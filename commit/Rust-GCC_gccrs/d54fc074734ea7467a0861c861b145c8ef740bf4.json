{"sha": "d54fc074734ea7467a0861c861b145c8ef740bf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU0ZmMwNzQ3MzRlYTc0NjdhMDg2MWM4NjFiMTQ1YzhlZjc0MGJmNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-02-10T06:02:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-02-10T06:02:38Z"}, "message": "compiler, libgo: Permit testing package when test imports it circularly.\n\nFrom-SVN: r195931", "tree": {"sha": "fe1dad02b57206be8eeb4f61819b2f677ea99ee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe1dad02b57206be8eeb4f61819b2f677ea99ee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d54fc074734ea7467a0861c861b145c8ef740bf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54fc074734ea7467a0861c861b145c8ef740bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54fc074734ea7467a0861c861b145c8ef740bf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54fc074734ea7467a0861c861b145c8ef740bf4/comments", "author": null, "committer": null, "parents": [{"sha": "8e29a61c2dc3d591cba39c4f4e8933a76493b22f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e29a61c2dc3d591cba39c4f4e8933a76493b22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e29a61c2dc3d591cba39c4f4e8933a76493b22f"}], "stats": {"total": 348, "additions": 84, "deletions": 264}, "files": [{"sha": "80ae8d464942e708edad0ba4ce6548277d5ae3a7", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -515,16 +515,23 @@ Gogo::add_import_init_fn(const std::string& package_name,\n        p != this->imported_init_fns_.end();\n        ++p)\n     {\n-      if (p->init_name() == init_name\n-\t  && (p->package_name() != package_name || p->priority() != prio))\n+      if (p->init_name() == init_name)\n \t{\n-\t  error(\"duplicate package initialization name %qs\",\n-\t\tGogo::message_name(init_name).c_str());\n-\t  inform(UNKNOWN_LOCATION, \"used by package %qs at priority %d\",\n-\t\t Gogo::message_name(p->package_name()).c_str(),\n-\t\t p->priority());\n-\t  inform(UNKNOWN_LOCATION, \" and by package %qs at priority %d\",\n-\t\t Gogo::message_name(package_name).c_str(), prio);\n+\t  // If a test of package P1, built as part of package P1,\n+\t  // imports package P2, and P2 imports P1 (perhaps\n+\t  // indirectly), then we will see the same import name with\n+\t  // different import priorities.  That is OK, so don't give\n+\t  // an error about it.\n+\t  if (p->package_name() != package_name)\n+\t    {\n+\t      error(\"duplicate package initialization name %qs\",\n+\t\t    Gogo::message_name(init_name).c_str());\n+\t      inform(UNKNOWN_LOCATION, \"used by package %qs at priority %d\",\n+\t\t     Gogo::message_name(p->package_name()).c_str(),\n+\t\t     p->priority());\n+\t      inform(UNKNOWN_LOCATION, \" and by package %qs at priority %d\",\n+\t\t     Gogo::message_name(package_name).c_str(), prio);\n+\t    }\n \t  return;\n \t}\n     }"}, {"sha": "640225b3291b138c6462107d5b62adf3024c98f1", "filename": "libgo/go/debug/macho/file_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,10 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package macho_test\n+package macho\n \n import (\n-\t. \"debug/macho\"\n \t\"reflect\"\n \t\"testing\"\n )"}, {"sha": "cfad8d36c7be1b0b44884df9f886b87b83bc8da3", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,11 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package binary_test\n+package binary\n \n import (\n \t\"bytes\"\n-\t. \"encoding/binary\"\n \t\"io\"\n \t\"math\"\n \t\"reflect\"\n@@ -239,7 +238,7 @@ func BenchmarkReadStruct(b *testing.B) {\n \tbsr := &byteSliceReader{}\n \tvar buf bytes.Buffer\n \tWrite(&buf, BigEndian, &s)\n-\tn := DataSize(reflect.ValueOf(s))\n+\tn := dataSize(reflect.ValueOf(s))\n \tb.SetBytes(int64(n))\n \tt := s\n \tb.ResetTimer()"}, {"sha": "9eae2a961fce87346e245dbf152b40ac3f71206d", "filename": "libgo/go/encoding/binary/export_test.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fexport_test.go?ref=8e29a61c2dc3d591cba39c4f4e8933a76493b22f", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package binary\n-\n-import \"reflect\"\n-\n-// Export for testing.\n-\n-func DataSize(v reflect.Value) int {\n-\treturn dataSize(v)\n-}\n-\n-var Overflow = overflow"}, {"sha": "9476bd5fb7a6d7ac69d905895a3fbaec81a02895", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,11 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package binary_test\n+package binary\n \n import (\n \t\"bytes\"\n-\t. \"encoding/binary\"\n \t\"io\"\n \t\"testing\"\n )\n@@ -135,8 +134,8 @@ func testOverflow(t *testing.T, buf []byte, n0 int, err0 error) {\n }\n \n func TestOverflow(t *testing.T) {\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, Overflow)\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, Overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, overflow)\n }\n \n func TestNonCanonicalZero(t *testing.T) {"}, {"sha": "799c1a7a11d5f1b98a71fd009ebe33551656c624", "filename": "libgo/go/image/image_test.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fimage%2Fimage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fimage%2Fimage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,15 +2,14 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package image_test\n+package image\n \n import (\n-\t. \"image\"\n \t\"image/color\"\n \t\"testing\"\n )\n \n-type timage interface {\n+type image interface {\n \tImage\n \tOpaque() bool\n \tSet(int, int, color.Color)\n@@ -24,7 +23,7 @@ func cmp(t *testing.T, cm color.Model, c0, c1 color.Color) bool {\n }\n \n func TestImage(t *testing.T) {\n-\ttestImage := []timage{\n+\ttestImage := []image{\n \t\tNewRGBA(Rect(0, 0, 10, 10)),\n \t\tNewRGBA64(Rect(0, 0, 10, 10)),\n \t\tNewNRGBA(Rect(0, 0, 10, 10)),\n@@ -52,11 +51,11 @@ func TestImage(t *testing.T) {\n \t\t\tt.Errorf(\"%T: at (6, 3), want a non-zero color, got %v\", m, m.At(6, 3))\n \t\t\tcontinue\n \t\t}\n-\t\tif !m.SubImage(Rect(6, 3, 7, 4)).(timage).Opaque() {\n+\t\tif !m.SubImage(Rect(6, 3, 7, 4)).(image).Opaque() {\n \t\t\tt.Errorf(\"%T: at (6, 3) was not opaque\", m)\n \t\t\tcontinue\n \t\t}\n-\t\tm = m.SubImage(Rect(3, 2, 9, 8)).(timage)\n+\t\tm = m.SubImage(Rect(3, 2, 9, 8)).(image)\n \t\tif !Rect(3, 2, 9, 8).Eq(m.Bounds()) {\n \t\t\tt.Errorf(\"%T: sub-image want bounds %v, got %v\", m, Rect(3, 2, 9, 8), m.Bounds())\n \t\t\tcontinue\n@@ -97,7 +96,7 @@ func Test16BitsPerColorChannel(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t}\n-\ttestImage := []timage{\n+\ttestImage := []image{\n \t\tNewRGBA64(Rect(0, 0, 10, 10)),\n \t\tNewNRGBA64(Rect(0, 0, 10, 10)),\n \t\tNewAlpha16(Rect(0, 0, 10, 10)),"}, {"sha": "a5f4482654feba6f29f246ef55d26b3eb0dc684b", "filename": "libgo/go/image/ycbcr_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fimage%2Fycbcr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,10 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package image_test\n+package image\n \n import (\n-\t. \"image\"\n \t\"image/color\"\n \t\"testing\"\n )"}, {"sha": "9c4d64f582b1d860518d04754165ec5ad5bda654", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,11 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package regexp_test\n+package regexp\n \n import (\n \t\"reflect\"\n-\t. \"regexp\"\n \t\"strings\"\n \t\"testing\"\n )"}, {"sha": "b0ad9d3400263efefbd2149f4be76842e76249d4", "filename": "libgo/go/regexp/example_test.go", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fregexp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fregexp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexample_test.go?ref=8e29a61c2dc3d591cba39c4f4e8933a76493b22f", "patch": "@@ -1,144 +0,0 @@\n-package regexp_test\n-\n-import (\n-\t\"fmt\"\n-\t\"regexp\"\n-)\n-\n-func Example() {\n-\t// Compile the expression once, usually at init time.\n-\t// Use raw strings to avoid having to quote the backslashes.\n-\tvar validID = regexp.MustCompile(`^[a-z]+\\[[0-9]+\\]$`)\n-\n-\tfmt.Println(validID.MatchString(\"adam[23]\"))\n-\tfmt.Println(validID.MatchString(\"eve[7]\"))\n-\tfmt.Println(validID.MatchString(\"Job[48]\"))\n-\tfmt.Println(validID.MatchString(\"snakey\"))\n-\t// Output:\n-\t// true\n-\t// true\n-\t// false\n-\t// false\n-}\n-\n-func ExampleMatchString() {\n-\tmatched, err := regexp.MatchString(\"foo.*\", \"seafood\")\n-\tfmt.Println(matched, err)\n-\tmatched, err = regexp.MatchString(\"bar.*\", \"seafood\")\n-\tfmt.Println(matched, err)\n-\tmatched, err = regexp.MatchString(\"a(b\", \"seafood\")\n-\tfmt.Println(matched, err)\n-\t// Output:\n-\t// true <nil>\n-\t// false <nil>\n-\t// false error parsing regexp: missing closing ): `a(b`\n-}\n-\n-func ExampleRegexp_FindString() {\n-\tre := regexp.MustCompile(\"fo.?\")\n-\tfmt.Printf(\"%q\\n\", re.FindString(\"seafood\"))\n-\tfmt.Printf(\"%q\\n\", re.FindString(\"meat\"))\n-\t// Output:\n-\t// \"foo\"\n-\t// \"\"\n-}\n-\n-func ExampleRegexp_FindStringIndex() {\n-\tre := regexp.MustCompile(\"ab?\")\n-\tfmt.Println(re.FindStringIndex(\"tablett\"))\n-\tfmt.Println(re.FindStringIndex(\"foo\") == nil)\n-\t// Output:\n-\t// [1 3]\n-\t// true\n-}\n-\n-func ExampleRegexp_FindStringSubmatch() {\n-\tre := regexp.MustCompile(\"a(x*)b(y|z)c\")\n-\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-axxxbyc-\"))\n-\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-abzc-\"))\n-\t// Output:\n-\t// [\"axxxbyc\" \"xxx\" \"y\"]\n-\t// [\"abzc\" \"\" \"z\"]\n-}\n-\n-func ExampleRegexp_FindAllString() {\n-\tre := regexp.MustCompile(\"a.\")\n-\tfmt.Println(re.FindAllString(\"paranormal\", -1))\n-\tfmt.Println(re.FindAllString(\"paranormal\", 2))\n-\tfmt.Println(re.FindAllString(\"graal\", -1))\n-\tfmt.Println(re.FindAllString(\"none\", -1))\n-\t// Output:\n-\t// [ar an al]\n-\t// [ar an]\n-\t// [aa]\n-\t// []\n-}\n-\n-func ExampleRegexp_FindAllStringSubmatch() {\n-\tre := regexp.MustCompile(\"a(x*)b\")\n-\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-\", -1))\n-\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-\", -1))\n-\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-axb-\", -1))\n-\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-ab-\", -1))\n-\t// Output:\n-\t// [[\"ab\" \"\"]]\n-\t// [[\"axxb\" \"xx\"]]\n-\t// [[\"ab\" \"\"] [\"axb\" \"x\"]]\n-\t// [[\"axxb\" \"xx\"] [\"ab\" \"\"]]\n-}\n-\n-func ExampleRegexp_FindAllStringSubmatchIndex() {\n-\tre := regexp.MustCompile(\"a(x*)b\")\n-\t// Indices:\n-\t//    01234567   012345678\n-\t//    -ab-axb-   -axxb-ab-\n-\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-\", -1))\n-\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-\", -1))\n-\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-axb-\", -1))\n-\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-ab-\", -1))\n-\tfmt.Println(re.FindAllStringSubmatchIndex(\"-foo-\", -1))\n-\t// Output:\n-\t// [[1 3 2 2]]\n-\t// [[1 5 2 4]]\n-\t// [[1 3 2 2] [4 7 5 6]]\n-\t// [[1 5 2 4] [6 8 7 7]]\n-\t// []\n-}\n-\n-func ExampleRegexp_ReplaceAllLiteralString() {\n-\tre := regexp.MustCompile(\"a(x*)b\")\n-\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"T\"))\n-\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"$1\"))\n-\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"${1}\"))\n-\t// Output:\n-\t// -T-T-\n-\t// -$1-$1-\n-\t// -${1}-${1}-\n-}\n-\n-func ExampleRegexp_ReplaceAllString() {\n-\tre := regexp.MustCompile(\"a(x*)b\")\n-\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"T\"))\n-\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1\"))\n-\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1W\"))\n-\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"${1}W\"))\n-\t// Output:\n-\t// -T-T-\n-\t// --xx-\n-\t// ---\n-\t// -W-xxW-\n-}\n-\n-func ExampleRegexp_SubexpNames() {\n-\tre := regexp.MustCompile(\"(?P<first>[a-zA-Z]+) (?P<last>[a-zA-Z]+)\")\n-\tfmt.Println(re.MatchString(\"Alan Turing\"))\n-\tfmt.Printf(\"%q\\n\", re.SubexpNames())\n-\treversed := fmt.Sprintf(\"${%s} ${%s}\", re.SubexpNames()[2], re.SubexpNames()[1])\n-\tfmt.Println(reversed)\n-\tfmt.Println(re.ReplaceAllString(\"Alan Turing\", reversed))\n-\t// Output:\n-\t// true\n-\t// [\"\" \"first\" \"last\"]\n-\t// ${last} ${first}\n-\t// Turing Alan\n-}"}, {"sha": "e5d52b40df3fc2b5c4c4dba56f0fca6c6be69417", "filename": "libgo/go/regexp/exec_test.go", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,11 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package regexp_test\n+package regexp\n \n import (\n-\t. \"regexp\"\n-\n \t\"bufio\"\n \t\"compress/bzip2\"\n \t\"fmt\"\n@@ -220,22 +218,22 @@ var run = []func(*Regexp, *Regexp, string) ([]int, string){\n }\n \n func runFull(re, refull *Regexp, text string) ([]int, string) {\n-\trefull.SetLongest(false)\n+\trefull.longest = false\n \treturn refull.FindStringSubmatchIndex(text), \"[full]\"\n }\n \n func runPartial(re, refull *Regexp, text string) ([]int, string) {\n-\tre.SetLongest(false)\n+\tre.longest = false\n \treturn re.FindStringSubmatchIndex(text), \"\"\n }\n \n func runFullLongest(re, refull *Regexp, text string) ([]int, string) {\n-\trefull.SetLongest(true)\n+\trefull.longest = true\n \treturn refull.FindStringSubmatchIndex(text), \"[full,longest]\"\n }\n \n func runPartialLongest(re, refull *Regexp, text string) ([]int, string) {\n-\tre.SetLongest(true)\n+\tre.longest = true\n \treturn re.FindStringSubmatchIndex(text), \"[longest]\"\n }\n \n@@ -247,22 +245,22 @@ var match = []func(*Regexp, *Regexp, string) (bool, string){\n }\n \n func matchFull(re, refull *Regexp, text string) (bool, string) {\n-\trefull.SetLongest(false)\n+\trefull.longest = false\n \treturn refull.MatchString(text), \"[full]\"\n }\n \n func matchPartial(re, refull *Regexp, text string) (bool, string) {\n-\tre.SetLongest(false)\n+\tre.longest = false\n \treturn re.MatchString(text), \"\"\n }\n \n func matchFullLongest(re, refull *Regexp, text string) (bool, string) {\n-\trefull.SetLongest(true)\n+\trefull.longest = true\n \treturn refull.MatchString(text), \"[full,longest]\"\n }\n \n func matchPartialLongest(re, refull *Regexp, text string) (bool, string) {\n-\tre.SetLongest(true)\n+\tre.longest = true\n \treturn re.MatchString(text), \"[longest]\"\n }\n \n@@ -542,7 +540,7 @@ Reading:\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tre, err := CompileInternal(pattern, syn, true)\n+\t\t\tre, err := compile(pattern, syn, true)\n \t\t\tif err != nil {\n \t\t\t\tif shouldCompile {\n \t\t\t\t\tt.Errorf(\"%s:%d: %#q did not compile\", file, lineno, pattern)"}, {"sha": "25080ad19cebe08680bf0d1fee8e144d08b5c8c2", "filename": "libgo/go/regexp/export_test.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fregexp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e29a61c2dc3d591cba39c4f4e8933a76493b22f/libgo%2Fgo%2Fregexp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexport_test.go?ref=8e29a61c2dc3d591cba39c4f4e8933a76493b22f", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package regexp\n-\n-import \"regexp/syntax\"\n-\n-func (re *Regexp) SetLongest(b bool) {\n-\tre.longest = b\n-}\n-\n-func CompileInternal(expr string, mode syntax.Flags, longest bool) (*Regexp, error) {\n-\treturn compile(expr, mode, longest)\n-}"}, {"sha": "e07eb7d5c05059c3ba0ee74477a3179ebccdf416", "filename": "libgo/go/regexp/find_test.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Ffind_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Ffind_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Ffind_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,11 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package regexp_test\n+package regexp\n \n import (\n-\t. \"regexp\"\n-\n \t\"fmt\"\n \t\"strings\"\n \t\"testing\""}, {"sha": "30e0e8b7fe42dac4d4d54201ac2f068f0e703e9a", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -191,7 +191,7 @@ func (p *parser) newLiteral(r rune, flags Flags) *Regexp {\n \n // minFoldRune returns the minimum rune fold-equivalent to r.\n func minFoldRune(r rune) rune {\n-\tif r < MinFold || r > MaxFold {\n+\tif r < minFold || r > maxFold {\n \t\treturn r\n \t}\n \tmin := r\n@@ -1553,7 +1553,7 @@ func (p *parser) parseClass(s string) (rest string, err error) {\n \t\t\t}\n \t\t}\n \t\tif p.flags&FoldCase == 0 {\n-\t\t\tclass = AppendRange(class, lo, hi)\n+\t\t\tclass = appendRange(class, lo, hi)\n \t\t} else {\n \t\t\tclass = appendFoldedRange(class, lo, hi)\n \t\t}\n@@ -1608,11 +1608,11 @@ func appendLiteral(r []rune, x rune, flags Flags) []rune {\n \tif flags&FoldCase != 0 {\n \t\treturn appendFoldedRange(r, x, x)\n \t}\n-\treturn AppendRange(r, x, x)\n+\treturn appendRange(r, x, x)\n }\n \n // appendRange returns the result of appending the range lo-hi to the class r.\n-func AppendRange(r []rune, lo, hi rune) []rune {\n+func appendRange(r []rune, lo, hi rune) []rune {\n \t// Expand last range or next to last range if it overlaps or abuts.\n \t// Checking two ranges helps when appending case-folded\n \t// alphabets, so that one range can be expanding A-Z and the\n@@ -1639,39 +1639,39 @@ func AppendRange(r []rune, lo, hi rune) []rune {\n const (\n \t// minimum and maximum runes involved in folding.\n \t// checked during test.\n-\tMinFold = 0x0041\n-\tMaxFold = 0x1044f\n+\tminFold = 0x0041\n+\tmaxFold = 0x1044f\n )\n \n // appendFoldedRange returns the result of appending the range lo-hi\n // and its case folding-equivalent runes to the class r.\n func appendFoldedRange(r []rune, lo, hi rune) []rune {\n \t// Optimizations.\n-\tif lo <= MinFold && hi >= MaxFold {\n+\tif lo <= minFold && hi >= maxFold {\n \t\t// Range is full: folding can't add more.\n-\t\treturn AppendRange(r, lo, hi)\n+\t\treturn appendRange(r, lo, hi)\n \t}\n-\tif hi < MinFold || lo > MaxFold {\n+\tif hi < minFold || lo > maxFold {\n \t\t// Range is outside folding possibilities.\n-\t\treturn AppendRange(r, lo, hi)\n+\t\treturn appendRange(r, lo, hi)\n \t}\n-\tif lo < MinFold {\n-\t\t// [lo, MinFold-1] needs no folding.\n-\t\tr = AppendRange(r, lo, MinFold-1)\n-\t\tlo = MinFold\n+\tif lo < minFold {\n+\t\t// [lo, minFold-1] needs no folding.\n+\t\tr = appendRange(r, lo, minFold-1)\n+\t\tlo = minFold\n \t}\n-\tif hi > MaxFold {\n-\t\t// [MaxFold+1, hi] needs no folding.\n-\t\tr = AppendRange(r, MaxFold+1, hi)\n-\t\thi = MaxFold\n+\tif hi > maxFold {\n+\t\t// [maxFold+1, hi] needs no folding.\n+\t\tr = appendRange(r, maxFold+1, hi)\n+\t\thi = maxFold\n \t}\n \n-\t// Brute force.  Depend on AppendRange to coalesce ranges on the fly.\n+\t// Brute force.  Depend on appendRange to coalesce ranges on the fly.\n \tfor c := lo; c <= hi; c++ {\n-\t\tr = AppendRange(r, c, c)\n+\t\tr = appendRange(r, c, c)\n \t\tf := unicode.SimpleFold(c)\n \t\tfor f != c {\n-\t\t\tr = AppendRange(r, f, f)\n+\t\t\tr = appendRange(r, f, f)\n \t\t\tf = unicode.SimpleFold(f)\n \t\t}\n \t}\n@@ -1682,7 +1682,7 @@ func appendFoldedRange(r []rune, lo, hi rune) []rune {\n // It assume x is clean.\n func appendClass(r []rune, x []rune) []rune {\n \tfor i := 0; i < len(x); i += 2 {\n-\t\tr = AppendRange(r, x[i], x[i+1])\n+\t\tr = appendRange(r, x[i], x[i+1])\n \t}\n \treturn r\n }\n@@ -1702,12 +1702,12 @@ func appendNegatedClass(r []rune, x []rune) []rune {\n \tfor i := 0; i < len(x); i += 2 {\n \t\tlo, hi := x[i], x[i+1]\n \t\tif nextLo <= lo-1 {\n-\t\t\tr = AppendRange(r, nextLo, lo-1)\n+\t\t\tr = appendRange(r, nextLo, lo-1)\n \t\t}\n \t\tnextLo = hi + 1\n \t}\n \tif nextLo <= unicode.MaxRune {\n-\t\tr = AppendRange(r, nextLo, unicode.MaxRune)\n+\t\tr = appendRange(r, nextLo, unicode.MaxRune)\n \t}\n \treturn r\n }\n@@ -1717,21 +1717,21 @@ func appendTable(r []rune, x *unicode.RangeTable) []rune {\n \tfor _, xr := range x.R16 {\n \t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n-\t\t\tr = AppendRange(r, lo, hi)\n+\t\t\tr = appendRange(r, lo, hi)\n \t\t\tcontinue\n \t\t}\n \t\tfor c := lo; c <= hi; c += stride {\n-\t\t\tr = AppendRange(r, c, c)\n+\t\t\tr = appendRange(r, c, c)\n \t\t}\n \t}\n \tfor _, xr := range x.R32 {\n \t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n-\t\t\tr = AppendRange(r, lo, hi)\n+\t\t\tr = appendRange(r, lo, hi)\n \t\t\tcontinue\n \t\t}\n \t\tfor c := lo; c <= hi; c += stride {\n-\t\t\tr = AppendRange(r, c, c)\n+\t\t\tr = appendRange(r, c, c)\n \t\t}\n \t}\n \treturn r\n@@ -1744,14 +1744,14 @@ func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune {\n \t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tif nextLo <= lo-1 {\n-\t\t\t\tr = AppendRange(r, nextLo, lo-1)\n+\t\t\t\tr = appendRange(r, nextLo, lo-1)\n \t\t\t}\n \t\t\tnextLo = hi + 1\n \t\t\tcontinue\n \t\t}\n \t\tfor c := lo; c <= hi; c += stride {\n \t\t\tif nextLo <= c-1 {\n-\t\t\t\tr = AppendRange(r, nextLo, c-1)\n+\t\t\t\tr = appendRange(r, nextLo, c-1)\n \t\t\t}\n \t\t\tnextLo = c + 1\n \t\t}\n@@ -1760,20 +1760,20 @@ func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune {\n \t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tif nextLo <= lo-1 {\n-\t\t\t\tr = AppendRange(r, nextLo, lo-1)\n+\t\t\t\tr = appendRange(r, nextLo, lo-1)\n \t\t\t}\n \t\t\tnextLo = hi + 1\n \t\t\tcontinue\n \t\t}\n \t\tfor c := lo; c <= hi; c += stride {\n \t\t\tif nextLo <= c-1 {\n-\t\t\t\tr = AppendRange(r, nextLo, c-1)\n+\t\t\t\tr = appendRange(r, nextLo, c-1)\n \t\t\t}\n \t\t\tnextLo = c + 1\n \t\t}\n \t}\n \tif nextLo <= unicode.MaxRune {\n-\t\tr = AppendRange(r, nextLo, unicode.MaxRune)\n+\t\tr = appendRange(r, nextLo, unicode.MaxRune)\n \t}\n \treturn r\n }"}, {"sha": "81fd9dc0136a3d73869407da964d7f2991fd906c", "filename": "libgo/go/regexp/syntax/parse_test.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,12 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package syntax_test\n+package syntax\n \n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t. \"regexp/syntax\"\n \t\"testing\"\n \t\"unicode\"\n )\n@@ -413,13 +412,13 @@ func TestFoldConstants(t *testing.T) {\n \t\tif unicode.SimpleFold(i) == i {\n \t\t\tcontinue\n \t\t}\n-\t\tif last == -1 && MinFold != i {\n-\t\t\tt.Errorf(\"MinFold=%#U should be %#U\", MinFold, i)\n+\t\tif last == -1 && minFold != i {\n+\t\t\tt.Errorf(\"minFold=%#U should be %#U\", minFold, i)\n \t\t}\n \t\tlast = i\n \t}\n-\tif MaxFold != last {\n-\t\tt.Errorf(\"MaxFold=%#U should be %#U\", MaxFold, last)\n+\tif maxFold != last {\n+\t\tt.Errorf(\"maxFold=%#U should be %#U\", maxFold, last)\n \t}\n }\n \n@@ -430,11 +429,11 @@ func TestAppendRangeCollapse(t *testing.T) {\n \t// Note that we are not calling cleanClass.\n \tvar r []rune\n \tfor i := rune('A'); i <= 'Z'; i++ {\n-\t\tr = AppendRange(r, i, i)\n-\t\tr = AppendRange(r, i+'a'-'A', i+'a'-'A')\n+\t\tr = appendRange(r, i, i)\n+\t\tr = appendRange(r, i+'a'-'A', i+'a'-'A')\n \t}\n \tif string(r) != \"AZaz\" {\n-\t\tt.Errorf(\"AppendRange interlaced A-Z a-z = %s, want AZaz\", string(r))\n+\t\tt.Errorf(\"appendRange interlaced A-Z a-z = %s, want AZaz\", string(r))\n \t}\n }\n "}, {"sha": "663d5a8d7788bf5b961adf48b1a461acd62f8843", "filename": "libgo/go/regexp/syntax/prog_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,10 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package syntax_test\n+package syntax\n \n import (\n-\t. \"regexp/syntax\"\n \t\"testing\"\n )\n "}, {"sha": "879eff5be7ee3d9aa25489fb10180a708b633125", "filename": "libgo/go/regexp/syntax/simplify_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fsimplify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54fc074734ea7467a0861c861b145c8ef740bf4/libgo%2Fgo%2Fregexp%2Fsyntax%2Fsimplify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fsimplify_test.go?ref=d54fc074734ea7467a0861c861b145c8ef740bf4", "patch": "@@ -2,9 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package syntax_test\n+package syntax\n \n-import . \"regexp/syntax\"\n import \"testing\"\n \n var simplifyTests = []struct {"}]}