{"sha": "cb2afeb31ed8d214b711f60ab7e24c190933916a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyYWZlYjMxZWQ4ZDIxNGI3MTFmNjBhYjdlMjRjMTkwOTMzOTE2YQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-10-16T19:54:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-16T19:54:38Z"}, "message": "Fix consistency problems with reg_equiv_{mem,address};\n\n        Improve reload inheritance;\n        * reload.c (reload_out_reg): New variable.\n        (loc_mentioned_in_p, remove_address_replacements): New functions.\n        (remove_replacements): Deleted.\n        (push_reload): Set reload_out_reg[i].\n        When merging, also set reload_{in,out}_reg[i], and remove\n        duplicate address reloads.\n        (combine_reloads): Copy reload_out_reg[i].\n        (find_reloads): Do make_memloc substitution also when\n        reg_equiv_memory_loc[regno] and num_not_at_initial_offset\n        are both nonzero.\n        Include *recog_operand_loc in commutativity operand changes.\n        Generate optional output reloads.\n        Delete reference to n_memlocs.  Don't set *recog_operand_loc before\n        processing operands.  Call make_memloc in reg_equiv_address code.\n        Set *recog_operand_loc only after processing operands, and only\n        if replace is true.  Return a value.\n        When changing address reload types for operands that didn't get\n        reloaded, use RELOAD_FOR_OPADDR_ADDRESS for\n        RELOAD_FOR_INPADDR_ADDRESS / RELOAD_FOR_OUTADDR_ADDRESS reloads.\n        Don't emit USEs for pseudo SUBREGs when not replacing.\n        (find_reloads_address): Do make_memloc substitution also when\n        reg_equiv_memory_loc[regno] and num_not_at_initial_offset\n        are both nonzero.\n        (find_reloads_toplev): Likewise.\n        Call make_memloc in reg_equiv_address code.\n        (debug_reload_to_stream): Add code to output reload_out_reg.\n        (make_memloc): Delete local variable i, ifdefed out code, and\n        references to memlocs and n_memlocs.\n        (memlocs, n_memlocs): Delete.\n        (push_secondary_reload): Clear reload_out_reg.\n        (find_reloads_address_1): Provide memrefloc argument to all calls\n        to find_reloads_address.\n        In AUTO_INC code, handle non-directly addressable equivalences properly.\n        * reload.h (reload_out_reg, num_not_at_initial_offset): Declare.\n        (find_reloads): Add return type.\n        (remove_address_replacements, deallocate_reload_reg): Declare.\n        * reload1.c (num_not_at_initial_offset): No longer static.\n        (delete_address_reloads, delete_address_reloads_1): Likewise.\n        (deallocate_reload_reg): New function.\n        (spill_reg_stored_to): New array.\n        (eliminate_regs): Don't substitute from reg_equiv_memory_loc.\n        (eliminate_regs_in_insn): Move assignments of previous_offset and\n        max_offset fields, and recalculation of num_not_at_initial_offset\n        into new static function:\n        (update_eliminable_offsets) .\n        (reload_as_needed): Call update_eliminable_offsetss after calling\n        find_reloads.\n        Call forget_old_reloads_1 with contents of reloaded auto_inc\n        expressions if the actual addressing can't be changed to match the\n        auto_inc.\n        (choose_reload_regs): For inheritance, replace\n        reload_reg_free_before_p test with reload_reg_ions.\n        (emit_reload_insns): If reload_in is a MEM, set OLD to\n        reload_in_reg[j].\n        Don't reload directly from oldequiv; if it's a pseudo with a\n        stack slot, use reload_in[j].\n        Check that reload_in_reg[j] is a MEM before replacing reload_in\n        from reg_reloaded_contents.\n        Include non-spill registers in reload inheritance processing.\n        Also try to use reload_out_reg to set spill_reg_store /\n        reg_last_reload_reg.\n        In code to set new_spill_reg_store, use single_set to find out if\n        there is a single set.\n        Add code that allows to delete optional output reloads.\n        Add code to allow deletion of output reloads that use no spill reg.\n        At the end, set reload_override_in to oldequiv.\n        Also call delete_output_reload if reload_out_reg is equal to old\n        in oldequiv code.\n        Add code to call delete_output_reload for stores with no matching load.\n        Set / use spill_reg_stored_to.\n        Handle case where secondary output reload uses a temporary, but\n        actual store isn't found.\n        When looking for a store of a value not loaded in order to call\n        delete_output_reload, count_occurences should return 0 for no\n        loads; but discount inherited input reloadill_reg_stored_to.\n        Do checks for extra uses of REG.  Changed all\n        callers.\n        Use delete_address_reloads.\n        (reload): Take return value of find_reloads into account.\n        If a no-op set needs more than one reload, delete it.\n        (reload_reg_free_before_p): RELOAD_FOR_INPUT\n        can ignore RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS\n        for the same operand.\n        (clear_reload_reg_in_use): Check for other reloads that keep a\n        register in use.\n        (reload_reg_free_for_value_p): handle RELOAD_FOR_OPERAND_ADDRESS /\n        RELOAD_FOR_OPADDR_ADDR.\n        Take into account when an address address reload is only needed\n        for the address reload we are considering.\n        (count_occurrences): Use rtx_equal_p for MEMs.\n        (inc_for_reload): Return instruction that stores into RELOADREG.\n        New argument two, IN, and rtx.  Changed all callers.\n        (calculate_needs_all_insns, reload_as_needed):\n        Don't clear after_call for a CLOBBER.\n        Keep track of how many hard registers need to be copied from\n        after_call, and don't clear after_call before we have seen\n        that much copies, or we see a different instruction.\n\nFrom-SVN: r23143", "tree": {"sha": "cf1f8fb6fb17ad64ddc6a0a663fac8dcb1c7dc8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1f8fb6fb17ad64ddc6a0a663fac8dcb1c7dc8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb2afeb31ed8d214b711f60ab7e24c190933916a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2afeb31ed8d214b711f60ab7e24c190933916a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2afeb31ed8d214b711f60ab7e24c190933916a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2afeb31ed8d214b711f60ab7e24c190933916a/comments", "author": null, "committer": null, "parents": [{"sha": "c583dd46ad05221ee43832d6845ebeb686492579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c583dd46ad05221ee43832d6845ebeb686492579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c583dd46ad05221ee43832d6845ebeb686492579"}], "stats": {"total": 1862, "additions": 1375, "deletions": 487}, "files": [{"sha": "04da772f4aa66b5b7c7048684056db33f96bcc5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb2afeb31ed8d214b711f60ab7e24c190933916a", "patch": "@@ -1,3 +1,114 @@\n+Fri Oct 16 20:40:50 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\tFix consistency problems with reg_equiv_{mem,address};\n+\tImprove reload inheritance;\n+\n+\t* reload.c (reload_out_reg): New variable.\n+\t(loc_mentioned_in_p, remove_address_replacements): New functions.\n+\t(remove_replacements): Deleted.\n+\t(push_reload): Set reload_out_reg[i].\n+\tWhen merging, also set reload_{in,out}_reg[i], and remove\n+\tduplicate address reloads.\n+\t(combine_reloads): Copy reload_out_reg[i].\n+\t(find_reloads): Do make_memloc substitution also when\n+\treg_equiv_memory_loc[regno] and num_not_at_initial_offset\n+\tare both nonzero.\n+\tInclude *recog_operand_loc in commutativity operand changes.\n+\tGenerate optional output reloads.\n+\tDelete reference to n_memlocs.  Don't set *recog_operand_loc before\n+\tprocessing operands.  Call make_memloc in reg_equiv_address code.\n+\tSet *recog_operand_loc only after processing operands, and only\n+\tif replace is true.  Return a value.\n+\tWhen changing address reload types for operands that didn't get\n+\treloaded, use RELOAD_FOR_OPADDR_ADDRESS for\n+\tRELOAD_FOR_INPADDR_ADDRESS / RELOAD_FOR_OUTADDR_ADDRESS reloads.\n+\tDon't emit USEs for pseudo SUBREGs when not replacing.\n+\t(find_reloads_address): Do make_memloc substitution also when\n+\treg_equiv_memory_loc[regno] and num_not_at_initial_offset\n+\tare both nonzero.\n+\t(find_reloads_toplev): Likewise.\n+\tCall make_memloc in reg_equiv_address code.\n+\t(debug_reload_to_stream): Add code to output reload_out_reg.\n+\t(make_memloc): Delete local variable i, ifdefed out code, and\n+\treferences to memlocs and n_memlocs.\n+\t(memlocs, n_memlocs): Delete.\n+\t(push_secondary_reload): Clear reload_out_reg.\n+\t(find_reloads_address_1): Provide memrefloc argument to all calls\n+\tto find_reloads_address.\n+\tIn AUTO_INC code, handle non-directly addressable equivalences properly.\n+\t* reload.h (reload_out_reg, num_not_at_initial_offset): Declare.\n+\t(find_reloads): Add return type.\n+\t(remove_address_replacements, deallocate_reload_reg): Declare.\n+\t* reload1.c (num_not_at_initial_offset): No longer static.\n+\t(delete_address_reloads, delete_address_reloads_1): Likewise.\n+\t(deallocate_reload_reg): New function.\n+\t(spill_reg_stored_to): New array.\n+\t(eliminate_regs): Don't substitute from reg_equiv_memory_loc.\n+\t(eliminate_regs_in_insn): Move assignments of previous_offset and\n+\tmax_offset fields, and recalculation of num_not_at_initial_offset\n+\tinto new static function:\n+\t(update_eliminable_offsets) .\n+\t(reload_as_needed): Call update_eliminable_offsetss after calling\n+\tfind_reloads.\n+\tCall forget_old_reloads_1 with contents of reloaded auto_inc\n+\texpressions if the actual addressing can't be changed to match the\n+\tauto_inc.\n+\t(choose_reload_regs): For inheritance, replace\n+\treload_reg_free_before_p test with reload_reg_used_at_all test, and\n+\tremove stand-alone reload_reg_used_at_all test.\n+\tUse reload_out_reg to determine which reload regs have output reloads.\n+\tTreat reload_override_in more similar to inherited reloads.\n+\tHandle (subreg (reg... for inheritance.\n+\tFor flag_expensive_optimizations, add an extra pass to remove\n+\tunnecessary reloads from known working inheritance.\n+\tDelete obsolete code for pseudos replaced with MEMs.\n+\tHandle inheritance from auto_inc expressions.\n+\t(emit_reload_insns): If reload_in is a MEM, set OLD to \n+\treload_in_reg[j].\n+\tDon't reload directly from oldequiv; if it's a pseudo with a\n+\tstack slot, use reload_in[j].\n+\tCheck that reload_in_reg[j] is a MEM before replacing reload_in\n+\tfrom reg_reloaded_contents.\n+\tInclude non-spill registers in reload inheritance processing.\n+\tAlso try to use reload_out_reg to set spill_reg_store /\n+\treg_last_reload_reg.\n+\tIn code to set new_spill_reg_store, use single_set to find out if\n+\tthere is a single set.\n+\tAdd code that allows to delete optional output reloads.\n+\tAdd code to allow deletion of output reloads that use no spill reg.\n+\tAt the end, set reload_override_in to oldequiv.\n+\tAlso call delete_output_reload if reload_out_reg is equal to old\n+\tin oldequiv code.\n+\tAdd code to call delete_output_reload for stores with no matching load.\n+\tSet / use spill_reg_stored_to.\n+        Handle case where secondary output reload uses a temporary, but\n+\tactual store isn't found.\n+\tWhen looking for a store of a value not loaded in order to call\n+\tdelete_output_reload, count_occurences should return 0 for no\n+\tloads; but discount inherited input reloadill_reg_stored_to.\n+\tDo checks for extra uses of REG.  Changed all\n+\tcallers.\n+\tUse delete_address_reloads.\n+\t(reload): Take return value of find_reloads into account.\n+\tIf a no-op set needs more than one reload, delete it.\n+\t(reload_reg_free_before_p): RELOAD_FOR_INPUT\n+\tcan ignore RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS\n+\tfor the same operand.\n+\t(clear_reload_reg_in_use): Check for other reloads that keep a\n+\tregister in use.\n+\t(reload_reg_free_for_value_p): handle RELOAD_FOR_OPERAND_ADDRESS /\n+\tRELOAD_FOR_OPADDR_ADDR.\n+\tTake into account when an address address reload is only needed\n+\tfor the address reload we are considering.\n+\t(count_occurrences): Use rtx_equal_p for MEMs.\n+\t(inc_for_reload): Return instruction that stores into RELOADREG.\n+\tNew argument two, IN, and rtx.  Changed all callers.\n+\t(calculate_needs_all_insns, reload_as_needed):\n+\tDon't clear after_call for a CLOBBER.\n+\tKeep track of how many hard registers need to be copied from\n+\tafter_call, and don't clear after_call before we have seen\n+\tthat much copies, or we see a different instruction.\n+\n Fri Oct 16 10:58:23 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (find_basic_blocks_1): Do not delete unreachable blocks"}, {"sha": "6f3ba43b26ac45797207b4f4490fee25c35415dd", "filename": "gcc/reload.c", "status": "modified", "additions": 310, "deletions": 166, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=cb2afeb31ed8d214b711f60ab7e24c190933916a", "patch": "@@ -181,6 +181,7 @@ char reload_optional[MAX_RELOADS];\n char reload_nongroup[MAX_RELOADS];\n int reload_inc[MAX_RELOADS];\n rtx reload_in_reg[MAX_RELOADS];\n+rtx reload_out_reg[MAX_RELOADS];\n char reload_nocombine[MAX_RELOADS];\n int reload_opnum[MAX_RELOADS];\n enum reload_type reload_when_needed[MAX_RELOADS];\n@@ -232,11 +233,6 @@ struct decomposition\n   HOST_WIDE_INT end;\t/* Ending offset or register number.  */\n };\n \n-/* MEM-rtx's created for pseudo-regs in stack slots not directly addressable;\n-   (see reg_equiv_address).  */\n-static rtx memlocs[MAX_RECOG_OPERANDS * ((MAX_REGS_PER_ADDRESS * 2) + 1)];\n-static int n_memlocs;\n-\n #ifdef SECONDARY_MEMORY_NEEDED\n \n /* Save MEMs needed to copy from one class of registers to another.  One MEM\n@@ -329,18 +325,19 @@ static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n static struct decomposition decompose PROTO((rtx));\n static int immune_p\t\tPROTO((rtx, rtx, struct decomposition));\n static int alternative_allows_memconst PROTO((char *, int));\n-static rtx find_reloads_toplev\tPROTO((rtx, int, enum reload_type, int, int));\n+static rtx find_reloads_toplev\tPROTO((rtx, int, enum reload_type, int, int, rtx));\n static rtx make_memloc\t\tPROTO((rtx, int));\n static int find_reloads_address\tPROTO((enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t       int, enum reload_type, int, rtx));\n-static rtx subst_reg_equivs\tPROTO((rtx));\n+static rtx subst_reg_equivs\tPROTO((rtx, rtx));\n static rtx subst_indexed_address PROTO((rtx));\n static int find_reloads_address_1 PROTO((enum machine_mode, rtx, int, rtx *,\n \t\t\t\t\t int, enum reload_type,int, rtx));\n static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n \t\t\t\t\t     enum machine_mode, int,\n \t\t\t\t\t     enum reload_type, int));\n static int find_inc_amount\tPROTO((rtx, rtx));\n+static int loc_mentioned_in_p\tPROTO((rtx *, rtx));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n \n@@ -536,6 +533,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t  /* Maybe we could combine these, but it seems too tricky.  */\n \t  reload_nocombine[t_reload] = 1;\n \t  reload_in_reg[t_reload] = 0;\n+\t  reload_out_reg[t_reload] = 0;\n \t  reload_opnum[t_reload] = opnum;\n \t  reload_when_needed[t_reload] = secondary_type;\n \t  reload_secondary_in_reload[t_reload] = -1;\n@@ -605,6 +603,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n       /* Maybe we could combine these, but it seems too tricky.  */\n       reload_nocombine[s_reload] = 1;\n       reload_in_reg[s_reload] = 0;\n+      reload_out_reg[s_reload] = 0;\n       reload_opnum[s_reload] = opnum;\n       reload_when_needed[s_reload] = secondary_type;\n       reload_secondary_in_reload[s_reload] = in_p ? t_reload : -1;\n@@ -1170,7 +1169,11 @@ push_reload (in, out, inloc, outloc, class,\n \t}\n     }\n \n-  if (class == NO_REGS)\n+  /* Optional output reloads are always OK even if we have no register class,\n+     since the function of these reloads is only to have spill_reg_store etc.\n+     set, so that the storing insn can be deleted later.  */\n+  if (class == NO_REGS\n+      && (optional == 0 || type != RELOAD_FOR_OUTPUT))\n     abort ();\n \n   /* We can use an existing reload if the class is right\n@@ -1281,6 +1284,7 @@ push_reload (in, out, inloc, outloc, class,\n       reload_inc[i] = 0;\n       reload_nocombine[i] = 0;\n       reload_in_reg[i] = inloc ? *inloc : 0;\n+      reload_out_reg[i] = outloc ? *outloc : 0;\n       reload_opnum[i] = opnum;\n       reload_when_needed[i] = type;\n       reload_secondary_in_reload[i] = secondary_in_reload;\n@@ -1315,9 +1319,32 @@ push_reload (in, out, inloc, outloc, class,\n \t  && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (reload_outmode[i]))\n \treload_outmode[i] = outmode;\n       if (in != 0)\n-\treload_in[i] = in;\n+\t{\n+\t  /* If we merge reloads for two distinct rtl expressions that\n+\t     are identical in content, there might be duplicate address\n+\t     reloads.  Remove the extra set now, so that if we later find\n+\t     that we can inherit this reload, we can get rid of the\n+\t     address reloads altogether.  */\n+\t  if (reload_in[i] != in && rtx_equal_p (in, reload_in[i]))\n+\t    {\n+\t      /* We must keep the address reload with the lower operand\n+\t\t number alive.  */\n+\t      if (opnum > reload_opnum[i])\n+\t\t{\n+\t\t  remove_address_replacements (in);\n+\t\t  in = reload_in[i];\n+\t\t}\n+\t      else\n+\t\tremove_address_replacements (reload_in[i]);\n+\t    }\n+\t  reload_in[i] = in;\n+\t  reload_in_reg[i] = inloc ? *inloc : 0;\n+\t}\n       if (out != 0)\n-\treload_out[i] = out;\n+\t{\n+\t  reload_out[i] = out;\n+\t  reload_out_reg[i] = outloc ? *outloc : 0;\n+\t}\n       if (reg_class_subset_p (class, reload_reg_class[i]))\n \treload_reg_class[i] = class;\n       reload_optional[i] &= optional;\n@@ -1506,19 +1533,67 @@ transfer_replacements (to, from)\n       replacements[i].what = to;\n }\n \f\n-/* Remove all replacements in reload FROM.  */\n-void\n-remove_replacements (from)\n-     int from;\n+/* IN_RTX is the value loaded by a reload that we now decided to inherit,\n+   or a subpart of it.  If we have any replacements registered for IN_RTX,\n+   cancel the reloads that were supposed to load them.\n+   Return non-zero if we canceled any reloads.  */\n+int\n+remove_address_replacements (in_rtx)\n+     rtx in_rtx;\n {\n   int i, j;\n+  char reload_flags[MAX_RELOADS];\n+  int something_changed = 0;\n \n+  bzero (reload_flags, sizeof reload_flags);\n   for (i = 0, j = 0; i < n_replacements; i++)\n     {\n-      if (replacements[i].what == from)\n-        continue;\n-      replacements[j++] = replacements[i];\n+      if (loc_mentioned_in_p (replacements[i].where, in_rtx))\n+\treload_flags[replacements[i].what] |= 1;\n+      else\n+\t{\n+\t  replacements[j++] = replacements[i];\n+\t  reload_flags[replacements[i].what] |= 2;\n+\t}\n+    }\n+  /* Note that the following store must be done before the recursive calls.  */\n+  n_replacements = j;\n+\n+  for (i = n_reloads - 1; i >= 0; i--)\n+    {\n+      if (reload_flags[i] == 1)\n+\t{\n+\t  deallocate_reload_reg (i);\n+\t  remove_address_replacements (reload_in[i]);\n+\t  reload_in[i] = 0;\n+\t  something_changed = 1;\n+\t}\n+    }\n+  return something_changed;\n+}\n+\n+/* Return non-zero if IN contains a piece of rtl that has the address LOC */\n+static int\n+loc_mentioned_in_p (loc, in)\n+     rtx *loc, in;\n+{\n+  enum rtx_code code = GET_CODE (in);\n+  char *fmt = GET_RTX_FORMAT (code);\n+  int i, j;\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (loc == &XEXP (in, i))\n+\treturn 1;\n+      if (fmt[i] == 'e')\n+\tif (loc_mentioned_in_p (loc, XEXP (in, i)))\n+\t  return 1;\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (in, i) - 1; i >= 0; i--)\n+\t  if (loc_mentioned_in_p (loc, XVECEXP (in, i, j)))\n+\t    return 1;\n     }\n+  return 0;\n }\n \f\n /* If there is only one output reload, and it is not for an earlyclobber\n@@ -1617,6 +1692,7 @@ combine_reloads ()\n \n \t/* We have found a reload to combine with!  */\n \treload_out[i] = reload_out[output_reload];\n+\treload_out_reg[i] = reload_out_reg[output_reload];\n \treload_outmode[i] = reload_outmode[output_reload];\n \t/* Mark the old output reload as inoperative.  */\n \treload_out[output_reload] = 0;\n@@ -2299,9 +2375,12 @@ safe_from_earlyclobber (op, clobber)\n    RELOAD_REG_P if nonzero is a vector indexed by hard reg number\n    which is nonnegative if the reg has been commandeered for reloading into.\n    It is copied into STATIC_RELOAD_REG_P and referenced from there\n-   by various subroutines.  */\n+   by various subroutines.\n \n-void\n+   Return TRUE if some operands need to be changed, because of swapping\n+   commutative operands, reg_equiv_address substitution, or whatever.  */\n+\n+int\n find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      rtx insn;\n      int replace, ind_levels;\n@@ -2357,6 +2436,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   rtx set = single_set (insn);\n   int goal_earlyclobber, this_earlyclobber;\n   enum machine_mode operand_mode[MAX_RECOG_OPERANDS];\n+  int retval = 0;\n   /* Cache the last regno for the last pseudo we did an output reload\n      for in case the next insn uses it.  */\n   static int last_output_reload_regno = -1;\n@@ -2365,7 +2445,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   this_insn_is_asm = 0;\t\t/* Tentative.  */\n   n_reloads = 0;\n   n_replacements = 0;\n-  n_memlocs = 0;\n   n_earlyclobbers = 0;\n   replace_reloads = replace;\n   hard_regs_live_known = live_known;\n@@ -2406,7 +2485,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n     case ASM_INPUT:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n-      return;\n+      return 0;\n \n     case SET:\n       /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it\n@@ -2418,7 +2497,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  && REGNO (SET_SRC (body)) < FIRST_PSEUDO_REGISTER\n \t  && REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n \t\t\t\t REGNO_REG_CLASS (REGNO (SET_DEST (body)))) == 2)\n-\treturn;\n+\treturn 0;\n     case PARALLEL:\n     case ASM_OPERANDS:\n       reload_n_operands = noperands = asm_noperands (body);\n@@ -2458,7 +2537,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       n_alternatives = insn_n_alternatives[insn_code_number];\n       /* Just return \"no reloads\" if insn has no operands with constraints.  */\n       if (n_alternatives == 0)\n-\treturn;\n+\treturn 0;\n       insn_extract (insn);\n       for (i = 0; i < noperands; i++)\n \t{\n@@ -2469,7 +2548,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n     }\n \n   if (noperands == 0)\n-    return;\n+    return 0;\n \n   commutative = -1;\n \n@@ -2577,9 +2656,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  || GET_CODE (recog_operand[i]) == PLUS))\n \t    {\n \t      INSN_CODE (insn) = -1;\n-\t      find_reloads (insn, replace, ind_levels, live_known,\n-\t\t\t    reload_reg_p);\n-\t      return;\n+\t      retval = find_reloads (insn, replace, ind_levels, live_known,\n+\t\t\t\t     reload_reg_p);\n+\t      return retval;\n \t    }\n \n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n@@ -2601,30 +2680,32 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    = find_reloads_toplev (recog_operand[i], i, address_type[i],\n \t\t\t\t   ind_levels,\n \t\t\t\t   set != 0\n-\t\t\t\t   && &SET_DEST (set) == recog_operand_loc[i]);\n+\t\t\t\t   && &SET_DEST (set) == recog_operand_loc[i],\n+\t\t\t\t   insn);\n \n \t  /* If we made a MEM to load (a part of) the stackslot of a pseudo\n \t     that didn't get a hard register, emit a USE with a REG_EQUAL\n \t     note in front so that we might inherit a previous, possibly\n \t     wider reload.  */\n \t     \n-\t  if (GET_CODE (op) == MEM\n+\t  if (replace\n+\t      && GET_CODE (op) == MEM\n \t      && GET_CODE (reg) == REG\n \t      && (GET_MODE_SIZE (GET_MODE (reg))\n \t\t  >= GET_MODE_SIZE (GET_MODE (op))))\n             REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, reg), insn))\n               = gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t\t   reg_equiv_memory_loc[REGNO (reg)], NULL_RTX);\n \n-\t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i] = op;\n+\t  substed_operand[i] = recog_operand[i] = op;\n \t}\n       else if (code == PLUS || GET_RTX_CLASS (code) == '1')\n \t/* We can get a PLUS as an \"operand\" as a result of register\n \t   elimination.  See eliminate_regs and gen_reload.  We handle\n \t   a unary operator by reloading the operand.  */\n-\tsubsted_operand[i] = recog_operand[i] = *recog_operand_loc[i]\n+\tsubsted_operand[i] = recog_operand[i]\n \t  = find_reloads_toplev (recog_operand[i], i, address_type[i],\n-\t\t\t\t ind_levels, 0);\n+\t\t\t\t ind_levels, 0, insn);\n       else if (code == REG)\n \t{\n \t  /* This is equivalent to calling find_reloads_toplev.\n@@ -2646,44 +2727,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      substed_operand[i] = recog_operand[i]\n \t        = reg_equiv_constant[regno];\n \t    }\n-#if 0 /* This might screw code in reload1.c to delete prior output-reload\n-\t that feeds this insn.  */\n-\t  if (reg_equiv_mem[regno] != 0)\n+\t  if (reg_equiv_memory_loc[regno] != 0\n+\t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n+\t    /* We need not give a valid is_set_dest argument since the case\n+\t       of a constant equivalence was checked above.  */\n \t    substed_operand[i] = recog_operand[i]\n-\t      = reg_equiv_mem[regno];\n-#endif\n-\t  if (reg_equiv_address[regno] != 0)\n-\t    {\n-\t      /* If reg_equiv_address is not a constant address, copy it,\n-\t\t since it may be shared.  */\n-\t      /* We must rerun eliminate_regs, in case the elimination\n-\t\t offsets have changed.  */\n-\t      rtx address = XEXP (eliminate_regs (reg_equiv_memory_loc[regno],\n-\t\t\t\t\t\t  0, NULL_RTX),\n-\t\t\t\t  0);\n-\n-\t      if (rtx_varies_p (address))\n-\t\taddress = copy_rtx (address);\n-\n-\t      /* Emit a USE that shows what register is being used/modified.  */\n-\t      REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\trecog_operand[i]),\n-\t\t\t\t\t   insn))\n-\t\t= gen_rtx_EXPR_LIST (REG_EQUAL,\n-\t\t\t\t     reg_equiv_memory_loc[regno],\n-\t\t\t\t     NULL_RTX);\n-\n-\t      *recog_operand_loc[i] = recog_operand[i]\n-\t\t= gen_rtx_MEM (GET_MODE (recog_operand[i]), address);\n-\t      RTX_UNCHANGING_P (recog_operand[i])\n-\t\t= RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-\t      find_reloads_address (GET_MODE (recog_operand[i]),\n-\t\t\t\t    recog_operand_loc[i],\n-\t\t\t\t    XEXP (recog_operand[i], 0),\n-\t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    i, address_type[i], ind_levels, insn);\n-\t      substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n-\t    }\n+\t      = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\t\t\t\t     ind_levels, 0, insn);\n \t}\n       /* If the operand is still a register (we didn't replace it with an\n \t equivalent), get the preferred class to reload it into.  */\n@@ -3511,7 +3561,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n       n_reloads = 0;\n-      return;\n+      return 0;\n     }\n \n   /* Jump to `finish' from above if all operands are valid already.\n@@ -3546,6 +3596,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       tem = recog_operand[commutative];\n       recog_operand[commutative] = recog_operand[commutative + 1];\n       recog_operand[commutative + 1] = tem;\n+      tem = *recog_operand_loc[commutative];\n+      *recog_operand_loc[commutative] = *recog_operand_loc[commutative+1];\n+      *recog_operand_loc[commutative+1] = tem;\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n@@ -3556,14 +3609,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t}\n     }\n \n-  /* Perform whatever substitutions on the operands we are supposed\n-     to make due to commutativity or replacement of registers\n-     with equivalent constants or memory slots.  */\n-\n   for (i = 0; i < noperands; i++)\n     {\n-      *recog_operand_loc[i] = substed_operand[i];\n-      /* While we are looping on operands, initialize this.  */\n       operand_reloadnum[i] = -1;\n \n       /* If this is an earlyclobber operand, we need to widen the scope.\n@@ -3605,7 +3652,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t*recog_operand_loc[i] = recog_operand[i]\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n \t\t\t\t\t\t  recog_operand[i]),\n-\t\t\t\t i, address_type[i], ind_levels, 0);\n+\t\t\t\t i, address_type[i], ind_levels, 0, insn);\n \tif (alternative_allows_memconst (constraints1[i],\n \t\t\t\t\t goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n@@ -3730,7 +3777,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    /* Avoid further trouble with this insn.  */\n \t    PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n \t    n_reloads = 0;\n-\t    return;\n+\t    return 0;\n \t  }\n       }\n     else if (goal_alternative_matched[i] < 0\n@@ -3748,13 +3795,21 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tif ((GET_CODE (operand) == MEM\n \t     || (GET_CODE (operand) == REG\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n-\t    && (enum reg_class) goal_alternative[i] != NO_REGS\n+\t    /* If this is only for an output, the optional reload would not\n+\t       actually cause us to use a register now, just note that\n+\t       something is stored here.  */\n+\t    && ((enum reg_class) goal_alternative[i] != NO_REGS\n+\t\t|| modified[i] == RELOAD_WRITE)\n \t    && ! no_input_reloads\n-\t    /* Optional output reloads don't do anything and we mustn't\n-\t       make in-out reloads on insns that are not permitted output\n-\t       reloads.  */\n+\t    /* An optional output reload might allow to delete INSN later.\n+\t       We mustn't make in-out reloads on insns that are not permitted\n+\t       output reloads.\n+\t       If this is an asm, we can't delete it; we must not even call\n+\t       push_reload for an optional output reload in this case,\n+\t       because we can't be sure that the constraint allows a register,\n+\t       and push_reload verifies the constraints for asms.  */\n \t    && (modified[i] == RELOAD_READ\n-\t\t|| (modified[i] == RELOAD_READ_WRITE && ! no_output_reloads)))\n+\t\t|| (! no_output_reloads && ! this_insn_is_asm)))\n \t  operand_reloadnum[i]\n \t    = push_reload (modified[i] != RELOAD_WRITE ? recog_operand[i] : 0,\n \t\t\t   modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n@@ -3770,6 +3825,24 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   (insn_code_number < 0 ? 0\n \t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n \t\t\t   1, i, operand_type[i]);\n+\t/* If a memory reference remains, yet we can't make an optional\n+\t   reload, check if this is actually a pseudo register reference;\n+\t   we then need to emit a USE and/or a CLOBBER so that reload\n+\t   inheritance will do the right thing.  */\n+\telse if (replace && GET_CODE (operand) == MEM)\n+\t  {\n+\t    operand = *recog_operand_loc[i];\n+\n+\t    while (GET_CODE (operand) == SUBREG)\n+\t      operand = XEXP (operand, 0);\n+\t    if (GET_CODE (operand) == REG)\n+\t      {\n+\t\tif (modified[i] != RELOAD_WRITE)\n+\t\t  emit_insn_before (gen_rtx_USE (VOIDmode, operand), insn);\n+\t\tif (modified[i] != RELOAD_READ)\n+\t\t  emit_insn_after (gen_rtx_CLOBBER (VOIDmode, operand), insn);\n+\t      }\n+\t  }\n       }\n     else if (goal_alternative_matches[i] >= 0\n \t     && goal_alternative_win[goal_alternative_matches[i]]\n@@ -3801,6 +3874,23 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   0, 1, goal_alternative_matches[i], RELOAD_OTHER);\n       }\n   \n+  /* Perform whatever substitutions on the operands we are supposed\n+     to make due to commutativity or replacement of registers\n+     with equivalent constants or memory slots.  */\n+\n+  for (i = 0; i < noperands; i++)\n+    {\n+      /* We only do this on the last pass through reload, because it is\n+       possible for some data (like reg_equiv_address) to be changed during\n+       later passes.  Moreover, we loose the opportunity to get a useful\n+       reload_{in,out}_reg when we do these replacements.  */\n+\n+      if (replace)\n+\t*recog_operand_loc[i] = substed_operand[i];\n+      else\n+\tretval |= (substed_operand[i] != *recog_operand_loc[i]);\n+    }\n+\n   /* If this insn pattern contains any MATCH_DUP's, make sure that\n      they will be substituted if the operands they match are substituted.\n      Also do now any substitutions we already did on the operands.\n@@ -3955,7 +4045,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n-\t  reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\t  if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n+\t      || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t    reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n+\t  else\n+\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n \t}\n \n       if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n@@ -4170,6 +4264,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   int goal_earlyclobber = 0; /* Always 0, to make combine_reloads happen.  */\n   register int i;\n   rtx body = PATTERN (insn);\n+  int retval = 0;\n \n   n_reloads = 0;\n   n_replacements = 0;\n@@ -4269,6 +4364,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   if (!goal_earlyclobber)\n     combine_reloads ();\n #endif /* no REGISTER_CONSTRAINTS */\n+  return retval;\n }\n \n /* Return 1 if alternative number ALTNUM in constraint-string CONSTRAINT\n@@ -4307,15 +4403,20 @@ alternative_allows_memconst (constraint, altnum)\n    OPNUM and TYPE identify the purpose of the reload.\n \n    IS_SET_DEST is true if X is the destination of a SET, which is not\n-   appropriate to be replaced by a constant.  */\n+   appropriate to be replaced by a constant.\n+\n+   INSN, if nonzero, is the insn in which we do the reload.  It is used\n+   to determine if we may generate output reloads, and where to put USEs\n+   for pseudos that we have to replace with stack slots.  */\n \n static rtx\n-find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n+find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n      rtx x;\n      int opnum;\n      enum reload_type type;\n      int ind_levels;\n      int is_set_dest;\n+     rtx insn;\n {\n   register RTX_CODE code = GET_CODE (x);\n \n@@ -4334,31 +4435,30 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n       else if (reg_equiv_mem[regno] != 0)\n \tx = reg_equiv_mem[regno];\n #endif\n-      else if (reg_equiv_address[regno] != 0)\n+      else if (reg_equiv_memory_loc[regno]\n+\t       && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n \t{\n-\t  /* If reg_equiv_address varies, it may be shared, so copy it.  */\n-\t  /* We must rerun eliminate_regs, in case the elimination\n-\t     offsets have changed.  */\n-\t  rtx addr = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0,\n-\t\t\t\t\t   NULL_RTX),\n-\t\t\t   0);\n-\n-\t  if (rtx_varies_p (addr))\n-\t    addr = copy_rtx (addr);\n-\n-\t  x = gen_rtx_MEM (GET_MODE (x), addr);\n-\t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-\t  find_reloads_address (GET_MODE (x), NULL_PTR,\n-\t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, 0);\n+\t  rtx mem = make_memloc (x, regno);\n+\t  if (reg_equiv_address[regno]\n+\t      || ! rtx_equal_p (mem, reg_equiv_mem[regno]))\n+\t    {\n+\t      /* If this is not a toplevel operand, find_reloads doesn't see\n+\t\t this substitution.  We have to emit a USE of the pseudo so\n+\t\t that delete_output_reload can see it.  */\n+\t      if (replace_reloads && recog_operand[opnum] != x)\n+\t\temit_insn_before (gen_rtx_USE (VOIDmode, x), insn);\n+\t      x = mem;\n+\t      find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\t    opnum, type, ind_levels, insn);\n+\t    }\n \t}\n       return x;\n     }\n   if (code == MEM)\n     {\n       rtx tem = x;\n       find_reloads_address (GET_MODE (x), &tem, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    opnum, type, ind_levels, 0);\n+\t\t\t    opnum, type, ind_levels, insn);\n       return tem;\n     }\n \n@@ -4452,7 +4552,8 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t\t   || (reg_equiv_mem[regno] != 0\n \t\t       && (! strict_memory_address_p (GET_MODE (x), \n \t\t\t\t\t\t      XEXP (reg_equiv_mem[regno], 0))\n-\t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])))))\n+\t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n+\t\t\t   || num_not_at_initial_offset))))\n \t{\n \t  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n \t  /* We must rerun eliminate_regs, in case the elimination\n@@ -4473,7 +4574,12 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, 0);\n+\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, insn);\n+\t  /* If this is not a toplevel operand, find_reloads doesn't see this\n+\t     substitution.  We have to emit a USE of the pseudo so that\n+\t     delete_output_reload can see it.  */\n+\t  if (replace_reloads && recog_operand[opnum] != x)\n+\t    emit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn);\n \t}\n \n     }\n@@ -4482,7 +4588,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n     {\n       if (fmt[i] == 'e')\n \tXEXP (x, i) = find_reloads_toplev (XEXP (x, i), opnum, type,\n-\t\t\t\t\t   ind_levels, is_set_dest);\n+\t\t\t\t\t   ind_levels, is_set_dest, insn);\n     }\n   return x;\n }\n@@ -4495,22 +4601,10 @@ make_memloc (ad, regno)\n      rtx ad;\n      int regno;\n {\n-#if 0\n-  register int i;\n-#endif\n   /* We must rerun eliminate_regs, in case the elimination\n      offsets have changed.  */\n-  rtx tem = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0, NULL_RTX), 0);\n-\n-#if 0 /* We cannot safely reuse a memloc made here;\n-\t if the pseudo appears twice, and its mem needs a reload,\n-\t it gets two separate reloads assigned, but it only\n-\t gets substituted with the second of them;\n-\t then it can get used before that reload reg gets loaded up.  */\n-  for (i = 0; i < n_memlocs; i++)\n-    if (rtx_equal_p (tem, XEXP (memlocs[i], 0)))\n-      return memlocs[i];\n-#endif\n+  rtx tem\n+    = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0, NULL_RTX), 0);\n \n   /* If TEM might contain a pseudo, we must copy it to avoid\n      modifying it when we do the substitution for the reload.  */\n@@ -4519,7 +4613,6 @@ make_memloc (ad, regno)\n \n   tem = gen_rtx_MEM (GET_MODE (ad), tem);\n   RTX_UNCHANGING_P (tem) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-  memlocs[n_memlocs++] = tem;\n   return tem;\n }\n \n@@ -4535,7 +4628,8 @@ make_memloc (ad, regno)\n    supports.\n \n    INSN, if nonzero, is the insn in which we do the reload.  It is used\n-   to determine if we may generate output reloads.\n+   to determine if we may generate output reloads, and where to put USEs\n+   for pseudos that we have to replace with stack slots.\n \n    Value is nonzero if this address is reloaded or replaced as a whole.\n    This is interesting to the caller if the address is an autoincrement.\n@@ -4575,32 +4669,48 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  return 1;\n \t}\n \n-      else if (reg_equiv_address[regno] != 0)\n+      tem = reg_equiv_memory_loc[regno];\n+      if (tem != 0)\n \t{\n-\t  tem = make_memloc (ad, regno);\n-\t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n-\t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n-\t\t\t\tind_levels, insn);\n-\t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n-\t\t       reload_address_base_reg_class,\n-\t\t       GET_MODE (ad), VOIDmode, 0, 0,\n-\t\t       opnum, type);\n-\t  return 1;\n+\t  if (reg_equiv_address[regno] != 0 || num_not_at_initial_offset)\n+\t    {\n+\t      tem = make_memloc (ad, regno);\n+\t      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n+\t\t{\n+\t\t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n+\t\t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n+\t\t\t\t\tind_levels, insn);\n+\t\t}\n+\t      /* We can avoid a reload if the register's equivalent memory\n+\t\t expression is valid as an indirect memory address.\n+\t\t But not all addresses are valid in a mem used as an indirect\n+\t\t address: only reg or reg+constant.  */\n+\n+\t      if (ind_levels > 0\n+\t\t  && strict_memory_address_p (mode, tem)\n+\t\t  && (GET_CODE (XEXP (tem, 0)) == REG\n+\t\t      || (GET_CODE (XEXP (tem, 0)) == PLUS\n+\t\t\t  && GET_CODE (XEXP (XEXP (tem, 0), 0)) == REG\n+\t\t\t  && CONSTANT_P (XEXP (XEXP (tem, 0), 1)))))\n+\t\t{\n+\t\t  /* TEM is not the same as what we'll be replacing the\n+\t\t     pseudo with after reload, put a USE in front of INSN\n+\t\t     in the final reload pass.  */\n+\t\t  if (replace_reloads\n+\t\t      && num_not_at_initial_offset\n+\t\t      && ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t\t    {\n+\t\t      *loc = tem;\n+\t\t      emit_insn_before (gen_rtx_USE (VOIDmode, ad), insn);\n+\t\t      /* This doesn't really count as replacing the address\n+\t\t\t as a whole, since it is still a memory access.  */\n+\t\t    }\n+\t\t  return 0;\n+\t\t}\n+\t      ad = tem;\n+\t    }\n \t}\n \n-      /* We can avoid a reload if the register's equivalent memory expression\n-\t is valid as an indirect memory address.\n-\t But not all addresses are valid in a mem used as an indirect address:\n-\t only reg or reg+constant.  */\n-\n-      else if (reg_equiv_mem[regno] != 0 && ind_levels > 0\n-\t       && strict_memory_address_p (mode, reg_equiv_mem[regno])\n-\t       && (GET_CODE (XEXP (reg_equiv_mem[regno], 0)) == REG\n-\t\t   || (GET_CODE (XEXP (reg_equiv_mem[regno], 0)) == PLUS\n-\t\t       && GET_CODE (XEXP (XEXP (reg_equiv_mem[regno], 0), 0)) == REG\n-\t\t       && CONSTANT_P (XEXP (XEXP (reg_equiv_mem[regno], 0), 1)))))\n-\treturn 0;\n-\n       /* The only remaining case where we can avoid a reload is if this is a\n \t hard register that is valid as a base register and which is not the\n \t subject of a CLOBBER in this insn.  */\n@@ -4633,7 +4743,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \treturn 0;\n \n       subst_reg_equivs_changed = 0;\n-      *loc = subst_reg_equivs (ad);\n+      *loc = subst_reg_equivs (ad, insn);\n \n       if (! subst_reg_equivs_changed)\n \treturn 0;\n@@ -4838,7 +4948,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t registers.  */\n \n       subst_reg_equivs_changed = 0;\n-      tem = subst_reg_equivs (tem);\n+      tem = subst_reg_equivs (tem, insn);\n \n       /* Make sure that didn't make the address invalid again.  */\n \n@@ -4874,11 +4984,14 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \f\n /* Find all pseudo regs appearing in AD\n    that are eliminable in favor of equivalent values\n-   and do not have hard regs; replace them by their equivalents.  */\n+   and do not have hard regs; replace them by their equivalents.\n+   INSN, if nonzero, is the insn in which we do the reload.  We put USEs in\n+   front of it for pseudos that we have to replace with stack slots.  */\n \n static rtx\n-subst_reg_equivs (ad)\n+subst_reg_equivs (ad, insn)\n      rtx ad;\n+     rtx insn;\n {\n   register RTX_CODE code = GET_CODE (ad);\n   register int i;\n@@ -4905,6 +5018,16 @@ subst_reg_equivs (ad)\n \t    subst_reg_equivs_changed = 1;\n \t    return reg_equiv_constant[regno];\n \t  }\n+\tif (reg_equiv_memory_loc[regno] && num_not_at_initial_offset)\n+\t  {\n+\t    rtx mem = make_memloc (ad, regno);\n+\t    if (! rtx_equal_p (mem, reg_equiv_mem[regno]))\n+\t      {\n+\t\tsubst_reg_equivs_changed = 1;\n+\t\temit_insn_before (gen_rtx_USE (VOIDmode, ad), insn);\n+\t\treturn mem;\n+\t      }\n+\t  }\n       }\n       return ad;\n \n@@ -4922,7 +5045,7 @@ subst_reg_equivs (ad)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      XEXP (ad, i) = subst_reg_equivs (XEXP (ad, i));\n+      XEXP (ad, i) = subst_reg_equivs (XEXP (ad, i), insn);\n   return ad;\n }\n \f\n@@ -5195,19 +5318,24 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n \t  /* Handle a register that is equivalent to a memory location\n \t     which cannot be addressed directly.  */\n-\t  if (reg_equiv_address[regno] != 0)\n+\t  if (reg_equiv_memory_loc[regno] != 0\n+\t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n \t    {\n \t      rtx tem = make_memloc (XEXP (x, 0), regno);\n-\t      /* First reload the memory location's address.\n-\t\t We can't use ADDR_TYPE (type) here, because we need to\n-\t\t write back the value after reading it, hence we actually\n-\t\t need two registers.  */\n-\t      find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n-\t\t\t\t    &XEXP (tem, 0), opnum, type,\n-\t\t\t\t    ind_levels, insn);\n-\t      /* Put this inside a new increment-expression.  */\n-\t      x = gen_rtx_fmt_e (GET_CODE (x), GET_MODE (x), tem);\n-\t      /* Proceed to reload that, as if it contained a register.  */\n+\t      if (reg_equiv_address[regno]\n+\t\t  || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t\t{\n+\t\t  /* First reload the memory location's address.\n+\t\t     We can't use ADDR_TYPE (type) here, because we need to\n+\t\t     write back the value after reading it, hence we actually\n+\t\t     need two registers.  */\n+\t\t  find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n+\t\t\t\t\t&XEXP (tem, 0), opnum, type,\n+\t\t\t\t\tind_levels, insn);\n+\t\t  /* Put this inside a new increment-expression.  */\n+\t\t  x = gen_rtx_fmt_e (GET_CODE (x), GET_MODE (x), tem);\n+\t\t  /* Proceed to reload that, as if it contained a register.  */\n+\t\t}\n \t    }\n \n \t  /* If we have a hard register that is ok as an index,\n@@ -5240,9 +5368,12 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t memory location, since this will make it harder to\n \t\t reuse address reloads, and increases register pressure.\n \t\t Also don't do this if we can probably update x directly.  */\n-\t      rtx equiv = reg_equiv_mem[regno];\n+\t      rtx equiv = (GET_CODE (XEXP (x, 0)) == MEM\n+\t\t\t   ? XEXP (x, 0)\n+\t\t\t   : reg_equiv_mem[regno]);\n \t      int icode = (int) add_optab->handlers[(int) Pmode].insn_code;\n \t      if (insn && GET_CODE (insn) == INSN && equiv\n+\t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n #endif\n@@ -5375,11 +5506,18 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t  }\n #endif\n \n-\tif (reg_equiv_address[regno] != 0)\n+\tif (reg_equiv_memory_loc[regno]\n+\t    && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n \t  {\n-\t    x = make_memloc (x, regno);\n-\t    find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\t  opnum, ADDR_TYPE (type), ind_levels, insn);\n+\t    rtx tem = make_memloc (x, regno);\n+\t    if (reg_equiv_address[regno] != 0\n+\t\t|| ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t      {\n+\t\tx = tem;\n+\t\tfind_reloads_address (GET_MODE (x), &x, XEXP (x, 0),\n+\t\t\t\t      &XEXP (x, 0), opnum, ADDR_TYPE (type),\n+\t\t\t\t      ind_levels, insn);\n+\t      }\n \t  }\n \n \tif (reg_renumber[regno] >= 0)\n@@ -6517,6 +6655,12 @@ debug_reload_to_stream (f)\n \t  print_inline_rtx (f, reload_in_reg[r], 24);\n \t}\n \n+      if (reload_out_reg[r] != 0)\n+\t{\n+\t  fprintf (f, \"\\n\\treload_out_reg: \");\n+\t  print_inline_rtx (f, reload_out_reg[r], 24);\n+\t}\n+\n       if (reload_reg_rtx[r] != 0)\n \t{\n \t  fprintf (f, \"\\n\\treload_reg_rtx: \");"}, {"sha": "e49da9abc344ee8977ae2a609948d2d48ec509d6", "filename": "gcc/reload.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=cb2afeb31ed8d214b711f60ab7e24c190933916a", "patch": "@@ -55,6 +55,7 @@ extern enum reg_class reload_address_index_reg_class;\n extern rtx reload_in[MAX_RELOADS];\n extern rtx reload_out[MAX_RELOADS];\n extern rtx reload_in_reg[MAX_RELOADS];\n+extern rtx reload_out_reg[MAX_RELOADS];\n extern enum reg_class reload_reg_class[MAX_RELOADS];\n extern enum machine_mode reload_inmode[MAX_RELOADS];\n extern enum machine_mode reload_outmode[MAX_RELOADS];\n@@ -134,6 +135,8 @@ extern char indirect_symref_ok;\n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n extern char double_reg_address_ok;\n \n+extern int num_not_at_initial_offset;\n+\n #ifdef MAX_INSN_CODE\n /* These arrays record the insn_code of insns that may be needed to\n    perform input and output reloads of special objects.  They provide a\n@@ -233,8 +236,11 @@ extern void clear_secondary_mem PROTO((void));\n    reload TO.  */\n extern void transfer_replacements PROTO((int, int));\n \n-/* Remove all replacements in reload FROM.  */\n-extern void remove_replacements PROTO((int));\n+/* IN_RTX is the value loaded by a reload that we now decided to inherit,\n+   or a subpart of it.  If we have any replacements registered for IN_RTX,\n+   chancel the reloads that were supposed to load them.\n+   Return non-zero if we chanceled any reloads.  */\n+extern int remove_address_replacements PROTO((rtx in_rtx));\n \n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n@@ -250,7 +256,7 @@ extern int safe_from_earlyclobber PROTO((rtx, rtx));\n /* Search the body of INSN for values that need reloading and record them\n    with push_reload.  REPLACE nonzero means record also where the values occur\n    so that subst_reloads can be used.  */\n-extern void find_reloads PROTO((rtx, int, int, int, short *));\n+extern int find_reloads PROTO((rtx, int, int, int, short *));\n \n /* Compute the sum of X and Y, making canonicalizations assumed in an\n    address, namely: sum constant integers, surround the sum of two\n@@ -319,6 +325,9 @@ extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx));\n    OPNUM with reload type TYPE.  */\n extern rtx gen_reload PROTO((rtx, rtx, int, enum reload_type));\n \n+/* Deallocate the reload register used by reload number R.  */\n+extern void deallocate_reload_reg PROTO((int r));\n+\n /* Functions in caller-save.c:  */\n \n /* Initialize for caller-save.  */"}, {"sha": "d4a5cd6561a5ce8646fbea4db3bec3b1f22948e0", "filename": "gcc/reload1.c", "status": "modified", "additions": 942, "deletions": 318, "changes": 1260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb2afeb31ed8d214b711f60ab7e24c190933916a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cb2afeb31ed8d214b711f60ab7e24c190933916a", "patch": "@@ -148,6 +148,11 @@ static rtx spill_reg_rtx[FIRST_PSEUDO_REGISTER];\n    The precise value is the insn generated to do the store.  */\n static rtx spill_reg_store[FIRST_PSEUDO_REGISTER];\n \n+/* This is the register that was stored with spill_reg_store.  This is a\n+   copy of reload_out / reload_out_reg when the value was stored; if\n+   reload_out is a MEM, spill_reg_stored_to will be set to reload_out_reg.  */\n+static rtx spill_reg_stored_to[FIRST_PSEUDO_REGISTER];\n+\n /* This table is the inverse mapping of spill_regs:\n    indexed by hard reg number,\n    it contains the position of that reg in spill_regs,\n@@ -335,7 +340,7 @@ static struct elim_table\n /* Record the number of pending eliminations that have an offset not equal\n    to their initial offset.  If non-zero, we use a new copy of each\n    replacement result in any insns encountered.  */\n-static int num_not_at_initial_offset;\n+int num_not_at_initial_offset;\n \n /* Count the number of registers that we may be able to eliminate.  */\n static int num_eliminable;\n@@ -377,6 +382,7 @@ static void delete_dead_insn\t\tPROTO((rtx));\n static void alter_reg  \t\t\tPROTO((int, int));\n static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n static int eliminate_regs_in_insn\tPROTO((rtx, int));\n+static void update_eliminable_offsets\tPROTO((void));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n static void set_initial_elim_offsets\tPROTO((void));\n static void init_elim_table\t\tPROTO((void));\n@@ -402,8 +408,10 @@ static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int, int));\n static void choose_reload_regs\t\tPROTO((struct insn_chain *, rtx));\n static void merge_assigned_reloads\tPROTO((rtx));\n static void emit_reload_insns\t\tPROTO((struct insn_chain *));\n-static void delete_output_reload\tPROTO((rtx, int, rtx));\n-static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n+static void delete_output_reload\tPROTO((rtx, int, int));\n+static void delete_address_reloads\tPROTO((rtx, rtx));\n+static void delete_address_reloads_1\tPROTO((rtx, rtx, rtx));\n+static rtx inc_for_reload\t\tPROTO((rtx, rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n static void reload_cse_regs_1\t\tPROTO((rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n@@ -582,6 +590,8 @@ compute_use_by_pseudos (to, from)\n \n /* Set during calculate_needs if an insn needs register elimination.  */\n static int something_needs_elimination;\n+/* Set during calculate_needs if an insn needs an operand changed.  */\n+int something_needs_operands_changed;\n \n /* For each class, number of reload regs needed in that class.\n    This is the maximum over all insns of the needs in that class\n@@ -920,6 +930,7 @@ reload (first, global, dumpfile)\n   /* This flag is set if there are any insns that require register\n      eliminations.  */\n   something_needs_elimination = 0;\n+  something_needs_operands_changed = 0;\n   while (something_changed)\n     {\n       HOST_WIDE_INT starting_frame_size;\n@@ -1399,6 +1410,7 @@ calculate_needs_all_insns (global)\n {\n   int something_changed = 0;\n   rtx after_call = 0;\n+  int after_call_nregs;\n   struct insn_chain **pprev_reload = &insns_need_reload;\n   struct insn_chain *chain;\n \n@@ -1424,6 +1436,7 @@ calculate_needs_all_insns (global)\n \t  int old_code = INSN_CODE (insn);\n \t  rtx old_notes = REG_NOTES (insn);\n \t  int did_elimination = 0;\n+\t  int operands_changed = 0;\n \n \t  /* Nonzero means don't use a reload reg that overlaps\n \t     the place where a function value can be returned.  */\n@@ -1434,35 +1447,82 @@ calculate_needs_all_insns (global)\n \t  if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SET)\n-\t\tafter_call = SET_DEST (PATTERN (insn));\n+\t\t{\n+\t\t  after_call = SET_DEST (PATTERN (insn));\n+\t\t  after_call_nregs = HARD_REGNO_NREGS (REGNO (after_call),\n+\t\t\t\t\t\t       GET_MODE (after_call));\n+\t\t}\n \t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n \t\t       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t\tafter_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t\t{\n+\t\t  after_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t\t  after_call_nregs = HARD_REGNO_NREGS (REGNO (after_call),\n+\t\t\t\t\t\t       GET_MODE (after_call));\n+\t\t}\n \t      else\n \t\tafter_call = 0;\n \t    }\n \t  else if (SMALL_REGISTER_CLASSES && after_call != 0\n \t\t   && !(GET_CODE (PATTERN (insn)) == SET\n \t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n+\t\t   && GET_CODE (PATTERN (insn)) != CLOBBER\n \t\t   && GET_CODE (PATTERN (insn)) != USE)\n \t    {\n \t      if (reg_referenced_p (after_call, PATTERN (insn)))\n-\t\tavoid_return_reg = after_call;\n-\t      after_call = 0;\n+\t\t{\n+\t\t  avoid_return_reg = after_call;\n+\t\t  if (! --after_call_nregs)\n+\t\t    after_call = 0;\n+\t\t  else\n+\t\t    {\n+\t\t      /* If INSN copies the return register in a single chunk,\n+\t\t\t clear after_call now.  */\n+\t\t      rtx set = single_set (insn);\n+\t\t      if (set && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n+\t\t\t\t  == GET_MODE_SIZE (GET_MODE (after_call))))\n+\t\t\tafter_call = 0;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tafter_call = 0;\n \t    }\n \n \t  /* If needed, eliminate any eliminable registers.  */\n \t  if (num_eliminable)\n \t    did_elimination = eliminate_regs_in_insn (insn, 0);\n \n \t  /* Analyze the instruction.  */\n-\t  find_reloads (insn, 0, spill_indirect_levels, global,\n-\t\t\tspill_reg_order);\n+\t  operands_changed = find_reloads (insn, 0, spill_indirect_levels,\n+\t\t\t\t\t   global, spill_reg_order);\n+\n+\t  /* If a no-op set needs more than one reload, this is likely\n+\t     to be something that needs input address reloads.  We\n+\t     can't get rid of this cleanly later, and it is of no use\n+\t     anyway, so discard it now.\n+\t     We only do this when expensive_optimizations is enabled,\n+\t     since this complements reload inheritance / output\n+\t     reload deletion, and it can make debugging harder.  */\n+\t  if (flag_expensive_optimizations && n_reloads > 1)\n+\t    {\n+\t      rtx set = single_set (insn);\n+\t      if (set\n+\t\t  && SET_SRC (set) == SET_DEST (set)\n+\t\t  && GET_CODE (SET_SRC (set)) == REG\n+\t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  PUT_CODE (insn, NOTE);\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  if (num_eliminable)\n+\t    update_eliminable_offsets ();\n \n \t  /* Remember for later shortcuts which insns had any reloads or\n \t     register eliminations.  */\n \t  chain->need_elim = did_elimination;\n-\t  chain->need_reload = n_reloads > 0;\n+\t  chain->need_reload = (n_reloads > 0 | operands_changed);\n \n \t  /* Discard any register replacements done.  */\n \t  if (did_elimination)\n@@ -1474,6 +1534,8 @@ calculate_needs_all_insns (global)\n \t      something_needs_elimination = 1;\n \t    }\n \n+\t  something_needs_operands_changed |= operands_changed;\n+\n \t  if (n_reloads != 0)\n \t    {\n \t      *pprev_reload = chain;\n@@ -2895,27 +2957,6 @@ eliminate_regs (x, mem_mode, insn)\n \t      }\n \n \t}\n-      else if (reg_equiv_memory_loc && reg_equiv_memory_loc[regno]\n-\t       && (reg_equiv_address[regno] || num_not_at_initial_offset))\n-\t{\n-\t  /* In this case, find_reloads would attempt to either use an\n-\t     incorrect address (if something is not at its initial offset)\n-\t     or substitute an replaced address into an insn (which loses\n-\t     if the offset is changed by some later action).  So we simply\n-\t     return the replaced stack slot (assuming it is changed by\n-\t     elimination) and ignore the fact that this is actually a\n-\t     reference to the pseudo.  Ensure we make a copy of the\n-\t     address in case it is shared.  */\n-\t  new = eliminate_regs (reg_equiv_memory_loc[regno], mem_mode, insn);\n-\t  if (new != reg_equiv_memory_loc[regno])\n-\t    {\n-\t      if (insn != 0 && GET_CODE (insn) != EXPR_LIST\n-\t\t  && GET_CODE (insn) != INSN_LIST)\n-\t\tREG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, x), insn))\n-\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);\n-\t      return copy_rtx (new);\n-\t    }\n-\t}\n       return x;\n \n     case PLUS:\n@@ -3123,6 +3164,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  && reg_equiv_memory_loc != 0\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n+#if 0\n \t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n \t\t\t\tmem_mode, insn);\n \n@@ -3143,6 +3185,9 @@ eliminate_regs (x, mem_mode, insn)\n \t      /* Ensure NEW isn't shared in case we have to reload it.  */\n \t      new = copy_rtx (new);\n \t    }\n+#else\n+\t  new = SUBREG_REG (x);\n+#endif\n \t}\n       else\n \tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n@@ -3505,7 +3550,7 @@ eliminate_regs_in_insn (insn, replace)\n \t in the insn is the negative of the offset in FROM.  Substitute\n \t (set (reg) (reg to)) for the insn and change its code.\n \n-\t We have to do this here, rather than in eliminate_regs, do that we can\n+\t We have to do this here, rather than in eliminate_regs, so that we can\n \t change the insn code.  */\n \n       if (GET_CODE (SET_SRC (old_set)) == PLUS\n@@ -3592,11 +3637,7 @@ eliminate_regs_in_insn (insn, replace)\n       val = 1;\n     }\n \n-  /* Loop through all elimination pairs.  See if any have changed and\n-     recalculate the number not at initial offset.\n-\n-     Compute the maximum offset (minimum offset if the stack does not\n-     grow downward) for each elimination pair.\n+  /* Loop through all elimination pairs.  See if any have changed.\n \n      We also detect a cases where register elimination cannot be done,\n      namely, if a register would be both changed and referenced outside a MEM\n@@ -3607,7 +3648,6 @@ eliminate_regs_in_insn (insn, replace)\n \n      If anything changes, return nonzero.  */\n \n-  num_not_at_initial_offset = 0;\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       if (ep->previous_offset != ep->offset && ep->ref_outside_mem)\n@@ -3617,16 +3657,6 @@ eliminate_regs_in_insn (insn, replace)\n \n       if (ep->previous_offset != ep->offset)\n \tval = 1;\n-\n-      ep->previous_offset = ep->offset;\n-      if (ep->can_eliminate && ep->offset != ep->initial_offset)\n-\tnum_not_at_initial_offset++;\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-      ep->max_offset = MAX (ep->max_offset, ep->offset);\n-#else\n-      ep->max_offset = MIN (ep->max_offset, ep->offset);\n-#endif\n     }\n \n  done:\n@@ -3644,6 +3674,32 @@ eliminate_regs_in_insn (insn, replace)\n   return val;\n }\n \n+/* Loop through all elimination pairs.\n+   Recalculate the number not at initial offset.\n+\n+   Compute the maximum offset (minimum offset if the stack does not\n+   grow downward) for each elimination pair.  */\n+\n+static void\n+update_eliminable_offsets ()\n+{\n+  struct elim_table *ep;\n+\n+  num_not_at_initial_offset = 0;\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      ep->previous_offset = ep->offset;\n+      if (ep->can_eliminate && ep->offset != ep->initial_offset)\n+\tnum_not_at_initial_offset++;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+      ep->max_offset = MAX (ep->max_offset, ep->offset);\n+#else\n+      ep->max_offset = MIN (ep->max_offset, ep->offset);\n+#endif\n+    }\n+}\n+\n /* Given X, a SET or CLOBBER of DEST, if DEST is the target of a register\n    replacement we currently believe is valid, mark it as not eliminable if X\n    modifies DEST in any way other than by adding a constant integer to it.\n@@ -4170,6 +4226,7 @@ reload_as_needed (live_known)\n   register int i;\n   rtx x;\n   rtx after_call = 0;\n+  int after_call_nregs;\n \n   bzero ((char *) spill_reg_rtx, sizeof spill_reg_rtx);\n   bzero ((char *) spill_reg_store, sizeof spill_reg_store);\n@@ -4208,6 +4265,7 @@ reload_as_needed (live_known)\n     {\n       rtx insn = chain->insn;\n       rtx old_next = NEXT_INSN (insn);\n+      rtx prev;\n \n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n@@ -4235,21 +4293,44 @@ reload_as_needed (live_known)\n \t  if (SMALL_REGISTER_CLASSES && GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SET)\n-\t\tafter_call = SET_DEST (PATTERN (insn));\n+\t\t{\n+\t\t  after_call = SET_DEST (PATTERN (insn));\n+\t\t  after_call_nregs = HARD_REGNO_NREGS (REGNO (after_call),\n+\t\t\t\t\t\t       GET_MODE (after_call));\n+\t\t}\n \t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n \t\t       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t\tafter_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t\t{\n+\t\t  after_call = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t\t  after_call_nregs = HARD_REGNO_NREGS (REGNO (after_call),\n+\t\t\t\t\t\t       GET_MODE (after_call));\n+\t\t}\n \t      else\n \t\tafter_call = 0;\n \t    }\n \t  else if (SMALL_REGISTER_CLASSES && after_call != 0\n \t\t   && !(GET_CODE (PATTERN (insn)) == SET\n \t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n+\t\t   && GET_CODE (PATTERN (insn)) != CLOBBER\n \t\t   && GET_CODE (PATTERN (insn)) != USE)\n \t    {\n \t      if (reg_referenced_p (after_call, PATTERN (insn)))\n-\t\tavoid_return_reg = after_call;\n-\t      after_call = 0;\n+\t\t{\n+\t\t  avoid_return_reg = after_call;\n+\t\t  if (! --after_call_nregs)\n+\t\t    after_call = 0;\n+\t\t  else\n+\t\t    {\n+\t\t      /* If INSN copies the return register in a single chunk,\n+\t\t\t clear after_call now.  */\n+\t\t      rtx set = single_set (insn);\n+\t\t      if (set && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n+\t\t\t\t  == GET_MODE_SIZE (GET_MODE (after_call))))\n+\t\t\tafter_call = 0;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tafter_call = 0;\n \t    }\n \n \t  /* If this is a USE and CLOBBER of a MEM, ensure that any\n@@ -4269,7 +4350,10 @@ reload_as_needed (live_known)\n \t    {\n \t      eliminate_regs_in_insn (insn, 1);\n \t      if (GET_CODE (insn) == NOTE)\n-\t\tcontinue;\n+\t\t{\n+\t\t  update_eliminable_offsets ();\n+\t\t  continue;\n+\t\t}\n \t    }\n \n \t  /* If need_elim is nonzero but need_reload is zero, one might think\n@@ -4294,12 +4378,17 @@ reload_as_needed (live_known)\n \t\t\t    spill_reg_order);\n \t    }\n \n+\t  if (num_eliminable && GET_MODE (insn) == QImode)\n+\t    update_eliminable_offsets ();\n+\n \t  if (n_reloads > 0)\n \t    {\n-\t      rtx prev = PREV_INSN (insn), next = NEXT_INSN (insn);\n+\t      rtx next = NEXT_INSN (insn);\n \t      rtx p;\n \t      int class;\n \n+\t      prev = PREV_INSN (insn);\n+\n \t      /* If this block has not had spilling done for a\n \t\t particular clas and we have any non-optionals that need a\n \t\t spill reg in that class, abort.  */\n@@ -4370,6 +4459,54 @@ reload_as_needed (live_known)\n \t      note_stores (PATTERN (x), forget_old_reloads_1);\n \n #ifdef AUTO_INC_DEC\n+\t  /* Likewise for regs altered by auto-increment in this insn.\n+\t     REG_INC notes have been changed by reloading:\n+\t     find_reloads_address_1 records substitutions for them,\n+\t     which have been performed by subst_reloads above.  */\n+\t  for (i = n_reloads - 1; i >= 0; i--)\n+\t    {\n+\t      rtx in_reg = reload_in_reg[i];\n+\t      if (in_reg)\n+\t\t{\n+\t\t  enum rtx_code code = GET_CODE (in_reg);\n+\t\t  /* PRE_INC / PRE_DEC will have the reload register ending up\n+\t\t     with the same value as the stack slot, but that doesn't\n+\t\t     hold true for POST_INC / POST_DEC.  Either we have to\n+\t\t     convert the memory access to a true POST_INC / POST_DEC,\n+\t\t     or we can't use the reload register for inheritance.  */\n+\t\t  if ((code == POST_INC || code == POST_DEC)\n+\t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid,\n+\t\t\t\t\t    REGNO (reload_reg_rtx[i])))\n+\t\t    {\n+\t\t      rtx reload_reg = reload_reg_rtx[i];\n+\t\t      enum machine_mode mode = GET_MODE (reload_reg);\n+\t\t      int n = 0;\n+\t\t      rtx p;\n+\n+\t\t      for (p = PREV_INSN (old_next); p != prev; p = PREV_INSN (p))\n+\t\t\t{\n+\t\t\t  /* We really want to ignore REG_INC notes here, so\n+\t\t\t     use PATTERN (p) as argument to reg_set_p .  */\n+\t\t\t  if (reg_set_p (reload_reg, PATTERN (p)))\n+\t\t\t    break;\n+\t\t\t  n = count_occurrences (PATTERN (p), reload_reg);\n+\t\t\t  if (! n)\n+\t\t\t    continue;\n+\t\t\t  if (n == 1)\n+\t\t\t    n = validate_replace_rtx (reload_reg,\n+\t\t\t\t\t\t      gen_rtx (code, mode,\n+\t\t\t\t\t\t\t       reload_reg), p);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      if (n == 1)\n+\t\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_INC, reload_reg,\n+\t\t\t\t\t\t\t   REG_NOTES (p));\n+\t\t      else\n+\t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX);\n+\t\t    }\n+\t\t}\n+\t    }\n+#if 0 /* ??? Is this code obsolete now?  Need to check carefully. */\n \t  /* Likewise for regs altered by auto-increment in this insn.\n \t     But note that the reg-notes are not changed by reloading:\n \t     they still contain the pseudo-regs, not the spill regs.  */\n@@ -4386,6 +4523,7 @@ reload_as_needed (live_known)\n \t\tif (i == n_reloads)\n \t\t  forget_old_reloads_1 (XEXP (x, 0), NULL_RTX);\n \t      }\n+#endif\n #endif\n \t}\n       /* A reload reg's contents are unknown after a label.  */\n@@ -4622,57 +4760,104 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n      enum machine_mode mode;\n {\n   int nregs = HARD_REGNO_NREGS (regno, mode);\n+  int start_regno, end_regno;\n   int i;\n+  /* A complication is that for some reload types, inheritance might\n+     allow multiple reloads of the same types to share a reload register.\n+     We set check_opnum if we have to check only reloads with the same\n+     operand number, and check_any if we have to check all reloads.  */\n+  int check_opnum = 0;\n+  int check_any = 0;\n+  HARD_REG_SET *used_in_set;\n \n-  for (i = regno; i < nregs + regno; i++)\n+  switch (type)\n     {\n-      switch (type)\n-\t{\n-\tcase RELOAD_OTHER:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used, i);\n-\t  break;\n+    case RELOAD_OTHER:\n+      used_in_set = &reload_reg_used;\n+      break;\n \n-\tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      used_in_set = &reload_reg_used_in_input_addr[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_INPADDR_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      check_opnum = 1;\n+      used_in_set = &reload_reg_used_in_inpaddr_addr[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      used_in_set = &reload_reg_used_in_output_addr[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      check_opnum = 1;\n+      used_in_set = &reload_reg_used_in_outaddr_addr[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_OPERAND_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n-\t  break;\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      used_in_set = &reload_reg_used_in_op_addr;\n+      break;\n \n-\tcase RELOAD_FOR_OPADDR_ADDR:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, i);\n-\t  break;\n+    case RELOAD_FOR_OPADDR_ADDR:\n+      check_any = 1;\n+      used_in_set = &reload_reg_used_in_op_addr_reload;\n+      break;\n \n-\tcase RELOAD_FOR_OTHER_ADDRESS:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n-\t  break;\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      used_in_set = &reload_reg_used_in_other_addr;\n+      check_any = 1;\n+      break;\n \n-\tcase RELOAD_FOR_INPUT:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_input[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPUT:\n+      used_in_set = &reload_reg_used_in_input[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_OUTPUT:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_output[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_OUTPUT:\n+      used_in_set = &reload_reg_used_in_output[opnum];\n+      break;\n \n-\tcase RELOAD_FOR_INSN:\n-\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_insn, i);\n-\t  break;\n+    case RELOAD_FOR_INSN:\n+      used_in_set = &reload_reg_used_in_insn;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  /* We resolve conflicts with remaining reloads of the same type by\n+     excluding the intervals of of reload registers by them from the\n+     interval of freed reload registers.  Since we only keep track of\n+     one set of interval bounds, we might have to exclude somewhat\n+     more then what would be necessary if we used a HARD_REG_SET here.\n+     But this should only happen very infrequently, so there should\n+     be no reason to worry about it.  */\n+    \n+  start_regno = regno;\n+  end_regno = regno + nregs;\n+  if (check_opnum || check_any)\n+    {\n+      for (i = n_reloads - 1; i >= 0; i--)\n+\t{\n+\t  if (reload_when_needed[i] == type\n+\t      && (check_any || reload_opnum[i] == opnum)\n+\t      && reload_reg_rtx[i])\n+\t    {\n+\t      int conflict_start = true_regnum (reload_reg_rtx[i]);\n+\t      int conflict_end\n+\t\t= (conflict_start\n+\t\t   + HARD_REGNO_NREGS (conflict_start, reload_mode[i]));\n+\n+\t      /* If there is an overlap with the first to-be-freed register,\n+\t\t adjust the interval start.  */\n+\t      if (conflict_start <= start_regno && conflict_end > start_regno)\n+\t\tstart_regno = conflict_end;\n+\t      /* Otherwise, if there is a conflict with one of the other\n+\t\t to-be-freed registers, adjust the interval end.  */\n+\t      if (conflict_start > start_regno && conflict_start < end_regno)\n+\t\tend_regno = conflict_start;\n+\t    }\n \t}\n     }\n+  for (i = start_regno; i < end_regno; i++)\n+    CLEAR_HARD_REG_BIT (*used_in_set, i);\n }\n \n /* 1 if reg REGNO is free as a reload reg for a reload of the sort\n@@ -4953,9 +5138,11 @@ reload_reg_free_before_p (regno, opnum, type, equiv)\n \n       /* The only things earlier are the address for this and\n \t earlier inputs, other inputs (which we know we don't conflict\n-\t with), and addresses of RELOAD_OTHER objects.  */\n+\t with), and addresses of RELOAD_OTHER objects.\n+\t We can ignore the conflict with addresses of this operand, since\n+         when we inherit this operand, its address reloads are discarded.  */\n \n-      for (i = 0; i <= opnum; i++)\n+      for (i = 0; i < opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n@@ -5268,18 +5455,26 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n     case RELOAD_FOR_INPUT_ADDRESS:\n       time1 = opnum * 4 + 2;\n       break;\n+    case RELOAD_FOR_OPADDR_ADDR:\n+    /* opnum * 4 + 3 < opnum * 4 + 4\n+       <= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */\n+      time1 = MAX_RECOG_OPERANDS * 4;\n+      break;\n     case RELOAD_FOR_INPUT:\n       /* All RELOAD_FOR_INPUT reloads remain live till just before the\n \t instruction is executed.  */\n-      time1 = (MAX_RECOG_OPERANDS - 1) * 4 + 3;\n+      time1 = MAX_RECOG_OPERANDS * 4 + 1;\n+      break;\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      /* RELOAD_FOR_OPERAND_ADDRESS reloads are live even while the insn\n+\t is executed.  */\n+      time1 = MAX_RECOG_OPERANDS * 4 + 2;\n       break;\n-    /* opnum * 4 + 3 < opnum * 4 + 4\n-       <= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n-      time1 = MAX_RECOG_OPERANDS * 4 + opnum;\n+      time1 = MAX_RECOG_OPERANDS * 4 + 3 + opnum;\n       break;\n     default:\n-      time1 = MAX_RECOG_OPERANDS * 5;\n+      time1 = MAX_RECOG_OPERANDS * 5 + 3;\n     }\n \n   for (i = 0; i < n_reloads; i++)\n@@ -5305,6 +5500,14 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n \t\t  time2 = 0;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPADDR_ADDRESS:\n+\t\t  /* find_reloads makes sure that a\n+\t\t     RELOAD_FOR_{INP,OP,OUT}ADDR_ADDRESS reload is only used\n+\t\t     by at most one - the first -\n+\t\t     RELOAD_FOR_{INPUT,OPERAND,OUTPUT}_ADDRESS .  If the\n+\t\t     address reload is inherited, the address address reload\n+\t\t     goes away, so we can ignore this conflict.  */\n+\t\t  if (type == RELOAD_FOR_INPUT_ADDRESS && reloadnum == i + 1)\n+\t\t    continue;\n \t\t  time2 = reload_opnum[i] * 4 + 1;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT_ADDRESS:\n@@ -5313,20 +5516,32 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n \t\tcase RELOAD_FOR_INPUT:\n \t\t  time2 = reload_opnum[i] * 4 + 3;\n \t\t  break;\n+\t\tcase RELOAD_FOR_OPADDR_ADDR:\n+\t\t  if (type == RELOAD_FOR_OPERAND_ADDRESS && reloadnum == i + 1)\n+\t\t    continue;\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_OPERAND_ADDRESS:\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 1;\n+\t\t  break;\n \t\tcase RELOAD_FOR_OUTPUT:\n \t\t/* All RELOAD_FOR_OUTPUT reloads become live just after the\n \t\t   instruction is executed.  */\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n \t\t  break;\n+\t\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n+\t\t  if (type == RELOAD_FOR_OUTPUT_ADDRESS && reloadnum == i + 1)\n+\t\t    continue;\n+\t\t/* fall through. */\n \t\t/* The first RELOAD_FOR_OUTPUT_ADDRESS reload conflicts with the\n \t\t   RELOAD_FOR_OUTPUT reloads, so assign it the same time value.  */\n \t\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + reload_opnum[i];\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3 + reload_opnum[i];\n \t\t  break;\n \t\tcase RELOAD_OTHER:\n \t\t  if (! reload_in[i] || rtx_equal_p (reload_in[i], value))\n \t\t    {\n-\t\t      time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t      time2 = MAX_RECOG_OPERANDS * 4 + 3;\n \t\t      break;\n \t\t    }\n \t\tdefault:\n@@ -5566,6 +5781,7 @@ choose_reload_regs (chain, avoid_return_reg)\n   int max_group_size = 1;\n   enum reg_class group_class = NO_REGS;\n   int inheritance;\n+  int pass;\n \n   rtx save_reload_reg_rtx[MAX_RELOADS];\n   char save_reload_inherited[MAX_RELOADS];\n@@ -5823,6 +6039,7 @@ choose_reload_regs (chain, avoid_return_reg)\n \n \t  if (inheritance)\n \t    {\n+\t      int word = 0;\n \t      register int regno = -1;\n \t      enum machine_mode mode;\n \n@@ -5838,33 +6055,27 @@ choose_reload_regs (chain, avoid_return_reg)\n \t\t  regno = REGNO (reload_in_reg[r]);\n \t\t  mode = GET_MODE (reload_in_reg[r]);\n \t\t}\n-\t      else if (GET_CODE (reload_in[r]) == MEM)\n+\t      else if (GET_CODE (reload_in_reg[r]) == SUBREG\n+\t\t       && GET_CODE (SUBREG_REG (reload_in_reg[r])) == REG)\n \t\t{\n-\t\t  rtx prev = prev_nonnote_insn (insn), note;\n-\n-\t\t  if (prev && GET_CODE (prev) == INSN\n-\t\t      && GET_CODE (PATTERN (prev)) == USE\n-\t\t      && GET_CODE (XEXP (PATTERN (prev), 0)) == REG\n-\t\t      && (REGNO (XEXP (PATTERN (prev), 0))\n-\t\t\t  >= FIRST_PSEUDO_REGISTER)\n-\t\t      && (note = find_reg_note (prev, REG_EQUAL, NULL_RTX))\n-\t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n-\t\t    {\n-\t\t      rtx addr = XEXP (XEXP (note, 0), 0);\n-\t\t      int size_diff\n-\t\t\t= (GET_MODE_SIZE (GET_MODE (addr))\n-\t\t\t   - GET_MODE_SIZE (GET_MODE (reload_in[r])));\n-\t\t      if (size_diff >= 0\n-\t\t\t  && rtx_equal_p ((BYTES_BIG_ENDIAN\n-\t\t\t\t\t   ? plus_constant (addr, size_diff)\n-\t\t\t\t\t   : addr),\n-\t\t\t\t\t  XEXP (reload_in[r], 0)))\n-\t\t\t{\n-\t\t\t  regno = REGNO (XEXP (PATTERN (prev), 0));\n-\t\t\t  mode = GET_MODE (reload_in[r]);\n-\t\t\t}\n-\t\t    }\n+\t\t  word = SUBREG_WORD (reload_in_reg[r]);\n+\t\t  regno = REGNO (SUBREG_REG (reload_in_reg[r]));\n+\t\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t    regno += word;\n+\t\t  mode = GET_MODE (reload_in_reg[r]);\n+\t\t}\n+#ifdef AUTO_INC_DEC\n+\t      else if ((GET_CODE (reload_in_reg[r]) == PRE_INC\n+\t\t\t|| GET_CODE (reload_in_reg[r]) == PRE_DEC\n+\t\t\t|| GET_CODE (reload_in_reg[r]) == POST_INC\n+\t\t\t|| GET_CODE (reload_in_reg[r]) == POST_DEC)\n+\t\t       && GET_CODE (XEXP (reload_in_reg[r], 0)) == REG)\n+\t\t{\n+\t\t  regno = REGNO (XEXP (reload_in_reg[r], 0));\n+\t\t  mode = GET_MODE (XEXP (reload_in_reg[r], 0));\n+\t\t  reload_out[r] = reload_in[r];\n \t\t}\n+#endif\n #if 0\n \t      /* This won't work, since REGNO can be a pseudo reg number.\n \t\t Also, it takes much more hair to keep track of all the things\n@@ -5876,15 +6087,34 @@ choose_reload_regs (chain, avoid_return_reg)\n \n \t      if (regno >= 0 && reg_last_reload_reg[regno] != 0)\n \t\t{\n-\t\t  i = REGNO (reg_last_reload_reg[regno]);\n-\n-\t\t  if (reg_reloaded_contents[i] == regno\n+\t\t  enum reg_class class = reload_reg_class[r], last_class;\n+\t\t  rtx last_reg = reg_last_reload_reg[regno];\n+\t\t  \n+\t\t  i = REGNO (last_reg) + word;\n+\t\t  last_class = REGNO_REG_CLASS (i);\n+\t\t  if ((GET_MODE_SIZE (GET_MODE (last_reg))\n+\t\t       >= GET_MODE_SIZE (mode) + word * UNITS_PER_WORD)\n+\t\t      && reg_reloaded_contents[i] == regno\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n-\t\t      && (GET_MODE_SIZE (GET_MODE (reg_last_reload_reg[regno]))\n-\t\t\t  >= GET_MODE_SIZE (mode))\n \t\t      && HARD_REGNO_MODE_OK (i, reload_mode[r])\n-\t\t      && TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n-\t\t\t\t\t    i)\n+\t\t      && (TEST_HARD_REG_BIT (reg_class_contents[(int) class], i)\n+\t\t\t  /* Even if we can't use this register as a reload\n+\t\t\t     register, we might use it for reload_override_in,\n+\t\t\t     if copying it to the desired class is cheap\n+\t\t\t     enough.  */\n+\t\t\t  || ((REGISTER_MOVE_COST (last_class, class)\n+\t\t\t       < MEMORY_MOVE_COST (mode, class, 1))\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+\t\t\t      && (SECONDARY_INPUT_RELOAD_CLASS (class, mode,\n+\t\t\t\t\t\t\t\tlast_reg)\n+\t\t\t\t  == NO_REGS)\n+#endif\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t\t\t      && ! SECONDARY_MEMORY_NEEDED (last_class, class,\n+\t\t\t\t\t\t\t    mode)\n+#endif\n+\t\t\t      ))\n+\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n@@ -5913,6 +6143,9 @@ choose_reload_regs (chain, avoid_return_reg)\n \t\t\t{\n \t\t\t  int i1;\n \n+\t\t\t  last_reg = (GET_MODE (last_reg) == mode\n+\t\t\t\t      ? last_reg : gen_rtx_REG (mode, i));\n+\n \t\t\t  /* We found a register that contains the\n \t\t\t     value we need.  If this register is the\n \t\t\t     same as an `earlyclobber' operand of the\n@@ -5935,13 +6168,20 @@ choose_reload_regs (chain, avoid_return_reg)\n \t\t\t\t if we need it wider than we've got it.  */\n \t\t\t      || (GET_MODE_SIZE (reload_mode[r])\n \t\t\t\t  > GET_MODE_SIZE (mode))\n+\t\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n+\t\t\t\t\t\t      i)\n+\n \t\t\t      /* If find_reloads chose reload_out as reload\n \t\t\t\t register, stay with it - that leaves the\n \t\t\t\t inherited register for subsequent reloads.  */\n \t\t\t      || (reload_out[r] && reload_reg_rtx\n \t\t\t\t  && rtx_equal_p (reload_out[r],\n \t\t\t\t\t\t  reload_reg_rtx[r])))\n-\t\t\t    reload_override_in[r] = reg_last_reload_reg[regno];\n+\t\t\t    {\n+\t\t\t      reload_override_in[r] = last_reg;\n+\t\t\t      reload_inheritance_insn[r]\n+\t\t\t\t= reg_reloaded_insn[i];\n+\t\t\t    }\n \t\t\t  else\n \t\t\t    {\n \t\t\t      int k;\n@@ -5952,7 +6192,7 @@ choose_reload_regs (chain, avoid_return_reg)\n \t\t\t\t\t\t      reload_opnum[r],\n \t\t\t\t\t\t      reload_when_needed[r],\n \t\t\t\t\t\t      reload_mode[r]);\n-\t\t\t      reload_reg_rtx[r] = reg_last_reload_reg[regno];\n+\t\t\t      reload_reg_rtx[r] = last_reg;\n \t\t\t      reload_inherited[r] = 1;\n \t\t\t      reload_inheritance_insn[r]\n \t\t\t\t= reg_reloaded_insn[i];\n@@ -6003,21 +6243,15 @@ choose_reload_regs (chain, avoid_return_reg)\n \t      /* If we found a spill reg, reject it unless it is free\n \t\t and of the desired class.  */\n \t      if (equiv != 0\n-\t\t  && ((spill_reg_order[regno] >= 0\n-\t\t       && ! (reload_reg_free_before_p (regno, reload_opnum[r],\n-\t\t\t\t\t\t       reload_when_needed[r], 1)\n-\t\t\t     || reload_reg_free_for_value_p (regno,\n-\t\t\t\t\t\t\t     reload_opnum[r],\n-\t\t\t\t\t\t\t     reload_when_needed[r],\n-\t\t\t\t\t\t\t     reload_in[r],\n-\t\t\t\t\t\t\t     reload_out[r], r)))\n+\t\t  && ((TEST_HARD_REG_BIT (reload_reg_used_at_all, regno)\n+\t\t       && ! reload_reg_free_for_value_p (regno, reload_opnum[r],\n+\t\t\t\t\t\t\t reload_when_needed[r],\n+\t\t\t\t\t\t\t reload_in[r],\n+\t\t\t\t\t\t\t reload_out[r], r))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n \n-\t      if (equiv != 0 && TEST_HARD_REG_BIT (reload_reg_used_at_all, regno))\n-\t\tequiv = 0;\n-\n \t      if (equiv != 0 && ! HARD_REGNO_MODE_OK (regno, reload_mode[r]))\n \t\tequiv = 0;\n \n@@ -6204,75 +6438,57 @@ choose_reload_regs (chain, avoid_return_reg)\n \n   /* If we thought we could inherit a reload, because it seemed that\n      nothing else wanted the same reload register earlier in the insn,\n-     verify that assumption, now that all reloads have been assigned.  */\n+     verify that assumption, now that all reloads have been assigned.\n+     Likewise for reloads where reload_override_in has been set.  */\n \n-  for (j = 0; j < n_reloads; j++)\n+  /* If doing expensive optimizations, do one preliminary pass that doesn't\n+     cancel any inheritance, but removes reloads that have been needed only\n+     for reloads that we know can be inherited.  */\n+  for (pass = flag_expensive_optimizations; pass >= 0; pass--)\n     {\n-      register int r = reload_order[j];\n-\n-      if (reload_inherited[r] && reload_reg_rtx[r] != 0\n-\t  && ! (reload_reg_free_before_p (true_regnum (reload_reg_rtx[r]),\n-\t\t\t\t\t  reload_opnum[r],\n-\t\t\t\t\t  reload_when_needed[r], 0)\n-\t\t|| reload_reg_free_for_value_p (true_regnum (reload_reg_rtx[r]),\n-\t\t\t\t\t\treload_opnum[r],\n-\t\t\t\t\t\treload_when_needed[r],\n-\t\t\t\t\t\treload_in[r],\n-\t\t\t\t\t\treload_out[r], r)))\n-\treload_inherited[r] = 0;\n-      /* If we can inherit a RELOAD_FOR_INPUT, then we do not need its related\n-\t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads.\n-\t ??? This could be extended to other reload types, but these are\n-         more tricky to handle:\n-\t RELOAD_FOR_OTHER_ADDRESS reloads might have been merged, so we\n-\t can't eliminate them without a check that *all* references are\n-\t now unused due to inheritance.\n-\t While RELOAD_FOR_INPADDR_ADDRESS and RELOAD_FOR_OUTADDR_ADDRESS are\n-\t not merged, we can't be sure that we have eliminated the use of\n-\t that particular reload if we have seen just one\n-\t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_OUTPUT_ADDRESS being inherited,\n-\t since there might be multiple of the latter two reloads for a single\n-\t operand.\n-\t RELOAD_FOR_OPADDR_ADDR reloads for different operands are not\n-\t merged, but might share the same register by courtesy of\n-\t reload_reg_free_for_value_p.  reload_reg_used_in_op_addr_reload\n-\t does not differentiate by opnum, thus calling clear_reload_reg_in_use\n-\t for one of these reloads would mark the register as free even though\n-\t another RELOAD_FOR_OPADDR_ADDR reload might still use it.  */\n-      else if (reload_inherited[r] && reload_when_needed[r] == RELOAD_FOR_INPUT)\n+      for (j = 0; j < n_reloads; j++)\n \t{\n-\t  for (i = 0; i < n_reloads; i++)\n+\t  register int r = reload_order[j];\n+\t  rtx check_reg;\n+\n+\t  if (reload_inherited[r] && reload_reg_rtx[r])\n+\t    check_reg = reload_reg_rtx[r];\n+\t  else if (reload_override_in[r]\n+\t\t   && (GET_CODE (reload_override_in[r]) == REG\n+\t    \t\t     || GET_CODE (reload_override_in[r]) == SUBREG))\n+\t    check_reg = reload_override_in[r];\n+\t  else\n+\t    continue;\n+\t  if (! (reload_reg_free_before_p (true_regnum (check_reg),\n+\t    \t\t\t       reload_opnum[r], reload_when_needed[r],\n+\t    \t\t\t       ! reload_inherited[r])\n+\t\t || reload_reg_free_for_value_p (true_regnum (check_reg),\n+\t    \t\t\t\t     reload_opnum[r],\n+\t    \t\t\t\t     reload_when_needed[r],\n+\t    \t\t\t\t     reload_in[r],\n+\t    \t\t\t\t     reload_out[r], r)))\n \t    {\n-\t      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n-\t\t  && reload_opnum[i] == reload_opnum[r]\n-\t\t  && reload_in[i] && reload_reg_rtx[i])\n-\t\t{\n-\t\t  int regno = true_regnum (reload_reg_rtx[i]);\n-\n-\t\t  reload_in[i] = 0;\n-\t\t  if (spill_reg_order[regno] >= 0)\n-\t\t    clear_reload_reg_in_use (regno, reload_opnum[i],\n-\t\t\t\t\t     reload_when_needed[i],\n-\t\t\t\t\t     reload_mode[i]);\n-\t\t  reload_reg_rtx[i] = 0;\n-\t\t  reload_spill_index[i] = -1;\n-\t\t  remove_replacements (i);\n-\t\t}\n+\t      if (pass)\n+\t\tcontinue;\n+\t      reload_inherited[r] = 0;\n+\t      reload_override_in[r] = 0;\n \t    }\n-\t}\n-\n-      /* If we found a better place to reload from,\n-\t validate it in the same fashion, if it is a reload reg.  */\n-      if (reload_override_in[r]\n-\t  && (GET_CODE (reload_override_in[r]) == REG\n-\t      || GET_CODE (reload_override_in[r]) == SUBREG))\n-\t{\n-\t  int regno = true_regnum (reload_override_in[r]);\n-\t  if (spill_reg_order[regno] >= 0\n-\t      && ! reload_reg_free_before_p (regno, reload_opnum[r],\n-\t\t\t\t\t     reload_when_needed[r], 1))\n-\t    reload_override_in[r] = 0;\n+\t  /* If we can inherit a RELOAD_FOR_INPUT, or can use a\n+\t     reload_override_in, then we do not need its related\n+\t     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads;\n+\t     likewise for other reload types.\n+\t     We handle this by removing a reload when its only replacement\n+\t     is mentioned in reload_in of the reload we are going to inherit.\n+\t     A special case are auto_inc expressions; even if the input is\n+\t     inherited, we still need the address for the output.  We can\n+\t     recognize them because they have RELOAD_OUT set but not\n+\t     RELOAD_OUT_REG.\n+\t     If we suceeded removing some reload and we are doing a preliminary\n+\t     pass just to remove such reloads, make another pass, since the\n+\t     removal of one reload might allow us to inherit another one.  */\n+\t  else if ((! reload_out[r] || reload_out_reg[r])\n+\t\t   && remove_address_replacements (reload_in[r]) && pass)\n+\t    pass = 2;\n \t}\n     }\n \n@@ -6309,10 +6525,10 @@ choose_reload_regs (chain, avoid_return_reg)\n       /* I is nonneg if this reload uses a register.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */\n-      if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG\n+      if (reload_out_reg[r] != 0 && GET_CODE (reload_out_reg[r]) == REG\n \t  && reload_reg_rtx[r] != 0)\n \t{\n-\t  register int nregno = REGNO (reload_out[r]);\n+\t  register int nregno = REGNO (reload_out_reg[r]);\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n@@ -6335,6 +6551,24 @@ choose_reload_regs (chain, avoid_return_reg)\n \t}\n     }\n }\n+\n+/* Deallocate the reload register for reload R.  This is called from\n+   remove_address_replacements.  */\n+void\n+deallocate_reload_reg (r)\n+     int r;\n+{\n+  int regno;\n+\n+  if (! reload_reg_rtx[r])\n+    return;\n+  regno = true_regnum (reload_reg_rtx[r]);\n+  reload_reg_rtx[r] = 0;\n+  if (spill_reg_order[regno] >= 0)\n+    clear_reload_reg_in_use (regno, reload_opnum[r], reload_when_needed[r],\n+\t\t\t     reload_mode[r]);\n+  reload_spill_index[r] = -1;\n+}\n \f\n /* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two\n    reloads of the same item for fear that we might not have enough reload\n@@ -6495,11 +6729,17 @@ emit_reload_insns (chain)\n       rtx this_reload_insn = 0;\n       int expect_occurrences = 1;\n \n-      if (reload_spill_index[j] >= 0)\n-\tnew_spill_reg_store[reload_spill_index[j]] = 0;\n+      if (reload_reg_rtx[j]\n+\t  && REGNO (reload_reg_rtx[j]) < FIRST_PSEUDO_REGISTER)\n+\tnew_spill_reg_store[REGNO (reload_reg_rtx[j])] = 0;\n+\n+      old = (reload_in[j] && GET_CODE (reload_in[j]) == MEM\n+\t     ? reload_in_reg[j] : reload_in[j]);\n \n-      old = reload_in[j];\n-      if (old != 0 && ! reload_inherited[j]\n+      if (old != 0\n+\t  /* AUTO_INC reloads need to be handled even if inherited.  We got an\n+\t     AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */\n+\t  && (! reload_inherited[j] || (reload_out[j] && ! reload_out_reg[j]))\n \t  && ! rtx_equal_p (reload_reg_rtx[j], old)\n \t  && reload_reg_rtx[j] != 0)\n \t{\n@@ -6628,6 +6868,17 @@ emit_reload_insns (chain)\n \t\toldequiv = 0;\n \t    }\n \n+\t  /* delete_output_reload is only invoked properly if old contains\n+\t     the original pseudo register.  Since this is replaced with a\n+\t     hard reg when RELOAD_OVERRIDE_IN is set, see if we can\n+\t     find the pseudo in RELOAD_IN_REG.  */\n+\t  if (oldequiv == 0\n+\t      && reload_override_in[j]\n+\t      && GET_CODE (reload_in_reg[j]) == REG)\n+\t    {\n+\t      oldequiv = old;\n+\t      old = reload_in_reg[j];\n+\t    }\n \t  if (oldequiv == 0)\n \t    oldequiv = old;\n \t  else if (GET_CODE (oldequiv) == REG)\n@@ -6642,11 +6893,11 @@ emit_reload_insns (chain)\n \t  if (optimize && GET_CODE (oldequiv) == REG\n \t      && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n \t      && spill_reg_store[REGNO (oldequiv)]\n-\t      && GET_CODE (old) == REG && dead_or_set_p (insn, old)\n-\t      /* This is unsafe if operand occurs more than once in current\n-\t\t insn.  Perhaps some occurrences weren't reloaded.  */\n-\t      && count_occurrences (PATTERN (insn), old) == 1)\n-\t    delete_output_reload (insn, j, spill_reg_store[REGNO (oldequiv)]);\n+\t      && GET_CODE (old) == REG\n+\t      && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n+\t\t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n+\t\t\t\t  reload_out_reg[j])))\n+\t    delete_output_reload (insn, j, REGNO (oldequiv));\n \n \t  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n \t     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n@@ -6700,20 +6951,35 @@ emit_reload_insns (chain)\n \t  special = 0;\n \n \t  /* Auto-increment addresses must be reloaded in a special way.  */\n-\t  if (GET_CODE (oldequiv) == POST_INC\n-\t      || GET_CODE (oldequiv) == POST_DEC\n-\t      || GET_CODE (oldequiv) == PRE_INC\n-\t      || GET_CODE (oldequiv) == PRE_DEC)\n+\t  if (reload_out[j] && ! reload_out_reg[j])\n \t    {\n \t      /* We are not going to bother supporting the case where a\n \t\t incremented register can't be copied directly from\n \t\t OLDEQUIV since this seems highly unlikely.  */\n \t      if (reload_secondary_in_reload[j] >= 0)\n \t\tabort ();\n+\n+\t      if (reload_inherited[j])\n+\t\toldequiv = reloadreg;\n+\n+\t      old = XEXP (reload_in_reg[j], 0);\n+\n+\t      if (optimize && GET_CODE (oldequiv) == REG\n+\t\t  && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n+\t\t  && spill_reg_store[REGNO (oldequiv)]\n+\t\t  && GET_CODE (old) == REG\n+\t\t  && (dead_or_set_p (insn,\n+\t\t\t\t     spill_reg_stored_to[REGNO (oldequiv)])\n+\t\t      || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n+\t\t\t\t      old)))\n+\t\tdelete_output_reload (insn, j, REGNO (oldequiv));\n+\n \t      /* Prevent normal processing of this reload.  */\n \t      special = 1;\n \t      /* Output a special code sequence for this case.  */\n-\t      inc_for_reload (reloadreg, oldequiv, reload_inc[j]);\n+\t      new_spill_reg_store[REGNO (reloadreg)]\n+\t\t= inc_for_reload (reloadreg, oldequiv, reload_out[j],\n+\t\t\t\t  reload_inc[j]);\n \t    }\n \n \t  /* If we are reloading a pseudo-register that was set by the previous\n@@ -6789,15 +7055,31 @@ emit_reload_insns (chain)\n \t\t  /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n \t\t     and similarly for OLD.\n \t\t     See comments in get_secondary_reload in reload.c.  */\n+\t\t  /* If it is a pseudo that cannot be replaced with its\n+\t\t     equivalent MEM, we must fall back to reload_in, which\n+\t\t     will have all the necessary substitutions registered.  */\n+\t\t\t\t\n \t\t  if (GET_CODE (oldequiv) == REG\n \t\t      && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n-\t\t      && reg_equiv_mem[REGNO (oldequiv)] != 0)\n-\t\t    real_oldequiv = reg_equiv_mem[REGNO (oldequiv)];\n+\t\t      && reg_equiv_memory_loc[REGNO (oldequiv)] != 0)\n+\t\t    {\n+\t\t      if (reg_equiv_address[REGNO (oldequiv)]\n+\t\t\t  || num_not_at_initial_offset)\n+\t\t\treal_oldequiv = reload_in[j];\n+\t\t      else\n+\t\t\treal_oldequiv = reg_equiv_mem[REGNO (oldequiv)];\n+\t\t    }\n \n \t\t  if (GET_CODE (old) == REG\n \t\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t\t      && reg_equiv_mem[REGNO (old)] != 0)\n-\t\t    real_old = reg_equiv_mem[REGNO (old)];\n+\t\t      && reg_equiv_memory_loc[REGNO (old)] != 0)\n+\t\t    {\n+\t\t      if (reg_equiv_address[REGNO (old)]\n+\t\t\t  || num_not_at_initial_offset)\n+\t\t\treal_old = reload_in[j];\n+\t\t      else\n+\t\t\treal_old = reg_equiv_mem[REGNO (old)];\n+\t\t    }\n \n \t\t  second_reload_reg = reload_reg_rtx[secondary_reload];\n \t\t  icode = reload_secondary_in_icode[j];\n@@ -6882,7 +7164,7 @@ emit_reload_insns (chain)\n \t\t\t\t\t   third_reload_reg)));\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    gen_reload (second_reload_reg, oldequiv,\n+\t\t\t    gen_reload (second_reload_reg, real_oldequiv,\n \t\t\t\t\treload_opnum[j],\n \t\t\t\t\treload_when_needed[j]);\n \n@@ -6893,22 +7175,42 @@ emit_reload_insns (chain)\n #endif\n \n \t      if (! special && ! rtx_equal_p (reloadreg, oldequiv))\n-\t\tgen_reload (reloadreg, oldequiv, reload_opnum[j],\n-\t\t\t    reload_when_needed[j]);\n+\t\t{\n+\t\t  rtx real_oldequiv = oldequiv;\n+\n+\t\t  if ((GET_CODE (oldequiv) == REG\n+\t\t       && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n+\t\t       && reg_equiv_memory_loc[REGNO (oldequiv)] != 0)\n+\t\t      || (GET_CODE (oldequiv) == SUBREG\n+\t\t\t  && GET_CODE (SUBREG_REG (oldequiv)) == REG\n+\t\t\t  && (REGNO (SUBREG_REG (oldequiv))\n+\t\t\t      >= FIRST_PSEUDO_REGISTER)\n+\t\t\t  && (reg_equiv_memory_loc\n+\t\t\t      [REGNO (SUBREG_REG (oldequiv))] != 0)))\n+\t\t    real_oldequiv = reload_in[j];\n+\t\t  gen_reload (reloadreg, real_oldequiv, reload_opnum[j],\n+\t\t\t      reload_when_needed[j]);\n+\t\t}\n \n \t    }\n \n \t  this_reload_insn = get_last_insn ();\n \t  /* End this sequence.  */\n \t  *where = get_insns ();\n \t  end_sequence ();\n+\n+\t  /* Update reload_override_in so that delete_address_reloads_1\n+\t     can see the actual register usage.  */\n+\t  if (oldequiv_reg)\n+\t    reload_override_in[j] = oldequiv;\n \t}\n \n       /* When inheriting a wider reload, we have a MEM in reload_in[j],\n \t e.g. inheriting a SImode output reload for\n \t (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */\n       if (optimize && reload_inherited[j] && reload_in[j]\n \t  && GET_CODE (reload_in[j]) == MEM\n+\t  && GET_CODE (reload_in_reg[j]) == MEM\n \t  && reload_spill_index[j] >= 0\n \t  && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n \t{\n@@ -6922,35 +7224,60 @@ emit_reload_insns (chain)\n \t output-reload, see if we can prove there was\n \t actually no need to store the old value in it.  */\n \n-      if (optimize && reload_inherited[j] && reload_spill_index[j] >= 0\n-\t  && reload_in[j] != 0\n-\t  && GET_CODE (reload_in[j]) == REG\n+      if (optimize\n+\t  && (reload_inherited[j] || reload_override_in[j])\n+\t  && reload_reg_rtx[j]\n+\t  && GET_CODE (reload_reg_rtx[j]) == REG\n+\t  && spill_reg_store[REGNO (reload_reg_rtx[j])] != 0\n #if 0\n \t  /* There doesn't seem to be any reason to restrict this to pseudos\n \t     and doing so loses in the case where we are copying from a\n \t     register of the wrong class.  */\n-\t  && REGNO (reload_in[j]) >= FIRST_PSEUDO_REGISTER\n+\t  && REGNO (spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n+\t     >= FIRST_PSEUDO_REGISTER\n #endif\n-\t  && spill_reg_store[reload_spill_index[j]] != 0\n-\t  /* This is unsafe if some other reload uses the same reg first.  */\n-\t  && reload_reg_free_before_p (reload_spill_index[j],\n-\t\t\t\t       reload_opnum[j], reload_when_needed[j],\n-\t\t\t\t       0)\n-\t  && dead_or_set_p (insn, reload_in[j])\n-\t  /* This is unsafe if operand occurs more than once in current\n-\t     insn.  Perhaps some occurrences weren't reloaded.  */\n-\t  && (count_occurrences (PATTERN (insn), reload_in[j])\n-\t      == expect_occurrences))\n-\tdelete_output_reload (insn, j,\n-\t\t\t      spill_reg_store[reload_spill_index[j]]);\n+\t     /* The insn might have already some references to stackslots\n+\t\treplaced by MEMs, while reload_out_reg still names the\n+\t\toriginal pseudo.  */\n+\t  && (dead_or_set_p (insn,\n+\t\t\t     spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n+\t      || rtx_equal_p (spill_reg_stored_to[REGNO (reload_reg_rtx[j])],\n+\t\t\t      reload_out_reg[j])))\n+\tdelete_output_reload (insn, j, REGNO (reload_reg_rtx[j]));\n \n       /* Input-reloading is done.  Now do output-reloading,\n \t storing the value from the reload-register after the main insn\n \t if reload_out[j] is nonzero.\n \n \t ??? At some point we need to support handling output reloads of\n \t JUMP_INSNs or insns that set cc0.  */\n-      old = reload_out[j];\n+\n+      /* If this is an output reload that stores something that is\n+\t not loaded in this same reload, see if we can eliminate a previous\n+\t store.  */\n+      {\n+\trtx pseudo = reload_out_reg[j];\n+\t  \n+\tif (pseudo\n+\t    && GET_CODE (pseudo) == REG\n+\t    && ! rtx_equal_p (reload_in_reg[j], pseudo)\n+\t    && REGNO (pseudo) >= FIRST_PSEUDO_REGISTER\n+\t    && reg_last_reload_reg[REGNO (pseudo)])\n+\t  {\n+\t    int pseudo_no = REGNO (pseudo);\n+\t    int last_regno = REGNO (reg_last_reload_reg[pseudo_no]);\n+\n+\t    /* We don't need to test full validity of last_regno for\n+\t       inherit here; we only want to know if the store actually\n+\t       matches the pseudo.  */\n+\t    if (reg_reloaded_contents[last_regno] == pseudo_no\n+\t\t&& spill_reg_store[last_regno]\n+\t\t&& rtx_equal_p (pseudo, spill_reg_stored_to[last_regno]))\n+\t      delete_output_reload (insn, j, last_regno);\n+\t  }\n+      }\n+\n+      old = reload_out_reg[j];\n       if (old != 0\n \t  && reload_reg_rtx[j] != old\n \t  && reload_reg_rtx[j] != 0)\n@@ -7006,6 +7333,8 @@ emit_reload_insns (chain)\n \t  else\n \t    push_to_sequence (output_reload_insns[reload_opnum[j]]);\n \n+\t  old = reload_out[j];\n+\n \t  /* Determine the mode to reload in.\n \t     See comments above (for input reloading).  */\n \n@@ -7136,21 +7465,22 @@ emit_reload_insns (chain)\n \n \t\tif (reg_mentioned_p (reload_reg_rtx[j], pat))\n \t\t  {\n+\t\t    rtx set = single_set (insn);\n \t\t    if (reload_spill_index[j] < 0\n-\t\t\t&& GET_CODE (pat) == SET\n-\t\t\t&& SET_SRC (pat) == reload_reg_rtx[j])\n+\t\t\t&& set\n+\t\t\t&& SET_SRC (set) == reload_reg_rtx[j])\n \t\t      {\n-\t\t\tint src = REGNO (SET_SRC (pat));\n+\t\t\tint src = REGNO (SET_SRC (set));\n \n \t\t\treload_spill_index[j] = src;\n \t\t\tSET_HARD_REG_BIT (reg_is_output_reload, src);\n \t\t\tif (find_regno_note (insn, REG_DEAD, src))\n \t\t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n \t\t      }\n-\t\t    if (reload_spill_index[j] >= 0)\n+\t\t    if (REGNO (reload_reg_rtx[j]) < FIRST_PSEUDO_REGISTER)\n \t\t      {\n \t\t\tint s = reload_secondary_out_reload[j];\n-\t\t\trtx set = single_set (p);\n+\t\t\tset = single_set (p);\n \t\t\t/* If this reload copies only to the secondary reload\n \t\t\t   register, the secondary reload does the actual\n \t\t\t   store.  */\n@@ -7169,13 +7499,18 @@ emit_reload_insns (chain)\n \t\t\t    rtx s_reg = reload_reg_rtx[s];\n \t\t\t    rtx next = NEXT_INSN (p);\n \t\t\t    reload_out[s] = reload_out[j];\n+\t\t\t    reload_out_reg[s] = reload_out_reg[j];\n \t\t\t    set = single_set (next);\n \t\t\t    if (set && SET_SRC (set) == s_reg\n \t\t\t\t&& ! new_spill_reg_store[REGNO (s_reg)])\n-\t\t\t      new_spill_reg_store[REGNO (s_reg)] = next;\n+\t\t\t      {\n+\t\t\t\tSET_HARD_REG_BIT (reg_is_output_reload,\n+\t\t\t\t\t\t  REGNO (s_reg));\n+\t\t\t\tnew_spill_reg_store[REGNO (s_reg)] = next;\n+\t\t\t      }\n \t\t\t  }\n \t\t\telse\n-\t\t\t  new_spill_reg_store[reload_spill_index[j]] = p;\n+\t\t\t  new_spill_reg_store[REGNO (reload_reg_rtx[j])] = p;\n \t\t      }\n \t\t  }\n \t      }\n@@ -7292,14 +7627,25 @@ emit_reload_insns (chain)\n \t\tCLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \n \t      /* Maybe the spill reg contains a copy of reload_out.  */\n-\t      if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n+\t      if (reload_out[r] != 0\n+\t\t  && (GET_CODE (reload_out[r]) == REG\n+#ifdef AUTO_INC_DEC\n+\t\t      || ! reload_out_reg[r]\n+#endif\n+\t\t      || GET_CODE (reload_out_reg[r]) == REG))\n \t\t{\n-\t\t  register int nregno = REGNO (reload_out[r]);\n+\t\t  rtx out = (GET_CODE (reload_out[r]) == REG\n+\t\t\t     ? reload_out[r]\n+\t\t\t     : reload_out_reg[r]\n+\t\t\t     ? reload_out_reg[r]\n+/* AUTO_INC */\t\t     : XEXP (reload_in_reg[r], 0));\n+\t\t  register int nregno = REGNO (out);\n \t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t     : HARD_REGNO_NREGS (nregno,\n \t\t\t\t\t\t GET_MODE (reload_reg_rtx[r])));\n \n \t\t  spill_reg_store[i] = new_spill_reg_store[i];\n+\t\t  spill_reg_stored_to[i] = out;\n \t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n \t\t  /* If NREGNO is a hard register, it may occupy more than\n@@ -7332,21 +7678,25 @@ emit_reload_insns (chain)\n \t      /* Maybe the spill reg contains a copy of reload_in.  Only do\n \t\t something if there will not be an output reload for\n \t\t the register being reloaded.  */\n-\t      else if (reload_out[r] == 0\n+\t      else if (reload_out_reg[r] == 0\n \t\t       && reload_in[r] != 0\n-\t\t       && spill_reg_order[i] >= 0\n \t\t       && ((GET_CODE (reload_in[r]) == REG\n+\t\t\t    && REGNO (reload_in[r]) >= FIRST_PSEUDO_REGISTER\n \t\t\t    && ! reg_has_output_reload[REGNO (reload_in[r])])\n \t\t\t   || (GET_CODE (reload_in_reg[r]) == REG\n-\t\t\t       && ! reg_has_output_reload[REGNO (reload_in_reg[r])])))\n+\t\t\t       && ! reg_has_output_reload[REGNO (reload_in_reg[r])]))\n+\t\t       && ! reg_set_p (reload_reg_rtx[r], PATTERN (insn)))\n \t\t{\n \t\t  register int nregno;\n \t\t  int nnr;\n \n-\t\t  if (GET_CODE (reload_in[r]) == REG)\n+\t\t  if (GET_CODE (reload_in[r]) == REG\n+\t\t      && REGNO (reload_in[r]) >= FIRST_PSEUDO_REGISTER)\n \t\t    nregno = REGNO (reload_in[r]);\n-\t\t  else\n+\t\t  else if (GET_CODE (reload_in_reg[r]) == REG)\n \t\t    nregno = REGNO (reload_in_reg[r]);\n+\t\t  else\n+\t\t    nregno = REGNO (XEXP (reload_in_reg[r], 0));\n \n \t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t : HARD_REGNO_NREGS (nregno,\n@@ -7363,8 +7713,11 @@ emit_reload_insns (chain)\n \t\t\t   : 0);\n \n \t\t  /* Unless we inherited this reload, show we haven't\n-\t\t     recently done a store.  */\n-\t\t  if (! reload_inherited[r])\n+\t\t     recently done a store.\n+\t\t     Previous stores of inherited auto_inc expressions\n+\t\t     also have to be discarded.  */\n+\t\t  if (! reload_inherited[r]\n+\t\t      || (reload_out[r] && ! reload_out_reg[r]))\n \t\t    spill_reg_store[i] = 0;\n \n \t\t  for (k = 0; k < nr; k++)\n@@ -7400,11 +7753,76 @@ emit_reload_insns (chain)\n \t that invalidates any previous reloaded copy of it.\n \t But forget_old_reloads_1 won't get to see it, because\n \t it thinks only about the original insn.  So invalidate it here.  */\n-      if (i < 0 && reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n+      if (i < 0 && reload_out[r] != 0\n+\t  && (GET_CODE (reload_out[r]) == REG\n+\t      || (GET_CODE (reload_out[r]) == MEM\n+\t\t  && GET_CODE (reload_out_reg[r]) == REG)))\n \t{\n-\t  register int nregno = REGNO (reload_out[r]);\n+\t  rtx out = (GET_CODE (reload_out[r]) == REG\n+\t\t     ? reload_out[r] : reload_out_reg[r]);\n+\t  register int nregno = REGNO (out);\n \t  if (nregno >= FIRST_PSEUDO_REGISTER)\n-\t    reg_last_reload_reg[nregno] = 0;\n+\t    {\n+\t      rtx src_reg, store_insn;\n+\n+\t      reg_last_reload_reg[nregno] = 0;\n+\n+\t      /* If we can find a hard register that is stored, record\n+\t\t the storing insn so that we may delete this insn with\n+\t\t delete_output_reload.  */\n+\t      src_reg = reload_reg_rtx[r];\n+\n+\t      /* If this is an optional reload, try to find the source reg\n+\t\t from an input reload.  */\n+\t      if (! src_reg)\n+\t\t{\n+\t\t  rtx set = single_set (insn);\n+\t\t  if (SET_DEST (set) == reload_out[r])\n+\t\t    {\n+\t\t      int k;\n+\n+\t\t      src_reg = SET_SRC (set);\n+\t\t      store_insn = insn;\n+\t\t      for (k = 0; k < n_reloads; k++)\n+\t\t\t{\n+\t\t\t  if (reload_in[k] == src_reg)\n+\t\t\t    {\n+\t\t\t      src_reg = reload_reg_rtx[k];\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tstore_insn = new_spill_reg_store[REGNO (src_reg)];\n+\t      if (src_reg && GET_CODE (src_reg) == REG\n+\t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  int src_regno = REGNO (src_reg);\n+\t\t  int nr = HARD_REGNO_NREGS (src_regno, reload_mode[r]);\n+\t\t  /* The place where to find a death note varies with\n+\t\t     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not\n+\t\t     necessarily checked exactly in the code that moves\n+\t\t     notes, so just check both locations.  */\n+\t\t  rtx note = find_regno_note (insn, REG_DEAD, src_regno);\n+\t\t  if (! note)\n+\t\t    note = find_regno_note (store_insn, REG_DEAD, src_regno);\n+\t\t  while (nr-- > 0)\n+\t\t    {\n+\t\t      spill_reg_store[src_regno + nr] = store_insn;\n+\t\t      spill_reg_stored_to[src_regno + nr] = out;\n+\t\t      reg_reloaded_contents[src_regno + nr] = nregno;\n+\t\t      reg_reloaded_insn[src_regno + nr] = store_insn;\n+\t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + nr);\n+\t\t      SET_HARD_REG_BIT (reg_is_output_reload, src_regno + nr);\n+\t\t      if (note)\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_died, src_regno);\n+\t\t      else\n+\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_died, src_regno);\n+\t\t    }\n+\t\t  reg_last_reload_reg[nregno] = src_reg;\n+\t\t}\n+\t    }\n \t  else\n \t    {\n \t      int num_regs = HARD_REGNO_NREGS (nregno,GET_MODE (reload_out[r]));\n@@ -7630,22 +8048,66 @@ gen_reload (out, in, opnum, type)\n    First we double-check.\n \n    INSN is the insn now being processed.\n-   OUTPUT_RELOAD_INSN is the insn of the output reload.\n-   J is the reload-number for this insn.  */\n+   LAST_RELOAD_REG is the hard register number for which we want to delete\n+   the last output reload.\n+   J is the reload-number that originally used REG.  The caller has made\n+   certain that reload J doesn't use REG any longer for input.  */\n \n static void\n-delete_output_reload (insn, j, output_reload_insn)\n+delete_output_reload (insn, j, last_reload_reg)\n      rtx insn;\n      int j;\n-     rtx output_reload_insn;\n+     int last_reload_reg;\n {\n+  rtx output_reload_insn = spill_reg_store[last_reload_reg];\n+  rtx reg = spill_reg_stored_to[last_reload_reg];\n+  int k;\n+  int n_occurrences;\n+  int n_inherited = 0;\n   register rtx i1;\n-\n+  rtx substed;\n+  \n   /* Get the raw pseudo-register referred to.  */\n \n-  rtx reg = reload_in[j];\n   while (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n+  substed = reg_equiv_memory_loc[REGNO (reg)];\n+\n+  /* This is unsafe if the operand occurs more often in the current\n+     insn than it is inherited.  */\n+  for (k = n_reloads - 1; k >= 0; k--)\n+    {\n+      rtx reg2 = reload_in[k];\n+      if (! reg2)\n+\tcontinue;\n+      if (GET_CODE (reg2) == MEM || reload_override_in[k])\n+\treg2 = reload_in_reg[k];\n+#ifdef AUTO_INC_DEC\n+      if (reload_out[k] && ! reload_out_reg[k])\n+\treg2 = XEXP (reload_in_reg[k], 0);\n+#endif\n+      while (GET_CODE (reg2) == SUBREG)\n+\treg2 = SUBREG_REG (reg2);\n+      if (rtx_equal_p (reg2, reg))\n+\tif (reload_inherited[k] || reload_override_in[k] || k == j)\n+\t  {\n+\t    n_inherited++;\n+\t    reg2 = reload_out_reg[k];\n+\t    if (! reg2)\n+\t      continue;\n+\t    while (GET_CODE (reg2) == SUBREG)\n+\t      reg2 = XEXP (reg2, 0);\n+\t    if (rtx_equal_p (reg2, reg))\n+\t      n_inherited++;\n+\t  }\n+\telse\n+\t  return;\n+    }\n+  n_occurrences = count_occurrences (PATTERN (insn), reg);\n+  if (substed)\n+    n_occurrences += count_occurrences (PATTERN (insn), substed);\n+  if (n_occurrences > n_inherited)\n+    return;\n \n   /* If the pseudo-reg we are reloading is no longer referenced\n      anywhere between the store into it and here,\n@@ -7660,21 +8122,14 @@ delete_output_reload (insn, j, output_reload_insn)\n       if ((GET_CODE (i1) == INSN || GET_CODE (i1) == CALL_INSN)\n \t  && reg_mentioned_p (reg, PATTERN (i1)))\n \t{\n-\t  /* If this is just a single USE with an REG_EQUAL note in front\n-\t     of INSN, this is no problem, because this mentions just the\n-\t     address that we are using here.\n-\t     But if there is more than one such USE, the insn might use\n-\t     the operand directly, or another reload might do that.\n-\t     This is analogous to the count_occurences check in the callers.  */\n-\t  int num_occurences = 0;\n-\n-\t  while (GET_CODE (i1) == INSN && GET_CODE (PATTERN (i1)) == USE\n-\t\t && find_reg_note (i1, REG_EQUAL, NULL_RTX))\n+\t  /* If this is USE in front of INSN, we only have to check that\n+\t     there are no more references than accounted for by inheritance.  */\n+\t  while (GET_CODE (i1) == INSN && GET_CODE (PATTERN (i1)) == USE)\n \t    {\n-\t      num_occurences += rtx_equal_p (reg, XEXP (PATTERN (i1), 0)) != 0;\n+\t      n_occurrences += rtx_equal_p (reg, XEXP (PATTERN (i1), 0)) != 0;\n \t      i1 = NEXT_INSN (i1);\n \t    }\n-\t  if (num_occurences == 1 && i1 == insn)\n+\t  if (n_occurrences <= n_inherited && i1 == insn)\n \t    break;\n \t  return;\n \t}\n@@ -7717,7 +8172,10 @@ delete_output_reload (insn, j, output_reload_insn)\n \t    {\n \t      /* Some other ref remains; just delete the output reload we\n \t\t know to be dead.  */\n-\t      delete_insn (output_reload_insn);\n+\t      delete_address_reloads (output_reload_insn, insn);\n+\t      PUT_CODE (output_reload_insn, NOTE);\n+\t      NOTE_SOURCE_FILE (output_reload_insn) = 0;\n+\t      NOTE_LINE_NUMBER (output_reload_insn) = NOTE_INSN_DELETED;\n \t      return;\n \t    }\n \t}\n@@ -7729,6 +8187,7 @@ delete_output_reload (insn, j, output_reload_insn)\n \n \t  if (set != 0 && SET_DEST (set) == reg)\n \t    {\n+\t      delete_address_reloads (i2, insn);\n \t      /* This might be a basic block head,\n \t\t thus don't use delete_insn.  */\n \t      PUT_CODE (i2, NOTE);\n@@ -7745,22 +8204,178 @@ delete_output_reload (insn, j, output_reload_insn)\n       reg_renumber[REGNO (reg)] = REGNO (reload_reg_rtx[j]);\n       alter_reg (REGNO (reg), -1);\n     }\n-  delete_insn (output_reload_insn);\n+  delete_address_reloads (output_reload_insn, insn);\n+  PUT_CODE (output_reload_insn, NOTE);\n+  NOTE_SOURCE_FILE (output_reload_insn) = 0;\n+  NOTE_LINE_NUMBER (output_reload_insn) = NOTE_INSN_DELETED;\n+\n+}\n \n+/* We are going to delete DEAD_INSN.  Recursively delete loads of\n+   reload registers used in DEAD_INSN that are not used till CURRENT_INSN.\n+   CURRENT_INSN is being reloaded, so we have to check its reloads too.  */\n+static void\n+delete_address_reloads (dead_insn, current_insn)\n+     rtx dead_insn, current_insn;\n+{\n+  rtx set = single_set (dead_insn);\n+  rtx set2, dst, prev, next;\n+  if (set)\n+    {\n+      rtx dst = SET_DEST (set);\n+      if (GET_CODE (dst) == MEM)\n+\tdelete_address_reloads_1 (dead_insn, XEXP (dst, 0), current_insn);\n+    }\n+  /* If we deleted the store from a reloaded post_{in,de}c expression,\n+     we can delete the matching adds.  */\n+  prev = PREV_INSN (dead_insn);\n+  next = NEXT_INSN (dead_insn);\n+  if (! prev || ! next)\n+    return;\n+  set = single_set (next);\n+  set2 = single_set (prev);\n+  if (! set || ! set2\n+      || GET_CODE (SET_SRC (set)) != PLUS || GET_CODE (SET_SRC (set2)) != PLUS\n+      || GET_CODE (XEXP (SET_SRC (set), 1)) != CONST_INT\n+      || GET_CODE (XEXP (SET_SRC (set2), 1)) != CONST_INT)\n+    return;\n+  dst = SET_DEST (set);\n+  if (! rtx_equal_p (dst, SET_DEST (set2))\n+      || ! rtx_equal_p (dst, XEXP (SET_SRC (set), 0))\n+      || ! rtx_equal_p (dst, XEXP (SET_SRC (set2), 0))\n+      || (INTVAL (XEXP (SET_SRC (set), 1))\n+\t  != - INTVAL (XEXP (SET_SRC (set2), 1))))\n+    return;\n+  delete_insn (prev);\n+  delete_insn (next);\n+}\n+\n+/* Subfunction of delete_address_reloads: process registers found in X.  */\n+static void\n+delete_address_reloads_1 (dead_insn, x, current_insn)\n+     rtx dead_insn, x, current_insn;\n+{\n+  rtx prev, set, dst, i2;\n+  int i, j;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  if (code != REG)\n+    {\n+      char *fmt= GET_RTX_FORMAT (code);\n+      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t{\n+\t  if (fmt[i] == 'e')\n+\t    delete_address_reloads_1 (dead_insn, XEXP (x, i), current_insn);\n+\t  else if (fmt[i] == 'E')\n+\t    {\n+\t      for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t\tdelete_address_reloads_1 (dead_insn, XVECEXP (x, i, j),\n+\t\t\t\t\t  current_insn);\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  if (spill_reg_order[REGNO (x)] < 0)\n+    return;\n+\n+  /* Scan backwards for the insn that sets x.  This might be a way back due\n+     to inheritance.  */\n+  for (prev = PREV_INSN (dead_insn); prev; prev = PREV_INSN (prev))\n+    {\n+      code = GET_CODE (prev);\n+      if (code == CODE_LABEL || code == JUMP_INSN)\n+\treturn;\n+      if (GET_RTX_CLASS (code) != 'i')\n+\tcontinue;\n+      if (reg_set_p (x, PATTERN (prev)))\n+\tbreak;\n+      if (reg_referenced_p (x, PATTERN (prev)))\n+\treturn;\n+    }\n+  if (! prev || INSN_UID (prev) < reload_first_uid)\n+    return;\n+  /* Check that PREV only sets the reload register.  */\n+  set = single_set (prev);\n+  if (! set)\n+    return;\n+  dst = SET_DEST (set);\n+  if (GET_CODE (dst) != REG\n+      || ! rtx_equal_p (dst, x))\n+    return;\n+  if (! reg_set_p (dst, PATTERN (dead_insn)))\n+    {\n+      /* Check if DST was used in a later insn -\n+\t it might have been inherited.  */\n+      for (i2 = NEXT_INSN (dead_insn); i2; i2 = NEXT_INSN (i2))\n+\t{\n+\t  if (GET_CODE (i2) == CODE_LABEL)\n+\t    break;\n+\t  if (GET_RTX_CLASS (GET_CODE (i2)) != 'i')\n+\t    continue;\n+\t  if (reg_referenced_p (dst, PATTERN (i2)))\n+\t    {\n+\t      /* If there is a reference to the register in the current insn,\n+\t\t it might be loaded in a non-inherited reload.  If no other\n+\t\t reload uses it, that means the register is set before\n+\t\t referenced.  */\n+\t      if (i2 == current_insn)\n+\t\t{\n+\t\t  for (j = n_reloads - 1; j >= 0; j--)\n+\t\t    if ((reload_reg_rtx[j] == dst && reload_inherited[j])\n+\t\t\t|| reload_override_in[j] == dst)\n+\t\t      return;\n+\t\t  for (j = n_reloads - 1; j >= 0; j--)\n+\t\t    if (reload_in[j] && reload_reg_rtx[j] == dst)\n+\t\t      break;\n+\t\t  if (j >= 0)\n+\t\t    break;\n+\t\t}\n+\t      return;\n+\t    }\n+\t  if (GET_CODE (i2) == JUMP_INSN)\n+\t    break;\n+\t  if (reg_set_p (dst, PATTERN (i2)))\n+\t    break;\n+\t  /* If DST is still live at CURRENT_INSN, check if it is used for\n+\t     any reload.  */\n+\t  if (i2 == current_insn)\n+\t    {\n+\t      for (j = n_reloads - 1; j >= 0; j--)\n+\t\tif ((reload_reg_rtx[j] == dst && reload_inherited[j])\n+\t\t    || reload_override_in[j] == dst)\n+\t\t  return;\n+\t      /* ??? We can't finish the loop here, because dst might be\n+\t\t allocated to a pseudo in this block if no reload in this\n+\t\t block needs any of the clsses containing DST - see\n+\t\t spill_hard_reg.  There is no easy way to tell this, so we\n+\t\t have to scan till the end of the basic block.  */\n+\t    }\n+\t}\n+    }\n+  delete_address_reloads_1 (prev, SET_SRC (set), current_insn);\n+  reg_reloaded_contents[REGNO (dst)] = -1;\n+  /* Can't use delete_insn here because PREV might be a basic block head.  */\n+  PUT_CODE (prev, NOTE);\n+  NOTE_LINE_NUMBER (prev) = NOTE_INSN_DELETED;\n+  NOTE_SOURCE_FILE (prev) = 0;\n }\n \f\n /* Output reload-insns to reload VALUE into RELOADREG.\n    VALUE is an autoincrement or autodecrement RTX whose operand\n    is a register or memory location;\n    so reloading involves incrementing that location.\n+   IN is either identical to VALUE, or some cheaper place to reload from.\n \n    INC_AMOUNT is the number to increment or decrement by (always positive).\n-   This cannot be deduced from VALUE.  */\n+   This cannot be deduced from VALUE.\n \n-static void\n-inc_for_reload (reloadreg, value, inc_amount)\n+   Return the instruction that stores into RELOADREG.  */\n+\n+static rtx\n+inc_for_reload (reloadreg, in, value, inc_amount)\n      rtx reloadreg;\n-     rtx value;\n+     rtx in, value;\n      int inc_amount;\n {\n   /* REG or MEM to be copied and incremented.  */\n@@ -7771,6 +8386,8 @@ inc_for_reload (reloadreg, value, inc_amount)\n   rtx inc;\n   rtx add_insn;\n   int code;\n+  rtx store;\n+  rtx real_in = in == value ? XEXP (in, 0) : in;\n \n   /* No hard register is equivalent to this register after\n      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,\n@@ -7785,46 +8402,49 @@ inc_for_reload (reloadreg, value, inc_amount)\n   inc = GEN_INT (inc_amount);\n \n   /* If this is post-increment, first copy the location to the reload reg.  */\n-  if (post)\n-    emit_insn (gen_move_insn (reloadreg, incloc));\n+  if (post && real_in != reloadreg)\n+    emit_insn (gen_move_insn (reloadreg, real_in));\n \n-  /* See if we can directly increment INCLOC.  Use a method similar to that\n-     in gen_reload.  */\n+  if (in == value)\n+    {\n+      /* See if we can directly increment INCLOC.  Use a method similar to\n+\t that in gen_reload.  */\n \n-  last = get_last_insn ();\n-  add_insn = emit_insn (gen_rtx_SET (VOIDmode, incloc,\n-\t\t\t\t     gen_rtx_PLUS (GET_MODE (incloc),\n-\t\t\t\t\t\t   incloc, inc)));\n+      last = get_last_insn ();\n+      add_insn = emit_insn (gen_rtx_SET (VOIDmode, incloc,\n+\t\t\t\t\t gen_rtx_PLUS (GET_MODE (incloc),\n+\t\t\t\t\t\t       incloc, inc)));\n \t\t\t\t\t\t\t  \n-  code = recog_memoized (add_insn);\n-  if (code >= 0)\n-    {\n-      insn_extract (add_insn);\n-      if (constrain_operands (code, 1))\n+      code = recog_memoized (add_insn);\n+      if (code >= 0)\n \t{\n-\t  /* If this is a pre-increment and we have incremented the value\n-\t     where it lives, copy the incremented value to RELOADREG to\n-\t     be used as an address.  */\n+\t  insn_extract (add_insn);\n+\t  if (constrain_operands (code, 1))\n+\t    {\n+\t      /* If this is a pre-increment and we have incremented the value\n+\t\t where it lives, copy the incremented value to RELOADREG to\n+\t\t be used as an address.  */\n \n-\t  if (! post)\n-\t    emit_insn (gen_move_insn (reloadreg, incloc));\n+\t      if (! post)\n+\t\temit_insn (gen_move_insn (reloadreg, incloc));\n \n-\t  return;\n+\t      return add_insn;\n+\t    }\n \t}\n+      delete_insns_since (last);\n     }\n \n-  delete_insns_since (last);\n-\n   /* If couldn't do the increment directly, must increment in RELOADREG.\n      The way we do this depends on whether this is pre- or post-increment.\n      For pre-increment, copy INCLOC to the reload register, increment it\n      there, then save back.  */\n \n   if (! post)\n     {\n-      emit_insn (gen_move_insn (reloadreg, incloc));\n+      if (in != reloadreg)\n+\temit_insn (gen_move_insn (reloadreg, real_in));\n       emit_insn (gen_add2_insn (reloadreg, inc));\n-      emit_insn (gen_move_insn (incloc, reloadreg));\n+      store = emit_insn (gen_move_insn (incloc, reloadreg));\n     }\n   else\n     {\n@@ -7833,16 +8453,16 @@ inc_for_reload (reloadreg, value, inc_amount)\n \t may not be available after the insn in an input reload, we must do\n \t the incrementation before the insn being reloaded for.\n \n-\t We have already copied INCLOC to RELOADREG.  Increment the copy in\n+\t We have already copied IN to RELOADREG.  Increment the copy in\n \t RELOADREG, save that back, then decrement RELOADREG so it has\n \t the original value.  */\n \n       emit_insn (gen_add2_insn (reloadreg, inc));\n-      emit_insn (gen_move_insn (incloc, reloadreg));\n+      store = emit_insn (gen_move_insn (incloc, reloadreg));\n       emit_insn (gen_add2_insn (reloadreg, GEN_INT (-inc_amount)));\n     }\n \n-  return;\n+  return store;\n }\n \f\n /* Return 1 if we are certain that the constraint-string STRING allows\n@@ -7921,6 +8541,10 @@ count_occurrences (x, find)\n     case CC0:\n       return 0;\n \n+    case MEM:\n+      if (GET_CODE (find) == MEM && rtx_equal_p (x, find))\n+\treturn 1;\n+      break;\n     case SET:\n       if (SET_DEST (x) == find)\n \treturn count_occurrences (SET_SRC (x), find);"}]}