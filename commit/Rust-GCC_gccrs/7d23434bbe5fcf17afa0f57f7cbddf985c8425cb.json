{"sha": "7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyMzQzNGJiZTVmY2YxN2FmYTBmNTdmN2NiZGRmOTg1Yzg0MjVjYg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-01-04T07:56:51Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-01-04T07:56:51Z"}, "message": "tree-vectorizer.c (vect_strip_conversions): New function.\n\n2005-01-03  Ira Rosen  <irar@il.ibm.com>\n\n        * tree-vectorizer.c (vect_strip_conversions): New function.\n        (vect_analyze_offset_expr): Call vect_strip_conversions. Add\n        check for binary class.\n\nFrom-SVN: r92888", "tree": {"sha": "f412c09bb335055c6da1ef6ff7193443453ec2a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f412c09bb335055c6da1ef6ff7193443453ec2a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1aae12a2d9286bedfc5a8b5d6c4fc828ef5d760a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aae12a2d9286bedfc5a8b5d6c4fc828ef5d760a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aae12a2d9286bedfc5a8b5d6c4fc828ef5d760a"}], "stats": {"total": 65, "additions": 50, "deletions": 15}, "files": [{"sha": "51d5225ef6be4d008542550799bf6a6d81cd00d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "patch": "@@ -1,3 +1,9 @@\n+2005-01-03  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_strip_conversions): New function.\n+\t(vect_analyze_offset_expr): Call vect_strip_conversions. Add\n+\tcheck for binary class.\t\n+\n 2005-01-03  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR debug/17924"}, {"sha": "d2333352df6272734acd290ab3367b9b4a874990", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d23434bbe5fcf17afa0f57f7cbddf985c8425cb/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=7d23434bbe5fcf17afa0f57f7cbddf985c8425cb", "patch": "@@ -230,6 +230,7 @@ static tree vect_get_memtag_and_dr\n   (tree, tree, bool, loop_vec_info, tree, struct data_reference **);\n static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n \t\t\t\t      tree *, tree *);\n+static tree vect_strip_conversion (tree);\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n@@ -1339,6 +1340,32 @@ vect_get_ptr_offset (tree ref ATTRIBUTE_UNUSED,\n }\n \n \n+/* Function vect_strip_conversions\n+\n+   Strip conversions that don't narrow the mode.  */\n+\n+static tree \n+vect_strip_conversion (tree expr)\n+{\n+  tree to, ti, oprnd0;\n+  \n+  while (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n+    {\n+      to = TREE_TYPE (expr);\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      ti = TREE_TYPE (oprnd0);\n+ \n+      if (!INTEGRAL_TYPE_P (to) || !INTEGRAL_TYPE_P (ti))\n+\treturn NULL_TREE;\n+      if (GET_MODE_SIZE (TYPE_MODE (to)) < GET_MODE_SIZE (TYPE_MODE (ti)))\n+\treturn NULL_TREE;\n+      \n+      expr = oprnd0;\n+    }\n+  return expr; \n+}\n+\n+\n /* Function vect_analyze_offset_expr\n \n    Given an offset expression EXPR received from get_inner_reference, analyze\n@@ -1391,22 +1418,10 @@ vect_analyze_offset_expr (tree expr,\n   tree init, evolution, def_stmt;\n \n   /* Strip conversions that don't narrow the mode.  */\n-  while (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n-    {\n-      tree to, ti;\n-\n-      to = TREE_TYPE (expr);\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      ti = TREE_TYPE (oprnd0);\n-\n-      if (!INTEGRAL_TYPE_P (to) || !INTEGRAL_TYPE_P (ti))\n-\treturn false;\n-      if (GET_MODE_SIZE (TYPE_MODE (to)) < GET_MODE_SIZE (TYPE_MODE (ti)))\n-\treturn false;\n+  expr = vect_strip_conversion (expr);\n+  if (!expr)\n+    return false;\n \n-      expr = oprnd0;\n-    }\n-  \n   *step = NULL_TREE;\n   *misalign = NULL_TREE;\n   *initial_offset = NULL_TREE;\n@@ -1463,6 +1478,16 @@ vect_analyze_offset_expr (tree expr,\n     }\n \n   /* Recursive computation.  */\n+  if (!BINARY_CLASS_P (expr))\n+    {\n+      /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n+      if (vect_debug_details (NULL))\n+        {\n+\t  fprintf (dump_file, \"Not binary expression \");\n+          print_generic_expr (dump_file, expr, TDF_SLIM);\n+\t}\n+      return false;\n+    }\n   oprnd0 = TREE_OPERAND (expr, 0);\n   oprnd1 = TREE_OPERAND (expr, 1);\n \n@@ -1483,6 +1508,10 @@ vect_analyze_offset_expr (tree expr,\n \t   FORNOW: We don't support such cases.  */\n \treturn false;\n \n+      /* Strip conversions that don't narrow the mode.  */\n+      left_offset = vect_strip_conversion (left_offset);      \n+      if (!left_offset)\n+\treturn false;      \n       /* Misalignment computation.  */\n       if (SSA_VAR_P (left_offset))\n \t{"}]}