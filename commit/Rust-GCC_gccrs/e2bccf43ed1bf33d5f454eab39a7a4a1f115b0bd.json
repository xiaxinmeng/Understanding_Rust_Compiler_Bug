{"sha": "e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "node_id": "C_kwDOANBUbNoAKGUyYmNjZjQzZWQxYmYzM2Q1ZjQ1NGVhYjM5YTdhNGExZjExNWIwYmQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-06T20:50:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-06T20:50:55Z"}, "message": "Merge #985\n\n985: Parse macro!(); as MacroInvocation with semicolon r=CohenArthur a=CohenArthur\n\nWhen parsing a macro invocation as a statement, the parser would parse\r\nan expression and then try parsing a semicolon. Since no actual\r\nlookahead was done (which is a good thing), we couldn't convert a\r\n`MacroInvocation` to a `MacroInvocationSemi` after the fact.\r\n\r\nSince, unlike function calls, macro invocations can act differently\r\nbased on whether or not they are followed by a semicolon, we actually\r\nneed to differentiate between the two up until expansion.\r\n\r\nThis commits adds a new virtual method for ExprWithoutBlock when\r\nconverting to ExprStmtWithoutBlock so that classes inheriting\r\nExprWithoutBlock can specify a new behavior. In the case of our\r\nMacroInvocation class, it simply means toggling a boolean: If we're\r\nconverting a macro from an expression to a statement, it must mean that\r\nit should contain a semicolon.\r\n\r\nCloses #941 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "6e9e933267fd6c651c59607668e2fa08641b8b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e9e933267fd6c651c59607668e2fa08641b8b9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiJR6vCRBK7hj4Ov3rIwAAIC8IADrH3g2wTM4Strx4p6sqocfY\nTTx0Fg/+IYL/lkeqfUFaytL91rvrrFLSRZylDpc37SIDz5za4fYsE9fIy0np/mGX\nRRh+n1JBf7gQ1NNLZZxpmbOdovMwweEKFKMO4NBexO06hqJkwPlKx2Gos6c3sTv1\nO+NZqeTDJ8i4Q1/qLADEwBXhM5dKy6Hy/0EJRgmGtA4A2cLm/iq1LJ7/HbnbppqV\nOor/b+gIyxbzVhnuEZC8Jmks7rcrw/qR+8q2X4fg/4ECf9OeO87+NtFJyzT1fK9p\nK43hikYvSbSq+dcPZsaVC0ll2EoG/pvSHbRc+KBrXcvuV9JPU59L0x33izOnljc=\n=aEGE\n-----END PGP SIGNATURE-----\n", "payload": "tree 6e9e933267fd6c651c59607668e2fa08641b8b9d\nparent d89c8ccf3237e66029125c0fe007297bb86eca74\nparent 58d1721529e99c7c633615e7491b777a6198ed00\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646599855 +0000\ncommitter GitHub <noreply@github.com> 1646599855 +0000\n\nMerge #985\n\n985: Parse macro!(); as MacroInvocation with semicolon r=CohenArthur a=CohenArthur\n\nWhen parsing a macro invocation as a statement, the parser would parse\r\nan expression and then try parsing a semicolon. Since no actual\r\nlookahead was done (which is a good thing), we couldn't convert a\r\n`MacroInvocation` to a `MacroInvocationSemi` after the fact.\r\n\r\nSince, unlike function calls, macro invocations can act differently\r\nbased on whether or not they are followed by a semicolon, we actually\r\nneed to differentiate between the two up until expansion.\r\n\r\nThis commits adds a new virtual method for ExprWithoutBlock when\r\nconverting to ExprStmtWithoutBlock so that classes inheriting\r\nExprWithoutBlock can specify a new behavior. In the case of our\r\nMacroInvocation class, it simply means toggling a boolean: If we're\r\nconverting a macro from an expression to a statement, it must mean that\r\nit should contain a semicolon.\r\n\r\nCloses #941 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89c8ccf3237e66029125c0fe007297bb86eca74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89c8ccf3237e66029125c0fe007297bb86eca74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89c8ccf3237e66029125c0fe007297bb86eca74"}, {"sha": "58d1721529e99c7c633615e7491b777a6198ed00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d1721529e99c7c633615e7491b777a6198ed00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d1721529e99c7c633615e7491b777a6198ed00"}], "stats": {"total": 354, "additions": 154, "deletions": 200}, "files": [{"sha": "f3af42e1595b9d9dd884cb62a595e34071e7429c", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -54,7 +54,6 @@ class MacroItem;\n class TraitItem;\n class InherentImplItem;\n class TraitImplItem;\n-class MacroInvocationSemi;\n struct Crate;\n class PathExpr;\n "}, {"sha": "826d41af658d122e324b439aad54092c816d984c", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -1275,18 +1275,6 @@ TypeAlias::as_string () const\n   return str;\n }\n \n-std::string\n-MacroInvocationSemi::as_string () const\n-{\n-  std::string str = \"MacroInvocationSemi: \";\n-\n-  str += append_attributes (outer_attrs, OUTER);\n-\n-  str += \"\\n\" + invoc_data.as_string ();\n-\n-  return str;\n-}\n-\n std::string\n ExternBlock::as_string () const\n {\n@@ -1377,6 +1365,9 @@ MacroInvocation::as_string () const\n \n   str += \"\\n \" + invoc_data.as_string ();\n \n+  str += \"\\n has semicolon: \";\n+  str += has_semicolon () ? \"true\" : \"false\";\n+\n   return str;\n }\n \n@@ -4921,12 +4912,6 @@ LifetimeParam::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-MacroInvocationSemi::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n PathInExpression::accept_vis (ASTVisitor &vis)\n {"}, {"sha": "d3383b45ddba1bc609ae06831e1b7f14e33a5767", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -52,7 +52,6 @@ class ASTVisitor\n   // virtual void visit(TraitItem& trait_item) = 0;\n   // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n   // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n-  virtual void visit (MacroInvocationSemi &macro) = 0;\n \n   // rust-path.h\n   virtual void visit (PathInExpression &path) = 0;"}, {"sha": "08ecd1858606109855426b69eb4f7a15458b57da", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 5, "deletions": 99, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -861,7 +861,9 @@ class Item : public Stmt\n   add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n-  bool is_item () const override final { return true; }\n+  // FIXME: ARTHUR: Is it okay to have removed that final? Is it *required*\n+  // behavior that we have items that can also be expressions?\n+  bool is_item () const override { return true; }\n \n protected:\n   // Clone function implementation as pure virtual method\n@@ -957,6 +959,8 @@ class ExprWithoutBlock : public Expr\n   {\n     return clone_expr_without_block_impl ();\n   }\n+\n+  virtual ExprWithoutBlock *to_stmt () const { return clone_expr_impl (); }\n };\n \n /* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n@@ -1630,104 +1634,6 @@ class ASTFragment\n   std::vector<SingleASTNode> &get_nodes () { return nodes; }\n };\n \n-/* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n- * invocation) */\n-class MacroInvocationSemi : public MacroItem,\n-\t\t\t    public TraitItem,\n-\t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem,\n-\t\t\t    public ExternalItem\n-{\n-  std::vector<Attribute> outer_attrs;\n-  MacroInvocData invoc_data;\n-  Location locus;\n-  NodeId node_id;\n-\n-  // this is the expanded macro\n-  ASTFragment fragment;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  MacroInvocationSemi (MacroInvocData invoc_data,\n-\t\t       std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n-      fragment (ASTFragment::create_empty ())\n-  {}\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  // Clones this macro invocation semi.\n-  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n-  {\n-    return std::unique_ptr<MacroInvocationSemi> (\n-      clone_macro_invocation_semi_impl ());\n-  }\n-\n-  void mark_for_strip () override { invoc_data.mark_for_strip (); }\n-  bool is_marked_for_strip () const override\n-  {\n-    return invoc_data.is_marked_for_strip ();\n-  }\n-\n-  // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n-  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n-\n-  Location get_locus () const override final { return locus; }\n-\n-  MacroInvocData &get_invoc_data () { return invoc_data; }\n-\n-  ASTFragment &get_fragment () { return fragment; }\n-\n-  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n-\n-  NodeId get_macro_node_id () const { return node_id; }\n-\n-protected:\n-  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n-  {\n-    return new MacroInvocationSemi (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_inherent_impl_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_trait_impl_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_trait_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_external_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-};\n-\n // A crate AST object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "567da0cb18c125aa6f06eb3faf2fdae1950f2b3f", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -28,7 +28,6 @@ namespace AST {\n // forward decls\n class BlockExpr;\n class TypePath;\n-class MacroInvocationSemi;\n \n // TODO: inline?\n /*struct AbiName {\n@@ -4306,7 +4305,6 @@ class ExternBlock : public VisItem\n \n // Replaced with forward decls - defined in \"rust-macro.h\"\n class MacroItem;\n-class MacroInvocationSemi;\n class MacroRulesDefinition;\n } // namespace AST\n } // namespace Rust"}, {"sha": "2b396248ec6ae3d953e6dc2866fa16358163a53e", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -27,7 +27,6 @@ namespace AST {\n \n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n-class MacroInvocationSemi;\n \n enum MacroFragSpec\n {\n@@ -454,6 +453,10 @@ class MacroRulesDefinition : public MacroItem\n  * compile time */\n class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n+\t\t\tpublic MacroItem,\n+\t\t\tpublic TraitItem,\n+\t\t\tpublic TraitImplItem,\n+\t\t\tpublic InherentImplItem,\n \t\t\tpublic ExprWithoutBlock\n {\n   std::vector<Attribute> outer_attrs;\n@@ -463,14 +466,22 @@ class MacroInvocation : public TypeNoBounds,\n   // this is the expanded macro\n   ASTFragment fragment;\n \n+  // Important for when we actually expand the macro\n+  bool is_semi_coloned;\n+\n+  NodeId node_id;\n+\n public:\n   std::string as_string () const override;\n \n   MacroInvocation (MacroInvocData invoc_data,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+\t\t   std::vector<Attribute> outer_attrs, Location locus,\n+\t\t   bool is_semi_coloned = false)\n     : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus),\n-      fragment (ASTFragment::create_empty ())\n+      fragment (ASTFragment::create_empty ()),\n+      is_semi_coloned (is_semi_coloned),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -497,12 +508,16 @@ class MacroInvocation : public TypeNoBounds,\n     return ExprWithoutBlock::get_node_id ();\n   }\n \n+  NodeId get_macro_node_id () const { return node_id; }\n+\n   MacroInvocData &get_invoc_data () { return invoc_data; }\n \n   ASTFragment &get_fragment () { return fragment; }\n \n   void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n \n+  bool has_semicolon () const { return is_semi_coloned; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -529,6 +544,37 @@ class MacroInvocation : public TypeNoBounds,\n   {\n     return new MacroInvocation (*this);\n   }\n+\n+  Item *clone_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  bool is_item () const override { return !has_semicolon (); }\n+\n+  TraitItem *clone_trait_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  TraitImplItem *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  InherentImplItem *clone_inherent_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  ExprWithoutBlock *to_stmt () const override\n+\n+  {\n+    auto new_impl = clone_macro_invocation_impl ();\n+    new_impl->is_semi_coloned = true;\n+\n+    return new_impl;\n+  }\n };\n \n // more generic meta item path-only form"}, {"sha": "942da7f4db5e86a5a0c188ab0dd53d73b2286baa", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -211,8 +211,9 @@ class ExprStmtWithoutBlock : public ExprStmt\n   std::string as_string () const override;\n \n   ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n-    : ExprStmt (locus), expr (std::move (expr))\n+    : ExprStmt (locus), expr (std::move (expr->to_stmt ()))\n   {}\n+\n   /*ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n     : ExprStmt (locus), expr (std::move (expr))\n   {}*/\n@@ -336,9 +337,6 @@ class ExprStmtWithBlock : public ExprStmt\n   }\n };\n \n-/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n- * rust-macro.h */\n-class MacroInvocationSemi;\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "26f584d253babd4d4b1713f027b27f6119f255ec", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -310,7 +310,8 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // supposedly does not require - cfg does nothing\n   }\n-  void visit (AST::MacroInvocationSemi &macro_invoc) override\n+\n+  void visit (AST::MacroInvocation &macro_invoc) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n@@ -326,9 +327,13 @@ class AttrVisitor : public AST::ASTVisitor\n \n     // TODO: maybe have cfg! macro stripping behaviour here?\n \n-    expander.expand_invoc_semi (macro_invoc);\n+    if (macro_invoc.has_semicolon ())\n+      expander.expand_invoc_semi (macro_invoc);\n+    else\n+      expander.expand_invoc (macro_invoc);\n \n-    // we need to visit the expanded fragments since it may need cfg expansion\n+    // we need to visit the expanded fragments since it may need cfg\n+    // expansion\n     // and it may be recursive\n     for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n       node.accept_vis (*this);\n@@ -2534,28 +2539,6 @@ class AttrVisitor : public AST::ASTVisitor\n     expander.mappings->insert_macro_def (&rules_def);\n   }\n \n-  void visit (AST::MacroInvocation &macro_invoc) override\n-  {\n-    // FIXME\n-    // we probably need another recurision check here\n-\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n-      {\n-\tmacro_invoc.mark_for_strip ();\n-\treturn;\n-      }\n-\n-    // I don't think any macro token trees can be stripped in any way\n-    expander.expand_invoc (macro_invoc);\n-\n-    // we need to visit the expanded fragments since it may need cfg expansion\n-    // and it may be recursive\n-    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::MetaItemPath &) override {}\n   void visit (AST::MetaItemSeq &) override {}\n   void visit (AST::MetaWord &) override {}\n@@ -3209,7 +3192,7 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n }\n \n void\n-MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n+MacroExpander::expand_invoc_semi (AST::MacroInvocation &invoc)\n {\n   if (depth_exceeds_recursion_limit ())\n     {"}, {"sha": "c56ece622241663e1b3b2a7fca0f88d40592eddb", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -146,11 +146,11 @@ struct MacroExpander\n   // Expands all macros in the crate passed in.\n   void expand_crate ();\n \n-  /* Expands a macro invocation (not macro invocation semi) - possibly make both\n+  /* Expands a macro invocation - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n   void expand_invoc (AST::MacroInvocation &invoc);\n-  void expand_invoc_semi (AST::MacroInvocationSemi &invoc);\n+  void expand_invoc_semi (AST::MacroInvocation &invoc);\n \n   // Expands a single declarative macro.\n   AST::ASTFragment expand_decl_macro (Location locus,"}, {"sha": "738ed58e3db8481f99a17d7e6ec3ea4408107221", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -56,7 +56,6 @@ class ASTLoweringBase : public AST::ASTVisitor\n   //  virtual void visit(TraitItem& trait_item) {}\n   //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n   //  virtual void visit(TraitImplItem& trait_impl_item) {}\n-  virtual void visit (AST::MacroInvocationSemi &macro) {}\n \n   // rust-path.h\n   virtual void visit (AST::PathInExpression &path) {}"}, {"sha": "3b901f600868e2ea813ff270dceb8e6680c3784d", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -52,8 +52,11 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n \n     // FIXME\n@@ -318,8 +321,11 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n \n     // FIXME"}, {"sha": "660a30cb6190fca4f77c31594b7d2db9290b0078", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -51,8 +51,11 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n \n     // FIXME"}, {"sha": "484c638c82ee9c3136b513852c0632a985232326", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -45,8 +45,11 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n \n     // FIXME"}, {"sha": "8559c3b92c7902357ffedc8a492dc5cd65da0470", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -1529,7 +1529,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (AST::AttrVec outer_attrs)\n \n // Parses a semi-coloned (except for full block) macro invocation item.\n template <typename ManagedTokenSource>\n-std::unique_ptr<AST::MacroInvocationSemi>\n+std::unique_ptr<AST::MacroInvocation>\n Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   AST::AttrVec outer_attrs)\n {\n@@ -1618,10 +1618,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \n-\t      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t      std::move (outer_attrs),\n-\t\t\t\t\t      macro_locus));\n+\t      return std::unique_ptr<AST::MacroInvocation> (\n+\t\tnew AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t\t  std::move (outer_attrs), macro_locus,\n+\t\t\t\t\t  true));\n \t    }\n \t}\n \n@@ -1630,9 +1630,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t\t  t->get_token_description (),\n \t\t  lexer.peek_token ()->get_token_description ());\n \n-      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t      std::move (outer_attrs), macro_locus));\n+      return std::unique_ptr<AST::MacroInvocation> (\n+\tnew AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t  std::move (outer_attrs), macro_locus, true));\n     }\n   else\n     {\n@@ -7200,7 +7200,11 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   // attempt to parse via parse_expr_without_block - seems to work\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n-  expr = parse_expr_without_block (std::move (outer_attrs));\n+\n+  auto restrictions = ParseRestrictions ();\n+  restrictions.expr_can_be_stmt = true;\n+\n+  expr = parse_expr_without_block (std::move (outer_attrs), restrictions);\n   if (expr == nullptr)\n     {\n       // expr is required, error\n@@ -7227,7 +7231,8 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n  * disambiguates). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithoutBlock>\n-Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_without_block (\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n {\n   /* Notes on types of expr without block:\n    *  - literal expr          tokens that are literals\n@@ -7298,7 +7303,8 @@ Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n \t/* HACK: piggyback on pratt parsed expr and abuse polymorphism to\n \t * essentially downcast */\n \n-\tstd::unique_ptr<AST::Expr> expr = parse_expr (std::move (outer_attrs));\n+\tstd::unique_ptr<AST::Expr> expr\n+\t  = parse_expr (std::move (outer_attrs), restrictions);\n \n \tif (expr == nullptr)\n \t  {\n@@ -11825,18 +11831,20 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t      {\n \t\tlexer.skip_token ();\n \n-\t\tstd::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t\t  new AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t\tstd::move (outer_attrs),\n-\t\t\t\t\t\tstmt_or_expr_loc));\n+\t\tstd::unique_ptr<AST::MacroInvocation> stmt (\n+\t\t  new AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t\t    stmt_or_expr_loc),\n+\t\t  true);\n \t\treturn ExprOrStmt (std::move (stmt));\n \t      }\n \n \t    // otherwise, create macro invocation\n \t    std::unique_ptr<AST::MacroInvocation> expr (\n \t      new AST::MacroInvocation (std::move (invoc_data),\n \t\t\t\t\tstd::move (outer_attrs),\n-\t\t\t\t\tstmt_or_expr_loc));\n+\t\t\t\t\tstmt_or_expr_loc),\n+\t      false);\n \t    return ExprOrStmt (std::move (expr));\n \t  }\n \telse\n@@ -12145,10 +12153,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \t{\n \t  lexer.skip_token ();\n \n-\t  std::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t    new AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t  std::move (outer_attrs),\n-\t\t\t\t\t  macro_locus));\n+\t  std::unique_ptr<AST::MacroInvocation> stmt (\n+\t    new AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t      std::move (outer_attrs), macro_locus),\n+\t    true);\n \t  return ExprOrStmt (std::move (stmt));\n \t}\n \n@@ -12430,7 +12438,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t  case EXCLAM:\n \t    // macro\n \t    return parse_macro_invocation_partial (std::move (path),\n-\t\t\t\t\t\t   std::move (outer_attrs));\n+\t\t\t\t\t\t   std::move (outer_attrs),\n+\t\t\t\t\t\t   restrictions);\n \t    case LEFT_CURLY: {\n \t      bool not_a_block\n \t\t= lexer.peek_token (1)->get_id () == IDENTIFIER\n@@ -14331,7 +14340,8 @@ Parser<ManagedTokenSource>::parse_function_call_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocation>\n Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n-  AST::PathInExpression path, AST::AttrVec outer_attrs)\n+  AST::PathInExpression path, AST::AttrVec outer_attrs,\n+  ParseRestrictions restrictions)\n {\n   // macro invocation\n   if (!skip_token (EXCLAM))\n@@ -14356,10 +14366,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n \n   Location macro_locus = converted_path.get_locus ();\n \n-  return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (AST::MacroInvocData (std::move (converted_path),\n-\t\t\t\t\t\t   std::move (tok_tree)),\n-\t\t\t      std::move (outer_attrs), macro_locus));\n+  return std::unique_ptr<AST::MacroInvocation> (new AST::MacroInvocation (\n+    AST::MacroInvocData (std::move (converted_path), std::move (tok_tree)),\n+    std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt));\n }\n \n /* Parses a struct expr struct with a path in expression already parsed (but not"}, {"sha": "b283197b2cc45d6357612bc7322e10dcce601a97", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -80,6 +80,7 @@ struct ParseRestrictions\n    * like struct exprs being parsed from a dereference. */\n   bool entered_from_unary = false;\n   bool expr_can_be_null = false;\n+  bool expr_can_be_stmt = false;\n };\n \n // Parser implementation for gccrs.\n@@ -157,7 +158,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TokenTree> parse_token_tree ();\n   std::unique_ptr<AST::MacroRulesDefinition>\n   parse_macro_rules_def (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::MacroInvocationSemi>\n+  std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation_semi (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation (AST::AttrVec outer_attrs);\n@@ -468,9 +469,9 @@ template <typename ManagedTokenSource> class Parser\n   parse_index_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> array_expr,\n \t\t    AST::AttrVec outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::MacroInvocation>\n-  parse_macro_invocation_partial (AST::PathInExpression path,\n-\t\t\t\t  AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroInvocation> parse_macro_invocation_partial (\n+    AST::PathInExpression path, AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::StructExprStruct>\n   parse_struct_expr_struct_partial (AST::PathInExpression path,\n \t\t\t\t    AST::AttrVec outer_attrs);\n@@ -490,7 +491,9 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::ExprWithBlock>\n   parse_expr_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t    ParseRestrictions restrictions\n+\t\t\t    = ParseRestrictions ());\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped)."}, {"sha": "eca9694da960b3706ca1f35c3a4397ded2b63c05", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -38,7 +38,6 @@ class ResolverBase : public AST::ASTVisitor\n   void visit (AST::IdentifierExpr &) {}\n   void visit (AST::Lifetime &) {}\n   void visit (AST::LifetimeParam &) {}\n-  void visit (AST::MacroInvocationSemi &) {}\n   void visit (AST::PathInExpression &) {}\n   void visit (AST::TypePathSegment &) {}\n   void visit (AST::TypePathSegmentGeneric &) {}"}, {"sha": "73933935e7504a8e9fd214afd330b1628f4552c2", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -49,8 +49,11 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())\n       node.accept_vis (*this);\n@@ -144,8 +147,11 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())\n       node.accept_vis (*this);\n@@ -254,8 +260,11 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())\n       node.accept_vis (*this);"}, {"sha": "2cb00065f0b1f296e17582533a696956194c62ad", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -45,8 +45,11 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())\n       node.accept_vis (*this);\n@@ -234,8 +237,11 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())\n       node.accept_vis (*this);"}, {"sha": "785f3dea29229f243aff07b268c36ca64a174d6a", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -44,8 +44,11 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n \n     for (auto &node : fragment.get_nodes ())"}, {"sha": "1f528fe9550929bde1245a04e3dab12a97f735a8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=e2bccf43ed1bf33d5f454eab39a7a4a1f115b0bd", "patch": "@@ -43,7 +43,7 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n+  void visit (AST::MacroInvocation &invoc) override\n   {\n     AST::ASTFragment &fragment = invoc.get_fragment ();\n     for (auto &node : fragment.get_nodes ())"}]}