{"sha": "7065e130e02c335c37f44874a83c4cbf59dfea89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA2NWUxMzBlMDJjMzM1YzM3ZjQ0ODc0YTgzYzRjYmY1OWRmZWE4OQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-02-14T07:38:20Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-02-14T07:38:20Z"}, "message": "c-lex.c (lex_number): Only warn traditionally for U suffix outside system macros.\n\n        * c-lex.c (lex_number): Only warn traditionally for U suffix\n        outside system macros.\n        * cppexp.c (parse_number): Similarly.\n        * cpplib.h (NODE_SYSHDR, cpp_sys_objmacro_p): New.\n        * cppmacro.c (struct cpp_macro): New member node.\n        (parse_args): Only warn about missing rest args if not\n        a system macro.\n        (funlike_invocation_p): Similarly for uninvoked funlike macros.\n        (cpp_sys_objmacro_p): New.\n        (_cpp_create_definition): Store the node with the macro defn.\n        Remember if the macro is defined in a system header.\n\nFrom-SVN: r39661", "tree": {"sha": "5dc2a18484a5feaa3e30f77dadcb35f5c4945fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dc2a18484a5feaa3e30f77dadcb35f5c4945fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7065e130e02c335c37f44874a83c4cbf59dfea89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7065e130e02c335c37f44874a83c4cbf59dfea89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7065e130e02c335c37f44874a83c4cbf59dfea89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7065e130e02c335c37f44874a83c4cbf59dfea89/comments", "author": null, "committer": null, "parents": [{"sha": "52682a1b7720c9f2d8528c3498631636f09ebd90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52682a1b7720c9f2d8528c3498631636f09ebd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52682a1b7720c9f2d8528c3498631636f09ebd90"}], "stats": {"total": 48, "additions": 42, "deletions": 6}, "files": [{"sha": "2566f27840441e55b3de025512635b720ffcec4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7065e130e02c335c37f44874a83c4cbf59dfea89", "patch": "@@ -1,3 +1,17 @@\n+2001-02-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * c-lex.c (lex_number): Only warn traditionally for U suffix\n+        outside system macros.\n+        * cppexp.c (parse_number): Similarly.\n+        * cpplib.h (NODE_SYSHDR, cpp_sys_objmacro_p): New.\n+        * cppmacro.c (struct cpp_macro): New member node.\n+        (parse_args): Only warn about missing rest args if not\n+        a system macro.\n+        (funlike_invocation_p): Similarly for uninvoked funlike macros.\n+        (cpp_sys_objmacro_p): New.\n+        (_cpp_create_definition): Store the node with the macro defn.\n+        Remember if the macro is defined in a system header.\n+\n 2001-02-13  DJ Delorie  <dj@redhat.com>\n \n \t* configure.in (check_languages): determine languages to check"}, {"sha": "c147648d1bbb6f7aaae706f77a69ff1aadd23529", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=7065e130e02c335c37f44874a83c4cbf59dfea89", "patch": "@@ -1225,7 +1225,8 @@ lex_number (str, len)\n \t  case 'f': case 'F':\n \t    if (fflag)\n \t      ERROR (\"more than one 'f' suffix on floating constant\");\n-\t    else if (warn_traditional && !in_system_header)\n+\t    else if (warn_traditional && !in_system_header\n+\t\t     && ! cpp_sys_objmacro_p (parse_in))\n \t      warning (\"traditional C rejects the 'f' suffix\");\n \n \t    fflag = 1;\n@@ -1234,7 +1235,8 @@ lex_number (str, len)\n \t  case 'l': case 'L':\n \t    if (lflag)\n \t      ERROR (\"more than one 'l' suffix on floating constant\");\n-\t    else if (warn_traditional && !in_system_header)\n+\t    else if (warn_traditional && !in_system_header\n+\t\t     && ! cpp_sys_objmacro_p (parse_in))\n \t      warning (\"traditional C rejects the 'l' suffix\");\n \n \t    lflag = 1;\n@@ -1309,7 +1311,8 @@ lex_number (str, len)\n \t    case 'u': case 'U':\n \t      if (spec_unsigned)\n \t\terror (\"two 'u' suffixes on integer constant\");\n-\t      else if (warn_traditional && !in_system_header)\n+\t      else if (warn_traditional && !in_system_header\n+\t\t       && ! cpp_sys_objmacro_p (parse_in))\n \t\twarning (\"traditional C rejects the 'u' suffix\");\n \n \t      spec_unsigned = 1;"}, {"sha": "6aa6d4b4dc3bb7f27da82a0f2a77be91145c48d4", "filename": "gcc/cppexp.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7065e130e02c335c37f44874a83c4cbf59dfea89", "patch": "@@ -203,7 +203,9 @@ parse_number (pfile, tok)\n \tgoto invalid_suffix;\n       op.unsignedp = sufftab[i].u;\n \n-      if (CPP_WTRADITIONAL (pfile) && sufftab[i].u)\n+      if (CPP_WTRADITIONAL (pfile)\n+\t  && sufftab[i].u\n+\t  && ! cpp_sys_objmacro_p (pfile))\n \tcpp_warning (pfile, \"traditional C rejects the `U' suffix\");\n       if (sufftab[i].l == 2 && CPP_OPTION (pfile, pedantic)\n \t  && ! CPP_OPTION (pfile, c99))"}, {"sha": "2b7a99da6ce4190f6d27a364cbfdd1572eb74df0", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=7065e130e02c335c37f44874a83c4cbf59dfea89", "patch": "@@ -604,6 +604,7 @@ extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *, int));\n extern void cpp_start_lookahead\t\tPARAMS ((cpp_reader *));\n extern void cpp_stop_lookahead\t\tPARAMS ((cpp_reader *, int));\n+extern int  cpp_sys_objmacro_p\t\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));"}, {"sha": "7a65e9725e592a2b8cc71abe2f3dac46adc92f03", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7065e130e02c335c37f44874a83c4cbf59dfea89/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=7065e130e02c335c37f44874a83c4cbf59dfea89", "patch": "@@ -44,6 +44,7 @@ struct cpp_macro\n   unsigned int fun_like : 1;\t/* If a function-like macro.  */\n   unsigned int variadic : 1;\t/* If a variadic macro.  */\n   unsigned int disabled : 1;\t/* If macro is disabled.  */\n+  unsigned int syshdr   : 1;\t/* If macro defined in system header.  */\n };\n \n typedef struct macro_arg macro_arg;\n@@ -562,7 +563,7 @@ parse_args (pfile, node)\n \n       if (argc + 1 == macro->paramc && macro->variadic)\n \t{\n-\t  if (CPP_PEDANTIC (pfile))\n+\t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n \t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n \t}\n       else\n@@ -616,7 +617,7 @@ funlike_invocation_p (pfile, node, list)\n \n   if (maybe_paren.type == CPP_OPEN_PAREN)\n     args = parse_args (pfile, node);\n-  else if (CPP_WTRADITIONAL (pfile))\n+  else if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n     cpp_warning (pfile,\n \t \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n \t\t node->name);\n@@ -995,6 +996,18 @@ cpp_get_token (pfile, token)\n     save_lookahead_token (pfile, token);\n }\n \n+/* Returns true if we're expanding an object-like macro that was\n+   defined in a system header.  Just checks the macro at the top of\n+   the stack.  Used for diagnostic suppression.  */\n+int\n+cpp_sys_objmacro_p (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_macro *macro = pfile->context->macro;\n+\n+  return macro && ! macro->fun_like && macro->syshdr;\n+}\n+\n /* Read each token in, until EOF.  Directives are transparently\n    processed.  */\n void\n@@ -1453,6 +1466,9 @@ _cpp_create_definition (pfile, node)\n \t\t     && macro->expansion[0].type == CPP_NAME\n \t\t     && macro->expansion[0].val.node == node);\n \n+  /* To suppress some diagnostics.  */\n+  macro->syshdr = pfile->buffer->sysp != 0;\n+\n   /* Commit the memory.  */\n   POOL_COMMIT (&pfile->macro_pool, macro->count * sizeof (cpp_token));\n "}]}