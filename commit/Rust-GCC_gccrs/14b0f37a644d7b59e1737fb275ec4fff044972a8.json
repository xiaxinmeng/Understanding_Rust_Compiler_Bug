{"sha": "14b0f37a644d7b59e1737fb275ec4fff044972a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiMGYzN2E2NDRkN2I1OWUxNzM3ZmIyNzVlYzRmZmYwNDQ5NzJhOA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-07T16:03:01Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-07T19:01:35Z"}, "message": "Clean up and virtualize the on-entry cache interface.\n\nCleanup/Virtualize the ssa_block_range class, and implement the current\nvector approach as a derived class.\nAllow memory allocation from the irange allocator obstack for easy freeing.\n\n\t* gimple-range-cache.cc (ssa_block_ranges): Virtualize.\n\t(sbr_vector): Renamed from ssa_block_cache.\n\t(sbr_vector::sbr_vector): Allocate from obstack abd initialize.\n\t(ssa_block_ranges::~ssa_block_ranges): Remove.\n\t(sbr_vector::set_bb_range): Use varying and undefined cached values.\n\t(ssa_block_ranges::set_bb_varying): Remove.\n\t(sbr_vector::get_bb_range): Adjust assert.\n\t(sbr_vector::bb_range_p): Adjust assert.\n\t(~block_range_cache): No freeing loop required.\n\t(block_range_cache::get_block_ranges): Remove.\n\t(block_range_cache::set_bb_range): Inline get_block_ranges.\n\t(block_range_cache::set_bb_varying): Remove.\n\t* gimple-range-cache.h (set_bb_varying): Remove prototype.\n\t* value-range.h (irange_allocator::get_memory): New.", "tree": {"sha": "82f00813ce65dafa682bc3f092f8e599af64968c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f00813ce65dafa682bc3f092f8e599af64968c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14b0f37a644d7b59e1737fb275ec4fff044972a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b0f37a644d7b59e1737fb275ec4fff044972a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14b0f37a644d7b59e1737fb275ec4fff044972a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b0f37a644d7b59e1737fb275ec4fff044972a8/comments", "author": null, "committer": null, "parents": [{"sha": "a7943ea96d6a076a06eb06bd71a2656e682b8a78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7943ea96d6a076a06eb06bd71a2656e682b8a78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7943ea96d6a076a06eb06bd71a2656e682b8a78"}], "stats": {"total": 175, "additions": 80, "deletions": 95}, "files": [{"sha": "60e5d66c52ddd8a1842a8835844f7b310ac9361a", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 71, "deletions": 94, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=14b0f37a644d7b59e1737fb275ec4fff044972a8", "patch": "@@ -125,85 +125,97 @@ non_null_ref::process_name (tree name)\n \n // -------------------------------------------------------------------------\n \n-// This class implements a cache of ranges indexed by basic block.  It\n-// represents all that is known about an SSA_NAME on entry to each\n-// block.  It caches a range-for-type varying range so it doesn't need\n-// to be reformed all the time.  If a range is ever always associated\n-// with a type, we can use that instead.  Whenever varying is being\n-// set for a block, the cache simply points to this cached one rather\n-// than create a new one each time.\n+// This class represents the API into a cache of ranges for an SSA_NAME.\n+// Routines must be implemented to set, get, and query if a value is set.\n \n class ssa_block_ranges\n {\n public:\n-  ssa_block_ranges (tree t, irange_allocator *allocator);\n-  ~ssa_block_ranges ();\n-\n-  void set_bb_range (const basic_block bb, const irange &r);\n-  void set_bb_varying (const basic_block bb);\n-  bool get_bb_range (irange &r, const basic_block bb);\n-  bool bb_range_p (const basic_block bb);\n+  virtual void set_bb_range (const basic_block bb, const irange &r) = 0;\n+  virtual bool get_bb_range (irange &r, const basic_block bb) = 0;\n+  virtual bool bb_range_p (const basic_block bb) = 0;\n \n   void dump(FILE *f);\n-private:\n-  vec<irange *> m_tab;\n-  irange *m_type_range;\n+};\n+\n+// Print the list of known ranges for file F in a nice format.\n+\n+void\n+ssa_block_ranges::dump (FILE *f)\n+{\n+  basic_block bb;\n+  int_range_max r;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    if (get_bb_range (r, bb))\n+      {\n+\tfprintf (f, \"BB%d  -> \", bb->index);\n+\tr.dump (f);\n+\tfprintf (f, \"\\n\");\n+      }\n+}\n+\n+// This class implements the range cache as a linear vector, indexed by BB.\n+// It caches a varying and undefined range which are used instead of\n+// allocating new ones each time.\n+\n+class sbr_vector : public ssa_block_ranges\n+{\n+public:\n+  sbr_vector (tree t, irange_allocator *allocator);\n+\n+  virtual void set_bb_range (const basic_block bb, const irange &r) OVERRIDE;\n+  virtual bool get_bb_range (irange &r, const basic_block bb) OVERRIDE;\n+  virtual bool bb_range_p (const basic_block bb) OVERRIDE;\n+protected:\n+  irange **m_tab;\t// Non growing vector.\n+  int m_tab_size;\n+  int_range<2> m_varying;\n+  int_range<2> m_undefined;\n   tree m_type;\n   irange_allocator *m_irange_allocator;\n };\n \n \n // Initialize a block cache for an ssa_name of type T.\n \n-ssa_block_ranges::ssa_block_ranges (tree t, irange_allocator *allocator)\n+sbr_vector::sbr_vector (tree t, irange_allocator *allocator)\n {\n   gcc_checking_assert (TYPE_P (t));\n   m_type = t;\n   m_irange_allocator = allocator;\n-\n-  m_tab.create (0);\n-  m_tab.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+  m_tab_size = last_basic_block_for_fn (cfun) + 1;\n+  m_tab = (irange **)allocator->get_memory (m_tab_size * sizeof (irange *));\n+  memset (m_tab, 0, m_tab_size * sizeof (irange *));\n \n   // Create the cached type range.\n-  m_type_range = m_irange_allocator->allocate (2);\n-  m_type_range->set_varying (t);\n-\n-  m_tab[ENTRY_BLOCK_PTR_FOR_FN (cfun)->index] = m_type_range;\n-}\n-\n-// Destruct block range.\n-\n-ssa_block_ranges::~ssa_block_ranges ()\n-{\n-  m_tab.release ();\n+  m_varying.set_varying (t);\n+  m_undefined.set_undefined ();\n }\n \n // Set the range for block BB to be R.\n \n void\n-ssa_block_ranges::set_bb_range (const basic_block bb, const irange &r)\n+sbr_vector::set_bb_range (const basic_block bb, const irange &r)\n {\n-  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n-  irange *m = m_irange_allocator->allocate (r);\n+  irange *m;\n+  gcc_checking_assert (bb->index < m_tab_size);\n+  if (r.varying_p ())\n+    m = &m_varying;\n+  else if (r.undefined_p ())\n+    m = &m_undefined;\n+  else\n+    m = m_irange_allocator->allocate (r);\n   m_tab[bb->index] = m;\n }\n \n-// Set the range for block BB to the range for the type.\n-\n-void\n-ssa_block_ranges::set_bb_varying (const basic_block bb)\n-{\n-  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n-  m_tab[bb->index] = m_type_range;\n-}\n-\n // Return the range associated with block BB in R.  Return false if\n // there is no range.\n \n bool\n-ssa_block_ranges::get_bb_range (irange &r, const basic_block bb)\n+sbr_vector::get_bb_range (irange &r, const basic_block bb)\n {\n-  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n+  gcc_checking_assert (bb->index < m_tab_size);\n   irange *m = m_tab[bb->index];\n   if (m)\n     {\n@@ -216,30 +228,12 @@ ssa_block_ranges::get_bb_range (irange &r, const basic_block bb)\n // Return true if a range is present.\n \n bool\n-ssa_block_ranges::bb_range_p (const basic_block bb)\n+sbr_vector::bb_range_p (const basic_block bb)\n {\n-  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n+  gcc_checking_assert (bb->index < m_tab_size);\n   return m_tab[bb->index] != NULL;\n }\n \n-\n-// Print the list of known ranges for file F in a nice format.\n-\n-void\n-ssa_block_ranges::dump (FILE *f)\n-{\n-  basic_block bb;\n-  int_range_max r;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    if (get_bb_range (r, bb))\n-      {\n-\tfprintf (f, \"BB%d  -> \", bb->index);\n-\tr.dump (f);\n-\tfprintf (f, \"\\n\");\n-      }\n-}\n-\n // -------------------------------------------------------------------------\n \n // Initialize the block cache.\n@@ -255,38 +249,36 @@ block_range_cache::block_range_cache ()\n \n block_range_cache::~block_range_cache ()\n {\n-  unsigned x;\n-  for (x = 0; x < m_ssa_ranges.length (); ++x)\n-    {\n-      if (m_ssa_ranges[x])\n-\tdelete m_ssa_ranges[x];\n-    }\n   delete m_irange_allocator;\n   // Release the vector itself.\n   m_ssa_ranges.release ();\n }\n \n-// Return a reference to the ssa_block_cache for NAME.  If it has not been\n-// accessed yet, allocate it first.\n+// Set the range for NAME on entry to block BB to R.\n+// If it has not been // accessed yet, allocate it first.\n \n-ssa_block_ranges &\n-block_range_cache::get_block_ranges (tree name)\n+void\n+block_range_cache::set_bb_range (tree name, const basic_block bb,\n+\t\t\t\t const irange &r)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_ssa_ranges.length ())\n     m_ssa_ranges.safe_grow_cleared (num_ssa_names + 1);\n \n   if (!m_ssa_ranges[v])\n-    m_ssa_ranges[v] = new ssa_block_ranges (TREE_TYPE (name),\n+    {\n+      void *r = m_irange_allocator->get_memory (sizeof (sbr_vector));\n+      m_ssa_ranges[v] = new (r) sbr_vector (TREE_TYPE (name),\n \t\t\t\t\t    m_irange_allocator);\n-  return *(m_ssa_ranges[v]);\n+    }\n+  m_ssa_ranges[v]->set_bb_range (bb, r);\n }\n \n \n // Return a pointer to the ssa_block_cache for NAME.  If it has not been\n // accessed yet, return NULL.\n \n-ssa_block_ranges *\n+inline ssa_block_ranges *\n block_range_cache::query_block_ranges (tree name)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n@@ -295,22 +287,7 @@ block_range_cache::query_block_ranges (tree name)\n   return m_ssa_ranges[v];\n }\n \n-// Set the range for NAME on entry to block BB to R.\n \n-void\n-block_range_cache::set_bb_range (tree name, const basic_block bb,\n-\t\t\t\t const irange &r)\n-{\n-  return get_block_ranges (name).set_bb_range (bb, r);\n-}\n-\n-// Set the range for NAME on entry to block BB to varying.\n-\n-void\n-block_range_cache::set_bb_varying (tree name, const basic_block bb)\n-{\n-  return get_block_ranges (name).set_bb_varying (bb);\n-}\n \n // Return the range for NAME on entry to BB in R.  Return true if there\n // is one."}, {"sha": "15e6d0c61c4206058e6516a8f74ecc3cdeb251aa", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=14b0f37a644d7b59e1737fb275ec4fff044972a8", "patch": "@@ -51,7 +51,6 @@ class block_range_cache\n   ~block_range_cache ();\n \n   void set_bb_range (tree name, const basic_block bb, const irange &r);\n-  void set_bb_varying (tree name, const basic_block bb);\n   bool get_bb_range (irange &r, tree name, const basic_block bb);\n   bool bb_range_p (tree name, const basic_block bb);\n "}, {"sha": "3e58dad4e900c772620301518d1ca9642fc2c771", "filename": "gcc/value-range.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b0f37a644d7b59e1737fb275ec4fff044972a8/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=14b0f37a644d7b59e1737fb275ec4fff044972a8", "patch": "@@ -639,6 +639,7 @@ class irange_allocator\n   // Return a copy of SRC with the minimum amount of sub-ranges needed\n   // to represent it.\n   irange *allocate (const irange &src);\n+  void *get_memory (unsigned num_bytes);\n private:\n   DISABLE_COPY_AND_ASSIGN (irange_allocator);\n   struct obstack m_obstack;\n@@ -656,6 +657,14 @@ irange_allocator::~irange_allocator ()\n   obstack_free (&m_obstack, NULL);\n }\n \n+// Provide a hunk of memory from the obstack\n+inline void *\n+irange_allocator::get_memory (unsigned num_bytes)\n+{\n+  void *r = obstack_alloc (&m_obstack, num_bytes);\n+  return r;\n+}\n+\n // Return a new range with NUM_PAIRS.\n \n inline irange *"}]}