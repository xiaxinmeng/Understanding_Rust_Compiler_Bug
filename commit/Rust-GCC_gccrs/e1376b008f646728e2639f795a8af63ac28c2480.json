{"sha": "e1376b008f646728e2639f795a8af63ac28c2480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzNzZiMDA4ZjY0NjcyOGUyNjM5Zjc5NWE4YWY2M2FjMjhjMjQ4MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-27T04:58:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-27T04:58:19Z"}, "message": "cp-tree.h (AGGR_INIT_VIA_CTOR_P): New macro.\n\n\t* cp-tree.h (AGGR_INIT_VIA_CTOR_P): New macro.\n\t* tree.c (build_cplus_new): Set it.\n\t* expr.c (cplus_expand_expr): Use it.\n\nFrom-SVN: r28915", "tree": {"sha": "87aeb110ffe300a105006b507f18cd0169cee5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87aeb110ffe300a105006b507f18cd0169cee5b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1376b008f646728e2639f795a8af63ac28c2480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1376b008f646728e2639f795a8af63ac28c2480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1376b008f646728e2639f795a8af63ac28c2480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1376b008f646728e2639f795a8af63ac28c2480/comments", "author": null, "committer": null, "parents": [{"sha": "078a76c8a059f7a0ff4db84234279e1b0e3ef770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078a76c8a059f7a0ff4db84234279e1b0e3ef770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078a76c8a059f7a0ff4db84234279e1b0e3ef770"}], "stats": {"total": 31, "additions": 26, "deletions": 5}, "files": [{"sha": "521710c31e9e4baa637321887fdbc7ecd156e6d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1376b008f646728e2639f795a8af63ac28c2480", "patch": "@@ -1,5 +1,9 @@\n 1999-08-26  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.def (AGGR_INIT_VIA_CTOR_P): New macro.\n+\t* tree.c (build_cplus_new): Set it.\n+\t* expr.c (cplus_expand_expr): Use it.\n+\n \t* decl.c (store_parm_decls): Reset immediate_size_expand.\n \t(finish_function): Likewise.\n \t"}, {"sha": "a9f4b291764b6331e9611d06965e32a0362463b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e1376b008f646728e2639f795a8af63ac28c2480", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n       LOCAL_BINDING_P (in CPLUS_BINDING)\n       ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n+      AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1528,6 +1529,10 @@ struct lang_decl\n #define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n #define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n+/* Nonzero if this AGGR_INIT_EXPR provides for initialization via a\n+   constructor call, rather than an ordinary function call.  */\n+#define AGGR_INIT_VIA_CTOR_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n /* The TYPE_MAIN_DECL for a class template type is a TYPE_DECL, not a\n    TEMPLATE_DECL.  This macro determines whether or not a given class\n    type is really a template type, as opposed to an instantiation or"}, {"sha": "373afe62dbc25d16e97a11df8432652af55a3c0e", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e1376b008f646728e2639f795a8af63ac28c2480", "patch": "@@ -154,9 +154,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t   initialization.  It is left here to show the choices that\n \t   exist for C++.  */\n \t   \n-\tif (TREE_CODE (func) == ADDR_EXPR\n-\t    && TREE_CODE (TREE_OPERAND (func, 0)) == FUNCTION_DECL\n-\t    && DECL_CONSTRUCTOR_P (TREE_OPERAND (func, 0)))\n+\tif (AGGR_INIT_VIA_CTOR_P (exp))\n \t  {\n \t    type = build_pointer_type (type);\n \t    /* Don't clobber a value that might be part of a default"}, {"sha": "68357c0ef171fab74e60358851bcd75f4d590ea8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1376b008f646728e2639f795a8af63ac28c2480/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e1376b008f646728e2639f795a8af63ac28c2480", "patch": "@@ -220,6 +220,7 @@ build_cplus_new (type, init)\n      tree type;\n      tree init;\n {\n+  tree fn;\n   tree slot;\n   tree rval;\n \n@@ -233,9 +234,22 @@ build_cplus_new (type, init)\n   slot = build (VAR_DECL, type);\n   DECL_ARTIFICIAL (slot) = 1;\n   layout_decl (slot, 0);\n-  rval = build (AGGR_INIT_EXPR, type,\n-\t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n+\n+  /* We split the CALL_EXPR into its function and its arguments here.\n+     Then, in expand_expr, we put them back together.  The reason for\n+     this is that this expression might be a default argument\n+     expression.  In that case, we need a new temporary every time the\n+     expression is used.  That's what break_out_target_exprs does; it\n+     replaces every AGGR_INIT_EXPR with a copy that uses a fresh\n+     temporary slot.  Then, expand_expr builds up a call-expression\n+     using the new slot.  */\n+  fn = TREE_OPERAND (init, 0);\n+  rval = build (AGGR_INIT_EXPR, type, fn, TREE_OPERAND (init, 1), slot);\n   TREE_SIDE_EFFECTS (rval) = 1;\n+  AGGR_INIT_VIA_CTOR_P (rval) \n+    = (TREE_CODE (fn) == ADDR_EXPR\n+       && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n+       && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0)));\n   rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (rval) = 1;\n "}]}