{"sha": "bcbaaba1a33590a2795a9e49228943466e360315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNiYWFiYTFhMzM1OTBhMjc5NWE5ZTQ5MjI4OTQzNDY2ZTM2MDMxNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:54:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:54:17Z"}, "message": "defaults.h (MAX_MOVE_MAX, [...]): Define if not defined.\n\ngcc/\n\t* defaults.h (MAX_MOVE_MAX, MIN_UNITS_PER_WORD): Define if not defined.\n\t* libgcc2.c (MIN_UNITS_PER_WORD): Delete.\n\t* hard-reg-set.h (target_hard_regs): Add x_no_caller_save_reg_set.\n\t(no_caller_save_reg_set): Redefine as a macro.\n\t* reload.h (target_reload): Add x_caller_save_initialized_p and\n\tx_regno_save_mode.\n\t(caller_save_initialized_p): Redefine as a macro.\n\t* caller-save.c (caller_save_initialized_p, no_caller_save_reg_set)\n\t(MAX_MOVE_MAX, MIN_UNITS_PER_WORD): Delete.\n\t(regno_save_mode): Redefine as a macro.\n\nFrom-SVN: r162095", "tree": {"sha": "5eb3ab86331c6edc711e274c6b449087603a4829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eb3ab86331c6edc711e274c6b449087603a4829"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcbaaba1a33590a2795a9e49228943466e360315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcbaaba1a33590a2795a9e49228943466e360315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcbaaba1a33590a2795a9e49228943466e360315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcbaaba1a33590a2795a9e49228943466e360315/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "462f85cedc8375e893fd1179f5ecab498085c78d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/462f85cedc8375e893fd1179f5ecab498085c78d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/462f85cedc8375e893fd1179f5ecab498085c78d"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "f9460379e64bb56cb2093c4d1b276dd8f703f1b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -1,3 +1,16 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* defaults.h (MAX_MOVE_MAX, MIN_UNITS_PER_WORD): Define if not defined.\n+\t* libgcc2.c (MIN_UNITS_PER_WORD): Delete.\n+\t* hard-reg-set.h (target_hard_regs): Add x_no_caller_save_reg_set.\n+\t(no_caller_save_reg_set): Redefine as a macro.\n+\t* reload.h (target_reload): Add x_caller_save_initialized_p and\n+\tx_regno_save_mode.\n+\t(caller_save_initialized_p): Redefine as a macro.\n+\t* caller-save.c (caller_save_initialized_p, no_caller_save_reg_set)\n+\t(MAX_MOVE_MAX, MIN_UNITS_PER_WORD): Delete.\n+\t(regno_save_mode): Redefine as a macro.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (expmed.o, target-globals.o): Depend on expmed.h."}, {"sha": "3bd41f244c9c562e3a4fc3eba999b81c19a03365", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -41,30 +41,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"ggc.h\"\n \n-/* True if caller-save has been initialized.  */\n-bool caller_save_initialized_p;\n-\n-/* Call used hard registers which can not be saved because there is no\n-   insn for this.  */\n-HARD_REG_SET no_caller_save_reg_set;\n-\n-#ifndef MAX_MOVE_MAX\n-#define MAX_MOVE_MAX MOVE_MAX\n-#endif\n-\n-#ifndef MIN_UNITS_PER_WORD\n-#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n-#endif\n-\n #define MOVE_MAX_WORDS (MOVE_MAX / UNITS_PER_WORD)\n \n-/* Modes for each hard register that we can save.  The smallest mode is wide\n-   enough to save the entire contents of the register.  When saving the\n-   register because it is live we first try to save in multi-register modes.\n-   If that is not possible the save is done one register at a time.  */\n-\n-static enum machine_mode\n-  regno_save_mode[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n+#define regno_save_mode \\\n+  (this_target_reload->x_regno_save_mode)\n \n /* For each hard register, a place on the stack where it can be saved,\n    if needed.  */"}, {"sha": "336f386edf0ce7a2919122751fc8cbecec3a7973", "filename": "gcc/defaults.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -1025,6 +1025,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define MOVE_MAX_PIECES   MOVE_MAX\n #endif\n \n+#ifndef MAX_MOVE_MAX\n+#define MAX_MOVE_MAX MOVE_MAX\n+#endif\n+\n+#ifndef MIN_UNITS_PER_WORD\n+#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n+#endif\n+\n #ifndef STACK_POINTER_OFFSET\n #define STACK_POINTER_OFFSET    0\n #endif"}, {"sha": "486a88a2ed84b9377cd97d372b345602c641e9a3", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -582,11 +582,6 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n-/* Call used hard registers which can not be saved because there is no\n-   insn for this.  */\n-\n-extern HARD_REG_SET no_caller_save_reg_set;\n-\n struct target_hard_regs {\n   /* Indexed by hard register number, contains 1 for registers\n      that are fixed use (stack pointer, pc, frame pointer, etc.;.\n@@ -622,6 +617,10 @@ struct target_hard_regs {\n      with the local stack frame are safe, but scant others.  */\n   HARD_REG_SET x_regs_invalidated_by_call;\n \n+  /* Call used hard registers which can not be saved because there is no\n+     insn for this.  */\n+  HARD_REG_SET x_no_caller_save_reg_set;\n+\n   /* Table of register numbers in the order in which to try to use them.  */\n   int x_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n \n@@ -674,6 +673,8 @@ extern struct target_hard_regs *this_target_hard_regs;\n   (this_target_hard_regs->x_call_fixed_reg_set)\n #define regs_invalidated_by_call \\\n   (this_target_hard_regs->x_regs_invalidated_by_call)\n+#define no_caller_save_reg_set \\\n+  (this_target_hard_regs->x_no_caller_save_reg_set)\n #define reg_alloc_order \\\n   (this_target_hard_regs->x_reg_alloc_order)\n #define inv_reg_alloc_order \\"}, {"sha": "02828e3f640908c656becc02eda4e975e0d8528d", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -36,10 +36,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define ATTRIBUTE_HIDDEN\n #endif\n \n-#ifndef MIN_UNITS_PER_WORD\n-#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n-#endif\n-\n /* Work out the largest \"word\" size that we can deal with on this target.  */\n #if MIN_UNITS_PER_WORD > 4\n # define LIBGCC2_MAX_UNITS_PER_WORD 8"}, {"sha": "16d52d95a5ce7e0cb292a5e749121273bdd0a272", "filename": "gcc/reload.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcbaaba1a33590a2795a9e49228943466e360315/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=bcbaaba1a33590a2795a9e49228943466e360315", "patch": "@@ -171,6 +171,17 @@ struct target_reload {\n      means that (MEM (MEM (REG n))) is also valid if (REG n) does not get\n      a hard register.  */\n   bool x_spill_indirect_levels;\n+\n+  /* True if caller-save has been reinitialized.  */\n+  bool x_caller_save_initialized_p;\n+\n+  /* Modes for each hard register that we can save.  The smallest mode is wide\n+     enough to save the entire contents of the register.  When saving the\n+     register because it is live we first try to save in multi-register modes.\n+     If that is not possible the save is done one register at a time.  */\n+  enum machine_mode (x_regno_save_mode\n+\t\t     [FIRST_PSEUDO_REGISTER]\n+\t\t     [MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1]);\n };\n \n extern struct target_reload default_target_reload;\n@@ -184,6 +195,8 @@ extern struct target_reload *this_target_reload;\n   (this_target_reload->x_indirect_symref_ok)\n #define double_reg_address_ok \\\n   (this_target_reload->x_double_reg_address_ok)\n+#define caller_save_initialized_p \\\n+  (this_target_reload->x_caller_save_initialized_p)\n \n extern GTY (()) VEC(rtx,gc) *reg_equiv_memory_loc_vec;\n extern rtx *reg_equiv_constant;\n@@ -377,9 +390,6 @@ extern void calculate_elim_costs_all_insns (void);\n /* Deallocate the reload register used by reload number R.  */\n extern void deallocate_reload_reg (int r);\n \n-/* True if caller-save has been reinitialized.  */\n-extern bool caller_save_initialized_p;\n-\n /* Functions in caller-save.c:  */\n \n /* Initialize for caller-save.  */"}]}