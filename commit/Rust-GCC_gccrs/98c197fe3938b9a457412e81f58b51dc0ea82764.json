{"sha": "98c197fe3938b9a457412e81f58b51dc0ea82764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMTk3ZmUzOTM4YjlhNDU3NDEyZTgxZjU4YjUxZGMwZWE4Mjc2NA==", "commit": {"author": {"name": "Bruce Korb", "email": "bkorb@gnu.org", "date": "2001-05-18T02:54:25Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2001-05-18T02:54:25Z"}, "message": "Upgrade to AutoGen 5 Template\n\nFrom-SVN: r42235", "tree": {"sha": "24cf25602ae9865e100a6d4cc5f823bc08e780db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cf25602ae9865e100a6d4cc5f823bc08e780db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c197fe3938b9a457412e81f58b51dc0ea82764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c197fe3938b9a457412e81f58b51dc0ea82764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c197fe3938b9a457412e81f58b51dc0ea82764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c197fe3938b9a457412e81f58b51dc0ea82764/comments", "author": {"login": "brkorb", "id": 1242936, "node_id": "MDQ6VXNlcjEyNDI5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1242936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brkorb", "html_url": "https://github.com/brkorb", "followers_url": "https://api.github.com/users/brkorb/followers", "following_url": "https://api.github.com/users/brkorb/following{/other_user}", "gists_url": "https://api.github.com/users/brkorb/gists{/gist_id}", "starred_url": "https://api.github.com/users/brkorb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brkorb/subscriptions", "organizations_url": "https://api.github.com/users/brkorb/orgs", "repos_url": "https://api.github.com/users/brkorb/repos", "events_url": "https://api.github.com/users/brkorb/events{/privacy}", "received_events_url": "https://api.github.com/users/brkorb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3eddceefef17ca298ed8e9297654096e86af190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3eddceefef17ca298ed8e9297654096e86af190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3eddceefef17ca298ed8e9297654096e86af190"}], "stats": {"total": 251, "additions": 131, "deletions": 120}, "files": [{"sha": "82642e844c8ee7f3296dfaab840d7d589e4da612", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98c197fe3938b9a457412e81f58b51dc0ea82764", "patch": "@@ -1,3 +1,8 @@\n+2001-05-17  Bruce Korb <bkorb@gnu.org>\n+\n+\t* fixinc/fixincl.tpl: rewritten as an AutoGen version 5 template\n+\t* fixinc/genfixes: emit a warning if AutoGen is out of date\n+\n 2001-05-17  Brendan Conoboy <blc@cygnus.com>\n \t    Bruce Korb <bkorb@gnu.org>\n "}, {"sha": "7aeb9cab6f1f7ae9acc87198ac9013f7fbb5dd3a", "filename": "gcc/fixinc/fixincl.tpl", "status": "modified", "additions": 118, "deletions": 120, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2Ffixinc%2Ffixincl.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2Ffixinc%2Ffixincl.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.tpl?ref=98c197fe3938b9a457412e81f58b51dc0ea82764", "patch": "@@ -1,4 +1,4 @@\n-[= autogen template -*- Mode: C -*-\n+[= AutoGen5 Template -*- Mode: C -*-\n x=fixincl.x =]\n /*\n  *  DO NOT EDIT THIS FILE - it has been generated\n@@ -7,171 +7,167 @@ x=fixincl.x =]\n  * files which are fixed to work correctly with ANSI C and placed in a\n  * directory that GNU C will search.\n  *\n- * This file contains [=_eval fix _count =] fixup descriptions.\n+ * This file contains [=(count \"fix\")=] fixup descriptions.\n  *\n  * See README for more information.\n  *\n  *  inclhack copyright (c) 1998, 1999, 2000, 2001\n  *  The Free Software Foundation, Inc.\n  *\n-[=_eval inclhack \"# *  \" _gpl=]\n+ [=(define re-ct 0) (define max-mach 0) (define ct 0)\n+   (define HACK \"\") (define Hack \"\")    (define tmp \"\")\n+   (gpl \"inclhack\" \" *  \")=]\n  */\n-[= _SETENV re_ct 0 =][= _SETENV max_mach 0 =][=\n+[=\n \n-_FOR fix =]\n+FOR fix =]\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description of [=hackname _cap=] fix\n+ *  Description of [=\n+    (set! Hack (string-capitalize! (get \"hackname\")))\n+    (set! HACK (string-upcase!     (get \"hackname\")))\n+    (. Hack)=] fix\n  */[=\n \n # Note that this is not just for debugging purposes, but in case\n   some C fix wishes to refer to the regexps it is paired with.\n   See commentary at the top of fixfixes.c.\n =]\n-#define [=hackname _up #_FIXIDX + #%-32s _printf=] [=_eval _index=]\n-tSCC z[=hackname _cap=]Name[] =\n-     [=hackname _krstr=];\n+#define [=(sprintf \"%-32s\" (string-append HACK \"_FIXIDX\"))=] [=(for-index)=]\n+tSCC z[=(. Hack)=]Name[] =\n+     \"[=hackname=]\";\n \n /*\n  *  File name selection pattern\n  */[=\n \n-  _IF files _exist=]\n-tSCC z[=hackname _cap=]List[] =\n-  \"[=_FOR files =]|[=files=][=/files=]|\";[=\n+  IF (exist? \"files\")=]\n+tSCC z[=(. Hack)=]List[] =\n+  \"[=FOR files =]|[=files=][=ENDFOR=]|\";[=\n \n-  _ELSE =]\n-#define z[=hackname _cap=]List (char*)NULL[=\n-  _ENDIF \"files _exist\" =]\n+  ELSE =]\n+#define z[=(. Hack)=]List (char*)NULL[=\n+  ENDIF (exist? \"files\") =]\n /*\n  *  Machine/OS name selection pattern\n  */[=\n \n-  _IF mach _exist=]\n-tSCC* apz[=hackname _cap=]Machs[] = {[=\n-    _SETENV this_mach 0 =][=\n+  IF (exist? \"mach\")=]\n+tSCC* apz[=(. Hack)=]Machs[] = {[=\n+    (set! ct 0) =][=\n \n-    _FOR mach =]\n-        [=mach _krstr=],[=\n-      _SETENV this_mach mach _len this_mach _env _val 5 + +\n-      =][= /mach=]\n+    FOR mach =]\n+        [=\n+      (set! tmp (get \"mach\"))\n+      (set! ct (+ ct (string-length tmp) 5))\n+      (kr-string tmp)=],[=\n+    ENDFOR=]\n         (const char*)NULL };[=\n \n-    _SETENV max_mach _mark this_mach _env _val max_mach _env _val _max =][=\n+    (if (> ct max-mach) (set! max-mach ct)) =][=\n \n-  _ELSE =]\n-#define apz[=hackname _cap=]Machs (const char**)NULL[=\n-  _ENDIF \"files _exist\" =][=\n+  ELSE =]\n+#define apz[=(. Hack)=]Machs (const char**)NULL[=\n+  ENDIF (exist? \"files\") =][=\n \n-  _IF select _exist=]\n+  IF (exist? \"select\")=]\n \n /*\n  *  content selection pattern - do fix if pattern found\n  */[=\n-    _FOR select =]\n-tSCC z[=hackname _cap=]Select[=_eval _index=][] =\n-       [=select _krstr=];[=\n-    /select =][=\n-  _ENDIF =][=\n+    FOR select =]\n+tSCC z[=(. Hack)=]Select[=(for-index)=][] =\n+       [=(kr-string (get \"select\"))=];[=\n+    ENDFOR select =][=\n+  ENDIF =][=\n \n-  _IF bypass _exist=]\n+  IF (exist? \"bypass\")=]\n \n /*\n  *  content bypass pattern - skip fix if pattern found\n  */[=\n-    _FOR bypass =]\n-tSCC z[=hackname _cap=]Bypass[=_eval _index=][] =\n-       [=bypass _krstr=];[=\n-    /bypass =][=\n-  _ENDIF =][=\n+    FOR bypass =]\n+tSCC z[=(. Hack)=]Bypass[=(for-index)=][] =\n+       [=(kr-string (get \"bypass\"))=];[=\n+    ENDFOR bypass =][=\n+  ENDIF =][=\n \n-  _IF test _exist=]\n+  IF (exist? \"test\")=]\n \n /*\n  *  perform the 'test' shell command - do fix on success\n  */[=\n-    _FOR test =]\n-tSCC z[=hackname _cap=]Test[=_eval _index=][] =\n-       [=test _krstr=];[=\n-    /test =][=\n-  _ENDIF =][=\n+    FOR test =]\n+tSCC z[=(. Hack)=]Test[=(for-index)=][] =\n+       [=(kr-string (get \"test\"))=];[=\n+    ENDFOR  =][=\n+  ENDIF     =][=\n \n-  _IF c_test _exist=]\n+  IF (exist? \"c_test\")=]\n \n /*\n  *  perform the C function call test\n  */[=\n-    _FOR c_test =]\n-tSCC z[=hackname _cap=]FTst[=_eval _index=][] = \"[=c_test=]\";[=\n-    /c_test =][=\n-  _ENDIF =][=\n+    FOR c_test =]\n+tSCC z[=(. Hack)=]FTst[=(for-index)=][] = \"[=c_test=]\";[=\n+    ENDFOR c_test =][=\n+  ENDIF =][=\n \n+  IF (set! ct (+ (count \"select\") (count \"bypass\") \n+              (count \"test\") (count \"c_test\")))\n \n-#  Build the array of test descriptions for this fix: =][=\n-\n-  _IF select  _exist\n-      bypass  _exist |\n-      test    _exist |\n-      c_test  _exist |\n+     (= ct 0)\n =]\n+#define [=(. HACK)=]_TEST_CT  0\n+#define a[=(. Hack)=]Tests   (tTestDesc*)NULL[=\n+  ELSE =]\n+\n+#define    [=(. HACK)=]_TEST_CT  [=(. ct)=][=\n+\t(set! re-ct (+ re-ct (count \"select\") (count \"bypass\"))) =]\n+static tTestDesc a[=(. Hack)=]Tests[] = {[=\n+\n+    FOR test =]\n+  { TT_TEST,     z[=(. Hack)=]Test[=(for-index)=],   0 /* unused */ },[=\n+    ENDFOR test =][=\n+\n+    FOR c_test =]\n+  { TT_FUNCTION, z[=(. Hack)=]FTst[=(for-index)=],   0 /* unused */ },[=\n+    ENDFOR c_test =][=\n+\n+    FOR bypass =]\n+  { TT_NEGREP,   z[=(. Hack)=]Bypass[=(for-index)=], (regex_t*)NULL },[=\n+    ENDFOR bypass =][=\n \n-#define    [=hackname _up =]_TEST_CT  [=\n-       _eval select       _count\n-             bypass       _count +\n-             test         _count + \n-             c_test       _count + =][=\n-_SETENV re_ct\n-\tre_ct _env _val\n-\tselect _count +\n-\tbypass _count + =]\n-static tTestDesc a[=hackname _cap=]Tests[] = {[=\n-\n-    _FOR test =]\n-  { TT_TEST,     z[=hackname _cap=]Test[=_eval _index=],   0 /* unused */ },[=\n-    /test =][=\n-\n-    _FOR c_test =]\n-  { TT_FUNCTION, z[=hackname _cap=]FTst[=_eval _index=],   0 /* unused */ },[=\n-    /c_test =][=\n-\n-    _FOR bypass =]\n-  { TT_NEGREP,   z[=hackname _cap=]Bypass[=_eval _index=], (regex_t*)NULL },[=\n-    /bypass =][=\n-\n-      _FOR select =]\n-  { TT_EGREP,    z[=hackname _cap=]Select[=_eval _index=], (regex_t*)NULL },[=\n-      /select =] };[=\n-  _ELSE =]\n-#define [=hackname _up=]_TEST_CT  0\n-#define a[=hackname _cap=]Tests   (tTestDesc*)NULL[=\n-  _ENDIF =]\n+    FOR select =]\n+  { TT_EGREP,    z[=(. Hack)=]Select[=(for-index)=], (regex_t*)NULL },[=\n+    ENDFOR select =] };[=\n+  ENDIF =]\n \n /*\n- *  Fix Command Arguments for [=hackname _cap=]\n+ *  Fix Command Arguments for [=(. Hack)=]\n  */\n-static const char* apz[=hackname _cap=]Patch[] = {[=\n-    _IF   sed         _exist =] \"sed\"[=\n-      _FOR sed=],\n-    \"-e\", [=sed _krstr=][=\n-      /sed=],[=\n+static const char* apz[=(. Hack)=]Patch[] = {[=\n+    IF   (exist? \"sed\")=] \"sed\"[=\n+      FOR sed=],\n+    \"-e\", [=(kr-string (get \"sed\"))=][=\n+      ENDFOR sed=],[=\n \n-    _ELIF shell       _exist =] \"sh\", \"-c\",\n-    [=shell _krstr=],[=\n+    ELIF (exist? \"shell\")=] \"sh\", \"-c\",\n+    [=(kr-string (get \"shell\"))=],[=\n \n-    _ELIF c_fix _exist =]\n-    [=\n-      c_fix _krstr=],[=\n+    ELIF (exist? \"c_fix\")=]\n+    [=(kr-string (get \"c_fix\"))=],[=\n \n-      _FOR c_fix_arg =]\n-    [=c_fix_arg _krstr=],[=\n-      /c_fix_arg =][=\n+      FOR c_fix_arg =]\n+    [=(kr-string (get \"c_fix_arg\"))=],[=\n+      ENDFOR c_fix_arg =][=\n \n-    _ELIF replace _len =]\n-[=replace _krstr=],[=\n+    ELIF (> (len \"replace\") 0) =]\n+[=(kr-string (get \"replace\"))=],[=\n \n-    _ENDIF=]\n+    ENDIF=]\n     (char*)NULL };\n-[=/fix=]\n+[=ENDFOR fix=]\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n@@ -181,25 +177,27 @@ static const char* apz[=hackname _cap=]Patch[] = {[=\n    We also must allow for the size of the target machine machine name.\n    This allows for a 79 byte machine name.  Better be enough.\n =]\n-#define REGEX_COUNT          [= _eval re_ct _env =]\n-#define MACH_LIST_SIZE_LIMIT [= _eval max_mach _env _val 128 + =]\n-#define FIX_COUNT            [= _eval fix _count =]\n+#define REGEX_COUNT          [= (. re-ct) =]\n+#define MACH_LIST_SIZE_LIMIT [= (+ 128 max-mach) =]\n+#define FIX_COUNT            [= (count \"fix\") =]\n \n tFixDesc fixDescList[ FIX_COUNT ] = {[=\n \n \n-_FOR fix \",\\n\" =]\n-  {  z[=hackname _cap=]Name,    z[=hackname _cap=]List,\n-     apz[=hackname _cap=]Machs,\n-     [=hackname  _up=]_TEST_CT, [=\n-       _IF not_machine _exist =]FD_MACH_IFNOT[=\n-       _ELSE                  =]FD_MACH_ONLY[=\n-       _ENDIF =][=\n-       _IF    shell    _exist =] | FD_SHELL_SCRIPT[=\n-       _ELIF  c_fix    _exist =] | FD_SUBROUTINE[=\n-       _ELIF  replace  _exist =] | FD_REPLACEMENT[=\n-       _ENDIF =],\n-     a[=hackname _cap=]Tests,   apz[=hackname _cap=]Patch, 0 }[=\n-\n-/fix=]\n+FOR fix \",\\n\" =][=\n+    (set! Hack (string-capitalize! (get \"hackname\")))\n+    (set! HACK (string-upcase!     (get \"hackname\"))) =]\n+  {  z[=(. Hack)=]Name,    z[=(. Hack)=]List,\n+     apz[=(. Hack)=]Machs,\n+     [=(. HACK)=]_TEST_CT, [=\n+       IF (exist? \"not_machine\") =]FD_MACH_IFNOT[=\n+       ELSE                      =]FD_MACH_ONLY[=\n+       ENDIF =][=\n+       IF    (exist? \"shell\")    =] | FD_SHELL_SCRIPT[=\n+       ELIF  (exist? \"c_fix\")    =] | FD_SUBROUTINE[=\n+       ELIF  (exist? \"replace\")  =] | FD_REPLACEMENT[=\n+       ENDIF =],\n+     a[=(. Hack)=]Tests,   apz[=(. Hack)=]Patch, 0 }[=\n+\n+ENDFOR =]\n };"}, {"sha": "d556de6a6ff69597db4fb28de78b1144e821ba69", "filename": "gcc/fixinc/genfixes", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2Ffixinc%2Fgenfixes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c197fe3938b9a457412e81f58b51dc0ea82764/gcc%2Ffixinc%2Fgenfixes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fgenfixes?ref=98c197fe3938b9a457412e81f58b51dc0ea82764", "patch": "@@ -66,6 +66,14 @@ fi\n AG=\"autogen $AG\"\n set -e\n \n+if [ -z \"`${AG} -v | fgrep 'Ver. 5.'`\" ]\n+then\n+  echo \"Your AutoGen is either out of date or not available\" >&2\n+  echo \"Please get AutoGen5 from ftp.gnu.org/gnu/autogen\" >&2\n+  touch $@\n+  exit 0\n+fi\n+\n case \"$1\" in\n fixincl.x | */fixincl.x )\n   if (${AG} --help > /dev/null 2>&1)"}]}