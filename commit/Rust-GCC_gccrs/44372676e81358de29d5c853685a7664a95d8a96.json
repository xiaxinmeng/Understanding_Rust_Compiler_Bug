{"sha": "44372676e81358de29d5c853685a7664a95d8a96", "node_id": "C_kwDOANBUbNoAKDQ0MzcyNjc2ZTgxMzU4ZGUyOWQ1Yzg1MzY4NWE3NjY0YTk1ZDhhOTY", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-29T01:09:14Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-29T01:11:28Z"}, "message": "Fix ICE in lsplit when built with -O3 -fno-guess-branch-probability [PR103793]\n\nno-guess-branch-probability option requires profile_count scaling with\ninitialized_p guard, use multiply instead of apply_scale, which will do\nthe right thing to undefined probabilities and will not cause unnecesary\nroundoff errors and precision info loss.\nAlso merge the missed part of r12-6086 of factor out function to avoid\nduplicate code.\n\nRegression testest pass on Power and X86.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/103793\n\t* tree-ssa-loop-split.c (fix_loop_bb_probability): New function.\n\t(split_loop): Use multiply to scale loop1's exit probability.\n\t(do_split_loop_on_cond): Call fix_loop_bb_probability.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/103793\n\t* gcc.dg/pr103793.c: New test.", "tree": {"sha": "0a4e76fdcad408ddebe415e5886fa65c5c7b1104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a4e76fdcad408ddebe415e5886fa65c5c7b1104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44372676e81358de29d5c853685a7664a95d8a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44372676e81358de29d5c853685a7664a95d8a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44372676e81358de29d5c853685a7664a95d8a96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44372676e81358de29d5c853685a7664a95d8a96/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "054e57e467b15677966f832b491b1584feb194ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054e57e467b15677966f832b491b1584feb194ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054e57e467b15677966f832b491b1584feb194ee"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "d7ed721c973fc3cc79699b96c9d0b7c2fcaa7514", "filename": "gcc/testsuite/gcc.dg/pr103793.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44372676e81358de29d5c853685a7664a95d8a96/gcc%2Ftestsuite%2Fgcc.dg%2Fpr103793.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44372676e81358de29d5c853685a7664a95d8a96/gcc%2Ftestsuite%2Fgcc.dg%2Fpr103793.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr103793.c?ref=44372676e81358de29d5c853685a7664a95d8a96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-guess-branch-probability\" } */\n+\n+extern void bar (void);\n+\n+void\n+foo (int x, int w)\n+{\n+  for (int y; y < w; y++)\n+    if (y < x)\n+      bar ();\n+}"}, {"sha": "3e1bbc84007f7a99ea62e18f3a0ddbc94d0c16f1", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44372676e81358de29d5c853685a7664a95d8a96/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44372676e81358de29d5c853685a7664a95d8a96/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=44372676e81358de29d5c853685a7664a95d8a96", "patch": "@@ -484,6 +484,39 @@ compute_new_first_bound (gimple_seq *stmts, class tree_niter_desc *niter,\n   return newend;\n }\n \n+/* Fix the two loop's bb count after split based on the split edge probability,\n+   don't adjust the bbs dominated by true branches of that loop to avoid\n+   dropping 1s down.  */\n+static void\n+fix_loop_bb_probability (class loop *loop1, class loop *loop2, edge true_edge,\n+\t\t\t edge false_edge)\n+{\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Proportion first loop's bb counts except those dominated by true\n+     branch to avoid drop 1s down.  */\n+  basic_block *bbs1, *bbs2;\n+  bbs1 = get_loop_body (loop1);\n+  unsigned j;\n+  for (j = 0; j < loop1->num_nodes; j++)\n+    if (bbs1[j] == loop1->latch\n+\t|| !dominated_by_p (CDI_DOMINATORS, bbs1[j], true_edge->dest))\n+      bbs1[j]->count\n+\t= bbs1[j]->count.apply_probability (true_edge->probability);\n+  free (bbs1);\n+\n+  /* Proportion second loop's bb counts except those dominated by false\n+     branch to avoid drop 1s down.  */\n+  basic_block bbi_copy = get_bb_copy (false_edge->dest);\n+  bbs2 = get_loop_body (loop2);\n+  for (j = 0; j < loop2->num_nodes; j++)\n+    if (bbs2[j] == loop2->latch\n+\t|| !dominated_by_p (CDI_DOMINATORS, bbs2[j], bbi_copy))\n+      bbs2[j]->count\n+\t= bbs2[j]->count.apply_probability (true_edge->probability.invert ());\n+  free (bbs2);\n+}\n+\n /* Checks if LOOP contains an conditional block whose condition\n    depends on which side in the iteration space it is, and if so\n    splits the iteration space into two loops.  Returns true if the\n@@ -610,38 +643,14 @@ split_loop (class loop *loop1)\n \ttree guard_next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop1));\n \tpatch_loop_exit (loop1, guard_stmt, guard_next, newend, initial_true);\n \n-\tupdate_ssa (TODO_update_ssa);\n-\n-\t/* Proportion first loop's bb counts except those dominated by true\n-\t   branch to avoid drop 1s down.  */\n-\tbasic_block *bbs1, *bbs2;\n-\tbbs1 = get_loop_body (loop1);\n-\tunsigned j;\n-\tfor (j = 0; j < loop1->num_nodes; j++)\n-\t  if (bbs1[j] == loop1->latch\n-\t      || !dominated_by_p (CDI_DOMINATORS, bbs1[j], true_edge->dest))\n-\t    bbs1[j]->count\n-\t      = bbs1[j]->count.apply_probability (true_edge->probability);\n-\tfree (bbs1);\n+\tfix_loop_bb_probability (loop1, loop2, true_edge, false_edge);\n \n \t/* Fix first loop's exit probability after scaling.  */\n \tedge exit_to_latch1 = single_pred_edge (loop1->latch);\n-\texit_to_latch1->probability = exit_to_latch1->probability.apply_scale (\n-\t  true_edge->probability.to_reg_br_prob_base (), REG_BR_PROB_BASE);\n+\texit_to_latch1->probability *= true_edge->probability;\n \tsingle_exit (loop1)->probability\n \t  = exit_to_latch1->probability.invert ();\n \n-\t/* Proportion second loop's bb counts except those dominated by false\n-\t   branch to avoid drop 1s down.  */\n-\tbasic_block bbi_copy = get_bb_copy (false_edge->dest);\n-\tbbs2 = get_loop_body (loop2);\n-\tfor (j = 0; j < loop2->num_nodes; j++)\n-\t  if (bbs2[j] == loop2->latch\n-\t      || !dominated_by_p (CDI_DOMINATORS, bbs2[j], bbi_copy))\n-\t    bbs2[j]->count = bbs2[j]->count.apply_probability (\n-\t      true_edge->probability.invert ());\n-\tfree (bbs2);\n-\n \t/* Finally patch out the two copies of the condition to be always\n \t   true/false (or opposite).  */\n \tgcond *force_true = as_a<gcond *> (last_stmt (bbs[i]));\n@@ -1570,40 +1579,17 @@ do_split_loop_on_cond (struct loop *loop1, edge invar_branch)\n      between loop1 and loop2.  */\n   connect_loop_phis (loop1, loop2, to_loop2);\n \n-  update_ssa (TODO_update_ssa);\n-\n   edge true_edge, false_edge, skip_edge1, skip_edge2;\n   extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n \n-  /* Proportion first loop's bb counts except those dominated by true\n-     branch to avoid drop 1s down.  */\n   skip_edge1 = true_invar ? false_edge : true_edge;\n   skip_edge2 = true_invar ? true_edge : false_edge;\n-  basic_block *bbs1, *bbs2;\n-  bbs1 = get_loop_body (loop1);\n-  unsigned j;\n-  for (j = 0; j < loop1->num_nodes; j++)\n-    if (bbs1[j] == loop1->latch\n-\t|| !dominated_by_p (CDI_DOMINATORS, bbs1[j], skip_edge1->dest))\n-      bbs1[j]->count\n-\t= bbs1[j]->count.apply_probability (skip_edge1->probability);\n-  free (bbs1);\n+  fix_loop_bb_probability (loop1, loop2, skip_edge1, skip_edge2);\n \n   /* Fix first loop's exit probability after scaling.  */\n   to_loop1->probability = invar_branch->probability.invert ();\n   to_loop2->probability = invar_branch->probability;\n \n-  /* Proportion second loop's bb counts except those dominated by false\n-     branch to avoid drop 1s down.  */\n-  basic_block bbi_copy = get_bb_copy (skip_edge2->dest);\n-  bbs2 = get_loop_body (loop2);\n-  for (j = 0; j < loop2->num_nodes; j++)\n-    if (bbs2[j] == loop2->latch\n-\t|| !dominated_by_p (CDI_DOMINATORS, bbs2[j], bbi_copy))\n-      bbs2[j]->count\n-\t= bbs2[j]->count.apply_probability (skip_edge2->probability);\n-  free (bbs2);\n-\n   free_original_copy_tables ();\n \n   return true;"}]}