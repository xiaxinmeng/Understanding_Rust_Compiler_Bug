{"sha": "74b846e0def7675566fc4dd849b01372d839a36c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRiODQ2ZTBkZWY3Njc1NTY2ZmM0ZGQ4NDliMDEzNzJkODM5YTM2Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-12T18:47:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-12T18:47:52Z"}, "message": "cp-tree.h (scope_kind): New type.\n\n\t* cp-tree.h (scope_kind): New type.\n\t(tmpl_spec_kind): Likewise.\n\t(declare_pseudo_global_level): Remove.\n\t(pseudo_global_level_p): Rename to template_parm_scope_p.\n\t(pushlevel): Remove declaration.\n\t(begin_scope): New function.\n\t(finish_scope): Likewise.\n\t(current_tmpl_spec_kind): Likewise.\n\t* decl.c (struct binding_level): Shorten parm_flag to 2 bits.\n\tShorten keep to 2 bits.  Rename pseudo_global to template_parms_p.\n\tAdd template_spec_p.\n\t(toplevel_bindings_p): Adjust.\n\t(declare_pseudo_global_level): Remove.\n\t(pseudo_global_level_p): Rename to template_parm_scope_p.\n\t(current_tmpl_spec_kind): New function.\n\t(begin_scope): Likewise.\n\t(finish_scope): Likewise.\n\t(maybe_push_to_top_level): Adjust.\n\t(maybe_process_template_type_declaration): Likewise.\n\t(pushtag): Likewise.\n\t(pushdecl_nonclass_level): Likewise.\n\t(lookup_tag): Likewise.\n\t(grokfndecl): Handle member template specializations.  Share\n\tconstructor and non-constructor code.\n\t* decl2.c (check_classfn): Handle member template specializations.\n\t* pt.c (begin_template_parm_list): Use begin_scope.\n\t(begin_specialization): Likewise.\n\t(end_specialization): Likewise.\n\t(check_explicit_specialization): Use current_tmpl_spec_kind.\n\tHandle member template specializations.\n\t(end_template_decl): Use finish_scope.  Remove call to\n\tget_pending_sizes.\n\t(push_template_decl_real): Remove bogus error message.\n\t(tsubst_decl): Fix typo in code contained in comment.\n\t(instantiate_template): Handle member template specializations.\n\t(most_general_template): Likewise.\n\nFrom-SVN: r32494", "tree": {"sha": "cc6c6ee272891ffacecf2646e5035c7b822cdff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc6c6ee272891ffacecf2646e5035c7b822cdff4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74b846e0def7675566fc4dd849b01372d839a36c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b846e0def7675566fc4dd849b01372d839a36c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b846e0def7675566fc4dd849b01372d839a36c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b846e0def7675566fc4dd849b01372d839a36c/comments", "author": null, "committer": null, "parents": [{"sha": "d45371489682747db260202e5dd90debf0de37cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45371489682747db260202e5dd90debf0de37cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45371489682747db260202e5dd90debf0de37cd"}], "stats": {"total": 642, "additions": 409, "deletions": 233}, "files": [{"sha": "0e4812c607396f088223228d0211ef754621bf27", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -1,3 +1,42 @@\n+2000-03-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (scope_kind): New type.\n+\t(tmpl_spec_kind): Likewise.\n+\t(declare_pseudo_global_level): Remove.\n+\t(pseudo_global_level_p): Rename to template_parm_scope_p.\n+\t(pushlevel): Remove declaration.\n+\t(begin_scope): New function.\n+\t(finish_scope): Likewise.\n+\t(current_tmpl_spec_kind): Likewise.\n+\t* decl.c (struct binding_level): Shorten parm_flag to 2 bits.\n+\tShorten keep to 2 bits.  Rename pseudo_global to template_parms_p.\n+\tAdd template_spec_p.\n+\t(toplevel_bindings_p): Adjust.\n+\t(declare_pseudo_global_level): Remove.\n+\t(pseudo_global_level_p): Rename to template_parm_scope_p.\n+\t(current_tmpl_spec_kind): New function.\n+\t(begin_scope): Likewise.\n+\t(finish_scope): Likewise.\n+\t(maybe_push_to_top_level): Adjust.\n+\t(maybe_process_template_type_declaration): Likewise.\n+\t(pushtag): Likewise.\n+\t(pushdecl_nonclass_level): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(grokfndecl): Handle member template specializations.  Share\n+\tconstructor and non-constructor code.\n+\t* decl2.c (check_classfn): Handle member template specializations.\n+\t* pt.c (begin_template_parm_list): Use begin_scope.\n+\t(begin_specialization): Likewise.\n+\t(end_specialization): Likewise.\n+\t(check_explicit_specialization): Use current_tmpl_spec_kind.\n+\tHandle member template specializations.\n+\t(end_template_decl): Use finish_scope.  Remove call to\n+\tget_pending_sizes.\n+\t(push_template_decl_real): Remove bogus error message.\n+\t(tsubst_decl): Fix typo in code contained in comment.\n+\t(instantiate_template): Handle member template specializations.\n+\t(most_general_template): Likewise.\n+\t\n 2000-03-11  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* lex.c (whitespace_cr): Compress consecutive calls to warning()."}, {"sha": "28f67c072f0777855ed7a243703078631f7146ec", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -3043,6 +3043,32 @@ typedef enum cp_lvalue_kind {\n   clk_bitfield = 4, /* An lvalue for a bit-field.  */\n } cp_lvalue_kind;\n \n+/* The kinds of scopes we recognize.  */\n+typedef enum scope_kind {\n+  sk_template_parms, /* A scope for template parameters.  */\n+  sk_template_spec   /* A scope corresponding to a template\n+\t\t\tspecialization.  There is never anything in\n+\t\t\tthis scope.  */\n+} scope_kind;\n+\n+/* Various kinds of template specialization, instantiation, etc.  */\n+typedef enum tmpl_spec_kind {\n+  tsk_none,                /* Not a template at all.  */\n+  tsk_invalid_member_spec, /* An explicit member template\n+\t\t\t      specialization, but the enclosing\n+\t\t\t      classes have not all been explicitly\n+\t\t\t      specialized.  */\n+  tsk_invalid_expl_inst,   /* An explicit instantiation containing\n+\t\t\t      template parameter lists.  */\n+  tsk_excessive_parms,     /* A template declaration with too many\n+\t\t\t      template parameter lists.  */\n+  tsk_insufficient_parms,  /* A template declaration with too few\n+\t\t\t      parameter lists.  */\n+  tsk_template,            /* A template declaration.  */\n+  tsk_expl_spec,           /* An explicit specialization.  */\n+  tsk_expl_inst            /* An explicit instantiation.  */\n+} tmpl_spec_kind;\n+\n /* Zero means prototype weakly, as in ANSI C (no args means nothing).\n    Each language context defines how this variable should be set.  */\n extern int strict_prototype;\n@@ -3682,10 +3708,10 @@ extern int toplevel_bindings_p\t\t\tPARAMS ((void));\n extern int namespace_bindings_p\t\t\tPARAMS ((void));\n extern void keep_next_level\t\t\tPARAMS ((int));\n extern int kept_level_p\t\t\t\tPARAMS ((void));\n-extern void declare_pseudo_global_level\t\tPARAMS ((void));\n-extern int pseudo_global_level_p\t\tPARAMS ((void));\n+extern int template_parm_scope_p\t\tPARAMS ((void));\n extern void set_class_shadows\t\t\tPARAMS ((tree));\n-extern void pushlevel\t\t\t\tPARAMS ((int));\n+extern void begin_scope                         PARAMS ((scope_kind));\n+extern void finish_scope                        PARAMS ((void));\n extern void note_level_for_for\t\t\tPARAMS ((void));\n extern void resume_level\t\t\tPARAMS ((struct binding_level *));\n extern void delete_block\t\t\tPARAMS ((tree));\n@@ -3832,6 +3858,7 @@ extern int local_variable_p                     PARAMS ((tree));\n extern int nonstatic_local_decl_p               PARAMS ((tree));\n extern tree declare_global_var                  PARAMS ((tree, tree));\n extern void register_dtor_fn                    PARAMS ((tree));\n+extern tmpl_spec_kind current_tmpl_spec_kind    PARAMS ((int));\n \n /* in decl2.c */\n extern void init_decl2\t\t\t\tPARAMS ((void));"}, {"sha": "5b6e6a9d8f67b148fbb938654443655f4138a83b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 211, "deletions": 133, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -456,13 +456,12 @@ struct binding_level\n     tree dead_vars_from_for;\n \n     /* 1 for the level that holds the parameters of a function.\n-       2 for the level that holds a class declaration.\n-       3 for levels that hold parameter declarations.  */\n-    unsigned parm_flag : 4;\n+       2 for the level that holds a class declaration.  */\n+    unsigned parm_flag : 2;\n \n     /* 1 means make a BLOCK for this level regardless of all else.\n        2 for temporary binding contours created by the compiler.  */\n-    unsigned keep : 3;\n+    unsigned keep : 2;\n \n     /* Nonzero if this level \"doesn't exist\" for tags.  */\n     unsigned tag_transparent : 1;\n@@ -472,10 +471,15 @@ struct binding_level\n     unsigned more_cleanups_ok : 1;\n     unsigned have_cleanups : 1;\n \n-    /* Nonzero if this level is for storing the decls for template\n+    /* Nonzero if this scope is for storing the decls for template\n        parameters and generic decls; these decls will be discarded and\n        replaced with a TEMPLATE_DECL.  */\n-    unsigned pseudo_global : 1;\n+    unsigned template_parms_p : 1;\n+\n+    /* Nonzero if this scope corresponds to the `<>' in a \n+       `template <>' clause.  Whenever this flag is set,\n+       TEMPLATE_PARMS_P will be set as well.  */\n+    unsigned template_spec_p : 1;\n \n     /* This is set for a namespace binding level.  */\n     unsigned namespace_p : 1;\n@@ -487,7 +491,7 @@ struct binding_level\n     /* True if this level corresponds to an EH region, as for a try block.  */\n     unsigned eh_region : 1;\n \n-    /* One bit left for this word.  */\n+    /* Four bits left for this word.  */\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n     /* Binding depth at which this level began.  */\n@@ -704,15 +708,15 @@ innermost_nonclass_level ()\n /* Nonzero if we are currently in a toplevel binding level.  This\n    means either the global binding level or a namespace in a toplevel\n    binding level.  Since there are no non-toplevel namespace levels,\n-   this really means any namespace or pseudo-global level.  We also\n-   include a class whose context is toplevel.  */\n+   this really means any namespace or template parameter level.  We\n+   also include a class whose context is toplevel.  */\n \n int\n toplevel_bindings_p ()\n {\n   struct binding_level *b = innermost_nonclass_level ();\n \n-  return b->namespace_p || b->pseudo_global;\n+  return b->namespace_p || b->template_parms_p;\n }\n \n /* Nonzero if this is a namespace scope, or if we are defining a class\n@@ -750,22 +754,108 @@ kept_level_p ()\n \t      && !current_binding_level->tag_transparent));\n }\n \n-void\n-declare_pseudo_global_level ()\n-{\n-  current_binding_level->pseudo_global = 1;\n-}\n-\n static void\n declare_namespace_level ()\n {\n   current_binding_level->namespace_p = 1;\n }\n \n+/* Returns non-zero if this scope was created to store template\n+   parameters.  */\n+\n int\n-pseudo_global_level_p ()\n+template_parm_scope_p ()\n {\n-  return current_binding_level->pseudo_global;\n+  return current_binding_level->template_parms_p;\n+}\n+\n+/* Returns the kind of template specialization we are currently\n+   processing, given that it's declaration contained N_CLASS_SCOPES\n+   explicit scope qualifications.  */\n+\n+tmpl_spec_kind\n+current_tmpl_spec_kind (n_class_scopes)\n+     int n_class_scopes;\n+{\n+  int n_template_parm_scopes = 0;\n+  int seen_specialization_p = 0;\n+  int innermost_specialization_p = 0;\n+  struct binding_level *b;\n+\n+  /* Scan through the template parameter scopes.  */\n+  for (b = current_binding_level; b->template_parms_p; b = b->level_chain)\n+    {\n+      /* If we see a specialization scope inside a parameter scope,\n+\t then something is wrong.  That corresponds to a declaration\n+\t like:\n+\n+\t    template <class T> template <> ...\n+\n+\t which is always illegal since [temp.expl.spec] forbids the\n+\t specialization of a class member template if the enclosing\n+\t class templates are not explicitly specialized as well.  */\n+      if (b->template_spec_p)\n+\t{\n+\t  if (n_template_parm_scopes == 0)\n+\t    innermost_specialization_p = 1;\n+\t  else\n+\t    seen_specialization_p = 1;\n+\t}\n+      else if (seen_specialization_p == 1)\n+\treturn tsk_invalid_member_spec;\n+\n+      ++n_template_parm_scopes;\n+    }\n+\n+  /* Handle explicit instantiations.  */\n+  if (processing_explicit_instantiation)\n+    {\n+      if (n_template_parm_scopes != 0)\n+\t/* We've seen a template parameter list during an explicit\n+\t   instantiation.  For example:\n+\n+\t     template <class T> template void f(int);\n+\n+\t   This is erroneous.  */\n+\treturn tsk_invalid_expl_inst;\n+      else\n+\treturn tsk_expl_inst;\n+    }\n+\n+  if (n_template_parm_scopes < n_class_scopes)\n+    /* We've not seen enough template headers to match all the\n+       specialized classes present.  For example:\n+\n+         template <class T> void R<T>::S<T>::f(int);\n+\n+       This is illegal; there needs to be one set of template\n+       parameters for each class.  */\n+    return tsk_insufficient_parms;\n+  else if (n_template_parm_scopes == n_class_scopes)\n+    /* We're processing a non-template declaration (even though it may\n+       be a member of a template class.)  For example:\n+\n+         template <class T> void S<T>::f(int);\n+\n+       The `class T' maches the `S<T>', leaving no template headers\n+       corresponding to the `f'.  */\n+    return tsk_none;\n+  else if (n_template_parm_scopes > n_class_scopes + 1)\n+    /* We've got too many template headers.  For example:\n+\n+         template <> template <class T> void f (T);\n+\n+       There need to be more enclosing classes.  */\n+    return tsk_excessive_parms;\n+  else\n+    /* This must be a template.  It's of the form:\n+\n+         template <class T> template <class U> void S<T>::f(U);\n+\n+       This is a specialization if the innermost level was a\n+       specialization; otherwise it's just a definition of the\n+       template.  */\n+    return innermost_specialization_p ? tsk_expl_spec : tsk_template;\n }\n \n void\n@@ -806,6 +896,38 @@ pushlevel (tag_transparent)\n   keep_next_level_flag = 0;\n }\n \n+/* Enter a new scope.  The KIND indicates what kind of scope is being\n+   created.  */\n+\n+void\n+begin_scope (sk)\n+     scope_kind sk;\n+{\n+  pushlevel (0);\n+\n+  switch (sk)\n+    {\n+    case sk_template_spec:\n+      current_binding_level->template_spec_p = 1;\n+      /* Fall through.  */\n+\n+    case sk_template_parms:\n+      current_binding_level->template_parms_p = 1;\n+      break;\n+\n+    default:\n+      my_friendly_abort (20000309);\n+    }\n+}\n+\n+/* Exit the current scope.  */\n+\n+void\n+finish_scope ()\n+{\n+  poplevel (0, 0, 0);\n+}\n+\n void\n note_level_for_for ()\n {\n@@ -2381,7 +2503,7 @@ maybe_push_to_top_level (pseudo)\n \t inserted into namespace level, finish_file wouldn't find them\n \t when doing pending instantiations. Therefore, don't stop at\n \t namespace level, but continue until :: .  */\n-      if (b == global_binding_level || (pseudo && b->pseudo_global))\n+      if (b == global_binding_level || (pseudo && b->template_parms_p))\n \tbreak;\n \n       old_bindings = store_bindings (b->names, old_bindings);\n@@ -2590,7 +2712,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t     friend case, push_template_decl will already have put the\n \t     friend into global scope, if appropriate.  */\n \t  if (TREE_CODE (type) != ENUMERAL_TYPE\n-\t      && !globalize && b->pseudo_global\n+\t      && !globalize && b->template_parms_p\n \t      && b->level_chain->parm_flag == 2)\n \t    {\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n@@ -2675,7 +2797,7 @@ pushtag (name, type, globalize)\n \t  if (!context)\n \t    context = current_namespace;\n \n-\t  if ((b->pseudo_global && b->level_chain->parm_flag == 2)\n+\t  if ((b->template_parms_p && b->level_chain->parm_flag == 2)\n \t      || b->parm_flag == 2)\n \t    in_class = 1;\n \n@@ -4195,29 +4317,6 @@ maybe_push_decl (decl)\n     return pushdecl (decl);\n }\n \n-#if 0\n-/* This function is used to push the mangled decls for nested types into\n-   the appropriate scope.  Previously pushdecl_top_level was used, but that\n-   is incorrect for members of local classes.  */\n-\n-void\n-pushdecl_nonclass_level (x)\n-     tree x;\n-{\n-  struct binding_level *b = current_binding_level;\n-\n-  my_friendly_assert (b->parm_flag != 2, 180);\n-\n-#if 0\n-  /* Get out of template binding levels */\n-  while (b->pseudo_global)\n-    b = b->level_chain;\n-#endif\n-\n-  pushdecl_with_scope (x, b);\n-}\n-#endif\n-\n /* Make the declaration(s) of X appear in CLASS scope\n    under the name NAME.  */\n \n@@ -4969,9 +5068,9 @@ lookup_tag (form, name, binding_level, thislevel_only)\n      int thislevel_only;\n {\n   register struct binding_level *level;\n-  /* Non-zero if, we should look past a pseudo-global level, even if\n-     THISLEVEL_ONLY.  */\n-  int allow_pseudo_global = 1;\n+  /* Non-zero if, we should look past a template parameter level, even\n+     if THISLEVEL_ONLY.  */\n+  int allow_template_parms_p = 1;\n \n   for (level = binding_level; level; level = level->level_chain)\n     {\n@@ -4990,11 +5089,11 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t  {\n \t    tree old = binding_for_name (name, tail);\n \n-\t    /* If we just skipped past a pseudo global level, even\n-\t       though THISLEVEL_ONLY, and we find a template class\n-\t       declaration, then we use the _TYPE node for the\n+\t    /* If we just skipped past a template parameter level,\n+\t       even though THISLEVEL_ONLY, and we find a template\n+\t       class declaration, then we use the _TYPE node for the\n \t       template.  See the example below.  */\n-\t    if (thislevel_only && !allow_pseudo_global\n+\t    if (thislevel_only && !allow_template_parms_p\n \t\t&& old && BINDING_VALUE (old)\n \t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (old)))\n \t      old = TREE_TYPE (BINDING_VALUE (old));\n@@ -5037,7 +5136,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t  }\n       if (thislevel_only && ! level->tag_transparent)\n \t{\n-\t  if (level->pseudo_global && allow_pseudo_global)\n+\t  if (level->template_parms_p && allow_template_parms_p)\n \t    {\n \t      /* We must deal with cases like this:\n \n@@ -5050,7 +5149,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t template parameters, rather than the (surrounding)\n \t\t namespace level.  Thus, we keep going one more level,\n \t\t even though THISLEVEL_ONLY is non-zero.  */\n-\t      allow_pseudo_global = 0;\n+\t      allow_template_parms_p = 0;\n \t      continue;\n \t    }\n \t  else\n@@ -8680,98 +8779,77 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     return decl;\n \n   if (flags == NO_SPECIAL && ctype && constructor_name (cname) == declarator)\n-    {\n-      tree tmp;\n-      /* Just handle constructors here.  We could do this\n-\t inside the following if stmt, but I think\n-\t that the code is more legible by breaking this\n-\t case out.  See comments below for what each of\n-\t the following calls is supposed to do.  */\n-      DECL_CONSTRUCTOR_P (decl) = 1;\n-\n-      grokclassfn (ctype, decl, flags, quals);\n-\n-      decl = check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t\t    template_count,\n-\t\t\t\t\t    2 * (funcdef_flag != 0) +\n-\t\t\t\t\t    4 * (friendp != 0));\n-      if (decl == error_mark_node)\n-\treturn NULL_TREE;\n-\n-      if ((! TYPE_FOR_JAVA (ctype) || check_java_method (decl))\n-\t  && check)\n-\t{\n-\t  tmp = check_classfn (ctype, decl);\n-\n-\t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n-\t    tmp = DECL_TEMPLATE_RESULT(tmp);\n+    DECL_CONSTRUCTOR_P (decl) = 1;\n+\n+  /* Function gets the ugly name, field gets the nice one.  This call\n+     may change the type of the function (because of default\n+     parameters)!  */\n+  if (ctype != NULL_TREE)\n+    grokclassfn (ctype, decl, flags, quals);\n+\n+  decl = check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t\ttemplate_count,\n+\t\t\t\t\t2 * (funcdef_flag != 0) +\n+\t\t\t\t\t4 * (friendp != 0));\n+  if (decl == error_mark_node)\n+    return NULL_TREE;\n \n-\t  if (tmp && DECL_ARTIFICIAL (tmp))\n-\t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n-\t  if (tmp && duplicate_decls (decl, tmp))\n-\t    return tmp;\n-\t}\n-      if (! grok_ctor_properties (ctype, decl))\n-\treturn NULL_TREE;\n-    }\n-  else\n+  if (ctype != NULL_TREE\n+      && (! TYPE_FOR_JAVA (ctype) || check_java_method (decl))\n+      && check)\n     {\n-      tree tmp;\n+      tree old_decl;\n \n-      /* Function gets the ugly name, field gets the nice one.\n-\t This call may change the type of the function (because\n-\t of default parameters)!  */\n-      if (ctype != NULL_TREE)\n-\tgrokclassfn (ctype, decl, flags, quals);\n+      old_decl = check_classfn (ctype, decl);\n \n-      decl = check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t\t    template_count,\n-\t\t\t\t\t    2 * (funcdef_flag != 0) +\n-\t\t\t\t\t    4 * (friendp != 0));\n-      if (decl == error_mark_node)\n-\treturn NULL_TREE;\n+      if (old_decl && TREE_CODE (old_decl) == TEMPLATE_DECL)\n+\t/* Because grokfndecl is always supposed to return a\n+\t   FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT\n+\t   here.  We depend on our callers to figure out that its\n+\t   really a template that's being returned.  */\n+\told_decl = DECL_TEMPLATE_RESULT (old_decl);\n \n-      if (ctype != NULL_TREE\n-\t  && (! TYPE_FOR_JAVA (ctype) || check_java_method (decl))\n-\t  && check)\n+      if (old_decl && DECL_STATIC_FUNCTION_P (old_decl)\n+\t  && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n \t{\n-\t  tmp = check_classfn (ctype, decl);\n+\t  /* Remove the `this' parm added by grokclassfn.\n+\t     XXX Isn't this done in start_function, too?  */\n+\t  revert_static_member_fn (&decl, NULL, NULL);\n+\t  last_function_parms = TREE_CHAIN (last_function_parms);\n+\t}\n+      if (old_decl && DECL_ARTIFICIAL (old_decl))\n+\tcp_error (\"definition of implicitly-declared `%D'\", old_decl);\n \n-\t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n-\t    tmp = DECL_TEMPLATE_RESULT (tmp);\n+      if (old_decl)\n+\t{\n+\t  /* Since we've smashed OLD_DECL to its\n+\t     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */\n+\t  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+\t    decl = DECL_TEMPLATE_RESULT (decl);\n \n-\t  if (tmp && DECL_STATIC_FUNCTION_P (tmp)\n-\t      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\t    {\n-\t      /* Remove the `this' parm added by grokclassfn.\n-\t         XXX Isn't this done in start_function, too?  */\n-\t      revert_static_member_fn (&decl, NULL, NULL);\n-\t      last_function_parms = TREE_CHAIN (last_function_parms);\n-\t    }\n-\t  if (tmp && DECL_ARTIFICIAL (tmp))\n-\t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n-\t  if (tmp)\n-\t    {\n-\t      /* Attempt to merge the declarations.  This can fail, in\n-\t\t the case of some illegal specialization declarations.  */\n-\t      if (!duplicate_decls (decl, tmp))\n-\t\tcp_error (\"no `%#D' member function declared in class `%T'\",\n-\t\t\t  decl, ctype);\n-\t      return tmp;\n-\t    }\n+\t  /* Attempt to merge the declarations.  This can fail, in\n+\t     the case of some illegal specialization declarations.  */\n+\t  if (!duplicate_decls (decl, old_decl))\n+\t    cp_error (\"no `%#D' member function declared in class `%T'\",\n+\t\t      decl, ctype);\n+\t  return old_decl;\n \t}\n+    }\n \n-      if (ctype == NULL_TREE || check)\n-\treturn decl;\n+  if (DECL_CONSTRUCTOR_P (decl) && !grok_ctor_properties (ctype, decl))\n+    return NULL_TREE;\n \n-      if (virtualp)\n-\t{\n-\t  DECL_VIRTUAL_P (decl) = 1;\n-\t  if (DECL_VINDEX (decl) == NULL_TREE)\n-\t    DECL_VINDEX (decl) = error_mark_node;\n-\t  IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n-\t}\n+  if (ctype == NULL_TREE || check)\n+    return decl;\n+\n+  if (virtualp)\n+    {\n+      DECL_VIRTUAL_P (decl) = 1;\n+      if (DECL_VINDEX (decl) == NULL_TREE)\n+\tDECL_VINDEX (decl) = error_mark_node;\n+      IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n     }\n+\n   return decl;\n }\n "}, {"sha": "f7ed5810e3b0d2eb18ab811bf37287eeb676e200", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -1358,6 +1358,8 @@ check_classfn (ctype, function)\n   tree *end = 0;\n   \n   if (DECL_USE_TEMPLATE (function)\n+      && !(TREE_CODE (function) == TEMPLATE_DECL\n+\t   && DECL_TEMPLATE_SPECIALIZATION (function))\n       && is_member_template (DECL_TI_TEMPLATE (function)))\n     /* Since this is a specialization of a member template,\n        we're not going to find the declaration in the class."}, {"sha": "9fef5acd36e3c7e1019abb7d0274b4d55cfc039a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 110, "deletions": 96, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -551,8 +551,7 @@ begin_template_parm_list ()\n \n      pushtag contains special code to call pushdecl_with_scope on the\n      TEMPLATE_DECL for S2.  */\n-  pushlevel (0);\n-  declare_pseudo_global_level ();\n+  begin_scope (sk_template_parms);\n   ++processing_template_decl;\n   ++processing_template_parmlist;\n   note_template_header (0);\n@@ -596,6 +595,7 @@ check_specialization_scope ()\n void\n begin_specialization ()\n {\n+  begin_scope (sk_template_spec);\n   note_template_header (1);\n   check_specialization_scope ();\n }\n@@ -606,6 +606,7 @@ begin_specialization ()\n void \n end_specialization ()\n {\n+  finish_scope ();\n   reset_specialization ();\n }\n \n@@ -1166,109 +1167,99 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n   int specialization = 0;\n   int explicit_instantiation = 0;\n   int member_specialization = 0;\n-\n   tree ctype = DECL_CLASS_CONTEXT (decl);\n   tree dname = DECL_NAME (decl);\n+  tmpl_spec_kind tsk;\n \n-  if (processing_specialization) \n-    {\n-      /* The last template header was of the form template <>.  */\n-\t  \n-      if (template_header_count > template_count) \n-\t{\n-\t  /* There were more template headers than qualifying template\n-\t     classes.  */\n-\t  if (template_header_count - template_count > 1)\n-\t    /* There shouldn't be that many template parameter lists.\n-\t       There can be at most one parameter list for every\n-\t       qualifying class, plus one for the function itself.  */\n-\t    cp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n+  tsk = current_tmpl_spec_kind (template_count);\n \n-\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t  if (ctype)\n-\t    member_specialization = 1;\n-\t  else\n-\t    specialization = 1;\n-\t}\n-      else if (template_header_count == template_count)\n+  switch (tsk)\n+    {\n+    case tsk_none:\n+      if (processing_specialization) \n \t{\n-\t  /* The counts are equal.  So, this might be a\n-\t     specialization, but it is not a specialization of a\n-\t     member template.  It might be something like\n-\t\t \n-\t     template <class T> struct S { \n-\t     void f(int i); \n-\t     };\n-\t     template <>\n-\t     void S<int>::f(int i) {}  */\n \t  specialization = 1;\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n \t}\n-      else \n+      else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n \t{\n-\t  /* This cannot be an explicit specialization.  There are not\n-\t     enough headers for all of the qualifying classes.  For\n-\t     example, we might have:\n-\t     \n-\t     template <>\n-\t     void S<int>::T<char>::f();\n+\t  if (is_friend)\n+\t    /* This could be something like:\n \n-\t     But, we're missing another template <>.  */\n-\t  cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n-\t  return decl;\n-\t} \n-    }\n-  else if (processing_explicit_instantiation)\n-    {\n-      if (template_header_count)\n-\tcp_error (\"template parameter list used in explicit instantiation\");\n-\t  \n+\t       template <class T> void f(T);\n+\t       class S { friend void f<>(int); }  */\n+\t    specialization = 1;\n+\t  else\n+\t    {\n+\t      /* This case handles bogus declarations like template <>\n+\t\t template <class T> void f<int>(); */\n+\n+\t      cp_error (\"template-id `%D' in declaration of primary template\",\n+\t\t\tdeclarator);\n+\t      return decl;\n+\t    }\n+\t}\n+      break;\n+\n+    case tsk_invalid_member_spec:\n+      /* The error has already been reported in\n+\t check_specialization_scope.  */\n+      return error_mark_node;\n+\n+    case tsk_invalid_expl_inst:\n+      cp_error (\"template parameter list used in explicit instantiation\");\n+\n+      /* Fall through.  */\n+\n+    case tsk_expl_inst:\n       if (have_def)\n \tcp_error (\"definition provided for explicit instantiation\");\n-\n+      \n       explicit_instantiation = 1;\n-    }\n-  else if (ctype != NULL_TREE\n-\t   && !TYPE_BEING_DEFINED (ctype)\n-\t   && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype)\n-\t   && !is_friend)\n-    {\n-      /* This case catches outdated code that looks like this:\n-\n-\t template <class T> struct S { void f(); };\n-\t void S<int>::f() {} // Missing template <>\n+      break;\n \n-\t We disable this check when the type is being defined to\n-\t avoid complaining about default compiler-generated\n-\t constructors, destructors, and assignment operators.\n-\t Since the type is an instantiation, not a specialization,\n-\t these are the only functions that can be defined before\n-\t the class is complete.  */\n+    case tsk_excessive_parms:\n+      cp_error (\"too many template parameter lists in declaration of `%D'\", \n+\t\tdecl);\n+      return error_mark_node;\n \n-\t  /* If they said\n-\t       template <class T> void S<int>::f() {}\n-\t     that's bogus.  */\n+      /* Fall through.  */\n+    case tsk_expl_spec:\n+      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+      if (ctype)\n+\tmember_specialization = 1;\n+      else\n+\tspecialization = 1;\n+      break;\n+     \n+    case tsk_insufficient_parms:\n       if (template_header_count)\n \t{\n-\t  cp_error (\"template parameters specified in specialization\");\n+\t  cp_error(\"too few template parameter lists in declaration of `%D'\", \n+\t\t   decl);\n \t  return decl;\n \t}\n+      else if (ctype != NULL_TREE\n+\t       && !TYPE_BEING_DEFINED (ctype)\n+\t       && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype)\n+\t       && !is_friend)\n+\t{\n+\t  /* For backwards compatibility, we accept:\n \n-      if (pedantic)\n-\tcp_pedwarn\n-\t  (\"explicit specialization not preceded by `template <>'\");\n-      specialization = 1;\n-      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-    }\n-  else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n-    {\n-      if (is_friend)\n-\t/* This could be something like:\n+\t       template <class T> struct S { void f(); };\n+\t       void S<int>::f() {} // Missing template <>\n \n-\t   template <class T> void f(T);\n-\t   class S { friend void f<>(int); }  */\n-\tspecialization = 1;\n-      else\n+\t     That used to be legal C++.  */\n+\t  if (pedantic)\n+\t    cp_pedwarn\n+\t      (\"explicit specialization not preceded by `template <>'\");\n+\t  specialization = 1;\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t}\n+      break;\n+\n+    case tsk_template:\n+      if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n \t{\n \t  /* This case handles bogus declarations like template <>\n \t     template <class T> void f<int>(); */\n@@ -1277,6 +1268,22 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t    declarator);\n \t  return decl;\n \t}\n+\n+      if (ctype && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n+\t/* This is a specialization of a member template, without\n+\t   specialization the containing class.  Something like:\n+\n+\t     template <class T> struct S {\n+\t       template <class U> void f (U); \n+             };\n+\t     template <> template <class U> void S<int>::f(U) {}\n+\t     \n+\t   That's a specialization -- but of the entire template.  */\n+\tspecialization = 1;\n+      break;\n+\n+    default:\n+      my_friendly_abort (20000309);\n     }\n \n   if (specialization || member_specialization)\n@@ -1474,10 +1481,19 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t  targs = new_targs;\n \t\t}\n \t\t  \n-\t      decl = instantiate_template (tmpl, targs);\n-\t      return decl;\n+\t      return instantiate_template (tmpl, targs);\n \t    }\n-\t  \n+\n+\t  /* If this is both a template specialization, then it's a\n+\t     specialization of a member template of a template class.\n+\t     In that case we want to return the TEMPLATE_DECL, not the\n+\t     specialization of it.  */\n+\t  if (tsk == tsk_template)\n+\t    {\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n+\t      return tmpl;\n+\t    }\n+\n \t  /* If we though that the DECL was a member function, but it\n \t     turns out to be specializing a static member function,\n \t     make DECL a static member function as well.  */\n@@ -1504,7 +1520,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     we do not mangle S<int>::f() here.  That's because it's\n \t     just an ordinary member function and doesn't need special\n \t     treatment.  We do this here so that the ordinary,\n-\t     non-template, name-mangling algorith will not be used\n+\t     non-template, name-mangling algorithm will not be used\n \t     later.  */\n \t  if ((is_member_template (tmpl) || ctype == NULL_TREE)\n \t      && name_mangling_version >= 1)\n@@ -1863,11 +1879,10 @@ end_template_decl ()\n     return;\n \n   /* This matches the pushlevel in begin_template_parm_list.  */\n-  poplevel (0, 0, 0);\n+  finish_scope ();\n \n   --processing_template_decl;\n   current_template_parms = TREE_CHAIN (current_template_parms);\n-  (void) get_pending_sizes ();\t/* Why? */\n }\n \n /* Given a template argument vector containing the template PARMS.\n@@ -2370,7 +2385,7 @@ push_template_decl_real (decl, is_friend)\n     DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n   /* See if this is a primary template.  */\n-  primary = pseudo_global_level_p ();\n+  primary = template_parm_scope_p ();\n \n   if (primary)\n     {\n@@ -2444,9 +2459,6 @@ push_template_decl_real (decl, is_friend)\n       tree a, t, current, parms;\n       int i;\n \n-      if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n-\tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n-\t\t  ctx, decl);\n       if (TREE_CODE (decl) == TYPE_DECL)\n \t{\n \t  if ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (decl)))\n@@ -5597,7 +5609,7 @@ tsubst_decl (t, args, type, in_decl)\n \t\t template <class T> struct S { \n \t\t   template <class U> friend void f();\n \t\t };\n-\t\t template <class U> friend void f() {}\n+\t\t template <class U> void f() {}\n \t\t template S<int>;\n \t\t template void f<double>();\n \n@@ -7395,7 +7407,7 @@ instantiate_template (tmpl, targ_ptr)\n   if (spec != NULL_TREE)\n     return spec;\n \n-  if (DECL_TEMPLATE_INFO (tmpl))\n+  if (DECL_TEMPLATE_INFO (tmpl) && !DECL_TEMPLATE_SPECIALIZATION (tmpl))\n     {\n       /* The TMPL is a partial instantiation.  To get a full set of\n \t arguments we must add the arguments used to perform the\n@@ -8944,6 +8956,8 @@ most_general_template (decl)\n      tree decl;\n {\n   while (DECL_TEMPLATE_INFO (decl)\n+\t && !(TREE_CODE (decl) == TEMPLATE_DECL\n+\t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n \t /* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or\n \t    IDENTIFIER_NODE in some cases.  (See cp-tree.h for\n \t    details.)  */"}, {"sha": "fc6af32938c95ecb6271f06a46a120924c83ce22", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem05.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -49,7 +49,7 @@ unsigned short X_one<T>::ret_id() {\n   return id;\n }\n \n-export template <class T> template <class T2> // WARNING - \n+export template <class T2> // WARNING - \n bool compare_ge(T2 test) {\n   if (test > type)\n     return true;"}, {"sha": "50f74233b17bb40bae85dc3265dabc84ee0dc59d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp93.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp93.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b846e0def7675566fc4dd849b01372d839a36c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp93.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp93.C?ref=74b846e0def7675566fc4dd849b01372d839a36c", "patch": "@@ -0,0 +1,16 @@\n+// Build don't run:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <int n> struct A { \n+  template <class T> A (T t);\n+  template <class T> int f(T t) const; \n+}; \n+\n+template <> template<class T> int A<1>::f(T t) const {return 1;} \n+template <> template<class T> A<1>::A (T t) {}\n+\n+int main() { \n+  A<1> a (3);\n+  a.f(1);\n+  return 0; \n+}"}]}