{"sha": "ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY0YmRkYzI5OWVhZTEzY2MyNWU1MGVlYmM1MjNhNDk2M2UwYTVmNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-10-29T12:02:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-10-29T12:02:45Z"}, "message": "decl.c, [...]: Remove redundant enum from machine_mode.\n\ngcc/ada/\n\t* gcc-interface/decl.c, gcc-interface/gigi.h, gcc-interface/misc.c,\n\tgcc-interface/trans.c, gcc-interface/utils.c, gcc-interface/utils2.c:\n\tRemove redundant enum from machine_mode.\n\ngcc/c-family/\n\t* c-common.c, c-common.h, c-cppbuiltin.c, c-lex.c: Remove redundant\n\tenum from machine_mode.\n\ngcc/c/\n\t* c-decl.c, c-tree.h, c-typeck.c: Remove redundant enum from\n\tmachine_mode.\n\ngcc/cp/\n\t* constexpr.c: Remove redundant enum from machine_mode.\n\ngcc/fortran/\n\t* trans-types.c, trans-types.h: Remove redundant enum from\n\tmachine_mode.\n\ngcc/go/\n\t* go-lang.c: Remove redundant enum from machine_mode.\n\ngcc/java/\n\t* builtins.c, java-tree.h, typeck.c: Remove redundant enum from\n\tmachine_mode.\n\ngcc/lto/\n\t* lto-lang.c: Remove redundant enum from machine_mode.\n\ngcc/\n\t* addresses.h, alias.c, asan.c, auto-inc-dec.c, bt-load.c, builtins.c,\n\tbuiltins.h, caller-save.c, calls.c, calls.h, cfgexpand.c, cfgloop.h,\n\tcfgrtl.c, combine.c, compare-elim.c, config/aarch64/aarch64-builtins.c,\n\tconfig/aarch64/aarch64-protos.h, config/aarch64/aarch64-simd.md,\n\tconfig/aarch64/aarch64.c, config/aarch64/aarch64.h,\n\tconfig/aarch64/aarch64.md, config/alpha/alpha-protos.h,\n\tconfig/alpha/alpha.c, config/arc/arc-protos.h, config/arc/arc.c,\n\tconfig/arc/arc.h, config/arc/predicates.md,\n\tconfig/arm/aarch-common-protos.h, config/arm/aarch-common.c,\n\tconfig/arm/arm-protos.h, config/arm/arm.c, config/arm/arm.h,\n\tconfig/arm/arm.md, config/arm/neon.md, config/arm/thumb2.md,\n\tconfig/avr/avr-log.c, config/avr/avr-protos.h, config/avr/avr.c,\n\tconfig/avr/avr.md, config/bfin/bfin-protos.h, config/bfin/bfin.c,\n\tconfig/c6x/c6x-protos.h, config/c6x/c6x.c, config/c6x/c6x.md,\n\tconfig/cr16/cr16-protos.h, config/cr16/cr16.c,\n\tconfig/cris/cris-protos.h, config/cris/cris.c, config/cris/cris.md,\n\tconfig/darwin-protos.h, config/darwin.c,\n\tconfig/epiphany/epiphany-protos.h, config/epiphany/epiphany.c,\n\tconfig/epiphany/epiphany.md, config/fr30/fr30.c,\n\tconfig/frv/frv-protos.h, config/frv/frv.c, config/frv/predicates.md,\n\tconfig/h8300/h8300-protos.h, config/h8300/h8300.c,\n\tconfig/i386/i386-builtin-types.awk, config/i386/i386-protos.h,\n\tconfig/i386/i386.c, config/i386/i386.md, config/i386/predicates.md,\n\tconfig/i386/sse.md, config/i386/sync.md, config/ia64/ia64-protos.h,\n\tconfig/ia64/ia64.c, config/iq2000/iq2000-protos.h,\n\tconfig/iq2000/iq2000.c, config/iq2000/iq2000.md,\n\tconfig/lm32/lm32-protos.h, config/lm32/lm32.c,\n\tconfig/m32c/m32c-protos.h, config/m32c/m32c.c,\n\tconfig/m32r/m32r-protos.h, config/m32r/m32r.c,\n\tconfig/m68k/m68k-protos.h, config/m68k/m68k.c,\n\tconfig/mcore/mcore-protos.h, config/mcore/mcore.c,\n\tconfig/mcore/mcore.md, config/mep/mep-protos.h, config/mep/mep.c,\n\tconfig/microblaze/microblaze-protos.h, config/microblaze/microblaze.c,\n\tconfig/mips/mips-protos.h, config/mips/mips.c,\n\tconfig/mmix/mmix-protos.h, config/mmix/mmix.c,\n\tconfig/mn10300/mn10300-protos.h, config/mn10300/mn10300.c,\n\tconfig/moxie/moxie.c, config/msp430/msp430-protos.h,\n\tconfig/msp430/msp430.c, config/nds32/nds32-cost.c,\n\tconfig/nds32/nds32-intrinsic.c, config/nds32/nds32-md-auxiliary.c,\n\tconfig/nds32/nds32-protos.h, config/nds32/nds32.c,\n\tconfig/nios2/nios2-protos.h, config/nios2/nios2.c,\n\tconfig/pa/pa-protos.h, config/pa/pa.c, config/pdp11/pdp11-protos.h,\n\tconfig/pdp11/pdp11.c, config/rl78/rl78-protos.h, config/rl78/rl78.c,\n\tconfig/rs6000/altivec.md, config/rs6000/rs6000-c.c,\n\tconfig/rs6000/rs6000-protos.h, config/rs6000/rs6000.c,\n\tconfig/rs6000/rs6000.h, config/rx/rx-protos.h, config/rx/rx.c,\n\tconfig/s390/predicates.md, config/s390/s390-protos.h,\n\tconfig/s390/s390.c, config/s390/s390.h, config/s390/s390.md,\n\tconfig/sh/predicates.md, config/sh/sh-protos.h, config/sh/sh.c,\n\tconfig/sh/sh.md, config/sparc/predicates.md,\n\tconfig/sparc/sparc-protos.h, config/sparc/sparc.c,\n\tconfig/sparc/sparc.md, config/spu/spu-protos.h, config/spu/spu.c,\n\tconfig/stormy16/stormy16-protos.h, config/stormy16/stormy16.c,\n\tconfig/tilegx/tilegx-protos.h, config/tilegx/tilegx.c,\n\tconfig/tilegx/tilegx.md, config/tilepro/tilepro-protos.h,\n\tconfig/tilepro/tilepro.c, config/v850/v850-protos.h,\n\tconfig/v850/v850.c, config/v850/v850.md, config/vax/vax-protos.h,\n\tconfig/vax/vax.c, config/vms/vms-c.c, config/xtensa/xtensa-protos.h,\n\tconfig/xtensa/xtensa.c, coverage.c, cprop.c, cse.c, cselib.c, cselib.h,\n\tdbxout.c, ddg.c, df-problems.c, dfp.c, dfp.h, doc/md.texi,\n\tdoc/rtl.texi, doc/tm.texi, doc/tm.texi.in, dojump.c, dse.c,\n\tdwarf2cfi.c, dwarf2out.c, dwarf2out.h, emit-rtl.c, emit-rtl.h,\n\texcept.c, explow.c, expmed.c, expmed.h, expr.c, expr.h, final.c,\n\tfixed-value.c, fixed-value.h, fold-const.c, function.c, function.h,\n\tfwprop.c, gcse.c, gengenrtl.c, genmodes.c, genopinit.c, genoutput.c,\n\tgenpreds.c, genrecog.c, gensupport.c, gimple-ssa-strength-reduction.c,\n\tgraphite-clast-to-gimple.c, haifa-sched.c, hooks.c, hooks.h, ifcvt.c,\n\tinternal-fn.c, ira-build.c, ira-color.c, ira-conflicts.c, ira-costs.c,\n\tira-emit.c, ira-int.h, ira-lives.c, ira.c, ira.h, jump.c, langhooks.h,\n\tlibfuncs.h, lists.c, loop-doloop.c, loop-invariant.c, loop-iv.c,\n\tloop-unroll.c, lower-subreg.c, lower-subreg.h, lra-assigns.c,\n\tlra-constraints.c, lra-eliminations.c, lra-int.h, lra-lives.c,\n\tlra-spills.c, lra.c, lra.h, machmode.h, omp-low.c, optabs.c, optabs.h,\n\toutput.h, postreload.c, print-tree.c, read-rtl.c, real.c, real.h,\n\trecog.c, recog.h, ree.c, reg-stack.c, regcprop.c, reginfo.c,\n\tregrename.c, regs.h, reload.c, reload.h, reload1.c, rtl.c, rtl.h,\n\trtlanal.c, rtlhash.c, rtlhooks-def.h, rtlhooks.c, sched-deps.c,\n\tsel-sched-dump.c, sel-sched-ir.c, sel-sched-ir.h, sel-sched.c,\n\tsimplify-rtx.c, stmt.c, stor-layout.c, stor-layout.h, target.def,\n\ttarghooks.c, targhooks.h, tree-affine.c, tree-call-cdce.c,\n\ttree-complex.c, tree-data-ref.c, tree-dfa.c, tree-if-conv.c,\n\ttree-inline.c, tree-outof-ssa.c, tree-scalar-evolution.c,\n\ttree-ssa-address.c, tree-ssa-ccp.c, tree-ssa-loop-ivopts.c,\n\ttree-ssa-loop-ivopts.h, tree-ssa-loop-manip.c,\n\ttree-ssa-loop-prefetch.c, tree-ssa-math-opts.c, tree-ssa-reassoc.c,\n\ttree-ssa-sccvn.c, tree-streamer-in.c, tree-switch-conversion.c,\n\ttree-vect-data-refs.c, tree-vect-generic.c, tree-vect-loop.c,\n\ttree-vect-patterns.c, tree-vect-slp.c, tree-vect-stmts.c,\n\ttree-vrp.c, tree.c, tree.h, tsan.c, ubsan.c, valtrack.c,\n\tvar-tracking.c, varasm.c: Remove redundant enum from\n\tmachine_mode.\ngcc/\n\t* gengtype.c (main): Treat machine_mode as a scalar typedef.\n\t* genmodes.c (emit_insn_modes_h): Hide inline functions if\n\tUSED_FOR_TARGET.\n\nFrom-SVN: r216834", "tree": {"sha": "9a57dad975c942ce6765490066e2492bc1ce59e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a57dad975c942ce6765490066e2492bc1ce59e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca557f533aa5e941d765c4c78b10b095537f0bdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca557f533aa5e941d765c4c78b10b095537f0bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca557f533aa5e941d765c4c78b10b095537f0bdf"}], "stats": {"total": 11428, "additions": 5782, "deletions": 5646}, "files": [{"sha": "f0c7327c9b1ba41e2c6c6f168e0edafa5e75de81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1,3 +1,100 @@\n+2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* addresses.h, alias.c, asan.c, auto-inc-dec.c, bt-load.c, builtins.c,\n+\tbuiltins.h, caller-save.c, calls.c, calls.h, cfgexpand.c, cfgloop.h,\n+\tcfgrtl.c, combine.c, compare-elim.c, config/aarch64/aarch64-builtins.c,\n+\tconfig/aarch64/aarch64-protos.h, config/aarch64/aarch64-simd.md,\n+\tconfig/aarch64/aarch64.c, config/aarch64/aarch64.h,\n+\tconfig/aarch64/aarch64.md, config/alpha/alpha-protos.h,\n+\tconfig/alpha/alpha.c, config/arc/arc-protos.h, config/arc/arc.c,\n+\tconfig/arc/arc.h, config/arc/predicates.md,\n+\tconfig/arm/aarch-common-protos.h, config/arm/aarch-common.c,\n+\tconfig/arm/arm-protos.h, config/arm/arm.c, config/arm/arm.h,\n+\tconfig/arm/arm.md, config/arm/neon.md, config/arm/thumb2.md,\n+\tconfig/avr/avr-log.c, config/avr/avr-protos.h, config/avr/avr.c,\n+\tconfig/avr/avr.md, config/bfin/bfin-protos.h, config/bfin/bfin.c,\n+\tconfig/c6x/c6x-protos.h, config/c6x/c6x.c, config/c6x/c6x.md,\n+\tconfig/cr16/cr16-protos.h, config/cr16/cr16.c,\n+\tconfig/cris/cris-protos.h, config/cris/cris.c, config/cris/cris.md,\n+\tconfig/darwin-protos.h, config/darwin.c,\n+\tconfig/epiphany/epiphany-protos.h, config/epiphany/epiphany.c,\n+\tconfig/epiphany/epiphany.md, config/fr30/fr30.c,\n+\tconfig/frv/frv-protos.h, config/frv/frv.c, config/frv/predicates.md,\n+\tconfig/h8300/h8300-protos.h, config/h8300/h8300.c,\n+\tconfig/i386/i386-builtin-types.awk, config/i386/i386-protos.h,\n+\tconfig/i386/i386.c, config/i386/i386.md, config/i386/predicates.md,\n+\tconfig/i386/sse.md, config/i386/sync.md, config/ia64/ia64-protos.h,\n+\tconfig/ia64/ia64.c, config/iq2000/iq2000-protos.h,\n+\tconfig/iq2000/iq2000.c, config/iq2000/iq2000.md,\n+\tconfig/lm32/lm32-protos.h, config/lm32/lm32.c,\n+\tconfig/m32c/m32c-protos.h, config/m32c/m32c.c,\n+\tconfig/m32r/m32r-protos.h, config/m32r/m32r.c,\n+\tconfig/m68k/m68k-protos.h, config/m68k/m68k.c,\n+\tconfig/mcore/mcore-protos.h, config/mcore/mcore.c,\n+\tconfig/mcore/mcore.md, config/mep/mep-protos.h, config/mep/mep.c,\n+\tconfig/microblaze/microblaze-protos.h, config/microblaze/microblaze.c,\n+\tconfig/mips/mips-protos.h, config/mips/mips.c,\n+\tconfig/mmix/mmix-protos.h, config/mmix/mmix.c,\n+\tconfig/mn10300/mn10300-protos.h, config/mn10300/mn10300.c,\n+\tconfig/moxie/moxie.c, config/msp430/msp430-protos.h,\n+\tconfig/msp430/msp430.c, config/nds32/nds32-cost.c,\n+\tconfig/nds32/nds32-intrinsic.c, config/nds32/nds32-md-auxiliary.c,\n+\tconfig/nds32/nds32-protos.h, config/nds32/nds32.c,\n+\tconfig/nios2/nios2-protos.h, config/nios2/nios2.c,\n+\tconfig/pa/pa-protos.h, config/pa/pa.c, config/pdp11/pdp11-protos.h,\n+\tconfig/pdp11/pdp11.c, config/rl78/rl78-protos.h, config/rl78/rl78.c,\n+\tconfig/rs6000/altivec.md, config/rs6000/rs6000-c.c,\n+\tconfig/rs6000/rs6000-protos.h, config/rs6000/rs6000.c,\n+\tconfig/rs6000/rs6000.h, config/rx/rx-protos.h, config/rx/rx.c,\n+\tconfig/s390/predicates.md, config/s390/s390-protos.h,\n+\tconfig/s390/s390.c, config/s390/s390.h, config/s390/s390.md,\n+\tconfig/sh/predicates.md, config/sh/sh-protos.h, config/sh/sh.c,\n+\tconfig/sh/sh.md, config/sparc/predicates.md,\n+\tconfig/sparc/sparc-protos.h, config/sparc/sparc.c,\n+\tconfig/sparc/sparc.md, config/spu/spu-protos.h, config/spu/spu.c,\n+\tconfig/stormy16/stormy16-protos.h, config/stormy16/stormy16.c,\n+\tconfig/tilegx/tilegx-protos.h, config/tilegx/tilegx.c,\n+\tconfig/tilegx/tilegx.md, config/tilepro/tilepro-protos.h,\n+\tconfig/tilepro/tilepro.c, config/v850/v850-protos.h,\n+\tconfig/v850/v850.c, config/v850/v850.md, config/vax/vax-protos.h,\n+\tconfig/vax/vax.c, config/vms/vms-c.c, config/xtensa/xtensa-protos.h,\n+\tconfig/xtensa/xtensa.c, coverage.c, cprop.c, cse.c, cselib.c, cselib.h,\n+\tdbxout.c, ddg.c, df-problems.c, dfp.c, dfp.h, doc/md.texi,\n+\tdoc/rtl.texi, doc/tm.texi, doc/tm.texi.in, dojump.c, dse.c,\n+\tdwarf2cfi.c, dwarf2out.c, dwarf2out.h, emit-rtl.c, emit-rtl.h,\n+\texcept.c, explow.c, expmed.c, expmed.h, expr.c, expr.h, final.c,\n+\tfixed-value.c, fixed-value.h, fold-const.c, function.c, function.h,\n+\tfwprop.c, gcse.c, gengenrtl.c, genmodes.c, genopinit.c, genoutput.c,\n+\tgenpreds.c, genrecog.c, gensupport.c, gimple-ssa-strength-reduction.c,\n+\tgraphite-clast-to-gimple.c, haifa-sched.c, hooks.c, hooks.h, ifcvt.c,\n+\tinternal-fn.c, ira-build.c, ira-color.c, ira-conflicts.c, ira-costs.c,\n+\tira-emit.c, ira-int.h, ira-lives.c, ira.c, ira.h, jump.c, langhooks.h,\n+\tlibfuncs.h, lists.c, loop-doloop.c, loop-invariant.c, loop-iv.c,\n+\tloop-unroll.c, lower-subreg.c, lower-subreg.h, lra-assigns.c,\n+\tlra-constraints.c, lra-eliminations.c, lra-int.h, lra-lives.c,\n+\tlra-spills.c, lra.c, lra.h, machmode.h, omp-low.c, optabs.c, optabs.h,\n+\toutput.h, postreload.c, print-tree.c, read-rtl.c, real.c, real.h,\n+\trecog.c, recog.h, ree.c, reg-stack.c, regcprop.c, reginfo.c,\n+\tregrename.c, regs.h, reload.c, reload.h, reload1.c, rtl.c, rtl.h,\n+\trtlanal.c, rtlhash.c, rtlhooks-def.h, rtlhooks.c, sched-deps.c,\n+\tsel-sched-dump.c, sel-sched-ir.c, sel-sched-ir.h, sel-sched.c,\n+\tsimplify-rtx.c, stmt.c, stor-layout.c, stor-layout.h, target.def,\n+\ttarghooks.c, targhooks.h, tree-affine.c, tree-call-cdce.c,\n+\ttree-complex.c, tree-data-ref.c, tree-dfa.c, tree-if-conv.c,\n+\ttree-inline.c, tree-outof-ssa.c, tree-scalar-evolution.c,\n+\ttree-ssa-address.c, tree-ssa-ccp.c, tree-ssa-loop-ivopts.c,\n+\ttree-ssa-loop-ivopts.h, tree-ssa-loop-manip.c,\n+\ttree-ssa-loop-prefetch.c, tree-ssa-math-opts.c, tree-ssa-reassoc.c,\n+\ttree-ssa-sccvn.c, tree-streamer-in.c, tree-switch-conversion.c,\n+\ttree-vect-data-refs.c, tree-vect-generic.c, tree-vect-loop.c,\n+\ttree-vect-patterns.c, tree-vect-slp.c, tree-vect-stmts.c,\n+\ttree-vrp.c, tree.c, tree.h, tsan.c, ubsan.c, valtrack.c,\n+\tvar-tracking.c, varasm.c: Remove redundant enum from\n+\tmachine_mode.\n+\t* gengtype.c (main): Treat machine_mode as a scalar typedef.\n+\t* genmodes.c (emit_insn_modes_h): Hide inline functions if\n+\tUSED_FOR_TARGET.\n+\n 2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR rtl-optimization/63340 (part 2)"}, {"sha": "8c6bf7a5857ff566ed52ab79797040d2e7d74d9a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1,3 +1,9 @@\n+2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc-interface/decl.c, gcc-interface/gigi.h, gcc-interface/misc.c,\n+\tgcc-interface/trans.c, gcc-interface/utils.c, gcc-interface/utils2.c:\n+\tRemove redundant enum from machine_mode.\n+\n 2014-10-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gcc-interface/trans.c: Adjust include files."}, {"sha": "ed50294f2bae2ae1353c00f06f19ddaa986cc9d2", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -3738,7 +3738,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* True if we make a dummy type here.  */\n \tbool made_dummy = false;\n \t/* The mode to be used for the pointer type.  */\n-\tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n+\tmachine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n \t/* The GCC type used for the designated type.  */\n \ttree gnu_desig_type = NULL_TREE;\n \n@@ -4470,7 +4470,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    unsigned int size\n \t\t      = TREE_INT_CST_LOW (TYPE_SIZE (gnu_return_type));\n \t\t    unsigned int i = BITS_PER_UNIT;\n-\t\t    enum machine_mode mode;\n+\t\t    machine_mode mode;\n \n \t\t    while (i < size)\n \t\t      i <<= 1;\n@@ -6157,7 +6157,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \t{\n \t  HOST_WIDE_INT bitsize, bitpos;\n \t  tree offset;\n-\t  enum machine_mode mode;\n+\t  machine_mode mode;\n \t  int unsignedp, volatilep;\n \n \t  inner = get_inner_reference (inner, &bitsize, &bitpos, &offset,\n@@ -7841,7 +7841,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n      by the smallest integral mode that's valid for pointers.  */\n   if (TREE_CODE (gnu_type) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n-      enum machine_mode p_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+      machine_mode p_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n       while (!targetm.valid_pointer_mode (p_mode))\n \tp_mode = GET_MODE_WIDER_MODE (p_mode);\n       type_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n@@ -8051,7 +8051,7 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, bool comp_p)\n {\n   Node_Id gnat_error_point = gnat_entity;\n   Node_Id gnat_node;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned int align;\n   tree size;\n "}, {"sha": "6d65fc519e4a23d7b1841224960d20487df1e76b", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -533,7 +533,7 @@ extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n \n /* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n    an unsigned type; otherwise a signed type is returned.  */\n-extern tree gnat_type_for_mode (enum machine_mode mode, int unsignedp);\n+extern tree gnat_type_for_mode (machine_mode mode, int unsignedp);\n \n /* Emit debug info for all global variable declarations.  */\n extern void gnat_write_global_declarations (void);"}, {"sha": "4510cd141c36d665e9c4a0202af886f7daf3b264", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -725,8 +725,8 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \n   for (iloop = 0; iloop < NUM_MACHINE_MODES; iloop++)\n     {\n-      enum machine_mode i = (enum machine_mode) iloop;\n-      enum machine_mode inner_mode = i;\n+      machine_mode i = (machine_mode) iloop;\n+      machine_mode inner_mode = i;\n       bool float_p = false;\n       bool complex_p = false;\n       bool vector_p = false;\n@@ -821,7 +821,7 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n int\n fp_prec_to_size (int prec)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n@@ -836,7 +836,7 @@ fp_prec_to_size (int prec)\n int\n fp_size_to_prec (int size)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))"}, {"sha": "a343261dce930528ce4f6b94d00943a1f2789cf9", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1268,7 +1268,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t  Node_Id gnat_expr = Expression (gnat_temp);\n \t  tree gnu_expr = gnat_to_gnu (gnat_expr);\n \t  int use_address;\n-\t  enum machine_mode mode;\n+\t  machine_mode mode;\n \t  tree asm_constraint = NULL_TREE;\n #ifdef ASM_COMMENT_START\n \t  char *comment;\n@@ -2126,7 +2126,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \ttree gnu_field_bitpos;\n \ttree gnu_field_offset;\n \ttree gnu_inner;\n-\tenum machine_mode mode;\n+\tmachine_mode mode;\n \tint unsignedp, volatilep;\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));"}, {"sha": "39350f75deef97e5219d808da2364e646eecc7df", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -251,7 +251,7 @@ static GTY ((if_marked (\"pad_type_hash_marked_p\"),\n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n-static tree float_type_for_precision (int, enum machine_mode);\n+static tree float_type_for_precision (int, machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static unsigned int scale_by_factor_of (tree, unsigned int);\n static bool potential_alignment_gap (tree, tree, tree);\n@@ -1128,7 +1128,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \t may need to return the thin pointer.  */\n       if (TYPE_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n \t{\n-\t  enum machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n+\t  machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n \t  if (!targetm.valid_pointer_mode (p_mode))\n \t    p_mode = ptr_mode;\n \t  return\n@@ -3222,7 +3222,7 @@ gnat_type_for_size (unsigned precision, int unsignedp)\n /* Likewise for floating-point types.  */\n \n static tree\n-float_type_for_precision (int precision, enum machine_mode mode)\n+float_type_for_precision (int precision, machine_mode mode)\n {\n   tree t;\n   char type_name[20];\n@@ -3248,7 +3248,7 @@ float_type_for_precision (int precision, enum machine_mode mode)\n    an unsigned type; otherwise a signed type is returned.  */\n \n tree\n-gnat_type_for_mode (enum machine_mode mode, int unsignedp)\n+gnat_type_for_mode (machine_mode mode, int unsignedp)\n {\n   if (mode == BLKmode)\n     return NULL_TREE;\n@@ -3267,7 +3267,7 @@ gnat_type_for_mode (enum machine_mode mode, int unsignedp)\n \n   if (VECTOR_MODE_P (mode))\n     {\n-      enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+      machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = gnat_type_for_mode (inner_mode, unsignedp);\n       if (inner_type)\n \treturn build_vector_type_for_mode (inner_type, mode);\n@@ -3580,7 +3580,7 @@ build_template (tree template_type, tree array_type, tree expr)\n static bool\n type_for_vector_element_p (tree type)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (!INTEGRAL_TYPE_P (type)\n       && !SCALAR_FLOAT_TYPE_P (type)"}, {"sha": "e853e1f55f2f1d3c232fe22608ddd0d9e4b85f8b", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1314,7 +1314,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      HOST_WIDE_INT bitsize;\n \t      HOST_WIDE_INT bitpos;\n \t      tree offset, inner;\n-\t      enum machine_mode mode;\n+\t      machine_mode mode;\n \t      int unsignedp, volatilep;\n \n \t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,"}, {"sha": "f1d9416c7b7f9f3000848c0fadd99ac306a27359", "filename": "gcc/addresses.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Faddresses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Faddresses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faddresses.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_ADDRESSES_H\n \n static inline enum reg_class\n-base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n \t\taddr_space_t as ATTRIBUTE_UNUSED,\n \t\tenum rtx_code outer_code ATTRIBUTE_UNUSED,\n \t\tenum rtx_code index_code ATTRIBUTE_UNUSED)\n@@ -52,7 +52,7 @@ base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n static inline bool\n ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n-\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t addr_space_t as ATTRIBUTE_UNUSED,\n \t\t enum rtx_code outer_code ATTRIBUTE_UNUSED,\n \t\t enum rtx_code index_code ATTRIBUTE_UNUSED)\n@@ -77,7 +77,7 @@ ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n    complete.  Arguments as for the called function.  */\n \n static inline bool\n-regno_ok_for_base_p (unsigned regno, enum machine_mode mode, addr_space_t as,\n+regno_ok_for_base_p (unsigned regno, machine_mode mode, addr_space_t as,\n \t\t     enum rtx_code outer_code, enum rtx_code index_code)\n {\n   if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)"}, {"sha": "aa6ae418522a5fe9bee19a8e8994eab22464f270", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -161,15 +161,15 @@ typedef struct alias_set_entry_d *alias_set_entry;\n static int rtx_equal_for_memref_p (const_rtx, const_rtx);\n static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n static void record_set (rtx, const_rtx, void *);\n-static int base_alias_check (rtx, rtx, rtx, rtx, enum machine_mode,\n-\t\t\t     enum machine_mode);\n+static int base_alias_check (rtx, rtx, rtx, rtx, machine_mode,\n+\t\t\t     machine_mode);\n static rtx find_base_value (rtx);\n static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n static int insert_subset_children (splay_tree_node, void*);\n static alias_set_entry get_alias_set_entry (alias_set_type);\n static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n-\t\t\t       const_rtx, enum machine_mode, rtx,\n+\t\t\t       const_rtx, machine_mode, rtx,\n \t\t\t       bool, bool, bool);\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n@@ -1802,7 +1802,7 @@ may_be_sp_based_p (rtx x)\n \n static int\n base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n-\t\t  enum machine_mode x_mode, enum machine_mode y_mode)\n+\t\t  machine_mode x_mode, machine_mode y_mode)\n {\n   /* If the address itself has no known base see if a known equivalent\n      value has one.  If either address still has no known base, nothing\n@@ -2446,7 +2446,7 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n    Returns 1 if there is a true dependence, 0 otherwise.  */\n \n static int\n-true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n+true_dependence_1 (const_rtx mem, machine_mode mem_mode, rtx mem_addr,\n \t\t   const_rtx x, rtx x_addr, bool mem_canonicalized)\n {\n   rtx true_mem_addr;\n@@ -2528,7 +2528,7 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n-true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x)\n+true_dependence (const_rtx mem, machine_mode mem_mode, const_rtx x)\n {\n   return true_dependence_1 (mem, mem_mode, NULL_RTX,\n \t\t\t    x, NULL_RTX, /*mem_canonicalized=*/false);\n@@ -2541,7 +2541,7 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x)\n    this value prior to canonicalizing.  */\n \n int\n-canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n+canon_true_dependence (const_rtx mem, machine_mode mem_mode, rtx mem_addr,\n \t\t       const_rtx x, rtx x_addr)\n {\n   return true_dependence_1 (mem, mem_mode, mem_addr,\n@@ -2556,7 +2556,7 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n \n static int\n write_dependence_p (const_rtx mem,\n-\t\t    const_rtx x, enum machine_mode x_mode, rtx x_addr,\n+\t\t    const_rtx x, machine_mode x_mode, rtx x_addr,\n \t\t    bool mem_canonicalized, bool x_canonicalized, bool writep)\n {\n   rtx mem_addr;\n@@ -2651,7 +2651,7 @@ anti_dependence (const_rtx mem, const_rtx x)\n \n int\n canon_anti_dependence (const_rtx mem, bool mem_canonicalized,\n-\t\t       const_rtx x, enum machine_mode x_mode, rtx x_addr)\n+\t\t       const_rtx x, machine_mode x_mode, rtx x_addr)\n {\n   return write_dependence_p (mem, x, x_mode, x_addr,\n \t\t\t     mem_canonicalized, /*x_canonicalized=*/true,"}, {"sha": "b4b08228933680b37c277653de3c4bbb7cb29b60", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1780,7 +1780,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int volatilep = 0, unsignedp = 0;\n   tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset,\n \t\t\t\t    &mode, &unsignedp, &volatilep, false);"}, {"sha": "d0d2be654f1887efa2a292f7e624151d09b428d0", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -481,7 +481,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   rtx_insn *mov_insn = NULL;\n   int regno;\n   rtx mem = *mem_insn.mem_loc;\n-  enum machine_mode mode = GET_MODE (mem);\n+  machine_mode mode = GET_MODE (mem);\n   rtx new_mem;\n   int old_cost = 0;\n   int new_cost = 0;\n@@ -621,7 +621,7 @@ try_merge (void)\n   /* The width of the mem being accessed.  */\n   int size = GET_MODE_SIZE (GET_MODE (mem));\n   rtx_insn *last_insn = NULL;\n-  enum machine_mode reg_mode = GET_MODE (inc_reg);\n+  machine_mode reg_mode = GET_MODE (inc_reg);\n \n   switch (inc_insn.form)\n     {"}, {"sha": "66bbf03bd00885ee260c11d1b538590788d991e0", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1153,7 +1153,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   rtx src;\n   rtx btr_rtx;\n   rtx_insn *new_insn;\n-  enum machine_mode btr_mode;\n+  machine_mode btr_mode;\n   btr_user user;\n   rtx set;\n "}, {"sha": "dd0869d366f2cfc2da0afd202be7d63c00dd2fac", "filename": "gcc/builtins.c", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -92,7 +92,7 @@ builtin_info_type builtin_info;\n /* Non-zero if __builtin_constant_p should be folded right away.  */\n bool force_folding_builtin_constant_p;\n \n-static rtx c_readstr (const char *, enum machine_mode);\n+static rtx c_readstr (const char *, machine_mode);\n static int target_char_cast (tree, char *);\n static rtx get_memory_rtx (tree, tree);\n static int apply_args_size (void);\n@@ -122,25 +122,25 @@ static rtx expand_builtin_next_arg (void);\n static rtx expand_builtin_va_start (tree);\n static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n-static rtx expand_builtin_memcmp (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_memcmp (tree, rtx, machine_mode);\n static rtx expand_builtin_strcmp (tree, rtx);\n-static rtx expand_builtin_strncmp (tree, rtx, enum machine_mode);\n-static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n+static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memcpy (tree, rtx);\n-static rtx expand_builtin_mempcpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_mempcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n-\t\t\t\t\tenum machine_mode, int);\n+\t\t\t\t\tmachine_mode, int);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n-static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_strncpy (tree, rtx);\n-static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, enum machine_mode);\n-static rtx expand_builtin_memset (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_memset_args (tree, tree, tree, rtx, enum machine_mode, tree);\n+static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, machine_mode);\n+static rtx expand_builtin_memset (tree, rtx, machine_mode);\n+static rtx expand_builtin_memset_args (tree, tree, tree, rtx, machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n-static rtx expand_builtin_strlen (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strlen (tree, rtx, machine_mode);\n static rtx expand_builtin_alloca (tree, bool);\n-static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n+static rtx expand_builtin_unop (machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n static tree stabilize_va_list_loc (location_t, tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n@@ -197,7 +197,7 @@ static tree fold_builtin_strspn (location_t, tree, tree);\n static tree fold_builtin_strcspn (location_t, tree, tree);\n \n static rtx expand_builtin_object_size (tree);\n-static rtx expand_builtin_memory_chk (tree, rtx, enum machine_mode,\n+static rtx expand_builtin_memory_chk (tree, rtx, machine_mode,\n \t\t\t\t      enum built_in_function);\n static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n@@ -290,7 +290,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n {\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsignedp, volatilep;\n   unsigned int align = BITS_PER_UNIT;\n   bool known_alignment = false;\n@@ -652,7 +652,7 @@ c_getstr (tree src)\n    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */\n \n static rtx\n-c_readstr (const char *str, enum machine_mode mode)\n+c_readstr (const char *str, machine_mode mode)\n {\n   HOST_WIDE_INT ch;\n   unsigned int i, j;\n@@ -826,7 +826,7 @@ static alias_set_type setjmp_alias_set = -1;\n void\n expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n {\n-  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n   rtx stack_save;\n   rtx mem;\n \n@@ -970,7 +970,7 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n {\n   rtx fp, lab, stack;\n   rtx_insn *insn, *last;\n-  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n \n   /* DRAP is needed for stack realign if longjmp is expanded to current\n      function  */\n@@ -1197,7 +1197,7 @@ expand_builtin_nonlocal_goto (tree exp)\n static void\n expand_builtin_update_setjmp_buf (rtx buf_addr)\n {\n-  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n   rtx stack_save\n     = gen_rtx_MEM (sa_mode,\n \t\t   memory_address\n@@ -1359,7 +1359,7 @@ apply_args_size (void)\n   static int size = -1;\n   int align;\n   unsigned int regno;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* The values computed by this function never change.  */\n   if (size < 0)\n@@ -1401,7 +1401,7 @@ apply_result_size (void)\n {\n   static int size = -1;\n   int align, regno;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* The values computed by this function never change.  */\n   if (size < 0)\n@@ -1442,7 +1442,7 @@ static rtx\n result_vector (int savep, rtx result)\n {\n   int regno, size, align, nelts;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx reg, mem;\n   rtx *savevec = XALLOCAVEC (rtx, FIRST_PSEUDO_REGISTER);\n \n@@ -1472,7 +1472,7 @@ expand_builtin_apply_args_1 (void)\n {\n   rtx registers, tem;\n   int size, align, regno;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx struct_incoming_value = targetm.calls.struct_value_rtx (cfun ? TREE_TYPE (cfun->decl) : 0, 1);\n \n   /* Create a block where the arg-pointer, structure value address,\n@@ -1577,7 +1577,7 @@ static rtx\n expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n {\n   int size, align, regno;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx incoming_args, result, reg, dest, src;\n   rtx_call_insn *call_insn;\n   rtx old_stack_level = 0;\n@@ -1744,7 +1744,7 @@ static void\n expand_builtin_return (rtx result)\n {\n   int size, align, regno;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx reg;\n   rtx_insn *call_fusage = 0;\n \n@@ -2024,7 +2024,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n   rtx op0;\n   rtx_insn *insns;\n   tree fndecl = get_callee_fndecl (exp);\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool errno_set = false;\n   bool try_widening = false;\n   tree arg;\n@@ -2153,7 +2153,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   int op1_type = REAL_TYPE;\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg0, arg1;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool errno_set = true;\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n@@ -2262,7 +2262,7 @@ expand_builtin_mathfn_ternary (tree exp, rtx target, rtx subtarget)\n   rtx_insn *insns;\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg0, arg1, arg2;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (!validate_arglist (exp, REAL_TYPE, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -2335,7 +2335,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n   rtx op0;\n   rtx_insn *insns;\n   tree fndecl = get_callee_fndecl (exp);\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree arg;\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n@@ -2431,7 +2431,7 @@ interclass_mathfn_icode (tree arg, tree fndecl)\n {\n   bool errno_set = false;\n   optab builtin_optab = unknown_optab;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n@@ -2479,7 +2479,7 @@ expand_builtin_interclass_mathfn (tree exp, rtx target)\n   enum insn_code icode = CODE_FOR_nothing;\n   rtx op0;\n   tree fndecl = get_callee_fndecl (exp);\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree arg;\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n@@ -2526,7 +2526,7 @@ static rtx\n expand_builtin_sincos (tree exp)\n {\n   rtx op0, op1, op2, target1, target2;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree arg, sinp, cosp;\n   int result;\n   location_t loc = EXPR_LOCATION (exp);\n@@ -2580,7 +2580,7 @@ expand_builtin_cexpi (tree exp, rtx target)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg, type;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx op0, op1, op2;\n   location_t loc = EXPR_LOCATION (exp);\n \n@@ -2715,7 +2715,7 @@ expand_builtin_int_roundingfn (tree exp, rtx target)\n   tree fndecl = get_callee_fndecl (exp);\n   enum built_in_function fallback_fn;\n   tree fallback_fndecl;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree arg;\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n@@ -2851,7 +2851,7 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n   rtx_insn *insns;\n   tree fndecl = get_callee_fndecl (exp);\n   tree arg;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum built_in_function fallback_fn = BUILT_IN_NONE;\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n@@ -2949,8 +2949,8 @@ expand_builtin_powi (tree exp, rtx target)\n {\n   tree arg0, arg1;\n   rtx op0, op1;\n-  enum machine_mode mode;\n-  enum machine_mode mode2;\n+  machine_mode mode;\n+  machine_mode mode2;\n \n   if (! validate_arglist (exp, REAL_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -2987,7 +2987,7 @@ expand_builtin_powi (tree exp, rtx target)\n \n static rtx\n expand_builtin_strlen (tree exp, rtx target,\n-\t\t       enum machine_mode target_mode)\n+\t\t       machine_mode target_mode)\n {\n   if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -2999,7 +2999,7 @@ expand_builtin_strlen (tree exp, rtx target,\n       tree src = CALL_EXPR_ARG (exp, 0);\n       rtx src_reg;\n       rtx_insn *before_strlen;\n-      enum machine_mode insn_mode = target_mode;\n+      machine_mode insn_mode = target_mode;\n       enum insn_code icode = CODE_FOR_nothing;\n       unsigned int align;\n \n@@ -3092,7 +3092,7 @@ expand_builtin_strlen (tree exp, rtx target,\n \n static rtx\n builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -3265,7 +3265,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n    stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n {\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3288,7 +3288,7 @@ expand_builtin_mempcpy (tree exp, rtx target, enum machine_mode mode)\n \n static rtx\n expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n-\t\t\t     rtx target, enum machine_mode mode, int endp)\n+\t\t\t     rtx target, machine_mode mode, int endp)\n {\n     /* If return value is ignored, transform mempcpy into memcpy.  */\n   if (target == const0_rtx && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n@@ -3444,7 +3444,7 @@ expand_builtin_strcpy_args (tree dest, tree src, rtx target)\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n {\n   tree dst, src;\n   location_t loc = EXPR_LOCATION (exp);\n@@ -3520,7 +3520,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \n rtx\n builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n-\t\t\t  enum machine_mode mode)\n+\t\t\t  machine_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -3586,7 +3586,7 @@ expand_builtin_strncpy (tree exp, rtx target)\n \n rtx\n builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n   const char *c = (const char *) data;\n   char *p = XALLOCAVEC (char, GET_MODE_SIZE (mode));\n@@ -3603,7 +3603,7 @@ builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n \n static rtx\n builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode)\n+\t\t\tmachine_mode mode)\n {\n   rtx target, coeff;\n   size_t size;\n@@ -3628,7 +3628,7 @@ builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n    convenient).  */\n \n static rtx\n-expand_builtin_memset (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n {\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3650,11 +3650,11 @@ expand_builtin_memset (tree exp, rtx target, enum machine_mode mode)\n \n static rtx\n expand_builtin_memset_args (tree dest, tree val, tree len,\n-\t\t\t    rtx target, enum machine_mode mode, tree orig_exp)\n+\t\t\t    rtx target, machine_mode mode, tree orig_exp)\n {\n   tree fndecl, fn;\n   enum built_in_function fcode;\n-  enum machine_mode val_mode;\n+  machine_mode val_mode;\n   char c;\n   unsigned int dest_align;\n   rtx dest_mem, dest_addr, len_rtx;\n@@ -3816,7 +3816,7 @@ expand_builtin_bzero (tree exp)\n \n static rtx\n expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n-\t\t       ATTRIBUTE_UNUSED enum machine_mode mode)\n+\t\t       ATTRIBUTE_UNUSED machine_mode mode)\n {\n   location_t loc ATTRIBUTE_UNUSED = EXPR_LOCATION (exp);\n \n@@ -3838,7 +3838,7 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n     unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n     unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n-    enum machine_mode insn_mode;\n+    machine_mode insn_mode;\n \n     if (HAVE_cmpmemsi)\n       insn_mode = insn_data[(int) CODE_FOR_cmpmemsi].operand[0].mode;\n@@ -3939,7 +3939,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n       /* Try to call cmpstrsi.  */\n       if (HAVE_cmpstrsi)\n \t{\n-\t  enum machine_mode insn_mode\n+\t  machine_mode insn_mode\n \t    = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \n \t  /* Make a place to write the result of the instruction.  */\n@@ -3960,7 +3960,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \t  tree len;\n \t  rtx arg3_rtx;\n \n-\t  enum machine_mode insn_mode\n+\t  machine_mode insn_mode\n \t    = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n \t  tree len1 = c_strlen (arg1, 1);\n \t  tree len2 = c_strlen (arg2, 1);\n@@ -4014,7 +4014,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \n       if (insn)\n \t{\n-\t  enum machine_mode mode;\n+\t  machine_mode mode;\n \t  emit_insn (insn);\n \n \t  /* Return the value in the proper mode for this function.  */\n@@ -4048,7 +4048,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \n static rtx\n expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n-\t\t\tATTRIBUTE_UNUSED enum machine_mode mode)\n+\t\t\tATTRIBUTE_UNUSED machine_mode mode)\n {\n   location_t loc ATTRIBUTE_UNUSED = EXPR_LOCATION (exp);\n \n@@ -4072,7 +4072,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n     unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n     unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n-    enum machine_mode insn_mode\n+    machine_mode insn_mode\n       = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n \n     len1 = c_strlen (arg1, 1);\n@@ -4511,7 +4511,7 @@ expand_builtin_alloca (tree exp, bool cannot_accumulate)\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n \n static rtx\n-expand_builtin_bswap (enum machine_mode target_mode, tree exp, rtx target,\n+expand_builtin_bswap (machine_mode target_mode, tree exp, rtx target,\n \t\t      rtx subtarget)\n {\n   tree arg;\n@@ -4541,7 +4541,7 @@ expand_builtin_bswap (enum machine_mode target_mode, tree exp, rtx target,\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n \n static rtx\n-expand_builtin_unop (enum machine_mode target_mode, tree exp, rtx target,\n+expand_builtin_unop (machine_mode target_mode, tree exp, rtx target,\n \t\t     rtx subtarget, optab op_optab)\n {\n   rtx op0;\n@@ -4640,7 +4640,7 @@ expand_builtin_unreachable (void)\n static rtx\n expand_builtin_fabs (tree exp, rtx target, rtx subtarget)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree arg;\n   rtx op0;\n \n@@ -4837,7 +4837,7 @@ static rtx\n expand_builtin_signbit (tree exp, rtx target)\n {\n   const struct real_format *fmt;\n-  enum machine_mode fmode, imode, rmode;\n+  machine_mode fmode, imode, rmode;\n   tree arg;\n   int word, bitpos;\n   enum insn_code icode;\n@@ -5010,7 +5010,7 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n    FCODE_DIFF should be fcode - base, where base is the FOO_1 code for the\n    group of builtins.  This gives us log2 of the mode size.  */\n \n-static inline enum machine_mode\n+static inline machine_mode\n get_builtin_sync_mode (int fcode_diff)\n {\n   /* The size is not negotiable, so ask not to get BLKmode in return\n@@ -5022,7 +5022,7 @@ get_builtin_sync_mode (int fcode_diff)\n    for the builtin_sync operations.  */\n \n static rtx\n-get_builtin_sync_mem (tree loc, enum machine_mode mode)\n+get_builtin_sync_mem (tree loc, machine_mode mode)\n {\n   rtx addr, mem;\n \n@@ -5048,10 +5048,10 @@ get_builtin_sync_mem (tree loc, enum machine_mode mode)\n    MODE is the mode it should be in.  */\n \n static rtx\n-expand_expr_force_mode (tree exp, enum machine_mode mode)\n+expand_expr_force_mode (tree exp, machine_mode mode)\n {\n   rtx val;\n-  enum machine_mode old_mode;\n+  machine_mode old_mode;\n \n   val = expand_expr (exp, NULL_RTX, mode, EXPAND_NORMAL);\n   /* If VAL is promoted to a wider mode, convert it back to MODE.  Take care\n@@ -5073,7 +5073,7 @@ expand_expr_force_mode (tree exp, enum machine_mode mode)\n    fetch_and_xxx form.  */\n \n static rtx\n-expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n+expand_builtin_sync_operation (machine_mode mode, tree exp,\n \t\t\t       enum rtx_code code, bool after,\n \t\t\t       rtx target)\n {\n@@ -5134,7 +5134,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n    results; this is NOT optional if IS_BOOL is true.  */\n \n static rtx\n-expand_builtin_compare_and_swap (enum machine_mode mode, tree exp,\n+expand_builtin_compare_and_swap (machine_mode mode, tree exp,\n \t\t\t\t bool is_bool, rtx target)\n {\n   rtx old_val, new_val, mem;\n@@ -5168,7 +5168,7 @@ expand_builtin_compare_and_swap (enum machine_mode mode, tree exp,\n    the results.  */\n \n static rtx\n-expand_builtin_sync_lock_test_and_set (enum machine_mode mode, tree exp,\n+expand_builtin_sync_lock_test_and_set (machine_mode mode, tree exp,\n \t\t\t\t       rtx target)\n {\n   rtx val, mem;\n@@ -5183,7 +5183,7 @@ expand_builtin_sync_lock_test_and_set (enum machine_mode mode, tree exp,\n /* Expand the __sync_lock_release intrinsic.  EXP is the CALL_EXPR.  */\n \n static void\n-expand_builtin_sync_lock_release (enum machine_mode mode, tree exp)\n+expand_builtin_sync_lock_release (machine_mode mode, tree exp)\n {\n   rtx mem;\n \n@@ -5235,7 +5235,7 @@ get_memmodel (tree exp)\n    TARGET is an optional place for us to store the results.  */\n \n static rtx\n-expand_builtin_atomic_exchange (enum machine_mode mode, tree exp, rtx target)\n+expand_builtin_atomic_exchange (machine_mode mode, tree exp, rtx target)\n {\n   rtx val, mem;\n   enum memmodel model;\n@@ -5266,7 +5266,7 @@ expand_builtin_atomic_exchange (enum machine_mode mode, tree exp, rtx target)\n    TARGET is an optional place for us to store the results.  */\n \n static rtx\n-expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp, \n+expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp, \n \t\t\t\t\trtx target)\n {\n   rtx expect, desired, mem, oldval;\n@@ -5338,7 +5338,7 @@ expand_builtin_atomic_compare_exchange (enum machine_mode mode, tree exp,\n    TARGET is an optional place for us to store the results.  */\n \n static rtx\n-expand_builtin_atomic_load (enum machine_mode mode, tree exp, rtx target)\n+expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n {\n   rtx mem;\n   enum memmodel model;\n@@ -5367,7 +5367,7 @@ expand_builtin_atomic_load (enum machine_mode mode, tree exp, rtx target)\n    TARGET is an optional place for us to store the results.  */\n \n static rtx\n-expand_builtin_atomic_store (enum machine_mode mode, tree exp)\n+expand_builtin_atomic_store (machine_mode mode, tree exp)\n {\n   rtx mem, val;\n   enum memmodel model;\n@@ -5403,7 +5403,7 @@ expand_builtin_atomic_store (enum machine_mode mode, tree exp)\n    resolved to an instruction sequence.  */\n \n static rtx\n-expand_builtin_atomic_fetch_op (enum machine_mode mode, tree exp, rtx target,\n+expand_builtin_atomic_fetch_op (machine_mode mode, tree exp, rtx target,\n \t\t\t\tenum rtx_code code, bool fetch_after,\n \t\t\t\tbool ignore, enum built_in_function ext_call)\n {\n@@ -5473,7 +5473,7 @@ expand_builtin_atomic_fetch_op (enum machine_mode mode, tree exp, rtx target,\n static rtx\n expand_builtin_atomic_clear (tree exp) \n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx mem, ret;\n   enum memmodel model;\n \n@@ -5514,7 +5514,7 @@ expand_builtin_atomic_test_and_set (tree exp, rtx target)\n {\n   rtx mem;\n   enum memmodel model;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = mode_for_size (BOOL_TYPE_SIZE, MODE_INT, 0);\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n@@ -5531,7 +5531,7 @@ static tree\n fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n {\n   int size;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned int mode_align, type_align;\n \n   if (TREE_CODE (arg0) != INTEGER_CST)\n@@ -5758,12 +5758,12 @@ expand_stack_save (void)\n    IGNORE is nonzero if the value is to be ignored.  */\n \n rtx\n-expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n+expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \t\tint ignore)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  enum machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n+  machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n   int flags;\n \n   /* When ASan is enabled, we don't want to expand some memory/string\n@@ -9359,7 +9359,7 @@ fold_builtin_modf (location_t loc, tree arg0, tree arg1, tree rettype)\n static tree\n fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (!validate_arg (arg, REAL_TYPE))\n     return NULL_TREE;\n@@ -9547,7 +9547,7 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n {\n   tree fp_nan, fp_infinite, fp_normal, fp_subnormal, fp_zero,\n     arg, type, res, tmp;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   REAL_VALUE_TYPE r;\n   char buf[128];\n \n@@ -10691,7 +10691,7 @@ rtx\n default_expand_builtin (tree exp ATTRIBUTE_UNUSED,\n \t\t\trtx target ATTRIBUTE_UNUSED,\n \t\t\trtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tint ignore ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n@@ -11283,7 +11283,7 @@ expand_builtin_object_size (tree exp)\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n+expand_builtin_memory_chk (tree exp, rtx target, machine_mode mode,\n \t\t\t   enum built_in_function fcode)\n {\n   tree dest, src, len, size;"}, {"sha": "7960b0158db918c975d11e7924509c920f512cf2", "filename": "gcc/builtins.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -29,14 +29,14 @@ struct target_builtins {\n      the register is not used for calling a function.  If the machine\n      has register windows, this gives only the outbound registers.\n      INCOMING_REGNO gives the corresponding inbound register.  */\n-  enum machine_mode x_apply_args_mode[FIRST_PSEUDO_REGISTER];\n+  machine_mode x_apply_args_mode[FIRST_PSEUDO_REGISTER];\n \n   /* For each register that may be used for returning values, this gives\n      a mode used to copy the register's value.  VOIDmode indicates the\n      register is not used for returning values.  If the machine has\n      register windows, this gives only the outbound registers.\n      INCOMING_REGNO gives the corresponding inbound register.  */\n-  enum machine_mode x_apply_result_mode[FIRST_PSEUDO_REGISTER];\n+  machine_mode x_apply_result_mode[FIRST_PSEUDO_REGISTER];\n };\n \n extern struct target_builtins default_target_builtins;\n@@ -60,15 +60,15 @@ extern tree c_strlen (tree, int);\n extern void expand_builtin_setjmp_setup (rtx, rtx);\n extern void expand_builtin_setjmp_receiver (rtx);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n-extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n-extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n+extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, machine_mode);\n extern rtx expand_builtin_saveregs (void);\n extern tree std_build_builtin_va_list (void);\n extern tree std_fn_abi_va_list (tree);\n extern tree std_canonical_va_list_type (tree);\n extern void std_expand_builtin_va_start (tree, rtx);\n extern void expand_builtin_trap (void);\n-extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_expect (location_t, tree, tree, tree);\n extern tree fold_fma (location_t, tree, tree, tree, tree);\n@@ -77,7 +77,7 @@ extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n extern tree fold_builtin_n (location_t, tree, tree *, int, bool);\n extern bool validate_gimple_arglist (const_gimple, ...);\n-extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern rtx default_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern bool fold_builtin_next_arg (tree, bool);\n extern tree do_mpc_arg2 (tree, tree, tree, int, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n extern tree fold_call_stmt (gimple, bool);"}, {"sha": "4052b5edc7446d4d586d09eb95c1a739c8ac35f4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1,3 +1,8 @@\n+2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-common.c, c-common.h, c-cppbuiltin.c, c-lex.c: Remove redundant\n+\tenum from machine_mode.\n+\n 2014-10-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-family/c-common.c: Adjust include files."}, {"sha": "03137febc080c91cb4faa2caf3bda12b19213205", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -3507,7 +3507,7 @@ tree\n c_common_fixed_point_type_for_size (unsigned int ibit, unsigned int fbit,\n \t\t\t\t    int unsignedp, int satp)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   if (ibit == 0)\n     mode = unsignedp ? UQQmode : QQmode;\n   else\n@@ -3539,7 +3539,7 @@ tree registered_builtin_types;\n    then UNSIGNEDP selects between saturating and nonsaturating types.  */\n \n tree\n-c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n+c_common_type_for_mode (machine_mode mode, int unsignedp)\n {\n   tree t;\n   int i;\n@@ -3610,7 +3610,7 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n \n   if (COMPLEX_MODE_P (mode))\n     {\n-      enum machine_mode inner_mode;\n+      machine_mode inner_mode;\n       tree inner_type;\n \n       if (mode == TYPE_MODE (complex_float_type_node))\n@@ -3630,7 +3630,7 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n     }\n   else if (VECTOR_MODE_P (mode))\n     {\n-      enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+      machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = c_common_type_for_mode (inner_mode, unsignedp);\n       if (inner_type != NULL_TREE)\n \treturn build_vector_type_for_mode (inner_type, mode);\n@@ -7243,10 +7243,10 @@ handle_destructor_attribute (tree *node, tree name, tree args,\n    vector mode, but we can emulate with narrower modes.  */\n \n static int\n-vector_mode_valid_p (enum machine_mode mode)\n+vector_mode_valid_p (machine_mode mode)\n {\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n-  enum machine_mode innermode;\n+  machine_mode innermode;\n \n   /* Doh!  What's going on?  */\n   if (mclass != MODE_VECTOR_INT\n@@ -7291,7 +7291,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n       int j;\n       const char *p = IDENTIFIER_POINTER (ident);\n       int len = strlen (p);\n-      enum machine_mode mode = VOIDmode;\n+      machine_mode mode = VOIDmode;\n       tree typefm;\n       bool valid_mode;\n \n@@ -7323,7 +7323,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n \t  if (!strcmp (p, GET_MODE_NAME (j)))\n \t    {\n-\t      mode = (enum machine_mode) j;\n+\t      mode = (machine_mode) j;\n \t      break;\n \t    }\n \n@@ -7377,7 +7377,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n       if (POINTER_TYPE_P (type))\n \t{\n \t  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));\n-\t  tree (*fn)(tree, enum machine_mode, bool);\n+\t  tree (*fn)(tree, machine_mode, bool);\n \n \t  if (!targetm.addr_space.valid_pointer_mode (mode, as))\n \t    {\n@@ -8663,7 +8663,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \t\t\t      bool *no_add_attrs)\n {\n   unsigned HOST_WIDE_INT vecsize, nunits;\n-  enum machine_mode orig_mode;\n+  machine_mode orig_mode;\n   tree type = *node, new_type, size;\n \n   *no_add_attrs = true;"}, {"sha": "17b26ce993a123e417d9bec82866056db084fe5e", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -762,7 +762,7 @@ extern bool attribute_takes_identifier_p (const_tree);\n extern bool c_common_handle_option (size_t, const char *, int, int, location_t,\n \t\t\t\t    const struct cl_option_handlers *);\n extern bool default_handle_c_option (size_t, const char *, int);\n-extern tree c_common_type_for_mode (enum machine_mode, int);\n+extern tree c_common_type_for_mode (machine_mode, int);\n extern tree c_common_type_for_size (unsigned int, int);\n extern tree c_common_fixed_point_type_for_size (unsigned int, unsigned int,\n \t\t\t\t\t\tint, int);"}, {"sha": "803f146ad02ded06b55ad163ddddedbda61bf9ba", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -72,7 +72,7 @@ static void builtin_define_float_constants (const char *,\n    point types.  */\n \n static bool\n-mode_has_fma (enum machine_mode mode)\n+mode_has_fma (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -1006,7 +1006,7 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (flag_building_libgcc)\n     {\n       /* Properties of floating-point modes for libgcc2.c.  */\n-      for (enum machine_mode mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+      for (machine_mode mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n \t   mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n@@ -1364,7 +1364,7 @@ struct GTY(()) lazy_hex_fp_value_struct\n {\n   const char *hex_str;\n   cpp_macro *macro;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int digits;\n   const char *fp_suffix;\n };"}, {"sha": "d2c231cb86d5b41f42cb339abda6d84c102d5bb4", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -724,7 +724,7 @@ interpret_float (const cpp_token *token, unsigned int flags,\n     if (flags & CPP_N_WIDTH_MD)\n       {\n \tchar suffix;\n-\tenum machine_mode mode;\n+\tmachine_mode mode;\n \n \tif ((flags & CPP_N_WIDTH_MD) == CPP_N_MD_W)\n \t  suffix = 'w';"}, {"sha": "e2d061f928700f0ba247e1ac92e818a0c2218ebc", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1,3 +1,8 @@\n+2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-decl.c, c-tree.h, c-typeck.c: Remove redundant enum from\n+\tmachine_mode.\n+\n 2014-10-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-decl.c: Adjust include files."}, {"sha": "23cad017dad777765bfdf901c84db48108f4f7f6", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -161,7 +161,7 @@ static bool undef_nested_function;\n \n /* Mode used to build pointers (VOIDmode means ptr_mode).  */\n \n-enum machine_mode c_default_pointer_mode = VOIDmode;\n+machine_mode c_default_pointer_mode = VOIDmode;\n \n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n@@ -658,7 +658,7 @@ c_build_pointer_type (tree to_type)\n {\n   addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC\n \t\t\t\t\t      : TYPE_ADDR_SPACE (to_type);\n-  enum machine_mode pointer_mode;\n+  machine_mode pointer_mode;\n \n   if (as != ADDR_SPACE_GENERIC || c_default_pointer_mode == VOIDmode)\n     pointer_mode = targetm.addr_space.pointer_mode (as);"}, {"sha": "f7e723b932ac88ac058cdcafaa2d6ac6f6bdcd1c", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -670,7 +670,7 @@ extern int current_function_returns_abnormally;\n \n /* Mode used to build pointers (VOIDmode means ptr_mode).  */\n \n-extern enum machine_mode c_default_pointer_mode;\n+extern machine_mode c_default_pointer_mode;\n \n /* In c-decl.c */\n "}, {"sha": "79dbc3dff91c62c69649aa527291710f0536f894", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -821,7 +821,7 @@ c_common_type (tree t1, tree t2)\n   if (code1 == FIXED_POINT_TYPE || code2 == FIXED_POINT_TYPE)\n     {\n       unsigned int unsignedp = 0, satp = 0;\n-      enum machine_mode m1, m2;\n+      machine_mode m1, m2;\n       unsigned int fbit1, ibit1, fbit2, ibit2, max_fbit, max_ibit;\n \n       m1 = TYPE_MODE (t1);"}, {"sha": "fdde47e4f5757f88f97266e4952e28aba1f18e95", "filename": "gcc/caller-save.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -81,11 +81,11 @@ static int n_regs_saved;\n static HARD_REG_SET referenced_regs;\n \n \n-typedef void refmarker_fn (rtx *loc, enum machine_mode mode, int hardregno,\n+typedef void refmarker_fn (rtx *loc, machine_mode mode, int hardregno,\n \t\t\t   void *mark_arg);\n \n-static int reg_save_code (int, enum machine_mode);\n-static int reg_restore_code (int, enum machine_mode);\n+static int reg_save_code (int, machine_mode);\n+static int reg_restore_code (int, machine_mode);\n \n struct saved_hard_reg;\n static void initiate_saved_hard_regs (void);\n@@ -98,9 +98,9 @@ static void mark_referenced_regs (rtx *, refmarker_fn *mark, void *mark_arg);\n static refmarker_fn mark_reg_as_referenced;\n static refmarker_fn replace_reg_with_saved_mem;\n static int insert_save (struct insn_chain *, int, int, HARD_REG_SET *,\n-\t\t\tenum machine_mode *);\n+\t\t\tmachine_mode *);\n static int insert_restore (struct insn_chain *, int, int, int,\n-\t\t\t   enum machine_mode *);\n+\t\t\t   machine_mode *);\n static struct insn_chain *insert_one_insn (struct insn_chain *, int, int,\n \t\t\t\t\t   rtx);\n static void add_stored_regs (rtx, const_rtx, void *);\n@@ -116,7 +116,7 @@ static GTY(()) rtx_insn *restinsn;\n \n /* Return the INSN_CODE used to save register REG in mode MODE.  */\n static int\n-reg_save_code (int reg, enum machine_mode mode)\n+reg_save_code (int reg, machine_mode mode)\n {\n   bool ok;\n   if (cached_reg_save_code[reg][mode])\n@@ -170,7 +170,7 @@ reg_save_code (int reg, enum machine_mode mode)\n \n /* Return the INSN_CODE used to restore register REG in mode MODE.  */\n static int\n-reg_restore_code (int reg, enum machine_mode mode)\n+reg_restore_code (int reg, machine_mode mode)\n {\n   if (cached_reg_restore_code[reg][mode])\n      return cached_reg_restore_code[reg][mode];\n@@ -755,7 +755,7 @@ void\n save_call_clobbered_regs (void)\n {\n   struct insn_chain *chain, *next, *last = NULL;\n-  enum machine_mode save_mode [FIRST_PSEUDO_REGISTER];\n+  machine_mode save_mode [FIRST_PSEUDO_REGISTER];\n \n   /* Computed in mark_set_regs, holds all registers set by the current\n      instruction.  */\n@@ -841,7 +841,7 @@ save_call_clobbered_regs (void)\n \t\t{\n \t\t  int r = reg_renumber[regno];\n \t\t  int nregs;\n-\t\t  enum machine_mode mode;\n+\t\t  machine_mode mode;\n \n \t\t  if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t\t    continue;\n@@ -994,7 +994,7 @@ static void\n add_stored_regs (rtx reg, const_rtx setter, void *data)\n {\n   int regno, endregno, i;\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   int offset = 0;\n \n   if (GET_CODE (setter) == CLOBBER)\n@@ -1097,7 +1097,7 @@ mark_referenced_regs (rtx *loc, refmarker_fn *mark, void *arg)\n \n static void\n mark_reg_as_referenced (rtx *loc ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode,\n+\t\t\tmachine_mode mode,\n \t\t\tint hardregno,\n \t\t\tvoid *arg ATTRIBUTE_UNUSED)\n {\n@@ -1110,13 +1110,13 @@ mark_reg_as_referenced (rtx *loc ATTRIBUTE_UNUSED,\n \n static void\n replace_reg_with_saved_mem (rtx *loc,\n-\t\t\t    enum machine_mode mode,\n+\t\t\t    machine_mode mode,\n \t\t\t    int regno,\n \t\t\t    void *arg)\n {\n   unsigned int i, nregs = hard_regno_nregs [regno][mode];\n   rtx mem;\n-  enum machine_mode *save_mode = (enum machine_mode *)arg;\n+  machine_mode *save_mode = (machine_mode *)arg;\n \n   for (i = 0; i < nregs; i++)\n     if (TEST_HARD_REG_BIT (hard_regs_saved, regno + i))\n@@ -1168,7 +1168,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t  }\n \telse\n \t  {\n-\t    enum machine_mode smode = save_mode[regno];\n+\t    machine_mode smode = save_mode[regno];\n \t    gcc_assert (smode != VOIDmode);\n \t    if (hard_regno_nregs [regno][smode] > 1)\n \t      smode = mode_for_size (GET_MODE_SIZE (mode) / nregs,\n@@ -1197,7 +1197,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \n static int\n insert_restore (struct insn_chain *chain, int before_p, int regno,\n-\t\tint maxrestore, enum machine_mode *save_mode)\n+\t\tint maxrestore, machine_mode *save_mode)\n {\n   int i, k;\n   rtx pat = NULL_RTX;\n@@ -1278,7 +1278,7 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n \n static int\n insert_save (struct insn_chain *chain, int before_p, int regno,\n-\t     HARD_REG_SET (*to_save), enum machine_mode *save_mode)\n+\t     HARD_REG_SET (*to_save), machine_mode *save_mode)\n {\n   int i;\n   unsigned int k;"}, {"sha": "861c6158c90e81ce2e262ed461fce4ea2a0dfeb3", "filename": "gcc/calls.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -71,7 +71,7 @@ struct arg_data\n   /* Tree node for this argument.  */\n   tree tree_value;\n   /* Mode for value; TYPE_MODE unless promoted.  */\n-  enum machine_mode mode;\n+  machine_mode mode;\n   /* Current RTL value for argument, or 0 if it isn't precomputed.  */\n   rtx value;\n   /* Initially-compute RTL value for argument; only for const functions.  */\n@@ -161,7 +161,7 @@ static rtx rtx_for_function_call (tree, tree);\n static void load_register_parameters (struct arg_data *, int, rtx *, int,\n \t\t\t\t      int, int *);\n static rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n-\t\t\t\t      enum machine_mode, int, va_list);\n+\t\t\t\t      machine_mode, int, va_list);\n static int special_function_p (const_tree, int);\n static int check_sibcall_argument_overlap_1 (rtx);\n static int check_sibcall_argument_overlap (rtx_insn *, struct arg_data *, int);\n@@ -915,7 +915,7 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n     if (stack_usage_map[low] != 0)\n       {\n \tint num_to_save;\n-\tenum machine_mode save_mode;\n+\tmachine_mode save_mode;\n \tint delta;\n \trtx addr;\n \trtx stack_area;\n@@ -966,7 +966,7 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n static void\n restore_fixed_argument_area (rtx save_area, rtx argblock, int high_to_save, int low_to_save)\n {\n-  enum machine_mode save_mode = GET_MODE (save_area);\n+  machine_mode save_mode = GET_MODE (save_area);\n   int delta;\n   rtx addr, stack_area;\n \n@@ -1163,7 +1163,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n     {\n       tree type = TREE_TYPE (args[i].tree_value);\n       int unsignedp;\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       /* Replace erroneous argument with constant zero.  */\n       if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n@@ -1466,7 +1466,7 @@ precompute_arguments (int num_actuals, struct arg_data *args)\n   for (i = 0; i < num_actuals; i++)\n     {\n       tree type;\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       if (TREE_CODE (args[i].tree_value) != CALL_EXPR)\n \tcontinue;\n@@ -1584,7 +1584,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t  rtx addr;\n \t  unsigned int align, boundary;\n \t  unsigned int units_on_stack = 0;\n-\t  enum machine_mode partial_mode = VOIDmode;\n+\t  machine_mode partial_mode = VOIDmode;\n \n \t  /* Skip this parm if it will not be passed on the stack.  */\n \t  if (! args[i].pass_on_stack\n@@ -2138,7 +2138,7 @@ check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n    as specified by LEFT_P.  Return true if some action was needed.  */\n \n bool\n-shift_return_value (enum machine_mode mode, bool left_p, rtx value)\n+shift_return_value (machine_mode mode, bool left_p, rtx value)\n {\n   HOST_WIDE_INT shift;\n \n@@ -2623,8 +2623,8 @@ expand_call (tree exp, rtx target, int ignore)\n      return value.  */\n   if (try_tail_call)\n     {\n-      enum machine_mode caller_mode, caller_promoted_mode;\n-      enum machine_mode callee_mode, callee_promoted_mode;\n+      machine_mode caller_mode, caller_promoted_mode;\n+      machine_mode callee_mode, callee_promoted_mode;\n       int caller_unsignedp, callee_unsignedp;\n       tree caller_res = DECL_RESULT (current_function_decl);\n \n@@ -3356,7 +3356,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  tree type = rettype;\n \t  int unsignedp = TYPE_UNSIGNED (type);\n \t  int offset = 0;\n-\t  enum machine_mode pmode;\n+\t  machine_mode pmode;\n \n \t  /* Ensure we promote as expected, and get the new unsignedness.  */\n \t  pmode = promote_function_mode (type, TYPE_MODE (type), &unsignedp,\n@@ -3411,7 +3411,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  for (i = 0; i < num_actuals; i++)\n \t    if (args[i].save_area)\n \t      {\n-\t\tenum machine_mode save_mode = GET_MODE (args[i].save_area);\n+\t\tmachine_mode save_mode = GET_MODE (args[i].save_area);\n \t\trtx stack_area\n \t\t  = gen_rtx_MEM (save_mode,\n \t\t\t\t memory_address (save_mode,\n@@ -3587,7 +3587,7 @@ split_complex_types (tree types)\n static rtx\n emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t   enum libcall_type fn_type,\n-\t\t\t   enum machine_mode outmode, int nargs, va_list p)\n+\t\t\t   machine_mode outmode, int nargs, va_list p)\n {\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n@@ -3606,7 +3606,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   struct arg\n   {\n     rtx value;\n-    enum machine_mode mode;\n+    machine_mode mode;\n     rtx reg;\n     int partial;\n     struct locate_and_pad_arg_data locate;\n@@ -3771,7 +3771,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   for (; count < nargs; count++)\n     {\n       rtx val = va_arg (p, rtx);\n-      enum machine_mode mode = (enum machine_mode) va_arg (p, int);\n+      machine_mode mode = (machine_mode) va_arg (p, int);\n       int unsigned_p = 0;\n \n       /* We cannot convert the arg value to the mode the library wants here;\n@@ -3972,7 +3972,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum--)\n     {\n-      enum machine_mode mode = argvec[argnum].mode;\n+      machine_mode mode = argvec[argnum].mode;\n       rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n@@ -4011,7 +4011,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t  /* We need to make a save area.  */\n \t\t  unsigned int size\n \t\t    = argvec[argnum].locate.size.constant * BITS_PER_UNIT;\n-\t\t  enum machine_mode save_mode\n+\t\t  machine_mode save_mode\n \t\t    = mode_for_size (size, MODE_INT, 1);\n \t\t  rtx adr\n \t\t    = plus_constant (Pmode, argblock,\n@@ -4083,7 +4083,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum--)\n     {\n-      enum machine_mode mode = argvec[argnum].mode;\n+      machine_mode mode = argvec[argnum].mode;\n       rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n@@ -4294,7 +4294,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       for (count = 0; count < nargs; count++)\n \tif (argvec[count].save_area)\n \t  {\n-\t    enum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n+\t    machine_mode save_mode = GET_MODE (argvec[count].save_area);\n \t    rtx adr = plus_constant (Pmode, argblock,\n \t\t\t\t     argvec[count].locate.offset.constant);\n \t    rtx stack_area = gen_rtx_MEM (save_mode,\n@@ -4332,7 +4332,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n void\n emit_library_call (rtx orgfun, enum libcall_type fn_type,\n-\t\t   enum machine_mode outmode, int nargs, ...)\n+\t\t   machine_mode outmode, int nargs, ...)\n {\n   va_list p;\n \n@@ -4352,7 +4352,7 @@ emit_library_call (rtx orgfun, enum libcall_type fn_type,\n rtx\n emit_library_call_value (rtx orgfun, rtx value,\n \t\t\t enum libcall_type fn_type,\n-\t\t\t enum machine_mode outmode, int nargs, ...)\n+\t\t\t machine_mode outmode, int nargs, ...)\n {\n   rtx result;\n   va_list p;\n@@ -4438,7 +4438,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t    {\n \t      /* We need to make a save area.  */\n \t      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;\n-\t      enum machine_mode save_mode = mode_for_size (size, MODE_INT, 1);\n+\t      machine_mode save_mode = mode_for_size (size, MODE_INT, 1);\n \t      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));\n \t      rtx stack_area = gen_rtx_MEM (save_mode, adr);\n \n@@ -4732,7 +4732,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n /* Nonzero if we do not know how to pass TYPE solely in registers.  */\n \n bool\n-must_pass_in_stack_var_size (enum machine_mode mode ATTRIBUTE_UNUSED,\n+must_pass_in_stack_var_size (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     const_tree type)\n {\n   if (!type)\n@@ -4755,7 +4755,7 @@ must_pass_in_stack_var_size (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* ??? Should be able to merge these two by examining BLOCK_REG_PADDING.  */\n \n bool\n-must_pass_in_stack_var_size_or_pad (enum machine_mode mode, const_tree type)\n+must_pass_in_stack_var_size_or_pad (machine_mode mode, const_tree type)\n {\n   if (!type)\n     return false;"}, {"sha": "5a6ad399e8894fb6726c1e52b2ee5fadf21bde32", "filename": "gcc/calls.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -25,7 +25,7 @@ extern int call_expr_flags (const_tree);\n extern int setjmp_call_p (const_tree);\n extern bool gimple_alloca_call_p (const_gimple);\n extern bool alloca_call_p (const_tree);\n-extern bool must_pass_in_stack_var_size (enum machine_mode, const_tree);\n-extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);\n+extern bool must_pass_in_stack_var_size (machine_mode, const_tree);\n+extern bool must_pass_in_stack_var_size_or_pad (machine_mode, const_tree);\n \n #endif // GCC_CALLS_H"}, {"sha": "9bd61359e80fb4f878c2ba0c7c4f82534583fe5c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1145,7 +1145,7 @@ expand_one_register_var (tree var)\n {\n   tree decl = SSAVAR (var);\n   tree type = TREE_TYPE (decl);\n-  enum machine_mode reg_mode = promote_decl_mode (decl, NULL);\n+  machine_mode reg_mode = promote_decl_mode (decl, NULL);\n   rtx x = gen_reg_rtx (reg_mode);\n \n   set_rtl (var, x);\n@@ -1165,7 +1165,7 @@ expand_one_register_var (tree var)\n static void\n expand_one_error_var (tree var)\n {\n-  enum machine_mode mode = DECL_MODE (var);\n+  machine_mode mode = DECL_MODE (var);\n   rtx x;\n \n   if (mode == BLKmode)\n@@ -2480,7 +2480,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n   int *inout_opnum = XALLOCAVEC (int, noutputs);\n   rtx *real_output_rtx = XALLOCAVEC (rtx, noutputs);\n-  enum machine_mode *inout_mode = XALLOCAVEC (enum machine_mode, noutputs);\n+  machine_mode *inout_mode = XALLOCAVEC (machine_mode, noutputs);\n   const char **constraints = XALLOCAVEC (const char *, noutputs + ninputs);\n   int old_generating_concat_p = generating_concat_p;\n   rtx_code_label *fallthru_label = NULL;\n@@ -3101,8 +3101,8 @@ expand_value_return (rtx val)\n       tree funtype = TREE_TYPE (current_function_decl);\n       tree type = TREE_TYPE (decl);\n       int unsignedp = TYPE_UNSIGNED (type);\n-      enum machine_mode old_mode = DECL_MODE (decl);\n-      enum machine_mode mode;\n+      machine_mode old_mode = DECL_MODE (decl);\n+      machine_mode mode;\n       if (DECL_BY_REFERENCE (decl))\n         mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 2);\n       else\n@@ -3518,7 +3518,7 @@ expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n /* Return the difference between the floor and the truncated result of\n    a signed division by OP1 with remainder MOD.  */\n static rtx\n-floor_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+floor_sdiv_adjust (machine_mode mode, rtx mod, rtx op1)\n {\n   /* (mod != 0 ? (op1 / mod < 0 ? -1 : 0) : 0) */\n   return gen_rtx_IF_THEN_ELSE\n@@ -3534,7 +3534,7 @@ floor_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n /* Return the difference between the ceil and the truncated result of\n    a signed division by OP1 with remainder MOD.  */\n static rtx\n-ceil_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+ceil_sdiv_adjust (machine_mode mode, rtx mod, rtx op1)\n {\n   /* (mod != 0 ? (op1 / mod > 0 ? 1 : 0) : 0) */\n   return gen_rtx_IF_THEN_ELSE\n@@ -3550,7 +3550,7 @@ ceil_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n /* Return the difference between the ceil and the truncated result of\n    an unsigned division by OP1 with remainder MOD.  */\n static rtx\n-ceil_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1 ATTRIBUTE_UNUSED)\n+ceil_udiv_adjust (machine_mode mode, rtx mod, rtx op1 ATTRIBUTE_UNUSED)\n {\n   /* (mod != 0 ? 1 : 0) */\n   return gen_rtx_IF_THEN_ELSE\n@@ -3562,7 +3562,7 @@ ceil_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1 ATTRIBUTE_UNUSED)\n    of a signed division by OP1 with remainder MOD.  Halfway cases are\n    rounded away from zero, rather than to the nearest even number.  */\n static rtx\n-round_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+round_sdiv_adjust (machine_mode mode, rtx mod, rtx op1)\n {\n   /* (abs (mod) >= abs (op1) - abs (mod)\n       ? (op1 / mod > 0 ? 1 : -1)\n@@ -3585,7 +3585,7 @@ round_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n    are rounded away from zero, rather than to the nearest even\n    number.  */\n static rtx\n-round_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+round_udiv_adjust (machine_mode mode, rtx mod, rtx op1)\n {\n   /* (mod >= op1 - mod ? 1 : 0) */\n   return gen_rtx_IF_THEN_ELSE\n@@ -3598,10 +3598,10 @@ round_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n    any rtl.  */\n \n static rtx\n-convert_debug_memory_address (enum machine_mode mode, rtx x,\n+convert_debug_memory_address (machine_mode mode, rtx x,\n \t\t\t      addr_space_t as)\n {\n-  enum machine_mode xmode = GET_MODE (x);\n+  machine_mode xmode = GET_MODE (x);\n \n #ifndef POINTERS_EXTEND_UNSIGNED\n   gcc_assert (mode == Pmode\n@@ -3731,8 +3731,8 @@ static rtx\n expand_debug_expr (tree exp)\n {\n   rtx op0 = NULL_RTX, op1 = NULL_RTX, op2 = NULL_RTX;\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-  enum machine_mode inner_mode = VOIDmode;\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  machine_mode inner_mode = VOIDmode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n   addr_space_t as;\n \n@@ -4019,7 +4019,7 @@ expand_debug_expr (tree exp)\n     case IMAGPART_EXPR:\n     case VIEW_CONVERT_EXPR:\n       {\n-\tenum machine_mode mode1;\n+\tmachine_mode mode1;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n \tint volatilep = 0;\n@@ -4037,7 +4037,7 @@ expand_debug_expr (tree exp)\n \n \tif (offset)\n \t  {\n-\t    enum machine_mode addrmode, offmode;\n+\t    machine_mode addrmode, offmode;\n \n \t    if (!MEM_P (op0))\n \t      return NULL;\n@@ -4107,7 +4107,7 @@ expand_debug_expr (tree exp)\n \tif ((bitpos % BITS_PER_UNIT) == 0\n \t    && bitsize == GET_MODE_BITSIZE (mode1))\n \t  {\n-\t    enum machine_mode opmode = GET_MODE (op0);\n+\t    machine_mode opmode = GET_MODE (op0);\n \n \t    if (opmode == VOIDmode)\n \t      opmode = TYPE_MODE (TREE_TYPE (tem));\n@@ -4402,7 +4402,7 @@ expand_debug_expr (tree exp)\n \t\t\t\t\t\t   GET_MODE_INNER (mode)));\n       else\n \t{\n-\t  enum machine_mode imode = GET_MODE_INNER (mode);\n+\t  machine_mode imode = GET_MODE_INNER (mode);\n \t  rtx re, im;\n \n \t  if (MEM_P (op0))\n@@ -4412,8 +4412,8 @@ expand_debug_expr (tree exp)\n \t    }\n \t  else\n \t    {\n-\t      enum machine_mode ifmode = int_mode_for_mode (mode);\n-\t      enum machine_mode ihmode = int_mode_for_mode (imode);\n+\t      machine_mode ifmode = int_mode_for_mode (mode);\n+\t      machine_mode ihmode = int_mode_for_mode (imode);\n \t      rtx halfsize;\n \t      if (ifmode == BLKmode || ihmode == BLKmode)\n \t\treturn NULL;\n@@ -4709,7 +4709,7 @@ static rtx\n expand_debug_source_expr (tree exp)\n {\n   rtx op0 = NULL_RTX;\n-  enum machine_mode mode = VOIDmode, inner_mode;\n+  machine_mode mode = VOIDmode, inner_mode;\n \n   switch (TREE_CODE (exp))\n     {\n@@ -4857,7 +4857,7 @@ expand_debug_locations (void)\n \ttree value = (tree)INSN_VAR_LOCATION_LOC (insn);\n \trtx val;\n \trtx_insn *prev_insn, *insn2;\n-\tenum machine_mode mode;\n+\tmachine_mode mode;\n \n \tif (value == NULL_TREE)\n \t  val = NULL_RTX;\n@@ -5046,7 +5046,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t\t    tree value = gimple_assign_rhs_to_tree (def);\n \t\t    tree vexpr = make_node (DEBUG_EXPR_DECL);\n \t\t    rtx val;\n-\t\t    enum machine_mode mode;\n+\t\t    machine_mode mode;\n \n \t\t    set_curr_insn_location (gimple_location (def));\n \n@@ -5098,7 +5098,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t      tree var = gimple_debug_bind_get_var (stmt);\n \t      tree value;\n \t      rtx val;\n-\t      enum machine_mode mode;\n+\t      machine_mode mode;\n \n \t      if (TREE_CODE (var) != DEBUG_EXPR_DECL\n \t\t  && TREE_CODE (var) != LABEL_DECL\n@@ -5158,7 +5158,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t  tree var = gimple_debug_source_bind_get_var (stmt);\n \t  tree value = gimple_debug_source_bind_get_value (stmt);\n \t  rtx val;\n-\t  enum machine_mode mode;\n+\t  machine_mode mode;\n \n \t  last = get_last_insn ();\n "}, {"sha": "c24e7c52838c3fd1ccd688d218698914691b2e89", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -355,10 +355,10 @@ struct rtx_iv\n   rtx delta, mult;\n \n   /* The mode it is extended to.  */\n-  enum machine_mode extend_mode;\n+  machine_mode extend_mode;\n \n   /* The mode the variable iterates in.  */\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* Whether the first iteration needs to be handled specially.  */\n   unsigned first_special : 1;\n@@ -399,7 +399,7 @@ struct GTY(()) niter_desc\n   bool signed_p;\n \n   /* The mode in that niter_expr should be computed.  */\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* The number of iterations of the loop.  */\n   rtx niter_expr;\n@@ -408,7 +408,7 @@ struct GTY(()) niter_desc\n extern void iv_analysis_loop_init (struct loop *);\n extern bool iv_analyze (rtx_insn *, rtx, struct rtx_iv *);\n extern bool iv_analyze_result (rtx_insn *, rtx, struct rtx_iv *);\n-extern bool iv_analyze_expr (rtx_insn *, rtx, enum machine_mode,\n+extern bool iv_analyze_expr (rtx_insn *, rtx, machine_mode,\n \t\t\t     struct rtx_iv *);\n extern rtx get_iv_value (struct rtx_iv *, rtx);\n extern bool biv_p (rtx_insn *, rtx);"}, {"sha": "f6eb2072d11b4fac507b610bcd1f6e2b5ec62e94", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -4921,7 +4921,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   rtx op0 = XEXP ((rtx)comp_rtx, 0);\n   rtx op1 = XEXP ((rtx)comp_rtx, 1);\n   enum rtx_code comp = GET_CODE ((rtx)comp_rtx);\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n \n   label = block_label (first_head);"}, {"sha": "6d711ebb3f507bf97e10fb32188847b9759edef0", "filename": "gcc/combine.c", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -367,7 +367,7 @@ static int label_tick_ebb_start;\n /* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n    largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n-static enum machine_mode nonzero_bits_mode;\n+static machine_mode nonzero_bits_mode;\n \n /* Nonzero when reg_stat[].nonzero_bits and reg_stat[].sign_bit_copies can\n    be safely used.  It is zero while computing them and after combine has\n@@ -387,7 +387,7 @@ struct undo\n {\n   struct undo *next;\n   enum undo_kind kind;\n-  union { rtx r; int i; enum machine_mode m; struct insn_link *l; } old_contents;\n+  union { rtx r; int i; machine_mode m; struct insn_link *l; } old_contents;\n   union { rtx *r; int *i; struct insn_link **l; } where;\n };\n \n@@ -411,12 +411,12 @@ static struct undobuf undobuf;\n \n static int n_occurrences;\n \n-static rtx reg_nonzero_bits_for_combine (const_rtx, enum machine_mode, const_rtx,\n-\t\t\t\t\t enum machine_mode,\n+static rtx reg_nonzero_bits_for_combine (const_rtx, machine_mode, const_rtx,\n+\t\t\t\t\t machine_mode,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n \t\t\t\t\t unsigned HOST_WIDE_INT *);\n-static rtx reg_num_sign_bit_copies_for_combine (const_rtx, enum machine_mode, const_rtx,\n-\t\t\t\t\t\tenum machine_mode,\n+static rtx reg_num_sign_bit_copies_for_combine (const_rtx, machine_mode, const_rtx,\n+\t\t\t\t\t\tmachine_mode,\n \t\t\t\t\t\tunsigned int, unsigned int *);\n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n@@ -434,38 +434,38 @@ static void undo_all (void);\n static void undo_commit (void);\n static rtx *find_split_point (rtx *, rtx_insn *, bool);\n static rtx subst (rtx, rtx, rtx, int, int, int);\n-static rtx combine_simplify_rtx (rtx, enum machine_mode, int, int);\n+static rtx combine_simplify_rtx (rtx, machine_mode, int, int);\n static rtx simplify_if_then_else (rtx);\n static rtx simplify_set (rtx);\n static rtx simplify_logical (rtx);\n static rtx expand_compound_operation (rtx);\n static const_rtx expand_field_assignment (const_rtx);\n-static rtx make_extraction (enum machine_mode, rtx, HOST_WIDE_INT,\n+static rtx make_extraction (machine_mode, rtx, HOST_WIDE_INT,\n \t\t\t    rtx, unsigned HOST_WIDE_INT, int, int, int);\n static rtx extract_left_shift (rtx, int);\n static int get_pos_from_mask (unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT *);\n static rtx canon_reg_for_combine (rtx, rtx);\n-static rtx force_to_mode (rtx, enum machine_mode,\n+static rtx force_to_mode (rtx, machine_mode,\n \t\t\t  unsigned HOST_WIDE_INT, int);\n static rtx if_then_else_cond (rtx, rtx *, rtx *);\n static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n static int rtx_equal_for_field_assignment_p (rtx, rtx);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n static rtx distribute_and_simplify_rtx (rtx, int);\n-static rtx simplify_and_const_int_1 (enum machine_mode, rtx,\n+static rtx simplify_and_const_int_1 (machine_mode, rtx,\n \t\t\t\t     unsigned HOST_WIDE_INT);\n-static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n+static rtx simplify_and_const_int (rtx, machine_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n-\t\t\t    HOST_WIDE_INT, enum machine_mode, int *);\n-static rtx simplify_shift_const_1 (enum rtx_code, enum machine_mode, rtx, int);\n-static rtx simplify_shift_const (rtx, enum rtx_code, enum machine_mode, rtx,\n+\t\t\t    HOST_WIDE_INT, machine_mode, int *);\n+static rtx simplify_shift_const_1 (enum rtx_code, machine_mode, rtx, int);\n+static rtx simplify_shift_const (rtx, enum rtx_code, machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx_insn *, rtx *);\n-static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n-static enum rtx_code simplify_compare_const (enum rtx_code, enum machine_mode,\n+static rtx gen_lowpart_for_combine (machine_mode, rtx);\n+static enum rtx_code simplify_compare_const (enum rtx_code, machine_mode,\n \t\t\t\t\t     rtx, rtx *);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n@@ -486,8 +486,8 @@ static void mark_used_regs_combine (rtx);\n static void record_promoted_value (rtx_insn *, rtx);\n static bool unmentioned_reg_p (rtx, rtx);\n static void record_truncated_values (rtx *, void *);\n-static bool reg_truncated_to_mode (enum machine_mode, const_rtx);\n-static rtx gen_lowpart_or_truncate (enum machine_mode, rtx);\n+static bool reg_truncated_to_mode (machine_mode, const_rtx);\n+static rtx gen_lowpart_or_truncate (machine_mode, rtx);\n \f\n \n /* It is not safe to use ordinary gen_lowpart in combine.\n@@ -790,10 +790,10 @@ do_SUBST_INT (int *into, int newval)\n    well.  */\n \n static void\n-do_SUBST_MODE (rtx *into, enum machine_mode newval)\n+do_SUBST_MODE (rtx *into, machine_mode newval)\n {\n   struct undo *buf;\n-  enum machine_mode oldval = GET_MODE (*into);\n+  machine_mode oldval = GET_MODE (*into);\n \n   if (oldval == newval)\n     return;\n@@ -1551,7 +1551,7 @@ setup_incoming_promotions (rtx_insn *first)\n     {\n       rtx x, reg = DECL_INCOMING_RTL (arg);\n       int uns1, uns3;\n-      enum machine_mode mode1, mode2, mode3, mode4;\n+      machine_mode mode1, mode2, mode3, mode4;\n \n       /* Only continue if the incoming argument is in a register.  */\n       if (!REG_P (reg))\n@@ -2368,7 +2368,7 @@ adjust_for_new_dest (rtx_insn *insn)\n /* Return TRUE if combine can reuse reg X in mode MODE.\n    ADDED_SETS is nonzero if the original set is still required.  */\n static bool\n-can_change_dest_mode (rtx x, int added_sets, enum machine_mode mode)\n+can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n {\n   unsigned int regno;\n \n@@ -2975,7 +2975,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       rtx *cc_use_loc = NULL;\n       rtx_insn *cc_use_insn = NULL;\n       rtx op0 = i2src, op1 = XEXP (SET_SRC (PATTERN (i3)), 1);\n-      enum machine_mode compare_mode, orig_compare_mode;\n+      machine_mode compare_mode, orig_compare_mode;\n       enum rtx_code compare_code = UNKNOWN, orig_compare_code = UNKNOWN;\n \n       newpat = PATTERN (i3);\n@@ -3004,7 +3004,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  if (cc_use_loc)\n \t    {\n #ifdef SELECT_CC_MODE\n-\t      enum machine_mode new_mode\n+\t      machine_mode new_mode\n \t\t= SELECT_CC_MODE (compare_code, op0, op1);\n \t      if (new_mode != orig_compare_mode\n \t\t  && can_change_dest_mode (SET_DEST (newpat),\n@@ -3361,7 +3361,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n       if (m_split_insn == 0 && ! reg_overlap_mentioned_p (i2dest, newpat))\n \t{\n-\t  enum machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n+\t  machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n \n \t  /* First try to split using the original register as a\n \t     scratch register.  */\n@@ -3378,7 +3378,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      && new_mode != VOIDmode\n \t      && can_change_dest_mode (i2dest, added_sets_2, new_mode))\n \t    {\n-\t      enum machine_mode old_mode = GET_MODE (i2dest);\n+\t      machine_mode old_mode = GET_MODE (i2dest);\n \t      rtx ni2dest;\n \n \t      if (REGNO (i2dest) < FIRST_PSEUDO_REGISTER)\n@@ -3501,7 +3501,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t{\n \t  rtx newdest = i2dest;\n \t  enum rtx_code split_code = GET_CODE (*split);\n-\t  enum machine_mode split_mode = GET_MODE (*split);\n+\t  machine_mode split_mode = GET_MODE (*split);\n \t  bool subst_done = false;\n \t  newi2pat = NULL_RTX;\n \n@@ -3568,7 +3568,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      && ! side_effects_p (SET_SRC (newpat)))\n \t    {\n \t      rtx setsrc = SET_SRC (newpat);\n-\t      enum machine_mode mode = GET_MODE (setsrc);\n+\t      machine_mode mode = GET_MODE (setsrc);\n \t      enum rtx_code code = GET_CODE (setsrc);\n \t      rtx src_op0 = XEXP (setsrc, 0);\n \t      rtx src_op1 = XEXP (setsrc, 1);\n@@ -3863,8 +3863,8 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \tif (undo->kind == UNDO_MODE)\n \t  {\n \t    rtx reg = *undo->where.r;\n-\t    enum machine_mode new_mode = GET_MODE (reg);\n-\t    enum machine_mode old_mode = undo->old_contents.m;\n+\t    machine_mode new_mode = GET_MODE (reg);\n+\t    machine_mode old_mode = undo->old_contents.m;\n \n \t    /* Temporarily revert mode back.  */\n \t    adjust_reg_mode (reg, old_mode);\n@@ -4524,7 +4524,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n       if (GET_CODE (XEXP (x, 0)) == CONST\n \t  || GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n-\t  enum machine_mode address_mode = get_address_mode (x);\n+\t  machine_mode address_mode = get_address_mode (x);\n \n \t  SUBST (XEXP (x, 0),\n \t\t gen_rtx_LO_SUM (address_mode,\n@@ -4656,7 +4656,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  unsigned HOST_WIDE_INT len = INTVAL (XEXP (SET_DEST (x), 1));\n \t  unsigned HOST_WIDE_INT src = INTVAL (SET_SRC (x));\n \t  rtx dest = XEXP (SET_DEST (x), 0);\n-\t  enum machine_mode mode = GET_MODE (dest);\n+\t  machine_mode mode = GET_MODE (dest);\n \t  unsigned HOST_WIDE_INT mask\n \t    = ((unsigned HOST_WIDE_INT) 1 << len) - 1;\n \t  rtx or_mask;\n@@ -4730,7 +4730,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t\t       (nonzero_bits (XEXP (SET_SRC (x), 0),\n \t\t\t\t      GET_MODE (XEXP (SET_SRC (x), 0))))))\n \t    {\n-\t      enum machine_mode mode = GET_MODE (XEXP (SET_SRC (x), 0));\n+\t      machine_mode mode = GET_MODE (XEXP (SET_SRC (x), 0));\n \n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_NEG (mode,\n@@ -4781,7 +4781,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n       if (len && pos >= 0\n \t  && pos + len <= GET_MODE_PRECISION (GET_MODE (inner)))\n \t{\n-\t  enum machine_mode mode = GET_MODE (SET_SRC (x));\n+\t  machine_mode mode = GET_MODE (SET_SRC (x));\n \n \t  /* For unsigned, we have a choice of a shift followed by an\n \t     AND or two shifts.  Use two shifts for field sizes where the\n@@ -4878,7 +4878,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n \t  && exact_log2 (INTVAL (XEXP (XEXP (x, 1), 1))) < 0)\n \t{\n-\t  enum machine_mode mode = GET_MODE (x);\n+\t  machine_mode mode = GET_MODE (x);\n \t  unsigned HOST_WIDE_INT this_int = INTVAL (XEXP (XEXP (x, 1), 1));\n \t  HOST_WIDE_INT other_int = trunc_int_for_mode (-this_int, mode);\n \t  SUBST (*loc, gen_rtx_PLUS (mode,\n@@ -4959,7 +4959,7 @@ static rtx\n subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n {\n   enum rtx_code code = GET_CODE (x);\n-  enum machine_mode op0_mode = VOIDmode;\n+  machine_mode op0_mode = VOIDmode;\n   const char *fmt;\n   int len, i;\n   rtx new_rtx;\n@@ -5176,7 +5176,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \n \t      if (GET_CODE (x) == SUBREG && CONST_SCALAR_INT_P (new_rtx))\n \t\t{\n-\t\t  enum machine_mode mode = GET_MODE (x);\n+\t\t  machine_mode mode = GET_MODE (x);\n \n \t\t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t\t       GET_MODE (SUBREG_REG (x)),\n@@ -5242,11 +5242,11 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n    of a condition.  */\n \n static rtx\n-combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n+combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t\t      int in_cond)\n {\n   enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   rtx temp;\n   int i;\n \n@@ -5372,7 +5372,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n     case RTX_COMPARE:\n     case RTX_COMM_COMPARE:\n       {\n-\tenum machine_mode cmp_mode = GET_MODE (XEXP (x, 0));\n+\tmachine_mode cmp_mode = GET_MODE (XEXP (x, 0));\n \tif (cmp_mode == VOIDmode)\n \t  {\n \t    cmp_mode = GET_MODE (XEXP (x, 1));\n@@ -5944,7 +5944,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n static rtx\n simplify_if_then_else (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   rtx cond = XEXP (x, 0);\n   rtx true_rtx = XEXP (x, 1);\n   rtx false_rtx = XEXP (x, 2);\n@@ -6142,7 +6142,7 @@ simplify_if_then_else (rtx x)\n       rtx cond_op0 = XEXP (cond, 0);\n       rtx cond_op1 = XEXP (cond, 1);\n       enum rtx_code op = UNKNOWN, extend_op = UNKNOWN;\n-      enum machine_mode m = mode;\n+      machine_mode m = mode;\n       rtx z = 0, c1 = NULL_RTX;\n \n       if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n@@ -6284,7 +6284,7 @@ simplify_set (rtx x)\n {\n   rtx src = SET_SRC (x);\n   rtx dest = SET_DEST (x);\n-  enum machine_mode mode\n+  machine_mode mode\n     = GET_MODE (src) != VOIDmode ? GET_MODE (src) : GET_MODE (dest);\n   rtx_insn *other_insn;\n   rtx *cc_use;\n@@ -6319,7 +6319,7 @@ simplify_set (rtx x)\n       rtx op0, op1, tmp;\n       int other_changed = 0;\n       rtx inner_compare = NULL_RTX;\n-      enum machine_mode compare_mode = GET_MODE (dest);\n+      machine_mode compare_mode = GET_MODE (dest);\n \n       if (GET_CODE (src) == COMPARE)\n \t{\n@@ -6530,7 +6530,7 @@ simplify_set (rtx x)\n \t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (src)))))\n     {\n       rtx inner = SUBREG_REG (src);\n-      enum machine_mode inner_mode = GET_MODE (inner);\n+      machine_mode inner_mode = GET_MODE (inner);\n \n       /* Here we make sure that we don't have a sign bit on.  */\n       if (val_signbit_known_clear_p (GET_MODE (src),\n@@ -6635,7 +6635,7 @@ simplify_set (rtx x)\n static rtx\n simplify_logical (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   rtx op0 = XEXP (x, 0);\n   rtx op1 = XEXP (x, 1);\n \n@@ -6889,7 +6889,7 @@ expand_compound_operation (rtx x)\n   modewidth = GET_MODE_PRECISION (GET_MODE (x));\n   if (modewidth >= pos + len)\n     {\n-      enum machine_mode mode = GET_MODE (x);\n+      machine_mode mode = GET_MODE (x);\n       tem = gen_lowpart (mode, XEXP (x, 0));\n       if (!tem || GET_CODE (tem) == CLOBBER)\n \treturn x;\n@@ -6931,7 +6931,7 @@ expand_field_assignment (const_rtx x)\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n   int len;\n   rtx mask, cleared, masked;\n-  enum machine_mode compute_mode;\n+  machine_mode compute_mode;\n \n   /* Loop until we find something we can't simplify.  */\n   while (1)\n@@ -7004,7 +7004,7 @@ expand_field_assignment (const_rtx x)\n       /* Don't attempt bitwise arithmetic on non scalar integer modes.  */\n       if (! SCALAR_INT_MODE_P (compute_mode))\n \t{\n-\t  enum machine_mode imode;\n+\t  machine_mode imode;\n \n \t  /* Don't do anything for vector or complex integral types.  */\n \t  if (! FLOAT_MODE_P (compute_mode))\n@@ -7070,20 +7070,20 @@ expand_field_assignment (const_rtx x)\n    can't handle it.  */\n \n static rtx\n-make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n+make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t rtx pos_rtx, unsigned HOST_WIDE_INT len, int unsignedp,\n \t\t int in_dest, int in_compare)\n {\n   /* This mode describes the size of the storage area\n      to fetch the overall value from.  Within that, we\n      ignore the POS lowest bits, etc.  */\n-  enum machine_mode is_mode = GET_MODE (inner);\n-  enum machine_mode inner_mode;\n-  enum machine_mode wanted_inner_mode;\n-  enum machine_mode wanted_inner_reg_mode = word_mode;\n-  enum machine_mode pos_mode = word_mode;\n-  enum machine_mode extraction_mode = word_mode;\n-  enum machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n+  machine_mode is_mode = GET_MODE (inner);\n+  machine_mode inner_mode;\n+  machine_mode wanted_inner_mode;\n+  machine_mode wanted_inner_reg_mode = word_mode;\n+  machine_mode pos_mode = word_mode;\n+  machine_mode extraction_mode = word_mode;\n+  machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n   rtx new_rtx = 0;\n   rtx orig_pos_rtx = pos_rtx;\n   HOST_WIDE_INT orig_pos;\n@@ -7463,7 +7463,7 @@ static rtx\n extract_left_shift (rtx x, int count)\n {\n   enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   rtx tem;\n \n   switch (code)\n@@ -7527,7 +7527,7 @@ rtx\n make_compound_operation (rtx x, enum rtx_code in_code)\n {\n   enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   int mode_width = GET_MODE_PRECISION (mode);\n   rtx rhs, lhs;\n   enum rtx_code next_code;\n@@ -8036,7 +8036,7 @@ canon_reg_for_combine (rtx x, rtx reg)\n    would need an explicit truncation.  */\n \n static rtx\n-gen_lowpart_or_truncate (enum machine_mode mode, rtx x)\n+gen_lowpart_or_truncate (machine_mode mode, rtx x)\n {\n   if (!CONST_INT_P (x)\n       && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x))\n@@ -8067,12 +8067,12 @@ gen_lowpart_or_truncate (enum machine_mode mode, rtx x)\n    NOT, NEG, or XOR.  */\n \n static rtx\n-force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n+force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t       int just_select)\n {\n   enum rtx_code code = GET_CODE (x);\n   int next_select = just_select || code == XOR || code == NOT || code == NEG;\n-  enum machine_mode op_mode;\n+  machine_mode op_mode;\n   unsigned HOST_WIDE_INT fuller_mask, nonzero;\n   rtx op0, op1, temp;\n \n@@ -8615,7 +8615,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n static rtx\n if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   enum rtx_code code = GET_CODE (x);\n   rtx cond0, cond1, true0, true1, false0, false1;\n   unsigned HOST_WIDE_INT nz;\n@@ -8914,7 +8914,7 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n     }\n   else if (code == SUBREG)\n     {\n-      enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n+      machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n       rtx new_rtx, r = known_cond (SUBREG_REG (x), cond, reg, val);\n \n       if (SUBREG_REG (x) != r)\n@@ -8939,7 +8939,7 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n      story is different.  */\n   else if (code == ZERO_EXTEND)\n     {\n-      enum machine_mode inner_mode = GET_MODE (XEXP (x, 0));\n+      machine_mode inner_mode = GET_MODE (XEXP (x, 0));\n       rtx new_rtx, r = known_cond (XEXP (x, 0), cond, reg, val);\n \n       if (XEXP (x, 0) != r)\n@@ -9022,7 +9022,7 @@ make_field_assignment (rtx x)\n   HOST_WIDE_INT pos;\n   unsigned HOST_WIDE_INT len;\n   rtx other;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* If SRC was (and (not (ashift (const_int 1) POS)) DEST), this is\n      a clear of a one-bit field.  We will have changed it to\n@@ -9305,7 +9305,7 @@ apply_distributive_law (rtx x)\n static rtx\n distribute_and_simplify_rtx (rtx x, int n)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum rtx_code outer_code, inner_code;\n   rtx decomposed, distributed, inner_op0, inner_op1, new_op0, new_op1, tmp;\n \n@@ -9363,7 +9363,7 @@ distribute_and_simplify_rtx (rtx x, int n)\n    (const_int CONSTOP)).  Otherwise, return NULL_RTX.  */\n \n static rtx\n-simplify_and_const_int_1 (enum machine_mode mode, rtx varop,\n+simplify_and_const_int_1 (machine_mode mode, rtx varop,\n \t\t\t  unsigned HOST_WIDE_INT constop)\n {\n   unsigned HOST_WIDE_INT nonzero;\n@@ -9478,7 +9478,7 @@ simplify_and_const_int_1 (enum machine_mode mode, rtx varop,\n    X is zero, we are to always construct the equivalent form.  */\n \n static rtx\n-simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n+simplify_and_const_int (rtx x, machine_mode mode, rtx varop,\n \t\t\tunsigned HOST_WIDE_INT constop)\n {\n   rtx tem = simplify_and_const_int_1 (mode, varop, constop);\n@@ -9500,9 +9500,9 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n    a shift, AND, or zero_extract, we can do better.  */\n \n static rtx\n-reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n+reg_nonzero_bits_for_combine (const_rtx x, machine_mode mode,\n \t\t\t      const_rtx known_x ATTRIBUTE_UNUSED,\n-\t\t\t      enum machine_mode known_mode ATTRIBUTE_UNUSED,\n+\t\t\t      machine_mode known_mode ATTRIBUTE_UNUSED,\n \t\t\t      unsigned HOST_WIDE_INT known_ret ATTRIBUTE_UNUSED,\n \t\t\t      unsigned HOST_WIDE_INT *nonzero)\n {\n@@ -9581,9 +9581,9 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n    be between 1 and the number of bits in MODE.  */\n \n static rtx\n-reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n+reg_num_sign_bit_copies_for_combine (const_rtx x, machine_mode mode,\n \t\t\t\t     const_rtx known_x ATTRIBUTE_UNUSED,\n-\t\t\t\t     enum machine_mode known_mode\n+\t\t\t\t     machine_mode known_mode\n \t\t\t\t     ATTRIBUTE_UNUSED,\n \t\t\t\t     unsigned int known_ret ATTRIBUTE_UNUSED,\n \t\t\t\t     unsigned int *result)\n@@ -9631,7 +9631,7 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n    implies that it must be called from a define_split.  */\n \n unsigned int\n-extended_count (const_rtx x, enum machine_mode mode, int unsignedp)\n+extended_count (const_rtx x, machine_mode mode, int unsignedp)\n {\n   if (nonzero_sign_valid == 0)\n     return 0;\n@@ -9666,7 +9666,7 @@ extended_count (const_rtx x, enum machine_mode mode, int unsignedp)\n    return 0 and do not change *POP0, *PCONST0, and *PCOMP_P.  */\n \n static int\n-merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1, HOST_WIDE_INT const1, enum machine_mode mode, int *pcomp_p)\n+merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1, HOST_WIDE_INT const1, machine_mode mode, int *pcomp_p)\n {\n   enum rtx_code op0 = *pop0;\n   HOST_WIDE_INT const0 = *pconst0;\n@@ -9782,9 +9782,9 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n    result of the shift is subject to operation OUTER_CODE with operand\n    OUTER_CONST.  */\n \n-static enum machine_mode\n+static machine_mode\n try_widen_shift_mode (enum rtx_code code, rtx op, int count,\n-\t\t      enum machine_mode orig_mode, enum machine_mode mode,\n+\t\t      machine_mode orig_mode, machine_mode mode,\n \t\t      enum rtx_code outer_code, HOST_WIDE_INT outer_const)\n {\n   if (orig_mode == mode)\n@@ -9841,14 +9841,14 @@ try_widen_shift_mode (enum rtx_code code, rtx op, int count,\n    are ASHIFTRT and ROTATE, which are always done in their original mode.  */\n \n static rtx\n-simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n+simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t\t\trtx varop, int orig_count)\n {\n   enum rtx_code orig_code = code;\n   rtx orig_varop = varop;\n   int count;\n-  enum machine_mode mode = result_mode;\n-  enum machine_mode shift_mode, tmode;\n+  machine_mode mode = result_mode;\n+  machine_mode shift_mode, tmode;\n   unsigned int mode_words\n     = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n@@ -10577,7 +10577,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n    are ASHIFTRT and ROTATE, which are always done in their original mode.  */\n \n static rtx\n-simplify_shift_const (rtx x, enum rtx_code code, enum machine_mode result_mode,\n+simplify_shift_const (rtx x, enum rtx_code code, machine_mode result_mode,\n \t\t      rtx varop, int count)\n {\n   rtx tem = simplify_shift_const_1 (code, result_mode, varop, count);\n@@ -10765,9 +10765,9 @@ recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n    An insn containing that will not be recognized.  */\n \n static rtx\n-gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n+gen_lowpart_for_combine (machine_mode omode, rtx x)\n {\n-  enum machine_mode imode = GET_MODE (x);\n+  machine_mode imode = GET_MODE (x);\n   unsigned int osize = GET_MODE_SIZE (omode);\n   unsigned int isize = GET_MODE_SIZE (imode);\n   rtx result;\n@@ -10869,7 +10869,7 @@ gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n    *POP1 may be updated.  */\n \n static enum rtx_code\n-simplify_compare_const (enum rtx_code code, enum machine_mode mode,\n+simplify_compare_const (enum rtx_code code, machine_mode mode,\n \t\t\trtx op0, rtx *pop1)\n {\n   unsigned int mode_width = GET_MODE_PRECISION (mode);\n@@ -11065,7 +11065,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   rtx op1 = *pop1;\n   rtx tem, tem1;\n   int i;\n-  enum machine_mode mode, tmode;\n+  machine_mode mode, tmode;\n \n   /* Try a few ways of applying the same transformation to both operands.  */\n   while (1)\n@@ -11112,7 +11112,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  && INTVAL (XEXP (op0, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && XEXP (op0, 1) == XEXP (op1, 1))\n \t{\n-\t  enum machine_mode mode = GET_MODE (op0);\n+\t  machine_mode mode = GET_MODE (op0);\n \t  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n \t  int shift_count = INTVAL (XEXP (op0, 1));\n \n@@ -11217,7 +11217,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n   while (CONST_INT_P (op1))\n     {\n-      enum machine_mode mode = GET_MODE (op0);\n+      machine_mode mode = GET_MODE (op0);\n       unsigned int mode_width = GET_MODE_PRECISION (mode);\n       unsigned HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n       int equality_comparison_p;\n@@ -11442,7 +11442,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && GET_CODE (SUBREG_REG (op0)) == PLUS\n \t      && CONST_INT_P (XEXP (SUBREG_REG (op0), 1)))\n \t    {\n-\t      enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n+\t      machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n \t      rtx a = XEXP (SUBREG_REG (op0), 0);\n \t      HOST_WIDE_INT c1 = -INTVAL (XEXP (SUBREG_REG (op0), 1));\n \n@@ -12325,7 +12325,7 @@ record_value_for_reg (rtx reg, rtx_insn *insn, rtx value)\n \n   if (value)\n     {\n-      enum machine_mode mode = GET_MODE (reg);\n+      machine_mode mode = GET_MODE (reg);\n       subst_low_luid = DF_INSN_LUID (insn);\n       rsp->last_set_mode = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n@@ -12461,7 +12461,7 @@ record_promoted_value (rtx_insn *insn, rtx subreg)\n   struct insn_link *links;\n   rtx set;\n   unsigned int regno = REGNO (SUBREG_REG (subreg));\n-  enum machine_mode mode = GET_MODE (subreg);\n+  machine_mode mode = GET_MODE (subreg);\n \n   if (GET_MODE_PRECISION (mode) > HOST_BITS_PER_WIDE_INT)\n     return;\n@@ -12504,10 +12504,10 @@ record_promoted_value (rtx_insn *insn, rtx subreg)\n    an explicit truncation.  */\n \n static bool\n-reg_truncated_to_mode (enum machine_mode mode, const_rtx x)\n+reg_truncated_to_mode (machine_mode mode, const_rtx x)\n {\n   reg_stat_type *rsp = &reg_stat[REGNO (x)];\n-  enum machine_mode truncated = rsp->truncated_to_mode;\n+  machine_mode truncated = rsp->truncated_to_mode;\n \n   if (truncated == 0\n       || rsp->truncation_label < label_tick_ebb_start)\n@@ -12527,12 +12527,12 @@ reg_truncated_to_mode (enum machine_mode mode, const_rtx x)\n static bool\n record_truncated_value (rtx x)\n {\n-  enum machine_mode truncated_mode;\n+  machine_mode truncated_mode;\n   reg_stat_type *rsp;\n \n   if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x)))\n     {\n-      enum machine_mode original_mode = GET_MODE (SUBREG_REG (x));\n+      machine_mode original_mode = GET_MODE (SUBREG_REG (x));\n       truncated_mode = GET_MODE (x);\n \n       if (GET_MODE_SIZE (original_mode) <= GET_MODE_SIZE (truncated_mode))"}, {"sha": "d4c0e6884c157cc84c6685b74f4cf14003df47ed", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -118,7 +118,7 @@ struct comparison\n   struct comparison_use uses[MAX_CMP_USE];\n \n   /* The original CC_MODE for this comparison.  */\n-  enum machine_mode orig_mode;\n+  machine_mode orig_mode;\n \n   /* The number of uses identified for this comparison.  */\n   unsigned short n_uses;\n@@ -317,7 +317,7 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n       src = conforming_compare (insn);\n       if (src)\n \t{\n-\t  enum machine_mode src_mode = GET_MODE (src);\n+\t  machine_mode src_mode = GET_MODE (src);\n \t  rtx eh_note = NULL;\n \n \t  if (flag_non_call_exceptions)\n@@ -338,7 +338,7 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \n \t  /* New mode must be compatible with the previous compare mode.  */\n \t  {\n-\t    enum machine_mode new_mode\n+\t    machine_mode new_mode\n \t      = targetm.cc_modes_compatible (last_cmp->orig_mode, src_mode);\n \t    if (new_mode == VOIDmode)\n \t      goto dont_delete;\n@@ -466,7 +466,7 @@ static rtx\n maybe_select_cc_mode (struct comparison *cmp, rtx a ATTRIBUTE_UNUSED,\n \t\t      rtx b ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode sel_mode;\n+  machine_mode sel_mode;\n   const int n = cmp->n_uses;\n   rtx flags = NULL;\n \n@@ -498,7 +498,7 @@ maybe_select_cc_mode (struct comparison *cmp, rtx a ATTRIBUTE_UNUSED,\n       sel_mode = SELECT_CC_MODE (cmp->uses[0].code, a, b);\n       for (i = 1; i < n; ++i)\n \t{\n-\t  enum machine_mode new_mode;\n+\t  machine_mode new_mode;\n \t  new_mode = SELECT_CC_MODE (cmp->uses[i].code, a, b);\n \t  if (new_mode != sel_mode)\n \t    {"}, {"sha": "df65c85fff9e17541808663875629013251215c7", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -119,7 +119,7 @@ enum aarch64_type_qualifiers\n typedef struct\n {\n   const char *name;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   const enum insn_code code;\n   unsigned int fcode;\n   enum aarch64_type_qualifiers *qualifiers;\n@@ -316,7 +316,7 @@ static aarch64_simd_builtin_datum aarch64_simd_builtin_data[] = {\n typedef struct\n {\n   const char *name;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   const enum insn_code icode;\n   unsigned int fcode;\n } aarch64_crc_builtin_datum;\n@@ -365,7 +365,7 @@ static GTY(()) tree aarch64_builtin_decls[AARCH64_BUILTIN_MAX];\n /* Return a tree for a signed or unsigned argument of either\n    the mode specified by MODE, or the inner mode of MODE.  */\n tree\n-aarch64_build_scalar_type (enum machine_mode mode,\n+aarch64_build_scalar_type (machine_mode mode,\n \t\t\t   bool unsigned_p,\n \t\t\t   bool poly_p)\n {\n@@ -444,7 +444,7 @@ aarch64_build_scalar_type (enum machine_mode mode,\n }\n \n tree\n-aarch64_build_vector_type (enum machine_mode mode,\n+aarch64_build_vector_type (machine_mode mode,\n \t\t\t   bool unsigned_p,\n \t\t\t   bool poly_p)\n {\n@@ -511,7 +511,7 @@ aarch64_build_vector_type (enum machine_mode mode,\n }\n \n tree\n-aarch64_build_type (enum machine_mode mode, bool unsigned_p, bool poly_p)\n+aarch64_build_type (machine_mode mode, bool unsigned_p, bool poly_p)\n {\n   if (VECTOR_MODE_P (mode))\n     return aarch64_build_vector_type (mode, unsigned_p, poly_p);\n@@ -520,19 +520,19 @@ aarch64_build_type (enum machine_mode mode, bool unsigned_p, bool poly_p)\n }\n \n tree\n-aarch64_build_signed_type (enum machine_mode mode)\n+aarch64_build_signed_type (machine_mode mode)\n {\n   return aarch64_build_type (mode, false, false);\n }\n \n tree\n-aarch64_build_unsigned_type (enum machine_mode mode)\n+aarch64_build_unsigned_type (machine_mode mode)\n {\n   return aarch64_build_type (mode, true, false);\n }\n \n tree\n-aarch64_build_poly_type (enum machine_mode mode)\n+aarch64_build_poly_type (machine_mode mode)\n {\n   return aarch64_build_type (mode, false, true);\n }\n@@ -646,7 +646,7 @@ aarch64_init_simd_builtins (void)\n \t removing duplicates for us.  */\n       for (; op_num >= 0; arg_num--, op_num--)\n \t{\n-\t  enum machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n+\t  machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n \t  enum aarch64_type_qualifiers qualifiers = d->qualifiers[arg_num];\n \n \t  if (qualifiers & qualifier_unsigned)\n@@ -781,8 +781,8 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n   rtx pat;\n   tree arg[SIMD_MAX_BUILTIN_ARGS];\n   rtx op[SIMD_MAX_BUILTIN_ARGS];\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode[SIMD_MAX_BUILTIN_ARGS];\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode[SIMD_MAX_BUILTIN_ARGS];\n   int argc = 0;\n \n   if (have_retval\n@@ -959,9 +959,9 @@ aarch64_crc32_expand_builtin (int fcode, tree exp, rtx target)\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n \n   if (! target\n       || GET_MODE (target) != tmode\n@@ -990,7 +990,7 @@ rtx\n aarch64_expand_builtin (tree exp,\n \t\t     rtx target,\n \t\t     rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -1037,7 +1037,7 @@ aarch64_expand_builtin (tree exp,\n tree\n aarch64_builtin_vectorized_function (tree fndecl, tree type_out, tree type_in)\n {\n-  enum machine_mode in_mode, out_mode;\n+  machine_mode in_mode, out_mode;\n   int in_n, out_n;\n \n   if (TREE_CODE (type_out) != VECTOR_TYPE"}, {"sha": "810644c4a474bb1a255cf1b5a3ba45ffc1890e56", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -174,9 +174,9 @@ struct tune_params\n \n HOST_WIDE_INT aarch64_initial_elimination_offset (unsigned, unsigned);\n int aarch64_get_condition_code (rtx);\n-bool aarch64_bitmask_imm (HOST_WIDE_INT val, enum machine_mode);\n-bool aarch64_cannot_change_mode_class (enum machine_mode,\n-\t\t\t\t       enum machine_mode,\n+bool aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode);\n+bool aarch64_cannot_change_mode_class (machine_mode,\n+\t\t\t\t       machine_mode,\n \t\t\t\t       enum reg_class);\n enum aarch64_symbol_type\n aarch64_classify_symbolic_expression (rtx, enum aarch64_symbol_context);\n@@ -187,29 +187,29 @@ bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n bool aarch64_gen_movmemqi (rtx *);\n bool aarch64_gimple_fold_builtin (gimple_stmt_iterator *);\n-bool aarch64_is_extend_from_extract (enum machine_mode, rtx, rtx);\n+bool aarch64_is_extend_from_extract (machine_mode, rtx, rtx);\n bool aarch64_is_long_call_p (rtx);\n bool aarch64_label_mentioned_p (rtx);\n bool aarch64_legitimate_pic_operand_p (rtx);\n-bool aarch64_modes_tieable_p (enum machine_mode mode1,\n-\t\t\t      enum machine_mode mode2);\n-bool aarch64_move_imm (HOST_WIDE_INT, enum machine_mode);\n+bool aarch64_modes_tieable_p (machine_mode mode1,\n+\t\t\t      machine_mode mode2);\n+bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n bool aarch64_mov_operand_p (rtx, enum aarch64_symbol_context,\n-\t\t\t    enum machine_mode);\n-bool aarch64_offset_7bit_signed_scaled_p (enum machine_mode, HOST_WIDE_INT);\n-char *aarch64_output_scalar_simd_mov_immediate (rtx, enum machine_mode);\n-char *aarch64_output_simd_mov_immediate (rtx, enum machine_mode, unsigned);\n-bool aarch64_pad_arg_upward (enum machine_mode, const_tree);\n-bool aarch64_pad_reg_upward (enum machine_mode, const_tree, bool);\n+\t\t\t    machine_mode);\n+bool aarch64_offset_7bit_signed_scaled_p (machine_mode, HOST_WIDE_INT);\n+char *aarch64_output_scalar_simd_mov_immediate (rtx, machine_mode);\n+char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned);\n+bool aarch64_pad_arg_upward (machine_mode, const_tree);\n+bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);\n-bool aarch64_simd_check_vect_par_cnst_half (rtx op, enum machine_mode mode,\n+bool aarch64_simd_check_vect_par_cnst_half (rtx op, machine_mode mode,\n \t\t\t\t\t    bool high);\n-bool aarch64_simd_imm_scalar_p (rtx x, enum machine_mode mode);\n-bool aarch64_simd_imm_zero_p (rtx, enum machine_mode);\n-bool aarch64_simd_scalar_immediate_valid_for_move (rtx, enum machine_mode);\n-bool aarch64_simd_shift_imm_p (rtx, enum machine_mode, bool);\n-bool aarch64_simd_valid_immediate (rtx, enum machine_mode, bool,\n+bool aarch64_simd_imm_scalar_p (rtx x, machine_mode mode);\n+bool aarch64_simd_imm_zero_p (rtx, machine_mode);\n+bool aarch64_simd_scalar_immediate_valid_for_move (rtx, machine_mode);\n+bool aarch64_simd_shift_imm_p (rtx, machine_mode, bool);\n+bool aarch64_simd_valid_immediate (rtx, machine_mode, bool,\n \t\t\t\t   struct simd_immediate_info *);\n bool aarch64_symbolic_address_p (rtx);\n bool aarch64_uimm12_shift (HOST_WIDE_INT);\n@@ -222,19 +222,19 @@ enum aarch64_symbol_type aarch64_classify_symbol (rtx,\n enum aarch64_symbol_type aarch64_classify_tls_symbol (rtx);\n enum reg_class aarch64_regno_regclass (unsigned);\n int aarch64_asm_preferred_eh_data_format (int, int);\n-enum machine_mode aarch64_hard_regno_caller_save_mode (unsigned, unsigned,\n-\t\t\t\t\t\t       enum machine_mode);\n-int aarch64_hard_regno_mode_ok (unsigned, enum machine_mode);\n-int aarch64_hard_regno_nregs (unsigned, enum machine_mode);\n+machine_mode aarch64_hard_regno_caller_save_mode (unsigned, unsigned,\n+\t\t\t\t\t\t       machine_mode);\n+int aarch64_hard_regno_mode_ok (unsigned, machine_mode);\n+int aarch64_hard_regno_nregs (unsigned, machine_mode);\n int aarch64_simd_attr_length_move (rtx_insn *);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n rtx aarch64_final_eh_return_addr (void);\n-rtx aarch64_legitimize_reload_address (rtx *, enum machine_mode, int, int, int);\n+rtx aarch64_legitimize_reload_address (rtx *, machine_mode, int, int, int);\n const char *aarch64_output_move_struct (rtx *operands);\n rtx aarch64_return_addr (int, rtx);\n-rtx aarch64_simd_gen_const_vector_dup (enum machine_mode, int);\n+rtx aarch64_simd_gen_const_vector_dup (machine_mode, int);\n bool aarch64_simd_mem_operand_p (rtx);\n-rtx aarch64_simd_vect_par_cnst_half (enum machine_mode, bool);\n+rtx aarch64_simd_vect_par_cnst_half (machine_mode, bool);\n rtx aarch64_tls_get_addr (void);\n tree aarch64_fold_builtin (tree, int, tree *, bool);\n unsigned aarch64_dbx_register_number (unsigned);\n@@ -260,7 +260,7 @@ void aarch64_simd_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n \n /* Emit code to place a AdvSIMD pair result in memory locations (with equal\n    registers).  */\n-void aarch64_simd_emit_pair_result_insn (enum machine_mode,\n+void aarch64_simd_emit_pair_result_insn (machine_mode,\n \t\t\t\t\t rtx (*intfn) (rtx, rtx, rtx), rtx,\n \t\t\t\t\t rtx);\n \n@@ -282,8 +282,8 @@ bool aarch64_float_const_representable_p (rtx);\n \n #if defined (RTX_CODE)\n \n-bool aarch64_legitimate_address_p (enum machine_mode, rtx, RTX_CODE, bool);\n-enum machine_mode aarch64_select_cc_mode (RTX_CODE, rtx, rtx);\n+bool aarch64_legitimate_address_p (machine_mode, rtx, RTX_CODE, bool);\n+machine_mode aarch64_select_cc_mode (RTX_CODE, rtx, rtx);\n rtx aarch64_gen_compare_reg (RTX_CODE, rtx, rtx);\n rtx aarch64_load_tp (rtx);\n \n@@ -297,7 +297,7 @@ void aarch64_init_builtins (void);\n rtx aarch64_expand_builtin (tree exp,\n \t\t\t    rtx target,\n \t\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    int ignore ATTRIBUTE_UNUSED);\n tree aarch64_builtin_decl (unsigned, bool ATTRIBUTE_UNUSED);\n "}, {"sha": "ef196e4b6fb39c0d2fd9ebfee76abab8369b1e92", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -3807,7 +3807,7 @@\n     if (GP_REGNUM_P (REGNO (operands[0]))\n \t&& GP_REGNUM_P (REGNO (operands[1])))\n       {\n-\tenum machine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n+\tmachine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n \trtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n \trtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n \temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n@@ -3870,7 +3870,7 @@\n     if (GP_REGNUM_P (REGNO (operands[0]))\n \t&& GP_REGNUM_P (REGNO (operands[1])))\n       {\n-\tenum machine_mode mode = CCmode;\n+\tmachine_mode mode = CCmode;\n \trtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n \trtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n \temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n@@ -3943,7 +3943,7 @@\n \t&& GP_REGNUM_P (REGNO (operands[1])))\n       {\n \trtx and_tree = gen_rtx_AND (DImode, operands[1], operands[2]);\n-\tenum machine_mode mode = SELECT_CC_MODE (NE, and_tree, const0_rtx);\n+\tmachine_mode mode = SELECT_CC_MODE (NE, and_tree, const0_rtx);\n \trtx cc_reg = aarch64_gen_compare_reg (NE, and_tree, const0_rtx);\n \trtx comparison = gen_rtx_NE (mode, and_tree, const0_rtx);\n \temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n@@ -4319,7 +4319,7 @@\n    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_TWO_ELEM>mode;\n+  machine_mode mode = <V_TWO_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   emit_insn (gen_aarch64_simd_ld2r<mode> (operands[0], mem));\n@@ -4332,7 +4332,7 @@\n    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_THREE_ELEM>mode;\n+  machine_mode mode = <V_THREE_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   emit_insn (gen_aarch64_simd_ld3r<mode> (operands[0], mem));\n@@ -4345,7 +4345,7 @@\n    (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_FOUR_ELEM>mode;\n+  machine_mode mode = <V_FOUR_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   emit_insn (gen_aarch64_simd_ld4r<mode> (operands[0],mem));\n@@ -4490,7 +4490,7 @@\n   (unspec:VDC [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;\n+  machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   emit_insn (gen_aarch64_ld<VSTRUCT:nregs><VDC:mode>_dreg (operands[0], mem));\n@@ -4502,7 +4502,7 @@\n   (match_operand:DI 1 \"register_operand\")]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VALL:MODE>mode;\n+  machine_mode mode = <VALL:MODE>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   if (BYTES_BIG_ENDIAN)\n@@ -4518,7 +4518,7 @@\n   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VSTRUCT:MODE>mode;\n+  machine_mode mode = <VSTRUCT:MODE>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   emit_insn (gen_vec_load_lanes<VSTRUCT:mode><VQ:mode> (operands[0], mem));\n@@ -4533,7 +4533,7 @@\n \t(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_TWO_ELEM>mode;\n+  machine_mode mode = <V_TWO_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode));\n@@ -4552,7 +4552,7 @@\n \t(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_THREE_ELEM>mode;\n+  machine_mode mode = <V_THREE_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode));\n@@ -4571,7 +4571,7 @@\n \t(unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_FOUR_ELEM>mode;\n+  machine_mode mode = <V_FOUR_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[1]);\n \n   aarch64_simd_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<VCONQ>mode));\n@@ -4804,7 +4804,7 @@\n   (unspec:VDC [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;\n+  machine_mode mode = <VSTRUCT:VSTRUCT_DREG>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n \n   emit_insn (gen_aarch64_st<VSTRUCT:nregs><VDC:mode>_dreg (mem, operands[1]));\n@@ -4817,7 +4817,7 @@\n   (unspec:VQ [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VSTRUCT:MODE>mode;\n+  machine_mode mode = <VSTRUCT:MODE>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n \n   emit_insn (gen_vec_store_lanes<VSTRUCT:mode><VQ:mode> (mem, operands[1]));\n@@ -4831,7 +4831,7 @@\n   (match_operand:SI 2 \"immediate_operand\")]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_TWO_ELEM>mode;\n+  machine_mode mode = <V_TWO_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n   operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n \n@@ -4848,7 +4848,7 @@\n   (match_operand:SI 2 \"immediate_operand\")]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_THREE_ELEM>mode;\n+  machine_mode mode = <V_THREE_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n   operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n \n@@ -4865,7 +4865,7 @@\n   (match_operand:SI 2 \"immediate_operand\")]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <V_FOUR_ELEM>mode;\n+  machine_mode mode = <V_FOUR_ELEM>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n   operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n \n@@ -4880,7 +4880,7 @@\n   (match_operand:VALL 1 \"register_operand\")]\n   \"TARGET_SIMD\"\n {\n-  enum machine_mode mode = <VALL:MODE>mode;\n+  machine_mode mode = <VALL:MODE>mode;\n   rtx mem = gen_rtx_MEM (mode, operands[0]);\n \n   if (BYTES_BIG_ENDIAN)"}, {"sha": "e222ee37cf257a4449ec4fa0e74736524088721b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 142, "deletions": 142, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -140,19 +140,19 @@ enum aarch64_code_model aarch64_cmodel;\n #endif\n \n static bool aarch64_lra_p (void);\n-static bool aarch64_composite_type_p (const_tree, enum machine_mode);\n-static bool aarch64_vfp_is_call_or_return_candidate (enum machine_mode,\n+static bool aarch64_composite_type_p (const_tree, machine_mode);\n+static bool aarch64_vfp_is_call_or_return_candidate (machine_mode,\n \t\t\t\t\t\t     const_tree,\n-\t\t\t\t\t\t     enum machine_mode *, int *,\n+\t\t\t\t\t\t     machine_mode *, int *,\n \t\t\t\t\t\t     bool *);\n static void aarch64_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n static void aarch64_override_options_after_change (void);\n-static bool aarch64_vector_mode_supported_p (enum machine_mode);\n+static bool aarch64_vector_mode_supported_p (machine_mode);\n static unsigned bit_count (unsigned HOST_WIDE_INT);\n-static bool aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+static bool aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t\t const unsigned char *sel);\n-static int aarch64_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n+static int aarch64_address_cost (rtx, machine_mode, addr_space_t, bool);\n \n /* The processor for which instructions should be scheduled.  */\n enum aarch64_processor aarch64_tune = cortexa53;\n@@ -401,7 +401,7 @@ static const struct aarch64_option_extension all_extensions[] =\n \n /* Used to track the size of an address when generating a pre/post\n    increment address.  */\n-static enum machine_mode aarch64_memory_reference_mode;\n+static machine_mode aarch64_memory_reference_mode;\n \n /* Used to force GTY into this file.  */\n static GTY(()) int gty_dummy;\n@@ -447,22 +447,22 @@ aarch64_dbx_register_number (unsigned regno)\n \n /* Return TRUE if MODE is any of the large INT modes.  */\n static bool\n-aarch64_vect_struct_mode_p (enum machine_mode mode)\n+aarch64_vect_struct_mode_p (machine_mode mode)\n {\n   return mode == OImode || mode == CImode || mode == XImode;\n }\n \n /* Return TRUE if MODE is any of the vector modes.  */\n static bool\n-aarch64_vector_mode_p (enum machine_mode mode)\n+aarch64_vector_mode_p (machine_mode mode)\n {\n   return aarch64_vector_mode_supported_p (mode)\n \t || aarch64_vect_struct_mode_p (mode);\n }\n \n /* Implement target hook TARGET_ARRAY_MODE_SUPPORTED_P.  */\n static bool\n-aarch64_array_mode_supported_p (enum machine_mode mode,\n+aarch64_array_mode_supported_p (machine_mode mode,\n \t\t\t\tunsigned HOST_WIDE_INT nelems)\n {\n   if (TARGET_SIMD\n@@ -476,7 +476,7 @@ aarch64_array_mode_supported_p (enum machine_mode mode,\n /* Implement HARD_REGNO_NREGS.  */\n \n int\n-aarch64_hard_regno_nregs (unsigned regno, enum machine_mode mode)\n+aarch64_hard_regno_nregs (unsigned regno, machine_mode mode)\n {\n   switch (aarch64_regno_regclass (regno))\n     {\n@@ -492,7 +492,7 @@ aarch64_hard_regno_nregs (unsigned regno, enum machine_mode mode)\n /* Implement HARD_REGNO_MODE_OK.  */\n \n int\n-aarch64_hard_regno_mode_ok (unsigned regno, enum machine_mode mode)\n+aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return regno == CC_REGNUM;\n@@ -522,9 +522,9 @@ aarch64_hard_regno_mode_ok (unsigned regno, enum machine_mode mode)\n }\n \n /* Implement HARD_REGNO_CALLER_SAVE_MODE.  */\n-enum machine_mode\n+machine_mode\n aarch64_hard_regno_caller_save_mode (unsigned regno, unsigned nregs,\n-\t\t\t\t     enum machine_mode mode)\n+\t\t\t\t     machine_mode mode)\n {\n   /* Handle modes that fit within single registers.  */\n   if (nregs == 1 && GET_MODE_SIZE (mode) <= 16)\n@@ -561,7 +561,7 @@ aarch64_is_long_call_p (rtx sym)\n \n    (extract:MODE (mult (reg) (MULT_IMM)) (EXTRACT_IMM) (const_int 0)).  */\n bool\n-aarch64_is_extend_from_extract (enum machine_mode mode, rtx mult_imm,\n+aarch64_is_extend_from_extract (machine_mode mode, rtx mult_imm,\n \t\t\t\trtx extract_imm)\n {\n   HOST_WIDE_INT mult_val, extract_val;\n@@ -595,7 +595,7 @@ emit_set_insn (rtx x, rtx y)\n rtx\n aarch64_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n {\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n \n   emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n@@ -686,7 +686,7 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n       {\n \t/* In ILP32, the mode of dest can be either SImode or DImode.  */\n \trtx tmp_reg = dest;\n-\tenum machine_mode mode = GET_MODE (dest);\n+\tmachine_mode mode = GET_MODE (dest);\n \n \tgcc_assert (mode == Pmode || mode == ptr_mode);\n \n@@ -712,7 +712,7 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n \t   This is why we have to handle three different ldr_got_small\n \t   patterns here (two patterns for ILP32).  */\n \trtx tmp_reg = dest;\n-\tenum machine_mode mode = GET_MODE (dest);\n+\tmachine_mode mode = GET_MODE (dest);\n \n \tif (can_create_pseudo_p ())\n \t  tmp_reg = gen_reg_rtx (mode);\n@@ -751,7 +751,7 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n \n     case SYMBOL_SMALL_TLSDESC:\n       {\n-\tenum machine_mode mode = GET_MODE (dest);\n+\tmachine_mode mode = GET_MODE (dest);\n \trtx x0 = gen_rtx_REG (mode, R0_REGNUM);\n \trtx tp;\n \n@@ -782,7 +782,7 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n \t   DImode if dest is dereferenced to access the memeory.\n \t   This is why we have to handle three different tlsie_small\n \t   patterns here (two patterns for ILP32).  */\n-\tenum machine_mode mode = GET_MODE (dest);\n+\tmachine_mode mode = GET_MODE (dest);\n \trtx tmp_reg = gen_reg_rtx (mode);\n \trtx tp = aarch64_load_tp (NULL);\n \n@@ -849,7 +849,7 @@ aarch64_split_128bit_move (rtx dst, rtx src)\n   rtx dst_lo, dst_hi;\n   rtx src_lo, src_hi;\n \n-  enum machine_mode mode = GET_MODE (dst);\n+  machine_mode mode = GET_MODE (dst);\n \n   gcc_assert (mode == TImode || mode == TFmode);\n   gcc_assert (!(side_effects_p (src) || side_effects_p (dst)));\n@@ -927,8 +927,8 @@ aarch64_split_128bit_move_p (rtx dst, rtx src)\n void\n aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)\n {\n-  enum machine_mode src_mode = GET_MODE (src1);\n-  enum machine_mode dst_mode = GET_MODE (dst);\n+  machine_mode src_mode = GET_MODE (src1);\n+  machine_mode dst_mode = GET_MODE (dst);\n \n   gcc_assert (VECTOR_MODE_P (dst_mode));\n \n@@ -970,8 +970,8 @@ aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)\n void\n aarch64_split_simd_move (rtx dst, rtx src)\n {\n-  enum machine_mode src_mode = GET_MODE (src);\n-  enum machine_mode dst_mode = GET_MODE (dst);\n+  machine_mode src_mode = GET_MODE (src);\n+  machine_mode dst_mode = GET_MODE (dst);\n \n   gcc_assert (VECTOR_MODE_P (dst_mode));\n \n@@ -1011,7 +1011,7 @@ aarch64_split_simd_move (rtx dst, rtx src)\n }\n \n static rtx\n-aarch64_force_temporary (enum machine_mode mode, rtx x, rtx value)\n+aarch64_force_temporary (machine_mode mode, rtx x, rtx value)\n {\n   if (can_create_pseudo_p ())\n     return force_reg (mode, value);\n@@ -1024,7 +1024,7 @@ aarch64_force_temporary (enum machine_mode mode, rtx x, rtx value)\n \n \n static rtx\n-aarch64_add_offset (enum machine_mode mode, rtx temp, rtx reg, HOST_WIDE_INT offset)\n+aarch64_add_offset (machine_mode mode, rtx temp, rtx reg, HOST_WIDE_INT offset)\n {\n   if (!aarch64_plus_immediate (GEN_INT (offset), mode))\n     {\n@@ -1043,7 +1043,7 @@ aarch64_add_offset (enum machine_mode mode, rtx temp, rtx reg, HOST_WIDE_INT off\n void\n aarch64_expand_mov_immediate (rtx dest, rtx imm)\n {\n-  enum machine_mode mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (dest);\n   unsigned HOST_WIDE_INT mask;\n   int i;\n   bool first;\n@@ -1343,12 +1343,12 @@ aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \n static bool\n aarch64_pass_by_reference (cumulative_args_t pcum ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode,\n+\t\t\t   machine_mode mode,\n \t\t\t   const_tree type,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size;\n-  enum machine_mode dummymode;\n+  machine_mode dummymode;\n   int nregs;\n \n   /* GET_MODE_SIZE (BLKmode) is useless since it is 0.  */\n@@ -1381,7 +1381,7 @@ aarch64_pass_by_reference (cumulative_args_t pcum ATTRIBUTE_UNUSED,\n static bool\n aarch64_return_in_msb (const_tree valtype)\n {\n-  enum machine_mode dummy_mode;\n+  machine_mode dummy_mode;\n   int dummy_int;\n \n   /* Never happens in little-endian mode.  */\n@@ -1413,10 +1413,10 @@ static rtx\n aarch64_function_value (const_tree type, const_tree func,\n \t\t\tbool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsignedp;\n   int count;\n-  enum machine_mode ag_mode;\n+  machine_mode ag_mode;\n \n   mode = TYPE_MODE (type);\n   if (INTEGRAL_TYPE_P (type))\n@@ -1495,7 +1495,7 @@ static bool\n aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size;\n-  enum machine_mode ag_mode;\n+  machine_mode ag_mode;\n   int count;\n \n   if (!AGGREGATE_TYPE_P (type)\n@@ -1517,7 +1517,7 @@ aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n }\n \n static bool\n-aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, enum machine_mode mode,\n+aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, machine_mode mode,\n \t\t\t       const_tree type, int *nregs)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n@@ -1534,7 +1534,7 @@ aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, enum machine_mode mode,\n    This is a helper function for local use only.  */\n \n static unsigned int\n-aarch64_function_arg_alignment (enum machine_mode mode, const_tree type)\n+aarch64_function_arg_alignment (machine_mode mode, const_tree type)\n {\n   unsigned int alignment;\n \n@@ -1560,7 +1560,7 @@ aarch64_function_arg_alignment (enum machine_mode mode, const_tree type)\n    numbers refer to the rule numbers in the AAPCS64.  */\n \n static void\n-aarch64_layout_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n+aarch64_layout_arg (cumulative_args_t pcum_v, machine_mode mode,\n \t\t    const_tree type,\n \t\t    bool named ATTRIBUTE_UNUSED)\n {\n@@ -1691,7 +1691,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-aarch64_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n+aarch64_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n \t\t      const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n@@ -1726,7 +1726,7 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n \n static void\n aarch64_function_arg_advance (cumulative_args_t pcum_v,\n-\t\t\t      enum machine_mode mode,\n+\t\t\t      machine_mode mode,\n \t\t\t      const_tree type,\n \t\t\t      bool named)\n {\n@@ -1760,7 +1760,7 @@ aarch64_function_arg_regno_p (unsigned regno)\n    8 bytes.  */\n \n static unsigned int\n-aarch64_function_arg_boundary (enum machine_mode mode, const_tree type)\n+aarch64_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   unsigned int alignment = aarch64_function_arg_alignment (mode, type);\n \n@@ -1781,7 +1781,7 @@ aarch64_function_arg_boundary (enum machine_mode mode, const_tree type)\n    The related parameter passing rules are B.4, C.3, C.5 and C.14.  */\n \n bool\n-aarch64_pad_arg_upward (enum machine_mode mode, const_tree type)\n+aarch64_pad_arg_upward (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the least significant byte of every stack\n      argument is passed at the lowest byte address of the stack slot.  */\n@@ -1824,7 +1824,7 @@ aarch64_pad_arg_upward (enum machine_mode mode, const_tree type)\n    significant byte does.  */\n \n bool\n-aarch64_pad_reg_upward (enum machine_mode mode, const_tree type,\n+aarch64_pad_reg_upward (machine_mode mode, const_tree type,\n \t\t     bool first ATTRIBUTE_UNUSED)\n {\n \n@@ -1841,7 +1841,7 @@ aarch64_pad_reg_upward (enum machine_mode mode, const_tree type,\n   return !BYTES_BIG_ENDIAN;\n }\n \n-static enum machine_mode\n+static machine_mode\n aarch64_libgcc_cmp_return_mode (void)\n {\n   return SImode;\n@@ -1973,7 +1973,7 @@ aarch64_next_callee_save (unsigned regno, unsigned limit)\n }\n \n static void\n-aarch64_pushwb_single_reg (enum machine_mode mode, unsigned regno,\n+aarch64_pushwb_single_reg (machine_mode mode, unsigned regno,\n \t\t\t   HOST_WIDE_INT adjustment)\n  {\n   rtx base_rtx = stack_pointer_rtx;\n@@ -1989,7 +1989,7 @@ aarch64_pushwb_single_reg (enum machine_mode mode, unsigned regno,\n }\n \n static rtx\n-aarch64_gen_storewb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n+aarch64_gen_storewb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n \t\t\t  HOST_WIDE_INT adjustment)\n {\n   switch (mode)\n@@ -2008,7 +2008,7 @@ aarch64_gen_storewb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n }\n \n static void\n-aarch64_pushwb_pair_reg (enum machine_mode mode, unsigned regno1,\n+aarch64_pushwb_pair_reg (machine_mode mode, unsigned regno1,\n \t\t\t unsigned regno2, HOST_WIDE_INT adjustment)\n {\n   rtx_insn *insn;\n@@ -2023,7 +2023,7 @@ aarch64_pushwb_pair_reg (enum machine_mode mode, unsigned regno1,\n }\n \n static rtx\n-aarch64_gen_loadwb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n+aarch64_gen_loadwb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n \t\t\t HOST_WIDE_INT adjustment)\n {\n   switch (mode)\n@@ -2040,7 +2040,7 @@ aarch64_gen_loadwb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n }\n \n static rtx\n-aarch64_gen_store_pair (enum machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n+aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n \t\t\trtx reg2)\n {\n   switch (mode)\n@@ -2057,7 +2057,7 @@ aarch64_gen_store_pair (enum machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n }\n \n static rtx\n-aarch64_gen_load_pair (enum machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n+aarch64_gen_load_pair (machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n \t\t       rtx mem2)\n {\n   switch (mode)\n@@ -2075,11 +2075,11 @@ aarch64_gen_load_pair (enum machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n \n \n static void\n-aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n+aarch64_save_callee_saves (machine_mode mode, HOST_WIDE_INT start_offset,\n \t\t\t   unsigned start, unsigned limit, bool skip_wb)\n {\n   rtx_insn *insn;\n-  rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n+  rtx (*gen_mem_ref) (machine_mode, rtx) = (frame_pointer_needed\n \t\t\t\t\t\t ? gen_frame_mem : gen_rtx_MEM);\n   unsigned regno;\n   unsigned regno2;\n@@ -2132,12 +2132,12 @@ aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n }\n \n static void\n-aarch64_restore_callee_saves (enum machine_mode mode,\n+aarch64_restore_callee_saves (machine_mode mode,\n \t\t\t      HOST_WIDE_INT start_offset, unsigned start,\n \t\t\t      unsigned limit, bool skip_wb, rtx *cfi_ops)\n {\n   rtx base_rtx = stack_pointer_rtx;\n-  rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n+  rtx (*gen_mem_ref) (machine_mode, rtx) = (frame_pointer_needed\n \t\t\t\t\t\t ? gen_frame_mem : gen_rtx_MEM);\n   unsigned regno;\n   unsigned regno2;\n@@ -2340,7 +2340,7 @@ aarch64_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      enum machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n+\t      machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n \n \t      skip_wb = true;\n \n@@ -2461,7 +2461,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n \n       if (skip_wb)\n \t{\n-\t  enum machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n+\t  machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n \t  rtx rreg1 = gen_rtx_REG (mode1, reg1);\n \n \t  cfi_ops = alloc_reg_note (REG_CFA_RESTORE, rreg1, cfi_ops);\n@@ -2891,7 +2891,7 @@ aarch64_uimm12_shift (HOST_WIDE_INT val)\n /* Return true if val is an immediate that can be loaded into a\n    register by a MOVZ instruction.  */\n static bool\n-aarch64_movw_imm (HOST_WIDE_INT val, enum machine_mode mode)\n+aarch64_movw_imm (HOST_WIDE_INT val, machine_mode mode)\n {\n   if (GET_MODE_SIZE (mode) > 4)\n     {\n@@ -2911,7 +2911,7 @@ aarch64_movw_imm (HOST_WIDE_INT val, enum machine_mode mode)\n \n /* Return true if val is a valid bitmask immediate.  */\n bool\n-aarch64_bitmask_imm (HOST_WIDE_INT val, enum machine_mode mode)\n+aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode mode)\n {\n   if (GET_MODE_SIZE (mode) < 8)\n     {\n@@ -2927,15 +2927,15 @@ aarch64_bitmask_imm (HOST_WIDE_INT val, enum machine_mode mode)\n /* Return true if val is an immediate that can be loaded into a\n    register in a single instruction.  */\n bool\n-aarch64_move_imm (HOST_WIDE_INT val, enum machine_mode mode)\n+aarch64_move_imm (HOST_WIDE_INT val, machine_mode mode)\n {\n   if (aarch64_movw_imm (val, mode) || aarch64_movw_imm (~val, mode))\n     return 1;\n   return aarch64_bitmask_imm (val, mode);\n }\n \n static bool\n-aarch64_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+aarch64_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   rtx base, offset;\n \n@@ -3019,7 +3019,7 @@ aarch64_base_register_rtx_p (rtx x, bool strict_p)\n \n static bool\n aarch64_classify_index (struct aarch64_address_info *info, rtx x,\n-\t\t\tenum machine_mode mode, bool strict_p)\n+\t\t\tmachine_mode mode, bool strict_p)\n {\n   enum aarch64_address_type type;\n   rtx index;\n@@ -3174,22 +3174,22 @@ aarch64_classify_index (struct aarch64_address_info *info, rtx x,\n }\n \n bool\n-aarch64_offset_7bit_signed_scaled_p (enum machine_mode mode, HOST_WIDE_INT offset)\n+aarch64_offset_7bit_signed_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n {\n   return (offset >= -64 * GET_MODE_SIZE (mode)\n \t  && offset < 64 * GET_MODE_SIZE (mode)\n \t  && offset % GET_MODE_SIZE (mode) == 0);\n }\n \n static inline bool\n-offset_9bit_signed_unscaled_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+offset_9bit_signed_unscaled_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       HOST_WIDE_INT offset)\n {\n   return offset >= -256 && offset < 256;\n }\n \n static inline bool\n-offset_12bit_unsigned_scaled_p (enum machine_mode mode, HOST_WIDE_INT offset)\n+offset_12bit_unsigned_scaled_p (machine_mode mode, HOST_WIDE_INT offset)\n {\n   return (offset >= 0\n \t  && offset < 4096 * GET_MODE_SIZE (mode)\n@@ -3202,7 +3202,7 @@ offset_12bit_unsigned_scaled_p (enum machine_mode mode, HOST_WIDE_INT offset)\n \n static bool\n aarch64_classify_address (struct aarch64_address_info *info,\n-\t\t\t  rtx x, enum machine_mode mode,\n+\t\t\t  rtx x, machine_mode mode,\n \t\t\t  RTX_CODE outer_code, bool strict_p)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -3423,7 +3423,7 @@ aarch64_classify_symbolic_expression (rtx x,\n /* Return TRUE if X is a legitimate address for accessing memory in\n    mode MODE.  */\n static bool\n-aarch64_legitimate_address_hook_p (enum machine_mode mode, rtx x, bool strict_p)\n+aarch64_legitimate_address_hook_p (machine_mode mode, rtx x, bool strict_p)\n {\n   struct aarch64_address_info addr;\n \n@@ -3434,7 +3434,7 @@ aarch64_legitimate_address_hook_p (enum machine_mode mode, rtx x, bool strict_p)\n    mode MODE.  OUTER_CODE will be PARALLEL if this is a load/store\n    pair operation.  */\n bool\n-aarch64_legitimate_address_p (enum machine_mode mode, rtx x,\n+aarch64_legitimate_address_p (machine_mode mode, rtx x,\n \t\t\t      RTX_CODE outer_code, bool strict_p)\n {\n   struct aarch64_address_info addr;\n@@ -3479,7 +3479,7 @@ aarch64_emit_call_insn (rtx pat)\n   clobber_reg (fusage, gen_rtx_REG (word_mode, IP1_REGNUM));\n }\n \n-enum machine_mode\n+machine_mode\n aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n {\n   /* All floating point compares return CCFP if it is an equality\n@@ -3551,7 +3551,7 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n int\n aarch64_get_condition_code (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (XEXP (x, 0));\n+  machine_mode mode = GET_MODE (XEXP (x, 0));\n   enum rtx_code comp_code = GET_CODE (x);\n \n   if (GET_MODE_CLASS (mode) != MODE_CC)\n@@ -4199,7 +4199,7 @@ aarch64_regno_regclass (unsigned regno)\n }\n \n static rtx\n-aarch64_legitimize_address (rtx x, rtx /* orig_x  */, enum machine_mode mode)\n+aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n {\n   /* Try to split X+CONST into Y=X+(CONST & ~mask), Y+(CONST&mask),\n      where mask is selected by alignment and size of the offset.\n@@ -4244,7 +4244,7 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, enum machine_mode mode)\n \n rtx\n aarch64_legitimize_reload_address (rtx *x_p,\n-\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   machine_mode mode,\n \t\t\t\t   int opnum, int type,\n \t\t\t\t   int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -4294,7 +4294,7 @@ aarch64_legitimize_reload_address (rtx *x_p,\n       HOST_WIDE_INT high = val - low;\n       HOST_WIDE_INT offs;\n       rtx cst;\n-      enum machine_mode xmode = GET_MODE (x);\n+      machine_mode xmode = GET_MODE (x);\n \n       /* In ILP32, xmode can be either DImode or SImode.  */\n       gcc_assert (xmode == DImode || xmode == SImode);\n@@ -4356,7 +4356,7 @@ aarch64_legitimize_reload_address (rtx *x_p,\n static reg_class_t\n aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  reg_class_t rclass,\n-\t\t\t  enum machine_mode mode,\n+\t\t\t  machine_mode mode,\n \t\t\t  secondary_reload_info *sri)\n {\n   /* Without the TARGET_SIMD instructions we cannot move a Q register\n@@ -4493,7 +4493,7 @@ aarch64_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n }\n \n static unsigned char\n-aarch64_class_max_nregs (reg_class_t regclass, enum machine_mode mode)\n+aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)\n {\n   switch (regclass)\n     {\n@@ -4670,7 +4670,7 @@ aarch64_uxt_size (int shift, HOST_WIDE_INT mask)\n }\n \n static bool\n-aarch64_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+aarch64_use_blocks_for_constant_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t   const_rtx x ATTRIBUTE_UNUSED)\n {\n   /* We can't use blocks for constants when we're using a per-function\n@@ -4679,7 +4679,7 @@ aarch64_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n static section *\n-aarch64_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n+aarch64_select_rtx_section (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    rtx x ATTRIBUTE_UNUSED,\n \t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n@@ -4773,7 +4773,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n     = aarch64_tune_params->insn_extra_cost;\n   int cost = 0;\n   bool maybe_fma = (outer == PLUS || outer == MINUS);\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   gcc_checking_assert (code == MULT);\n \n@@ -4871,7 +4871,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \n static int\n aarch64_address_cost (rtx x,\n-\t\t      enum machine_mode mode,\n+\t\t      machine_mode mode,\n \t\t      addr_space_t as ATTRIBUTE_UNUSED,\n \t\t      bool speed)\n {\n@@ -4967,7 +4967,7 @@ aarch64_address_cost (rtx x,\n /* Return true if the RTX X in mode MODE is a zero or sign extract\n    usable in an ADD or SUB (extended register) instruction.  */\n static bool\n-aarch64_rtx_arith_op_extract_p (rtx x, enum machine_mode mode)\n+aarch64_rtx_arith_op_extract_p (rtx x, machine_mode mode)\n {\n   /* Catch add with a sign extract.\n      This is add_<optab><mode>_multp2.  */\n@@ -5095,7 +5095,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n   rtx op0, op1, op2;\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params->insn_extra_cost;\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   /* By default, assume that everything has equivalent cost to the\n      cheapest instruction.  Any additional costs are applied as a delta\n@@ -6033,7 +6033,7 @@ aarch64_rtx_costs_wrapper (rtx x, int code, int outer,\n }\n \n static int\n-aarch64_register_move_cost (enum machine_mode mode,\n+aarch64_register_move_cost (machine_mode mode,\n \t\t\t    reg_class_t from_i, reg_class_t to_i)\n {\n   enum reg_class from = (enum reg_class) from_i;\n@@ -6090,7 +6090,7 @@ aarch64_register_move_cost (enum machine_mode mode,\n }\n \n static int\n-aarch64_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+aarch64_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t\t  bool in ATTRIBUTE_UNUSED)\n {\n@@ -6658,7 +6658,7 @@ aarch64_legitimate_pic_operand_p (rtx x)\n /* Return true if X holds either a quarter-precision or\n      floating-point +0.0 constant.  */\n static bool\n-aarch64_valid_floating_const (enum machine_mode mode, rtx x)\n+aarch64_valid_floating_const (machine_mode mode, rtx x)\n {\n   if (!CONST_DOUBLE_P (x))\n     return false;\n@@ -6677,7 +6677,7 @@ aarch64_valid_floating_const (enum machine_mode mode, rtx x)\n }\n \n static bool\n-aarch64_legitimate_constant_p (enum machine_mode mode, rtx x)\n+aarch64_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   /* Do not allow vector struct mode constants.  We could support\n      0 and -1 easily, but they need support in aarch64-simd.md.  */\n@@ -6879,9 +6879,9 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   bool indirect_p;\n   bool is_ha;\t\t/* is HFA or HVA.  */\n   bool dw_align;\t/* double-word align.  */\n-  enum machine_mode ag_mode = VOIDmode;\n+  machine_mode ag_mode = VOIDmode;\n   int nregs;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   tree f_stack, f_grtop, f_vrtop, f_groff, f_vroff;\n   tree stack, f_top, f_off, off, arg, roundup, on_stack;\n@@ -7133,7 +7133,7 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-aarch64_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n+aarch64_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t\tint no_rtl)\n {\n@@ -7178,7 +7178,7 @@ aarch64_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n \t{\n \t  /* We can't use move_block_from_reg, because it will use\n \t     the wrong mode, storing D regs only.  */\n-\t  enum machine_mode mode = TImode;\n+\t  machine_mode mode = TImode;\n \t  int off, i;\n \n \t  /* Set OFF to the offset from virtual_incoming_args_rtx of\n@@ -7229,9 +7229,9 @@ aarch64_conditional_register_usage (void)\n    type that doesn't match a non-VOIDmode *MODEP is found, then return -1,\n    otherwise return the count in the sub-tree.  */\n static int\n-aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n+aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   HOST_WIDE_INT size;\n \n   switch (TREE_CODE (type))\n@@ -7415,7 +7415,7 @@ aarch64_lra_p (void)\n \n static bool\n aarch64_composite_type_p (const_tree type,\n-\t\t\t  enum machine_mode mode)\n+\t\t\t  machine_mode mode)\n {\n   if (type && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE))\n     return true;\n@@ -7435,7 +7435,7 @@ aarch64_composite_type_p (const_tree type,\n \n static bool\n aarch64_short_vector_p (const_tree type,\n-\t\t\tenum machine_mode mode)\n+\t\t\tmachine_mode mode)\n {\n   HOST_WIDE_INT size = -1;\n \n@@ -7459,13 +7459,13 @@ aarch64_short_vector_p (const_tree type,\n    floating-point aggregate or a homogeneous short-vector aggregate.  */\n \n static bool\n-aarch64_vfp_is_call_or_return_candidate (enum machine_mode mode,\n+aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n \t\t\t\t\t const_tree type,\n-\t\t\t\t\t enum machine_mode *base_mode,\n+\t\t\t\t\t machine_mode *base_mode,\n \t\t\t\t\t int *count,\n \t\t\t\t\t bool *is_ha)\n {\n-  enum machine_mode new_mode = VOIDmode;\n+  machine_mode new_mode = VOIDmode;\n   bool composite_p = aarch64_composite_type_p (type, mode);\n \n   if (is_ha != NULL) *is_ha = false;\n@@ -7512,7 +7512,7 @@ aarch64_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n \n /* Implements target hook vector_mode_supported_p.  */\n static bool\n-aarch64_vector_mode_supported_p (enum machine_mode mode)\n+aarch64_vector_mode_supported_p (machine_mode mode)\n {\n   if (TARGET_SIMD\n       && (mode == V4SImode  || mode == V8HImode\n@@ -7528,8 +7528,8 @@ aarch64_vector_mode_supported_p (enum machine_mode mode)\n \n /* Return appropriate SIMD container\n    for MODE within a vector of WIDTH bits.  */\n-static enum machine_mode\n-aarch64_simd_container_mode (enum machine_mode mode, unsigned width)\n+static machine_mode\n+aarch64_simd_container_mode (machine_mode mode, unsigned width)\n {\n   gcc_assert (width == 64 || width == 128);\n   if (TARGET_SIMD)\n@@ -7571,8 +7571,8 @@ aarch64_simd_container_mode (enum machine_mode mode, unsigned width)\n }\n \n /* Return 128-bit container as the preferred SIMD mode for MODE.  */\n-static enum machine_mode\n-aarch64_preferred_simd_mode (enum machine_mode mode)\n+static machine_mode\n+aarch64_preferred_simd_mode (machine_mode mode)\n {\n   return aarch64_simd_container_mode (mode, 128);\n }\n@@ -7597,7 +7597,7 @@ aarch64_autovectorize_vector_sizes (void)\n    mangled names.  */\n typedef struct\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   const char *element_type_name;\n   const char *mangled_name;\n } aarch64_simd_mangle_map_entry;\n@@ -7848,7 +7848,7 @@ aarch64_vect_float_const_representable_p (rtx x)\n \n /* Return true for valid and false for invalid.  */\n bool\n-aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n+aarch64_simd_valid_immediate (rtx op, machine_mode mode, bool inverse,\n \t\t\t      struct simd_immediate_info *info)\n {\n #define CHECK(STRIDE, ELSIZE, CLASS, TEST, SHIFT, NEG)\t\\\n@@ -8031,7 +8031,7 @@ aarch64_simd_valid_immediate (rtx op, enum machine_mode mode, bool inverse,\n \n /* Check of immediate shift constants are within range.  */\n bool\n-aarch64_simd_shift_imm_p (rtx x, enum machine_mode mode, bool left)\n+aarch64_simd_shift_imm_p (rtx x, machine_mode mode, bool left)\n {\n   int bit_width = GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT;\n   if (left)\n@@ -8044,13 +8044,13 @@ aarch64_simd_shift_imm_p (rtx x, enum machine_mode mode, bool left)\n    are either the floating-point constant 0.0 or the\n    integer constant 0.  */\n bool\n-aarch64_simd_imm_zero_p (rtx x, enum machine_mode mode)\n+aarch64_simd_imm_zero_p (rtx x, machine_mode mode)\n {\n   return x == CONST0_RTX (mode);\n }\n \n bool\n-aarch64_simd_imm_scalar_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+aarch64_simd_imm_scalar_p (rtx x, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT imm = INTVAL (x);\n   int i;\n@@ -8069,7 +8069,7 @@ aarch64_simd_imm_scalar_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n bool\n aarch64_mov_operand_p (rtx x,\n \t\t       enum aarch64_symbol_context context,\n-\t\t       enum machine_mode mode)\n+\t\t       machine_mode mode)\n {\n   if (GET_CODE (x) == HIGH\n       && aarch64_valid_symref (XEXP (x, 0), GET_MODE (XEXP (x, 0))))\n@@ -8087,7 +8087,7 @@ aarch64_mov_operand_p (rtx x,\n \n /* Return a const_int vector of VAL.  */\n rtx\n-aarch64_simd_gen_const_vector_dup (enum machine_mode mode, int val)\n+aarch64_simd_gen_const_vector_dup (machine_mode mode, int val)\n {\n   int nunits = GET_MODE_NUNITS (mode);\n   rtvec v = rtvec_alloc (nunits);\n@@ -8102,9 +8102,9 @@ aarch64_simd_gen_const_vector_dup (enum machine_mode mode, int val)\n /* Check OP is a legal scalar immediate for the MOVI instruction.  */\n \n bool\n-aarch64_simd_scalar_immediate_valid_for_move (rtx op, enum machine_mode mode)\n+aarch64_simd_scalar_immediate_valid_for_move (rtx op, machine_mode mode)\n {\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n \n   gcc_assert (!VECTOR_MODE_P (mode));\n   vmode = aarch64_preferred_simd_mode (mode);\n@@ -8133,7 +8133,7 @@ High Mask:        { 0, 1 }                { 2, 3 }\n */\n \n rtx\n-aarch64_simd_vect_par_cnst_half (enum machine_mode mode, bool high)\n+aarch64_simd_vect_par_cnst_half (machine_mode mode, bool high)\n {\n   int nunits = GET_MODE_NUNITS (mode);\n   rtvec v = rtvec_alloc (nunits / 2);\n@@ -8161,7 +8161,7 @@ aarch64_simd_vect_par_cnst_half (enum machine_mode mode, bool high)\n    aarch64_simd_vect_par_cnst_half for more details.  */\n \n bool\n-aarch64_simd_check_vect_par_cnst_half (rtx op, enum machine_mode mode,\n+aarch64_simd_check_vect_par_cnst_half (rtx op, machine_mode mode,\n \t\t\t\t       bool high)\n {\n   rtx ideal = aarch64_simd_vect_par_cnst_half (mode, high);\n@@ -8203,7 +8203,7 @@ aarch64_simd_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n /* Emit code to place a AdvSIMD pair result in memory locations (with equal\n    registers).  */\n void\n-aarch64_simd_emit_pair_result_insn (enum machine_mode mode,\n+aarch64_simd_emit_pair_result_insn (machine_mode mode,\n \t\t\t    rtx (*intfn) (rtx, rtx, rtx), rtx destaddr,\n                             rtx op1)\n {\n@@ -8262,7 +8262,7 @@ aarch64_simd_disambiguate_copy (rtx *operands, rtx *dest,\n int\n aarch64_simd_attr_length_move (rtx_insn *insn)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   extract_insn_cached (insn);\n \n@@ -8315,8 +8315,8 @@ aarch64_simd_vector_alignment_reachable (const_tree type, bool is_packed)\n static rtx\n aarch64_simd_dup_constant (rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (vals);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (vals);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n   bool all_same = true;\n   rtx x;\n@@ -8350,7 +8350,7 @@ aarch64_simd_dup_constant (rtx vals)\n static rtx\n aarch64_simd_make_constant (rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (vals);\n+  machine_mode mode = GET_MODE (vals);\n   rtx const_dup;\n   rtx const_vec = NULL_RTX;\n   int n_elts = GET_MODE_NUNITS (mode);\n@@ -8396,8 +8396,8 @@ aarch64_simd_make_constant (rtx vals)\n void\n aarch64_expand_vector_init (rtx target, rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (target);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (target);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n   int n_var = 0, one_var = -1;\n   bool all_same = true;\n@@ -8469,7 +8469,7 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n }\n \n static unsigned HOST_WIDE_INT\n-aarch64_shift_truncation_mask (enum machine_mode mode)\n+aarch64_shift_truncation_mask (machine_mode mode)\n {\n   return\n     (aarch64_vector_mode_supported_p (mode)\n@@ -8576,7 +8576,7 @@ aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)\n /* Emit load exclusive.  */\n \n static void\n-aarch64_emit_load_exclusive (enum machine_mode mode, rtx rval,\n+aarch64_emit_load_exclusive (machine_mode mode, rtx rval,\n \t\t\t     rtx mem, rtx model_rtx)\n {\n   rtx (*gen) (rtx, rtx, rtx);\n@@ -8597,7 +8597,7 @@ aarch64_emit_load_exclusive (enum machine_mode mode, rtx rval,\n /* Emit store exclusive.  */\n \n static void\n-aarch64_emit_store_exclusive (enum machine_mode mode, rtx bval,\n+aarch64_emit_store_exclusive (machine_mode mode, rtx bval,\n \t\t\t      rtx rval, rtx mem, rtx model_rtx)\n {\n   rtx (*gen) (rtx, rtx, rtx, rtx);\n@@ -8632,7 +8632,7 @@ void\n aarch64_expand_compare_and_swap (rtx operands[])\n {\n   rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n-  enum machine_mode mode, cmp_mode;\n+  machine_mode mode, cmp_mode;\n   rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n   bval = operands[0];\n@@ -8702,7 +8702,7 @@ void\n aarch64_split_compare_and_swap (rtx operands[])\n {\n   rtx rval, mem, oldval, newval, scratch;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool is_weak;\n   rtx_code_label *label1, *label2;\n   rtx x, cond;\n@@ -8756,8 +8756,8 @@ void\n aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \t\t     rtx value, rtx model_rtx, rtx cond)\n {\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum machine_mode wmode = (mode == DImode ? DImode : SImode);\n+  machine_mode mode = GET_MODE (mem);\n+  machine_mode wmode = (mode == DImode ? DImode : SImode);\n   rtx_code_label *label;\n   rtx x;\n \n@@ -8841,7 +8841,7 @@ aarch64_start_file (void)\n }\n \n /* Target hook for c_mode_for_suffix.  */\n-static enum machine_mode\n+static machine_mode\n aarch64_c_mode_for_suffix (char suffix)\n {\n   if (suffix == 'q')\n@@ -8943,7 +8943,7 @@ aarch64_float_const_representable_p (rtx x)\n \n char*\n aarch64_output_simd_mov_immediate (rtx const_vector,\n-\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   machine_mode mode,\n \t\t\t\t   unsigned width)\n {\n   bool is_valid;\n@@ -9006,9 +9006,9 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n \n char*\n aarch64_output_scalar_simd_mov_immediate (rtx immediate,\n-\t\t\t\t\t  enum machine_mode mode)\n+\t\t\t\t\t  machine_mode mode)\n {\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n \n   gcc_assert (!VECTOR_MODE_P (mode));\n   vmode = aarch64_simd_container_mode (mode, 64);\n@@ -9024,7 +9024,7 @@ aarch64_split_combinev16qi (rtx operands[3])\n   unsigned int dest = REGNO (operands[0]);\n   unsigned int src1 = REGNO (operands[1]);\n   unsigned int src2 = REGNO (operands[2]);\n-  enum machine_mode halfmode = GET_MODE (operands[1]);\n+  machine_mode halfmode = GET_MODE (operands[1]);\n   unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n   rtx destlo, desthi;\n \n@@ -9076,7 +9076,7 @@ struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n   unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n   unsigned char nelt;\n   bool one_vector_p;\n   bool testing_p;\n@@ -9087,7 +9087,7 @@ struct expand_vec_perm_d\n static void\n aarch64_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   bool one_vector_p = rtx_equal_p (op0, op1);\n \n   gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n@@ -9132,7 +9132,7 @@ aarch64_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n void\n aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   unsigned int nelt = GET_MODE_NUNITS (vmode);\n   bool one_vector_p = rtx_equal_p (op0, op1);\n   rtx mask;\n@@ -9163,7 +9163,7 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n   unsigned int i, odd, mask, nelt = d->nelt;\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n     return false;\n@@ -9247,7 +9247,7 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n   unsigned int i, odd, mask, nelt = d->nelt;\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n     return false;\n@@ -9330,7 +9330,7 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n   unsigned int i, high, mask, nelt = d->nelt;\n   rtx out, in0, in1, x;\n   rtx (*gen) (rtx, rtx, rtx);\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n     return false;\n@@ -9555,7 +9555,7 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)\n   rtx (*gen) (rtx, rtx, rtx);\n   rtx out = d->target;\n   rtx in0;\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   unsigned int i, elt, nelt = d->nelt;\n   rtx lane;\n \n@@ -9598,7 +9598,7 @@ static bool\n aarch64_evpc_tbl (struct expand_vec_perm_d *d)\n {\n   rtx rperm[MAX_VECT_LEN], sel;\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   unsigned int i, nelt = d->nelt;\n \n   if (d->testing_p)\n@@ -9723,7 +9723,7 @@ aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n }\n \n static bool\n-aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t     const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n@@ -9766,8 +9766,8 @@ aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n \n /* Implement target hook CANNOT_CHANGE_MODE_CLASS.  */\n bool\n-aarch64_cannot_change_mode_class (enum machine_mode from,\n-\t\t\t\t  enum machine_mode to,\n+aarch64_cannot_change_mode_class (machine_mode from,\n+\t\t\t\t  machine_mode to,\n \t\t\t\t  enum reg_class rclass)\n {\n   /* Full-reg subregs are allowed on general regs or any class if they are\n@@ -9815,7 +9815,7 @@ aarch64_cannot_change_mode_class (enum machine_mode from,\n /* Implement MODES_TIEABLE_P.  */\n \n bool\n-aarch64_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+aarch64_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2))\n     return true;\n@@ -9859,7 +9859,7 @@ aarch64_progress_pointer (rtx pointer)\n \n static void\n aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,\n-\t\t\t\t\t      enum machine_mode mode)\n+\t\t\t\t\t      machine_mode mode)\n {\n   rtx reg = gen_reg_rtx (mode);\n "}, {"sha": "5fca0782b6687277d4b549e415e88e7042113c4d", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -604,14 +604,14 @@ enum arm_pcs\n \n \n \n-/* We can't use enum machine_mode inside a generator file because it\n+/* We can't use machine_mode inside a generator file because it\n    hasn't been created yet; we shouldn't be using any code that\n    needs the real definition though, so this ought to be safe.  */\n #ifdef GENERATOR_FILE\n #define MACHMODE int\n #else\n #include \"insn-modes.h\"\n-#define MACHMODE enum machine_mode\n+#define MACHMODE machine_mode\n #endif\n \n "}, {"sha": "17570ba026b45df097f8838751eed86d7ce03609", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -3831,7 +3831,7 @@\n \t\t(match_operand 2 \"aarch64_valid_symref\" \"S\")))]\n   \"\"\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   emit_insn ((mode == DImode\n \t      ? gen_add_losym_di\n@@ -3942,7 +3942,7 @@\n                    UNSPEC_GOTSMALLTLS))]\n   \"\"\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   emit_insn ((mode == DImode\n \t      ? gen_tlsle_small_di\n \t      : gen_tlsle_small_si) (operands[0],\n@@ -4001,7 +4001,7 @@\n    (match_operand 1 \"memory_operand\")]\n   \"\"\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   emit_insn ((mode == DImode\n \t      ? gen_stack_protect_set_di\n@@ -4026,7 +4026,7 @@\n   \"\"\n {\n   rtx result;\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   result = gen_reg_rtx(mode);\n "}, {"sha": "8ce9c297d7196a91bd8f1f87051f6e583ddddcbd", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -30,8 +30,8 @@ extern void alpha_expand_prologue (void);\n extern void alpha_expand_epilogue (void);\n extern void alpha_output_filename (FILE *, const char *);\n \n-extern bool alpha_legitimate_constant_p (enum machine_mode, rtx);\n-extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n+extern bool alpha_legitimate_constant_p (machine_mode, rtx);\n+extern rtx alpha_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t    int, int, int);\n \n extern rtx split_small_symbolic_operand (rtx);\n@@ -42,13 +42,13 @@ extern rtx get_unaligned_offset (rtx, HOST_WIDE_INT);\n extern enum reg_class alpha_preferred_reload_class (rtx, enum reg_class);\n \n extern void alpha_set_memflags (rtx, rtx);\n-extern bool alpha_split_const_mov (enum machine_mode, rtx *);\n-extern bool alpha_expand_mov (enum machine_mode, rtx *);\n-extern bool alpha_expand_mov_nobwx (enum machine_mode, rtx *);\n-extern void alpha_expand_movmisalign (enum machine_mode, rtx *);\n+extern bool alpha_split_const_mov (machine_mode, rtx *);\n+extern bool alpha_expand_mov (machine_mode, rtx *);\n+extern bool alpha_expand_mov_nobwx (machine_mode, rtx *);\n+extern void alpha_expand_movmisalign (machine_mode, rtx *);\n extern void alpha_emit_floatuns (rtx[]);\n-extern rtx alpha_emit_conditional_move (rtx, enum machine_mode);\n-extern void alpha_split_tmode_pair (rtx[], enum machine_mode, bool);\n+extern rtx alpha_emit_conditional_move (rtx, machine_mode);\n+extern void alpha_split_tmode_pair (rtx[], machine_mode, bool);\n extern void alpha_split_tfmode_frobsign (rtx[], rtx (*)(rtx, rtx, rtx));\n extern void alpha_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, int);\n@@ -58,7 +58,7 @@ extern int alpha_expand_block_move (rtx []);\n extern int alpha_expand_block_clear (rtx []);\n extern rtx alpha_expand_zap_mask (HOST_WIDE_INT);\n extern void alpha_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n-\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t       machine_mode,\n \t\t\t\t\t       rtx, rtx, rtx);\n extern void alpha_expand_builtin_establish_vms_condition_handler (rtx, rtx);\n extern void alpha_expand_builtin_revert_vms_condition_handler (rtx);\n@@ -70,20 +70,20 @@ extern void print_operand_address (FILE *, rtx);\n extern void alpha_initialize_trampoline (rtx, rtx, rtx, int, int, int);\n \n extern rtx alpha_va_arg (tree, tree);\n-extern rtx function_value (const_tree, const_tree, enum machine_mode);\n+extern rtx function_value (const_tree, const_tree, machine_mode);\n \n extern void alpha_start_function (FILE *, const char *, tree);\n extern void alpha_end_function (FILE *, const char *, tree);\n \n extern bool alpha_find_lo_sum_using_gp (rtx);\n \n #ifdef REAL_VALUE_TYPE\n-extern int check_float_value (enum machine_mode, REAL_VALUE_TYPE *, int);\n+extern int check_float_value (machine_mode, REAL_VALUE_TYPE *, int);\n #endif\n \n #ifdef RTX_CODE\n-extern void alpha_emit_conditional_branch (rtx[], enum machine_mode);\n-extern bool alpha_emit_setcc (rtx[], enum machine_mode);\n+extern void alpha_emit_conditional_branch (rtx[], machine_mode);\n+extern bool alpha_emit_setcc (rtx[], machine_mode);\n extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n@@ -100,7 +100,7 @@ extern void alpha_split_atomic_exchange_12 (rtx op[]);\n extern rtx alpha_use_linkage (rtx, bool, bool);\n \n #if TARGET_ABI_OPEN_VMS\n-extern enum avms_arg_type alpha_arg_type (enum machine_mode);\n+extern enum avms_arg_type alpha_arg_type (machine_mode);\n extern rtx alpha_arg_info_reg_val (CUMULATIVE_ARGS);\n extern void avms_asm_output_external (FILE *, tree, const char *);\n extern void vms_output_aligned_decl_common (FILE *, tree, const char *,"}, {"sha": "0c71965a2debca7f1ca96053171bba4915749860", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -229,7 +229,7 @@ static void alpha_align_insns (void);\n \n #if TARGET_ABI_OPEN_VMS\n static void alpha_write_linkage (FILE *, const char *);\n-static bool vms_valid_pointer_mode (enum machine_mode);\n+static bool vms_valid_pointer_mode (machine_mode);\n #else\n #define vms_patch_builtins()  gcc_unreachable()\n #endif\n@@ -718,7 +718,7 @@ resolve_reload_operand (rtx op)\n    indicates only DFmode.  */\n \n static bool\n-alpha_scalar_mode_supported_p (enum machine_mode mode)\n+alpha_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -747,7 +747,7 @@ alpha_scalar_mode_supported_p (enum machine_mode mode)\n    or when expand_vector_operations can do something useful.  */\n \n static bool\n-alpha_vector_mode_supported_p (enum machine_mode mode)\n+alpha_vector_mode_supported_p (machine_mode mode)\n {\n   return mode == V8QImode || mode == V4HImode || mode == V2SImode;\n }\n@@ -842,7 +842,7 @@ alpha_in_small_data_p (const_tree exp)\n \n #if TARGET_ABI_OPEN_VMS\n static bool\n-vms_valid_pointer_mode (enum machine_mode mode)\n+vms_valid_pointer_mode (machine_mode mode)\n {\n   return (mode == SImode || mode == DImode);\n }\n@@ -877,7 +877,7 @@ alpha_linkage_symbol_p (const char *symname)\n    low-order three bits; this is an \"unaligned\" access.  */\n \n static bool\n-alpha_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+alpha_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   /* If this is an ldq_u type address, discard the outer AND.  */\n   if (mode == DImode\n@@ -988,7 +988,7 @@ get_tls_get_addr (void)\n    to be legitimate.  If we find one, return the new, valid address.  */\n \n static rtx\n-alpha_legitimize_address_1 (rtx x, rtx scratch, enum machine_mode mode)\n+alpha_legitimize_address_1 (rtx x, rtx scratch, machine_mode mode)\n {\n   HOST_WIDE_INT addend;\n \n@@ -1188,7 +1188,7 @@ alpha_legitimize_address_1 (rtx x, rtx scratch, enum machine_mode mode)\n \n static rtx\n alpha_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode)\n+\t\t\t  machine_mode mode)\n {\n   rtx new_x = alpha_legitimize_address_1 (x, NULL_RTX, mode);\n   return new_x ? new_x : x;\n@@ -1210,7 +1210,7 @@ alpha_mode_dependent_address_p (const_rtx addr,\n    should never be spilling symbolic operands to the constant pool, ever.  */\n \n static bool\n-alpha_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+alpha_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   return code == SYMBOL_REF || code == LABEL_REF || code == CONST;\n@@ -1301,7 +1301,7 @@ alpha_cannot_copy_insn_p (rtx_insn *insn)\n \n rtx\n alpha_legitimize_reload_address (rtx x,\n-\t\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t int opnum, int type,\n \t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -1360,7 +1360,7 @@ static bool\n alpha_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \t\t bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   const struct alpha_rtx_cost_data *cost_data;\n \n@@ -1645,7 +1645,7 @@ alpha_preferred_reload_class(rtx x, enum reg_class rclass)\n \n static reg_class_t\n alpha_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n-\t\t\tenum machine_mode mode, secondary_reload_info *sri)\n+\t\t\tmachine_mode mode, secondary_reload_info *sri)\n {\n   enum reg_class rclass = (enum reg_class) rclass_i;\n \n@@ -1725,15 +1725,15 @@ alpha_set_memflags (rtx seq, rtx ref)\n       gcc_unreachable ();\n }\n \f\n-static rtx alpha_emit_set_const (rtx, enum machine_mode, HOST_WIDE_INT,\n+static rtx alpha_emit_set_const (rtx, machine_mode, HOST_WIDE_INT,\n \t\t\t\t int, bool);\n \n /* Internal routine for alpha_emit_set_const to check for N or below insns.\n    If NO_OUTPUT is true, then we only check to see if N insns are possible,\n    and return pc_rtx if successful.  */\n \n static rtx\n-alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n+alpha_emit_set_const_1 (rtx target, machine_mode mode,\n \t\t\tHOST_WIDE_INT c, int n, bool no_output)\n {\n   HOST_WIDE_INT new_const;\n@@ -1981,10 +1981,10 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n    insns and emitted.  */\n \n static rtx\n-alpha_emit_set_const (rtx target, enum machine_mode mode,\n+alpha_emit_set_const (rtx target, machine_mode mode,\n \t\t      HOST_WIDE_INT c, int n, bool no_output)\n {\n-  enum machine_mode orig_mode = mode;\n+  machine_mode orig_mode = mode;\n   rtx orig_target = target;\n   rtx result = 0;\n   int i;\n@@ -2132,7 +2132,7 @@ alpha_extract_integer (rtx x, HOST_WIDE_INT *p0, HOST_WIDE_INT *p1)\n    take three or fewer instructions, and floating-point zero.  */\n \n bool\n-alpha_legitimate_constant_p (enum machine_mode mode, rtx x)\n+alpha_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   HOST_WIDE_INT i0, i1;\n \n@@ -2192,7 +2192,7 @@ alpha_legitimate_constant_p (enum machine_mode mode, rtx x)\n    instruction to load.  Emit that multi-part load.  */\n \n bool\n-alpha_split_const_mov (enum machine_mode mode, rtx *operands)\n+alpha_split_const_mov (machine_mode mode, rtx *operands)\n {\n   HOST_WIDE_INT i0, i1;\n   rtx temp = NULL_RTX;\n@@ -2219,7 +2219,7 @@ alpha_split_const_mov (enum machine_mode mode, rtx *operands)\n    We don't handle non-bwx subword loads here.  */\n \n bool\n-alpha_expand_mov (enum machine_mode mode, rtx *operands)\n+alpha_expand_mov (machine_mode mode, rtx *operands)\n {\n   rtx tmp;\n \n@@ -2274,7 +2274,7 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n    return true if all work is done.  */\n \n bool\n-alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n+alpha_expand_mov_nobwx (machine_mode mode, rtx *operands)\n {\n   rtx seq;\n \n@@ -2396,7 +2396,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n    that is not naturally aligned.  Emit instructions to load it.  */\n \n void\n-alpha_expand_movmisalign (enum machine_mode mode, rtx *operands)\n+alpha_expand_movmisalign (machine_mode mode, rtx *operands)\n {\n   /* Honor misaligned loads, for those we promised to do so.  */\n   if (MEM_P (operands[1]))\n@@ -2476,7 +2476,7 @@ void\n alpha_emit_floatuns (rtx operands[2])\n {\n   rtx neglab, donelab, i0, i1, f0, in, out;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   out = operands[0];\n   in = force_reg (DImode, operands[1]);\n@@ -2507,10 +2507,10 @@ alpha_emit_floatuns (rtx operands[2])\n /* Generate the comparison for a conditional branch.  */\n \n void\n-alpha_emit_conditional_branch (rtx operands[], enum machine_mode cmp_mode)\n+alpha_emit_conditional_branch (rtx operands[], machine_mode cmp_mode)\n {\n   enum rtx_code cmp_code, branch_code;\n-  enum machine_mode branch_mode = VOIDmode;\n+  machine_mode branch_mode = VOIDmode;\n   enum rtx_code code = GET_CODE (operands[0]);\n   rtx op0 = operands[1], op1 = operands[2];\n   rtx tem;\n@@ -2640,7 +2640,7 @@ alpha_emit_conditional_branch (rtx operands[], enum machine_mode cmp_mode)\n    valid.  Return the final comparison, or NULL if we can't work.  */\n \n bool\n-alpha_emit_setcc (rtx operands[], enum machine_mode cmp_mode)\n+alpha_emit_setcc (rtx operands[], machine_mode cmp_mode)\n {\n   enum rtx_code cmp_code;\n   enum rtx_code code = GET_CODE (operands[1]);\n@@ -2729,15 +2729,15 @@ alpha_emit_setcc (rtx operands[], enum machine_mode cmp_mode)\n    the conditional move).  */\n \n rtx\n-alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n+alpha_emit_conditional_move (rtx cmp, machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (cmp);\n   enum rtx_code cmov_code = NE;\n   rtx op0 = XEXP (cmp, 0);\n   rtx op1 = XEXP (cmp, 1);\n-  enum machine_mode cmp_mode\n+  machine_mode cmp_mode\n     = (GET_MODE (op0) == VOIDmode ? DImode : GET_MODE (op0));\n-  enum machine_mode cmov_mode = VOIDmode;\n+  machine_mode cmov_mode = VOIDmode;\n   int local_fast_math = flag_unsafe_math_optimizations;\n   rtx tem;\n \n@@ -2892,7 +2892,7 @@ alpha_split_conditional_move (enum rtx_code code, rtx dest, rtx cond,\n \t\t\t      rtx t_rtx, rtx f_rtx)\n {\n   HOST_WIDE_INT t, f, diff;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx target, subtarget, tmp;\n \n   mode = GET_MODE (dest);\n@@ -3274,7 +3274,7 @@ alpha_emit_xfloating_cvt (enum rtx_code orig_code, rtx operands[])\n    This is used by *movtf_internal and *movti_internal.  */\n   \n void\n-alpha_split_tmode_pair (rtx operands[4], enum machine_mode mode,\n+alpha_split_tmode_pair (rtx operands[4], machine_mode mode,\n \t\t\tbool fixup_overlap)\n {\n   switch (GET_CODE (operands[1]))\n@@ -3399,7 +3399,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \t\t\t     HOST_WIDE_INT ofs, int sign)\n {\n   rtx meml, memh, addr, extl, exth, tmp, mema;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (TARGET_BWX && size == 2)\n     {\n@@ -4082,7 +4082,7 @@ alpha_expand_block_clear (rtx operands[])\n \t       && align >= 32\n \t       && !(alignofs == 4 && bytes >= 4))\n \t{\n-\t  enum machine_mode mode = (align >= 64 ? DImode : SImode);\n+\t  machine_mode mode = (align >= 64 ? DImode : SImode);\n \t  int inv_alignofs = (align >= 64 ? 8 : 4) - alignofs;\n \t  rtx mem, tmp;\n \t  HOST_WIDE_INT mask;\n@@ -4353,7 +4353,7 @@ alpha_expand_zap_mask (HOST_WIDE_INT value)\n \n void\n alpha_expand_builtin_vector_binop (rtx (*gen) (rtx, rtx, rtx),\n-\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   machine_mode mode,\n \t\t\t\t   rtx op0, rtx op1, rtx op2)\n {\n   op0 = gen_lowpart (mode, op0);\n@@ -4389,7 +4389,7 @@ emit_unlikely_jump (rtx cond, rtx label)\n    instruction in MODE.  */\n \n static void\n-emit_load_locked (enum machine_mode mode, rtx reg, rtx mem)\n+emit_load_locked (machine_mode mode, rtx reg, rtx mem)\n {\n   rtx (*fn) (rtx, rtx) = NULL;\n   if (mode == SImode)\n@@ -4403,7 +4403,7 @@ emit_load_locked (enum machine_mode mode, rtx reg, rtx mem)\n    instruction in MODE.  */\n \n static void\n-emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n+emit_store_conditional (machine_mode mode, rtx res, rtx mem, rtx val)\n {\n   rtx (*fn) (rtx, rtx, rtx) = NULL;\n   if (mode == SImode)\n@@ -4434,7 +4434,7 @@ alpha_post_atomic_barrier (enum memmodel model)\n    instruction in MODE.  */\n \n static rtx\n-emit_insxl (enum machine_mode mode, rtx op1, rtx op2)\n+emit_insxl (machine_mode mode, rtx op1, rtx op2)\n {\n   rtx ret = gen_reg_rtx (DImode);\n   rtx (*fn) (rtx, rtx, rtx);\n@@ -4473,7 +4473,7 @@ void\n alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val, rtx before,\n \t\t       rtx after, rtx scratch, enum memmodel model)\n {\n-  enum machine_mode mode = GET_MODE (mem);\n+  machine_mode mode = GET_MODE (mem);\n   rtx label, x, cond = gen_rtx_REG (DImode, REGNO (scratch));\n \n   alpha_pre_atomic_barrier (model);\n@@ -4515,7 +4515,7 @@ alpha_split_compare_and_swap (rtx operands[])\n   rtx cond, retval, mem, oldval, newval;\n   bool is_weak;\n   enum memmodel mod_s, mod_f;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx label1, label2, x;\n \n   cond = operands[0];\n@@ -4576,7 +4576,7 @@ void\n alpha_expand_compare_and_swap_12 (rtx operands[])\n {\n   rtx cond, dst, mem, oldval, newval, is_weak, mod_s, mod_f;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx addr, align, wdst;\n   rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n@@ -4617,7 +4617,7 @@ void\n alpha_split_compare_and_swap_12 (rtx operands[])\n {\n   rtx cond, dest, orig_mem, oldval, newval, align, scratch;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool is_weak;\n   enum memmodel mod_s, mod_f;\n   rtx label1, label2, mem, addr, width, mask, x;\n@@ -4698,7 +4698,7 @@ alpha_split_atomic_exchange (rtx operands[])\n {\n   rtx retval, mem, val, scratch;\n   enum memmodel model;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx label, x, cond;\n \n   retval = operands[0];\n@@ -4728,7 +4728,7 @@ void\n alpha_expand_atomic_exchange_12 (rtx operands[])\n {\n   rtx dst, mem, val, model;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx addr, align, wdst;\n   rtx (*gen) (rtx, rtx, rtx, rtx, rtx);\n \n@@ -4764,7 +4764,7 @@ alpha_split_atomic_exchange_12 (rtx operands[])\n {\n   rtx dest, orig_mem, addr, val, align, scratch;\n   rtx label, mem, width, mask, x;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum memmodel model;\n \n   dest = operands[0];\n@@ -5662,7 +5662,7 @@ alpha_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    and the rest are pushed.  */\n \n static rtx\n-alpha_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+alpha_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -5724,7 +5724,7 @@ alpha_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-alpha_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+alpha_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -5742,7 +5742,7 @@ alpha_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n static int\n alpha_arg_partial_bytes (cumulative_args_t cum_v,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n@@ -5769,7 +5769,7 @@ alpha_arg_partial_bytes (cumulative_args_t cum_v,\n static bool\n alpha_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = VOIDmode;\n+  machine_mode mode = VOIDmode;\n   int size;\n \n   if (type)\n@@ -5823,7 +5823,7 @@ alpha_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n \n static bool\n alpha_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode,\n+\t\t\t machine_mode mode,\n \t\t\t const_tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n@@ -5840,7 +5840,7 @@ alpha_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n \n rtx\n function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n-\t\tenum machine_mode mode)\n+\t\tmachine_mode mode)\n {\n   unsigned int regnum, dummy ATTRIBUTE_UNUSED;\n   enum mode_class mclass;\n@@ -5871,7 +5871,7 @@ function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n \n     case MODE_COMPLEX_FLOAT:\n       {\n-\tenum machine_mode cmode = GET_MODE_INNER (mode);\n+\tmachine_mode cmode = GET_MODE_INNER (mode);\n \n \treturn gen_rtx_PARALLEL\n \t  (VOIDmode,\n@@ -6160,7 +6160,7 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n    variable number of arguments.  */\n \n static void\n-alpha_setup_incoming_varargs (cumulative_args_t pcum, enum machine_mode mode,\n+alpha_setup_incoming_varargs (cumulative_args_t pcum, machine_mode mode,\n \t\t\t      tree type, int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (pcum);\n@@ -6683,7 +6683,7 @@ alpha_init_builtins (void)\n static rtx\n alpha_expand_builtin (tree exp, rtx target,\n \t\t      rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      int ignore ATTRIBUTE_UNUSED)\n {\n #define MAX_ARGS 2\n@@ -6726,7 +6726,7 @@ alpha_expand_builtin (tree exp, rtx target,\n \n   if (nonvoid)\n     {\n-      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+      machine_mode tmode = insn_data[icode].operand[0].mode;\n       if (!target\n \t  || GET_MODE (target) != tmode\n \t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n@@ -9551,7 +9551,7 @@ alpha_elf_reloc_rw_mask (void)\n    honor small data.  */\n \n static section *\n-alpha_elf_select_rtx_section (enum machine_mode mode, rtx x,\n+alpha_elf_select_rtx_section (machine_mode mode, rtx x,\n \t\t\t      unsigned HOST_WIDE_INT align)\n {\n   if (TARGET_SMALL_DATA && GET_MODE_SIZE (mode) <= g_switch_value)\n@@ -9599,7 +9599,7 @@ struct GTY(()) alpha_links\n /* Return the VMS argument type corresponding to MODE.  */\n \n enum avms_arg_type\n-alpha_arg_type (enum machine_mode mode)\n+alpha_arg_type (machine_mode mode)\n {\n   switch (mode)\n     {"}, {"sha": "bbf0d552e1302403453bada6998e36d7cf94393c", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -19,27 +19,27 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef RTX_CODE\n \n-extern enum machine_mode arc_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern machine_mode arc_select_cc_mode (enum rtx_code, rtx, rtx);\n \n /* Define the function that build the compare insn for scc, bcc and mov*cc.  */\n-extern struct rtx_def *gen_compare_reg (rtx, enum machine_mode);\n+extern struct rtx_def *gen_compare_reg (rtx, machine_mode);\n \n /* Declarations for various fns used in the .md file.  */\n extern void arc_output_function_epilogue (FILE *, HOST_WIDE_INT, int);\n extern const char *output_shift (rtx *);\n-extern bool compact_sda_memory_operand (rtx op,enum machine_mode  mode);\n+extern bool compact_sda_memory_operand (rtx op,machine_mode  mode);\n extern bool arc_double_limm_p (rtx);\n extern void arc_print_operand (FILE *, rtx, int);\n extern void arc_print_operand_address (FILE *, rtx);\n extern void arc_final_prescan_insn (rtx_insn *, rtx *, int);\n extern void arc_set_default_type_attributes(tree type);\n extern const char *arc_output_libcall (const char *);\n extern bool prepare_extend_operands (rtx *operands, enum rtx_code code,\n-\t\t\t\t     enum machine_mode omode);\n+\t\t\t\t     machine_mode omode);\n extern int arc_output_addsi (rtx *operands, bool, bool);\n extern int arc_output_commutative_cond_exec (rtx *operands, bool);\n extern bool arc_expand_movmem (rtx *operands);\n-extern bool prepare_move_operands (rtx *operands, enum machine_mode mode);\n+extern bool prepare_move_operands (rtx *operands, machine_mode mode);\n extern void emit_shift (enum rtx_code, rtx, rtx, rtx);\n #endif /* RTX_CODE */\n \n@@ -61,21 +61,21 @@ void arc_asm_output_aligned_decl_local (FILE *, tree, const char *,\n extern rtx arc_return_addr_rtx (int , rtx);\n extern bool check_if_valid_regno_const (rtx *, int);\n extern bool check_if_valid_sleep_operand (rtx *, int);\n-extern bool arc_legitimate_constant_p (enum machine_mode, rtx);\n+extern bool arc_legitimate_constant_p (machine_mode, rtx);\n extern bool arc_legitimate_pc_offset_p (rtx);\n extern bool arc_legitimate_pic_addr_p (rtx);\n-extern void emit_pic_move (rtx *, enum machine_mode);\n+extern void emit_pic_move (rtx *, machine_mode);\n extern bool arc_raw_symbolic_reference_mentioned_p (rtx, bool);\n extern bool arc_legitimate_pic_operand_p (rtx);\n extern bool arc_is_longcall_p (rtx);\n extern bool arc_is_shortcall_p (rtx);\n extern bool arc_profile_call (rtx callee);\n extern bool valid_brcc_with_delay_p (rtx *);\n-extern bool small_data_pattern (rtx , enum machine_mode);\n+extern bool small_data_pattern (rtx , machine_mode);\n extern rtx arc_rewrite_small_data (rtx);\n extern bool arc_ccfsm_cond_exec_p (void);\n struct secondary_reload_info;\n-extern int arc_register_move_cost (enum machine_mode, enum reg_class,\n+extern int arc_register_move_cost (machine_mode, enum reg_class,\n \t\t\t\t   enum reg_class);\n extern rtx disi_highpart (rtx);\n extern int arc_adjust_insn_length (rtx_insn *, int, bool);\n@@ -115,6 +115,6 @@ extern int arc_decl_pretend_args (tree decl);\n extern bool arc_short_comparison_p (rtx, int);\n extern bool arc_epilogue_uses (int regno);\n /* insn-attrtab.c doesn't include reload.h, which declares regno_clobbered_p. */\n-extern int regno_clobbered_p (unsigned int, rtx_insn *, enum machine_mode, int);\n+extern int regno_clobbered_p (unsigned int, rtx_insn *, machine_mode, int);\n extern int arc_return_slot_offset (void);\n-extern bool arc_legitimize_reload_address (rtx *, enum machine_mode, int, int);\n+extern bool arc_legitimize_reload_address (rtx *, machine_mode, int, int);"}, {"sha": "d04be019480f748be5c3770ce1f3eba6cd75f321", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -385,16 +385,16 @@ static void arc_file_start (void);\n static void arc_internal_label (FILE *, const char *, unsigned long);\n static void arc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n-static int arc_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n+static int arc_address_cost (rtx, machine_mode, addr_space_t, bool);\n static void arc_encode_section_info (tree decl, rtx rtl, int first);\n \n static void arc_init_builtins (void);\n-static rtx arc_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static rtx arc_expand_builtin (tree, rtx, rtx, machine_mode, int);\n \n static int branch_dest (rtx);\n \n static void  arc_output_pic_addr_const (FILE *,  rtx, int);\n-void emit_pic_move (rtx *, enum machine_mode);\n+void emit_pic_move (rtx *, machine_mode);\n bool arc_legitimate_pic_operand_p (rtx);\n static bool arc_function_ok_for_sibcall (tree, tree);\n static rtx arc_function_value (const_tree, const_tree, bool);\n@@ -405,7 +405,7 @@ static bool arc_in_small_data_p (const_tree);\n static void arc_init_reg_tables (void);\n static bool arc_return_in_memory (const_tree, const_tree);\n static void arc_init_simd_builtins (void);\n-static bool arc_vector_mode_supported_p (enum machine_mode);\n+static bool arc_vector_mode_supported_p (machine_mode);\n \n static bool arc_can_use_doloop_p (const widest_int &, const widest_int &,\n \t\t\t\t  unsigned int, bool);\n@@ -418,7 +418,7 @@ static bool arc_frame_pointer_required (void);\n /* Implements target hook vector_mode_supported_p.  */\n \n static bool\n-arc_vector_mode_supported_p (enum machine_mode mode)\n+arc_vector_mode_supported_p (machine_mode mode)\n {\n   if (!TARGET_SIMD_SET)\n     return false;\n@@ -438,9 +438,9 @@ static bool arc_can_follow_jump (const rtx_insn *follower,\n \t\t\t\t const rtx_insn *followee);\n \n static rtx frame_insn (rtx);\n-static void arc_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void arc_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n-static rtx arc_legitimize_address_0 (rtx, rtx, enum machine_mode mode);\n+static rtx arc_legitimize_address_0 (rtx, rtx, machine_mode mode);\n \n static void arc_finalize_pic (void);\n \n@@ -602,7 +602,7 @@ arc_sched_adjust_priority (rtx_insn *insn, int priority)\n }\n \n static reg_class_t\n-arc_secondary_reload (bool in_p, rtx x, reg_class_t cl, enum machine_mode,\n+arc_secondary_reload (bool in_p, rtx x, reg_class_t cl, machine_mode,\n \t\t      secondary_reload_info *)\n {\n   if (cl == DOUBLE_REGS)\n@@ -996,10 +996,10 @@ arc_short_comparison_p (rtx comparison, int offset)\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n \n-enum machine_mode\n+machine_mode\n arc_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   rtx x1;\n \n   /* For an operation that sets the condition codes as a side-effect, the\n@@ -1150,7 +1150,7 @@ arc_init_reg_tables (void)\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n-      enum machine_mode m = (enum machine_mode) i;\n+      machine_mode m = (machine_mode) i;\n \n       switch (GET_MODE_CLASS (m))\n \t{\n@@ -1490,13 +1490,13 @@ arc_set_default_type_attributes (tree type ATTRIBUTE_UNUSED)\n    return the rtx for the cc reg in the proper mode.  */\n \n rtx\n-gen_compare_reg (rtx comparison, enum machine_mode omode)\n+gen_compare_reg (rtx comparison, machine_mode omode)\n {\n   enum rtx_code code = GET_CODE (comparison);\n   rtx x = XEXP (comparison, 0);\n   rtx y = XEXP (comparison, 1);\n   rtx tmp, cc_reg;\n-  enum machine_mode mode, cmode;\n+  machine_mode mode, cmode;\n \n \n   cmode = GET_MODE (x);\n@@ -1641,7 +1641,7 @@ arc_double_limm_p (rtx value)\n \n static void\n arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n-\t\t\t    enum machine_mode mode, tree type,\n+\t\t\t    machine_mode mode, tree type,\n \t\t\t    int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n@@ -1680,7 +1680,7 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n int\n-arc_address_cost (rtx addr, enum machine_mode, addr_space_t, bool speed)\n+arc_address_cost (rtx addr, machine_mode, addr_space_t, bool speed)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -2564,7 +2564,7 @@ output_shift (rtx *operands)\n {\n   /*  static int loopend_lab;*/\n   rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n+  machine_mode mode = GET_MODE (shift);\n   enum rtx_code code = GET_CODE (shift);\n   const char *shift_one;\n \n@@ -4712,7 +4712,7 @@ arc_output_pic_addr_const (FILE * file, rtx x, int code)\n /* Emit insns to move operands[1] into operands[0].  */\n \n void\n-emit_pic_move (rtx *operands, enum machine_mode)\n+emit_pic_move (rtx *operands, machine_mode)\n {\n   rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n \n@@ -4754,7 +4754,7 @@ emit_pic_move (rtx *operands, enum machine_mode)\n /* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n static int\n-arc_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+arc_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t       tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -4812,7 +4812,7 @@ arc_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n    and the rest are pushed.  */\n \n static rtx\n-arc_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+arc_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t  const_tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -4859,7 +4859,7 @@ arc_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    course function_arg_partial_nregs will come into play.  */\n \n static void\n-arc_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+arc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -4885,7 +4885,7 @@ arc_function_value (const_tree valtype,\n \t\t    const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n \t\t    bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = TYPE_MODE (valtype);\n+  machine_mode mode = TYPE_MODE (valtype);\n   int unsignedp ATTRIBUTE_UNUSED;\n \n   unsignedp = TYPE_UNSIGNED (valtype);\n@@ -4919,7 +4919,7 @@ arc_legitimate_pic_operand_p (rtx x)\n    satisfies CONSTANT_P.  */\n \n bool\n-arc_legitimate_constant_p (enum machine_mode, rtx x)\n+arc_legitimate_constant_p (machine_mode, rtx x)\n {\n   if (!flag_pic)\n     return true;\n@@ -4970,7 +4970,7 @@ arc_legitimate_constant_p (enum machine_mode, rtx x)\n }\n \n static bool\n-arc_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+arc_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   if (RTX_OK_FOR_BASE_P (x, strict))\n      return true;\n@@ -5026,7 +5026,7 @@ arc_mode_dependent_address_p (const_rtx addr, addr_space_t)\n /* Determine if it's legal to put X into the constant pool.  */\n \n static bool\n-arc_cannot_force_const_mem (enum machine_mode mode, rtx x)\n+arc_cannot_force_const_mem (machine_mode mode, rtx x)\n {\n   return !arc_legitimate_constant_p (mode, x);\n }\n@@ -5115,7 +5115,7 @@ arc_init_builtins (void)\n       arc_init_simd_builtins ();\n }\n \n-static rtx arc_expand_simd_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static rtx arc_expand_simd_builtin (tree, rtx, rtx, machine_mode, int);\n \n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -5127,7 +5127,7 @@ static rtx\n arc_expand_builtin (tree exp,\n \t\t    rtx target,\n \t\t    rtx subtarget,\n-\t\t    enum machine_mode mode,\n+\t\t    machine_mode mode,\n \t\t    int ignore)\n {\n   tree              fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -5137,8 +5137,8 @@ arc_expand_builtin (tree exp,\n   rtx               op1;\n   int               fcode = DECL_FUNCTION_CODE (fndecl);\n   int               icode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n+  machine_mode mode0;\n+  machine_mode mode1;\n \n   if (fcode > ARC_SIMD_BUILTIN_BEGIN && fcode < ARC_SIMD_BUILTIN_END)\n     return arc_expand_simd_builtin (exp, target, subtarget, mode, ignore);\n@@ -5705,7 +5705,7 @@ walk_stores (rtx x, void (*fun) (rtx, rtx, void *), void *data)\n \n static bool\n arc_pass_by_reference (cumulative_args_t ca_v ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       const_tree type,\n \t\t       bool named ATTRIBUTE_UNUSED)\n {\n@@ -6419,7 +6419,7 @@ small_data_pattern_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n    a PLUS.  */\n \n bool\n-small_data_pattern (rtx op, enum machine_mode)\n+small_data_pattern (rtx op, machine_mode)\n {\n   return (GET_CODE (op) != SEQUENCE\n \t  && for_each_rtx (&op, small_data_pattern_1, 0));\n@@ -6433,7 +6433,7 @@ small_data_pattern (rtx op, enum machine_mode)\n /* volatile cache option still to be handled.  */\n \n bool\n-compact_sda_memory_operand (rtx op, enum machine_mode mode)\n+compact_sda_memory_operand (rtx op, machine_mode mode)\n {\n   rtx addr;\n   int size;\n@@ -6837,7 +6837,7 @@ static rtx\n arc_expand_simd_builtin (tree exp,\n \t\t\t rtx target,\n \t\t\t rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t int ignore ATTRIBUTE_UNUSED)\n {\n   tree              fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -6854,11 +6854,11 @@ arc_expand_simd_builtin (tree exp,\n   unsigned int         i;\n   int               fcode = DECL_FUNCTION_CODE (fndecl);\n   int               icode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n-  enum machine_mode mode3;\n-  enum machine_mode mode4;\n+  machine_mode mode0;\n+  machine_mode mode1;\n+  machine_mode mode2;\n+  machine_mode mode3;\n+  machine_mode mode4;\n   const struct builtin_description * d;\n \n   for (i = 0, d = arc_simd_builtin_desc_list;\n@@ -7298,7 +7298,7 @@ arc_preserve_reload_p (rtx in)\n }\n \n int\n-arc_register_move_cost (enum machine_mode,\n+arc_register_move_cost (machine_mode,\n \t\t\tenum reg_class from_class, enum reg_class to_class)\n {\n   /* The ARC600 has no bypass for extension registers, hence a nop might be\n@@ -7545,7 +7545,7 @@ arc_expand_movmem (rtx *operands)\n   for (i = 0; size > 0; i ^= 1, size -= piece)\n     {\n       rtx tmp;\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       if (piece > size)\n \tpiece = size & -size;\n@@ -7576,7 +7576,7 @@ arc_expand_movmem (rtx *operands)\n    been emitted.  */\n \n bool\n-prepare_move_operands (rtx *operands, enum machine_mode mode)\n+prepare_move_operands (rtx *operands, machine_mode mode)\n {\n   /* We used to do this only for MODE_INT Modes, but addresses to floating\n      point variables may well be in the small data section.  */\n@@ -7664,7 +7664,7 @@ prepare_move_operands (rtx *operands, enum machine_mode mode)\n \n bool\n prepare_extend_operands (rtx *operands, enum rtx_code code,\n-\t\t\t enum machine_mode omode)\n+\t\t\t machine_mode omode)\n {\n   if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[1], Pmode))\n     {\n@@ -8187,7 +8187,7 @@ arc_get_ccfsm_cond (struct arc_ccfsm *statep, bool reverse)\n \n   gcc_assert (ARC_INVERSE_CONDITION_CODE (raw_cc) == statep->cc);\n \n-  enum machine_mode ccm = GET_MODE (XEXP (cond, 0));\n+  machine_mode ccm = GET_MODE (XEXP (cond, 0));\n   enum rtx_code code = reverse_condition (GET_CODE (cond));\n   if (code == UNKNOWN || ccm == CC_FP_GTmode || ccm == CC_FP_GEmode)\n     code = reverse_condition_maybe_unordered (GET_CODE (cond));\n@@ -8420,7 +8420,7 @@ arc_predicate_delay_insns (void)\n \tgcc_unreachable ();\n       if (reverse != !INSN_FROM_TARGET_P (dlay))\n \t{\n-\t  enum machine_mode ccm = GET_MODE (XEXP (cond, 0));\n+\t  machine_mode ccm = GET_MODE (XEXP (cond, 0));\n \t  enum rtx_code code = reverse_condition (GET_CODE (cond));\n \t  if (code == UNKNOWN || ccm == CC_FP_GTmode || ccm == CC_FP_GEmode)\n \t    code = reverse_condition_maybe_unordered (GET_CODE (cond));\n@@ -8484,7 +8484,7 @@ arc_write_ext_corereg (rtx insn)\n \n static rtx\n arc_legitimize_address_0 (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode)\n+\t\t\t  machine_mode mode)\n {\n   rtx addr, inner;\n \n@@ -8515,13 +8515,13 @@ arc_legitimize_address_0 (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     }\n   else if (GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_FUNCTION_P (addr))\n     x = force_reg (Pmode, x);\n-  if (memory_address_p ((enum machine_mode) mode, x))\n+  if (memory_address_p ((machine_mode) mode, x))\n      return x;\n   return NULL_RTX;\n }\n \n static rtx\n-arc_legitimize_address (rtx orig_x, rtx oldx, enum machine_mode mode)\n+arc_legitimize_address (rtx orig_x, rtx oldx, machine_mode mode)\n {\n   rtx new_x = arc_legitimize_address_0 (orig_x, oldx, mode);\n \n@@ -8975,7 +8975,7 @@ arc_process_double_reg_moves (rtx *operands)\n rtx\n arc_split_move (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   int i;\n   int swap = 0;\n   rtx xop[4];\n@@ -9310,13 +9310,13 @@ arc_register_priority (int r)\n }\n \n static reg_class_t\n-arc_spill_class (reg_class_t /* orig_class */, enum machine_mode)\n+arc_spill_class (reg_class_t /* orig_class */, machine_mode)\n {\n   return GENERAL_REGS;\n }\n \n bool\n-arc_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n+arc_legitimize_reload_address (rtx *p, machine_mode mode, int opnum,\n \t\t\t       int itype)\n {\n   rtx x = *p;"}, {"sha": "d40f5c3648aba6177232b7beaad3169e61c28194", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1057,7 +1057,7 @@ extern int arc_initial_elimination_offset(int from, int to);\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n-/*extern enum machine_mode arc_select_cc_mode ();*/\n+/*extern machine_mode arc_select_cc_mode ();*/\n #define SELECT_CC_MODE(OP, X, Y) \\\n arc_select_cc_mode (OP, X, Y)\n "}, {"sha": "f7e045bf61553d34595203e0d010f9668b82db9f", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -585,7 +585,7 @@\n (define_special_predicate \"cc_set_register\"\n   (match_code \"reg\")\n {\n-  enum machine_mode rmode = GET_MODE (op);\n+  machine_mode rmode = GET_MODE (op);\n \n   if (mode == VOIDmode)\n     {"}, {"sha": "264bf019e211fb8276c31e3484390850faa589cf", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -25,8 +25,8 @@\n \n extern int aarch_crypto_can_dual_issue (rtx_insn *, rtx_insn *);\n extern bool aarch_rev16_p (rtx);\n-extern bool aarch_rev16_shleft_mask_imm_p (rtx, enum machine_mode);\n-extern bool aarch_rev16_shright_mask_imm_p (rtx, enum machine_mode);\n+extern bool aarch_rev16_shleft_mask_imm_p (rtx, machine_mode);\n+extern bool aarch_rev16_shright_mask_imm_p (rtx, machine_mode);\n extern int arm_early_load_addr_dep (rtx, rtx);\n extern int arm_early_store_addr_dep (rtx, rtx);\n extern int arm_mac_accumulator_is_mul_result (rtx, rtx);"}, {"sha": "e4727cb15d609b5ce21abf899709cbe99989398a", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -193,7 +193,7 @@ arm_get_set_operands (rtx producer, rtx consumer,\n }\n \n bool\n-aarch_rev16_shright_mask_imm_p (rtx val, enum machine_mode mode)\n+aarch_rev16_shright_mask_imm_p (rtx val, machine_mode mode)\n {\n   return CONST_INT_P (val)\n          && INTVAL (val)\n@@ -202,7 +202,7 @@ aarch_rev16_shright_mask_imm_p (rtx val, enum machine_mode mode)\n }\n \n bool\n-aarch_rev16_shleft_mask_imm_p (rtx val, enum machine_mode mode)\n+aarch_rev16_shleft_mask_imm_p (rtx val, machine_mode mode)\n {\n   return CONST_INT_P (val)\n          && INTVAL (val)\n@@ -212,7 +212,7 @@ aarch_rev16_shleft_mask_imm_p (rtx val, enum machine_mode mode)\n \n \n static bool\n-aarch_rev16_p_1 (rtx lhs, rtx rhs, enum machine_mode mode)\n+aarch_rev16_p_1 (rtx lhs, rtx rhs, machine_mode mode)\n {\n   if (GET_CODE (lhs) == AND\n          && GET_CODE (XEXP (lhs, 0)) == ASHIFT"}, {"sha": "a37aa80e01748a62f55dd4df9348ab95eee9bbba", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -44,54 +44,54 @@ extern void arm_output_fn_unwind (FILE *, bool);\n   \n \n #ifdef RTX_CODE\n-extern bool arm_vector_mode_supported_p (enum machine_mode);\n-extern bool arm_small_register_classes_for_mode_p (enum machine_mode);\n-extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n-extern bool arm_modes_tieable_p (enum machine_mode, enum machine_mode);\n+extern bool arm_vector_mode_supported_p (machine_mode);\n+extern bool arm_small_register_classes_for_mode_p (machine_mode);\n+extern int arm_hard_regno_mode_ok (unsigned int, machine_mode);\n+extern bool arm_modes_tieable_p (machine_mode, machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);\n-extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,\n+extern int arm_split_constant (RTX_CODE, machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern int legitimate_pic_operand_p (rtx);\n-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx legitimize_pic_address (rtx, machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx, rtx);\n-extern bool arm_legitimate_address_p (enum machine_mode, rtx, bool);\n-extern int arm_legitimate_address_outer_p (enum machine_mode, rtx, RTX_CODE, int);\n-extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n-extern bool arm_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n+extern bool arm_legitimate_address_p (machine_mode, rtx, bool);\n+extern int arm_legitimate_address_outer_p (machine_mode, rtx, RTX_CODE, int);\n+extern int thumb_legitimate_offset_p (machine_mode, HOST_WIDE_INT);\n+extern bool arm_legitimize_reload_address (rtx *, machine_mode, int, int,\n \t\t\t\t\t   int);\n-extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n+extern rtx thumb_legitimize_reload_address (rtx *, machine_mode, int, int,\n \t\t\t\t\t    int);\n-extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n-extern bool ldm_stm_operation_p (rtx, bool, enum machine_mode mode,\n+extern int thumb1_legitimate_address_p (machine_mode, rtx, int);\n+extern bool ldm_stm_operation_p (rtx, bool, machine_mode mode,\n                                  bool, bool);\n extern int arm_const_double_rtx (rtx);\n extern int vfp3_const_double_rtx (rtx);\n-extern int neon_immediate_valid_for_move (rtx, enum machine_mode, rtx *, int *);\n-extern int neon_immediate_valid_for_logic (rtx, enum machine_mode, int, rtx *,\n+extern int neon_immediate_valid_for_move (rtx, machine_mode, rtx *, int *);\n+extern int neon_immediate_valid_for_logic (rtx, machine_mode, int, rtx *,\n \t\t\t\t\t   int *);\n-extern int neon_immediate_valid_for_shift (rtx, enum machine_mode, rtx *,\n+extern int neon_immediate_valid_for_shift (rtx, machine_mode, rtx *,\n \t\t\t\t\t   int *, bool);\n extern char *neon_output_logic_immediate (const char *, rtx *,\n-\t\t\t\t\t  enum machine_mode, int, int);\n+\t\t\t\t\t  machine_mode, int, int);\n extern char *neon_output_shift_immediate (const char *, char, rtx *,\n-\t\t\t\t\t  enum machine_mode, int, bool);\n-extern void neon_pairwise_reduce (rtx, rtx, enum machine_mode,\n+\t\t\t\t\t  machine_mode, int, bool);\n+extern void neon_pairwise_reduce (rtx, rtx, machine_mode,\n \t\t\t\t  rtx (*) (rtx, rtx, rtx));\n extern rtx neon_make_constant (rtx);\n extern tree arm_builtin_vectorized_function (tree, tree, tree);\n extern void neon_expand_vector_init (rtx, rtx);\n extern void neon_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n extern void neon_const_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n-extern HOST_WIDE_INT neon_element_bits (enum machine_mode);\n+extern HOST_WIDE_INT neon_element_bits (machine_mode);\n extern void neon_reinterpret (rtx, rtx);\n-extern void neon_emit_pair_result_insn (enum machine_mode,\n+extern void neon_emit_pair_result_insn (machine_mode,\n \t\t\t\t\trtx (*) (rtx, rtx, rtx, rtx),\n \t\t\t\t\trtx, rtx, rtx);\n extern void neon_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n extern void neon_split_vcombine (rtx op[3]);\n-extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n+extern enum reg_class coproc_secondary_reload_class (machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n \n@@ -115,8 +115,8 @@ extern bool operands_ok_ldrd_strd (rtx, rtx, rtx, HOST_WIDE_INT, bool, bool);\n extern bool gen_operands_ldrd_strd (rtx *, bool, bool, bool);\n extern int arm_gen_movmemqi (rtx *);\n extern bool gen_movmem_ldrd_strd (rtx *);\n-extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n-extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n+extern machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n+extern machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n \t\t\t\t\t\t       HOST_WIDE_INT);\n extern rtx arm_gen_compare_reg (RTX_CODE, rtx, rtx, rtx);\n extern rtx arm_gen_return_addr_mask (void);\n@@ -165,8 +165,8 @@ extern rtx arm_load_tp (rtx);\n \n #if defined TREE_CODE\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n-extern bool arm_pad_arg_upward (enum machine_mode, const_tree);\n-extern bool arm_pad_reg_upward (enum machine_mode, tree, int);\n+extern bool arm_pad_arg_upward (machine_mode, const_tree);\n+extern bool arm_pad_reg_upward (machine_mode, tree, int);\n #endif\n extern int arm_apply_result_size (void);\n \n@@ -297,7 +297,7 @@ extern bool arm_gen_setmem (rtx *);\n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n \n-extern bool arm_autoinc_modes_ok_p (enum machine_mode, enum arm_auto_incmodes);\n+extern bool arm_autoinc_modes_ok_p (machine_mode, enum arm_auto_incmodes);\n \n extern void arm_emit_eabi_attribute (const char *, int, int);\n "}, {"sha": "f4c4ebd4a2901c1025eb48b730033c65233489cc", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 203, "deletions": 203, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -96,20 +96,20 @@ struct four_ints\n /* Forward function declarations.  */\n static bool arm_const_not_ok_for_debug_p (rtx);\n static bool arm_lra_p (void);\n-static bool arm_needs_doubleword_align (enum machine_mode, const_tree);\n+static bool arm_needs_doubleword_align (machine_mode, const_tree);\n static int arm_compute_static_chain_stack_bytes (void);\n static arm_stack_offsets *arm_get_frame_offsets (void);\n static void arm_add_gc_roots (void);\n-static int arm_gen_constant (enum rtx_code, enum machine_mode, rtx,\n+static int arm_gen_constant (enum rtx_code, machine_mode, rtx,\n \t\t\t     HOST_WIDE_INT, rtx, rtx, int, int);\n static unsigned bit_count (unsigned long);\n static int arm_address_register_rtx_p (rtx, int);\n-static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n-static int thumb2_legitimate_index_p (enum machine_mode, rtx, int);\n-static int thumb1_base_register_rtx_p (rtx, enum machine_mode, int);\n-static rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n+static int arm_legitimate_index_p (machine_mode, rtx, RTX_CODE, int);\n+static int thumb2_legitimate_index_p (machine_mode, rtx, int);\n+static int thumb1_base_register_rtx_p (rtx, machine_mode, int);\n+static rtx arm_legitimize_address (rtx, rtx, machine_mode);\n static reg_class_t arm_preferred_reload_class (rtx, reg_class_t);\n-static rtx thumb_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx thumb_legitimize_address (rtx, rtx, machine_mode);\n inline static int thumb1_index_register_rtx_p (rtx, int);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n@@ -139,7 +139,7 @@ static int arm_barrier_cost (rtx);\n static Mfix *create_fix_barrier (Mfix *, HOST_WIDE_INT);\n static void push_minipool_barrier (rtx_insn *, HOST_WIDE_INT);\n static void push_minipool_fix (rtx_insn *, HOST_WIDE_INT, rtx *,\n-\t\t\t       enum machine_mode, rtx);\n+\t\t\t       machine_mode, rtx);\n static void arm_reorg (void);\n static void note_invalid_constants (rtx_insn *, HOST_WIDE_INT, int);\n static unsigned long arm_compute_save_reg0_reg12_mask (void);\n@@ -167,50 +167,50 @@ static int optimal_immediate_sequence_1 (enum rtx_code code,\n \t\t\t\t\t int i);\n static int arm_get_strip_length (int);\n static bool arm_function_ok_for_sibcall (tree, tree);\n-static enum machine_mode arm_promote_function_mode (const_tree,\n-\t\t\t\t\t\t    enum machine_mode, int *,\n+static machine_mode arm_promote_function_mode (const_tree,\n+\t\t\t\t\t\t    machine_mode, int *,\n \t\t\t\t\t\t    const_tree, int);\n static bool arm_return_in_memory (const_tree, const_tree);\n static rtx arm_function_value (const_tree, const_tree, bool);\n-static rtx arm_libcall_value_1 (enum machine_mode);\n-static rtx arm_libcall_value (enum machine_mode, const_rtx);\n+static rtx arm_libcall_value_1 (machine_mode);\n+static rtx arm_libcall_value (machine_mode, const_rtx);\n static bool arm_function_value_regno_p (const unsigned int);\n static void arm_internal_label (FILE *, const char *, unsigned long);\n static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n static bool arm_have_conditional_execution (void);\n-static bool arm_cannot_force_const_mem (enum machine_mode, rtx);\n-static bool arm_legitimate_constant_p (enum machine_mode, rtx);\n+static bool arm_cannot_force_const_mem (machine_mode, rtx);\n+static bool arm_legitimate_constant_p (machine_mode, rtx);\n static bool arm_rtx_costs_1 (rtx, enum rtx_code, int*, bool);\n static bool arm_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);\n static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_fastmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_9e_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_rtx_costs (rtx, int, int, int, int *, bool);\n-static int arm_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n-static int arm_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n-static int arm_memory_move_cost (enum machine_mode, reg_class_t, bool);\n+static int arm_address_cost (rtx, machine_mode, addr_space_t, bool);\n+static int arm_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n+static int arm_memory_move_cost (machine_mode, reg_class_t, bool);\n static void arm_init_builtins (void);\n static void arm_init_iwmmxt_builtins (void);\n-static rtx safe_vector_operand (rtx, enum machine_mode);\n+static rtx safe_vector_operand (rtx, machine_mode);\n static rtx arm_expand_binop_builtin (enum insn_code, tree, rtx);\n static rtx arm_expand_unop_builtin (enum insn_code, tree, rtx, int);\n-static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static rtx arm_expand_builtin (tree, rtx, rtx, machine_mode, int);\n static tree arm_builtin_decl (unsigned, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx_insn *emit_set_insn (rtx, rtx);\n static rtx emit_multi_reg_push (unsigned long, unsigned long);\n-static int arm_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static int arm_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t  tree, bool);\n-static rtx arm_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx arm_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n-static void arm_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void arm_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n-static unsigned int arm_function_arg_boundary (enum machine_mode, const_tree);\n-static rtx aapcs_allocate_return_reg (enum machine_mode, const_tree,\n+static unsigned int arm_function_arg_boundary (machine_mode, const_tree);\n+static rtx aapcs_allocate_return_reg (machine_mode, const_tree,\n \t\t\t\t      const_tree);\n-static rtx aapcs_libcall_value (enum machine_mode);\n+static rtx aapcs_libcall_value (machine_mode);\n static int aapcs_select_return_coproc (const_tree, const_tree);\n \n #ifdef OBJECT_FORMAT_ELF\n@@ -224,15 +224,15 @@ static void arm_encode_section_info (tree, rtx, int);\n static void arm_file_end (void);\n static void arm_file_start (void);\n \n-static void arm_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static void arm_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\ttree, int *, int);\n static bool arm_pass_by_reference (cumulative_args_t,\n-\t\t\t\t   enum machine_mode, const_tree, bool);\n+\t\t\t\t   machine_mode, const_tree, bool);\n static bool arm_promote_prototypes (const_tree);\n static bool arm_default_short_enums (void);\n static bool arm_align_anon_bitfield (void);\n static bool arm_return_in_msb (const_tree);\n-static bool arm_must_pass_in_stack (enum machine_mode, const_tree);\n+static bool arm_must_pass_in_stack (machine_mode, const_tree);\n static bool arm_return_in_memory (const_tree, const_tree);\n #if ARM_UNWIND_INFO\n static void arm_unwind_emit (FILE *, rtx_insn *);\n@@ -256,7 +256,7 @@ static tree arm_build_builtin_va_list (void);\n static void arm_expand_builtin_va_start (tree, rtx);\n static tree arm_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n static void arm_option_override (void);\n-static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n+static unsigned HOST_WIDE_INT arm_shift_truncation_mask (machine_mode);\n static bool arm_cannot_copy_insn_p (rtx_insn *);\n static int arm_issue_rate (void);\n static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n@@ -267,7 +267,7 @@ static const char *arm_invalid_parameter_type (const_tree t);\n static const char *arm_invalid_return_type (const_tree t);\n static tree arm_promoted_type (const_tree t);\n static tree arm_convert_to_type (tree type, tree expr);\n-static bool arm_scalar_mode_supported_p (enum machine_mode);\n+static bool arm_scalar_mode_supported_p (machine_mode);\n static bool arm_frame_pointer_required (void);\n static bool arm_can_eliminate (const int, const int);\n static void arm_asm_trampoline_template (FILE *);\n@@ -277,13 +277,13 @@ static rtx arm_pic_static_addr (rtx orig, rtx reg);\n static bool cortex_a9_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n static bool xscale_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n static bool fa726te_sched_adjust_cost (rtx_insn *, rtx, rtx_insn *, int *);\n-static bool arm_array_mode_supported_p (enum machine_mode,\n+static bool arm_array_mode_supported_p (machine_mode,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n-static enum machine_mode arm_preferred_simd_mode (enum machine_mode);\n+static machine_mode arm_preferred_simd_mode (machine_mode);\n static bool arm_class_likely_spilled_p (reg_class_t);\n static HOST_WIDE_INT arm_vector_alignment (const_tree type);\n static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);\n-static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,\n+static bool arm_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t     const_tree type,\n \t\t\t\t\t\t     int misalignment,\n \t\t\t\t\t\t     bool is_packed);\n@@ -294,7 +294,7 @@ static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n \n-static bool arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+static bool arm_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t     const unsigned char *sel);\n \n static int arm_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n@@ -907,7 +907,7 @@ bool arm_disable_literal_pool = false;\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference,\n    we must report the mode of the memory reference from\n    TARGET_PRINT_OPERAND to TARGET_PRINT_OPERAND_ADDRESS.  */\n-enum machine_mode output_memory_reference_mode;\n+machine_mode output_memory_reference_mode;\n \n /* The register number to be used for the PIC offset register.  */\n unsigned arm_pic_register = INVALID_REGNUM;\n@@ -2153,14 +2153,14 @@ bit_count (unsigned long value)\n \n typedef struct\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   const char *name;\n } arm_fixed_mode_set;\n \n /* A small helper for setting fixed-point library libfuncs.  */\n \n static void\n-arm_set_fixed_optab_libfunc (optab optable, enum machine_mode mode,\n+arm_set_fixed_optab_libfunc (optab optable, machine_mode mode,\n \t\t\t     const char *funcname, const char *modename,\n \t\t\t     int num_suffix)\n {\n@@ -2175,8 +2175,8 @@ arm_set_fixed_optab_libfunc (optab optable, enum machine_mode mode,\n }\n \n static void\n-arm_set_fixed_conv_libfunc (convert_optab optable, enum machine_mode to,\n-\t\t\t    enum machine_mode from, const char *funcname,\n+arm_set_fixed_conv_libfunc (convert_optab optable, machine_mode to,\n+\t\t\t    machine_mode from, const char *funcname,\n \t\t\t    const char *toname, const char *fromname)\n {\n   char buffer[50];\n@@ -3658,7 +3658,7 @@ const_ok_for_dimode_op (HOST_WIDE_INT i, enum rtx_code code)\n \n /* ??? Tweak this for thumb2.  */\n int\n-arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n+arm_split_constant (enum rtx_code code, machine_mode mode, rtx insn,\n \t\t    HOST_WIDE_INT val, rtx target, rtx source, int subtargets)\n {\n   rtx cond;\n@@ -3958,7 +3958,7 @@ emit_constant_insn (rtx cond, rtx pattern)\n    RTL generation.  */\n \n static int\n-arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n+arm_gen_constant (enum rtx_code code, machine_mode mode, rtx cond,\n \t\t  HOST_WIDE_INT val, rtx target, rtx source, int subtargets,\n \t\t  int generate)\n {\n@@ -4620,7 +4620,7 @@ static void\n arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\t     bool op0_preserve_value)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned HOST_WIDE_INT i, maxval;\n \n   mode = GET_MODE (*op0);\n@@ -4768,7 +4768,7 @@ static rtx\n arm_function_value(const_tree type, const_tree func,\n \t\t   bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsignedp ATTRIBUTE_UNUSED;\n   rtx r ATTRIBUTE_UNUSED;\n \n@@ -4900,7 +4900,7 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)\n }\n \n static rtx\n-arm_libcall_value_1 (enum machine_mode mode)\n+arm_libcall_value_1 (machine_mode mode)\n {\n   if (TARGET_AAPCS_BASED)\n     return aapcs_libcall_value (mode);\n@@ -4915,7 +4915,7 @@ arm_libcall_value_1 (enum machine_mode mode)\n    assuming the value has mode MODE.  */\n \n static rtx\n-arm_libcall_value (enum machine_mode mode, const_rtx libcall)\n+arm_libcall_value (machine_mode mode, const_rtx libcall)\n {\n   if (TARGET_AAPCS_BASED && arm_pcs_default != ARM_PCS_AAPCS\n       && GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -5223,9 +5223,9 @@ aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n    type that doesn't match a non-VOIDmode *MODEP is found, then return -1,\n    otherwise return the count in the sub-tree.  */\n static int\n-aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n+aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   HOST_WIDE_INT size;\n \n   switch (TREE_CODE (type))\n@@ -5416,10 +5416,10 @@ use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)\n    *COUNT to hold the number of such elements.  */\n static bool\n aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n-\t\t\t\t       enum machine_mode mode, const_tree type,\n-\t\t\t\t       enum machine_mode *base_mode, int *count)\n+\t\t\t\t       machine_mode mode, const_tree type,\n+\t\t\t\t       machine_mode *base_mode, int *count)\n {\n-  enum machine_mode new_mode = VOIDmode;\n+  machine_mode new_mode = VOIDmode;\n \n   /* If we have the type information, prefer that to working things\n      out from the mode.  */\n@@ -5457,10 +5457,10 @@ aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n \n static bool\n aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,\n-\t\t\t       enum machine_mode mode, const_tree type)\n+\t\t\t       machine_mode mode, const_tree type)\n {\n   int count ATTRIBUTE_UNUSED;\n-  enum machine_mode ag_mode ATTRIBUTE_UNUSED;\n+  machine_mode ag_mode ATTRIBUTE_UNUSED;\n \n   if (!use_vfp_abi (pcs_variant, false))\n     return false;\n@@ -5469,7 +5469,7 @@ aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,\n }\n \n static bool\n-aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, machine_mode mode,\n \t\t\t     const_tree type)\n {\n   if (!use_vfp_abi (pcum->pcs_variant, false))\n@@ -5481,7 +5481,7 @@ aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n }\n \n static bool\n-aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, machine_mode mode,\n \t\t    const_tree type  ATTRIBUTE_UNUSED)\n {\n   int shift = GET_MODE_SIZE (pcum->aapcs_vfp_rmode) / GET_MODE_SIZE (SFmode);\n@@ -5499,7 +5499,7 @@ aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \t    int i;\n \t    int rcount = pcum->aapcs_vfp_rcount;\n \t    int rshift = shift;\n-\t    enum machine_mode rmode = pcum->aapcs_vfp_rmode;\n+\t    machine_mode rmode = pcum->aapcs_vfp_rmode;\n \t    rtx par;\n \t    if (!TARGET_NEON)\n \t      {\n@@ -5535,7 +5535,7 @@ aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \n static rtx\n aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n-\t\t\t       enum machine_mode mode,\n+\t\t\t       machine_mode mode,\n \t\t\t       const_tree type ATTRIBUTE_UNUSED)\n {\n   if (!use_vfp_abi (pcs_variant, false))\n@@ -5544,7 +5544,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n   if (mode == BLKmode || (mode == TImode && !TARGET_NEON))\n     {\n       int count;\n-      enum machine_mode ag_mode;\n+      machine_mode ag_mode;\n       int i;\n       rtx par;\n       int shift;\n@@ -5580,7 +5580,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n \n static void\n aapcs_vfp_advance (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode  ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode  ATTRIBUTE_UNUSED,\n \t\t   const_tree type  ATTRIBUTE_UNUSED)\n {\n   pcum->aapcs_vfp_regs_free &= ~pcum->aapcs_vfp_reg_alloc;\n@@ -5613,25 +5613,25 @@ static struct\n      BLKmode) is a candidate for this co-processor's registers; this\n      function should ignore any position-dependent state in\n      CUMULATIVE_ARGS and only use call-type dependent information.  */\n-  bool (*is_call_candidate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+  bool (*is_call_candidate) (CUMULATIVE_ARGS *, machine_mode, const_tree);\n \n   /* Return true if the argument does get a co-processor register; it\n      should set aapcs_reg to an RTX of the register allocated as is\n      required for a return from FUNCTION_ARG.  */\n-  bool (*allocate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+  bool (*allocate) (CUMULATIVE_ARGS *, machine_mode, const_tree);\n \n   /* Return true if a result of mode MODE (or type TYPE if MODE is\n      BLKmode) is can be returned in this co-processor's registers.  */\n-  bool (*is_return_candidate) (enum arm_pcs, enum machine_mode, const_tree);\n+  bool (*is_return_candidate) (enum arm_pcs, machine_mode, const_tree);\n \n   /* Allocate and return an RTX element to hold the return type of a\n      call, this routine must not fail and will only be called if\n      is_return_candidate returned true with the same parameters.  */\n-  rtx (*allocate_return_reg) (enum arm_pcs, enum machine_mode, const_tree);\n+  rtx (*allocate_return_reg) (enum arm_pcs, machine_mode, const_tree);\n \n   /* Finish processing this argument and prepare to start processing\n      the next one.  */\n-  void (*advance) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+  void (*advance) (CUMULATIVE_ARGS *, machine_mode, const_tree);\n } aapcs_cp_arg_layout[ARM_NUM_COPROC_SLOTS] =\n   {\n     AAPCS_CP(vfp)\n@@ -5640,7 +5640,7 @@ static struct\n #undef AAPCS_CP\n \n static int\n-aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, machine_mode mode,\n \t\t\t  const_tree type)\n {\n   int i;\n@@ -5689,7 +5689,7 @@ aapcs_select_return_coproc (const_tree type, const_tree fntype)\n }\n \n static rtx\n-aapcs_allocate_return_reg (enum machine_mode mode, const_tree type,\n+aapcs_allocate_return_reg (machine_mode mode, const_tree type,\n \t\t\t   const_tree fntype)\n {\n   /* We aren't passed a decl, so we can't check that a call is local.\n@@ -5744,7 +5744,7 @@ aapcs_allocate_return_reg (enum machine_mode mode, const_tree type,\n }\n \n static rtx\n-aapcs_libcall_value (enum machine_mode mode)\n+aapcs_libcall_value (machine_mode mode)\n {\n   if (BYTES_BIG_ENDIAN && ALL_FIXED_POINT_MODE_P (mode)\n       && GET_MODE_SIZE (mode) <= 4)\n@@ -5756,7 +5756,7 @@ aapcs_libcall_value (enum machine_mode mode)\n /* Lay out a function argument using the AAPCS rules.  The rule\n    numbers referred to here are those in the AAPCS.  */\n static void\n-aapcs_layout_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+aapcs_layout_arg (CUMULATIVE_ARGS *pcum, machine_mode mode,\n \t\t  const_tree type, bool named)\n {\n   int nregs, nregs2;\n@@ -5928,7 +5928,7 @@ arm_lra_p (void)\n \n /* Return true if mode/type need doubleword alignment.  */\n static bool\n-arm_needs_doubleword_align (enum machine_mode mode, const_tree type)\n+arm_needs_doubleword_align (machine_mode mode, const_tree type)\n {\n   return (GET_MODE_ALIGNMENT (mode) > PARM_BOUNDARY\n \t  || (type && TYPE_ALIGN (type) > PARM_BOUNDARY));\n@@ -5955,7 +5955,7 @@ arm_needs_doubleword_align (enum machine_mode mode, const_tree type)\n    indeed make it pass in the stack if necessary).  */\n \n static rtx\n-arm_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n+arm_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n \t\t  const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n@@ -6008,15 +6008,15 @@ arm_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n }\n \n static unsigned int\n-arm_function_arg_boundary (enum machine_mode mode, const_tree type)\n+arm_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   return (ARM_DOUBLEWORD_ALIGN && arm_needs_doubleword_align (mode, type)\n \t  ? DOUBLEWORD_ALIGNMENT\n \t  : PARM_BOUNDARY);\n }\n \n static int\n-arm_arg_partial_bytes (cumulative_args_t pcum_v, enum machine_mode mode,\n+arm_arg_partial_bytes (cumulative_args_t pcum_v, machine_mode mode,\n \t\t       tree type, bool named)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n@@ -6044,7 +6044,7 @@ arm_arg_partial_bytes (cumulative_args_t pcum_v, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-arm_function_arg_advance (cumulative_args_t pcum_v, enum machine_mode mode,\n+arm_function_arg_advance (cumulative_args_t pcum_v, machine_mode mode,\n \t\t\t  const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n@@ -6083,7 +6083,7 @@ arm_function_arg_advance (cumulative_args_t pcum_v, enum machine_mode mode,\n \n static bool\n arm_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n@@ -6513,7 +6513,7 @@ require_pic_register (void)\n }\n \n rtx\n-legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n+legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n {\n   if (GET_CODE (orig) == SYMBOL_REF\n       || GET_CODE (orig) == LABEL_REF)\n@@ -6838,7 +6838,7 @@ will_be_in_index_register (const_rtx x)\n \n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n-arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n+arm_legitimate_address_outer_p (machine_mode mode, rtx x, RTX_CODE outer,\n \t\t\t        int strict_p)\n {\n   bool use_ldrd;\n@@ -6925,7 +6925,7 @@ arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \n /* Return nonzero if X is a valid Thumb-2 address operand.  */\n static int\n-thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n+thumb2_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n {\n   bool use_ldrd;\n   enum rtx_code code = GET_CODE (x);\n@@ -7020,7 +7020,7 @@ thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n /* Return nonzero if INDEX is valid for an address index operand in\n    ARM state.  */\n static int\n-arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n+arm_legitimate_index_p (machine_mode mode, rtx index, RTX_CODE outer,\n \t\t\tint strict_p)\n {\n   HOST_WIDE_INT range;\n@@ -7141,7 +7141,7 @@ thumb2_index_mul_operand (rtx op)\n \n /* Return nonzero if INDEX is a valid Thumb-2 address index operand.  */\n static int\n-thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n+thumb2_legitimate_index_p (machine_mode mode, rtx index, int strict_p)\n {\n   enum rtx_code code = GET_CODE (index);\n \n@@ -7234,7 +7234,7 @@ thumb2_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n \n /* Return nonzero if X is valid as a 16-bit Thumb state base register.  */\n static int\n-thumb1_base_register_rtx_p (rtx x, enum machine_mode mode, int strict_p)\n+thumb1_base_register_rtx_p (rtx x, machine_mode mode, int strict_p)\n {\n   int regno;\n \n@@ -7282,7 +7282,7 @@ thumb1_index_register_rtx_p (rtx x, int strict_p)\n    reload pass starts.  This is so that eliminating such addresses\n    into stack based ones won't produce impossible code.  */\n int\n-thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n+thumb1_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n {\n   /* ??? Not clear if this is right.  Experiment.  */\n   if (GET_MODE_SIZE (mode) < 4\n@@ -7381,7 +7381,7 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n /* Return nonzero if VAL can be used as an offset in a Thumb-state address\n    instruction of mode MODE.  */\n int\n-thumb_legitimate_offset_p (enum machine_mode mode, HOST_WIDE_INT val)\n+thumb_legitimate_offset_p (machine_mode mode, HOST_WIDE_INT val)\n {\n   switch (GET_MODE_SIZE (mode))\n     {\n@@ -7399,7 +7399,7 @@ thumb_legitimate_offset_p (enum machine_mode mode, HOST_WIDE_INT val)\n }\n \n bool\n-arm_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+arm_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n {\n   if (TARGET_ARM)\n     return arm_legitimate_address_outer_p (mode, x, SET, strict_p);\n@@ -7637,7 +7637,7 @@ legitimize_tls_address (rtx x, rtx reg)\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n rtx\n-arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n+arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n {\n   if (arm_tls_referenced_p (x))\n     {\n@@ -7783,7 +7783,7 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n /* Try machine-dependent ways of modifying an illegitimate Thumb address\n    to be legitimate.  If we find one, return the new, valid address.  */\n rtx\n-thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n+thumb_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n {\n   if (GET_CODE (x) == PLUS\n       && CONST_INT_P (XEXP (x, 1))\n@@ -7849,7 +7849,7 @@ thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \n bool\n arm_legitimize_reload_address (rtx *p,\n-\t\t\t       enum machine_mode mode,\n+\t\t\t       machine_mode mode,\n \t\t\t       int opnum, int type,\n \t\t\t       int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -8036,7 +8036,7 @@ arm_legitimize_reload_address (rtx *p,\n \n rtx\n thumb_legitimize_reload_address (rtx *x_p,\n-\t\t\t\t enum machine_mode mode,\n+\t\t\t\t machine_mode mode,\n \t\t\t\t int opnum, int type,\n \t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -8116,7 +8116,7 @@ arm_tls_referenced_p (rtx x)\n    When generating pic allow anything.  */\n \n static bool\n-arm_legitimate_constant_p_1 (enum machine_mode mode, rtx x)\n+arm_legitimate_constant_p_1 (machine_mode mode, rtx x)\n {\n   /* At present, we have no support for Neon structure constants, so forbid\n      them here.  It might be possible to handle simple cases like 0 and -1\n@@ -8128,7 +8128,7 @@ arm_legitimate_constant_p_1 (enum machine_mode mode, rtx x)\n }\n \n static bool\n-thumb_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+thumb_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return (CONST_INT_P (x)\n \t  || CONST_DOUBLE_P (x)\n@@ -8137,7 +8137,7 @@ thumb_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n }\n \n static bool\n-arm_legitimate_constant_p (enum machine_mode mode, rtx x)\n+arm_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   return (!arm_cannot_force_const_mem (mode, x)\n \t  && (TARGET_32BIT\n@@ -8148,7 +8148,7 @@ arm_legitimate_constant_p (enum machine_mode mode, rtx x)\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-arm_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   rtx base, offset;\n \n@@ -8172,7 +8172,7 @@ arm_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n static inline int\n thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   int total, words;\n \n   switch (code)\n@@ -8300,7 +8300,7 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n static inline bool\n arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   enum rtx_code subcode;\n   rtx operand;\n   enum rtx_code code = GET_CODE (x);\n@@ -8762,7 +8762,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n \t  rtx op = XEXP (x, 0);\n-\t  enum machine_mode opmode = GET_MODE (op);\n+\t  machine_mode opmode = GET_MODE (op);\n \n \t  if (mode == DImode)\n \t    *total += COSTS_N_INSNS (1);\n@@ -8905,7 +8905,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n static inline int\n thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   int words;\n \n   switch (code)\n@@ -9047,7 +9047,7 @@ static bool\n arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t    int *total)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   if (TARGET_THUMB1)\n     {\n       *total = thumb1_size_rtx_costs (x, code, outer_code);\n@@ -9402,7 +9402,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t   const struct cpu_cost_table *extra_cost,\n \t\t   int *cost, bool speed_p)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (TARGET_THUMB1)\n     {\n@@ -10398,7 +10398,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t*cost = 0;\n       else\n \t{\n-\t  enum machine_mode op0mode;\n+\t  machine_mode op0mode;\n \t  /* We'll mostly assume that the cost of a compare is the cost of the\n \t     LHS.  However, there are some notable exceptions.  */\n \n@@ -11122,7 +11122,7 @@ static bool\n arm_slowmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t       int *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (TARGET_THUMB)\n     {\n@@ -11176,7 +11176,7 @@ static bool\n arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t       int *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (TARGET_THUMB1)\n     {\n@@ -11260,7 +11260,7 @@ static bool\n arm_xscale_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t      int *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (TARGET_THUMB)\n     {\n@@ -11349,7 +11349,7 @@ static bool\n arm_9e_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  int *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (TARGET_THUMB1)\n     {\n@@ -11454,7 +11454,7 @@ arm_thumb_address_cost (rtx x)\n }\n \n static int\n-arm_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n+arm_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  addr_space_t as ATTRIBUTE_UNUSED, bool speed ATTRIBUTE_UNUSED)\n {\n   return TARGET_32BIT ? arm_arm_address_cost (x) : arm_thumb_address_cost (x);\n@@ -11632,7 +11632,7 @@ fa726te_sched_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep, int * cost)\n    point to integer conversion does not go through memory.  */\n \n int\n-arm_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+arm_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\treg_class_t from, reg_class_t to)\n {\n   if (TARGET_32BIT)\n@@ -11660,7 +11660,7 @@ arm_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Implement TARGET_MEMORY_MOVE_COST.  */\n \n int\n-arm_memory_move_cost (enum machine_mode mode, reg_class_t rclass,\n+arm_memory_move_cost (machine_mode mode, reg_class_t rclass,\n \t\t      bool in ATTRIBUTE_UNUSED)\n {\n   if (TARGET_32BIT)\n@@ -12219,7 +12219,7 @@ vfp3_const_double_rtx (rtx x)\n    -1 if the given value doesn't match any of the listed patterns.\n */\n static int\n-neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n+neon_valid_immediate (rtx op, machine_mode mode, int inverse,\n \t\t      rtx *modconst, int *elementwidth)\n {\n #define CHECK(STRIDE, ELSIZE, CLASS, TEST)\t\\\n@@ -12424,7 +12424,7 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n    VMOV) in *MODCONST.  */\n \n int\n-neon_immediate_valid_for_move (rtx op, enum machine_mode mode,\n+neon_immediate_valid_for_move (rtx op, machine_mode mode,\n \t\t\t       rtx *modconst, int *elementwidth)\n {\n   rtx tmpconst;\n@@ -12449,7 +12449,7 @@ neon_immediate_valid_for_move (rtx op, enum machine_mode mode,\n    *ELEMENTWIDTH. See neon_valid_immediate for description of INVERSE.  */\n \n int\n-neon_immediate_valid_for_logic (rtx op, enum machine_mode mode, int inverse,\n+neon_immediate_valid_for_logic (rtx op, machine_mode mode, int inverse,\n \t\t\t\trtx *modconst, int *elementwidth)\n {\n   rtx tmpconst;\n@@ -12475,7 +12475,7 @@ neon_immediate_valid_for_logic (rtx op, enum machine_mode mode, int inverse,\n    because they have different limitations.  */\n \n int\n-neon_immediate_valid_for_shift (rtx op, enum machine_mode mode,\n+neon_immediate_valid_for_shift (rtx op, machine_mode mode,\n \t\t\t\trtx *modconst, int *elementwidth,\n \t\t\t\tbool isleftshift)\n {\n@@ -12532,7 +12532,7 @@ neon_immediate_valid_for_shift (rtx op, enum machine_mode mode,\n    MNEM.  */\n \n char *\n-neon_output_logic_immediate (const char *mnem, rtx *op2, enum machine_mode mode,\n+neon_output_logic_immediate (const char *mnem, rtx *op2, machine_mode mode,\n \t\t\t     int inverse, int quad)\n {\n   int width, is_valid;\n@@ -12555,7 +12555,7 @@ neon_output_logic_immediate (const char *mnem, rtx *op2, enum machine_mode mode,\n \n char *\n neon_output_shift_immediate (const char *mnem, char sign, rtx *op2,\n-\t\t\t     enum machine_mode mode, int quad,\n+\t\t\t     machine_mode mode, int quad,\n \t\t\t     bool isleftshift)\n {\n   int width, is_valid;\n@@ -12583,10 +12583,10 @@ neon_output_shift_immediate (const char *mnem, char sign, rtx *op2,\n    for no particular gain.  */\n \n void\n-neon_pairwise_reduce (rtx op0, rtx op1, enum machine_mode mode,\n+neon_pairwise_reduce (rtx op0, rtx op1, machine_mode mode,\n \t\t      rtx (*reduc) (rtx, rtx, rtx))\n {\n-  enum machine_mode inner = GET_MODE_INNER (mode);\n+  machine_mode inner = GET_MODE_INNER (mode);\n   unsigned int i, parts = GET_MODE_SIZE (mode) / GET_MODE_SIZE (inner);\n   rtx tmpsum = op1;\n \n@@ -12605,8 +12605,8 @@ neon_pairwise_reduce (rtx op0, rtx op1, enum machine_mode mode,\n static rtx\n neon_vdup_constant (rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (vals);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (vals);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n   bool all_same = true;\n   rtx x;\n@@ -12645,7 +12645,7 @@ neon_vdup_constant (rtx vals)\n rtx\n neon_make_constant (rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (vals);\n+  machine_mode mode = GET_MODE (vals);\n   rtx target;\n   rtx const_vec = NULL_RTX;\n   int n_elts = GET_MODE_NUNITS (mode);\n@@ -12697,8 +12697,8 @@ neon_make_constant (rtx vals)\n void\n neon_expand_vector_init (rtx target, rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (target);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (target);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n   int n_var = 0, one_var = -1;\n   bool all_same = true;\n@@ -12828,7 +12828,7 @@ neon_const_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n }\n \n HOST_WIDE_INT\n-neon_element_bits (enum machine_mode mode)\n+neon_element_bits (machine_mode mode)\n {\n   if (mode == DImode)\n     return GET_MODE_BITSIZE (mode);\n@@ -13037,7 +13037,7 @@ arm_eliminable_register (rtx x)\n    coprocessor registers.  Otherwise return NO_REGS.  */\n \n enum reg_class\n-coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)\n+coproc_secondary_reload_class (machine_mode mode, rtx x, bool wb)\n {\n   if (mode == HFmode)\n     {\n@@ -13322,7 +13322,7 @@ adjacent_mem_locations (rtx a, rtx b)\n          REGNO (R_dk) = REGNO (R_d0) + k.\n    The pattern for store is similar.  */\n bool\n-ldm_stm_operation_p (rtx op, bool load, enum machine_mode mode,\n+ldm_stm_operation_p (rtx op, bool load, machine_mode mode,\n                      bool consecutive, bool return_pc)\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n@@ -14780,7 +14780,7 @@ by mode size.  */\n inline static rtx\n next_consecutive_mem (rtx mem)\n {\n-  enum machine_mode mode = GET_MODE (mem);\n+  machine_mode mode = GET_MODE (mem);\n   HOST_WIDE_INT offset = GET_MODE_SIZE (mode);\n   rtx addr = plus_constant (Pmode, XEXP (mem, 0), offset);\n \n@@ -14920,7 +14920,7 @@ gen_movmem_ldrd_strd (rtx *operands)\n    here.  If we are unable to support a dominance comparison we return\n    CC mode.  This will then fail to match for the RTL expressions that\n    generate this call.  */\n-enum machine_mode\n+machine_mode\n arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n {\n   enum rtx_code cond1, cond2;\n@@ -15062,7 +15062,7 @@ arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n     }\n }\n \n-enum machine_mode\n+machine_mode\n arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n   /* All floating point compares return CCFP if it is an equality\n@@ -15245,7 +15245,7 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n rtx\n arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y, rtx scratch)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx cc_reg;\n   int dimode_comparison = GET_MODE (x) == DImode || GET_MODE (y) == DImode;\n \n@@ -15581,7 +15581,7 @@ arm_reload_out_hi (rtx *operands)\n    (padded to the size of a word) should be passed in a register.  */\n \n static bool\n-arm_must_pass_in_stack (enum machine_mode mode, const_tree type)\n+arm_must_pass_in_stack (machine_mode mode, const_tree type)\n {\n   if (TARGET_AAPCS_BASED)\n     return must_pass_in_stack_var_size (mode, type);\n@@ -15597,7 +15597,7 @@ arm_must_pass_in_stack (enum machine_mode mode, const_tree type)\n    aggregate types are placed in the lowest memory address.  */\n \n bool\n-arm_pad_arg_upward (enum machine_mode mode ATTRIBUTE_UNUSED, const_tree type)\n+arm_pad_arg_upward (machine_mode mode ATTRIBUTE_UNUSED, const_tree type)\n {\n   if (!TARGET_AAPCS_BASED)\n     return DEFAULT_FUNCTION_ARG_PADDING(mode, type) == upward;\n@@ -15615,7 +15615,7 @@ arm_pad_arg_upward (enum machine_mode mode ATTRIBUTE_UNUSED, const_tree type)\n    significant byte does.  */\n \n bool\n-arm_pad_reg_upward (enum machine_mode mode,\n+arm_pad_reg_upward (machine_mode mode,\n                     tree type, int first ATTRIBUTE_UNUSED)\n {\n   if (TARGET_AAPCS_BASED && BYTES_BIG_ENDIAN)\n@@ -16140,7 +16140,7 @@ struct minipool_node\n   /* The value in table.  */\n   rtx value;\n   /* The mode of value.  */\n-  enum machine_mode mode;\n+  machine_mode mode;\n   /* The size of the value.  With iWMMXt enabled\n      sizes > 4 also imply an alignment of 8-bytes.  */\n   int fix_size;\n@@ -16152,7 +16152,7 @@ struct minipool_fixup\n   rtx_insn *        insn;\n   HOST_WIDE_INT     address;\n   rtx *             loc;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int               fix_size;\n   rtx               value;\n   Mnode *           minipool;\n@@ -16873,7 +16873,7 @@ push_minipool_barrier (rtx_insn *insn, HOST_WIDE_INT address)\n    MODE.  */\n static void\n push_minipool_fix (rtx_insn *insn, HOST_WIDE_INT address, rtx *loc,\n-\t\t   enum machine_mode mode, rtx value)\n+\t\t   machine_mode mode, rtx value)\n {\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n \n@@ -16940,7 +16940,7 @@ int\n arm_const_double_inline_cost (rtx val)\n {\n   rtx lowpart, highpart;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = GET_MODE (val);\n \n@@ -16976,7 +16976,7 @@ arm_const_inline_cost (enum rtx_code code, rtx val)\n bool\n arm_const_double_by_parts (rtx val)\n {\n-  enum machine_mode mode = GET_MODE (val);\n+  machine_mode mode = GET_MODE (val);\n   rtx part;\n \n   if (optimize_size || arm_ld_sched)\n@@ -17009,7 +17009,7 @@ arm_const_double_by_parts (rtx val)\n bool\n arm_const_double_by_immediates (rtx val)\n {\n-  enum machine_mode mode = GET_MODE (val);\n+  machine_mode mode = GET_MODE (val);\n   rtx part;\n \n   if (mode == VOIDmode)\n@@ -18461,7 +18461,7 @@ output_move_vfp (rtx *operands)\n   int integer_p = GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT;\n   const char *templ;\n   char buff[50];\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   reg = operands[!load];\n   mem = operands[load];\n@@ -18557,7 +18557,7 @@ output_move_neon (rtx *operands)\n   int regno, nregs, load = REG_P (operands[0]);\n   const char *templ;\n   char buff[50];\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   reg = operands[!load];\n   mem = operands[load];\n@@ -18672,7 +18672,7 @@ arm_attr_length_move_neon (rtx_insn *insn)\n {\n   rtx reg, mem, addr;\n   int load;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   extract_insn_cached (insn);\n \n@@ -20624,7 +20624,7 @@ arm_emit_ldrd_pop (unsigned long saved_regs_mask)\n static unsigned\n arm_size_return_regs (void)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (crtl->return_rtx != 0)\n     mode = GET_MODE (crtl->return_rtx);\n@@ -21718,7 +21718,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n     case 'R':\n       if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n \t{\n-\t  enum machine_mode mode = GET_MODE (x);\n+\t  machine_mode mode = GET_MODE (x);\n \t  rtx part;\n \n \t  if (mode == VOIDmode)\n@@ -21879,7 +21879,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n        register.  */\n     case 'p':\n       {\n-        enum machine_mode mode = GET_MODE (x);\n+        machine_mode mode = GET_MODE (x);\n         int regno;\n \n         if (GET_MODE_SIZE (mode) != 8 || !REG_P (x))\n@@ -21903,7 +21903,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n     case 'P':\n     case 'q':\n       {\n-\tenum machine_mode mode = GET_MODE (x);\n+\tmachine_mode mode = GET_MODE (x);\n \tint is_quad = (code == 'q');\n \tint regno;\n \n@@ -21939,7 +21939,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n     case 'e':\n     case 'f':\n       {\n-        enum machine_mode mode = GET_MODE (x);\n+        machine_mode mode = GET_MODE (x);\n         int regno;\n \n         if ((GET_MODE_SIZE (mode) != 16\n@@ -22080,7 +22080,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n     /* Translate an S register number into a D register number and element index.  */\n     case 'y':\n       {\n-        enum machine_mode mode = GET_MODE (x);\n+        machine_mode mode = GET_MODE (x);\n         int regno;\n \n         if (GET_MODE_SIZE (mode) != 4 || !REG_P (x))\n@@ -22114,7 +22114,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n        number into a D register number and element index.  */\n     case 'z':\n       {\n-        enum machine_mode mode = GET_MODE (x);\n+        machine_mode mode = GET_MODE (x);\n         int regno;\n \n         if (GET_MODE_SIZE (mode) != 2 || !REG_P (x))\n@@ -22239,7 +22239,7 @@ arm_print_operand_address (FILE *stream, rtx x)\n       else if (GET_CODE (x) == PRE_INC || GET_CODE (x) == POST_INC\n \t       || GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_DEC)\n \t{\n-\t  extern enum machine_mode output_memory_reference_mode;\n+\t  extern machine_mode output_memory_reference_mode;\n \n \t  gcc_assert (REG_P (XEXP (x, 0)));\n \n@@ -22316,7 +22316,7 @@ arm_print_operand_punct_valid_p (unsigned char code)\n static bool\n arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (size == UNITS_PER_WORD && aligned_p)\n     {\n@@ -22472,7 +22472,7 @@ arm_elf_asm_destructor (rtx symbol, int priority)\n enum arm_cond_code\n maybe_get_arm_condition_code (rtx comparison)\n {\n-  enum machine_mode mode = GET_MODE (XEXP (comparison, 0));\n+  machine_mode mode = GET_MODE (XEXP (comparison, 0));\n   enum arm_cond_code code;\n   enum rtx_code comp_code = GET_CODE (comparison);\n \n@@ -23021,7 +23021,7 @@ thumb2_asm_output_opcode (FILE * stream)\n /* Returns true if REGNO is a valid register\n    for holding a quantity of type MODE.  */\n int\n-arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return (regno == CC_REGNUM\n@@ -23101,7 +23101,7 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n /* Implement MODES_TIEABLE_P.  */\n \n bool\n-arm_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+arm_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2))\n     return true;\n@@ -24741,7 +24741,7 @@ arm_init_iwmmxt_builtins (void)\n     {\n       /* Use one of the operands; the target can have a different mode for\n \t mask-generating compares.  */\n-      enum machine_mode mode;\n+      machine_mode mode;\n       tree type;\n \n       if (d->name == 0 || !(d->mask == FL_IWMMXT || d->mask == FL_IWMMXT2))\n@@ -25070,7 +25070,7 @@ arm_convert_to_type (tree type, tree expr)\n    special-cased in the default hook.  */\n \n static bool\n-arm_scalar_mode_supported_p (enum machine_mode mode)\n+arm_scalar_mode_supported_p (machine_mode mode)\n {\n   if (mode == HFmode)\n     return (arm_fp16_format != ARM_FP16_FORMAT_NONE);\n@@ -25085,7 +25085,7 @@ arm_scalar_mode_supported_p (enum machine_mode mode)\n    clear instructions.  */\n \n static rtx\n-safe_vector_operand (rtx x, enum machine_mode mode)\n+safe_vector_operand (rtx x, machine_mode mode)\n {\n   if (x != const0_rtx)\n     return x;\n@@ -25122,10 +25122,10 @@ arm_expand_ternop_builtin (enum insn_code icode,\n                   || icode == CODE_FOR_crypto_sha1m);\n       builtin_sha1cpm_p = true;\n     }\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n-  enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode mode2 = insn_data[icode].operand[3].mode;\n \n \n   if (VECTOR_MODE_P (mode0))\n@@ -25174,9 +25174,9 @@ arm_expand_binop_builtin (enum insn_code icode,\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n \n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n@@ -25213,8 +25213,8 @@ arm_expand_unop_builtin (enum insn_code icode,\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = NULL_RTX;\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n   bool builtin_sha1h_p = false;\n \n   if (insn_data[icode].n_operands == 3)\n@@ -25269,8 +25269,8 @@ typedef enum {\n    available.  */\n \n static tree\n-neon_dereference_pointer (tree exp, tree type, enum machine_mode mem_mode,\n-\t\t\t  enum machine_mode reg_mode,\n+neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n+\t\t\t  machine_mode reg_mode,\n \t\t\t  neon_builtin_type_mode type_mode)\n {\n   HOST_WIDE_INT reg_size, vector_size, nvectors, nelems;\n@@ -25320,9 +25320,9 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n   rtx op[NEON_MAX_BUILTIN_ARGS];\n   tree arg_type;\n   tree formals;\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode[NEON_MAX_BUILTIN_ARGS];\n-  enum machine_mode other_mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode[NEON_MAX_BUILTIN_ARGS];\n+  machine_mode other_mode;\n   int argc = 0;\n   int opno;\n \n@@ -25627,7 +25627,7 @@ neon_split_vcombine (rtx operands[3])\n   unsigned int dest = REGNO (operands[0]);\n   unsigned int src1 = REGNO (operands[1]);\n   unsigned int src2 = REGNO (operands[2]);\n-  enum machine_mode halfmode = GET_MODE (operands[1]);\n+  machine_mode halfmode = GET_MODE (operands[1]);\n   unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n   rtx destlo, desthi;\n \n@@ -25680,7 +25680,7 @@ static rtx\n arm_expand_builtin (tree exp,\n \t\t    rtx target,\n \t\t    rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    int ignore ATTRIBUTE_UNUSED)\n {\n   const struct builtin_description * d;\n@@ -25695,10 +25695,10 @@ arm_expand_builtin (tree exp,\n   rtx               pat;\n   unsigned int      fcode = DECL_FUNCTION_CODE (fndecl);\n   size_t            i;\n-  enum machine_mode tmode;\n-  enum machine_mode mode0;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n+  machine_mode tmode;\n+  machine_mode mode0;\n+  machine_mode mode1;\n+  machine_mode mode2;\n   int opint;\n   int selector;\n   int mask;\n@@ -26362,7 +26362,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n   int pops_needed;\n   unsigned available;\n   unsigned required;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int size;\n   int restore_a4 = FALSE;\n \n@@ -28773,7 +28773,7 @@ arm_output_load_gr (rtx *operands)\n \n static void\n arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n-\t\t\t    enum machine_mode mode,\n+\t\t\t    machine_mode mode,\n \t\t\t    tree type,\n \t\t\t    int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n@@ -28804,9 +28804,9 @@ arm_promote_prototypes (const_tree t ATTRIBUTE_UNUSED)\n     return !TARGET_AAPCS_BASED;\n }\n \n-static enum machine_mode\n+static machine_mode\n arm_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n-                           enum machine_mode mode,\n+                           machine_mode mode,\n                            int *punsignedp ATTRIBUTE_UNUSED,\n                            const_tree fntype ATTRIBUTE_UNUSED,\n                            int for_return ATTRIBUTE_UNUSED)\n@@ -29027,7 +29027,7 @@ thumb_set_return_address (rtx source, rtx scratch)\n \n /* Implements target hook vector_mode_supported_p.  */\n bool\n-arm_vector_mode_supported_p (enum machine_mode mode)\n+arm_vector_mode_supported_p (machine_mode mode)\n {\n   /* Neon also supports V2SImode, etc. listed in the clause below.  */\n   if (TARGET_NEON && (mode == V2SFmode || mode == V4SImode || mode == V8HImode\n@@ -29051,7 +29051,7 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n /* Implements target hook array_mode_supported_p.  */\n \n static bool\n-arm_array_mode_supported_p (enum machine_mode mode,\n+arm_array_mode_supported_p (machine_mode mode,\n \t\t\t    unsigned HOST_WIDE_INT nelems)\n {\n   if (TARGET_NEON\n@@ -29066,8 +29066,8 @@ arm_array_mode_supported_p (enum machine_mode mode,\n    registers when autovectorizing for Neon, at least until multiple vector\n    widths are supported properly by the middle-end.  */\n \n-static enum machine_mode\n-arm_preferred_simd_mode (enum machine_mode mode)\n+static machine_mode\n+arm_preferred_simd_mode (machine_mode mode)\n {\n   if (TARGET_NEON)\n     switch (mode)\n@@ -29124,7 +29124,7 @@ arm_class_likely_spilled_p (reg_class_t rclass)\n \n /* Implements target hook small_register_classes_for_mode_p.  */\n bool\n-arm_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n+arm_small_register_classes_for_mode_p (machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return TARGET_THUMB1;\n }\n@@ -29135,7 +29135,7 @@ arm_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n    guarantee no particular behavior for out-of-range counts.  */\n \n static unsigned HOST_WIDE_INT\n-arm_shift_truncation_mask (enum machine_mode mode)\n+arm_shift_truncation_mask (machine_mode mode)\n {\n   return mode == SImode ? 255 : 0;\n }\n@@ -29173,7 +29173,7 @@ arm_dbx_register_number (unsigned int regno)\n static rtx\n arm_dwarf_register_span (rtx rtl)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned regno;\n   rtx parts[16];\n   int nregs;\n@@ -29728,7 +29728,7 @@ arm_output_iwmmxt_shift_immediate (const char *insn_name, rtx *operands, bool wr\n {\n   int shift = INTVAL (operands[2]);\n   char templ[50];\n-  enum machine_mode opmode = GET_MODE (operands[0]);\n+  machine_mode opmode = GET_MODE (operands[0]);\n \n   gcc_assert (shift >= 0);\n \n@@ -29906,7 +29906,7 @@ arm_issue_rate (void)\n    composed of NEON vector element types (e.g. __builtin_neon_qi).  */\n typedef struct\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   const char *element_type_name;\n   const char *aapcs_name;\n } arm_mangle_map_entry;\n@@ -30020,7 +30020,7 @@ arm_have_conditional_execution (void)\n tree\n arm_builtin_vectorized_function (tree fndecl, tree type_out, tree type_in)\n {\n-  enum machine_mode in_mode, out_mode;\n+  machine_mode in_mode, out_mode;\n   int in_n, out_n;\n   bool out_unsigned_p = TYPE_UNSIGNED (type_out);\n \n@@ -30171,7 +30171,7 @@ arm_vector_alignment_reachable (const_tree type, bool is_packed)\n }\n \n static bool\n-arm_builtin_support_vector_misalignment (enum machine_mode mode,\n+arm_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t const_tree type, int misalignment,\n \t\t\t\t\t bool is_packed)\n {\n@@ -30395,7 +30395,7 @@ arm_post_atomic_barrier (enum memmodel model)\n    Use acquire and release versions if necessary.  */\n \n static void\n-arm_emit_load_exclusive (enum machine_mode mode, rtx rval, rtx mem, bool acq)\n+arm_emit_load_exclusive (machine_mode mode, rtx rval, rtx mem, bool acq)\n {\n   rtx (*gen) (rtx, rtx);\n \n@@ -30428,7 +30428,7 @@ arm_emit_load_exclusive (enum machine_mode mode, rtx rval, rtx mem, bool acq)\n }\n \n static void\n-arm_emit_store_exclusive (enum machine_mode mode, rtx bval, rtx rval,\n+arm_emit_store_exclusive (machine_mode mode, rtx bval, rtx rval,\n                           rtx mem, bool rel)\n {\n   rtx (*gen) (rtx, rtx, rtx);\n@@ -30478,7 +30478,7 @@ void\n arm_expand_compare_and_swap (rtx operands[])\n {\n   rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n   bval = operands[0];\n@@ -30559,7 +30559,7 @@ void\n arm_split_compare_and_swap (rtx operands[])\n {\n   rtx rval, mem, oldval, newval, scratch;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum memmodel mod_s, mod_f;\n   bool is_weak;\n   rtx_code_label *label1, *label2;\n@@ -30637,8 +30637,8 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \t\t     rtx value, rtx model_rtx, rtx cond)\n {\n   enum memmodel model = (enum memmodel) INTVAL (model_rtx);\n-  enum machine_mode mode = GET_MODE (mem);\n-  enum machine_mode wmode = (mode == DImode ? DImode : SImode);\n+  machine_mode mode = GET_MODE (mem);\n+  machine_mode wmode = (mode == DImode ? DImode : SImode);\n   rtx_code_label *label;\n   rtx x;\n \n@@ -30732,7 +30732,7 @@ struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n   unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n   unsigned char nelt;\n   bool one_vector_p;\n   bool testing_p;\n@@ -30743,7 +30743,7 @@ struct expand_vec_perm_d\n static void\n arm_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   bool one_vector_p = rtx_equal_p (op0, op1);\n \n   gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n@@ -30782,7 +30782,7 @@ arm_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n void\n arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n   bool one_vector_p = rtx_equal_p (op0, op1);\n   rtx rmask[MAX_VECT_LEN], mask;\n@@ -31150,7 +31150,7 @@ static bool\n arm_evpc_neon_vtbl (struct expand_vec_perm_d *d)\n {\n   rtx rperm[MAX_VECT_LEN], sel;\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   unsigned int i, nelt = d->nelt;\n \n   /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n@@ -31275,7 +31275,7 @@ arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n \n static bool\n-arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+arm_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n@@ -31316,7 +31316,7 @@ arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n }\n \n bool\n-arm_autoinc_modes_ok_p (enum machine_mode mode, enum arm_auto_incmodes code)\n+arm_autoinc_modes_ok_p (machine_mode mode, enum arm_auto_incmodes code)\n {\n   /* If we are soft float and we do not have ldrd\n      then all auto increment forms are ok.  */\n@@ -31620,7 +31620,7 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n {\n   enum rtx_code code = GET_CODE (*comparison);\n   int code_int;\n-  enum machine_mode mode = (GET_MODE (*op1) == VOIDmode) \n+  machine_mode mode = (GET_MODE (*op1) == VOIDmode) \n     ? GET_MODE (*op2) : GET_MODE (*op1);\n \n   gcc_assert (GET_MODE (*op1) != VOIDmode || GET_MODE (*op2) != VOIDmode);\n@@ -31722,7 +31722,7 @@ arm_block_set_non_vect_profit_p (rtx val,\n static bool\n arm_block_set_vect_profit_p (unsigned HOST_WIDE_INT length,\n \t\t\t     unsigned HOST_WIDE_INT align,\n-\t\t\t     enum machine_mode mode)\n+\t\t\t     machine_mode mode)\n {\n   int num;\n   bool unaligned_p = ((align & 3) != 0);\n@@ -31760,7 +31760,7 @@ arm_block_set_unaligned_vect (rtx dstbase,\n   rtx val_elt, val_vec, reg;\n   rtx rval[MAX_VECT_LEN];\n   rtx (*gen_func) (rtx, rtx);\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned HOST_WIDE_INT v = value;\n \n   gcc_assert ((align & 0x3) != 0);\n@@ -31851,7 +31851,7 @@ arm_block_set_aligned_vect (rtx dstbase,\n   rtx dst, addr, mem;\n   rtx val_elt, val_vec, reg;\n   rtx rval[MAX_VECT_LEN];\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned HOST_WIDE_INT v = value;\n \n   gcc_assert ((align & 0x3) == 0);\n@@ -31962,7 +31962,7 @@ arm_block_set_unaligned_non_vect (rtx dstbase,\n   unsigned int i;\n   rtx dst, addr, mem;\n   rtx val_exp, val_reg, reg;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   HOST_WIDE_INT v = value;\n \n   gcc_assert (align == 1 || align == 2);"}, {"sha": "02d0a93f74932f1967d2557f775b9f7064134806", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -29,14 +29,14 @@\n #ifndef GCC_ARM_H\n #define GCC_ARM_H\n \n-/* We can't use enum machine_mode inside a generator file because it\n+/* We can't use machine_mode inside a generator file because it\n    hasn't been created yet; we shouldn't be using any code that\n    needs the real definition though, so this ought to be safe.  */\n #ifdef GENERATOR_FILE\n #define MACHMODE int\n #else\n #include \"insn-modes.h\"\n-#define MACHMODE enum machine_mode\n+#define MACHMODE machine_mode\n #endif\n \n #include \"config/vxworks-dummy.h\"\n@@ -1547,7 +1547,7 @@ typedef struct GTY(()) machine_function\n   rtx thumb1_cc_op0;\n   rtx thumb1_cc_op1;\n   /* Also record the CC mode that is supported.  */\n-  enum machine_mode thumb1_cc_mode;\n+  machine_mode thumb1_cc_mode;\n   /* Set to 1 after arm_reorg has started.  */\n   int after_arm_reorg;\n }"}, {"sha": "8106943a80041c99d676805575f3bcc581a1448c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -3538,7 +3538,7 @@\n               (set (match_dup 0)\n                    (match_dup 6)))]\n   {\n-  enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+  machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n                                            operands[2], operands[3]);\n   enum rtx_code rc = minmax_code (operands[4]);\n   operands[4] = gen_rtx_fmt_ee (rc, VOIDmode,\n@@ -4876,7 +4876,7 @@\n   [(set (match_dup 0) (match_dup 1))]\n {\n   rtx lo_part = gen_lowpart (SImode, operands[0]);\n-  enum machine_mode src_mode = GET_MODE (operands[1]);\n+  machine_mode src_mode = GET_MODE (operands[1]);\n \n   if (REG_P (operands[0])\n       && !reg_overlap_mentioned_p (operands[0], operands[1]))\n@@ -4902,7 +4902,7 @@\n   [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (const_int 31)))]\n {\n   rtx lo_part = gen_lowpart (SImode, operands[0]);\n-  enum machine_mode src_mode = GET_MODE (operands[1]);\n+  machine_mode src_mode = GET_MODE (operands[1]);\n \n   if (REG_P (operands[0])\n       && !reg_overlap_mentioned_p (operands[0], operands[1]))\n@@ -7453,7 +7453,7 @@\n   [(const_int 0)]\n   {\n     enum rtx_code rev_code;\n-    enum machine_mode mode;\n+    machine_mode mode;\n     rtx rev_cond;\n \n     emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n@@ -8383,7 +8383,7 @@\n    (cond_exec (match_dup 4) (set (match_dup 0)\n                                  (and:SI (match_dup 3) (const_int 1))))]\n   {\n-    enum machine_mode mode = GET_MODE (operands[2]);\n+    machine_mode mode = GET_MODE (operands[2]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     /* Note that operands[4] is the same as operands[1],\n@@ -8417,7 +8417,7 @@\n    (cond_exec (match_dup 4) (set (match_dup 0)\n                                  (ior:SI (match_dup 3) (const_int 1))))]\n   {\n-    enum machine_mode mode = GET_MODE (operands[2]);\n+    machine_mode mode = GET_MODE (operands[2]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     /* Note that operands[4] is the same as operands[1],\n@@ -8521,7 +8521,7 @@\n    (cond_exec (match_dup 5) (set (match_dup 0) (const_int 1)))]\n {\n   rtx tmp1;\n-  enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+  machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t   operands[2], operands[3]);\n   enum rtx_code rc = GET_CODE (operands[1]);\n \n@@ -9325,7 +9325,7 @@\n \t      (set (match_dup 0) (match_dup 2)))]\n   \"\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[5]),\n+    machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[5]),\n \t\t\t\t\t     operands[3], operands[4]);\n     enum rtx_code rc = GET_CODE (operands[5]);\n     operands[6] = gen_rtx_REG (mode, CC_REGNUM);\n@@ -10221,7 +10221,7 @@\n \t      (set (match_dup 0) (match_dup 4)))]\n   \"\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+    machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t     operands[2], operands[3]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n@@ -10249,7 +10249,7 @@\n \t      (set (match_dup 0) (match_dup 4)))]\n   \"\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+    machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t     operands[2], operands[3]);\n \n     operands[5] = gen_rtx_REG (mode, CC_REGNUM);\n@@ -10272,7 +10272,7 @@\n \t      (set (match_dup 0) (match_dup 5)))]\n   \"\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+    machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t     operands[2], operands[3]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n@@ -10304,7 +10304,7 @@\n \t      (set (match_dup 0) (not:SI (match_dup 5))))]\n   \"\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n+    machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[1]),\n \t\t\t\t\t     operands[2], operands[3]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n "}, {"sha": "a0ec446071a63ad165a670f2cdb2f8009b17301b", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1210,7 +1210,7 @@\n   rtx zero_reg;\n   HOST_WIDE_INT num_bits = INTVAL (operands[2]);\n   const int width = GET_MODE_BITSIZE (<MODE>mode);\n-  const enum machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;\n+  const machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;\n   rtx (*gen_ext) (rtx, rtx, rtx, rtx) =\n     (width == 128) ? gen_neon_vextv16qi : gen_neon_vextv8qi;\n \n@@ -1238,7 +1238,7 @@\n   rtx zero_reg;\n   HOST_WIDE_INT num_bits = INTVAL (operands[2]);\n   const int width = GET_MODE_BITSIZE (<MODE>mode);\n-  const enum machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;\n+  const machine_mode bvecmode = (width == 128) ? V16QImode : V8QImode;\n   rtx (*gen_ext) (rtx, rtx, rtx, rtx) =\n     (width == 128) ? gen_neon_vextv16qi : gen_neon_vextv8qi;\n "}, {"sha": "64acfeaa769a969c8a926ea75f86aa2a9a5560a2", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -416,7 +416,7 @@\n                    (const_int 0)))]\n   {\n     operands[3] = GEN_INT (~0);\n-    enum machine_mode mode = GET_MODE (operands[2]);\n+    machine_mode mode = GET_MODE (operands[2]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     if (mode == CCFPmode || mode == CCFPEmode)\n@@ -503,7 +503,7 @@\n   [(const_int 0)]\n   {\n     enum rtx_code rev_code;\n-    enum machine_mode mode;\n+    machine_mode mode;\n     rtx rev_cond;\n \n     emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n@@ -595,7 +595,7 @@\n         (and:SI (match_dup 3) (const_int 1)))\n    (cond_exec (match_dup 4) (set (match_dup 0) (const_int 0)))]\n   {\n-    enum machine_mode mode = GET_MODE (operands[2]);\n+    machine_mode mode = GET_MODE (operands[2]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     if (mode == CCFPmode || mode == CCFPEmode)\n@@ -627,7 +627,7 @@\n     (cond_exec (match_dup 4) (set (match_dup 0)\n                                   (ior:SI (match_dup 3) (const_int 1))))]\n   {\n-    enum machine_mode mode = GET_MODE (operands[2]);\n+    machine_mode mode = GET_MODE (operands[2]);\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     operands[4] = gen_rtx_fmt_ee (rc, VOIDmode, operands[2], const0_rtx);\n@@ -891,7 +891,7 @@\n       {\n        /* Emit:  cmp\\\\t%1, %2\\;mvn\\\\t%0, #0\\;it\\\\t%D3\\;mov%D3\\\\t%0, #0\\;*/\n        enum rtx_code rc = reverse_condition (GET_CODE (operands[3]));\n-       enum machine_mode mode = SELECT_CC_MODE (rc, operands[1], operands[2]);\n+       machine_mode mode = SELECT_CC_MODE (rc, operands[1], operands[2]);\n        rtx tmp1 = gen_rtx_REG (mode, CC_REGNUM);\n \n        emit_insn (gen_rtx_SET (VOIDmode,"}, {"sha": "68d5cbe0b1327481e72b0231d85a9cf2ce1a66d8", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -53,7 +53,7 @@\n   t: tree\n   T: tree (brief)\n   C: enum rtx_code\n-  m: enum machine_mode\n+  m: machine_mode\n   R: enum reg_class\n   L: insn list\n   H: location_t\n@@ -238,7 +238,7 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n               break;\n \n             case 'm':\n-              fputs (GET_MODE_NAME ((enum machine_mode) va_arg (ap, int)),\n+              fputs (GET_MODE_NAME ((machine_mode) va_arg (ap, int)),\n                      file);\n               break;\n "}, {"sha": "8a0e2bdcbbe3681251d05a312065d3f1c593af3b", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -45,8 +45,8 @@ extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n-extern int avr_hard_regno_call_part_clobbered (unsigned, enum machine_mode);\n-extern bool tiny_valid_direct_memory_access_range(rtx, enum machine_mode);\n+extern int avr_hard_regno_call_part_clobbered (unsigned, machine_mode);\n+extern bool tiny_valid_direct_memory_access_range(rtx, machine_mode);\n extern const char *output_movqi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movsisf (rtx_insn *insn, rtx operands[], int *l);\n@@ -111,22 +111,22 @@ extern int avr_jump_mode (rtx x, rtx_insn *insn);\n extern int test_hard_reg_class (enum reg_class rclass, rtx x);\n extern int jump_over_one_insn_p (rtx_insn *insn, rtx dest);\n \n-extern int avr_hard_regno_mode_ok (int regno, enum machine_mode mode);\n+extern int avr_hard_regno_mode_ok (int regno, machine_mode mode);\n extern void avr_final_prescan_insn (rtx_insn *insn, rtx *operand,\n \t\t\t\t    int num_operands);\n-extern int avr_simplify_comparison_p (enum machine_mode mode,\n+extern int avr_simplify_comparison_p (machine_mode mode,\n \t\t\t\t      RTX_CODE op, rtx x);\n extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n extern void out_shift_with_cnt (const char *templ, rtx_insn *insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n-extern enum reg_class avr_mode_code_base_reg_class (enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n-extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n+extern enum reg_class avr_mode_code_base_reg_class (machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n+extern bool avr_regno_mode_code_ok_for_base_p (int, machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n extern rtx avr_incoming_return_addr_rtx (void);\n-extern rtx avr_legitimize_reload_address (rtx*, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n+extern rtx avr_legitimize_reload_address (rtx*, machine_mode, int, int, int, int, rtx (*)(rtx,int));\n extern bool avr_mem_flash_p (rtx);\n extern bool avr_mem_memx_p (rtx);\n extern bool avr_load_libgcc_p (rtx);\n-extern bool avr_xload_libgcc_p (enum machine_mode);\n+extern bool avr_xload_libgcc_p (machine_mode);\n extern rtx avr_eval_addr_attrib (rtx x);\n \n extern rtx lpm_reg_rtx;"}, {"sha": "bbd8644e7bc3bb8db7da4e9b84f3a30493005c79", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -161,8 +161,8 @@ static int get_sequence_length (rtx_insn *insns);\n static int sequent_regs_live (void);\n static const char *ptrreg_to_str (int);\n static const char *cond_string (enum rtx_code);\n-static int avr_num_arg_regs (enum machine_mode, const_tree);\n-static int avr_operand_rtx_cost (rtx, enum machine_mode, enum rtx_code,\n+static int avr_num_arg_regs (machine_mode, const_tree);\n+static int avr_operand_rtx_cost (rtx, machine_mode, enum rtx_code,\n                                  int, bool);\n static void output_reload_in_const (rtx*, rtx, int*, bool);\n static struct machine_function * avr_init_machine_status (void);\n@@ -283,7 +283,7 @@ avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n {\n   int i;\n \n-  enum machine_mode mode = GET_MODE (xval);\n+  machine_mode mode = GET_MODE (xval);\n \n   if (VOIDmode == mode)\n     mode = SImode;\n@@ -307,7 +307,7 @@ avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n rtx\n avr_to_int_mode (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   return VOIDmode == mode\n     ? x\n@@ -480,7 +480,7 @@ avr_regno_reg_class (int r)\n /* Implement `TARGET_SCALAR_MODE_SUPPORTED_P'.  */\n \n static bool\n-avr_scalar_mode_supported_p (enum machine_mode mode)\n+avr_scalar_mode_supported_p (machine_mode mode)\n {\n   if (ALL_FIXED_POINT_MODE_P (mode))\n     return true;\n@@ -832,7 +832,7 @@ avr_initial_elimination_offset (int from, int to)\n /* Helper for the function below.  */\n \n static void\n-avr_adjust_type_node (tree *node, enum machine_mode mode, int sat_p)\n+avr_adjust_type_node (tree *node, machine_mode mode, int sat_p)\n {\n   *node = make_node (FIXED_POINT_TYPE);\n   TYPE_SATURATING (*node) = sat_p;\n@@ -1749,7 +1749,7 @@ avr_reg_ok_for_addr_p (rtx reg, addr_space_t as,\n    machine for a memory operand of mode MODE.  */\n \n static bool\n-avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+avr_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   bool ok = CONSTANT_ADDRESS_P (x);\n \n@@ -1839,7 +1839,7 @@ avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    memory address for an operand of mode MODE  */\n \n static rtx\n-avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+avr_legitimize_address (rtx x, rtx oldx, machine_mode mode)\n {\n   bool big_offset_p = false;\n \n@@ -1880,7 +1880,7 @@ avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n    than 63 bytes or for R++ or --R addressing.  */\n \n rtx\n-avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n+avr_legitimize_reload_address (rtx *px, machine_mode mode,\n                                int opnum, int type, int addr_type,\n                                int ind_levels ATTRIBUTE_UNUSED,\n                                rtx (*mk_memloc)(rtx,int))\n@@ -1962,7 +1962,7 @@ avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n static reg_class_t\n avr_secondary_reload (bool in_p, rtx x,\n                       reg_class_t reload_class ATTRIBUTE_UNUSED,\n-                      enum machine_mode mode, secondary_reload_info *sri)\n+                      machine_mode mode, secondary_reload_info *sri)\n {\n   if (in_p\n       && MEM_P (x)\n@@ -2621,7 +2621,7 @@ avr_final_prescan_insn (rtx_insn *insn, rtx *operand ATTRIBUTE_UNUSED,\n /* Return 0 if undefined, 1 if always true or always false.  */\n \n int\n-avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)\n+avr_simplify_comparison_p (machine_mode mode, RTX_CODE op, rtx x)\n {\n   unsigned int max = (mode == QImode ? 0xff :\n                       mode == HImode ? 0xffff :\n@@ -2672,7 +2672,7 @@ avr_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,\n /* Returns the number of registers to allocate for a function argument.  */\n \n static int\n-avr_num_arg_regs (enum machine_mode mode, const_tree type)\n+avr_num_arg_regs (machine_mode mode, const_tree type)\n {\n   int size;\n \n@@ -2693,7 +2693,7 @@ avr_num_arg_regs (enum machine_mode mode, const_tree type)\n    in a register, and which register.  */\n \n static rtx\n-avr_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+avr_function_arg (cumulative_args_t cum_v, machine_mode mode,\n                   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2711,7 +2711,7 @@ avr_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    in the argument list.  */\n \n static void\n-avr_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+avr_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n                           const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2827,7 +2827,7 @@ avr_function_ok_for_sibcall (tree decl_callee, tree exp_callee)\n bool\n avr_load_libgcc_p (rtx op)\n {\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n   int n_bytes = GET_MODE_SIZE (mode);\n \n   return (n_bytes > 2\n@@ -2838,7 +2838,7 @@ avr_load_libgcc_p (rtx op)\n /* Return true if a value of mode MODE is read by __xload_* function.  */\n \n bool\n-avr_xload_libgcc_p (enum machine_mode mode)\n+avr_xload_libgcc_p (machine_mode mode)\n {\n   int n_bytes = GET_MODE_SIZE (mode);\n \n@@ -3204,7 +3204,7 @@ avr_out_xload (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n    IN / OUT instruction will be generated.  */\n \n bool\n-tiny_valid_direct_memory_access_range (rtx op, enum machine_mode mode)\n+tiny_valid_direct_memory_access_range (rtx op, machine_mode mode)\n {\n   rtx x;\n \n@@ -5218,7 +5218,7 @@ avr_out_compare (rtx_insn *insn, rtx *xop, int *plen)\n   rtx xval = xop[1];\n \n   /* MODE of the comparison.  */\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* Number of bytes to operate on.  */\n   int i, n_bytes = GET_MODE_SIZE (GET_MODE (xreg));\n@@ -7007,10 +7007,10 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n                 enum rtx_code code_sat, int sign, bool out_label)\n {\n   /* MODE of the operation.  */\n-  enum machine_mode mode = GET_MODE (xop[0]);\n+  machine_mode mode = GET_MODE (xop[0]);\n \n   /* INT_MODE of the same size.  */\n-  enum machine_mode imode = int_mode_for_mode (mode);\n+  machine_mode imode = int_mode_for_mode (mode);\n \n   /* Number of bytes to operate on.  */\n   int i, n_bytes = GET_MODE_SIZE (mode);\n@@ -7461,7 +7461,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n static const char*\n avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)\n {\n-  enum machine_mode mode = GET_MODE (xop[0]);\n+  machine_mode mode = GET_MODE (xop[0]);\n \n   /* Only pointer modes want to add symbols.  */\n \n@@ -7512,8 +7512,8 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)\n   rtx op[4];\n   rtx xpattern = INSN_P (insn) ? single_set (as_a <rtx_insn *> (insn)) : insn;\n   rtx xdest = SET_DEST (xpattern);\n-  enum machine_mode mode = GET_MODE (xdest);\n-  enum machine_mode imode = int_mode_for_mode (mode);\n+  machine_mode mode = GET_MODE (xdest);\n+  machine_mode imode = int_mode_for_mode (mode);\n   int n_bytes = GET_MODE_SIZE (mode);\n   enum rtx_code code_sat = GET_CODE (SET_SRC (xpattern));\n   enum rtx_code code\n@@ -7607,7 +7607,7 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)\n   /* CODE and MODE of the operation.  */\n   rtx xpattern = INSN_P (insn) ? single_set (as_a <rtx_insn *> (insn)) : insn;\n   enum rtx_code code = GET_CODE (SET_SRC (xpattern));\n-  enum machine_mode mode = GET_MODE (xop[0]);\n+  machine_mode mode = GET_MODE (xop[0]);\n \n   /* Number of bytes to operate on.  */\n   int i, n_bytes = GET_MODE_SIZE (mode);\n@@ -7884,7 +7884,7 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n \n   for (i = 0; i < sizeof (val) / sizeof (*val); i++)\n     {\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       xop[i] = operands[i];\n \n@@ -8378,8 +8378,8 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n const char*\n avr_out_round (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n {\n-  enum machine_mode mode = GET_MODE (xop[0]);\n-  enum machine_mode imode = int_mode_for_mode (mode);\n+  machine_mode mode = GET_MODE (xop[0]);\n+  machine_mode imode = int_mode_for_mode (mode);\n   // The smallest fractional bit not cleared by the rounding is 2^(-RP).\n   int fbit = (int) GET_MODE_FBIT (mode);\n   double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (xop[2]));\n@@ -8440,14 +8440,14 @@ bool\n avr_rotate_bytes (rtx operands[])\n {\n     int i, j;\n-    enum machine_mode mode = GET_MODE (operands[0]);\n+    machine_mode mode = GET_MODE (operands[0]);\n     bool overlapped = reg_overlap_mentioned_p (operands[0], operands[1]);\n     bool same_reg = rtx_equal_p (operands[0], operands[1]);\n     int num = INTVAL (operands[2]);\n     rtx scratch = operands[3];\n     /* Work out if byte or word move is needed.  Odd byte rotates need QImode.\n        Word move if no scratch is needed, otherwise use size of scratch.  */\n-    enum machine_mode move_mode = QImode;\n+    machine_mode move_mode = QImode;\n     int move_size, offset, size;\n \n     if (num & 0xf)\n@@ -9803,7 +9803,7 @@ avr_adjust_reg_alloc_order (void)\n /* Implement `TARGET_REGISTER_MOVE_COST' */\n \n static int\n-avr_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+avr_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n                         reg_class_t from, reg_class_t to)\n {\n   return (from == STACK_REG ? 6\n@@ -9815,7 +9815,7 @@ avr_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Implement `TARGET_MEMORY_MOVE_COST' */\n \n static int\n-avr_memory_move_cost (enum machine_mode mode,\n+avr_memory_move_cost (machine_mode mode,\n                       reg_class_t rclass ATTRIBUTE_UNUSED,\n                       bool in ATTRIBUTE_UNUSED)\n {\n@@ -9833,7 +9833,7 @@ avr_memory_move_cost (enum machine_mode mode,\n    operand's parent operator.  */\n \n static int\n-avr_operand_rtx_cost (rtx x, enum machine_mode mode, enum rtx_code outer,\n+avr_operand_rtx_cost (rtx x, machine_mode mode, enum rtx_code outer,\n \t\t      int opno, bool speed)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -9870,7 +9870,7 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n                  int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n   enum rtx_code code = (enum rtx_code) codearg;\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   HOST_WIDE_INT val;\n \n   switch (code)\n@@ -10717,7 +10717,7 @@ avr_rtx_costs (rtx x, int codearg, int outer_code,\n /* Implement `TARGET_ADDRESS_COST'.  */\n \n static int\n-avr_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n+avr_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n                   addr_space_t as ATTRIBUTE_UNUSED,\n                   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -10809,8 +10809,8 @@ avr_compare_pattern (rtx_insn *insn)\n       && SET_DEST (pattern) == cc0_rtx\n       && GET_CODE (SET_SRC (pattern)) == COMPARE)\n     {\n-      enum machine_mode mode0 = GET_MODE (XEXP (SET_SRC (pattern), 0));\n-      enum machine_mode mode1 = GET_MODE (XEXP (SET_SRC (pattern), 1));\n+      machine_mode mode0 = GET_MODE (XEXP (SET_SRC (pattern), 0));\n+      machine_mode mode1 = GET_MODE (XEXP (SET_SRC (pattern), 1));\n \n       /* The 64-bit comparisons have fixed operands ACC_A and ACC_B.\n          They must not be swapped, thus skip them.  */\n@@ -11056,7 +11056,7 @@ avr_reorg (void)\n               rtx x = XEXP (pattern, 1);\n               rtx src = SET_SRC (pat);\n               rtx t = XEXP (src,0);\n-              enum machine_mode mode = GET_MODE (XEXP (pattern, 0));\n+              machine_mode mode = GET_MODE (XEXP (pattern, 0));\n \n               if (avr_simplify_comparison_p (mode, GET_CODE (t), x))\n                 {\n@@ -11093,7 +11093,7 @@ avr_function_value_regno_p (const unsigned int regno)\n    library function returns a value of mode MODE.  */\n \n static rtx\n-avr_libcall_value (enum machine_mode mode,\n+avr_libcall_value (machine_mode mode,\n \t\t   const_rtx func ATTRIBUTE_UNUSED)\n {\n   int offs = GET_MODE_SIZE (mode);\n@@ -11216,7 +11216,7 @@ jump_over_one_insn_p (rtx_insn *insn, rtx dest)\n    (this way we don't have to check for odd registers everywhere).  */\n \n int\n-avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+avr_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   /* NOTE: 8-bit values must not be disallowed for R28 or R29.\n         Disallowing QI et al. in these regs might lead to code like\n@@ -11249,7 +11249,7 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n /* Implement `HARD_REGNO_CALL_PART_CLOBBERED'.  */\n \n int\n-avr_hard_regno_call_part_clobbered (unsigned regno, enum machine_mode mode)\n+avr_hard_regno_call_part_clobbered (unsigned regno, machine_mode mode)\n {\n   /* FIXME: This hook gets called with MODE:REGNO combinations that don't\n         represent valid hard registers like, e.g. HI:29.  Returning TRUE\n@@ -11271,7 +11271,7 @@ avr_hard_regno_call_part_clobbered (unsigned regno, enum machine_mode mode)\n /* Implement `MODE_CODE_BASE_REG_CLASS'.  */\n \n enum reg_class\n-avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+avr_mode_code_base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n                               addr_space_t as, RTX_CODE outer_code,\n                               RTX_CODE index_code ATTRIBUTE_UNUSED)\n {\n@@ -11291,7 +11291,7 @@ avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n bool\n avr_regno_mode_code_ok_for_base_p (int regno,\n-                                   enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                   machine_mode mode ATTRIBUTE_UNUSED,\n                                    addr_space_t as ATTRIBUTE_UNUSED,\n                                    RTX_CODE outer_code,\n                                    RTX_CODE index_code ATTRIBUTE_UNUSED)\n@@ -11376,7 +11376,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n   int clobber_val = 1234;\n   bool cooked_clobber_p = false;\n   bool set_p = false;\n-  enum machine_mode mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (dest);\n   int n, n_bytes = GET_MODE_SIZE (mode);\n \n   gcc_assert (REG_P (dest)\n@@ -11920,7 +11920,7 @@ avr_case_values_threshold (void)\n \n /* Implement `TARGET_ADDR_SPACE_ADDRESS_MODE'.  */\n \n-static enum machine_mode\n+static machine_mode\n avr_addr_space_address_mode (addr_space_t as)\n {\n   return avr_addrspace[as].pointer_size == 3 ? PSImode : HImode;\n@@ -11929,7 +11929,7 @@ avr_addr_space_address_mode (addr_space_t as)\n \n /* Implement `TARGET_ADDR_SPACE_POINTER_MODE'.  */\n \n-static enum machine_mode\n+static machine_mode\n avr_addr_space_pointer_mode (addr_space_t as)\n {\n   return avr_addr_space_address_mode (as);\n@@ -11963,7 +11963,7 @@ avr_reg_ok_for_pgm_addr (rtx reg, bool strict)\n /* Implement `TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P'.  */\n \n static bool\n-avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n+avr_addr_space_legitimate_address_p (machine_mode mode, rtx x,\n                                      bool strict, addr_space_t as)\n {\n   bool ok = false;\n@@ -12046,7 +12046,7 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n \n static rtx\n avr_addr_space_legitimize_address (rtx x, rtx old_x,\n-                                   enum machine_mode mode, addr_space_t as)\n+                                   machine_mode mode, addr_space_t as)\n {\n   if (ADDR_SPACE_GENERIC_P (as))\n     return avr_legitimize_address (x, old_x, mode);\n@@ -12213,7 +12213,7 @@ bool\n avr_emit_movmemhi (rtx *xop)\n {\n   HOST_WIDE_INT count;\n-  enum machine_mode loop_mode;\n+  machine_mode loop_mode;\n   addr_space_t as = MEM_ADDR_SPACE (xop[1]);\n   rtx loop_reg, addr1, a_src, a_dest, insn, xas;\n   rtx a_hi8 = NULL_RTX;\n@@ -12319,7 +12319,7 @@ const char*\n avr_out_movmem (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n {\n   addr_space_t as = (addr_space_t) INTVAL (op[0]);\n-  enum machine_mode loop_mode = GET_MODE (op[1]);\n+  machine_mode loop_mode = GET_MODE (op[1]);\n   bool sbiw_p = test_hard_reg_class (ADDW_REGS, op[1]);\n   rtx xop[3];\n \n@@ -13048,7 +13048,7 @@ avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, xop[3];\n   int n, n_args = call_expr_nargs (exp);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n \n   gcc_assert (n_args >= 1 && n_args <= 3);\n \n@@ -13063,8 +13063,8 @@ avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n     {\n       tree arg = CALL_EXPR_ARG (exp, n);\n       rtx op = expand_expr (arg, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      enum machine_mode opmode = GET_MODE (op);\n-      enum machine_mode mode = insn_data[icode].operand[n+1].mode;\n+      machine_mode opmode = GET_MODE (op);\n+      machine_mode mode = insn_data[icode].operand[n+1].mode;\n \n       if ((opmode == SImode || opmode == VOIDmode) && mode == HImode)\n         {\n@@ -13112,7 +13112,7 @@ avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n static rtx\n avr_expand_builtin (tree exp, rtx target,\n                     rtx subtarget ATTRIBUTE_UNUSED,\n-                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                    machine_mode mode ATTRIBUTE_UNUSED,\n                     int ignore)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);"}, {"sha": "a2c3872c94847b942707ac67df0d1851a7005cf1", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1075,7 +1075,7 @@\n   \"\"\n   {\n     rtx addr0;\n-    enum machine_mode mode;\n+    machine_mode mode;\n \n     /* If value to set is not zero, use the library routine.  */\n     if (operands[2] != const0_rtx)"}, {"sha": "14f5c36bf7fe3b73ba0d87d962c18f8d7387f983", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -71,34 +71,34 @@ extern char *bfin_asm_long (void);\n extern char *bfin_asm_short (void);\n extern int log2constp (unsigned HOST_WIDE_INT);\n \n-extern int hard_regno_mode_ok (int, enum machine_mode);\n+extern int hard_regno_mode_ok (int, machine_mode);\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\t  \n extern HOST_WIDE_INT bfin_initial_elimination_offset (int, int);\n \n-extern int effective_address_32bit_p (rtx, enum machine_mode);\n+extern int effective_address_32bit_p (rtx, machine_mode);\n extern int symbolic_reference_mentioned_p (rtx);\n-extern rtx bfin_gen_compare (rtx, enum machine_mode);\n-extern bool expand_move (rtx *, enum machine_mode);\n+extern rtx bfin_gen_compare (rtx, machine_mode);\n+extern bool expand_move (rtx *, machine_mode);\n extern void bfin_expand_call (rtx, rtx, rtx, rtx, int);\n extern bool bfin_longcall_p (rtx, int);\n extern bool bfin_dsp_memref_p (rtx);\n extern bool bfin_expand_movmem (rtx, rtx, rtx, rtx);\n \n extern enum reg_class secondary_input_reload_class (enum reg_class,\n-\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t    rtx);\n extern enum reg_class secondary_output_reload_class (enum reg_class,\n-\t\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t\t     machine_mode,\n \t\t\t\t\t\t     rtx);\n extern char *section_asm_op_1 (SECT_ENUM_T);\n extern char *section_asm_op (SECT_ENUM_T);\n extern void print_operand (FILE *,  rtx, char);\n extern void print_address_operand (FILE *, rtx);\n extern void split_di (rtx [], int, rtx [], rtx []);\n extern int split_load_immediate (rtx []);\n-extern void emit_pic_move (rtx *, enum machine_mode);\n+extern void emit_pic_move (rtx *, machine_mode);\n extern void asm_conditional_branch (rtx_insn *, rtx *, int, int);\n-extern rtx bfin_gen_compare (rtx, enum machine_mode);\n+extern rtx bfin_gen_compare (rtx, machine_mode);\n \n extern unsigned bfin_local_alignment (tree, unsigned);\n extern rtx bfin_va_arg (tree, tree);"}, {"sha": "4c9ce5733b2c564ed0a0f821ea35fb8bb2972de8", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -582,7 +582,7 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n \n static void\n setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\ttree type ATTRIBUTE_UNUSED, int *pretend_size,\n \t\t\tint no_rtl)\n {\n@@ -1256,7 +1256,7 @@ bfin_delegitimize_address (rtx orig_x)\n    32-bit instruction.  */\n \n int\n-effective_address_32bit_p (rtx op, enum machine_mode mode) \n+effective_address_32bit_p (rtx op, machine_mode mode) \n {\n   HOST_WIDE_INT offset;\n \n@@ -1310,7 +1310,7 @@ bfin_dsp_memref_p (rtx x)\n \n static int\n bfin_address_cost (rtx addr ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -1358,7 +1358,7 @@ print_address_operand (FILE *file, rtx x)\n void\n print_operand (FILE *file, rtx x, char code)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (code == '!')\n     {\n@@ -1673,7 +1673,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-bfin_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+bfin_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1713,7 +1713,7 @@ bfin_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-bfin_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+bfin_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1743,7 +1743,7 @@ bfin_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    stack.   */\n \n static int\n-bfin_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n+bfin_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \t\t\ttree type ATTRIBUTE_UNUSED,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -1765,7 +1765,7 @@ bfin_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n \n static bool\n bfin_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n@@ -1930,7 +1930,7 @@ bfin_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n /* Emit insns to move operands[1] into operands[0].  */\n \n void\n-emit_pic_move (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n+emit_pic_move (rtx *operands, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n \n@@ -1948,7 +1948,7 @@ emit_pic_move (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n    should generate an insn to move OPERANDS[1] to OPERANDS[0].  */\n \n bool\n-expand_move (rtx *operands, enum machine_mode mode)\n+expand_move (rtx *operands, machine_mode mode)\n {\n   rtx op = operands[1];\n   if ((TARGET_ID_SHARED_LIBRARY || TARGET_FDPIC)\n@@ -2139,7 +2139,7 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n /* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n int\n-hard_regno_mode_ok (int regno, enum machine_mode mode)\n+hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   /* Allow only dregs to store value of mode HI or QI */\n   enum reg_class rclass = REGNO_REG_CLASS (regno);\n@@ -2169,15 +2169,15 @@ hard_regno_mode_ok (int regno, enum machine_mode mode)\n /* Implements target hook vector_mode_supported_p.  */\n \n static bool\n-bfin_vector_mode_supported_p (enum machine_mode mode)\n+bfin_vector_mode_supported_p (machine_mode mode)\n {\n   return mode == V2HImode;\n }\n \n /* Worker function for TARGET_REGISTER_MOVE_COST.  */\n \n static int\n-bfin_register_move_cost (enum machine_mode mode,\n+bfin_register_move_cost (machine_mode mode,\n \t\t\t reg_class_t class1, reg_class_t class2)\n {\n   /* These need secondary reloads, so they're more expensive.  */\n@@ -2208,7 +2208,7 @@ bfin_register_move_cost (enum machine_mode mode,\n    program; it'll make the costs more accurate.  */\n \n static int\n-bfin_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+bfin_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       reg_class_t rclass,\n \t\t       bool in ATTRIBUTE_UNUSED)\n {\n@@ -2227,7 +2227,7 @@ bfin_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n static reg_class_t\n bfin_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n-\t\t       enum machine_mode mode, secondary_reload_info *sri)\n+\t\t       machine_mode mode, secondary_reload_info *sri)\n {\n   /* If we have HImode or QImode, we can only use DREGS as secondary registers;\n      in most other cases we can also use PREGS.  */\n@@ -2511,7 +2511,7 @@ asm_conditional_branch (rtx_insn *insn, rtx *operands, int n_nops, int predict_t\n    stored in bfin_compare_op0 and bfin_compare_op1 already.  */\n \n rtx\n-bfin_gen_compare (rtx cmp, enum machine_mode mode ATTRIBUTE_UNUSED)\n+bfin_gen_compare (rtx cmp, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code1, code2;\n   rtx op0 = XEXP (cmp, 0), op1 = XEXP (cmp, 1);\n@@ -2681,7 +2681,7 @@ split_load_immediate (rtx operands[])\n    MODE.  Return false if not.  */\n \n static bool\n-bfin_valid_add (enum machine_mode mode, HOST_WIDE_INT value)\n+bfin_valid_add (machine_mode mode, HOST_WIDE_INT value)\n {\n   unsigned HOST_WIDE_INT v = value > 0 ? value : -value;\n   int sz = GET_MODE_SIZE (mode);\n@@ -2694,7 +2694,7 @@ bfin_valid_add (enum machine_mode mode, HOST_WIDE_INT value)\n }\n \n static bool\n-bfin_valid_reg_p (unsigned int regno, int strict, enum machine_mode mode,\n+bfin_valid_reg_p (unsigned int regno, int strict, machine_mode mode,\n \t\t  enum rtx_code outer_code)\n {\n   if (strict)\n@@ -2722,7 +2722,7 @@ bfin_valid_reg_p (unsigned int regno, int strict, enum machine_mode mode,\n */\n \n static bool\n-bfin_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+bfin_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   switch (GET_CODE (x)) {\n   case REG:\n@@ -2761,7 +2761,7 @@ bfin_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    another way.  */\n \n static bool\n-bfin_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n+bfin_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     rtx x ATTRIBUTE_UNUSED)\n {\n   /* We have only one class of non-legitimate constants, and our movsi\n@@ -2777,7 +2777,7 @@ bfin_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n    crossing section boundaries.  */\n \n static bool\n-bfin_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+bfin_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   rtx sym;\n   HOST_WIDE_INT offset;\n@@ -3196,7 +3196,7 @@ output_pop_multiple (rtx insn, rtx *operands)\n /* Adjust DST and SRC by OFFSET bytes, and generate one move in mode MODE.  */\n \n static void\n-single_move_for_movmem (rtx dst, rtx src, enum machine_mode mode, HOST_WIDE_INT offset)\n+single_move_for_movmem (rtx dst, rtx src, machine_mode mode, HOST_WIDE_INT offset)\n {\n   rtx scratch = gen_reg_rtx (mode);\n   rtx srcmem, dstmem;\n@@ -5348,7 +5348,7 @@ static const struct builtin_description bdesc_1arg[] =\n    where we expect a vector.  To avoid crashing, use one of the vector\n    clear instructions.  */\n static rtx\n-safe_vector_operand (rtx x, enum machine_mode mode)\n+safe_vector_operand (rtx x, machine_mode mode)\n {\n   if (x != const0_rtx)\n     return x;\n@@ -5370,11 +5370,11 @@ bfin_expand_binop_builtin (enum insn_code icode, tree exp, rtx target,\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode op1mode = GET_MODE (op1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode op0mode = GET_MODE (op0);\n+  machine_mode op1mode = GET_MODE (op1);\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n \n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n@@ -5426,9 +5426,9 @@ bfin_expand_unop_builtin (enum insn_code icode, tree exp,\n   rtx pat;\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode op0mode = GET_MODE (op0);\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n \n   if (! target\n       || GET_MODE (target) != tmode\n@@ -5464,7 +5464,7 @@ bfin_expand_unop_builtin (enum insn_code icode, tree exp,\n static rtx\n bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t     rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   size_t i;\n@@ -5474,7 +5474,7 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0, arg1, arg2;\n   rtx op0, op1, op2, accvec, pat, tmp1, tmp2, a0reg, a1reg;\n-  enum machine_mode tmode, mode0;\n+  machine_mode tmode, mode0;\n \n   switch (fcode)\n     {"}, {"sha": "5e58ee34d9dc49ea503aba1c973e85f0587fc7d8", "filename": "gcc/config/c6x/c6x-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -25,15 +25,15 @@\n \n #ifdef RTX_CODE\n extern void c6x_init_cumulative_args (CUMULATIVE_ARGS *, const_tree, rtx, int);\n-extern bool c6x_block_reg_pad_upward (enum machine_mode, const_tree, bool);\n+extern bool c6x_block_reg_pad_upward (machine_mode, const_tree, bool);\n \n-extern bool c6x_legitimate_address_p_1 (enum machine_mode, rtx, bool, bool);\n+extern bool c6x_legitimate_address_p_1 (machine_mode, rtx, bool, bool);\n extern bool c6x_mem_operand (rtx, enum reg_class, bool);\n-extern bool expand_move (rtx *, enum machine_mode);\n+extern bool expand_move (rtx *, machine_mode);\n \n extern bool c6x_long_call_p (rtx);\n extern void c6x_expand_call (rtx, rtx, bool);\n-extern rtx c6x_expand_compare (rtx, enum machine_mode);\n+extern rtx c6x_expand_compare (rtx, machine_mode);\n extern bool c6x_force_op_for_comparison_p (enum rtx_code, rtx);\n extern bool c6x_expand_movmem (rtx, rtx, rtx, rtx, rtx, rtx);\n "}, {"sha": "06319d0306d755ba7736c452ec6bb22aa5be0753", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -517,7 +517,7 @@ c6x_init_cumulative_args (CUMULATIVE_ARGS *cum, const_tree fntype, rtx libname,\n /* Implements the macro FUNCTION_ARG defined in c6x.h.  */\n \n static rtx\n-c6x_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+c6x_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -543,7 +543,7 @@ c6x_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \n static void\n c6x_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -556,7 +556,7 @@ c6x_function_arg_advance (cumulative_args_t cum_v,\n    upward rather than downward.  */\n \n bool\n-c6x_block_reg_pad_upward (enum machine_mode mode ATTRIBUTE_UNUSED,\n+c6x_block_reg_pad_upward (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type, bool first)\n {\n   HOST_WIDE_INT size;\n@@ -574,7 +574,7 @@ c6x_block_reg_pad_upward (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  */\n \n static unsigned int\n-c6x_function_arg_boundary (enum machine_mode mode, const_tree type)\n+c6x_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   unsigned int boundary = type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode);\n \n@@ -599,7 +599,7 @@ c6x_function_arg_boundary (enum machine_mode mode, const_tree type)\n \n /* Implement TARGET_FUNCTION_ARG_ROUND_BOUNDARY.  */\n static unsigned int\n-c6x_function_arg_round_boundary (enum machine_mode mode, const_tree type)\n+c6x_function_arg_round_boundary (machine_mode mode, const_tree type)\n {\n   return c6x_function_arg_boundary (mode, type);\n }\n@@ -632,7 +632,7 @@ c6x_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED,\n /* Implement TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-c6x_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+c6x_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, REG_A4);\n }\n@@ -658,7 +658,7 @@ c6x_function_value_regno_p (const unsigned int regno)\n \n static bool\n c6x_pass_by_reference (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode, const_tree type,\n+\t\t       machine_mode mode, const_tree type,\n \t\t       bool named ATTRIBUTE_UNUSED)\n {\n   int size = -1;\n@@ -694,7 +694,7 @@ c6x_return_in_msb (const_tree valtype)\n \n static bool\n c6x_callee_copies (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n {\n@@ -912,7 +912,7 @@ c6x_in_small_data_p (const_tree exp)\n    everything sized 8 bytes or smaller into small data.  */\n \n static section *\n-c6x_select_rtx_section (enum machine_mode mode, rtx x,\n+c6x_select_rtx_section (machine_mode mode, rtx x,\n \t\t\tunsigned HOST_WIDE_INT align)\n {\n   if (c6x_sdata_mode == C6X_SDATA_ALL\n@@ -1110,7 +1110,7 @@ c6x_call_saved_register_used (tree call_expr)\n   cumulative_args_t cum;\n   HARD_REG_SET call_saved_regset;\n   tree parameter;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree type;\n   rtx parm_rtx;\n   int i;\n@@ -1375,7 +1375,7 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n    should generate an insn to move OPERANDS[1] to OPERANDS[0].  */\n \n bool\n-expand_move (rtx *operands, enum machine_mode mode)\n+expand_move (rtx *operands, machine_mode mode)\n {\n   rtx dest = operands[0];\n   rtx op = operands[1];\n@@ -1438,14 +1438,14 @@ c6x_force_op_for_comparison_p (enum rtx_code code, rtx op)\n    that should be used in the jump insn.  */\n \n rtx\n-c6x_expand_compare (rtx comparison, enum machine_mode mode)\n+c6x_expand_compare (rtx comparison, machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (comparison);\n   rtx op0 = XEXP (comparison, 0);\n   rtx op1 = XEXP (comparison, 1);\n   rtx cmp;\n   enum rtx_code jump_code = code;\n-  enum machine_mode op_mode = GET_MODE (op0);\n+  machine_mode op_mode = GET_MODE (op0);\n \n   if (op_mode == DImode && (code == NE || code == EQ) && op1 == const0_rtx)\n     {\n@@ -1642,7 +1642,7 @@ rtx\n c6x_subword (rtx op, bool high_p)\n {\n   unsigned int byte;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = GET_MODE (op);\n   if (mode == VOIDmode)\n@@ -1762,7 +1762,7 @@ c6x_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   while (count > 0)\n     {\n       rtx reg, reg_lowpart;\n-      enum machine_mode srcmode, dstmode;\n+      machine_mode srcmode, dstmode;\n       unsigned HOST_WIDE_INT src_size, dst_size, src_left;\n       int shift;\n       rtx srcmem, dstmem;\n@@ -1852,7 +1852,7 @@ c6x_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n    use the scaled form.  */\n \n static void\n-print_address_offset (FILE *file, rtx off, enum machine_mode mem_mode)\n+print_address_offset (FILE *file, rtx off, machine_mode mem_mode)\n {\n   rtx pat;\n \n@@ -1891,7 +1891,7 @@ static void c6x_print_operand (FILE *, rtx, int);\n /* Subroutine of c6x_print_operand; used to print a memory reference X to FILE.  */\n \n static void\n-c6x_print_address_operand (FILE *file, rtx x, enum machine_mode mem_mode)\n+c6x_print_address_operand (FILE *file, rtx x, machine_mode mem_mode)\n {\n   rtx off;\n   switch (GET_CODE (x))\n@@ -2107,7 +2107,7 @@ c6x_print_operand (FILE *file, rtx x, int code)\n   int i;\n   HOST_WIDE_INT v;\n   tree t;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (code == '|')\n     {\n@@ -2328,7 +2328,7 @@ c6x_print_operand (FILE *file, rtx x, int code)\n bool\n c6x_mem_operand (rtx op, enum reg_class c, bool small_offset)\n {\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n   rtx base = XEXP (op, 0);\n   switch (GET_CODE (base))\n     {\n@@ -2372,7 +2372,7 @@ c6x_mem_operand (rtx op, enum reg_class c, bool small_offset)\n    recursively examining an operand inside a PRE/POST_MODIFY.  */\n \n bool\n-c6x_legitimate_address_p_1 (enum machine_mode mode, rtx x, bool strict,\n+c6x_legitimate_address_p_1 (machine_mode mode, rtx x, bool strict,\n \t\t\t    bool no_large_offset)\n {\n   int size, size1;\n@@ -2480,13 +2480,13 @@ c6x_legitimate_address_p_1 (enum machine_mode mode, rtx x, bool strict,\n }\n \n static bool\n-c6x_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+c6x_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   return c6x_legitimate_address_p_1 (mode, x, strict, false);\n }\n \n static bool\n-c6x_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+c6x_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   rtx x ATTRIBUTE_UNUSED)\n {\n   return true;\n@@ -2834,7 +2834,7 @@ c6x_expand_prologue (void)\n \t  int idx = N_SAVE_ORDER - i - 1;\n \t  unsigned regno = reg_save_order[idx];\n \t  rtx reg;\n-\t  enum machine_mode save_mode = SImode;\n+\t  machine_mode save_mode = SImode;\n \n \t  if (regno == REG_A15 && frame_pointer_needed)\n \t    /* Already saved.  */\n@@ -2926,7 +2926,7 @@ c6x_expand_epilogue (bool sibcall)\n \t{\n \t  unsigned regno = reg_save_order[i];\n \t  rtx reg;\n-\t  enum machine_mode save_mode = SImode;\n+\t  machine_mode save_mode = SImode;\n \n \t  if (!c6x_save_reg (regno))\n \t    continue;\n@@ -6236,7 +6236,7 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n /* Implements target hook vector_mode_supported_p.  */\n \n static bool\n-c6x_vector_mode_supported_p (enum machine_mode mode)\n+c6x_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -6252,8 +6252,8 @@ c6x_vector_mode_supported_p (enum machine_mode mode)\n }\n \n /* Implements TARGET_VECTORIZE_PREFERRED_SIMD_MODE.  */\n-static enum machine_mode\n-c6x_preferred_simd_mode (enum machine_mode mode)\n+static machine_mode\n+c6x_preferred_simd_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -6270,7 +6270,7 @@ c6x_preferred_simd_mode (enum machine_mode mode)\n /* Implement TARGET_SCALAR_MODE_SUPPORTED_P.  */\n \n static bool\n-c6x_scalar_mode_supported_p (enum machine_mode mode)\n+c6x_scalar_mode_supported_p (machine_mode mode)\n {\n   if (ALL_FIXED_POINT_MODE_P (mode)\n       && GET_MODE_PRECISION (mode) <= 2 * BITS_PER_WORD)\n@@ -6550,7 +6550,7 @@ static const struct builtin_description bdesc_1arg[] =\n    where we expect a vector.  To avoid crashing, use one of the vector\n    clear instructions.  */\n static rtx\n-safe_vector_operand (rtx x, enum machine_mode mode)\n+safe_vector_operand (rtx x, machine_mode mode)\n {\n   if (x != const0_rtx)\n     return x;\n@@ -6573,11 +6573,11 @@ c6x_expand_binop_builtin (enum insn_code icode, tree exp, rtx target,\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n   rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode op1mode = GET_MODE (op1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1 + offs].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2 + offs].mode;\n+  machine_mode op0mode = GET_MODE (op0);\n+  machine_mode op1mode = GET_MODE (op1);\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1 + offs].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2 + offs].mode;\n   rtx ret = target;\n \n   if (VECTOR_MODE_P (mode0))\n@@ -6642,9 +6642,9 @@ c6x_expand_unop_builtin (enum insn_code icode, tree exp,\n   rtx pat;\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-  enum machine_mode op0mode = GET_MODE (op0);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode op0mode = GET_MODE (op0);\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n \n   if (! target\n       || GET_MODE (target) != tmode\n@@ -6680,7 +6680,7 @@ c6x_expand_unop_builtin (enum insn_code icode, tree exp,\n static rtx\n c6x_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t     rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   size_t i;"}, {"sha": "0567486015dcd494ece358e9f36d521ccd6a60ab", "filename": "gcc/config/c6x/c6x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fc6x%2Fc6x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -469,7 +469,7 @@\n   [(set (match_dup 2) (match_dup 3))]\n {\n   unsigned HOST_WIDE_INT mask, val;\n-  enum machine_mode inner_mode = GET_MODE_INNER (<MODE>mode);\n+  machine_mode inner_mode = GET_MODE_INNER (<MODE>mode);\n   int i;\n \n   val = 0;\n@@ -505,7 +505,7 @@\n   unsigned HOST_WIDE_INT mask;\n   unsigned HOST_WIDE_INT val[2];\n   rtx lo_half, hi_half;\n-  enum machine_mode inner_mode = GET_MODE_INNER (<MODE>mode);\n+  machine_mode inner_mode = GET_MODE_INNER (<MODE>mode);\n   int i, j;\n \n   split_di (operands, 1, &lo_half, &hi_half);"}, {"sha": "196b60e50db06ecba5522025918a0a7d6e119603", "filename": "gcc/config/cr16/cr16-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -23,7 +23,7 @@\n \n /* Register usage.  */\n extern enum reg_class cr16_regno_reg_class (int);\n-extern int cr16_hard_regno_mode_ok (int regno, enum machine_mode);\n+extern int cr16_hard_regno_mode_ok (int regno, machine_mode);\n \n /* Passing function arguments.  */\n extern int cr16_function_arg_regno_p (int);\n@@ -79,7 +79,7 @@ extern enum cr16_addrtype cr16_decompose_address (rtx addr,\n \t\t\t\t\t\t  bool treat_as_const);\n extern int cr16_const_double_ok (rtx op);\n extern int legitimate_pic_operand_p (rtx);\n-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx legitimize_pic_address (rtx, machine_mode, rtx);\n \n \n /* Prologue/Epilogue functions.  */"}, {"sha": "be7d663721df9c85135baae7b2f2185946017f77", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -479,7 +479,7 @@ cr16_regno_reg_class (int regno)\n \n /* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n int\n-cr16_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+cr16_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   if ((GET_MODE_SIZE (mode) >= 4) && (regno == 11))\n     return 0;\n@@ -528,7 +528,7 @@ cr16_function_value_regno_p (const unsigned int regno)\n /* Create an RTX representing the place where a\n    library function returns a value of mode MODE.  */\n static rtx\n-cr16_libcall_value (enum machine_mode mode,\n+cr16_libcall_value (machine_mode mode,\n \t\t    const_rtx func ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, cr16_ret_register ());\n@@ -550,7 +550,7 @@ cr16_function_value (const_tree type,\n    the number of registers needed else 0.  */\n static int\n enough_regs_for_param (CUMULATIVE_ARGS * cum, const_tree type,\n-\t\t       enum machine_mode mode)\n+\t\t       machine_mode mode)\n {\n   int type_size;\n   int remaining_size;\n@@ -574,7 +574,7 @@ enough_regs_for_param (CUMULATIVE_ARGS * cum, const_tree type,\n \n /* Implements the macro FUNCTION_ARG defined in cr16.h.  */\n static rtx\n-cr16_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+cr16_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -641,7 +641,7 @@ cr16_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n \n /* Implements the macro FUNCTION_ARG_ADVANCE defined in cr16.h.  */\n static void\n-cr16_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+cr16_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS * cum = get_cumulative_args (cum_v);\n@@ -1170,7 +1170,7 @@ legitimate_pic_operand_p (rtx x)\n      NOTE: @BRO is added using unspec:BRO\n      NOTE: @GOT is added using unspec:GOT.  */\n rtx\n-legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\trtx reg)\n {\n   /* First handle a simple SYMBOL_REF or LABEL_REF.  */\n@@ -1223,7 +1223,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Implementation of TARGET_LEGITIMATE_ADDRESS_P.  */\n static bool\n-cr16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+cr16_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   rtx addr, bool strict)\n {\n   enum cr16_addrtype addrtype;\n@@ -1302,7 +1302,7 @@ cr16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Return cost of the memory address x.  */\n static int\n-cr16_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n+cr16_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -1354,7 +1354,7 @@ cr16_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Implement `TARGET_REGISTER_MOVE_COST'.  */\n static int\n-cr16_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+cr16_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t reg_class_t from ATTRIBUTE_UNUSED, reg_class_t to)\n {\n   return (to != GENERAL_REGS ? 8 : 2);\n@@ -1367,7 +1367,7 @@ cr16_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    nonzero if it is to be read in. This cost is relative to those in\n    REGISTER_MOVE_COST.  */\n static int\n-cr16_memory_move_cost (enum machine_mode mode,\n+cr16_memory_move_cost (machine_mode mode,\n \t\t       reg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t       bool in ATTRIBUTE_UNUSED)\n {\n@@ -1819,7 +1819,7 @@ cr16_create_dwarf_for_multi_push (rtx insn)\n {\n   rtx dwarf, reg, tmp;\n   int i, j, from, to, word_cnt, dwarf_par_index, inc;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int num_regs = 0, offset = 0, split_here = 0, total_push_bytes = 0;\n \n   for (i = 0; i <= current_frame_info.last_reg_to_save; ++i)\n@@ -2061,7 +2061,7 @@ cr16_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n    it should assign X (which will always be a C variable) a new value.  */\n static rtx\n cr16_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic)\n     return legitimize_pic_address (orig_x, mode, NULL_RTX);\n@@ -2075,7 +2075,7 @@ cr16_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n    satisfies CONSTANT_P. In cr16c treat legitimize float \n    constant as an immediate operand.  */\n static bool\n-cr16_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+cr16_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    rtx x ATTRIBUTE_UNUSED)\n {\n   return 1;\n@@ -2112,7 +2112,7 @@ notice_update_cc (rtx exp)\n   return;\n }\n \n-static enum machine_mode\n+static machine_mode\n cr16_unwind_word_mode (void)\n {\n   return SImode;"}, {"sha": "3796d30a97f941d0cfd7736b385a5ff13e29ae55", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -24,7 +24,7 @@ extern bool cris_simple_epilogue (void);\n #ifdef RTX_CODE\n extern const char *cris_op_str (rtx);\n extern void cris_notice_update_cc (rtx, rtx_insn *);\n-extern bool cris_reload_address_legitimized (rtx, enum machine_mode, int, int, int);\n+extern bool cris_reload_address_legitimized (rtx, machine_mode, int, int, int);\n extern int cris_side_effect_mode_ok (enum rtx_code, rtx *, int, int,\n                                      int, int, int);\n extern bool cris_cc0_user_requires_cmp (rtx);\n@@ -33,13 +33,13 @@ extern rtx cris_split_movdx (rtx *);\n extern int cris_legitimate_pic_operand (rtx);\n extern enum cris_symbol_type cris_symbol_type_of (const_rtx);\n extern bool cris_valid_pic_const (const_rtx, bool);\n-extern bool cris_legitimate_constant_p (enum machine_mode, rtx);\n+extern bool cris_legitimate_constant_p (machine_mode, rtx);\n extern bool cris_constant_index_p (const_rtx);\n extern bool cris_base_p (const_rtx, bool);\n extern bool cris_base_or_autoincr_p (const_rtx, bool);\n extern bool cris_bdap_index_p (const_rtx, bool);\n extern bool cris_biap_index_p (const_rtx, bool);\n-extern bool cris_legitimate_address_p (enum machine_mode, rtx, bool);\n+extern bool cris_legitimate_address_p (machine_mode, rtx, bool);\n extern bool cris_store_multiple_op_p (rtx);\n extern bool cris_movem_load_rest_p (rtx, int);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);"}, {"sha": "bb2578cf376816e12c88b49c06e2a09dfe295600", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -109,10 +109,10 @@ static int in_code = 0;\n /* Fix for reg_overlap_mentioned_p.  */\n static int cris_reg_overlap_mentioned_p (rtx, rtx);\n \n-static enum machine_mode cris_promote_function_mode (const_tree, enum machine_mode,\n+static machine_mode cris_promote_function_mode (const_tree, machine_mode,\n \t\t\t\t\t\t     int *, const_tree, int);\n \n-static unsigned int cris_atomic_align_for_mode (enum machine_mode);\n+static unsigned int cris_atomic_align_for_mode (machine_mode);\n \n static void cris_print_base (rtx, FILE *);\n \n@@ -124,7 +124,7 @@ static struct machine_function * cris_init_machine_status (void);\n \n static rtx cris_struct_value_rtx (tree, int);\n \n-static void cris_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static void cris_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree type, int *, int);\n \n static int cris_initial_frame_pointer_offset (void);\n@@ -151,22 +151,22 @@ static void cris_init_libfuncs (void);\n \n static reg_class_t cris_preferred_reload_class (rtx, reg_class_t);\n \n-static int cris_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n-static int cris_memory_move_cost (enum machine_mode, reg_class_t, bool);\n+static int cris_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n+static int cris_memory_move_cost (machine_mode, reg_class_t, bool);\n static bool cris_rtx_costs (rtx, int, int, int, int *, bool);\n-static int cris_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n-static bool cris_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static int cris_address_cost (rtx, machine_mode, addr_space_t, bool);\n+static bool cris_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int cris_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static int cris_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx cris_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx cris_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static rtx cris_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t       enum machine_mode, const_tree, bool);\n-static void cris_function_arg_advance (cumulative_args_t, enum machine_mode,\n+\t\t\t\t       machine_mode, const_tree, bool);\n+static void cris_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static tree cris_md_asm_clobbers (tree, tree, tree);\n-static bool cris_cannot_force_const_mem (enum machine_mode, rtx);\n+static bool cris_cannot_force_const_mem (machine_mode, rtx);\n \n static void cris_option_override (void);\n \n@@ -176,7 +176,7 @@ static void cris_asm_trampoline_template (FILE *);\n static void cris_trampoline_init (rtx, tree, rtx);\n \n static rtx cris_function_value(const_tree, const_tree, bool);\n-static rtx cris_libcall_value (enum machine_mode, const_rtx);\n+static rtx cris_libcall_value (machine_mode, const_rtx);\n static bool cris_function_value_regno_p (const unsigned int);\n static void cris_file_end (void);\n \n@@ -538,7 +538,7 @@ cris_cfun_uses_pic_table (void)\n    can be reached as pc-relative as we can't tell when or how to do that.  */\n \n static bool\n-cris_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+cris_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum cris_symbol_type t = cris_symbol_type_of (x);\n \n@@ -1466,7 +1466,7 @@ cris_biap_index_p (const_rtx x, bool strict)\n    symbol is valid for the plain \"symbol + offset\" case.  */\n \n bool\n-cris_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+cris_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   const_rtx x1, x2;\n \n@@ -1517,7 +1517,7 @@ cris_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    so don't bother; fix the documentation instead.  */\n \n bool\n-cris_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+cris_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum cris_symbol_type t;\n \n@@ -1536,7 +1536,7 @@ cris_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \n bool\n cris_reload_address_legitimized (rtx x,\n-\t\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t int opnum ATTRIBUTE_UNUSED,\n \t\t\t\t int itype,\n \t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n@@ -1636,7 +1636,7 @@ cris_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, reg_class_t rclass)\n /* Worker function for TARGET_REGISTER_MOVE_COST.  */\n \n static int\n-cris_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+cris_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t reg_class_t from, reg_class_t to)\n {\n   /* Can't move to and from a SPECIAL_REGS register, so we have to say\n@@ -1674,7 +1674,7 @@ cris_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    suffice.  */\n \n static int\n-cris_memory_move_cost (enum machine_mode mode,\n+cris_memory_move_cost (machine_mode mode,\n                        reg_class_t rclass ATTRIBUTE_UNUSED,\n                        bool in ATTRIBUTE_UNUSED)\n {\n@@ -2220,7 +2220,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n /* The ADDRESS_COST worker.  */\n \n static int\n-cris_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n+cris_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -2883,7 +2883,7 @@ cris_init_machine_status (void)\n rtx\n cris_split_movdx (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n   rtx val;\n@@ -4055,7 +4055,7 @@ cris_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n \n static void\n cris_setup_incoming_varargs (cumulative_args_t ca_v,\n-\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_arg_size,\n \t\t\t     int second_time)\n@@ -4080,7 +4080,7 @@ cris_setup_incoming_varargs (cumulative_args_t ca_v,\n \n static bool\n cris_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode, const_tree type,\n+\t\t\tmachine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   return (targetm.calls.must_pass_in_stack (mode, type)\n@@ -4091,9 +4091,9 @@ cris_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n    and *not* defining TARGET_PROMOTE_PROTOTYPES or PROMOTE_MODE gives the\n    best code size and speed for gcc, ipps and products in gcc-2.7.2.  */\n \n-enum machine_mode\n+machine_mode\n cris_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n-                            enum machine_mode mode,\n+                            machine_mode mode,\n                             int *punsignedp ATTRIBUTE_UNUSED,\n \t\t\t    const_tree fntype ATTRIBUTE_UNUSED,\n                             int for_return)\n@@ -4109,7 +4109,7 @@ cris_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n /* Atomic types require alignment to be at least their \"natural\" size.  */\n \n static unsigned int\n-cris_atomic_align_for_mode (enum machine_mode mode)\n+cris_atomic_align_for_mode (machine_mode mode)\n {\n   return GET_MODE_BITSIZE (mode);\n }\n@@ -4129,7 +4129,7 @@ cris_function_value(const_tree type,\n    time being.  */\n \n static rtx\n-cris_libcall_value (enum machine_mode mode,\n+cris_libcall_value (machine_mode mode,\n \t\t    const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, CRIS_FIRST_ARG_REG);\n@@ -4145,7 +4145,7 @@ cris_function_value_regno_p (const unsigned int regno)\n }\n \n static int\n-cris_arg_partial_bytes (cumulative_args_t ca, enum machine_mode mode,\n+cris_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   if (get_cumulative_args (ca)->regs == CRIS_MAX_ARGS_IN_REGS - 1\n@@ -4159,7 +4159,7 @@ cris_arg_partial_bytes (cumulative_args_t ca, enum machine_mode mode,\n \n static rtx\n cris_function_arg_1 (cumulative_args_t ca_v,\n-\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     const_tree type ATTRIBUTE_UNUSED,\n \t\t     bool named, bool incoming)\n {\n@@ -4175,7 +4175,7 @@ cris_function_arg_1 (cumulative_args_t ca_v,\n    The void_type_node is sent as a \"closing\" call.  */\n \n static rtx\n-cris_function_arg (cumulative_args_t ca, enum machine_mode mode,\n+cris_function_arg (cumulative_args_t ca, machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   return cris_function_arg_1 (ca, mode, type, named, false);\n@@ -4189,7 +4189,7 @@ cris_function_arg (cumulative_args_t ca, enum machine_mode mode,\n    void_type_node TYPE parameter.  */\n \n static rtx\n-cris_function_incoming_arg (cumulative_args_t ca, enum machine_mode mode,\n+cris_function_incoming_arg (cumulative_args_t ca, machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n   return cris_function_arg_1 (ca, mode, type, named, true);\n@@ -4198,7 +4198,7 @@ cris_function_incoming_arg (cumulative_args_t ca, enum machine_mode mode,\n /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-cris_function_arg_advance (cumulative_args_t ca_v, enum machine_mode mode,\n+cris_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);"}, {"sha": "44e453bd4c6bcac394a8061beb780bbf314cb50a", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -4997,8 +4997,8 @@\n   [(set (match_dup 0) (match_dup 4))\n    (set (match_dup 5) (match_dup 6))]\n {\n-  enum machine_mode zmode = INTVAL (operands[3]) <= 255 ? QImode : HImode;\n-  enum machine_mode amode\n+  machine_mode zmode = INTVAL (operands[3]) <= 255 ? QImode : HImode;\n+  machine_mode amode\n     = satisfies_constraint_O (operands[3]) ? SImode : zmode;\n   rtx op1\n     = (REG_S_P (operands[1])\n@@ -5035,7 +5035,7 @@\n   [(set (match_dup 0) (match_dup 3))\n    (set (match_dup 0) (and:SI (match_dup 0) (match_dup 4)))]\n {\n-  enum machine_mode zmode = INTVAL (operands[2]) <= 255 ? QImode : HImode;\n+  machine_mode zmode = INTVAL (operands[2]) <= 255 ? QImode : HImode;\n   rtx op1\n     = (REG_S_P (operands[2])\n        ? gen_rtx_REG (zmode, REGNO (operands[2]))"}, {"sha": "949fbfa8c705675c270e734acdc5b3d381b4fec1", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -37,11 +37,11 @@ extern enum machopic_addr_class machopic_classify_symbol (rtx);\n \n extern rtx machopic_indirect_data_reference (rtx, rtx);\n extern rtx machopic_indirect_call_target (rtx);\n-extern rtx machopic_legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx machopic_legitimize_pic_address (rtx, machine_mode, rtx);\n \n extern void machopic_asm_out_constructor (rtx, int);\n extern void machopic_asm_out_destructor (rtx, int);\n-extern section *machopic_select_rtx_section (enum machine_mode, rtx,\n+extern section *machopic_select_rtx_section (machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT);\n #endif /* RTX_CODE */\n "}, {"sha": "a201a74ed397ea94665b2480186b4e332cef921f", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -798,7 +798,7 @@ machopic_indirect_call_target (rtx target)\n       rtx sym_ref = XEXP (target, 0);\n       const char *stub_name = machopic_indirection_name (sym_ref,\n \t\t\t\t\t\t\t /*stub_p=*/true);\n-      enum machine_mode mode = GET_MODE (sym_ref);\n+      machine_mode mode = GET_MODE (sym_ref);\n \n       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);\n       SYMBOL_REF_DATA (XEXP (target, 0)) = SYMBOL_REF_DATA (sym_ref);\n@@ -810,7 +810,7 @@ machopic_indirect_call_target (rtx target)\n }\n \n rtx\n-machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n+machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n {\n   rtx pic_ref = orig;\n \n@@ -1293,7 +1293,7 @@ darwin_mergeable_constant_section (tree exp,\n \t\t\t\t   unsigned HOST_WIDE_INT align,\n \t\t\t\t   bool zsize)\n {\n-  enum machine_mode mode = DECL_MODE (exp);\n+  machine_mode mode = DECL_MODE (exp);\n   unsigned int modesize = GET_MODE_BITSIZE (mode);\n \n   if (DARWIN_SECTION_ANCHORS \n@@ -1743,7 +1743,7 @@ machopic_select_section (tree decl,\n    They must go in \"const\".  */\n \n section *\n-machopic_select_rtx_section (enum machine_mode mode, rtx x,\n+machopic_select_rtx_section (machine_mode mode, rtx x,\n \t\t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (GET_MODE_SIZE (mode) == 8"}, {"sha": "9fba5ec7a021f7b595f7a3775bba736ea122c8ab", "filename": "gcc/config/epiphany/epiphany-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -19,11 +19,11 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #ifdef RTX_CODE\n-extern enum machine_mode epiphany_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern machine_mode epiphany_select_cc_mode (enum rtx_code, rtx, rtx);\n \n /* Define the function that build the compare insn for scc and bcc.  */\n-extern struct rtx_def *gen_compare_reg (enum machine_mode, enum rtx_code,\n-\t\t\t\t\tenum machine_mode, rtx, rtx);\n+extern struct rtx_def *gen_compare_reg (machine_mode, enum rtx_code,\n+\t\t\t\t\tmachine_mode, rtx, rtx);\n #endif\n \n /* Declarations for various fns used in the .md file.  */\n@@ -38,7 +38,7 @@ extern void epiphany_expand_prologue (void);\n extern void epiphany_expand_epilogue (int);\n extern int epiphany_initial_elimination_offset (int, int);\n extern void epiphany_init_expanders (void);\n-extern int hard_regno_mode_ok (int regno, enum machine_mode mode);\n+extern int hard_regno_mode_ok (int regno, machine_mode mode);\n #ifdef HARD_CONST\n extern void emit_set_fp_mode (int entity, int mode, int prev_mode,\n \t\t\t      HARD_REG_SET regs_live);"}, {"sha": "ec5779764fc242faacb8452c53db1a3acaa675a6", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -88,7 +88,7 @@ static int get_epiphany_condition_code (rtx);\n static tree epiphany_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n static tree epiphany_handle_forwarder_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n-static bool epiphany_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static bool epiphany_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t\tconst_tree, bool);\n static rtx_insn *frame_insn (rtx);\n \f\n@@ -374,7 +374,7 @@ get_epiphany_condition_code (rtx comparison)\n \n /* Return 1 if hard register REGNO can hold a value of machine_mode MODE.  */\n int\n-hard_regno_mode_ok (int regno, enum machine_mode mode)\n+hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     return (regno & 1) == 0 && GPR_P (regno);\n@@ -385,7 +385,7 @@ hard_regno_mode_ok (int regno, enum machine_mode mode)\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n \n-enum machine_mode\n+machine_mode\n epiphany_select_cc_mode (enum rtx_code op,\n \t\t\t rtx x ATTRIBUTE_UNUSED,\n \t\t\t rtx y ATTRIBUTE_UNUSED)\n@@ -580,10 +580,10 @@ sfunc_symbol (const char *name)\n    mode, and return the rtx for the cc reg comparison in CMODE.  */\n \n rtx\n-gen_compare_reg (enum machine_mode cmode, enum rtx_code code,\n-\t\t enum machine_mode in_mode, rtx x, rtx y)\n+gen_compare_reg (machine_mode cmode, enum rtx_code code,\n+\t\t machine_mode in_mode, rtx x, rtx y)\n {\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg, pat, clob0, clob1, clob2;\n \n   if (in_mode == VOIDmode)\n@@ -703,7 +703,7 @@ gen_compare_reg (enum machine_mode cmode, enum rtx_code code,\n    : (CUM))\n \n static unsigned int\n-epiphany_function_arg_boundary (enum machine_mode mode, const_tree type)\n+epiphany_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   if ((type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode)) <= PARM_BOUNDARY)\n     return PARM_BOUNDARY;\n@@ -718,7 +718,7 @@ epiphany_function_arg_boundary (enum machine_mode mode, const_tree type)\n \n \n static void\n-epiphany_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+epiphany_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t\t tree type, int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n@@ -746,7 +746,7 @@ epiphany_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n }\n \n static int\n-epiphany_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n+epiphany_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int words = 0, rounded_cum;\n@@ -844,7 +844,7 @@ epiphany_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n static int\n-epiphany_address_cost (rtx addr, enum machine_mode mode,\n+epiphany_address_cost (rtx addr, machine_mode mode,\n \t\t       addr_space_t as ATTRIBUTE_UNUSED, bool speed)\n {\n   rtx reg;\n@@ -905,7 +905,7 @@ epiphany_address_cost (rtx addr, enum machine_mode mode,\n    but issue pich is the same.  For floating point, load latency is three\n    times as much as a reg-reg move.  */\n static int\n-epiphany_memory_move_cost (enum machine_mode mode,\n+epiphany_memory_move_cost (machine_mode mode,\n                           reg_class_t rclass ATTRIBUTE_UNUSED,\n                           bool in ATTRIBUTE_UNUSED)\n {\n@@ -1484,7 +1484,7 @@ epiphany_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \n static bool\n epiphany_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode, const_tree type,\n+\t\t       machine_mode mode, const_tree type,\n \t\t       bool named ATTRIBUTE_UNUSED)\n {\n   if (type)\n@@ -1502,7 +1502,7 @@ epiphany_function_value (const_tree ret_type,\n \t\t\t const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n \t\t\t bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = TYPE_MODE (ret_type);\n   /* We must change the mode like PROMOTE_MODE does.\n@@ -1520,7 +1520,7 @@ epiphany_function_value (const_tree ret_type,\n }\n \n static rtx\n-epiphany_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+epiphany_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, 0);\n }\n@@ -1615,7 +1615,7 @@ frame_move_insn (rtx to, rtx from)\n /* Generate a MEM referring to a varargs argument slot.  */\n \n static rtx\n-gen_varargs_mem (enum machine_mode mode, rtx addr)\n+gen_varargs_mem (machine_mode mode, rtx addr)\n {\n   rtx mem = gen_rtx_MEM (mode, addr);\n   MEM_NOTRAP_P (mem) = 1;\n@@ -1647,10 +1647,10 @@ epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n       last_saved--;\n   for (i = 0; i < limit; i++)\n     {\n-      enum machine_mode mode = word_mode;\n+      machine_mode mode = word_mode;\n       rtx mem, reg;\n       int n = i;\n-      rtx (*gen_mem) (enum machine_mode, rtx) = gen_frame_mem;\n+      rtx (*gen_mem) (machine_mode, rtx) = gen_frame_mem;\n \n       /* Make sure we push the arguments in the right order.  */\n       if (n < MAX_EPIPHANY_PARM_REGS && crtl->args.pretend_args_size)\n@@ -1811,7 +1811,7 @@ epiphany_expand_prologue (void)\n \t allocate the entire frame; this is joint with one register save.  */\n       if (current_frame_info.first_slot >= 0)\n \t{\n-\t  enum machine_mode mode\n+\t  machine_mode mode\n \t= (current_frame_info.first_slot_size == UNITS_PER_WORD\n \t   ? word_mode : DImode);\n \n@@ -2047,7 +2047,7 @@ epiphany_adjust_cost (rtx_insn *insn, rtx link, rtx_insn *dep_insn, int cost)\n      || RTX_OK_FOR_OFFSET_P (MODE, XEXP (X, 1))))\n \n static bool\n-epiphany_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+epiphany_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n #define REG_OK_FOR_BASE_P(X) \\\n   (strict ? GPR_P (REGNO (X)) : GPR_AP_OR_PSEUDO_P (REGNO (X)))\n@@ -2082,7 +2082,7 @@ epiphany_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n static reg_class_t\n epiphany_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tsecondary_reload_info *sri)\n {\n   /* This could give more reload inheritance, but we are missing some\n@@ -2200,8 +2200,8 @@ epiphany_call_uninterruptible_p (rtx mem)\n   return epiphany_uninterruptible_p (t);\n }\n \n-static enum machine_mode\n-epiphany_promote_function_mode (const_tree type, enum machine_mode mode,\n+static machine_mode\n+epiphany_promote_function_mode (const_tree type, machine_mode mode,\n \t\t\t\tint *punsignedp ATTRIBUTE_UNUSED,\n \t\t\t\tconst_tree funtype ATTRIBUTE_UNUSED,\n \t\t\t\tint for_return ATTRIBUTE_UNUSED)\n@@ -2261,7 +2261,7 @@ epiphany_conditional_register_usage (void)\n /* On the EPIPHANY the first MAX_EPIPHANY_PARM_REGS args are normally in\n    registers and the rest are pushed.  */\n static rtx\n-epiphany_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+epiphany_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);\n@@ -2275,7 +2275,7 @@ epiphany_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n static void\n-epiphany_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+epiphany_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2775,7 +2775,7 @@ epiphany_epilogue_uses (int regno)\n }\n \n static unsigned int\n-epiphany_min_divisions_for_recip_mul (enum machine_mode mode)\n+epiphany_min_divisions_for_recip_mul (machine_mode mode)\n {\n   if (flag_reciprocal_math && mode == SFmode)\n     /* We'll expand into a multiply-by-reciprocal anyway, so we might a well do\n@@ -2784,14 +2784,14 @@ epiphany_min_divisions_for_recip_mul (enum machine_mode mode)\n   return default_min_divisions_for_recip_mul (mode);\n }\n \n-static enum machine_mode\n-epiphany_preferred_simd_mode (enum machine_mode mode ATTRIBUTE_UNUSED)\n+static machine_mode\n+epiphany_preferred_simd_mode (machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return TARGET_VECT_DOUBLE ? DImode : SImode;\n }\n \n static bool\n-epiphany_vector_mode_supported_p (enum machine_mode mode)\n+epiphany_vector_mode_supported_p (machine_mode mode)\n {\n   if (mode == V2SFmode)\n     return true;\n@@ -2813,7 +2813,7 @@ epiphany_vector_alignment_reachable (const_tree type, bool is_packed)\n }\n \n static bool\n-epiphany_support_vector_misalignment (enum machine_mode mode, const_tree type,\n+epiphany_support_vector_misalignment (machine_mode mode, const_tree type,\n \t\t\t\t      int misalignment, bool is_packed)\n {\n   if (GET_MODE_SIZE (mode) == 8 && misalignment % 4 == 0)"}, {"sha": "822c701c4638d17c4b994a06720309ae6613c9de", "filename": "gcc/config/epiphany/epiphany.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1946,7 +1946,7 @@\n {\n   rtx cmp_op0 = XEXP (operands[1], 0);\n   rtx cmp_op1 = XEXP (operands[1], 1);\n-  enum machine_mode cmp_in_mode;\n+  machine_mode cmp_in_mode;\n   enum rtx_code code = GET_CODE (operands[1]);\n \n   cmp_in_mode = GET_MODE (cmp_op0);"}, {"sha": "4832b77217d8b393fcc011d25674ef7f0eb5b581", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -130,23 +130,23 @@ static struct fr30_frame_info \tcurrent_frame_info;\n /* Zero structure to initialize current_frame_info.  */\n static struct fr30_frame_info \tzero_frame_info;\n \n-static void fr30_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static void fr30_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n-static bool fr30_must_pass_in_stack (enum machine_mode, const_tree);\n-static int fr30_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n+static int fr30_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx fr30_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx fr30_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static void fr30_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void fr30_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool fr30_frame_pointer_required (void);\n static rtx fr30_function_value (const_tree, const_tree, bool);\n-static rtx fr30_libcall_value (enum machine_mode, const_rtx);\n+static rtx fr30_libcall_value (machine_mode, const_rtx);\n static bool fr30_function_value_regno_p (const unsigned int);\n static bool fr30_can_eliminate (const int, const int);\n static void fr30_asm_trampoline_template (FILE *);\n static void fr30_trampoline_init (rtx, tree, rtx);\n-static int fr30_num_arg_regs (enum machine_mode, const_tree);\n+static int fr30_num_arg_regs (machine_mode, const_tree);\n \n #define FRAME_POINTER_MASK \t(1 << (FRAME_POINTER_REGNUM))\n #define RETURN_POINTER_MASK \t(1 << (RETURN_POINTER_REGNUM))\n@@ -471,7 +471,7 @@ fr30_expand_epilogue (void)\n    which has type TYPE and mode MODE, and we rely on this fact.  */\n void\n fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n-\t\t\t     enum machine_mode mode,\n+\t\t\t     machine_mode mode,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n@@ -733,7 +733,7 @@ fr30_function_value (const_tree valtype,\n /* Implements TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-fr30_libcall_value (enum machine_mode mode,\n+fr30_libcall_value (machine_mode mode,\n \t\t    const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n@@ -753,7 +753,7 @@ fr30_function_value_regno_p (const unsigned int regno)\n    in registers.  */\n \n static bool\n-fr30_must_pass_in_stack (enum machine_mode mode, const_tree type)\n+fr30_must_pass_in_stack (machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode)\n     return true;\n@@ -765,7 +765,7 @@ fr30_must_pass_in_stack (enum machine_mode mode, const_tree type)\n /* Compute the number of word sized registers needed to hold a\n    function argument of mode INT_MODE and tree type TYPE.  */\n static int\n-fr30_num_arg_regs (enum machine_mode mode, const_tree type)\n+fr30_num_arg_regs (machine_mode mode, const_tree type)\n {\n   int size;\n \n@@ -788,7 +788,7 @@ fr30_num_arg_regs (enum machine_mode mode, const_tree type)\n    parameters to the function.  */\n \n static int\n-fr30_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+fr30_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t\ttree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -812,7 +812,7 @@ fr30_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n }\n \n static rtx\n-fr30_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+fr30_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -834,7 +834,7 @@ fr30_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    the stack.  The compiler knows how to track the amount of stack space used\n    for arguments without any special help.  */\n static void\n-fr30_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n+fr30_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   *get_cumulative_args (cum) += named * fr30_num_arg_regs (mode, type);\n@@ -844,7 +844,7 @@ fr30_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n /*{{{  Operand predicates */ \n \n #ifndef Mmode\n-#define Mmode enum machine_mode\n+#define Mmode machine_mode\n #endif\n \n /* Returns true iff all the registers in the operands array\n@@ -916,7 +916,7 @@ fr30_move_double (rtx * operands)\n   rtx dest = operands[0];\n   enum rtx_code src_code = GET_CODE (src);\n   enum rtx_code dest_code = GET_CODE (dest);\n-  enum machine_mode mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (dest);\n   rtx val;\n \n   start_sequence ();"}, {"sha": "c1f6bbaaa4ef2a6ad34d8659956f65c721278aae", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -27,7 +27,7 @@ extern int frv_initial_elimination_offset\t(int, int);\n extern void frv_ifcvt_machdep_init\t\t(void *);\n \n #ifdef RTX_CODE\n-extern int frv_legitimate_address_p_1\t\t(enum machine_mode, rtx,\n+extern int frv_legitimate_address_p_1\t\t(machine_mode, rtx,\n \t\t\t\t\t\t int, int, int);\n extern rtx frv_find_base_term\t\t\t(rtx);\n \n@@ -42,11 +42,11 @@ extern int frv_expand_block_move\t\t(rtx *);\n extern int frv_expand_block_clear\t\t(rtx *);\n extern rtx frv_dynamic_chain_address\t\t(rtx);\n extern rtx frv_return_addr_rtx\t\t\t(int, rtx);\n-extern rtx frv_index_memory\t\t\t(rtx, enum machine_mode, int);\n+extern rtx frv_index_memory\t\t\t(rtx, machine_mode, int);\n extern const char *frv_asm_output_opcode\n \t\t\t\t \t(FILE *, const char *);\n extern void frv_final_prescan_insn\t(rtx_insn *, rtx *, int);\n-extern void frv_emit_move\t\t(enum machine_mode, rtx, rtx);\n+extern void frv_emit_move\t\t(machine_mode, rtx, rtx);\n extern int frv_emit_movsi\t\t(rtx, rtx);\n extern const char *output_move_single\t(rtx *, rtx);\n extern const char *output_move_double\t(rtx *, rtx);\n@@ -73,12 +73,12 @@ extern void frv_ifcvt_modify_cancel\t(struct ce_if_block *);\n #endif\n extern enum reg_class frv_secondary_reload_class\n \t\t\t\t\t(enum reg_class,\n-\t\t\t\t\t enum machine_mode, rtx);\n-extern int frv_hard_regno_mode_ok\t(int, enum machine_mode);\n-extern int frv_hard_regno_nregs\t\t(int, enum machine_mode);\n+\t\t\t\t\t machine_mode, rtx);\n+extern int frv_hard_regno_mode_ok\t(int, machine_mode);\n+extern int frv_hard_regno_nregs\t\t(int, machine_mode);\n extern int frv_class_max_nregs\t\t(enum reg_class rclass,\n-\t\t\t\t\t enum machine_mode mode);\n-extern enum machine_mode frv_select_cc_mode (enum rtx_code, rtx, rtx);\n+\t\t\t\t\t machine_mode mode);\n+extern machine_mode frv_select_cc_mode (enum rtx_code, rtx, rtx);\n #endif\t/* RTX_CODE */\n \n extern int frv_trampoline_size\t\t(void);\n@@ -91,77 +91,77 @@ extern int frv_adjust_field_align\t(tree, int);\n #endif\n \n #ifdef RTX_CODE\n-extern int integer_register_operand\t(rtx, enum machine_mode);\n-extern int frv_load_operand\t\t(rtx, enum machine_mode);\n-extern int gpr_or_fpr_operand\t\t(rtx, enum machine_mode);\n-extern int gpr_no_subreg_operand\t(rtx, enum machine_mode);\n-extern int gpr_or_int6_operand\t\t(rtx, enum machine_mode);\n-extern int fpr_or_int6_operand\t\t(rtx, enum machine_mode);\n-extern int gpr_or_int_operand\t\t(rtx, enum machine_mode);\n-extern int gpr_or_int12_operand\t\t(rtx, enum machine_mode);\n-extern int gpr_fpr_or_int12_operand\t(rtx, enum machine_mode);\n-extern int gpr_or_int10_operand\t\t(rtx, enum machine_mode);\n-extern int move_source_operand\t\t(rtx, enum machine_mode);\n-extern int move_destination_operand\t(rtx, enum machine_mode);\n-extern int condexec_source_operand\t(rtx, enum machine_mode);\n-extern int condexec_dest_operand\t(rtx, enum machine_mode);\n-extern int lr_operand\t\t\t(rtx, enum machine_mode);\n-extern int gpr_or_memory_operand\t(rtx, enum machine_mode);\n-extern int fpr_or_memory_operand\t(rtx, enum machine_mode);\n-extern int reg_or_0_operand\t\t(rtx, enum machine_mode);\n-extern int fcc_operand\t\t\t(rtx, enum machine_mode);\n-extern int icc_operand\t\t\t(rtx, enum machine_mode);\n-extern int cc_operand\t\t\t(rtx, enum machine_mode);\n-extern int fcr_operand\t\t\t(rtx, enum machine_mode);\n-extern int icr_operand\t\t\t(rtx, enum machine_mode);\n-extern int cr_operand\t\t\t(rtx, enum machine_mode);\n-extern int call_operand\t\t\t(rtx, enum machine_mode);\n-extern int fpr_operand\t\t\t(rtx, enum machine_mode);\n-extern int even_reg_operand\t\t(rtx, enum machine_mode);\n-extern int odd_reg_operand\t\t(rtx, enum machine_mode);\n-extern int even_gpr_operand\t\t(rtx, enum machine_mode);\n-extern int odd_gpr_operand\t\t(rtx, enum machine_mode);\n-extern int quad_fpr_operand\t\t(rtx, enum machine_mode);\n-extern int even_fpr_operand\t\t(rtx, enum machine_mode);\n-extern int odd_fpr_operand\t\t(rtx, enum machine_mode);\n-extern int dbl_memory_one_insn_operand\t(rtx, enum machine_mode);\n-extern int dbl_memory_two_insn_operand\t(rtx, enum machine_mode);\n-extern int int12_operand\t\t(rtx, enum machine_mode);\n-extern int int6_operand\t\t\t(rtx, enum machine_mode);\n-extern int int5_operand\t\t\t(rtx, enum machine_mode);\n-extern int uint5_operand\t\t(rtx, enum machine_mode);\n-extern int uint4_operand\t\t(rtx, enum machine_mode);\n-extern int uint1_operand\t\t(rtx, enum machine_mode);\n-extern int int_2word_operand\t\t(rtx, enum machine_mode);\n-extern int pic_register_operand\t\t(rtx, enum machine_mode);\n-extern int pic_symbolic_operand\t\t(rtx, enum machine_mode);\n-extern int small_data_register_operand\t(rtx, enum machine_mode);\n-extern int small_data_symbolic_operand\t(rtx, enum machine_mode);\n-extern int upper_int16_operand\t\t(rtx, enum machine_mode);\n-extern int uint16_operand\t\t(rtx, enum machine_mode);\n-extern int symbolic_operand\t\t(rtx, enum machine_mode);\n-extern int relational_operator\t\t(rtx, enum machine_mode);\n-extern int signed_relational_operator\t(rtx, enum machine_mode);\n-extern int unsigned_relational_operator\t(rtx, enum machine_mode);\n-extern int float_relational_operator\t(rtx, enum machine_mode);\n-extern int ccr_eqne_operator\t\t(rtx, enum machine_mode);\n-extern int minmax_operator\t\t(rtx, enum machine_mode);\n-extern int condexec_si_binary_operator\t(rtx, enum machine_mode);\n-extern int condexec_si_media_operator\t(rtx, enum machine_mode);\n-extern int condexec_si_divide_operator\t(rtx, enum machine_mode);\n-extern int condexec_si_unary_operator\t(rtx, enum machine_mode);\n-extern int condexec_sf_conv_operator\t(rtx, enum machine_mode);\n-extern int condexec_sf_add_operator\t(rtx, enum machine_mode);\n-extern int condexec_memory_operand\t(rtx, enum machine_mode);\n-extern int intop_compare_operator\t(rtx, enum machine_mode);\n-extern int acc_operand\t\t\t(rtx, enum machine_mode);\n-extern int even_acc_operand\t\t(rtx, enum machine_mode);\n-extern int quad_acc_operand\t\t(rtx, enum machine_mode);\n-extern int accg_operand\t\t\t(rtx, enum machine_mode);\n+extern int integer_register_operand\t(rtx, machine_mode);\n+extern int frv_load_operand\t\t(rtx, machine_mode);\n+extern int gpr_or_fpr_operand\t\t(rtx, machine_mode);\n+extern int gpr_no_subreg_operand\t(rtx, machine_mode);\n+extern int gpr_or_int6_operand\t\t(rtx, machine_mode);\n+extern int fpr_or_int6_operand\t\t(rtx, machine_mode);\n+extern int gpr_or_int_operand\t\t(rtx, machine_mode);\n+extern int gpr_or_int12_operand\t\t(rtx, machine_mode);\n+extern int gpr_fpr_or_int12_operand\t(rtx, machine_mode);\n+extern int gpr_or_int10_operand\t\t(rtx, machine_mode);\n+extern int move_source_operand\t\t(rtx, machine_mode);\n+extern int move_destination_operand\t(rtx, machine_mode);\n+extern int condexec_source_operand\t(rtx, machine_mode);\n+extern int condexec_dest_operand\t(rtx, machine_mode);\n+extern int lr_operand\t\t\t(rtx, machine_mode);\n+extern int gpr_or_memory_operand\t(rtx, machine_mode);\n+extern int fpr_or_memory_operand\t(rtx, machine_mode);\n+extern int reg_or_0_operand\t\t(rtx, machine_mode);\n+extern int fcc_operand\t\t\t(rtx, machine_mode);\n+extern int icc_operand\t\t\t(rtx, machine_mode);\n+extern int cc_operand\t\t\t(rtx, machine_mode);\n+extern int fcr_operand\t\t\t(rtx, machine_mode);\n+extern int icr_operand\t\t\t(rtx, machine_mode);\n+extern int cr_operand\t\t\t(rtx, machine_mode);\n+extern int call_operand\t\t\t(rtx, machine_mode);\n+extern int fpr_operand\t\t\t(rtx, machine_mode);\n+extern int even_reg_operand\t\t(rtx, machine_mode);\n+extern int odd_reg_operand\t\t(rtx, machine_mode);\n+extern int even_gpr_operand\t\t(rtx, machine_mode);\n+extern int odd_gpr_operand\t\t(rtx, machine_mode);\n+extern int quad_fpr_operand\t\t(rtx, machine_mode);\n+extern int even_fpr_operand\t\t(rtx, machine_mode);\n+extern int odd_fpr_operand\t\t(rtx, machine_mode);\n+extern int dbl_memory_one_insn_operand\t(rtx, machine_mode);\n+extern int dbl_memory_two_insn_operand\t(rtx, machine_mode);\n+extern int int12_operand\t\t(rtx, machine_mode);\n+extern int int6_operand\t\t\t(rtx, machine_mode);\n+extern int int5_operand\t\t\t(rtx, machine_mode);\n+extern int uint5_operand\t\t(rtx, machine_mode);\n+extern int uint4_operand\t\t(rtx, machine_mode);\n+extern int uint1_operand\t\t(rtx, machine_mode);\n+extern int int_2word_operand\t\t(rtx, machine_mode);\n+extern int pic_register_operand\t\t(rtx, machine_mode);\n+extern int pic_symbolic_operand\t\t(rtx, machine_mode);\n+extern int small_data_register_operand\t(rtx, machine_mode);\n+extern int small_data_symbolic_operand\t(rtx, machine_mode);\n+extern int upper_int16_operand\t\t(rtx, machine_mode);\n+extern int uint16_operand\t\t(rtx, machine_mode);\n+extern int symbolic_operand\t\t(rtx, machine_mode);\n+extern int relational_operator\t\t(rtx, machine_mode);\n+extern int signed_relational_operator\t(rtx, machine_mode);\n+extern int unsigned_relational_operator\t(rtx, machine_mode);\n+extern int float_relational_operator\t(rtx, machine_mode);\n+extern int ccr_eqne_operator\t\t(rtx, machine_mode);\n+extern int minmax_operator\t\t(rtx, machine_mode);\n+extern int condexec_si_binary_operator\t(rtx, machine_mode);\n+extern int condexec_si_media_operator\t(rtx, machine_mode);\n+extern int condexec_si_divide_operator\t(rtx, machine_mode);\n+extern int condexec_si_unary_operator\t(rtx, machine_mode);\n+extern int condexec_sf_conv_operator\t(rtx, machine_mode);\n+extern int condexec_sf_add_operator\t(rtx, machine_mode);\n+extern int condexec_memory_operand\t(rtx, machine_mode);\n+extern int intop_compare_operator\t(rtx, machine_mode);\n+extern int acc_operand\t\t\t(rtx, machine_mode);\n+extern int even_acc_operand\t\t(rtx, machine_mode);\n+extern int quad_acc_operand\t\t(rtx, machine_mode);\n+extern int accg_operand\t\t\t(rtx, machine_mode);\n extern rtx frv_matching_accg_for_acc\t(rtx);\n extern void frv_expand_fdpic_call\t(rtx *, bool, bool);\n extern rtx frv_gen_GPsym2reg\t\t(rtx, rtx);\n-extern int frv_legitimate_memory_operand (rtx, enum machine_mode, int);\n+extern int frv_legitimate_memory_operand (rtx, machine_mode, int);\n \n /* Information about a relocation unspec.  SYMBOL is the relocation symbol\n    (a SYMBOL_REF or LABEL_REF), RELOC is the type of relocation and OFFSET"}, {"sha": "41cc4974cadd58cdfec33ed68ded580e93f45bb0", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -275,7 +275,7 @@ static frv_stack_t *frv_stack_cache = (frv_stack_t *)0;\n /* Forward references */\n \n static void frv_option_override\t\t\t(void);\n-static bool frv_legitimate_address_p\t\t(enum machine_mode, rtx, bool);\n+static bool frv_legitimate_address_p\t\t(machine_mode, rtx, bool);\n static int frv_default_flags_for_cpu\t\t(void);\n static int frv_string_begins_with\t\t(const char *, const char *);\n static FRV_INLINE bool frv_small_data_reloc_p\t(rtx, int);\n@@ -289,17 +289,17 @@ static int frv_print_operand_jump_hint\t\t(rtx_insn *);\n static const char *comparison_string\t\t(enum rtx_code, rtx);\n static rtx frv_function_value\t\t\t(const_tree, const_tree,\n \t\t\t\t\t\t bool);\n-static rtx frv_libcall_value\t\t\t(enum machine_mode,\n+static rtx frv_libcall_value\t\t\t(machine_mode,\n \t\t\t\t\t\t const_rtx);\n static FRV_INLINE int frv_regno_ok_for_base_p\t(int, int);\n static rtx single_set_pattern\t\t\t(rtx);\n static int frv_function_contains_far_jump\t(void);\n static rtx frv_alloc_temp_reg\t\t\t(frv_tmp_reg_t *,\n \t\t\t\t\t\t enum reg_class,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t int, int);\n static rtx frv_frame_offset_rtx\t\t\t(int);\n-static rtx frv_frame_mem\t\t\t(enum machine_mode, rtx, int);\n+static rtx frv_frame_mem\t\t\t(machine_mode, rtx, int);\n static rtx frv_dwarf_store\t\t\t(rtx, int);\n static void frv_frame_insn\t\t\t(rtx, rtx);\n static void frv_frame_access\t\t\t(frv_frame_accessor_t*,\n@@ -310,14 +310,14 @@ static void frv_frame_access_standard_regs\t(enum frv_stack_op,\n \t\t\t\t\t\t frv_stack_t *);\n static struct machine_function *frv_init_machine_status\t\t(void);\n static rtx frv_int_to_acc\t\t\t(enum insn_code, int, rtx);\n-static enum machine_mode frv_matching_accg_mode\t(enum machine_mode);\n+static machine_mode frv_matching_accg_mode\t(machine_mode);\n static rtx frv_read_argument\t\t\t(tree, unsigned int);\n-static rtx frv_read_iacc_argument\t\t(enum machine_mode, tree, unsigned int);\n+static rtx frv_read_iacc_argument\t\t(machine_mode, tree, unsigned int);\n static int frv_check_constant_argument\t\t(enum insn_code, int, rtx);\n static rtx frv_legitimize_target\t\t(enum insn_code, rtx);\n static rtx frv_legitimize_argument\t\t(enum insn_code, int, rtx);\n static rtx frv_legitimize_tls_address\t\t(rtx, enum tls_model);\n-static rtx frv_legitimize_address\t\t(rtx, rtx, enum machine_mode);\n+static rtx frv_legitimize_address\t\t(rtx, rtx, machine_mode);\n static rtx frv_expand_set_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_unop_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_binop_builtin\t\t(enum insn_code, tree, rtx);\n@@ -336,7 +336,7 @@ static void frv_split_iacc_move\t\t\t(rtx, rtx);\n static rtx frv_emit_comparison\t\t\t(enum rtx_code, rtx, rtx);\n static int frv_clear_registers_used\t\t(rtx *, void *);\n static void frv_ifcvt_add_insn\t\t\t(rtx, rtx, int);\n-static rtx frv_ifcvt_rewrite_mem\t\t(rtx, enum machine_mode, rtx);\n+static rtx frv_ifcvt_rewrite_mem\t\t(rtx, machine_mode, rtx);\n static rtx frv_ifcvt_load_value\t\t\t(rtx, rtx);\n static int frv_acc_group_1\t\t\t(rtx *, void *);\n static unsigned int frv_insn_unit\t\t(rtx_insn *);\n@@ -371,47 +371,47 @@ static void frv_function_prologue\t\t(FILE *, HOST_WIDE_INT);\n static void frv_function_epilogue\t\t(FILE *, HOST_WIDE_INT);\n static bool frv_assemble_integer\t\t(rtx, unsigned, int);\n static void frv_init_builtins\t\t\t(void);\n-static rtx frv_expand_builtin\t\t\t(tree, rtx, rtx, enum machine_mode, int);\n+static rtx frv_expand_builtin\t\t\t(tree, rtx, rtx, machine_mode, int);\n static void frv_init_libfuncs\t\t\t(void);\n static bool frv_in_small_data_p\t\t\t(const_tree);\n static void frv_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void frv_setup_incoming_varargs\t\t(cumulative_args_t,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t tree, int *, int);\n static rtx frv_expand_builtin_saveregs\t\t(void);\n static void frv_expand_builtin_va_start\t\t(tree, rtx);\n static bool frv_rtx_costs\t\t\t(rtx, int, int, int, int*,\n \t\t\t\t\t\t bool);\n-static int frv_register_move_cost\t\t(enum machine_mode,\n+static int frv_register_move_cost\t\t(machine_mode,\n \t\t\t\t\t\t reg_class_t, reg_class_t);\n-static int frv_memory_move_cost\t\t\t(enum machine_mode,\n+static int frv_memory_move_cost\t\t\t(machine_mode,\n \t\t\t\t\t\t reg_class_t, bool);\n static void frv_asm_out_constructor\t\t(rtx, int);\n static void frv_asm_out_destructor\t\t(rtx, int);\n static bool frv_function_symbol_referenced_p\t(rtx);\n-static bool frv_legitimate_constant_p\t\t(enum machine_mode, rtx);\n-static bool frv_cannot_force_const_mem\t\t(enum machine_mode, rtx);\n+static bool frv_legitimate_constant_p\t\t(machine_mode, rtx);\n+static bool frv_cannot_force_const_mem\t\t(machine_mode, rtx);\n static const char *unspec_got_name\t\t(int);\n static void frv_output_const_unspec\t\t(FILE *,\n \t\t\t\t\t\t const struct frv_unspec *);\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n-static bool frv_must_pass_in_stack (enum machine_mode mode, const_tree type);\n-static int frv_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static bool frv_must_pass_in_stack (machine_mode mode, const_tree type);\n+static int frv_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t  tree, bool);\n-static rtx frv_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx frv_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n-static rtx frv_function_incoming_arg (cumulative_args_t, enum machine_mode,\n+static rtx frv_function_incoming_arg (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n-static void frv_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void frv_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static unsigned int frv_function_arg_boundary\t(enum machine_mode,\n+static unsigned int frv_function_arg_boundary\t(machine_mode,\n \t\t\t\t\t\t const_tree);\n static void frv_output_dwarf_dtprel\t\t(FILE *, int, rtx)\n   ATTRIBUTE_UNUSED;\n static reg_class_t frv_secondary_reload\t\t(bool, rtx, reg_class_t,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t secondary_reload_info *);\n static bool frv_frame_pointer_required\t\t(void);\n static bool frv_can_eliminate\t\t\t(const int, const int);\n@@ -612,7 +612,7 @@ frv_const_unspec_p (rtx x, struct frv_unspec *unspec)\n    4. In many cases, it's more efficient to calculate the constant in-line.  */\n \n static bool\n-frv_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n+frv_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    rtx x ATTRIBUTE_UNUSED)\n {\n   return TARGET_FDPIC;\n@@ -1496,7 +1496,7 @@ static rtx\n frv_alloc_temp_reg (\n      frv_tmp_reg_t *info,\t/* which registers are available */\n      enum reg_class rclass,\t/* register class desired */\n-     enum machine_mode mode,\t/* mode to allocate register with */\n+     machine_mode mode,\t/* mode to allocate register with */\n      int mark_as_used,\t\t/* register not available after allocation */\n      int no_abort)\t\t/* return NULL instead of aborting */\n {\n@@ -1560,7 +1560,7 @@ frv_frame_offset_rtx (int offset)\n /* Generate (mem:MODE (plus:Pmode BASE (frv_frame_offset OFFSET)))).  The\n    prologue and epilogue uses such expressions to access the stack.  */\n static rtx\n-frv_frame_mem (enum machine_mode mode, rtx base, int offset)\n+frv_frame_mem (machine_mode mode, rtx base, int offset)\n {\n   return gen_rtx_MEM (mode, gen_rtx_PLUS (Pmode,\n \t\t\t\t\t  base,\n@@ -1623,7 +1623,7 @@ frv_frame_insn (rtx pattern, rtx dwarf_pattern)\n static void\n frv_frame_access (frv_frame_accessor_t *accessor, rtx reg, int stack_offset)\n {\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   rtx mem = frv_frame_mem (mode,\n \t\t\t   accessor->base,\n \t\t\t   stack_offset - accessor->base_offset);\n@@ -2138,7 +2138,7 @@ frv_initial_elimination_offset (int from, int to)\n \n static void\n frv_setup_incoming_varargs (cumulative_args_t cum_v,\n-                            enum machine_mode mode,\n+                            machine_mode mode,\n                             tree type ATTRIBUTE_UNUSED,\n                             int *pretend_size,\n                             int second_time)\n@@ -2235,7 +2235,7 @@ frv_expand_block_move (rtx operands[])\n   rtx tmp_reg;\n   rtx stores[MAX_MOVE_REG];\n   int move_bytes;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* If this is not a fixed size move, just call memcpy.  */\n   if (! constp)\n@@ -2326,7 +2326,7 @@ frv_expand_block_clear (rtx operands[])\n   rtx dest_addr;\n   rtx dest_mem;\n   int clear_bytes;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* If this is not a fixed size move, just call memcpy.  */\n   if (! constp)\n@@ -2481,7 +2481,7 @@ frv_return_addr_rtx (int count, rtx frame)\n    frv_legitimate_address_p forbids register+register addresses, which\n    this function cannot handle.  */\n rtx\n-frv_index_memory (rtx memref, enum machine_mode mode, int index)\n+frv_index_memory (rtx memref, machine_mode mode, int index)\n {\n   rtx base = XEXP (memref, 0);\n   if (GET_CODE (base) == PRE_MODIFY)\n@@ -3111,7 +3111,7 @@ frv_init_cumulative_args (CUMULATIVE_ARGS *cum,\n    in registers.  */\n \n static bool\n-frv_must_pass_in_stack (enum machine_mode mode, const_tree type)\n+frv_must_pass_in_stack (machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode)\n     return true;\n@@ -3125,20 +3125,20 @@ frv_must_pass_in_stack (enum machine_mode mode, const_tree type)\n    `PARM_BOUNDARY' is used for all arguments.  */\n \n static unsigned int\n-frv_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+frv_function_arg_boundary (machine_mode mode ATTRIBUTE_UNUSED,\n                            const_tree type ATTRIBUTE_UNUSED)\n {\n   return BITS_PER_WORD;\n }\n \n static rtx\n-frv_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n+frv_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type ATTRIBUTE_UNUSED, bool named,\n \t\t    bool incoming ATTRIBUTE_UNUSED)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int arg_num = *cum;\n   rtx ret;\n   const char *debstr;\n@@ -3171,14 +3171,14 @@ frv_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n }\n \n static rtx\n-frv_function_arg (cumulative_args_t cum, enum machine_mode mode,\n+frv_function_arg (cumulative_args_t cum, machine_mode mode,\n \t\t  const_tree type, bool named)\n {\n   return frv_function_arg_1 (cum, mode, type, named, false);\n }\n \n static rtx\n-frv_function_incoming_arg (cumulative_args_t cum, enum machine_mode mode,\n+frv_function_incoming_arg (cumulative_args_t cum, machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   return frv_function_arg_1 (cum, mode, type, named, true);\n@@ -3196,13 +3196,13 @@ frv_function_incoming_arg (cumulative_args_t cum, enum machine_mode mode,\n \n static void\n frv_function_arg_advance (cumulative_args_t cum_v,\n-                          enum machine_mode mode,\n+                          machine_mode mode,\n                           const_tree type ATTRIBUTE_UNUSED,\n                           bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD  - 1) / UNITS_PER_WORD;\n   int arg_num = *cum;\n@@ -3233,11 +3233,11 @@ frv_function_arg_advance (cumulative_args_t cum_v,\n    the called function.  */\n \n static int\n-frv_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n+frv_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \t\t       tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n \n-  enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   int arg_num = *get_cumulative_args (cum);\n@@ -3269,7 +3269,7 @@ frv_function_value (const_tree valtype,\n /* Implements TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-frv_libcall_value (enum machine_mode mode,\n+frv_libcall_value (machine_mode mode,\n \t\t   const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n@@ -3337,7 +3337,7 @@ frv_regno_ok_for_base_p (int regno, int strict_p)\n    will be given to `TARGET_PRINT_OPERAND_ADDRESS'.  */\n \n int\n-frv_legitimate_address_p_1 (enum machine_mode mode,\n+frv_legitimate_address_p_1 (machine_mode mode,\n                             rtx x,\n                             int strict_p,\n                             int condexec_p,\n@@ -3469,7 +3469,7 @@ frv_legitimate_address_p_1 (enum machine_mode mode,\n }\n \n bool\n-frv_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+frv_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n {\n   return frv_legitimate_address_p_1 (mode, x, strict_p, FALSE, FALSE);\n }\n@@ -3636,7 +3636,7 @@ frv_legitimize_tls_address (rtx addr, enum tls_model model)\n rtx\n frv_legitimize_address (rtx x,\n \t\t\trtx oldx ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n@@ -3765,7 +3765,7 @@ frv_find_base_term (rtx x)\n    the operand is used by a predicated instruction.  */\n \n int\n-frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n+frv_legitimate_memory_operand (rtx op, machine_mode mode, int condexec_p)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == MEM\n@@ -3906,9 +3906,9 @@ frv_function_symbol_referenced_p (rtx x)\n    executed.  */\n \n int\n-condexec_memory_operand (rtx op, enum machine_mode mode)\n+condexec_memory_operand (rtx op, machine_mode mode)\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n   rtx addr;\n \n   if (mode != VOIDmode && op_mode != mode)\n@@ -3950,7 +3950,7 @@ direct_return_p (void)\n \n \f\n void\n-frv_emit_move (enum machine_mode mode, rtx dest, rtx src)\n+frv_emit_move (machine_mode mode, rtx dest, rtx src)\n {\n   if (GET_CODE (src) == SYMBOL_REF)\n     {\n@@ -4248,7 +4248,7 @@ output_move_single (rtx operands[], rtx insn)\n   if (GET_CODE (dest) == REG)\n     {\n       int dest_regno = REGNO (dest);\n-      enum machine_mode mode = GET_MODE (dest);\n+      machine_mode mode = GET_MODE (dest);\n \n       if (GPR_P (dest_regno))\n \t{\n@@ -4386,7 +4386,7 @@ output_move_single (rtx operands[], rtx insn)\n       if (GET_CODE (src) == REG)\n \t{\n \t  int src_regno = REGNO (src);\n-\t  enum machine_mode mode = GET_MODE (dest);\n+\t  machine_mode mode = GET_MODE (dest);\n \n \t  if (GPR_P (src_regno))\n \t    {\n@@ -4459,7 +4459,7 @@ output_move_double (rtx operands[], rtx insn)\n {\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n-  enum machine_mode mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (dest);\n \n   if (GET_CODE (dest) == REG)\n     {\n@@ -4594,7 +4594,7 @@ output_condmove_single (rtx operands[], rtx insn)\n   if (GET_CODE (dest) == REG)\n     {\n       int dest_regno = REGNO (dest);\n-      enum machine_mode mode = GET_MODE (dest);\n+      machine_mode mode = GET_MODE (dest);\n \n       if (GPR_P (dest_regno))\n \t{\n@@ -4670,7 +4670,7 @@ output_condmove_single (rtx operands[], rtx insn)\n       if (GET_CODE (src) == REG)\n \t{\n \t  int src_regno = REGNO (src);\n-\t  enum machine_mode mode = GET_MODE (dest);\n+\t  machine_mode mode = GET_MODE (dest);\n \n \t  if (GPR_P (src_regno))\n \t    {\n@@ -4697,7 +4697,7 @@ output_condmove_single (rtx operands[], rtx insn)\n \n       else if (ZERO_P (src))\n \t{\n-\t  enum machine_mode mode = GET_MODE (dest);\n+\t  machine_mode mode = GET_MODE (dest);\n \t  switch (mode)\n \t    {\n \t    default:\n@@ -4727,7 +4727,7 @@ output_condmove_single (rtx operands[], rtx insn)\n static rtx\n frv_emit_comparison (enum rtx_code test, rtx op0, rtx op1)\n {\n-  enum machine_mode cc_mode;\n+  machine_mode cc_mode;\n   rtx cc_reg;\n \n   /* Floating point doesn't have comparison against a constant.  */\n@@ -4761,7 +4761,7 @@ frv_emit_cond_branch (rtx operands[])\n   rtx if_else;\n   enum rtx_code test = GET_CODE (operands[0]);\n   rtx cc_reg = frv_emit_comparison (test, operands[1], operands[2]);\n-  enum machine_mode cc_mode = GET_MODE (cc_reg);\n+  machine_mode cc_mode = GET_MODE (cc_reg);\n \n   /* Branches generate:\n \t(set (pc)\n@@ -4856,7 +4856,7 @@ frv_emit_cond_move (rtx dest, rtx test_rtx, rtx src1, rtx src2)\n   enum rtx_code test = GET_CODE (test_rtx);\n   rtx cc_reg = frv_emit_comparison (test,\n \t\t\t\t    XEXP (test_rtx, 0), XEXP (test_rtx, 1));\n-  enum machine_mode cc_mode = GET_MODE (cc_reg);\n+  machine_mode cc_mode = GET_MODE (cc_reg);\n \n   /* Conditional move instructions generate:\n \t(parallel [(set <target>\n@@ -4933,7 +4933,7 @@ frv_split_cond_move (rtx operands[])\n   rtx src2\t= operands[4];\n   rtx cr_reg\t= operands[5];\n   rtx ret;\n-  enum machine_mode cr_mode = GET_MODE (cr_reg);\n+  machine_mode cr_mode = GET_MODE (cr_reg);\n \n   start_sequence ();\n \n@@ -5086,7 +5086,7 @@ frv_split_minmax (rtx operands[])\n   rtx cr_reg\t= operands[5];\n   rtx ret;\n   enum rtx_code test_code;\n-  enum machine_mode cr_mode = GET_MODE (cr_reg);\n+  machine_mode cr_mode = GET_MODE (cr_reg);\n \n   start_sequence ();\n \n@@ -5278,7 +5278,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n   rtx cr;\n   rtx cc;\n   rtx nested_cc;\n-  enum machine_mode mode = GET_MODE (true_expr);\n+  machine_mode mode = GET_MODE (true_expr);\n   int j;\n   basic_block *bb;\n   int num_bb;\n@@ -5644,7 +5644,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block *ce_info,\n   rtx compare;\n   rtx cc;\n   enum reg_class cr_class;\n-  enum machine_mode mode = GET_MODE (true_expr);\n+  machine_mode mode = GET_MODE (true_expr);\n   rtx (*logical_func)(rtx, rtx, rtx);\n \n   if (TARGET_DEBUG_COND_EXEC)\n@@ -5827,7 +5827,7 @@ frv_ifcvt_load_value (rtx value, rtx insn ATTRIBUTE_UNUSED)\n    into a temporary register, or the new MEM if we were successful.  */\n \n static rtx\n-frv_ifcvt_rewrite_mem (rtx mem, enum machine_mode mode, rtx insn)\n+frv_ifcvt_rewrite_mem (rtx mem, machine_mode mode, rtx insn)\n {\n   rtx addr = XEXP (mem, 0);\n \n@@ -5980,7 +5980,7 @@ frv_ifcvt_modify_insn (ce_if_block *ce_info,\n     {\n       rtx dest = SET_DEST (set);\n       rtx src = SET_SRC (set);\n-      enum machine_mode mode = GET_MODE (dest);\n+      machine_mode mode = GET_MODE (dest);\n \n       /* Check for normal binary operators.  */\n       if (mode == SImode && ARITHMETIC_P (src))\n@@ -6367,7 +6367,7 @@ frv_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \n enum reg_class\n frv_secondary_reload_class (enum reg_class rclass,\n-                            enum machine_mode mode ATTRIBUTE_UNUSED,\n+                            machine_mode mode ATTRIBUTE_UNUSED,\n                             rtx x)\n {\n   enum reg_class ret;\n@@ -6428,7 +6428,7 @@ frv_secondary_reload_class (enum reg_class rclass,\n    \n static reg_class_t\n frv_secondary_reload (bool in_p, rtx x, reg_class_t reload_class_i,\n-\t\t      enum machine_mode reload_mode,\n+\t\t      machine_mode reload_mode,\n \t\t      secondary_reload_info * sri)\n {\n   enum reg_class rclass = NO_REGS;\n@@ -6635,7 +6635,7 @@ frv_adjust_field_align (tree field, int computed)\n    pattern's constraint asks for one.  */\n \n int\n-frv_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+frv_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   int base;\n   int mask;\n@@ -6718,7 +6718,7 @@ frv_hard_regno_mode_ok (int regno, enum machine_mode mode)\n    for each byte.  */\n \n int\n-frv_hard_regno_nregs (int regno, enum machine_mode mode)\n+frv_hard_regno_nregs (int regno, machine_mode mode)\n {\n   if (ACCG_P (regno))\n     return GET_MODE_SIZE (mode);\n@@ -6740,7 +6740,7 @@ frv_hard_regno_nregs (int regno, enum machine_mode mode)\n    This declaration is required.  */\n \n int\n-frv_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n+frv_class_max_nregs (enum reg_class rclass, machine_mode mode)\n {\n   if (rclass == ACCG_REGS)\n     /* An N-byte value requires N accumulator guards.  */\n@@ -6756,7 +6756,7 @@ frv_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n    definition for this macro on machines where anything `CONSTANT_P' is valid.  */\n \n static bool\n-frv_legitimate_constant_p (enum machine_mode mode, rtx x)\n+frv_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   /* frv_cannot_force_const_mem always returns true for FDPIC.  This\n      means that the move expanders will be expected to deal with most\n@@ -6803,7 +6803,7 @@ frv_legitimate_constant_p (enum machine_mode mode, rtx x)\n    is enough, CC_UNS for other unsigned comparisons, and CC for other\n    signed comparisons.  */\n \n-enum machine_mode\n+machine_mode\n frv_select_cc_mode (enum rtx_code code, rtx x, rtx y)\n {\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n@@ -6836,7 +6836,7 @@ frv_select_cc_mode (enum rtx_code code, rtx x, rtx y)\n #define LOW_COST 1\n \n static int\n-frv_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+frv_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\treg_class_t from, reg_class_t to)\n {\n   switch (from)\n@@ -6940,7 +6940,7 @@ frv_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Worker function for TARGET_MEMORY_MOVE_COST.  */\n \n static int\n-frv_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+frv_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n                       reg_class_t rclass ATTRIBUTE_UNUSED,\n                       bool in ATTRIBUTE_UNUSED)\n {\n@@ -8701,8 +8701,8 @@ frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n /* If an ACC rtx has mode MODE, return the mode that the matching ACCG\n    should have.  */\n \n-static enum machine_mode\n-frv_matching_accg_mode (enum machine_mode mode)\n+static machine_mode\n+frv_matching_accg_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -8756,7 +8756,7 @@ frv_read_argument (tree exp, unsigned int index)\n    of an IACC register and return a (reg:MODE ...) rtx for it.  */\n \n static rtx\n-frv_read_iacc_argument (enum machine_mode mode, tree call,\n+frv_read_iacc_argument (machine_mode mode, tree call,\n \t\t\tunsigned int index)\n {\n   int i, regno;\n@@ -8809,7 +8809,7 @@ frv_check_constant_argument (enum insn_code icode, int opnum, rtx opval)\n static rtx\n frv_legitimize_target (enum insn_code icode, rtx target)\n {\n-  enum machine_mode mode = insn_data[icode].operand[0].mode;\n+  machine_mode mode = insn_data[icode].operand[0].mode;\n \n   if (! target\n       || GET_MODE (target) != mode\n@@ -8827,7 +8827,7 @@ frv_legitimize_target (enum insn_code icode, rtx target)\n static rtx\n frv_legitimize_argument (enum insn_code icode, int opnum, rtx arg)\n {\n-  enum machine_mode mode = insn_data[icode].operand[opnum].mode;\n+  machine_mode mode = insn_data[icode].operand[opnum].mode;\n \n   if ((*insn_data[icode].operand[opnum].predicate) (arg, mode))\n     return arg;\n@@ -8838,7 +8838,7 @@ frv_legitimize_argument (enum insn_code icode, int opnum, rtx arg)\n /* Return a volatile memory reference of mode MODE whose address is ARG.  */\n \n static rtx\n-frv_volatile_memref (enum machine_mode mode, rtx arg)\n+frv_volatile_memref (machine_mode mode, rtx arg)\n {\n   rtx mem;\n \n@@ -8970,7 +8970,7 @@ frv_expand_voidbinop_builtin (enum insn_code icode, tree call)\n   rtx pat;\n   rtx op0 = frv_read_argument (call, 0);\n   rtx op1 = frv_read_argument (call, 1);\n-  enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[0].mode;\n   rtx addr;\n \n   if (GET_CODE (op0) != MEM)\n@@ -9099,7 +9099,7 @@ frv_expand_voidaccop_builtin (enum insn_code icode, tree call)\n    membar and TARGET_MODE is the mode that the loaded value should have.  */\n \n static rtx\n-frv_expand_load_builtin (enum insn_code icode, enum machine_mode target_mode,\n+frv_expand_load_builtin (enum insn_code icode, machine_mode target_mode,\n                          tree call, rtx target)\n {\n   rtx op0 = frv_read_argument (call, 0);\n@@ -9252,7 +9252,7 @@ frv_expand_mwtacc_builtin (enum insn_code icode, tree call)\n static void\n frv_split_iacc_move (rtx dest, rtx src)\n {\n-  enum machine_mode inner;\n+  machine_mode inner;\n   int i;\n \n   inner = GET_MODE (dest);\n@@ -9267,7 +9267,7 @@ static rtx\n frv_expand_builtin (tree exp,\n                     rtx target,\n                     rtx subtarget ATTRIBUTE_UNUSED,\n-                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                    machine_mode mode ATTRIBUTE_UNUSED,\n                     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);"}, {"sha": "2aa4da78a4715511377a935f80503c01288f6b25", "filename": "gcc/config/frv/predicates.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1216,7 +1216,7 @@\n (define_predicate \"ccr_eqne_operator\"\n   (match_code \"eq,ne\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n   rtx op0;\n   rtx op1;\n   int regno;\n@@ -1279,7 +1279,7 @@\n (define_predicate \"condexec_si_binary_operator\"\n   (match_code \"plus,minus,and,ior,xor,ashift,ashiftrt,lshiftrt\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n@@ -1307,7 +1307,7 @@\n (define_predicate \"condexec_si_media_operator\"\n   (match_code \"and,ior,xor\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n@@ -1330,7 +1330,7 @@\n (define_predicate \"condexec_si_divide_operator\"\n   (match_code \"div,udiv\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n@@ -1352,7 +1352,7 @@\n (define_predicate \"condexec_si_unary_operator\"\n   (match_code \"not,neg\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n@@ -1375,7 +1375,7 @@\n (define_predicate \"condexec_sf_add_operator\"\n   (match_code \"plus,minus\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;\n@@ -1397,7 +1397,7 @@\n (define_predicate \"condexec_sf_conv_operator\"\n   (match_code \"abs,neg\")\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n+  machine_mode op_mode = GET_MODE (op);\n \n   if (mode != VOIDmode && op_mode != mode)\n     return FALSE;"}, {"sha": "39e970f243f7da8322dc79e0780baab8f613ba20", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -36,22 +36,22 @@ extern const char *output_simode_bld (int, rtx[]);\n extern void final_prescan_insn (rtx_insn *, rtx *, int);\n extern int h8300_expand_movsi (rtx[]);\n extern void notice_update_cc (rtx, rtx_insn *);\n-extern const char *output_logical_op (enum machine_mode, rtx *);\n-extern unsigned int compute_logical_op_length (enum machine_mode,\n+extern const char *output_logical_op (machine_mode, rtx *);\n+extern unsigned int compute_logical_op_length (machine_mode,\n \t\t\t\t\t       rtx *);\n #ifdef HAVE_ATTR_cc\n extern enum attr_cc compute_plussi_cc (rtx *);\n extern enum attr_cc compute_a_shift_cc (rtx, rtx *);\n-extern enum attr_cc compute_logical_op_cc (enum machine_mode, rtx *);\n+extern enum attr_cc compute_logical_op_cc (machine_mode, rtx *);\n #endif\n extern void h8300_expand_branch (rtx[]);\n extern void h8300_expand_store (rtx[]);\n-extern bool expand_a_shift (enum machine_mode, enum rtx_code, rtx[]);\n-extern int h8300_shift_needs_scratch_p (int, enum machine_mode);\n+extern bool expand_a_shift (machine_mode, enum rtx_code, rtx[]);\n+extern int h8300_shift_needs_scratch_p (int, machine_mode);\n extern int expand_a_rotate (rtx[]);\n extern int fix_bit_operand (rtx *, enum rtx_code);\n extern int h8300_adjust_insn_length (rtx, int);\n-extern void split_adds_subs (enum machine_mode, rtx[]);\n+extern void split_adds_subs (machine_mode, rtx[]);\n \n extern int h8300_eightbit_constant_address_p (rtx);\n extern int h8300_tiny_constant_address_p (rtx);\n@@ -81,7 +81,7 @@ enum h8sx_shift_type {\n   H8SX_SHIFT_BINARY\n };\n \n-extern enum h8sx_shift_type h8sx_classify_shift (enum machine_mode, enum rtx_code, rtx);\n+extern enum h8sx_shift_type h8sx_classify_shift (machine_mode, enum rtx_code, rtx);\n extern int h8300_ldm_stm_parallel (rtvec, int, int);\n #endif /* RTX_CODE */\n \n@@ -99,8 +99,8 @@ extern int h8300_current_function_monitor_function_p (void);\n extern int h8300_initial_elimination_offset (int, int);\n extern int h8300_regs_ok_for_stm (int, rtx[]);\n extern int h8300_hard_regno_rename_ok (unsigned int, unsigned int);\n-extern int h8300_hard_regno_nregs (int, enum machine_mode);\n-extern int h8300_hard_regno_mode_ok (int, enum machine_mode);\n+extern int h8300_hard_regno_nregs (int, machine_mode);\n+extern int h8300_hard_regno_mode_ok (int, machine_mode);\n extern bool h8300_move_ok (rtx, rtx);\n \n struct cpp_reader;"}, {"sha": "7f5ef5b2c288b27539ca0de51d38aeb2c2ad3035", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -115,7 +115,7 @@ static bool h8300_print_operand_punct_valid_p (unsigned char code);\n #ifndef OBJECT_FORMAT_ELF\n static void h8300_asm_named_section (const char *, unsigned int, tree);\n #endif\n-static int h8300_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n+static int h8300_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int h8300_and_costs (rtx);\n static int h8300_shift_costs (rtx);\n static void          h8300_push_pop               (int, int, bool, bool);\n@@ -133,7 +133,7 @@ static unsigned int  h8300_binary_length          (rtx_insn *, const h8300_lengt\n static bool          h8300_short_move_mem_p       (rtx, enum rtx_code);\n static unsigned int  h8300_move_length            (rtx *, const h8300_length_table *);\n static bool\t     h8300_hard_regno_scratch_ok  (unsigned int);\n-static rtx\t     h8300_get_index (rtx, enum machine_mode mode, int *);\n+static rtx\t     h8300_get_index (rtx, machine_mode mode, int *);\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -1014,7 +1014,7 @@ h8300_file_end (void)\n    instead of adds/subs.  */\n \n void\n-split_adds_subs (enum machine_mode mode, rtx *operands)\n+split_adds_subs (machine_mode mode, rtx *operands)\n {\n   HOST_WIDE_INT val = INTVAL (operands[1]);\n   rtx reg = operands[0];\n@@ -1087,7 +1087,7 @@ h8300_pr_saveall (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n    case the first 3 arguments are passed in registers.  */\n \n static rtx\n-h8300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+h8300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1160,7 +1160,7 @@ h8300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-h8300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+h8300_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1178,7 +1178,7 @@ h8300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n    shortcuts.  */\n \n static int\n-h8300_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+h8300_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n                          reg_class_t from, reg_class_t to)\n {\n   if (from == MAC_REGS || to == MAC_REG)\n@@ -2117,7 +2117,7 @@ notice_update_cc (rtx body, rtx_insn *insn)\n    if the address is known to be valid, but its mode is unknown.  */\n \n static rtx\n-h8300_get_index (rtx x, enum machine_mode mode, int *size)\n+h8300_get_index (rtx x, machine_mode mode, int *size)\n {\n   int dummy, factor;\n \n@@ -2792,7 +2792,7 @@ compute_mov_length (rtx *operands)\n      length, assuming the largest addressing mode is used, and then\n      adjust later in the function.  Otherwise, we compute and return\n      the exact length in one step.  */\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtx dest = operands[0];\n   rtx src = operands[1];\n   rtx addr;\n@@ -3042,7 +3042,7 @@ compute_mov_length (rtx *operands)\n const char *\n output_plussi (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   gcc_assert (mode == SImode);\n \n@@ -3126,7 +3126,7 @@ output_plussi (rtx *operands)\n unsigned int\n compute_plussi_length (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   gcc_assert (mode == SImode);\n \n@@ -3205,7 +3205,7 @@ compute_plussi_length (rtx *operands)\n enum attr_cc\n compute_plussi_cc (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   gcc_assert (mode == SImode);\n \n@@ -3260,7 +3260,7 @@ compute_plussi_cc (rtx *operands)\n /* Output a logical insn.  */\n \n const char *\n-output_logical_op (enum machine_mode mode, rtx *operands)\n+output_logical_op (machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -3441,7 +3441,7 @@ output_logical_op (enum machine_mode mode, rtx *operands)\n /* Compute the length of a logical insn.  */\n \n unsigned int\n-compute_logical_op_length (enum machine_mode mode, rtx *operands)\n+compute_logical_op_length (machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -3587,7 +3587,7 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n /* Compute which flag bits are valid after a logical insn.  */\n \n enum attr_cc\n-compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n+compute_logical_op_cc (machine_mode mode, rtx *operands)\n {\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n@@ -3745,7 +3745,7 @@ h8300_expand_store (rtx operands[])\n /* Classify a shift with the given mode and code.  OP is the shift amount.  */\n \n enum h8sx_shift_type\n-h8sx_classify_shift (enum machine_mode mode, enum rtx_code code, rtx op)\n+h8sx_classify_shift (machine_mode mode, enum rtx_code code, rtx op)\n {\n   if (!TARGET_H8300SX)\n     return H8SX_SHIFT_NONE;\n@@ -3837,7 +3837,7 @@ output_h8sx_shift (rtx *operands, int suffix, int optype)\n /* Emit code to do shifts.  */\n \n bool\n-expand_a_shift (enum machine_mode mode, enum rtx_code code, rtx operands[])\n+expand_a_shift (machine_mode mode, enum rtx_code code, rtx operands[])\n {\n   switch (h8sx_classify_shift (mode, code, operands[2]))\n     {\n@@ -4516,7 +4516,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n    needed for some shift with COUNT and MODE.  Return 0 otherwise.  */\n \n int\n-h8300_shift_needs_scratch_p (int count, enum machine_mode mode)\n+h8300_shift_needs_scratch_p (int count, machine_mode mode)\n {\n   enum h8_cpu cpu;\n   int a, lr, ar;\n@@ -4569,7 +4569,7 @@ output_a_shift (rtx *operands)\n {\n   static int loopend_lab;\n   rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n+  machine_mode mode = GET_MODE (shift);\n   enum rtx_code code = GET_CODE (shift);\n   enum shift_type shift_type;\n   enum shift_mode shift_mode;\n@@ -4739,7 +4739,7 @@ unsigned int\n compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n   rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n+  machine_mode mode = GET_MODE (shift);\n   enum rtx_code code = GET_CODE (shift);\n   enum shift_type shift_type;\n   enum shift_mode shift_mode;\n@@ -4887,7 +4887,7 @@ enum attr_cc\n compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n   rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n+  machine_mode mode = GET_MODE (shift);\n   enum rtx_code code = GET_CODE (shift);\n   enum shift_type shift_type;\n   enum shift_mode shift_mode;\n@@ -4982,7 +4982,7 @@ expand_a_rotate (rtx operands[])\n   rtx dst = operands[0];\n   rtx src = operands[1];\n   rtx rotate_amount = operands[2];\n-  enum machine_mode mode = GET_MODE (dst);\n+  machine_mode mode = GET_MODE (dst);\n \n   if (h8sx_classify_shift (mode, ROTATE, rotate_amount) == H8SX_SHIFT_UNARY)\n     return false;\n@@ -5066,7 +5066,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n   const char *insn_buf;\n   int bits;\n   int amount;\n-  enum machine_mode mode = GET_MODE (dst);\n+  machine_mode mode = GET_MODE (dst);\n \n   gcc_assert (GET_CODE (rotate_amount) == CONST_INT);\n \n@@ -5169,7 +5169,7 @@ compute_a_rotate_length (rtx *operands)\n {\n   rtx src = operands[1];\n   rtx amount_rtx = operands[2];\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n   int amount;\n   unsigned int length = 0;\n \n@@ -5848,7 +5848,7 @@ h8300_rtx_ok_for_base_p (rtx x, int strict)\n    CONSTANT_ADDRESS.  */\n \n static bool\n-h8300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+h8300_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   /* The register indirect addresses like @er0 is always valid.  */\n   if (h8300_rtx_ok_for_base_p (x, strict))\n@@ -5880,15 +5880,15 @@ h8300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    types on the H8 series to handle more than 32bits.  */\n \n int\n-h8300_hard_regno_nregs (int regno ATTRIBUTE_UNUSED, enum machine_mode mode)\n+h8300_hard_regno_nregs (int regno ATTRIBUTE_UNUSED, machine_mode mode)\n {\n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n /* Worker function for HARD_REGNO_MODE_OK.  */\n \n int\n-h8300_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+h8300_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   if (TARGET_H8300)\n     /* If an even reg, then anything goes.  Otherwise the mode must be\n@@ -5962,7 +5962,7 @@ h8300_function_value (const_tree ret_type,\n    On the H8 the return value is in R0/R1.  */\n \n static rtx\n-h8300_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+h8300_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, R0_REG);\n }"}, {"sha": "dc0678858fa458b44bfff56315fed585d6c4897a", "filename": "gcc/config/i386/i386-builtin-types.awk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -179,7 +179,7 @@ END {\n     # The vector types are defined via two tables defining the real\n     # machine mode and the builtin primitive type.  We use two tables\n     # rather than a structure to avoid structure padding and save space.\n-    print \"static const enum machine_mode ix86_builtin_type_vect_mode[] = {\"\n+    print \"static const machine_mode ix86_builtin_type_vect_mode[] = {\"\n     for (i = 0; i < vect_defs; ++i) {\n \tif (i == 0)\n \t    printf \"  \""}, {"sha": "81a1f11a18753079c7c5f6208aed38bacbe8e98a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -52,11 +52,11 @@ extern bool symbolic_reference_mentioned_p (rtx);\n extern bool extended_reg_mentioned_p (rtx);\n extern bool x86_extended_QIreg_mentioned_p (rtx_insn *);\n extern bool x86_extended_reg_mentioned_p (rtx);\n-extern bool x86_maybe_negate_const_int (rtx *, enum machine_mode);\n-extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n+extern bool x86_maybe_negate_const_int (rtx *, machine_mode);\n+extern machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n \n-extern int avx_vpermilp_parallel (rtx par, enum machine_mode mode);\n-extern int avx_vperm2f128_parallel (rtx par, enum machine_mode mode);\n+extern int avx_vpermilp_parallel (rtx par, machine_mode mode);\n+extern int avx_vperm2f128_parallel (rtx par, machine_mode mode);\n \n extern bool ix86_expand_strlen (rtx, rtx, rtx, rtx);\n extern bool ix86_expand_set_or_movmem (rtx, rtx, rtx, rtx, rtx, rtx,\n@@ -65,12 +65,12 @@ extern bool ix86_expand_set_or_movmem (rtx, rtx, rtx, rtx, rtx, rtx,\n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n extern bool legitimate_pic_address_disp_p (rtx);\n-extern bool ix86_legitimize_reload_address (rtx, enum machine_mode,\n+extern bool ix86_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t    int, int, int);\n extern void print_reg (rtx, int, FILE*);\n extern void ix86_print_operand (FILE *, rtx, int);\n \n-extern void split_double_mode (enum machine_mode, rtx[], int, rtx[], rtx[]);\n+extern void split_double_mode (machine_mode, rtx[], int, rtx[], rtx[]);\n \n extern const char *output_set_got (rtx, rtx);\n extern const char *output_387_binary_op (rtx, rtx*);\n@@ -81,30 +81,30 @@ extern const char *output_adjust_stack_and_probe (rtx);\n extern const char *output_probe_stack_range (rtx, rtx);\n \n extern void ix86_expand_clear (rtx);\n-extern void ix86_expand_move (enum machine_mode, rtx[]);\n-extern void ix86_expand_vector_move (enum machine_mode, rtx[]);\n-extern void ix86_expand_vector_move_misalign (enum machine_mode, rtx[]);\n+extern void ix86_expand_move (machine_mode, rtx[]);\n+extern void ix86_expand_vector_move (machine_mode, rtx[]);\n+extern void ix86_expand_vector_move_misalign (machine_mode, rtx[]);\n extern rtx ix86_fixup_binary_operands (enum rtx_code,\n-\t\t\t\t       enum machine_mode, rtx[]);\n+\t\t\t\t       machine_mode, rtx[]);\n extern void ix86_fixup_binary_operands_no_copy (enum rtx_code,\n-\t\t\t\t\t\tenum machine_mode, rtx[]);\n+\t\t\t\t\t\tmachine_mode, rtx[]);\n extern void ix86_expand_binary_operator (enum rtx_code,\n-\t\t\t\t\t enum machine_mode, rtx[]);\n+\t\t\t\t\t machine_mode, rtx[]);\n extern void ix86_expand_vector_logical_operator (enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx[]);\n-extern bool ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n+\t\t\t\t\t\t machine_mode, rtx[]);\n+extern bool ix86_binary_operator_ok (enum rtx_code, machine_mode, rtx[]);\n extern bool ix86_avoid_lea_for_add (rtx_insn *, rtx[]);\n extern bool ix86_use_lea_for_mov (rtx_insn *, rtx[]);\n extern bool ix86_avoid_lea_for_addr (rtx_insn *, rtx[]);\n-extern void ix86_split_lea_for_addr (rtx_insn *, rtx[], enum machine_mode);\n+extern void ix86_split_lea_for_addr (rtx_insn *, rtx[], machine_mode);\n extern bool ix86_lea_for_add_ok (rtx_insn *, rtx[]);\n extern bool ix86_vec_interleave_v2df_operator_ok (rtx operands[3], bool high);\n extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);\n extern bool ix86_agi_dependent (rtx_insn *set_insn, rtx_insn *use_insn);\n-extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n+extern void ix86_expand_unary_operator (enum rtx_code, machine_mode,\n \t\t\t\t\trtx[]);\n-extern rtx ix86_build_const_vector (enum machine_mode, bool, rtx);\n-extern rtx ix86_build_signbit_mask (enum machine_mode, bool, bool);\n+extern rtx ix86_build_const_vector (machine_mode, bool, rtx);\n+extern rtx ix86_build_signbit_mask (machine_mode, bool, bool);\n extern void ix86_split_convert_uns_si_sse (rtx[]);\n extern void ix86_expand_convert_uns_didf_sse (rtx, rtx);\n extern void ix86_expand_convert_uns_sixf_sse (rtx, rtx);\n@@ -114,13 +114,13 @@ extern void ix86_expand_convert_sign_didf_sse (rtx, rtx);\n extern void ix86_expand_vector_convert_uns_vsivsf (rtx, rtx);\n extern rtx ix86_expand_adjust_ufix_to_sfix_si (rtx, rtx *);\n extern enum ix86_fpcmp_strategy ix86_fp_comparison_strategy (enum rtx_code);\n-extern void ix86_expand_fp_absneg_operator (enum rtx_code, enum machine_mode,\n+extern void ix86_expand_fp_absneg_operator (enum rtx_code, machine_mode,\n \t\t\t\t\t    rtx[]);\n extern void ix86_expand_copysign (rtx []);\n extern void ix86_split_copysign_const (rtx []);\n extern void ix86_split_copysign_var (rtx []);\n-extern bool ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n-extern bool ix86_match_ccmode (rtx, enum machine_mode);\n+extern bool ix86_unary_operator_ok (enum rtx_code, machine_mode, rtx[]);\n+extern bool ix86_match_ccmode (rtx, machine_mode);\n extern void ix86_expand_branch (enum rtx_code, rtx, rtx, rtx);\n extern void ix86_expand_setcc (rtx, enum rtx_code, rtx, rtx);\n extern bool ix86_expand_int_movcc (rtx[]);\n@@ -136,34 +136,34 @@ extern void ix86_split_call_vzeroupper (rtx, rtx);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);\n extern rtx ix86_zero_extend_to_Pmode (rtx);\n extern void ix86_split_long_move (rtx[]);\n-extern void ix86_split_ashl (rtx *, rtx, enum machine_mode);\n-extern void ix86_split_ashr (rtx *, rtx, enum machine_mode);\n-extern void ix86_split_lshr (rtx *, rtx, enum machine_mode);\n+extern void ix86_split_ashl (rtx *, rtx, machine_mode);\n+extern void ix86_split_ashr (rtx *, rtx, machine_mode);\n+extern void ix86_split_lshr (rtx *, rtx, machine_mode);\n extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n-extern void ix86_split_idivmod (enum machine_mode, rtx[], bool);\n+extern void ix86_split_idivmod (machine_mode, rtx[], bool);\n \n-extern rtx assign_386_stack_local (enum machine_mode, enum ix86_stack_slot);\n+extern rtx assign_386_stack_local (machine_mode, enum ix86_stack_slot);\n extern int ix86_attr_length_immediate_default (rtx_insn *, bool);\n extern int ix86_attr_length_address_default (rtx_insn *);\n extern int ix86_attr_length_vex_default (rtx_insn *, bool, bool);\n \n-extern enum machine_mode ix86_fp_compare_mode (enum rtx_code);\n+extern machine_mode ix86_fp_compare_mode (enum rtx_code);\n \n-extern rtx ix86_libcall_value (enum machine_mode);\n+extern rtx ix86_libcall_value (machine_mode);\n extern bool ix86_function_arg_regno_p (int);\n extern void ix86_asm_output_function_label (FILE *, const char *, tree);\n extern void ix86_call_abi_override (const_tree);\n extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx);\n-extern bool ix86_hard_regno_mode_ok (int, enum machine_mode);\n-extern bool ix86_modes_tieable_p (enum machine_mode, enum machine_mode);\n+extern bool ix86_hard_regno_mode_ok (int, machine_mode);\n+extern bool ix86_modes_tieable_p (machine_mode, machine_mode);\n extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t  enum machine_mode, int);\n-extern bool ix86_cannot_change_mode_class (enum machine_mode,\n-\t\t\t\t\t   enum machine_mode, enum reg_class);\n+\t\t\t\t\t  machine_mode, int);\n+extern bool ix86_cannot_change_mode_class (machine_mode,\n+\t\t\t\t\t   machine_mode, enum reg_class);\n \n extern bool ix86_libc_has_function (enum function_class fn_class);\n \n@@ -174,10 +174,10 @@ extern void ix86_emit_fp_unordered_jump (rtx);\n \n extern void ix86_emit_i387_log1p (rtx, rtx);\n extern void ix86_emit_i387_round (rtx, rtx);\n-extern void ix86_emit_swdivsf (rtx, rtx, rtx, enum machine_mode);\n-extern void ix86_emit_swsqrtsf (rtx, rtx, enum machine_mode, bool);\n+extern void ix86_emit_swdivsf (rtx, rtx, rtx, machine_mode);\n+extern void ix86_emit_swsqrtsf (rtx, rtx, machine_mode, bool);\n \n-extern enum rtx_code ix86_reverse_condition (enum rtx_code, enum machine_mode);\n+extern enum rtx_code ix86_reverse_condition (enum rtx_code, machine_mode);\n \n extern void ix86_expand_lround (rtx, rtx);\n extern void ix86_expand_lfloorceil (rtx, rtx, bool);\n@@ -200,9 +200,9 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n \n #ifdef TREE_CODE\n extern int ix86_data_alignment (tree, int, bool);\n-extern unsigned int ix86_local_alignment (tree, enum machine_mode,\n+extern unsigned int ix86_local_alignment (tree, machine_mode,\n \t\t\t\t\t  unsigned int);\n-extern unsigned int ix86_minimum_alignment (tree, enum machine_mode,\n+extern unsigned int ix86_minimum_alignment (tree, machine_mode,\n \t\t\t\t\t    unsigned int);\n extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);"}, {"sha": "139b07c99768691379ac9590d1a08b925aca4e15", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 293, "deletions": 293, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -2415,12 +2415,12 @@ static bool ext_80387_constants_init = 0;\n static struct machine_function * ix86_init_machine_status (void);\n static rtx ix86_function_value (const_tree, const_tree, bool);\n static bool ix86_function_value_regno_p (const unsigned int);\n-static unsigned int ix86_function_arg_boundary (enum machine_mode,\n+static unsigned int ix86_function_arg_boundary (machine_mode,\n \t\t\t\t\t\tconst_tree);\n static rtx ix86_static_chain (const_tree, bool);\n static int ix86_function_regparm (const_tree, const_tree);\n static void ix86_compute_frame_layout (struct ix86_frame *);\n-static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n+static bool ix86_expand_vector_init_one_nonzero (bool, machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n static void ix86_add_new_builtins (HOST_WIDE_INT);\n static tree ix86_canonical_va_list_type (tree);\n@@ -5875,7 +5875,7 @@ ix86_legitimate_combined_insn (rtx_insn *insn)\n       for (i = 0; i < n_operands; i++)\n \t{\n \t  rtx op = recog_data.operand[i];\n-\t  enum machine_mode mode = GET_MODE (op);\n+\t  machine_mode mode = GET_MODE (op);\n \t  const operand_alternative *op_alt;\n \t  int offset = 0;\n \t  bool win;\n@@ -5999,7 +5999,7 @@ ix86_function_arg_regno_p (int regno)\n /* Return if we do not know how to pass TYPE solely in registers.  */\n \n static bool\n-ix86_must_pass_in_stack (enum machine_mode mode, const_tree type)\n+ix86_must_pass_in_stack (machine_mode mode, const_tree type)\n {\n   if (must_pass_in_stack_var_size_or_pad (mode, type))\n     return true;\n@@ -6341,11 +6341,11 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n    If INT_RETURN is true, warn ABI change if the vector mode isn't\n    available for function return value.  */\n \n-static enum machine_mode\n+static machine_mode\n type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t\t   bool in_return)\n {\n-  enum machine_mode mode = TYPE_MODE (type);\n+  machine_mode mode = TYPE_MODE (type);\n \n   if (TREE_CODE (type) == VECTOR_TYPE && !VECTOR_MODE_P (mode))\n     {\n@@ -6354,7 +6354,7 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t  /* ??? Generic code allows us to create width 1 vectors.  Ignore.  */\n \t  && TYPE_VECTOR_SUBPARTS (type) > 1)\n \t{\n-\t  enum machine_mode innermode = TYPE_MODE (TREE_TYPE (type));\n+\t  machine_mode innermode = TYPE_MODE (TREE_TYPE (type));\n \n \t  if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t    mode = MIN_MODE_VECTOR_FLOAT;\n@@ -6459,7 +6459,7 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n    go ahead and use it.  Otherwise we have to build a PARALLEL instead.  */\n \n static rtx\n-gen_reg_or_parallel (enum machine_mode mode, enum machine_mode orig_mode,\n+gen_reg_or_parallel (machine_mode mode, machine_mode orig_mode,\n \t\t     unsigned int regno)\n {\n   rtx tmp;\n@@ -6536,7 +6536,7 @@ merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n */\n \n static int\n-classify_argument (enum machine_mode mode, const_tree type,\n+classify_argument (machine_mode mode, const_tree type,\n \t\t   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset)\n {\n   HOST_WIDE_INT bytes =\n@@ -6939,7 +6939,7 @@ classify_argument (enum machine_mode mode, const_tree type,\n    class.  Return true iff parameter should be passed in memory.  */\n \n static bool\n-examine_argument (enum machine_mode mode, const_tree type, int in_return,\n+examine_argument (machine_mode mode, const_tree type, int in_return,\n \t\t  int *int_nregs, int *sse_nregs)\n {\n   enum x86_64_reg_class regclass[MAX_CLASSES];\n@@ -6982,7 +6982,7 @@ examine_argument (enum machine_mode mode, const_tree type, int in_return,\n    FUNCTION_ARG for the detailed description.  */\n \n static rtx\n-construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n+construct_container (machine_mode mode, machine_mode orig_mode,\n \t\t     const_tree type, int in_return, int nintregs, int nsseregs,\n \t\t     const int *intreg, int sse_regno)\n {\n@@ -6991,7 +6991,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   static bool issued_sse_ret_error;\n   static bool issued_x87_ret_error;\n \n-  enum machine_mode tmpmode;\n+  machine_mode tmpmode;\n   int bytes =\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   enum x86_64_reg_class regclass[MAX_CLASSES];\n@@ -7220,7 +7220,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n    may not be available.)  */\n \n static void\n-function_arg_advance_32 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t const_tree type, HOST_WIDE_INT bytes,\n \t\t\t HOST_WIDE_INT words)\n {\n@@ -7315,7 +7315,7 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static void\n-function_arg_advance_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+function_arg_advance_64 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t const_tree type, HOST_WIDE_INT words, bool named)\n {\n   int int_nregs, sse_nregs;\n@@ -7361,7 +7361,7 @@ function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n    may not be available.)  */\n \n static void\n-ix86_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -7398,8 +7398,8 @@ ix86_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-function_arg_32 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t enum machine_mode orig_mode, const_tree type,\n+function_arg_32 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n+\t\t machine_mode orig_mode, const_tree type,\n \t\t HOST_WIDE_INT bytes, HOST_WIDE_INT words)\n {\n   /* Avoid the AL settings for the Unix64 ABI.  */\n@@ -7508,8 +7508,8 @@ function_arg_32 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static rtx\n-function_arg_64 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t enum machine_mode orig_mode, const_tree type, bool named)\n+function_arg_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n+\t\t machine_mode orig_mode, const_tree type, bool named)\n {\n   /* Handle a hidden AL argument containing number of registers\n      for varargs x86-64 functions.  */\n@@ -7550,8 +7550,8 @@ function_arg_64 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n static rtx\n-function_arg_ms_64 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t    enum machine_mode orig_mode, bool named,\n+function_arg_ms_64 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n+\t\t    machine_mode orig_mode, bool named,\n \t\t    HOST_WIDE_INT bytes)\n {\n   unsigned int regno;\n@@ -7608,11 +7608,11 @@ function_arg_ms_64 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    ellipsis).  */\n \n static rtx\n-ix86_function_arg (cumulative_args_t cum_v, enum machine_mode omode,\n+ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n \t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  enum machine_mode mode = omode;\n+  machine_mode mode = omode;\n   HOST_WIDE_INT bytes, words;\n   rtx arg;\n \n@@ -7644,7 +7644,7 @@ ix86_function_arg (cumulative_args_t cum_v, enum machine_mode omode,\n    appropriate for passing a pointer to that type.  */\n \n static bool\n-ix86_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n+ix86_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n \t\t\tconst_tree type, bool)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -7688,7 +7688,7 @@ ix86_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n static bool\n ix86_compat_aligned_value_p (const_tree type)\n {\n-  enum machine_mode mode = TYPE_MODE (type);\n+  machine_mode mode = TYPE_MODE (type);\n   if (((TARGET_SSE && SSE_REG_MODE_P (mode))\n        || mode == TDmode\n        || mode == TFmode\n@@ -7737,7 +7737,7 @@ ix86_compat_aligned_value_p (const_tree type)\n    compatibility with previous versions of GCC.  */\n \n static unsigned int\n-ix86_compat_function_arg_boundary (enum machine_mode mode,\n+ix86_compat_function_arg_boundary (machine_mode mode,\n \t\t\t\t   const_tree type, unsigned int align)\n {\n   /* In 32bit, only _Decimal128 and __float128 are aligned to their\n@@ -7773,7 +7773,7 @@ ix86_compat_function_arg_boundary (enum machine_mode mode,\n static bool\n ix86_contains_aligned_value_p (const_tree type)\n {\n-  enum machine_mode mode = TYPE_MODE (type);\n+  machine_mode mode = TYPE_MODE (type);\n \n   if (mode == XFmode || mode == XCmode)\n     return false;\n@@ -7824,7 +7824,7 @@ ix86_contains_aligned_value_p (const_tree type)\n    specified mode and type.  */\n \n static unsigned int\n-ix86_function_arg_boundary (enum machine_mode mode, const_tree type)\n+ix86_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   unsigned int align;\n   if (type)\n@@ -7919,7 +7919,7 @@ ix86_function_value_regno_p (const unsigned int regno)\n    otherwise, FUNC is 0.  */\n \n static rtx\n-function_value_32 (enum machine_mode orig_mode, enum machine_mode mode,\n+function_value_32 (machine_mode orig_mode, machine_mode mode,\n \t\t   const_tree fntype, const_tree fn)\n {\n   unsigned int regno;\n@@ -7969,7 +7969,7 @@ function_value_32 (enum machine_mode orig_mode, enum machine_mode mode,\n }\n \n static rtx\n-function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n+function_value_64 (machine_mode orig_mode, machine_mode mode,\n \t\t   const_tree valtype)\n {\n   rtx ret;\n@@ -8022,7 +8022,7 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n }\n \n static rtx\n-function_value_ms_64 (enum machine_mode orig_mode, enum machine_mode mode,\n+function_value_ms_64 (machine_mode orig_mode, machine_mode mode,\n \t\t      const_tree valtype)\n {\n   unsigned int regno = AX_REG;\n@@ -8056,7 +8056,7 @@ function_value_ms_64 (enum machine_mode orig_mode, enum machine_mode mode,\n \n static rtx\n ix86_function_value_1 (const_tree valtype, const_tree fntype_or_decl,\n-\t\t       enum machine_mode orig_mode, enum machine_mode mode)\n+\t\t       machine_mode orig_mode, machine_mode mode)\n {\n   const_tree fn, fntype;\n \n@@ -8076,7 +8076,7 @@ ix86_function_value_1 (const_tree valtype, const_tree fntype_or_decl,\n static rtx\n ix86_function_value (const_tree valtype, const_tree fntype_or_decl, bool)\n {\n-  enum machine_mode mode, orig_mode;\n+  machine_mode mode, orig_mode;\n \n   orig_mode = TYPE_MODE (valtype);\n   mode = type_natural_mode (valtype, NULL, true);\n@@ -8086,8 +8086,8 @@ ix86_function_value (const_tree valtype, const_tree fntype_or_decl, bool)\n /* Pointer function arguments and return values are promoted to\n    word_mode.  */\n \n-static enum machine_mode\n-ix86_promote_function_mode (const_tree type, enum machine_mode mode,\n+static machine_mode\n+ix86_promote_function_mode (const_tree type, machine_mode mode,\n \t\t\t    int *punsignedp, const_tree fntype,\n \t\t\t    int for_return)\n {\n@@ -8104,7 +8104,7 @@ ix86_promote_function_mode (const_tree type, enum machine_mode mode,\n    should be accessed using BLKmode.  */\n \n static bool\n-ix86_member_type_forces_blk (const_tree field, enum machine_mode mode)\n+ix86_member_type_forces_blk (const_tree field, machine_mode mode)\n {\n   /* Union with XFmode must be in BLKmode.  */\n   return (mode == XFmode\n@@ -8113,7 +8113,7 @@ ix86_member_type_forces_blk (const_tree field, enum machine_mode mode)\n }\n \n rtx\n-ix86_libcall_value (enum machine_mode mode)\n+ix86_libcall_value (machine_mode mode)\n {\n   return ix86_function_value_1 (NULL, NULL, mode, mode);\n }\n@@ -8126,7 +8126,7 @@ ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n #ifdef SUBTARGET_RETURN_IN_MEMORY\n   return SUBTARGET_RETURN_IN_MEMORY (type, fntype);\n #else\n-  const enum machine_mode mode = type_natural_mode (type, NULL, true);\n+  const machine_mode mode = type_natural_mode (type, NULL, true);\n   HOST_WIDE_INT size;\n \n   if (TARGET_64BIT)\n@@ -8347,7 +8347,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n   if (ix86_varargs_fpr_size)\n     {\n-      enum machine_mode smode;\n+      machine_mode smode;\n       rtx_code_label *label;\n       rtx test;\n \n@@ -8415,7 +8415,7 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n }\n \n static void\n-ix86_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n+ix86_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t     tree type, int *, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -8604,7 +8604,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   rtx container;\n   int indirect_p = 0;\n   tree ptrtype;\n-  enum machine_mode nat_mode;\n+  machine_mode nat_mode;\n   unsigned int arg_boundary;\n \n   /* Only 64bit target needs something special.  */\n@@ -8766,7 +8766,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t    {\n \t      rtx slot = XVECEXP (container, 0, i);\n \t      rtx reg = XEXP (slot, 0);\n-\t      enum machine_mode mode = GET_MODE (reg);\n+\t      machine_mode mode = GET_MODE (reg);\n \t      tree piece_type;\n \t      tree addr_type;\n \t      tree daddr_type;\n@@ -8935,7 +8935,7 @@ init_ext_80387_constants (void)\n int\n standard_80387_constant_p (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   REAL_VALUE_TYPE r;\n \n@@ -9040,7 +9040,7 @@ standard_80387_constant_rtx (int idx)\n int\n standard_sse_constant_p (rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   if (x == const0_rtx || x == CONST0_RTX (GET_MODE (x)))\n     return 1;\n@@ -9949,7 +9949,7 @@ ix86_emit_save_regs (void)\n /* Emit a single register save at CFA - CFA_OFFSET.  */\n \n static void\n-ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n+ix86_emit_save_reg_using_mov (machine_mode mode, unsigned int regno,\n \t\t\t      HOST_WIDE_INT cfa_offset)\n {\n   struct machine_function *m = cfun->machine;\n@@ -12454,7 +12454,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n    requires to two regs - that would mean more pseudos with longer\n    lifetimes.  */\n static int\n-ix86_address_cost (rtx x, enum machine_mode, addr_space_t, bool)\n+ix86_address_cost (rtx x, machine_mode, addr_space_t, bool)\n {\n   struct ix86_address parts;\n   int cost = 1;\n@@ -12530,7 +12530,7 @@ darwin_local_data_pic (rtx disp)\n    satisfies CONSTANT_P.  */\n \n static bool\n-ix86_legitimate_constant_p (enum machine_mode, rtx x)\n+ix86_legitimate_constant_p (machine_mode, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -12616,7 +12616,7 @@ ix86_legitimate_constant_p (enum machine_mode, rtx x)\n    is checked above.  */\n \n static bool\n-ix86_cannot_force_const_mem (enum machine_mode mode, rtx x)\n+ix86_cannot_force_const_mem (machine_mode mode, rtx x)\n {\n   /* We can always put integral constants and vectors in memory.  */\n   switch (GET_CODE (x))\n@@ -12855,7 +12855,7 @@ legitimate_pic_address_disp_p (rtx disp)\n    0 if it should not.  */\n \n bool\n-ix86_legitimize_reload_address (rtx x, enum machine_mode, int opnum, int type,\n+ix86_legitimize_reload_address (rtx x, machine_mode, int opnum, int type,\n \t\t\t       \tint)\n {\n   /* Reload can generate:\n@@ -12912,7 +12912,7 @@ ix86_legitimize_reload_address (rtx x, enum machine_mode, int opnum, int type,\n static rtx\n ix86_validate_address_register (rtx op)\n {\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n \n   /* Only SImode or DImode registers can form the address.  */\n   if (mode != SImode && mode != DImode)\n@@ -12953,7 +12953,7 @@ ix86_validate_address_register (rtx op)\n    be recognized.  */\n \n static bool\n-ix86_legitimate_address_p (enum machine_mode, rtx addr, bool strict)\n+ix86_legitimate_address_p (machine_mode, rtx addr, bool strict)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n@@ -13392,7 +13392,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  else\n \t    {\n \t      rtx base = legitimize_pic_address (op0, reg);\n-\t      enum machine_mode mode = GET_MODE (base);\n+\t      machine_mode mode = GET_MODE (base);\n \t      new_rtx\n \t        = legitimize_pic_address (op1, base == reg ? NULL_RTX : reg);\n \n@@ -13428,7 +13428,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n /* Load the thread pointer.  If TO_REG is true, force it into a register.  */\n \n static rtx\n-get_thread_pointer (enum machine_mode tp_mode, bool to_reg)\n+get_thread_pointer (machine_mode tp_mode, bool to_reg)\n {\n   rtx tp = gen_rtx_UNSPEC (ptr_mode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n \n@@ -13501,7 +13501,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n {\n   rtx dest, base, off;\n   rtx pic = NULL_RTX, tp = NULL_RTX;\n-  enum machine_mode tp_mode = Pmode;\n+  machine_mode tp_mode = Pmode;\n   int type;\n \n   /* Fall back to global dynamic model if tool chain cannot support local\n@@ -13898,7 +13898,7 @@ legitimize_pe_coff_symbol (rtx addr, bool inreg)\n    See comments by legitimize_pic_address in i386.c for details.  */\n \n static rtx\n-ix86_legitimize_address (rtx x, rtx, enum machine_mode mode)\n+ix86_legitimize_address (rtx x, rtx, machine_mode mode)\n {\n   int changed = 0;\n   unsigned log;\n@@ -14534,7 +14534,7 @@ ix86_find_base_term (rtx x)\n }\n \f\n static void\n-put_condition_code (enum rtx_code code, enum machine_mode mode, bool reverse,\n+put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \t\t    bool fp, FILE *file)\n {\n   const char *suffix;\n@@ -15847,10 +15847,10 @@ i386_asm_output_addr_const_extra (FILE *file, rtx x)\n    that parallel \"operands\".  */\n \n void\n-split_double_mode (enum machine_mode mode, rtx operands[],\n+split_double_mode (machine_mode mode, rtx operands[],\n \t\t   int num, rtx lo_half[], rtx hi_half[])\n {\n-  enum machine_mode half_mode;\n+  machine_mode half_mode;\n   unsigned int byte;\n \n   switch (mode)\n@@ -16797,7 +16797,7 @@ maybe_get_pool_constant (rtx x)\n }\n \n void\n-ix86_expand_move (enum machine_mode mode, rtx operands[])\n+ix86_expand_move (machine_mode mode, rtx operands[])\n {\n   rtx op0, op1;\n   enum tls_model model;\n@@ -16944,7 +16944,7 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n }\n \n void\n-ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n+ix86_expand_vector_move (machine_mode mode, rtx operands[])\n {\n   rtx op0 = operands[0], op1 = operands[1];\n   unsigned int align = GET_MODE_ALIGNMENT (mode);\n@@ -17010,7 +17010,7 @@ ix86_avx256_split_vector_move_misalign (rtx op0, rtx op1)\n   rtx (*extract) (rtx, rtx, rtx);\n   rtx (*load_unaligned) (rtx, rtx);\n   rtx (*store_unaligned) (rtx, rtx);\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   switch (GET_MODE (op0))\n     {\n@@ -17125,7 +17125,7 @@ ix86_avx256_split_vector_move_misalign (rtx op0, rtx op1)\n  */\n \n void\n-ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n+ix86_expand_vector_move_misalign (machine_mode mode, rtx operands[])\n {\n   rtx op0, op1, orig_op0 = NULL_RTX, m;\n   rtx (*load_unaligned) (rtx, rtx);\n@@ -17383,7 +17383,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n    operand order.  Returns true if the operands should be swapped.  */\n \n static bool\n-ix86_swap_binary_operands_p (enum rtx_code code, enum machine_mode mode,\n+ix86_swap_binary_operands_p (enum rtx_code code, machine_mode mode,\n \t\t\t     rtx operands[])\n {\n   rtx dst = operands[0];\n@@ -17421,7 +17421,7 @@ ix86_swap_binary_operands_p (enum rtx_code code, enum machine_mode mode,\n    destination in operands[0], a copy operation will be required.  */\n \n rtx\n-ix86_fixup_binary_operands (enum rtx_code code, enum machine_mode mode,\n+ix86_fixup_binary_operands (enum rtx_code code, machine_mode mode,\n \t\t\t    rtx operands[])\n {\n   rtx dst = operands[0];\n@@ -17485,7 +17485,7 @@ ix86_fixup_binary_operands (enum rtx_code code, enum machine_mode mode,\n \n void\n ix86_fixup_binary_operands_no_copy (enum rtx_code code,\n-\t\t\t\t    enum machine_mode mode, rtx operands[])\n+\t\t\t\t    machine_mode mode, rtx operands[])\n {\n   rtx dst = ix86_fixup_binary_operands (code, mode, operands);\n   gcc_assert (dst == operands[0]);\n@@ -17496,7 +17496,7 @@ ix86_fixup_binary_operands_no_copy (enum rtx_code code,\n    memory references (one output, two input) in a single insn.  */\n \n void\n-ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n+ix86_expand_binary_operator (enum rtx_code code, machine_mode mode,\n \t\t\t     rtx operands[])\n {\n   rtx src1, src2, dst, op, clob;\n@@ -17537,7 +17537,7 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n    the given OPERANDS.  */\n \n void\n-ix86_expand_vector_logical_operator (enum rtx_code code, enum machine_mode mode,\n+ix86_expand_vector_logical_operator (enum rtx_code code, machine_mode mode,\n \t\t\t\t     rtx operands[])\n {\n   rtx op1 = NULL_RTX, op2 = NULL_RTX;\n@@ -17615,7 +17615,7 @@ ix86_expand_vector_logical_operator (enum rtx_code code, enum machine_mode mode,\n    appropriate constraints.  */\n \n bool\n-ix86_binary_operator_ok (enum rtx_code code, enum machine_mode mode,\n+ix86_binary_operator_ok (enum rtx_code code, machine_mode mode,\n \t\t\t rtx operands[3])\n {\n   rtx dst = operands[0];\n@@ -17659,7 +17659,7 @@ ix86_binary_operator_ok (enum rtx_code code, enum machine_mode mode,\n    memory references (one output, one input) in a single insn.  */\n \n void\n-ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n+ix86_expand_unary_operator (enum rtx_code code, machine_mode mode,\n \t\t\t    rtx operands[])\n {\n   int matching_memory;\n@@ -17708,7 +17708,7 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n    divisor are within the range [0-255].  */\n \n void\n-ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n+ix86_split_idivmod (machine_mode mode, rtx operands[],\n \t\t    bool signed_p)\n {\n   rtx_code_label *end_label, *qimode_label;\n@@ -18362,7 +18362,7 @@ ix86_avoid_lea_for_addr (rtx_insn *insn, rtx operands[])\n    matches destination.  RTX includes clobber of FLAGS_REG.  */\n \n static void\n-ix86_emit_binop (enum rtx_code code, enum machine_mode mode,\n+ix86_emit_binop (enum rtx_code code, machine_mode mode,\n \t\t rtx dst, rtx src)\n {\n   rtx op, clob;\n@@ -18407,7 +18407,7 @@ find_nearest_reg_def (rtx_insn *insn, int regno1, int regno2)\n    at lea position.  */\n \n void\n-ix86_split_lea_for_addr (rtx_insn *insn, rtx operands[], enum machine_mode mode)\n+ix86_split_lea_for_addr (rtx_insn *insn, rtx operands[], machine_mode mode)\n {\n   unsigned int regno0, regno1, regno2;\n   struct ix86_address parts;\n@@ -18627,7 +18627,7 @@ ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn)\n \n bool\n ix86_unary_operator_ok (enum rtx_code,\n-\t\t\tenum machine_mode,\n+\t\t\tmachine_mode,\n \t\t\trtx operands[2])\n {\n   /* If one of operands is memory, source and destination must match.  */\n@@ -18657,7 +18657,7 @@ ix86_vec_interleave_v2df_operator_ok (rtx operands[3], bool high)\n void\n ix86_split_convert_uns_si_sse (rtx operands[])\n {\n-  enum machine_mode vecmode;\n+  machine_mode vecmode;\n   rtx value, large, zero_or_two31, input, two31, x;\n \n   large = operands[1];\n@@ -18869,8 +18869,8 @@ ix86_expand_vector_convert_uns_vsivsf (rtx target, rtx val)\n {\n   rtx tmp[8];\n   REAL_VALUE_TYPE TWO16r;\n-  enum machine_mode intmode = GET_MODE (val);\n-  enum machine_mode fltmode = GET_MODE (target);\n+  machine_mode intmode = GET_MODE (val);\n+  machine_mode fltmode = GET_MODE (target);\n   rtx (*cvt) (rtx, rtx);\n \n   if (intmode == V4SImode)\n@@ -18908,9 +18908,9 @@ ix86_expand_adjust_ufix_to_sfix_si (rtx val, rtx *xorp)\n {\n   REAL_VALUE_TYPE TWO31r;\n   rtx two31r, tmp[4];\n-  enum machine_mode mode = GET_MODE (val);\n-  enum machine_mode scalarmode = GET_MODE_INNER (mode);\n-  enum machine_mode intmode = GET_MODE_SIZE (mode) == 32 ? V8SImode : V4SImode;\n+  machine_mode mode = GET_MODE (val);\n+  machine_mode scalarmode = GET_MODE_INNER (mode);\n+  machine_mode intmode = GET_MODE_SIZE (mode) == 32 ? V8SImode : V4SImode;\n   rtx (*cmp) (rtx, rtx, rtx, rtx);\n   int i;\n \n@@ -18955,11 +18955,11 @@ ix86_expand_adjust_ufix_to_sfix_si (rtx val, rtx *xorp)\n    register.  */\n \n rtx\n-ix86_build_const_vector (enum machine_mode mode, bool vect, rtx value)\n+ix86_build_const_vector (machine_mode mode, bool vect, rtx value)\n {\n   int i, n_elt;\n   rtvec v;\n-  enum machine_mode scalar_mode;\n+  machine_mode scalar_mode;\n \n   switch (mode)\n     {\n@@ -19005,9 +19005,9 @@ ix86_build_const_vector (enum machine_mode mode, bool vect, rtx value)\n    a mask excluding the sign bit.  */\n \n rtx\n-ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n+ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n {\n-  enum machine_mode vec_mode, imode;\n+  machine_mode vec_mode, imode;\n   HOST_WIDE_INT hi, lo;\n   int shift = 63;\n   rtx v;\n@@ -19097,13 +19097,13 @@ ix86_build_signbit_mask (enum machine_mode mode, bool vect, bool invert)\n /* Generate code for floating point ABS or NEG.  */\n \n void\n-ix86_expand_fp_absneg_operator (enum rtx_code code, enum machine_mode mode,\n+ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n \t\t\t\trtx operands[])\n {\n   rtx mask, set, dst, src;\n   bool use_sse = false;\n   bool vector_mode = VECTOR_MODE_P (mode);\n-  enum machine_mode vmode = mode;\n+  machine_mode vmode = mode;\n \n   if (vector_mode)\n     use_sse = true;\n@@ -19155,7 +19155,7 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, enum machine_mode mode,\n void\n ix86_expand_copysign (rtx operands[])\n {\n-  enum machine_mode mode, vmode;\n+  machine_mode mode, vmode;\n   rtx dest, op0, op1, mask, nmask;\n \n   dest = operands[0];\n@@ -19227,7 +19227,7 @@ ix86_expand_copysign (rtx operands[])\n void\n ix86_split_copysign_const (rtx operands[])\n {\n-  enum machine_mode mode, vmode;\n+  machine_mode mode, vmode;\n   rtx dest, op0, mask, x;\n \n   dest = operands[0];\n@@ -19254,7 +19254,7 @@ ix86_split_copysign_const (rtx operands[])\n void\n ix86_split_copysign_var (rtx operands[])\n {\n-  enum machine_mode mode, vmode;\n+  machine_mode mode, vmode;\n   rtx dest, scratch, op0, op1, mask, nmask, x;\n \n   dest = operands[0];\n@@ -19326,10 +19326,10 @@ ix86_split_copysign_var (rtx operands[])\n    CC mode is at least as constrained as REQ_MODE.  */\n \n bool\n-ix86_match_ccmode (rtx insn, enum machine_mode req_mode)\n+ix86_match_ccmode (rtx insn, machine_mode req_mode)\n {\n   rtx set;\n-  enum machine_mode set_mode;\n+  machine_mode set_mode;\n \n   set = PATTERN (insn);\n   if (GET_CODE (set) == PARALLEL)\n@@ -19381,7 +19381,7 @@ ix86_match_ccmode (rtx insn, enum machine_mode req_mode)\n static rtx\n ix86_expand_int_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n-  enum machine_mode cmpmode;\n+  machine_mode cmpmode;\n   rtx tmp, flags;\n \n   cmpmode = SELECT_CC_MODE (code, op0, op1);\n@@ -19400,7 +19400,7 @@ ix86_expand_int_compare (enum rtx_code code, rtx op0, rtx op1)\n /* Figure out whether to use ordered or unordered fp comparisons.\n    Return the appropriate mode to use.  */\n \n-enum machine_mode\n+machine_mode\n ix86_fp_compare_mode (enum rtx_code)\n {\n   /* ??? In order to make all comparisons reversible, we do all comparisons\n@@ -19411,10 +19411,10 @@ ix86_fp_compare_mode (enum rtx_code)\n   return TARGET_IEEE_FP ? CCFPUmode : CCFPmode;\n }\n \n-enum machine_mode\n+machine_mode\n ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n \n   if (SCALAR_FLOAT_MODE_P (mode))\n     {\n@@ -19482,8 +19482,8 @@ ix86_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    mode which is compatible with both.  Otherwise, return\n    VOIDmode.  */\n \n-static enum machine_mode\n-ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+static machine_mode\n+ix86_cc_modes_compatible (machine_mode m1, machine_mode m2)\n {\n   if (m1 == m2)\n     return m1;\n@@ -19636,9 +19636,9 @@ ix86_fp_comparison_strategy (enum rtx_code)\n static enum rtx_code\n ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n {\n-  enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n   rtx op0 = *pop0, op1 = *pop1;\n-  enum machine_mode op_mode = GET_MODE (op0);\n+  machine_mode op_mode = GET_MODE (op0);\n   int is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n \n   /* All of the unordered compare instructions only work on registers.\n@@ -19752,7 +19752,7 @@ ix86_fp_compare_code_to_integer (enum rtx_code code)\n static rtx\n ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n {\n-  enum machine_mode fpcmp_mode, intcmp_mode;\n+  machine_mode fpcmp_mode, intcmp_mode;\n   rtx tmp, tmp2;\n \n   fpcmp_mode = ix86_fp_compare_mode (code);\n@@ -19936,7 +19936,7 @@ ix86_expand_compare (enum rtx_code code, rtx op0, rtx op1)\n void\n ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   rtx tmp;\n \n   switch (mode)\n@@ -19964,7 +19964,7 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n \trtx lo[2], hi[2];\n \trtx_code_label *label2;\n \tenum rtx_code code1, code2, code3;\n-\tenum machine_mode submode;\n+\tmachine_mode submode;\n \n \tif (CONSTANT_P (op0) && !CONSTANT_P (op1))\n \t  {\n@@ -20125,7 +20125,7 @@ ix86_expand_setcc (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n static bool\n ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n {\n-  enum machine_mode mode =\n+  machine_mode mode =\n     GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n \n   /* Do not handle double-mode compares that go through special path.  */\n@@ -20255,7 +20255,7 @@ ix86_expand_int_movcc (rtx operands[])\n   enum rtx_code code = GET_CODE (operands[1]), compare_code;\n   rtx_insn *compare_seq;\n   rtx compare_op;\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   bool sign_bit_compare_p = false;\n   rtx op0 = XEXP (operands[1], 0);\n   rtx op1 = XEXP (operands[1], 1);\n@@ -20440,7 +20440,7 @@ ix86_expand_int_movcc (rtx operands[])\n \n       if (diff < 0)\n \t{\n-\t  enum machine_mode cmp_mode = GET_MODE (op0);\n+\t  machine_mode cmp_mode = GET_MODE (op0);\n \n \t  HOST_WIDE_INT tmp;\n \t  tmp = ct, ct = cf, cf = tmp;\n@@ -20597,7 +20597,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t{\n \t  if (cf == 0)\n \t    {\n-\t      enum machine_mode cmp_mode = GET_MODE (op0);\n+\t      machine_mode cmp_mode = GET_MODE (op0);\n \n \t      cf = ct;\n \t      ct = 0;\n@@ -20835,7 +20835,7 @@ static bool\n ix86_expand_sse_fp_minmax (rtx dest, enum rtx_code code, rtx cmp_op0,\n \t\t\t   rtx cmp_op1, rtx if_true, rtx if_false)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool is_min;\n   rtx tmp;\n \n@@ -20886,11 +20886,11 @@ static rtx\n ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n \t\t     rtx op_true, rtx op_false)\n {\n-  enum machine_mode mode = GET_MODE (dest);\n-  enum machine_mode cmp_ops_mode = GET_MODE (cmp_op0);\n+  machine_mode mode = GET_MODE (dest);\n+  machine_mode cmp_ops_mode = GET_MODE (cmp_op0);\n \n   /* In general case result of comparison can differ from operands' type.  */\n-  enum machine_mode cmp_mode;\n+  machine_mode cmp_mode;\n \n   /* In AVX512F the result of comparison is an integer mask.  */\n   bool maskcmp = false;\n@@ -20958,8 +20958,8 @@ ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n static void\n ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n {\n-  enum machine_mode mode = GET_MODE (dest);\n-  enum machine_mode cmpmode = GET_MODE (cmp);\n+  machine_mode mode = GET_MODE (dest);\n+  machine_mode cmpmode = GET_MODE (cmp);\n \n   /* In AVX512F the result of comparison is an integer mask.  */\n   bool maskcmp = (mode != cmpmode && TARGET_AVX512F);\n@@ -21121,15 +21121,15 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n bool\n ix86_expand_fp_movcc (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx tmp, compare_op;\n   rtx op0 = XEXP (operands[1], 0);\n   rtx op1 = XEXP (operands[1], 1);\n \n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n     {\n-      enum machine_mode cmode;\n+      machine_mode cmode;\n \n       /* Since we've no cmove for sse registers, don't force bad register\n \t allocation just to gain access to it.  Deny movcc when the\n@@ -21232,8 +21232,8 @@ ix86_expand_fp_vcond (rtx operands[])\n bool\n ix86_expand_int_vcond (rtx operands[])\n {\n-  enum machine_mode data_mode = GET_MODE (operands[0]);\n-  enum machine_mode mode = GET_MODE (operands[4]);\n+  machine_mode data_mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[4]);\n   enum rtx_code code = GET_CODE (operands[3]);\n   bool negate = false;\n   rtx x, cop0, cop1;\n@@ -21438,7 +21438,7 @@ struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n   unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n   unsigned char nelt;\n   bool one_operand_p;\n   bool testing_p;\n@@ -21450,8 +21450,8 @@ ix86_expand_vec_perm_vpermi2 (rtx target, rtx op0, rtx mask, rtx op1,\n {\n   /* ix86_expand_vec_perm_vpermi2 is called from both const and non-const\n      expander, so args are either in d, or in op0, op1 etc.  */\n-  enum machine_mode mode = GET_MODE (d ? d->op0 : op0);\n-  enum machine_mode maskmode = mode;\n+  machine_mode mode = GET_MODE (d ? d->op0 : op0);\n+  machine_mode maskmode = mode;\n   rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;\n \n   switch (mode)\n@@ -21568,8 +21568,8 @@ ix86_expand_vec_perm (rtx operands[])\n   rtx op1 = operands[2];\n   rtx mask = operands[3];\n   rtx t1, t2, t3, t4, t5, t6, t7, t8, vt, vt2, vec[32];\n-  enum machine_mode mode = GET_MODE (op0);\n-  enum machine_mode maskmode = GET_MODE (mask);\n+  machine_mode mode = GET_MODE (op0);\n+  machine_mode maskmode = GET_MODE (mask);\n   int w, e, i;\n   bool one_operand_shuffle = rtx_equal_p (op0, op1);\n \n@@ -21939,14 +21939,14 @@ ix86_expand_vec_perm (rtx operands[])\n void\n ix86_expand_sse_unpack (rtx dest, rtx src, bool unsigned_p, bool high_p)\n {\n-  enum machine_mode imode = GET_MODE (src);\n+  machine_mode imode = GET_MODE (src);\n   rtx tmp;\n \n   if (TARGET_SSE4_1)\n     {\n       rtx (*unpack)(rtx, rtx);\n       rtx (*extract)(rtx, rtx) = NULL;\n-      enum machine_mode halfmode = BLKmode;\n+      machine_mode halfmode = BLKmode;\n \n       switch (imode)\n \t{\n@@ -22096,7 +22096,7 @@ ix86_expand_int_addcc (rtx operands[])\n   rtx compare_op;\n   rtx val = const0_rtx;\n   bool fpcmp = false;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx op0 = XEXP (operands[1], 0);\n   rtx op1 = XEXP (operands[1], 1);\n \n@@ -22182,7 +22182,7 @@ ix86_expand_int_addcc (rtx operands[])\n    in the right order.  Maximally three parts are generated.  */\n \n static int\n-ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n+ix86_split_to_parts (rtx operand, rtx *parts, machine_mode mode)\n {\n   int size;\n \n@@ -22218,7 +22218,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \n   if (GET_CODE (operand) == CONST_VECTOR)\n     {\n-      enum machine_mode imode = int_mode_for_mode (mode);\n+      machine_mode imode = int_mode_for_mode (mode);\n       /* Caution: if we looked through a constant pool memory above,\n \t the operand may actually have a different mode now.  That's\n \t ok, since we want to pun this all the way back to an integer.  */\n@@ -22286,7 +22286,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \tsplit_double_mode (mode, &operand, 1, &parts[0], &parts[1]);\n       if (mode == XFmode || mode == TFmode)\n \t{\n-\t  enum machine_mode upper_mode = mode==XFmode ? SImode : DImode;\n+\t  machine_mode upper_mode = mode==XFmode ? SImode : DImode;\n \t  if (REG_P (operand))\n \t    {\n \t      gcc_assert (reload_completed);\n@@ -22348,7 +22348,7 @@ ix86_split_long_move (rtx operands[])\n   int nparts, i, j;\n   int push = 0;\n   int collisions = 0;\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   bool collisionparts[4];\n \n   /* The DFmode expanders may ask us to move double.\n@@ -22562,7 +22562,7 @@ ix86_split_long_move (rtx operands[])\n    a sequence of add instructions.  */\n \n static void\n-ix86_expand_ashl_const (rtx operand, int count, enum machine_mode mode)\n+ix86_expand_ashl_const (rtx operand, int count, machine_mode mode)\n {\n   rtx (*insn)(rtx, rtx, rtx);\n \n@@ -22582,7 +22582,7 @@ ix86_expand_ashl_const (rtx operand, int count, enum machine_mode mode)\n }\n \n void\n-ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n+ix86_split_ashl (rtx *operands, rtx scratch, machine_mode mode)\n {\n   rtx (*gen_ashl3)(rtx, rtx, rtx);\n   rtx (*gen_shld)(rtx, rtx, rtx);\n@@ -22651,7 +22651,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n \t pentium4 a bit; no one else seems to care much either way.  */\n       else\n \t{\n-\t  enum machine_mode half_mode;\n+\t  machine_mode half_mode;\n \t  rtx (*gen_lshr3)(rtx, rtx, rtx);\n \t  rtx (*gen_and3)(rtx, rtx, rtx);\n \t  rtx (*gen_xor3)(rtx, rtx, rtx);\n@@ -22733,7 +22733,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n }\n \n void\n-ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n+ix86_split_ashr (rtx *operands, rtx scratch, machine_mode mode)\n {\n   rtx (*gen_ashr3)(rtx, rtx, rtx)\n     = mode == DImode ? gen_ashrsi3 : gen_ashrdi3;\n@@ -22812,7 +22812,7 @@ ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n }\n \n void\n-ix86_split_lshr (rtx *operands, rtx scratch, enum machine_mode mode)\n+ix86_split_lshr (rtx *operands, rtx scratch, machine_mode mode)\n {\n   rtx (*gen_lshr3)(rtx, rtx, rtx)\n     = mode == DImode ? gen_lshrsi3 : gen_lshrdi3;\n@@ -22945,7 +22945,7 @@ scale_counter (rtx countreg, int scale)\n /* Return mode for the memcpy/memset loop counter.  Prefer SImode over\n    DImode for constant loop counts.  */\n \n-static enum machine_mode\n+static machine_mode\n counter_mode (rtx count_exp)\n {\n   if (GET_MODE (count_exp) != VOIDmode)\n@@ -22984,12 +22984,12 @@ ix86_copy_addr_to_reg (rtx addr)\n static void\n expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t       rtx destptr, rtx srcptr, rtx value,\n-\t\t\t       rtx count, enum machine_mode mode, int unroll,\n+\t\t\t       rtx count, machine_mode mode, int unroll,\n \t\t\t       int expected_size, bool issetmem)\n {\n   rtx_code_label *out_label, *top_label;\n   rtx iter, tmp;\n-  enum machine_mode iter_mode = counter_mode (count);\n+  machine_mode iter_mode = counter_mode (count);\n   int piece_size_n = GET_MODE_SIZE (mode) * unroll;\n   rtx piece_size = GEN_INT (piece_size_n);\n   rtx piece_size_mask = GEN_INT (~((GET_MODE_SIZE (mode) * unroll) - 1));\n@@ -23123,7 +23123,7 @@ static void\n expand_set_or_movmem_via_rep (rtx destmem, rtx srcmem,\n \t\t\t   rtx destptr, rtx srcptr, rtx value, rtx orig_value,\n \t\t\t   rtx count,\n-\t\t\t   enum machine_mode mode, bool issetmem)\n+\t\t\t   machine_mode mode, bool issetmem)\n {\n   rtx destexp;\n   rtx srcexp;\n@@ -23203,7 +23203,7 @@ emit_memmov (rtx destmem, rtx *srcmem, rtx destptr, rtx srcptr,\n {\n   rtx dst = destmem, src = *srcmem, adjust, tempreg;\n   enum insn_code code;\n-  enum machine_mode move_mode;\n+  machine_mode move_mode;\n   int piece_size, i;\n \n   /* Find the widest mode in which we could perform moves.\n@@ -23388,7 +23388,7 @@ emit_memset (rtx destmem, rtx destptr, rtx promoted_val,\n {\n   rtx dst = destmem, adjust;\n   enum insn_code code;\n-  enum machine_mode move_mode;\n+  machine_mode move_mode;\n   int piece_size, i;\n \n   /* Find the widest mode in which we could perform moves.\n@@ -23594,7 +23594,7 @@ expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n \t\t\t       rtx done_label, bool issetmem)\n {\n   rtx_code_label *label = ix86_expand_aligntest (count, size, false);\n-  enum machine_mode mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 1);\n+  machine_mode mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 1);\n   rtx modesize;\n   int n;\n \n@@ -23715,7 +23715,7 @@ expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n static void\n expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx srcmem,\n \t\t\t\t\t\t\t    rtx *destptr, rtx *srcptr,\n-\t\t\t\t\t\t\t    enum machine_mode mode,\n+\t\t\t\t\t\t\t    machine_mode mode,\n \t\t\t\t\t\t\t    rtx value, rtx vec_value,\n \t\t\t\t\t\t\t    rtx *count,\n \t\t\t\t\t\t\t    rtx_code_label **done_label,\n@@ -24150,7 +24150,7 @@ static int\n decide_alignment (int align,\n \t\t  enum stringop_alg alg,\n \t\t  int expected_size,\n-\t\t  enum machine_mode move_mode)\n+\t\t  machine_mode move_mode)\n {\n   int desired_align = 0;\n \n@@ -24185,9 +24185,9 @@ decide_alignment (int align,\n    synth_mult by unwinding the sequence by hand on CPUs with\n    slow multiply.  */\n static rtx\n-promote_duplicated_reg (enum machine_mode mode, rtx val)\n+promote_duplicated_reg (machine_mode mode, rtx val)\n {\n-  enum machine_mode valmode = GET_MODE (val);\n+  machine_mode valmode = GET_MODE (val);\n   rtx tmp;\n   int nops = mode == DImode ? 3 : 2;\n \n@@ -24339,7 +24339,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   int dynamic_check;\n   bool need_zero_guard = false;\n   bool noalign;\n-  enum machine_mode move_mode = VOIDmode;\n+  machine_mode move_mode = VOIDmode;\n   int unroll_factor = 1;\n   /* TODO: Once value ranges are available, fill in proper data.  */\n   unsigned HOST_WIDE_INT min_size = 0;\n@@ -25120,7 +25120,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       for (i = 0; i < cregs_size; i++)\n \t{\n \t  int regno = x86_64_ms_sysv_extra_clobbered_registers[i];\n-\t  enum machine_mode mode = SSE_REGNO_P (regno) ? TImode : DImode;\n+\t  machine_mode mode = SSE_REGNO_P (regno) ? TImode : DImode;\n \n \t  clobber_reg (&use, gen_rtx_REG (mode, regno));\n \t}\n@@ -25225,7 +25225,7 @@ ix86_init_machine_status (void)\n    which slot to use.  */\n \n rtx\n-assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)\n+assign_386_stack_local (machine_mode mode, enum ix86_stack_slot n)\n {\n   struct stack_local_entry *s;\n \n@@ -26878,7 +26878,7 @@ ix86_data_alignment (tree type, int align, bool opt)\n    object.  */\n \n unsigned int\n-ix86_local_alignment (tree exp, enum machine_mode mode,\n+ix86_local_alignment (tree exp, machine_mode mode,\n \t\t      unsigned int align)\n {\n   tree type, decl;\n@@ -26987,7 +26987,7 @@ ix86_local_alignment (tree exp, enum machine_mode mode,\n    alignment that the object would ordinarily have.  */\n \n unsigned int\n-ix86_minimum_alignment (tree exp, enum machine_mode mode,\n+ix86_minimum_alignment (tree exp, machine_mode mode,\n \t\t\tunsigned int align)\n {\n   tree type, decl;\n@@ -27238,7 +27238,7 @@ ix86_get_builtin_type (enum ix86_builtin_type tcode)\n   gcc_assert (tcode > IX86_BT_LAST_PRIM);\n   if (tcode <= IX86_BT_LAST_VECT)\n     {\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       index = tcode - IX86_BT_LAST_PRIM - 1;\n       itype = ix86_get_builtin_type (ix86_builtin_type_vect_base[index]);\n@@ -35069,7 +35069,7 @@ ix86_builtin_decl (unsigned code, bool)\n    where we expect a vector.  To avoid crashing, use one of the vector\n    clear instructions.  */\n static rtx\n-safe_vector_operand (rtx x, enum machine_mode mode)\n+safe_vector_operand (rtx x, machine_mode mode)\n {\n   if (x == const0_rtx)\n     x = CONST0_RTX (mode);\n@@ -35086,9 +35086,9 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[icode].operand[2].mode;\n \n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n@@ -35137,10 +35137,10 @@ ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n   int num_memory = 0;\n   struct {\n     rtx op;\n-    enum machine_mode mode;\n+    machine_mode mode;\n   } args[4];\n \n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n \n   switch (m_type)\n     {\n@@ -35237,7 +35237,7 @@ ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n       tree arg = CALL_EXPR_ARG (exp, i);\n       rtx op = expand_normal (arg);\n       int adjust = (comparison_p) ? 1 : 0;\n-      enum machine_mode mode = insn_data[icode].operand[i+adjust+1].mode;\n+      machine_mode mode = insn_data[icode].operand[i+adjust+1].mode;\n \n       if (last_arg_constant && i == nargs - 1)\n \t{\n@@ -35365,8 +35365,8 @@ ix86_expand_unop_vec_merge_builtin (enum insn_code icode, tree exp,\n   rtx pat;\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op1, op0 = expand_normal (arg0);\n-  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[icode].operand[1].mode;\n \n   if (optimize || !target\n       || GET_MODE (target) != tmode\n@@ -35403,9 +35403,9 @@ ix86_expand_sse_compare (const struct builtin_description *d,\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2;\n-  enum machine_mode tmode = insn_data[d->icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[d->icode].operand[2].mode;\n+  machine_mode tmode = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[d->icode].operand[2].mode;\n   enum rtx_code comparison = d->comparison;\n \n   if (VECTOR_MODE_P (mode0))\n@@ -35454,8 +35454,8 @@ ix86_expand_sse_comi (const struct builtin_description *d, tree exp,\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode mode0 = insn_data[d->icode].operand[0].mode;\n-  enum machine_mode mode1 = insn_data[d->icode].operand[1].mode;\n+  machine_mode mode0 = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode1 = insn_data[d->icode].operand[1].mode;\n   enum rtx_code comparison = d->comparison;\n \n   if (VECTOR_MODE_P (mode0))\n@@ -35505,8 +35505,8 @@ ix86_expand_sse_round (const struct builtin_description *d, tree exp,\n   rtx pat;\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op1, op0 = expand_normal (arg0);\n-  enum machine_mode tmode = insn_data[d->icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n+  machine_mode tmode = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n \n   if (optimize || target == 0\n       || GET_MODE (target) != tmode\n@@ -35539,9 +35539,9 @@ ix86_expand_sse_round_vec_pack_sfix (const struct builtin_description *d,\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2;\n-  enum machine_mode tmode = insn_data[d->icode].operand[0].mode;\n-  enum machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n-  enum machine_mode mode1 = insn_data[d->icode].operand[2].mode;\n+  machine_mode tmode = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n+  machine_mode mode1 = insn_data[d->icode].operand[2].mode;\n \n   if (optimize || target == 0\n       || GET_MODE (target) != tmode\n@@ -35578,8 +35578,8 @@ ix86_expand_sse_ptest (const struct builtin_description *d, tree exp,\n   tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n-  enum machine_mode mode0 = insn_data[d->icode].operand[0].mode;\n-  enum machine_mode mode1 = insn_data[d->icode].operand[1].mode;\n+  machine_mode mode0 = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode1 = insn_data[d->icode].operand[1].mode;\n   enum rtx_code comparison = d->comparison;\n \n   if (VECTOR_MODE_P (mode0))\n@@ -35629,7 +35629,7 @@ ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n   rtx op2 = expand_normal (arg2);\n   rtx op3 = expand_normal (arg3);\n   rtx op4 = expand_normal (arg4);\n-  enum machine_mode tmode0, tmode1, modev2, modei3, modev4, modei5, modeimm;\n+  machine_mode tmode0, tmode1, modev2, modei3, modev4, modei5, modeimm;\n \n   tmode0 = insn_data[d->icode].operand[0].mode;\n   tmode1 = insn_data[d->icode].operand[1].mode;\n@@ -35706,7 +35706,7 @@ ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n       emit_insn\n \t(gen_rtx_SET (VOIDmode, gen_rtx_STRICT_LOW_PART (VOIDmode, target),\n \t\t      gen_rtx_fmt_ee (EQ, QImode,\n-\t\t\t\t      gen_rtx_REG ((enum machine_mode) d->flag,\n+\t\t\t\t      gen_rtx_REG ((machine_mode) d->flag,\n \t\t\t\t\t\t   FLAGS_REG),\n \t\t\t\t      const0_rtx)));\n       return SUBREG_REG (target);\n@@ -35730,7 +35730,7 @@ ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n-  enum machine_mode tmode0, tmode1, modev2, modev3, modeimm;\n+  machine_mode tmode0, tmode1, modev2, modev3, modeimm;\n \n   tmode0 = insn_data[d->icode].operand[0].mode;\n   tmode1 = insn_data[d->icode].operand[1].mode;\n@@ -35801,7 +35801,7 @@ ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n       emit_insn\n \t(gen_rtx_SET (VOIDmode, gen_rtx_STRICT_LOW_PART (VOIDmode, target),\n \t\t      gen_rtx_fmt_ee (EQ, QImode,\n-\t\t\t\t      gen_rtx_REG ((enum machine_mode) d->flag,\n+\t\t\t\t      gen_rtx_REG ((machine_mode) d->flag,\n \t\t\t\t\t\t   FLAGS_REG),\n \t\t\t\t      const0_rtx)));\n       return SUBREG_REG (target);\n@@ -35825,13 +35825,13 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n   struct\n     {\n       rtx op;\n-      enum machine_mode mode;\n+      machine_mode mode;\n     } args[6];\n   bool last_arg_count = false;\n   enum insn_code icode = d->icode;\n   const struct insn_data_d *insn_p = &insn_data[icode];\n-  enum machine_mode tmode = insn_p->operand[0].mode;\n-  enum machine_mode rmode = VOIDmode;\n+  machine_mode tmode = insn_p->operand[0].mode;\n+  machine_mode rmode = VOIDmode;\n   bool swap = false;\n   enum rtx_code comparison = d->comparison;\n \n@@ -36576,7 +36576,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n     {\n       tree arg = CALL_EXPR_ARG (exp, i);\n       rtx op = expand_normal (arg);\n-      enum machine_mode mode = insn_p->operand[i + 1].mode;\n+      machine_mode mode = insn_p->operand[i + 1].mode;\n       bool match = insn_p->operand[i + 1].predicate (op, mode);\n \n       if (last_arg_count && (i + 1) == nargs)\n@@ -36857,8 +36857,8 @@ ix86_expand_sse_comi_round (const struct builtin_description *d,\n   rtx op3 = expand_normal (arg3);\n   enum insn_code icode = d->icode;\n   const struct insn_data_d *insn_p = &insn_data[icode];\n-  enum machine_mode mode0 = insn_p->operand[0].mode;\n-  enum machine_mode mode1 = insn_p->operand[1].mode;\n+  machine_mode mode0 = insn_p->operand[0].mode;\n+  machine_mode mode1 = insn_p->operand[1].mode;\n   enum rtx_code comparison = UNEQ;\n   bool need_ucomi = false;\n \n@@ -36956,11 +36956,11 @@ ix86_expand_round_builtin (const struct builtin_description *d,\n   struct\n     {\n       rtx op;\n-      enum machine_mode mode;\n+      machine_mode mode;\n     } args[6];\n   enum insn_code icode = d->icode;\n   const struct insn_data_d *insn_p = &insn_data[icode];\n-  enum machine_mode tmode = insn_p->operand[0].mode;\n+  machine_mode tmode = insn_p->operand[0].mode;\n   unsigned int nargs_constant = 0;\n   unsigned int redundant_embed_rnd = 0;\n \n@@ -37061,7 +37061,7 @@ ix86_expand_round_builtin (const struct builtin_description *d,\n     {\n       tree arg = CALL_EXPR_ARG (exp, i);\n       rtx op = expand_normal (arg);\n-      enum machine_mode mode = insn_p->operand[i + 1].mode;\n+      machine_mode mode = insn_p->operand[i + 1].mode;\n       bool match = insn_p->operand[i + 1].predicate (op, mode);\n \n       if (i == nargs - nargs_constant)\n@@ -37173,12 +37173,12 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n   struct\n     {\n       rtx op;\n-      enum machine_mode mode;\n+      machine_mode mode;\n     } args[3];\n   enum insn_code icode = d->icode;\n   bool last_arg_constant = false;\n   const struct insn_data_d *insn_p = &insn_data[icode];\n-  enum machine_mode tmode = insn_p->operand[0].mode;\n+  machine_mode tmode = insn_p->operand[0].mode;\n   enum { load, store } klass;\n \n   switch ((enum ix86_builtin_func_type) d->flag)\n@@ -37466,7 +37466,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \n   for (i = 0; i < nargs; i++)\n     {\n-      enum machine_mode mode = insn_p->operand[i + 1].mode;\n+      machine_mode mode = insn_p->operand[i + 1].mode;\n       bool match;\n \n       arg = CALL_EXPR_ARG (exp, i + arg_adjust);\n@@ -37580,8 +37580,8 @@ get_element_number (tree vec_type, tree arg)\n static rtx\n ix86_expand_vec_init_builtin (tree type, tree exp, rtx target)\n {\n-  enum machine_mode tmode = TYPE_MODE (type);\n-  enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n+  machine_mode tmode = TYPE_MODE (type);\n+  machine_mode inner_mode = GET_MODE_INNER (tmode);\n   int i, n_elt = GET_MODE_NUNITS (tmode);\n   rtvec v = rtvec_alloc (n_elt);\n \n@@ -37608,7 +37608,7 @@ ix86_expand_vec_init_builtin (tree type, tree exp, rtx target)\n static rtx\n ix86_expand_vec_ext_builtin (tree exp, rtx target)\n {\n-  enum machine_mode tmode, mode0;\n+  machine_mode tmode, mode0;\n   tree arg0, arg1;\n   int elt;\n   rtx op0;\n@@ -37640,7 +37640,7 @@ ix86_expand_vec_ext_builtin (tree exp, rtx target)\n static rtx\n ix86_expand_vec_set_builtin (tree exp)\n {\n-  enum machine_mode tmode, mode1;\n+  machine_mode tmode, mode1;\n   tree arg0, arg1, arg2;\n   int elt;\n   rtx op0, op1, target;\n@@ -37680,15 +37680,15 @@ ix86_expand_vec_set_builtin (tree exp)\n \n static rtx\n ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n-\t\t     enum machine_mode mode, int ignore)\n+\t\t     machine_mode mode, int ignore)\n {\n   const struct builtin_description *d;\n   size_t i;\n   enum insn_code icode;\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   tree arg0, arg1, arg2, arg3, arg4;\n   rtx op0, op1, op2, op3, op4, pat, insn;\n-  enum machine_mode mode0, mode1, mode2, mode3, mode4;\n+  machine_mode mode0, mode1, mode2, mode3, mode4;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n \n   /* For CPU builtins that can be folded, fold first and expand the fold.  */\n@@ -39029,7 +39029,7 @@ static tree\n ix86_builtin_vectorized_function (tree fndecl, tree type_out,\n \t\t\t\t  tree type_in)\n {\n-  enum machine_mode in_mode, out_mode;\n+  machine_mode in_mode, out_mode;\n   int in_n, out_n;\n   enum built_in_function fn = DECL_FUNCTION_CODE (fndecl);\n \n@@ -39409,7 +39409,7 @@ ix86_veclibabi_svml (enum built_in_function fn, tree type_out, tree type_in)\n   tree fntype, new_fndecl, args;\n   unsigned arity;\n   const char *bname;\n-  enum machine_mode el_mode, in_mode;\n+  machine_mode el_mode, in_mode;\n   int n, in_n;\n \n   /* The SVML is suitable for unsafe math only.  */\n@@ -39523,7 +39523,7 @@ ix86_veclibabi_acml (enum built_in_function fn, tree type_out, tree type_in)\n   tree fntype, new_fndecl, args;\n   unsigned arity;\n   const char *bname;\n-  enum machine_mode el_mode, in_mode;\n+  machine_mode el_mode, in_mode;\n   int n, in_n;\n \n   /* The ACML is 64bits only and suitable for unsafe math only as\n@@ -39757,7 +39757,7 @@ ix86_builtin_reciprocal (unsigned int fn, bool md_fn, bool)\n    The return value is 0 for no match and the imm8+1 for a match.  */\n \n int\n-avx_vpermilp_parallel (rtx par, enum machine_mode mode)\n+avx_vpermilp_parallel (rtx par, machine_mode mode)\n {\n   unsigned i, nelt = GET_MODE_NUNITS (mode);\n   unsigned mask = 0;\n@@ -39858,7 +39858,7 @@ avx_vpermilp_parallel (rtx par, enum machine_mode mode)\n    The return value is 0 for no match and the imm8+1 for a match.  */\n \n int\n-avx_vperm2f128_parallel (rtx par, enum machine_mode mode)\n+avx_vperm2f128_parallel (rtx par, machine_mode mode)\n {\n   unsigned i, nelt = GET_MODE_NUNITS (mode), nelt2 = nelt / 2;\n   unsigned mask = 0;\n@@ -39940,7 +39940,7 @@ ix86_register_priority (int hard_regno)\n static reg_class_t\n ix86_preferred_reload_class (rtx x, reg_class_t regclass)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   /* We're only allowed to return a subclass of CLASS.  Many of the\n      following checks fail for NO_REGS, so eliminate that early.  */\n@@ -40016,7 +40016,7 @@ ix86_preferred_reload_class (rtx x, reg_class_t regclass)\n static reg_class_t\n ix86_preferred_output_reload_class (rtx x, reg_class_t regclass)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   /* Restrict the output reload class to the register bank that we are doing\n      math on.  If we would like not to return a subset of CLASS, reject this\n@@ -40040,7 +40040,7 @@ ix86_preferred_output_reload_class (rtx x, reg_class_t regclass)\n \n static reg_class_t\n ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n-\t\t       enum machine_mode mode, secondary_reload_info *sri)\n+\t\t       machine_mode mode, secondary_reload_info *sri)\n {\n   /* Double-word spills from general registers to non-offsettable memory\n      references (zero-extended addresses) require special handling.  */\n@@ -40165,7 +40165,7 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n \n static inline bool\n inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t\tenum machine_mode mode, int strict)\n+\t\t\t\tmachine_mode mode, int strict)\n {\n   if (lra_in_progress && (class1 == NO_REGS || class2 == NO_REGS))\n     return false;\n@@ -40216,7 +40216,7 @@ inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \n bool\n ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t      enum machine_mode mode, int strict)\n+\t\t\t      machine_mode mode, int strict)\n {\n   return inline_secondary_memory_needed (class1, class2, mode, strict);\n }\n@@ -40227,7 +40227,7 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n    except in the FP regs, where a single reg is always enough.  */\n \n static unsigned char\n-ix86_class_max_nregs (reg_class_t rclass, enum machine_mode mode)\n+ix86_class_max_nregs (reg_class_t rclass, machine_mode mode)\n {\n   if (MAYBE_INTEGER_CLASS_P (rclass))\n     {\n@@ -40251,7 +40251,7 @@ ix86_class_max_nregs (reg_class_t rclass, enum machine_mode mode)\n    modes FROM to TO.  */\n \n bool\n-ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+ix86_cannot_change_mode_class (machine_mode from, machine_mode to,\n \t\t\t       enum reg_class regclass)\n {\n   if (from == to)\n@@ -40291,7 +40291,7 @@ ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n    Q_REGS classes.\n  */\n static inline int\n-inline_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n+inline_memory_move_cost (machine_mode mode, enum reg_class regclass,\n \t\t\t int in)\n {\n   int cost;\n@@ -40401,7 +40401,7 @@ inline_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n }\n \n static int\n-ix86_memory_move_cost (enum machine_mode mode, reg_class_t regclass,\n+ix86_memory_move_cost (machine_mode mode, reg_class_t regclass,\n \t\t       bool in)\n {\n   return inline_memory_move_cost (mode, (enum reg_class) regclass, in ? 1 : 0);\n@@ -40416,7 +40416,7 @@ ix86_memory_move_cost (enum machine_mode mode, reg_class_t regclass,\n    general registers.  */\n \n static int\n-ix86_register_move_cost (enum machine_mode mode, reg_class_t class1_i,\n+ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n \t\t\t reg_class_t class2_i)\n {\n   enum reg_class class1 = (enum reg_class) class1_i;\n@@ -40474,7 +40474,7 @@ ix86_register_move_cost (enum machine_mode mode, reg_class_t class1_i,\n    MODE.  */\n \n bool\n-ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+ix86_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   /* Flags and only flags can only hold CCmode values.  */\n   if (CC_REGNO_P (regno))\n@@ -40570,7 +40570,7 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n    tieable integer mode.  */\n \n static bool\n-ix86_tieable_integer_mode_p (enum machine_mode mode)\n+ix86_tieable_integer_mode_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -40594,7 +40594,7 @@ ix86_tieable_integer_mode_p (enum machine_mode mode)\n    can also hold MODE1.  */\n \n bool\n-ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+ix86_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (mode1 == mode2)\n     return true;\n@@ -40638,7 +40638,7 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n /* Return the cost of moving between two registers of mode MODE.  */\n \n static int\n-ix86_set_reg_reg_cost (enum machine_mode mode)\n+ix86_set_reg_reg_cost (machine_mode mode)\n {\n   unsigned int units = UNITS_PER_WORD;\n \n@@ -40693,7 +40693,7 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n   rtx mask;\n   enum rtx_code code = (enum rtx_code) code_i;\n   enum rtx_code outer_code = (enum rtx_code) outer_code_i;\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   const struct processor_costs *cost = speed ? ix86_cost : &ix86_size_cost;\n \n   switch (code)\n@@ -40961,7 +40961,7 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t         == GET_MODE_SIZE (mode))\n \t    {\n \t      int is_mulwiden = 0;\n-\t      enum machine_mode inner_mode = GET_MODE (op0);\n+\t      machine_mode inner_mode = GET_MODE (op0);\n \n \t      if (GET_CODE (op0) == GET_CODE (op1))\n \t\tis_mulwiden = 1, op1 = XEXP (op1, 0);\n@@ -41765,7 +41765,7 @@ x86_file_start (void)\n int\n x86_field_alignment (tree field, int computed)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   tree type = TREE_TYPE (field);\n \n   if (TARGET_64BIT || TARGET_ALIGN_DOUBLE)\n@@ -42260,7 +42260,7 @@ x86_extended_reg_mentioned_p (rtx insn)\n /* If profitable, negate (without causing overflow) integer constant\n    of mode MODE at location LOC.  Return true in this case.  */\n bool\n-x86_maybe_negate_const_int (rtx *loc, enum machine_mode mode)\n+x86_maybe_negate_const_int (rtx *loc, machine_mode mode)\n {\n   HOST_WIDE_INT val;\n \n@@ -42311,7 +42311,7 @@ x86_emit_floatuns (rtx operands[2])\n {\n   rtx_code_label *neglab, *donelab;\n   rtx i0, i1, f0, in, out;\n-  enum machine_mode mode, inmode;\n+  machine_mode mode, inmode;\n \n   inmode = GET_MODE (operands[1]);\n   gcc_assert (inmode == SImode || inmode == DImode);\n@@ -42353,11 +42353,11 @@ static bool expand_vec_perm_palignr (struct expand_vec_perm_d *d, bool);\n /* Get a vector mode of the same size as the original but with elements\n    twice as wide.  This is only guaranteed to apply to integral vectors.  */\n \n-static inline enum machine_mode\n-get_mode_wider_vector (enum machine_mode o)\n+static inline machine_mode\n+get_mode_wider_vector (machine_mode o)\n {\n   /* ??? Rely on the ordering that genmodes.c gives to vectors.  */\n-  enum machine_mode n = GET_MODE_WIDER_MODE (o);\n+  machine_mode n = GET_MODE_WIDER_MODE (o);\n   gcc_assert (GET_MODE_NUNITS (o) == GET_MODE_NUNITS (n) * 2);\n   gcc_assert (GET_MODE_SIZE (o) == GET_MODE_SIZE (n));\n   return n;\n@@ -42367,7 +42367,7 @@ get_mode_wider_vector (enum machine_mode o)\n    fill target with val via vec_duplicate.  */\n \n static bool\n-ix86_vector_duplicate_value (enum machine_mode mode, rtx target, rtx val)\n+ix86_vector_duplicate_value (machine_mode mode, rtx target, rtx val)\n {\n   bool ok;\n   rtx_insn *insn;\n@@ -42398,7 +42398,7 @@ ix86_vector_duplicate_value (enum machine_mode mode, rtx target, rtx val)\n    with all elements equal to VAR.  Return true if successful.  */\n \n static bool\n-ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n+ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t\t\t\t   rtx target, rtx val)\n {\n   bool ok;\n@@ -42489,7 +42489,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n     widen:\n       /* Replicate the value once into the next wider mode and recurse.  */\n       {\n-\tenum machine_mode smode, wsmode, wvmode;\n+\tmachine_mode smode, wsmode, wvmode;\n \trtx x;\n \n \tsmode = GET_MODE_INNER (mode);\n@@ -42515,7 +42515,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n \treturn ix86_vector_duplicate_value (mode, target, val);\n       else\n \t{\n-\t  enum machine_mode hvmode = (mode == V16HImode ? V8HImode : V16QImode);\n+\t  machine_mode hvmode = (mode == V16HImode ? V8HImode : V16QImode);\n \t  rtx x = gen_reg_rtx (hvmode);\n \n \t  ok = ix86_expand_vector_init_duplicate (false, hvmode, x, val);\n@@ -42532,7 +42532,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n \treturn ix86_vector_duplicate_value (mode, target, val);\n       else\n \t{\n-\t  enum machine_mode hvmode = (mode == V32HImode ? V16HImode : V32QImode);\n+\t  machine_mode hvmode = (mode == V32HImode ? V16HImode : V32QImode);\n \t  rtx x = gen_reg_rtx (hvmode);\n \n \t  ok = ix86_expand_vector_init_duplicate (false, hvmode, x, val);\n@@ -42553,10 +42553,10 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n    if successful.  */\n \n static bool\n-ix86_expand_vector_init_one_nonzero (bool mmx_ok, enum machine_mode mode,\n+ix86_expand_vector_init_one_nonzero (bool mmx_ok, machine_mode mode,\n \t\t\t\t     rtx target, rtx var, int one_var)\n {\n-  enum machine_mode vsimode;\n+  machine_mode vsimode;\n   rtx new_target;\n   rtx x, tmp;\n   bool use_vector_set = false;\n@@ -42710,11 +42710,11 @@ ix86_expand_vector_init_one_nonzero (bool mmx_ok, enum machine_mode mode,\n    except ONE_VAR are constants.  Return true if successful.  */\n \n static bool\n-ix86_expand_vector_init_one_var (bool mmx_ok, enum machine_mode mode,\n+ix86_expand_vector_init_one_var (bool mmx_ok, machine_mode mode,\n \t\t\t\t rtx target, rtx vals, int one_var)\n {\n   rtx var = XVECEXP (vals, 0, one_var);\n-  enum machine_mode wmode;\n+  machine_mode wmode;\n   rtx const_vec, x;\n \n   const_vec = copy_rtx (vals);\n@@ -42796,10 +42796,10 @@ ix86_expand_vector_init_one_var (bool mmx_ok, enum machine_mode mode,\n    and none identical.  */\n \n static void\n-ix86_expand_vector_init_concat (enum machine_mode mode,\n+ix86_expand_vector_init_concat (machine_mode mode,\n \t\t\t\trtx target, rtx *ops, int n)\n {\n-  enum machine_mode cmode, hmode = VOIDmode, gmode = VOIDmode;\n+  machine_mode cmode, hmode = VOIDmode, gmode = VOIDmode;\n   rtx first[16], second[8], third[4];\n   rtvec v;\n   int i, j;\n@@ -42985,10 +42985,10 @@ ix86_expand_vector_init_concat (enum machine_mode mode,\n    and none identical.  */\n \n static void\n-ix86_expand_vector_init_interleave (enum machine_mode mode,\n+ix86_expand_vector_init_interleave (machine_mode mode,\n \t\t\t\t    rtx target, rtx *ops, int n)\n {\n-  enum machine_mode first_imode, second_imode, third_imode, inner_mode;\n+  machine_mode first_imode, second_imode, third_imode, inner_mode;\n   int i, j;\n   rtx op0, op1;\n   rtx (*gen_load_even) (rtx, rtx, rtx);\n@@ -43099,12 +43099,12 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n    all values variable, and none identical.  */\n \n static void\n-ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n+ix86_expand_vector_init_general (bool mmx_ok, machine_mode mode,\n \t\t\t\t rtx target, rtx vals)\n {\n   rtx ops[64], op0, op1, op2, op3, op4, op5;\n-  enum machine_mode half_mode = VOIDmode;\n-  enum machine_mode quarter_mode = VOIDmode;\n+  machine_mode half_mode = VOIDmode;\n+  machine_mode quarter_mode = VOIDmode;\n   int n, i;\n \n   switch (mode)\n@@ -43221,7 +43221,7 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n \n     {\n       int i, j, n_elts, n_words, n_elt_per_word;\n-      enum machine_mode inner_mode;\n+      machine_mode inner_mode;\n       rtx words[4], shift;\n \n       inner_mode = GET_MODE_INNER (mode);\n@@ -43282,8 +43282,8 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n void\n ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n {\n-  enum machine_mode mode = GET_MODE (target);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (target);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n   int n_var = 0, one_var = -1;\n   bool all_same = true, all_const_zero = true;\n@@ -43336,9 +43336,9 @@ ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n void\n ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n {\n-  enum machine_mode mode = GET_MODE (target);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n-  enum machine_mode half_mode;\n+  machine_mode mode = GET_MODE (target);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode half_mode;\n   bool use_vec_merge = false;\n   rtx tmp;\n   static rtx (*gen_extract[6][2]) (rtx, rtx)\n@@ -43672,8 +43672,8 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n void\n ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n {\n-  enum machine_mode mode = GET_MODE (vec);\n-  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  machine_mode mode = GET_MODE (vec);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n   bool use_vec_extr = false;\n   rtx tmp;\n \n@@ -44062,7 +44062,7 @@ void\n ix86_expand_reduc (rtx (*fn) (rtx, rtx, rtx), rtx dest, rtx in)\n {\n   rtx half, dst, vec = in;\n-  enum machine_mode mode = GET_MODE (in);\n+  machine_mode mode = GET_MODE (in);\n   int i;\n \n   /* SSE4 has a special instruction for V8HImode UMIN reduction.  */\n@@ -44091,7 +44091,7 @@ ix86_expand_reduc (rtx (*fn) (rtx, rtx, rtx), rtx dest, rtx in)\n \f\n /* Target hook for scalar_mode_supported_p.  */\n static bool\n-ix86_scalar_mode_supported_p (enum machine_mode mode)\n+ix86_scalar_mode_supported_p (machine_mode mode)\n {\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return default_decimal_float_supported_p ();\n@@ -44103,7 +44103,7 @@ ix86_scalar_mode_supported_p (enum machine_mode mode)\n \n /* Implements target hook vector_mode_supported_p.  */\n static bool\n-ix86_vector_mode_supported_p (enum machine_mode mode)\n+ix86_vector_mode_supported_p (machine_mode mode)\n {\n   if (TARGET_SSE && VALID_SSE_REG_MODE (mode))\n     return true;\n@@ -44122,7 +44122,7 @@ ix86_vector_mode_supported_p (enum machine_mode mode)\n \n /* Implement target hook libgcc_floating_mode_supported_p.  */\n static bool\n-ix86_libgcc_floating_mode_supported_p (enum machine_mode mode)\n+ix86_libgcc_floating_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -44146,7 +44146,7 @@ ix86_libgcc_floating_mode_supported_p (enum machine_mode mode)\n }\n \n /* Target hook for c_mode_for_suffix.  */\n-static enum machine_mode\n+static machine_mode\n ix86_c_mode_for_suffix (char suffix)\n {\n   if (suffix == 'q')\n@@ -44188,7 +44188,7 @@ ix86_encode_section_info (tree decl, rtx rtl, int first)\n /* Worker function for REVERSE_CONDITION.  */\n \n enum rtx_code\n-ix86_reverse_condition (enum rtx_code code, enum machine_mode mode)\n+ix86_reverse_condition (enum rtx_code code, machine_mode mode)\n {\n   return (mode != CCFPmode && mode != CCFPUmode\n \t  ? reverse_condition (code)\n@@ -44302,8 +44302,8 @@ void ix86_emit_i387_log1p (rtx op0, rtx op1)\n /* Emit code for round calculation.  */\n void ix86_emit_i387_round (rtx op0, rtx op1)\n {\n-  enum machine_mode inmode = GET_MODE (op1);\n-  enum machine_mode outmode = GET_MODE (op0);\n+  machine_mode inmode = GET_MODE (op1);\n+  machine_mode outmode = GET_MODE (op0);\n   rtx e1, e2, res, tmp, tmp1, half;\n   rtx scratch = gen_reg_rtx (HImode);\n   rtx flags = gen_rtx_REG (CCNOmode, FLAGS_REG);\n@@ -44435,7 +44435,7 @@ void ix86_emit_i387_round (rtx op0, rtx op1)\n /* Output code to perform a Newton-Rhapson approximation of a single precision\n    floating point divide [http://en.wikipedia.org/wiki/N-th_root_algorithm].  */\n \n-void ix86_emit_swdivsf (rtx res, rtx a, rtx b, enum machine_mode mode)\n+void ix86_emit_swdivsf (rtx res, rtx a, rtx b, machine_mode mode)\n {\n   rtx x0, x1, e0, e1;\n \n@@ -44482,7 +44482,7 @@ void ix86_emit_swdivsf (rtx res, rtx a, rtx b, enum machine_mode mode)\n /* Output code to perform a Newton-Rhapson approximation of a\n    single precision floating point [reciprocal] square root.  */\n \n-void ix86_emit_swsqrtsf (rtx res, rtx a, enum machine_mode mode,\n+void ix86_emit_swsqrtsf (rtx res, rtx a, machine_mode mode,\n \t\t\t bool recip)\n {\n   rtx x0, e0, e1, e2, e3, mthree, mhalf;\n@@ -44674,11 +44674,11 @@ asm_preferred_eh_data_format (int code, int global)\n static void\n ix86_sse_copysign_to_positive (rtx result, rtx abs_value, rtx sign, rtx mask)\n {\n-  enum machine_mode mode = GET_MODE (sign);\n+  machine_mode mode = GET_MODE (sign);\n   rtx sgn = gen_reg_rtx (mode);\n   if (mask == NULL_RTX)\n     {\n-      enum machine_mode vmode;\n+      machine_mode vmode;\n \n       if (mode == SFmode)\n \tvmode = V4SFmode;\n@@ -44711,7 +44711,7 @@ ix86_sse_copysign_to_positive (rtx result, rtx abs_value, rtx sign, rtx mask)\n static rtx\n ix86_expand_sse_fabs (rtx op0, rtx *smask)\n {\n-  enum machine_mode vmode, mode = GET_MODE (op0);\n+  machine_mode vmode, mode = GET_MODE (op0);\n   rtx xa, mask;\n \n   xa = gen_reg_rtx (mode);\n@@ -44747,7 +44747,7 @@ static rtx_code_label *\n ix86_expand_sse_compare_and_jump (enum rtx_code code, rtx op0, rtx op1,\n                                   bool swap_operands)\n {\n-  enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n   rtx_code_label *label;\n   rtx tmp;\n \n@@ -44779,7 +44779,7 @@ ix86_expand_sse_compare_mask (enum rtx_code code, rtx op0, rtx op1,\n \t\t\t      bool swap_operands)\n {\n   rtx (*insn)(rtx, rtx, rtx, rtx);\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   rtx mask = gen_reg_rtx (mode);\n \n   if (swap_operands)\n@@ -44799,7 +44799,7 @@ ix86_expand_sse_compare_mask (enum rtx_code code, rtx op0, rtx op1,\n /* Generate and return a rtx of mode MODE for 2**n where n is the number\n    of bits of the mantissa of MODE, which must be one of DFmode or SFmode.  */\n static rtx\n-ix86_gen_TWO52 (enum machine_mode mode)\n+ix86_gen_TWO52 (machine_mode mode)\n {\n   REAL_VALUE_TYPE TWO52r;\n   rtx TWO52;\n@@ -44820,7 +44820,7 @@ ix86_expand_lround (rtx op0, rtx op1)\n        tmp = op1 + copysign (nextafter (0.5, 0.0), op1)\n        return (long)tmp;\n    */\n-  enum machine_mode mode = GET_MODE (op1);\n+  machine_mode mode = GET_MODE (op1);\n   const struct real_format *fmt;\n   REAL_VALUE_TYPE pred_half, half_minus_pred_half;\n   rtx adj;\n@@ -44851,8 +44851,8 @@ ix86_expand_lfloorceil (rtx op0, rtx op1, bool do_floor)\n         xi -= (double)xi > op1 ? 1 : 0;\n         return xi;\n    */\n-  enum machine_mode fmode = GET_MODE (op1);\n-  enum machine_mode imode = GET_MODE (op0);\n+  machine_mode fmode = GET_MODE (op1);\n+  machine_mode imode = GET_MODE (op0);\n   rtx ireg, freg, tmp;\n   rtx_code_label *label;\n \n@@ -44889,7 +44889,7 @@ ix86_expand_rint (rtx operand0, rtx operand1)\n         xa = xa + 2**52 - 2**52;\n         return copysign (xa, operand1);\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx res, xa, TWO52, mask;\n   rtx_code_label *label;\n \n@@ -44933,7 +44933,7 @@ ix86_expand_floorceildf_32 (rtx operand0, rtx operand1, bool do_floor)\n           x2 -= -1;\n         return x2;\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx xa, TWO52, tmp, one, res, mask;\n   rtx_code_label *label;\n \n@@ -44997,7 +44997,7 @@ ix86_expand_floorceil (rtx operand0, rtx operand1, bool do_floor)\n \t  return copysign (x2, x);\n \treturn x2;\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx xa, xi, TWO52, tmp, one, res, mask;\n   rtx_code_label *label;\n \n@@ -45061,7 +45061,7 @@ ix86_expand_rounddf_32 (rtx operand0, rtx operand1)\n         x2 = copysign (xa2, x);\n         return x2;\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx xa, xa2, dxa, TWO52, tmp, half, mhalf, one, res, mask;\n   rtx_code_label *label;\n \n@@ -45127,7 +45127,7 @@ ix86_expand_trunc (rtx operand0, rtx operand1)\n \t  return copysign (x2, x);\n \treturn x2;\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx xa, xi, TWO52, res, mask;\n   rtx_code_label *label;\n \n@@ -45163,7 +45163,7 @@ ix86_expand_trunc (rtx operand0, rtx operand1)\n void\n ix86_expand_truncdf_32 (rtx operand0, rtx operand1)\n {\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx xa, mask, TWO52, one, res, smask, tmp;\n   rtx_code_label *label;\n \n@@ -45229,7 +45229,7 @@ ix86_expand_round (rtx operand0, rtx operand1)\n         xa = (double)(long)(xa + nextafter (0.5, 0.0));\n         return copysign (xa, x);\n    */\n-  enum machine_mode mode = GET_MODE (operand0);\n+  machine_mode mode = GET_MODE (operand0);\n   rtx res, TWO52, xa, xi, half, mask;\n   rtx_code_label *label;\n   const struct real_format *fmt;\n@@ -45272,7 +45272,7 @@ ix86_expand_round (rtx operand0, rtx operand1)\n void\n ix86_expand_round_sse4 (rtx op0, rtx op1)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   rtx e1, e2, res, half;\n   const struct real_format *fmt;\n   REAL_VALUE_TYPE pred_half, half_minus_pred_half;\n@@ -45498,7 +45498,7 @@ expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n \t\t\tconst unsigned char *perm, unsigned nelt,\n \t\t\tbool testing_p)\n {\n-  enum machine_mode v2mode;\n+  machine_mode v2mode;\n   rtx x;\n   bool ok;\n \n@@ -45522,7 +45522,7 @@ expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n static bool\n expand_vec_perm_blend (struct expand_vec_perm_d *d)\n {\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   unsigned i, mask, nelt = d->nelt;\n   rtx target, op0, op1, x;\n   rtx rperm[32], vperm;\n@@ -45766,7 +45766,7 @@ expand_vec_perm_vpermil (struct expand_vec_perm_d *d)\n    instead.  */\n \n static bool\n-valid_perm_using_mode_p (enum machine_mode vmode, struct expand_vec_perm_d *d)\n+valid_perm_using_mode_p (machine_mode vmode, struct expand_vec_perm_d *d)\n {\n   unsigned int i, j, chunk;\n \n@@ -45798,7 +45798,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n {\n   unsigned i, nelt, eltsz, mask;\n   unsigned char perm[64];\n-  enum machine_mode vmode = V16QImode;\n+  machine_mode vmode = V16QImode;\n   rtx rperm[64], vperm, target, op0, op1;\n \n   nelt = d->nelt;\n@@ -46320,7 +46320,7 @@ expand_vec_perm_pblendv (struct expand_vec_perm_d *d)\n {\n   unsigned i, which, nelt = d->nelt;\n   struct expand_vec_perm_d dcopy, dcopy1;\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   bool ok;\n \n   /* Use the same checks as in expand_vec_perm_blend.  */\n@@ -47529,7 +47529,7 @@ static bool\n expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n {\n   unsigned elt = d->perm[0], nelt2 = d->nelt / 2;\n-  enum machine_mode vmode = d->vmode;\n+  machine_mode vmode = d->vmode;\n   unsigned char perm2[4];\n   rtx op0 = d->op0, dest;\n   bool ok;\n@@ -47906,7 +47906,7 @@ ix86_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.vec_perm_const_ok.  */\n \n static bool\n-ix86_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+ix86_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t  const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n@@ -48066,8 +48066,8 @@ ix86_expand_vec_interleave (rtx targ, rtx op0, rtx op1, bool high_p)\n void\n ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n {\n-  enum machine_mode qimode = GET_MODE (dest);\n-  enum machine_mode himode;\n+  machine_mode qimode = GET_MODE (dest);\n+  machine_mode himode;\n   rtx (*gen_il) (rtx, rtx, rtx);\n   rtx (*gen_ih) (rtx, rtx, rtx);\n   rtx op1_l, op1_h, op2_l, op2_h, res_l, res_h;\n@@ -48179,7 +48179,7 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n static bool\n const_vector_equal_evenodd_p (rtx op)\n {\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n   int i, nunits = GET_MODE_NUNITS (mode);\n   if (GET_CODE (op) != CONST_VECTOR\n       || nunits != CONST_VECTOR_NUNITS (op))\n@@ -48194,8 +48194,8 @@ void\n ix86_expand_mul_widen_evenodd (rtx dest, rtx op1, rtx op2,\n \t\t\t       bool uns_p, bool odd_p)\n {\n-  enum machine_mode mode = GET_MODE (op1);\n-  enum machine_mode wmode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (op1);\n+  machine_mode wmode = GET_MODE (dest);\n   rtx x;\n   rtx orig_op1 = op1, orig_op2 = op2;\n \n@@ -48289,8 +48289,8 @@ void\n ix86_expand_mul_widen_hilo (rtx dest, rtx op1, rtx op2,\n \t\t\t    bool uns_p, bool high_p)\n {\n-  enum machine_mode wmode = GET_MODE (dest);\n-  enum machine_mode mode = GET_MODE (op1);\n+  machine_mode wmode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (op1);\n   rtx t1, t2, t3, t4, mask;\n \n   switch (mode)\n@@ -48413,7 +48413,7 @@ ix86_expand_sse2_mulv4si3 (rtx op0, rtx op1, rtx op2)\n void\n ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   rtx t1, t2, t3, t4, t5, t6;\n \n   if (TARGET_AVX512DQ && mode == V8DImode)\n@@ -48459,7 +48459,7 @@ ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n     }\n   else\n     {\n-      enum machine_mode nmode;\n+      machine_mode nmode;\n       rtx (*umul) (rtx, rtx, rtx);\n \n       if (mode == V2DImode)\n@@ -48513,7 +48513,7 @@ ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n void\n ix86_expand_sse2_abs (rtx target, rtx input)\n {\n-  enum machine_mode mode = GET_MODE (target);\n+  machine_mode mode = GET_MODE (target);\n   rtx tmp0, tmp1, x;\n \n   switch (mode)\n@@ -48586,7 +48586,7 @@ ix86_expand_pinsr (rtx *operands)\n     case V4SImode:\n     case V2DImode:\n       {\n-\tenum machine_mode srcmode, dstmode;\n+\tmachine_mode srcmode, dstmode;\n \trtx (*pinsr)(rtx, rtx, rtx, rtx);\n \n \tsrcmode = mode_for_size (size, MODE_INT, 0);\n@@ -49585,7 +49585,7 @@ has_dispatch (rtx_insn *insn, int action)\n    enabled for other processors.  */\n \n static int\n-ix86_reassociation_width (unsigned int, enum machine_mode mode)\n+ix86_reassociation_width (unsigned int, machine_mode mode)\n {\n   int res = 1;\n \n@@ -49610,8 +49610,8 @@ ix86_reassociation_width (unsigned int, enum machine_mode mode)\n /* ??? No autovectorization into MMX or 3DNOW until we can reliably\n    place emms and femms instructions.  */\n \n-static enum machine_mode\n-ix86_preferred_simd_mode (enum machine_mode mode)\n+static machine_mode\n+ix86_preferred_simd_mode (machine_mode mode)\n {\n   if (!TARGET_SSE)\n     return word_mode;\n@@ -49672,7 +49672,7 @@ ix86_autovectorize_vector_sizes (void)\n    and of class RCLASS for spilling instead of memory.  Return NO_REGS\n    if it is not possible or non-profitable.  */\n static reg_class_t\n-ix86_spill_class (reg_class_t rclass, enum machine_mode mode)\n+ix86_spill_class (reg_class_t rclass, machine_mode mode)\n {\n   if (TARGET_SSE && TARGET_GENERAL_REGS_SSE_SPILL && ! TARGET_MMX\n       && (mode == SImode || (TARGET_64BIT && mode == DImode))\n@@ -49988,7 +49988,7 @@ ix86_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n \t  if (const_rtx x = *iter)\n \t    if (MEM_P (x))\n \t      {\n-\t\tenum machine_mode mode = GET_MODE (x);\n+\t\tmachine_mode mode = GET_MODE (x);\n \t\tunsigned int n_words = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n \t\tif (n_words > 4)\n \t\t  mem_count += 2;"}, {"sha": "a1803d56612160d0374d56be4cc44624f5a490ec", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -4408,8 +4408,8 @@\n      (clobber (match_scratch:<ssevecmode> 4))])]\n   \"!TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH\"\n {\n-  enum machine_mode mode = <MODE>mode;\n-  enum machine_mode vecmode = <ssevecmode>mode;\n+  machine_mode mode = <MODE>mode;\n+  machine_mode vecmode = <ssevecmode>mode;\n   REAL_VALUE_TYPE TWO31r;\n   rtx two31;\n \n@@ -4854,8 +4854,8 @@\n    && reload_completed && SSE_REG_P (operands[0])\"\n   [(const_int 0)]\n {\n-  const enum machine_mode vmode = <MODEF:ssevecmode>mode;\n-  const enum machine_mode mode = <MODEF:MODE>mode;\n+  const machine_mode vmode = <MODEF:ssevecmode>mode;\n+  const machine_mode mode = <MODEF:MODE>mode;\n   rtx t, op0 = simplify_gen_subreg (vmode, operands[0], mode, 0);\n \n   emit_move_insn (op0, CONST0_RTX (vmode));\n@@ -5071,7 +5071,7 @@\n   \"reload_completed && ix86_avoid_lea_for_addr (insn, operands)\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = <MODE>mode;\n+  machine_mode mode = <MODE>mode;\n   rtx pat;\n \n   /* ix86_avoid_lea_for_addr re-recognizes insn and may\n@@ -5439,7 +5439,7 @@\n   \"reload_completed && ix86_lea_for_add_ok (insn, operands)\" \n   [(const_int 0)]\n {\n-  enum machine_mode mode = <MODE>mode;\n+  machine_mode mode = <MODE>mode;\n   rtx pat;\n \n   if (<MODE_SIZE> < GET_MODE_SIZE (SImode))\n@@ -5945,7 +5945,7 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = SImode;\n+  machine_mode mode = SImode;\n   rtx pat;\n \n   operands[0] = gen_lowpart (mode, operands[0]);\n@@ -5976,7 +5976,7 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = SImode;\n+  machine_mode mode = SImode;\n   rtx pat;\n \n   operands[0] = gen_lowpart (mode, operands[0]);\n@@ -6006,7 +6006,7 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = SImode;\n+  machine_mode mode = SImode;\n   rtx pat;\n \n   operands[0] = gen_lowpart (mode, operands[0]);\n@@ -6045,7 +6045,7 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtx pat;\n \n   if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n@@ -7451,7 +7451,7 @@\n   HOST_WIDE_INT len = INTVAL (operands[3]);\n   HOST_WIDE_INT pos = INTVAL (operands[4]);\n   HOST_WIDE_INT mask;\n-  enum machine_mode mode, submode;\n+  machine_mode mode, submode;\n \n   mode = GET_MODE (val);\n   if (MEM_P (val))\n@@ -7574,7 +7574,7 @@\n \t\t  (match_operand:SWIM 2 \"<general_szext_operand>\")))]\n   \"\"\n {\n-  enum machine_mode mode = <MODE>mode;\n+  machine_mode mode = <MODE>mode;\n   rtx (*insn) (rtx, rtx);\n \n   if (CONST_INT_P (operands[2]) && REG_P (operands[0]))\n@@ -7825,7 +7825,7 @@\n   [(const_int 0)]\n {\n   HOST_WIDE_INT ival = INTVAL (operands[2]);\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx (*insn) (rtx, rtx);\n \n   if (ival == (HOST_WIDE_INT) 0xffffffff)\n@@ -8733,8 +8733,8 @@\n   \"reload_completed && SSE_REG_P (operands[0])\"\n   [(set (match_dup 0) (match_dup 3))]\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n-  enum machine_mode vmode = GET_MODE (operands[2]);\n+  machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode vmode = GET_MODE (operands[2]);\n   rtx tmp;\n \n   operands[0] = simplify_gen_subreg (vmode, operands[0], mode, 0);\n@@ -9512,7 +9512,7 @@\n    && true_regnum (operands[0]) != true_regnum (operands[1])\"\n   [(const_int 0)]\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtx pat;\n \n   if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n@@ -12157,7 +12157,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n {\n-  enum machine_mode flags_mode;\n+  machine_mode flags_mode;\n \n   if (<MODE>mode == SImode && !TARGET_CMOVE)\n     {\n@@ -12192,7 +12192,7 @@\n    (parallel [(set (match_dup 0) (plus:SI (match_dup 0) (const_int 1)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n {\n-  enum machine_mode flags_mode\n+  machine_mode flags_mode\n     = (TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI) ? CCCmode : CCZmode;\n \n   operands[3] = gen_lowpart (QImode, operands[2]);\n@@ -17847,8 +17847,8 @@\n   [(set (match_dup 5) (match_dup 4))\n    (set (match_dup 0) (match_dup 1))]\n {\n-  enum machine_mode op1mode = GET_MODE (operands[1]);\n-  enum machine_mode mode = op1mode == DImode ? DImode : SImode;\n+  machine_mode op1mode = GET_MODE (operands[1]);\n+  machine_mode mode = op1mode == DImode ? DImode : SImode;\n   int scale = 1 << INTVAL (operands[2]);\n   rtx index = gen_lowpart (word_mode, operands[1]);\n   rtx base = gen_lowpart (word_mode, operands[5]);"}, {"sha": "7d0b51e1d14c19419254d78f76aedc23ef162b09", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1111,7 +1111,7 @@\n (define_predicate \"fcmov_comparison_operator\"\n   (match_operand 0 \"comparison_operator\")\n {\n-  enum machine_mode inmode = GET_MODE (XEXP (op, 0));\n+  machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)\n@@ -1158,7 +1158,7 @@\n (define_predicate \"ix86_comparison_operator\"\n   (match_operand 0 \"comparison_operator\")\n {\n-  enum machine_mode inmode = GET_MODE (XEXP (op, 0));\n+  machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)\n@@ -1195,7 +1195,7 @@\n (define_predicate \"ix86_carry_flag_operator\"\n   (match_code \"ltu,lt,unlt,gtu,gt,ungt,le,unle,ge,unge,ltgt,uneq\")\n {\n-  enum machine_mode inmode = GET_MODE (XEXP (op, 0));\n+  machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n   if (inmode == CCFPmode || inmode == CCFPUmode)"}, {"sha": "2757a1e781c4fda61ceff31bb79a521890785864", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -14533,7 +14533,7 @@\n \t  UNSPEC_ROUND))]\n   \"TARGET_ROUND && !flag_trapping_math\"\n {\n-  enum machine_mode scalar_mode;\n+  machine_mode scalar_mode;\n   const struct real_format *fmt;\n   REAL_VALUE_TYPE pred_half, half_minus_pred_half;\n   rtx half, vec_half;\n@@ -17211,7 +17211,7 @@\n \t  [(match_operand 3 \"const_int_operand\" \"n, n\")])))]\n   \"TARGET_SSSE3\"\n {\n-  enum machine_mode imode = GET_MODE_INNER (GET_MODE (operands[0]));\n+  machine_mode imode = GET_MODE_INNER (GET_MODE (operands[0]));\n   operands[2] = GEN_INT (INTVAL (operands[3]) * GET_MODE_SIZE (imode));\n \n   switch (which_alternative)"}, {"sha": "35a3debacc2f10f41f5335d994ced8f550b25f97", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -350,7 +350,7 @@\n     }\n   else\n     {\n-      enum machine_mode hmode = <CASHMODE>mode;\n+      machine_mode hmode = <CASHMODE>mode;\n       rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n;\n \n       lo_o = operands[1];"}, {"sha": "47c52d5769615670a7ff0ef580f1a01183aa84d8", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -35,10 +35,10 @@ extern int addp4_optimize_ok (rtx, rtx);\n extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);\n extern void ia64_split_tmode_move (rtx[]);\n-extern bool ia64_expand_movxf_movrf (enum machine_mode, rtx[]);\n+extern bool ia64_expand_movxf_movrf (machine_mode, rtx[]);\n extern void ia64_expand_compare (rtx *, rtx *, rtx *);\n extern void ia64_expand_vecint_cmov (rtx[]);\n-extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);\n+extern bool ia64_expand_vecint_minmax (enum rtx_code, machine_mode, rtx[]);\n extern void ia64_unpack_assemble (rtx, rtx, rtx, bool);\n extern void ia64_expand_unpack (rtx [], bool, bool);\n extern void ia64_expand_widen_sum (rtx[], bool);\n@@ -57,7 +57,7 @@ extern bool ia64_expand_load_address (rtx, rtx);\n extern int ia64_hard_regno_rename_ok (int, int);\n \n extern enum reg_class ia64_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t   enum machine_mode, rtx);\n+\t\t\t\t\t\t   machine_mode, rtx);\n extern const char *get_bundle_name (int);\n extern const char *output_probe_stack_range (rtx, rtx);\n \n@@ -68,7 +68,7 @@ extern void ia64_expand_vec_setv2sf (rtx op[3]);\n \n #ifdef TREE_CODE\n #ifdef RTX_CODE\n-extern rtx ia64_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern rtx ia64_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern rtx ia64_va_arg (tree, tree);\n #endif /* RTX_CODE */\n \n@@ -91,7 +91,7 @@ extern void ia64_split_return_addr_rtx (rtx);\n \n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction'.  */\n-extern enum direction ia64_hpux_function_arg_padding (enum machine_mode, const_tree);\n+extern enum direction ia64_hpux_function_arg_padding (machine_mode, const_tree);\n #endif /* ARGS_SIZE_RTX */\n \n extern void ia64_hpux_handle_builtin_pragma (struct cpp_reader *);"}, {"sha": "beb9e606c056e40ffa94ce637a6688e2eab3e63c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -188,7 +188,7 @@ static void ia64_init_sched_context (void *, bool);\n static void ia64_set_sched_context (void *);\n static void ia64_clear_sched_context (void *);\n static void ia64_free_sched_context (void *);\n-static int ia64_mode_to_int (enum machine_mode);\n+static int ia64_mode_to_int (machine_mode);\n static void ia64_set_sched_flags (spec_info_t);\n static ds_t ia64_get_insn_spec_ds (rtx_insn *);\n static ds_t ia64_get_insn_checked_ds (rtx_insn *);\n@@ -215,29 +215,29 @@ static rtx gen_fr_restore_x (rtx, rtx, rtx);\n \n static void ia64_option_override (void);\n static bool ia64_can_eliminate (const int, const int);\n-static enum machine_mode hfa_element_mode (const_tree, bool);\n-static void ia64_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static machine_mode hfa_element_mode (const_tree, bool);\n+static void ia64_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n-static int ia64_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static int ia64_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx ia64_function_arg_1 (cumulative_args_t, enum machine_mode,\n+static rtx ia64_function_arg_1 (cumulative_args_t, machine_mode,\n \t\t\t\tconst_tree, bool, bool);\n-static rtx ia64_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx ia64_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static rtx ia64_function_incoming_arg (cumulative_args_t,\n-\t\t\t\t       enum machine_mode, const_tree, bool);\n-static void ia64_function_arg_advance (cumulative_args_t, enum machine_mode,\n+\t\t\t\t       machine_mode, const_tree, bool);\n+static void ia64_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static unsigned int ia64_function_arg_boundary (enum machine_mode,\n+static unsigned int ia64_function_arg_boundary (machine_mode,\n \t\t\t\t\t\tconst_tree);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n static bool ia64_return_in_memory (const_tree, const_tree);\n static rtx ia64_function_value (const_tree, const_tree, bool);\n-static rtx ia64_libcall_value (enum machine_mode, const_rtx);\n+static rtx ia64_libcall_value (machine_mode, const_rtx);\n static bool ia64_function_value_regno_p (const unsigned int);\n-static int ia64_register_move_cost (enum machine_mode, reg_class_t,\n+static int ia64_register_move_cost (machine_mode, reg_class_t,\n                                     reg_class_t);\n-static int ia64_memory_move_cost (enum machine_mode mode, reg_class_t,\n+static int ia64_memory_move_cost (machine_mode mode, reg_class_t,\n \t\t\t\t  bool);\n static bool ia64_rtx_costs (rtx, int, int, int, int *, bool);\n static int ia64_unspec_may_trap_p (const_rtx, unsigned);\n@@ -303,7 +303,7 @@ static void ia64_globalize_decl_name (FILE *, tree);\n \n static int ia64_hpux_reloc_rw_mask (void) ATTRIBUTE_UNUSED;\n static int ia64_reloc_rw_mask (void) ATTRIBUTE_UNUSED;\n-static section *ia64_select_rtx_section (enum machine_mode, rtx,\n+static section *ia64_select_rtx_section (machine_mode, rtx,\n \t\t\t\t\t unsigned HOST_WIDE_INT);\n static void ia64_output_dwarf_dtprel (FILE *, int, rtx)\n      ATTRIBUTE_UNUSED;\n@@ -318,7 +318,7 @@ static void ia64_vms_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n static void ia64_soft_fp_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n-static bool ia64_vms_valid_pointer_mode (enum machine_mode mode)\n+static bool ia64_vms_valid_pointer_mode (machine_mode mode)\n      ATTRIBUTE_UNUSED;\n static tree ia64_vms_common_object_attribute (tree *, tree, tree, int, bool *)\n      ATTRIBUTE_UNUSED;\n@@ -328,29 +328,29 @@ static tree ia64_handle_version_id_attribute (tree *, tree, tree, int, bool *);\n static void ia64_encode_section_info (tree, rtx, int);\n static rtx ia64_struct_value_rtx (tree, int);\n static tree ia64_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n-static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n-static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n-static bool ia64_libgcc_floating_mode_supported_p (enum machine_mode mode);\n-static bool ia64_legitimate_constant_p (enum machine_mode, rtx);\n-static bool ia64_legitimate_address_p (enum machine_mode, rtx, bool);\n-static bool ia64_cannot_force_const_mem (enum machine_mode, rtx);\n+static bool ia64_scalar_mode_supported_p (machine_mode mode);\n+static bool ia64_vector_mode_supported_p (machine_mode mode);\n+static bool ia64_libgcc_floating_mode_supported_p (machine_mode mode);\n+static bool ia64_legitimate_constant_p (machine_mode, rtx);\n+static bool ia64_legitimate_address_p (machine_mode, rtx, bool);\n+static bool ia64_cannot_force_const_mem (machine_mode, rtx);\n static const char *ia64_mangle_type (const_tree);\n static const char *ia64_invalid_conversion (const_tree, const_tree);\n static const char *ia64_invalid_unary_op (int, const_tree);\n static const char *ia64_invalid_binary_op (int, const_tree, const_tree);\n-static enum machine_mode ia64_c_mode_for_suffix (char);\n+static machine_mode ia64_c_mode_for_suffix (char);\n static void ia64_trampoline_init (rtx, tree, rtx);\n static void ia64_override_options_after_change (void);\n-static bool ia64_member_type_forces_blk (const_tree, enum machine_mode);\n+static bool ia64_member_type_forces_blk (const_tree, machine_mode);\n \n static tree ia64_builtin_decl (unsigned, bool);\n \n static reg_class_t ia64_preferred_reload_class (rtx, reg_class_t);\n-static enum machine_mode ia64_get_reg_raw_mode (int regno);\n+static machine_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n \n-static bool ia64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t      const unsigned char *sel);\n \n #define MAX_VECT_LEN\t8\n@@ -359,7 +359,7 @@ struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n   unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n   unsigned char nelt;\n   bool one_operand_p;\n   bool testing_p; \n@@ -1002,7 +1002,7 @@ ia64_legitimate_address_disp (const_rtx reg, const_rtx disp, bool strict)\n /* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n \n static bool\n-ia64_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+ia64_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   rtx x, bool strict)\n {\n   if (ia64_legitimate_address_reg (x, strict))\n@@ -1024,7 +1024,7 @@ ia64_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n    field in an instruction.  */\n \n static bool\n-ia64_legitimate_constant_p (enum machine_mode mode, rtx x)\n+ia64_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1079,7 +1079,7 @@ ia64_legitimate_constant_p (enum machine_mode mode, rtx x)\n /* Don't allow TLS addresses to get spilled to memory.  */\n \n static bool\n-ia64_cannot_force_const_mem (enum machine_mode mode, rtx x)\n+ia64_cannot_force_const_mem (machine_mode mode, rtx x)\n {\n   if (mode == RFmode)\n     return true;\n@@ -1286,7 +1286,7 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n rtx\n ia64_expand_move (rtx op0, rtx op1)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n \n   if (!reload_in_progress && !reload_completed && !ia64_move_ok (op0, op1))\n     op1 = force_reg (mode, op1);\n@@ -1613,7 +1613,7 @@ ia64_split_tmode_move (rtx operands[])\n    we see something like the above, we spill the inner register to memory.  */\n \n static rtx\n-spill_xfmode_rfmode_operand (rtx in, int force, enum machine_mode mode)\n+spill_xfmode_rfmode_operand (rtx in, int force, machine_mode mode)\n {\n   if (GET_CODE (in) == SUBREG\n       && GET_MODE (SUBREG_REG (in)) == TImode\n@@ -1638,7 +1638,7 @@ spill_xfmode_rfmode_operand (rtx in, int force, enum machine_mode mode)\n    DONE.  */\n \n bool\n-ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n+ia64_expand_movxf_movrf (machine_mode mode, rtx operands[])\n {\n   rtx op0 = operands[0];\n \n@@ -1861,7 +1861,7 @@ ia64_expand_compare (rtx *expr, rtx *op0, rtx *op1)\n    been reversed, and so the sense of the comparison should be inverted.  */\n \n static bool\n-ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n+ia64_expand_vecint_compare (enum rtx_code code, machine_mode mode,\n \t\t\t    rtx dest, rtx op0, rtx op1)\n {\n   bool negate = false;\n@@ -1952,7 +1952,7 @@ ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n void\n ia64_expand_vecint_cmov (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   enum rtx_code code = GET_CODE (operands[3]);\n   bool negate;\n   rtx cmp, x, ot, of;\n@@ -2002,7 +2002,7 @@ ia64_expand_vecint_cmov (rtx operands[])\n /* Emit an integral vector min or max operation.  Return true if all done.  */\n \n bool\n-ia64_expand_vecint_minmax (enum rtx_code code, enum machine_mode mode,\n+ia64_expand_vecint_minmax (enum rtx_code code, machine_mode mode,\n \t\t\t   rtx operands[])\n {\n   rtx xops[6];\n@@ -2059,7 +2059,7 @@ ia64_expand_vecint_minmax (enum rtx_code code, enum machine_mode mode,\n void\n ia64_unpack_assemble (rtx out, rtx lo, rtx hi, bool highp)\n {\n-  enum machine_mode vmode = GET_MODE (lo);\n+  machine_mode vmode = GET_MODE (lo);\n   unsigned int i, high, nelt = GET_MODE_NUNITS (vmode);\n   struct expand_vec_perm_d d;\n   bool ok;\n@@ -2088,7 +2088,7 @@ ia64_unpack_assemble (rtx out, rtx lo, rtx hi, bool highp)\n static rtx\n ia64_unpack_sign (rtx vec, bool unsignedp)\n {\n-  enum machine_mode mode = GET_MODE (vec);\n+  machine_mode mode = GET_MODE (vec);\n   rtx zero = CONST0_RTX (mode);\n \n   if (unsignedp)\n@@ -2119,7 +2119,7 @@ ia64_expand_unpack (rtx operands[3], bool unsignedp, bool highp)\n void\n ia64_expand_widen_sum (rtx operands[3], bool unsignedp)\n {\n-  enum machine_mode wmode;\n+  machine_mode wmode;\n   rtx l, h, t, sign;\n \n   sign = ia64_unpack_sign (operands[1], unsignedp);\n@@ -2336,7 +2336,7 @@ void\n ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n \t\t       rtx old_dst, rtx new_dst, enum memmodel model)\n {\n-  enum machine_mode mode = GET_MODE (mem);\n+  machine_mode mode = GET_MODE (mem);\n   rtx old_reg, new_reg, cmp_reg, ar_ccv, label;\n   enum insn_code icode;\n \n@@ -4503,7 +4503,7 @@ ia64_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n    We generate the actual spill instructions during prologue generation.  */\n \n static void\n-ia64_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+ia64_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t     tree type, int * pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n@@ -4532,11 +4532,11 @@ ia64_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n    have already decided to pass them by reference.  Top-level zero-sized\n    aggregates are excluded because our parallels crash the middle-end.  */\n \n-static enum machine_mode\n+static machine_mode\n hfa_element_mode (const_tree type, bool nested)\n {\n-  enum machine_mode element_mode = VOIDmode;\n-  enum machine_mode mode;\n+  machine_mode element_mode = VOIDmode;\n+  machine_mode mode;\n   enum tree_code code = TREE_CODE (type);\n   int know_element_mode = 0;\n   tree t;\n@@ -4611,7 +4611,7 @@ hfa_element_mode (const_tree type, bool nested)\n /* Return the number of words required to hold a quantity of TYPE and MODE\n    when passed as an argument.  */\n static int\n-ia64_function_arg_words (const_tree type, enum machine_mode mode)\n+ia64_function_arg_words (const_tree type, machine_mode mode)\n {\n   int words;\n \n@@ -4658,15 +4658,15 @@ ia64_function_arg_offset (const CUMULATIVE_ARGS *cum,\n    registers.  */\n \n static rtx\n-ia64_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n+ia64_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t\t     const_tree type, bool named, bool incoming)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n-  enum machine_mode hfa_mode = VOIDmode;\n+  machine_mode hfa_mode = VOIDmode;\n \n   /* For OPEN VMS, emit the instruction setting up the argument register here,\n      when we know this will be together with the other arguments setup related\n@@ -4753,7 +4753,7 @@ ia64_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n \n       for (; offset < byte_size && int_regs < MAX_ARGUMENT_SLOTS; i++)\n \t{\n-\t  enum machine_mode gr_mode = DImode;\n+\t  machine_mode gr_mode = DImode;\n \t  unsigned int gr_size;\n \n \t  /* If we have an odd 4 byte hunk because we ran out of FR regs,\n@@ -4833,7 +4833,7 @@ ia64_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n   else\n     {\n       /* See comment above.  */\n-      enum machine_mode inner_mode =\n+      machine_mode inner_mode =\n \t(BYTES_BIG_ENDIAN && mode == SFmode) ? DImode : mode;\n \n       rtx fp_reg = gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4853,7 +4853,7 @@ ia64_function_arg_1 (cumulative_args_t cum_v, enum machine_mode mode,\n /* Implement TARGET_FUNCION_ARG target hook.  */\n \n static rtx\n-ia64_function_arg (cumulative_args_t cum, enum machine_mode mode,\n+ia64_function_arg (cumulative_args_t cum, machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   return ia64_function_arg_1 (cum, mode, type, named, false);\n@@ -4863,7 +4863,7 @@ ia64_function_arg (cumulative_args_t cum, enum machine_mode mode,\n \n static rtx\n ia64_function_incoming_arg (cumulative_args_t cum,\n-\t\t\t    enum machine_mode mode,\n+\t\t\t    machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n   return ia64_function_arg_1 (cum, mode, type, named, true);\n@@ -4874,7 +4874,7 @@ ia64_function_incoming_arg (cumulative_args_t cum,\n    in memory.  */\n \n static int\n-ia64_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+ia64_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -4900,7 +4900,7 @@ ia64_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n /* Return ivms_arg_type based on machine_mode.  */\n \n static enum ivms_arg_type\n-ia64_arg_type (enum machine_mode mode)\n+ia64_arg_type (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -4917,13 +4917,13 @@ ia64_arg_type (enum machine_mode mode)\n    ia64_function_arg.  */\n \n static void\n-ia64_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n-  enum machine_mode hfa_mode = VOIDmode;\n+  machine_mode hfa_mode = VOIDmode;\n \n   /* If all arg slots are already full, then there is nothing to do.  */\n   if (cum->words >= MAX_ARGUMENT_SLOTS)\n@@ -5015,7 +5015,7 @@ ia64_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n    even though their normal alignment is 8 bytes.  See ia64_function_arg.  */\n \n static unsigned int\n-ia64_function_arg_boundary (enum machine_mode mode, const_tree type)\n+ia64_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   if (mode == TFmode && TARGET_HPUX && TARGET_ILP32)\n     return PARM_BOUNDARY * 2;\n@@ -5089,8 +5089,8 @@ ia64_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n static bool\n ia64_return_in_memory (const_tree valtype, const_tree fntype ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n-  enum machine_mode hfa_mode;\n+  machine_mode mode;\n+  machine_mode hfa_mode;\n   HOST_WIDE_INT byte_size;\n \n   mode = TYPE_MODE (valtype);\n@@ -5127,8 +5127,8 @@ ia64_function_value (const_tree valtype,\n \t\t     const_tree fn_decl_or_type,\n \t\t     bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n-  enum machine_mode hfa_mode;\n+  machine_mode mode;\n+  machine_mode hfa_mode;\n   int unsignedp;\n   const_tree func = fn_decl_or_type;\n \n@@ -5216,7 +5216,7 @@ ia64_function_value (const_tree valtype,\n /* Worker function for TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-ia64_libcall_value (enum machine_mode mode,\n+ia64_libcall_value (machine_mode mode,\n \t\t    const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode,\n@@ -5678,7 +5678,7 @@ ia64_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n    one in class TO, using MODE.  */\n \n static int\n-ia64_register_move_cost (enum machine_mode mode, reg_class_t from,\n+ia64_register_move_cost (machine_mode mode, reg_class_t from,\n \t\t\t reg_class_t to)\n {\n   /* ADDL_REGS is the same as GR_REGS for movement purposes.  */\n@@ -5750,7 +5750,7 @@ ia64_register_move_cost (enum machine_mode mode, reg_class_t from,\n    memory.  */\n \n static int\n-ia64_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+ia64_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       reg_class_t rclass,\n \t\t       bool in ATTRIBUTE_UNUSED)\n {\n@@ -5804,7 +5804,7 @@ ia64_preferred_reload_class (rtx x, reg_class_t rclass)\n \n enum reg_class\n ia64_secondary_reload_class (enum reg_class rclass,\n-\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   int regno = -1;\n \n@@ -7876,7 +7876,7 @@ get_spec_load_gen_function (ds_t ts, int mode_no)\n   return gen_ld[mode_no];\n }\n \n-/* Constants that help mapping 'enum machine_mode' to int.  */\n+/* Constants that help mapping 'machine_mode' to int.  */\n enum SPEC_MODES\n   {\n     SPEC_MODE_INVALID = -1,\n@@ -7894,7 +7894,7 @@ enum\n \n /* Return index of the MODE.  */\n static int\n-ia64_mode_to_int (enum machine_mode mode)\n+ia64_mode_to_int (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -10443,7 +10443,7 @@ ia64_init_builtins (void)\n \n rtx\n ia64_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -10467,7 +10467,7 @@ ia64_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IA64_BUILTIN_INFQ:\n     case IA64_BUILTIN_HUGE_VALQ:\n       {\n-        enum machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n+        machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n \tREAL_VALUE_TYPE inf;\n \trtx tmp;\n \n@@ -10509,7 +10509,7 @@ ia64_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n    most significant bits of the stack slot.  */\n \n enum direction\n-ia64_hpux_function_arg_padding (enum machine_mode mode, const_tree type)\n+ia64_hpux_function_arg_padding (machine_mode mode, const_tree type)\n {\n    /* Exception to normal case for structures/unions/etc.  */\n \n@@ -10676,7 +10676,7 @@ ia64_soft_fp_init_libfuncs (void)\n }\n \n static bool\n-ia64_vms_valid_pointer_mode (enum machine_mode mode)\n+ia64_vms_valid_pointer_mode (machine_mode mode)\n {\n   return (mode == SImode || mode == DImode);\n }\n@@ -10703,7 +10703,7 @@ ia64_reloc_rw_mask (void)\n    is to honor small data.  */\n \n static section *\n-ia64_select_rtx_section (enum machine_mode mode, rtx x,\n+ia64_select_rtx_section (machine_mode mode, rtx x,\n \t\t\t unsigned HOST_WIDE_INT align)\n {\n   if (GET_MODE_SIZE (mode) > 0\n@@ -10912,7 +10912,7 @@ ia64_struct_value_rtx (tree fntype,\n }\n \n static bool\n-ia64_scalar_mode_supported_p (enum machine_mode mode)\n+ia64_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -10938,7 +10938,7 @@ ia64_scalar_mode_supported_p (enum machine_mode mode)\n }\n \n static bool\n-ia64_vector_mode_supported_p (enum machine_mode mode)\n+ia64_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -10958,7 +10958,7 @@ ia64_vector_mode_supported_p (enum machine_mode mode)\n /* Implement TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P.  */\n \n static bool\n-ia64_libgcc_floating_mode_supported_p (enum machine_mode mode)\n+ia64_libgcc_floating_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -11175,7 +11175,7 @@ ia64_handle_version_id_attribute (tree *node ATTRIBUTE_UNUSED,\n \n /* Target hook for c_mode_for_suffix.  */\n \n-static enum machine_mode\n+static machine_mode\n ia64_c_mode_for_suffix (char suffix)\n {\n   if (suffix == 'q')\n@@ -11214,7 +11214,7 @@ ia64_dconst_0_375 (void)\n   return ia64_dconst_0_375_rtx;\n }\n \n-static enum machine_mode\n+static machine_mode\n ia64_get_reg_raw_mode (int regno)\n {\n   if (FR_REGNO_P (regno))\n@@ -11226,7 +11226,7 @@ ia64_get_reg_raw_mode (int regno)\n    anymore.  */\n \n bool\n-ia64_member_type_forces_blk (const_tree, enum machine_mode mode)\n+ia64_member_type_forces_blk (const_tree, machine_mode mode)\n {\n   return TARGET_HPUX && mode == TFmode;\n }\n@@ -11273,7 +11273,7 @@ static bool\n expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n \t\t\tconst unsigned char *perm, unsigned nelt)\n {\n-  enum machine_mode v2mode;\n+  machine_mode v2mode;\n   rtx x;\n \n   v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n@@ -11708,7 +11708,7 @@ ia64_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.vec_perm_const_ok.  */\n \n static bool\n-ia64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t  const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n@@ -11781,7 +11781,7 @@ void\n ia64_expand_vec_perm_even_odd (rtx target, rtx op0, rtx op1, int odd)\n {\n   struct expand_vec_perm_d d;\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n   bool ok;\n "}, {"sha": "43c0aa6a96ea95e149a9e775c92f037500603927", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -20,8 +20,8 @@\n #ifndef GCC_IQ2000_PROTOS_H\n #define GCC_IQ2000_PROTOS_H\n \n-extern int              iq2000_check_split (rtx, enum machine_mode);\n-extern int              iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n+extern int              iq2000_check_split (rtx, machine_mode);\n+extern int              iq2000_reg_mode_ok_for_base_p (rtx, machine_mode, int);\n extern const char *     iq2000_fill_delay_slot (const char *, enum delay_type, rtx *, rtx_insn *);\n extern const char *     iq2000_move_1word (rtx *, rtx_insn *, int);\n extern HOST_WIDE_INT    iq2000_debugger_offset (rtx, HOST_WIDE_INT);\n@@ -38,7 +38,7 @@ extern char *           iq2000_output_conditional_branch (rtx_insn *, rtx *,\n \n #ifdef RTX_CODE\n extern rtx              gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n-extern void             gen_conditional_branch (rtx *, enum machine_mode);\n+extern void             gen_conditional_branch (rtx *, machine_mode);\n #endif\n \n #ifdef TREE_CODE"}, {"sha": "9f45b1d36837bd8af2295e175e360939f025e947", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -154,42 +154,42 @@ static rtx iq2000_load_reg3;\n static rtx iq2000_load_reg4;\n \n /* Mode used for saving/restoring general purpose registers.  */\n-static enum machine_mode gpr_mode;\n+static machine_mode gpr_mode;\n \n \f\n /* Initialize the GCC target structure.  */\n static struct machine_function* iq2000_init_machine_status (void);\n static void iq2000_option_override    (void);\n-static section *iq2000_select_rtx_section (enum machine_mode, rtx,\n+static section *iq2000_select_rtx_section (machine_mode, rtx,\n \t\t\t\t\t   unsigned HOST_WIDE_INT);\n static void iq2000_init_builtins      (void);\n-static rtx  iq2000_expand_builtin     (tree, rtx, rtx, enum machine_mode, int);\n+static rtx  iq2000_expand_builtin     (tree, rtx, rtx, machine_mode, int);\n static bool iq2000_return_in_memory   (const_tree, const_tree);\n static void iq2000_setup_incoming_varargs (cumulative_args_t,\n-\t\t\t\t\t   enum machine_mode, tree, int *,\n+\t\t\t\t\t   machine_mode, tree, int *,\n \t\t\t\t\t   int);\n static bool iq2000_rtx_costs          (rtx, int, int, int, int *, bool);\n-static int  iq2000_address_cost       (rtx, enum machine_mode, addr_space_t,\n+static int  iq2000_address_cost       (rtx, machine_mode, addr_space_t,\n \t\t\t\t       bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n-static rtx  iq2000_legitimize_address (rtx, rtx, enum machine_mode);\n-static bool iq2000_pass_by_reference  (cumulative_args_t, enum machine_mode,\n+static rtx  iq2000_legitimize_address (rtx, rtx, machine_mode);\n+static bool iq2000_pass_by_reference  (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static int  iq2000_arg_partial_bytes  (cumulative_args_t, enum machine_mode,\n+static int  iq2000_arg_partial_bytes  (cumulative_args_t, machine_mode,\n \t\t\t\t       tree, bool);\n static rtx iq2000_function_arg\t      (cumulative_args_t,\n-\t\t\t\t       enum machine_mode, const_tree, bool);\n+\t\t\t\t       machine_mode, const_tree, bool);\n static void iq2000_function_arg_advance (cumulative_args_t,\n-\t\t\t\t\t enum machine_mode, const_tree, bool);\n-static unsigned int iq2000_function_arg_boundary (enum machine_mode,\n+\t\t\t\t\t machine_mode, const_tree, bool);\n+static unsigned int iq2000_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t  const_tree);\n static void iq2000_va_start\t      (tree, rtx);\n-static bool iq2000_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool iq2000_legitimate_address_p (machine_mode, rtx, bool);\n static bool iq2000_can_eliminate      (const int, const int);\n static void iq2000_asm_trampoline_template (FILE *);\n static void iq2000_trampoline_init    (rtx, tree, rtx);\n static rtx iq2000_function_value      (const_tree, const_tree, bool);\n-static rtx iq2000_libcall_value       (enum machine_mode, const_rtx);\n+static rtx iq2000_libcall_value       (machine_mode, const_rtx);\n static void iq2000_print_operand      (FILE *, rtx, int);\n static void iq2000_print_operand_address (FILE *, rtx);\n static bool iq2000_print_operand_punct_valid_p (unsigned char code);\n@@ -272,7 +272,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* Return nonzero if we split the address into high and low parts.  */\n \n int\n-iq2000_check_split (rtx address, enum machine_mode mode)\n+iq2000_check_split (rtx address, machine_mode mode)\n {\n   /* This is the same check used in simple_memory_operand.\n      We use it here because LO_SUM is not offsettable.  */\n@@ -292,7 +292,7 @@ iq2000_check_split (rtx address, enum machine_mode mode)\n \n int\n iq2000_reg_mode_ok_for_base_p (rtx reg,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       int strict)\n {\n   return (strict\n@@ -305,7 +305,7 @@ iq2000_reg_mode_ok_for_base_p (rtx reg,\n    function is called during reload.  */\n \n bool\n-iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, bool strict)\n+iq2000_legitimate_address_p (machine_mode mode, rtx xinsn, bool strict)\n {\n   if (TARGET_DEBUG_A_MODE)\n     {\n@@ -366,7 +366,7 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, bool strict)\n     }\n \n   if (TARGET_DEBUG_A_MODE)\n-    GO_PRINTF (\"Not a enum machine_mode mode, legitimate address\\n\");\n+    GO_PRINTF (\"Not a machine_mode mode, legitimate address\\n\");\n \n   /* The address was not legitimate.  */\n   return 0;\n@@ -386,7 +386,7 @@ iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n \t\t\trtx_insn *cur_insn)\n {\n   rtx set_reg;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx_insn *next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL;\n   int num_nops;\n \n@@ -573,7 +573,7 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n   rtx op1 = operands[1];\n   enum rtx_code code0 = GET_CODE (op0);\n   enum rtx_code code1 = GET_CODE (op1);\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   int subreg_offset0 = 0;\n   int subreg_offset1 = 0;\n   enum delay_type delay = DELAY_NONE;\n@@ -796,7 +796,7 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n /* Provide the costs of an addressing mode that contains ADDR.  */\n \n static int\n-iq2000_address_cost (rtx addr, enum machine_mode mode, addr_space_t as,\n+iq2000_address_cost (rtx addr, machine_mode mode, addr_space_t as,\n \t\t     bool speed)\n {\n   switch (GET_CODE (addr))\n@@ -924,7 +924,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n   };\n \n   enum internal_test test;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   struct cmp_info *p_info;\n   int branch_p;\n   int eqne_p;\n@@ -1058,7 +1058,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n    The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n-gen_conditional_branch (rtx operands[], enum machine_mode mode)\n+gen_conditional_branch (rtx operands[], machine_mode mode)\n {\n   enum rtx_code test_code = GET_CODE (operands[0]);\n   rtx cmp0 = operands[1];\n@@ -1147,7 +1147,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n    position in CUM.  */\n \n static void\n-iq2000_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t     const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1218,7 +1218,7 @@ iq2000_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n    and type TYPE in CUM, or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-iq2000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t     const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1375,15 +1375,15 @@ iq2000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n   if (mode == VOIDmode)\n     {\n       if (cum->num_adjusts > 0)\n-\tret = gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,\n+\tret = gen_rtx_PARALLEL ((machine_mode) cum->fp_code,\n \t\t       gen_rtvec_v (cum->num_adjusts, cum->adjust));\n     }\n \n   return ret;\n }\n \n static unsigned int\n-iq2000_function_arg_boundary (enum machine_mode mode, const_tree type)\n+iq2000_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   return (type != NULL_TREE\n \t  ? (TYPE_ALIGN (type) <= PARM_BOUNDARY\n@@ -1395,7 +1395,7 @@ iq2000_function_arg_boundary (enum machine_mode mode, const_tree type)\n }\n \n static int\n-iq2000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+iq2000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -1934,7 +1934,7 @@ iq2000_expand_prologue (void)\n   for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)\n     {\n       tree passed_type = DECL_ARG_TYPE (cur_arg);\n-      enum machine_mode passed_mode = TYPE_MODE (passed_type);\n+      machine_mode passed_mode = TYPE_MODE (passed_type);\n       rtx entry_parm;\n \n       if (TREE_ADDRESSABLE (passed_type))\n@@ -2167,7 +2167,7 @@ iq2000_can_use_return_insn (void)\n    mode MODE.  */\n \n static section *\n-iq2000_select_rtx_section (enum machine_mode mode, rtx x ATTRIBUTE_UNUSED,\n+iq2000_select_rtx_section (machine_mode mode, rtx x ATTRIBUTE_UNUSED,\n \t\t\t   unsigned HOST_WIDE_INT align)\n {\n   /* For embedded applications, always put constants in read-only data,\n@@ -2226,7 +2226,7 @@ iq2000_function_value (const_tree valtype,\n \t\t       bool outgoing ATTRIBUTE_UNUSED)\n {\n   int reg = GP_RETURN;\n-  enum machine_mode mode = TYPE_MODE (valtype);\n+  machine_mode mode = TYPE_MODE (valtype);\n   int unsignedp = TYPE_UNSIGNED (valtype);\n   const_tree func = fn_decl_or_type;\n \n@@ -2243,7 +2243,7 @@ iq2000_function_value (const_tree valtype,\n /* Worker function for TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-iq2000_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+iq2000_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (((GET_MODE_CLASS (mode) != MODE_INT\n \t                || GET_MODE_SIZE (mode) >= 4)\n@@ -2265,7 +2265,7 @@ iq2000_function_value_regno_p (const unsigned int regno)\n /* Return true when an argument must be passed by reference.  */\n \n static bool\n-iq2000_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n+iq2000_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2602,7 +2602,7 @@ expand_one_builtin (enum insn_code icode, rtx target, tree exp,\n   rtx pat;\n   tree arg [5];\n   rtx op [5];\n-  enum machine_mode mode [5];\n+  machine_mode mode [5];\n   int i;\n \n   mode[0] = insn_data[icode].operand[0].mode;\n@@ -2674,7 +2674,7 @@ expand_one_builtin (enum insn_code icode, rtx target, tree exp,\n \n static rtx\n iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -2866,7 +2866,7 @@ iq2000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \n static void\n iq2000_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       tree type ATTRIBUTE_UNUSED, int * pretend_size,\n \t\t\t       int no_rtl)\n {\n@@ -3250,7 +3250,7 @@ iq2000_print_operand_punct_valid_p (unsigned char code)\n \n rtx\n iq2000_legitimize_address (rtx xinsn, rtx old_x ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode)\n+\t\t\t   machine_mode mode)\n {\n   if (TARGET_DEBUG_B_MODE)\n     {\n@@ -3310,7 +3310,7 @@ iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t\t  int opno ATTRIBUTE_UNUSED, int * total,\n \t\t  bool speed ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   switch (code)\n     {"}, {"sha": "7224bb4736ecb4001e8521433a7e5983ca51d427", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -691,7 +691,7 @@\n {\n   if (iq2000_check_split (operands[1], SImode))\n     {\n-      enum machine_mode mode = GET_MODE (operands[0]);\n+      machine_mode mode = GET_MODE (operands[0]);\n       rtx tem = ((reload_in_progress | reload_completed)\n \t\t ? operands[0] : gen_reg_rtx (mode));\n "}, {"sha": "c56b1fa73e8365da92d11c01f1675b103e7cc6f6", "filename": "gcc/config/lm32/lm32-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Flm32%2Flm32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Flm32%2Flm32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -32,7 +32,7 @@ extern int lm32_can_use_return (void);\n extern rtx lm32_return_addr_rtx (int count, rtx frame);\n extern int lm32_expand_block_move (rtx *);\n extern int nonpic_symbol_mentioned_p (rtx);\n-extern rtx lm32_legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx lm32_legitimize_pic_address (rtx, machine_mode, rtx);\n extern void lm32_expand_scc (rtx operands[]);\n extern void lm32_expand_conditional_branch (rtx operands[]);\n-extern bool lm32_move_ok (enum machine_mode, rtx operands[2]);\n+extern bool lm32_move_ok (machine_mode, rtx operands[2]);"}, {"sha": "449833ca6364413f1d22307de59e297ce1e9d659", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -81,20 +81,20 @@ static void expand_save_restore (struct lm32_frame_info *info, int op);\n static void stack_adjust (HOST_WIDE_INT amount);\n static bool lm32_in_small_data_p (const_tree);\n static void lm32_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t\t\t enum machine_mode mode, tree type,\n+\t\t\t\t\t machine_mode mode, tree type,\n \t\t\t\t\t int *pretend_size, int no_rtl);\n static bool lm32_rtx_costs (rtx x, int code, int outer_code, int opno,\n \t\t\t    int *total, bool speed);\n static bool lm32_can_eliminate (const int, const int);\n static bool\n-lm32_legitimate_address_p (enum machine_mode mode, rtx x, bool strict);\n+lm32_legitimate_address_p (machine_mode mode, rtx x, bool strict);\n static HOST_WIDE_INT lm32_compute_frame_size (int size);\n static void lm32_option_override (void);\n static rtx lm32_function_arg (cumulative_args_t cum,\n-\t\t\t      enum machine_mode mode, const_tree type,\n+\t\t\t      machine_mode mode, const_tree type,\n \t\t\t      bool named);\n static void lm32_function_arg_advance (cumulative_args_t cum,\n-\t\t\t\t       enum machine_mode mode,\n+\t\t\t\t       machine_mode mode,\n \t\t\t\t       const_tree type, bool named);\n \n #undef TARGET_OPTION_OVERRIDE\n@@ -178,7 +178,7 @@ gen_int_relational (enum rtx_code code,\n \t\t    rtx cmp1,\t\n \t\t    rtx destination)\t\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int branch_p;\n \n   mode = GET_MODE (cmp0);\n@@ -632,7 +632,7 @@ lm32_print_operand_address (FILE * file, rtx addr)\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-lm32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+lm32_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -651,7 +651,7 @@ lm32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n }\n \n static void\n-lm32_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n+lm32_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   *get_cumulative_args (cum) += LM32_NUM_REGS2 (mode, type);\n@@ -687,7 +687,7 @@ lm32_compute_initial_elimination_offset (int from, int to)\n }\n \n static void\n-lm32_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n+lm32_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t     tree type, int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -831,7 +831,7 @@ lm32_block_move_inline (rtx dest, rtx src, HOST_WIDE_INT length,\n   HOST_WIDE_INT offset, delta;\n   unsigned HOST_WIDE_INT bits;\n   int i;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx *regs;\n \n   /* Work out how many bits to move at a time.  */\n@@ -940,7 +940,7 @@ static bool\n lm32_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   bool small_mode;\n \n   const int arithmetic_latency = 1;\n@@ -1207,7 +1207,7 @@ lm32_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n /* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n \n static bool\n-lm32_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x, bool strict)\n+lm32_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x, bool strict)\n {  \n    /* (rM) */                                                    \n   if (strict && REG_P (x) && STRICT_REG_OK_FOR_BASE_P (x))\n@@ -1234,7 +1234,7 @@ lm32_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x, bool\n /* Check a move is not memory to memory.  */ \n \n bool \n-lm32_move_ok (enum machine_mode mode, rtx operands[2]) {\n+lm32_move_ok (machine_mode mode, rtx operands[2]) {\n   if (memory_operand (operands[0], mode))\n     return register_or_zero_operand (operands[1], mode);\n   return true;"}, {"sha": "2b8060e743f8a214af93d360a6fd34c74788b7f4", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -38,7 +38,7 @@ int  m32c_trampoline_size (void);\n \n #ifdef RTX_CODE\n \n-int  m32c_cannot_change_mode_class (enum machine_mode, enum machine_mode, int);\n+int  m32c_cannot_change_mode_class (machine_mode, machine_mode, int);\n rtx  m32c_eh_return_stackadj_rtx (void);\n void m32c_emit_eh_epilogue (rtx);\n int  m32c_expand_cmpstr (rtx *);\n@@ -49,24 +49,24 @@ int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n bool m32c_matches_constraint_p (rtx, int);\n-int  m32c_hard_regno_nregs (int, enum machine_mode);\n-int  m32c_hard_regno_ok (int, enum machine_mode);\n+int  m32c_hard_regno_nregs (int, machine_mode);\n+int  m32c_hard_regno_ok (int, machine_mode);\n bool m32c_illegal_subreg_p (rtx);\n-bool m32c_immd_dbl_mov (rtx *, enum machine_mode);\n+bool m32c_immd_dbl_mov (rtx *, machine_mode);\n rtx  m32c_incoming_return_addr_rtx (void);\n-int  m32c_legitimize_reload_address (rtx *, enum machine_mode, int, int, int);\n-int  m32c_limit_reload_class (enum machine_mode, int);\n-int  m32c_modes_tieable_p (enum machine_mode, enum machine_mode);\n-bool m32c_mov_ok (rtx *, enum machine_mode);\n+int  m32c_legitimize_reload_address (rtx *, machine_mode, int, int, int);\n+int  m32c_limit_reload_class (machine_mode, int);\n+int  m32c_modes_tieable_p (machine_mode, machine_mode);\n+bool m32c_mov_ok (rtx *, machine_mode);\n char * m32c_output_compare (rtx_insn *, rtx *);\n-int  m32c_prepare_move (rtx *, enum machine_mode);\n+int  m32c_prepare_move (rtx *, machine_mode);\n int  m32c_prepare_shift (rtx *, int, int);\n int  m32c_reg_ok_for_base_p (rtx, int);\n enum reg_class m32c_regno_reg_class (int);\n rtx  m32c_return_addr_rtx (int);\n const char *m32c_scc_pattern (rtx *, RTX_CODE);\n-int  m32c_secondary_reload_class (int, enum machine_mode, rtx);\n-int  m32c_split_move (rtx *, enum machine_mode, int);\n+int  m32c_secondary_reload_class (int, machine_mode, rtx);\n+int  m32c_split_move (rtx *, machine_mode, int);\n int  m32c_split_psi_p (rtx *);\n int current_function_special_page_vector (rtx);\n "}, {"sha": "132873f6550176d2f2b77f729395f38e89daa3b7", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -96,22 +96,22 @@ static int m32c_comp_type_attributes (const_tree, const_tree);\n static bool m32c_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static struct machine_function *m32c_init_machine_status (void);\n static void m32c_insert_attributes (tree, tree *);\n-static bool m32c_legitimate_address_p (enum machine_mode, rtx, bool);\n-static bool m32c_addr_space_legitimate_address_p (enum machine_mode, rtx, bool, addr_space_t);\n-static rtx m32c_function_arg (cumulative_args_t, enum machine_mode,\n+static bool m32c_legitimate_address_p (machine_mode, rtx, bool);\n+static bool m32c_addr_space_legitimate_address_p (machine_mode, rtx, bool, addr_space_t);\n+static rtx m32c_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static bool m32c_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static bool m32c_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n-static void m32c_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void m32c_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static unsigned int m32c_function_arg_boundary (enum machine_mode, const_tree);\n+static unsigned int m32c_function_arg_boundary (machine_mode, const_tree);\n static int m32c_pushm_popm (Push_Pop_Type);\n static bool m32c_strict_argument_naming (cumulative_args_t);\n static rtx m32c_struct_value_rtx (tree, int);\n-static rtx m32c_subreg (enum machine_mode, rtx, enum machine_mode, int);\n+static rtx m32c_subreg (machine_mode, rtx, machine_mode, int);\n static int need_to_save (int);\n static rtx m32c_function_value (const_tree, const_tree, bool);\n-static rtx m32c_libcall_value (enum machine_mode, const_rtx);\n+static rtx m32c_libcall_value (machine_mode, const_rtx);\n \n /* Returns true if an address is specified, else false.  */\n static bool m32c_get_pragma_address (const char *varname, unsigned *addr);\n@@ -291,7 +291,7 @@ encode_pattern (rtx x)\n    by print_operand().  */\n \n static const char *\n-reg_name_with_mode (int regno, enum machine_mode mode)\n+reg_name_with_mode (int regno, machine_mode mode)\n {\n   int mlen = GET_MODE_SIZE (mode);\n   if (regno == R0_REGNO && mlen == 1)\n@@ -379,7 +379,7 @@ reduce_class (reg_class_t original_class, reg_class_t limiting_class,\n /* Used by m32c_register_move_cost to determine if a move is\n    impossibly expensive.  */\n static bool\n-class_can_hold_mode (reg_class_t rclass, enum machine_mode mode)\n+class_can_hold_mode (reg_class_t rclass, machine_mode mode)\n {\n   /* Cache the results:  0=untested  1=no  2=yes */\n   static char results[LIM_REG_CLASSES][MAX_MACHINE_MODE];\n@@ -561,7 +561,7 @@ m32c_conditional_register_usage (void)\n    different registers are different sizes from each other, *and* may\n    be different sizes in different chip families.  */\n static int\n-m32c_hard_regno_nregs_1 (int regno, enum machine_mode mode)\n+m32c_hard_regno_nregs_1 (int regno, machine_mode mode)\n {\n   if (regno == FLG_REGNO && mode == CCmode)\n     return 1;\n@@ -587,7 +587,7 @@ m32c_hard_regno_nregs_1 (int regno, enum machine_mode mode)\n }\n \n int\n-m32c_hard_regno_nregs (int regno, enum machine_mode mode)\n+m32c_hard_regno_nregs (int regno, machine_mode mode)\n {\n   int rv = m32c_hard_regno_nregs_1 (regno, mode);\n   return rv ? rv : 1;\n@@ -596,7 +596,7 @@ m32c_hard_regno_nregs (int regno, enum machine_mode mode)\n /* Implements HARD_REGNO_MODE_OK.  The above function does the work\n    already; just test its return value.  */\n int\n-m32c_hard_regno_ok (int regno, enum machine_mode mode)\n+m32c_hard_regno_ok (int regno, machine_mode mode)\n {\n   return m32c_hard_regno_nregs_1 (regno, mode) != 0;\n }\n@@ -606,7 +606,7 @@ m32c_hard_regno_ok (int regno, enum machine_mode mode)\n    bigger than our registers anyway, it's easier to implement this\n    function that way, leaving QImode as the only unique case.  */\n int\n-m32c_modes_tieable_p (enum machine_mode m1, enum machine_mode m2)\n+m32c_modes_tieable_p (machine_mode m1, machine_mode m2)\n {\n   if (GET_MODE_SIZE (m1) == GET_MODE_SIZE (m2))\n     return 1;\n@@ -735,7 +735,7 @@ m32c_preferred_output_reload_class (rtx x, reg_class_t rclass)\n    address registers for reloads since they're needed for address\n    reloads.  */\n int\n-m32c_limit_reload_class (enum machine_mode mode, int rclass)\n+m32c_limit_reload_class (machine_mode mode, int rclass)\n {\n #if DEBUG_RELOAD\n   fprintf (stderr, \"limit_reload_class for %s: %s ->\",\n@@ -763,7 +763,7 @@ m32c_limit_reload_class (enum machine_mode mode, int rclass)\n    reloaded through appropriately sized general or address\n    registers.  */\n int\n-m32c_secondary_reload_class (int rclass, enum machine_mode mode, rtx x)\n+m32c_secondary_reload_class (int rclass, machine_mode mode, rtx x)\n {\n   int cc = class_contents[rclass][0];\n #if DEBUG0\n@@ -804,7 +804,7 @@ m32c_class_likely_spilled_p (reg_class_t regclass)\n #define TARGET_CLASS_MAX_NREGS m32c_class_max_nregs\n \n static unsigned char\n-m32c_class_max_nregs (reg_class_t regclass, enum machine_mode mode)\n+m32c_class_max_nregs (reg_class_t regclass, machine_mode mode)\n {\n   int rn;\n   unsigned char max = 0;\n@@ -824,8 +824,8 @@ m32c_class_max_nregs (reg_class_t regclass, enum machine_mode mode)\n    registers (well, it does on a0/a1 but if we let gcc do that, reload\n    suffers).  Otherwise, we allow changes to larger modes.  */\n int\n-m32c_cannot_change_mode_class (enum machine_mode from,\n-\t\t\t       enum machine_mode to, int rclass)\n+m32c_cannot_change_mode_class (machine_mode from,\n+\t\t\t       machine_mode to, int rclass)\n {\n   int rn;\n #if DEBUG0\n@@ -962,7 +962,7 @@ m32c_matches_constraint_p (rtx value, int constraint)\n rtx\n m32c_return_addr_rtx (int count)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int offset;\n   rtx ra_mem;\n \n@@ -1189,7 +1189,7 @@ m32c_pushm_popm (Push_Pop_Type ppt)\n \n       if (ppt == PP_pushm)\n \t{\n-\t  enum machine_mode mode = (bytes == 2) ? HImode : SImode;\n+\t  machine_mode mode = (bytes == 2) ? HImode : SImode;\n \t  rtx addr;\n \n \t  /* Always use stack_pointer_rtx instead of calling\n@@ -1344,7 +1344,7 @@ m32c_push_rounding (int n)\n #define TARGET_FUNCTION_ARG m32c_function_arg\n static rtx\n m32c_function_arg (cumulative_args_t ca_v,\n-\t\t   enum machine_mode mode, const_tree type, bool named)\n+\t\t   machine_mode mode, const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n@@ -1397,7 +1397,7 @@ m32c_function_arg (cumulative_args_t ca_v,\n #define TARGET_PASS_BY_REFERENCE m32c_pass_by_reference\n static bool\n m32c_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type ATTRIBUTE_UNUSED,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n@@ -1427,7 +1427,7 @@ m32c_init_cumulative_args (CUMULATIVE_ARGS * ca,\n #define TARGET_FUNCTION_ARG_ADVANCE m32c_function_arg_advance\n static void\n m32c_function_arg_advance (cumulative_args_t ca_v,\n-\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n@@ -1443,7 +1443,7 @@ m32c_function_arg_advance (cumulative_args_t ca_v,\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY m32c_function_arg_boundary\n static unsigned int\n-m32c_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+m32c_function_arg_boundary (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    const_tree type ATTRIBUTE_UNUSED)\n {\n   return (TARGET_A16 ? 8 : 16);\n@@ -1464,7 +1464,7 @@ m32c_function_arg_regno_p (int r)\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE m32c_valid_pointer_mode\n static bool\n-m32c_valid_pointer_mode (enum machine_mode mode)\n+m32c_valid_pointer_mode (machine_mode mode)\n {\n   if (mode == HImode\n       || mode == PSImode\n@@ -1488,7 +1488,7 @@ m32c_valid_pointer_mode (enum machine_mode mode)\n #define TARGET_LIBCALL_VALUE m32c_libcall_value\n \n static rtx\n-m32c_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+m32c_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   /* return reg or parallel */\n #if 0\n@@ -1550,7 +1550,7 @@ m32c_function_value (const_tree valtype,\n \t\t     bool outgoing ATTRIBUTE_UNUSED)\n {\n   /* return reg or parallel */\n-  const enum machine_mode mode = TYPE_MODE (valtype);\n+  const machine_mode mode = TYPE_MODE (valtype);\n   return m32c_libcall_value (mode, NULL_RTX);\n }\n \n@@ -1672,7 +1672,7 @@ m32c_trampoline_init (rtx m_tramp, tree fndecl, rtx chainval)\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P m32c_legitimate_address_p\n bool\n-m32c_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+m32c_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   int mode_adjust;\n   if (CONSTANT_P (x))\n@@ -1852,7 +1852,7 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n #define TARGET_LEGITIMIZE_ADDRESS m32c_legitimize_address\n static rtx\n m32c_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n #if DEBUG0\n   fprintf (stderr, \"m32c_legitimize_address for mode %s\\n\", mode_name[mode]);\n@@ -1880,7 +1880,7 @@ m32c_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n /* Implements LEGITIMIZE_RELOAD_ADDRESS.  See comment above.  */\n int\n m32c_legitimize_reload_address (rtx * x,\n-\t\t\t\tenum machine_mode mode,\n+\t\t\t\tmachine_mode mode,\n \t\t\t\tint opnum,\n \t\t\t\tint type, int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -1943,7 +1943,7 @@ m32c_legitimize_reload_address (rtx * x,\n /* Return the appropriate mode for a named address pointer.  */\n #undef TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE m32c_addr_space_pointer_mode\n-static enum machine_mode\n+static machine_mode\n m32c_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1960,7 +1960,7 @@ m32c_addr_space_pointer_mode (addr_space_t addrspace)\n /* Return the appropriate mode for a named address address.  */\n #undef TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE m32c_addr_space_address_mode\n-static enum machine_mode\n+static machine_mode\n m32c_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1979,7 +1979,7 @@ m32c_addr_space_address_mode (addr_space_t addrspace)\n #define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n   m32c_addr_space_legitimate_address_p\n static bool\n-m32c_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n+m32c_addr_space_legitimate_address_p (machine_mode mode, rtx x,\n \t\t\t\t      bool strict, addr_space_t as)\n {\n   if (as == ADDR_SPACE_FAR)\n@@ -2068,7 +2068,7 @@ m32c_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n #undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n #define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS m32c_addr_space_legitimize_address\n static rtx\n-m32c_addr_space_legitimize_address (rtx x, rtx oldx, enum machine_mode mode,\n+m32c_addr_space_legitimize_address (rtx x, rtx oldx, machine_mode mode,\n \t\t\t\t    addr_space_t as)\n {\n   if (as != ADDR_SPACE_GENERIC)\n@@ -2161,7 +2161,7 @@ m32c_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n #define TARGET_REGISTER_MOVE_COST m32c_register_move_cost\n \n static int\n-m32c_register_move_cost (enum machine_mode mode, reg_class_t from,\n+m32c_register_move_cost (machine_mode mode, reg_class_t from,\n \t\t\t reg_class_t to)\n {\n   int cost = COSTS_N_INSNS (3);\n@@ -2209,7 +2209,7 @@ m32c_register_move_cost (enum machine_mode mode, reg_class_t from,\n #define TARGET_MEMORY_MOVE_COST m32c_memory_move_cost\n \n static int\n-m32c_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+m32c_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       reg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t       bool in ATTRIBUTE_UNUSED)\n {\n@@ -2302,7 +2302,7 @@ m32c_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST m32c_address_cost\n static int\n-m32c_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n+m32c_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -3146,7 +3146,7 @@ m32c_illegal_subreg_p (rtx op)\n {\n   int offset;\n   unsigned int i;\n-  enum machine_mode src_mode, dest_mode;\n+  machine_mode src_mode, dest_mode;\n \n   if (GET_CODE (op) == MEM\n       && ! m32c_legitimate_address_p (Pmode, XEXP (op, 0), false))\n@@ -3200,7 +3200,7 @@ m32c_illegal_subreg_p (rtx op)\n    number of address registers, and we can get into a situation where\n    we need three of them when we only have two.  */\n bool\n-m32c_mov_ok (rtx * operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n+m32c_mov_ok (rtx * operands, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -3241,7 +3241,7 @@ m32c_mov_ok (rtx * operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n    location, can be combined into single SImode mov instruction.  */\n bool\n m32c_immd_dbl_mov (rtx * operands ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED)\n {\n   /* ??? This relied on the now-defunct MEM_SCALAR and MEM_IN_STRUCT_P\n      flags.  */\n@@ -3253,8 +3253,8 @@ m32c_immd_dbl_mov (rtx * operands ATTRIBUTE_UNUSED,\n /* Subregs are non-orthogonal for us, because our registers are all\n    different sizes.  */\n static rtx\n-m32c_subreg (enum machine_mode outer,\n-\t     rtx x, enum machine_mode inner, int byte)\n+m32c_subreg (machine_mode outer,\n+\t     rtx x, machine_mode inner, int byte)\n {\n   int r, nr = -1;\n \n@@ -3341,7 +3341,7 @@ m32c_subreg (enum machine_mode outer,\n /* Used to emit move instructions.  We split some moves,\n    and avoid mem-mem moves.  */\n int\n-m32c_prepare_move (rtx * operands, enum machine_mode mode)\n+m32c_prepare_move (rtx * operands, machine_mode mode)\n {\n   if (far_addr_space_p (operands[0])\n       && CONSTANT_P (operands[1]))\n@@ -3403,12 +3403,12 @@ m32c_split_psi_p (rtx * operands)\n    (define_expand), 1 if it is not optional (define_insn_and_split),\n    and 3 for define_split (alternate api). */\n int\n-m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n+m32c_split_move (rtx * operands, machine_mode mode, int split_all)\n {\n   rtx s[4], d[4];\n   int parts, si, di, rev = 0;\n   int rv = 0, opi = 2;\n-  enum machine_mode submode = HImode;\n+  machine_mode submode = HImode;\n   rtx *ops, local_ops[10];\n \n   /* define_split modifies the existing operands, but the other two\n@@ -3744,7 +3744,7 @@ shift_gen_func_for (int mode, int code)\n int\n m32c_prepare_shift (rtx * operands, int scale, int shift_code)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   shift_gen_func func = shift_gen_func_for (mode, shift_code);\n   rtx temp;\n \n@@ -4183,7 +4183,7 @@ m32c_emit_epilogue (void)\n \n   if (cfun->machine->is_interrupt)\n     {\n-      enum machine_mode spmode = TARGET_A16 ? HImode : PSImode;\n+      machine_mode spmode = TARGET_A16 ? HImode : PSImode;\n \n       /* REIT clears B flag and restores $fp for us, but we still\n \t have to fix up the stack.  USE_RTS just means we didn't"}, {"sha": "baccf69080a514787eee9168ef5a7b17a9883fc8", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -49,13 +49,13 @@ extern rtx    m32r_return_addr (int);\n extern rtx    m32r_function_symbol (const char *);\n \n #ifdef HAVE_MACHINE_MODES\n-extern int    call_operand (rtx, enum machine_mode);\n-extern int    small_data_operand (rtx, enum machine_mode);\n-extern int    addr24_operand (rtx, enum machine_mode);\n-extern int    addr32_operand (rtx, enum machine_mode);\n-extern int    call26_operand (rtx, enum machine_mode);\n-extern int    memreg_operand (rtx, enum machine_mode);\n-extern int    small_insn_p (rtx, enum machine_mode);\n+extern int    call_operand (rtx, machine_mode);\n+extern int    small_data_operand (rtx, machine_mode);\n+extern int    addr24_operand (rtx, machine_mode);\n+extern int    addr32_operand (rtx, machine_mode);\n+extern int    call26_operand (rtx, machine_mode);\n+extern int    memreg_operand (rtx, machine_mode);\n+extern int    small_insn_p (rtx, machine_mode);\n \n #endif /* HAVE_MACHINE_MODES */\n "}, {"sha": "26b93bf2b6a2526bdd1938c74cd8d825c9d7864d", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -78,8 +78,8 @@ static void  m32r_option_override (void);\n static void  init_reg_tables (void);\n static void  block_move_call (rtx, rtx, rtx);\n static int   m32r_is_insn (rtx);\n-static bool  m32r_legitimate_address_p (enum machine_mode, rtx, bool);\n-static rtx   m32r_legitimize_address (rtx, rtx, enum machine_mode);\n+static bool  m32r_legitimate_address_p (machine_mode, rtx, bool);\n+static rtx   m32r_legitimize_address (rtx, rtx, machine_mode);\n static bool  m32r_mode_dependent_address_p (const_rtx, addr_space_t);\n static tree  m32r_handle_model_attribute (tree *, tree, tree, int, bool *);\n static void  m32r_print_operand (FILE *, rtx, int);\n@@ -97,25 +97,25 @@ static void m32r_encode_section_info (tree, rtx, int);\n static bool m32r_in_small_data_p (const_tree);\n static bool m32r_return_in_memory (const_tree, const_tree);\n static rtx m32r_function_value (const_tree, const_tree, bool);\n-static rtx m32r_libcall_value (enum machine_mode, const_rtx);\n+static rtx m32r_libcall_value (machine_mode, const_rtx);\n static bool m32r_function_value_regno_p (const unsigned int);\n-static void m32r_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static void m32r_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n static void init_idents (void);\n static bool m32r_rtx_costs (rtx, int, int, int, int *, bool speed);\n-static int m32r_memory_move_cost (enum machine_mode, reg_class_t, bool);\n-static bool m32r_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static int m32r_memory_move_cost (machine_mode, reg_class_t, bool);\n+static bool m32r_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int m32r_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static int m32r_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t   tree, bool);\n-static rtx m32r_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx m32r_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static void m32r_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void m32r_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static bool m32r_can_eliminate (const int, const int);\n static void m32r_conditional_register_usage (void);\n static void m32r_trampoline_init (rtx, tree, rtx);\n-static bool m32r_legitimate_constant_p (enum machine_mode, rtx);\n+static bool m32r_legitimate_constant_p (machine_mode, rtx);\n \f\n /* M32R specific attributes.  */\n \n@@ -297,7 +297,7 @@ init_reg_tables (void)\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n-      enum machine_mode m = (enum machine_mode) i;\n+      machine_mode m = (machine_mode) i;\n       \n       switch (GET_MODE_CLASS (m))\n \t{\n@@ -515,7 +515,7 @@ m32r_init_expanders (void)\n }\n \f\n int\n-call_operand (rtx op, enum machine_mode mode)\n+call_operand (rtx op, machine_mode mode)\n {\n   if (!MEM_P (op))\n     return 0;\n@@ -526,7 +526,7 @@ call_operand (rtx op, enum machine_mode mode)\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n-small_data_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+small_data_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! TARGET_SDATA_USE)\n     return 0;\n@@ -546,7 +546,7 @@ small_data_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n /* Return 1 if OP is a symbol that can use 24-bit addressing.  */\n \n int\n-addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+addr24_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx sym;\n \n@@ -580,7 +580,7 @@ addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n /* Return 1 if OP is a symbol that needs 32-bit addressing.  */\n \n int\n-addr32_operand (rtx op, enum machine_mode mode)\n+addr32_operand (rtx op, machine_mode mode)\n {\n   rtx sym;\n \n@@ -605,7 +605,7 @@ addr32_operand (rtx op, enum machine_mode mode)\n /* Return 1 if OP is a function that can be called with the `bl' insn.  */\n \n int\n-call26_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+call26_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic)\n     return 1;\n@@ -659,7 +659,7 @@ easy_df_const (rtx op)\n    This is used in insn length calcs.  */\n \n int\n-memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+memreg_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return MEM_P (op) && REG_P (XEXP (op, 0));\n }\n@@ -668,7 +668,7 @@ memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n static bool\n m32r_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode, const_tree type,\n+\t\t\tmachine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   int size;\n@@ -893,7 +893,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n bool\n gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n \n   gcc_assert (mode == SImode);\n   switch (code)\n@@ -1040,7 +1040,7 @@ gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n rtx\n gen_split_move_double (rtx operands[])\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n   rtx val;\n@@ -1157,7 +1157,7 @@ gen_split_move_double (rtx operands[])\n \n \f\n static int\n-m32r_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+m32r_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1217,7 +1217,7 @@ m32r_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n    and the rest are pushed.  */\n \n static rtx\n-m32r_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+m32r_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n {\n@@ -1233,7 +1233,7 @@ m32r_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-m32r_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+m32r_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1265,7 +1265,7 @@ m32r_function_value (const_tree valtype,\n /* Worker function for TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-m32r_libcall_value (enum machine_mode mode,\n+m32r_libcall_value (machine_mode mode,\n \t\tconst_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, 0);\n@@ -1289,7 +1289,7 @@ m32r_function_value_regno_p (const unsigned int regno)\n    and mode MODE, and we rely on this fact.  */\n \n static void\n-m32r_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+m32r_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t     tree type, int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n@@ -1363,7 +1363,7 @@ m32r_issue_rate (void)\n    ??? Is that the right way to look at it?  */\n \n static int\n-m32r_memory_move_cost (enum machine_mode mode,\n+m32r_memory_move_cost (machine_mode mode,\n \t\t       reg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t       bool in ATTRIBUTE_UNUSED)\n {\n@@ -2018,7 +2018,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n \n static rtx\n m32r_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic)\n     return m32r_legitimize_pic_address (x, NULL_RTX);\n@@ -2838,7 +2838,7 @@ m32r_rtx_ok_for_offset_p (const_rtx x)\n }\n \n static inline bool\n-m32r_legitimate_offset_addres_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+m32r_legitimate_offset_addres_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t const_rtx x, bool strict)\n {\n   if (GET_CODE (x) == PLUS\n@@ -2853,7 +2853,7 @@ m32r_legitimate_offset_addres_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n    since more than one instruction will be required.  */\n \n static inline bool\n-m32r_legitimate_lo_sum_addres_p (enum machine_mode mode, const_rtx x,\n+m32r_legitimate_lo_sum_addres_p (machine_mode mode, const_rtx x,\n \t\t\t\t bool strict)\n {\n   if (GET_CODE (x) == LO_SUM\n@@ -2868,7 +2868,7 @@ m32r_legitimate_lo_sum_addres_p (enum machine_mode mode, const_rtx x,\n /* Is this a load and increment operation.  */\n \n static inline bool\n-m32r_load_postinc_p (enum machine_mode mode, const_rtx x, bool strict)\n+m32r_load_postinc_p (machine_mode mode, const_rtx x, bool strict)\n {\n   if ((mode == SImode || mode == SFmode)\n       && GET_CODE (x) == POST_INC\n@@ -2882,7 +2882,7 @@ m32r_load_postinc_p (enum machine_mode mode, const_rtx x, bool strict)\n /* Is this an increment/decrement and store operation.  */\n \n static inline bool\n-m32r_store_preinc_predec_p (enum machine_mode mode, const_rtx x, bool strict)\n+m32r_store_preinc_predec_p (machine_mode mode, const_rtx x, bool strict)\n {\n   if ((mode == SImode || mode == SFmode)\n       && (GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n@@ -2896,7 +2896,7 @@ m32r_store_preinc_predec_p (enum machine_mode mode, const_rtx x, bool strict)\n /* Implement  TARGET_LEGITIMATE_ADDRESS_P.  */\n \n static bool\n-m32r_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+m32r_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   if (m32r_rtx_ok_for_base_p (x, strict)\n       || m32r_legitimate_offset_addres_p (mode, x, strict)\n@@ -2926,7 +2926,7 @@ m32r_conditional_register_usage (void)\n    constant to memory if they can't handle them.  */\n \n static bool\n-m32r_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+m32r_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return !(GET_CODE (x) == CONST\n \t   && GET_CODE (XEXP (x, 0)) == PLUS"}, {"sha": "571c1cc3726db3b6cf06b38f4d57ba2e30a9e678", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -44,7 +44,7 @@ extern const char *output_call (rtx);\n extern const char *output_sibcall (rtx);\n extern void output_dbcc_and_branch (rtx *);\n extern int floating_exact_log2 (rtx);\n-extern bool strict_low_part_peephole_ok (enum machine_mode mode,\n+extern bool strict_low_part_peephole_ok (machine_mode mode,\n \t\t\t\t\t rtx_insn *first_insn, rtx target);\n \n /* Functions from m68k.c used in macros.  */\n@@ -55,16 +55,16 @@ extern void notice_update_cc (rtx, rtx);\n extern bool m68k_legitimate_base_reg_p (rtx, bool);\n extern bool m68k_legitimate_index_reg_p (rtx, bool);\n extern bool m68k_illegitimate_symbolic_constant_p (rtx);\n-extern bool m68k_legitimate_constant_p (enum machine_mode, rtx);\n+extern bool m68k_legitimate_constant_p (machine_mode, rtx);\n extern bool m68k_matches_q_p (rtx);\n extern bool m68k_matches_u_p (rtx);\n-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx legitimize_pic_address (rtx, machine_mode, rtx);\n extern rtx m68k_legitimize_tls_address (rtx);\n extern bool m68k_tls_reference_p (rtx, bool);\n-extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n-extern rtx m68k_libcall_value (enum machine_mode);\n+extern int valid_dbcc_comparison_p_2 (rtx, machine_mode);\n+extern rtx m68k_libcall_value (machine_mode);\n extern rtx m68k_function_value (const_tree, const_tree);\n-extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n+extern int emit_move_sequence (rtx *, machine_mode, rtx);\n extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);\n extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);\n extern void m68k_final_prescan_insn (rtx_insn *, rtx *, int);\n@@ -86,9 +86,9 @@ extern enum attr_op_mem m68k_sched_attr_op_mem (rtx_insn *);\n \n #endif /* RTX_CODE */\n \n-extern bool m68k_regno_mode_ok (int, enum machine_mode);\n+extern bool m68k_regno_mode_ok (int, machine_mode);\n extern enum reg_class m68k_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t   enum machine_mode, rtx);\n+\t\t\t\t\t\t   machine_mode, rtx);\n extern enum reg_class m68k_preferred_reload_class (rtx, enum reg_class);\n extern int flags_in_68881 (void);\n extern void m68k_expand_prologue (void);"}, {"sha": "d8abc0e74c78d0f7d95353276a12fae16c491a6c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -152,7 +152,7 @@ static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);\n \n static bool m68k_can_eliminate (const int, const int);\n static void m68k_conditional_register_usage (void);\n-static bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool m68k_legitimate_address_p (machine_mode, rtx, bool);\n static void m68k_option_override (void);\n static void m68k_override_options_after_change (void);\n static rtx find_addr_reg (rtx);\n@@ -167,7 +167,7 @@ static void m68k_compute_frame_layout (void);\n static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static bool m68k_ok_for_sibcall_p (tree, tree);\n static bool m68k_tls_symbol_p (rtx);\n-static rtx m68k_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx m68k_legitimize_address (rtx, rtx, machine_mode);\n static bool m68k_rtx_costs (rtx, int, int, int, int *, bool);\n #if M68K_HONOR_TARGET_STRICT_ALIGNMENT\n static bool m68k_return_in_memory (const_tree, const_tree);\n@@ -176,11 +176,11 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void m68k_trampoline_init (rtx, tree, rtx);\n static int m68k_return_pops_args (tree, tree, int);\n static rtx m68k_delegitimize_address (rtx);\n-static void m68k_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void m68k_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx m68k_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx m68k_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static bool m68k_cannot_force_const_mem (enum machine_mode mode, rtx x);\n+static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);\n static bool m68k_output_addr_const_extra (FILE *, rtx);\n static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n \f\n@@ -933,7 +933,7 @@ m68k_emit_movem (rtx base, HOST_WIDE_INT offset,\n {\n   int i;\n   rtx body, addr, src, operands[2];\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (adjust_stack_p + count));\n   mode = reg_raw_mode[regno];\n@@ -1326,7 +1326,7 @@ m68k_expand_epilogue (bool sibcall_p)\n    It also rejects some comparisons when CC_NO_OVERFLOW is set.  */\n    \n int\n-valid_dbcc_comparison_p_2 (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+valid_dbcc_comparison_p_2 (rtx x, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1425,15 +1425,15 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)\n \n static rtx\n m68k_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n }\n \n static void\n-m68k_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+m68k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1477,7 +1477,7 @@ m68k_legitimize_sibcall_address (rtx x)\n    nothing needs to be done because REG can certainly go in an address reg.  */\n \n static rtx\n-m68k_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+m68k_legitimize_address (rtx x, rtx oldx, machine_mode mode)\n {\n   if (m68k_tls_symbol_p (x))\n     return m68k_legitimize_tls_address (x);\n@@ -1906,7 +1906,7 @@ m68k_illegitimate_symbolic_constant_p (rtx x)\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-m68k_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+m68k_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return m68k_illegitimate_symbolic_constant_p (x);\n }\n@@ -1961,7 +1961,7 @@ m68k_jump_table_ref_p (rtx x)\n    is valid, describe its components in *ADDRESS.  */\n \n static bool\n-m68k_decompose_address (enum machine_mode mode, rtx x,\n+m68k_decompose_address (machine_mode mode, rtx x,\n \t\t\tbool strict_p, struct m68k_address *address)\n {\n   unsigned int reach;\n@@ -2109,7 +2109,7 @@ m68k_decompose_address (enum machine_mode mode, rtx x,\n    STRICT_P says whether strict checking is needed.  */\n \n bool\n-m68k_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+m68k_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n {\n   struct m68k_address address;\n \n@@ -2131,7 +2131,7 @@ m68k_legitimate_mem_p (rtx x, struct m68k_address *address)\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n bool\n-m68k_legitimate_constant_p (enum machine_mode mode, rtx x)\n+m68k_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   return mode != XFmode && !m68k_illegitimate_symbolic_constant_p (x);\n }\n@@ -2435,7 +2435,7 @@ m68k_wrap_symbol_into_got_ref (rtx x, enum m68k_reloc reloc, rtx temp_reg)\n    handled.  */\n \n rtx\n-legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t        rtx reg)\n {\n   rtx pic_ref = orig;\n@@ -3568,7 +3568,7 @@ output_movsi (rtx operands[2])\n \n /* Copy OP and change its mode to MODE.  */\n static rtx\n-copy_operand (rtx op, enum machine_mode mode)\n+copy_operand (rtx op, machine_mode mode)\n {\n   /* ??? This looks really ugly.  There must be a better way\n      to change a mode on the operand.  */\n@@ -3619,7 +3619,7 @@ m68k_emit_move_double (rtx operands[2])\n    new rtx with the correct mode.  */\n \n static rtx\n-force_mode (enum machine_mode mode, rtx orig)\n+force_mode (machine_mode mode, rtx orig)\n {\n   if (mode == GET_MODE (orig))\n     return orig;\n@@ -3631,7 +3631,7 @@ force_mode (enum machine_mode mode, rtx orig)\n }\n \n static int\n-fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+fp_reg_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return reg_renumber && FP_REG_P (op);\n }\n@@ -3647,7 +3647,7 @@ fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    of SCRATCH_REG in the proper mode.  */\n \n int\n-emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n+emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n@@ -4309,7 +4309,7 @@ init_68881_table (void)\n {\n   int i;\n   REAL_VALUE_TYPE r;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = SFmode;\n   for (i = 0; i < 7; i++)\n@@ -4804,7 +4804,7 @@ print_operand_address (FILE *file, rtx addr)\n    clear insn.  */\n \n bool\n-strict_low_part_peephole_ok (enum machine_mode mode, rtx_insn *first_insn,\n+strict_low_part_peephole_ok (machine_mode mode, rtx_insn *first_insn,\n                              rtx target)\n {\n   rtx_insn *p = first_insn;\n@@ -5167,7 +5167,7 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n    restrict the 68881 registers to floating-point modes.  */\n \n bool\n-m68k_regno_mode_ok (int regno, enum machine_mode mode)\n+m68k_regno_mode_ok (int regno, machine_mode mode)\n {\n   if (DATA_REGNO_P (regno))\n     {\n@@ -5196,7 +5196,7 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n \n enum reg_class\n m68k_secondary_reload_class (enum reg_class rclass,\n-\t\t\t     enum machine_mode mode, rtx x)\n+\t\t\t     machine_mode mode, rtx x)\n {\n   int regno;\n \n@@ -5259,7 +5259,7 @@ m68k_preferred_reload_class (rtx x, enum reg_class rclass)\n    If there is need for a hard-float ABI it is probably worth doing it\n    properly and also passing function arguments in FP registers.  */\n rtx\n-m68k_libcall_value (enum machine_mode mode)\n+m68k_libcall_value (machine_mode mode)\n {\n   switch (mode) {\n   case SFmode:\n@@ -5281,7 +5281,7 @@ m68k_libcall_value (enum machine_mode mode)\n rtx\n m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = TYPE_MODE (valtype);\n   switch (mode) {\n@@ -5324,7 +5324,7 @@ m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n static bool\n m68k_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = TYPE_MODE (type);\n+  machine_mode mode = TYPE_MODE (type);\n \n   if (mode == BLKmode)\n     return true;\n@@ -5386,7 +5386,7 @@ enum attr_op_type\n \n /* Return type of memory ADDR_RTX refers to.  */\n static enum attr_op_type\n-sched_address_type (enum machine_mode mode, rtx addr_rtx)\n+sched_address_type (machine_mode mode, rtx addr_rtx)\n {\n   struct m68k_address address;\n "}, {"sha": "973b868324be80cc09c3c8c713ee22b7a891ed26", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -34,7 +34,7 @@ extern int          mcore_naked_function_p       \t(void);\n \n #ifdef TREE_CODE\n #ifdef HAVE_MACHINE_MODES\n-extern int          mcore_num_arg_regs           \t(enum machine_mode, const_tree);\n+extern int          mcore_num_arg_regs           \t(machine_mode, const_tree);\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef RTX_CODE\n@@ -55,14 +55,14 @@ extern const char * mcore_output_andn          \t\t(rtx, rtx *);\n extern bool         mcore_gen_compare\t        \t(RTX_CODE, rtx, rtx);\n extern int          mcore_symbolic_address_p     \t(rtx);\n extern bool         mcore_r15_operand_p\t\t\t(rtx);\n-extern enum reg_class mcore_secondary_reload_class\t(enum reg_class, enum machine_mode, rtx);\n+extern enum reg_class mcore_secondary_reload_class\t(enum reg_class, machine_mode, rtx);\n extern enum reg_class mcore_reload_class \t\t(rtx, enum reg_class);\n extern int          mcore_is_same_reg            \t(rtx, rtx);\n extern int          mcore_arith_S_operand         \t(rtx);\n \n #ifdef HAVE_MACHINE_MODES\n-extern const char * mcore_output_move          \t\t(rtx, rtx *, enum machine_mode);\n-extern const char * mcore_output_movedouble    \t\t(rtx *, enum machine_mode);\n+extern const char * mcore_output_move          \t\t(rtx, rtx *, machine_mode);\n+extern const char * mcore_output_movedouble    \t\t(rtx *, machine_mode);\n extern int          const_ok_for_mcore                  (HOST_WIDE_INT);\n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */"}, {"sha": "c2db3345a58f0933d10723526491db855cf1e1be", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -112,15 +112,15 @@ cond_type;\n static void       output_stack_adjust           (int, int);\n static int        calc_live_regs                (int *);\n static int        try_constant_tricks           (HOST_WIDE_INT, HOST_WIDE_INT *, HOST_WIDE_INT *);\n-static const char *     output_inline_const     (enum machine_mode, rtx *);\n+static const char *     output_inline_const     (machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n-static void       mcore_setup_incoming_varargs\t(cumulative_args_t, enum machine_mode, tree, int *, int);\n+static void       mcore_setup_incoming_varargs\t(cumulative_args_t, machine_mode, tree, int *, int);\n static cond_type  is_cond_candidate             (rtx);\n static rtx_insn  *emit_new_cond_insn            (rtx, int);\n static rtx_insn  *conditionalize_block          (rtx_insn *);\n static void       conditionalize_optimization   (void);\n static void       mcore_reorg                   (void);\n-static rtx        handle_structs_in_regs        (enum machine_mode, const_tree, int);\n+static rtx        handle_structs_in_regs        (machine_mode, const_tree, int);\n static void       mcore_mark_dllexport          (tree);\n static void       mcore_mark_dllimport          (tree);\n static int        mcore_dllexport_p             (tree);\n@@ -144,21 +144,21 @@ static bool       mcore_rtx_costs\t\t(rtx, int, int, int,\n static void       mcore_external_libcall\t(rtx);\n static bool       mcore_return_in_memory\t(const_tree, const_tree);\n static int        mcore_arg_partial_bytes       (cumulative_args_t,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t tree, bool);\n static rtx        mcore_function_arg            (cumulative_args_t,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n static void       mcore_function_arg_advance    (cumulative_args_t,\n-\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n-static unsigned int mcore_function_arg_boundary (enum machine_mode,\n+static unsigned int mcore_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n static void       mcore_asm_trampoline_template (FILE *);\n static void       mcore_trampoline_init\t\t(rtx, tree, rtx);\n static bool       mcore_warn_func_return        (tree);\n static void       mcore_option_override\t\t(void);\n-static bool       mcore_legitimate_constant_p   (enum machine_mode, rtx);\n+static bool       mcore_legitimate_constant_p   (machine_mode, rtx);\n \f\n /* MCore specific attributes.  */\n \n@@ -1170,7 +1170,7 @@ mcore_output_andn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n /* Output an inline constant.  */\n \n static const char *\n-output_inline_const (enum machine_mode mode, rtx operands[])\n+output_inline_const (machine_mode mode, rtx operands[])\n {\n   HOST_WIDE_INT x = 0, y = 0;\n   int trick_no;\n@@ -1270,7 +1270,7 @@ output_inline_const (enum machine_mode mode, rtx operands[])\n \n const char *\n mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -1340,7 +1340,7 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n    to take care when we see overlapping source and dest registers.  */\n \n const char *\n-mcore_output_movedouble (rtx operands[], enum machine_mode mode ATTRIBUTE_UNUSED)\n+mcore_output_movedouble (rtx operands[], machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -1562,7 +1562,7 @@ mcore_expand_insv (rtx operands[])\n    known constants.  DEST and SRC are registers.  OFFSET is the known\n    starting point for the output pattern.  */\n \n-static const enum machine_mode mode_from_align[] =\n+static const machine_mode mode_from_align[] =\n {\n   VOIDmode, QImode, HImode, VOIDmode, SImode,\n };\n@@ -1571,7 +1571,7 @@ static void\n block_move_sequence (rtx dst_mem, rtx src_mem, int size, int align)\n {\n   rtx temp[2];\n-  enum machine_mode mode[2];\n+  machine_mode mode[2];\n   int amount[2];\n   bool active[2];\n   int phase = 0;\n@@ -1935,7 +1935,7 @@ mcore_initial_elimination_offset (int from, int to)\n \n static void\n mcore_setup_incoming_varargs (cumulative_args_t args_so_far_v,\n-\t\t\t      enum machine_mode mode, tree type,\n+\t\t\t      machine_mode mode, tree type,\n \t\t\t      int * ptr_pretend_size ATTRIBUTE_UNUSED,\n \t\t\t      int second_time ATTRIBUTE_UNUSED)\n {\n@@ -2645,7 +2645,7 @@ mcore_r15_operand_p (rtx x)\n \n enum reg_class\n mcore_secondary_reload_class (enum reg_class rclass,\n-\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+\t\t\t      machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   if (TEST_HARD_REG_BIT (reg_class_contents[rclass], 15)\n       && !mcore_r15_operand_p (x))\n@@ -2701,7 +2701,7 @@ mcore_option_override (void)\n    hold a function argument of mode MODE and type TYPE.  */\n \n int\n-mcore_num_arg_regs (enum machine_mode mode, const_tree type)\n+mcore_num_arg_regs (machine_mode mode, const_tree type)\n {\n   int size;\n \n@@ -2717,7 +2717,7 @@ mcore_num_arg_regs (enum machine_mode mode, const_tree type)\n }\n \n static rtx\n-handle_structs_in_regs (enum machine_mode mode, const_tree type, int reg)\n+handle_structs_in_regs (machine_mode mode, const_tree type, int reg)\n {\n   int size;\n \n@@ -2763,7 +2763,7 @@ handle_structs_in_regs (enum machine_mode mode, const_tree type, int reg)\n rtx\n mcore_function_value (const_tree valtype, const_tree func)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsigned_p;\n   \n   mode = TYPE_MODE (valtype);\n@@ -2793,7 +2793,7 @@ mcore_function_value (const_tree valtype, const_tree func)\n    its data type forbids.  */\n \n static rtx\n-mcore_function_arg (cumulative_args_t cum, enum machine_mode mode,\n+mcore_function_arg (cumulative_args_t cum, machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   int arg_reg;\n@@ -2813,7 +2813,7 @@ mcore_function_arg (cumulative_args_t cum, enum machine_mode mode,\n }\n \n static void\n-mcore_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+mcore_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2823,7 +2823,7 @@ mcore_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n }\n \n static unsigned int\n-mcore_function_arg_boundary (enum machine_mode mode,\n+mcore_function_arg_boundary (machine_mode mode,\n \t\t\t     const_tree type ATTRIBUTE_UNUSED)\n {\n   /* Doubles must be aligned to an 8 byte boundary.  */\n@@ -2840,7 +2840,7 @@ mcore_function_arg_boundary (enum machine_mode mode,\n    the function.  */\n \n static int\n-mcore_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n+mcore_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \t\t\t tree type, bool named)\n {\n   int reg = ROUND_REG (*get_cumulative_args (cum), mode);\n@@ -3193,7 +3193,7 @@ mcore_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    On the MCore, allow anything but a double.  */\n \n static bool\n-mcore_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+mcore_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return GET_CODE (x) != CONST_DOUBLE;\n }"}, {"sha": "4b7e665d2c59ea8c296f7a3a4389c796569db0f0", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -2769,7 +2769,7 @@\n \"*\n {\n    int ofs;\n-   enum machine_mode mode;\n+   machine_mode mode;\n    rtx base_reg = XEXP (operands[4], 0);\n \n    if ((ofs = mcore_byte_offset (INTVAL (operands[3]))) > -1)"}, {"sha": "17afd86a5875d3659ff5cc24aab83041c69833de", "filename": "gcc/config/mep/mep-protos.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmep%2Fmep-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmep%2Fmep-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -28,28 +28,28 @@ extern bool mep_split_mov (rtx *, int);\n extern bool mep_vliw_mode_match (rtx);\n extern bool mep_vliw_jmp_match (rtx);\n extern bool mep_multi_slot (rtx_insn *);\n-extern bool mep_legitimate_address (enum machine_mode, rtx, int);\n-extern int mep_legitimize_address (rtx *, rtx, enum machine_mode);\n-extern int mep_legitimize_reload_address (rtx *, enum machine_mode, int, /*enum reload_type*/ int, int);\n+extern bool mep_legitimate_address (machine_mode, rtx, int);\n+extern int mep_legitimize_address (rtx *, rtx, machine_mode);\n+extern int mep_legitimize_reload_address (rtx *, machine_mode, int, /*enum reload_type*/ int, int);\n extern int mep_core_address_length (rtx_insn *, int);\n extern int mep_cop_address_length (rtx_insn *, int);\n-extern bool mep_expand_mov (rtx *, enum machine_mode);\n-extern bool mep_mov_ok (rtx *, enum machine_mode);\n-extern void mep_split_wide_move (rtx *, enum machine_mode);\n+extern bool mep_expand_mov (rtx *, machine_mode);\n+extern bool mep_mov_ok (rtx *, machine_mode);\n+extern void mep_split_wide_move (rtx *, machine_mode);\n #ifdef RTX_CODE\n extern bool mep_expand_setcc (rtx *);\n extern rtx mep_expand_cbranch (rtx *);\n #endif\n extern const char *mep_emit_cbranch (rtx *, int);\n extern void mep_expand_call (rtx *, int);\n extern rtx mep_find_base_term (rtx);\n-extern enum reg_class mep_secondary_input_reload_class (enum reg_class, enum machine_mode, rtx);\n-extern enum reg_class mep_secondary_output_reload_class (enum reg_class, enum machine_mode, rtx);\n+extern enum reg_class mep_secondary_input_reload_class (enum reg_class, machine_mode, rtx);\n+extern enum reg_class mep_secondary_output_reload_class (enum reg_class, machine_mode, rtx);\n extern bool mep_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t enum machine_mode);\n-extern void mep_expand_reload (rtx *, enum machine_mode);\n+\t\t\t\t\t machine_mode);\n+extern void mep_expand_reload (rtx *, machine_mode);\n extern enum reg_class mep_preferred_reload_class (rtx, enum reg_class);\n-extern int mep_register_move_cost (enum machine_mode, enum reg_class, enum reg_class);\n+extern int mep_register_move_cost (machine_mode, enum reg_class, enum reg_class);\n extern void mep_init_expanders (void);\n extern rtx mep_return_addr_rtx (int);\n extern bool mep_epilogue_uses (int);\n@@ -69,7 +69,7 @@ extern void mep_final_prescan_insn (rtx_insn *, rtx *, int);\n extern void mep_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern bool mep_return_in_memory (const_tree, const_tree);\n extern rtx mep_function_value (const_tree, const_tree);\n-extern rtx mep_libcall_value (enum machine_mode);\n+extern rtx mep_libcall_value (machine_mode);\n extern void mep_asm_output_opcode (FILE *, const char *);\n extern void mep_note_pragma_disinterrupt (const char *);\n extern void mep_note_pragma_call (const char *);\n@@ -93,7 +93,7 @@ extern bool mep_lookup_pragma_call (const char *);\n extern bool mep_have_core_copro_moves_p;\n extern bool mep_have_copro_copro_moves_p;\n \n-extern bool mep_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n+extern bool mep_cannot_change_mode_class (machine_mode, machine_mode,\n \t\t\t\t\t  enum reg_class);\n \n /* These are called from mep-pragmas (front end) and then call into\n@@ -104,25 +104,25 @@ extern void mep_reinit_regs (void);\n extern void mep_init_regs (void);\n \n \n-extern int cgen_h_uint_6a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_7a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_8a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_6a2_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_22a4_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_2a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_24a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_6a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_5a4_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_2a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_16a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_3a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_5a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_16a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_8a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_7a2_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_6a4_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_5a8_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_4a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_10a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_sint_12a1_immediate (rtx, enum machine_mode);\n-extern int cgen_h_uint_20a1_immediate (rtx, enum machine_mode);\n+extern int cgen_h_uint_6a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_7a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_8a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_6a2_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_22a4_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_2a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_24a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_6a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_5a4_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_2a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_16a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_3a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_5a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_16a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_8a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_7a2_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_6a4_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_5a8_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_4a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_10a1_immediate (rtx, machine_mode);\n+extern int cgen_h_sint_12a1_immediate (rtx, machine_mode);\n+extern int cgen_h_uint_20a1_immediate (rtx, machine_mode);"}, {"sha": "46a451c58a85949c54a8ee32353355fcb880e620", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -170,7 +170,7 @@ static void mep_rewrite_mult (rtx_insn *, rtx);\n static void mep_rewrite_mulsi3 (rtx_insn *, rtx, rtx, rtx);\n static void mep_rewrite_maddsi3 (rtx_insn *, rtx, rtx, rtx, rtx);\n static bool mep_reuse_lo_p_1 (rtx, rtx, rtx_insn *, bool);\n-static bool move_needs_splitting (rtx, rtx, enum machine_mode);\n+static bool move_needs_splitting (rtx, rtx, machine_mode);\n static bool mep_expand_setcc_1 (enum rtx_code, rtx, rtx, rtx);\n static bool mep_nongeneral_reg (rtx);\n static bool mep_general_copro_reg (rtx);\n@@ -192,7 +192,7 @@ static void mep_start_function (FILE *, HOST_WIDE_INT);\n static bool mep_function_ok_for_sibcall (tree, tree);\n static int unique_bit_in (HOST_WIDE_INT);\n static int bit_size_for_clip (HOST_WIDE_INT);\n-static int bytesize (const_tree, enum machine_mode);\n+static int bytesize (const_tree, machine_mode);\n static tree mep_validate_based_tiny (tree *, tree, tree, int, bool *);\n static tree mep_validate_near_far (tree *, tree, tree, int, bool *);\n static tree mep_validate_disinterrupt (tree *, tree, tree, int, bool *);\n@@ -226,11 +226,11 @@ static void mep_init_builtins (void);\n static void mep_intrinsic_unavailable (int);\n static bool mep_get_intrinsic_insn (int, const struct cgen_insn **);\n static bool mep_get_move_insn (int, const struct cgen_insn **);\n-static rtx mep_convert_arg (enum machine_mode, rtx);\n+static rtx mep_convert_arg (machine_mode, rtx);\n static rtx mep_convert_regnum (const struct cgen_regnum_operand *, rtx);\n static rtx mep_legitimize_arg (const struct insn_operand_data *, rtx, int);\n static void mep_incompatible_arg (const struct insn_operand_data *, rtx, int, tree);\n-static rtx mep_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static rtx mep_expand_builtin (tree, rtx, rtx, machine_mode, int);\n static int mep_adjust_cost (rtx_insn *, rtx, rtx_insn *, int);\n static int mep_issue_rate (void);\n static rtx_insn *mep_find_ready_insn (rtx_insn **, int, enum attr_slot, int);\n@@ -239,16 +239,16 @@ static int mep_sched_reorder (FILE *, int, rtx_insn **, int *, int);\n static rtx_insn *mep_make_bundle (rtx, rtx_insn *);\n static void mep_bundle_insns (rtx_insn *);\n static bool mep_rtx_cost (rtx, int, int, int, int *, bool);\n-static int mep_address_cost (rtx, enum machine_mode, addr_space_t, bool);\n-static void mep_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+static int mep_address_cost (rtx, machine_mode, addr_space_t, bool);\n+static void mep_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\ttree, int *, int);\n-static bool mep_pass_by_reference (cumulative_args_t cum, enum machine_mode,\n+static bool mep_pass_by_reference (cumulative_args_t cum, machine_mode,\n \t\t\t\t   const_tree, bool);\n-static rtx mep_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx mep_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n-static void mep_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void mep_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n-static bool mep_vector_mode_supported_p (enum machine_mode);\n+static bool mep_vector_mode_supported_p (machine_mode);\n static rtx  mep_allocate_initial_value (rtx);\n static void mep_asm_init_sections (void);\n static int mep_comp_type_attributes (const_tree, const_tree);\n@@ -810,7 +810,7 @@ mep_use_post_modify_for_set_p (rtx set, rtx gpr, rtx offset)\n {\n   rtx *reg, *mem;\n   unsigned int reg_bytes, mem_bytes;\n-  enum machine_mode reg_mode, mem_mode;\n+  machine_mode reg_mode, mem_mode;\n \n   /* Only simple SETs can be converted.  */\n   if (GET_CODE (set) != SET)\n@@ -993,7 +993,7 @@ mep_bit_position_p (rtx x, bool looking_for)\n \n static bool\n move_needs_splitting (rtx dest, rtx src,\n-\t\t      enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t      machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int s = mep_section_tag (src);\n \n@@ -1082,7 +1082,7 @@ mep_multi_slot (rtx_insn *x)\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool\n-mep_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+mep_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   /* We can't convert symbol values to gp- or tp-rel values after\n      reload, as reload might have used $gp or $tp for other\n@@ -1099,7 +1099,7 @@ mep_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n    strict, and another way for not-strict, like REG_OK_FOR_BASE_P.  */\n \n bool\n-mep_legitimate_address (enum machine_mode mode, rtx x, int strict)\n+mep_legitimate_address (machine_mode mode, rtx x, int strict)\n {\n   int the_tag;\n \n@@ -1207,7 +1207,7 @@ mep_legitimate_address (enum machine_mode mode, rtx x, int strict)\n }\n \n int\n-mep_legitimize_reload_address (rtx *x, enum machine_mode mode, int opnum,\n+mep_legitimize_reload_address (rtx *x, machine_mode mode, int opnum,\n \t\t\t       int type_i,\n \t\t\t       int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -1314,7 +1314,7 @@ mep_cop_address_length (rtx_insn *insn, int opn)\n \n #define DEBUG_EXPAND_MOV 0\n bool\n-mep_expand_mov (rtx *operands, enum machine_mode mode)\n+mep_expand_mov (rtx *operands, machine_mode mode)\n {\n   int i, t;\n   int tag[2];\n@@ -1508,7 +1508,7 @@ mep_expand_mov (rtx *operands, enum machine_mode mode)\n /* Cases where the pattern can't be made to use at all.  */\n \n bool\n-mep_mov_ok (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n+mep_mov_ok (rtx *operands, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int i;\n \n@@ -1574,7 +1574,7 @@ mep_mov_ok (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n #define DEBUG_SPLIT_WIDE_MOVE 0\n void\n-mep_split_wide_move (rtx *operands, enum machine_mode mode)\n+mep_split_wide_move (rtx *operands, machine_mode mode)\n {\n   int i;\n \n@@ -1942,7 +1942,7 @@ mep_find_base_term (rtx x)\n    modes FROM to TO.  */\n \n bool\n-mep_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+mep_cannot_change_mode_class (machine_mode from, machine_mode to,\n \t\t\t       enum reg_class regclass)\n {\n   if (from == to)\n@@ -2039,7 +2039,7 @@ mep_secondary_copro_reload_class (enum reg_class rclass, rtx x)\n \n enum reg_class\n mep_secondary_input_reload_class (enum reg_class rclass,\n-\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t  rtx x)\n {\n   int rv = NO_REGS;\n@@ -2065,7 +2065,7 @@ mep_secondary_input_reload_class (enum reg_class rclass,\n \n enum reg_class\n mep_secondary_output_reload_class (enum reg_class rclass,\n-\t\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t   rtx x)\n {\n   int rv = NO_REGS;\n@@ -2092,7 +2092,7 @@ mep_secondary_output_reload_class (enum reg_class rclass,\n \n bool\n mep_secondary_memory_needed (enum reg_class rclass1, enum reg_class rclass2,\n-\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (!mep_have_core_copro_moves_p)\n     {\n@@ -2111,7 +2111,7 @@ mep_secondary_memory_needed (enum reg_class rclass1, enum reg_class rclass2,\n }\n \n void\n-mep_expand_reload (rtx *operands, enum machine_mode mode)\n+mep_expand_reload (rtx *operands, machine_mode mode)\n {\n   /* There are three cases for each direction:\n      register, farsym\n@@ -2198,7 +2198,7 @@ mep_preferred_reload_class (rtx x, enum reg_class rclass)\n    that requires a temporary register or temporary stack slot.  */\n \n int\n-mep_register_move_cost (enum machine_mode mode, enum reg_class from, enum reg_class to)\n+mep_register_move_cost (machine_mode mode, enum reg_class from, enum reg_class to)\n {\n   if (mep_have_copro_copro_moves_p\n       && reg_class_subset_p (from, CR_REGS)\n@@ -2727,7 +2727,7 @@ mep_expand_prologue (void)\n       {\n \trtx mem;\n \tbool maybe_dead_p;\n-\tenum machine_mode rmode;\n+\tmachine_mode rmode;\n \n \trss = cfun->machine->reg_save_slot[i];\n \n@@ -2967,7 +2967,7 @@ mep_expand_epilogue (void)\n   for (i=FIRST_PSEUDO_REGISTER-1; i>=1; i--)\n     if (mep_call_saves_register (i))\n       {\n-\tenum machine_mode rmode;\n+\tmachine_mode rmode;\n \tint rss = cfun->machine->reg_save_slot[i];\n \n \tif (mep_reg_size (i) == 8)\n@@ -3401,7 +3401,7 @@ mep_final_prescan_insn (rtx_insn *insn, rtx *operands ATTRIBUTE_UNUSED,\n \n static void\n mep_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    tree type ATTRIBUTE_UNUSED, int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n {\n@@ -3413,7 +3413,7 @@ mep_setup_incoming_varargs (cumulative_args_t cum,\n }\n \n static int\n-bytesize (const_tree type, enum machine_mode mode)\n+bytesize (const_tree type, machine_mode mode)\n {\n   if (mode == BLKmode)\n     return int_size_in_bytes (type);\n@@ -3669,7 +3669,7 @@ mep_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n    first arg.  For varargs, we copy $1..$4 to the stack.  */\n \n static rtx\n-mep_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+mep_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -3696,7 +3696,7 @@ mep_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \n static bool\n mep_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode,\n+\t\t       machine_mode mode,\n \t\t       const_tree        type,\n \t\t       bool              named ATTRIBUTE_UNUSED)\n {\n@@ -3719,7 +3719,7 @@ mep_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \n static void\n mep_function_arg_advance (cumulative_args_t pcum,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type ATTRIBUTE_UNUSED,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -3755,7 +3755,7 @@ mep_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED)\n /* Implement LIBCALL_VALUE, using the same rules as mep_function_value.  */\n \n rtx\n-mep_libcall_value (enum machine_mode mode)\n+mep_libcall_value (machine_mode mode)\n {\n   return gen_rtx_REG (mode, RETURN_VALUE_REGNUM);\n }\n@@ -6069,7 +6069,7 @@ mep_get_move_insn (int intrinsic, const struct cgen_insn **cgen_insn)\n    to MODE using a subreg.  Otherwise return ARG as-is.  */\n \n static rtx\n-mep_convert_arg (enum machine_mode mode, rtx arg)\n+mep_convert_arg (machine_mode mode, rtx arg)\n {\n   if (GET_MODE (arg) != mode\n       && register_operand (arg, VOIDmode)\n@@ -6190,7 +6190,7 @@ mep_incompatible_arg (const struct insn_operand_data *operand, rtx arg,\n static rtx\n mep_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t    rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    int ignore ATTRIBUTE_UNUSED)\n {\n   rtx pat, op[10], arg[10];\n@@ -6287,7 +6287,7 @@ mep_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       if (cgen_insn->regnums[a].reference_p)\n \t{\n \t  tree pointed_to = TREE_TYPE (TREE_TYPE (value));\n-\t  enum machine_mode pointed_mode = TYPE_MODE (pointed_to);\n+\t  machine_mode pointed_mode = TYPE_MODE (pointed_to);\n \n \t  arg[a] = gen_rtx_MEM (pointed_mode, arg[a]);\n \t}\n@@ -6368,7 +6368,7 @@ mep_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n }\n \n static bool\n-mep_vector_mode_supported_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n+mep_vector_mode_supported_p (machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n@@ -7163,7 +7163,7 @@ mep_rtx_cost (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \n static int\n mep_address_cost (rtx addr ATTRIBUTE_UNUSED,\n-\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  addr_space_t as ATTRIBUTE_UNUSED,\n \t\t  bool ATTRIBUTE_UNUSED speed_p)\n {"}, {"sha": "cbd2422768933a420ff0aae65c3040cbda0374c5", "filename": "gcc/config/microblaze/microblaze-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -29,22 +29,22 @@ extern void microblaze_expand_prologue (void);\n extern void microblaze_expand_epilogue (void);\n extern void override_options (void);\n extern int microblaze_expand_shift (rtx *);\n-extern bool microblaze_expand_move (enum machine_mode, rtx *);\n+extern bool microblaze_expand_move (machine_mode, rtx *);\n extern bool microblaze_expand_block_move (rtx, rtx, rtx, rtx);\n extern void microblaze_expand_divide (rtx *);\n-extern void microblaze_expand_conditional_branch (enum machine_mode, rtx *); \n+extern void microblaze_expand_conditional_branch (machine_mode, rtx *); \n extern void microblaze_expand_conditional_branch_sf (rtx *); \n extern int microblaze_can_use_return_insn (void);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern void init_cumulative_args (CUMULATIVE_ARGS *,tree, rtx);\n-extern bool microblaze_legitimate_address_p (enum machine_mode, rtx, bool);\n+extern bool microblaze_legitimate_address_p (machine_mode, rtx, bool);\n extern int microblaze_is_interrupt_variant (void);\n extern int microblaze_is_break_handler (void);\n extern int microblaze_break_function_p (tree func);\n extern rtx microblaze_return_addr (int, rtx);\n-extern int simple_memory_operand (rtx, enum machine_mode);\n-extern int double_memory_operand (rtx, enum machine_mode);\n+extern int simple_memory_operand (rtx, machine_mode);\n+extern int double_memory_operand (rtx, machine_mode);\n extern void microblaze_order_regs_for_local_alloc (void);\n extern int microblaze_regno_ok_for_base_p (int, int);\n extern HOST_WIDE_INT microblaze_initial_elimination_offset (int, int);\n@@ -55,7 +55,7 @@ extern int microblaze_legitimate_pic_operand (rtx);\n extern bool microblaze_tls_referenced_p (rtx);\n extern int symbol_mentioned_p (rtx);\n extern int label_mentioned_p (rtx);\n-extern bool microblaze_cannot_force_const_mem (enum machine_mode, rtx);\n+extern bool microblaze_cannot_force_const_mem (machine_mode, rtx);\n #endif  /* RTX_CODE */\n \n /* Declare functions in microblaze-c.c.  */"}, {"sha": "48ebf861c5aa9ac1e7f32988e00fff1ddccd2db1", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -261,7 +261,7 @@ section *sdata2_section;\n \n /* Return truth value if a CONST_DOUBLE is ok to be a legitimate constant.  */\n static bool\n-microblaze_const_double_ok (rtx op, enum machine_mode mode)\n+microblaze_const_double_ok (rtx op, machine_mode mode)\n {\n   REAL_VALUE_TYPE d;\n \n@@ -303,7 +303,7 @@ microblaze_const_double_ok (rtx op, enum machine_mode mode)\n    (ie, register + small offset) or (register + register).  */\n \n int\n-simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+simple_memory_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx addr, plus0, plus1;\n \n@@ -364,7 +364,7 @@ simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    a doubleword.  */\n \n int\n-double_memory_operand (rtx op, enum machine_mode mode)\n+double_memory_operand (rtx op, machine_mode mode)\n {\n   rtx addr;\n \n@@ -423,7 +423,7 @@ microblaze_regno_ok_for_base_p (int regno, int strict)\n \n static bool\n microblaze_valid_base_register_p (rtx x,\n-\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t  int strict)\n {\n   if (!strict && GET_CODE (x) == SUBREG)\n@@ -480,7 +480,7 @@ microblaze_tls_referenced_p (rtx x)\n }\n \n bool\n-microblaze_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+microblaze_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return microblaze_tls_referenced_p(x);\n }\n@@ -683,7 +683,7 @@ microblaze_classify_unspec (struct microblaze_address_info *info, rtx x)\n \n static bool\n microblaze_valid_index_register_p (rtx x,\n-\t\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t   int strict)\n {\n   if (!strict && GET_CODE (x) == SUBREG)\n@@ -744,7 +744,7 @@ get_base_reg (rtx x)\n \n static bool\n microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n-\t\t\t     enum machine_mode mode, int strict)\n+\t\t\t     machine_mode mode, int strict)\n {\n   rtx xplus0;\n   rtx xplus1;\n@@ -906,7 +906,7 @@ microblaze_classify_address (struct microblaze_address_info *info, rtx x,\n    is called during reload.  */\n \n bool\n-microblaze_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+microblaze_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   struct microblaze_address_info addr;\n \n@@ -967,7 +967,7 @@ microblaze_legitimate_pic_operand (rtx x)\n \n static rtx\n microblaze_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t       machine_mode mode ATTRIBUTE_UNUSED)\n {\n   register rtx xinsn = x, result;\n \n@@ -1101,7 +1101,7 @@ microblaze_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n   HOST_WIDE_INT offset, delta;\n   unsigned HOST_WIDE_INT bits;\n   int i;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx *regs;\n \n   bits = BITS_PER_WORD;\n@@ -1244,7 +1244,7 @@ microblaze_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t\t      int opno ATTRIBUTE_UNUSED, int *total,\n \t\t      bool speed ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n \n   switch (code)\n     {\n@@ -1388,7 +1388,7 @@ microblaze_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n    of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n \n static int\n-microblaze_address_insns (rtx x, enum machine_mode mode)\n+microblaze_address_insns (rtx x, machine_mode mode)\n {\n   struct microblaze_address_info addr;\n \n@@ -1433,7 +1433,7 @@ microblaze_address_insns (rtx x, enum machine_mode mode)\n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.  */\n static int\n-microblaze_address_cost (rtx addr, enum machine_mode mode ATTRIBUTE_UNUSED,\n+microblaze_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t addr_space_t as ATTRIBUTE_UNUSED,\n \t\t\t bool speed ATTRIBUTE_UNUSED)\n {\n@@ -1491,7 +1491,7 @@ init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n \n static void\n microblaze_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t\t enum machine_mode mode,\n+\t\t\t\t machine_mode mode,\n \t\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1548,7 +1548,7 @@ microblaze_function_arg_advance (cumulative_args_t cum_v,\n    or 0 if the argument is to be passed on the stack.  */\n \n static rtx\n-microblaze_function_arg (cumulative_args_t cum_v, enum machine_mode mode, \n+microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode, \n \t\t\t const_tree type ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n@@ -1592,7 +1592,7 @@ microblaze_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n   if (mode == VOIDmode)\n     {\n       if (cum->num_adjusts > 0)\n-\tret = gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,\n+\tret = gen_rtx_PARALLEL ((machine_mode) cum->fp_code,\n \t\t\t\tgen_rtvec_v (cum->num_adjusts, cum->adjust));\n     }\n \n@@ -1601,7 +1601,7 @@ microblaze_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \n /* Return number of bytes of argument to put in registers. */\n static int\n-function_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\t\n+function_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\t\n \t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\t\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1694,7 +1694,7 @@ microblaze_option_override (void)\n {\n   register int i, start;\n   register int regno;\n-  register enum machine_mode mode;\n+  register machine_mode mode;\n   int ver;\n \n   microblaze_section_threshold = (global_options_set.x_g_switch_value\n@@ -1842,7 +1842,7 @@ microblaze_option_override (void)\n   /* Set up array giving whether a given register can hold a given mode.   */\n \n   for (mode = VOIDmode;\n-       mode != MAX_MACHINE_MODE; mode = (enum machine_mode) ((int) mode + 1))\n+       mode != MAX_MACHINE_MODE; mode = (machine_mode) ((int) mode + 1))\n     {\n       register int size = GET_MODE_SIZE (mode);\n \n@@ -2816,7 +2816,7 @@ microblaze_expand_prologue (void)\n   for (cur_arg = fnargs; cur_arg != 0; cur_arg = next_arg)\n     {\n       tree passed_type = DECL_ARG_TYPE (cur_arg);\n-      enum machine_mode passed_mode = TYPE_MODE (passed_type);\n+      machine_mode passed_mode = TYPE_MODE (passed_type);\n       rtx entry_parm;\n \n       if (TREE_ADDRESSABLE (passed_type))\n@@ -3082,7 +3082,7 @@ microblaze_can_use_return_insn (void)\n \n static reg_class_t\n microblaze_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED, \n-\t\t\t     reg_class_t rclass, enum machine_mode mode ATTRIBUTE_UNUSED, \n+\t\t\t     reg_class_t rclass, machine_mode mode ATTRIBUTE_UNUSED, \n \t\t\t     secondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n   if (rclass == ST_REGS)\n@@ -3171,7 +3171,7 @@ microblaze_encode_section_info (tree decl, rtx rtl, int first)\n }\n \n static rtx\n-expand_pic_symbol_ref (enum machine_mode mode ATTRIBUTE_UNUSED, rtx op)\n+expand_pic_symbol_ref (machine_mode mode ATTRIBUTE_UNUSED, rtx op)\n {\n   rtx result;\n   result = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), UNSPEC_GOTOFF);\n@@ -3250,7 +3250,7 @@ microblaze_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n }\n \n bool\n-microblaze_expand_move (enum machine_mode mode, rtx operands[])\n+microblaze_expand_move (machine_mode mode, rtx operands[])\n {\n   rtx op0, op1;\n \n@@ -3423,7 +3423,7 @@ microblaze_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    second, generate correct branch instruction.  */\n \n void\n-microblaze_expand_conditional_branch (enum machine_mode mode, rtx operands[])\n+microblaze_expand_conditional_branch (machine_mode mode, rtx operands[])\n {\n   enum rtx_code code = GET_CODE (operands[0]);\n   rtx cmp_op0 = operands[1];\n@@ -3558,7 +3558,7 @@ microblaze_adjust_cost (rtx_insn *insn ATTRIBUTE_UNUSED, rtx link,\n    At present, GAS doesn't understand li.[sd], so don't allow it\n    to be generated at present.  */\n static bool\n-microblaze_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+microblaze_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n \n   if (microblaze_cannot_force_const_mem(mode, x))"}, {"sha": "db939132355a618593df0edd49621b0af09359cc", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -192,9 +192,9 @@ enum mips_split_type {\n \n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,\n \t\t\t\t      enum mips_symbol_type *);\n-extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n-extern bool mips_stack_address_p (rtx, enum machine_mode);\n-extern int mips_address_insns (rtx, enum machine_mode, bool);\n+extern int mips_regno_mode_ok_for_base_p (int, machine_mode, bool);\n+extern bool mips_stack_address_p (rtx, machine_mode);\n+extern int mips_address_insns (rtx, machine_mode, bool);\n extern int mips_const_insns (rtx);\n extern int mips_split_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx_insn *);\n@@ -205,11 +205,11 @@ extern void mips_emit_binary (enum rtx_code, rtx, rtx, rtx);\n #endif\n extern rtx mips_pic_base_register (rtx);\n extern rtx mips_got_load (rtx, rtx, enum mips_symbol_type);\n-extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n+extern bool mips_split_symbol (rtx, rtx, machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern rtx mips_strip_unspec_address (rtx);\n extern void mips_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);\n-extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n+extern bool mips_legitimize_move (machine_mode, rtx, rtx);\n \n extern rtx mips_subword (rtx, bool);\n extern bool mips_split_move_p (rtx, rtx, enum mips_split_type);\n@@ -240,14 +240,14 @@ extern bool mips_expand_block_move (rtx, rtx, rtx);\n extern void mips_expand_synci_loop (rtx, rtx);\n \n extern void mips_init_cumulative_args (CUMULATIVE_ARGS *, tree);\n-extern bool mips_pad_arg_upward (enum machine_mode, const_tree);\n-extern bool mips_pad_reg_upward (enum machine_mode, tree);\n+extern bool mips_pad_arg_upward (machine_mode, const_tree);\n+extern bool mips_pad_reg_upward (machine_mode, tree);\n \n extern bool mips_expand_ext_as_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t       HOST_WIDE_INT, bool);\n extern bool mips_expand_ins_as_unaligned_store (rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT);\n-extern bool mips_mem_fits_mode_p (enum machine_mode mode, rtx x);\n+extern bool mips_mem_fits_mode_p (machine_mode mode, rtx x);\n extern HOST_WIDE_INT mips_debugger_offset (rtx, HOST_WIDE_INT);\n \n extern void mips_push_asm_switch (struct mips_asm_switch *);\n@@ -278,14 +278,14 @@ extern void mips_expand_before_return (void);\n extern void mips_expand_epilogue (bool);\n extern bool mips_can_use_return_insn (void);\n \n-extern bool mips_cannot_change_mode_class (enum machine_mode,\n-\t\t\t\t\t   enum machine_mode, enum reg_class);\n+extern bool mips_cannot_change_mode_class (machine_mode,\n+\t\t\t\t\t   machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);\n-extern bool mips_modes_tieable_p (enum machine_mode, enum machine_mode);\n+extern bool mips_modes_tieable_p (machine_mode, machine_mode);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t   machine_mode,\n \t\t\t\t\t\t   rtx, bool);\n-extern int mips_class_max_nregs (enum reg_class, enum machine_mode);\n+extern int mips_class_max_nregs (enum reg_class, machine_mode);\n \n extern int mips_adjust_insn_length (rtx_insn *, int);\n extern void mips_output_load_label (rtx);\n@@ -298,7 +298,7 @@ extern const char *mips_output_sync_loop (rtx_insn *, rtx *);\n extern unsigned int mips_sync_loop_insns (rtx_insn *, rtx *);\n extern const char *mips_output_division (const char *, rtx *);\n extern const char *mips_output_probe_stack_range (rtx, rtx);\n-extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n+extern unsigned int mips_hard_regno_nregs (int, machine_mode);\n extern bool mips_linked_madd_p (rtx_insn *, rtx_insn *);\n extern bool mips_store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern int mips_dspalu_bypass_p (rtx, rtx);\n@@ -312,9 +312,9 @@ extern const char *mips16e_output_save_restore (rtx, HOST_WIDE_INT);\n extern bool mips16e_save_restore_pattern_p (rtx, HOST_WIDE_INT,\n \t\t\t\t\t    struct mips16e_save_restore_info *);\n \n-extern bool mask_low_and_shift_p (enum machine_mode, rtx, rtx, int);\n-extern int mask_low_and_shift_len (enum machine_mode, rtx, rtx);\n-extern bool and_operands_ok (enum machine_mode, rtx, rtx);\n+extern bool mask_low_and_shift_p (machine_mode, rtx, rtx, int);\n+extern int mask_low_and_shift_len (machine_mode, rtx, rtx);\n+extern bool and_operands_ok (machine_mode, rtx, rtx);\n extern bool mips_fmadd_bypass (rtx_insn *, rtx_insn *);\n \n union mips_gen_fn_ptrs\n@@ -341,9 +341,9 @@ extern bool umips_save_restore_pattern_p (bool, rtx);\n extern bool umips_load_store_pair_p (bool, rtx *);\n extern void umips_output_load_store_pair (bool, rtx *);\n extern bool umips_movep_target_p (rtx, rtx);\n-extern bool umips_12bit_offset_address_p (rtx, enum machine_mode);\n-extern bool lwsp_swsp_address_p (rtx, enum machine_mode);\n-extern bool m16_based_address_p (rtx, enum machine_mode,\n+extern bool umips_12bit_offset_address_p (rtx, machine_mode);\n+extern bool lwsp_swsp_address_p (rtx, machine_mode);\n+extern bool m16_based_address_p (rtx, machine_mode,\n \t\t\t         int (*)(rtx_def*, machine_mode)); \n extern rtx mips_expand_thread_pointer (rtx);\n extern void mips16_expand_get_fcsr (rtx);"}, {"sha": "3d9db9246c9d278c3fe1e4eb7bb7ad75a358f67c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 117, "deletions": 117, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1214,9 +1214,9 @@ static const struct mips_rtx_cost_data\n };\n \f\n static rtx mips_find_pic_call_symbol (rtx_insn *, rtx, bool);\n-static int mips_register_move_cost (enum machine_mode, reg_class_t,\n+static int mips_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n-static unsigned int mips_function_arg_boundary (enum machine_mode, const_tree);\n+static unsigned int mips_function_arg_boundary (machine_mode, const_tree);\n \f\n struct mips16_flip_traits : default_hashmap_traits\n {\n@@ -1630,7 +1630,7 @@ mips_build_integer (struct mips_integer_op *codes,\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool\n-mips_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+mips_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return mips_const_insns (x) > 0;\n }\n@@ -1804,7 +1804,7 @@ mips_symbol_binds_local_p (const_rtx x)\n    data section.  */\n \n static bool\n-mips_rtx_constant_in_small_data_p (enum machine_mode mode)\n+mips_rtx_constant_in_small_data_p (machine_mode mode)\n {\n   return (!TARGET_EMBEDDED_DATA\n \t  && TARGET_LOCAL_SDATA\n@@ -2057,7 +2057,7 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_context context,\n    extended ones.  */\n \n static int\n-mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n+mips_symbol_insns_1 (enum mips_symbol_type type, machine_mode mode)\n {\n   if (mips_use_pcrel_pool_p[(int) type])\n     {\n@@ -2169,15 +2169,15 @@ mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n    In both cases, instruction counts are based off BASE_INSN_LENGTH.  */\n \n static int\n-mips_symbol_insns (enum mips_symbol_type type, enum machine_mode mode)\n+mips_symbol_insns (enum mips_symbol_type type, machine_mode mode)\n {\n   return mips_symbol_insns_1 (type, mode) * (TARGET_MIPS16 ? 2 : 1);\n }\n \f\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-mips_cannot_force_const_mem (enum machine_mode mode, rtx x)\n+mips_cannot_force_const_mem (machine_mode mode, rtx x)\n {\n   enum mips_symbol_type type;\n   rtx base, offset;\n@@ -2227,7 +2227,7 @@ mips_cannot_force_const_mem (enum machine_mode mode, rtx x)\n    constants when we're using a per-function constant pool.  */\n \n static bool\n-mips_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+mips_use_blocks_for_constant_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\tconst_rtx x ATTRIBUTE_UNUSED)\n {\n   return !TARGET_MIPS16_PCREL_LOADS;\n@@ -2237,7 +2237,7 @@ mips_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n    STRICT_P is true if REG_OK_STRICT is in effect.  */\n \n int\n-mips_regno_mode_ok_for_base_p (int regno, enum machine_mode mode,\n+mips_regno_mode_ok_for_base_p (int regno, machine_mode mode,\n \t\t\t       bool strict_p)\n {\n   if (!HARD_REGISTER_NUM_P (regno))\n@@ -2265,7 +2265,7 @@ mips_regno_mode_ok_for_base_p (int regno, enum machine_mode mode,\n    STRICT_P is true if REG_OK_STRICT is in effect.  */\n \n static bool\n-mips_valid_base_register_p (rtx x, enum machine_mode mode, bool strict_p)\n+mips_valid_base_register_p (rtx x, machine_mode mode, bool strict_p)\n {\n   if (!strict_p && GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -2278,7 +2278,7 @@ mips_valid_base_register_p (rtx x, enum machine_mode mode, bool strict_p)\n    can address a value of mode MODE.  */\n \n static bool\n-mips_valid_offset_p (rtx x, enum machine_mode mode)\n+mips_valid_offset_p (rtx x, machine_mode mode)\n {\n   /* Check that X is a signed 16-bit number.  */\n   if (!const_arith_operand (x, Pmode))\n@@ -2297,7 +2297,7 @@ mips_valid_offset_p (rtx x, enum machine_mode mode)\n    LO_SUM symbol has type SYMBOL_TYPE.  */\n \n static bool\n-mips_valid_lo_sum_p (enum mips_symbol_type symbol_type, enum machine_mode mode)\n+mips_valid_lo_sum_p (enum mips_symbol_type symbol_type, machine_mode mode)\n {\n   /* Check that symbols of type SYMBOL_TYPE can be used to access values\n      of mode MODE.  */\n@@ -2325,7 +2325,7 @@ mips_valid_lo_sum_p (enum mips_symbol_type symbol_type, enum machine_mode mode)\n \n static bool\n mips_classify_address (struct mips_address_info *info, rtx x,\n-\t\t       enum machine_mode mode, bool strict_p)\n+\t\t       machine_mode mode, bool strict_p)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2384,7 +2384,7 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n /* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n \n static bool\n-mips_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+mips_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n {\n   struct mips_address_info addr;\n \n@@ -2394,7 +2394,7 @@ mips_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n /* Return true if X is a legitimate $sp-based address for mode MDOE.  */\n \n bool\n-mips_stack_address_p (rtx x, enum machine_mode mode)\n+mips_stack_address_p (rtx x, machine_mode mode)\n {\n   struct mips_address_info addr;\n \n@@ -2431,7 +2431,7 @@ mips_lwxs_address_p (rtx addr)\n    sense, because their use is so restricted.  */\n \n static bool\n-mips_lx_address_p (rtx addr, enum machine_mode mode)\n+mips_lx_address_p (rtx addr, machine_mode mode)\n {\n   if (GET_CODE (addr) != PLUS\n       || !REG_P (XEXP (addr, 0))\n@@ -2458,7 +2458,7 @@ mips_lx_address_p (rtx addr, enum machine_mode mode)\n    an 8-bit immediate field that's shifted left twice.  */\n \n static bool\n-mips16_unextended_reference_p (enum machine_mode mode, rtx base,\n+mips16_unextended_reference_p (machine_mode mode, rtx base,\n \t\t\t       unsigned HOST_WIDE_INT offset)\n {\n   if (mode != BLKmode && offset % GET_MODE_SIZE (mode) == 0)\n@@ -2478,7 +2478,7 @@ mips16_unextended_reference_p (enum machine_mode mode, rtx base,\n    enough.  */\n \n int\n-mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)\n+mips_address_insns (rtx x, machine_mode mode, bool might_split_p)\n {\n   struct mips_address_info addr;\n   int factor;\n@@ -2538,7 +2538,7 @@ mips_signed_immediate_p (unsigned HOST_WIDE_INT x, int bits, int shift = 0)\n    OFFSET_PREDICATE.  */\n \n bool\n-m16_based_address_p (rtx x, enum machine_mode mode,\n+m16_based_address_p (rtx x, machine_mode mode,\n \t\t     insn_operand_predicate_fn offset_predicate)\n {\n   struct mips_address_info addr;\n@@ -2553,7 +2553,7 @@ m16_based_address_p (rtx x, enum machine_mode mode,\n    for a microMIPS LWSP or SWSP insn.  */\n \n bool\n-lwsp_swsp_address_p (rtx x, enum machine_mode mode)\n+lwsp_swsp_address_p (rtx x, machine_mode mode)\n {\n   struct mips_address_info addr;\n \n@@ -2567,7 +2567,7 @@ lwsp_swsp_address_p (rtx x, enum machine_mode mode)\n    MODE is the mode of the value being accessed.  */\n \n bool\n-umips_12bit_offset_address_p (rtx x, enum machine_mode mode)\n+umips_12bit_offset_address_p (rtx x, machine_mode mode)\n {\n   struct mips_address_info addr;\n \n@@ -2682,7 +2682,7 @@ mips_split_const_insns (rtx x)\n int\n mips_load_store_insns (rtx mem, rtx_insn *insn)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool might_split_p;\n   rtx set;\n \n@@ -2762,7 +2762,7 @@ mips_emit_unary (enum rtx_code code, rtx target, rtx op0)\n    Return that new register.  */\n \n static rtx\n-mips_force_unary (enum machine_mode mode, enum rtx_code code, rtx op0)\n+mips_force_unary (machine_mode mode, enum rtx_code code, rtx op0)\n {\n   rtx reg;\n \n@@ -2784,7 +2784,7 @@ mips_emit_binary (enum rtx_code code, rtx target, rtx op0, rtx op1)\n    of mode MODE.  Return that new register.  */\n \n static rtx\n-mips_force_binary (enum machine_mode mode, enum rtx_code code, rtx op0, rtx op1)\n+mips_force_binary (machine_mode mode, enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx reg;\n \n@@ -3042,7 +3042,7 @@ mips_got_load (rtx temp, rtx addr, enum mips_symbol_type type)\n    is guaranteed to be a legitimate address for mode MODE.  */\n \n bool\n-mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *low_out)\n+mips_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)\n {\n   enum mips_symbol_context context;\n   enum mips_symbol_type symbol_type;\n@@ -3302,7 +3302,7 @@ mips16_expand_set_fcsr (rtx newval)\n /* If X is not a valid address for mode MODE, force it into a register.  */\n \n static rtx\n-mips_force_address (rtx x, enum machine_mode mode)\n+mips_force_address (rtx x, machine_mode mode)\n {\n   if (!mips_legitimate_address_p (mode, x, false))\n     x = force_reg (Pmode, x);\n@@ -3316,7 +3316,7 @@ mips_force_address (rtx x, enum machine_mode mode)\n \n static rtx\n mips_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n   rtx base, addr;\n   HOST_WIDE_INT offset;\n@@ -3347,7 +3347,7 @@ void\n mips_move_integer (rtx temp, rtx dest, unsigned HOST_WIDE_INT value)\n {\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned int i, num_ops;\n   rtx x;\n \n@@ -3377,7 +3377,7 @@ mips_move_integer (rtx temp, rtx dest, unsigned HOST_WIDE_INT value)\n    move_operand.  */\n \n static void\n-mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n+mips_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n {\n   rtx base, offset;\n \n@@ -3428,7 +3428,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n    sequence that is valid.  */\n \n bool\n-mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n+mips_legitimize_move (machine_mode mode, rtx dest, rtx src)\n {\n   if (!register_operand (dest, mode) && !reg_or_0_operand (src, mode))\n     {\n@@ -3678,15 +3678,15 @@ mips_binary_cost (rtx x, int single_cost, int double_cost, bool speed)\n /* Return the cost of floating-point multiplications of mode MODE.  */\n \n static int\n-mips_fp_mult_cost (enum machine_mode mode)\n+mips_fp_mult_cost (machine_mode mode)\n {\n   return mode == DFmode ? mips_cost->fp_mult_df : mips_cost->fp_mult_sf;\n }\n \n /* Return the cost of floating-point divisions of mode MODE.  */\n \n static int\n-mips_fp_div_cost (enum machine_mode mode)\n+mips_fp_div_cost (machine_mode mode)\n {\n   return mode == DFmode ? mips_cost->fp_div_df : mips_cost->fp_div_sf;\n }\n@@ -3695,7 +3695,7 @@ mips_fp_div_cost (enum machine_mode mode)\n    cost of OP itself.  */\n \n static int\n-mips_sign_extend_cost (enum machine_mode mode, rtx op)\n+mips_sign_extend_cost (machine_mode mode, rtx op)\n {\n   if (MEM_P (op))\n     /* Extended loads are as cheap as unextended ones.  */\n@@ -3717,7 +3717,7 @@ mips_sign_extend_cost (enum machine_mode mode, rtx op)\n    cost of OP itself.  */\n \n static int\n-mips_zero_extend_cost (enum machine_mode mode, rtx op)\n+mips_zero_extend_cost (machine_mode mode, rtx op)\n {\n   if (MEM_P (op))\n     /* Extended loads are as cheap as unextended ones.  */\n@@ -3743,15 +3743,15 @@ mips_zero_extend_cost (enum machine_mode mode, rtx op)\n    assuming that the move will be in pieces of at most UNITS bytes.  */\n \n static int\n-mips_set_reg_reg_piece_cost (enum machine_mode mode, unsigned int units)\n+mips_set_reg_reg_piece_cost (machine_mode mode, unsigned int units)\n {\n   return COSTS_N_INSNS ((GET_MODE_SIZE (mode) + units - 1) / units);\n }\n \n /* Return the cost of moving between two registers of mode MODE.  */\n \n static int\n-mips_set_reg_reg_cost (enum machine_mode mode)\n+mips_set_reg_reg_cost (machine_mode mode)\n {\n   switch (GET_MODE_CLASS (mode))\n     {\n@@ -3776,7 +3776,7 @@ static bool\n mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   int cost;\n   rtx addr;\n@@ -4198,7 +4198,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n /* Implement TARGET_ADDRESS_COST.  */\n \n static int\n-mips_address_cost (rtx addr, enum machine_mode mode,\n+mips_address_cost (rtx addr, machine_mode mode,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -4333,7 +4333,7 @@ rtx\n mips_subword (rtx op, bool high_p)\n {\n   unsigned int byte, offset;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = GET_MODE (op);\n   if (mode == VOIDmode)\n@@ -4508,7 +4508,7 @@ const char *\n mips_output_move (rtx dest, rtx src)\n {\n   enum rtx_code dest_code, src_code;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum mips_symbol_type symbol_type;\n   bool dbl_p;\n \n@@ -4729,7 +4729,7 @@ mips_int_order_operand_ok_p (enum rtx_code code, rtx cmp1)\n \n static bool\n mips_canonicalize_int_order_test (enum rtx_code *code, rtx *cmp1,\n-\t\t\t\t  enum machine_mode mode)\n+\t\t\t\t  machine_mode mode)\n {\n   HOST_WIDE_INT plus_one;\n \n@@ -4774,7 +4774,7 @@ static void\n mips_emit_int_order_test (enum rtx_code code, bool *invert_ptr,\n \t\t\t  rtx target, rtx cmp0, rtx cmp1)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* First see if there is a MIPS instruction that can do this operation.\n      If not, try doing the same for the inverse operation.  If that also\n@@ -4878,7 +4878,7 @@ mips_reversed_fp_cond (enum rtx_code *code)\n    a simple round-robin allocation scheme.  */\n \n static rtx\n-mips_allocate_fcc (enum machine_mode mode)\n+mips_allocate_fcc (machine_mode mode)\n {\n   unsigned int regno, count;\n \n@@ -5066,7 +5066,7 @@ void\n mips_expand_conditional_trap (rtx comparison)\n {\n   rtx op0, op1;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   enum rtx_code code;\n \n   /* MIPS conditional trap instructions don't have GT or LE flavors,\n@@ -5116,7 +5116,7 @@ mips_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype)\n \n static void\n mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n-\t\t   enum machine_mode mode, const_tree type, bool named)\n+\t\t   machine_mode mode, const_tree type, bool named)\n {\n   bool doubleword_aligned_p;\n   unsigned int num_bytes, num_words, max_regs;\n@@ -5253,7 +5253,7 @@ mips_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-mips_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+mips_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -5266,7 +5266,7 @@ mips_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n   if (mode == VOIDmode)\n     {\n       if (TARGET_MIPS16 && cum->fp_code != 0)\n-\treturn gen_rtx_REG ((enum machine_mode) cum->fp_code, 0);\n+\treturn gen_rtx_REG ((machine_mode) cum->fp_code, 0);\n       else\n \treturn NULL;\n     }\n@@ -5349,7 +5349,7 @@ mips_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n       && GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n     {\n       rtx real, imag;\n-      enum machine_mode inner;\n+      machine_mode inner;\n       unsigned int regno;\n \n       inner = GET_MODE_INNER (mode);\n@@ -5380,7 +5380,7 @@ mips_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-mips_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+mips_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -5418,7 +5418,7 @@ mips_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n static int\n mips_arg_partial_bytes (cumulative_args_t cum,\n-\t\t\tenum machine_mode mode, tree type, bool named)\n+\t\t\tmachine_mode mode, tree type, bool named)\n {\n   struct mips_arg_info info;\n \n@@ -5431,7 +5431,7 @@ mips_arg_partial_bytes (cumulative_args_t cum,\n    to STACK_BOUNDARY bits if the type requires it.  */\n \n static unsigned int\n-mips_function_arg_boundary (enum machine_mode mode, const_tree type)\n+mips_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   unsigned int alignment;\n \n@@ -5449,7 +5449,7 @@ mips_function_arg_boundary (enum machine_mode mode, const_tree type)\n    byte does.  */\n \n bool\n-mips_pad_arg_upward (enum machine_mode mode, const_tree type)\n+mips_pad_arg_upward (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the first byte of every stack argument\n      is passed in the first byte of the stack slot.  */\n@@ -5487,7 +5487,7 @@ mips_pad_arg_upward (enum machine_mode mode, const_tree type)\n    the opposite if the most significant byte does.  */\n \n bool\n-mips_pad_reg_upward (enum machine_mode mode, tree type)\n+mips_pad_reg_upward (machine_mode mode, tree type)\n {\n   /* No shifting is required for floating-point arguments.  */\n   if (type != 0 ? FLOAT_TYPE_P (type) : GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -5502,7 +5502,7 @@ mips_pad_reg_upward (enum machine_mode mode, tree type)\n \n static bool\n mips_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode, const_tree type,\n+\t\t\tmachine_mode mode, const_tree type,\n \t\t\tbool named ATTRIBUTE_UNUSED)\n {\n   if (mips_abi == ABI_EABI)\n@@ -5529,7 +5529,7 @@ mips_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \n static bool\n mips_callee_copies (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    const_tree type ATTRIBUTE_UNUSED, bool named)\n {\n   return mips_abi == ABI_EABI && named;\n@@ -5598,7 +5598,7 @@ mips_return_in_msb (const_tree valtype)\n    floating-point register.  */\n \n static bool\n-mips_return_mode_in_fpr_p (enum machine_mode mode)\n+mips_return_mode_in_fpr_p (machine_mode mode)\n {\n   return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   || mode == V2SFmode\n@@ -5617,8 +5617,8 @@ mips_return_mode_in_fpr_p (enum machine_mode mode)\n    the structure itself has mode BLKmode.  */\n \n static rtx\n-mips_return_fpr_single (enum machine_mode type_mode,\n-\t\t\tenum machine_mode value_mode)\n+mips_return_fpr_single (machine_mode type_mode,\n+\t\t\tmachine_mode value_mode)\n {\n   rtx x;\n \n@@ -5640,9 +5640,9 @@ mips_return_fpr_single (enum machine_mode type_mode,\n    Otherwise the values are packed together as closely as possible.  */\n \n static rtx\n-mips_return_fpr_pair (enum machine_mode mode,\n-\t\t      enum machine_mode mode1, HOST_WIDE_INT offset1,\n-\t\t      enum machine_mode mode2, HOST_WIDE_INT offset2)\n+mips_return_fpr_pair (machine_mode mode,\n+\t\t      machine_mode mode1, HOST_WIDE_INT offset1,\n+\t\t      machine_mode mode2, HOST_WIDE_INT offset2)\n {\n   int inc;\n \n@@ -5665,7 +5665,7 @@ mips_return_fpr_pair (enum machine_mode mode,\n \n static rtx\n mips_function_value_1 (const_tree valtype, const_tree fn_decl_or_type,\n-\t\t       enum machine_mode mode)\n+\t\t       machine_mode mode)\n {\n   if (valtype)\n     {\n@@ -5755,7 +5755,7 @@ mips_function_value (const_tree valtype, const_tree fn_decl_or_type,\n /* Implement TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-mips_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+mips_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return mips_function_value_1 (NULL_TREE, NULL_TREE, mode);\n }\n@@ -5795,7 +5795,7 @@ mips_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-mips_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+mips_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t     int no_rtl)\n {\n@@ -5834,7 +5834,7 @@ mips_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t{\n \t  /* We can't use move_block_from_reg, because it will use\n \t     the wrong mode.  */\n-\t  enum machine_mode mode;\n+\t  machine_mode mode;\n \t  int off, i;\n \n \t  /* Set OFF to the offset from virtual_incoming_args_rtx of\n@@ -6471,7 +6471,7 @@ static struct mips16_stub *mips16_stubs;\n    return mode MODE in the name of a MIPS16 function stub.  */\n \n static const char *\n-mips16_call_stub_mode_suffix (enum machine_mode mode)\n+mips16_call_stub_mode_suffix (machine_mode mode)\n {\n   if (mode == SFmode)\n     return \"sf\";\n@@ -6542,7 +6542,7 @@ mips_output_args_xfer (int fp_code, char direction)\n \n   for (f = (unsigned int) fp_code; f != 0; f >>= 2)\n     {\n-      enum machine_mode mode;\n+      machine_mode mode;\n       struct mips_arg_info info;\n \n       if ((f & 3) == 1)\n@@ -6667,7 +6667,7 @@ mips16_copy_fpr_return_value (void)\n {\n   rtx fn, insn, retval;\n   tree return_type;\n-  enum machine_mode return_mode;\n+  machine_mode return_mode;\n   const char *name;\n \n   return_type = DECL_RESULT (current_function_decl);\n@@ -7267,7 +7267,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n   HOST_WIDE_INT offset, delta;\n   unsigned HOST_WIDE_INT bits;\n   int i;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx *regs;\n \n   /* Work out how many bits to move at a time.  If both operands have\n@@ -7489,7 +7489,7 @@ mips_expand_atomic_qihi (union mips_gen_fn_ptrs generator,\n   rtx orig_addr, memsi_addr, memsi, shift, shiftsi, unshifted_mask;\n   rtx unshifted_mask_reg, mask, inverted_mask, si_op;\n   rtx res = NULL;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   mode = GET_MODE (mem);\n \n@@ -7674,7 +7674,7 @@ mips_expand_ins_as_unaligned_store (rtx dest, rtx src, HOST_WIDE_INT width,\n \t\t\t\t    HOST_WIDE_INT bitpos)\n {\n   rtx left, right;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (!mips_get_unaligned_mem (dest, width, bitpos, &left, &right))\n     return false;\n@@ -7697,7 +7697,7 @@ mips_expand_ins_as_unaligned_store (rtx dest, rtx src, HOST_WIDE_INT width,\n /* Return true if X is a MEM with the same size as MODE.  */\n \n bool\n-mips_mem_fits_mode_p (enum machine_mode mode, rtx x)\n+mips_mem_fits_mode_p (machine_mode mode, rtx x)\n {\n   return (MEM_P (x)\n \t  && MEM_SIZE_KNOWN_P (x)\n@@ -7739,7 +7739,7 @@ mips_use_ins_ext_p (rtx op, HOST_WIDE_INT width, HOST_WIDE_INT bitpos)\n    mask_low_and_shift_len for the actual definition.  */\n \n bool\n-mask_low_and_shift_p (enum machine_mode mode, rtx mask, rtx shift, int maxlen)\n+mask_low_and_shift_p (machine_mode mode, rtx mask, rtx shift, int maxlen)\n {\n   return IN_RANGE (mask_low_and_shift_len (mode, mask, shift), 1, maxlen);\n }\n@@ -7749,7 +7749,7 @@ mask_low_and_shift_p (enum machine_mode mode, rtx mask, rtx shift, int maxlen)\n    see the table in the comment before the pattern.  */\n \n bool\n-and_operands_ok (enum machine_mode mode, rtx op1, rtx op2)\n+and_operands_ok (machine_mode mode, rtx op1, rtx op2)\n {\n   return (memory_operand (op1, mode)\n \t  ? and_load_operand (op2, mode)\n@@ -7763,7 +7763,7 @@ and_operands_ok (enum machine_mode mode, rtx op1, rtx op2)\n    return the length of the mask, otherwise return -1.  */\n \n int\n-mask_low_and_shift_len (enum machine_mode mode, rtx mask, rtx shift)\n+mask_low_and_shift_len (machine_mode mode, rtx mask, rtx shift)\n {\n   HOST_WIDE_INT shval;\n \n@@ -8413,7 +8413,7 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n /* Implement TARGET_SELECT_RTX_SECTION.  */\n \n static section *\n-mips_select_rtx_section (enum machine_mode mode, rtx x,\n+mips_select_rtx_section (machine_mode mode, rtx x,\n \t\t\t unsigned HOST_WIDE_INT align)\n {\n   /* ??? Consider using mergeable small data sections.  */\n@@ -8661,7 +8661,7 @@ static rtx\n mips_dwarf_register_span (rtx reg)\n {\n   rtx high, low;\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* By default, GCC maps increasing register numbers to increasing\n      memory locations, but paired FPRs are always little-endian,\n@@ -10429,7 +10429,7 @@ typedef void (*mips_save_restore_fn) (rtx, rtx);\n    stack pointer.  */\n \n static void\n-mips_save_restore_reg (enum machine_mode mode, int regno,\n+mips_save_restore_reg (machine_mode mode, int regno,\n \t\t       HOST_WIDE_INT offset, mips_save_restore_fn fn)\n {\n   rtx mem;\n@@ -10595,7 +10595,7 @@ static void\n mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,\n \t\t\t\t mips_save_restore_fn fn)\n {\n-  enum machine_mode fpr_mode;\n+  machine_mode fpr_mode;\n   int regno;\n   const struct mips_frame_info *frame = &cfun->machine->frame;\n   HOST_WIDE_INT offset;\n@@ -11723,7 +11723,7 @@ mips_can_use_return_insn (void)\n    The result of this function is cached in mips_hard_regno_mode_ok.  */\n \n static bool\n-mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n+mips_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n {\n   unsigned int size;\n   enum mode_class mclass;\n@@ -11813,7 +11813,7 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n /* Implement HARD_REGNO_NREGS.  */\n \n unsigned int\n-mips_hard_regno_nregs (int regno, enum machine_mode mode)\n+mips_hard_regno_nregs (int regno, machine_mode mode)\n {\n   if (ST_REG_P (regno))\n     /* The size of FP status registers is always 4, because they only hold\n@@ -11831,7 +11831,7 @@ mips_hard_regno_nregs (int regno, enum machine_mode mode)\n    in mips_hard_regno_nregs.  */\n \n int\n-mips_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n+mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n {\n   int size;\n   HARD_REG_SET left;\n@@ -11858,8 +11858,8 @@ mips_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n /* Implement CANNOT_CHANGE_MODE_CLASS.  */\n \n bool\n-mips_cannot_change_mode_class (enum machine_mode from,\n-\t\t\t       enum machine_mode to,\n+mips_cannot_change_mode_class (machine_mode from,\n+\t\t\t       machine_mode to,\n \t\t\t       enum reg_class rclass)\n {\n   /* Allow conversions between different Loongson integer vectors,\n@@ -11897,7 +11897,7 @@ mips_cannot_change_mode_class (enum machine_mode from,\n /* Implement target hook small_register_classes_for_mode_p.  */\n \n static bool\n-mips_small_register_classes_for_mode_p (enum machine_mode mode\n+mips_small_register_classes_for_mode_p (machine_mode mode\n \t\t\t\t\tATTRIBUTE_UNUSED)\n {\n   return TARGET_MIPS16;\n@@ -11906,7 +11906,7 @@ mips_small_register_classes_for_mode_p (enum machine_mode mode\n /* Return true if moves in mode MODE can use the FPU's mov.fmt instruction.  */\n \n static bool\n-mips_mode_ok_for_mov_fmt_p (enum machine_mode mode)\n+mips_mode_ok_for_mov_fmt_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -11927,7 +11927,7 @@ mips_mode_ok_for_mov_fmt_p (enum machine_mode mode)\n /* Implement MODES_TIEABLE_P.  */\n \n bool\n-mips_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+mips_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   /* FPRs allow no mode punning, so it's not worth tying modes if we'd\n      prefer to put one of them in FPRs.  */\n@@ -12048,7 +12048,7 @@ mips_move_from_gpr_cost (reg_class_t to)\n    the maximum for us.  */\n \n static int\n-mips_register_move_cost (enum machine_mode mode,\n+mips_register_move_cost (machine_mode mode,\n \t\t\t reg_class_t from, reg_class_t to)\n {\n   reg_class_t dregs;\n@@ -12099,7 +12099,7 @@ mips_register_priority (int hard_regno)\n /* Implement TARGET_MEMORY_MOVE_COST.  */\n \n static int\n-mips_memory_move_cost (enum machine_mode mode, reg_class_t rclass, bool in)\n+mips_memory_move_cost (machine_mode mode, reg_class_t rclass, bool in)\n {\n   return (mips_cost->memory_latency\n \t  + memory_move_secondary_cost (mode, rclass, in));\n@@ -12113,7 +12113,7 @@ mips_memory_move_cost (enum machine_mode mode, reg_class_t rclass, bool in)\n \n enum reg_class\n mips_secondary_reload_class (enum reg_class rclass,\n-\t\t\t     enum machine_mode mode, rtx x, bool)\n+\t\t\t     machine_mode mode, rtx x, bool)\n {\n   int regno;\n \n@@ -12174,7 +12174,7 @@ mips_secondary_reload_class (enum reg_class rclass,\n /* Implement TARGET_MODE_REP_EXTENDED.  */\n \n static int\n-mips_mode_rep_extended (enum machine_mode mode, enum machine_mode mode_rep)\n+mips_mode_rep_extended (machine_mode mode, machine_mode mode_rep)\n {\n   /* On 64-bit targets, SImode register values are sign-extended to DImode.  */\n   if (TARGET_64BIT && mode == SImode && mode_rep == DImode)\n@@ -12186,15 +12186,15 @@ mips_mode_rep_extended (enum machine_mode mode, enum machine_mode mode_rep)\n /* Implement TARGET_VALID_POINTER_MODE.  */\n \n static bool\n-mips_valid_pointer_mode (enum machine_mode mode)\n+mips_valid_pointer_mode (machine_mode mode)\n {\n   return mode == SImode || (TARGET_64BIT && mode == DImode);\n }\n \n /* Implement TARGET_VECTOR_MODE_SUPPORTED_P.  */\n \n static bool\n-mips_vector_mode_supported_p (enum machine_mode mode)\n+mips_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -12224,7 +12224,7 @@ mips_vector_mode_supported_p (enum machine_mode mode)\n /* Implement TARGET_SCALAR_MODE_SUPPORTED_P.  */\n \n static bool\n-mips_scalar_mode_supported_p (enum machine_mode mode)\n+mips_scalar_mode_supported_p (machine_mode mode)\n {\n   if (ALL_FIXED_POINT_MODE_P (mode)\n       && GET_MODE_PRECISION (mode) <= 2 * BITS_PER_WORD)\n@@ -12235,8 +12235,8 @@ mips_scalar_mode_supported_p (enum machine_mode mode)\n \f\n /* Implement TARGET_VECTORIZE_PREFERRED_SIMD_MODE.  */\n \n-static enum machine_mode\n-mips_preferred_simd_mode (enum machine_mode mode ATTRIBUTE_UNUSED)\n+static machine_mode\n+mips_preferred_simd_mode (machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (TARGET_PAIRED_SINGLE_FLOAT\n       && mode == SFmode)\n@@ -14230,7 +14230,7 @@ static GTY(()) tree mips_builtin_decls[ARRAY_SIZE (mips_builtins)];\n    of the vector itself.  */\n \n static tree\n-mips_builtin_vector_type (tree type, enum machine_mode mode)\n+mips_builtin_vector_type (tree type, machine_mode mode)\n {\n   static tree types[2 * (int) MAX_MACHINE_MODE];\n   int mode_index;\n@@ -14574,7 +14574,7 @@ mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n \n static rtx\n mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t     enum machine_mode mode, int ignore)\n+\t\t     machine_mode mode, int ignore)\n {\n   tree fndecl;\n   unsigned int fcode, avail;\n@@ -14625,7 +14625,7 @@ struct mips16_constant {\n   struct mips16_constant *next;\n   rtx value;\n   rtx_code_label *label;\n-  enum machine_mode mode;\n+  machine_mode mode;\n };\n \n /* Information about an incomplete MIPS16 constant pool.  FIRST is the\n@@ -14643,7 +14643,7 @@ struct mips16_constant_pool {\n \n static rtx_code_label *\n mips16_add_constant (struct mips16_constant_pool *pool,\n-\t\t     rtx value, enum machine_mode mode)\n+\t\t     rtx value, machine_mode mode)\n {\n   struct mips16_constant **p, *c;\n   bool first_of_size_p;\n@@ -14699,7 +14699,7 @@ mips16_add_constant (struct mips16_constant_pool *pool,\n    instruction emitted.  MODE is the mode of the constant.  */\n \n static rtx_insn *\n-mips16_emit_constants_1 (enum machine_mode mode, rtx value, rtx_insn *insn)\n+mips16_emit_constants_1 (machine_mode mode, rtx value, rtx_insn *insn)\n {\n   if (SCALAR_INT_MODE_P (mode) || ALL_SCALAR_FIXED_POINT_MODE_P (mode))\n     {\n@@ -15062,7 +15062,7 @@ r10k_safe_mem_expr_p (tree expr, unsigned HOST_WIDE_INT offset)\n {\n   HOST_WIDE_INT bitoffset, bitsize;\n   tree inner, var_offset;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsigned_p, volatile_p;\n \n   inner = get_inner_reference (expr, &bitsize, &bitoffset, &var_offset, &mode,\n@@ -15728,7 +15728,7 @@ mips_mult_zero_zero_cost (struct mips_sim *state, bool setting)\n   mips_tuning_info.fast_mult_zero_zero_p = setting;\n   start_sequence ();\n \n-  enum machine_mode dword_mode = TARGET_64BIT ? TImode : DImode;\n+  machine_mode dword_mode = TARGET_64BIT ? TImode : DImode;\n   rtx hilo = gen_rtx_REG (dword_mode, MD_REG_FIRST);\n   mips_emit_move_or_split (hilo, const0_rtx, SPLIT_FOR_SPEED);\n \n@@ -17288,7 +17288,7 @@ mips_option_override (void)\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n       mips_hard_regno_mode_ok[mode][regno]\n-\t= mips_hard_regno_mode_ok_p (regno, (enum machine_mode) mode);\n+\t= mips_hard_regno_mode_ok_p (regno, (machine_mode) mode);\n \n   /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;\n@@ -18105,7 +18105,7 @@ void mips_function_profiler (FILE *file)\n    when TARGET_LOONGSON_VECTORS is true.  */\n \n static unsigned HOST_WIDE_INT\n-mips_shift_truncation_mask (enum machine_mode mode)\n+mips_shift_truncation_mask (machine_mode mode)\n {\n   if (TARGET_LOONGSON_VECTORS && VECTOR_MODE_P (mode))\n     return 0;\n@@ -18150,7 +18150,7 @@ struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n   unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n+  machine_mode vmode;\n   unsigned char nelt;\n   bool one_vector_p;\n   bool testing_p;\n@@ -18189,7 +18189,7 @@ static bool\n mips_expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n \t\t\t     const unsigned char *perm, unsigned nelt)\n {\n-  enum machine_mode v2mode;\n+  machine_mode v2mode;\n   rtx x;\n \n   v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n@@ -18463,7 +18463,7 @@ mips_expand_vec_perm_const (rtx operands[4])\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n \n static bool\n-mips_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+mips_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t  const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n@@ -18508,7 +18508,7 @@ mips_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n void\n mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n {\n-  enum machine_mode imode = GET_MODE (operands[1]);\n+  machine_mode imode = GET_MODE (operands[1]);\n   rtx (*unpack) (rtx, rtx, rtx);\n   rtx (*cmpgt) (rtx, rtx, rtx);\n   rtx tmp, dest, zero;\n@@ -18559,7 +18559,7 @@ mips_constant_elt_p (rtx x)\n /* A subroutine of mips_expand_vec_init, expand via broadcast.  */\n \n static void\n-mips_expand_vi_broadcast (enum machine_mode vmode, rtx target, rtx elt)\n+mips_expand_vi_broadcast (machine_mode vmode, rtx target, rtx elt)\n {\n   struct expand_vec_perm_d d;\n   rtx t1;\n@@ -18599,7 +18599,7 @@ mips_expand_vi_broadcast (enum machine_mode vmode, rtx target, rtx elt)\n    elements of VALS with zeros, copy the constant vector to TARGET.  */\n \n static void\n-mips_expand_vi_constant (enum machine_mode vmode, unsigned nelt,\n+mips_expand_vi_constant (machine_mode vmode, unsigned nelt,\n \t\t\t rtx target, rtx vals)\n {\n   rtvec vec = shallow_copy_rtvec (XVEC (vals, 0));\n@@ -18629,7 +18629,7 @@ mips_expand_vi_loongson_one_pinsrh (rtx target, rtx vals, unsigned one_var)\n /* A subroutine of mips_expand_vec_init, expand anything via memory.  */\n \n static void\n-mips_expand_vi_general (enum machine_mode vmode, enum machine_mode imode,\n+mips_expand_vi_general (machine_mode vmode, machine_mode imode,\n \t\t\tunsigned nelt, unsigned nvar, rtx target, rtx vals)\n {\n   rtx mem = assign_stack_temp (vmode, GET_MODE_SIZE (vmode));\n@@ -18653,8 +18653,8 @@ mips_expand_vi_general (enum machine_mode vmode, enum machine_mode imode,\n void\n mips_expand_vector_init (rtx target, rtx vals)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n-  enum machine_mode imode = GET_MODE_INNER (vmode);\n+  machine_mode vmode = GET_MODE (target);\n+  machine_mode imode = GET_MODE_INNER (vmode);\n   unsigned i, nelt = GET_MODE_NUNITS (vmode);\n   unsigned nvar = 0, one_var = -1u;\n   bool all_same = true;\n@@ -18711,7 +18711,7 @@ mips_expand_vector_init (rtx target, rtx vals)\n void\n mips_expand_vec_reduc (rtx target, rtx in, rtx (*gen)(rtx, rtx, rtx))\n {\n-  enum machine_mode vmode = GET_MODE (in);\n+  machine_mode vmode = GET_MODE (in);\n   unsigned char perm2[2];\n   rtx last, next, fold, x;\n   bool ok;\n@@ -18783,7 +18783,7 @@ void\n mips_expand_vec_minmax (rtx target, rtx op0, rtx op1,\n \t\t\trtx (*cmp) (rtx, rtx, rtx), bool min_p)\n {\n-  enum machine_mode vmode = GET_MODE (target);\n+  machine_mode vmode = GET_MODE (target);\n   rtx tc, t0, t1, x;\n \n   tc = gen_reg_rtx (vmode);\n@@ -18863,7 +18863,7 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n \n static reg_class_t\n mips_spill_class (reg_class_t rclass ATTRIBUTE_UNUSED,\n-\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (TARGET_MIPS16)\n     return SPILL_REGS;"}, {"sha": "3e54eb41afbe27ccfa5702089f44556d6fdfc70e", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -24,7 +24,7 @@ extern int mmix_initial_elimination_offset (int, int);\n extern int mmix_starting_frame_offset (void);\n extern int mmix_function_arg_regno_p (int, int);\n extern void mmix_function_profiler (FILE *, int);\n-extern int mmix_reversible_cc_mode (enum machine_mode);\n+extern int mmix_reversible_cc_mode (machine_mode);\n extern const char *mmix_text_section_asm_op (void);\n extern const char *mmix_data_section_asm_op (void);\n extern void mmix_output_quoted_string (FILE *, const char *, int);\n@@ -57,21 +57,21 @@ extern void mmix_asm_declare_register_global\n extern void mmix_asm_output_addr_diff_elt (FILE *, rtx, int, int);\n extern void mmix_asm_output_addr_vec_elt (FILE *, int);\n extern enum reg_class mmix_secondary_reload_class\n-  (enum reg_class, enum machine_mode, rtx, int);\n+  (enum reg_class, machine_mode, rtx, int);\n extern rtx mmix_dynamic_chain_address (rtx);\n extern rtx mmix_return_addr_rtx (int, rtx);\n extern rtx mmix_eh_return_stackadj_rtx (void);\n extern rtx mmix_eh_return_handler_rtx (void);\n extern int mmix_constant_address_p (rtx);\n extern void mmix_expand_prologue (void);\n extern void mmix_expand_epilogue (void);\n-extern rtx mmix_get_hard_reg_initial_val (enum machine_mode, int);\n+extern rtx mmix_get_hard_reg_initial_val (machine_mode, int);\n extern int mmix_asm_preferred_eh_data_format (int, int);\n extern void mmix_setup_frame_addresses (void);\n \n #ifdef RTX_CODE\n /* Needs to be ifdef:d for sake of enum rtx_code.  */\n-extern enum machine_mode mmix_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern machine_mode mmix_select_cc_mode (enum rtx_code, rtx, rtx);\n extern void mmix_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n extern rtx mmix_gen_compare_reg (enum rtx_code, rtx, rtx);\n #endif"}, {"sha": "c143c8fd1f4d8afc26fb7a38423fea985525fe0e", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -144,35 +144,35 @@ static void mmix_target_asm_function_end_prologue (FILE *);\n static void mmix_target_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n static reg_class_t mmix_preferred_reload_class (rtx, reg_class_t);\n static reg_class_t mmix_preferred_output_reload_class (rtx, reg_class_t);\n-static bool mmix_legitimate_address_p (enum machine_mode, rtx, bool);\n-static bool mmix_legitimate_constant_p (enum machine_mode, rtx);\n+static bool mmix_legitimate_address_p (machine_mode, rtx, bool);\n+static bool mmix_legitimate_constant_p (machine_mode, rtx);\n static void mmix_reorg (void);\n static void mmix_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void mmix_setup_incoming_varargs\n-  (cumulative_args_t, enum machine_mode, tree, int *, int);\n+  (cumulative_args_t, machine_mode, tree, int *, int);\n static void mmix_file_start (void);\n static void mmix_file_end (void);\n static bool mmix_rtx_costs (rtx, int, int, int, int *, bool);\n-static int mmix_register_move_cost (enum machine_mode,\n+static int mmix_register_move_cost (machine_mode,\n \t\t\t\t    reg_class_t, reg_class_t);\n static rtx mmix_struct_value_rtx (tree, int);\n-static enum machine_mode mmix_promote_function_mode (const_tree,\n-\t\t\t\t\t\t     enum machine_mode,\n+static machine_mode mmix_promote_function_mode (const_tree,\n+\t\t\t\t\t\t     machine_mode,\n \t                                             int *, const_tree, int);\n-static void mmix_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void mmix_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg_1 (const cumulative_args_t, enum machine_mode,\n+static rtx mmix_function_arg_1 (const cumulative_args_t, machine_mode,\n \t\t\t\tconst_tree, bool, bool);\n-static rtx mmix_function_incoming_arg (cumulative_args_t, enum machine_mode,\n+static rtx mmix_function_incoming_arg (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static rtx mmix_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx mmix_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static rtx mmix_function_value (const_tree, const_tree, bool);\n-static rtx mmix_libcall_value (enum machine_mode, const_rtx);\n+static rtx mmix_libcall_value (machine_mode, const_rtx);\n static bool mmix_function_value_regno_p (const unsigned int);\n static bool mmix_pass_by_reference (cumulative_args_t,\n-\t\t\t\t    enum machine_mode, const_tree, bool);\n+\t\t\t\t    machine_mode, const_tree, bool);\n static bool mmix_frame_pointer_required (void);\n static void mmix_asm_trampoline_template (FILE *);\n static void mmix_trampoline_init (rtx, tree, rtx);\n@@ -479,7 +479,7 @@ mmix_preferred_output_reload_class (rtx x, reg_class_t rclass)\n \n enum reg_class\n mmix_secondary_reload_class (enum reg_class rclass,\n-\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     rtx x ATTRIBUTE_UNUSED,\n \t\t\t     int in_p ATTRIBUTE_UNUSED)\n {\n@@ -600,7 +600,7 @@ mmix_initial_elimination_offset (int fromreg, int toreg)\n }\n \n static void\n-mmix_function_arg_advance (cumulative_args_t argsp_v, enum machine_mode mode,\n+mmix_function_arg_advance (cumulative_args_t argsp_v, machine_mode mode,\n \t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n@@ -618,7 +618,7 @@ mmix_function_arg_advance (cumulative_args_t argsp_v, enum machine_mode mode,\n \n static rtx\n mmix_function_arg_1 (const cumulative_args_t argsp_v,\n-\t\t     enum machine_mode mode,\n+\t\t     machine_mode mode,\n \t\t     const_tree type,\n \t\t     bool named ATTRIBUTE_UNUSED,\n \t\t     bool incoming)\n@@ -652,7 +652,7 @@ mmix_function_arg_1 (const cumulative_args_t argsp_v,\n \n static rtx\n mmix_function_arg (cumulative_args_t argsp,\n-\t\t   enum machine_mode mode,\n+\t\t   machine_mode mode,\n \t\t   const_tree type,\n \t\t   bool named)\n {\n@@ -661,7 +661,7 @@ mmix_function_arg (cumulative_args_t argsp,\n \n static rtx\n mmix_function_incoming_arg (cumulative_args_t argsp,\n-\t\t\t    enum machine_mode mode,\n+\t\t\t    machine_mode mode,\n \t\t\t    const_tree type,\n \t\t\t    bool named)\n {\n@@ -672,7 +672,7 @@ mmix_function_incoming_arg (cumulative_args_t argsp,\n    everything that goes by value.  */\n \n static bool\n-mmix_pass_by_reference (cumulative_args_t argsp_v, enum machine_mode mode,\n+mmix_pass_by_reference (cumulative_args_t argsp_v, machine_mode mode,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n@@ -710,8 +710,8 @@ mmix_function_value (const_tree valtype,\n \t\t     const_tree func ATTRIBUTE_UNUSED,\n \t\t     bool outgoing)\n {\n-  enum machine_mode mode = TYPE_MODE (valtype);\n-  enum machine_mode cmode;\n+  machine_mode mode = TYPE_MODE (valtype);\n+  machine_mode cmode;\n   int first_val_regnum = MMIX_OUTGOING_RETURN_VALUE_REGNUM;\n   rtx vec[MMIX_MAX_REGS_FOR_VALUE];\n   int i;\n@@ -774,7 +774,7 @@ mmix_function_value (const_tree valtype,\n /* Implements TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-mmix_libcall_value (enum machine_mode mode,\n+mmix_libcall_value (machine_mode mode,\n \t\t    const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, MMIX_RETURN_VALUE_REGNUM);\n@@ -940,7 +940,7 @@ mmix_function_profiler (FILE *stream ATTRIBUTE_UNUSED,\n \n static void\n mmix_setup_incoming_varargs (cumulative_args_t args_so_farp_v,\n-\t\t\t     enum machine_mode mode,\n+\t\t\t     machine_mode mode,\n \t\t\t     tree vartype,\n \t\t\t     int *pretend_sizep,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n@@ -1064,7 +1064,7 @@ mmix_constant_address_p (rtx x)\n /* Return 1 if the address is OK, otherwise 0.  */\n \n bool\n-mmix_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+mmix_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   rtx x,\n \t\t\t   bool strict_checking)\n {\n@@ -1124,7 +1124,7 @@ mmix_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool\n-mmix_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+mmix_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -1139,7 +1139,7 @@ mmix_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \n /* SELECT_CC_MODE.  */\n \n-enum machine_mode\n+machine_mode\n mmix_select_cc_mode (RTX_CODE op, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n   /* We use CCmode, CC_UNSmode, CC_FPmode, CC_FPEQmode and CC_FUNmode to\n@@ -1167,7 +1167,7 @@ mmix_select_cc_mode (RTX_CODE op, rtx x, rtx y ATTRIBUTE_UNUSED)\n /* REVERSIBLE_CC_MODE.  */\n \n int\n-mmix_reversible_cc_mode (enum machine_mode mode)\n+mmix_reversible_cc_mode (machine_mode mode)\n {\n   /* That is, all integer and the EQ, NE, ORDERED and UNORDERED float\n      compares.  */\n@@ -1196,7 +1196,7 @@ mmix_rtx_costs (rtx x ATTRIBUTE_UNUSED,\n    need to check that their constraints match, so say 3 for them.  */\n \n static int\n-mmix_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+mmix_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t reg_class_t from,\n \t\t\t reg_class_t to)\n {\n@@ -1902,7 +1902,7 @@ mmix_dbx_register_number (unsigned regno)\n    from insn-emit.c.  */\n \n rtx\n-mmix_get_hard_reg_initial_val (enum machine_mode mode, int regno)\n+mmix_get_hard_reg_initial_val (machine_mode mode, int regno)\n {\n   return get_hard_reg_initial_val (mode, regno);\n }\n@@ -2447,7 +2447,7 @@ mmix_shiftable_wyde_value (uint64_t value)\n rtx\n mmix_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n {\n-  enum machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n+  machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n   return gen_reg_rtx (ccmode);\n }\n \n@@ -2611,7 +2611,7 @@ mmix_output_condition (FILE *stream, const_rtx x, int reversed)\n \n   struct cc_type_conv\n   {\n-    enum machine_mode cc_mode;\n+    machine_mode cc_mode;\n \n     /* Terminated with {UNKNOWN, NULL, NULL} */\n     const struct cc_conv *const convs;\n@@ -2669,7 +2669,7 @@ mmix_output_condition (FILE *stream, const_rtx x, int reversed)\n   size_t i;\n   int j;\n \n-  enum machine_mode mode = GET_MODE (XEXP (x, 0));\n+  machine_mode mode = GET_MODE (XEXP (x, 0));\n   RTX_CODE cc = GET_CODE (x);\n \n   for (i = 0; i < ARRAY_SIZE (cc_convs); i++)\n@@ -2747,9 +2747,9 @@ mmix_intval (const_rtx x)\n \n /* Worker function for TARGET_PROMOTE_FUNCTION_MODE.  */\n \n-enum machine_mode\n+machine_mode\n mmix_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n-                            enum machine_mode mode,\n+                            machine_mode mode,\n                             int *punsignedp ATTRIBUTE_UNUSED,\n                             const_tree fntype ATTRIBUTE_UNUSED,\n                             int for_return)"}, {"sha": "14bd9013da84dd2742ecacb673911d6c7495b9b9", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -21,22 +21,22 @@\n #ifdef RTX_CODE\n extern rtx   mn10300_legitimize_pic_address (rtx, rtx);\n extern int   mn10300_legitimate_pic_operand_p (rtx);\n-extern rtx   mn10300_legitimize_reload_address (rtx, enum machine_mode,\n+extern rtx   mn10300_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t\tint, int, int);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n extern unsigned int   mn10300_get_live_callee_saved_regs (unsigned int *);\n-extern bool  mn10300_hard_regno_mode_ok (unsigned int, enum machine_mode);\n-extern bool  mn10300_modes_tieable (enum machine_mode, enum machine_mode);\n+extern bool  mn10300_hard_regno_mode_ok (unsigned int, machine_mode);\n+extern bool  mn10300_modes_tieable (machine_mode, machine_mode);\n extern const char *mn10300_output_add (rtx[3], bool);\n extern void  mn10300_print_operand (FILE *, rtx, int);\n extern void  mn10300_print_operand_address (FILE *, rtx);\n extern void  mn10300_print_reg_list (FILE *, int);\n-extern enum machine_mode mn10300_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern machine_mode mn10300_select_cc_mode (enum rtx_code, rtx, rtx);\n extern unsigned int mn10300_store_multiple_regs (rtx);\n-extern int   mn10300_symbolic_operand (rtx, enum machine_mode);\n-extern void  mn10300_split_cbranch (enum machine_mode, rtx, rtx);\n+extern int   mn10300_symbolic_operand (rtx, machine_mode);\n+extern void  mn10300_split_cbranch (machine_mode, rtx, rtx);\n extern int   mn10300_split_and_operand_count (rtx);\n-extern bool  mn10300_match_ccmode (rtx, enum machine_mode);\n+extern bool  mn10300_match_ccmode (rtx, machine_mode);\n #endif /* RTX_CODE */\n \n extern bool  mn10300_regno_in_class_p (unsigned, int, bool);"}, {"sha": "3f9a7becda6c4a1df43be4866964df01903772fb", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -79,7 +79,7 @@ enum processor_type mn10300_tune_cpu = PROCESSOR_DEFAULT;\n #define CC_FLAG_C\t4\n #define CC_FLAG_V\t8\n \n-static int cc_flags_for_mode(enum machine_mode);\n+static int cc_flags_for_mode(machine_mode);\n static int cc_flags_for_code(enum rtx_code);\n \f\n /* Implement TARGET_OPTION_OVERRIDE.  */\n@@ -160,7 +160,7 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n     case 'B':\n       {\n \tenum rtx_code cmp = GET_CODE (x);\n-\tenum machine_mode mode = GET_MODE (XEXP (x, 0));\n+\tmachine_mode mode = GET_MODE (XEXP (x, 0));\n \tconst char *str;\n \tint have_flags;\n \n@@ -1369,7 +1369,7 @@ mn10300_preferred_output_reload_class (rtx x, reg_class_t rclass)\n \n static reg_class_t\n mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n-\t\t\t  enum machine_mode mode, secondary_reload_info *sri)\n+\t\t\t  machine_mode mode, secondary_reload_info *sri)\n {\n   enum reg_class rclass = (enum reg_class) rclass_i;\n   enum reg_class xclass = NO_REGS;\n@@ -1539,7 +1539,7 @@ mn10300_va_start (tree valist, rtx nextarg)\n \n static bool\n mn10300_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode, const_tree type,\n+\t\t\t   machine_mode mode, const_tree type,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n   unsigned HOST_WIDE_INT size;\n@@ -1556,7 +1556,7 @@ mn10300_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n    from a function.  If the result is NULL_RTX, the argument is pushed.  */\n \n static rtx\n-mn10300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+mn10300_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1605,7 +1605,7 @@ mn10300_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-mn10300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+mn10300_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1619,7 +1619,7 @@ mn10300_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n    partially in registers and partially in memory.  */\n \n static int\n-mn10300_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+mn10300_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t   tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1665,7 +1665,7 @@ mn10300_function_value (const_tree valtype,\n \t\t\tbool outgoing)\n {\n   rtx rv;\n-  enum machine_mode mode = TYPE_MODE (valtype);\n+  machine_mode mode = TYPE_MODE (valtype);\n \n   if (! POINTER_TYPE_P (valtype))\n     return gen_rtx_REG (mode, FIRST_DATA_REGNUM);\n@@ -1689,7 +1689,7 @@ mn10300_function_value (const_tree valtype,\n /* Implements TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-mn10300_libcall_value (enum machine_mode mode,\n+mn10300_libcall_value (machine_mode mode,\n \t\t       const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, FIRST_DATA_REGNUM);\n@@ -1801,7 +1801,7 @@ mn10300_output_add (rtx operands[3], bool need_flags)\n \n int\n mn10300_symbolic_operand (rtx op,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1833,7 +1833,7 @@ mn10300_symbolic_operand (rtx op,\n \n static rtx\n mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t    machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic && ! mn10300_legitimate_pic_operand_p (x))\n     x = mn10300_legitimize_pic_address (oldx, NULL_RTX);\n@@ -1964,7 +1964,7 @@ mn10300_legitimate_pic_operand_p (rtx x)\n    function record_unscaled_index_insn_codes.  */\n \n static bool\n-mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+mn10300_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   rtx base, index;\n \n@@ -2032,7 +2032,7 @@ mn10300_regno_in_class_p (unsigned regno, int rclass, bool strict)\n \n rtx\n mn10300_legitimize_reload_address (rtx x,\n-\t\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t   int opnum, int type,\n \t\t\t\t   int ind_levels ATTRIBUTE_UNUSED)\n {\n@@ -2069,7 +2069,7 @@ mn10300_legitimize_reload_address (rtx x,\n    those here.  */\n \n static bool\n-mn10300_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+mn10300_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2175,7 +2175,7 @@ mn10300_delegitimize_address (rtx orig_x)\n    with an address register.  */\n \n static int\n-mn10300_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n+mn10300_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      addr_space_t as ATTRIBUTE_UNUSED, bool speed)\n {\n   HOST_WIDE_INT i;\n@@ -2240,7 +2240,7 @@ mn10300_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n    early exit from reload meaning no work is required.  */\n \n static int\n-mn10300_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+mn10300_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    reg_class_t ifrom, reg_class_t ito)\n {\n   enum reg_class from = (enum reg_class) ifrom;\n@@ -2327,7 +2327,7 @@ mn10300_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    move cost above.  This is not a problem.  */\n \n static int\n-mn10300_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED, \n+mn10300_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED, \n \t\t\t  reg_class_t iclass, bool in ATTRIBUTE_UNUSED)\n {\n   enum reg_class rclass = (enum reg_class) iclass;\n@@ -2639,7 +2639,7 @@ mn10300_can_output_mi_thunk (const_tree    thunk_fndecl ATTRIBUTE_UNUSED,\n }\n \n bool\n-mn10300_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+mn10300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (REGNO_REG_CLASS (regno) == FP_REGS\n       || REGNO_REG_CLASS (regno) == FP_ACC_REGS)\n@@ -2661,7 +2661,7 @@ mn10300_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n }\n \n bool\n-mn10300_modes_tieable (enum machine_mode mode1, enum machine_mode mode2)\n+mn10300_modes_tieable (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == MODE_FLOAT\n       && GET_MODE_CLASS (mode2) != MODE_FLOAT)\n@@ -2680,7 +2680,7 @@ mn10300_modes_tieable (enum machine_mode mode1, enum machine_mode mode2)\n }\n \n static int\n-cc_flags_for_mode (enum machine_mode mode)\n+cc_flags_for_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -2738,7 +2738,7 @@ cc_flags_for_code (enum rtx_code code)\n     }\n }\n \n-enum machine_mode\n+machine_mode\n mn10300_select_cc_mode (enum rtx_code code, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n   int req;\n@@ -2884,7 +2884,7 @@ mn10300_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n /* A helper function for splitting cbranch patterns after reload.  */\n \n void\n-mn10300_split_cbranch (enum machine_mode cmp_mode, rtx cmp_op, rtx label_ref)\n+mn10300_split_cbranch (machine_mode cmp_mode, rtx cmp_op, rtx label_ref)\n {\n   rtx flags, x;\n \n@@ -2902,10 +2902,10 @@ mn10300_split_cbranch (enum machine_mode cmp_mode, rtx cmp_op, rtx label_ref)\n /* A helper function for matching parallels that set the flags.  */\n \n bool\n-mn10300_match_ccmode (rtx insn, enum machine_mode cc_mode)\n+mn10300_match_ccmode (rtx insn, machine_mode cc_mode)\n {\n   rtx op1, flags;\n-  enum machine_mode flags_mode;\n+  machine_mode flags_mode;\n \n   gcc_checking_assert (XVECLEN (PATTERN (insn), 0) == 2);\n "}, {"sha": "ef1ed8fb2cc3e4bf5a874bbad00f75eccebcf440", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -101,7 +101,7 @@ moxie_function_value (const_tree valtype,\n    We always return values in register $r0 for moxie.  */\n \n static rtx\n-moxie_libcall_value (enum machine_mode mode,\n+moxie_libcall_value (machine_mode mode,\n                      const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, MOXIE_R0);\n@@ -402,7 +402,7 @@ moxie_initial_elimination_offset (int from, int to)\n \n static void\n moxie_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t      tree type ATTRIBUTE_UNUSED,\n \t\t\t      int *pretend_size, int no_rtl)\n {\n@@ -441,7 +441,7 @@ moxie_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    NULL_RTX if there's no more space.  */\n \n static rtx\n-moxie_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+moxie_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t    bool named ATTRIBUTE_UNUSED)\n {\n@@ -458,7 +458,7 @@ moxie_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    : (unsigned) int_size_in_bytes (TYPE))\n \n static void\n-moxie_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+moxie_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -473,7 +473,7 @@ moxie_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n static bool\n moxie_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode, const_tree type,\n+\t\t\t machine_mode mode, const_tree type,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n   unsigned HOST_WIDE_INT size;\n@@ -496,7 +496,7 @@ moxie_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \n static int\n moxie_arg_partial_bytes (cumulative_args_t cum_v,\n-\t\t\t enum machine_mode mode,\n+\t\t\t machine_mode mode,\n \t\t\t tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);"}, {"sha": "88037d0efdfe722d8f357d3183d4de5f4f36fff7", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -27,25 +27,25 @@ void\tmsp430_expand_epilogue (int);\n void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n void\tmsp430_expand_prologue (void);\n const char * msp430x_extendhisi (rtx *);\n-void\tmsp430_fixup_compare_operands (enum machine_mode, rtx *);\n-int\tmsp430_hard_regno_mode_ok (int, enum machine_mode);\n-int\tmsp430_hard_regno_nregs (int, enum machine_mode);\n-int\tmsp430_hard_regno_nregs_has_padding (int, enum machine_mode);\n-int\tmsp430_hard_regno_nregs_with_padding (int, enum machine_mode);\n+void\tmsp430_fixup_compare_operands (machine_mode, rtx *);\n+int\tmsp430_hard_regno_mode_ok (int, machine_mode);\n+int\tmsp430_hard_regno_nregs (int, machine_mode);\n+int\tmsp430_hard_regno_nregs_has_padding (int, machine_mode);\n+int\tmsp430_hard_regno_nregs_with_padding (int, machine_mode);\n bool    msp430_hwmult_enabled (void);\n rtx\tmsp430_incoming_return_addr_rtx (void);\n void\tmsp430_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n int\tmsp430_initial_elimination_offset (int, int);\n bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n-bool\tmsp430_modes_tieable_p (enum machine_mode, enum machine_mode);\n+bool\tmsp430_modes_tieable_p (machine_mode, machine_mode);\n void\tmsp430_output_labelref (FILE *, const char *);\n void\tmsp430_register_pragmas (void);\n rtx\tmsp430_return_addr_rtx (int);\n void\tmsp430_split_movsi (rtx *);\n void    msp430_start_function (FILE *, const char *, tree);\n-rtx\tmsp430_subreg (enum machine_mode, rtx, enum machine_mode, int);\n+rtx\tmsp430_subreg (machine_mode, rtx, machine_mode, int);\n bool    msp430_use_f5_series_hwmult (void);\n \n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "703bf9b7ca558cea58b815229daf86cc1438af7b", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -246,7 +246,7 @@ msp430_option_override (void)\n #define TARGET_SCALAR_MODE_SUPPORTED_P msp430_scalar_mode_supported_p\n \n static bool\n-msp430_scalar_mode_supported_p (enum machine_mode m)\n+msp430_scalar_mode_supported_p (machine_mode m)\n {\n   if (m == PSImode && msp430x)\n     return true;\n@@ -278,7 +278,7 @@ msp430_ms_bitfield_layout_p (const_tree record_type ATTRIBUTE_UNUSED)\n    PSImode value, but not an SImode value.  */\n int\n msp430_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n   if (mode == PSImode && msp430x)\n     return 1;\n@@ -289,7 +289,7 @@ msp430_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n /* Implements HARD_REGNO_NREGS_HAS_PADDING.  */\n int\n msp430_hard_regno_nregs_has_padding (int regno ATTRIBUTE_UNUSED,\n-\t\t\t\t     enum machine_mode mode)\n+\t\t\t\t     machine_mode mode)\n {\n   if (mode == PSImode && msp430x)\n     return 1;\n@@ -300,7 +300,7 @@ msp430_hard_regno_nregs_has_padding (int regno ATTRIBUTE_UNUSED,\n /* Implements HARD_REGNO_NREGS_WITH_PADDING.  */\n int\n msp430_hard_regno_nregs_with_padding (int regno ATTRIBUTE_UNUSED,\n-\t\t\t\t     enum machine_mode mode)\n+\t\t\t\t     machine_mode mode)\n {\n   if (mode == PSImode)\n     return 2;\n@@ -310,14 +310,14 @@ msp430_hard_regno_nregs_with_padding (int regno ATTRIBUTE_UNUSED,\n /* Implements HARD_REGNO_MODE_OK.  */\n int\n msp430_hard_regno_mode_ok (int regno ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode)\n+\t\t\t   machine_mode mode)\n {\n   return regno <= (ARG_POINTER_REGNUM - msp430_hard_regno_nregs (regno, mode));\n }\n \n /* Implements MODES_TIEABLE_P.  */\n bool\n-msp430_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+msp430_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if ((mode1 == PSImode || mode2 == SImode)\n       || (mode1 == SImode || mode2 == PSImode))\n@@ -397,7 +397,7 @@ msp430_initial_elimination_offset (int from, int to)\n #undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE msp430_addr_space_pointer_mode\n \n-static enum machine_mode\n+static machine_mode\n msp430_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -417,7 +417,7 @@ msp430_addr_space_pointer_mode (addr_space_t addrspace)\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE msp430_unwind_word_mode\n \n-static enum machine_mode\n+static machine_mode\n msp430_unwind_word_mode (void)\n {\n   return TARGET_LARGE ? PSImode : HImode;\n@@ -533,7 +533,7 @@ msp430_function_value (const_tree ret_type,\n #define TARGET_LIBCALL_VALUE msp430_libcall_value\n \n rtx\n-msp430_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+msp430_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, 12);\n }\n@@ -566,7 +566,7 @@ msp430_init_cumulative_args (CUMULATIVE_ARGS *ca,\n    code that determines where an argument will be passed.  */\n static void\n msp430_evaluate_arg (cumulative_args_t cap,\n-\t\t     enum machine_mode mode,\n+\t\t     machine_mode mode,\n \t\t     const_tree type ATTRIBUTE_UNUSED,\n \t\t     bool named)\n {\n@@ -651,7 +651,7 @@ msp430_promote_prototypes (const_tree fntype ATTRIBUTE_UNUSED)\n \n rtx\n msp430_function_arg (cumulative_args_t cap,\n-\t\t     enum machine_mode mode,\n+\t\t     machine_mode mode,\n \t\t     const_tree type,\n \t\t     bool named)\n {\n@@ -670,7 +670,7 @@ msp430_function_arg (cumulative_args_t cap,\n \n int\n msp430_arg_partial_bytes (cumulative_args_t cap,\n-\t\t\t  enum machine_mode mode,\n+\t\t\t  machine_mode mode,\n \t\t\t  tree type,\n \t\t\t  bool named)\n {\n@@ -689,7 +689,7 @@ msp430_arg_partial_bytes (cumulative_args_t cap,\n \n static bool\n msp430_pass_by_reference (cumulative_args_t cap ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode,\n+\t\t\t  machine_mode mode,\n \t\t\t  const_tree type,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -703,7 +703,7 @@ msp430_pass_by_reference (cumulative_args_t cap ATTRIBUTE_UNUSED,\n \n static bool\n msp430_callee_copies (cumulative_args_t cap ATTRIBUTE_UNUSED,\n-                     enum machine_mode mode ATTRIBUTE_UNUSED,\n+                     machine_mode mode ATTRIBUTE_UNUSED,\n                      const_tree type ATTRIBUTE_UNUSED,\n                      bool named ATTRIBUTE_UNUSED)\n {\n@@ -715,7 +715,7 @@ msp430_callee_copies (cumulative_args_t cap ATTRIBUTE_UNUSED,\n \n void\n msp430_function_arg_advance (cumulative_args_t cap,\n-\t\t\t     enum machine_mode mode,\n+\t\t\t     machine_mode mode,\n \t\t\t     const_tree type,\n \t\t\t     bool named)\n {\n@@ -735,7 +735,7 @@ msp430_function_arg_advance (cumulative_args_t cap,\n #define TARGET_FUNCTION_ARG_BOUNDARY msp430_function_arg_boundary\n \n static unsigned int\n-msp430_function_arg_boundary (enum machine_mode mode, const_tree type)\n+msp430_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode\n       && int_size_in_bytes (type) > 1)\n@@ -751,7 +751,7 @@ msp430_function_arg_boundary (enum machine_mode mode, const_tree type)\n static bool\n msp430_return_in_memory (const_tree ret_type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = TYPE_MODE (ret_type);\n+  machine_mode mode = TYPE_MODE (ret_type);\n \n   if (mode == BLKmode\n       || (fntype && TREE_CODE (TREE_TYPE (fntype)) == RECORD_TYPE)\n@@ -767,7 +767,7 @@ msp430_return_in_memory (const_tree ret_type, const_tree fntype ATTRIBUTE_UNUSED\n #undef  TARGET_GET_RAW_ARG_MODE\n #define TARGET_GET_RAW_ARG_MODE msp430_get_raw_arg_mode\n \n-static enum machine_mode\n+static machine_mode\n msp430_get_raw_arg_mode (int regno)\n {\n   return (regno == ARG_POINTER_REGNUM) ? VOIDmode : Pmode;\n@@ -776,7 +776,7 @@ msp430_get_raw_arg_mode (int regno)\n #undef  TARGET_GET_RAW_RESULT_MODE\n #define TARGET_GET_RAW_RESULT_MODE msp430_get_raw_result_mode\n \n-static enum machine_mode\n+static machine_mode\n msp430_get_raw_result_mode (int regno ATTRIBUTE_UNUSED)\n {\n   return Pmode;\n@@ -893,7 +893,7 @@ reg_ok_for_addr (rtx r, bool strict)\n }\n \n bool\n-msp430_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+msp430_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     rtx x ATTRIBUTE_UNUSED,\n \t\t\t     bool strict ATTRIBUTE_UNUSED)\n {\n@@ -939,7 +939,7 @@ msp430_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n #define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P msp430_addr_space_legitimate_address_p\n \n bool\n-msp430_addr_space_legitimate_address_p (enum machine_mode mode,\n+msp430_addr_space_legitimate_address_p (machine_mode mode,\n \t\t\t\t\trtx x,\n \t\t\t\t\tbool strict,\n \t\t\t\t\taddr_space_t as ATTRIBUTE_UNUSED)\n@@ -985,7 +985,7 @@ msp430_asm_output_addr_const_extra (FILE *file, rtx x)\n #define TARGET_LEGITIMATE_CONSTANT_P msp430_legitimate_constant\n \n static bool\n-msp430_legitimate_constant (enum machine_mode mode, rtx x)\n+msp430_legitimate_constant (machine_mode mode, rtx x)\n {\n   return ! CONST_INT_P (x)\n     || mode != PSImode\n@@ -1538,7 +1538,7 @@ static rtx\n msp430_expand_builtin (tree exp,\n \t\t       rtx target ATTRIBUTE_UNUSED,\n \t\t       rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -1913,9 +1913,9 @@ msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variant\n   char *helper_const = NULL;\n   int arg2 = 13;\n   int arg1sz = 1;\n-  enum machine_mode arg0mode = GET_MODE (operands[0]);\n-  enum machine_mode arg1mode = GET_MODE (operands[1]);\n-  enum machine_mode arg2mode = GET_MODE (operands[2]);\n+  machine_mode arg0mode = GET_MODE (operands[0]);\n+  machine_mode arg1mode = GET_MODE (operands[1]);\n+  machine_mode arg2mode = GET_MODE (operands[2]);\n   int have_430x = msp430x ? 1 : 0;\n \n   if (CONST_INT_P (operands[2]))\n@@ -1980,7 +1980,7 @@ msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variant\n \n /* Called by cbranch<mode>4 to coerce operands into usable forms.  */\n void\n-msp430_fixup_compare_operands (enum machine_mode my_mode, rtx * operands)\n+msp430_fixup_compare_operands (machine_mode my_mode, rtx * operands)\n {\n   /* constants we're looking for, not constants which are allowed.  */\n   int const_op_idx = 1;\n@@ -1997,15 +1997,15 @@ msp430_fixup_compare_operands (enum machine_mode my_mode, rtx * operands)\n    need it to below, so we use this function for when we must get a\n    valid subreg in a \"natural\" state.  */\n rtx\n-msp430_subreg (enum machine_mode mode, rtx r, enum machine_mode omode, int byte)\n+msp430_subreg (machine_mode mode, rtx r, machine_mode omode, int byte)\n {\n   rtx rv;\n \n   if (GET_CODE (r) == SUBREG\n       && SUBREG_BYTE (r) == 0)\n     {\n       rtx ireg = SUBREG_REG (r);\n-      enum machine_mode imode = GET_MODE (ireg);\n+      machine_mode imode = GET_MODE (ireg);\n \n       /* special case for (HI (SI (PSI ...), 0)) */\n       if (imode == PSImode"}, {"sha": "907737c1111a3c9b2a51a4d4f2b157eb6211a843", "filename": "gcc/config/nds32/nds32-cost.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -204,7 +204,7 @@ nds32_rtx_costs_impl (rtx x,\n \n int\n nds32_address_cost_impl (rtx address,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t addr_space_t as ATTRIBUTE_UNUSED,\n \t\t\t bool speed)\n {"}, {"sha": "4c45e96d5f7b8c03aca9c4cc58c0f00b9dd17958", "filename": "gcc/config/nds32/nds32-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -211,7 +211,7 @@ rtx\n nds32_expand_builtin_impl (tree exp,\n \t\t\t   rtx target,\n \t\t\t   rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);"}, {"sha": "ca78283f5da3a08016ad2f7bb5e71289ea6542b9", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -91,7 +91,7 @@ nds32_byte_to_size (int byte)\n enum nds32_16bit_address_type\n nds32_mem_format (rtx op)\n {\n-  enum machine_mode mode_test;\n+  machine_mode mode_test;\n   int val;\n   int regno;\n \n@@ -817,7 +817,7 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n const char *\n nds32_output_casesi_pc_relative (rtx *operands)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   rtx diff_vec;\n \n   diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])));"}, {"sha": "c456c4063db83efae31e59ca5608c6a1bdc4bc92", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -30,8 +30,8 @@ extern void nds32_init_expanders (void);\n \n /* -- How Values Fit in Registers.  */\n \n-extern int nds32_hard_regno_nregs (int, enum machine_mode);\n-extern int nds32_hard_regno_mode_ok (int, enum machine_mode);\n+extern int nds32_hard_regno_nregs (int, machine_mode);\n+extern int nds32_hard_regno_mode_ok (int, machine_mode);\n \n \f\n /* Register Classes.  */\n@@ -66,7 +66,7 @@ extern void nds32_expand_epilogue_v3pop (void);\n \n /* Auxiliary functions for auxiliary macros in nds32.h.  */\n \n-extern bool nds32_ls_333_p (rtx, rtx, rtx, enum machine_mode);\n+extern bool nds32_ls_333_p (rtx, rtx, rtx, machine_mode);\n \n /* Auxiliary functions for expanding rtl used in nds32-multiple.md.  */\n \n@@ -128,7 +128,7 @@ extern int nds32_target_alignment (rtx);\n \n extern void nds32_init_builtins_impl (void);\n extern rtx nds32_expand_builtin_impl (tree, rtx, rtx,\n-\t\t\t\t      enum machine_mode, int);\n+\t\t\t\t      machine_mode, int);\n \n /* Auxiliary functions for ISR implementation.  */\n \n@@ -141,6 +141,6 @@ extern bool nds32_isr_function_p (tree);\n /* Auxiliary functions for cost calculation.  */\n \n extern bool nds32_rtx_costs_impl (rtx, int, int, int, int *, bool);\n-extern int nds32_address_cost_impl (rtx, enum machine_mode, addr_space_t, bool);\n+extern int nds32_address_cost_impl (rtx, machine_mode, addr_space_t, bool);\n \n /* ------------------------------------------------------------------------ */"}, {"sha": "6fb2069cc54fe3d15936983512f5cc072311f29c", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -1019,7 +1019,7 @@ nds32_force_addi_stack_int (int full_value)\n \n /* Return true if MODE/TYPE need double word alignment.  */\n static bool\n-nds32_needs_double_word_align (enum machine_mode mode, const_tree type)\n+nds32_needs_double_word_align (machine_mode mode, const_tree type)\n {\n   unsigned int align;\n \n@@ -1075,7 +1075,7 @@ nds32_address_register_rtx_p (rtx x, bool strict)\n         INDEX : Check if this rtx is valid to be a index for address.\n        STRICT : If it is true, we are in reload pass or after reload pass.  */\n static bool\n-nds32_legitimate_index_p (enum machine_mode outer_mode,\n+nds32_legitimate_index_p (machine_mode outer_mode,\n \t\t\t  rtx index,\n \t\t\t  bool strict)\n {\n@@ -1203,7 +1203,7 @@ nds32_legitimate_index_p (enum machine_mode outer_mode,\n \n static unsigned char\n nds32_class_max_nregs (reg_class_t rclass ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode)\n+\t\t       machine_mode mode)\n {\n   /* Return the maximum number of consecutive registers\n      needed to represent \"mode\" in a register of \"rclass\".  */\n@@ -1305,7 +1305,7 @@ nds32_can_eliminate (const int from_reg, const int to_reg)\n /* -- Passing Arguments in Registers.  */\n \n static rtx\n-nds32_function_arg (cumulative_args_t ca, enum machine_mode mode,\n+nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   unsigned int regno;\n@@ -1367,7 +1367,7 @@ nds32_function_arg (cumulative_args_t ca, enum machine_mode mode,\n }\n \n static bool\n-nds32_must_pass_in_stack (enum machine_mode mode, const_tree type)\n+nds32_must_pass_in_stack (machine_mode mode, const_tree type)\n {\n   /* Return true if a type must be passed in memory.\n      If it is NOT using hard float abi, small aggregates can be\n@@ -1380,7 +1380,7 @@ nds32_must_pass_in_stack (enum machine_mode mode, const_tree type)\n }\n \n static int\n-nds32_arg_partial_bytes (cumulative_args_t ca, enum machine_mode mode,\n+nds32_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n \t\t\t tree type, bool named ATTRIBUTE_UNUSED)\n {\n   /* Returns the number of bytes at the beginning of an argument that\n@@ -1424,10 +1424,10 @@ nds32_arg_partial_bytes (cumulative_args_t ca, enum machine_mode mode,\n }\n \n static void\n-nds32_function_arg_advance (cumulative_args_t ca, enum machine_mode mode,\n+nds32_function_arg_advance (cumulative_args_t ca, machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n-  enum machine_mode sub_mode;\n+  machine_mode sub_mode;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n \n   if (named)\n@@ -1470,7 +1470,7 @@ nds32_function_arg_advance (cumulative_args_t ca, enum machine_mode mode,\n }\n \n static unsigned int\n-nds32_function_arg_boundary (enum machine_mode mode, const_tree type)\n+nds32_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   return (nds32_needs_double_word_align (mode, type)\n \t  ? NDS32_DOUBLE_WORD_ALIGNMENT\n@@ -1484,7 +1484,7 @@ nds32_function_value (const_tree ret_type,\n \t\t      const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n \t\t      bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int unsignedp;\n \n   mode = TYPE_MODE (ret_type);\n@@ -1496,7 +1496,7 @@ nds32_function_value (const_tree ret_type,\n }\n \n static rtx\n-nds32_libcall_value (enum machine_mode mode,\n+nds32_libcall_value (machine_mode mode,\n \t\t     const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, NDS32_GPR_RET_FIRST_REGNUM);\n@@ -1695,7 +1695,7 @@ nds32_warn_func_return (tree decl)\n \n static void\n nds32_setup_incoming_varargs (cumulative_args_t ca,\n-\t\t\t      enum machine_mode mode,\n+\t\t\t      machine_mode mode,\n \t\t\t      tree type,\n \t\t\t      int *pretend_args_size,\n \t\t\t      int second_time ATTRIBUTE_UNUSED)\n@@ -1910,7 +1910,7 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n /* Addressing Modes.  */\n \n static bool\n-nds32_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   /* For (mem:DI addr) or (mem:DF addr) case,\n      we only allow 'addr' to be [reg], [symbol_ref],\n@@ -2043,7 +2043,7 @@ nds32_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n /* Describing Relative Costs of Operations.  */\n \n static int\n-nds32_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+nds32_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t from,\n \t\t\t  reg_class_t to)\n {\n@@ -2054,7 +2054,7 @@ nds32_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n static int\n-nds32_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+nds32_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\treg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t\tbool in ATTRIBUTE_UNUSED)\n {\n@@ -2078,7 +2078,7 @@ nds32_rtx_costs (rtx x,\n \n static int\n nds32_address_cost (rtx address,\n-\t\t    enum machine_mode mode,\n+\t\t    machine_mode mode,\n \t\t    addr_space_t as,\n \t\t    bool speed)\n {\n@@ -2686,7 +2686,7 @@ static rtx\n nds32_expand_builtin (tree exp,\n \t\t      rtx target,\n \t\t      rtx subtarget,\n-\t\t      enum machine_mode mode,\n+\t\t      machine_mode mode,\n \t\t      int ignore)\n {\n   return nds32_expand_builtin_impl (exp, target, subtarget, mode, ignore);\n@@ -2714,13 +2714,13 @@ nds32_init_expanders (void)\n \n int\n nds32_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode)\n+\t\t\tmachine_mode mode)\n {\n   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n }\n \n int\n-nds32_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+nds32_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   /* Restrict double-word quantities to even register pairs.  */\n   if (HARD_REGNO_NREGS (regno, mode) == 1\n@@ -3383,7 +3383,7 @@ nds32_expand_epilogue_v3pop (void)\n    This is auxiliary extern function for auxiliary macro in nds32.h.\n    Because it is a little complicated, we use function instead of macro.  */\n bool\n-nds32_ls_333_p (rtx rt, rtx ra, rtx imm, enum machine_mode mode)\n+nds32_ls_333_p (rtx rt, rtx ra, rtx imm, machine_mode mode)\n {\n   if (REGNO_REG_CLASS (REGNO (rt)) == LOW_REGS\n       && REGNO_REG_CLASS (REGNO (ra)) == LOW_REGS)"}, {"sha": "0c38fb9d31febc72fde9aa0a1bb1b803cb42ded3", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -29,15 +29,15 @@ extern void nios2_expand_epilogue (bool);\n extern void nios2_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE\n-extern int nios2_emit_move_sequence (rtx *, enum machine_mode);\n-extern void nios2_emit_expensive_div (rtx *, enum machine_mode);\n+extern int nios2_emit_move_sequence (rtx *, machine_mode);\n+extern void nios2_emit_expensive_div (rtx *, machine_mode);\n extern void nios2_adjust_call_address (rtx *);\n \n extern rtx nios2_get_return_address (int);\n extern void nios2_set_return_address (rtx, rtx);\n \n-extern bool nios2_validate_compare (enum machine_mode, rtx *, rtx *, rtx *);\n-extern bool nios2_validate_fpu_compare (enum machine_mode, rtx *, rtx *, rtx *,\n+extern bool nios2_validate_compare (machine_mode, rtx *, rtx *, rtx *);\n+extern bool nios2_validate_fpu_compare (machine_mode, rtx *, rtx *, rtx *,\n \t\t\t\t\tbool);\n \n extern bool nios2_fpu_insn_enabled (enum n2fpu_code);\n@@ -51,8 +51,8 @@ extern bool nios2_unspec_reloc_p (rtx);\n #ifdef TREE_CODE\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines both ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction nios2_function_arg_padding (enum machine_mode, const_tree);\n-extern enum direction nios2_block_reg_padding (enum machine_mode, tree, int);\n+extern enum direction nios2_function_arg_padding (machine_mode, const_tree);\n+extern enum direction nios2_block_reg_padding (machine_mode, tree, int);\n #endif /* ARGS_SIZE_RTX */\n \n #endif /* TREE_CODE */"}, {"sha": "03451fe83c30c637f73767407696229030debbc7", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -334,7 +334,7 @@ nios2_fpu_insn_enabled (enum n2fpu_code code)\n    settings.  */\n \n static bool\n-nios2_fpu_compare_enabled (enum rtx_code cond, enum machine_mode mode)\n+nios2_fpu_compare_enabled (enum rtx_code cond, machine_mode mode)\n {\n   if (mode == SFmode)\n     switch (cond) \n@@ -1313,7 +1313,7 @@ nios2_legitimize_tls_address (rtx loc)\n    sdata section we can save even more cycles by doing things\n    gp relative.  */\n void\n-nios2_emit_expensive_div (rtx *operands, enum machine_mode mode)\n+nios2_emit_expensive_div (rtx *operands, machine_mode mode)\n {\n   rtx or_result, shift_left_result;\n   rtx lookup_value;\n@@ -1380,7 +1380,7 @@ nios2_emit_expensive_div (rtx *operands, enum machine_mode mode)\n static void\n nios2_alternate_compare_const (enum rtx_code code, rtx op,\n \t\t\t       enum rtx_code *alt_code, rtx *alt_op,\n-\t\t\t       enum machine_mode mode)\n+\t\t\t       machine_mode mode)\n {\n   HOST_WIDE_INT opval = INTVAL (op);\n   enum rtx_code scode = signed_condition (code);\n@@ -1433,7 +1433,7 @@ nios2_valid_compare_const_p (enum rtx_code code, rtx op)\n    Returns true if FPU compare can be done.  */\n \n bool\n-nios2_validate_fpu_compare (enum machine_mode mode, rtx *cmp, rtx *op1, rtx *op2,\n+nios2_validate_fpu_compare (machine_mode mode, rtx *cmp, rtx *op1, rtx *op2,\n \t\t\t    bool modify_p)\n {\n   bool rev_p = false;\n@@ -1466,7 +1466,7 @@ nios2_validate_fpu_compare (enum machine_mode mode, rtx *cmp, rtx *op1, rtx *op2\n /* Checks and modifies the comparison in *CMP, *OP1, and *OP2 into valid\n    nios2 supported form.  Returns true if success.  */\n bool\n-nios2_validate_compare (enum machine_mode mode, rtx *cmp, rtx *op1, rtx *op2)\n+nios2_validate_compare (machine_mode mode, rtx *cmp, rtx *op1, rtx *op2)\n {\n   enum rtx_code code = GET_CODE (*cmp);\n   enum rtx_code alt_code;\n@@ -1525,7 +1525,7 @@ nios2_validate_compare (enum machine_mode mode, rtx *cmp, rtx *op1, rtx *op2)\n \n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n static bool\n-nios2_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+nios2_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   rtx base, offset;\n   split_const (x, &base, &offset);\n@@ -1534,7 +1534,7 @@ nios2_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n static bool\n-nios2_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+nios2_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return nios2_legitimate_constant_p (mode, x) == false;\n }\n@@ -1580,7 +1580,7 @@ nios2_valid_addr_expr_p (rtx base, rtx offset, bool strict_p)\n \n /* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n static bool\n-nios2_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+nios2_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    rtx operand, bool strict_p)\n {\n   switch (GET_CODE (operand))\n@@ -1784,7 +1784,7 @@ nios2_legitimize_constant_address (rtx addr)\n /* Implement TARGET_LEGITIMIZE_ADDRESS.  */\n static rtx\n nios2_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (CONSTANT_P (x))\n     return nios2_legitimize_constant_address (x);\n@@ -1857,7 +1857,7 @@ nios2_delegitimize_address (rtx x)\n \n /* Main expander function for RTL moves.  */\n int\n-nios2_emit_move_sequence (rtx *operands, enum machine_mode mode)\n+nios2_emit_move_sequence (rtx *operands, machine_mode mode)\n {\n   rtx to = operands[0];\n   rtx from = operands[1];\n@@ -2184,8 +2184,8 @@ nios2_fpu_insn_asm (enum n2fpu_code code)\n   int num_operands = N2FPU (code).num_operands;\n   const char *insn_name = N2FPU_NAME (code);\n   tree ftype = nios2_ftype (N2FPU_FTCODE (code));\n-  enum machine_mode dst_mode = TYPE_MODE (TREE_TYPE (ftype));\n-  enum machine_mode src_mode = TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (ftype)));\n+  machine_mode dst_mode = TYPE_MODE (TREE_TYPE (ftype));\n+  machine_mode src_mode = TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (ftype)));\n \n   /* Prepare X register for DF input operands.  */\n   if (GET_MODE_SIZE (src_mode) == 8 && num_operands == 3)\n@@ -2274,7 +2274,7 @@ nios2_fpu_insn_asm (enum n2fpu_code code)\n    (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-nios2_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+nios2_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t    bool named ATTRIBUTE_UNUSED)\n {\n@@ -2293,7 +2293,7 @@ nios2_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \n static int\n nios2_arg_partial_bytes (cumulative_args_t cum_v,\n-                         enum machine_mode mode, tree type ATTRIBUTE_UNUSED,\n+                         machine_mode mode, tree type ATTRIBUTE_UNUSED,\n                          bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n@@ -2322,7 +2322,7 @@ nios2_arg_partial_bytes (cumulative_args_t cum_v,\n    may not be available.  */\n \n static void\n-nios2_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+nios2_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t\t    bool named ATTRIBUTE_UNUSED)\n {\n@@ -2347,7 +2347,7 @@ nios2_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n }\n \n enum direction\n-nios2_function_arg_padding (enum machine_mode mode, const_tree type)\n+nios2_function_arg_padding (machine_mode mode, const_tree type)\n {\n   /* On little-endian targets, the first byte of every stack argument\n      is passed in the first byte of the stack slot.  */\n@@ -2370,7 +2370,7 @@ nios2_function_arg_padding (enum machine_mode mode, const_tree type)\n }\n \n enum direction\n-nios2_block_reg_padding (enum machine_mode mode, tree type,\n+nios2_block_reg_padding (machine_mode mode, tree type,\n                          int first ATTRIBUTE_UNUSED)\n {\n   return nios2_function_arg_padding (mode, type);\n@@ -2402,7 +2402,7 @@ nios2_function_value (const_tree ret_type, const_tree fn ATTRIBUTE_UNUSED,\n \n /* Implement TARGET_LIBCALL_VALUE.  */\n static rtx\n-nios2_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+nios2_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, FIRST_RETVAL_REGNO);\n }\n@@ -2426,7 +2426,7 @@ nios2_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n    own va_arg type.  */\n static void\n nios2_setup_incoming_varargs (cumulative_args_t cum_v,\n-                              enum machine_mode mode, tree type,\n+                              machine_mode mode, tree type,\n                               int *pretend_size, int second_time)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n@@ -2484,7 +2484,7 @@ nios2_expand_fpu_builtin (tree exp, unsigned int code, rtx target)\n   enum insn_code icode = N2FPU_ICODE (code);\n   int nargs, argno, opno = 0;\n   int num_operands = N2FPU (code).num_operands;\n-  enum machine_mode dst_mode = TYPE_MODE (TREE_TYPE (exp));\n+  machine_mode dst_mode = TYPE_MODE (TREE_TYPE (exp));\n   bool has_target_p = (dst_mode != VOIDmode);\n \n   if (N2FPU_N (code) < 0)\n@@ -2573,7 +2573,7 @@ static rtx\n nios2_expand_custom_builtin (tree exp, unsigned int index, rtx target)\n {\n   bool has_target_p = (TREE_TYPE (exp) != void_type_node);\n-  enum machine_mode tmode = VOIDmode;\n+  machine_mode tmode = VOIDmode;\n   int nargs, argno;\n   rtx value, insn, unspec_args[3];\n   tree arg;\n@@ -2745,7 +2745,7 @@ nios2_expand_ldstio_builtin (tree exp, rtx target,\n   bool has_target_p;\n   rtx addr, mem, val;\n   struct expand_operand ops[MAX_RECOG_OPERANDS];\n-  enum machine_mode mode = insn_data[d->icode].operand[0].mode;\n+  machine_mode mode = insn_data[d->icode].operand[0].mode;\n \n   addr = expand_normal (CALL_EXPR_ARG (exp, 0));\n   mem = gen_rtx_MEM (mode, addr);\n@@ -2808,7 +2808,7 @@ nios2_expand_rdwrctl_builtin (tree exp, rtx target,\n \n static rtx\n nios2_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-                      enum machine_mode mode ATTRIBUTE_UNUSED,\n+                      machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);"}, {"sha": "80e1efeb619e30745e6e45537ddd244ffe4b685c", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -57,14 +57,14 @@ extern int pa_adjust_insn_length (rtx_insn *, int);\n extern int pa_fmpyaddoperands (rtx *);\n extern int pa_fmpysuboperands (rtx *);\n extern void pa_emit_bcond_fp (rtx[]);\n-extern int pa_emit_move_sequence (rtx *, enum machine_mode, rtx);\n+extern int pa_emit_move_sequence (rtx *, machine_mode, rtx);\n extern int pa_emit_hpdiv_const (rtx *, int);\n extern int pa_is_function_label_plus_const (rtx);\n extern int pa_fpstore_bypass_p (rtx_insn *, rtx_insn *);\n extern int pa_attr_length_millicode_call (rtx_insn *);\n extern int pa_attr_length_call (rtx_insn *, int);\n extern int pa_attr_length_indirect_call (rtx_insn *);\n-extern rtx pa_legitimize_reload_address (rtx, enum machine_mode,\n+extern rtx pa_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t int, int, int);\n \n /* Declare functions defined in pa.c and used in templates.  */\n@@ -74,7 +74,7 @@ extern rtx pa_return_addr_rtx (int, rtx);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n #ifdef TREE_CODE\n-extern enum direction pa_function_arg_padding (enum machine_mode, const_tree);\n+extern enum direction pa_function_arg_padding (machine_mode, const_tree);\n #endif\n #endif /* ARGS_SIZE_RTX */\n extern int pa_insn_refs_are_delayed (rtx_insn *);\n@@ -110,9 +110,9 @@ extern void pa_asm_output_aligned_local (FILE *, const char *,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n \t\t\t\t\t unsigned int);\n extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n-extern bool pa_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n+extern bool pa_cannot_change_mode_class (machine_mode, machine_mode,\n \t\t\t\t\t enum reg_class);\n-extern bool pa_modes_tieable_p (enum machine_mode, enum machine_mode);\n+extern bool pa_modes_tieable_p (machine_mode, machine_mode);\n extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);\n \n extern const int pa_magic_milli[];"}, {"sha": "707272203cbe81795b3bea7b35b732ed515ad4c9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -72,8 +72,8 @@ along with GCC; see the file COPYING3.  If not see\n int\n pa_fpstore_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n {\n-  enum machine_mode store_mode;\n-  enum machine_mode other_mode;\n+  machine_mode store_mode;\n+  machine_mode other_mode;\n   rtx set;\n \n   if (recog_memoized (in_insn) < 0\n@@ -105,11 +105,11 @@ pa_fpstore_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n static void pa_option_override (void);\n static void copy_reg_pointer (rtx, rtx);\n static void fix_range (const char *);\n-static int hppa_register_move_cost (enum machine_mode mode, reg_class_t,\n+static int hppa_register_move_cost (machine_mode mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n-static int hppa_address_cost (rtx, enum machine_mode mode, addr_space_t, bool);\n+static int hppa_address_cost (rtx, machine_mode mode, addr_space_t, bool);\n static bool hppa_rtx_costs (rtx, int, int, int, int *, bool);\n-static inline rtx force_mode (enum machine_mode, rtx);\n+static inline rtx force_mode (machine_mode, rtx);\n static void pa_reorg (void);\n static void pa_combine_instructions (void);\n static int pa_can_combine_p (rtx_insn *, rtx_insn *, rtx_insn *, int, rtx,\n@@ -126,7 +126,7 @@ static void store_reg_modify (int, int, HOST_WIDE_INT);\n static void load_reg (int, HOST_WIDE_INT, int);\n static void set_reg_plus_d (int, int, HOST_WIDE_INT, int);\n static rtx pa_function_value (const_tree, const_tree, bool);\n-static rtx pa_libcall_value (enum machine_mode, const_rtx);\n+static rtx pa_libcall_value (machine_mode, const_rtx);\n static bool pa_function_value_regno_p (const unsigned int);\n static void pa_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void update_total_code_bytes (unsigned int);\n@@ -150,15 +150,15 @@ static void pa_asm_out_constructor (rtx, int);\n static void pa_asm_out_destructor (rtx, int);\n #endif\n static void pa_init_builtins (void);\n-static rtx pa_expand_builtin (tree, rtx, rtx, enum machine_mode mode, int);\n+static rtx pa_expand_builtin (tree, rtx, rtx, machine_mode mode, int);\n static rtx hppa_builtin_saveregs (void);\n static void hppa_va_start (tree, rtx);\n static tree hppa_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n-static bool pa_scalar_mode_supported_p (enum machine_mode);\n+static bool pa_scalar_mode_supported_p (machine_mode);\n static bool pa_commutative_p (const_rtx x, int outer_code);\n static void copy_fp_args (rtx) ATTRIBUTE_UNUSED;\n static int length_fp_args (rtx) ATTRIBUTE_UNUSED;\n-static rtx hppa_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx hppa_legitimize_address (rtx, rtx, machine_mode);\n static inline void pa_file_start_level (void) ATTRIBUTE_UNUSED;\n static inline void pa_file_start_space (int) ATTRIBUTE_UNUSED;\n static inline void pa_file_start_file (int) ATTRIBUTE_UNUSED;\n@@ -175,22 +175,22 @@ static void pa_hpux_file_end (void);\n #endif\n static void pa_init_libfuncs (void);\n static rtx pa_struct_value_rtx (tree, int);\n-static bool pa_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static bool pa_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t  const_tree, bool);\n-static int pa_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n+static int pa_arg_partial_bytes (cumulative_args_t, machine_mode,\n \t\t\t\t tree, bool);\n-static void pa_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n-static rtx pa_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx pa_function_arg (cumulative_args_t, machine_mode,\n \t\t\t    const_tree, bool);\n-static unsigned int pa_function_arg_boundary (enum machine_mode, const_tree);\n+static unsigned int pa_function_arg_boundary (machine_mode, const_tree);\n static struct machine_function * pa_init_machine_status (void);\n static reg_class_t pa_secondary_reload (bool, rtx, reg_class_t,\n-\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\tmachine_mode,\n \t\t\t\t\tsecondary_reload_info *);\n static void pa_extra_live_on_entry (bitmap);\n-static enum machine_mode pa_promote_function_mode (const_tree,\n-\t\t\t\t\t\t   enum machine_mode, int *,\n+static machine_mode pa_promote_function_mode (const_tree,\n+\t\t\t\t\t\t   machine_mode, int *,\n \t\t\t\t\t\t   const_tree, int);\n \n static void pa_asm_trampoline_template (FILE *);\n@@ -201,12 +201,12 @@ static bool pa_print_operand_punct_valid_p (unsigned char);\n static rtx pa_internal_arg_pointer (void);\n static bool pa_can_eliminate (const int, const int);\n static void pa_conditional_register_usage (void);\n-static enum machine_mode pa_c_mode_for_suffix (char);\n+static machine_mode pa_c_mode_for_suffix (char);\n static section *pa_function_section (tree, enum node_frequency, bool, bool);\n-static bool pa_cannot_force_const_mem (enum machine_mode, rtx);\n-static bool pa_legitimate_constant_p (enum machine_mode, rtx);\n+static bool pa_cannot_force_const_mem (machine_mode, rtx);\n+static bool pa_legitimate_constant_p (machine_mode, rtx);\n static unsigned int pa_section_type_flags (tree, const char *, int);\n-static bool pa_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool pa_legitimate_address_p (machine_mode, rtx, bool);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -629,7 +629,7 @@ pa_init_builtins (void)\n \n static rtx\n pa_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n@@ -644,7 +644,7 @@ pa_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case PA_BUILTIN_INFQ:\n     case PA_BUILTIN_HUGE_VALQ:\n       {\n-\tenum machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n+\tmachine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n \tREAL_VALUE_TYPE inf;\n \trtx tmp;\n \n@@ -766,7 +766,7 @@ pa_ior_mask_p (unsigned HOST_WIDE_INT mask)\n    than one register, we lose.  */\n \n static rtx\n-legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n+legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n {\n   rtx pic_ref = orig;\n \n@@ -1026,7 +1026,7 @@ legitimize_tls_address (rtx addr)\n \n rtx\n hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t machine_mode mode)\n {\n   rtx orig = x;\n \n@@ -1391,7 +1391,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n    Other copies are reasonably cheap.  */\n \n static int\n-hppa_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+hppa_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t reg_class_t from, reg_class_t to)\n {\n   if (from == SHIFT_REGS)\n@@ -1414,7 +1414,7 @@ hppa_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    as pa_legitimate_address_p.  */\n \n static int\n-hppa_address_cost (rtx X, enum machine_mode mode ATTRIBUTE_UNUSED,\n+hppa_address_cost (rtx X, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   addr_space_t as ATTRIBUTE_UNUSED,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n@@ -1537,7 +1537,7 @@ hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n /* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n    new rtx with the correct mode.  */\n static inline rtx\n-force_mode (enum machine_mode mode, rtx orig)\n+force_mode (machine_mode mode, rtx orig)\n {\n   if (mode == GET_MODE (orig))\n     return orig;\n@@ -1550,7 +1550,7 @@ force_mode (enum machine_mode mode, rtx orig)\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-pa_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+pa_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return tls_referenced_p (x);\n }\n@@ -1566,7 +1566,7 @@ pa_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n    of SCRATCH_REG in the proper mode.  */\n \n int\n-pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n+pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n@@ -5829,7 +5829,7 @@ void\n pa_output_arg_descriptor (rtx call_insn)\n {\n   const char *arg_regs[4];\n-  enum machine_mode arg_mode;\n+  machine_mode arg_mode;\n   rtx link;\n   int i, output_flag = 0;\n   int regno;\n@@ -5905,7 +5905,7 @@ pa_output_arg_descriptor (rtx call_insn)\n \n static reg_class_t\n pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n-\t\t     enum machine_mode mode, secondary_reload_info *sri)\n+\t\t     machine_mode mode, secondary_reload_info *sri)\n {\n   int regno;\n   enum reg_class rclass = (enum reg_class) rclass_i;\n@@ -6093,7 +6093,7 @@ pa_eh_return_handler_rtx (void)\n \n static bool\n pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode, const_tree type,\n+\t\t      machine_mode mode, const_tree type,\n \t\t      bool named ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size;\n@@ -6110,7 +6110,7 @@ pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n }\n \n enum direction\n-pa_function_arg_padding (enum machine_mode mode, const_tree type)\n+pa_function_arg_padding (machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode\n       || (TARGET_64BIT\n@@ -6291,7 +6291,7 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n    2 * BITS_PER_WORD isn't equal LONG_LONG_TYPE_SIZE.  */\n \n static bool\n-pa_scalar_mode_supported_p (enum machine_mode mode)\n+pa_scalar_mode_supported_p (machine_mode mode)\n {\n   int precision = GET_MODE_PRECISION (mode);\n \n@@ -8478,7 +8478,7 @@ pa_commutative_p (const_rtx x, int outer_code)\n int\n pa_fmpyaddoperands (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   /* Must be a floating point mode.  */\n   if (mode != SFmode && mode != DFmode)\n@@ -8656,7 +8656,7 @@ pa_asm_output_aligned_local (FILE *stream,\n int\n pa_fmpysuboperands (rtx *operands)\n {\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n \n   /* Must be a floating point mode.  */\n   if (mode != SFmode && mode != DFmode)\n@@ -9144,9 +9144,9 @@ pa_insn_refs_are_delayed (rtx_insn *insn)\n \n /* Promote the return value, but not the arguments.  */\n \n-static enum machine_mode\n+static machine_mode\n pa_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n-                          enum machine_mode mode,\n+                          machine_mode mode,\n                           int *punsignedp ATTRIBUTE_UNUSED,\n                           const_tree fntype ATTRIBUTE_UNUSED,\n                           int for_return)\n@@ -9170,7 +9170,7 @@ pa_function_value (const_tree valtype,\n                    const_tree func ATTRIBUTE_UNUSED, \n                    bool outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode valmode;\n+  machine_mode valmode;\n \n   if (AGGREGATE_TYPE_P (valtype)\n       || TREE_CODE (valtype) == COMPLEX_TYPE\n@@ -9235,7 +9235,7 @@ pa_function_value (const_tree valtype,\n /* Implement the TARGET_LIBCALL_VALUE hook.  */\n \n static rtx\n-pa_libcall_value (enum machine_mode mode,\n+pa_libcall_value (machine_mode mode,\n \t\t  const_rtx fun ATTRIBUTE_UNUSED)\n {\n   if (! TARGET_SOFT_FLOAT\n@@ -9262,7 +9262,7 @@ pa_function_value_regno_p (const unsigned int regno)\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n static void\n-pa_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+pa_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -9284,7 +9284,7 @@ pa_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n    ??? We might want to restructure this so that it looks more like other\n    ports.  */\n static rtx\n-pa_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+pa_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -9480,7 +9480,7 @@ pa_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n /* Arguments larger than one word are double word aligned.  */\n \n static unsigned int\n-pa_function_arg_boundary (enum machine_mode mode, const_tree type)\n+pa_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   bool singleword = (type\n \t\t     ? (integer_zerop (TYPE_SIZE (type))\n@@ -9495,7 +9495,7 @@ pa_function_arg_boundary (enum machine_mode mode, const_tree type)\n    then this routine should return zero.  */\n \n static int\n-pa_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n+pa_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \t\t      tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -9780,7 +9780,7 @@ pa_hpux_file_end (void)\n    in register class RCLASS is invalid.  */\n \n bool\n-pa_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n \t\t\t     enum reg_class rclass)\n {\n   if (from == to)\n@@ -9825,7 +9825,7 @@ pa_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n    in the floating-point registers.  */\n \n bool\n-pa_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+pa_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   /* Don't tie modes in different classes.  */\n   if (GET_MODE_CLASS (mode1) != GET_MODE_CLASS (mode2))\n@@ -10091,7 +10091,7 @@ pa_conditional_register_usage (void)\n \n /* Target hook for c_mode_for_suffix.  */\n \n-static enum machine_mode\n+static machine_mode\n pa_c_mode_for_suffix (char suffix)\n {\n   if (HPUX_LONG_DOUBLE_LIBRARY)\n@@ -10136,7 +10136,7 @@ pa_function_section (tree decl, enum node_frequency freq,\n    to handle CONST_DOUBLES.  */\n \n static bool\n-pa_legitimate_constant_p (enum machine_mode mode, rtx x)\n+pa_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT && x != CONST0_RTX (mode))\n     return false;\n@@ -10236,7 +10236,7 @@ pa_section_type_flags (tree decl, const char *name, int reloc)\n    output as REG+SMALLINT.  */\n \n static bool\n-pa_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+pa_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   if ((REG_P (x)\n        && (strict ? STRICT_REG_OK_FOR_BASE_P (x)\n@@ -10377,7 +10377,7 @@ pa_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    There may be more opportunities to improve code with this hook.  */\n \n rtx\n-pa_legitimize_reload_address (rtx ad, enum machine_mode mode,\n+pa_legitimize_reload_address (rtx ad, machine_mode mode,\n \t\t\t      int opnum, int type,\n \t\t\t      int ind_levels ATTRIBUTE_UNUSED)\n {"}, {"sha": "53c8ea2843d45f43cc58b6c47e55883d2b72a3e0", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* declarations */\n #ifdef RTX_CODE\n-extern int simple_memory_operand (rtx, enum machine_mode);\n+extern int simple_memory_operand (rtx, machine_mode);\n \n extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n@@ -29,10 +29,10 @@ extern const char *output_move_multiple (rtx *);\n extern const char *output_block_move (rtx *);\n extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n-extern bool pdp11_cannot_change_mode_class (enum machine_mode,\n-                                            enum machine_mode, enum reg_class);\n+extern bool pdp11_cannot_change_mode_class (machine_mode,\n+                                            machine_mode, enum reg_class);\n extern bool pdp11_secondary_memory_needed (reg_class_t, reg_class_t, \n-\t\t\t\t\t   enum machine_mode);\n+\t\t\t\t\t   machine_mode);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n extern bool pdp11_expand_operands (rtx *, rtx [][2], int, "}, {"sha": "5e66e786e047445d1ba65535afc1672ad0bc2427", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -162,17 +162,17 @@ static bool pdp11_assemble_integer (rtx, unsigned int, int);\n static bool pdp11_rtx_costs (rtx, int, int, int, int *, bool);\n static bool pdp11_return_in_memory (const_tree, const_tree);\n static rtx pdp11_function_value (const_tree, const_tree, bool);\n-static rtx pdp11_libcall_value (enum machine_mode, const_rtx);\n+static rtx pdp11_libcall_value (machine_mode, const_rtx);\n static bool pdp11_function_value_regno_p (const unsigned int);\n static void pdp11_trampoline_init (rtx, tree, rtx);\n-static rtx pdp11_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx pdp11_function_arg (cumulative_args_t, machine_mode,\n \t\t\t       const_tree, bool);\n static void pdp11_function_arg_advance (cumulative_args_t,\n-\t\t\t\t\tenum machine_mode, const_tree, bool);\n+\t\t\t\t\tmachine_mode, const_tree, bool);\n static void pdp11_conditional_register_usage (void);\n-static bool pdp11_legitimate_constant_p (enum machine_mode, rtx);\n+static bool pdp11_legitimate_constant_p (machine_mode, rtx);\n \n-static bool pdp11_scalar_mode_supported_p (enum machine_mode);\n+static bool pdp11_scalar_mode_supported_p (machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_BYTE_OP\n@@ -904,7 +904,7 @@ static const int move_costs[N_REG_CLASSES][N_REG_CLASSES] =\n    -- as we do here with 10 -- or not ? */\n \n static int \n-pdp11_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t c1, reg_class_t c2)\n {\n     return move_costs[(int)c1][(int)c2];\n@@ -1127,7 +1127,7 @@ notice_update_cc_on_set(rtx exp, rtx insn ATTRIBUTE_UNUSED)\n \n \n int\n-simple_memory_operand(rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+simple_memory_operand(rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n     rtx addr;\n \n@@ -1375,8 +1375,8 @@ legitimate_const_double_p (rtx address)\n \n /* Implement CANNOT_CHANGE_MODE_CLASS.  */\n bool\n-pdp11_cannot_change_mode_class (enum machine_mode from,\n-\t\t\t\tenum machine_mode to,\n+pdp11_cannot_change_mode_class (machine_mode from,\n+\t\t\t\tmachine_mode to,\n \t\t\t\tenum reg_class rclass)\n {\n   /* Also, FPU registers contain a whole float value and the parts of\n@@ -1447,7 +1447,7 @@ static reg_class_t\n pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n \t\t\trtx x,\n \t\t\treg_class_t reload_class,\n-\t\t\tenum machine_mode reload_mode ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode reload_mode ATTRIBUTE_UNUSED,\n \t\t\tsecondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n   if (reload_class != NO_LOAD_FPU_REGS || GET_CODE (x) != REG ||\n@@ -1464,7 +1464,7 @@ pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n */\n bool \n pdp11_secondary_memory_needed (reg_class_t c1, reg_class_t c2, \n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t       machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int fromfloat = (c1 == LOAD_FPU_REGS || c1 == NO_LOAD_FPU_REGS || \n \t\t   c1 == FPU_REGS);\n@@ -1482,7 +1482,7 @@ pdp11_secondary_memory_needed (reg_class_t c1, reg_class_t c2,\n */\n \n static bool\n-pdp11_legitimate_address_p (enum machine_mode mode,\n+pdp11_legitimate_address_p (machine_mode mode,\n \t\t\t    rtx operand, bool strict)\n {\n     rtx xfoob;\n@@ -1783,7 +1783,7 @@ pdp11_function_value (const_tree valtype,\n /* Worker function for TARGET_LIBCALL_VALUE.  */\n \n static rtx\n-pdp11_libcall_value (enum machine_mode mode,\n+pdp11_libcall_value (machine_mode mode,\n                      const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return  gen_rtx_REG (mode, BASE_RETURN_VALUE_REG(mode));\n@@ -1846,7 +1846,7 @@ pdp11_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n static rtx\n pdp11_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    const_tree type ATTRIBUTE_UNUSED,\n \t\t    bool named ATTRIBUTE_UNUSED)\n {\n@@ -1860,7 +1860,7 @@ pdp11_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,\n    may not be available.)  */\n \n static void\n-pdp11_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+pdp11_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -1915,15 +1915,15 @@ pdp11_function_section (tree decl ATTRIBUTE_UNUSED,\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool\n-pdp11_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+pdp11_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return GET_CODE (x) != CONST_DOUBLE || legitimate_const_double_p (x);\n }\n \n /* Implement TARGET_SCALAR_MODE_SUPPORTED_P.  */\n \n static bool\n-pdp11_scalar_mode_supported_p (enum machine_mode mode)\n+pdp11_scalar_mode_supported_p (machine_mode mode)\n {\n   /* Support SFmode even with -mfloat64.  */\n   if (mode == SFmode)"}, {"sha": "c7126a34b129fa557de75a3814efcd25a41e68e1", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -28,18 +28,18 @@ void\t\trl78_expand_eh_epilogue (rtx);\n void\t\trl78_expand_epilogue (void);\n void\t\trl78_expand_prologue (void);\n int\t\trl78_far_p (rtx x);\n-int\t\trl78_hard_regno_mode_ok (int, enum machine_mode);\n-int\t\trl78_hard_regno_nregs (int, enum machine_mode);\n+int\t\trl78_hard_regno_mode_ok (int, machine_mode);\n+int\t\trl78_hard_regno_nregs (int, machine_mode);\n bool\t\trl78_hl_b_c_addr_p (rtx);\n int\t\trl78_initial_elimination_offset (int, int);\n-bool\t\trl78_as_legitimate_address (enum machine_mode, rtx,\n+bool\t\trl78_as_legitimate_address (machine_mode, rtx,\n \t\t\t\t\t    bool, addr_space_t);\n-int\t\trl78_legitimize_reload_address (rtx *, enum machine_mode, int,int, int);\n-enum reg_class\trl78_mode_code_base_reg_class (enum machine_mode, addr_space_t, int, int);\n+int\t\trl78_legitimize_reload_address (rtx *, machine_mode, int,int, int);\n+enum reg_class\trl78_mode_code_base_reg_class (machine_mode, addr_space_t, int, int);\n bool\t\trl78_peep_movhi_p (rtx *);\n bool\t\trl78_real_insns_ok (void);\n void\t\trl78_register_pragmas (void);\n-bool\t\trl78_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, int, int);\n+bool\t\trl78_regno_mode_code_ok_for_base_p (int, machine_mode, addr_space_t, int, int);\n void\t\trl78_setup_peep_movhi (rtx *);\n bool\t\trl78_virt_insns_ok (void);\n "}, {"sha": "9e7c6280d7c1565fb8540c4c6fc480469f791705", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -364,7 +364,7 @@ rl78_real_insns_ok (void)\n \n /* Implements HARD_REGNO_NREGS.  */\n int\n-rl78_hard_regno_nregs (int regno, enum machine_mode mode)\n+rl78_hard_regno_nregs (int regno, machine_mode mode)\n {\n   int rs = register_sizes[regno];\n   if (rs < 1)\n@@ -374,7 +374,7 @@ rl78_hard_regno_nregs (int regno, enum machine_mode mode)\n \n /* Implements HARD_REGNO_MODE_OK.  */\n int\n-rl78_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+rl78_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   int s = GET_MODE_SIZE (mode);\n \n@@ -406,7 +406,7 @@ rl78_hard_regno_mode_ok (int regno, enum machine_mode mode)\n    need it to below, so we use this function for when we must get a\n    valid subreg in a \"natural\" state.  */\n static rtx\n-rl78_subreg (enum machine_mode mode, rtx r, enum machine_mode omode, int byte)\n+rl78_subreg (machine_mode mode, rtx r, machine_mode omode, int byte)\n {\n   if (GET_CODE (r) == MEM)\n     return adjust_address (r, mode, byte);\n@@ -831,7 +831,7 @@ rl78_far_p (rtx x)\n /* Return the appropriate mode for a named address pointer.  */\n #undef  TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE rl78_addr_space_pointer_mode\n-static enum machine_mode\n+static machine_mode\n rl78_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -849,15 +849,15 @@ rl78_addr_space_pointer_mode (addr_space_t addrspace)\n #undef  TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE rl78_valid_pointer_mode\n static bool\n-rl78_valid_pointer_mode (enum machine_mode m)\n+rl78_valid_pointer_mode (machine_mode m)\n {\n   return (m == HImode || m == SImode);\n }\n \n /* Return the appropriate mode for a named address address.  */\n #undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n-static enum machine_mode\n+static machine_mode\n rl78_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -875,7 +875,7 @@ rl78_addr_space_address_mode (addr_space_t addrspace)\n #define TARGET_LEGITIMATE_CONSTANT_P\t\trl78_is_legitimate_constant\n \n static bool\n-rl78_is_legitimate_constant (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED)\n+rl78_is_legitimate_constant (machine_mode mode ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n@@ -884,7 +884,7 @@ rl78_is_legitimate_constant (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x ATTR\n #define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\trl78_as_legitimate_address\n \n bool\n-rl78_as_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n+rl78_as_legitimate_address (machine_mode mode ATTRIBUTE_UNUSED, rtx x,\n \t\t\t    bool strict ATTRIBUTE_UNUSED, addr_space_t as ATTRIBUTE_UNUSED)\n {\n   rtx base, index, addend;\n@@ -984,7 +984,7 @@ rl78_addr_space_convert (rtx op, tree from_type, tree to_type)\n \n /* Implements REGNO_MODE_CODE_OK_FOR_BASE_P.  */\n bool\n-rl78_regno_mode_code_ok_for_base_p (int regno, enum machine_mode mode ATTRIBUTE_UNUSED,\n+rl78_regno_mode_code_ok_for_base_p (int regno, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t    addr_space_t address_space ATTRIBUTE_UNUSED,\n \t\t\t\t    int outer_code ATTRIBUTE_UNUSED, int index_code)\n {\n@@ -999,7 +999,7 @@ rl78_regno_mode_code_ok_for_base_p (int regno, enum machine_mode mode ATTRIBUTE_\n \n /* Implements MODE_CODE_BASE_REG_CLASS.  */\n enum reg_class\n-rl78_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+rl78_mode_code_base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       addr_space_t address_space ATTRIBUTE_UNUSED,\n \t\t\t       int outer_code ATTRIBUTE_UNUSED,\n \t\t\t       int index_code ATTRIBUTE_UNUSED)\n@@ -1246,17 +1246,17 @@ rl78_function_value (const_tree ret_type,\n \t\t     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n \t\t     bool       outgoing ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = TYPE_MODE (ret_type);\n+  machine_mode mode = TYPE_MODE (ret_type);\n \n   return gen_rtx_REG (mode, 8);\n }\n \n #undef  TARGET_PROMOTE_FUNCTION_MODE\n #define TARGET_PROMOTE_FUNCTION_MODE rl78_promote_function_mode\n \n-static enum machine_mode\n+static machine_mode\n rl78_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t    enum machine_mode mode,\n+\t\t\t    machine_mode mode,\n \t\t\t    int *punsignedp ATTRIBUTE_UNUSED,\n \t\t\t    const_tree funtype ATTRIBUTE_UNUSED, int for_return ATTRIBUTE_UNUSED)\n {\n@@ -1275,7 +1275,7 @@ rl78_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n \n static rtx\n rl78_function_arg (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   const_tree type ATTRIBUTE_UNUSED,\n \t\t   bool named ATTRIBUTE_UNUSED)\n {\n@@ -1286,7 +1286,7 @@ rl78_function_arg (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n #define TARGET_FUNCTION_ARG_ADVANCE     rl78_function_arg_advance\n \n static void\n-rl78_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode, const_tree type,\n+rl78_function_arg_advance (cumulative_args_t cum_v, machine_mode mode, const_tree type,\n \t\t\t   bool named ATTRIBUTE_UNUSED)\n {\n   int rounded_size;\n@@ -1303,7 +1303,7 @@ rl78_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode, cons\n #define\tTARGET_FUNCTION_ARG_BOUNDARY rl78_function_arg_boundary\n \n static unsigned int\n-rl78_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n+rl78_function_arg_boundary (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    const_tree type ATTRIBUTE_UNUSED)\n {\n   return 16;\n@@ -1933,7 +1933,7 @@ static unsigned char content_memory [32 + NUM_STACK_LOCS];\n \n static unsigned char saved_update_index = NOT_KNOWN;\n static unsigned char saved_update_value;\n-static enum machine_mode saved_update_mode;\n+static machine_mode saved_update_mode;\n \n \n static inline void\n@@ -1951,7 +1951,7 @@ clear_content_memory (void)\n static unsigned char\n get_content_index (rtx loc)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (loc == NULL_RTX)\n     return NOT_KNOWN;\n@@ -1986,7 +1986,7 @@ get_content_index (rtx loc)\n /* Return a string describing content INDEX in mode MODE.\n    WARNING: Can return a pointer to a static buffer.  */\n static const char *\n-get_content_name (unsigned char index, enum machine_mode mode)\n+get_content_name (unsigned char index, machine_mode mode)\n {\n   static char buffer [128];\n \n@@ -2023,7 +2023,7 @@ display_content_memory (FILE * file)\n #endif\n \n static void\n-update_content (unsigned char index, unsigned char val, enum machine_mode mode)\n+update_content (unsigned char index, unsigned char val, machine_mode mode)\n {\n   unsigned int i;\n \n@@ -2088,7 +2088,7 @@ update_content (unsigned char index, unsigned char val, enum machine_mode mode)\n static void\n record_content (rtx loc, rtx value)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   unsigned char index;\n   unsigned char val;\n \n@@ -2356,7 +2356,7 @@ process_postponed_content_update (void)\n static rtx\n gen_and_emit_move (rtx to, rtx from, rtx where, bool before)\n {\n-  enum machine_mode mode = GET_MODE (to);\n+  machine_mode mode = GET_MODE (to);\n \n   if (optimize && before && already_contains (to, from))\n     {\n@@ -2511,7 +2511,7 @@ static rtx\n move_to_acc (int opno, rtx before)\n {\n   rtx src = OP (opno);\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n \n   if (REG_P (src) && REGNO (src) < 2)\n     return src;\n@@ -2525,7 +2525,7 @@ move_to_acc (int opno, rtx before)\n static void\n force_into_acc (rtx src, rtx before)\n {\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n   rtx move;\n \n   if (REG_P (src) && REGNO (src) < 2)\n@@ -2545,7 +2545,7 @@ static rtx\n move_from_acc (unsigned int opno, rtx after)\n {\n   rtx dest = OP (opno);\n-  enum machine_mode mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (dest);\n \n   if (REG_P (dest) && REGNO (dest) < 2)\n     return dest;\n@@ -2558,7 +2558,7 @@ move_from_acc (unsigned int opno, rtx after)\n static rtx\n move_acc_to_reg (rtx acc, int regno, rtx before)\n {\n-  enum machine_mode mode = GET_MODE (acc);\n+  machine_mode mode = GET_MODE (acc);\n   rtx reg;\n \n   reg = gen_rtx_REG (mode, regno);\n@@ -2572,7 +2572,7 @@ static rtx\n move_to_x (int opno, rtx before)\n {\n   rtx src = OP (opno);\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n   rtx reg;\n \n   if (mode == VOIDmode)\n@@ -2595,7 +2595,7 @@ static rtx\n move_to_hl (int opno, rtx before)\n {\n   rtx src = OP (opno);\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n   rtx reg;\n \n   if (mode == VOIDmode)\n@@ -2618,7 +2618,7 @@ static rtx\n move_to_de (int opno, rtx before)\n {\n   rtx src = OP (opno);\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n   rtx reg;\n \n   if (mode == VOIDmode)\n@@ -3746,7 +3746,7 @@ static bool rl78_rtx_costs (rtx   x,\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE rl78_unwind_word_mode\n \n-static enum machine_mode\n+static machine_mode\n rl78_unwind_word_mode (void)\n {\n   return HImode;"}, {"sha": "d46ef191409211a0a9d213b57fb4e657cd5a3cb4", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -244,7 +244,7 @@\n   [(const_int 0)]\n {\n   rtx dest = operands[0];\n-  enum machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[0]);\n   rtvec v;\n   int i, num_elements;\n \n@@ -273,7 +273,7 @@\n {\n   rtx dup = gen_easy_altivec_constant (operands[1]);\n   rtx const_vec;\n-  enum machine_mode op_mode = <MODE>mode;\n+  machine_mode op_mode = <MODE>mode;\n \n   /* Divide the operand of the resulting VEC_DUPLICATE, and use\n      simplify_rtx to make a CONST_VECTOR.  */"}, {"sha": "8fa791e8494cae577056e6b2adcf8d599c45add6", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -4436,7 +4436,7 @@ assignment for unaligned loads and stores\");\n       tree arg1_inner_type;\n       tree decl, stmt;\n       tree innerptrtype;\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       /* No second argument. */\n       if (nargs != 2)\n@@ -4538,7 +4538,7 @@ assignment for unaligned loads and stores\");\n       tree arg1_inner_type;\n       tree decl, stmt;\n       tree innerptrtype;\n-      enum machine_mode mode;\n+      machine_mode mode;\n \n       /* No second or third arguments. */\n       if (nargs != 3)"}, {"sha": "8d27a6986eadb14abf7127f0f30419623121f683", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7", "patch": "@@ -27,24 +27,24 @@\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int,\n-\t\t\t\t  tree, enum machine_mode);\n+\t\t\t\t  tree, machine_mode);\n #endif /* TREE_CODE */\n \n-extern bool easy_altivec_constant (rtx, enum machine_mode);\n+extern bool easy_altivec_constant (rtx, machine_mode);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n-extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n-extern int num_insns_constant (rtx, enum machine_mode);\n+extern bool macho_lo_sum_memory_operand (rtx, machine_mode);\n+extern int num_insns_constant (rtx, machine_mode);\n extern int num_insns_constant_wide (HOST_WIDE_INT);\n-extern int small_data_operand (rtx, enum machine_mode);\n-extern bool mem_operand_gpr (rtx, enum machine_mode);\n+extern int small_data_operand (rtx, machine_mode);\n+extern bool mem_operand_gpr (rtx, machine_mode);\n extern bool toc_relative_expr_p (const_rtx, bool);\n-extern bool invalid_e500_subreg (rtx, enum machine_mode);\n-extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n-extern bool legitimate_constant_pool_address_p (const_rtx, enum machine_mode,\n+extern bool invalid_e500_subreg (rtx, machine_mode);\n+extern void validate_condition_mode (enum rtx_code, machine_mode);\n+extern bool legitimate_constant_pool_address_p (const_rtx, machine_mode,\n \t\t\t\t\t\tbool);\n extern bool legitimate_indirect_address_p (rtx, int);\n extern bool legitimate_indexed_address_p (rtx, int);\n-extern bool avoiding_indexed_address_p (enum machine_mode);\n+extern bool avoiding_indexed_address_p (machine_mode);\n \n extern rtx rs6000_got_register (rtx);\n extern rtx find_addr_reg (rtx);\n@@ -60,9 +60,9 @@ extern void rs6000_expand_vector_extract (rtx, rtx, int);\n extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n extern bool rs6000_expand_vec_perm_const (rtx op[4]);\n-extern void altivec_expand_lvx_be (rtx, rtx, enum machine_mode, unsigned);\n-extern void altivec_expand_stvx_be (rtx, rtx, enum machine_mode, unsigned);\n-extern void altivec_expand_stvex_be (rtx, rtx, enum machine_mode, unsigned);\n+extern void altivec_expand_lvx_be (rtx, rtx, machine_mode, unsigned);\n+extern void altivec_expand_stvx_be (rtx, rtx, machine_mode, unsigned);\n+extern void altivec_expand_stvex_be (rtx, rtx, machine_mode, unsigned);\n extern void rs6000_expand_extract_even (rtx, rtx, rtx);\n extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);\n extern void rs6000_scale_v2df (rtx, rtx, int);\n@@ -86,13 +86,13 @@ extern const char *emit_fusion_gpr_load (rtx, rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n-\t\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t\t    rtx);\n extern bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class,\n \t\t\t\t\t\t   enum reg_class,\n-\t\t\t\t\t\t   enum machine_mode);\n-extern bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n-\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t   machine_mode);\n+extern bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n+\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t    enum reg_class);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n extern void rs6000_secondary_reload_gpr (rtx, rtx, rtx, bool);\n@@ -107,11 +107,11 @@ extern int extract_ME (rtx);\n extern void rs6000_output_function_entry (FILE *, const char *);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n-extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n+extern enum rtx_code rs6000_reverse_condition (machine_mode,\n \t\t\t\t\t       enum rtx_code);\n-extern void rs6000_emit_sISEL (enum machine_mode, rtx[]);\n-extern void rs6000_emit_sCOND (enum machine_mode, rtx[]);\n-extern void rs6000_emit_cbranch (enum machine_mode, rtx[]);\n+extern void rs6000_emit_sISEL (machine_mode, rtx[]);\n+extern void rs6000_emit_sCOND (machine_mode, rtx[]);\n+extern void rs6000_emit_cbranch (machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx_insn *);\n extern char * output_e500_flip_gt_bit (rtx, rtx);\n extern const char * output_probe_stack_range (rtx, rtx);\n@@ -124,19 +124,19 @@ extern void rs6000_expand_atomic_exchange (rtx op[]);\n extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_swdiv (rtx, rtx, rtx, bool);\n extern void rs6000_emit_swrsqrt (rtx, rtx);\n-extern void output_toc (FILE *, rtx, int, enum machine_mode);\n+extern void output_toc (FILE *, rtx, int, machine_mode);\n extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n-extern void rs6000_emit_le_vsx_move (rtx, rtx, enum machine_mode);\n-extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n-extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n-extern enum machine_mode rs6000_secondary_memory_needed_mode (enum\n+extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n+extern void rs6000_emit_move (rtx, rtx, machine_mode);\n+extern rtx rs6000_secondary_memory_needed_rtx (machine_mode);\n+extern machine_mode rs6000_secondary_memory_needed_mode (enum\n \t\t\t\t\t\t\t      machine_mode);\n-extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode,\n+extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n-extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx,\n+extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,\n \t\t\t\t\t\tbool, bool);\n extern rtx rs6000_find_base_term (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n@@ -145,11 +145,11 @@ extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);\n extern void rs6000_emit_popcount (rtx, rtx);\n extern void rs6000_emit_parity (rtx, rtx);\n \n-extern rtx rs6000_machopic_legitimize_pic_address (rtx, enum machine_mode,\n+extern rtx rs6000_machopic_legitimize_pic_address (rtx, machine_mode,\n \t\t\t\t\t\t   rtx);\n extern rtx rs6000_address_for_fpconvert (rtx);\n extern rtx rs6000_address_for_altivec (rtx);\n-extern rtx rs6000_allocate_stack_temp (enum machine_mode, bool, bool);\n+extern rtx rs6000_allocate_stack_temp (machine_mode, bool, bool);\n extern int rs6000_loop_align (rtx);\n extern void rs6000_split_logical (rtx [], enum rtx_code, bool, bool, bool);\n #endif /* RTX_CODE */\n@@ -162,7 +162,7 @@ extern unsigned int rs6000_special_round_type_align (tree, unsigned int,\n extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,\n \t\t\t\t\t\t\t    unsigned int);\n extern tree altivec_resolve_overloaded_builtin (location_t, tree, void *);\n-extern rtx rs6000_libcall_value (enum machine_mode);\n+extern rtx rs6000_libcall_value (machine_mode);\n extern rtx rs6000_va_arg (tree, tree);\n extern int function_ok_for_sibcall (tree);\n extern int rs6000_reg_parm_stack_space (tree, bool);\n@@ -172,7 +172,7 @@ extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n extern bool rs6000_elf_in_small_data_p (const_tree);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding (enum machine_mode, const_tree);\n+extern enum direction function_arg_padding (machine_mode, const_tree);\n #endif /* ARGS_SIZE_RTX */\n \n #endif /* TREE_CODE */"}, {"sha": "4adb168dda93b29d02170c218576950887711d6c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "5af255caa924ee8ecfe953e4ff4003d4d65ca4c2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "da61621fe0751588c27033733c6e823e98429a22", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "0aeb611d97b2af0e197d4551e12e1d786fc4ac10", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "fd6fc6350a7fd41893e184110183a754c3629c38", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "594b5762a984523b13dfb5a7e9febc0a16f405ac", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "874eb7c32dc17696374506c7571c8a38ab7d5d32", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "0a935eec7816420fc2425253051d714181e92f1b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b9fbf23513d5d299ac5df1c979e00932dbf22763", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "52267f71d23630b867693d49493fb3aa3b8f131b", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e01b91e2db7946d9e7f41c00f0b710536e87c49f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "1dc1bf43bcba535cc927af98ebee366b6196a87a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "8246143fc5174bca569b3d62d41dc1addb032e68", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "271817245759722e28cc50dd76e91e7f9b530498", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cb887fa5668467f82da54de0456f596777e1e5a6", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6287348715bea79766dc1339e563cd3a7d0a8d2b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c3995b245b83fd9d089ffdddbd1c5c292cb00891", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "323a66ca8eb8c9ef111b0467d315f9bae61082c4", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "eef42f0970c8ce6adbc3340347366112574fa654", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6acf613d73e81170b18587f2a68405f5e72fa21f", "filename": "gcc/config/stormy16/stormy16-protos.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "52d02392f2847c6334d2090e5288ad299ed9289b", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d45d9e35c98691534d3bc6014894b7deb38a0737", "filename": "gcc/config/tilegx/tilegx-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e807ffffb050bbcdd5b0d548d363ef53bb793fb3", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a555a54472754aabc4fcfc88069153b9db90df87", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "69b14aa6adb282596eb1a05ea5d24547190a42f7", "filename": "gcc/config/tilepro/tilepro-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "9fdfb42dab0020f2c46f4d188c33d019c4665d79", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cffc62b57cfd1764356b1bd568e011a1dabcbeda", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bdeb56b2368a520c67953300f154e750d35bcf66", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b1383fa60201e894dc482f5390efea8cc1f6166d", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cec2aee076a4d35c8c5a1193608b63b60f417e56", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bf12f89a86dfcc85fea9a43ceee29d08843cc531", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "fb9136832e77267324f3ffa64535ee9d113e5d4f", "filename": "gcc/config/vms/vms-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvms%2Fvms-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fvms%2Fvms-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms-c.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bc9ae83273c9d4027d197bcbe2b118aa51a7320c", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cce0d5806442e60d28a1efb4b4bae22feed9b342", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "beaa02f6a30174a39f922aeefc0cb7c5fefbdbe1", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c86f85bc644eee8d6c3f0bdfff3043058801d7d6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "3901e9a53da9913a7de94d0891547c6584828363", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "15ebc17ab75a929890cf2268c87ee6b935541d4c", "filename": "gcc/cprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d3bc84ac9d608471f26986fe4066c165b686ad6a", "filename": "gcc/cse.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6affd28f247c5a5117d9d877202fbcfc3a57b80d", "filename": "gcc/cselib.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e7656f99ce2860f0a2280390c6556e50c95918dd", "filename": "gcc/cselib.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b41096dd6f66dadc19144a2e7f7834f5d1f6855e", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b370d512e782aa05fc61816405636b6ada6e3bd1", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "43b5f86c9ddff52cd4d2751e75db889ccd57eec2", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "50626fd85e14ee942be20aace5b1befca9b83c95", "filename": "gcc/dfp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f841859eaa14a40a1268fcf8ea7341918cc26aa2", "filename": "gcc/dfp.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdfp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdfp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6404147579ebf11651884ad646d6221ce39583ef", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "109cea587453eda29c65966d29bcbfb12bb1f625", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bb04401209afe2c12d9e8ab0108d7a0611e9e960", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "aa19360d5b700354983b84bd35d063b68dade0d5", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "4040a6d4c3aba462cb5e1c07fc1fc5f31e3fbc88", "filename": "gcc/dojump.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "9a8f3cf0328c2606427e88d5cad21f6174c8e2cc", "filename": "gcc/dse.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f2d628cbe7ac39578be5e6c0493a846c726d4af1", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "7a29aae0bf815b956e0f8ff5085fec6abc323405", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a10cee81617336b307d0dc50792acd4297164396", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "1606232f46232f4c87e16fd360837b7c08258e81", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "3e02cdcf694400433501d356fa17b19bda326447", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "39bede08020e074f25b99916ca47bc49851d6491", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "19024b571abce3b5ffed4613a80431a810d6e6fd", "filename": "gcc/explow.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "2f53ecff102edcb021592f8fba1f3ba25b933c7b", "filename": "gcc/expmed.c", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "446341ef037e09b23aa395703247b2a8f2f331dd", "filename": "gcc/expmed.h", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "9b81e628cb0975929dc88a0f6eb1e7ad6d84b648", "filename": "gcc/expr.c", "status": "modified", "additions": 145, "deletions": 145, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "ba93693cda4a37ae6ae6208de0f459ebc9efb533", "filename": "gcc/expr.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f7ede57da44d8a47ff89305f7081631a6568cb31", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cd65b9cb56d68ce09d05fbf6bc13f3ed5aba0c6d", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "73226a8b38c5bb7d5b971ce074af9997b6d085cc", "filename": "gcc/fixed-value.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b5d16d272e14100e98498c5140f2c8e659af8f95", "filename": "gcc/fold-const.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d05fa8296bd38e0bc9b7f6c1845f5dc0a685510c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "060bf58ebb36eeada133c165e3518507591bbd01", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b91da2ca0538384584e0da2de989bfdb2bc5c8d1", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "85cf10388d47f29bda6e97ddd2cbe334d59869d9", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "4dfc5bc0f655d62642bc9df05a36b91647e4047c", "filename": "gcc/function.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "377b33c0217c8035009a32bab8c50423a0031ad2", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c4467d2d83c40f7973627e6fe40ed9725f0297c6", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "aa85c28656a3ff52bd4f5b34c75f2e6e6263f6a0", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d55d53041f6238d8c7ea87f9a6c03f7635063cba", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bb9dbbf508e452738480d9f1ed5e62028ad6c109", "filename": "gcc/genmodes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b8a282779de1731d0e589834e380594d6aabc3a2", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d667b94b37bde42c89e76ee4804ef888eb90f92f", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bbfd644b772db27208e778dbaf4cbbbc438dc867", "filename": "gcc/genpreds.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "0c0e0228e155a60f3db4656f0897665daeee2555", "filename": "gcc/genrecog.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "bcf040258d82a6c39243d64f685791943f305d99", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "4de84cfec171a3571965aa8da4c1826732082215", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "dadced939f9db1f25d446fdf196ba141d3145b68", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "011b237bf87fdcccbd41b7c25d2797712a146817", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "41a893eb996a487ccf43fa48539a8e3225445a78", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "db3187e491ffcae8a46e34307ad2d072ac620312", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b5b158752c27b1a840ff8c00512ee63acbac98ef", "filename": "gcc/hooks.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "90b31fb5d18b3a64bb6a18da4517f0b112197f52", "filename": "gcc/hooks.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "8cf0a95c2aeb1914294aff5907daf514cc6d3b24", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b32ce962c1cdfb1629ee4d7f49618874ae6e5638", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "af82b718fba053dbd55f8dba80c952f46c061bf3", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "39387c84ed10ad90ccdc983a7d40d4ee378667b6", "filename": "gcc/ira-color.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "7aaf0cb9948b94d016e9c3452e181ac04419434c", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "122815b80ffe6253d1e176ef6a4c4c954c70c57c", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d246b7ff019360708d95f259facfe321e7937777", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b5d00e58852a688b7820ec01ad3da30533b7444f", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "0604c47060997c6c4364707ecfa4cc5dadd59bef", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "630df40ead673f4398b9ad6394979e9800710461", "filename": "gcc/ira.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b294ea1b26f0e1f1f0a1f0d96d88bf9daf227186", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "4a027e26e72994b540f1bd1c08e9b09367d02f9f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "7c6b0ab2b6d24478e1cb8fb4cb4129a0aeddfced", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "7b827df036c8709b8d4d9ba177baaf8018204875", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d68ef45e708842901efe8a6454874a30dbf676ae", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6a30a0cd86b44d4a0247a11dfd0beaa36e9cca51", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "84449bf5d6d36b72c9ff14420024a8cadbda2cd3", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cbee5691f67216ccd47fe05c14b10929d062cfa4", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cf5df97f23341e67c663c73888068685bbe0c0ec", "filename": "gcc/lists.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f252fec76b151572c5ea3c970b84e6c1c616beea", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "19e536f5a426761f68e7fe51d76d22814f6dcc25", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "8ea458c3fc53c08f066f64ef3360c147017128b0", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "ec33f7495abcbe294acc484cbc176b2f28c91841", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "1eef803b394ad9079de8a9622f22ae46b0e08dc5", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "8c590473f7910fb75aba77063c64c566c0cd5380", "filename": "gcc/lower-subreg.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flower-subreg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flower-subreg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "d35f1126773cc5bae0da111c76aef5008acec5b9", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "36405d253929b69e11f7b22b687126b9850477a6", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e742ebaf0adcc0239bb0701d08de2c964ba56984", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "ae4164f21678b7205ada8e8311f00c2f26ccb4c1", "filename": "gcc/lra-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6a494032e6503ffe05a1f2fa3c7d40b22742dd5d", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a4ffc8578e6781bd2964075b96c945c91c5bd211", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c2c0fc3aad2c031e8f31bf4ccb5e0a13d43e64f9", "filename": "gcc/lra.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "48bf314db9f1a9c39c935fbecf9aad674a5e7acd", "filename": "gcc/lra.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cbd1af51f14255482370c808e1ac59e7e7ab9f87", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a4ae2a80a6882a21ed8068b289d0bbde7e99d164", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "940b953f8d7fb6a75879888fb6ddb2775858f816", "filename": "gcc/machmode.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "91f8e8f5b1dfcde8487f9e1f88535be41396fbbe", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a9a546ee8a946be5883eb17299500d3839c87b70", "filename": "gcc/optabs.c", "status": "modified", "additions": 193, "deletions": 193, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "1ed795711dfb940da6d1424d8f5eeaf4aeb5c557", "filename": "gcc/optabs.h", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f213b9964297eebe5e47b1077018a81e03b73233", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "2e44b0d73ac9b276e642d91ad768f4c8d1864a60", "filename": "gcc/postreload.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a3a64bb390f2ceb7b845a127a63e8339c4409492", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b2270dcf211f2af56fe8d4c87fd8e0178785f484", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cebbe8d7a7ec99de7f99dad0ac16e11b1ee90e85", "filename": "gcc/real.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "138b1565bb9a0cfd2268d4f90afa9fae647c0752", "filename": "gcc/real.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "410edb17d19e713de01833549e02359036d40a16", "filename": "gcc/recog.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "19eb952e9b72c918f056b514ee811e021a9c6179", "filename": "gcc/recog.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "a89427a399e89ac3d186d4b82c471f30856791fb", "filename": "gcc/ree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "5a9a75e595ac1e39546804c4e6755aeb9444bf93", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "daeb9801474046d202651a3acddbd5d8fb848c4a", "filename": "gcc/regcprop.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "efe23cdc41f918a2bd5832e6a117ac0c1e19e0a7", "filename": "gcc/reginfo.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "66f562bbbc3e247233d4819cd1fb8aef0959f012", "filename": "gcc/regrename.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "cc12a5101dae9cf2eb5dfbe0b2535c4ccb35612a", "filename": "gcc/regs.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "70f346a3da74a33ce822c19f5b485c2da2b83d1b", "filename": "gcc/reload.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "b52f408311e7c16f1315ca7f4e5c44eb2f93e31b", "filename": "gcc/reload.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "77d904263a088245ab7320a58130b1e061917a0c", "filename": "gcc/reload1.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c47ce03a83d319feb2b560e45dd923e83506971d", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "fec9658ec290c0b1c292b7e9ab94825a0b0a304b", "filename": "gcc/rtl.h", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c9bf69c4717b9169ac9f5a567996bd7df0d2deca", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "db103e370ad825b1413d15e461aa1bcd442359ee", "filename": "gcc/rtlhash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhash.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "c5e6c098de11e850abe34e92262696a069d337a4", "filename": "gcc/rtlhooks-def.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks-def.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "05b46c3aa9dfb874980795f72a87dc62379c5f5e", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6cdb95a27bb51bfc4a592d00af5d5d8f04cb64f1", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "edc6d52a5942a5a1c0dfb12890faf4d0a178fd7c", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "ac9faa44e82dc88912ddb9888007de4d922b1b6e", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "09ae52f0e28ea7c56625c7c5a1939a7bb94cc5f6", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e755a19428433afeadb76de7c21bf7c3d9240a98", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "be1632448a8977a9375ff129ecfac2c93f31e632", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "04303676e8fbab62561b0aec9b3284ccea9366ee", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "6a3c21210b2301bd284cbe6e091c6bbb93f0fa8b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "5c9b148e0550518e5404ef5b5abc99957c864b61", "filename": "gcc/stor-layout.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstor-layout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Fstor-layout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "14e19e838a8b049a166616c29a4ff5a3c933736c", "filename": "gcc/target.def", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "e482991d6eb5acc74825f26c8293d467556841e5", "filename": "gcc/targhooks.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "25f4feda940ada10828a4623c0d35462d050b93a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f16ef6ab4e753345e17c7afa010061bb400f2392", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "5f8930a0450a6d9e854e612440b866bcebae2270", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "f7f2135bbdaa03fc46b0b5d731714329d1e0183a", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "dd367057139d82830da5daba7b3f3c6bc5a7bb5e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "77c35007eebe84c35018947aa3b9d112c4c660fc", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "595c05b46d79559c03954796e090460cd6437f41", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "2025b384b7fc6e2c4fa228d82d1c8c1aacb257f6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}, {"sha": "45974bce74da255f2cedaa83692bc1c2c9f7fdab", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4bddc299eae13cc25e50eebc523a4963e0a5f7/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ef4bddc299eae13cc25e50eebc523a4963e0a5f7"}]}