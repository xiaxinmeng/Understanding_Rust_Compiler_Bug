{"sha": "ec64af64d6829135a7d8b5254f3b7881a18b5aba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2NGFmNjRkNjgyOTEzNWE3ZDhiNTI1NGYzYjc4ODFhMThiNWFiYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-09T13:20:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-09T13:20:11Z"}, "message": "tree-ssa-copy.c (cached_last_copy_of): Remove.\n\n2010-08-07  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-copy.c (cached_last_copy_of): Remove.\n\t(valueize_val): New function.\n\t(get_last_copy_of): Remove.\n\t(set_copy_of_val): Simplify.\n\t(dump_copy_of): Likewise.\n\t(copy_prop_visit_cond_stmt): Use valueize_val.\n\t(copy_prop_visit_phi_node): Properly handle unvisited names.\n\tDrop code managing copy-of chains.\n\t(init_copy_prop): Adjust.\n\t(fini_copy_prop): Likewise.\n\t(execute_copy_prop): Remove obsolete comment.\n\nFrom-SVN: r163032", "tree": {"sha": "2b985a84b8cb4a024b34bd6809bf439d216db0a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b985a84b8cb4a024b34bd6809bf439d216db0a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec64af64d6829135a7d8b5254f3b7881a18b5aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec64af64d6829135a7d8b5254f3b7881a18b5aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec64af64d6829135a7d8b5254f3b7881a18b5aba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec64af64d6829135a7d8b5254f3b7881a18b5aba/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37609bf08645fad9c5ea1cd8e06195c6d0fd2c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37609bf08645fad9c5ea1cd8e06195c6d0fd2c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37609bf08645fad9c5ea1cd8e06195c6d0fd2c7d"}], "stats": {"total": 282, "additions": 68, "deletions": 214}, "files": [{"sha": "1b103cbc1b6be15cdd7b7bca1a42cf217b54c81a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec64af64d6829135a7d8b5254f3b7881a18b5aba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec64af64d6829135a7d8b5254f3b7881a18b5aba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec64af64d6829135a7d8b5254f3b7881a18b5aba", "patch": "@@ -1,3 +1,17 @@\n+2010-08-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-copy.c (cached_last_copy_of): Remove.\n+\t(valueize_val): New function.\n+\t(get_last_copy_of): Remove.\n+\t(set_copy_of_val): Simplify.\n+\t(dump_copy_of): Likewise.\n+\t(copy_prop_visit_cond_stmt): Use valueize_val.\n+\t(copy_prop_visit_phi_node): Properly handle unvisited names.\n+\tDrop code managing copy-of chains.\n+\t(init_copy_prop): Adjust.\n+\t(fini_copy_prop): Likewise.\n+\t(execute_copy_prop): Remove obsolete comment.\n+\n 2010-08-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/44632"}, {"sha": "e148b8d670e06b77ca19f70f1837625b7410f420", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 54, "deletions": 214, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec64af64d6829135a7d8b5254f3b7881a18b5aba/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec64af64d6829135a7d8b5254f3b7881a18b5aba/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=ec64af64d6829135a7d8b5254f3b7881a18b5aba", "patch": "@@ -274,31 +274,23 @@ propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n /*---------------------------------------------------------------------------\n \t\t\t\tCopy propagation\n ---------------------------------------------------------------------------*/\n-/* During propagation, we keep chains of variables that are copies of\n-   one another.  If variable X_i is a copy of X_j and X_j is a copy of\n-   X_k, COPY_OF will contain:\n+/* Lattice for copy-propagation.  The lattice is initialized to\n+   UNDEFINED (value == NULL) for SSA names that can become a copy\n+   of something or VARYING (value == self) if not (see get_copy_of_val\n+   and stmt_may_generate_copy).  Other values make the name a COPY\n+   of that value.\n \n-   \tCOPY_OF[i].VALUE = X_j\n-\tCOPY_OF[j].VALUE = X_k\n-\tCOPY_OF[k].VALUE = X_k\n-\n-   After propagation, the copy-of value for each variable X_i is\n-   converted into the final value by walking the copy-of chains and\n-   updating COPY_OF[i].VALUE to be the last element of the chain.  */\n+   When visiting a statement or PHI node the lattice value for an\n+   SSA name can transition from UNDEFINED to COPY to VARYING.  */\n \n struct prop_value_d {\n     /* Copy-of value.  */\n     tree value;\n };\n-\n typedef struct prop_value_d prop_value_t;\n \n static prop_value_t *copy_of;\n \n-/* Used in set_copy_of_val to determine if the last link of a copy-of\n-   chain has changed.  */\n-static tree *cached_last_copy_of;\n-\n \n /* Return true if this statement may generate a useful copy.  */\n \n@@ -346,82 +338,38 @@ get_copy_of_val (tree var)\n   return val;\n }\n \n+/* Return the variable VAR is a copy of or VAR if VAR isn't the result\n+   of a copy.  */\n \n-/* Return last link in the copy-of chain for VAR.  */\n-\n-static tree\n-get_last_copy_of (tree var)\n+static inline tree\n+valueize_val (tree var)\n {\n-  tree last;\n-  int i;\n-\n-  /* Traverse COPY_OF starting at VAR until we get to the last\n-     link in the chain.  Since it is possible to have cycles in PHI\n-     nodes, the copy-of chain may also contain cycles.\n-\n-     To avoid infinite loops and to avoid traversing lengthy copy-of\n-     chains, we artificially limit the maximum number of chains we are\n-     willing to traverse.\n-\n-     The value 5 was taken from a compiler and runtime library\n-     bootstrap and a mixture of C and C++ code from various sources.\n-     More than 82% of all copy-of chains were shorter than 5 links.  */\n-#define LIMIT\t5\n-\n-  last = var;\n-  for (i = 0; i < LIMIT; i++)\n+  if (TREE_CODE (var) == SSA_NAME)\n     {\n-      tree copy = copy_of[SSA_NAME_VERSION (last)].value;\n-      if (copy == NULL_TREE || copy == last)\n-\tbreak;\n-      last = copy;\n+      tree val = get_copy_of_val (var)->value;\n+      if (val)\n+\treturn val;\n     }\n-\n-  /* If we have reached the limit, then we are either in a copy-of\n-     cycle or the copy-of chain is too long.  In this case, just\n-     return VAR so that it is not considered a copy of anything.  */\n-  return (i < LIMIT ? last : var);\n+  return var;\n }\n \n-\n-/* Set FIRST to be the first variable in the copy-of chain for DEST.\n-   If DEST's copy-of value or its copy-of chain has changed, return\n-   true.\n-\n-   MEM_REF is the memory reference where FIRST is stored.  This is\n-   used when DEST is a non-register and we are copy propagating loads\n-   and stores.  */\n+/* Set VAL to be the copy of VAR.  If that changed return true.  */\n \n static inline bool\n-set_copy_of_val (tree dest, tree first)\n+set_copy_of_val (tree var, tree val)\n {\n-  unsigned int dest_ver = SSA_NAME_VERSION (dest);\n-  tree old_first, old_last, new_last;\n+  unsigned int ver = SSA_NAME_VERSION (var);\n+  tree old;\n \n   /* Set FIRST to be the first link in COPY_OF[DEST].  If that\n      changed, return true.  */\n-  old_first = copy_of[dest_ver].value;\n-  copy_of[dest_ver].value = first;\n+  old = copy_of[ver].value;\n+  copy_of[ver].value = val;\n \n-  if (old_first != first)\n+  if (old != val)\n     return true;\n \n-  /* If FIRST and OLD_FIRST are the same, we need to check whether the\n-     copy-of chain starting at FIRST ends in a different variable.  If\n-     the copy-of chain starting at FIRST ends up in a different\n-     variable than the last cached value we had for DEST, then return\n-     true because DEST is now a copy of a different variable.\n-\n-     This test is necessary because even though the first link in the\n-     copy-of chain may not have changed, if any of the variables in\n-     the copy-of chain changed its final value, DEST will now be the\n-     copy of a different variable, so we have to do another round of\n-     propagation for everything that depends on DEST.  */\n-  old_last = cached_last_copy_of[dest_ver];\n-  new_last = get_last_copy_of (dest);\n-  cached_last_copy_of[dest_ver] = new_last;\n-\n-  return (old_last != new_last);\n+  return false;\n }\n \n \n@@ -431,50 +379,31 @@ static void\n dump_copy_of (FILE *file, tree var)\n {\n   tree val;\n-  sbitmap visited;\n \n   print_generic_expr (file, var, dump_flags);\n-\n   if (TREE_CODE (var) != SSA_NAME)\n     return;\n \n-  visited = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (visited);\n-  SET_BIT (visited, SSA_NAME_VERSION (var));\n-\n+  val = copy_of[SSA_NAME_VERSION (var)].value;\n   fprintf (file, \" copy-of chain: \");\n-\n-  val = var;\n-  print_generic_expr (file, val, 0);\n+  print_generic_expr (file, var, 0);\n   fprintf (file, \" \");\n-  while (copy_of[SSA_NAME_VERSION (val)].value)\n+  if (!val)\n+    fprintf (file, \"[UNDEFINED]\");\n+  else if (val == var)\n+    fprintf (file, \"[NOT A COPY]\");\n+  else\n     {\n       fprintf (file, \"-> \");\n-      val = copy_of[SSA_NAME_VERSION (val)].value;\n       print_generic_expr (file, val, 0);\n       fprintf (file, \" \");\n-      if (TEST_BIT (visited, SSA_NAME_VERSION (val)))\n-        break;\n-      SET_BIT (visited, SSA_NAME_VERSION (val));\n+      fprintf (file, \"[COPY]\");\n     }\n-\n-  val = get_copy_of_val (var)->value;\n-  if (val == NULL_TREE)\n-    fprintf (file, \"[UNDEFINED]\");\n-  else if (val != var)\n-    fprintf (file, \"[COPY]\");\n-  else\n-    fprintf (file, \"[NOT A COPY]\");\n-\n-  sbitmap_free (visited);\n }\n \n \n /* Evaluate the RHS of STMT.  If it produces a valid copy, set the LHS\n-   value and store the LHS into *RESULT_P.  If STMT generates more\n-   than one name (i.e., STMT is an aliased store), it is enough to\n-   store the first name in the VDEF list into *RESULT_P.  After\n-   all, the names generated will be VUSEd in the same statements.  */\n+   value and store the LHS into *RESULT_P.  */\n \n static enum ssa_prop_result\n copy_prop_visit_assignment (gimple stmt, tree *result_p)\n@@ -485,7 +414,6 @@ copy_prop_visit_assignment (gimple stmt, tree *result_p)\n   lhs = gimple_assign_lhs (stmt);\n   rhs = gimple_assign_rhs1 (stmt);\n \n-\n   gcc_assert (gimple_assign_rhs_code (stmt) == SSA_NAME);\n \n   rhs_val = get_copy_of_val (rhs);\n@@ -531,8 +459,8 @@ copy_prop_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n      are predicates involving two SSA_NAMEs.  */\n   if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)\n     {\n-      op0 = get_last_copy_of (op0);\n-      op1 = get_last_copy_of (op1);\n+      op0 = valueize_val (op0);\n+      op1 = valueize_val (op1);\n \n       /* See if we can determine the predicate's value.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -642,7 +570,6 @@ copy_prop_visit_phi_node (gimple phi)\n     {\n       fprintf (dump_file, \"\\nVisiting PHI node: \");\n       print_gimple_stmt (dump_file, phi, 0, dump_flags);\n-      fprintf (dump_file, \"\\n\\n\");\n     }\n \n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n@@ -670,19 +597,15 @@ copy_prop_visit_phi_node (gimple phi)\n \t their loops and prevent coalescing opportunities.  If the\n \t value was loop invariant, it will be hoisted by LICM and\n \t exposed for copy propagation.  Not a problem for virtual\n-\t operands though.  */\n+\t operands though.\n+\t ???  The value will be always loop invariant.  */\n       if (is_gimple_reg (lhs)\n \t  && loop_depth_of_name (arg) > loop_depth_of_name (lhs))\n \t{\n \t  phi_val.value = lhs;\n \t  break;\n \t}\n \n-      /* If the LHS appears in the argument list, ignore it.  It is\n-\t irrelevant as a copy.  */\n-      if (arg == lhs || get_last_copy_of (arg) == lhs)\n-\tcontinue;\n-\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"\\tArgument #%d: \", i);\n@@ -692,38 +615,39 @@ copy_prop_visit_phi_node (gimple phi)\n \n       arg_val = get_copy_of_val (arg);\n \n+      /* If we didn't visit the definition of arg yet treat it as\n+         UNDEFINED.  This also handles PHI arguments that are the\n+\t same as lhs.  We'll come here again.  */\n+      if (!arg_val->value)\n+\tcontinue;\n+\n       /* If the LHS didn't have a value yet, make it a copy of the\n-\t first argument we find.  Notice that while we make the LHS be\n-\t a copy of the argument itself, we take the memory reference\n-\t from the argument's value so that we can compare it to the\n-\t memory reference of all the other arguments.  */\n+\t first argument we find.   */\n       if (phi_val.value == NULL_TREE)\n \t{\n-\t  phi_val.value = arg_val->value ? arg_val->value : arg;\n+\t  phi_val.value = arg_val->value;\n \t  continue;\n \t}\n \n       /* If PHI_VAL and ARG don't have a common copy-of chain, then\n-\t this PHI node cannot be a copy operation.  Also, if we are\n-\t copy propagating stores and these two arguments came from\n-\t different memory references, they cannot be considered\n-\t copies.  */\n-      if (get_last_copy_of (phi_val.value) != get_last_copy_of (arg))\n+\t this PHI node cannot be a copy operation.  */\n+      if (phi_val.value != arg_val->value)\n \t{\n \t  phi_val.value = lhs;\n \t  break;\n \t}\n     }\n \n-  if (phi_val.value &&  may_propagate_copy (lhs, phi_val.value)\n+  if (phi_val.value\n+      && may_propagate_copy (lhs, phi_val.value)\n       && set_copy_of_val (lhs, phi_val.value))\n     retval = (phi_val.value != lhs) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n   else\n     retval = SSA_PROP_NOT_INTERESTING;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"\\nPHI node \");\n+      fprintf (dump_file, \"PHI node \");\n       dump_copy_of (dump_file, lhs);\n       fprintf (dump_file, \"\\nTelling the propagator to \");\n       if (retval == SSA_PROP_INTERESTING)\n@@ -739,9 +663,7 @@ copy_prop_visit_phi_node (gimple phi)\n }\n \n \n-/* Initialize structures used for copy propagation.   PHIS_ONLY is true\n-   if we should only consider PHI nodes as generating copy propagation\n-   opportunities.  */\n+/* Initialize structures used for copy propagation.  */\n \n static void\n init_copy_prop (void)\n@@ -750,8 +672,6 @@ init_copy_prop (void)\n \n   copy_of = XCNEWVEC (prop_value_t, num_ssa_names);\n \n-  cached_last_copy_of = XCNEWVEC (tree, num_ssa_names);\n-\n   FOR_EACH_BB (bb)\n     {\n       gimple_stmt_iterator si;\n@@ -773,7 +693,8 @@ init_copy_prop (void)\n \t     Otherwise, this may move loop variant variables outside of\n \t     their loops and prevent coalescing opportunities.  If the\n \t     value was loop invariant, it will be hoisted by LICM and\n-\t     exposed for copy propagation.  */\n+\t     exposed for copy propagation.\n+\t     ???  This doesn't make sense.  */\n \t  if (stmt_ends_bb_p (stmt))\n             prop_set_simulate_again (stmt, true);\n \t  else if (stmt_may_generate_copy (stmt)\n@@ -790,8 +711,6 @@ init_copy_prop (void)\n \t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n             if (!prop_simulate_again_p (stmt))\n \t      set_copy_of_val (def, def);\n-\t    else\n-\t      cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n \t}\n \n       /* In loop-closed SSA form do not copy-propagate through\n@@ -820,8 +739,6 @@ init_copy_prop (void)\n \n \t  if (!prop_simulate_again_p (phi))\n \t    set_copy_of_val (def, def);\n-\t  else\n-\t    cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n \t}\n     }\n }\n@@ -855,8 +772,6 @@ fini_copy_prop (void)\n \t  || copy_of[i].value == var)\n \tcontinue;\n \n-      copy_of[i].value = get_last_copy_of (var);\n-\n       /* In theory the points-to solution of all members of the\n          copy chain is their intersection.  For now we do not bother\n \t to compute this but only make sure we do not lose points-to\n@@ -872,7 +787,6 @@ fini_copy_prop (void)\n \n   substitute_and_fold (get_value, NULL, true);\n \n-  free (cached_last_copy_of);\n   free (copy_of);\n }\n \n@@ -908,81 +822,7 @@ fini_copy_prop (void)\n    through edges marked executable by the propagation engine.  So,\n    when visiting statement #2 for the first time, we will only look at\n    the first argument (a_24) and optimistically assume that its value\n-   is the copy of a_24 (x_1).\n-\n-   The problem with this approach is that it may fail to discover copy\n-   relations in PHI cycles.  Instead of propagating copy-of\n-   values, we actually propagate copy-of chains.  For instance:\n-\n-   \t\tA_3 = B_1;\n-\t\tC_9 = A_3;\n-\t\tD_4 = C_9;\n-\t\tX_i = D_4;\n-\n-   In this code fragment, COPY-OF (X_i) = { D_4, C_9, A_3, B_1 }.\n-   Obviously, we are only really interested in the last value of the\n-   chain, however the propagator needs to access the copy-of chain\n-   when visiting PHI nodes.\n-\n-   To represent the copy-of chain, we use the array COPY_CHAINS, which\n-   holds the first link in the copy-of chain for every variable.\n-   If variable X_i is a copy of X_j, which in turn is a copy of X_k,\n-   the array will contain:\n-\n-\t\tCOPY_CHAINS[i] = X_j\n-\t\tCOPY_CHAINS[j] = X_k\n-\t\tCOPY_CHAINS[k] = X_k\n-\n-   Keeping copy-of chains instead of copy-of values directly becomes\n-   important when visiting PHI nodes.  Suppose that we had the\n-   following PHI cycle, such that x_52 is already considered a copy of\n-   x_53:\n-\n-\t    1\tx_54 = PHI <x_53, x_52>\n-\t    2\tx_53 = PHI <x_898, x_54>\n-\n-   Visit #1: x_54 is copy-of x_53 (because x_52 is copy-of x_53)\n-   Visit #2: x_53 is copy-of x_898 (because x_54 is a copy of x_53,\n-\t\t\t\t    so it is considered irrelevant\n-\t\t\t\t    as a copy).\n-   Visit #1: x_54 is copy-of nothing (x_53 is a copy-of x_898 and\n-\t\t\t\t      x_52 is a copy of x_53, so\n-\t\t\t\t      they don't match)\n-   Visit #2: x_53 is copy-of nothing\n-\n-   This problem is avoided by keeping a chain of copies, instead of\n-   the final copy-of value.  Propagation will now only keep the first\n-   element of a variable's copy-of chain.  When visiting PHI nodes,\n-   arguments are considered equal if their copy-of chains end in the\n-   same variable.  So, as long as their copy-of chains overlap, we\n-   know that they will be a copy of the same variable, regardless of\n-   which variable that may be).\n-\n-   Propagation would then proceed as follows (the notation a -> b\n-   means that a is a copy-of b):\n-\n-   Visit #1: x_54 = PHI <x_53, x_52>\n-\t\tx_53 -> x_53\n-\t\tx_52 -> x_53\n-\t\tResult: x_54 -> x_53.  Value changed.  Add SSA edges.\n-\n-   Visit #1: x_53 = PHI <x_898, x_54>\n-   \t\tx_898 -> x_898\n-\t\tx_54 -> x_53\n-\t\tResult: x_53 -> x_898.  Value changed.  Add SSA edges.\n-\n-   Visit #2: x_54 = PHI <x_53, x_52>\n-   \t\tx_53 -> x_898\n-\t\tx_52 -> x_53 -> x_898\n-\t\tResult: x_54 -> x_898.  Value changed.  Add SSA edges.\n-\n-   Visit #2: x_53 = PHI <x_898, x_54>\n-   \t\tx_898 -> x_898\n-\t\tx_54 -> x_898\n-\t\tResult: x_53 -> x_898.  Value didn't change.  Stable state\n-\n-   Once the propagator stabilizes, we end up with the desired result\n-   x_53 and x_54 are both copies of x_898.  */\n+   is the copy of a_24 (x_1).  */\n \n static unsigned int\n execute_copy_prop (void)"}]}