{"sha": "8baf60bbb8b762f777eeae3f147246ee6c04f1e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhZjYwYmJiOGI3NjJmNzc3ZWVhZTNmMTQ3MjQ2ZWU2YzA0ZjFlMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-25T12:20:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-25T12:20:33Z"}, "message": "(BYTE_LOADS_EXTEND, LOAD_EXTEND): Deleted.\n\n(subst, force_to_mode, nonzero_bits, num_sign_bit_copies): Use new\nmacros LOAD_EXTEND_OP and WORD_REGISTER_OPERATION instead of\nBYTE_LOADS_*_EXTEND and LOAD_EXTEND.\n\nFrom-SVN: r5473", "tree": {"sha": "6828fdd727bb8f1a26da2ff395a87c511829da4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6828fdd727bb8f1a26da2ff395a87c511829da4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8baf60bbb8b762f777eeae3f147246ee6c04f1e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baf60bbb8b762f777eeae3f147246ee6c04f1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8baf60bbb8b762f777eeae3f147246ee6c04f1e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baf60bbb8b762f777eeae3f147246ee6c04f1e3/comments", "author": null, "committer": null, "parents": [{"sha": "eb862a37359c52850d5077af6486f08a2196983b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb862a37359c52850d5077af6486f08a2196983b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb862a37359c52850d5077af6486f08a2196983b"}], "stats": {"total": 75, "additions": 33, "deletions": 42}, "files": [{"sha": "d6ce0348a4ff2710d8ab87ebad3232e5c12b72aa", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baf60bbb8b762f777eeae3f147246ee6c04f1e3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baf60bbb8b762f777eeae3f147246ee6c04f1e3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8baf60bbb8b762f777eeae3f147246ee6c04f1e3", "patch": "@@ -95,20 +95,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    Use gen_lowpart_for_combine instead.  See comments there.  */\n #define gen_lowpart dont_use_gen_lowpart_you_dummy\n \n-/* If byte loads either zero- or sign- extend, define BYTE_LOADS_EXTEND\n-   for cases when we don't care which is true.  Define LOAD_EXTEND to\n-   be ZERO_EXTEND or SIGN_EXTEND, depending on which was defined.  */\n-\n-#ifdef BYTE_LOADS_ZERO_EXTEND\n-#define BYTE_LOADS_EXTEND\n-#define LOAD_EXTEND ZERO_EXTEND\n-#endif\n-\n-#ifdef BYTE_LOADS_SIGN_EXTEND\n-#define BYTE_LOADS_EXTEND\n-#define LOAD_EXTEND SIGN_EXTEND\n-#endif\n-\n /* Number of attempts to combine instructions in this function.  */\n \n static int combine_attempts;\n@@ -4190,12 +4176,11 @@ subst (x, from, to, in_dest, unique_copy)\n \t We can always do this if M1 is narrower than M2 because that\n \t means that we only care about the low bits of the result.\n \n-\t However, on most machines (those with neither BYTE_LOADS_ZERO_EXTEND\n-\t nor BYTE_LOADS_SIGN_EXTEND defined), we cannot perform a\n-\t narrower operation that requested since the high-order bits will\n-\t be undefined.  On machine where BYTE_LOADS_*_EXTEND is defined,\n-\t however, this transformation is safe as long as M1 and M2 have\n-\t the same number of words.  */\n+\t However, on machines without WORD_REGISTER_OPERATIONS defined,\n+\t we cannot perform a narrower operation that requested since the\n+\t high-order bits will be undefined.  On machine where it is defined,\n+\t this transformation is safe as long as M1 and M2 have the same\n+\t number of words.  */\n  \n       if (GET_CODE (SET_SRC (x)) == SUBREG\n \t  && subreg_lowpart_p (SET_SRC (x))\n@@ -4204,7 +4189,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t       / UNITS_PER_WORD)\n \t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n \t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-#ifndef BYTE_LOADS_EXTEND\n+#ifndef WORD_REGISTER_OPERATIONS\n \t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n #endif\n@@ -4218,21 +4203,24 @@ subst (x, from, to, in_dest, unique_copy)\n \t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n \t}\n \n-#ifdef BYTE_LOADS_EXTEND\n+#ifdef LOAD_EXTEND_OP\n       /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with\n \t M wider than N, this would require a paradoxical subreg.\n \t Replace the subreg with a zero_extend to avoid the reload that\n \t would otherwise be required. */\n \n       if (GET_CODE (SET_SRC (x)) == SUBREG\n+\t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (SET_SRC (x)))) != NIL\n \t  && subreg_lowpart_p (SET_SRC (x))\n \t  && SUBREG_WORD (SET_SRC (x)) == 0\n \t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n \t  && GET_CODE (SUBREG_REG (SET_SRC (x))) == MEM)\n-\tSUBST (SET_SRC (x), gen_rtx_combine (LOAD_EXTEND,\n-\t\t\t\t\t     GET_MODE (SET_SRC (x)),\n-\t\t\t\t\t     XEXP (SET_SRC (x), 0)));\n+\tSUBST (SET_SRC (x),\n+\t       gen_rtx_combine (LOAD_EXTEND_OP (GET_MODE\n+\t\t\t\t\t\t(SUBREG_REG (SET_SRC (x)))),\n+\t\t\t\tGET_MODE (SET_SRC (x)),\n+\t\t\t\tXEXP (SET_SRC (x), 0)));\n #endif\n \n #ifndef HAVE_conditional_move\n@@ -5647,11 +5635,12 @@ force_to_mode (x, mode, mask, reg)\n     case SUBREG:\n       if (subreg_lowpart_p (x)\n \t  /* We can ignore the effect this SUBREG if it narrows the mode or,\n-\t     on machines where byte operations extend, if the constant masks\n-\t     to zero all the bits the mode doesn't have.  */\n+\t     on machines where register operations are performed on the full\n+\t     word, if the constant masks to zero all the bits the mode\n+\t     doesn't have.  */\n \t  && ((GET_MODE_SIZE (GET_MODE (x))\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-#ifdef BYTE_LOADS_EXTEND\n+#ifdef WORD_REGISTER_OPERATIONS\n \t      || (0 == (mask\n \t\t\t& GET_MODE_MASK (GET_MODE (x))\n \t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))\n@@ -6416,7 +6405,7 @@ nonzero_bits (x, mode)\n        just return the mode mask.  Those tests will then be false.  */\n     return nonzero;\n \n-#ifndef BYTE_LOADS_EXTEND\n+#ifndef WORD_REGISTER_OPERATIONS\n   /* If MODE is wider than X, but both are a single word for both the host\n      and target machines, we can compute this from which bits of the \n      object might be nonzero in its own mode, taking into account the fact\n@@ -6512,14 +6501,15 @@ nonzero_bits (x, mode)\n \n       return INTVAL (x);\n \n-#ifdef BYTE_LOADS_ZERO_EXTEND\n     case MEM:\n+#ifdef LOAD_EXTEND_OP\n       /* In many, if not most, RISC machines, reading a byte from memory\n \t zeros the rest of the register.  Noticing that fact saves a lot\n \t of extra zero-extends.  */\n-      nonzero &= GET_MODE_MASK (GET_MODE (x));\n-      break;\n+      if (LOAD_EXTEND_OP (GET_MODE (x)) == ZERO_EXTEND)\n+\tnonzero &= GET_MODE_MASK (GET_MODE (x));\n #endif\n+      break;\n \n     case EQ:  case NE:\n     case GT:  case GTU:\n@@ -6672,7 +6662,8 @@ nonzero_bits (x, mode)\n \t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n \t  nonzero &= nonzero_bits (SUBREG_REG (x), mode);\n-#ifndef BYTE_LOADS_EXTEND\n+\n+#ifndef WORD_REGISTER_OPERATIONS\n \t  /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n@@ -6797,11 +6788,13 @@ num_sign_bit_copies (x, mode)\n \treturn reg_sign_bit_copies[REGNO (x)];\n       break;\n \n-#ifdef BYTE_LOADS_SIGN_EXTEND\n     case MEM:\n+#ifdef LOAD_EXTEND_OP\n       /* Some RISC machines sign-extend all loads of smaller than a word.  */\n-      return MAX (1, bitwidth - GET_MODE_BITSIZE (GET_MODE (x)) + 1);\n+      if (LOAD_EXTEND_OP (GET_MODE (x)) == SIGN_EXTEND)\n+\treturn MAX (1, bitwidth - GET_MODE_BITSIZE (GET_MODE (x)) + 1);\n #endif\n+      break;\n \n     case CONST_INT:\n       /* If the constant is negative, take its 1's complement and remask.\n@@ -6831,18 +6824,16 @@ num_sign_bit_copies (x, mode)\n \t\t\t     - bitwidth)));\n \t}\n \n-#ifdef BYTE_LOADS_EXTEND\n-      /* For paradoxical SUBREGs, just look inside since, on machines with\n-\t one of these defined, we assume that operations are actually \n-\t performed on the full register.  Note that we are passing MODE\n-\t to the recursive call, so the number of sign bit copies will\n-\t remain relative to that mode, not the inner mode.  */\n+#ifdef WORD_REGISTER_OPERATIONS\n+      /* For paradoxical SUBREGs on machines where all register operations\n+\t affect the entire register, just look inside.  Note that we are\n+\t passing MODE to the recursive call, so the number of sign bit copies\n+\t will remain relative to that mode, not the inner mode.  */\n \n       if (GET_MODE_SIZE (GET_MODE (x))\n \t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \treturn num_sign_bit_copies (SUBREG_REG (x), mode);\n #endif\n-\n       break;\n \n     case SIGN_EXTRACT:"}]}