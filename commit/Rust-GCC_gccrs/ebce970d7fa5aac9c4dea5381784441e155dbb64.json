{"sha": "ebce970d7fa5aac9c4dea5381784441e155dbb64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjZTk3MGQ3ZmE1YWFjOWM0ZGVhNTM4MTc4NDQ0MWUxNTVkYmI2NA==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-20T06:05:04Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-20T06:05:04Z"}, "message": "[multiple changes]\n\n2005-04-20  Sven de Marothy  <sven@physto.se>\n\n\t* java/nio/ByteBufferImpl.java:\n\t(putChar): Inlined for speed.\n\t(put, get): Bulk methods can use arraycopy.\n\t* java/nio/CharBufferImpl.java:\n\t(put, get): Bulk methods can use arraycopy.\n\n2005-04-20  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/nio/ByteBufferImpl.java (get(), put(byte)): Inlined checks\n\tand field updates.\n\t* java/nio/CharBufferImpl.java\n\t(CharBufferImpl(CharBufferImpl)): Copy array_offset field.\n\t(get(), put(char)): Inlined checks and field updates. Fixed to\n\ttake array_offset into account.\n\t(get(int), put(int, char)): Fixed to take array_offset into account.\n\nFrom-SVN: r98445", "tree": {"sha": "299c11c27a0bdee12676f0fa833c032c9a885cc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/299c11c27a0bdee12676f0fa833c032c9a885cc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebce970d7fa5aac9c4dea5381784441e155dbb64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebce970d7fa5aac9c4dea5381784441e155dbb64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebce970d7fa5aac9c4dea5381784441e155dbb64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebce970d7fa5aac9c4dea5381784441e155dbb64/comments", "author": null, "committer": null, "parents": [{"sha": "ce254988cf72001d72092a6ec0935121bfe64185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce254988cf72001d72092a6ec0935121bfe64185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce254988cf72001d72092a6ec0935121bfe64185"}], "stats": {"total": 134, "additions": 113, "deletions": 21}, "files": [{"sha": "0270724fbe0c316cf81e71cdc33208e20394c95e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ebce970d7fa5aac9c4dea5381784441e155dbb64", "patch": "@@ -1,3 +1,21 @@\n+2005-04-20  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/nio/ByteBufferImpl.java:\n+\t(putChar): Inlined for speed.\n+\t(put, get): Bulk methods can use arraycopy.\n+\t* java/nio/CharBufferImpl.java:\n+\t(put, get): Bulk methods can use arraycopy.\n+\n+2005-04-20  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/nio/ByteBufferImpl.java (get(), put(byte)): Inlined checks\n+\tand field updates.\n+\t* java/nio/CharBufferImpl.java\n+\t(CharBufferImpl(CharBufferImpl)): Copy array_offset field.\n+\t(get(), put(char)): Inlined checks and field updates. Fixed to\n+\ttake array_offset into account.\n+\t(get(int), put(int, char)): Fixed to take array_offset into account.\n+\n 2005-04-20  Sven de Marothy  <sven@physto.se>\n \n \t* java/text/SimpleDateFormat.java:"}, {"sha": "47961700a00e6871c477d87a527e970e7f7e9e19", "filename": "libjava/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferImpl.java?ref=ebce970d7fa5aac9c4dea5381784441e155dbb64", "patch": "@@ -144,13 +144,43 @@ public boolean isDirect ()\n    */\n   public byte get ()\n   {\n-    checkForUnderflow();\n+    if (pos >= limit)\n+        throw new BufferUnderflowException();\n \n-    byte result = backing_buffer [position () + array_offset];\n-    position (position () + 1);\n-    return result;\n+    return backing_buffer [(pos++) + array_offset];\n   }\n-  \n+\n+  /**\n+   * Bulk get\n+   */\n+  public ByteBuffer get (byte[] dst, int offset, int length)\n+  {\n+    checkArraySize(dst.length, offset, length);\n+    if ( (limit - pos) < length) // check for overflow\n+      throw new BufferUnderflowException();\n+\n+    System.arraycopy(backing_buffer, pos + array_offset, \n+\t\t     dst, offset, length);\n+    pos += length;\n+\n+    return this;\n+  }\n+\n+  /**\n+   * Relative bulk put(), overloads the ByteBuffer impl.\n+   */\n+  public ByteBuffer put (byte[] src, int offset, int length)\n+  {\n+    if ( (limit - pos) < length) // check for overflow\n+      throw new BufferOverflowException();\n+    checkArraySize(src.length, offset, length);\n+\n+    System.arraycopy(src, offset, backing_buffer, pos + array_offset, length);\n+    pos += length;\n+\n+    return this;\n+  }\n+\n   /**\n    * Relative put method. Writes <code>value</code> to the next position\n    * in the buffer.\n@@ -161,12 +191,12 @@ public byte get ()\n    */\n   public ByteBuffer put (byte value)\n   {\n-    checkIfReadOnly();\n-    checkForOverflow();\n+    if (readOnly)\n+        throw new ReadOnlyBufferException();\n+    if (pos >= limit)\n+        throw new BufferOverflowException();\n \n-    int pos = position();\n-    backing_buffer [pos + array_offset] = value;\n-    position (pos + 1);\n+    backing_buffer [(pos++) + array_offset] = value;\n     return this;\n   }\n   \n@@ -208,7 +238,21 @@ public char getChar ()\n   \n   public ByteBuffer putChar (char value)\n   {\n-    ByteBufferHelper.putChar(this, value, order());\n+    if (readOnly)\n+      throw new ReadOnlyBufferException ();\n+    if ( (limit-pos) < 2)\n+      throw new BufferOverflowException();\n+\n+    if (endian == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        backing_buffer [(pos++) + array_offset] = (byte)(value&0xFF);\n+        backing_buffer [(pos++) + array_offset] = (byte)(value>>8);\n+      }\n+    else\n+      {\n+        backing_buffer [(pos++) + array_offset] = (byte)(value>>8);\n+        backing_buffer [(pos++) + array_offset] = (byte)(value&0xFF);\n+      }\n     return this;\n   }\n   "}, {"sha": "a6c81d914fa2ee5e25e3b238ec2c4f28e2957c0f", "filename": "libjava/java/nio/CharBufferImpl.java", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2Fjava%2Fnio%2FCharBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebce970d7fa5aac9c4dea5381784441e155dbb64/libjava%2Fjava%2Fnio%2FCharBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharBufferImpl.java?ref=ebce970d7fa5aac9c4dea5381784441e155dbb64", "patch": "@@ -62,6 +62,7 @@ public CharBufferImpl (CharBufferImpl copy)\n   {\n     super (copy.capacity (), copy.limit (), copy.position (), 0);\n     backing_buffer = copy.backing_buffer;\n+    array_offset = copy.array_offset;\n     readOnly = copy.isReadOnly ();\n   }\n   \n@@ -127,11 +128,10 @@ public CharSequence subSequence (int start, int end)\n    */\n   public char get ()\n   {\n-    checkForUnderflow();\n+    if (pos >= limit)\n+        throw new BufferUnderflowException();\n \n-    char result = backing_buffer [position ()];\n-    position (position () + 1);\n-    return result;\n+    return backing_buffer [(pos++) + array_offset];\n   }\n   \n   /**\n@@ -142,10 +142,12 @@ public char get ()\n    */\n   public CharBuffer put (char value)\n   {\n-    checkIfReadOnly();\n-\t  \t    \n-    backing_buffer [position ()] = value;\n-    position (position () + 1);\n+    if (readOnly)\n+        throw new ReadOnlyBufferException();\n+    if (pos >= limit)\n+        throw new BufferOverflowException();\n+\n+    backing_buffer [(pos++) + array_offset] = value;\n     return this;\n   }\n   \n@@ -162,9 +164,37 @@ public char get (int index)\n   {\n     checkIndex(index);\n     \n-    return backing_buffer [index];\n+    return backing_buffer [index + array_offset];\n   }\n   \n+  /**\n+   * Bulk get, overloaded for speed.\n+   */\n+  public CharBuffer get (char[] dst, int offset, int length)\n+  {\n+    checkArraySize(dst.length, offset, length);\n+    checkForUnderflow(length);\n+\n+    System.arraycopy(backing_buffer, pos + array_offset, \n+\t\t     dst, offset, length);\n+    pos += length;\n+    return this;\n+  }\n+\n+  /**\n+   * Bulk put, overloaded for speed.\n+   */\n+  public CharBuffer put (char[] src, int offset, int length)\n+  {\n+    checkArraySize(src.length, offset, length);\n+    checkForOverflow(length);\n+\t\t    \n+    System.arraycopy(src, offset,\n+\t\t     backing_buffer, pos + array_offset, length);\n+    pos += length;\n+    return this;\n+  }\n+\n   /**\n    * Absolute put method. Writes <code>value</code> to position\n    * <code>index</code> in the buffer.\n@@ -178,7 +208,7 @@ public CharBuffer put (int index, char value)\n     checkIndex(index);\n     checkIfReadOnly();\n     \t    \n-    backing_buffer [index] = value;\n+    backing_buffer [index + array_offset] = value;\n     return this;\n   }\n   "}]}