{"sha": "bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxNDMxZTM1OTZiNDVkYzE3MDJmZDdiZTdkYmYzZjUxYWJkYTM4ZQ==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2012-07-19T07:29:24Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2012-07-19T07:29:24Z"}, "message": "eh_personality.cc (__gxx_personality_seh0): New function.\n\nlibstdc++-v3/\n\t* libsupc++/eh_personality.cc (__gxx_personality_seh0): New function.\n\tAdjust for SEH.\n\t* config/abi/pre/gnu.ver: Add __gxx_personality_seh0.\n\nlibobjc/\n\t* exception.c (__gnu_objc_personality_seh0): New function.\n\nlibjava/\n\t* libgcj.ver: Add __gcj_personality_seh0.\n\t* exception.cc (__gcj_personality_seh0): New function.\n\tAdjust for SEH.\n\nlibgcc/\n\t* unwind-seh.c: New file.\n\t* unwind-generic.h: Include windows.h for SEH.\n\t(_Unwind_Exception): Use 6 private fields for SEH.\n\t(_GCC_specific_handler): Declare.\n\t* unwind-c.c (__gcc_personality_seh0): New function.\n\tAdjust for SEH.\n\t* config/i386/libgcc-cygming.ver: New file.\n\t* config/i386/t-seh-eh: New file.\n\t* config.host (x86_64-*-mingw*): Default to seh.\n\ngcc/\n\t* opts.c (finish_options): Handle UI_SEH.\n\t* expr.c (build_personality_function): Handle UI_SEH.\n\t* dwarf2out.c (dwarf2out_begin_prologue): Handle UI_SEH.\n\t* coretypes.h (unwind_info_type): Add UI_SEH.\n\t* config/i386/winnt.c (i386_pe_seh_emit_except_personality):\n\tNew function.\n\t(i386_pe_seh_init_sections): Likewise.\n\t* config/i386/cygming.h (TARGET_ASM_EMIT_EXCEPT_PERSONALITY): Define.\n\t(TARGET_ASM_INIT_SECTIONS): Define.\n\t* common/config/i386/i386-common.c (TARGET_EXCEPT_UNWIND_INFO): Define.\n\t(i386_except_unwind_info): New function.\n\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r189644", "tree": {"sha": "01e5d9fd06f28730cf73b04831f6df6e60c2cfca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01e5d9fd06f28730cf73b04831f6df6e60c2cfca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa4a66d152dad4a1f08bc6119cba3c6922310dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4a66d152dad4a1f08bc6119cba3c6922310dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4a66d152dad4a1f08bc6119cba3c6922310dce"}], "stats": {"total": 739, "additions": 729, "deletions": 10}, "files": [{"sha": "174d62fc89b787f60131152a3df3ebe4c6a2198c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1,3 +1,18 @@\n+2012-07-19  Tristan Gingold  <gingold@adacore.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* opts.c (finish_options): Handle UI_SEH.\n+\t* expr.c (build_personality_function): Handle UI_SEH.\n+\t* dwarf2out.c (dwarf2out_begin_prologue): Handle UI_SEH.\n+\t* coretypes.h (unwind_info_type): Add UI_SEH.\n+\t* config/i386/winnt.c (i386_pe_seh_emit_except_personality):\n+\tNew function.\n+\t(i386_pe_seh_init_sections): Likewise.\n+\t* config/i386/cygming.h (TARGET_ASM_EMIT_EXCEPT_PERSONALITY): Define.\n+\t(TARGET_ASM_INIT_SECTIONS): Define.\n+\t* common/config/i386/i386-common.c (TARGET_EXCEPT_UNWIND_INFO): Define.\n+\t(i386_except_unwind_info): New function.\n+\n 2012-07-18  Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Chao-ying Fu  <fu@mips.com>\n "}, {"sha": "1fe04a6b57541ad0eee23c233e2a0be27ebbb12c", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -667,6 +667,30 @@ ix86_supports_split_stack (bool report ATTRIBUTE_UNUSED,\n   return ret;\n }\n \n+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n+\n+static enum unwind_info_type\n+i386_except_unwind_info (struct gcc_options *opts)\n+{\n+  /* Honor the --enable-sjlj-exceptions configure switch.  */\n+#ifdef CONFIG_SJLJ_EXCEPTIONS\n+  if (CONFIG_SJLJ_EXCEPTIONS)\n+    return UI_SJLJ;\n+#endif\n+\n+  /* On windows 64, prefer SEH exceptions over anything else.  */\n+  if (TARGET_64BIT && DEFAULT_ABI == MS_ABI && opts->x_flag_unwind_tables)\n+    return UI_SEH;\n+\n+  if (DWARF2_UNWIND_INFO)\n+    return UI_DWARF2;\n+\n+  return UI_SJLJ;\n+}\n+\n+#undef  TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO  i386_except_unwind_info\n+\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS\t\\\n   (TARGET_DEFAULT\t\t\t\\"}, {"sha": "8455a67b7a5e6e07e36d4a9e5aa8076803a40eae", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -48,6 +48,10 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_ASM_UNWIND_EMIT_BEFORE_INSN  false\n #undef  TARGET_ASM_FUNCTION_END_PROLOGUE\n #define TARGET_ASM_FUNCTION_END_PROLOGUE  i386_pe_seh_end_prologue\n+#undef  TARGET_ASM_EMIT_EXCEPT_PERSONALITY\n+#define TARGET_ASM_EMIT_EXCEPT_PERSONALITY i386_pe_seh_emit_except_personality\n+#undef  TARGET_ASM_INIT_SECTIONS\n+#define TARGET_ASM_INIT_SECTIONS  i386_pe_seh_init_sections\n #define SUBTARGET_ASM_UNWIND_INIT  i386_pe_seh_init\n \n #undef DEFAULT_ABI"}, {"sha": "49e6bbd9d32176d4554eeabcef30de6280c3c2c1", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -258,6 +258,8 @@ extern tree i386_pe_mangle_assembler_name (const char *);\n extern void i386_pe_seh_init (FILE *);\n extern void i386_pe_seh_end_prologue (FILE *);\n extern void i386_pe_seh_unwind_emit (FILE *, rtx);\n+extern void i386_pe_seh_emit_except_personality (rtx);\n+extern void i386_pe_seh_init_sections (void);\n \n /* In winnt-cxx.c and winnt-stubs.c  */\n extern void i386_pe_adjust_class_at_definition (tree);"}, {"sha": "17ee13751075190dd8c3018a5b32cdc2cd00e5a6", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1143,6 +1143,48 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx insn)\n  found:\n   seh_frame_related_expr (asm_out_file, seh, pat);\n }\n+\n+void\n+i386_pe_seh_emit_except_personality (rtx personality)\n+{\n+  int flags = 0;\n+\n+  if (!TARGET_SEH)\n+    return;\n+\n+  fputs (\"\\t.seh_handler\\t\", asm_out_file);\n+  output_addr_const (asm_out_file, personality);\n+\n+#if 0\n+  /* ??? The current implementation of _GCC_specific_handler requires\n+     both except and unwind handling, regardless of which sorts the\n+     user-level function requires.  */\n+  eh_region r;\n+  FOR_ALL_EH_REGION(r)\n+    {\n+      if (r->type == ERT_CLEANUP)\n+\tflags |= 1;\n+      else\n+\tflags |= 2;\n+    }\n+#else\n+  flags = 3;\n+#endif\n+\n+  if (flags & 1)\n+    fputs (\", @unwind\", asm_out_file);\n+  if (flags & 2)\n+    fputs (\", @except\", asm_out_file);\n+  fputc ('\\n', asm_out_file);\n+}\n+\n+void\n+i386_pe_seh_init_sections (void)\n+{\n+  if (TARGET_SEH)\n+    exception_section = get_unnamed_section (0, output_section_asm_op,\n+\t\t\t\t\t     \"\\t.seh_handlerdata\");\n+}\n \f\n void\n i386_pe_start_function (FILE *f, const char *name, tree decl)"}, {"sha": "02578f681fc3cf2aa76fbc1a36e1ece74827a882", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -116,7 +116,8 @@ enum unwind_info_type\n   UI_NONE,\n   UI_SJLJ,\n   UI_DWARF2,\n-  UI_TARGET\n+  UI_TARGET,\n+  UI_SEH\n };\n \n /* Callgraph node profile representation.  */"}, {"sha": "dd48d1d7891f0a9453f1c73ec2f47047bf693c1c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -976,7 +976,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n      call-site information.  We must emit this label if it might be used.  */\n   if (!do_frame\n       && (!flag_exceptions\n-\t  || targetm_common.except_unwind_info (&global_options) != UI_TARGET))\n+\t  || targetm_common.except_unwind_info (&global_options) == UI_SJLJ))\n     return;\n \n   fnsec = function_section (current_function_decl);"}, {"sha": "5aec53e1737e0b596d0cb53d078da2ed4960a6a9", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -11011,6 +11011,9 @@ build_personality_function (const char *lang)\n     case UI_TARGET:\n       unwind_and_version = \"_v0\";\n       break;\n+    case UI_SEH:\n+      unwind_and_version = \"_seh0\";\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "d9287845c968f02220d82fd9cd2a15d9da2ed12c", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -717,7 +717,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \n   if (opts->x_flag_exceptions\n       && opts->x_flag_reorder_blocks_and_partition\n-      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))\n+      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n     {\n       inform (loc,\n \t      \"-freorder-blocks-and-partition does not work \"\n@@ -732,7 +732,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n   if (opts->x_flag_unwind_tables\n       && !targetm_common.unwind_tables_default\n       && opts->x_flag_reorder_blocks_and_partition\n-      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))\n+      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n     {\n       inform (loc,\n \t      \"-freorder-blocks-and-partition does not support \"\n@@ -749,7 +749,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       && (!targetm_common.have_named_sections\n \t  || (opts->x_flag_unwind_tables\n \t      && targetm_common.unwind_tables_default\n-\t      && (ui_except == UI_SJLJ || ui_except == UI_TARGET))))\n+\t      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))))\n     {\n       inform (loc,\n \t      \"-freorder-blocks-and-partition does not work \""}, {"sha": "2424cab910107c49f1c9b9a7bfe1bbe7a370a80d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1,3 +1,16 @@\n+2012-07-19  Tristan Gingold  <gingold@adacore.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* unwind-seh.c: New file.\n+\t* unwind-generic.h: Include windows.h for SEH.\n+\t(_Unwind_Exception): Use 6 private fields for SEH.\n+\t(_GCC_specific_handler): Declare.\n+\t* unwind-c.c (__gcc_personality_seh0): New function.\n+\tAdjust for SEH.\n+\t* config/i386/libgcc-cygming.ver: New file.\n+\t* config/i386/t-seh-eh: New file.\n+\t* config.host (x86_64-*-mingw*): Default to seh.\n+\n 2012-07-14  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/t-darwin (crt3.0): Remove work-around for fixed PR26840."}, {"sha": "2615d876581379346a809166e5f05cfa09f7d140", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -618,7 +618,7 @@ x86_64-*-mingw*)\n \tif test x$enable_sjlj_exceptions = xyes; then\n \t\ttmake_eh_file=\"i386/t-sjlj-eh\"\n \telse\n-\t\ttmake_eh_file=\"i386/t-dw2-eh\"\n+\t\ttmake_eh_file=\"i386/t-seh-eh\"\n \tfi\n \t# Shared libgcc DLL install dir depends on cross/native build.\n \tif test x${build} = x${host} ; then"}, {"sha": "8966cfb53227cd3b5c98fa385fedc77a1d35432e", "filename": "libgcc/config/i386/libgcc-cygming.ver", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Flibgcc-cygming.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Flibgcc-cygming.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Flibgcc-cygming.ver?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -0,0 +1,22 @@\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+GCC_4.8 {\n+  _GCC_specific_handler\n+  __gcc_personality_seh0\n+}"}, {"sha": "066ca54b01063185ca45bb05308337723b0d793a", "filename": "libgcc/config/i386/t-seh-eh", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Ft-seh-eh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Ft-seh-eh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-seh-eh?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -0,0 +1,6 @@\n+\n+# We are using SEH EH.\n+EH_MODEL = seh\n+\n+# Use SEH exception handling.\n+LIB2ADDEH = $(srcdir)/unwind-seh.c $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c"}, {"sha": "6236c78e4668ede59480732609e80ae5e3e84b43", "filename": "libgcc/config/i386/t-slibgcc-cygming", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-cygming?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -55,4 +55,4 @@ SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk\n # We'd like to use SHLIB_SONAME here too, but shlib_base_name\n # does not get substituted before mkmap-flat.awk is run.\n SHLIB_MKMAP_OPTS = -v pe_dll=libgcc_s_$(EH_MODEL)-$(SHLIB_SOVERSION)$(SHLIB_EXT)\n-SHLIB_MAPFILES = libgcc-std.ver\n+SHLIB_MAPFILES = libgcc-std.ver $(srcdir)/config/i386/libgcc-cygming.ver"}, {"sha": "eb50ad82a17db6c38acab943ded81167b691983c", "filename": "libgcc/unwind-c.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-c.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -93,6 +93,8 @@ parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n #ifdef __USING_SJLJ_EXCEPTIONS__\n #define PERSONALITY_FUNCTION    __gcc_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n+#elif defined(__SEH__)\n+#define PERSONALITY_FUNCTION\t__gcc_personality_imp\n #else\n #define PERSONALITY_FUNCTION    __gcc_personality_v0\n #endif\n@@ -107,6 +109,9 @@ PERSONALITY_FUNCTION (_Unwind_State state,\n \t\t      struct _Unwind_Exception * ue_header,\n \t\t      struct _Unwind_Context * context)\n #else\n+#ifdef __SEH__\n+static\n+#endif\n _Unwind_Reason_Code\n PERSONALITY_FUNCTION (int, _Unwind_Action, _Unwind_Exception_Class,\n \t\t      struct _Unwind_Exception *, struct _Unwind_Context *);\n@@ -227,3 +232,13 @@ PERSONALITY_FUNCTION (int version,\n   _Unwind_SetIP (context, landing_pad);\n   return _URC_INSTALL_CONTEXT;\n }\n+\n+#ifdef __SEH__\n+EXCEPTION_DISPOSITION\n+__gcc_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n+\t\t\tPCONTEXT ms_orig_context, PDISPATCHER_CONTEXT ms_disp)\n+{\n+  return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n+\t\t\t\tms_disp, __gcc_personality_imp);\n+}\n+#endif /* SEH */"}, {"sha": "c9c993b2785ac5ebb6010a7530b49ede69e01e72", "filename": "libgcc/unwind-generic.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-generic.h?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -28,6 +28,11 @@\n #ifndef _UNWIND_H\n #define _UNWIND_H\n \n+#ifdef __SEH__\n+/* Only for _GCC_specific_handler.  */\n+#include <windows.h>\n+#endif\n+\n #ifndef HIDE_EXPORTS\n #pragma GCC visibility push(default)\n #endif\n@@ -86,8 +91,13 @@ struct _Unwind_Exception\n {\n   _Unwind_Exception_Class exception_class;\n   _Unwind_Exception_Cleanup_Fn exception_cleanup;\n+\n+#if !defined (__USING_SJLJ_EXCEPTIONS__) && defined (__SEH__)\n+  _Unwind_Word private_[6];\n+#else\n   _Unwind_Word private_1;\n   _Unwind_Word private_2;\n+#endif\n \n   /* @@@ The IA-64 ABI says that this structure must be double-word aligned.\n      Taking that literally does not make much sense generically.  Instead we\n@@ -265,6 +275,13 @@ extern void * _Unwind_FindEnclosingFunction (void *pc);\n # error \"What type shall we use for _sleb128_t?\"\n #endif\n \n+#ifdef __SEH__\n+/* Handles the mapping from SEH to GCC interfaces.  */\n+EXCEPTION_DISPOSITION _GCC_specific_handler (PEXCEPTION_RECORD, void *,\n+\t\t\t\t\t     PCONTEXT, PDISPATCHER_CONTEXT,\n+\t\t\t\t\t     _Unwind_Personality_Fn);\n+#endif\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "24e4280fde7e6a9d0a47a38399cdeea69147888b", "filename": "libgcc/unwind-seh.c", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-seh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libgcc%2Funwind-seh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-seh.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -0,0 +1,483 @@\n+/* Structured Exception Handling (SEH) runtime interface routines.\n+   Copyright (C) 2010  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"unwind.h\"\n+\n+#ifdef __SEH__\n+\n+/* At the moment everything is written for x64, but in theory this could\n+   also be used for i386, arm, mips and other extant embedded Windows.  */\n+#ifndef __x86_64__\n+#error \"Unsupported architecture.\"\n+#endif\n+\f\n+/* Define GCC's exception codes.  See\n+     http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx\n+   In particular, MS defines bits:\n+     [31:30] = 3 (error), 2 (warning), 1 (info), 0 (success)\n+     [29]    = 1 (user-defined)\n+     [28]    = 0 (reserved)\n+   We define bits:\n+     [24:27] = type\n+     [0:23]  = magic\n+   We set \"magic\" to \"GCC\", which is similar to MVC++ which uses \"msc\"\n+   as the low 3 bytes of its user-defined codes for C++ exceptions.\n+\n+   We define the ExceptionInformation entries as follows:\n+     [0] = _Unwind_Exception pointer\n+     [1] = target frame\n+     [2] = target ip\n+     [3] = target rdx\n+*/\n+\n+#define STATUS_USER_DEFINED\t\t(1U << 29)\n+\n+#define GCC_MAGIC\t\t\t(('G' << 16) | ('C' << 8) | 'C')\n+#define GCC_EXCEPTION(TYPE)\t\t\\\n+       (STATUS_USER_DEFINED | ((TYPE) << 24) | GCC_MAGIC)\n+\n+#define STATUS_GCC_THROW\t\tGCC_EXCEPTION (0)\n+#define STATUS_GCC_UNWIND\t\tGCC_EXCEPTION (1)\n+#define STATUS_GCC_FORCED\t\tGCC_EXCEPTION (2)\n+\n+\f\n+struct _Unwind_Context\n+{\n+  _Unwind_Word cfa;\n+  _Unwind_Word ra;\n+  _Unwind_Word reg[2];\n+  PDISPATCHER_CONTEXT disp;\n+};\n+\n+/* Get the value of register INDEX as saved in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *c, int index)\n+{\n+  if (index < 0 || index > 2)\n+    abort ();\n+  return c->reg[index];\n+}\n+\n+/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */\n+\n+void\n+_Unwind_SetGR (struct _Unwind_Context *c, int index, _Unwind_Word val)\n+{\n+  if (index < 0 || index > 2)\n+    abort ();\n+  c->reg[index] = val;\n+}\n+\n+/* Get the value of the CFA as saved in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetCFA (struct _Unwind_Context *c)\n+{\n+  return c->cfa;\n+}\n+\n+/* Retrieve the return address for CONTEXT.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *c)\n+{\n+  return c->ra;\n+}\n+\n+/* Retrieve the return address and flag whether that IP is before\n+   or after first not yet fully executed instruction.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *c, int *ip_before_insn)\n+{\n+  /* ??? Is there a concept of a signal context properly?  There's\n+     obviously an UNWP_PUSH_MACHFRAME opcode, but the runtime might\n+     have arranged for that not to matter, really.  */\n+  *ip_before_insn = 0;\n+  return c->ra;\n+}\n+\n+/* Overwrite the return address for CONTEXT with VAL.  */\n+\n+void\n+_Unwind_SetIP (struct _Unwind_Context *c, _Unwind_Ptr val)\n+{\n+  c->ra = val;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *c)\n+{\n+  return c->disp->HandlerData;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *c)\n+{\n+  return c->disp->FunctionEntry->BeginAddress + c->disp->ImageBase;\n+}\n+\n+void *\n+_Unwind_FindEnclosingFunction (void *pc)\n+{\n+  PRUNTIME_FUNCTION entry;\n+  ULONG64 ImageBase;\n+\n+  entry = RtlLookupFunctionEntry ((ULONG64)pc, &ImageBase, NULL);\n+\n+  return (entry ? (void *)(entry->BeginAddress + ImageBase) : NULL);\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetDataRelBase (struct _Unwind_Context *c ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetTextRelBase (struct _Unwind_Context *c)\n+{\n+  return c->disp->ImageBase;\n+}\n+\n+\f\n+/* The two-phase unwind process that GCC uses is ordered differently\n+   from the two-phase unwind process that SEH uses.  The mechansism\n+   that GCC uses is to have the filter return _URC_HANDER_FOUND; the\n+   mechanism that SEH uses is for the filter function call back into\n+   the unwinder.\n+\n+   An Ideal port to SEH would have GCC emit handler functions that\n+   can be called, given a pointer to the \"EstablisherFrame\" (i.e.\n+   the frame pointer base of the user-level function) can manipulate\n+   the user-level variables within the user-level function's stack\n+   frame.  Once done manipulating the variables, it would return\n+   a ExceptionContinueSearch, and the unwind process would continue.\n+\n+   GCC has always done things a bit differently.  We continue to\n+   transfer control back into the user-level function which, once\n+   done manipulating the user-level variables, re-throws the exception.  */\n+\n+/* The \"real\" language-specific personality handler forwards to here\n+   where we handle the MS SEH state and transforms it into the GCC\n+   unwind state as per GCC's <unwind.h>, at which point we defer to\n+   the regular language-specfic exception handler, which is passed in.  */\n+\n+EXCEPTION_DISPOSITION\n+_GCC_specific_handler (PEXCEPTION_RECORD ms_exc, void *this_frame,\n+\t\t       PCONTEXT ms_orig_context, PDISPATCHER_CONTEXT ms_disp,\n+\t\t       _Unwind_Personality_Fn gcc_per)\n+{\n+  DWORD ms_flags = ms_exc->ExceptionFlags;\n+  DWORD ms_code = ms_exc->ExceptionCode;\n+\n+  struct _Unwind_Exception *gcc_exc\n+    = (struct _Unwind_Exception *) ms_exc->ExceptionInformation[0];\n+  struct _Unwind_Context gcc_context;\n+  _Unwind_Action gcc_action;\n+  _Unwind_Reason_Code gcc_reason;\n+\n+  if (ms_flags & EXCEPTION_TARGET_UNWIND)\n+    {\n+      /* This frame is known to be the target frame.  We've already\n+         \"installed\" the target_ip and RAX value via the arguments\n+         to RtlUnwindEx.  All that's left is to set the RDX value\n+         and \"continue\" to have the context installed.  */\n+      ms_disp->ContextRecord->Rdx = ms_exc->ExceptionInformation[3];\n+      return ExceptionContinueSearch;\n+    }\n+\n+  if (ms_code == STATUS_GCC_UNWIND)\n+    {\n+      /* This is a colliding exception that we threw so that we could\n+         cancel the already in-flight exception and stop in a frame\n+\t that wanted to perform some unwind action.  The only relevant\n+\t test is that we're the target frame.  */\n+      if (ms_exc->ExceptionInformation[1] == (_Unwind_Ptr) this_frame)\n+\t{\n+\t  RtlUnwindEx (this_frame, ms_exc->ExceptionInformation[2],\n+\t\t       ms_exc, gcc_exc, ms_orig_context,\n+\t\t       ms_disp->HistoryTable);\n+\t  abort ();\n+\t}\n+      return ExceptionContinueSearch;\n+    }\n+\n+  gcc_context.cfa = ms_disp->ContextRecord->Rsp;\n+  gcc_context.ra = ms_disp->ControlPc;\n+  gcc_context.reg[0] = 0xdeadbeef;\t/* These are write-only.  */\n+  gcc_context.reg[1] = 0xdeadbeef;\n+  gcc_context.disp = ms_disp;\n+\n+  if (ms_code == STATUS_GCC_FORCED)\n+    {\n+       _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) gcc_exc->private_[0];\n+       void *stop_argument = (void *) gcc_exc->private_[4];\n+\n+       gcc_action = _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE;\n+\n+       stop (1, gcc_action, gcc_exc->exception_class, gcc_exc,\n+             &gcc_context, stop_argument);\n+\n+       goto phase2;\n+    }\n+\n+  /* ??? TODO: handling non-gcc user-defined exceptions as foreign.  */\n+  if (ms_code != STATUS_GCC_THROW)\n+    return ExceptionContinueSearch;\n+\n+  if (ms_flags & (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND))\n+    {\n+      /* This is Phase 2.  */\n+      /* We know this isn't the target frame because we've already tested\n+\t EXCEPTION_TARGET_UNWIND.  The remaining possibility is that the\n+\t gcc personality has unwind code to run.  */\n+\n+      gcc_action = _UA_CLEANUP_PHASE;\n+    phase2:\n+      gcc_reason = gcc_per (1, gcc_action, gcc_exc->exception_class,\n+\t\t\t    gcc_exc, &gcc_context);\n+\n+      if (gcc_reason == _URC_CONTINUE_UNWIND)\n+\treturn ExceptionContinueSearch;\n+\n+      if (gcc_reason == _URC_INSTALL_CONTEXT)\n+\t{\n+\t  /* Scratch space for the bits for the unwind catch.  */\n+\t  ms_exc->ExceptionInformation[1] = (_Unwind_Ptr) this_frame;\n+\t  ms_exc->ExceptionInformation[2] = gcc_context.ra;\n+\t  ms_exc->ExceptionInformation[3] = gcc_context.reg[1];\n+\n+\t  /* Cancel the current exception by raising another.  */\n+\t  RaiseException (STATUS_GCC_UNWIND, EXCEPTION_NONCONTINUABLE,\n+\t\t\t  4, ms_exc->ExceptionInformation);\n+\n+\t  /* Is RaiseException declared noreturn?  */\n+\t}\n+\n+      /* In _Unwind_RaiseException_Phase2 we return _URC_FATAL_PHASE2_ERROR. */\n+    }\n+  else\n+    {\n+      /* This is Phase 1.  */\n+      gcc_reason = gcc_per (1, _UA_SEARCH_PHASE, gcc_exc->exception_class,\n+\t\t\t    gcc_exc, &gcc_context);\n+\n+      if (gcc_reason == _URC_CONTINUE_UNWIND)\n+\treturn ExceptionContinueSearch;\n+\n+      if (gcc_reason == _URC_HANDLER_FOUND)\n+\t{\n+\t  /* We really need some of the information that GCC's personality\n+\t     routines compute during phase 2 right now, like the target IP.\n+\t     Go ahead and ask for it now, and cache it.  */\n+\t  gcc_reason = gcc_per (1, _UA_CLEANUP_PHASE | _UA_HANDLER_FRAME,\n+\t\t\t\tgcc_exc->exception_class, gcc_exc,\n+\t\t\t\t&gcc_context);\n+\t  if (gcc_reason != _URC_INSTALL_CONTEXT)\n+\t    abort ();\n+\n+\t  gcc_exc->private_[1] = (_Unwind_Ptr) this_frame;\n+\t  gcc_exc->private_[2] = gcc_context.ra;\n+\t  gcc_exc->private_[3] = gcc_context.reg[1];\n+\n+\t  ms_exc->NumberParameters = 4;\n+\t  ms_exc->ExceptionInformation[1] = (_Unwind_Ptr) this_frame;\n+\t  ms_exc->ExceptionInformation[2] = gcc_context.ra;\n+\t  ms_exc->ExceptionInformation[3] = gcc_context.reg[1];\n+\n+\t  /* Begin phase 2.  Perform the unwinding.  */\n+\t  RtlUnwindEx (this_frame, gcc_context.ra, ms_exc, gcc_exc,\n+\t\t       ms_orig_context, ms_disp->HistoryTable);\n+\t}\n+\n+      /* In _Unwind_RaiseException we return _URC_FATAL_PHASE1_ERROR.  */\n+    }\n+  abort ();\n+}\n+\n+/* Raise an exception, passing along the given exception object.  */\n+\n+_Unwind_Reason_Code\n+_Unwind_RaiseException (struct _Unwind_Exception *exc)\n+{\n+  memset (exc->private_, 0, sizeof (exc->private_));\n+\n+  /* The ExceptionInformation array will have only 1 element, EXC.  */\n+  RaiseException (STATUS_GCC_THROW, 0, 1, (ULONG_PTR *)&exc);\n+\n+  /* The exception handler installed in crt0 will continue any GCC\n+     exception that reaches there (and isn't marked non-continuable).\n+     Returning allows the C++ runtime to call std::terminate.  */\n+  return _URC_END_OF_STACK;\n+}\n+\n+/* Resume propagation of an existing exception.  This is used after\n+   e.g. executing cleanup code, and not to implement rethrowing.  */\n+\n+void\n+_Unwind_Resume (struct _Unwind_Exception *gcc_exc)\n+{\n+  UNWIND_HISTORY_TABLE ms_history;\n+  EXCEPTION_RECORD ms_exc;\n+  CONTEXT ms_context;\n+\n+  memset (&ms_exc, 0, sizeof(ms_exc));\n+  memset (&ms_history, 0, sizeof(ms_history));\n+\n+  /* ??? Not 100% perfect, since we aren't passing on the *original*\n+     exception context, but should be good enough.  */\n+  ms_exc.ExceptionCode = STATUS_GCC_THROW;\n+  ms_exc.ExceptionFlags = EXCEPTION_NONCONTINUABLE;\n+  ms_exc.NumberParameters = 4;\n+  ms_exc.ExceptionInformation[0] = (ULONG_PTR) gcc_exc;\n+  ms_exc.ExceptionInformation[1] = gcc_exc->private_[1];\n+  ms_exc.ExceptionInformation[2] = gcc_exc->private_[2];\n+  ms_exc.ExceptionInformation[3] = gcc_exc->private_[3];\n+\n+  ms_context.ContextFlags = CONTEXT_ALL;\n+  RtlCaptureContext (&ms_context);\n+\n+  RtlUnwindEx ((void *) gcc_exc->private_[1], gcc_exc->private_[2],\n+\t       &ms_exc, gcc_exc, &ms_context, &ms_history);\n+\n+  /* Is RtlUnwindEx declared noreturn?  */\n+  abort ();\n+}\n+\n+static _Unwind_Reason_Code\n+_Unwind_ForcedUnwind_Phase2 (struct _Unwind_Exception *exc)\n+{\n+  _Unwind_Stop_Fn stop;\n+  void * stop_argument;\n+\n+  RaiseException (STATUS_GCC_FORCED, 0, 1, (ULONG_PTR *)&exc);\n+\n+  /* If we get here, we got to top-of-stack.  */\n+  /* ??? We no longer have a context pointer to pass in.  */\n+\n+  stop = (_Unwind_Stop_Fn) exc->private_[0];\n+  stop_argument = (void *) exc->private_[4];\n+  stop (1, _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE | _UA_END_OF_STACK,\n+\texc->exception_class, exc, NULL, stop_argument);\n+\n+  return _UA_END_OF_STACK;\n+}\n+\n+_Unwind_Reason_Code\n+_Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)\n+{\n+  if (exc->private_[0] == 0)\n+    _Unwind_RaiseException (exc);\n+  else\n+    _Unwind_ForcedUnwind_Phase2 (exc);\n+  abort ();\n+}\n+\n+/* Raise an exception for forced unwinding.  */\n+\n+_Unwind_Reason_Code\n+_Unwind_ForcedUnwind (struct _Unwind_Exception *exc,\n+\t\t      _Unwind_Stop_Fn stop, void * stop_argument)\n+{\n+  /* ??? This is a hack that only works with _GCC_specific_handler.\n+     There's no way to invoke STOP within frames that use a different\n+     exception handler.  This is essentially just good enough to run\n+     the code within the gcc testsuite.  */\n+\n+  memset (exc->private_, 0, sizeof (exc->private_));\n+  exc->private_[0] = (_Unwind_Ptr) stop;\n+  exc->private_[4] = (_Unwind_Ptr) stop_argument;\n+\n+  return _Unwind_ForcedUnwind_Phase2 (exc);\n+}\n+\n+/* A convenience function that calls the exception_cleanup field.  */\n+\n+void\n+_Unwind_DeleteException (struct _Unwind_Exception *exc)\n+{\n+  if (exc->exception_cleanup)\n+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);\n+}\n+\n+/* Perform stack backtrace through unwind data.  */\n+\n+_Unwind_Reason_Code\n+_Unwind_Backtrace(_Unwind_Trace_Fn trace ATTRIBUTE_UNUSED,\n+\t\t  void *trace_argument ATTRIBUTE_UNUSED)\n+{\n+#if 0\n+  UNWIND_HISTORY_TABLE ms_history;\n+  CONTEXT ms_context;\n+  struct _Unwind_Context gcc_context;\n+\n+  memset (&ms_history, 0, sizeof(ms_history));\n+  memset (&gcc_context, 0, sizeof(gcc_context));\n+\n+  ms_context.ContextFlags = CONTEXT_ALL;\n+  RtlCaptureContext (&ms_context);\n+\n+  gcc_context.disp.ContextRecord = &ms_context;\n+  gcc_context.disp.HistoryTable = &ms_history;\n+\n+  while (1)\n+    {\n+      gcc_context.disp.ControlPc = ms_context.Rip;\n+      gcc_context.disp.FunctionEntry\n+\t= RtlLookupFunctionEntry (ms_context.Rip, &gcc_context.disp.ImageBase,\n+\t\t\t\t  &ms_history);\n+\n+      if (gcc_context.disp.FunctionEntry)\n+\t{\n+\t  gcc_context.disp.LanguageHandler\n+\t    = RtlVirtualUnwind (0, gcc_context.disp.ImageBase, ms_context.Rip,\n+\t\t\t\tgcc_context.disp.FunctionEntry, &ms_context,\n+\t\t\t\t&gcc_context.disp.HandlerData,\n+\t\t\t\t&gcc_context.disp.EstablisherFrame, NULL);\n+\t}\n+      else\n+\t{\n+\t  ms_context.Rip = *(ULONG_PTR *)ms_context.Rsp;\n+\t  ms_context.Rsp += 8;\n+\t}\n+\n+      /* Call trace function.  */\n+      if (trace (&gcc_context, trace_argument) != _URC_NO_REASON)\n+\treturn _URC_FATAL_PHASE1_ERROR;\n+\n+      /* ??? Check for invalid stack pointer.  */\n+      if (ms_context.Rip == 0)\n+\treturn _URC_END_OF_STACK;\n+    }\n+#else\n+  return _URC_END_OF_STACK;\n+#endif\n+}\n+#endif /* __SEH__ */"}, {"sha": "6b598024e237e9b52fd1b8c8c64eb8c9a5352e3d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1,3 +1,10 @@\n+2012-07-19  Tristan Gingold  <gingold@adacore.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* libgcj.ver: Add __gcj_personality_seh0.\n+\t* exception.cc (__gcj_personality_seh0): New function.\n+\tAdjust for SEH.\n+\n 2012-07-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR libjava/53973"}, {"sha": "cc5ab7c5355f537c9a2652ff8f5f187df1d87ef2", "filename": "libjava/exception.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -197,6 +197,8 @@ get_ttype_entry (_Unwind_Context *context, lsda_header_info *info, long i)\n #ifdef SJLJ_EXCEPTIONS\n #define PERSONALITY_FUNCTION\t__gcj_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n+#elif defined (__SEH__)\n+#define PERSONALITY_FUNCTION\t__gcj_personality_imp\n #else\n #define PERSONALITY_FUNCTION\t__gcj_personality_v0\n #endif\n@@ -220,7 +222,12 @@ PERSONALITY_FUNCTION (_Unwind_State state,\n \n #define CONTINUE_UNWINDING return _URC_CONTINUE_UNWIND\n \n-extern \"C\" _Unwind_Reason_Code\n+#ifdef __SEH__\n+static\n+#else\n+extern \"C\"\n+#endif\n+_Unwind_Reason_Code\n PERSONALITY_FUNCTION (int version,\n \t\t      _Unwind_Action actions,\n \t\t      _Unwind_Exception_Class exception_class,\n@@ -484,3 +491,14 @@ PERSONALITY_FUNCTION (int version,\n #endif\n   return _URC_INSTALL_CONTEXT;\n }\n+\n+#ifdef __SEH__\n+extern \"C\"\n+EXCEPTION_DISPOSITION\n+__gcj_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n+\t\t\tPCONTEXT ms_orig_context, PDISPATCHER_CONTEXT ms_disp)\n+{\n+  return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n+\t\t\t\tms_disp, __gcj_personality_imp);\n+}\n+#endif /* SEH */"}, {"sha": "142c6fbf044bf7b32b61c4b935f045b44920f98b", "filename": "libjava/libgcj.ver", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2Flibgcj.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libjava%2Flibgcj.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flibgcj.ver?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -7,6 +7,7 @@\n     _Jv_*;\n     __gcj_personality_v0;\n     __gcj_personality_sj0;\n+    __gcj_personality_seh0;\n     _Z*;\n   local:\n     *;"}, {"sha": "fe1d395c6f98f46414b3a73010c4d34f54f34576", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1,3 +1,8 @@\n+2012-07-19  Tristan Gingold  <gingold@adacore.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* exception.c (__gnu_objc_personality_seh0): New function.\n+\n 2012-05-16  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* configure: Regenerated.\n@@ -38,7 +43,7 @@\n \tfields other than the first two upon loading a class.\n \n 2011-10-09  Nicola Pero  <nicola.pero@meta-innovation.com>\n-\t\n+\n \t* class.c (objc_lookup_class): Added back for compatibility with\n \tclang which seems to emit calls to it.\n "}, {"sha": "1f802a84a68af89ebcd1cfff3f38f89153d9723b", "filename": "libobjc/exception.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libobjc%2Fexception.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libobjc%2Fexception.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fexception.c?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -202,6 +202,8 @@ get_ttype_entry (struct lsda_header_info *info, _Unwind_Word i)\n #ifdef SJLJ_EXCEPTIONS\n #define PERSONALITY_FUNCTION\t__gnu_objc_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n+#elif defined(__SEH__)\n+#define PERSONALITY_FUNCTION\t__gnu_objc_personality_imp\n #else\n #define PERSONALITY_FUNCTION\t__gnu_objc_personality_v0\n #endif\n@@ -225,6 +227,9 @@ PERSONALITY_FUNCTION (_Unwind_State state,\n \n #define CONTINUE_UNWINDING return _URC_CONTINUE_UNWIND\n \n+#ifdef __SEH__\n+static\n+#endif\n _Unwind_Reason_Code\n PERSONALITY_FUNCTION (int version,\n \t\t      _Unwind_Action actions,\n@@ -519,3 +524,13 @@ objc_exception_throw (id exception)\n   abort ();\n }\n \n+#ifdef __SEH__\n+EXCEPTION_DISPOSITION\n+__gnu_objc_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n+\t\t\t     PCONTEXT ms_orig_context,\n+\t\t\t     PDISPATCHER_CONTEXT ms_disp)\n+{\n+  return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n+\t\t\t\tms_disp, __gnu_objc_personality_imp);\n+}\n+#endif /* SEH */"}, {"sha": "1a6f19fdb307d4882f36f2aee882748ad5a1c113", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1,3 +1,10 @@\n+2012-07-19  Tristan Gingold  <gingold@adacore.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* libsupc++/eh_personality.cc (__gxx_personality_seh0): New function.\n+\tAdjust for SEH.\n+\t* config/abi/pre/gnu.ver: Add __gxx_personality_seh0.\n+\n 2012-07-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51213"}, {"sha": "cd0be4e051beb6fdf5bf28081996320b093cedcb", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -1357,6 +1357,7 @@ CXXABI_1.3 {\n     __cxa_vec_new3;\n     __gxx_personality_v0;\n     __gxx_personality_sj0;\n+    __gxx_personality_seh0;\n     __dynamic_cast;\n \n     # *_type_info classes, ctor and dtor"}, {"sha": "72f596e0692c9758998d0094a4831e56e03ef52f", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1431e3596b45dc1702fd7be7dbf3f51abda38e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=bf1431e3596b45dc1702fd7be7dbf3f51abda38e", "patch": "@@ -332,11 +332,18 @@ namespace __cxxabiv1\n #ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n #define PERSONALITY_FUNCTION\t__gxx_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n+#elif defined(__SEH__)\n+#define PERSONALITY_FUNCTION\t__gxx_personality_imp\n #else\n #define PERSONALITY_FUNCTION\t__gxx_personality_v0\n #endif\n \n-extern \"C\" _Unwind_Reason_Code\n+#ifdef __SEH__\n+static\n+#else\n+extern \"C\"\n+#endif\n+_Unwind_Reason_Code\n #ifdef __ARM_EABI_UNWINDER__\n PERSONALITY_FUNCTION (_Unwind_State state,\n \t\t      struct _Unwind_Exception* ue_header,\n@@ -778,4 +785,15 @@ __cxa_call_unexpected (void *exc_obj_in)\n }\n #endif\n \n+#ifdef __SEH__\n+extern \"C\"\n+EXCEPTION_DISPOSITION\n+__gxx_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n+\t\t\tPCONTEXT ms_orig_context, PDISPATCHER_CONTEXT ms_disp)\n+{\n+  return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n+\t\t\t\tms_disp, __gxx_personality_imp);\n+}\n+#endif /* SEH */\n+\n } // namespace __cxxabiv1"}]}