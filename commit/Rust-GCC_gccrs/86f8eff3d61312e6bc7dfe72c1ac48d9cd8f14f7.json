{"sha": "86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmOGVmZjNkNjEzMTJlNmJjN2RmZTcyYzFhYzQ4ZDljZDhmMTRmNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-07T23:15:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-07T23:15:24Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r417", "tree": {"sha": "dc84e846fc212fa5e7b8bbf19dd006f000c8244b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc84e846fc212fa5e7b8bbf19dd006f000c8244b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7/comments", "author": null, "committer": null, "parents": [{"sha": "19b229d9687fa5ecf69ddad133bbffbd1fe8668c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b229d9687fa5ecf69ddad133bbffbd1fe8668c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b229d9687fa5ecf69ddad133bbffbd1fe8668c"}], "stats": {"total": 75, "additions": 40, "deletions": 35}, "files": [{"sha": "4e5e2a73142e7ce02de26c69da73d902508ac39f", "filename": "gcc/function.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "patch": "@@ -553,18 +553,6 @@ assign_stack_local (mode, size, align)\n   else\n     alignment = align / BITS_PER_UNIT;\n \n-#if 0 /* Let's see if this is really needed--rms.  */\n-#ifdef STRICT_ALIGNMENT\n-  /* Supposedly sub-word sized units may later be accessed\n-     with word intructions.  It's not certain this is really true.  */\n-  if (mode != BLKmode && align == 0 && alignment < UNITS_PER_WORD)\n-    alignment = UNITS_PER_WORD;\n-\n-  /* This is in case we just made the alignment bigger than the size.  */\n-  size = CEIL_ROUND (size, alignment);\n-#endif\n-#endif\n-\n   /* Round frame offset to that alignment.\n      We must be careful here, since FRAME_OFFSET might be negative and\n      division with a negative dividend isn't as well defined as we might\n@@ -642,18 +630,6 @@ assign_outer_stack_local (mode, size, align, function)\n   else\n     alignment = align / BITS_PER_UNIT;\n \n-#if 0 /* Let's see if this is really needed--rms.  */\n-#ifdef STRICT_ALIGNMENT\n-  /* Sub-word sized units may later be accessed with word intructions.\n-     This results from (SUBREG (MEM ...) ...).  */\n-  if (mode != BLKmode && align == 0 && alignment < UNITS_PER_WORD)\n-    alignment = UNITS_PER_WORD;\n-\n-  /* This is in case we just made the alignment bigger than the size.  */\n-  size = CEIL_ROUND (size, alignment);\n-#endif\n-#endif\n-\n   /* Round frame offset to that alignment.  */\n #ifdef FRAME_GROWS_DOWNWARD\n   frame_offset = FLOOR_ROUND (frame_offset, alignment);\n@@ -1928,11 +1904,14 @@ instantiate_decls (fndecl, valid_only)\n       if (DECL_RTL (decl) && GET_CODE (DECL_RTL (decl)) == MEM)\n \tinstantiate_virtual_regs_1 (&XEXP (DECL_RTL (decl), 0),\n \t\t\t\t    valid_only ? DECL_RTL (decl) : 0, 0);\n+#if 0 /* This is probably correct, but it seems to require fixes\n+\t elsewhere in order to work.  Let's fix them in 2.1.  */\n       if (DECL_INCOMING_RTL (decl)\n \t  && GET_CODE (DECL_INCOMING_RTL (decl)) == MEM)\n \tinstantiate_virtual_regs_1 (&XEXP (DECL_INCOMING_RTL (decl), 0),\n \t\t\t\t    valid_only ? DECL_INCOMING_RTL (decl) : 0,\n \t\t\t\t    0);\n+#endif\n     }\n \n   /* Now process all variables defined in the function or its subblocks. */\n@@ -2831,7 +2810,21 @@ assign_parms (fndecl, second_time)\n \n \t  /* Copy the value into the register.  */\n \t  if (GET_MODE (parmreg) != GET_MODE (entry_parm))\n-\t    convert_move (parmreg, validize_mem (entry_parm), 0);\n+\t    {\n+\t      /* If ENTRY_PARM is a hard register, it might be in a register\n+\t\t not valid for operating in its mode (e.g., an odd-numbered\n+\t\t register for a DFmode).  In that case, moves are the only\n+\t\t thing valid, so we can't do a convert from there.  This\n+\t\t occurs when the calling sequence allow such misaligned\n+\t\t usages.  */\n+\t      if (GET_CODE (entry_parm) == REG\n+\t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n+\t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm),\n+\t\t\t\t\t   GET_MODE (entry_parm)))\n+\t\tconvert_move (parmreg, copy_to_reg (entry_parm));\n+\t      else\n+\t\tconvert_move (parmreg, validize_mem (entry_parm), 0);\n+\t    }\n \t  else\n \t    emit_move_insn (parmreg, validize_mem (entry_parm));\n \n@@ -2872,8 +2865,15 @@ assign_parms (fndecl, second_time)\n \t     during function execution.  */\n \n \t  if (passed_mode != nominal_mode)\n-\t    /* Conversion is required.  */\n-\t    entry_parm = convert_to_mode (nominal_mode, entry_parm, 0);\n+\t    {\n+\t      /* Conversion is required.   */\n+\t      if (GET_CODE (entry_parm) == REG\n+\t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n+\t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm), passed_mode))\n+\t\tentry_parm = copy_to_reg (entry_parm);\n+\n+\t      entry_parm = convert_to_mode (nominal_mode, entry_parm, 0);\n+\t    }\n \n \t  if (entry_parm != stack_parm)\n \t    {\n@@ -3335,6 +3335,7 @@ fix_lexical_addr (addr, var)\n       base = copy_to_reg (gen_rtx (MEM, Pmode, addr));\n #else\n       displacement += (FIRST_PARM_OFFSET (context) - STARTING_FRAME_OFFSET);\n+      base = lookup_static_chain (var);\n #endif\n     }\n \n@@ -3844,8 +3845,12 @@ expand_function_end (filename, line)\n       /* First make sure this compilation has a template for\n \t initializing trampolines.  */\n       if (initial_trampoline == 0)\n-\tinitial_trampoline\n-\t  = gen_rtx (MEM, BLKmode, assemble_trampoline_template ());\n+\t{\n+\t  end_temporary_allocation ();\n+\t  initial_trampoline\n+\t    = gen_rtx (MEM, BLKmode, assemble_trampoline_template ());\n+\t  resume_temporary_allocation ();\n+\t}\n \n       /* Generate insns to initialize the trampoline.  */\n       start_sequence ();"}, {"sha": "e80f7cb3078b4852fa5492d4b9056818f1b7c764", "filename": "gcc/optabs.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=86f8eff3d61312e6bc7dfe72c1ac48d9cd8f14f7", "patch": "@@ -1495,12 +1495,12 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n #endif\n \t{\n #ifdef TARGET_MEM_FUNCTIONS\n-\t  emit_library_call (memcmp_libfunc, 0,\n+\t  emit_library_call (memcmp_libfunc, 1,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     size, Pmode);\n #else\n-\t  emit_library_call (bcmp_libfunc, 0,\n+\t  emit_library_call (bcmp_libfunc, 1,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     size, Pmode);\n@@ -1585,7 +1585,7 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n       if (unsignedp && ucmp_optab->handlers[(int) mode].libfunc)\n \tlibfunc = ucmp_optab->handlers[(int) mode].libfunc;\n \n-      emit_library_call (libfunc, 0,\n+      emit_library_call (libfunc, 1,\n \t\t\t SImode, 2, x, mode, y, mode);\n \n       /* Integer comparison returns a result that must be compared against 1,\n@@ -1706,7 +1706,7 @@ emit_float_lib_cmp (x, y, comparison)\n       abort ();\n     }\n \n-  emit_library_call (libfunc, 0,\n+  emit_library_call (libfunc, 1,\n \t\t     SImode, 2, x, mode, y, mode);\n \n   emit_cmp_insn (hard_libcall_value (SImode), const0_rtx, comparison,\n@@ -2556,7 +2556,7 @@ expand_float (to, from, unsignedp)\n \n       start_sequence ();\n \n-      emit_library_call (libfcn, 0, GET_MODE (to), 1, from, GET_MODE (from));\n+      emit_library_call (libfcn, 1, GET_MODE (to), 1, from, GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -2752,7 +2752,7 @@ expand_fix (to, from, unsignedp)\n \n       start_sequence ();\n \n-      emit_library_call (libfcn, 0, GET_MODE (to), 1, from, GET_MODE (from));\n+      emit_library_call (libfcn, 1, GET_MODE (to), 1, from, GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n "}]}