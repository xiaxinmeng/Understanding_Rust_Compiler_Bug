{"sha": "866d73019bd4d1804f7e09409322e6605b81780b", "node_id": "C_kwDOANBUbNoAKDg2NmQ3MzAxOWJkNGQxODA0ZjdlMDk0MDkzMjJlNjYwNWI4MTc4MGI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-26T18:42:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-26T18:42:31Z"}, "message": "dwarf2out: For ppc64le IEEE quad long double, emit DW_TAG_typedef to _Float128 [PR104194]\n\nOn Mon, Jan 24, 2022 at 11:26:27PM +0100, Jakub Jelinek via Gcc-patches wrote:\n> Yet another short term solution might be not use DW_TAG_base_type\n> for the IEEE quad long double, but instead pretend it is a DW_TAG_typedef\n> with DW_AT_name \"long double\" to __float128 DW_TAG_base_type.\n> I bet gdb would even handle it without any changes, but of course, it would\n> be larger than the other proposed changes.\n\nHere it is implemented.\n\nTestcases I've played with are e.g.:\n__ibm128 a;\nlong double b;\n_Complex long double c;\n\nstatic __attribute__((noinline)) int\nfoo (long double d)\n{\n  long double e = d + 1.0L;\n  return 0;\n}\n\nint\nmain ()\n{\n  a = 1.0;\n  b = 2.0;\n  c = 5.0 + 6.0i;\n  return foo (7.0L);\n}\nand\n  real(kind=16) :: a\n  complex(kind=16) :: b\n  a = 1.0\n  b = 2.0\nend\n\nPrinting the values of the variables works well,\np &b or p &c shows pointer to the correct type, just\nptype b or ptype c prints _Float128 instead of\nlong double or complex _Float128 instead of complex long double.\nEven worse in fortran where obviously _Float128 or\ncomplex _Float128 aren't valid types, but as GDB knows them by name,\nit is just ptype that is weird.\n\n2022-01-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/104194\n\t* dwarf2out.cc (long_double_as_float128): New function.\n\t(modified_type_die): For powerpc64le IEEE 754 quad long double\n\tand complex long double emit those as DW_TAG_typedef to\n\t_Float128 or complex _Float128 base type.", "tree": {"sha": "2c13128e5fab0a5e4b8fd9fda0097d630b7793c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c13128e5fab0a5e4b8fd9fda0097d630b7793c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/866d73019bd4d1804f7e09409322e6605b81780b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866d73019bd4d1804f7e09409322e6605b81780b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866d73019bd4d1804f7e09409322e6605b81780b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866d73019bd4d1804f7e09409322e6605b81780b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abea1c9a252ef7712ab800360e1e0e2697ee14f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abea1c9a252ef7712ab800360e1e0e2697ee14f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abea1c9a252ef7712ab800360e1e0e2697ee14f2"}], "stats": {"total": 68, "additions": 67, "deletions": 1}, "files": [{"sha": "ad1d804dcaff549c611e7edcb87fdecff7d6a329", "filename": "gcc/dwarf2out.cc", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866d73019bd4d1804f7e09409322e6605b81780b/gcc%2Fdwarf2out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866d73019bd4d1804f7e09409322e6605b81780b/gcc%2Fdwarf2out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.cc?ref=866d73019bd4d1804f7e09409322e6605b81780b", "patch": "@@ -13568,6 +13568,47 @@ qualified_die_p (dw_die_ref die, int *mask, unsigned int depth)\n   return type;\n }\n \n+/* If TYPE is long double or complex long double that\n+   should be emitted as artificial typedef to _Float128 or\n+   complex _Float128, return the type it should be emitted as.\n+   This is done in case the target already supports 16-byte\n+   composite floating point type (ibm_extended_format).  */\n+\n+static tree\n+long_double_as_float128 (tree type)\n+{\n+  if (type != long_double_type_node\n+      && type != complex_long_double_type_node)\n+    return NULL_TREE;\n+\n+  machine_mode mode, fmode;\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    mode = TYPE_MODE (TREE_TYPE (type));\n+  else\n+    mode = TYPE_MODE (type);\n+  if (known_eq (GET_MODE_SIZE (mode), 16) && !MODE_COMPOSITE_P (mode))\n+    FOR_EACH_MODE_IN_CLASS (fmode, MODE_FLOAT)\n+      if (known_eq (GET_MODE_SIZE (fmode), 16)\n+          && MODE_COMPOSITE_P (fmode))\n+\t{\n+\t  if (type == long_double_type_node)\n+\t    {\n+\t      if (float128_type_node\n+\t\t  && (TYPE_MODE (float128_type_node)\n+\t\t      == TYPE_MODE (type)))\n+\t\treturn float128_type_node;\n+\t      return NULL_TREE;\n+\t    }\n+\t  for (int i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+\t    if (COMPLEX_FLOATN_NX_TYPE_NODE (i) != NULL_TREE\n+\t\t&& (TYPE_MODE (COMPLEX_FLOATN_NX_TYPE_NODE (i))\n+\t\t    == TYPE_MODE (type)))\n+\t      return COMPLEX_FLOATN_NX_TYPE_NODE (i);\n+\t}\n+\n+  return NULL_TREE;\n+}\n+\n /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging\n    entry that chains the modifiers specified by CV_QUALS in front of the\n    given type.  REVERSE is true if the type is to be interpreted in the\n@@ -13848,7 +13889,32 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n     }\n   else if (is_base_type (type))\n     {\n-      mod_type_die = base_type_die (type, reverse);\n+      /* If a target supports long double as different floating point\n+\t modes with the same 16-byte size, use normal DW_TAG_base_type\n+\t only for the composite (ibm_extended_real_format) type and\n+\t for the other for the time being emit instead a \"_Float128\"\n+\t or \"complex _Float128\" DW_TAG_base_type and a \"long double\"\n+\t or \"complex long double\" typedef to it.  */\n+      if (tree other_type = long_double_as_float128 (type))\n+\t{\n+\t  dw_die_ref other_die;\n+\t  if (TYPE_NAME (other_type))\n+\t    other_die\n+\t      = modified_type_die (other_type, TYPE_UNQUALIFIED, reverse,\n+\t\t\t\t   context_die);\n+\t  else\n+\t    {\n+\t      other_die = base_type_die (type, reverse);\n+\t      add_child_die (comp_unit_die (), other_die);\n+\t      add_name_attribute (other_die,\n+\t\t\t\t  TREE_CODE (type) == COMPLEX_TYPE\n+\t\t\t\t  ? \"complex _Float128\" : \"_Float128\");\n+\t    }\n+\t  mod_type_die = new_die_raw (DW_TAG_typedef);\n+\t  add_AT_die_ref (mod_type_die, DW_AT_type, other_die);\n+\t}\n+      else\n+\tmod_type_die = base_type_die (type, reverse);\n \n       /* The DIE with DW_AT_endianity is placed right after the naked DIE.  */\n       if (reverse_base_type)"}]}