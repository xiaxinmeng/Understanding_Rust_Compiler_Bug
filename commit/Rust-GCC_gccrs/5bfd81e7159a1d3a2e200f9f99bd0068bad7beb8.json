{"sha": "5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJmZDgxZTcxNTlhMWQzYTJlMjAwZjlmOTliZDAwNjhiYWQ3YmViOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2016-12-13T20:43:08Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2016-12-13T20:43:08Z"}, "message": "re PR c++/69481 (ICE with C++11 alias using with templates)\n\n\tcp/\n\tPR c++/69481\n\t* cp-tree.h (TYPE_TEMPLATE_INFO): Remove alias type checking.\n\t(TYPE_ALIAS_TEMPLATE_INFO): New.\n\t(TYPE_TEMPLATE_INFO_MAYBE_ALIAS): New.  Use those macros.\n\t* error.c (dump_alias_template_specialization): Adjust.\n\t* pt.c (maybe_process_partial_specialization)\n\titerative_has_template_arg, find_parameter_packs_r,\n\talias_template_specialization_p, dependent_alias_template_spec_p,\n\tget_underlying_template, lookup_template_class_1, unify): Adjust\n\ttemplate using decl access.\n\n\ttestsuite/\n\tPR c++/69481\n\t* g++.dg/cpp0x/pr69481.C: New.\n(--This line, and those below, will be ignored--\n\nM    gcc/testsuite/ChangeLog\nA    gcc/testsuite/g++.dg/cpp0x/pr69481.C\nM    gcc/cp/cp-tree.h\nM    gcc/cp/error.c\nM    gcc/cp/ChangeLog\nM    gcc/cp/pt.c\n\nFrom-SVN: r243624", "tree": {"sha": "24915d3755b3e9603ff9e056744214621d436522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24915d3755b3e9603ff9e056744214621d436522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2de1796a6bf6748e1b3d392056761d68df40dbd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de1796a6bf6748e1b3d392056761d68df40dbd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de1796a6bf6748e1b3d392056761d68df40dbd0"}], "stats": {"total": 212, "additions": 131, "deletions": 81}, "files": [{"sha": "24ceb04ce57d9b2e9748b0ac2ac3f74c712b5d43", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -1,3 +1,16 @@\n+2016-12-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/69481\n+\t* cp-tree.h (TYPE_TEMPLATE_INFO): Remove alias type checking.\n+\t(TYPE_ALIAS_TEMPLATE_INFO): New.\n+\t(TYPE_TEMPLATE_INFO_MAYBE_ALIAS): New.  Use those macros.\n+\t* error.c (dump_alias_template_specialization): Adjust.\n+\t* pt.c (maybe_process_partial_specialization,\n+\titerative_has_template_arg, find_parameter_packs_r,\n+\talias_template_specialization_p, dependent_alias_template_spec_p,\n+\tget_underlying_template, lookup_template_class_1, unify): Adjust\n+\ttemplate using decl access.\n+\n 2016-12-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/78637"}, {"sha": "cc7ca87376f1d6bbfc105a1cd83a91e0e982a968", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -3038,23 +3038,30 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    ->template_info)\n \n /* Template information for an ENUMERAL_, RECORD_, UNION_TYPE, or\n-   BOUND_TEMPLATE_TEMPLATE_PARM type.  Note that if NODE is a\n-   specialization of an alias template, this accessor returns the\n-   template info for the alias template, not the one (if any) for the\n-   template of the underlying type.  */\n+   BOUND_TEMPLATE_TEMPLATE_PARM type.  This ignores any alias\n+   templateness of NODE.  */\n #define TYPE_TEMPLATE_INFO(NODE)\t\t\t\t\t\\\n-  ((TYPE_ALIAS_P (NODE) && DECL_LANG_SPECIFIC (TYPE_NAME (NODE)))\t\\\n-   ? (DECL_LANG_SPECIFIC (TYPE_NAME (NODE))\t\t\t\t\\\n-      ? DECL_TEMPLATE_INFO (TYPE_NAME (NODE))\t\t\t\t\\\n-      : NULL_TREE)\t\t\t\t\t\t\t\\\n-   : ((TREE_CODE (NODE) == ENUMERAL_TYPE)\t\t\t\t\\\n-      ? ENUM_TEMPLATE_INFO (NODE)\t\t\t\t\t\\\n-      : ((TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM)\t\t\\\n-\t ? TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE)\t\t\t\\\n-\t : (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n-\t    ? CLASSTYPE_TEMPLATE_INFO (NODE)\t\t\t\t\\\n-\t    : NULL_TREE))))\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\t\t\t\\\n+   ? ENUM_TEMPLATE_INFO (NODE)\t\t\t\t\t\t\\\n+   : (TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM\t\t\t\\\n+      ? TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE)\t\t\t\\\n+      : (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n+\t ? CLASSTYPE_TEMPLATE_INFO (NODE)\t\t\t\t\\\n+\t : NULL_TREE)))\n+\n+/* Template information for an alias template type.  */\n+#define TYPE_ALIAS_TEMPLATE_INFO(NODE)\t\t\t\t\t\\\n+  (DECL_LANG_SPECIFIC (TYPE_NAME (NODE))\t\t\t\t\\\n+   ? DECL_TEMPLATE_INFO (TYPE_NAME (NODE))\t\t\t\t\\\n+   : NULL_TREE)\n \n+/* If NODE is a specialization of an alias template, this accessor\n+   returns the template info for the alias template.  Otherwise behave\n+   as TYPE_TEMPLATE_INFO.  */\n+#define TYPE_TEMPLATE_INFO_MAYBE_ALIAS(NODE)\t\t\t\t\\\n+  (TYPE_ALIAS_P (NODE) && DECL_LANG_SPECIFIC (TYPE_NAME (NODE))\t\t\\\n+   ? DECL_TEMPLATE_INFO (TYPE_NAME (NODE))\t\t\t\t\\\n+   : TYPE_TEMPLATE_INFO (NODE))\n \n /* Set the template information for an ENUMERAL_, RECORD_, or\n    UNION_TYPE to VAL.  */"}, {"sha": "d025fcb5fa320edb30143450b26bec247b994411", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -365,15 +365,13 @@ dump_template_bindings (cxx_pretty_printer *pp, tree parms, tree args,\n static void\n dump_alias_template_specialization (cxx_pretty_printer *pp, tree t, int flags)\n {\n-  tree name;\n-\n   gcc_assert (alias_template_specialization_p (t));\n \n+  tree decl = TYPE_NAME (t);\n   if (!(flags & TFF_UNQUALIFIED_NAME))\n-    dump_scope (pp, CP_DECL_CONTEXT (TYPE_NAME (t)), flags);\n-  name = TYPE_IDENTIFIER (t);\n-  pp_cxx_tree_identifier (pp, name);\n-  dump_template_parms (pp, TYPE_TEMPLATE_INFO (t),\n+    dump_scope (pp, CP_DECL_CONTEXT (decl), flags);\n+  pp_cxx_tree_identifier (pp, DECL_NAME (decl));\n+  dump_template_parms (pp, DECL_TEMPLATE_INFO (decl),\n \t\t       /*primary=*/false,\n \t\t       flags & ~TFF_TEMPLATE_HEADER);\n }"}, {"sha": "bae96ec9d220477f8e41e1dcd206bf95498b0739", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -940,10 +940,11 @@ maybe_process_partial_specialization (tree type)\n \n   if (TYPE_ALIAS_P (type))\n     {\n-      if (TYPE_TEMPLATE_INFO (type)\n-\t  && DECL_ALIAS_TEMPLATE_P (TYPE_TI_TEMPLATE (type)))\n+      tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (type);\n+\n+      if (tinfo && DECL_ALIAS_TEMPLATE_P (TI_TEMPLATE (tinfo)))\n \terror (\"specialization of alias template %qD\",\n-\t       TYPE_TI_TEMPLATE (type));\n+\t       TI_TEMPLATE (tinfo));\n       else\n \terror (\"explicit specialization of non-template %qT\", type);\n       return error_mark_node;\n@@ -1829,7 +1830,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n \t  // left alone, or untouched specializations because\n \t  // coerce_template_parms returns the unconverted template\n \t  // arguments if it sees incomplete argument packs.\n-\t  tree ti = TYPE_TEMPLATE_INFO (arg);\n+\t  tree ti = TYPE_ALIAS_TEMPLATE_INFO (arg);\n \t  return hash_tmpl_and_args (TI_TEMPLATE (ti), TI_ARGS (ti));\n \t}\n       if (TYPE_CANONICAL (arg))\n@@ -3459,8 +3460,8 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n   /* Handle type aliases/typedefs.  */\n   if (TYPE_ALIAS_P (t))\n     {\n-      if (TYPE_TEMPLATE_INFO (t))\n-\tcp_walk_tree (&TYPE_TI_ARGS (t),\n+      if (tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t))\n+\tcp_walk_tree (&TI_ARGS (tinfo),\n \t\t      &find_parameter_packs_r,\n \t\t      ppd, ppd->visited);\n       *walk_subtrees = 0;\n@@ -5794,15 +5795,9 @@ alias_template_specialization_p (const_tree t)\n   /* It's an alias template specialization if it's an alias and its\n      TYPE_NAME is a specialization of a primary template.  */\n   if (TYPE_ALIAS_P (t))\n-    {\n-      tree name = TYPE_NAME (t);\n-      if (DECL_LANG_SPECIFIC (name))\n-\tif (tree ti = DECL_TEMPLATE_INFO (name))\n-\t  {\n-\t    tree tmpl = TI_TEMPLATE (ti);\n-\t    return PRIMARY_TEMPLATE_P (tmpl);\n-\t  }\n-    }\n+    if (tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t))\n+      return PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo));\n+\n   return false;\n }\n \n@@ -5854,10 +5849,18 @@ complex_alias_template_p (const_tree tmpl)\n bool\n dependent_alias_template_spec_p (const_tree t)\n {\n-  return (alias_template_specialization_p (t)\n-\t  && TEMPLATE_DECL_COMPLEX_ALIAS_P (DECL_TI_TEMPLATE (TYPE_NAME (t)))\n-\t  && (any_dependent_template_arguments_p\n-\t      (INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (t)))));\n+  if (!alias_template_specialization_p (t))\n+    return false;\n+\n+  tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t);\n+  if (!TEMPLATE_DECL_COMPLEX_ALIAS_P (TI_TEMPLATE (tinfo)))\n+    return false;\n+\n+  tree args = INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo));\n+  if (!any_dependent_template_arguments_p (args))\n+    return false;\n+\n+  return true;\n }\n \n /* Return the number of innermost template parameters in TMPL.  */\n@@ -5879,26 +5882,27 @@ get_underlying_template (tree tmpl)\n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n   while (DECL_ALIAS_TEMPLATE_P (tmpl))\n     {\n-      tree result = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n-      if (TYPE_TEMPLATE_INFO (result))\n-\t{\n-\t  tree sub = TYPE_TI_TEMPLATE (result);\n-\t  if (PRIMARY_TEMPLATE_P (sub)\n-\t      && (num_innermost_template_parms (tmpl)\n-\t\t  == num_innermost_template_parms (sub)))\n-\t    {\n-\t      tree alias_args = INNERMOST_TEMPLATE_ARGS\n-\t\t(template_parms_to_args (DECL_TEMPLATE_PARMS (tmpl)));\n-\t      if (!comp_template_args (TYPE_TI_ARGS (result), alias_args))\n-\t\tbreak;\n-\t      /* The alias type is equivalent to the pattern of the\n-\t\t underlying template, so strip the alias.  */\n-\t      tmpl = sub;\n-\t      continue;\n-\t    }\n-\t}\n-      break;\n+      /* Determine if the alias is equivalent to an underlying template.  */\n+      tree orig_type = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n+      tree tinfo = TYPE_TEMPLATE_INFO_MAYBE_ALIAS (orig_type);\n+      if (!tinfo)\n+\tbreak;\n+\n+      tree underlying = TI_TEMPLATE (tinfo);\n+      if (!PRIMARY_TEMPLATE_P (underlying)\n+\t  || (num_innermost_template_parms (tmpl)\n+\t      != num_innermost_template_parms (underlying)))\n+\tbreak;\n+\n+      tree alias_args = INNERMOST_TEMPLATE_ARGS\n+\t(template_parms_to_args (DECL_TEMPLATE_PARMS (tmpl)));\n+      if (!comp_template_args (TI_ARGS (tinfo), alias_args))\n+\tbreak;\n+\n+      /* Alias is equivalent.  Strip it and repeat.  */\n+      tmpl = underlying;\n     }\n+\n   return tmpl;\n }\n \n@@ -8375,9 +8379,8 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t     TEMPLATE will be `template <class T> template\n \t     <class U> struct S1<T>::S2'.  We must fill in the missing\n \t     arguments.  */\n-\t  arglist\n-\t    = add_outermost_template_args (TYPE_TI_ARGS (TREE_TYPE (templ)),\n-\t\t\t\t\t   arglist);\n+\t  tree ti = TYPE_TEMPLATE_INFO_MAYBE_ALIAS (TREE_TYPE (templ));\n+\t  arglist = add_outermost_template_args (TI_ARGS (ti), arglist);\n \t  arg_depth = TMPL_ARGS_DEPTH (arglist);\n \t}\n \n@@ -8407,13 +8410,15 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \n \t the `C<T>' is just the same as `C'.  Outside of the\n \t class, however, such a reference is an instantiation.  */\n-      if ((entering_scope\n-\t   || !PRIMARY_TEMPLATE_P (gen_tmpl)\n-\t   || currently_open_class (template_type))\n-\t  /* comp_template_args is expensive, check it last.  */\n-\t  && comp_template_args (TYPE_TI_ARGS (template_type),\n-\t\t\t\t arglist))\n-\treturn template_type;\n+      if (entering_scope\n+\t  || !PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t  || currently_open_class (template_type))\n+\t{\n+\t  tree tinfo = TYPE_TEMPLATE_INFO_MAYBE_ALIAS (template_type);\n+\n+\t  if (comp_template_args (TI_ARGS (tinfo), arglist))\n+\t    return template_type;\n+\t}\n \n       /* If we already have this specialization, return it.  */\n       elt.tmpl = gen_tmpl;\n@@ -8641,12 +8646,11 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  && CLASS_TYPE_P (context)\n \t  && !same_type_p (context, DECL_CONTEXT (gen_tmpl)))\n \t{\n-\t  tree partial_inst_args;\n \t  TREE_VEC_LENGTH (arglist)--;\n \t  ++processing_template_decl;\n-\t  partial_inst_args =\n-\t    tsubst (INNERMOST_TEMPLATE_ARGS\n-\t\t\t(TYPE_TI_ARGS (TREE_TYPE (gen_tmpl))),\n+\t  tree tinfo = TYPE_TEMPLATE_INFO_MAYBE_ALIAS (TREE_TYPE (gen_tmpl));\n+\t  tree partial_inst_args =\n+\t    tsubst (INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo)),\n \t\t    arglist, complain, NULL_TREE);\n \t  --processing_template_decl;\n \t  TREE_VEC_LENGTH (arglist)++;\n@@ -8678,11 +8682,11 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t     for parameters in the TYPE_DECL of the alias template\n \t     done earlier.  So be careful while getting the template\n \t     of FOUND.  */\n-\t  found = TREE_CODE (found) == TEMPLATE_DECL\n-\t    ? found\n-\t    : TREE_CODE (found) == TYPE_DECL\n-\t    ? TYPE_TI_TEMPLATE (TREE_TYPE (found))\n-\t    : CLASSTYPE_TI_TEMPLATE (found);\n+\t  found = (TREE_CODE (found) == TEMPLATE_DECL\n+\t\t   ? found\n+\t\t   : (TREE_CODE (found) == TYPE_DECL\n+\t\t      ? DECL_TI_TEMPLATE (found)\n+\t\t      : CLASSTYPE_TI_TEMPLATE (found)));\n \t}\n \n       // Build template info for the new specialization.\n@@ -20035,9 +20039,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t    return unify_template_deduction_failure (explain_p, parm, arg);\n \t  {\n \t    tree parmvec = TYPE_TI_ARGS (parm);\n-\t    /* An alias template name is never deduced.  */\n-\t    if (TYPE_ALIAS_P (arg))\n-\t      arg = strip_typedefs (arg);\n \t    tree argvec = INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (arg));\n \t    tree full_argvec = add_to_template_args (targs, argvec);\n \t    tree parm_parms "}, {"sha": "4378e36bbe7a9fb12e7f55190fda4cf7fa4f701e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -1,3 +1,8 @@\n+2016-12-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/69481\n+\t* g++.dg/cpp0x/pr69481.C: New.\n+\n 2016-12-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78794"}, {"sha": "bab166b70ae93dc33a239ecb2a0353a4e242436a", "filename": "gcc/testsuite/g++.dg/cpp0x/pr69481.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr69481.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr69481.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr69481.C?ref=5bfd81e7159a1d3a2e200f9f99bd0068bad7beb8", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/69481\n+// { dg-do compile { target c++11 } }\n+\n+// ICE with canonical type verification\n+\n+template <typename> struct Traits;\n+\n+template <typename T>\n+struct Bob {\n+  using Loc = Traits<T>;\n+  using typename Loc::Thing;\n+\n+  Thing Foo (); \n+};\n+\n+template <class V> struct tt\n+{\n+  using ut = tt<V>;\n+  ut Bob ();\n+};\n+\n+template <class V>\n+tt<V> tt<V>::Bob ()\n+{\n+  return tt();\n+}"}]}