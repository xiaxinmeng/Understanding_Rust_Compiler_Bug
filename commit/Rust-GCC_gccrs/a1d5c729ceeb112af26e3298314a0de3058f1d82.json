{"sha": "a1d5c729ceeb112af26e3298314a0de3058f1d82", "node_id": "C_kwDOANBUbNoAKGExZDVjNzI5Y2VlYjExMmFmMjZlMzI5ODMxNGEwZGUzMDU4ZjFkODI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-10T09:07:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-10T09:07:51Z"}, "message": "range-op-float: Fix up -ffinite-math-only range extension and don't extend into infinities [PR109008]\n\nThe following patch does two things (both related to range extension\naround the boundaries).\n\nThe first part (in the 2 real_isfinite blocks) is to make the ranges\nnarrower when the old boundaries are minimum and/or maximum representable\nfinite number.  In that case frange_nextafter gives -Inf or +Inf,\nbut then the resulting computed reverse range is very far from the actually\nneeded range, usually extends up to infinity or could even result in NaNs.\nWhile infinities are really the next representable numbers in the\ncorresponding mode, REAL_VALUE_TYPE is actually a type with wider range\nfor exponent and 160 bit precision, so the patch instead uses\nnextafter number in a hypothetical floating point format with the same\nmantissa precision but wider range of exponents.  This significantly\nimproves the actual ranges of the reverse operations, while still making\nthem conservatively correct.\n\nThe second part is a fix for miscompilation of the new testcase below.\nFor -ffinite-math-only, without this patch we extend the minimum and/or\nmaximum representable finite number to -Inf or +Inf, with the patch to\nsome number outside of the normal exponent range of the mode, but then\nwe use set which canonicalizes it and turns the boundaries back to\nthe minimum and/or maximum representable finite numbers, but because\nin say [__DBL_MAX__, __DBL_MAX__] = op1 + [__DBL_MAX__, __DBL_MAX__]\nop1 can be larger than 0, up to the largest number which rounds to even\ndown back to __DBL_MAX__ and there are still no infinities involved,\nit needs to work even with -ffinite-math-only.  So, we really need to\nwiden the lhs range a little bit even in that case.  The patch does\nthat through temporarily clearing -ffinite-math-only, such that the\nvalue with infinities or the outside of bounds values passes the\nsetting and verification (the VR_VARYING case is needed because\nwe get ICEs otherwise, but when lhs is VR_VARYING in -ffast-math,\ni.e. minimum to maximum representable finite and both signs of NaN,\nthen set does all we need, we don't need to or in a NaN range).\nWe don't really later use the range in a way that would become a problem\nthat it is wider than varying, we actually just perform maths on the\ntwo boundaries.\n\nAs I said in the PR, this doesn't fix the !MODE_HAS_INFINITIES case,\nI believe we actually need to treat the boundary values as infinities\nin that case because they (probably) work like that, but it is unclear\nif it is just the reverse operation lhs widening that is a problem there,\nor whether it is a general problem.  I have zero experience with\nfloating points without infinities (PDP11, some ARM half type?,\nwhat else?).\n\n2023-03-10  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/109008\n\t* range-op-float.cc (float_widen_lhs_range): If lb is\n\tminimum representable finite number or ub is maximum\n\trepresentable finite number, instead of widening it to\n\t-inf or inf widen it to negative or positive 0x0.8p+(EMAX+1).\n\tTemporarily clear flag_finite_math_only when canonicalizing\n\tthe widened range.\n\n\t* gcc.dg/pr109008.c: New test.", "tree": {"sha": "cdcb193eae8ed6be54351cfb9867f6eb6c55ff95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdcb193eae8ed6be54351cfb9867f6eb6c55ff95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1d5c729ceeb112af26e3298314a0de3058f1d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d5c729ceeb112af26e3298314a0de3058f1d82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d5c729ceeb112af26e3298314a0de3058f1d82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d5c729ceeb112af26e3298314a0de3058f1d82/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60bd33bcbb75fbe040efe681f81e864a0df2244d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60bd33bcbb75fbe040efe681f81e864a0df2244d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60bd33bcbb75fbe040efe681f81e864a0df2244d"}], "stats": {"total": 64, "additions": 60, "deletions": 4}, "files": [{"sha": "58606aa46112f83dd9d7aa41a9d4728219d4871a", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d5c729ceeb112af26e3298314a0de3058f1d82/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d5c729ceeb112af26e3298314a0de3058f1d82/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=a1d5c729ceeb112af26e3298314a0de3058f1d82", "patch": "@@ -2217,12 +2217,42 @@ float_widen_lhs_range (tree type, const frange &lhs)\n   REAL_VALUE_TYPE lb = lhs.lower_bound ();\n   REAL_VALUE_TYPE ub = lhs.upper_bound ();\n   if (real_isfinite (&lb))\n-    frange_nextafter (TYPE_MODE (type), lb, dconstninf);\n+    {\n+      frange_nextafter (TYPE_MODE (type), lb, dconstninf);\n+      if (real_isinf (&lb))\n+\t{\n+\t  /* For -DBL_MAX, instead of -Inf use\n+\t     nexttoward (-DBL_MAX, -LDBL_MAX) in a hypothetical\n+\t     wider type with the same mantissa precision but larger\n+\t     exponent range; it is outside of range of double values,\n+\t     but makes it clear it is just one ulp larger rather than\n+\t     infinite amount larger.  */\n+\t  lb = dconstm1;\n+\t  SET_REAL_EXP (&lb, FLOAT_MODE_FORMAT (TYPE_MODE (type))->emax + 1);\n+\t}\n+    }\n   if (real_isfinite (&ub))\n-    frange_nextafter (TYPE_MODE (type), ub, dconstinf);\n+    {\n+      frange_nextafter (TYPE_MODE (type), ub, dconstinf);\n+      if (real_isinf (&ub))\n+\t{\n+\t  /* For DBL_MAX similarly.  */\n+\t  ub = dconst1;\n+\t  SET_REAL_EXP (&ub, FLOAT_MODE_FORMAT (TYPE_MODE (type))->emax + 1);\n+\t}\n+    }\n+  /* Temporarily disable -ffinite-math-only, so that frange::set doesn't\n+     reduce the range back to real_min_representable (type) as lower bound\n+     or real_max_representable (type) as upper bound.  */\n+  bool save_flag_finite_math_only = flag_finite_math_only;\n+  flag_finite_math_only = false;\n   ret.set (type, lb, ub);\n-  ret.clear_nan ();\n-  ret.union_ (lhs);\n+  if (lhs.kind () != VR_VARYING)\n+    {\n+      ret.clear_nan ();\n+      ret.union_ (lhs);\n+    }\n+  flag_finite_math_only = save_flag_finite_math_only;\n   return ret;\n }\n "}, {"sha": "9c5614b44c8a51b9345c4002e25000a07bd3d870", "filename": "gcc/testsuite/gcc.dg/pr109008.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d5c729ceeb112af26e3298314a0de3058f1d82/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109008.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d5c729ceeb112af26e3298314a0de3058f1d82/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109008.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109008.c?ref=a1d5c729ceeb112af26e3298314a0de3058f1d82", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/109008 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffinite-math-only -fexcess-precision=standard\" } */\n+\n+__attribute__((noipa)) double\n+foo (double eps)\n+{\n+  double d = __DBL_MAX__ + eps;\n+  if (d == __DBL_MAX__)\n+    if (eps > 16.0)\n+      return eps;\n+  return 0.0;\n+}\n+\n+int\n+main ()\n+{\n+#if __DBL_MANT_DIG__ == 53 && __DBL_MAX_EXP__ == 1024 && __DBL_MIN_EXP__ == -1021 \\\n+    && __FLT_EVAL_METHOD__ == 0\n+  if (foo (0x0.8p+970) == 0.0)\n+    __builtin_abort ();\n+  if (foo (32.0) == 0.0)\n+    __builtin_abort ();\n+#endif\n+  return 0;\n+}"}]}