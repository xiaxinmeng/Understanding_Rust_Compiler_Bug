{"sha": "fa54f4da74b48a088fb1cef7b7f593d02319d019", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1NGY0ZGE3NGI0OGEwODhmYjFjZWY3YjdmNTkzZDAyMzE5ZDAxOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-24T08:36:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-02T08:58:20Z"}, "message": "[Ada] Remove degenerate Treat_Fixed_As_Integer mechanism\n\n2020-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Op_Divide): Remove code dealing with\n\tthe Treat_Fixed_As_Integer flag.\n\t(Expand_N_Op_Multiply): Likewise.\n\t* exp_fixd.adb (Build_Divide): Do the division in an integer\n\ttype long enough to hold both operands and convert the result\n\tto the type of the LHS.  Do not set Treat_Fixed_As_Integer.\n\t(Build_Multiply): Do not set Treat_Fixed_As_Integer.\n\t(Build_Rem): Likewise.\n\t* sem_ch4.adb (Analyze_Arithmetic_Op): Remove code dealing with\n\tthe Treat_Fixed_As_Integer flag.\n\t(Check_Arithmetic_Pair): Likewise.\n\t* sinfo.ads (Treat_Fixed_As_Integer): Delete.\n\t(N_Has_Treat_Fixed_As_Integer): Likewise.\n\t(Set_Treat_Fixed_As_Integer): Likewise.\n\t* sinfo.adb (Treat_Fixed_As_Integer): Likewise.\n\t(Set_Treat_Fixed_As_Integer): Likewise.\n\t* sprint.ads (Syntax Extensions): Remove '#' special character.\n\t* sprint.adb (Process_TFAI_RR_Flags): Delete.\n\t(Sprint_Node_Actual) <N_Op_Divide>: Print '@' manually.\n\t<N_Op_Multiply>: Likewise.\n\t<N_Op_Mod>: Do not print '#'.\n\t<N_Op_Rem>: Likewise.", "tree": {"sha": "46e552494ee55a6bcc714a1aab1df6d8d97d65c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e552494ee55a6bcc714a1aab1df6d8d97d65c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa54f4da74b48a088fb1cef7b7f593d02319d019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa54f4da74b48a088fb1cef7b7f593d02319d019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa54f4da74b48a088fb1cef7b7f593d02319d019", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa54f4da74b48a088fb1cef7b7f593d02319d019/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a987d785122fb015aac527e927818bdc9975a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a987d785122fb015aac527e927818bdc9975a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a987d785122fb015aac527e927818bdc9975a7b"}], "stats": {"total": 349, "additions": 117, "deletions": 232}, "files": [{"sha": "85840a6d5b74635134344ff9d27ae60fdba36f86", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -7432,16 +7432,10 @@ package body Exp_Ch4 is\n \n       if Is_Fixed_Point_Type (Typ) then\n \n-         --  No special processing if Treat_Fixed_As_Integer is set, since\n-         --  from a semantic point of view such operations are simply integer\n-         --  operations and will be treated that way.\n-\n-         if not Treat_Fixed_As_Integer (N) then\n-            if Is_Integer_Type (Rtyp) then\n-               Expand_Divide_Fixed_By_Integer_Giving_Fixed (N);\n-            else\n-               Expand_Divide_Fixed_By_Fixed_Giving_Fixed (N);\n-            end if;\n+         if Is_Integer_Type (Rtyp) then\n+            Expand_Divide_Fixed_By_Integer_Giving_Fixed (N);\n+         else\n+            Expand_Divide_Fixed_By_Fixed_Giving_Fixed (N);\n          end if;\n \n          --  Deal with divide-by-zero check if back end cannot handle them\n@@ -7465,12 +7459,9 @@ package body Exp_Ch4 is\n                   Reason  => CE_Divide_By_Zero));\n          end if;\n \n-      --  Other cases of division of fixed-point operands. Again we exclude the\n-      --  case where Treat_Fixed_As_Integer is set.\n+      --  Other cases of division of fixed-point operands\n \n-      elsif (Is_Fixed_Point_Type (Ltyp) or else Is_Fixed_Point_Type (Rtyp))\n-        and then not Treat_Fixed_As_Integer (N)\n-      then\n+      elsif Is_Fixed_Point_Type (Ltyp) or else Is_Fixed_Point_Type (Rtyp) then\n          if Is_Integer_Type (Typ) then\n             Expand_Divide_Fixed_By_Fixed_Giving_Integer (N);\n          else\n@@ -9574,35 +9565,25 @@ package body Exp_Ch4 is\n \n       if Is_Fixed_Point_Type (Typ) then\n \n-         --  No special processing if Treat_Fixed_As_Integer is set, since from\n-         --  a semantic point of view such operations are simply integer\n-         --  operations and will be treated that way.\n-\n-         if not Treat_Fixed_As_Integer (N) then\n+         --  Case of fixed * integer => fixed\n \n-            --  Case of fixed * integer => fixed\n+         if Is_Integer_Type (Rtyp) then\n+            Expand_Multiply_Fixed_By_Integer_Giving_Fixed (N);\n \n-            if Is_Integer_Type (Rtyp) then\n-               Expand_Multiply_Fixed_By_Integer_Giving_Fixed (N);\n+         --  Case of integer * fixed => fixed\n \n-            --  Case of integer * fixed => fixed\n+         elsif Is_Integer_Type (Ltyp) then\n+            Expand_Multiply_Integer_By_Fixed_Giving_Fixed (N);\n \n-            elsif Is_Integer_Type (Ltyp) then\n-               Expand_Multiply_Integer_By_Fixed_Giving_Fixed (N);\n+         --  Case of fixed * fixed => fixed\n \n-            --  Case of fixed * fixed => fixed\n-\n-            else\n-               Expand_Multiply_Fixed_By_Fixed_Giving_Fixed (N);\n-            end if;\n+         else\n+            Expand_Multiply_Fixed_By_Fixed_Giving_Fixed (N);\n          end if;\n \n-      --  Other cases of multiplication of fixed-point operands. Again we\n-      --  exclude the cases where Treat_Fixed_As_Integer flag is set.\n+      --  Other cases of multiplication of fixed-point operands\n \n-      elsif (Is_Fixed_Point_Type (Ltyp) or else Is_Fixed_Point_Type (Rtyp))\n-        and then not Treat_Fixed_As_Integer (N)\n-      then\n+      elsif Is_Fixed_Point_Type (Ltyp) or else Is_Fixed_Point_Type (Rtyp) then\n          if Is_Integer_Type (Typ) then\n             Expand_Multiply_Fixed_By_Fixed_Giving_Integer (N);\n          else"}, {"sha": "b237271df6cd16866ba0a7bf79605342d3f4a826", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 79, "deletions": 62, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -56,8 +56,8 @@ package body Exp_Fixd is\n    --  set the Etype values correctly. In addition, setting the Etype ensures\n    --  that the analyzer does not try to redetermine the type when the node\n    --  is analyzed (which would be wrong, since in the case where we set the\n-   --  Treat_Fixed_As_Integer or Conversion_OK flags, it would think it was\n-   --  still dealing with a normal fixed-point operation and mess it up).\n+   --  Conversion_OK flag, it would think it was still dealing with a normal\n+   --  fixed-point operation and mess it up).\n \n    function Build_Conversion\n      (N     : Node_Id;\n@@ -79,12 +79,13 @@ package body Exp_Fixd is\n    --  expressions, using the source location from Sloc (N). The operands are\n    --  either both Universal_Real, in which case Build_Divide differs from\n    --  Make_Op_Divide only in that the Etype of the resulting node is set (to\n-   --  Universal_Real), or they can be integer types. In this case the integer\n-   --  types need not be the same, and Build_Divide converts the operand with\n-   --  the smaller sized type to match the type of the other operand and sets\n-   --  this as the result type. The Rounded_Result flag of the result in this\n-   --  case is set from the Rounded_Result flag of node N. On return, the\n-   --  resulting node is analyzed, and has its Etype set.\n+   --  Universal_Real), or they can be integer or fixed-point types. In this\n+   --  case the types need not be the same, and Build_Divide chooses a type\n+   --  long enough to hold both operands (i.e. the size of the longer of the\n+   --  two operand types), and both operands are converted to this type. The\n+   --  Etype of the result is also set to this value. The Rounded_Result flag\n+   --  of the result in this case is set from the Rounded_Result flag of node\n+   --  N. On return, the resulting node is analyzed and has its Etype set.\n \n    function Build_Double_Divide\n      (N       : Node_Id;\n@@ -111,13 +112,13 @@ package body Exp_Fixd is\n    --  expressions, using the source location from Sloc (N). The operands are\n    --  either both Universal_Real, in which case Build_Multiply differs from\n    --  Make_Op_Multiply only in that the Etype of the resulting node is set (to\n-   --  Universal_Real), or they can be integer types. In this case the integer\n-   --  types need not be the same, and Build_Multiply chooses a type long\n-   --  enough to hold the product (i.e. twice the size of the longer of the two\n-   --  operand types), and both operands are converted to this type. The Etype\n-   --  of the result is also set to this value. However, the result can never\n-   --  overflow Integer_64, so this is the largest type that is ever generated.\n-   --  On return, the resulting node is analyzed and has its Etype set.\n+   --  Universal_Real), or they can be integer or fixed-point types. In this\n+   --  case the types need not be the same, and Build_Multiply chooses a type\n+   --  long enough to hold the product (i.e. twice the size of the longer of\n+   --  the two operand types), and both operands are converted to this type.\n+   --  The Etype of the result is also set to this value. However, the result\n+   --  can never overflow Integer_64, so this is the largest type that is ever\n+   --  generated. On return, the resulting node is analyzed and has Etype set.\n \n    function Build_Rem (N : Node_Id; L, R : Node_Id) return Node_Id;\n    --  Builds an N_Op_Rem node from the given left and right operand\n@@ -317,6 +318,9 @@ package body Exp_Fixd is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Left_Type   : constant Entity_Id  := Base_Type (Etype (L));\n       Right_Type  : constant Entity_Id  := Base_Type (Etype (R));\n+      Left_Size   : Int;\n+      Right_Size  : Int;\n+      Rsize       : Int;\n       Result_Type : Entity_Id;\n       Rnode       : Node_Id;\n \n@@ -341,48 +345,68 @@ package body Exp_Fixd is\n             return L;\n          end if;\n \n-         --  If left and right types are the same, no conversion needed\n+         --  First figure out the effective sizes of the operands. Normally\n+         --  the effective size of an operand is the RM_Size of the operand.\n+         --  But a special case arises with operands whose size is known at\n+         --  compile time. In this case, we can use the actual value of the\n+         --  operand to get its size if it would fit signed in 8 or 16 bits.\n+\n+         Left_Size := UI_To_Int (RM_Size (Left_Type));\n+\n+         if Compile_Time_Known_Value (L) then\n+            declare\n+               Val : constant Uint := Expr_Value (L);\n+            begin\n+               if Val < Int'(2 ** 7) then\n+                  Left_Size := 8;\n+               elsif Val < Int'(2 ** 15) then\n+                  Left_Size := 16;\n+               end if;\n+            end;\n+         end if;\n+\n+         Right_Size := UI_To_Int (RM_Size (Right_Type));\n+\n+         if Compile_Time_Known_Value (R) then\n+            declare\n+               Val : constant Uint := Expr_Value (R);\n+            begin\n+               if Val <= Int'(2 ** 7) then\n+                  Right_Size := 8;\n+               elsif Val <= Int'(2 ** 15) then\n+                  Right_Size := 16;\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Do the operation using the longer of the two sizes\n \n-         if Left_Type = Right_Type then\n-            Result_Type := Left_Type;\n-            Rnode :=\n-              Make_Op_Divide (Loc,\n-                Left_Opnd  => L,\n-                Right_Opnd => R);\n+         Rsize := Int'Max (Left_Size, Right_Size);\n \n-         --  Use left type if it is the larger of the two\n+         if Rsize <= 8 then\n+            Result_Type := Standard_Integer_8;\n \n-         elsif Esize (Left_Type) >= Esize (Right_Type) then\n-            Result_Type := Left_Type;\n-            Rnode :=\n-              Make_Op_Divide (Loc,\n-                Left_Opnd  => L,\n-                Right_Opnd => Build_Conversion (N, Left_Type, R));\n+         elsif Rsize <= 16 then\n+            Result_Type := Standard_Integer_16;\n \n-         --  Otherwise right type is larger of the two, us it\n+         elsif Rsize <= 32 then\n+            Result_Type := Standard_Integer_32;\n \n          else\n-            Result_Type := Right_Type;\n-            Rnode :=\n-              Make_Op_Divide (Loc,\n-                Left_Opnd => Build_Conversion (N, Right_Type, L),\n-                Right_Opnd => R);\n+            Result_Type := Standard_Integer_64;\n          end if;\n+\n+         Rnode :=\n+            Make_Op_Divide (Loc,\n+              Left_Opnd  => Build_Conversion (N, Result_Type, L),\n+              Right_Opnd => Build_Conversion (N, Result_Type, R));\n       end if;\n \n       --  We now have a divide node built with Result_Type set. First\n       --  set Etype of result, as required for all Build_xxx routines\n \n       Set_Etype (Rnode, Base_Type (Result_Type));\n \n-      --  Set Treat_Fixed_As_Integer if operation on fixed-point type\n-      --  since this is a literal arithmetic operation, to be performed\n-      --  by Gigi without any consideration of small values.\n-\n-      if Is_Fixed_Point_Type (Result_Type) then\n-         Set_Treat_Fixed_As_Integer (Rnode);\n-      end if;\n-\n       --  The result is rounded if the target of the operation is decimal\n       --  and Rounded_Result is set, or if the target of the operation\n       --  is an integer type.\n@@ -393,6 +417,17 @@ package body Exp_Fixd is\n          Set_Rounded_Result (Rnode);\n       end if;\n \n+      --  One more check. We did the divide operation using the longer of\n+      --  the two sizes, which is reasonable. However, in the case where the\n+      --  two types have unequal sizes, it is impossible for the result of\n+      --  a divide operation to be larger than the dividend, so we can put\n+      --  a conversion round the result to keep the evolving operation size\n+      --  as small as possible.\n+\n+      if not Is_Floating_Point_Type (Left_Type) then\n+         Rnode := Build_Conversion (N, Left_Type, Rnode);\n+      end if;\n+\n       return Rnode;\n    end Build_Divide;\n \n@@ -696,14 +731,6 @@ package body Exp_Fixd is\n \n       Set_Etype (Rnode, Base_Type (Result_Type));\n \n-      --  Set Treat_Fixed_As_Integer if operation on fixed-point type\n-      --  since this is a literal arithmetic operation, to be performed\n-      --  by Gigi without any consideration of small values.\n-\n-      if Is_Fixed_Point_Type (Result_Type) then\n-         Set_Treat_Fixed_As_Integer (Rnode);\n-      end if;\n-\n       return Rnode;\n    end Build_Multiply;\n \n@@ -752,14 +779,6 @@ package body Exp_Fixd is\n \n       Set_Etype (Rnode, Base_Type (Result_Type));\n \n-      --  Set Treat_Fixed_As_Integer if operation on fixed-point type\n-      --  since this is a literal arithmetic operation, to be performed\n-      --  by Gigi without any consideration of small values.\n-\n-      if Is_Fixed_Point_Type (Result_Type) then\n-         Set_Treat_Fixed_As_Integer (Rnode);\n-      end if;\n-\n       --  One more check. We did the rem operation using the larger of the\n       --  two types, which is reasonable. However, in the case where the\n       --  two types have unequal sizes, it is impossible for the result of\n@@ -2387,9 +2406,7 @@ package body Exp_Fixd is\n \n       --  We really need to set Analyzed here because we may be creating a\n       --  very strange beast, namely an integer literal typed as fixed-point\n-      --  and the analyzer won't like that. Probably we should allow the\n-      --  Treat_Fixed_As_Integer flag to appear on integer literal nodes\n-      --  and teach the analyzer how to handle them ???\n+      --  and the analyzer won't like that.\n \n       Set_Analyzed (L);\n       return L;"}, {"sha": "8ac5e21fa993a1d45863806646a40198d0f6b1cc", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -935,16 +935,8 @@ package body Sem_Ch4 is\n \n       if Present (Op_Id) then\n          if Ekind (Op_Id) = E_Operator then\n-\n-            if Nkind_In (N, N_Op_Divide, N_Op_Mod, N_Op_Multiply, N_Op_Rem)\n-              and then Treat_Fixed_As_Integer (N)\n-            then\n-               null;\n-            else\n-               Set_Etype (N, Any_Type);\n-               Find_Arithmetic_Types (L, R, Op_Id, N);\n-            end if;\n-\n+            Set_Etype (N, Any_Type);\n+            Find_Arithmetic_Types (L, R, Op_Id, N);\n          else\n             Set_Etype (N, Any_Type);\n             Add_One_Interp (N, Op_Id, Etype (Op_Id));\n@@ -5915,25 +5907,15 @@ package body Sem_Ch4 is\n          if Is_Fixed_Point_Type (T1)\n            and then (Is_Fixed_Point_Type (T2) or else T2 = Universal_Real)\n          then\n-            --  If Treat_Fixed_As_Integer is set then the Etype is already set\n-            --  and no further processing is required (this is the case of an\n-            --  operator constructed by Exp_Fixd for a fixed point operation)\n-            --  Otherwise add one interpretation with universal fixed result\n-            --  If the operator is given in functional notation, it comes\n-            --  from source and Fixed_As_Integer cannot apply.\n-\n-            if (Nkind (N) not in N_Op\n-                 or else not Treat_Fixed_As_Integer (N))\n-              and then\n-                (not Has_Fixed_Op (T1, Op_Id)\n-                  or else Nkind (Parent (N)) = N_Type_Conversion)\n+            --  Add one interpretation with universal fixed result\n+\n+            if not Has_Fixed_Op (T1, Op_Id)\n+              or else Nkind (Parent (N)) = N_Type_Conversion\n             then\n                Add_One_Interp (N, Op_Id, Universal_Fixed);\n             end if;\n \n          elsif Is_Fixed_Point_Type (T2)\n-           and then (Nkind (N) not in N_Op\n-                      or else not Treat_Fixed_As_Integer (N))\n            and then T1 = Universal_Real\n            and then\n              (not Has_Fixed_Op (T1, Op_Id)\n@@ -5985,10 +5967,6 @@ package body Sem_Ch4 is\n \n       elsif Op_Name = Name_Op_Mod or else Op_Name = Name_Op_Rem then\n \n-         --  Note: The fixed-point operands case with Treat_Fixed_As_Integer\n-         --  set does not require any special processing, since the Etype is\n-         --  already set (case of operation constructed by Exp_Fixed).\n-\n          if Is_Integer_Type (T1)\n            and then (Covers (T1 => T1, T2 => T2)\n                        or else"}, {"sha": "2df0c90ed6681ab1a4a58733994e351bff50f998", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -3411,17 +3411,6 @@ package body Sinfo is\n       return List2 (N);\n    end Then_Statements;\n \n-   function Treat_Fixed_As_Integer\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Op_Divide\n-        or else NT (N).Nkind = N_Op_Mod\n-        or else NT (N).Nkind = N_Op_Multiply\n-        or else NT (N).Nkind = N_Op_Rem);\n-      return Flag14 (N);\n-   end Treat_Fixed_As_Integer;\n-\n    function Triggering_Alternative\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -6916,17 +6905,6 @@ package body Sinfo is\n       Set_List2_With_Parent (N, Val);\n    end Set_Then_Statements;\n \n-   procedure Set_Treat_Fixed_As_Integer\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Op_Divide\n-        or else NT (N).Nkind = N_Op_Mod\n-        or else NT (N).Nkind = N_Op_Multiply\n-        or else NT (N).Nkind = N_Op_Rem);\n-      Set_Flag14 (N, Val);\n-   end Set_Treat_Fixed_As_Integer;\n-\n    procedure Set_Triggering_Alternative\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "78ac00bb2693ae2cced6415b522ccfab1bc106b0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 9, "deletions": 48, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -2451,20 +2451,6 @@ package Sinfo is\n    --    need for this field, so in the tree passed to Gigi, this field is\n    --    always set to No_List.\n \n-   --  Treat_Fixed_As_Integer (Flag14-Sem)\n-   --    This flag appears in operator nodes for divide, multiply, mod, and rem\n-   --    on fixed-point operands. It indicates that the operands are to be\n-   --    treated as integer values, ignoring small values. This flag is only\n-   --    set as a result of expansion of fixed-point operations. Typically a\n-   --    fixed-point multiplication in the source generates subsidiary\n-   --    multiplication and division operations that work with the underlying\n-   --    integer values and have this flag set. Note that this flag is not\n-   --    needed on other arithmetic operations (add, neg, subtract etc.) since\n-   --    in these cases it is always the case that fixed is treated as integer.\n-   --    The Etype field MUST be set if this flag is set. The analyzer knows to\n-   --    leave such nodes alone, and whoever makes them must set the correct\n-   --    Etype value.\n-\n    --  TSS_Elist (Elist3-Sem)\n    --    Present in N_Freeze_Entity nodes. Holds an element list containing\n    --    entries for each TSS (type support subprogram) associated with the\n@@ -4527,20 +4513,13 @@ package Sinfo is\n \n       --  HIGHEST_PRECEDENCE_OPERATOR  ::=  **  | abs | not\n \n-      --  Sprint syntax if Treat_Fixed_As_Integer is set:\n-\n-      --     x #* y\n-      --     x #/ y\n-      --     x #mod y\n-      --     x #rem y\n-\n-      --  Gigi restriction: For * / mod rem with fixed-point operands, Gigi\n-      --  will only be given nodes with the Treat_Fixed_As_Integer flag set.\n-      --  All handling of smalls for multiplication and division is handled\n-      --  by the front end (mod and rem result only from expansion). Gigi\n-      --  thus never needs to worry about small values (for other operators\n-      --  operating on fixed-point, e.g. addition, the small value does not\n-      --  have any semantic effect anyway, these are always integer operations.\n+      --  Gigi restriction: Gigi will never be given * / mod rem nodes with\n+      --  fixed-point operands. All handling of smalls for multiplication and\n+      --  division is handled by the front end (mod and rem result only from\n+      --  expansion). Gigi thus never needs to worry about small values (for\n+      --  other operators operating on fixed-point, e.g. addition, the small\n+      --  value does not have any semantic effect anyway, these are always\n+      --  integer operations.\n \n       --  Gigi restriction: For all operators taking Boolean operands, the\n       --  type is always Standard.Boolean. The expander inserts the required\n@@ -4613,29 +4592,25 @@ package Sinfo is\n \n       --  N_Op_Multiply\n       --  Sloc points to *\n-      --  Treat_Fixed_As_Integer (Flag14-Sem)\n       --  Rounded_Result (Flag18-Sem)\n       --  plus fields for binary operator\n       --  plus fields for expression\n \n       --  N_Op_Divide\n       --  Sloc points to /\n-      --  Treat_Fixed_As_Integer (Flag14-Sem)\n       --  Do_Division_Check (Flag13-Sem)\n       --  Rounded_Result (Flag18-Sem)\n       --  plus fields for binary operator\n       --  plus fields for expression\n \n       --  N_Op_Mod\n       --  Sloc points to MOD\n-      --  Treat_Fixed_As_Integer (Flag14-Sem)\n       --  Do_Division_Check (Flag13-Sem)\n       --  plus fields for binary operator\n       --  plus fields for expression\n \n       --  N_Op_Rem\n       --  Sloc points to REM\n-      --  Treat_Fixed_As_Integer (Flag14-Sem)\n       --  Do_Division_Check (Flag13-Sem)\n       --  plus fields for binary operator\n       --  plus fields for expression\n@@ -4672,9 +4647,7 @@ package Sinfo is\n       --  the semantics is to treat these simply as integer operations, with\n       --  the small values being ignored (the bounds are already stored in\n       --  units of small, so that constraint checking works as usual). For the\n-      --  case of multiply/divide/rem/mod operations, Gigi will only see fixed\n-      --  point operands if the Treat_Fixed_As_Integer flag is set and will\n-      --  thus treat these nodes in identical manner, ignoring small values.\n+      --  case of multiply/divide/rem/mod operations, Gigi will never see them.\n \n       --  Note on equality/inequality tests for records. In the expanded tree,\n       --  record comparisons are always expanded to be a series of component\n@@ -8707,7 +8680,7 @@ package Sinfo is\n       N_Op_Expon,\n       N_Op_Subtract,\n \n-      --  N_Binary_Op, N_Op, N_Subexpr, N_Has_Treat_Fixed_As_Integer\n+      --  N_Binary_Op, N_Op, N_Subexpr,\n       --  N_Has_Etype, N_Has_Chars, N_Has_Entity, N_Multiplying_Operator\n \n       N_Op_Divide,\n@@ -9115,10 +9088,6 @@ package Sinfo is\n      N_Error ..\n      N_Subtype_Indication;\n \n-   subtype N_Has_Treat_Fixed_As_Integer is Node_Kind range\n-      N_Op_Divide ..\n-      N_Op_Rem;\n-\n    subtype N_Multiplying_Operator is Node_Kind range\n       N_Op_Divide ..\n       N_Op_Rem;\n@@ -10296,9 +10265,6 @@ package Sinfo is\n    function Then_Statements\n      (N : Node_Id) return List_Id;    -- List2\n \n-   function Treat_Fixed_As_Integer\n-     (N : Node_Id) return Boolean;    -- Flag14\n-\n    function Triggering_Alternative\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -11411,9 +11377,6 @@ package Sinfo is\n    procedure Set_Then_Statements\n      (N : Node_Id; Val : List_Id);            -- List2\n \n-   procedure Set_Treat_Fixed_As_Integer\n-     (N : Node_Id; Val : Boolean := True);    -- Flag14\n-\n    procedure Set_Triggering_Alternative\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -13679,7 +13642,6 @@ package Sinfo is\n    pragma Inline (Then_Statements);\n    pragma Inline (Triggering_Alternative);\n    pragma Inline (Triggering_Statement);\n-   pragma Inline (Treat_Fixed_As_Integer);\n    pragma Inline (TSS_Elist);\n    pragma Inline (Type_Definition);\n    pragma Inline (Uneval_Old_Accept);\n@@ -14044,7 +14006,6 @@ package Sinfo is\n    pragma Inline (Set_Task_Present);\n    pragma Inline (Set_Then_Actions);\n    pragma Inline (Set_Then_Statements);\n-   pragma Inline (Set_Treat_Fixed_As_Integer);\n    pragma Inline (Set_Triggering_Alternative);\n    pragma Inline (Set_Triggering_Statement);\n    pragma Inline (Set_Type_Definition);"}, {"sha": "6a02d8f8e01d89022c73f2032ea3947e5e8a00a7", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -176,11 +176,6 @@ package body Sprint is\n    --  Used to print output lines in Debug_Generated_Code mode (this is used\n    --  as the argument for a call to Set_Special_Output in package Output).\n \n-   procedure Process_TFAI_RR_Flags (Nod : Node_Id);\n-   --  Given a divide, multiplication or division node, check the flags\n-   --  Treat_Fixed_As_Integer and Rounded_Flags, and if set, output the\n-   --  appropriate special syntax characters (# and @).\n-\n    procedure Set_Debug_Sloc;\n    --  If Dump_Node is non-empty, this routine sets the appropriate value\n    --  in its Sloc field, from the current location in the debug source file\n@@ -471,21 +466,6 @@ package body Sprint is\n       Write_Debug_Line (S, Debug_Sloc);\n    end Print_Debug_Line;\n \n-   ---------------------------\n-   -- Process_TFAI_RR_Flags --\n-   ---------------------------\n-\n-   procedure Process_TFAI_RR_Flags (Nod : Node_Id) is\n-   begin\n-      if Treat_Fixed_As_Integer (Nod) then\n-         Write_Char ('#');\n-      end if;\n-\n-      if Rounded_Result (Nod) then\n-         Write_Char ('@');\n-      end if;\n-   end Process_TFAI_RR_Flags;\n-\n    --------\n    -- ps --\n    --------\n@@ -2508,7 +2488,9 @@ package body Sprint is\n          when N_Op_Divide =>\n             Sprint_Left_Opnd (Node);\n             Write_Char (' ');\n-            Process_TFAI_RR_Flags (Node);\n+            if Rounded_Result (Node) then\n+               Write_Char ('@');\n+            end if;\n             Write_Operator (Node, \"/ \");\n             Sprint_Right_Opnd (Node);\n \n@@ -2548,18 +2530,15 @@ package body Sprint is\n \n          when N_Op_Mod =>\n             Sprint_Left_Opnd (Node);\n-\n-            if Treat_Fixed_As_Integer (Node) then\n-               Write_Str (\" #\");\n-            end if;\n-\n             Write_Operator (Node, \" mod \");\n             Sprint_Right_Opnd (Node);\n \n          when N_Op_Multiply =>\n             Sprint_Left_Opnd (Node);\n             Write_Char (' ');\n-            Process_TFAI_RR_Flags (Node);\n+            if Rounded_Result (Node) then\n+               Write_Char ('@');\n+            end if;\n             Write_Operator (Node, \"* \");\n             Sprint_Right_Opnd (Node);\n \n@@ -2583,11 +2562,6 @@ package body Sprint is\n \n          when N_Op_Rem =>\n             Sprint_Left_Opnd (Node);\n-\n-            if Treat_Fixed_As_Integer (Node) then\n-               Write_Str (\" #\");\n-            end if;\n-\n             Write_Operator (Node, \" rem \");\n             Sprint_Right_Opnd (Node);\n "}, {"sha": "40bbc6357ff1fddb1b35a5ca4b5bdfc8b7661423", "filename": "gcc/ada/sprint.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa54f4da74b48a088fb1cef7b7f593d02319d019/gcc%2Fada%2Fsprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.ads?ref=fa54f4da74b48a088fb1cef7b7f593d02319d019", "patch": "@@ -51,7 +51,6 @@ package Sprint is\n    --    Convert wi Conversion_OK            target?(source)\n    --    Convert wi Float_Truncate           target^(source)\n    --    Convert wi Rounded_Result           target@(source)\n-   --    Divide wi Treat_Fixed_As_Integer    x #/ y\n    --    Divide wi Rounded_Result            x @/ y\n    --    Expression with actions             do action; .. action; in expr end\n    --    Expression with range check         {expression}\n@@ -66,9 +65,7 @@ package Sprint is\n    --    Itype declaration                   [(sub)type declaration without ;]\n    --    Itype reference                     reference itype\n    --    Label declaration                   labelname : label\n-   --    Mod wi Treat_Fixed_As_Integer       x #mod y\n    --    Multiple concatenation              expr && expr && expr ... && expr\n-   --    Multiply wi Treat_Fixed_As_Integer  x #* y\n    --    Multiply wi Rounded_Result          x @* y\n    --    Operator with overflow check        {operator} (e.g. {+})\n    --    Others choice for cleanup           when all others\n@@ -77,7 +74,6 @@ package Sprint is\n    --    Raise xxx error                     [xxx_error [when cond]]\n    --    Raise xxx error with msg            [xxx_error [when cond], \"msg\"]\n    --    Rational literal                    [expression]\n-   --    Rem wi Treat_Fixed_As_Integer       x #rem y\n    --    Reference                           expression'reference\n    --    Shift nodes                         shift_name!(expr, count)\n    --    Static declaration                  name : static xxx"}]}