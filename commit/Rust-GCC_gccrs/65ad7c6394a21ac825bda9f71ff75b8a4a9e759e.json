{"sha": "65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhZDdjNjM5NGEyMWFjODI1YmRhOWY3MWZmNzViOGE0YTllNzU5ZQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-03-03T18:15:58Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-03-03T18:15:58Z"}, "message": "tree-ssa-operands.c: Tidy whitespace.\n\n\n\t* tree-ssa-operands.c: Tidy whitespace.  Fix spelling.\n\t(correct_use_link): Remove reference to get_stmt_operands.\n\t(update_stmt_operands): Likewise.\n\t(get_modify_expr_operands): New function factored out of\n\tparse_ssa_operands and get_expr_operands.\n\tTry to create V_MUST_DEFs for LHS by default.\n\t(get_expr_operands) <case MODIFY_EXPR>: Call\n\tget_modify_expr_operands.\n\t<case ARRAY_RANGE_REF>: Handle together with ARRAY_REF.\n\t<case BIT_FIELD_REF>: Clear opf_kill_def from FLAGS.\n\t(parse_ssa_operands) <case MODIFY_EXPR>: Call\n\tget_modify_expr_operands.\n\nFrom-SVN: r111682", "tree": {"sha": "16f3f8d1de82d7a17cfb7a4318705370a27a5360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16f3f8d1de82d7a17cfb7a4318705370a27a5360"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e/comments", "author": null, "committer": null, "parents": [{"sha": "e3860a7d0d01e98cb28b892e31adc940369fbc87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3860a7d0d01e98cb28b892e31adc940369fbc87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3860a7d0d01e98cb28b892e31adc940369fbc87"}], "stats": {"total": 286, "additions": 141, "deletions": 145}, "files": [{"sha": "aa9bfbf6c44d13e114413e8eb20bc61a31a76adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "patch": "@@ -1,3 +1,18 @@\n+2006-03-03  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa-operands.c: Tidy whitespace.  Fix spelling.\n+\t(correct_use_link): Remove reference to get_stmt_operands.\n+\t(update_stmt_operands): Likewise.\n+\t(get_modify_expr_operands): New function factored out of\n+\tparse_ssa_operands and get_expr_operands.\n+\tTry to create V_MUST_DEFs for LHS by default.\n+\t(get_expr_operands) <case MODIFY_EXPR>: Call\n+\tget_modify_expr_operands.\n+\t<case ARRAY_RANGE_REF>: Handle together with ARRAY_REF.\n+\t<case BIT_FIELD_REF>: Clear opf_kill_def from FLAGS.\n+\t(parse_ssa_operands) <case MODIFY_EXPR>: Call\n+\tget_modify_expr_operands.\n+\n 2006-03-03  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-dfa.c (referenced_var_lookup_if_exists): Remove."}, {"sha": "7bf6ff3e5fa475e25b161e71b9fdca7e8906381c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 126, "deletions": 145, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65ad7c6394a21ac825bda9f71ff75b8a4a9e759e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=65ad7c6394a21ac825bda9f71ff75b8a4a9e759e", "patch": "@@ -82,7 +82,7 @@ Boston, MA 02110-1301, USA.  */\n #define opf_none\t0\n \n /* Operand is the target of an assignment expression or a \n-   call-clobbered variable  */\n+   call-clobbered variable.  */\n #define opf_is_def \t(1 << 0)\n \n /* Operand is the target of an assignment expression.  */\n@@ -96,8 +96,9 @@ Boston, MA 02110-1301, USA.  */\n    VUSE for 'b'.  */\n #define opf_no_vops \t(1 << 2)\n \n-/* Operand is a \"non-specific\" kill for call-clobbers and such.  This is used\n-   to distinguish \"reset the world\" events from explicit MODIFY_EXPRs.  */\n+/* Operand is a \"non-specific\" kill for call-clobbers and such.  This\n+   is used to distinguish \"reset the world\" events from explicit\n+   MODIFY_EXPRs.  */\n #define opf_non_specific  (1 << 3)\n \n /* Array for building all the def operands.  */\n@@ -106,13 +107,13 @@ static VEC(tree,heap) *build_defs;\n /* Array for building all the use operands.  */\n static VEC(tree,heap) *build_uses;\n \n-/* Array for building all the v_may_def operands.  */\n+/* Array for building all the V_MAY_DEF operands.  */\n static VEC(tree,heap) *build_v_may_defs;\n \n-/* Array for building all the vuse operands.  */\n+/* Array for building all the VUSE operands.  */\n static VEC(tree,heap) *build_vuses;\n \n-/* Array for building all the v_must_def operands.  */\n+/* Array for building all the V_MUST_DEF operands.  */\n static VEC(tree,heap) *build_v_must_defs;\n \n /* These arrays are the cached operand vectors for call clobbered calls.  */\n@@ -168,8 +169,10 @@ static inline void\n operand_build_sort_virtual (VEC(tree,heap) *list)\n {\n   int num = VEC_length (tree, list);\n+\n   if (num < 2)\n     return;\n+\n   if (num == 2)\n     {\n       if (get_name_decl (VEC_index (tree, list, 0)) \n@@ -182,6 +185,7 @@ operand_build_sort_virtual (VEC(tree,heap) *list)\n \t}\n       return;\n     }\n+\n   /* There are 3 or more elements, call qsort.  */\n   qsort (VEC_address (tree, list), \n \t VEC_length (tree, list), \n@@ -190,7 +194,7 @@ operand_build_sort_virtual (VEC(tree,heap) *list)\n }\n \n \n-/*  Return true if the ssa operands cache is active.  */\n+/*  Return true if the SSA operands cache is active.  */\n \n bool\n ssa_operands_active (void)\n@@ -208,23 +212,22 @@ static struct\n      add_call_clobber_ops.  */\n   unsigned int clobbered_vars;\n \n-  /* Number of write-clobbers (v_may_defs) avoided by using\n+  /* Number of write-clobbers (V_MAY_DEFs) avoided by using\n      not_written information.  */\n   unsigned int static_write_clobbers_avoided;\n \n-  /* Number of reads (vuses) avoided by using not_read\n-     information.  */\n+  /* Number of reads (VUSEs) avoided by using not_read information.  */\n   unsigned int static_read_clobbers_avoided;\n   \n   /* Number of write-clobbers avoided because the variable can't escape to\n      this call.  */\n   unsigned int unescapable_clobbers_avoided;\n \n-  /* Number of readonly uses we attempt to add to calls in\n+  /* Number of read-only uses we attempt to add to calls in\n      add_call_read_ops.  */\n   unsigned int readonly_clobbers;\n \n-  /* Number of readonly uses we avoid using not_read information.  */\n+  /* Number of read-only uses we avoid using not_read information.  */\n   unsigned int static_readonly_clobbers_avoided;\n } clobber_stats;\n   \n@@ -244,7 +247,6 @@ init_ssa_operands (void)\n   operand_memory_index = SSA_OPERAND_MEMORY_SIZE;\n   ops_active = true;\n   memset (&clobber_stats, 0, sizeof (clobber_stats));\n-  \n }\n \n \n@@ -282,9 +284,9 @@ fini_ssa_operands (void)\n \t       clobber_stats.static_read_clobbers_avoided);\n       fprintf (dump_file, \"Unescapable clobbers avoided:%d\\n\",\n \t       clobber_stats.unescapable_clobbers_avoided);\n-      fprintf (dump_file, \"Original readonly clobbers:%d\\n\",\n+      fprintf (dump_file, \"Original read-only clobbers:%d\\n\",\n \t       clobber_stats.readonly_clobbers);\n-      fprintf (dump_file, \"Static readonly clobbers avoided:%d\\n\",\n+      fprintf (dump_file, \"Static read-only clobbers avoided:%d\\n\",\n \t       clobber_stats.static_readonly_clobbers_avoided);\n     }\n }\n@@ -324,7 +326,7 @@ correct_use_link (use_operand_p ptr, tree stmt)\n   use_operand_p prev;\n   tree root;\n \n-  /*  Fold_stmt () may have changed the stmt pointers.  */\n+  /*  fold_stmt may have changed the stmt pointers.  */\n   if (ptr->stmt != stmt)\n     ptr->stmt = stmt;\n \n@@ -335,8 +337,9 @@ correct_use_link (use_operand_p ptr, tree stmt)\n       while (prev->use != NULL || prev->stmt == NULL)\n \tprev = prev->prev;\n \n-      /* Get the ssa_name of the list the node is in.  */\n+      /* Get the SSA_NAME of the list the node is in.  */\n       root = prev->stmt;\n+\n       /* If it's the right list, simply return.  */\n       if (root == *(ptr->use))\n \treturn;\n@@ -356,7 +359,7 @@ correct_use_link (use_operand_p ptr, tree stmt)\n static inline void\n set_virtual_use_link (use_operand_p ptr, tree stmt)\n {\n-  /*  Fold_stmt () may have changed the stmt pointers.  */\n+  /*  fold_stmt may have changed the stmt pointers.  */\n   if (ptr->stmt != stmt)\n     ptr->stmt = stmt;\n \n@@ -434,7 +437,7 @@ finalize_ssa_uses (tree stmt)\n \n     /* If the pointer to the operand is the statement itself, something is\n        wrong.  It means that we are pointing to a local variable (the \n-       initial call to get_stmt_operands does not pass a pointer to a \n+       initial call to update_stmt_operands does not pass a pointer to a \n        statement).  */\n     for (x = 0; x < num; x++)\n       gcc_assert (*((tree *)VEC_index (tree, build_uses, x)) != stmt);\n@@ -445,7 +448,7 @@ finalize_ssa_uses (tree stmt)\n }\n                                                                               \n                                                                               \n-/* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */                                                                                \n+/* Return a new V_MAY_DEF operand vector for STMT, comparing to OLD_OPS_P.  */                                                                                \n #define FINALIZE_OPBUILD\tbuild_v_may_defs\n #define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_may_defs, (I))\n #define FINALIZE_OPBUILD_BASE(I)\tget_name_decl (VEC_index (tree,\t\\\n@@ -477,7 +480,7 @@ finalize_ssa_v_may_defs (tree stmt)\n }\n                                                                                \n \n-/* Clear the in_list bits and empty the build array for v_may_defs.  */\n+/* Clear the in_list bits and empty the build array for V_MAY_DEFs.  */\n \n static inline void\n cleanup_v_may_defs (void)\n@@ -521,7 +524,7 @@ cleanup_v_may_defs (void)\n #include \"tree-ssa-opfinalize.h\"\n \n \n-/* Return a new vuse operand vector, comparing to OLD_OPS_P.  */\n+/* Return a new VUSE operand vector, comparing to OLD_OPS_P.  */\n                                                                               \n static void\n finalize_ssa_vuses (tree stmt)\n@@ -530,17 +533,16 @@ finalize_ssa_vuses (tree stmt)\n   unsigned vuse_index;\n \n   /* Remove superfluous VUSE operands.  If the statement already has a\n-   V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is not\n-   needed because V_MAY_DEFs imply a VUSE of the variable.  For instance,\n-   suppose that variable 'a' is aliased:\n+     V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is\n+     not needed because V_MAY_DEFs imply a VUSE of the variable.  For\n+     instance, suppose that variable 'a' is aliased:\n \n \t      # VUSE <a_2>\n \t      # a_3 = V_MAY_DEF <a_2>\n \t      a = a + 1;\n \n-  The VUSE <a_2> is superfluous because it is implied by the V_MAY_DEF\n-  operation.  */\n-\n+     The VUSE <a_2> is superfluous because it is implied by the\n+     V_MAY_DEF operation.  */\n   num = VEC_length (tree, build_vuses);\n   num_v_may_defs = VEC_length (tree, build_v_may_defs);\n \n@@ -564,29 +566,32 @@ finalize_ssa_vuses (tree stmt)\n \t}\n     }\n   else\n-    /* Clear out the in_list bits.  */\n-    for (vuse_index = 0;\n-\t vuse_index < VEC_length (tree, build_vuses);\n-\t vuse_index++)\n-      {\n-\ttree t = VEC_index (tree, build_vuses, vuse_index);\n-\tif (TREE_CODE (t) != SSA_NAME)\n-\t  {\n-\t    var_ann_t ann = var_ann (t);\n-\t    ann->in_vuse_list = 0;\n-\t  }\n-      }\n+    {\n+      /* Clear out the in_list bits.  */\n+      for (vuse_index = 0;\n+\t  vuse_index < VEC_length (tree, build_vuses);\n+\t  vuse_index++)\n+\t{\n+\t  tree t = VEC_index (tree, build_vuses, vuse_index);\n+\t  if (TREE_CODE (t) != SSA_NAME)\n+\t    {\n+\t      var_ann_t ann = var_ann (t);\n+\t      ann->in_vuse_list = 0;\n+\t    }\n+\t}\n+    }\n \n   finalize_ssa_vuse_ops (stmt);\n-  /* The v_may_def build vector wasn't cleaned up because we needed it.  */\n+\n+  /* The V_MAY_DEF build vector wasn't cleaned up because we needed it.  */\n   cleanup_v_may_defs ();\n                                                                               \n-  /* Free the vuses build vector.  */\n+  /* Free the VUSEs build vector.  */\n   VEC_truncate (tree, build_vuses, 0);\n \n }\n                                                                               \n-/* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n+/* Return a new V_MUST_DEF operand vector for STMT, comparing to OLD_OPS_P.  */\n                                                                               \n #define FINALIZE_OPBUILD\tbuild_v_must_defs\n #define FINALIZE_OPBUILD_ELEM(I)\tVEC_index (tree, build_v_must_defs, (I))\n@@ -615,11 +620,12 @@ finalize_ssa_vuses (tree stmt)\n static void\n finalize_ssa_v_must_defs (tree stmt)\n {\n-  /* In the presence of subvars, there may be more than one V_MUST_DEF per\n-     statement (one for each subvar).  It is a bit expensive to verify that\n-     all must-defs in a statement belong to subvars if there is more than one\n-     MUST-def, so we don't do it.  Suffice to say, if you reach here without\n-     having subvars, and have num >1, you have hit a bug. */\n+  /* In the presence of subvars, there may be more than one V_MUST_DEF\n+     per statement (one for each subvar).  It is a bit expensive to\n+     verify that all must-defs in a statement belong to subvars if\n+     there is more than one must-def, so we don't do it.  Suffice to\n+     say, if you reach here without having subvars, and have num >1,\n+     you have hit a bug.  */\n   finalize_ssa_v_must_def_ops (stmt);\n   VEC_truncate (tree, build_v_must_defs, 0);\n }\n@@ -693,7 +699,6 @@ append_v_may_def (tree var)\n static inline void\n append_vuse (tree var)\n {\n-\n   /* Don't allow duplicate entries.  */\n   if (TREE_CODE (var) != SSA_NAME)\n     {\n@@ -958,7 +963,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t     aliases will link up properly with calls.   In order to\n \t     keep the number of these bare defs we add down to the\n \t     minimum necessary, we keep track of which SMT's were used\n-\t     alone in statement vdefs or vuses.  */\n+\t     alone in statement vdefs or VUSEs.  */\n \t  if (v_ann->is_aliased\n \t      || none_added\n \t      || (TREE_CODE (var) == SYMBOL_MEMORY_TAG\n@@ -1266,10 +1271,8 @@ add_call_clobber_ops (tree stmt, tree callee)\n \t    clobber_stats.static_read_clobbers_avoided++;\n \t}\n       else\n-\tadd_virtual_operand (var, s_ann, opf_is_def, \n-\t\t\t     NULL, 0, -1, true);\n+\tadd_virtual_operand (var, s_ann, opf_is_def, NULL, 0, -1, true);\n     }\n-  \n }\n \n \n@@ -1310,8 +1313,8 @@ add_call_read_ops (tree stmt, tree callee)\n       if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n \treal_var = SFT_PARENT_VAR (var);\n \n-      not_read = not_read_b ? bitmap_bit_p (not_read_b, \n-\t\t\t\t\t    DECL_UID (real_var)) : false;\n+      not_read = not_read_b ? bitmap_bit_p (not_read_b, DECL_UID (real_var))\n+\t                    : false;\n       \n       if (not_read)\n \t{\n@@ -1382,10 +1385,10 @@ get_asm_expr_operands (tree stmt)\n \n   for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n     {\n-      oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n-      parse_output_constraint (&constraint, i, 0, 0,\n-\t  &allows_mem, &allows_reg, &is_inout);\n+      constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+      oconstraints[i] = constraint;\n+      parse_output_constraint (&constraint, i, 0, 0, &allows_mem,\n+\t                       &allows_reg, &is_inout);\n \n       /* This should have been split in gimplify_asm_expr.  */\n       gcc_assert (!allows_reg || !is_inout);\n@@ -1462,9 +1465,34 @@ get_asm_expr_operands (tree stmt)\n }\n \n \n+/* Scan operands for the assignment expression EXPR in statement STMT.  */\n+\n+static void\n+get_modify_expr_operands (tree stmt, tree expr)\n+{\n+  /* First get operands from the RHS.  */\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n+\n+  /* For the LHS, use a regular definition (OPF_IS_DEF) for GIMPLE\n+     registers.  If the LHS is a store to memory, we will either need\n+     a preserving definition (V_MAY_DEF) or a killing definition\n+     (V_MUST_DEF).\n+\n+     Preserving definitions are those that modify a part of an\n+     aggregate object for which no subvars have been computed (or the\n+     reference does not correspond exactly to one of them). Stores\n+     through a pointer are also represented with V_MAY_DEF operators.\n+\n+     The determination of whether to use a preserving or a killing\n+     definition is done while scanning the LHS of the assignment.  By\n+     default, assume that we will emit a V_MUST_DEF.  */\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_is_def|opf_kill_def);\n+}\n+\n+\n /* Recursively scan the expression pointed to by EXPR_P in statement\n-   referred to by INFO.  FLAGS is one of the OPF_* constants modifying\n-   how to interpret the operands found.  */\n+   STMT.  FLAGS is one of the OPF_* constants modifying how to\n+   interpret the operands found.  */\n \n static void\n get_expr_operands (tree stmt, tree *expr_p, int flags)\n@@ -1516,7 +1544,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       {\n \tsubvar_t svars;\n \t\n-\t/* Add the subvars for a variable if it has subvars, to DEFS\n+\t/* Add the subvars for a variable, if it has subvars, to DEFS\n \t   or USES.  Otherwise, add the variable itself.  Whether it\n \t   goes to USES or DEFS depends on the operand flags.  */\n \tif (var_can_have_subvars (expr)\n@@ -1538,25 +1566,15 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \n     case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n-      get_indirect_ref_operands (stmt, expr, flags, NULL_TREE,\n-\t\t\t\t 0, -1, true);\n+      get_indirect_ref_operands (stmt, expr, flags, NULL_TREE, 0, -1, true);\n       return;\n \n     case TARGET_MEM_REF:\n       get_tmr_operands (stmt, expr, flags);\n       return;\n \n-    case ARRAY_RANGE_REF:\n-      /* Treat array references as references to the virtual variable\n-\t representing the array.  The virtual variable for an ARRAY_REF\n-\t is the VAR_DECL for the array.  */\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none);\n-      return;\n-\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -1596,14 +1614,14 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t  }\n \telse if (TREE_CODE (ref) == INDIRECT_REF)\n \t  {\n-\t    get_indirect_ref_operands (stmt, ref, flags, expr, \n-\t\t\t\t       offset, maxsize, false);\n+\t    get_indirect_ref_operands (stmt, ref, flags, expr, offset,\n+\t\t                       maxsize, false);\n \t    flags |= opf_no_vops;\n \t  }\n \n \t/* Even if we found subvars above we need to ensure to see\n \t   immediate uses for d in s.a[d].  In case of s.a having\n-\t   a subvar we'd miss it otherwise.  */\n+\t   a subvar or we would miss it otherwise.  */\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0),\n \t\t\t   flags & ~opf_kill_def);\n \t\n@@ -1613,7 +1631,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t      s_ann->has_volatile_ops = true; \n \t    get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n \t  }\n-\telse if (code == ARRAY_REF)\n+\telse if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t  {\n             get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n             get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n@@ -1642,25 +1660,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       return;\n \n     case MODIFY_EXPR:\n-      {\n-\tint subflags;\n-\ttree op;\n-\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n-\n-\top = TREE_OPERAND (expr, 0);\n-\tif (TREE_CODE (op) == WITH_SIZE_EXPR)\n-\t  op = TREE_OPERAND (expr, 0);\n-\tif (TREE_CODE (op) == ARRAY_RANGE_REF\n-\t    || TREE_CODE (op) == REALPART_EXPR\n-\t    || TREE_CODE (op) == IMAGPART_EXPR)\n-\t  subflags = opf_is_def;\n-\telse\n-\t  subflags = opf_is_def | opf_kill_def;\n-\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), subflags);\n-\treturn;\n-      }\n+      get_modify_expr_operands (stmt, expr);\n+      return;\n \n     case CONSTRUCTOR:\n       {\n@@ -1677,8 +1678,13 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \treturn;\n       }\n \n-    case TRUTH_NOT_EXPR:\n     case BIT_FIELD_REF:\n+      /* Stores using BIT_FIELD_REF are always preserving definitions.  */\n+      flags &= ~opf_kill_def;\n+\n+      /* Fallthru  */\n+\n+    case TRUTH_NOT_EXPR:\n     case VIEW_CONVERT_EXPR:\n     do_unary:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n@@ -1742,10 +1748,9 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n }\n \n \n-/* Parse STMT looking for operands.  OLD_OPS is the original stmt operand\n-   cache for STMT, if it existed before.  When finished, the various build_*\n-   operand vectors will have potential operands. in them.  */\n-                                                                                \n+/* Parse STMT looking for operands.  When finished, the various\n+   build_* operand vectors will have potential operands in them.  */\n+\n static void\n parse_ssa_operands (tree stmt)\n {\n@@ -1755,30 +1760,7 @@ parse_ssa_operands (tree stmt)\n   switch (code)\n     {\n     case MODIFY_EXPR:\n-      /* First get operands from the RHS.  For the LHS, we use a V_MAY_DEF if\n-\t either only part of LHS is modified or if the RHS might throw,\n-\t otherwise, use V_MUST_DEF.\n-\n-\t ??? If it might throw, we should represent somehow that it is killed\n-\t on the fallthrough path.  */\n-      {\n-\ttree lhs = TREE_OPERAND (stmt, 0);\n-\tint lhs_flags = opf_is_def;\n-\n-\tget_expr_operands (stmt, &TREE_OPERAND (stmt, 1), opf_none);\n-\n-\t/* If the LHS is a VIEW_CONVERT_EXPR, it isn't changing whether\n-\t   or not the entire LHS is modified; that depends on what's\n-\t   inside the VIEW_CONVERT_EXPR.  */\n-\tif (TREE_CODE (lhs) == VIEW_CONVERT_EXPR)\n-\t  lhs = TREE_OPERAND (lhs, 0);\n-\n-\tif (TREE_CODE (lhs) != ARRAY_RANGE_REF\n-\t    && TREE_CODE (lhs) != BIT_FIELD_REF)\n-\t  lhs_flags |= opf_kill_def;\n-\n-        get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), lhs_flags);\n-      }\n+      get_modify_expr_operands (stmt, stmt);\n       break;\n \n     case COND_EXPR:\n@@ -1805,22 +1787,22 @@ parse_ssa_operands (tree stmt)\n       get_expr_operands (stmt, &LABEL_EXPR_LABEL (stmt), opf_none);\n       break;\n \n-      /* These nodes contain no variable references.  */\n     case BIND_EXPR:\n     case CASE_LABEL_EXPR:\n     case TRY_CATCH_EXPR:\n     case TRY_FINALLY_EXPR:\n     case EH_FILTER_EXPR:\n     case CATCH_EXPR:\n     case RESX_EXPR:\n+      /* These nodes contain no variable references.  */\n       break;\n \n     default:\n-      /* Notice that if get_expr_operands tries to use &STMT as the operand\n-\t pointer (which may only happen for USE operands), we will fail in\n-\t append_use.  This default will handle statements like empty\n-\t statements, or CALL_EXPRs that may appear on the RHS of a statement\n-\t or as statements themselves.  */\n+      /* Notice that if get_expr_operands tries to use &STMT as the\n+\t operand pointer (which may only happen for USE operands), we\n+\t will fail in add_stmt_operand.  This default will handle\n+\t statements like empty statements, or CALL_EXPRs that may\n+\t appear on the RHS of a statement or as statements themselves.  */\n       get_expr_operands (stmt, &stmt, opf_none);\n       break;\n     }\n@@ -1850,6 +1832,7 @@ build_ssa_operands (tree stmt)\n \n \n /* Free any operands vectors in OPS.  */\n+\n void \n free_ssa_operands (stmt_operands_p ops)\n {\n@@ -1868,8 +1851,8 @@ update_stmt_operands (tree stmt)\n {\n   stmt_ann_t ann = get_stmt_ann (stmt);\n \n-  /* If get_stmt_operands is called before SSA is initialized, dont\n-  do anything.  */\n+  /* If update_stmt_operands is called before SSA is initialized, do\n+     nothing.  */\n   if (!ssa_operands_active ())\n     return;\n \n@@ -1883,15 +1866,13 @@ update_stmt_operands (tree stmt)\n \n   build_ssa_operands (stmt);\n \n-  /* Clear the modified bit for STMT.  Subsequent calls to\n-     get_stmt_operands for this statement will do nothing until the\n-     statement is marked modified by a call to mark_stmt_modified().  */\n+  /* Clear the modified bit for STMT.  */\n   ann->modified = 0;\n \n   timevar_pop (TV_TREE_OPS);\n }\n \n-  \n+\n /* Copies virtual operands from SRC to DST.  */\n \n void\n@@ -1923,8 +1904,6 @@ copy_virtual_operands (tree dest, tree src)\n   finalize_ssa_vuses (dest);\n \n   /* Finally, set the field to the same values as then originals.  */\n-\n-  \n   t = op_iter_init_tree (&old_iter, src, SSA_OP_VUSE);\n   FOR_EACH_SSA_USE_OPERAND (use_p, dest, iter, SSA_OP_VUSE)\n     {\n@@ -1974,7 +1953,7 @@ create_ssa_artficial_load_stmt (tree new_stmt, tree old_stmt)\n \n   ann = get_stmt_ann (new_stmt);\n \n-  /* process the stmt looking for operands.  */\n+  /* Process the stmt looking for operands.  */\n   start_ssa_stmt_operands ();\n   parse_ssa_operands (new_stmt);\n \n@@ -2029,8 +2008,9 @@ swap_tree_operands (tree stmt, tree *exp0, tree *exp1)\n   op0 = *exp0;\n   op1 = *exp1;\n \n-  /* If the operand cache is active, attempt to preserve the relative positions\n-     of these two operands in their respective immediate use lists.  */\n+  /* If the operand cache is active, attempt to preserve the relative\n+     positions of these two operands in their respective immediate use\n+     lists.  */\n   if (ssa_operands_active () && op0 != op1)\n     {\n       use_optype_p use0, use1, ptr;\n@@ -2052,7 +2032,7 @@ swap_tree_operands (tree stmt, tree *exp0, tree *exp1)\n \t  }\n \n       /* If both uses don't have operand entries, there isn't much we can do\n-         at this point.  Presumably we dont need to worry about it.  */\n+         at this point.  Presumably we don't need to worry about it.  */\n       if (use0 && use1)\n         {\n \t  tree *tmp = USE_OP_PTR (use1)->use;\n@@ -2113,7 +2093,7 @@ add_to_addressable_set (tree ref, bitmap *addresses_taken)\n \n \n /* Scan the immediate_use list for VAR making sure its linked properly.\n-   return RTUE iof there is a problem.  */\n+   Return TRUE if there is a problem and emit an error message to F.  */\n \n bool\n verify_imm_links (FILE *f, tree var)\n@@ -2242,6 +2222,7 @@ debug_immediate_uses (void)\n   dump_immediate_uses (stderr);\n }\n \n+\n /* Dump def-use edges on stderr.  */\n \n void"}]}