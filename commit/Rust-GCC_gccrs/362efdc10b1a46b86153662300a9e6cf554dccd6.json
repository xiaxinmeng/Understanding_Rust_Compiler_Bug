{"sha": "362efdc10b1a46b86153662300a9e6cf554dccd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYyZWZkYzEwYjFhNDZiODYxNTM2NjIzMDBhOWU2Y2Y1NTRkY2NkNg==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T15:07:48Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T15:07:48Z"}, "message": "init.c: removes use of PARAMS macro.\n\n\t2003-05-19  Jens-Michael Hoffmann  <jensmh@gmx.de>\n\t* init.c: removes use of PARAMS macro.  Use ISO style function\n\tdeclarations.  (Not copyright-significant change.)\n\nFrom-SVN: r67902", "tree": {"sha": "4246f6f686b6bb9779fe6dfacd676647c603025c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4246f6f686b6bb9779fe6dfacd676647c603025c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/362efdc10b1a46b86153662300a9e6cf554dccd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362efdc10b1a46b86153662300a9e6cf554dccd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362efdc10b1a46b86153662300a9e6cf554dccd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362efdc10b1a46b86153662300a9e6cf554dccd6/comments", "author": null, "committer": null, "parents": [{"sha": "dc125bdfd98a3efeabcd48f1de28bba1b4f36fca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc125bdfd98a3efeabcd48f1de28bba1b4f36fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc125bdfd98a3efeabcd48f1de28bba1b4f36fca"}], "stats": {"total": 181, "additions": 59, "deletions": 122}, "files": [{"sha": "93459930a85f9037657b4315315fe8d594014698", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362efdc10b1a46b86153662300a9e6cf554dccd6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362efdc10b1a46b86153662300a9e6cf554dccd6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=362efdc10b1a46b86153662300a9e6cf554dccd6", "patch": "@@ -1,5 +1,9 @@\n 2003-06-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n+\t2003-05-19  Jens-Michael Hoffmann  <jensmh@gmx.de>\n+\t* init.c: removes use of PARAMS macro.  Use ISO style function\n+\tdeclarations.  (Not copyright-significant change.)\n+\n \t* rtti.c: Remove PARAMS.\n \n \t* typeck2.c: Convert to ISO C."}, {"sha": "59395eed1d0c07dae0d61a93ba01e9bebcb25d59", "filename": "gcc/cp/init.c", "status": "modified", "additions": 55, "deletions": 122, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362efdc10b1a46b86153662300a9e6cf554dccd6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362efdc10b1a46b86153662300a9e6cf554dccd6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=362efdc10b1a46b86153662300a9e6cf554dccd6", "patch": "@@ -36,24 +36,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n \n static void construct_virtual_base (tree, tree);\n-static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));\n-static void expand_default_init PARAMS ((tree, tree, tree, tree, int));\n-static tree build_vec_delete_1 PARAMS ((tree, tree, tree, special_function_kind, int));\n+static void expand_aggr_init_1 (tree, tree, tree, tree, int);\n+static void expand_default_init (tree, tree, tree, tree, int);\n+static tree build_vec_delete_1 (tree, tree, tree, special_function_kind, int);\n static void perform_member_init (tree, tree);\n-static tree build_builtin_delete_call PARAMS ((tree));\n-static int member_init_ok_or_else PARAMS ((tree, tree, tree));\n-static void expand_virtual_init PARAMS ((tree, tree));\n+static tree build_builtin_delete_call (tree);\n+static int member_init_ok_or_else (tree, tree, tree);\n+static void expand_virtual_init (tree, tree);\n static tree sort_mem_initializers (tree, tree);\n-static tree initializing_context PARAMS ((tree));\n-static void expand_cleanup_for_base PARAMS ((tree, tree));\n-static tree get_temp_regvar PARAMS ((tree, tree));\n-static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n-static tree build_default_init PARAMS ((tree, tree));\n-static tree build_new_1\tPARAMS ((tree));\n-static tree get_cookie_size PARAMS ((tree));\n-static tree build_dtor_call PARAMS ((tree, special_function_kind, int));\n-static tree build_field_list PARAMS ((tree, tree, int *));\n-static tree build_vtbl_address PARAMS ((tree));\n+static tree initializing_context (tree);\n+static void expand_cleanup_for_base (tree, tree);\n+static tree get_temp_regvar (tree, tree);\n+static tree dfs_initialize_vtbl_ptrs (tree, void *);\n+static tree build_default_init (tree, tree);\n+static tree build_new_1\t(tree);\n+static tree get_cookie_size (tree);\n+static tree build_dtor_call (tree, special_function_kind, int);\n+static tree build_field_list (tree, tree, int *);\n+static tree build_vtbl_address (tree);\n \n /* We are about to generate some complex initialization code.\n    Conceptually, it is all a single expression.  However, we may want\n@@ -65,9 +65,7 @@ static tree build_vtbl_address PARAMS ((tree));\n    complete.  */\n \n void\n-begin_init_stmts (stmt_expr_p, compound_stmt_p)\n-     tree *stmt_expr_p;\n-     tree *compound_stmt_p;\n+begin_init_stmts (tree *stmt_expr_p, tree *compound_stmt_p)\n {\n   if (building_stmt_tree ())\n     *stmt_expr_p = begin_stmt_expr ();\n@@ -82,10 +80,7 @@ begin_init_stmts (stmt_expr_p, compound_stmt_p)\n    begin_init_stmts.  Returns the statement-expression itself.  */\n \n tree\n-finish_init_stmts (stmt_expr, compound_stmt)\n-     tree stmt_expr;\n-     tree compound_stmt;\n-\n+finish_init_stmts (tree stmt_expr, tree compound_stmt)\n {  \n   if (building_stmt_tree ())\n     finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n@@ -113,9 +108,7 @@ finish_init_stmts (stmt_expr, compound_stmt)\n    TREE_LIST whose TREE_VALUE is the this ptr expression.  */\n \n static tree\n-dfs_initialize_vtbl_ptrs (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n {\n   if ((!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n@@ -136,8 +129,7 @@ dfs_initialize_vtbl_ptrs (binfo, data)\n    ADDR.  */\n \n void\n-initialize_vtbl_ptrs (addr)\n-     tree addr;\n+initialize_vtbl_ptrs (tree addr)\n {\n   tree list;\n   tree type;\n@@ -270,9 +262,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n    constructors to be called.  */\n \n static tree\n-build_default_init (type, nelts)\n-     tree type;\n-     tree nelts;\n+build_default_init (tree type, tree nelts)\n {\n   /* [dcl.init]:\n \n@@ -418,10 +408,7 @@ perform_member_init (tree member, tree init)\n    the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */\n \n static tree \n-build_field_list (t, list, uses_unions_p)\n-     tree t;\n-     tree list;\n-     int *uses_unions_p;\n+build_field_list (tree t, tree list, int *uses_unions_p)\n {\n   tree fields;\n \n@@ -724,8 +711,7 @@ emit_mem_initializers (tree mem_inits)\n    assigned to the vptr) for BINFO.  */\n \n static tree\n-build_vtbl_address (binfo)\n-     tree binfo;\n+build_vtbl_address (tree binfo)\n {\n   tree binfo_for = binfo;\n   tree vtbl;\n@@ -764,8 +750,7 @@ build_vtbl_address (binfo)\n    multiple inheritance, this might mean \"C's A\" if C : A, B.  */\n \n static void\n-expand_virtual_init (binfo, decl)\n-     tree binfo, decl;\n+expand_virtual_init (tree binfo, tree decl)\n {\n   tree vtbl, vtbl_ptr;\n   tree vtt_index;\n@@ -817,9 +802,7 @@ expand_virtual_init (binfo, decl)\n    destroyed.  */\n \n static void\n-expand_cleanup_for_base (binfo, flag)\n-     tree binfo;\n-     tree flag;\n+expand_cleanup_for_base (tree binfo, tree flag)\n {\n   tree expr;\n \n@@ -896,8 +879,7 @@ construct_virtual_base (tree vbase, tree arguments)\n /* Find the context in which this FIELD can be initialized.  */\n \n static tree\n-initializing_context (field)\n-     tree field;\n+initializing_context (tree field)\n {\n   tree t = DECL_CONTEXT (field);\n \n@@ -916,10 +898,7 @@ initializing_context (field)\n    MEMBER_NAME is the name of the member.  */\n \n static int\n-member_init_ok_or_else (field, type, member_name)\n-     tree field;\n-     tree type;\n-     tree member_name;\n+member_init_ok_or_else (tree field, tree type, tree member_name)\n {\n   if (field == error_mark_node)\n     return 0;\n@@ -1068,9 +1047,7 @@ expand_member_init (tree name)\n    perform the initialization, but not both, as it would be ambiguous.  */\n \n tree\n-build_aggr_init (exp, init, flags)\n-     tree exp, init;\n-     int flags;\n+build_aggr_init (tree exp, tree init, int flags)\n {\n   tree stmt_expr;\n   tree compound_stmt;\n@@ -1148,9 +1125,7 @@ build_aggr_init (exp, init, flags)\n /* Like build_aggr_init, but not just for aggregates.  */\n \n tree\n-build_init (decl, init, flags)\n-     tree decl, init;\n-     int flags;\n+build_init (tree decl, tree init, int flags)\n {\n   tree expr;\n \n@@ -1164,11 +1139,7 @@ build_init (decl, init, flags)\n }\n \n static void\n-expand_default_init (binfo, true_exp, exp, init, flags)\n-     tree binfo;\n-     tree true_exp, exp;\n-     tree init;\n-     int flags;\n+expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n {\n   tree type = TREE_TYPE (exp);\n   tree ctor_name;\n@@ -1268,11 +1239,7 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n    its description.  */\n \n static void\n-expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n-     tree binfo;\n-     tree true_exp, exp;\n-     tree init;\n-     int flags;\n+expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n {\n   tree type = TREE_TYPE (exp);\n \n@@ -1306,9 +1273,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n    OR_ELSE is nonzero, give an error message.  */\n \n int\n-is_aggr_type (type, or_else)\n-     tree type;\n-     int or_else;\n+is_aggr_type (tree type, int or_else)\n {\n   if (type == error_mark_node)\n     return 0;\n@@ -1327,9 +1292,7 @@ is_aggr_type (type, or_else)\n /* Like is_aggr_typedef, but returns typedef if successful.  */\n \n tree\n-get_aggr_from_typedef (name, or_else)\n-     tree name;\n-     int or_else;\n+get_aggr_from_typedef (tree name, int or_else)\n {\n   tree type;\n \n@@ -1357,8 +1320,7 @@ get_aggr_from_typedef (name, or_else)\n }\n \n tree\n-get_type_value (name)\n-     tree name;\n+get_type_value (tree name)\n {\n   if (name == error_mark_node)\n     return NULL_TREE;\n@@ -1377,8 +1339,7 @@ get_type_value (name)\n    the appropriate function call.  */\n \n tree\n-build_member_call (type, name, parmlist)\n-     tree type, name, parmlist;\n+build_member_call (tree type, tree name, tree parmlist)\n {\n   tree t;\n   tree method_name;\n@@ -1532,8 +1493,7 @@ build_member_call (type, name, parmlist)\n    @@ This function should be rewritten and placed in search.c.  */\n \n tree\n-build_offset_ref (type, name)\n-     tree type, name;\n+build_offset_ref (tree type, tree name)\n {\n   tree decl, t = error_mark_node;\n   tree member;\n@@ -1722,8 +1682,7 @@ build_offset_ref (type, name)\n    not have its address taken.  */\n \n tree\n-resolve_offset_ref (exp)\n-     tree exp;\n+resolve_offset_ref (tree exp)\n {\n   tree type = TREE_TYPE (exp);\n   tree base = NULL_TREE;\n@@ -1846,8 +1805,7 @@ resolve_offset_ref (exp)\n    constant, then return that value.  */\n \n tree\n-decl_constant_value (decl)\n-     tree decl;\n+decl_constant_value (tree decl)\n {\n   if (TREE_READONLY_DECL_P (decl)\n       && ! TREE_THIS_VOLATILE (decl)\n@@ -1868,8 +1826,7 @@ decl_constant_value (decl)\n /* Call the global __builtin_delete to delete ADDR.  */\n \n static tree\n-build_builtin_delete_call (addr)\n-     tree addr;\n+build_builtin_delete_call (tree addr)\n {\n   mark_used (global_delete_fndecl);\n   return build_call (global_delete_fndecl, build_tree_list (NULL_TREE, addr));\n@@ -1902,10 +1859,7 @@ build_builtin_delete_call (addr)\n    PLACEMENT is the `placement' list for user-defined operator new ().  */\n \n tree\n-build_new (placement, decl, init, use_global_new)\n-     tree placement;\n-     tree decl, init;\n-     int use_global_new;\n+build_new (tree placement, tree decl, tree init, int use_global_new)\n {\n   tree type, rval;\n   tree nelts = NULL_TREE, t;\n@@ -2075,8 +2029,7 @@ build_new (placement, decl, init, use_global_new)\n /* Given a Java class, return a decl for the corresponding java.lang.Class.  */\n \n tree\n-build_java_class_ref (type)\n-     tree type;\n+build_java_class_ref (tree type)\n {\n   tree name = NULL_TREE, class_decl;\n   static tree CL_suffix = NULL_TREE;\n@@ -2125,8 +2078,7 @@ build_java_class_ref (type)\n    known that a cookie is needed.  */\n \n static tree\n-get_cookie_size (type)\n-     tree type;\n+get_cookie_size (tree type)\n {\n   tree cookie_size;\n \n@@ -2149,8 +2101,7 @@ get_cookie_size (type)\n    value is immediately handed to expand_expr.  */\n \n static tree\n-build_new_1 (exp)\n-     tree exp;\n+build_new_1 (tree exp)\n {\n   tree placement, init;\n   tree true_type, size, rval, t;\n@@ -2535,10 +2486,8 @@ build_new_1 (exp)\n }\n \f\n static tree\n-build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n-     tree base, maxindex, type;\n-     special_function_kind auto_delete_vec;\n-     int use_global_delete;\n+build_vec_delete_1 (tree base, tree maxindex, tree type,\n+    special_function_kind auto_delete_vec, int use_global_delete)\n {\n   tree virtual_size;\n   tree ptype = build_pointer_type (type = complete_type (type));\n@@ -2676,8 +2625,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n /* Create an unnamed variable of the indicated TYPE.  */ \n \n tree\n-create_temporary_var (type)\n-     tree type;\n+create_temporary_var (tree type)\n {\n   tree decl;\n  \n@@ -2699,8 +2647,7 @@ create_temporary_var (type)\n    \"outside\" the binding contour of the function).  */\n \n static tree\n-get_temp_regvar (type, init)\n-     tree type, init;\n+get_temp_regvar (tree type, tree init)\n {\n   tree decl;\n \n@@ -2731,9 +2678,7 @@ get_temp_regvar (type, init)\n    but use assignment instead of initialization.  */\n \n tree\n-build_vec_init (base, maxindex, init, from_array)\n-     tree base, init, maxindex;\n-     int from_array;\n+build_vec_init (tree base, tree maxindex, tree init, int from_array)\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n@@ -3024,10 +2969,7 @@ build_vec_init (base, maxindex, init, from_array)\n    This does not call any destructors.  */\n \n tree\n-build_x_delete (addr, which_delete, virtual_size)\n-     tree addr;\n-     int which_delete;\n-     tree virtual_size;\n+build_x_delete (tree addr, int which_delete, tree virtual_size)\n {\n   int use_global_delete = which_delete & 1;\n   int use_vec_delete = !!(which_delete & 2);\n@@ -3041,10 +2983,7 @@ build_x_delete (addr, which_delete, virtual_size)\n    build_delete.  */\n \n static tree\n-build_dtor_call (exp, dtor_kind, flags)\n-     tree exp;\n-     special_function_kind dtor_kind;\n-     int flags;\n+build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n {\n   tree name;\n \n@@ -3079,11 +3018,8 @@ build_dtor_call (exp, dtor_kind, flags)\n    flags.  See cp-tree.h for more info.  */\n \n tree\n-build_delete (type, addr, auto_delete, flags, use_global_delete)\n-     tree type, addr;\n-     special_function_kind auto_delete;\n-     int flags;\n-     int use_global_delete;\n+build_delete (tree type, tree addr, special_function_kind auto_delete,\n+    int flags, int use_global_delete)\n {\n   tree expr;\n \n@@ -3312,8 +3248,7 @@ push_base_cleanups ()\n /* For type TYPE, delete the virtual baseclass objects of DECL.  */\n \n tree\n-build_vbase_delete (type, decl)\n-     tree type, decl;\n+build_vbase_delete (tree type, tree decl)\n {\n   tree vbases = CLASSTYPE_VBASECLASSES (type);\n   tree result = NULL_TREE;\n@@ -3353,10 +3288,8 @@ build_vbase_delete (type, decl)\n    be worth bothering.)  */\n \n tree\n-build_vec_delete (base, maxindex, auto_delete_vec, use_global_delete)\n-     tree base, maxindex;\n-     special_function_kind auto_delete_vec;\n-     int use_global_delete;\n+build_vec_delete (tree base, tree maxindex,\n+    special_function_kind auto_delete_vec, int use_global_delete)\n {\n   tree type;\n   tree rval;"}]}