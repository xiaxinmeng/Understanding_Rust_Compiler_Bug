{"sha": "e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVkNzJjODQwYTIyNmZkYmFiNjU5MTJmOTdkNDJhMWRiZGFmNmVkMg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-19T15:02:46Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-19T15:17:46Z"}, "message": "c++: Fix self-mapping in map_arguments [PR96531, PR97103]\n\nWith r10-8077 we stopped passing the argified current_template_parms to\nnormalize_constraint_expression from finish_nested_requirement, and\ninstead made map_arguments perform a self-mapping of parameters when\nargs is NULL.  But we're currently not handling parameter packs and\nBOUND_TEMPLATE_TEMPLATE_PARMs properly during this self-mapping, which\nleads to ICEs later during satisfaction.\n\nTo properly handle self-mapping of a parameter pack, this patch\nextends template_parm_to_arg to handle TEMPLATE_PARM_P nodes, and\nmakes map_arguments use it.  (This change revealed that the call to\ntemplate_parm_to_arg in convert_generic_types_to_packs was a no-op\nbecause the argument 't' is never a TREE_LIST, so this patch\nadditionally removes this call.)\n\nAs for bound ttps, map_arguments before r10-8077 would map a\nBOUND_TEMPLATE_TEMPLATE_PARM not to itself but to its underlying\nTEMPLATE_TEMPLATE_PARM.  We could restore this behavior in\nmap_arguments, but since a bound ttp is not really a template parameter\nit seems better to make keep_template_parm not give us a bound ttp in\nthe first place.  So this patch makes keep_template_parm return the\nunderlying ttp when it sees a bound ttp.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96531\n\tPR c++/97103\n\t* constraint.cc (map_arguments): Call template_parm_to_arg\n\tin the self-mapping case.\n\t(finish_shorthand_constraint): No need to build a TREE_LIST\n\tbefore calling template_parm_to_arg.\n\t* pt.c (template_parm_to_arg): Rewrite to handle TEMPLATE_PARM_P\n\tnodes as well as DECL_TEMPLATE_PARM_P nodes, and to make the\n\toverlying TREE_LIST node optional.\n\t(keep_template_parm): Don't record a BOUND_TEMPLATE_TEMPLATE_PARM,\n\tinstead record its corresponding TEMPLATE_TEMPLATE_PARM.\n\t(convert_generic_types_to_packs): Don't call\n\ttemplate_parm_to_arg.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96531\n\tPR c++/97103\n\t* g++.dg/cpp2a/concepts-ttp2.C: New test.\n\t* g++.dg/cpp2a/concepts-variadic1.C: New test.", "tree": {"sha": "a1a6f094057cf76e0a7e259f1d01289d0ad36def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1a6f094057cf76e0a7e259f1d01289d0ad36def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/comments", "author": null, "committer": null, "parents": [{"sha": "dea470d09155f2007bdd502c16614128cb6f9348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea470d09155f2007bdd502c16614128cb6f9348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea470d09155f2007bdd502c16614128cb6f9348"}], "stats": {"total": 86, "additions": 68, "deletions": 18}, "files": [{"sha": "d49957a6c4ab96d6eba2b1de25047cd08e45a575", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "patch": "@@ -554,7 +554,7 @@ map_arguments (tree parms, tree args)\n \tTREE_PURPOSE (p) = TMPL_ARG (args, level, index);\n       }\n     else\n-      TREE_PURPOSE (p) = TREE_VALUE (p);\n+      TREE_PURPOSE (p) = template_parm_to_arg (p);\n \n   return parms;\n }\n@@ -1492,7 +1492,7 @@ finish_shorthand_constraint (tree decl, tree constr)\n \n   /* Get the argument and overload used for the requirement\n      and adjust it if we're going to expand later.  */\n-  tree arg = template_parm_to_arg (build_tree_list (NULL_TREE, decl));\n+  tree arg = template_parm_to_arg (decl);\n   if (apply_to_each_p && declared_pack_p)\n     arg = PACK_EXPANSION_PATTERN (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg), 0));\n "}, {"sha": "fe45de8d79626d712b5733730fbf2f26089852f0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "patch": "@@ -4704,29 +4704,37 @@ end_template_decl (void)\n   current_template_parms = TREE_CHAIN (current_template_parms);\n }\n \n-/* Takes a TREE_LIST representing a template parameter and convert it\n-   into an argument suitable to be passed to the type substitution\n-   functions.  Note that If the TREE_LIST contains an error_mark\n-   node, the returned argument is error_mark_node.  */\n+/* Takes a TEMPLATE_PARM_P or DECL_TEMPLATE_PARM_P node or a TREE_LIST\n+   thereof, and converts it into an argument suitable to be passed to\n+   the type substitution functions.  Note that if the TREE_LIST contains\n+   an error_mark node, the returned argument is error_mark_node.  */\n \n tree\n template_parm_to_arg (tree t)\n {\n+  if (!t)\n+    return NULL_TREE;\n \n-  if (t == NULL_TREE\n-      || TREE_CODE (t) != TREE_LIST)\n-    return t;\n+  if (TREE_CODE (t) == TREE_LIST)\n+    t = TREE_VALUE (t);\n \n-  if (error_operand_p (TREE_VALUE (t)))\n+  if (error_operand_p (t))\n     return error_mark_node;\n \n-  t = TREE_VALUE (t);\n-\n-  if (TREE_CODE (t) == TYPE_DECL\n-      || TREE_CODE (t) == TEMPLATE_DECL)\n+  if (DECL_P (t) && DECL_TEMPLATE_PARM_P (t))\n     {\n-      t = TREE_TYPE (t);\n+      if (TREE_CODE (t) == TYPE_DECL\n+\t  || TREE_CODE (t) == TEMPLATE_DECL)\n+\tt = TREE_TYPE (t);\n+      else\n+\tt = DECL_INITIAL (t);\n+    }\n+\n+  gcc_assert (TEMPLATE_PARM_P (t));\n \n+  if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+    {\n       if (TEMPLATE_TYPE_PARAMETER_PACK (t))\n \t{\n \t  /* Turn this argument into a TYPE_ARGUMENT_PACK\n@@ -4743,8 +4751,6 @@ template_parm_to_arg (tree t)\n     }\n   else\n     {\n-      t = DECL_INITIAL (t);\n-\n       if (TEMPLATE_PARM_PARAMETER_PACK (t))\n \t{\n \t  /* Turn this argument into a NONTYPE_ARGUMENT_PACK\n@@ -10539,6 +10545,11 @@ keep_template_parm (tree t, void* data)\n   if (level > ftpi->max_depth)\n     return 0;\n \n+  if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+    /* We want the underlying TEMPLATE_TEMPLATE_PARM, not the\n+       BOUND_TEMPLATE_TEMPLATE_PARM itself.  */\n+    t = TREE_TYPE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t));\n+\n   /* Arguments like const T yield parameters like const T. This means that\n      a template-id like X<T, const T> would yield two distinct parameters:\n      T and const T. Adjust types to their unqualified versions.  */\n@@ -29448,7 +29459,7 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n       if (tree constr = TEMPLATE_PARM_CONSTRAINTS (node))\n \t{\n \t  tree id = unpack_concept_check (constr);\n-\t  TREE_VEC_ELT (TREE_OPERAND (id, 1), 0) = template_parm_to_arg (t);\n+\t  TREE_VEC_ELT (TREE_OPERAND (id, 1), 0) = t;\n \t  tree fold = finish_left_unary_fold_expr (constr, TRUTH_ANDIF_EXPR);\n \t  TEMPLATE_PARM_CONSTRAINTS (node) = fold;\n "}, {"sha": "7f4883754dded36e699628b29340d677ea3a3783", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-ttp2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ttp2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ttp2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ttp2.C?ref=e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/97103\n+// { dg-do compile { target c++20 } }\n+\n+template<typename R, typename Rep>\n+class quantity {};\n+\n+template<template<typename, typename> typename Q>\n+inline constexpr bool valid_template_arguments = requires {\n+  requires requires { typename Q<int, int>; };\n+};\n+static_assert(valid_template_arguments<quantity>);"}, {"sha": "deab028ca3c18be9639a31c8d61105ea18f75cb8", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-variadic1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-variadic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d72c840a226fdbab65912f97d42a1dbdaf6ed2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-variadic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-variadic1.C?ref=e5d72c840a226fdbab65912f97d42a1dbdaf6ed2", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/96531\n+// { dg-do compile { target c++20 } }\n+\n+template<typename T>\n+concept is_bool = __is_same(bool, T);\n+\n+template <typename... Ts>\n+concept C = requires {\n+  requires (is_bool<Ts> || ...);\n+};\n+\n+template <bool... Bs>\n+concept D = requires {\n+  requires (Bs || ...);\n+};\n+\n+template <typename... Ts>\n+requires C<Ts...>\n+void bar() {}\n+\n+template <bool... Bs>\n+requires D<Bs...>\n+void baz() {}\n+\n+int main() {\n+  bar<int, char, bool>();\n+  baz<false, true, false>();\n+}"}]}