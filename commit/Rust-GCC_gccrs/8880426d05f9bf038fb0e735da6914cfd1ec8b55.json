{"sha": "8880426d05f9bf038fb0e735da6914cfd1ec8b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg4MDQyNmQwNWY5YmYwMzhmYjBlNzM1ZGE2OTE0Y2ZkMWVjOGI1NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-20T14:19:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-20T14:19:23Z"}, "message": "[multiple changes]\n\n2014-02-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Usage_Error): Remove local\n\tconstant Typ. Remove the specialized diagnostics for unconstrained\n\tor tagged items as those are not part of the explicit input set\n\tof the related subprogram and should not be flagged.\n\n2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb: Add guard to preserve all errors.\n\n2014-02-20  Vincent Celier  <celier@adacore.com>\n\n\t* switch-m.adb (Normalize_Compiler_Switches): Take into account\n\tswitches that are recorded in ALI files: -gnateA, -gnateE,\n\t-gnateF, -gnateinn, -gnateu, -gnateV and -gnateY.\n\n2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Check legality\n\tof an element iterator form over a formal container with an\n\tIterable aspect.\n\t* exp_ch5.adb (Build_Formal_Container_Iteration): Utility\n\tto create declaration and loop statements for both forms of\n\tcontainer iterators.\n\t(Expand_Formal_Container_Element_Iterator): New procedure\n\tto handle loops of the form  \"for E of C\" when C is a formal\n\tcontainer.\n\t(Expand_Formal_Container_Iterator): Code cleanup.\n\nFrom-SVN: r207953", "tree": {"sha": "acda77da521c803a9d0a1e3b30930e1a5286d31f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acda77da521c803a9d0a1e3b30930e1a5286d31f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8880426d05f9bf038fb0e735da6914cfd1ec8b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8880426d05f9bf038fb0e735da6914cfd1ec8b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8880426d05f9bf038fb0e735da6914cfd1ec8b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8880426d05f9bf038fb0e735da6914cfd1ec8b55/comments", "author": null, "committer": null, "parents": [{"sha": "46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46de64cad15d3673b13bc6d9a9d9f31e84da3ef6"}], "stats": {"total": 394, "additions": 266, "deletions": 128}, "files": [{"sha": "68bd2691710e75d48652cc34ec4b166b968d3582", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -1,3 +1,33 @@\n+2014-02-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Usage_Error): Remove local\n+\tconstant Typ. Remove the specialized diagnostics for unconstrained\n+\tor tagged items as those are not part of the explicit input set\n+\tof the related subprogram and should not be flagged.\n+\n+2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb: Add guard to preserve all errors.\n+\n+2014-02-20  Vincent Celier  <celier@adacore.com>\n+\n+\t* switch-m.adb (Normalize_Compiler_Switches): Take into account\n+\tswitches that are recorded in ALI files: -gnateA, -gnateE,\n+\t-gnateF, -gnateinn, -gnateu, -gnateV and -gnateY.\n+\n+2014-02-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Check legality\n+\tof an element iterator form over a formal container with an\n+\tIterable aspect.\n+\t* exp_ch5.adb (Build_Formal_Container_Iteration): Utility\n+\tto create declaration and loop statements for both forms of\n+\tcontainer iterators.\n+\t(Expand_Formal_Container_Element_Iterator): New procedure\n+\tto handle loops of the form  \"for E of C\" when C is a formal\n+\tcontainer.\n+\t(Expand_Formal_Container_Iterator): Code cleanup.\n+\n 2014-02-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Add_Item_To_Name_Buffer): New routine."}, {"sha": "df1f3f2d38419054c39450341cc64ce389fe4052", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 175, "deletions": 48, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -62,6 +62,16 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch5 is\n \n+   procedure Build_Formal_Container_Iteration\n+     (N         : Node_Id;\n+      Container : Entity_Id;\n+      Cursor    : Entity_Id;\n+      Init      : out Node_Id;\n+      Advance   : out Node_Id;\n+      New_Loop  : out Node_Id);\n+   --  Utility to create declarations and loop statement for both forms\n+   --  of formal container iterators.\n+\n    function Change_Of_Representation (N : Node_Id) return Boolean;\n    --  Determine if the right hand side of assignment N is a type conversion\n    --  which requires a change of representation. Called only for the array\n@@ -103,10 +113,15 @@ package body Exp_Ch5 is\n    --  clause (this last case is required because holes in the tagged type\n    --  might be filled with components from child types).\n \n-   procedure Expand_Formal_Container_Loop (Typ : Entity_Id; N : Node_Id);\n+   procedure Expand_Formal_Container_Loop (N : Node_Id);\n    --  Use the primitives specified in an Iterable aspect to expand a loop\n    --  over a so-called formal container, primarily for SPARK usage.\n \n+   procedure Expand_Formal_Container_Element_Loop (N : Node_Id);\n+   --  Same, for an iterator of the form \" For E of C\". In this case the\n+   --  iterator provides the name of the element, and the cursor is generated\n+   --  internally.\n+\n    procedure Expand_Iterator_Loop (N : Node_Id);\n    --  Expand loop over arrays and containers that uses the form \"for X of C\"\n    --  with an optional subtype mark, or \"for Y in C\".\n@@ -124,6 +139,72 @@ package body Exp_Ch5 is\n    --  are not 'part of the value' and must not be changed upon assignment. N\n    --  is the original Assignment node.\n \n+   --------------------------------------\n+   -- Build_Formal_Container_iteration --\n+   --------------------------------------\n+\n+   procedure Build_Formal_Container_Iteration\n+     (N         : Node_Id;\n+      Container : Entity_Id;\n+      Cursor    : Entity_Id;\n+      Init      : out Node_Id;\n+      Advance   : out Node_Id;\n+      New_Loop  : out Node_Id)\n+   is\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Stats    : constant List_Id    := Statements (N);\n+\n+      Typ      : constant Entity_Id := Base_Type (Etype (Container));\n+      First_Op : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_First);\n+      Next_Op  : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_Next);\n+      Has_Element_Op : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_Has_Element);\n+   begin\n+      --  Declaration for Cursor\n+\n+      Init :=\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Cursor,\n+           Object_Definition => New_Occurrence_Of (Etype (First_Op),  Loc),\n+             Expression =>\n+               Make_Function_Call (Loc,\n+                 Name => New_Occurrence_Of (First_Op, Loc),\n+                   Parameter_Associations =>\n+                     New_List (New_Occurrence_Of (Container, Loc))));\n+\n+      --  Statement that advances cursor in loop\n+\n+      Advance :=\n+        Make_Assignment_Statement (Loc,\n+          Name => New_Occurrence_Of (Cursor, Loc),\n+          Expression =>\n+            Make_Function_Call (Loc,\n+              Name => New_Occurrence_Of (Next_Op, Loc),\n+                Parameter_Associations =>\n+                  New_List\n+                    (New_Occurrence_Of (Container, Loc),\n+                     New_Occurrence_Of (Cursor, Loc))));\n+\n+      --  Iterator is rewritten as a while_loop\n+\n+      New_Loop :=\n+        Make_Loop_Statement (Loc,\n+          Iteration_Scheme =>\n+            Make_Iteration_Scheme (Loc,\n+              Condition =>\n+                Make_Function_Call (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (Has_Element_Op, Loc),\n+                  Parameter_Associations =>\n+                    New_List\n+                     (New_Occurrence_Of (Container, Loc),\n+                      New_Occurrence_Of (Cursor, Loc)))),\n+          Statements => Stats,\n+          End_Label  => Empty);\n+   end Build_Formal_Container_Iteration;\n+\n    ------------------------------\n    -- Change_Of_Representation --\n    ------------------------------\n@@ -2660,80 +2741,122 @@ package body Exp_Ch5 is\n    -- Expand_Formal_Container_Loop --\n    ----------------------------------\n \n-   procedure Expand_Formal_Container_Loop (Typ : Entity_Id; N : Node_Id) is\n+   procedure Expand_Formal_Container_Loop (N : Node_Id) is\n       Isc       : constant Node_Id    := Iteration_Scheme (N);\n       I_Spec    : constant Node_Id    := Iterator_Specification (Isc);\n       Cursor    : constant Entity_Id  := Defining_Identifier (I_Spec);\n       Container : constant Node_Id    := Entity (Name (I_Spec));\n       Stats     : constant List_Id    := Statements (N);\n-      Loc       : constant Source_Ptr := Sloc (N);\n \n-      First_Op : constant Entity_Id :=\n-                   Get_Iterable_Type_Primitive (Typ, Name_First);\n-      Next_Op  : constant Entity_Id :=\n-                   Get_Iterable_Type_Primitive (Typ, Name_Next);\n-      Has_Element_Op : constant Entity_Id :=\n-                   Get_Iterable_Type_Primitive (Typ, Name_Has_Element);\n-\n-      Advance  : Node_Id;\n-      Init     : Node_Id;\n-      New_Loop : Node_Id;\n+      Advance   : Node_Id;\n+      Init      : Node_Id;\n+      New_Loop  : Node_Id;\n \n    begin\n       --  The expansion resembles the one for Ada containers, but the\n-      --  primitives mention the the domain of iteration explicitly, and\n-      --  First applied to the container yields a cursor directly.\n+      --  primitives mention the domain of iteration explicitly, and\n+      --  function First applied to the container yields a cursor directly.\n \n       --    Cursor : Cursor_type := First (Container);\n       --    while Has_Element (Cursor, Container) loop\n       --          <original loop statements>\n       --       Cursor := Next (Container, Cursor);\n       --    end loop;\n \n-      Init :=\n-         Make_Object_Declaration (Loc,\n-           Defining_Identifier => Cursor,\n-           Object_Definition => New_Occurrence_Of (Etype (First_Op),  Loc),\n-             Expression =>\n-               Make_Function_Call (Loc,\n-                 Name => New_Occurrence_Of (First_Op, Loc),\n-                   Parameter_Associations =>\n-                     New_List (New_Occurrence_Of (Container, Loc))));\n+      Build_Formal_Container_Iteration\n+        (N, Container, Cursor, Init, Advance, New_Loop);\n \n       Set_Ekind (Cursor, E_Variable);\n+      Insert_Action (N, Init);\n+\n+      Append_To (Stats, Advance);\n+\n+      Rewrite (N, New_Loop);\n+      Analyze (New_Loop);\n+   end Expand_Formal_Container_Loop;\n+\n+   ------------------------------------------\n+   -- Expand_Formal_Container_Element_Loop --\n+   ------------------------------------------\n+\n+   procedure Expand_Formal_Container_Element_Loop (N : Node_Id) is\n+      Loc           : constant Source_Ptr := Sloc (N);\n+      Isc           : constant Node_Id    := Iteration_Scheme (N);\n+      I_Spec        : constant Node_Id    := Iterator_Specification (Isc);\n+      Element       : constant Entity_Id  := Defining_Identifier (I_Spec);\n+      Container     : constant Node_Id    := Entity (Name (I_Spec));\n+      Container_Typ : constant Entity_Id := Base_Type (Etype (Container));\n+      Stats         : constant List_Id    := Statements (N);\n \n+      Cursor    : constant Entity_Id :=\n+                    Make_Defining_Identifier (Loc,\n+                     Chars => New_External_Name (Chars (Element), 'C'));\n+      Elmt_Decl : Node_Id;\n+      Elmt_Ref  : Node_Id;\n+\n+      Element_Op     : constant Entity_Id :=\n+                         Get_Iterable_Type_Primitive\n+                           (Container_Typ, Name_Element);\n+\n+      Advance   : Node_Id;\n+      Init      : Node_Id;\n+      New_Loop  : Node_Id;\n+\n+   begin\n+      --  For an element iterator, the Element aspect must be present,\n+      --  (this is checked during analysis) and the expansion takes the form:\n+\n+      --    Cursor : Cursor_type := First (Container);\n+      --    Elmt : Element_Type;\n+      --    while Has_Element (Cursor, Container) loop\n+      --       Elmt := Element (Container, Cursor);\n+      --          <original loop statements>\n+      --       Cursor := Next (Container, Cursor);\n+      --    end loop;\n+\n+      Build_Formal_Container_Iteration\n+        (N, Container, Cursor, Init, Advance, New_Loop);\n+\n+      Set_Ekind (Cursor, E_Variable);\n       Insert_Action (N, Init);\n \n-      Advance :=\n-        Make_Assignment_Statement (Loc,\n-          Name => New_Occurrence_Of (Cursor, Loc),\n-          Expression =>\n-            Make_Function_Call (Loc,\n-              Name => New_Occurrence_Of (Next_Op, Loc),\n-                Parameter_Associations =>\n-                  New_List\n+      --  Declaration for Element.\n+\n+      Elmt_Decl := Make_Object_Declaration (Loc,\n+        Defining_Identifier => Element,\n+        Object_Definition   => New_Occurrence_Of (Etype (Element_Op), Loc));\n+\n+      --  The element is only modified in expanded code, so it appears as\n+      --  unassigned to the warning machinery. We must suppress this spurious\n+      --  warning explicitly.\n+\n+      Set_Warnings_Off (Element);\n+\n+      Elmt_Ref := Make_Assignment_Statement (Loc,\n+         Name       => New_Occurrence_Of (Element, Loc),\n+         Expression =>\n+           Make_Function_Call (Loc,\n+             Name => New_Occurrence_Of (Element_Op, Loc),\n+                 Parameter_Associations =>\n+                   New_List\n                     (New_Occurrence_Of (Container, Loc),\n                      New_Occurrence_Of (Cursor, Loc))));\n \n+      Prepend (Elmt_Ref, Stats);\n       Append_To (Stats, Advance);\n \n-      New_Loop :=\n-        Make_Loop_Statement (Loc,\n-          Iteration_Scheme =>\n-            Make_Iteration_Scheme (Loc,\n-              Condition =>\n-                Make_Function_Call (Loc,\n-                  Name                   =>\n-                    New_Occurrence_Of (Has_Element_Op, Loc),\n-                  Parameter_Associations =>\n-                    New_List\n-                     (New_Occurrence_Of (Container, Loc),\n-                      New_Occurrence_Of (Cursor, Loc)))),\n-          Statements => Stats,\n-          End_Label  => Empty);\n+      --  The loop is rewritten as a block, to hold the declaration for the\n+      --  element.\n+\n+      New_Loop := Make_Block_Statement (Loc,\n+         Declarations               => New_List (Elmt_Decl),\n+         Handled_Statement_Sequence =>\n+           Make_Handled_Sequence_Of_Statements (Loc,\n+             Statements =>  New_List (New_Loop)));\n+\n       Rewrite (N, New_Loop);\n       Analyze (New_Loop);\n-   end Expand_Formal_Container_Loop;\n+   end Expand_Formal_Container_Element_Loop;\n \n    -----------------------------\n    -- Expand_N_Goto_Statement --\n@@ -3052,7 +3175,11 @@ package body Exp_Ch5 is\n          return;\n \n       elsif Has_Aspect (Container_Typ, Aspect_Iterable) then\n-         Expand_Formal_Container_Loop (Container_Typ, N);\n+         if Of_Present (I_Spec) then\n+            Expand_Formal_Container_Element_Loop (N);\n+         else\n+            Expand_Formal_Container_Loop (N);\n+         end if;\n          return;\n       end if;\n "}, {"sha": "9146dc68e2565b57133f06239a146b23317221bb", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -6310,8 +6310,12 @@ package body Sem_Attr is\n                      --  Verify that all choices in an association denote\n                      --  components of the same type.\n \n-                     if No (Comp_Type) then\n+                     if No (Etype (Comp)) then\n+                        null;\n+\n+                     elsif No (Comp_Type) then\n                         Comp_Type := Base_Type (Etype (Comp));\n+\n                      elsif Comp_Type /= Base_Type (Etype (Comp)) then\n                         Error_Msg_N\n                           (\"components in choice list must have same type\","}, {"sha": "e5ea4cefe1e0ec014556afa0f7df56878e29e3b0", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -1857,39 +1857,45 @@ package body Sem_Ch5 is\n          Set_Ekind (Def_Id, E_Loop_Parameter);\n \n          if Of_Present (N) then\n+            if Has_Aspect (Typ, Aspect_Iterable) then\n+               if No (Get_Iterable_Type_Primitive (Typ, Name_Element)) then\n+                  Error_Msg_N (\"Missing Element primitive for iteration\", N);\n+               end if;\n \n-            --  The type of the loop variable is the Iterator_Element aspect of\n-            --  the container type.\n+            --  For a predefined container, The type of the loop variable is\n+            --  the Iterator_Element aspect of the container type.\n \n-            declare\n-               Element : constant Entity_Id :=\n+            else\n+               declare\n+                  Element : constant Entity_Id :=\n                            Find_Value_Of_Aspect (Typ, Aspect_Iterator_Element);\n-            begin\n-               if No (Element) then\n-                  Error_Msg_NE (\"cannot iterate over&\", N, Typ);\n-                  return;\n-               else\n-                  Set_Etype (Def_Id, Entity (Element));\n+               begin\n+                  if No (Element) then\n+                     Error_Msg_NE (\"cannot iterate over&\", N, Typ);\n+                     return;\n+                  else\n+                     Set_Etype (Def_Id, Entity (Element));\n \n-                  --  If subtype indication was given, verify that it matches\n-                  --  element type of container.\n+                     --  If subtype indication was given, verify that it\n+                     --  matches element type of container.\n \n-                  if Present (Subt)\n-                     and then Bas /= Base_Type (Etype (Def_Id))\n-                  then\n-                     Error_Msg_N\n-                       (\"subtype indication does not match element type\",\n-                          Subt);\n-                  end if;\n+                     if Present (Subt)\n+                        and then Bas /= Base_Type (Etype (Def_Id))\n+                     then\n+                        Error_Msg_N\n+                          (\"subtype indication does not match element type\",\n+                             Subt);\n+                     end if;\n \n-                  --  If the container has a variable indexing aspect, the\n-                  --  element is a variable and is modifiable in the loop.\n+                     --  If the container has a variable indexing aspect, the\n+                     --  element is a variable and is modifiable in the loop.\n \n-                  if Has_Aspect (Typ, Aspect_Variable_Indexing) then\n-                     Set_Ekind (Def_Id, E_Variable);\n+                     if Has_Aspect (Typ, Aspect_Variable_Indexing) then\n+                        Set_Ekind (Def_Id, E_Variable);\n+                     end if;\n                   end if;\n-               end if;\n-            end;\n+               end;\n+            end if;\n \n          else\n             --  For an iteration of the form IN, the name must denote an"}, {"sha": "113678301a0577cf6b7106686357f488311bdc3f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -1235,64 +1235,34 @@ package body Sem_Prag is\n          -----------------\n \n          procedure Usage_Error (Item : Node_Id; Item_Id : Entity_Id) is\n-            Typ       : constant Entity_Id := Etype (Item_Id);\n             Error_Msg : Name_Id;\n \n          begin\n-            Name_Len := 0;\n-\n             --  Input case\n \n             if Is_Input then\n-               Add_Item_To_Name_Buffer (Item_Id);\n-               Add_Str_To_Name_Buffer\n-                 (\" & must appear in at least one input dependence list \"\n-                  & \"(SPARK RM 6.1.5(8))\");\n-\n-               Error_Msg := Name_Find;\n-               Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n-\n-               --  Refine the error message for unconstrained parameters and\n-               --  variables by giving the reason for the illegality.\n-\n-               if Ekind (Item_Id) = E_Out_Parameter then\n-\n-                  --  Unconstrained arrays must appear as inputs because their\n-                  --  bounds must be read.\n-\n-                  if Is_Array_Type (Typ)\n-                    and then not Is_Constrained (Typ)\n-                  then\n-                     Error_Msg_NE\n-                       (\"\\\\type & is an unconstrained array\", Item, Typ);\n-                     Error_Msg_N (\"\\\\array bounds must be read\", Item);\n \n-                  --  Unconstrained discriminated records must appear as inputs\n-                  --  because their discriminants and constrained flag must be\n-                  --  read.\n+               --  Unconstrained and tagged items are not part of the explicit\n+               --  input set of the related subprogram, they do not have to be\n+               --  present in a dependence relation and should not be flagged.\n \n-                  elsif Is_Record_Type (Typ)\n-                    and then Has_Discriminants (Typ)\n-                    and then not Is_Constrained (Typ)\n-                  then\n-                     Error_Msg_NE\n-                       (\"\\\\type & is an unconstrained discriminated record\",\n-                        Item, Typ);\n-                     Error_Msg_N\n-                       (\"\\\\discriminants and constrained flag must be read\",\n-                        Item);\n+               if not Is_Unconstrained_Or_Tagged_Item (Item_Id) then\n+                  Name_Len := 0;\n \n-                  --  Not clear if there are other cases. Anyway, we will\n-                  --  simply ignore any other cases.\n+                  Add_Item_To_Name_Buffer (Item_Id);\n+                  Add_Str_To_Name_Buffer\n+                    (\" & must appear in at least one input dependence list \"\n+                     & \"(SPARK RM 6.1.5(8))\");\n \n-                  else\n-                     null;\n-                  end if;\n+                  Error_Msg := Name_Find;\n+                  Error_Msg_NE (Get_Name_String (Error_Msg), Item, Item_Id);\n                end if;\n \n             --  Output case\n \n             else\n+               Name_Len := 0;\n+\n                Add_Item_To_Name_Buffer (Item_Id);\n                Add_Str_To_Name_Buffer\n                  (\" & must appear in exactly one output dependence list \""}, {"sha": "c9ac972dda7df5668042f552827be7a09f5ec832", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8880426d05f9bf038fb0e735da6914cfd1ec8b55/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=8880426d05f9bf038fb0e735da6914cfd1ec8b55", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -310,6 +310,10 @@ package body Switch.M is\n                      else\n                         case Switch_Chars (Ptr) is\n \n+                           when 'A' =>\n+                              Ptr := Ptr + 1;\n+                              Add_Switch_Component (\"-gnateA\");\n+\n                            when 'D' =>\n                               Storing (First_Stored + 1 ..\n                                          First_Stored + Max - Ptr + 1) :=\n@@ -319,16 +323,17 @@ package body Switch.M is\n                                    First_Stored + Max - Ptr + 1));\n                               Ptr := Max + 1;\n \n-                           when 'G' =>\n-                              Ptr := Ptr + 1;\n-                              Add_Switch_Component (\"-gnateG\");\n-\n-                           when 'I' =>\n+                           when 'E' | 'F' | 'G' | 'S' | 'u' | 'V' | 'Y' =>\n+                              Add_Switch_Component\n+                                (\"-gnate\" & Switch_Chars (Ptr));\n                               Ptr := Ptr + 1;\n \n+                           when 'i' | 'I' =>\n                               declare\n-                                 First : constant Positive := Ptr - 1;\n+                                 First : constant Positive := Ptr;\n                               begin\n+                                 Ptr := Ptr + 1;\n+\n                                  if Ptr <= Max and then\n                                    Switch_Chars (Ptr) = '='\n                                  then\n@@ -376,10 +381,6 @@ package body Switch.M is\n \n                               return;\n \n-                           when 'S' =>\n-                              Ptr := Ptr + 1;\n-                              Add_Switch_Component (\"-gnateS\");\n-\n                            when others =>\n                               Last := 0;\n                               return;"}]}