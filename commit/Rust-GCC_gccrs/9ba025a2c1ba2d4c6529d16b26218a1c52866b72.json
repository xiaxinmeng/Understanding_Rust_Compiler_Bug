{"sha": "9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhMDI1YTJjMWJhMmQ0YzY1MjlkMTZiMjYyMThhMWM1Mjg2NmI3Mg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-11T15:52:01Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-11T15:52:01Z"}, "message": "tree-loop-linear.c (gather_interchange_stats, [...]): Use loop_depth and loop_outer accessor functions.\n\n\t* tree-loop-linear.c (gather_interchange_stats, try_interchange_loops):\n\tUse loop_depth and loop_outer accessor functions.\n\t* tree-ssa-loop-im.c (outermost_invariant_loop, set_level,\n\tdetermine_invariantness_stmt, move_computations_stmt): Ditto.\n\t* cfgloopmanip.c (fix_bb_placement, fix_loop_placement, remove_path,\n\tadd_loop, loopify, unloop, fix_loop_structure): Ditto.\n\t* tree-ssa-loop-manip.c (find_uses_to_rename_use): Ditto.\n\t* tree-scalar-evolution.c (interpret_loop_phi,\n\tcompute_scalar_evolution_in_loop, analyze_scalar_evolution_in_loop,\n\tinstantiate_parameters_1, scev_const_prop): Ditto.\n\t* cfghooks.c (make_forwarder_block): Ditto.\n\t* cfgloopanal.c (mark_irreducible_loops, mark_loop_exit_edges): Ditto.\n\t* modulo-sched.c (loop_canon_p): Ditto.\n\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg,\n\tslpeel_can_duplicate_loop_p): Ditto.\n\t* lambda-code.c (invariant_in_loop_and_outer_loops): Ditto.\n\t* tree-cfg.c (tree_duplicate_sese_region): Ditto.\n\t* cfgloop.c (flow_loop_dump, flow_loop_nodes_find, rescan_loop_exit,\n\tcancel_loop, verify_loop_structure): Ditto.\n\t(flow_loop_nested_p, superloop_at_depth, flow_loop_free,\n\tadd_bb_to_loop, remove_bb_from_loops, find_common_loop): Use the\n\tsuperloops vector instead of \"pred\" array.\n\t(establish_preds): Take father loop as an argument.  Initialize the\n\tsuperloops vector.\n\t(flow_loop_tree_node_add): Pass father loop to establish_preds.  Do not\n\tinitialize loop->outer.\n\t(flow_loop_tree_node_remove): Truncate the superloops vector.\n\t* cfgloop.h (struct loop): Removed field \"outer\", fields \"depth\" and\n\t\"pred\" merged to \"superloops\" vector.\n\t(loop_depth, loop_outer): New.\n\t(fel_init): Use loop_outer.\n\nFrom-SVN: r124619", "tree": {"sha": "94649f85c3e7ccd857de92cda5f4eabf23d7ec05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94649f85c3e7ccd857de92cda5f4eabf23d7ec05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/comments", "author": null, "committer": null, "parents": [{"sha": "7be82279042841a50c9a3464fce35c471fa07f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be82279042841a50c9a3464fce35c471fa07f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7be82279042841a50c9a3464fce35c471fa07f1c"}], "stats": {"total": 284, "additions": 174, "deletions": 110}, "files": [{"sha": "f7aad187b2c7cfd912c4ccee5be7cac131fbd59c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -1,3 +1,37 @@\n+2007-05-11  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-loop-linear.c (gather_interchange_stats, try_interchange_loops):\n+\tUse loop_depth and loop_outer accessor functions.\n+\t* tree-ssa-loop-im.c (outermost_invariant_loop, set_level,\n+\tdetermine_invariantness_stmt, move_computations_stmt): Ditto.\n+\t* cfgloopmanip.c (fix_bb_placement, fix_loop_placement, remove_path,\n+\tadd_loop, loopify, unloop, fix_loop_structure): Ditto.\n+\t* tree-ssa-loop-manip.c (find_uses_to_rename_use): Ditto.\n+\t* tree-scalar-evolution.c (interpret_loop_phi,\n+\tcompute_scalar_evolution_in_loop, analyze_scalar_evolution_in_loop,\n+\tinstantiate_parameters_1, scev_const_prop): Ditto.\n+\t* cfghooks.c (make_forwarder_block): Ditto.\n+\t* cfgloopanal.c (mark_irreducible_loops, mark_loop_exit_edges): Ditto.\n+\t* modulo-sched.c (loop_canon_p): Ditto.\n+\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg,\n+\tslpeel_can_duplicate_loop_p): Ditto.\n+\t* lambda-code.c (invariant_in_loop_and_outer_loops): Ditto.\n+\t* tree-cfg.c (tree_duplicate_sese_region): Ditto.\n+\t* cfgloop.c (flow_loop_dump, flow_loop_nodes_find, rescan_loop_exit,\n+\tcancel_loop, verify_loop_structure): Ditto.\n+\t(flow_loop_nested_p, superloop_at_depth, flow_loop_free,\n+\tadd_bb_to_loop, remove_bb_from_loops, find_common_loop): Use the\n+\tsuperloops vector instead of \"pred\" array.\n+\t(establish_preds): Take father loop as an argument.  Initialize the\n+\tsuperloops vector.\n+\t(flow_loop_tree_node_add): Pass father loop to establish_preds.  Do not\n+\tinitialize loop->outer.\n+\t(flow_loop_tree_node_remove): Truncate the superloops vector.\n+\t* cfgloop.h (struct loop): Removed field \"outer\", fields \"depth\" and\n+\t\"pred\" merged to \"superloops\" vector.\n+\t(loop_depth, loop_outer): New.\n+\t(fel_init): Use loop_outer.\n+\n 2007-05-11  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c: Include gt-cgraphunit.h"}, {"sha": "f1103c15685a66046a2da11f4b93e6b2b6bfea93", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -767,7 +767,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \t}\n \n       /* In case we split loop latch, update it.  */\n-      for (ploop = loop; ploop; ploop = ploop->outer)\n+      for (ploop = loop; ploop; ploop = loop_outer (ploop))\n \tif (ploop->latch == dummy)\n \t  ploop->latch = bb;\n     }"}, {"sha": "c77fdafd93ce5dd6b44148d81c3dac69020c856d", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -36,7 +36,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"output.h\"\n \n static void flow_loops_cfg_dump (FILE *);\n-static void establish_preds (struct loop *);\n \f\n /* Dump loop related CFG information.  */\n \n@@ -65,8 +64,10 @@ flow_loops_cfg_dump (FILE *file)\n bool\n flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n {\n-  return (loop->depth > outer->depth\n-\t && loop->pred[outer->depth] == outer);\n+  unsigned odepth = loop_depth (outer);\n+\n+  return (loop_depth (loop) > odepth\n+\t  && VEC_index (loop_p, loop->superloops, odepth) == outer);\n }\n \n /* Returns the loop such that LOOP is nested DEPTH (indexed from zero)\n@@ -75,12 +76,14 @@ flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n struct loop *\n superloop_at_depth (struct loop *loop, unsigned depth)\n {\n-  gcc_assert (depth <= (unsigned) loop->depth);\n+  unsigned ldepth = loop_depth (loop);\n+\n+  gcc_assert (depth <= ldepth);\n \n-  if (depth == (unsigned) loop->depth)\n+  if (depth == ldepth)\n     return loop;\n \n-  return loop->pred[depth];\n+  return VEC_index (loop_p, loop->superloops, depth);\n }\n \n /* Returns the list of the latch edges of LOOP.  */\n@@ -133,7 +136,8 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n     }\n \n   fprintf (file, \";;  depth %d, outer %ld\\n\",\n-\t   loop->depth, (long) (loop->outer ? loop->outer->num : -1));\n+\t   loop_depth (loop), (long) (loop_outer (loop)\n+\t\t\t\t      ? loop_outer (loop)->num : -1));\n \n   fprintf (file, \";;  nodes:\");\n   bbs = get_loop_body (loop);\n@@ -175,8 +179,7 @@ flow_loop_free (struct loop *loop)\n {\n   struct loop_exit *exit, *next;\n \n-  if (loop->pred)\n-    free (loop->pred);\n+  VEC_free (loop_p, heap, loop->superloops);\n \n   /* Break the list of the loop exit records.  They will be freed when the\n      corresponding edge is rescanned or removed, and this avoids\n@@ -226,9 +229,10 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n   int num_nodes = 1;\n   edge latch;\n   edge_iterator latch_ei;\n+  unsigned depth = loop_depth (loop);\n \n   header->loop_father = loop;\n-  header->loop_depth = loop->depth;\n+  header->loop_depth = depth;\n \n   FOR_EACH_EDGE (latch, latch_ei, loop->header->preds)\n     {\n@@ -239,7 +243,7 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n       num_nodes++;\n       VEC_safe_push (basic_block, heap, stack, latch->src);\n       latch->src->loop_father = loop;\n-      latch->src->loop_depth = loop->depth;\n+      latch->src->loop_depth = depth;\n \n       while (!VEC_empty (basic_block, stack))\n \t{\n@@ -256,7 +260,7 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \t      if (ancestor->loop_father != loop)\n \t\t{\n \t\t  ancestor->loop_father = loop;\n-\t\t  ancestor->loop_depth = loop->depth;\n+\t\t  ancestor->loop_depth = depth;\n \t\t  num_nodes++;\n \t\t  VEC_safe_push (basic_block, heap, stack, ancestor);\n \t\t}\n@@ -268,24 +272,27 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n   return num_nodes;\n }\n \n+/* Records the vector of superloops of the loop LOOP, whose immediate\n+   superloop is FATHER.  */\n+\n static void\n-establish_preds (struct loop *loop)\n+establish_preds (struct loop *loop, struct loop *father)\n {\n-  struct loop *ploop, *father = loop->outer;\n-\n-  loop->depth = father->depth + 1;\n+  loop_p ploop;\n+  unsigned depth = loop_depth (father) + 1;\n+  unsigned i;\n \n   /* Remember the current loop depth if it is the largest seen so far.  */\n-  cfun->max_loop_depth = MAX (cfun->max_loop_depth, loop->depth);\n+  cfun->max_loop_depth = MAX (cfun->max_loop_depth, (int) depth);\n \n-  if (loop->pred)\n-    free (loop->pred);\n-  loop->pred = XNEWVEC (struct loop *, loop->depth);\n-  memcpy (loop->pred, father->pred, sizeof (struct loop *) * father->depth);\n-  loop->pred[father->depth] = father;\n+  VEC_truncate (loop_p, loop->superloops, 0);\n+  VEC_reserve (loop_p, heap, loop->superloops, depth);\n+  for (i = 0; VEC_iterate (loop_p, father->superloops, i, ploop); i++)\n+    VEC_quick_push (loop_p, loop->superloops, ploop);\n+  VEC_quick_push (loop_p, loop->superloops, father);\n \n   for (ploop = loop->inner; ploop; ploop = ploop->next)\n-    establish_preds (ploop);\n+    establish_preds (ploop, loop);\n }\n \n /* Add LOOP to the loop hierarchy tree where FATHER is father of the\n@@ -297,9 +304,8 @@ flow_loop_tree_node_add (struct loop *father, struct loop *loop)\n {\n   loop->next = father->inner;\n   father->inner = loop;\n-  loop->outer = father;\n \n-  establish_preds (loop);\n+  establish_preds (loop, father);\n }\n \n /* Remove LOOP from the loop hierarchy tree.  */\n@@ -309,21 +315,19 @@ flow_loop_tree_node_remove (struct loop *loop)\n {\n   struct loop *prev, *father;\n \n-  father = loop->outer;\n-  loop->outer = NULL;\n+  father = loop_outer (loop);\n \n   /* Remove loop from the list of sons.  */\n   if (father->inner == loop)\n     father->inner = loop->next;\n   else\n     {\n-      for (prev = father->inner; prev->next != loop; prev = prev->next);\n+      for (prev = father->inner; prev->next != loop; prev = prev->next)\n+\tcontinue;\n       prev->next = loop->next;\n     }\n \n-  loop->depth = -1;\n-  free (loop->pred);\n-  loop->pred = NULL;\n+  VEC_truncate (loop_p, loop->superloops, 0);\n }\n \n /* Allocates and returns new loop structure.  */\n@@ -994,7 +998,7 @@ rescan_loop_exit (edge e, bool new_edge, bool removed)\n       cloop = find_common_loop (e->src->loop_father, e->dest->loop_father);\n       for (aloop = e->src->loop_father;\n \t   aloop != cloop;\n-\t   aloop = aloop->outer)\n+\t   aloop = loop_outer (aloop))\n \t{\n \t  exit = XNEW (struct loop_exit);\n \t  exit->e = e;\n@@ -1161,16 +1165,17 @@ num_loop_branches (const struct loop *loop)\n void\n add_bb_to_loop (basic_block bb, struct loop *loop)\n {\n-  int i;\n+  unsigned i;\n+  loop_p ploop;\n   edge_iterator ei;\n   edge e;\n \n   gcc_assert (bb->loop_father == NULL);\n   bb->loop_father = loop;\n-  bb->loop_depth = loop->depth;\n+  bb->loop_depth = loop_depth (loop);\n   loop->num_nodes++;\n-  for (i = 0; i < loop->depth; i++)\n-    loop->pred[i]->num_nodes++;\n+  for (i = 0; VEC_iterate (loop_p, loop->superloops, i, ploop); i++)\n+    ploop->num_nodes++;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -1188,13 +1193,14 @@ remove_bb_from_loops (basic_block bb)\n {\n   int i;\n   struct loop *loop = bb->loop_father;\n+  loop_p ploop;\n   edge_iterator ei;\n   edge e;\n \n   gcc_assert (loop != NULL);\n   loop->num_nodes--;\n-  for (i = 0; i < loop->depth; i++)\n-    loop->pred[i]->num_nodes--;\n+  for (i = 0; VEC_iterate (loop_p, loop->superloops, i, ploop); i++)\n+    ploop->num_nodes--;\n   bb->loop_father = NULL;\n   bb->loop_depth = 0;\n \n@@ -1212,18 +1218,23 @@ remove_bb_from_loops (basic_block bb)\n struct loop *\n find_common_loop (struct loop *loop_s, struct loop *loop_d)\n {\n+  unsigned sdepth, ddepth;\n+\n   if (!loop_s) return loop_d;\n   if (!loop_d) return loop_s;\n \n-  if (loop_s->depth < loop_d->depth)\n-    loop_d = loop_d->pred[loop_s->depth];\n-  else if (loop_s->depth > loop_d->depth)\n-    loop_s = loop_s->pred[loop_d->depth];\n+  sdepth = loop_depth (loop_s);\n+  ddepth = loop_depth (loop_d);\n+\n+  if (sdepth < ddepth)\n+    loop_d = VEC_index (loop_p, loop_d->superloops, sdepth);\n+  else if (sdepth > ddepth)\n+    loop_s = VEC_index (loop_p, loop_s->superloops, ddepth);\n \n   while (loop_s != loop_d)\n     {\n-      loop_s = loop_s->outer;\n-      loop_d = loop_d->outer;\n+      loop_s = loop_outer (loop_s);\n+      loop_d = loop_outer (loop_d);\n     }\n   return loop_s;\n }\n@@ -1250,13 +1261,14 @@ cancel_loop (struct loop *loop)\n {\n   basic_block *bbs;\n   unsigned i;\n+  struct loop *outer = loop_outer (loop);\n \n   gcc_assert (!loop->inner);\n \n   /* Move blocks up one level (they should be removed as soon as possible).  */\n   bbs = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n-    bbs[i]->loop_father = loop->outer;\n+    bbs[i]->loop_father = outer;\n \n   delete_loop (loop);\n }\n@@ -1295,7 +1307,7 @@ verify_loop_structure (void)\n   sizes[0] = 2;\n \n   FOR_EACH_BB (bb)\n-    for (loop = bb->loop_father; loop; loop = loop->outer)\n+    for (loop = bb->loop_father; loop; loop = loop_outer (loop))\n       sizes[loop->num]++;\n \n   FOR_EACH_LOOP (li, loop, LI_INCLUDE_ROOT)\n@@ -1494,7 +1506,7 @@ verify_loop_structure (void)\n \n \t      for (loop = bb->loop_father;\n \t\t   loop != e->dest->loop_father;\n-\t\t   loop = loop->outer)\n+\t\t   loop = loop_outer (loop))\n \t\t{\n \t\t  eloops--;\n \t\t  sizes[loop->num]++;"}, {"sha": "4c33c9cc056b6391d014276610d0e98fae413242", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -85,6 +85,10 @@ struct loop_exit\n   struct loop_exit *next_e;\n };\n \n+typedef struct loop *loop_p;\n+DEF_VEC_P (loop_p);\n+DEF_VEC_ALLOC_P (loop_p, heap);\n+\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n@@ -109,14 +113,8 @@ struct loop\n   /* Number of blocks contained within the loop.  */\n   unsigned num_nodes;\n \n-  /* The loop nesting depth.  */\n-  int depth;\n-\n-  /* Superloops of the loop.  */\n-  struct loop **pred;\n-\n-  /* The outer (parent) loop or NULL if outermost loop.  */\n-  struct loop *outer;\n+  /* Superloops of the loop, starting with the outermost loop.  */\n+  VEC (loop_p, heap) *superloops;\n \n   /* The first inner (child) loop or NULL if innermost loop.  */\n   struct loop *inner;\n@@ -178,10 +176,6 @@ enum\n \t\t      | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n #define AVOID_CFG_MODIFICATIONS (LOOPS_MAY_HAVE_MULTIPLE_LATCHES)\n \n-typedef struct loop *loop_p;\n-DEF_VEC_P (loop_p);\n-DEF_VEC_ALLOC_P (loop_p, heap);\n-\n /* Structure to hold CFG information about natural loops within a function.  */\n struct loops\n {\n@@ -410,6 +404,28 @@ get_loop (unsigned num)\n   return VEC_index (loop_p, current_loops->larray, num);\n }\n \n+/* Returns the number of superloops of LOOP.  */\n+\n+static inline unsigned\n+loop_depth (const struct loop *loop)\n+{\n+  return VEC_length (loop_p, loop->superloops);\n+}\n+\n+/* Returns the immediate superloop of LOOP, or NULL if LOOP is the outermost\n+   loop.  */\n+\n+static inline struct loop *\n+loop_outer (const struct loop *loop)\n+{\n+  unsigned n = VEC_length (loop_p, loop->superloops);\n+\n+  if (n == 0)\n+    return NULL;\n+\n+  return VEC_index (loop_p, loop->superloops, n - 1);\n+}\n+\n /* Returns the list of loops in current_loops.  */\n \n static inline VEC (loop_p, heap) *\n@@ -519,10 +535,10 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \t\t   aloop = aloop->inner)\n \t\tcontinue;\n \t    }\n-\t  else if (!aloop->outer)\n+\t  else if (!loop_outer (aloop))\n \t    break;\n \t  else\n-\t    aloop = aloop->outer;\n+\t    aloop = loop_outer (aloop);\n \t}\n     }\n   else\n@@ -539,7 +555,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \t  else\n \t    {\n \t      while (aloop != NULL && aloop->next == NULL)\n-\t\taloop = aloop->outer;\n+\t\taloop = loop_outer (aloop);\n \t      if (aloop == NULL)\n \t\tbreak;\n \t      aloop = aloop->next;"}, {"sha": "54d00ce574c7b887a7cdd4e93ac53fcc76fa9a65", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -276,7 +276,8 @@ mark_irreducible_loops (void)\n   int num = current_loops ? number_of_loops () : 1;\n   int *queue1 = XNEWVEC (int, last_basic_block + num);\n   int *queue2 = XNEWVEC (int, last_basic_block + num);\n-  int nq, depth;\n+  int nq;\n+  unsigned depth;\n   struct loop *cloop, *loop;\n   loop_iterator li;\n \n@@ -321,12 +322,13 @@ mark_irreducible_loops (void)\n \n \t    if (!flow_bb_inside_loop_p (act->loop_father, e->dest))\n \t      {\n-\t\tdepth = find_common_loop (act->loop_father,\n-\t\t\t\t\t  e->dest->loop_father)->depth + 1;\n-\t\tif (depth == act->loop_father->depth)\n+\t\tdepth = 1 + loop_depth (find_common_loop (act->loop_father,\n+\t\t\t\t\t\te->dest->loop_father));\n+\t\tif (depth == loop_depth (act->loop_father))\n \t\t  cloop = act->loop_father;\n \t\telse\n-\t\t  cloop = act->loop_father->pred[depth];\n+\t\t  cloop = VEC_index (loop_p, act->loop_father->superloops,\n+\t\t\t\t     depth);\n \n \t\tsrc = LOOP_REPR (cloop);\n \t      }\n@@ -612,7 +614,7 @@ mark_loop_exit_edges (void)\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  if (bb->loop_father->outer\n+\t  if (loop_outer (bb->loop_father)\n \t      && loop_exit_edge_p (bb->loop_father, e))\n \t    e->flags |= EDGE_LOOP_EXIT;\n \t  else"}, {"sha": "a1af1111f1592ae97ff9f2432e5b5b713ad1e32d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -102,7 +102,7 @@ fix_bb_placement (basic_block bb)\n \n       act = e->dest->loop_father;\n       if (act->header == e->dest)\n-\tact = act->outer;\n+\tact = loop_outer (act);\n \n       if (flow_loop_nested_p (loop, act))\n \tloop = act;\n@@ -138,9 +138,9 @@ fix_loop_placement (struct loop *loop)\n \tfather = act;\n     }\n \n-  if (father != loop->outer)\n+  if (father != loop_outer (loop))\n     {\n-      for (act = loop->outer; act != father; act = act->outer)\n+      for (act = loop_outer (loop); act != father; act = loop_outer (act))\n \tact->num_nodes -= loop->num_nodes;\n       flow_loop_tree_node_remove (loop);\n       flow_loop_tree_node_add (father, loop);\n@@ -305,7 +305,7 @@ remove_path (edge e)\n      we belong to.  In this case first unloop the loops, then proceed\n      normally.   We may assume that e->dest is not a header of any loop,\n      as it now has exactly one predecessor.  */\n-  while (e->src->loop_father->outer\n+  while (loop_outer (e->src->loop_father)\n \t && dominated_by_p (CDI_DOMINATORS,\n \t\t\t    e->src->loop_father->latch, e->dest))\n     unloop (e->src->loop_father, &irred_invalidated);\n@@ -434,7 +434,7 @@ add_loop (struct loop *loop, struct loop *outer)\n \n       /* If we find a direct subloop of OUTER, move it to LOOP.  */\n       subloop = bbs[i]->loop_father;\n-      if (subloop->outer == outer\n+      if (loop_outer (subloop) == outer\n \t  && subloop->header == bbs[i])\n \t{\n \t  flow_loop_tree_node_remove (subloop);\n@@ -477,7 +477,7 @@ loopify (edge latch_edge, edge header_edge,\n   unsigned n_dom_bbs, i;\n   sbitmap seen;\n   struct loop *loop = alloc_loop ();\n-  struct loop *outer = succ_bb->loop_father->outer;\n+  struct loop *outer = loop_outer (succ_bb->loop_father);\n   int freq;\n   gcov_type cnt;\n   edge e;\n@@ -592,15 +592,15 @@ unloop (struct loop *loop, bool *irred_invalidated)\n     if (body[i]->loop_father == loop)\n       {\n \tremove_bb_from_loops (body[i]);\n-\tadd_bb_to_loop (body[i], loop->outer);\n+\tadd_bb_to_loop (body[i], loop_outer (loop));\n       }\n   free(body);\n \n   while (loop->inner)\n     {\n       ploop = loop->inner;\n       flow_loop_tree_node_remove (ploop);\n-      flow_loop_tree_node_add (loop->outer, ploop);\n+      flow_loop_tree_node_add (loop_outer (loop), ploop);\n     }\n \n   /* Remove the loop and free its data.  */\n@@ -627,9 +627,9 @@ fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n {\n   struct loop *outer;\n \n-  while (loop->outer)\n+  while (loop_outer (loop))\n     {\n-      outer = loop->outer;\n+      outer = loop_outer (loop);\n       if (!fix_loop_placement (loop))\n \tbreak;\n \n@@ -1393,7 +1393,7 @@ fix_loop_structure (bitmap changed_bbs)\n   FOR_EACH_BB (bb)\n     {\n       if (changed_bbs)\n-\tbb->aux = (void *) (size_t) bb->loop_father->depth;\n+\tbb->aux = (void *) (size_t) loop_depth (bb->loop_father);\n       bb->loop_father = current_loops->tree_root;\n     }\n \n@@ -1416,7 +1416,7 @@ fix_loop_structure (bitmap changed_bbs)\n \t{\n \t  ploop = loop->inner;\n \t  flow_loop_tree_node_remove (ploop);\n-\t  flow_loop_tree_node_add (loop->outer, ploop);\n+\t  flow_loop_tree_node_add (loop_outer (loop), ploop);\n \t}\n \n       /* Remove the loop and free its data.  */\n@@ -1439,7 +1439,7 @@ fix_loop_structure (bitmap changed_bbs)\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       ploop = superloop[loop->num];\n-      if (ploop != loop->outer)\n+      if (ploop != loop_outer (loop))\n \t{\n \t  flow_loop_tree_node_remove (loop);\n \t  flow_loop_tree_node_add (ploop, loop);\n@@ -1452,7 +1452,7 @@ fix_loop_structure (bitmap changed_bbs)\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  if ((void *) (size_t) bb->loop_father->depth != bb->aux)\n+\t  if ((void *) (size_t) loop_depth (bb->loop_father) != bb->aux)\n \t    bitmap_set_bit (changed_bbs, bb->index);\n \n     \t  bb->aux = NULL;"}, {"sha": "579c3d3fb7fe573b40fa136e9d488258188c9934", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -1187,12 +1187,11 @@ invariant_in_loop_and_outer_loops (struct loop *loop, tree op)\n {\n   if (is_gimple_min_invariant (op))\n     return true;\n-  if (loop->depth == 0)\n+  if (loop_depth (loop) == 0)\n     return true;\n   if (!expr_invariant_in_loop_p (loop, op))\n     return false;\n-  if (loop->outer \n-      && !invariant_in_loop_and_outer_loops (loop->outer, op))\n+  if (!invariant_in_loop_and_outer_loops (loop_outer (loop), op))\n     return false;\n   return true;\n }"}, {"sha": "36278a3a9eb00d6157e2cfc856ccda5ee7dd8c20", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -811,7 +811,7 @@ static bool\n loop_canon_p (struct loop *loop)\n {\n \n-  if (loop->inner || ! loop->outer)\n+  if (loop->inner || !loop_outer (loop))\n     return false;\n \n   if (!single_exit (loop))"}, {"sha": "15beeabb54406577646c5c3a1405ab4c546e85de", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -4367,7 +4367,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   if (loop->header == entry->dest)\n     {\n       copying_header = true;\n-      loop->copy = loop->outer;\n+      loop->copy = loop_outer (loop);\n \n       if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n \treturn false;"}, {"sha": "f0dfa7ac49029cdb50df508f958cf0ddfd8fa622", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -117,7 +117,7 @@ gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations,\n \n       for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n \t{\n-\t  int dist = DDR_DIST_VECT (ddr, j)[loop->depth - first_loop->depth];\n+\t  int dist = DDR_DIST_VECT (ddr, j)[loop_depth (loop) - loop_depth (first_loop)];\n \n \t  if (dist == 0)\n \t    (*nb_deps_not_carried_by_loop) += 1;\n@@ -200,7 +200,7 @@ try_interchange_loops (lambda_trans_matrix trans,\n        loop_j; \n        loop_j = loop_j->inner)\n     for (loop_i = first_loop; \n-\t loop_i->depth < loop_j->depth; \n+\t loop_depth (loop_i) < loop_depth (loop_j); \n \t loop_i = loop_i->inner)\n       {\n \tgather_interchange_stats (dependence_relations, datarefs,\n@@ -230,14 +230,14 @@ try_interchange_loops (lambda_trans_matrix trans,\n \t    || double_int_ucmp (access_strides_i, access_strides_j) < 0)\n \t  {\n \t    lambda_matrix_row_exchange (LTM_MATRIX (trans),\n-\t\t\t\t\tloop_i->depth - first_loop->depth,\n-\t\t\t\t\tloop_j->depth - first_loop->depth);\n+\t\t\t\t\tloop_depth (loop_i) - loop_depth (first_loop),\n+\t\t\t\t\tloop_depth (loop_j) - loop_depth (first_loop));\n \t    /* Validate the resulting matrix.  When the transformation\n \t       is not valid, reverse to the previous transformation.  */\n \t    if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n \t      lambda_matrix_row_exchange (LTM_MATRIX (trans), \n-\t\t\t\t\t  loop_i->depth - first_loop->depth, \n-\t\t\t\t\t  loop_j->depth - first_loop->depth);\n+\t\t\t\t\t  loop_depth (loop_i) - loop_depth (first_loop), \n+\t\t\t\t\t  loop_depth (loop_j) - loop_depth (first_loop));\n \t  }\n       }\n "}, {"sha": "b2a266bbf46f807fce1661fec3c0b7310400ef0b", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -1534,7 +1534,7 @@ interpret_loop_phi (struct loop *loop, tree loop_phi_node)\n \t(phi_loop, PHI_RESULT (loop_phi_node));\n \n       /* Dive one level deeper.  */\n-      subloop = superloop_at_depth (phi_loop, loop->depth + 1);\n+      subloop = superloop_at_depth (phi_loop, loop_depth (loop) + 1);\n \n       /* Interpret the subloop.  */\n       res = compute_overall_effect_of_inner_loop (subloop, evolution_fn);\n@@ -1680,7 +1680,7 @@ compute_scalar_evolution_in_loop (struct loop *wrto_loop,\n   if (def_loop == wrto_loop)\n     return ev;\n \n-  def_loop = superloop_at_depth (def_loop, wrto_loop->depth + 1);\n+  def_loop = superloop_at_depth (def_loop, loop_depth (wrto_loop) + 1);\n   res = compute_overall_effect_of_inner_loop (def_loop, ev);\n \n   return analyze_scalar_evolution_1 (wrto_loop, res, chrec_not_analyzed_yet);\n@@ -2023,7 +2023,7 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n \t  || !val)\n \treturn chrec_dont_know;\n \n-      use_loop = use_loop->outer;\n+      use_loop = loop_outer (use_loop);\n     }\n }\n \n@@ -2169,8 +2169,8 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       /* Don't instantiate loop-closed-ssa phi nodes.  */\n       if (TREE_CODE (res) == SSA_NAME\n \t  && (loop_containing_stmt (SSA_NAME_DEF_STMT (res)) == NULL\n-\t      || (loop_containing_stmt (SSA_NAME_DEF_STMT (res))->depth\n-\t\t  > def_loop->depth)))\n+\t      || (loop_depth (loop_containing_stmt (SSA_NAME_DEF_STMT (res)))\n+\t\t  > loop_depth (def_loop))))\n \t{\n \t  if (res == chrec)\n \t    res = loop_closed_phi_def (chrec);\n@@ -2966,7 +2966,8 @@ scev_const_prop (void)\n       tree_block_label (exit->dest);\n       bsi = bsi_after_labels (exit->dest);\n \n-      ex_loop = superloop_at_depth (loop, exit->dest->loop_father->depth + 1);\n+      ex_loop = superloop_at_depth (loop,\n+\t\t\t\t    loop_depth (exit->dest->loop_father) + 1);\n \n       for (phi = phi_nodes (exit->dest); phi; phi = next_phi)\n \t{"}, {"sha": "c3fb54245910ee60b4c2341b007a7aeae7809bd7", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -316,10 +316,10 @@ outermost_invariant_loop (tree def, struct loop *loop)\n \n   if (LIM_DATA (def_stmt) && LIM_DATA (def_stmt)->max_loop)\n     max_loop = find_common_loop (max_loop,\n-\t\t\t\t LIM_DATA (def_stmt)->max_loop->outer);\n+\t\t\t\t loop_outer (LIM_DATA (def_stmt)->max_loop));\n   if (max_loop == loop)\n     return NULL;\n-  max_loop = superloop_at_depth (loop, max_loop->depth + 1);\n+  max_loop = superloop_at_depth (loop, loop_depth (max_loop) + 1);\n \n   return max_loop;\n }\n@@ -525,7 +525,7 @@ set_level (tree stmt, struct loop *orig_loop, struct loop *level)\n   stmt_loop = find_common_loop (orig_loop, stmt_loop);\n   if (LIM_DATA (stmt) && LIM_DATA (stmt)->tgt_loop)\n     stmt_loop = find_common_loop (stmt_loop,\n-\t\t\t\t  LIM_DATA (stmt)->tgt_loop->outer);\n+\t\t\t\t  loop_outer (LIM_DATA (stmt)->tgt_loop));\n   if (flow_loop_nested_p (stmt_loop, level))\n     return;\n \n@@ -709,12 +709,12 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n   bool maybe_never = ALWAYS_EXECUTED_IN (bb) == NULL;\n   struct loop *outermost = ALWAYS_EXECUTED_IN (bb);\n \n-  if (!bb->loop_father->outer)\n+  if (!loop_outer (bb->loop_father))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Basic block %d (loop %d -- depth %d):\\n\\n\",\n-\t     bb->index, bb->loop_father->num, bb->loop_father->depth);\n+\t     bb->index, bb->loop_father->num, loop_depth (bb->loop_father));\n \n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n@@ -774,7 +774,7 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t{\n \t  print_generic_stmt_indented (dump_file, stmt, 0, 2);\n \t  fprintf (dump_file, \"  invariant up to level %d, cost %d.\\n\\n\",\n-\t\t   LIM_DATA (stmt)->max_loop->depth,\n+\t\t   loop_depth (LIM_DATA (stmt)->max_loop),\n \t\t   LIM_DATA (stmt)->cost);\n \t}\n \n@@ -815,7 +815,7 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n   tree stmt;\n   unsigned cost = 0;\n \n-  if (!bb->loop_father->outer)\n+  if (!loop_outer (bb->loop_father))\n     return;\n \n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); )"}, {"sha": "16b126dc4571a6a93c92e7333d131d608782ed46", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -244,7 +244,7 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,\n   def_loop = def_bb->loop_father;\n \n   /* If the definition is not inside loop, it is not interesting.  */\n-  if (!def_loop->outer)\n+  if (!loop_outer (def_loop))\n     return;\n \n   if (!use_blocks[ver])"}, {"sha": "fc501261591e3db214513ba66c6066eb1c22867f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba025a2c1ba2d4c6529d16b26218a1c52866b72/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=9ba025a2c1ba2d4c6529d16b26218a1c52866b72", "patch": "@@ -832,7 +832,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n     }\n \n   /* Generate new loop structure.  */\n-  new_loop = duplicate_loop (loop, loop->outer);\n+  new_loop = duplicate_loop (loop, loop_outer (loop));\n   if (!new_loop)\n     {\n       free (bbs);\n@@ -962,7 +962,7 @@ slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n   if (loop->inner\n       /* All loops have an outer scope; the only case loop->outer is NULL is for\n          the function itself.  */\n-      || !loop->outer\n+      || !loop_outer (loop)\n       || loop->num_nodes != 2\n       || !empty_block_p (loop->latch)\n       || !single_exit (loop)"}]}