{"sha": "90e4e4c58d96511359fcede8e00658953ae9faaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlNGU0YzU4ZDk2NTExMzU5ZmNlZGU4ZTAwNjU4OTUzYWU5ZmFhYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-01-09T02:31:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-01-09T02:31:40Z"}, "message": "re PR rtl-optimization/12441 (Can't spill register bug)\n\n        PR opt/12441\n        Revert: Sat Mar 30 14:08:55 CET 2002  Jan Hubicka  <jh@suse.cz>\n        * i386.c (aligned_operand): Be prepared for SUBREGed registers.\n        (ix86_decompose_address): Use REG_P instead of GET_CODE (...) == REG.\n        (ix86_address_cost): Be prepared for SUBREGed registers.\n        (legitimate_address_p): Accept SUBREGed registers.\n\nFrom-SVN: r75568", "tree": {"sha": "a50510c78d44fcb64dedd306b10fff24daf02feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50510c78d44fcb64dedd306b10fff24daf02feb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e4e4c58d96511359fcede8e00658953ae9faaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e4e4c58d96511359fcede8e00658953ae9faaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e4e4c58d96511359fcede8e00658953ae9faaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e4e4c58d96511359fcede8e00658953ae9faaa/comments", "author": null, "committer": null, "parents": [{"sha": "a6a5e4c91b3d1da707a3b07e12efdf380106b834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a5e4c91b3d1da707a3b07e12efdf380106b834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a5e4c91b3d1da707a3b07e12efdf380106b834"}], "stats": {"total": 45, "additions": 16, "deletions": 29}, "files": [{"sha": "208ee947d7cf14608cbac7a6117685a6d7eacb23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e4e4c58d96511359fcede8e00658953ae9faaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e4e4c58d96511359fcede8e00658953ae9faaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90e4e4c58d96511359fcede8e00658953ae9faaa", "patch": "@@ -1,3 +1,12 @@\n+2004-01-08  Richard Henderson  <rth@redhat.com>\n+\n+\tPR opt/12441\n+\tRevert: Sat Mar 30 14:08:55 CET 2002  Jan Hubicka  <jh@suse.cz>\n+        * i386.c (aligned_operand): Be prepared for SUBREGed registers.\n+        (ix86_decompose_address): Use REG_P instead of GET_CODE (...) == REG.\n+        (ix86_address_cost): Be prepared for SUBREGed registers.\n+        (legitimate_address_p): Accept SUBREGed registers.\n+\n 2004-01-08  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.in: Rename configure.in to configure.ac"}, {"sha": "709e6c25c357301c784eacc82260eb7d34bb6daf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e4e4c58d96511359fcede8e00658953ae9faaa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e4e4c58d96511359fcede8e00658953ae9faaa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=90e4e4c58d96511359fcede8e00658953ae9faaa", "patch": "@@ -4257,11 +4257,6 @@ aligned_operand (rtx op, enum machine_mode mode)\n   if (! ix86_decompose_address (op, &parts))\n     abort ();\n \n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n-    parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n-    parts.index = SUBREG_REG (parts.index);\n-\n   /* Look for some component that isn't known to be aligned.  */\n   if (parts.index)\n     {\n@@ -5480,7 +5475,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   int retval = 1;\n   enum ix86_address_seg seg = SEG_DEFAULT;\n \n-  if (REG_P (addr) || GET_CODE (addr) == SUBREG)\n+  if (GET_CODE (addr) == REG || GET_CODE (addr) == SUBREG)\n     base = addr;\n   else if (GET_CODE (addr) == PLUS)\n     {\n@@ -5632,11 +5627,6 @@ ix86_address_cost (rtx x)\n   if (!ix86_decompose_address (x, &parts))\n     abort ();\n \n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n-    parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n-    parts.index = SUBREG_REG (parts.index);\n-\n   /* More complex memory references are better.  */\n   if (parts.disp && parts.disp != const0_rtx)\n     cost--;\n@@ -5981,15 +5971,9 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \n   if (base)\n     {\n-      rtx reg;\n       reason_rtx = base;\n \n-      if (GET_CODE (base) == SUBREG)\n-\treg = SUBREG_REG (base);\n-      else\n-\treg = base;\n-\n-      if (GET_CODE (reg) != REG)\n+      if (GET_CODE (base) != REG)\n \t{\n \t  reason = \"base is not a register\";\n \t  goto report_error;\n@@ -6001,8 +5985,8 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (reg))\n-\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (reg)))\n+      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n+\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n \t{\n \t  reason = \"base is not valid\";\n \t  goto report_error;\n@@ -6017,15 +6001,9 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \n   if (index)\n     {\n-      rtx reg;\n       reason_rtx = index;\n \n-      if (GET_CODE (index) == SUBREG)\n-\treg = SUBREG_REG (index);\n-      else\n-\treg = index;\n-\n-      if (GET_CODE (reg) != REG)\n+      if (GET_CODE (index) != REG)\n \t{\n \t  reason = \"index is not a register\";\n \t  goto report_error;\n@@ -6037,8 +6015,8 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (reg))\n-\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (reg)))\n+      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (index))\n+\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (index)))\n \t{\n \t  reason = \"index is not valid\";\n \t  goto report_error;"}]}