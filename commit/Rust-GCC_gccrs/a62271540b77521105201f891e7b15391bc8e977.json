{"sha": "a62271540b77521105201f891e7b15391bc8e977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyMjcxNTQwYjc3NTIxMTA1MjAxZjg5MWU3YjE1MzkxYmM4ZTk3Nw==", "commit": {"author": {"name": "Kurt Garloff", "email": "garloff@suse.de", "date": "2002-04-27T18:59:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-27T18:59:40Z"}, "message": "tree-inline.c (inlinable_function_p): Improve heuristics by using a smoother function to cut down allowable inlinable...\n\n        * tree-inline.c (inlinable_function_p): Improve heuristics\n        by using a smoother function to cut down allowable inlinable size.\n        * param.def: Add parameters max-inline-insns-single,\n        max-inline-slope, min-inline-insns that determine the exact\n        shape of the above function.\n        * param.h: Likewise.\n\nFrom-SVN: r52832", "tree": {"sha": "44b746e8edff894622cc845061d0426f9996dee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44b746e8edff894622cc845061d0426f9996dee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a62271540b77521105201f891e7b15391bc8e977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62271540b77521105201f891e7b15391bc8e977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62271540b77521105201f891e7b15391bc8e977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62271540b77521105201f891e7b15391bc8e977/comments", "author": null, "committer": null, "parents": [{"sha": "c3a6afe78df226088609daacffd8a329a3a7ede7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a6afe78df226088609daacffd8a329a3a7ede7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a6afe78df226088609daacffd8a329a3a7ede7"}], "stats": {"total": 130, "additions": 110, "deletions": 20}, "files": [{"sha": "60324ffa73dfdc4be145611f712752efadfd2b4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62271540b77521105201f891e7b15391bc8e977/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62271540b77521105201f891e7b15391bc8e977/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a62271540b77521105201f891e7b15391bc8e977", "patch": "@@ -1,3 +1,12 @@\n+2002-04-27  Kurt Garloff <garloff@suse.de>\n+\n+\t* tree-inline.c (inlinable_function_p): Improve heuristics\n+\tby using a smoother function to cut down allowable inlinable size.\n+\t* param.def: Add parameters max-inline-insns-single,\n+\tmax-inline-slope, min-inline-insns that determine the exact\n+\tshape of the above function.\n+\t* param.h: Likewise.\n+\n 2002-04-26  Richard Henderson  <rth@redhat.com>\n \n \t* c-parse.in (malloced_yyss, malloced_yyvs): New.\n@@ -50,7 +59,7 @@\n \n 2002-04-26  Richard Henderson  <rth@redhat.com>\n \n-        * c-parse.in (yyoverflow): Revert.\n+\t* c-parse.in (yyoverflow): Revert.\n \n 2002-04-26  David Edelsohn  <edelsohn@gnu.org>\n \t    Richard Henderson  <rth@redhat.com>"}, {"sha": "2b2cfe67c4dc5dcd189cb09c85fc44bfb749633e", "filename": "gcc/params.def", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62271540b77521105201f891e7b15391bc8e977/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62271540b77521105201f891e7b15391bc8e977/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=a62271540b77521105201f891e7b15391bc8e977", "patch": "@@ -35,17 +35,71 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Be sure to add an entry to invoke.texi summarizing the parameter.  */\n \n-/* The maximum number of instructions accepted for inlining a\n-   function.  Increasing values mean more agressive inlining.\n-   This affects currently only functions explicitly marked as\n-   inline (or methods defined within the class definition for C++).\n-   The original default value of 10000 was arbitrary and caused\n-   significant compile-time performance regressions.  */\n+/* The single function inlining limit. This is the maximum size\n+   of a function counted in internal gcc instructions (not in\n+   real machine instructions) that is eligible for inlining\n+   by the tree inliner.\n+   The default value is 300.\n+   Only functions marked inline (or methods defined in the class\n+   definition for C++) are affected by this, unless you set the\n+   -finline-functions (included in -O3) compiler option.\n+   There are more restrictions to inlining: If inlined functions\n+   call other functions, the already inlined instructions are\n+   counted and once the recursive inline limit (see \n+   \"max-inline-insns\" parameter) is exceeded, the acceptable size\n+   gets decreased.  */\n+DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n+\t  \"max-inline-insns-single\",\n+\t  \"The maximum number of instructions in a single function eliglible for inlining\",\n+\t  300)\n+\n+/* The repeated inlining limit. After this number of instructions \n+   (in the internal gcc representation, not real machine instructions)\n+   got inlined by repeated inlining, gcc starts to decrease the maximum\n+   number of inlinable instructions in the tree inliner.\n+   This is done by a linear function, see \"max-inline-slope\" parameter.\n+   It is necessary in order to limit the compile-time resources, that \n+   could otherwise become very high.\n+   It is recommended to set this value to twice the value of the single\n+   function limit (set by the \"max-inline-insns-single\" parameter) or\n+   higher. The default value is 600.\n+   Higher values mean that more inlining is done, resulting in\n+   better performance of the code, at the expense of higher \n+   compile-time resource (time, memory) requirements and larger\n+   binaries.  \n+   This parameters also controls the maximum size of functions considered\n+   for inlining in the RTL inliner.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS,\n \t  \"max-inline-insns\",\n-\t  \"The maximum number of instructions in a function that is eligible for inlining\",\n+\t  \"The maximuem number of instructions by repeated inlining before gcc starts to throttle inlining\",\n \t  600)\n \n+/* After the repeated inline limit has been exceeded (see\n+   \"max-inline-insns\" parameter), a linear function is used to\n+   decrease the size of single functions eligible for inlining.\n+   The slope of this linear function is given the negative\n+   reciprocal value (-1/x) of this parameter. \n+   The default vlue is 32.\n+   This linear function is used until it falls below a minimum\n+   value specified by the \"min-inline-insns\" parameter.  */\n+DEFPARAM (PARAM_MAX_INLINE_SLOPE,\n+\t  \"max-inline-slope\",\n+\t  \"The slope of the linear funtion throttling inlining after the recursive inlining limit has been reached is given by the negative reciprocal value of this parameter\",\n+\t  32)\n+\n+/* When gcc has inlined so many instructions (by repeated\n+   inlining) that the throttling limits the inlining very much,\n+   inlining for very small functions is still desirable to\n+   achieve good runtime performance. The size of single functions \n+   (measured in gcc instructions) which will still be eligible for \n+   inlining then is given by this parameter. It defaults to 130.\n+   Only much later (after exceeding 128 times the recursive limit)\n+   inlining is cut down completely.  */\n+DEFPARAM (PARAM_MIN_INLINE_INSNS,\n+\t  \"min-inline-insns\",\n+\t  \"The number of instructions in a single functions still eligible to inlining after a lot recursive inlining\",\n+\t  130)\n+\n /* The maximum number of instructions to consider when looking for an\n    instruction to fill a delay slot.  If more than this arbitrary\n    number of instructions is searched, the time savings from filling"}, {"sha": "c4474e418ee4ed089e46282e6eef2bafd43003a1", "filename": "gcc/params.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62271540b77521105201f891e7b15391bc8e977/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62271540b77521105201f891e7b15391bc8e977/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=a62271540b77521105201f891e7b15391bc8e977", "patch": "@@ -84,8 +84,14 @@ typedef enum compiler_param\n   (compiler_params[(int) ENUM].value)\n   \n /* Macros for the various parameters.  */\n+#define MAX_INLINE_INSNS_SINGLE \\\n+  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)\n #define MAX_INLINE_INSNS \\\n   PARAM_VALUE (PARAM_MAX_INLINE_INSNS)\n+#define MAX_INLINE_SLOPE \\\n+  PARAM_VALUE (PARAM_MAX_INLINE_SLOPE)\n+#define MIN_INLINE_INSNS \\\n+  PARAM_VALUE (PARAM_MIN_INLINE_INSNS)\n #define MAX_DELAY_SLOT_INSN_SEARCH \\\n   PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n #define MAX_DELAY_SLOT_LIVE_SEARCH \\"}, {"sha": "1385e8389be3cd10912d67da882eac70e5dda044", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62271540b77521105201f891e7b15391bc8e977/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62271540b77521105201f891e7b15391bc8e977/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a62271540b77521105201f891e7b15391bc8e977", "patch": "@@ -668,6 +668,7 @@ inlinable_function_p (fn, id)\n      inline_data *id;\n {\n   int inlinable;\n+  int currfn_insns;\n \n   /* If we've already decided this function shouldn't be inlined,\n      there's no need to check again.  */\n@@ -676,6 +677,9 @@ inlinable_function_p (fn, id)\n \n   /* Assume it is not inlinable.  */\n   inlinable = 0;\n+       \n+  /* The number of instructions (estimated) of current function. */\n+  currfn_insns = DECL_NUM_STMTS (fn) * INSNS_PER_STMT;\n \n   /* If we're not inlining things, then nothing is inlinable.  */\n   if (! flag_inline_trees)\n@@ -689,10 +693,10 @@ inlinable_function_p (fn, id)\n   else if (! DECL_INLINE (fn))\n     ;\n   /* We can't inline functions that are too big.  Only allow a single\n-     function to eat up half of our budget.  Make special allowance\n-     for extern inline functions, though.  */\n+     function to be of MAX_INLINE_INSNS_SINGLE size.  Make special \n+     allowance for extern inline functions, though.  */\n   else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-\t   && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 2)\n+\t   && currfn_insns > MAX_INLINE_INSNS_SINGLE)\n     ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n      has refused to inline functions using alloca, or functions whose\n@@ -704,15 +708,31 @@ inlinable_function_p (fn, id)\n   /* Squirrel away the result so that we don't have to check again.  */\n   DECL_UNINLINABLE (fn) = ! inlinable;\n \n-  /* Even if this function is not itself too big to inline, it might\n-     be that we've done so much inlining already that we don't want to\n-     risk too much inlining any more and thus halve the acceptable\n-     size.  */\n+  /* In case we don't disregard the inlining limits and we basically\n+     can inline this function, investigate further. */\n   if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-      && ((DECL_NUM_STMTS (fn) + (id ? id->inlined_stmts : 0)) * INSNS_PER_STMT\n-\t  > MAX_INLINE_INSNS)\n-      && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 4)\n-    inlinable = 0;\n+      && inlinable)\n+    { \n+      int sum_insns = (id ? id->inlined_stmts : 0) * INSNS_PER_STMT\n+\t\t     + currfn_insns;\n+      /* In the extreme case that we have exceeded the recursive inlining\n+         limit by a huge factor (128), we just say no. Should not happen\n+         in real life. */\n+      if (sum_insns > MAX_INLINE_INSNS * 128)\n+\t inlinable = 0;\n+      /* If we did not hit the extreme limit, we use a linear function\n+         with slope -1/MAX_INLINE_SLOPE to exceedingly decrease the\n+         allowable size. We always allow a size of MIN_INLINE_INSNS\n+         though. */\n+      else if ((sum_insns > MAX_INLINE_INSNS)\n+\t       && (currfn_insns > MIN_INLINE_INSNS))\n+        {\n+\t  int max_curr = MAX_INLINE_INSNS_SINGLE\n+\t\t\t- (sum_insns - MAX_INLINE_INSNS) / MAX_INLINE_SLOPE;\n+\t  if (currfn_insns > max_curr)\n+\t    inlinable = 0;\n+\t}\n+    }\n \n   if (inlinable && (*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn))\n     inlinable = 0;\n@@ -968,7 +988,8 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Our function now has more statements than it did before.  */\n   DECL_NUM_STMTS (VARRAY_TREE (id->fns, 0)) += DECL_NUM_STMTS (fn);\n-  id->inlined_stmts += DECL_NUM_STMTS (fn);\n+  /* For accounting, subtract one for the saved call/ret. */\n+  id->inlined_stmts += DECL_NUM_STMTS (fn) - 1;\n \n   /* Recurse into the body of the just inlined function.  */\n   expand_calls_inline (inlined_body, id);"}]}