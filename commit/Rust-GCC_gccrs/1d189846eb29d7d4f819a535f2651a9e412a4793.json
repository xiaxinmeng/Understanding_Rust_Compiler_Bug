{"sha": "1d189846eb29d7d4f819a535f2651a9e412a4793", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQxODk4NDZlYjI5ZDdkNGY4MTlhNTM1ZjI2NTFhOWU0MTJhNDc5Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-11-18T18:01:00Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-11-18T18:01:00Z"}, "message": "i386.c (ix86_decompose_address): Use REG_P instead of ix86_address_subreg_operand.\n\n\t* config/i386/i386.c (ix86_decompose_address): Use REG_P instead of\n\tix86_address_subreg_operand.  Move subreg checks to\n\tix86_validate_address_register.  Move address override check to\n\tix86_legitimate_address_p.\n\t(ix86_validate_address_register): New function.\n\t(ix86_legitimate_address_p): Call ix86_validate_address_register\n\tto validate base and index registers.  Add address override check\n\tfrom ix86_decompose_address.\n\t(ix86_decompose_address): Remove.\n\nFrom-SVN: r204976", "tree": {"sha": "d7ca5dcb7d561704fe9d3b5c6829160db4dda762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7ca5dcb7d561704fe9d3b5c6829160db4dda762"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d189846eb29d7d4f819a535f2651a9e412a4793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d189846eb29d7d4f819a535f2651a9e412a4793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d189846eb29d7d4f819a535f2651a9e412a4793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d189846eb29d7d4f819a535f2651a9e412a4793/comments", "author": null, "committer": null, "parents": [{"sha": "f18578157dadbe06c19ac23c5bcb3dff242f4bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f18578157dadbe06c19ac23c5bcb3dff242f4bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f18578157dadbe06c19ac23c5bcb3dff242f4bec"}], "stats": {"total": 132, "additions": 73, "deletions": 59}, "files": [{"sha": "810197367443d7f8e203bc22e79b6fe6dac232b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d189846eb29d7d4f819a535f2651a9e412a4793/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d189846eb29d7d4f819a535f2651a9e412a4793/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d189846eb29d7d4f819a535f2651a9e412a4793", "patch": "@@ -1,3 +1,15 @@\n+2013-11-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Use REG_P instead of\n+\tix86_address_subreg_operand.  Move subreg checks to\n+\tix86_validate_address_register.  Move address override check to\n+\tix86_legitimate_address_p.\n+\t(ix86_validate_address_register): New function.\n+\t(ix86_legitimate_address_p): Call ix86_validate_address_register\n+\tto validate base and index registers.  Add address override check\n+\tfrom ix86_decompose_address.\n+\t(ix86_decompose_address): Remove.\n+\n 2013-11-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59125\n@@ -137,9 +149,8 @@\n \n 2013-11-18  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n-\t* gcc/config/ia64/ia64.c (ia64_split_tmode_move): Mark\n-\tload with `dead' flag if it kills address, not its\n-\tpost-increment.\n+\t* gcc/config/ia64/ia64.c (ia64_split_tmode_move): Mark load with\n+\t`dead' flag if it kills address, not its post-increment.\n \n 2013-11-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n@@ -173,7 +184,7 @@\n \t* config/arm/arm.c (arm_cortex_a53_tune): New.\n \t* config/arm/arm-cores.def (cortex-a53): Use cortex_a53 tuning struct.\n \n-2013-11-12 Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n+2013-11-12  Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n \n \t* config.gcc (i[34567]86-*-linux* | ...): Add bdver4.\n \t(case ${target}): Add bdver4.\n@@ -213,18 +224,17 @@\n \n \t* doc/md.texi (setmem, movstr): Update documentation.\n \t* builtins.c (determine_block_size): New function.\n-\t(expand_builtin_memcpy): Use it and pass it to\n-\temit_block_move_hints.\n+\t(expand_builtin_memcpy): Use it and pass it to emit_block_move_hints.\n \t(expand_builtin_memset_args): Use it and pass it to\n \tset_storage_via_setmem.\n-\t* expr.c (emit_block_move_via_movmem): Add min_size/max_size parameters;\n-\tupdate call to expander.\n+\t* expr.c (emit_block_move_via_movmem): Add min_size/max_size\n+\tparameters; update call to expander.\n \t(emit_block_move_hints): Add min_size/max_size parameters.\n \t(clear_storage_hints): Likewise.\n \t(set_storage_via_setmem): Likewise.\n \t(clear_storage): Update.\n \t* expr.h (emit_block_move_hints, clear_storage_hints,\n-\tset_storage_via_setmem): Update prototype.\n+\tset_storage_via_setmem): Update prototypes.\n \t* i386.c (ix86_expand_set_or_movmem): Add bounds; export.\n \t(ix86_expand_movmem, ix86_expand_setmem): Remove.\n \t(ix86_expand_movmem, ix86_expand_setmem): Remove."}, {"sha": "3fe3db07dbf6195564da967ab6ec6e7bc0b83b4a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d189846eb29d7d4f819a535f2651a9e412a4793/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d189846eb29d7d4f819a535f2651a9e412a4793/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1d189846eb29d7d4f819a535f2651a9e412a4793", "patch": "@@ -11869,27 +11869,6 @@ ix86_live_on_entry (bitmap regs)\n     }\n }\n \f\n-/* Determine if op is suitable SUBREG RTX for address.  */\n-\n-static bool\n-ix86_address_subreg_operand (rtx op)\n-{\n-  enum machine_mode mode;\n-\n-  if (!REG_P (op))\n-    return false;\n-\n-  mode = GET_MODE (op);\n-\n-  /* Don't allow SUBREGs that span more than a word.  It can lead to spill\n-     failures when the register is one word out of a two word structure.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-    return false;\n-\n-  /* Allow only SUBREGs of non-eliminable hard registers.  */\n-  return register_no_elim_operand (op, mode);\n-}\n-\n /* Extract the parts of an RTL expression that is a valid memory address\n    for an instruction.  Return 0 if the structure of the address is\n    grossly off.  Return -1 if the address contains ASHIFT, so it is not\n@@ -11946,7 +11925,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n     base = addr;\n   else if (GET_CODE (addr) == SUBREG)\n     {\n-      if (ix86_address_subreg_operand (SUBREG_REG (addr)))\n+      if (REG_P (SUBREG_REG (addr)))\n \tbase = addr;\n       else\n \treturn 0;\n@@ -12010,7 +11989,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t      break;\n \n \t    case SUBREG:\n-\t      if (!ix86_address_subreg_operand (SUBREG_REG (op)))\n+\t      if (!REG_P (SUBREG_REG (op)))\n \t\treturn 0;\n \t      /* FALLTHRU */\n \n@@ -12063,18 +12042,12 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       if (REG_P (index))\n \t;\n       else if (GET_CODE (index) == SUBREG\n-\t       && ix86_address_subreg_operand (SUBREG_REG (index)))\n+\t       && REG_P (SUBREG_REG (index)))\n \t;\n       else\n \treturn 0;\n     }\n \n-/* Address override works only on the (%reg) part of %fs:(%reg).  */\n-  if (seg != SEG_DEFAULT\n-      && ((base && GET_MODE (base) != word_mode)\n-\t  || (index && GET_MODE (index) != word_mode)))\n-    return 0;\n-\n   /* Extract the integral value of scale.  */\n   if (scale_rtx)\n     {\n@@ -12591,6 +12564,45 @@ ix86_legitimize_reload_address (rtx x,\n   return false;\n }\n \n+/* Determine if op is suitable RTX for an address register.\n+   Return naked register if a register or a register subreg is\n+   found, otherwise return NULL_RTX.  */\n+\n+static rtx\n+ix86_validate_address_register (rtx op)\n+{\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  /* Only SImode or DImode registers can form the address.  */\n+  if (mode != SImode && mode != DImode)\n+    return NULL_RTX;\n+\n+  if (REG_P (op))\n+    return op;\n+  else if (GET_CODE (op) == SUBREG)\n+    {\n+      rtx reg = SUBREG_REG (op);\n+\n+      if (!REG_P (reg))\n+\treturn NULL_RTX;\n+\n+      mode = GET_MODE (reg);\n+\n+      /* Don't allow SUBREGs that span more than a word.  It can\n+\t lead to spill failures when the register is one word out\n+\t of a two word structure.  */\n+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn NULL_RTX;\n+\n+      /* Allow only SUBREGs of non-eliminable hard registers.  */\n+      if (register_no_elim_operand (reg, mode))\n+\treturn reg;\n+    }\n+\n+  /* Op is not a register.  */\n+  return NULL_RTX;\n+}\n+\n /* Recognizes RTL expressions that are valid memory addresses for an\n    instruction.  The MODE argument is the machine mode for the MEM\n    expression that wants to use this address.\n@@ -12606,6 +12618,7 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   struct ix86_address parts;\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n+  enum ix86_address_seg seg;\n \n   if (ix86_decompose_address (addr, &parts) <= 0)\n     /* Decomposition failed.  */\n@@ -12615,21 +12628,14 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   index = parts.index;\n   disp = parts.disp;\n   scale = parts.scale;\n+  seg = parts.seg;\n \n   /* Validate base register.  */\n   if (base)\n     {\n-      rtx reg;\n+      rtx reg = ix86_validate_address_register (base);\n \n-      if (REG_P (base))\n-  \treg = base;\n-      else if (GET_CODE (base) == SUBREG && REG_P (SUBREG_REG (base)))\n-\treg = SUBREG_REG (base);\n-      else\n-\t/* Base is not a register.  */\n-\treturn false;\n-\n-      if (GET_MODE (base) != SImode && GET_MODE (base) != DImode)\n+      if (reg == NULL_RTX)\n \treturn false;\n \n       if ((strict && ! REG_OK_FOR_BASE_STRICT_P (reg))\n@@ -12641,17 +12647,9 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   /* Validate index register.  */\n   if (index)\n     {\n-      rtx reg;\n-\n-      if (REG_P (index))\n-  \treg = index;\n-      else if (GET_CODE (index) == SUBREG && REG_P (SUBREG_REG (index)))\n-\treg = SUBREG_REG (index);\n-      else\n-\t/* Index is not a register.  */\n-\treturn false;\n+      rtx reg = ix86_validate_address_register (index);\n \n-      if (GET_MODE (index) != SImode && GET_MODE (index) != DImode)\n+      if (reg == NULL_RTX)\n \treturn false;\n \n       if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (reg))\n@@ -12665,6 +12663,12 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n       && GET_MODE (base) != GET_MODE (index))\n     return false;\n \n+  /* Address override works only on the (%reg) part of %fs:(%reg).  */\n+  if (seg != SEG_DEFAULT\n+      && ((base && GET_MODE (base) != word_mode)\n+\t  || (index && GET_MODE (index) != word_mode)))\n+    return false;\n+\n   /* Validate scale factor.  */\n   if (scale != 1)\n     {"}]}