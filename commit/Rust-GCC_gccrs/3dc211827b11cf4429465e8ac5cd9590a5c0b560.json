{"sha": "3dc211827b11cf4429465e8ac5cd9590a5c0b560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjMjExODI3YjExY2Y0NDI5NDY1ZThhYzVjZDk1OTBhNWMwYjU2MA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2008-11-26T09:46:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-11-26T09:46:23Z"}, "message": "re PR tree-optimization/37869 (PTA results wrong for \"non-pointer\" variables)\n\n2008-11-25  Daniel Berlin  <dberlin@dberlin.org>\n\tRichard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/37869\n\t* tree-ssa-structalias.c (struct constraint_graph): Remove\n\tpt_used and number_incoming members.\n\t(build_pred_graph): Do not allocate them.\n\t(condense_visit): Do not use them.\n\t(label_visit): Likewise.\n\t(free_var_substitution_info): Do not free them.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r142213", "tree": {"sha": "ef0b716452a3ce458930760da82b1c853db49011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef0b716452a3ce458930760da82b1c853db49011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dc211827b11cf4429465e8ac5cd9590a5c0b560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc211827b11cf4429465e8ac5cd9590a5c0b560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dc211827b11cf4429465e8ac5cd9590a5c0b560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc211827b11cf4429465e8ac5cd9590a5c0b560/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1dbc1ae77ad4b55903d723266e4ecb18a4ff851a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dbc1ae77ad4b55903d723266e4ecb18a4ff851a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dbc1ae77ad4b55903d723266e4ecb18a4ff851a"}], "stats": {"total": 47, "additions": 13, "deletions": 34}, "files": [{"sha": "1d76afdf9d8e9064fb22ba665d336946ff58be89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc211827b11cf4429465e8ac5cd9590a5c0b560/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc211827b11cf4429465e8ac5cd9590a5c0b560/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dc211827b11cf4429465e8ac5cd9590a5c0b560", "patch": "@@ -1,3 +1,14 @@\n+2008-11-25  Daniel Berlin  <dberlin@dberlin.org>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/37869\n+\t* tree-ssa-structalias.c (struct constraint_graph): Remove\n+\tpt_used and number_incoming members.\n+\t(build_pred_graph): Do not allocate them.\n+\t(condense_visit): Do not use them.\n+\t(label_visit): Likewise.\n+\t(free_var_substitution_info): Do not free them.\n+\n 2008-11-25  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* doc/invoke.texi (ira-max-loops-num): Change semantics."}, {"sha": "5083ee5a32963a0161487265e949bc00561ad13a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc211827b11cf4429465e8ac5cd9590a5c0b560/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc211827b11cf4429465e8ac5cd9590a5c0b560/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=3dc211827b11cf4429465e8ac5cd9590a5c0b560", "patch": "@@ -506,16 +506,6 @@ struct constraint_graph\n      taken.  Used for variable substitution.  */\n   bitmap address_taken;\n \n-  /* True if points_to bitmap for this node is stored in the hash\n-     table.  */\n-  sbitmap pt_used;\n-\n-  /* Number of incoming edges remaining to be processed by pointer\n-     equivalence.\n-     Used for variable substitution.  */\n-  unsigned int *number_incoming;\n-\n-\n   /* Vector of complex constraints for each graph node.  Complex\n      constraints are those involving dereferences or offsets that are\n      not 0.  */\n@@ -1101,11 +1091,8 @@ build_pred_graph (void)\n   graph->points_to = XCNEWVEC (bitmap, graph->size);\n   graph->eq_rep = XNEWVEC (int, graph->size);\n   graph->direct_nodes = sbitmap_alloc (graph->size);\n-  graph->pt_used = sbitmap_alloc (graph->size);\n   graph->address_taken = BITMAP_ALLOC (&predbitmap_obstack);\n-  graph->number_incoming = XCNEWVEC (unsigned int, graph->size);\n   sbitmap_zero (graph->direct_nodes);\n-  sbitmap_zero (graph->pt_used);\n \n   for (j = 0; j < FIRST_REF_NODE; j++)\n     {\n@@ -2008,11 +1995,6 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t      bitmap_ior_into (graph->points_to[n],\n \t\t\t       graph->points_to[w]);\n \t    }\n-\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n-\t    {\n-\t      unsigned int rep = si->node_mapping[i];\n-\t      graph->number_incoming[rep]++;\n-\t    }\n \t}\n       SET_BIT (si->deleted, n);\n     }\n@@ -2041,21 +2023,10 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n       /* Skip unused edges  */\n       if (w == n || graph->pointer_label[w] == 0)\n-\t{\n-\t  graph->number_incoming[w]--;\n-\t  continue;\n-\t}\n+\tcontinue;\n+\n       if (graph->points_to[w])\n \tbitmap_ior_into(graph->points_to[n], graph->points_to[w]);\n-\n-      /* If all incoming edges to w have been processed and\n-\t graph->points_to[w] was not stored in the hash table, we can\n-\t free it.  */\n-      graph->number_incoming[w]--;\n-      if (!graph->number_incoming[w] && !TEST_BIT (graph->pt_used, w))\n-\t{\n-\t  BITMAP_FREE (graph->points_to[w]);\n-\t}\n     }\n   /* Indirect nodes get fresh variables.  */\n   if (!TEST_BIT (graph->direct_nodes, n))\n@@ -2067,7 +2038,6 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t\t\t\t\t       graph->points_to[n]);\n       if (!label)\n \t{\n-\t  SET_BIT (graph->pt_used, n);\n \t  label = pointer_equiv_class++;\n \t  equiv_class_add (pointer_equiv_class_table,\n \t\t\t   label, graph->points_to[n]);\n@@ -2193,10 +2163,8 @@ free_var_substitution_info (struct scc_info *si)\n   free (graph->loc_label);\n   free (graph->pointed_by);\n   free (graph->points_to);\n-  free (graph->number_incoming);\n   free (graph->eq_rep);\n   sbitmap_free (graph->direct_nodes);\n-  sbitmap_free (graph->pt_used);\n   htab_delete (pointer_equiv_class_table);\n   htab_delete (location_equiv_class_table);\n   bitmap_obstack_release (&iteration_obstack);"}]}