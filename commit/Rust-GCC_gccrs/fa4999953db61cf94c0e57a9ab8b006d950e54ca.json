{"sha": "fa4999953db61cf94c0e57a9ab8b006d950e54ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE0OTk5OTUzZGI2MWNmOTRjMGU1N2E5YWI4YjAwNmQ5NTBlNTRjYQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-11-13T12:38:04Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-11-13T12:38:04Z"}, "message": "GCN libgomp port\n\n2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\tinclude/\n\t* gomp-constants.h (GOMP_DEVICE_GCN): Define.\n\t(GOMP_VERSION_GCN): Define.\n\n\tlibgomp/\n\t* Makefile.am (libgomp_la_SOURCES): Add oacc-target.c.\n\t* Makefile.in: Regenerate.\n\t* config.h.in (PLUGIN_GCN): Add new undef.\n\t* config/accel/openacc.f90 (acc_device_gcn): New parameter.\n\t* config/gcn/affinity-fmt.c: New file.\n\t* config/gcn/bar.c: New file.\n\t* config/gcn/bar.h: New file.\n\t* config/gcn/doacross.h: New file.\n\t* config/gcn/icv-device.c: New file.\n\t* config/gcn/oacc-target.c: New file.\n\t* config/gcn/simple-bar.h: New file.\n\t* config/gcn/target.c: New file.\n\t* config/gcn/task.c: New file.\n\t* config/gcn/team.c: New file.\n\t* config/gcn/time.c: New file.\n\t* configure.ac: Add amdgcn*-*-*.\n\t* configure: Regenerate.\n\t* configure.tgt: Add amdgcn*-*-*.\n\t* libgomp-plugin.h (offload_target_type): Add OFFLOAD_TARGET_TYPE_GCN.\n\t* libgomp.h (gcn_thrs): Add amdgcn variant.\n\t(set_gcn_thrs): Likewise.\n\t(gomp_thread): Likewise.\n\t* oacc-int.h (goacc_thread): Likewise.\n\t* oacc-target.c: New file.\n\t* openacc.f90 (acc_device_gcn): New parameter.\n\t* openacc.h (acc_device_t): Add acc_device_gcn.\n\t* team.c (gomp_free_pool_helper): Add amdgcn support.\n\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r278135", "tree": {"sha": "67ef377eddd6913af99044788a7ca23e7ee8c19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67ef377eddd6913af99044788a7ca23e7ee8c19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa4999953db61cf94c0e57a9ab8b006d950e54ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4999953db61cf94c0e57a9ab8b006d950e54ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4999953db61cf94c0e57a9ab8b006d950e54ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4999953db61cf94c0e57a9ab8b006d950e54ca/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2903ce05bf055daeafe14e8b0b2be133ce180be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2903ce05bf055daeafe14e8b0b2be133ce180be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2903ce05bf055daeafe14e8b0b2be133ce180be"}], "stats": {"total": 1132, "additions": 1125, "deletions": 7}, "files": [{"sha": "364fa72d457b00c0554663dfc0190b55adc3d2fb", "filename": "include/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -1,3 +1,11 @@\n+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* gomp-constants.h (GOMP_DEVICE_GCN): Define.\n+\t(GOMP_VERSION_GCN): Define.\n+\n 2019-08-08  Martin Liska  <mliska@suse.cz>\n \n \tPR bootstrap/91352"}, {"sha": "9e356cdfeec96ecc716210443c54f679747045aa", "filename": "include/gomp-constants.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -174,6 +174,7 @@ enum gomp_map_kind\n #define GOMP_DEVICE_NVIDIA_PTX\t\t5\n #define GOMP_DEVICE_INTEL_MIC\t\t6\n #define GOMP_DEVICE_HSA\t\t\t7\n+#define GOMP_DEVICE_GCN\t\t\t8\n \n #define GOMP_DEVICE_ICV\t\t\t-1\n #define GOMP_DEVICE_HOST_FALLBACK\t-2\n@@ -215,6 +216,7 @@ enum gomp_map_kind\n #define GOMP_VERSION_NVIDIA_PTX 1\n #define GOMP_VERSION_INTEL_MIC 0\n #define GOMP_VERSION_HSA 0\n+#define GOMP_VERSION_GCN 1\n \n #define GOMP_VERSION_PACK(LIB, DEV) (((LIB) << 16) | (DEV))\n #define GOMP_VERSION_LIB(PACK) (((PACK) >> 16) & 0xffff)"}, {"sha": "a7ce28f6dabcd9831423ff6c306c73222703bfc3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -1,3 +1,36 @@\n+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* Makefile.am (libgomp_la_SOURCES): Add oacc-target.c.\n+\t* Makefile.in: Regenerate.\n+\t* config.h.in (PLUGIN_GCN): Add new undef.\n+\t* config/accel/openacc.f90 (acc_device_gcn): New parameter.\n+\t* config/gcn/affinity-fmt.c: New file.\n+\t* config/gcn/bar.c: New file.\n+\t* config/gcn/bar.h: New file.\n+\t* config/gcn/doacross.h: New file.\n+\t* config/gcn/icv-device.c: New file.\n+\t* config/gcn/oacc-target.c: New file.\n+\t* config/gcn/simple-bar.h: New file.\n+\t* config/gcn/target.c: New file.\n+\t* config/gcn/task.c: New file.\n+\t* config/gcn/team.c: New file.\n+\t* config/gcn/time.c: New file.\n+\t* configure.ac: Add amdgcn*-*-*.\n+\t* configure: Regenerate.\n+\t* configure.tgt: Add amdgcn*-*-*.\n+\t* libgomp-plugin.h (offload_target_type): Add OFFLOAD_TARGET_TYPE_GCN.\n+\t* libgomp.h (gcn_thrs): Add amdgcn variant.\n+\t(set_gcn_thrs): Likewise.\n+\t(gomp_thread): Likewise.\n+\t* oacc-int.h (goacc_thread): Likewise.\n+\t* oacc-target.c: New file.\n+\t* openacc.f90 (acc_device_gcn): New parameter.\n+\t* openacc.h (acc_device_t): Add acc_device_gcn.\n+\t* team.c (gomp_free_pool_helper): Add amdgcn support.\n+\n 2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "669b9e4defdff24a37caaf4c90f5509c27b09e0d", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -65,7 +65,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c error.c \\\n \tproc.c sem.c bar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n \tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c oacc-init.c \\\n \toacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n-\taffinity-fmt.c teams.c oacc-profiling.c\n+\taffinity-fmt.c teams.c oacc-profiling.c oacc-target.c\n \n include $(top_srcdir)/plugin/Makefrag.am\n "}, {"sha": "d4185b35b503c24265ca1a7eda0a60a9e7e06290", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -217,7 +217,7 @@ am_libgomp_la_OBJECTS = alloc.lo atomic.lo barrier.lo critical.lo \\\n \ttarget.lo splay-tree.lo libgomp-plugin.lo oacc-parallel.lo \\\n \toacc-host.lo oacc-init.lo oacc-mem.lo oacc-async.lo \\\n \toacc-plugin.lo oacc-cuda.lo priority_queue.lo affinity-fmt.lo \\\n-\tteams.lo oacc-profiling.lo $(am__objects_1)\n+\tteams.lo oacc-profiling.lo oacc-target.lo $(am__objects_1)\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n@@ -552,7 +552,8 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n \taffinity.c target.c splay-tree.c libgomp-plugin.c \\\n \toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \\\n \toacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n-\taffinity-fmt.c teams.c oacc-profiling.c $(am__append_3)\n+\taffinity-fmt.c teams.c oacc-profiling.c oacc-target.c \\\n+\t$(am__append_3)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -755,6 +756,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-parallel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-profiling.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-target.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@"}, {"sha": "2d50fcd5c1a7a2bcd86b14858f90d66d29ce10fc", "filename": "libgomp/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -170,6 +170,9 @@\n /* Define to the version of this package. */\n #undef PACKAGE_VERSION\n \n+/* Define to 1 if the GCN plugin is built, 0 if not. */\n+#undef PLUGIN_GCN\n+\n /* Define to 1 if the HSA plugin is built, 0 if not. */\n #undef PLUGIN_HSA\n "}, {"sha": "6a8c5e9cb3db4a6a7d3ed0932677e0c0cf5fc374", "filename": "libgomp/config/accel/openacc.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Faccel%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Faccel%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Faccel%2Fopenacc.f90?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -51,6 +51,7 @@ module openacc_kinds\n   ! integer (acc_device_kind), parameter :: acc_device_host_nonshm = 3 removed.\n   integer (acc_device_kind), parameter :: acc_device_not_host = 4\n   integer (acc_device_kind), parameter :: acc_device_nvidia = 5\n+  integer (acc_device_kind), parameter :: acc_device_gcn = 8\n \n end module\n "}, {"sha": "3585f414460f3e5853c91c7ec4c6a3adc9a57360", "filename": "libgomp/config/gcn/affinity-fmt.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Faffinity-fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Faffinity-fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Faffinity-fmt.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgomp.h\"\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_INTTYPES_H\n+# include <inttypes.h>  /* For PRIx64.  */\n+#endif\n+#ifdef HAVE_UNAME\n+#include <sys/utsname.h>\n+#endif\n+\n+/* The HAVE_GETPID and HAVE_GETHOSTNAME configure tests are passing for nvptx,\n+   while the nvptx newlib implementation does not support those functions.\n+   Override the configure test results here.  */\n+#undef HAVE_GETPID\n+#undef HAVE_GETHOSTNAME\n+\n+/* The GCN newlib implementation does not support fwrite, but it does support\n+   write.  Map fwrite to write.  */\n+#undef fwrite\n+#define fwrite(ptr, size, nmemb, stream) write (1, (ptr), (nmemb) * (size))\n+\n+#include \"../../affinity-fmt.c\"\n+"}, {"sha": "fb709be26ce6499c257dfd936a8a535d53193b57", "filename": "libgomp/config/gcn/bar.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fbar.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,232 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an AMD GCN specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and s_barrier instruction.  It\n+   uses MEMMODEL_RELAXED here because barriers are within workgroups and\n+   therefore don't need to flush caches.  */\n+\n+#include <limits.h>\n+#include \"libgomp.h\"\n+\n+\n+void\n+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      bar->awaited = bar->total;\n+      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n+\t\t\tMEMMODEL_RELAXED);\n+    }\n+  asm (\"s_barrier\" ::: \"memory\");\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+/* Like gomp_barrier_wait, except that if the encountering thread\n+   is not the last one to hit the barrier, it returns immediately.\n+   The intended usage is that a thread which intends to gomp_barrier_destroy\n+   this barrier calls gomp_barrier_wait, while all other threads\n+   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,\n+   the barrier can be safely destroyed.  */\n+\n+void\n+gomp_barrier_wait_last (gomp_barrier_t *bar)\n+{\n+  /* Deferring to gomp_barrier_wait does not use the optimization opportunity\n+     allowed by the interface contract for all-but-last participants.  The\n+     original implementation in config/linux/bar.c handles this better.  */\n+  gomp_barrier_wait (bar);\n+}\n+\n+void\n+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n+{\n+  asm (\"s_barrier\" ::: \"memory\");\n+}\n+\n+void\n+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state &= ~BAR_CANCELLED;\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);\n+\t  asm (\"s_barrier\" ::: \"memory\");\n+\t  return;\n+\t}\n+    }\n+\n+  generation = state;\n+  state &= ~BAR_CANCELLED;\n+  int retry = 100;\n+  do\n+    {\n+      if (retry-- == 0)\n+\t{\n+\t  /* It really shouldn't happen that barriers get out of sync, but\n+\t     if they do then this will loop until they realign, so we need\n+\t     to avoid an infinite loop where the thread just isn't there.  */\n+\t  const char msg[] = (\"Barrier sync failed (another thread died?);\"\n+\t\t\t      \" aborting.\");\n+\t  write (2, msg, sizeof (msg)-1);\n+\t  abort();\n+\t}\n+\n+      asm (\"s_barrier\" ::: \"memory\");\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+}\n+\n+void\n+gomp_team_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    bar->awaited_final = bar->total;\n+  gomp_team_barrier_wait_end (bar, state);\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n+\t\t\t\t   gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      /* BAR_CANCELLED should never be set in state here, because\n+\t cancellation means that at least one of the threads has been\n+\t cancelled, thus on a cancellable barrier we should never see\n+\t all threads to arrive.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);\n+\t  asm (\"s_barrier\" ::: \"memory\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (__builtin_expect (state & BAR_CANCELLED, 0))\n+    return true;\n+\n+  generation = state;\n+  int retry = 100;\n+  do\n+    {\n+      if (retry-- == 0)\n+\t{\n+\t  /* It really shouldn't happen that barriers get out of sync, but\n+\t     if they do then this will loop until they realign, so we need\n+\t     to avoid an infinite loop where the thread just isn't there.  */\n+\t  const char msg[] = (\"Barrier sync failed (another thread died?);\"\n+\t\t\t      \" aborting.\");\n+\t  write (2, msg, sizeof (msg)-1);\n+\t  abort();\n+\t}\n+\n+      asm (\"s_barrier\" ::: \"memory\");\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);\n+      if (__builtin_expect (gen & BAR_CANCELLED, 0))\n+\treturn true;\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+\n+  return false;\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n+{\n+  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_cancel (struct gomp_team *team)\n+{\n+  gomp_mutex_lock (&team->task_lock);\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+  team->barrier.generation |= BAR_CANCELLED;\n+  gomp_mutex_unlock (&team->task_lock);\n+  gomp_team_barrier_wake (&team->barrier, INT_MAX);\n+}"}, {"sha": "ec8851ba07874ae34b6b2d953e6ba5cff7408fc5", "filename": "libgomp/config/gcn/bar.h", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fbar.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,168 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is an AMD GCN specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and s_barrier instruction.  It\n+   uses MEMMODEL_RELAXED here because barriers are within workgroups and\n+   therefore don't need to flush caches.  */\n+\n+#ifndef GOMP_BARRIER_H\n+#define GOMP_BARRIER_H 1\n+\n+#include \"mutex.h\"\n+\n+typedef struct\n+{\n+  unsigned total;\n+  unsigned generation;\n+  unsigned awaited;\n+  unsigned awaited_final;\n+} gomp_barrier_t;\n+\n+typedef unsigned int gomp_barrier_state_t;\n+\n+/* The generation field contains a counter in the high bits, with a few\n+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can\n+   share space because WAS_LAST is never stored back to generation.  */\n+#define BAR_TASK_PENDING\t1\n+#define BAR_WAS_LAST\t\t1\n+#define BAR_WAITING_FOR_TASK\t2\n+#define BAR_CANCELLED\t\t4\n+#define BAR_INCR\t\t8\n+\n+static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n+{\n+  bar->total = count;\n+  bar->awaited = count;\n+  bar->awaited_final = count;\n+  bar->generation = 0;\n+}\n+\n+static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n+{\n+  __atomic_add_fetch (&bar->awaited, count - bar->total, MEMMODEL_RELAXED);\n+  bar->total = count;\n+}\n+\n+static inline void gomp_barrier_destroy (gomp_barrier_t *bar)\n+{\n+}\n+\n+extern void gomp_barrier_wait (gomp_barrier_t *);\n+extern void gomp_barrier_wait_last (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n+extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_final (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n+\t\t\t\t\tgomp_barrier_state_t);\n+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);\n+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,\n+\t\t\t\t\t       gomp_barrier_state_t);\n+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n+struct gomp_team;\n+extern void gomp_team_barrier_cancel (struct gomp_team *);\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* A memory barrier is needed before exiting from the various forms\n+     of gomp_barrier_wait, to satisfy OpenMP API version 3.1 section\n+     2.8.6 flush Construct, which says there is an implicit flush during\n+     a barrier region.  This is a convenient place to add the barrier,\n+     so we use MEMMODEL_ACQ_REL here rather than MEMMODEL_ACQUIRE.  */\n+  if (__atomic_add_fetch (&bar->awaited, -1, MEMMODEL_RELAXED) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)\n+{\n+  return gomp_barrier_wait_start (bar);\n+}\n+\n+/* This is like gomp_barrier_wait_start, except it decrements\n+   bar->awaited_final rather than bar->awaited and should be used\n+   for the gomp_team_end barrier only.  */\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_final_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* See above gomp_barrier_wait_start comment.  */\n+  if (__atomic_add_fetch (&bar->awaited_final, -1, MEMMODEL_RELAXED) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline bool\n+gomp_barrier_last_thread (gomp_barrier_state_t state)\n+{\n+  return state & BAR_WAS_LAST;\n+}\n+\n+/* All the inlines below must be called with team->task_lock\n+   held.  */\n+\n+static inline void\n+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation &= ~BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_WAITING_FOR_TASK;\n+}\n+\n+static inline bool\n+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;\n+}\n+\n+static inline bool\n+gomp_team_barrier_cancelled (gomp_barrier_t *bar)\n+{\n+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);\n+}\n+\n+static inline void\n+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  bar->generation = (state & -BAR_INCR) + BAR_INCR;\n+}\n+\n+#endif /* GOMP_BARRIER_H */"}, {"sha": "2bff18ae1a8c95b641dbe72a2f9a68629c375607", "filename": "libgomp/config/gcn/doacross.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fdoacross.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fdoacross.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fdoacross.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,58 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the AMD GCN implementation of doacross spinning.  */\n+\n+#ifndef GOMP_DOACROSS_H\n+#define GOMP_DOACROSS_H 1\n+\n+#include \"libgomp.h\"\n+\n+static inline int\n+cpu_relax (void)\n+{\n+  /* This can be implemented as just a memory barrier, but a sleep seems\n+     like it should allow the wavefront to yield (maybe?)\n+     Use the shortest possible sleep time of 1*64 cycles.  */\n+  asm volatile (\"s_sleep\\t1\" ::: \"memory\");\n+  return 0;\n+}\n+\n+static inline void doacross_spin (unsigned long *addr, unsigned long expected,\n+\t\t\t\t  unsigned long cur)\n+{\n+  /* Prevent compiler from optimizing based on bounds of containing object.  */\n+  asm (\"\" : \"+r\" (addr));\n+  do\n+    {\n+       /* An alternative implementation might use s_setprio to lower the\n+\t  priority temporarily, and then restore it after.  */\n+      int i = cpu_relax ();\n+      cur = addr[i];\n+    }\n+  while (cur <= expected);\n+}\n+\n+#endif /* GOMP_DOACROSS_H */"}, {"sha": "cbb9dfa11330302417f758c180f2a0ebd539d06d", "filename": "libgomp/config/gcn/icv-device.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ficv-device.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines OpenMP API entry points that accelerator targets are\n+   expected to replace.  */\n+\n+#include \"libgomp.h\"\n+\n+void\n+omp_set_default_device (int device_num __attribute__((unused)))\n+{\n+}\n+\n+int\n+omp_get_default_device (void)\n+{\n+  return 0;\n+}\n+\n+int\n+omp_get_num_devices (void)\n+{\n+  return 0;\n+}\n+\n+int\n+omp_get_num_teams (void)\n+{\n+  return gomp_num_teams_var + 1;\n+}\n+\n+int __attribute__ ((__optimize__ (\"O2\")))\n+omp_get_team_num (void)\n+{\n+  return __builtin_gcn_dim_pos (0);\n+}\n+\n+int\n+omp_is_initial_device (void)\n+{\n+  /* AMD GCN is an accelerator-only target.  */\n+  return 0;\n+}\n+\n+ialias (omp_set_default_device)\n+ialias (omp_get_default_device)\n+ialias (omp_get_num_devices)\n+ialias (omp_get_num_teams)\n+ialias (omp_get_team_num)\n+ialias (omp_is_initial_device)"}, {"sha": "bdcc9153d9652d83d3fa65e8928ddd7bf43a7c6b", "filename": "libgomp/config/gcn/oacc-target.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Foacc-target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Foacc-target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Foacc-target.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,31 @@\n+/* Oversized reductions lock variable\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Graphics.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* We use a global lock variable for reductions on objects larger than\n+   64 bits.  Until and unless proven that lock contention for\n+   different reductions is a problem, a single lock will suffice.  */\n+\n+unsigned volatile __reduction_lock = 0;"}, {"sha": "802e0f5c3017a8c23db77bd9b917c76a85f69a29", "filename": "libgomp/config/gcn/simple-bar.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fsimple-bar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fsimple-bar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fsimple-bar.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,61 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is a simplified barrier that is suitable for thread pool\n+   synchronizaton.  Only a subset of full barrier API (bar.h) is exposed.\n+   Here in the AMD GCN-specific implementation, we expect that thread pool\n+   corresponds to the wavefronts within a work group.  */\n+\n+#ifndef GOMP_SIMPLE_BARRIER_H\n+#define GOMP_SIMPLE_BARRIER_H 1\n+\n+/* AMD GCN has no use for this type.  */\n+typedef int gomp_simple_barrier_t;\n+\n+/* GCN barriers block all wavefronts, so the count is not interesting.  */\n+static inline void\n+gomp_simple_barrier_init (gomp_simple_barrier_t *bar, unsigned count)\n+{\n+}\n+\n+static inline void\n+gomp_simple_barrier_destroy (gomp_simple_barrier_t *bar)\n+{\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait (gomp_simple_barrier_t *bar)\n+{\n+  asm volatile (\"s_barrier\" ::: \"memory\");\n+}\n+\n+static inline void\n+gomp_simple_barrier_wait_last (gomp_simple_barrier_t *bar)\n+{\n+  /* GCN has no way to signal a barrier without waiting.  */\n+  asm volatile (\"s_barrier\" ::: \"memory\");\n+}\n+\n+#endif /* GOMP_SIMPLE_BARRIER_H */"}, {"sha": "db00551e695a609924c4fa7f57da8cfd982e78e2", "filename": "libgomp/config/gcn/target.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ftarget.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,67 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgomp.h\"\n+#include <limits.h>\n+\n+void\n+GOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n+{\n+  if (thread_limit)\n+    {\n+      struct gomp_task_icv *icv = gomp_icv (true);\n+      icv->thread_limit_var\n+\t= thread_limit > INT_MAX ? UINT_MAX : thread_limit;\n+    }\n+  unsigned int num_workgroups, workgroup_id;\n+  num_workgroups = __builtin_gcn_dim_size (0);\n+  workgroup_id = __builtin_gcn_dim_pos (0);\n+  if (!num_teams || num_teams >= num_workgroups)\n+    num_teams = num_workgroups;\n+  else if (workgroup_id >= num_teams)\n+    {\n+      gomp_free_thread (gcn_thrs ());\n+      exit (0);\n+    }\n+  gomp_num_teams_var = num_teams - 1;\n+}\n+\n+int\n+omp_pause_resource (omp_pause_resource_t kind, int device_num)\n+{\n+  (void) kind;\n+  (void) device_num;\n+  return -1;\n+}\n+\n+int\n+omp_pause_resource_all (omp_pause_resource_t kind)\n+{\n+  (void) kind;\n+  return -1;\n+}\n+\n+ialias (omp_pause_resource)\n+ialias (omp_pause_resource_all)"}, {"sha": "a13565034b6c3fc5bd3decc5d6358b1ac827e33d", "filename": "libgomp/config/gcn/task.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ftask.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,39 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file handles the maintainence of tasks in response to task\n+   creation and termination.  */\n+\n+#include \"libgomp.h\"\n+\n+/* AMD GCN is an accelerator-only target, so this should never be called.  */\n+\n+bool\n+gomp_target_task_fn (void *data)\n+{\n+  __builtin_unreachable ();\n+}\n+\n+#include \"../../task.c\""}, {"sha": "c566482bda25e13a327a2672727797c8dd354cef", "filename": "libgomp/config/gcn/team.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fteam.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,202 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file handles maintainance of threads on AMD GCN.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static void gomp_thread_start (struct gomp_thread_pool *);\n+\n+/* This externally visible function handles target region entry.  It\n+   sets up a per-team thread pool and transfers control by returning to\n+   the kernel in the master thread or gomp_thread_start in other threads.\n+\n+   The name of this function is part of the interface with the compiler: for\n+   each OpenMP kernel the compiler configures the stack, then calls here.\n+\n+   Likewise, gomp_gcn_exit_kernel is called during the kernel epilogue.  */\n+\n+void\n+gomp_gcn_enter_kernel (void)\n+{\n+  int threadid = __builtin_gcn_dim_pos (1);\n+\n+  if (threadid == 0)\n+    {\n+      int numthreads = __builtin_gcn_dim_size (1);\n+      int teamid = __builtin_gcn_dim_pos(0);\n+\n+      /* Set up the global state.\n+\t Every team will do this, but that should be harmless.  */\n+      gomp_global_icv.nthreads_var = 16;\n+      gomp_global_icv.thread_limit_var = numthreads;\n+      /* Starting additional threads is not supported.  */\n+      gomp_global_icv.dyn_var = true;\n+\n+      /* Allocate and initialize the team-local-storage data.  */\n+      struct gomp_thread *thrs = gomp_malloc_cleared (sizeof (*thrs)\n+\t\t\t\t\t\t      * numthreads);\n+      set_gcn_thrs (thrs);\n+\n+      /* Allocate and initailize a pool of threads in the team.\n+         The threads are already running, of course, we just need to manage\n+         the communication between them.  */\n+      struct gomp_thread_pool *pool = gomp_malloc (sizeof (*pool));\n+      pool->threads = gomp_malloc (sizeof (void *) * numthreads);\n+      for (int tid = 0; tid < numthreads; tid++)\n+\tpool->threads[tid] = &thrs[tid];\n+      pool->threads_size = numthreads;\n+      pool->threads_used = numthreads;\n+      pool->threads_busy = 1;\n+      pool->last_team = NULL;\n+      gomp_simple_barrier_init (&pool->threads_dock, numthreads);\n+      thrs->thread_pool = pool;\n+\n+      asm (\"s_barrier\" ::: \"memory\");\n+      return;  /* Return to kernel.  */\n+    }\n+  else\n+    {\n+      asm (\"s_barrier\" ::: \"memory\");\n+      gomp_thread_start (gcn_thrs ()[0].thread_pool);\n+      /* gomp_thread_start does not return.  */\n+    }\n+}\n+\n+void\n+gomp_gcn_exit_kernel (void)\n+{\n+  gomp_free_thread (gcn_thrs ());\n+  free (gcn_thrs ());\n+}\n+\n+/* This function contains the idle loop in which a thread waits\n+   to be called up to become part of a team.  */\n+\n+static void\n+gomp_thread_start (struct gomp_thread_pool *pool)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  gomp_sem_init (&thr->release, 0);\n+  thr->thread_pool = pool;\n+\n+  /* The loop exits only when \"fn\" is assigned \"gomp_free_pool_helper\",\n+     which contains \"s_endpgm\", or an infinite no-op loop is\n+     suspected (this happens when the thread master crashes).  */\n+  int nul_limit = 99;\n+  do\n+    {\n+      gomp_simple_barrier_wait (&pool->threads_dock);\n+      if (!thr->fn)\n+\t{\n+\t  if (nul_limit-- > 0)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      const char msg[] = (\"team master not responding;\"\n+\t\t\t\t  \" slave thread aborting\");\n+\t      write (2, msg, sizeof (msg)-1);\n+\t      abort();\n+\t    }\n+\t}\n+      thr->fn (thr->data);\n+      thr->fn = NULL;\n+\n+      struct gomp_task *task = thr->task;\n+      gomp_team_barrier_wait_final (&thr->ts.team->barrier);\n+      gomp_finish_task (task);\n+    }\n+  while (1);\n+}\n+\n+/* Launch a team.  */\n+\n+void\n+gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n+\t\t unsigned flags, struct gomp_team *team,\n+\t\t struct gomp_taskgroup *taskgroup)\n+{\n+  struct gomp_thread *thr, *nthr;\n+  struct gomp_task *task;\n+  struct gomp_task_icv *icv;\n+  struct gomp_thread_pool *pool;\n+  unsigned long nthreads_var;\n+\n+  thr = gomp_thread ();\n+  pool = thr->thread_pool;\n+  task = thr->task;\n+  icv = task ? &task->icv : &gomp_global_icv;\n+\n+  /* Always save the previous state, even if this isn't a nested team.\n+     In particular, we should save any work share state from an outer\n+     orphaned work share construct.  */\n+  team->prev_ts = thr->ts;\n+\n+  thr->ts.team = team;\n+  thr->ts.team_id = 0;\n+  ++thr->ts.level;\n+  if (nthreads > 1)\n+    ++thr->ts.active_level;\n+  thr->ts.work_share = &team->work_shares[0];\n+  thr->ts.last_work_share = NULL;\n+  thr->ts.single_count = 0;\n+  thr->ts.static_trip = 0;\n+  thr->task = &team->implicit_task[0];\n+  nthreads_var = icv->nthreads_var;\n+  gomp_init_task (thr->task, task, icv);\n+  team->implicit_task[0].icv.nthreads_var = nthreads_var;\n+  team->implicit_task[0].taskgroup = taskgroup;\n+\n+  if (nthreads == 1)\n+    return;\n+\n+  /* Release existing idle threads.  */\n+  for (unsigned i = 1; i < nthreads; ++i)\n+    {\n+      nthr = pool->threads[i];\n+      nthr->ts.team = team;\n+      nthr->ts.work_share = &team->work_shares[0];\n+      nthr->ts.last_work_share = NULL;\n+      nthr->ts.team_id = i;\n+      nthr->ts.level = team->prev_ts.level + 1;\n+      nthr->ts.active_level = thr->ts.active_level;\n+      nthr->ts.single_count = 0;\n+      nthr->ts.static_trip = 0;\n+      nthr->task = &team->implicit_task[i];\n+      gomp_init_task (nthr->task, task, icv);\n+      team->implicit_task[i].icv.nthreads_var = nthreads_var;\n+      team->implicit_task[i].taskgroup = taskgroup;\n+      nthr->fn = fn;\n+      nthr->data = data;\n+      team->ordered_release[i] = &nthr->release;\n+    }\n+\n+  gomp_simple_barrier_wait (&pool->threads_dock);\n+}\n+\n+#include \"../../team.c\""}, {"sha": "f189e55889c406383deea505bfa66327157a832e", "filename": "libgomp/config/gcn/time.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfig%2Fgcn%2Ftime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ftime.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1,52 @@\n+/* Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements timer routines for AMD GCN.  */\n+\n+#include \"libgomp.h\"\n+\n+/* According to AMD:\n+    dGPU RTC is 27MHz\n+    AGPU RTC is 100MHz\n+   FIXME: DTRT on an APU.  */\n+#define RTC_TICKS (1.0 / 27000000.0) /* 27MHz */\n+\n+double\n+omp_get_wtime (void)\n+{\n+  uint64_t clock;\n+  asm (\"s_memrealtime %0\\n\\t\"\n+       \"s_waitcnt 0\" : \"=r\" (clock));\n+  return clock * RTC_TICKS;\n+}\n+\n+double\n+omp_get_wtick (void)\n+{\n+  return RTC_TICKS;\n+}\n+\n+ialias (omp_get_wtime)\n+ialias (omp_get_wtick)"}, {"sha": "6a9ccc1f17357820490b4a09dfbde456d276d916", "filename": "libgomp/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -14921,7 +14921,7 @@ case \"$host\" in\n   *-*-rtems*)\n     # RTEMS supports Pthreads, but the library is not available at GCC build time.\n     ;;\n-  nvptx*-*-*)\n+  nvptx*-*-* | amdgcn*-*-*)\n     # NVPTX does not support Pthreads, has its own code replacement.\n     libgomp_use_pthreads=no\n     # NVPTX is an accelerator-only target"}, {"sha": "725f3bfd285a9f8f076dd76694b2cd540efa0fdb", "filename": "libgomp/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -176,7 +176,7 @@ case \"$host\" in\n   *-*-rtems*)\n     # RTEMS supports Pthreads, but the library is not available at GCC build time.\n     ;;\n-  nvptx*-*-*)\n+  nvptx*-*-* | amdgcn*-*-*)\n     # NVPTX does not support Pthreads, has its own code replacement.\n     libgomp_use_pthreads=no\n     # NVPTX is an accelerator-only target"}, {"sha": "06ee115ece92581d2e288a156e902a7a75abd1ed", "filename": "libgomp/configure.tgt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -164,6 +164,10 @@ case \"${target}\" in\n \tfi\n \t;;\n \n+  amdgcn*-*-*)\n+\tconfig_path=\"gcn accel\"\n+\t;;\n+\n   *)\n \t;;\n "}, {"sha": "037558c43f5641dbf7492b8c53afe711e8c9ea95", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -50,7 +50,8 @@ enum offload_target_type\n   /* OFFLOAD_TARGET_TYPE_HOST_NONSHM = 3 removed.  */\n   OFFLOAD_TARGET_TYPE_NVIDIA_PTX = 5,\n   OFFLOAD_TARGET_TYPE_INTEL_MIC = 6,\n-  OFFLOAD_TARGET_TYPE_HSA = 7\n+  OFFLOAD_TARGET_TYPE_HSA = 7,\n+  OFFLOAD_TARGET_TYPE_GCN = 8\n };\n \n /* Opaque type to represent plugin-dependent implementation of an"}, {"sha": "19e1241ee4c7023f6800a95129c63efb540f8209", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -692,6 +692,24 @@ static inline struct gomp_thread *gomp_thread (void)\n   asm (\"mov.u32 %0, %%tid.y;\" : \"=r\" (tid));\n   return nvptx_thrs + tid;\n }\n+#elif defined __AMDGCN__\n+static inline struct gomp_thread *gcn_thrs (void)\n+{\n+  /* The value is at the bottom of LDS.  */\n+  struct gomp_thread * __lds *thrs = (struct gomp_thread * __lds *)4;\n+  return *thrs;\n+}\n+static inline void set_gcn_thrs (struct gomp_thread *val)\n+{\n+  /* The value is at the bottom of LDS.  */\n+  struct gomp_thread * __lds *thrs = (struct gomp_thread * __lds *)4;\n+  *thrs = val;\n+}\n+static inline struct gomp_thread *gomp_thread (void)\n+{\n+  int tid = __builtin_gcn_dim_pos(1);\n+  return gcn_thrs () + tid;\n+}\n #elif defined HAVE_TLS || defined USE_EMUTLS\n extern __thread struct gomp_thread gomp_tls_data;\n static inline struct gomp_thread *gomp_thread (void)"}, {"sha": "9dc6c8a57139525d795087e02616be88b8c6f309", "filename": "libgomp/oacc-int.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Foacc-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Foacc-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-int.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -82,7 +82,14 @@ struct goacc_thread\n   void *target_tls;\n };\n \n-#if defined HAVE_TLS || defined USE_EMUTLS\n+#ifdef __AMDGCN__\n+static inline struct goacc_thread *\n+goacc_thread (void)\n+{\n+  /* Unused in the offload libgomp for OpenACC: return a dummy value.  */\n+  return 0;\n+}\n+#elif defined HAVE_TLS || defined USE_EMUTLS\n extern __thread struct goacc_thread *goacc_tls_data;\n static inline struct goacc_thread *\n goacc_thread (void)"}, {"sha": "f2e798990304bd9ee3c10559349edde40f7629bf", "filename": "libgomp/oacc-target.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Foacc-target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Foacc-target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-target.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -0,0 +1 @@\n+/* Nothing needed here.  */"}, {"sha": "831a157e703df3a043c1d91c8e700902677266fe", "filename": "libgomp/openacc.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.f90?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -46,6 +46,7 @@ module openacc_kinds\n   ! integer (acc_device_kind), parameter :: acc_device_host_nonshm = 3 removed.\n   integer (acc_device_kind), parameter :: acc_device_not_host = 4\n   integer (acc_device_kind), parameter :: acc_device_nvidia = 5\n+  integer (acc_device_kind), parameter :: acc_device_gcn = 8\n \n   public :: acc_handle_kind\n "}, {"sha": "42c861caabf7ddfbced8b8978e5bfa7439336d2d", "filename": "libgomp/openacc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fopenacc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fopenacc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.h?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -55,6 +55,7 @@ typedef enum acc_device_t {\n   /* acc_device_host_nonshm = 3 removed.  */\n   acc_device_not_host = 4,\n   acc_device_nvidia = 5,\n+  acc_device_gcn = 8,\n   _ACC_device_hwm,\n   /* Ensure enumeration is layout compatible with int.  */\n   _ACC_highest = __INT_MAX__,"}, {"sha": "b26caaaaec6874d7bd4351ddae3e5607e684994c", "filename": "libgomp/team.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa4999953db61cf94c0e57a9ab8b006d950e54ca/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=fa4999953db61cf94c0e57a9ab8b006d950e54ca", "patch": "@@ -239,6 +239,9 @@ gomp_free_pool_helper (void *thread_pool)\n   pthread_exit (NULL);\n #elif defined(__nvptx__)\n   asm (\"exit;\");\n+#elif defined(__AMDGCN__)\n+  asm (\"s_dcache_wb\\n\\t\"\n+       \"s_endpgm\");\n #else\n #error gomp_free_pool_helper must terminate the thread\n #endif"}]}