{"sha": "a946dd00743b24b4ac24ed1f5d39df34bc263964", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0NmRkMDA3NDNiMjRiNGFjMjRlZDFmNWQzOWRmMzRiYzI2Mzk2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-13T10:05:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T10:05:56Z"}, "message": "i386.h (VALID_FP_MODE_P, [...]): New.\n\n\n\t* i386.h (VALID_FP_MODE_P, VALID_INT_MODE_P): New.\n\t(HARD_REGNO_MODE_OK): Move offline to ....\n\t* i386.c (ix86_hard_regno_mode_ok) ... here;\n\trefuse all incorrect modes.\n\t* i386-protos.h (ix86_hard_regno_mode_ok): Declare.\n\nFrom-SVN: r39621", "tree": {"sha": "04682f946d515d8096bcf94e039ad47b025b99f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04682f946d515d8096bcf94e039ad47b025b99f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a946dd00743b24b4ac24ed1f5d39df34bc263964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a946dd00743b24b4ac24ed1f5d39df34bc263964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a946dd00743b24b4ac24ed1f5d39df34bc263964", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a946dd00743b24b4ac24ed1f5d39df34bc263964/comments", "author": null, "committer": null, "parents": [{"sha": "1b9ea8eb1a5e831e8c3d474aedc8f9996306d14e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9ea8eb1a5e831e8c3d474aedc8f9996306d14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9ea8eb1a5e831e8c3d474aedc8f9996306d14e"}], "stats": {"total": 75, "additions": 54, "deletions": 21}, "files": [{"sha": "aac7623b7c11fc3a4385ecf753cd33806cae140a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a946dd00743b24b4ac24ed1f5d39df34bc263964", "patch": "@@ -1,3 +1,11 @@\n+Die Feb 13 11:04:25 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (VALID_FP_MODE_P, VALID_INT_MODE_P): New.\n+\t(HARD_REGNO_MODE_OK): Move offline to ....\n+\t* i386.c (ix86_hard_regno_mode_ok) ... here;\n+\trefuse all incorrect modes.\n+\t* i386-protos.h (ix86_hard_regno_mode_ok): Declare.\n+\n 2001-02-13  Richard Henderson  <rth@redhat.com>\n \n \t* sparc.md (cmp_cc_arith_op_set): Don't use match_dup on the"}, {"sha": "57fdaa417b5574ce475a9793e135cf0acf7ffc82", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=a946dd00743b24b4ac24ed1f5d39df34bc263964", "patch": "@@ -131,6 +131,7 @@ extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n extern void ix86_split_fp_branch PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));\n+extern int ix86_hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n \n #ifdef TREE_CODE\n extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));"}, {"sha": "683c8817b3da04f10c420bb02e1f6ff9567c30ea", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a946dd00743b24b4ac24ed1f5d39df34bc263964", "patch": "@@ -8724,3 +8724,33 @@ ix86_free_from_memory (mode)\n \t\t\t\t\t\t ? 2\n \t\t\t\t\t\t : 4))));\n }\n+\n+/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+int\n+ix86_hard_regno_mode_ok (regno, mode)\n+     int regno;\n+     enum machine_mode mode;\n+{\n+  /* Flags and only flags can only hold CCmode values.  */\n+  if (CC_REGNO_P (regno))\n+    return GET_MODE_CLASS (mode) == MODE_CC;\n+  if (GET_MODE_CLASS (mode) == MODE_CC\n+      || GET_MODE_CLASS (mode) == MODE_RANDOM\n+      || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+    return 0;\n+  if (FP_REGNO_P (regno))\n+    return VALID_FP_MODE_P (mode);\n+  if (SSE_REGNO_P (regno))\n+    return VALID_SSE_REG_MODE (mode);\n+  if (MMX_REGNO_P (regno))\n+    return VALID_MMX_REG_MODE (mode);\n+  /* We handle both integer and floats in the general purpose registers.\n+     In future we should be able to handle vector modes as well.  */\n+  if (!VALID_INT_MODE_P (mode) && !VALID_FP_MODE_P (mode))\n+    return 0;\n+  /* Take care for QImode values - they can be in non-QI regs, but then\n+     they do cause partial register stalls.  */\n+  if (QI_REG_P (regno) || mode != QImode)\n+    return 1;\n+  return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n+}"}, {"sha": "162da52ff14b99efb9ff9fad553412f350fe9930", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a946dd00743b24b4ac24ed1f5d39df34bc263964", "patch": "@@ -775,28 +775,22 @@ extern int ix86_arch;\n     (VALID_SSE_REG_MODE (MODE) && TARGET_SSE ? 1\t\t\t\\\n      : VALID_MMX_REG_MODE (MODE) && TARGET_MMX ? 1 : 0)\n \n+#define VALID_FP_MODE_P(mode) \\\n+    ((mode) == SFmode || (mode) == DFmode || (mode) == TFmode\t\\\n+     || (mode) == XFmode\t\t\t\t\t\\\n+     || (mode) == SCmode || (mode) == DCmode || (mode) == TCmode\\\n+     || (mode) == XCmode)\n+\n+#define VALID_INT_MODE_P(mode) \\\n+    ((mode) == QImode || (mode) == HImode || (mode) == SImode\t\\\n+     || (mode) == DImode\t\t\t\t\t\\\n+     || (mode) == CQImode || (mode) == CHImode || (mode) == CSImode \\\n+     || (mode) == CDImode)\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n-  /* Flags and only flags can only hold CCmode values.  */\t\\\n-  (CC_REGNO_P (REGNO)\t\t\t\t\t\t\\\n-   ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\t\t\\\n-   : GET_MODE_CLASS (MODE) == MODE_CC ? 0\t\t\t\\\n-   /* FP regs can only hold floating point; make it clear they\t\\\n-      cannot hold TFmode floats.  */\t\t\t\t\\\n-   : FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n-   ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n-      && GET_MODE_UNIT_SIZE (MODE) <= 16)\\\n-   : SSE_REGNO_P (REGNO) ? VALID_SSE_REG_MODE (MODE)\t\t\\\n-   : MMX_REGNO_P (REGNO) ? VALID_MMX_REG_MODE (MODE)\t\t\\\n-   /* Only SSE and MMX regs can hold vector modes.  */\t\t\\\n-   : VECTOR_MODE_P (MODE) || (MODE) == TImode ? 0\t\t\\\n-   : (REGNO) < 4 ? 1\t\t\t\t\t\t\\\n-   /* Other regs cannot do byte accesses.  */\t\t\t\\\n-   : (MODE) != QImode ? 1\t\t\t\t\t\\\n-   : reload_in_progress || reload_completed\t\t\t\\\n-     || !TARGET_PARTIAL_REG_STALL)\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n+   ix86_hard_regno_mode_ok (REGNO, MODE)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2."}, {"sha": "2fa46112e2612062434895994e736337990f03cd", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a946dd00743b24b4ac24ed1f5d39df34bc263964/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=a946dd00743b24b4ac24ed1f5d39df34bc263964", "patch": "@@ -1571,7 +1571,7 @@ esac\n \n \n # Find some useful tools\n-for ac_prog in gawk mawk nawk awk\n+for ac_prog in mawk gawk nawk awk\n do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2"}]}