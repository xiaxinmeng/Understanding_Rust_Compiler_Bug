{"sha": "73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhMmI4ZGQxN2RiYzAyYzBjN2U2Mjg2ZTkwZjE3ODMzYWE1MDkwNg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-08-13T18:56:13Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-08-31T20:09:10Z"}, "message": "c++: Implement P1009: Array size deduction in new-expressions.\n\nThis patch implements C++20 P1009, allowing code like\n\n  new double[]{1,2,3}; // array bound will be deduced\n\nSince this proposal makes the initialization rules more consistent, it is\napplied to all previous versions of C++ (thus, effectively, all the way back\nto C++11).\n\nMy patch is based on Jason's patch that handled the basic case.  I've\nextended it to work with ()-init and also the string literal case.\nFurther testing revealed that to handle stuff like\n\n  new int[]{t...};\n\nin a template, we have to consider such a NEW_EXPR type-dependent.\nObviously, we first have to expand the pack to be able to deduce the\nnumber of elements in the array.\n\nCuriously, while implementing this proposal, I noticed that we fail\nto accept\n\n  new char[4]{\"abc\"};\n\nso I've assigned 77841 to self.  I think the fix will depend on the\nbuild_new_1 hunk in this patch.\n\nThe new tree.c function build_constructor_from_vec helps us morph\na vector into a CONSTRUCTOR more efficiently.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/93529\n\t* call.c (build_new_method_call_1): Use build_constructor_from_vec\n\tinstead of build_tree_list_vec + build_constructor_from_list.\n\t* init.c (build_new_1): Handle new char[]{\"foo\"}.  Use\n\tbuild_constructor_from_vec instead of build_tree_list_vec +\n\tbuild_constructor_from_list.\n\t(build_new): Deduce the array size in new-expression if not\n\tpresent.  Handle ()-init.  Handle initializing an array from\n\ta string literal.\n\t* parser.c (cp_parser_new_type_id): Leave [] alone.\n\t(cp_parser_direct_new_declarator): Allow [].\n\t* pt.c (type_dependent_expression_p): In a NEW_EXPR, consider\n\tarray types whose dimension has to be deduced type-dependent.\n\ngcc/ChangeLog:\n\n\tPR c++/93529\n\t* tree.c (build_constructor_from_vec): New.\n\t* tree.h (build_constructor_from_vec): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/93529\n\t* g++.dg/cpp0x/sfinae4.C: Adjust expected result after P1009.\n\t* g++.dg/cpp2a/new-array1.C: New test.\n\t* g++.dg/cpp2a/new-array2.C: New test.\n\t* g++.dg/cpp2a/new-array3.C: New test.\n\t* g++.dg/cpp2a/new-array4.C: New test.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "9585c05c0faaa35dc21c0c1331a7681cd20ad9bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9585c05c0faaa35dc21c0c1331a7681cd20ad9bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2"}], "stats": {"total": 219, "additions": 209, "deletions": 10}, "files": [{"sha": "61bbb38bd2b9c5705dbe087816f0074741502902", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -10297,8 +10297,8 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t  && !vec_safe_is_empty (user_args))\n \t{\n \t  /* Create a CONSTRUCTOR from ARGS, e.g. {1, 2} from <1, 2>.  */\n-\t  tree list = build_tree_list_vec (user_args);\n-\t  tree ctor = build_constructor_from_list (init_list_type_node, list);\n+\t  tree ctor = build_constructor_from_vec (init_list_type_node,\n+\t\t\t\t\t\t  user_args);\n \t  CONSTRUCTOR_IS_DIRECT_INIT (ctor) = true;\n \t  CONSTRUCTOR_IS_PAREN_INIT (ctor) = true;\n \t  if (is_dummy_object (instance))"}, {"sha": "360ab8c0b52e5c11552237df8b769953457580fb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -3559,8 +3559,8 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       else if (array_p)\n \t{\n \t  tree vecinit = NULL_TREE;\n-\t  if (vec_safe_length (*init) == 1\n-\t      && DIRECT_LIST_INIT_P ((**init)[0]))\n+\t  const size_t len = vec_safe_length (*init);\n+\t  if (len == 1 && DIRECT_LIST_INIT_P ((**init)[0]))\n \t    {\n \t      vecinit = (**init)[0];\n \t      if (CONSTRUCTOR_NELTS (vecinit) == 0)\n@@ -3578,6 +3578,15 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t  vecinit = digest_init (arraytype, vecinit, complain);\n \t\t}\n \t    }\n+\t  /* This handles code like new char[]{\"foo\"}.  */\n+\t  else if (len == 1\n+\t\t   && char_type_p (TYPE_MAIN_VARIANT (type))\n+\t\t   && TREE_CODE (tree_strip_any_location_wrapper ((**init)[0]))\n+\t\t      == STRING_CST)\n+\t    {\n+\t      vecinit = (**init)[0];\n+\t      STRIP_ANY_LOCATION_WRAPPER (vecinit);\n+\t    }\n \t  else if (*init)\n             {\n               if (complain & tf_error)\n@@ -3634,8 +3643,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t  && AGGREGATE_TYPE_P (type)\n \t\t  && (*init)->length () > 1)\n \t\t{\n-\t\t  ie = build_tree_list_vec (*init);\n-\t\t  ie = build_constructor_from_list (init_list_type_node, ie);\n+\t\t  ie = build_constructor_from_vec (init_list_type_node, *init);\n \t\t  CONSTRUCTOR_IS_DIRECT_INIT (ie) = true;\n \t\t  CONSTRUCTOR_IS_PAREN_INIT (ie) = true;\n \t\t  ie = digest_init (type, ie, complain);\n@@ -3917,6 +3925,45 @@ build_new (location_t loc, vec<tree, va_gc> **placement, tree type,\n       return error_mark_node;\n     }\n \n+  /* P1009: Array size deduction in new-expressions.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && !TYPE_DOMAIN (type)\n+      && *init)\n+    {\n+      /* This means we have 'new T[]()'.  */\n+      if ((*init)->is_empty ())\n+\t{\n+\t  tree ctor = build_constructor (init_list_type_node, NULL);\n+\t  CONSTRUCTOR_IS_DIRECT_INIT (ctor) = true;\n+\t  vec_safe_push (*init, ctor);\n+\t}\n+      tree &elt = (**init)[0];\n+      /* The C++20 'new T[](e_0, ..., e_k)' case allowed by P0960.  */\n+      if (!DIRECT_LIST_INIT_P (elt) && cxx_dialect >= cxx20)\n+\t{\n+\t  /* Handle new char[](\"foo\").  */\n+\t  if (vec_safe_length (*init) == 1\n+\t      && char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+\t      && TREE_CODE (tree_strip_any_location_wrapper (elt))\n+\t\t == STRING_CST)\n+\t    /* Leave it alone: the string should not be wrapped in {}.  */;\n+\t  else\n+\t    {\n+\t      tree ctor = build_constructor_from_vec (init_list_type_node, *init);\n+\t      CONSTRUCTOR_IS_DIRECT_INIT (ctor) = true;\n+\t      CONSTRUCTOR_IS_PAREN_INIT (ctor) = true;\n+\t      elt = ctor;\n+\t      /* We've squashed all the vector elements into the first one;\n+\t\t truncate the rest.  */\n+\t      (*init)->truncate (1);\n+\t    }\n+\t}\n+      /* Otherwise we should have 'new T[]{e_0, ..., e_k}'.  */\n+      if (BRACE_ENCLOSED_INITIALIZER_P (elt))\n+\telt = reshape_init (type, elt, complain);\n+      cp_complete_array_type (&type, elt, /*do_default*/false);\n+    }\n+\n   /* The type allocated must be complete.  If the new-type-id was\n      \"T[N]\" then we are just checking that \"T\" is complete here, but\n      that is equivalent, since the value of \"N\" doesn't matter.  */"}, {"sha": "9849e59d5aa4a0aa06712e2568a903533035cf7b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -9011,7 +9011,9 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n       if (*nelts == error_mark_node)\n \t*nelts = integer_one_node;\n \n-      if (outer_declarator)\n+      if (*nelts == NULL_TREE)\n+\t/* Leave [] in the declarator.  */;\n+      else if (outer_declarator)\n \touter_declarator->declarator = declarator->declarator;\n       else\n \tnew_declarator = NULL;\n@@ -9072,6 +9074,7 @@ static cp_declarator *\n cp_parser_direct_new_declarator (cp_parser* parser)\n {\n   cp_declarator *declarator = NULL;\n+  bool first_p = true;\n \n   while (true)\n     {\n@@ -9082,14 +9085,17 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n \n       token = cp_lexer_peek_token (parser->lexer);\n-      expression = cp_parser_expression (parser);\n+      if (token->type == CPP_CLOSE_SQUARE && first_p)\n+\texpression = NULL_TREE;\n+      else\n+\texpression = cp_parser_expression (parser);\n       /* The standard requires that the expression have integral\n \t type.  DR 74 adds enumeration types.  We believe that the\n \t real intent is that these expressions be handled like the\n \t expression in a `switch' condition, which also allows\n \t classes with a single conversion to integral or\n \t enumeration type.  */\n-      if (!processing_template_decl)\n+      if (expression && !processing_template_decl)\n \t{\n \t  expression\n \t    = build_expr_type_conversion (WANT_INT | WANT_ENUM,\n@@ -9114,6 +9120,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t bounds.  */\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_SQUARE))\n \tbreak;\n+      first_p = false;\n     }\n \n   return declarator;"}, {"sha": "a7b7a12b59f3f4582056960a9c34a882ee0e3606", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -26872,6 +26872,10 @@ type_dependent_expression_p (tree expression)\n \treturn dependent_type_p (TREE_VALUE (TREE_PURPOSE (type)))\n \t       || value_dependent_expression_p\n \t\t    (TREE_OPERAND (TREE_VALUE (type), 1));\n+      /* Array type whose dimension has to be deduced.  */\n+      else if (TREE_CODE (type) == ARRAY_TYPE\n+\t       && TREE_OPERAND (expression, 2) == NULL_TREE)\n+\treturn true;\n       else\n \treturn dependent_type_p (type);\n     }"}, {"sha": "f271cf1df6a545055cc2cd1f01e36e632242688f", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae4.C", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -19,5 +19,11 @@ template<typename _Tp, typename... _Args>\n     static const bool value = sizeof(__test<_Tp, _Args...>(0)) == 1;\n   };\n \n-static_assert( !is_constructible_mini<int[], int>::value, \"\");\n+// int[](...) will work with P0960 and P1009.\n+#if __cpp_aggregate_paren_init\n+constexpr bool r = true;\n+#else\n+constexpr bool r = false;\n+#endif\n+static_assert( is_constructible_mini<int[], int>::value == r, \"\");\n static_assert( !is_constructible_mini<void, int>::value, \"\");"}, {"sha": "2353c3843595ade6f121753a62b9e7e07a1774a5", "filename": "gcc/testsuite/g++.dg/cpp2a/new-array1.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array1.C?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -0,0 +1,70 @@\n+// PR c++/93529\n+// P1009: Array size deduction in new-expressions\n+// { dg-do run { target c++11 } }\n+\n+// When the array bound is deduced to 0, malloc(0) returns\n+// a non-dereferenceable pointer.\n+int *p0 = new int[]{};\n+int *p1 = new int[]{ 1 };\n+int *p2 = new int[]{ 1, 2, 3 };\n+char *c1 = new char[]{\"foo\"};\n+#if __cpp_aggregate_paren_init\n+int *q0 = new int[]();\n+int *q1 = new int[](1);\n+int *q2 = new int[](1, 2, 3);\n+char *d1 = new char[](\"foo\");\n+char *d2 = new char[4](\"foo\");\n+char *d3 = new char[](((\"foo\")));\n+#endif\n+\n+struct Aggr { int a; int b; int c; };\n+Aggr *a1 = new Aggr[]{};\n+Aggr *a2 = new Aggr[]{ 1, 2, 3 };\n+Aggr *a3 = new Aggr[]{ 1, 2, 3, 4 };\n+Aggr *a4 = new Aggr[]{ { 1, 2, 3 } };\n+Aggr *a5 = new Aggr[]{ { 1 }, { 6, 7 } };\n+#if __cpp_designated_initializers\n+Aggr *a9 = new Aggr[]{ { .a = 1, .b = 2, .c = 3 } };\n+#endif\n+#if __cpp_aggregate_paren_init\n+Aggr *a6 = new Aggr[]();\n+Aggr *a7 = new Aggr[]({ 1, 2, 3 });\n+Aggr *a8 = new Aggr[]({ 1 }, { 6, 7 });\n+#endif\n+\n+int\n+main ()\n+{\n+  if (p1[0] != 1 || p2[0] != 1 || p2[1] != 2 || p2[2] != 3)\n+    __builtin_abort ();\n+  if (__builtin_strcmp (c1, \"foo\"))\n+    __builtin_abort ();\n+  if (a2->a != 1 || a2->b != 2 || a2->c != 3)\n+    __builtin_abort ();\n+  if (a3[0].a != 1 || a3[0].b != 2 || a3[0].c != 3\n+      || a3[1].a != 4 || a3[1].b != 0 || a3[1].c != 0)\n+    __builtin_abort ();\n+  if (a4->a != 1 || a4->b != 2 || a4->c != 3)\n+    __builtin_abort ();\n+  if (a5[0].a != 1 || a5[0].b != 0 || a5[0].c != 0\n+      || a5[1].a != 6 || a5[1].b != 7 || a5[1].c != 0)\n+    __builtin_abort ();\n+#if __cpp_designated_initializers\n+  if (a9->a != 1 || a9->b != 2 || a9->c != 3)\n+    __builtin_abort ();\n+#endif\n+#if __cpp_aggregate_paren_init\n+  if (q1[0] != 1)\n+    __builtin_abort ();\n+  if (q2[0] != 1 || q2[1] != 2 || q2[2] != 3)\n+    __builtin_abort ();\n+  if (__builtin_strcmp (d1, \"foo\") || __builtin_strcmp (d2, \"foo\")\n+      || __builtin_strcmp (d3, \"foo\"))\n+    __builtin_abort ();\n+  if (a7[0].a != 1 || a7[0].b != 2 || a7[0].c != 3)\n+    __builtin_abort ();\n+  if (a8[0].a != 1 || a8[0].b != 0 || a8[0].c != 0\n+      || a8[1].a != 6 || a8[1].b != 7 || a8[1].c != 0)\n+    __builtin_abort ();\n+#endif\n+}"}, {"sha": "9fa3f9ea7a3468bd3fcb50b0e5733d7a646a5bbb", "filename": "gcc/testsuite/g++.dg/cpp2a/new-array2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array2.C?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/93529\n+// P1009: Array size deduction in new-expressions\n+// { dg-do compile { target c++11 } }\n+\n+// Test error cases.\n+int *p = new double[] = { 1, 2, 3}; // { dg-error \"invalid use of array with unspecified bounds\" }\n+int *p2 = new double[] = (1, 2, 3); // { dg-error \"invalid use of array with unspecified bounds\" }\n+struct Aggr { int a; int b; int c; };\n+Aggr *p3 = new Aggr[]( 1, 2, 3 ); // { dg-error \"could not convert|parenthesized initializer\" }\n+char *p4 = new char[](\"foo\", \"a\"); // { dg-error \"invalid conversion|parenthesized initializer\" }\n+\n+template<typename... T>\n+int *fn(T... t)\n+{\n+  return new int[]{t...}; // { dg-error \"invalid conversion\" }\n+}\n+\n+void\n+g ()\n+{\n+  int *p = fn (\"a\");\n+}"}, {"sha": "f35124e159dd8ac7561849dc7a5546b93752deac", "filename": "gcc/testsuite/g++.dg/cpp2a/new-array3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array3.C?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/93529\n+// P1009: Array size deduction in new-expressions\n+// { dg-do compile { target c++11 } }\n+\n+template<typename... T>\n+int *fn(T... t)\n+{\n+  return new int[]{t...};\n+}\n+\n+int\n+main ()\n+{\n+  int *p0 = fn ();\n+  int *p1 = fn (1);\n+  int *p3 = fn (1, 2, 3);\n+}"}, {"sha": "2c327ebc853ddb0a468808873b17f4acdf912ca7", "filename": "gcc/testsuite/g++.dg/cpp2a/new-array4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnew-array4.C?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/93529\n+// P1009: Array size deduction in new-expressions\n+// { dg-do compile { target c++11 } }\n+\n+void\n+fn ()\n+{\n+  new int[][3]{ { 1, 2, 3 } };\n+  new int[][]{ { 1, 2, 3 } }; // { dg-error \"expected primary-expression\" }\n+}"}, {"sha": "45aacadbe2dffef94ef8ac9a0eb3d0df0ef38459", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -2123,6 +2123,21 @@ build_constructor_from_list (tree type, tree vals)\n   return build_constructor (type, v);\n }\n \n+/* Return a new CONSTRUCTOR node whose type is TYPE and whose values\n+   are in a vector pointed to by VALS.  Note that the TREE_PURPOSE\n+   fields in the constructor remain null.  */\n+\n+tree\n+build_constructor_from_vec (tree type, const vec<tree, va_gc> *vals)\n+{\n+  vec<constructor_elt, va_gc> *v = NULL;\n+\n+  for (tree t : *vals)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, t);\n+\n+  return build_constructor (type, v);\n+}\n+\n /* Return a new CONSTRUCTOR node whose type is TYPE.  NELTS is the number\n    of elements, provided as index/value pairs.  */\n "}, {"sha": "b0ef14b6cd91fe77b68074439ef3eb6992ae047d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a2b8dd17dbc02c0c7e6286e90f17833aa50906/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=73a2b8dd17dbc02c0c7e6286e90f17833aa50906", "patch": "@@ -4407,6 +4407,7 @@ extern void verify_constructor_flags (tree);\n extern tree build_constructor (tree, vec<constructor_elt, va_gc> * CXX_MEM_STAT_INFO);\n extern tree build_constructor_single (tree, tree, tree);\n extern tree build_constructor_from_list (tree, tree);\n+extern tree build_constructor_from_vec (tree, const vec<tree, va_gc> *);\n extern tree build_constructor_va (tree, int, ...);\n extern tree build_clobber (tree);\n extern tree build_real_from_int_cst (tree, const_tree);"}]}