{"sha": "3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkODBlNTdmOGJhMDQ0YzEyMTdkNTBmMmEwM2E2N2QyYTIwZWM1ZA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-08-20T14:27:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-20T14:27:59Z"}, "message": "exp_ch5.adb (Controlled_Type): New routine.\n\n2008-08-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch5.adb (Controlled_Type): New routine.\n\t(Expand_N_Extended_Return_Statement): When generating a move of the\n\tfinal list in extended return statements, check the type of the\n\tfunction and in the case of double expanded return statements, the type\n\tof the returned object.\n\t(Expand_Simple_Function_Return): Perform an interface conversion when\n\tthe type of the returned object is an interface and the context is an\n\textended return statement.\n\nFrom-SVN: r139305", "tree": {"sha": "08f1ae56470746f8cd921c45fafb71c081b5efc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08f1ae56470746f8cd921c45fafb71c081b5efc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "deff3e5e46d740c9b857bf96daf9f9206bd22ea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deff3e5e46d740c9b857bf96daf9f9206bd22ea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deff3e5e46d740c9b857bf96daf9f9206bd22ea7"}], "stats": {"total": 70, "additions": 53, "deletions": 17}, "files": [{"sha": "952501ea82fbe2758d22a51dd5ac3b4e5ebf0e67", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3ad80e57f8ba044c1217d50f2a03a67d2a20ec5d", "patch": "@@ -2371,6 +2371,7 @@ package body Exp_Ch5 is\n                                Parent (Return_Object_Entity);\n       Parent_Function      : constant Entity_Id :=\n                                Return_Applies_To (Return_Statement_Entity (N));\n+      Parent_Function_Typ  : constant Entity_Id := Etype (Parent_Function);\n       Is_Build_In_Place    : constant Boolean :=\n                                Is_Build_In_Place_Function (Parent_Function);\n \n@@ -2380,6 +2381,10 @@ package body Exp_Ch5 is\n       Result          : Node_Id;\n       Exp             : Node_Id;\n \n+      function Controlled_Type (Typ : Entity_Id) return Boolean;\n+      --  Determine whether type Typ is controlled or contains a controlled\n+      --  component.\n+\n       function Move_Activation_Chain return Node_Id;\n       --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n       --  with parameters:\n@@ -2394,6 +2399,17 @@ package body Exp_Ch5 is\n       --    From         finalization list of the return statement\n       --    To           finalization list passed in by the caller\n \n+      ---------------------\n+      -- Controlled_Type --\n+      ---------------------\n+\n+      function Controlled_Type (Typ : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Is_Controlled (Typ)\n+             or else Has_Controlled_Component (Typ);\n+      end Controlled_Type;\n+\n       ---------------------------\n       -- Move_Activation_Chain --\n       ---------------------------\n@@ -2518,23 +2534,24 @@ package body Exp_Ch5 is\n          --  in the rather obscure case of a select-then-abort statement whose\n          --  abortable part contains the return statement.\n \n-         --  We test the type of the expression as well as the return type\n-         --  of the function, because the latter may be a class-wide type\n-         --  which is always treated as controlled, while the expression itself\n-         --  has to have a definite type. The expression may be absent if a\n-         --  constrained aggregate has been expanded into component assignments\n-         --  so we have to check for this as well.\n+         --  Check the type of the function to determine whether to move the\n+         --  finalization list. A special case arises when processing a simple\n+         --  return statement which has been rewritten as an extended return.\n+         --  In that case check the type of the returned object or the original\n+         --  expression.\n \n          if Is_Build_In_Place\n-           and then Controlled_Type (Etype (Parent_Function))\n+           and then\n+               (Controlled_Type (Parent_Function_Typ)\n+             or else\n+               (Is_Class_Wide_Type (Parent_Function_Typ)\n+                  and then Controlled_Type (Root_Type (Parent_Function_Typ)))\n+             or else\n+               Controlled_Type (Etype (Return_Object_Entity))\n+             or else\n+               (Present (Exp) and then Controlled_Type (Etype (Exp))))\n          then\n-            if not Is_Class_Wide_Type (Etype (Parent_Function))\n-              or else\n-               (Present (Exp)\n-                 and then Controlled_Type (Etype (Exp)))\n-            then\n-               Append_To (Statements, Move_Final_List);\n-            end if;\n+            Append_To (Statements, Move_Final_List);\n          end if;\n \n          --  Similarly to the above Move_Final_List, if the result type\n@@ -3678,7 +3695,7 @@ package body Exp_Ch5 is\n       --  inherently limited). We might prefer to do this translation in all\n       --  cases (except perhaps for the case of Ada 95 inherently limited),\n       --  in order to fully exercise the Expand_N_Extended_Return_Statement\n-      --  code. This would also allow us to to the build-in-place optimization\n+      --  code. This would also allow us to do the build-in-place optimization\n       --  for efficiency even in cases where it is semantically not required.\n \n       --  As before, we check the type of the return expression rather than the\n@@ -3704,8 +3721,11 @@ package body Exp_Ch5 is\n             --  expression is an aggregate that is built in place, this avoids\n             --  the need for an expensive conversion of the return object to\n             --  the specific type on assignments to the individual components.\n+            --  Do not perform this high-level optimization if the result type\n+            --  is an interface because the \"this\" pointer must be displaced.\n \n             if Is_Class_Wide_Type (R_Type)\n+              and then not Is_Interface (R_Type)\n               and then not Is_Class_Wide_Type (Etype (Exp))\n             then\n                Subtype_Ind := New_Occurrence_Of (Etype (Exp), Loc);\n@@ -3720,8 +3740,9 @@ package body Exp_Ch5 is\n                               Object_Definition   => Subtype_Ind,\n                               Expression          => Exp);\n \n-               Ext : constant Node_Id := Make_Extended_Return_Statement (Loc,\n-                       Return_Object_Declarations => New_List (Obj_Decl));\n+               Ext : constant Node_Id :=\n+                       Make_Extended_Return_Statement (Loc,\n+                         Return_Object_Declarations => New_List (Obj_Decl));\n \n             begin\n                Rewrite (N, Ext);\n@@ -4177,6 +4198,21 @@ package body Exp_Ch5 is\n              Name => Make_Identifier (Loc, Name_uPostconditions),\n              Parameter_Associations => New_List (Duplicate_Subexpr (Exp))));\n       end if;\n+\n+      --  Ada 2005 (AI-251): If this return statement corresponds with an\n+      --  simple return statement associated with an extended return statement\n+      --  and the type of the returned object is an interface then generate an\n+      --  implicit conversion to force displacement of the \"this\" pointer.\n+\n+      if Ada_Version >= Ada_05\n+        and then Comes_From_Extended_Return_Statement (N)\n+        and then Nkind (Expression (N)) = N_Identifier\n+        and then Is_Interface (Utyp)\n+        and then Utyp /= Underlying_Type (Exptyp)\n+      then\n+         Rewrite (Exp, Convert_To (Utyp, Relocate_Node (Exp)));\n+         Analyze_And_Resolve (Exp);\n+      end if;\n    end Expand_Simple_Function_Return;\n \n    ------------------------------"}]}