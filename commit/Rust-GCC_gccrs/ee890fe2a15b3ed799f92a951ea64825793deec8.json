{"sha": "ee890fe2a15b3ed799f92a951ea64825793deec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU4OTBmZTJhMTViM2VkNzk5ZjkyYTk1MWVhNjQ4MjU3OTNkZWVjOA==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-04-12T02:13:00Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-04-12T02:13:00Z"}, "message": "Add Darwin (Mac OS X kernel) native support.\n\n        * config.gcc (powerpc-*-darwin*): Add native bits.\n        * config/darwin.c: New file, generic Darwin support functions.\n        * config/darwin.h: New file, generic Darwin definitions.\n        * config/darwin-protos.h: New file, generic Darwin prototypes.\n        * rs6000/darwin.h: New file, Darwin for PowerPC.\n        * rs6000/t-darwin: New file, Darwin makefile fragment.\n        * rs6000/rs6000.h (OBJECT_MACHO): New macro.\n        (TARGET_MACHO): Ditto.\n        (rs6000_abi): Add ABI_DARWIN.\n        (RS6000_REG_SAVE): Add ABI_DARWIN case.\n        (RS6000_SAVE_AREA): Ditto.\n        (FP_ARG_MAX_REG): Ditto.\n        (RETURN_ADDRESS_OFFSET): Ditto.\n        * rs6000/rs6000.c (rs6000_legitimize_address): Add TARGET_MACHO\n        cases.\n        (rs6000_emit_move): Add ABI_DARWIN cases.\n        (print_operand): Ditto.\n        (first_reg_to_save): Ditto.\n        (rs6000_stack_info): Ditto, also align stack by 16 instead of 8.\n        (debug_stack_info): Ditto.\n        (rs6000_emit_prologue): Ditto.\n        (rs6000_emit_epilogue): Ditto.\n        (output_profiler_hook): Ditto.\n        (output_function_profiler): Ditto.\n        (rs6000_add_gc_roots): Call machopic_add_gc_roots if TARGET_MACHO.\n        (output_mi_thunk): Add TARGET_MACHO case.\n        (add_compiler_stub): Ditto.\n        (output_compiler_stub): Ditto.\n        (no_previous_def): Ditto.\n        (output_call): Ditto.\n        (machopic_output_stub): Ditto.\n        (rs6000_machopic_legitimize_pic_address): Ditto.\n        (toc_section): Ditto.\n        * rs6000/rs6000.md (addsi3_high): New TARGET_MACHO pattern.\n        (macho_high): Ditto.\n        (macho_low): Ditto.\n        (movsi_low): Ditto.\n        (load_macho_picbase): Ditto.\n        (call): Add TARGET_MACHO case to modify function.\n        (call_value): Ditto.\n        (call_nonlocal_sysv): Add ABI_DARWIN case.\n        (call_value_nonlocal_sysv): Ditto.\n        * rs6000/rs6000-protos.h (rs6000_machopic_legitimize_pic_address):\n        Add prototype.\n        (machopic_output_stub): Ditto.\n        * ginclude/stddef.h: Test _BSD_WCHAR_T_DEFINED_.\n\nFrom-SVN: r41277", "tree": {"sha": "050edc4f92fee78d3a1e0cff1ebad238fc8801f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/050edc4f92fee78d3a1e0cff1ebad238fc8801f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee890fe2a15b3ed799f92a951ea64825793deec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee890fe2a15b3ed799f92a951ea64825793deec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee890fe2a15b3ed799f92a951ea64825793deec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee890fe2a15b3ed799f92a951ea64825793deec8/comments", "author": null, "committer": null, "parents": [{"sha": "5101b304668b06b6ef938a0acc84ba03debc816a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5101b304668b06b6ef938a0acc84ba03debc816a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5101b304668b06b6ef938a0acc84ba03debc816a"}], "stats": {"total": 2622, "additions": 2606, "deletions": 16}, "files": [{"sha": "094a78849c4cfdcb74247758dbdc7b7a8ec224f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -1,3 +1,53 @@\n+2001-04-11  Stan Shebs  <shebs@apple.com>\n+\n+\tAdd Darwin (Mac OS X kernel) native support.\n+\t* config.gcc (powerpc-*-darwin*): Add native bits.\n+\t* config/darwin.c: New file, generic Darwin support functions.\n+\t* config/darwin.h: New file, generic Darwin definitions.\n+\t* config/darwin-protos.h: New file, generic Darwin prototypes.\n+\t* rs6000/darwin.h: New file, Darwin for PowerPC.\n+\t* rs6000/t-darwin: New file, Darwin makefile fragment.\n+\t* rs6000/rs6000.h (OBJECT_MACHO): New macro.\n+\t(TARGET_MACHO): Ditto.\n+\t(rs6000_abi): Add ABI_DARWIN.\n+\t(RS6000_REG_SAVE): Add ABI_DARWIN case.\n+\t(RS6000_SAVE_AREA): Ditto.\n+\t(FP_ARG_MAX_REG): Ditto.\n+\t(RETURN_ADDRESS_OFFSET): Ditto.\n+\t* rs6000/rs6000.c (rs6000_legitimize_address): Add TARGET_MACHO\n+\tcases.\n+\t(rs6000_emit_move): Add ABI_DARWIN cases.\n+\t(print_operand): Ditto.\n+\t(first_reg_to_save): Ditto.\n+\t(rs6000_stack_info): Ditto, also align stack by 16 instead of 8.\n+\t(debug_stack_info): Ditto.\n+\t(rs6000_emit_prologue): Ditto.\n+\t(rs6000_emit_epilogue): Ditto.\n+\t(output_profiler_hook): Ditto.\n+\t(output_function_profiler): Ditto.\n+\t(rs6000_add_gc_roots): Call machopic_add_gc_roots if TARGET_MACHO.\n+\t(output_mi_thunk): Add TARGET_MACHO case.\n+\t(add_compiler_stub): Ditto.\n+\t(output_compiler_stub): Ditto.\n+\t(no_previous_def): Ditto.\n+\t(output_call): Ditto.\n+\t(machopic_output_stub): Ditto.\n+\t(rs6000_machopic_legitimize_pic_address): Ditto.\n+\t(toc_section): Ditto.\n+\t* rs6000/rs6000.md (addsi3_high): New TARGET_MACHO pattern.\n+\t(macho_high): Ditto.\n+\t(macho_low): Ditto.\n+\t(movsi_low): Ditto.\n+\t(load_macho_picbase): Ditto.\n+\t(call): Add TARGET_MACHO case to modify function.\n+\t(call_value): Ditto.\n+\t(call_nonlocal_sysv): Add ABI_DARWIN case.\n+\t(call_value_nonlocal_sysv): Ditto.\n+\t* rs6000/rs6000-protos.h (rs6000_machopic_legitimize_pic_address):\n+\tAdd prototype.\n+\t(machopic_output_stub): Ditto.\n+\t* ginclude/stddef.h: Test _BSD_WCHAR_T_DEFINED_.\n+\n 2001-04-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dwarf2out.c (modified_type_die): Don't create new types here."}, {"sha": "07578f97eb3bb26083ef9a768990803aa6cd892a", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -2647,8 +2647,15 @@ powerpc-*-beos*)\n \ttmake_file=rs6000/t-beos\n \t;;\n powerpc-*-darwin*)\n+\tcpu_type=rs6000\n+\ttm_file=\"${tm_file} darwin.h rs6000/darwin.h\"\n+\ttm_p_file=\"${tm_p_file} darwin-protos.h\"\n+\ttmake_file=rs6000/t-darwin\n \txm_file=rs6000/xm-darwin.h\n \txmake_file=rs6000/x-darwin\n+\textra_objs=\"darwin.o\"\n+\t# Darwin linker does collect2 functionality\n+\tuse_collect2=no\n \t;;\n powerpc-*-sysv*)\n \ttm_file=\"${tm_file} svr4.h rs6000/sysv4.h\""}, {"sha": "b2326c050c0535fe40bfd45ec3a8b86b1c6000ae", "filename": "gcc/config/darwin-protos.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -0,0 +1,57 @@\n+/* Prototypes.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+extern int name_needs_quotes PARAMS ((const char *));\n+\n+extern void machopic_validate_stub_or_non_lazy_ptr PARAMS ((const char *, int));\n+\n+extern char *machopic_function_base_name PARAMS ((void));\n+extern char *machopic_non_lazy_ptr_name PARAMS ((const char*));\n+extern char *machopic_stub_name PARAMS ((const char*));\n+\n+extern void machopic_add_gc_roots PARAMS ((void));\n+\n+extern void machopic_picsymbol_stub_section PARAMS ((void));\n+extern void machopic_symbol_stub_section PARAMS ((void));\n+extern void machopic_lazy_symbol_ptr_section PARAMS ((void));\n+extern void machopic_nl_symbol_ptr_section PARAMS ((void));\n+\n+#ifdef RTX_CODE\n+\n+extern int machopic_operand_p PARAMS ((rtx));\n+extern enum machopic_addr_class machopic_classify_name PARAMS ((const char*));\n+\n+extern rtx machopic_indirect_data_reference PARAMS ((rtx, rtx));\n+extern rtx machopic_indirect_call_target PARAMS ((rtx));\n+extern rtx machopic_legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n+\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+\n+extern enum machopic_addr_class machopic_classify_ident PARAMS ((tree));\n+extern void machopic_define_ident PARAMS ((tree));\n+extern void machopic_define_name PARAMS ((const char*));\n+extern int machopic_name_defined_p PARAMS ((const char*));\n+extern int machopic_ident_defined_p PARAMS ((tree));\n+\n+#endif /* TREE_CODE */\n+\n+extern void machopic_finish PARAMS ((FILE *));"}, {"sha": "3e2a0008ef5c869192b8e4fc728d820aa98c456c", "filename": "gcc/config/darwin.c", "status": "added", "additions": 1002, "deletions": 0, "changes": 1002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -0,0 +1,1002 @@\n+/* Functions for generic Darwin as target machine for GNU C compiler.\n+   Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001\n+   Free Software Foundation, Inc.\n+   Contributed by Apple Computer Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"reload.h\"\n+/* need for IDENTIFIER_GLOBAL_VALUE and IDENTIFIER_LOCAL_VALUE */\n+#include \"c-tree.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+\n+#include \"darwin-protos.h\"\n+\n+extern void machopic_output_stub PARAMS ((FILE *, const char *, const char *));\n+\n+static int machopic_data_defined_p PARAMS ((const char *));\n+static int func_name_maybe_scoped PARAMS ((const char *));\n+\n+/* Make everything that used to go in the text section really go there.  */\n+\n+int flag_no_mach_text_sections = 0;\n+\n+int\n+name_needs_quotes (name)\n+     const char *name;\n+{\n+  int c;\n+  while ((c = *name++) != '\\0')\n+    if (!isalnum (c) && c != '_')\n+      return 1;\n+  return 0;\n+}\n+\n+/* \n+ * flag_pic = 1 ... generate only indirections\n+ * flag_pic = 2 ... generate indirections and pure code\n+ */\n+\n+/* This module assumes that (const (symbol_ref \"foo\")) is a legal pic\n+   reference, which will not be changed.  */\n+\n+static tree machopic_defined_list;\n+\n+enum machopic_addr_class\n+machopic_classify_ident (ident)\n+     tree ident;\n+{\n+  const char *name = IDENTIFIER_POINTER (ident);\n+  int lprefix = (((name[0] == '*' || name[0] == '&')\n+\t\t  && (name[1] == 'L' || (name[1] == '\"' && name[2] == 'L')))\n+\t\t || (   name[0] == '_' \n+\t\t     && name[1] == 'O' \n+\t\t     && name[2] == 'B' \n+\t\t     && name[3] == 'J'\n+\t\t     && name[4] == 'C'\n+\t\t     && name[5] == '_'));\n+  tree temp, decl = lookup_name_darwin (ident);\n+\n+  if (!decl)\n+    {\n+      if (lprefix)\n+\t{\n+\t  const char *name = IDENTIFIER_POINTER (ident);\n+\t  int len = strlen (name);\n+\n+\t  if ((len > 5 && !strcmp (name + len - 5, \"$stub\"))\n+\t      || (len > 6 && !strcmp (name + len - 6, \"$stub\\\"\")))\n+\t    return MACHOPIC_DEFINED_FUNCTION;\n+\t  return MACHOPIC_DEFINED_DATA;\n+\t}\n+\n+      for (temp = machopic_defined_list;\n+\t   temp != NULL_TREE;\n+\t   temp = TREE_CHAIN (temp))\n+\t{\n+\t  if (ident == TREE_VALUE (temp))\n+\t    return MACHOPIC_DEFINED_DATA;\n+\t}\n+\n+      if (TREE_ASM_WRITTEN (ident))\n+\treturn MACHOPIC_DEFINED_DATA;\n+\n+      return MACHOPIC_UNDEFINED;\n+    }\n+\n+  /* variable declarations */\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      if ((DECL_INITIAL (decl)\n+           || TREE_STATIC (decl))\n+          && ! TREE_PUBLIC (decl))\n+\treturn MACHOPIC_DEFINED_DATA;\n+    }\n+\n+  /* function declarations */\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && (!DECL_EXTERNAL (decl)))\n+    {\n+      if (TREE_STATIC (decl)\n+\t  || TREE_ASM_WRITTEN (decl))\n+\treturn MACHOPIC_DEFINED_FUNCTION;\n+    }\n+\n+  for (temp = machopic_defined_list; temp != NULL_TREE; temp = TREE_CHAIN (temp))\n+    {\n+      if (ident == TREE_VALUE (temp))\n+\t{\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    return MACHOPIC_DEFINED_FUNCTION;\n+\t  else\n+\t    return MACHOPIC_DEFINED_DATA;\n+\t}\n+    }\n+  \n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (lprefix)\n+\treturn MACHOPIC_DEFINED_FUNCTION;\n+      else\n+\treturn MACHOPIC_UNDEFINED_FUNCTION;\n+    }\n+  else\n+    {\n+      if (lprefix)\n+\treturn MACHOPIC_DEFINED_DATA;\n+      else\n+\treturn MACHOPIC_UNDEFINED_DATA;\n+    }\n+}\n+\n+     \n+enum machopic_addr_class\n+machopic_classify_name (name)\n+     const char *name;\n+{\n+  return machopic_classify_ident (get_identifier (name));\n+}\n+\n+int\n+machopic_ident_defined_p (ident)\n+     tree ident;\n+{\n+  switch (machopic_classify_ident (ident))\n+    {\n+    case MACHOPIC_UNDEFINED:\n+    case MACHOPIC_UNDEFINED_DATA:\n+    case MACHOPIC_UNDEFINED_FUNCTION:\n+      return 0;\n+    default:\n+      return 1;\n+    }\n+}\n+\n+static int\n+machopic_data_defined_p (name)\n+     const char *name;\n+{\n+  switch (machopic_classify_ident (get_identifier (name)))\n+    {\n+    case MACHOPIC_DEFINED_DATA:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+int\n+machopic_name_defined_p (name)\n+     const char *name;\n+{\n+  return machopic_ident_defined_p (get_identifier (name));\n+}\n+\n+void\n+machopic_define_ident (ident)\n+     tree ident;\n+{\n+  if (!machopic_ident_defined_p (ident))\n+    machopic_defined_list = \n+      tree_cons (NULL_TREE, ident, machopic_defined_list);\n+}\n+\n+void\n+machopic_define_name (name)\n+     const char *name;\n+{\n+  machopic_define_ident (get_identifier (name));\n+}\n+\n+tree\n+lookup_name_darwin (name)\n+     tree name;\n+{\n+  tree val;\n+\n+  if (!global_bindings_p()\n+      && IDENTIFIER_LOCAL_VALUE (name))\n+    val = IDENTIFIER_LOCAL_VALUE (name);\n+  else\n+    val = IDENTIFIER_GLOBAL_VALUE (name);\n+  return val;\n+}\n+\n+/* This is a static to make inline functions work.  The rtx\n+   representing the PIC base symbol always points to here. */\n+\n+static char function_base[32];\n+\n+static int current_pic_label_num;\n+\n+char *\n+machopic_function_base_name ()\n+{\n+  static char *name = NULL;\n+  static const char *current_name;\n+\n+  current_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n+\n+  if (name != current_name)\n+    {\n+      current_function_uses_pic_offset_table = 1;\n+\n+      /* Save mucho space and time.  Some of the C++ mangled names are over\n+\t 700 characters long!  Note that we produce a label containing a '-'\n+\t if the function we're compiling is an Objective-C method, as evinced\n+\t by the incredibly scientific test below.  This is because code in\n+\t rs6000.c makes the same ugly test when loading the PIC reg.  */\n+ \n+      ++current_pic_label_num;\n+      if (*current_name == '+' || *current_name == '-')\n+\tsprintf (function_base, \"*\\\"L-%d$pb\\\"\", current_pic_label_num);\n+      else\n+\tsprintf (function_base, \"*L%d$pb\", current_pic_label_num);\n+\n+      name = current_name;\n+    }\n+\n+  return function_base;\n+}\n+\n+static tree machopic_non_lazy_pointers = NULL;\n+\n+/* Return a non-lazy pointer name corresponding to the given name,\n+   either by finding it in our list of pointer names, or by generating\n+   a new one.  */\n+\n+char * \n+machopic_non_lazy_ptr_name (name)\n+     const char *name;\n+{\n+  tree temp, ident = get_identifier (name);\n+  \n+  for (temp = machopic_non_lazy_pointers;\n+       temp != NULL_TREE; \n+       temp = TREE_CHAIN (temp))\n+    {\n+      if (ident == TREE_VALUE (temp))\n+\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n+    }\n+\n+  {\n+    char *buffer;\n+    tree ptr_name;\n+\n+    buffer = alloca (strlen (name) + 20);\n+\n+    strcpy (buffer, \"&L\");\n+    if (name[0] == '*')\n+      strcat (buffer, name+1);\n+    else\n+      {\n+\tstrcat (buffer, \"_\");\n+\tstrcat (buffer, name);\n+      }\n+      \n+    strcat (buffer, \"$non_lazy_ptr\");\n+    ptr_name = get_identifier (buffer);\n+\n+    machopic_non_lazy_pointers \n+      = tree_cons (ptr_name, ident, machopic_non_lazy_pointers);\n+\n+    TREE_USED (machopic_non_lazy_pointers) = 0;\n+\n+    return IDENTIFIER_POINTER (ptr_name);\n+  }\n+}\n+\n+static tree machopic_stubs = 0;\n+\n+/* Make sure the GC knows about our homemade lists.  */\n+\n+void\n+machopic_add_gc_roots ()\n+{\n+  ggc_add_tree_root (&machopic_defined_list, 1);\n+  ggc_add_tree_root (&machopic_non_lazy_pointers, 1);\n+  ggc_add_tree_root (&machopic_stubs, 1);\n+}\n+\n+/* Return the name of the stub corresponding to the given name,\n+   generating a new stub name if necessary.  */\n+\n+char * \n+machopic_stub_name (name)\n+     const char *name;\n+{\n+  tree temp, ident = get_identifier (name);\n+  \n+  for (temp = machopic_stubs;\n+       temp != NULL_TREE; \n+       temp = TREE_CHAIN (temp))\n+    {\n+      if (ident == TREE_VALUE (temp))\n+\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n+    }\n+\n+  {\n+    char *buffer;\n+    tree ptr_name;\n+    int needs_quotes = name_needs_quotes (name);\n+\n+    buffer = alloca (strlen (name) + 20);\n+\n+    if (needs_quotes)\n+      strcpy (buffer, \"&\\\"L\");\n+    else\n+      strcpy (buffer, \"&L\");\n+    if (name[0] == '*')\n+      {\n+\tstrcat (buffer, name+1);\n+      }\n+    else\n+      {\n+\tstrcat (buffer, \"_\");\n+\tstrcat (buffer, name);\n+      }\n+\n+    if (needs_quotes)\n+      strcat (buffer, \"$stub\\\"\");\n+    else\n+      strcat (buffer, \"$stub\");\n+    ptr_name = get_identifier (buffer);\n+\n+    machopic_stubs = tree_cons (ptr_name, ident, machopic_stubs);\n+    TREE_USED (machopic_stubs) = 0;\n+\n+    return IDENTIFIER_POINTER (ptr_name);\n+  }\n+}\n+\n+void\n+machopic_validate_stub_or_non_lazy_ptr (name, validate_stub)\n+     const char *name;\n+     int validate_stub;\n+{\n+    tree temp, ident = get_identifier (name);\n+\n+    for (temp = (validate_stub ? machopic_stubs : machopic_non_lazy_pointers);\n+         temp != NULL_TREE;\n+         temp = TREE_CHAIN (temp))\n+      if (ident == TREE_PURPOSE (temp))\n+\t{\n+\t  /* Mark both the stub or non-lazy pointer as well as the\n+\t     original symbol as being referenced.  */\n+          TREE_USED (temp) = 1;\n+\t  if (TREE_CODE (TREE_VALUE (temp)) == IDENTIFIER_NODE)\n+\t    TREE_SYMBOL_REFERENCED (TREE_VALUE (temp)) = 1;\n+\t}\n+}\n+\n+/* Transform ORIG, which may be any data source, to the corresponding\n+   source using indirections.  */\n+\n+rtx\n+machopic_indirect_data_reference (orig, reg)\n+     rtx orig, reg;\n+{\n+  rtx ptr_ref = orig;\n+  \n+  if (! MACHOPIC_INDIRECT)\n+    return orig;\n+\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      const char *name = XSTR (orig, 0);\n+\n+      if (machopic_data_defined_p (name))\n+\t{\n+\t  rtx pic_base = gen_rtx (SYMBOL_REF, Pmode, \n+\t\t\t\t  machopic_function_base_name ());\n+\t  rtx offset = gen_rtx (CONST, Pmode,\n+\t\t\t\tgen_rtx (MINUS, Pmode, orig, pic_base));\n+\n+#if defined (TARGET_TOC) /* i.e., PowerPC */\n+\t  rtx hi_sum_reg = reg;\n+\n+\t  if (reg == NULL)\n+\t    abort ();\n+\n+\t  emit_insn (gen_rtx (SET, Pmode, hi_sum_reg,\n+\t\t\t      gen_rtx (PLUS, Pmode, pic_offset_table_rtx,\n+\t\t\t\t       gen_rtx (HIGH, Pmode, offset))));\n+\t  emit_insn (gen_rtx (SET, Pmode, reg,\n+\t\t\t      gen_rtx (LO_SUM, Pmode, hi_sum_reg, offset)));\n+\n+\t  orig = reg;\n+#else\n+#if defined (HAVE_lo_sum)\n+\t  if (reg == 0) abort ();\n+\n+\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t      gen_rtx (HIGH, Pmode, offset)));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t      gen_rtx (LO_SUM, Pmode, reg, offset)));\n+\t  emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\t      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+\n+\t  orig = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, reg);\n+#endif\n+#endif\n+\t  return orig;\n+\t}\n+\n+      ptr_ref = gen_rtx (SYMBOL_REF, Pmode,\n+                         machopic_non_lazy_ptr_name (name));\n+\n+      ptr_ref = gen_rtx_MEM (Pmode, ptr_ref);\n+      RTX_UNCHANGING_P (ptr_ref) = 1;\n+\n+      return ptr_ref;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, result;\n+\n+      /* legitimize both operands of the PLUS */\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = machopic_indirect_data_reference (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t   reg);\n+\t  orig = machopic_indirect_data_reference (XEXP (XEXP (orig, 0), 1),\n+\t\t\t\t\t\t   (base == reg ? 0 : reg));\n+\t}\n+      else \n+\treturn orig;\n+\n+      if (MACHOPIC_PURE && GET_CODE (orig) == CONST_INT)\n+        {\n+\t  result = plus_constant_for_output (base, INTVAL (orig));\n+        }\n+      else\n+        {\n+           result = gen_rtx (PLUS, Pmode, base, orig);\n+        }\n+\n+      if (RTX_UNCHANGING_P (base) && RTX_UNCHANGING_P (orig))\n+\tRTX_UNCHANGING_P (result) = 1;\n+\n+      if (MACHOPIC_JUST_INDIRECT && GET_CODE (base) == MEM)\n+\t{\n+\t  if (reg)\n+\t    {\n+\t      emit_move_insn (reg, result);\n+\t      result = reg;\n+\t    }\n+\t  else\n+\t    {\n+\t      result = force_reg (GET_MODE (result), result);\n+\t    }\n+\t}\n+\n+      return result;\n+\n+    }\n+  else if (GET_CODE (orig) == MEM)\n+    XEXP (ptr_ref, 0) = machopic_indirect_data_reference (XEXP (orig, 0), reg);\n+  /* When the target is i386, this code prevents crashes due to the\n+     compiler's ignorance on how to move the PIC base register to\n+     other registers.  (The reload phase sometimes introduces such\n+     insns.)  */\n+  else if (GET_CODE (orig) == PLUS\n+\t   && GET_CODE (XEXP (orig, 0)) == REG\n+\t   && REGNO (XEXP (orig, 0)) == PIC_OFFSET_TABLE_REGNUM\n+#ifdef I386\n+\t   /* Prevent the same register from being erroneously used\n+\t      as both the base and index registers.  */\n+\t   && GET_CODE (XEXP (orig, 1)) == CONST\n+#endif\n+\t   && reg)\n+    {\n+      emit_move_insn (reg, XEXP (orig, 0));\n+      XEXP (ptr_ref, 0) = reg;\n+    }\n+  return ptr_ref;\n+}\n+\n+/* For MACHOPIC_INDIRECT_CALL_TARGET below, we need to beware of:\n+\n+\textern \"C\" { int f(); }\n+\tstruct X { int f(); int g(); };\n+\tint X::f() { ::f(); }\n+\tint X::g() { ::f(); f();}\n+\n+  This is hairy.  Both calls to \"::f()\" need to be indirect (i.e., to\n+  appropriate symbol stubs), but since MACHOPIC_NAME_DEFINED_P calls\n+  GET_IDENTIFIER which treats \"f\" as \"X::f\", and \"X::f\" is indeed (being)\n+  defined somewhere in \"X\"'s inheritance hierarchy, MACHOPIC_NAME_DEFINED_P\n+  returns TRUE when called with \"f\", which means that\n+  MACHOPIC_INDIRECT_CALL_TARGET uses an \"internal\" call instead of an\n+  indirect one as it should.\n+\n+  Our quick-n-dirty solution to this is to call the following\n+  FUNC_NAME_MAYBE_SCOPED routine which (only for C++) checks whether\n+  FNAME -- the name of the function which we're calling -- is NOT a\n+  mangled C++ name, AND if the current function being compiled is a\n+  method, and if so, use an \"external\" or \"indirect\" call. \n+\n+  Note that this function will be called ONLY when MACHOPIC_INDIRECT_TARGET_P\n+  has already indicated that the target is NOT indirect.\n+\n+  This conservative solution will sometimes make indirect calls where\n+  it might have been possible to make direct ones.\n+\n+  FUNC_NAME_MAYBE_SCOPED returns 1 to indicate a \"C\" name (not scoped),\n+  which in turns means we should create a stub for an indirect call.\n+  */\n+\n+static int is_cplusplus = -1;\n+\n+static int\n+func_name_maybe_scoped (fname)\n+     const char *fname;\n+{\n+\n+  if (is_cplusplus < 0)\n+    is_cplusplus = (strcmp (lang_identify (), \"cplusplus\") == 0);\n+\n+  if (is_cplusplus)\n+    {\n+      /* If we have a method, then check whether the function we're trying to\n+         call is a \"C\" function.  If so, we should use an indirect call.\n+\n+         It turns out to be hard to tell whether \"we have a method\", since\n+         static member functions have a TREE_CODE of FUNCTION_TYPE, as do\n+         namespace-level non-member functions.  So here, we always look for\n+         an extern-\"C\"-like name, and make stubs for them no matter the\n+         calling context.  This is temporary, and leaves nagging suspicion\n+\t that improvements should be possible here.  (I.e., I suspect that\n+         it can still sometimes make stubs where it needn't.)  */\n+\n+      /* if (1 || TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE) */\n+\t{\n+\t  /* If fname is of the form \"f__1X\" or \"f__Fv\", it's C++.  */\n+\t  while (*fname == '_') ++fname;\t/* skip leading underscores  */\n+\t  while (*fname != 0)\n+\t    {\n+\t      if (fname[0] == '_' && fname[1] == '_'\n+\t\t  && (fname[2] == 'F' || (fname[2] >= '0' && fname[2] <= '9')))\n+\t\treturn 0;\n+\t      ++fname;\n+\t    }\n+\t  /* Not a C++ mangled name: must be \"C\", in which case play safe.  */\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Transform TARGET (a MEM), which is a function call target, to the\n+   corresponding symbol_stub if necessary.  Return a new MEM.  */\n+\n+rtx\n+machopic_indirect_call_target (target)\n+     rtx target;\n+{\n+  if (GET_CODE (target) != MEM)\n+    return target;\n+\n+  if (MACHOPIC_INDIRECT && GET_CODE (XEXP (target, 0)) == SYMBOL_REF)\n+    { \n+      enum machine_mode mode = GET_MODE (XEXP (target, 0));\n+      const char *name = XSTR (XEXP (target, 0), 0);\n+\n+      if (!machopic_name_defined_p (name) || func_name_maybe_scoped (name)) \n+\t{\n+\t  const char *stub_name = machopic_stub_name (name);\n+\n+\t  XEXP (target, 0) = gen_rtx (SYMBOL_REF, mode, stub_name);\n+\t  RTX_UNCHANGING_P (target) = 1;\n+\t} \n+    }\n+\n+  return target;\n+}\n+\n+rtx\n+machopic_legitimize_pic_address (orig, mode, reg)\n+     rtx orig, reg;\n+     enum machine_mode mode;\n+{\n+  rtx pic_ref = orig;\n+\n+  if (! MACHOPIC_PURE)\n+    return orig;\n+\n+  /* First handle a simple SYMBOL_REF or LABEL_REF */\n+  if (GET_CODE (orig) == LABEL_REF\n+      || (GET_CODE (orig) == SYMBOL_REF\n+\t  ))\n+    {\n+      /* addr(foo) = &func+(foo-func) */\n+      rtx pic_base;\n+\n+      orig = machopic_indirect_data_reference (orig, reg);\n+\n+      if (GET_CODE (orig) == PLUS \n+\t  && GET_CODE (XEXP (orig, 0)) == REG)\n+\t{\n+\t  if (reg == 0)\n+\t    return force_reg (mode, orig);\n+\n+\t  emit_move_insn (reg, orig);\n+\t  return reg;\n+\t}  \n+\n+      pic_base = gen_rtx (SYMBOL_REF, Pmode, machopic_function_base_name ());\n+\n+      if (GET_CODE (orig) == MEM)\n+\t{\n+\t  if (reg == 0)\n+\t    {\n+\t      if (reload_in_progress)\n+\t\tabort ();\n+\t      else\n+\t\treg = gen_reg_rtx (Pmode);\n+\t    }\n+\t\n+#ifdef HAVE_lo_sum\n+\t  if (GET_CODE (XEXP (orig, 0)) == SYMBOL_REF \n+\t      || GET_CODE (XEXP (orig, 0)) == LABEL_REF)\n+\t    {\n+\t      rtx offset = gen_rtx (CONST, Pmode,\n+\t\t\t\t    gen_rtx (MINUS, Pmode,\n+\t\t\t\t\t     XEXP (orig, 0), pic_base));\n+#if defined (TARGET_TOC) /* i.e., PowerPC */\n+\t      /* Generating a new reg may expose opportunities for\n+\t\t common subexpression elimination.  */\n+              rtx hi_sum_reg =\n+\t\t(reload_in_progress ? reg : gen_reg_rtx (SImode));\n+\n+\t      emit_insn (gen_rtx (SET, Pmode, hi_sum_reg,\n+\t\t\t\t  gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t   pic_offset_table_rtx,\n+\t\t\t\t\t   gen_rtx (HIGH, Pmode, offset))));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (MEM, GET_MODE (orig),\n+\t\t\t\t\t   gen_rtx (LO_SUM, Pmode, \n+\t\t\t\t\t\t    hi_sum_reg, offset))));\n+\t      pic_ref = reg;\n+\n+#else\n+\t      emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\t      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (HIGH, Pmode, \n+\t\t\t\t\t   gen_rtx (CONST, Pmode, offset))));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (LO_SUM, Pmode, reg, \n+\t\t\t\t\t   gen_rtx (CONST, Pmode, offset))));\n+\t      pic_ref = gen_rtx (PLUS, Pmode,\n+\t\t\t\t pic_offset_table_rtx, reg);\n+#endif\n+\t    }\n+\t  else\n+#endif  /* HAVE_lo_sum */\n+\t    {\n+\t      rtx pic = pic_offset_table_rtx;\n+\t      if (GET_CODE (pic) != REG)\n+\t\t{\n+\t\t  emit_move_insn (reg, pic);\n+\t\t  pic = reg;\n+\t\t}\n+#if 0\n+\t      emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\t\t  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+#endif\n+\n+\t      pic_ref = gen_rtx (PLUS, Pmode,\n+\t\t\t\t pic, \n+\t\t\t\t gen_rtx (CONST, Pmode, \n+\t\t\t\t\t  gen_rtx (MINUS, Pmode,\n+\t\t\t\t\t\t   XEXP (orig, 0), \n+\t\t\t\t\t\t   pic_base)));\n+\t    }\n+\t  \n+#if !defined (TARGET_TOC)\n+\t  RTX_UNCHANGING_P (pic_ref) = 1;\n+\t  emit_move_insn (reg, pic_ref);\n+\t  pic_ref = gen_rtx (MEM, GET_MODE (orig), reg);\n+#endif\n+\t}\n+      else\n+\t{\n+\n+#ifdef HAVE_lo_sum\n+\t  if (GET_CODE (orig) == SYMBOL_REF \n+\t      || GET_CODE (orig) == LABEL_REF)\n+\t    {\n+\t      rtx offset = gen_rtx (CONST, Pmode,\n+\t\t\t\t    gen_rtx (MINUS, Pmode, orig, pic_base));\n+#if defined (TARGET_TOC) /* i.e., PowerPC */\n+              rtx hi_sum_reg;\n+\n+\t      if (reg == 0)\n+\t\t{\n+\t\t  if (reload_in_progress)\n+\t\t    abort ();\n+\t\t  else\n+\t\t    reg = gen_reg_rtx (SImode);\n+\t\t}\n+\t\n+\t      hi_sum_reg = reg;\n+\n+\t      emit_insn (gen_rtx (SET, Pmode, hi_sum_reg,\n+\t\t\t\t  gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t   pic_offset_table_rtx,\n+\t\t\t\t\t   gen_rtx (HIGH, Pmode, offset))));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (LO_SUM, Pmode,\n+\t\t\t\t\t   hi_sum_reg, offset)));\n+\t      pic_ref = reg;\n+#else\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (HIGH, Pmode, offset)));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t\t  gen_rtx (LO_SUM, Pmode, reg, offset)));\n+\t      pic_ref = gen_rtx (PLUS, Pmode,\n+\t\t\t\t pic_offset_table_rtx, reg);\n+#endif\n+\t    }\n+\t  else\n+#endif  /*  HAVE_lo_sum  */\n+\t    {\n+\t      if (GET_CODE (orig) == REG)\n+\t\t{\n+\t\t  return orig;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx pic = pic_offset_table_rtx;\n+\t\t  if (GET_CODE (pic) != REG)\n+\t\t    {\n+\t\t      emit_move_insn (reg, pic);\n+\t\t      pic = reg;\n+\t\t    }\n+#if 0\n+\t\t  emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\t\t      pic_offset_table_rtx));\n+#endif\n+\t\t  pic_ref = gen_rtx (PLUS, Pmode,\n+\t\t\t\t     pic,\n+\t\t\t\t     gen_rtx (CONST, Pmode, \n+\t\t\t\t\t      gen_rtx (MINUS, Pmode,\n+\t\t\t\t\t\t       orig, pic_base)));\n+\t\t}\n+\t    }\n+\t}\n+\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+\n+      if (GET_CODE (pic_ref) != REG)\n+        {\n+          if (reg != 0)\n+            {\n+              emit_move_insn (reg, pic_ref);\n+              return reg;\n+            }\n+          else\n+            {\n+              return force_reg (mode, pic_ref);\n+            }\n+        }\n+      else\n+        {\n+          return pic_ref;\n+        }\n+    }\n+\n+  else if (GET_CODE (orig) == SYMBOL_REF)\n+    return orig;\n+\n+  else if (GET_CODE (orig) == PLUS\n+\t   && (GET_CODE (XEXP (orig, 0)) == MEM\n+\t       || GET_CODE (XEXP (orig, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (orig, 0)) == LABEL_REF)\n+\t   && XEXP (orig, 0) != pic_offset_table_rtx\n+\t   && GET_CODE (XEXP (orig, 1)) != REG)\n+    \n+    {\n+      rtx base;\n+      int is_complex = (GET_CODE (XEXP (orig, 0)) == MEM);\n+\n+      base = machopic_legitimize_pic_address (XEXP (orig, 0), Pmode, reg);\n+      orig = machopic_legitimize_pic_address (XEXP (orig, 1),\n+\t\t\t\t\t      Pmode, (base == reg ? 0 : reg));\n+      if (GET_CODE (orig) == CONST_INT)\n+\t{\n+\t  pic_ref = plus_constant_for_output (base, INTVAL (orig));\n+\t  is_complex = 1;\n+\t}\n+      else\n+\t{\n+\t  pic_ref = gen_rtx (PLUS, Pmode, base, orig);\n+\t}\n+\n+      if (RTX_UNCHANGING_P (base) && RTX_UNCHANGING_P (orig))\n+\tRTX_UNCHANGING_P (pic_ref) = 1;\n+\n+      if (reg && is_complex)\n+\t{\n+\t  emit_move_insn (reg, pic_ref);\n+\t  pic_ref = reg;\n+\t}\n+      /* Likewise, should we set special REG_NOTEs here?  */\n+    }\n+\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      return machopic_legitimize_pic_address (XEXP (orig, 0), Pmode, reg);\n+    }\n+\n+  else if (GET_CODE (orig) == MEM\n+\t   && GET_CODE (XEXP (orig, 0)) == SYMBOL_REF)\n+    {\n+      rtx addr = machopic_legitimize_pic_address (XEXP (orig, 0), Pmode, reg);\n+\n+      addr = gen_rtx (MEM, GET_MODE (orig), addr);\n+      RTX_UNCHANGING_P (addr) = RTX_UNCHANGING_P (orig);\n+      emit_move_insn (reg, addr);\n+      pic_ref = reg;\n+    }\n+\n+  return pic_ref;\n+}\n+\n+\n+void\n+machopic_finish (asm_out_file)\n+     FILE *asm_out_file;\n+{\n+  tree temp;\n+\n+  for (temp = machopic_stubs;\n+       temp != NULL_TREE;\n+       temp = TREE_CHAIN (temp))\n+    {\n+      char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n+      char *stub_name = IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n+      char *sym;\n+      char *stub;\n+      tree decl = lookup_name_darwin (TREE_VALUE (temp));\n+\n+      if (! TREE_USED (temp))\n+\tcontinue;\n+\n+      /* Don't emit stubs for static inline functions which have not\n+         been compiled.  */\n+      if (decl\n+          && TREE_CODE (decl) == FUNCTION_DECL\n+          && DECL_INLINE (decl)\n+          && ! TREE_PUBLIC (decl)\n+          && ! TREE_ASM_WRITTEN (decl))\n+\tcontinue;\n+\n+      sym = alloca (strlen (sym_name) + 2);\n+      if (sym_name[0] == '*' || sym_name[0] == '&')\n+\tstrcpy (sym, sym_name + 1);\n+      else if (sym_name[0] == '-' || sym_name[0] == '+')\n+\tstrcpy (sym, sym_name);\t  \n+      else\n+\tsym[0] = '_', strcpy (sym + 1, sym_name);\n+\n+      stub = alloca (strlen (stub_name) + 2);\n+      if (stub_name[0] == '*' || stub_name[0] == '&')\n+\tstrcpy (stub, stub_name + 1);\n+      else\n+\tstub[0] = '_', strcpy (stub + 1, stub_name);\n+\n+      machopic_output_stub (asm_out_file, sym, stub);\n+    }\n+\n+  for (temp = machopic_non_lazy_pointers;\n+       temp != NULL_TREE; \n+       temp = TREE_CHAIN (temp))\n+    {\n+      char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n+      char *lazy_name = IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n+#if 0\n+      tree decl = lookup_name_darwin (TREE_VALUE (temp));\n+#endif\n+\n+      if (! TREE_USED (temp))\n+\tcontinue;\n+\n+      if (machopic_ident_defined_p (TREE_VALUE (temp))\n+#if 0 /* add back when we have private externs */\n+          || (decl && DECL_PRIVATE_EXTERN (decl))\n+#endif\n+\t  )\n+\t{\n+\t  data_section ();\n+\t  assemble_align (UNITS_PER_WORD * BITS_PER_UNIT);\n+\t  assemble_label (lazy_name);\n+\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, sym_name),\n+\t\t\t    GET_MODE_SIZE (Pmode), 1);\n+\t}\n+      else\n+\t{\n+\t  machopic_nl_symbol_ptr_section ();\n+\t  assemble_name (asm_out_file, lazy_name); \n+\t  fprintf (asm_out_file, \":\\n\");\n+\n+\t  fprintf (asm_out_file, \"\\t.indirect_symbol \");\n+\t  assemble_name (asm_out_file, sym_name); \n+\t  fprintf (asm_out_file, \"\\n\");\n+\n+\t  assemble_integer (const0_rtx, GET_MODE_SIZE (Pmode), 1);\n+\t}\n+    }\n+}\n+\n+int \n+machopic_operand_p (op)\n+     rtx op;\n+{\n+  if (MACHOPIC_JUST_INDIRECT)\n+    {\n+      while (GET_CODE (op) == CONST)\n+\top = XEXP (op, 0);\n+\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\treturn machopic_name_defined_p (XSTR (op, 0));\n+      else\n+\treturn 0;\n+    }\n+\n+  while (GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) == MINUS\n+      && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (op, 1)) == SYMBOL_REF\n+      && machopic_name_defined_p (XSTR (XEXP (op, 0), 0))\n+      && machopic_name_defined_p (XSTR (XEXP (op, 1), 0)))\n+      return 1;\n+\n+#if 0 /*def TARGET_TOC*/ /* i.e., PowerPC */\n+  /* Without this statement, the compiler crashes while compiling enquire.c\n+     when targetting PowerPC.  It is not known why this code is not needed\n+     when targetting other processors.  */\n+  else if (GET_CODE (op) == SYMBOL_REF\n+\t   && (machopic_classify_name (XSTR (op, 0))\n+\t       == MACHOPIC_DEFINED_FUNCTION))\n+    {\n+      return 1;\n+    }\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "269d78ce98366ec8dff8030b83be54ecf90130e4", "filename": "gcc/config/darwin.h", "status": "added", "additions": 763, "deletions": 0, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -0,0 +1,763 @@\n+/* Target definitions for Darwin (Mac OS X) systems.\n+   Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001\n+   Free Software Foundation, Inc.\n+   Contributed by Apple Computer Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The definitions in this file are common to all processor types\n+   running Darwin, which is the kernel for Mac OS X.  Darwin is\n+   basically a BSD user layer laid over a Mach kernel, then evolved\n+   for many years (at NeXT) in parallel with other Unix systems.  So\n+   while the runtime is a somewhat idiosyncratic Mach-based thing,\n+   other definitions look like they would for a BSD variant.  */\n+\n+/* Although NeXT ran on many different architectures, as of Jan 2001\n+   the only supported Darwin targets are PowerPC and x86.  */\n+\n+/* Make the compiler look here for standard stuff.  */\n+\n+#undef STANDARD_EXEC_PREFIX\n+#define STANDARD_EXEC_PREFIX \"/usr/libexec/\"\n+\n+/* Name of the command that invokes the compiler - used in g++.c.  */\n+\n+#undef  GCC_NAME\n+#define GCC_NAME \"cc\"\n+\n+/* Never try linking with -lm - used in g++.c.  */\n+\n+#define NO_MATH_LIBRARY\n+\n+/* We have atexit.  */\n+\n+#define HAVE_ATEXIT\n+\n+/* Define an empty body for the function do_global_dtors() in libgcc2.c.  */\n+\n+#define DO_GLOBAL_DTORS_BODY\n+\n+/* The string value for __SIZE_TYPE__.  */\n+\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+#endif\n+\n+/* Type used for ptrdiff_t, as a string used in a declaration.  */\n+\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+/* wchar_t is int.  */\n+\n+#undef\tWCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#undef\tWCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n+   we want to retain compatibility with older gcc versions.  */\n+\n+#undef\tDEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Don't warn about MacOS-style 'APPL' four-char-constants.  */\n+\n+#undef WARN_FOUR_CHAR_CONSTANTS\n+#define WARN_FOUR_CHAR_CONSTANTS 0\n+\n+/* Machine dependent cpp options.  */\n+\n+/* The sequence here allows us to get a more specific version number\n+   glued into __APPLE_CC__.  Normally this number would be updated as\n+   part of submitting to a release engineering organization.  */\n+\n+#ifndef APPLE_CC\n+#define APPLE_CC 999\n+#endif\n+\n+#define STRINGIFY_THIS(x) # x\n+#define REALLY_STRINGIFY(x) STRINGIFY_THIS(x)\n+\n+#undef\tCPP_SPEC\n+#define CPP_SPEC \"-D__APPLE_CC__=\" REALLY_STRINGIFY(APPLE_CC) \"\t\\\n+\t\t  %{static:-D__STATIC__}%{!static:-D__DYNAMIC__}\"\n+\n+/* Machine dependent libraries.  */\n+\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \\\n+     \"%{!static:%{!pg:-framework System}%{pg:-framework System,_profile}}\"\n+\n+#undef LIBGCC_SPEC\n+#define LIBGCC_SPEC \"%{!shared:%{static:-lcc} \\\n+\t\t\t      %{!static:-lcc_dynamic}}\"\n+\n+/* We specify crt0.o as -lcrt0.o so that ld will search the library path. */\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:%{static:-lgcrt0.o}%{!static:-lgcrt1.o}} \\\n+    %{!pg:%{static:-lcrt0.o}%{!static:-lcrt1.o}}\"\n+\n+#undef\tDOLLARS_IN_IDENTIFIERS\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* Allow #sccs (but don't do anything). */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* We use Dbx symbol format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* When generating stabs debugging, use N_BINCL entries.  */\n+\n+#define DBX_USE_BINCL\n+\n+/* There is no limit to the length of stabs strings.  */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* gdb needs a null N_SO at the end of each file for scattered loading. */\n+\n+#undef\tDBX_OUTPUT_MAIN_SOURCE_FILE_END\n+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n+do { text_section ();\t\t\t\t\t\t\t\\\n+     fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t      \"\\t.stabs \\\"%s\\\",%d,0,0,Letext\\nLetext:\\n\", \"\" , N_SO);\t\\\n+   } while (0)\n+\n+/* Our profiling scheme doesn't LP labels and counter words.  */\n+\n+#define NO_PROFILE_COUNTERS\n+\n+/* Don't use .gcc_compiled symbols to communicate with GDB;\n+   They interfere with numerically sorted symbol lists. */\n+\n+#undef\tASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(asm_out_file)\n+\n+#undef\tINIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\n+\n+#undef\tINVOKE__main\n+\n+#undef\tASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)                       \\\n+  do { if (flag_pic)                                            \\\n+\t mod_init_section ();                                   \\\n+       else\t\t\t\t\t\t\t\\\n+\t constructor_section ();\t\t\t\t\\\n+       ASM_OUTPUT_ALIGN (FILE, 1);                              \\\n+       fprintf (FILE, \"\\t.long \");                              \\\n+       assemble_name (FILE, NAME);                              \\\n+       fprintf (FILE, \"\\n\");                                    \\\n+       if (!flag_pic)                                    \t\\\n+\t fprintf (FILE, \".reference .constructors_used\\n\");     \\\n+      } while (0)\n+\n+#undef\tASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)                        \\\n+  do { if (flag_pic)                                            \\\n+\t mod_term_section ();                                   \\\n+       else\t\t\t\t\t\t\t\\\n+\t destructor_section ();\t\t\t\t\t\\\n+       ASM_OUTPUT_ALIGN (FILE, 1);\t\t\t\t\\\n+       fprintf (FILE, \"\\t.long \");\t\t\t\t\\\n+       assemble_name (FILE, NAME);\t\t\t\t\\\n+       fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+       if (!flag_pic)                                    \t\\\n+       \tfprintf (FILE, \".reference .destructors_used\\n\");\t\\\n+     } while (0)\n+\n+\n+/* Don't output a .file directive.  That is only used by the assembler for\n+   error reporting.  */\n+\n+#undef\tASM_FILE_START\n+#define ASM_FILE_START(FILE)\n+\n+#undef\tASM_FILE_END\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    extern const char *language_string;\t\t\t\t\\\n+    machopic_finish (asm_out_file);                             \\\n+    if (strcmp (language_string, \"GNU C++\") == 0)\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tconstructor_section ();\t\t\t\t\t\\\n+\tdestructor_section ();\t\t\t\t\t\\\n+\tASM_OUTPUT_ALIGN (FILE, 1);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Give ObjcC methods pretty symbol names. */\n+\n+#undef\tOBJC_GEN_METHOD_LABEL\n+#define OBJC_GEN_METHOD_LABEL(BUF,IS_INST,CLASS_NAME,CAT_NAME,SEL_NAME,NUM) \\\n+  do { if (CAT_NAME)\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s(%s) %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (CAT_NAME), (SEL_NAME));\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (SEL_NAME));\t\t\t\t\\\n+     } while (0)\n+\n+/* The RTTI data (e.g., __ti4name) is common and public (and static),\n+   but it does need to be referenced via indirect PIC data pointers.\n+   The machopic_define_name calls are telling the machopic subsystem\n+   that the name *is* defined in this module, so it doesn't need to\n+   make them indirect.  */\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    char *xname = NAME;                                                 \\\n+    if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)             \\\n+      xname = IDENTIFIER_POINTER (DECL_NAME (DECL));                    \\\n+    if ((TREE_STATIC (DECL)                                             \\\n+\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))               \\\n+        || DECL_INITIAL (DECL))                                         \\\n+      machopic_define_name (xname);                                     \\\n+    ASM_OUTPUT_LABEL (FILE, xname);                                     \\\n+  } while (0)\n+\n+/* Wrap new method names in quotes so the assembler doesn't gag.\n+   Make Objective-C internal symbols local.  */\n+\n+#undef\tASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+       if (NAME[0] == '&')\t\t\t\t\t\t\\\n+         {\t\t\t\t\t\t\t\t\\\n+           int len = strlen (NAME);\t\t\t\t\t\\\n+\t   if (len > 6 && !strcmp (\"$stub\", NAME + len - 5))\t\t\\\n+\t     machopic_validate_stub_or_non_lazy_ptr (NAME, 1);\t\t\\\n+\t   else if (len > 7 && !strcmp (\"$stub\\\"\", NAME + len - 6))\t\\\n+\t     machopic_validate_stub_or_non_lazy_ptr (NAME, 1);\t\t\\\n+\t   else if (len > 14 && !strcmp (\"$non_lazy_ptr\", NAME + len - 13)) \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (NAME, 0);\t\t\\\n+\t   fputs (&NAME[1], FILE); \\\n+\t } \\\n+       else if (NAME[0] == '+' || NAME[0] == '-')   \\\n+         fprintf (FILE, \"\\\"%s\\\"\", NAME); \\\n+       else if (!strncmp (NAME, \"_OBJC_\", 6))  \\\n+         fprintf (FILE, \"L%s\", NAME);   \\\n+       else if (!strncmp (NAME, \".objc_class_name_\", 17))\t\t\\\n+\t fprintf (FILE, \"%s\", NAME);\t\t\t\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+         fprintf (FILE, \"_%s\", NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef\tALIGN_ASM_OP\n+#define ALIGN_ASM_OP\t\t\".align\"\n+\n+#undef\tASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t%s %d\\n\", ALIGN_ASM_OP, (LOG))\n+\n+/* Ensure correct alignment of bss data.  */\n+\n+#undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  do {  \\\n+    fputs (\".lcomm \", (FILE));\t\t\t\t\\\n+    assemble_name ((FILE), (NAME));\t\t\t\\\n+    fprintf ((FILE), \",%u,%u\\n\", (SIZE), floor_log2 ((ALIGN) / BITS_PER_UNIT)); \\\n+    if ((DECL) && ((TREE_STATIC (DECL)                                             \\\n+\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))               \\\n+        || DECL_INITIAL (DECL)))                                         \\\n+      machopic_define_name (NAME);                                     \\\n+  } while (0)\n+\n+/* Output nothing for #ident.  */\n+\n+#undef\tASM_OUTPUT_IDENT\n+#define ASM_OUTPUT_IDENT(FILE, NAME)\n+\n+/* The maximum alignment which the object file format can support.\n+   For Mach-O, this is 2^15.  */\n+\n+#undef\tMAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT 0x8000\n+\n+/* Create new Mach-O sections. */\n+\n+#undef\tSECTION_FUNCTION\n+#define SECTION_FUNCTION(FUNCTION, SECTION, DIRECTIVE, WAS_TEXT, OBJC)\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+FUNCTION ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section ();\t\t\t\t\t \t\\\n+  extern void objc_section_init ();\t\t\t\t\t\\\n+  extern int flag_no_mach_text_sections;\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  if (WAS_TEXT && flag_no_mach_text_sections)       \t\t\t\\\n+    text_section ();\t\t\t\t\t\t\t\\\n+  else if (in_section != SECTION)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (OBJC)\t\t\t\t\t\t\t\t\\\n+\tobjc_section_init ();\t\t\t\t\t\t\\\n+      data_section ();\t\t\t\t\t\t\t\\\n+      if (asm_out_file)\t\t\t\t\t\t\t\\\n+\tfprintf (asm_out_file, \"%s\\n\", DIRECTIVE);\t\t\t\\\n+      in_section = SECTION;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\n+#define ALIAS_SECTION(enum_value, alias_name) \t\t\t\t\\\n+do { if (!strcmp (alias_name, name))\t\t\t\t\t\\\n+       section_alias[enum_value] = (alias ? get_identifier (alias) : 0);  \\\n+   } while (0)\n+\n+/* Darwin uses many types of special sections.  */\n+\n+#undef\tEXTRA_SECTIONS\n+#define EXTRA_SECTIONS\t\t\t\t\t\\\n+  in_const, in_const_data, in_cstring, in_literal4, in_literal8,\t\\\n+  in_constructor, in_destructor, in_mod_init, in_mod_term,\t\t\\\n+  in_objc_class, in_objc_meta_class, in_objc_category,\t\\\n+  in_objc_class_vars, in_objc_instance_vars,\t\t\\\n+  in_objc_cls_meth, in_objc_inst_meth,\t\t\t\\\n+  in_objc_cat_cls_meth, in_objc_cat_inst_meth,\t\t\\\n+  in_objc_selector_refs,\t\t\t\t\\\n+  in_objc_selector_fixup,\t\t\t\t\\\n+  in_objc_symbols, in_objc_module_info,\t\t\t\\\n+  in_objc_protocol, in_objc_string_object,\t\t\\\n+  in_objc_constant_string_object,\t\t\t\\\n+  in_objc_class_names, in_objc_meth_var_names,\t\t\\\n+  in_objc_meth_var_types, in_objc_cls_refs, \t\t\\\n+  in_machopic_nl_symbol_ptr,\t\t\t\t\\\n+  in_machopic_lazy_symbol_ptr,\t\t\t\t\\\n+  in_machopic_symbol_stub,\t\t\t\t\\\n+  in_machopic_picsymbol_stub,\t\t\t\t\\\n+  num_sections\n+\n+#undef\tEXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\\\n+SECTION_FUNCTION (const_section,\t\t\\\n+                  in_const,\t\t\t\\\n+                  \".const\", 1, 0)\t\t\\\n+SECTION_FUNCTION (const_data_section,\t\t\\\n+                  in_const_data,\t\t\\\n+                  \".const_data\", 1, 0)\t\t\\\n+SECTION_FUNCTION (cstring_section,\t\t\\\n+\t\t  in_cstring,\t\t\t\\\n+\t\t  \".cstring\", 1, 0)\t\t\\\n+SECTION_FUNCTION (literal4_section,\t\t\\\n+\t\t  in_literal4,\t\t\t\\\n+\t\t  \".literal4\", 1, 0)\t\t\\\n+SECTION_FUNCTION (literal8_section,\t\t\\\n+\t\t  in_literal8,\t\t\t\\\n+\t\t  \".literal8\", 1, 0)\t\t\\\n+SECTION_FUNCTION (constructor_section,\t\t\\\n+\t\t  in_constructor,\t\t\\\n+\t\t  \".constructor\", 0, 0)\t\t\\\n+SECTION_FUNCTION (mod_init_section,\t\t\\\n+\t\t  in_mod_init,\t\t\t\\\n+\t\t  \".mod_init_func\", 0, 0)\t\\\n+SECTION_FUNCTION (mod_term_section, \\\n+\t\t  in_mod_term,\t\t\t\\\n+\t\t  \".mod_term_func\", 0, 0)\t\\\n+SECTION_FUNCTION (destructor_section,\t\t\\\n+\t\t  in_destructor,\t\t\\\n+\t\t  \".destructor\", 0, 0)\t\t\\\n+SECTION_FUNCTION (objc_class_section,\t\t\\\n+\t\t  in_objc_class,\t\t\\\n+\t\t  \".objc_class\", 0, 1)\t\t\\\n+SECTION_FUNCTION (objc_meta_class_section,\t\\\n+\t\t  in_objc_meta_class,\t\t\\\n+\t\t  \".objc_meta_class\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_category_section,\t\\\n+\t\t  in_objc_category,\t\t\\\n+\t\t\".objc_category\", 0, 1)\t\t\\\n+SECTION_FUNCTION (objc_class_vars_section,\t\\\n+\t\t  in_objc_class_vars,\t\t\\\n+\t\t  \".objc_class_vars\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_instance_vars_section,\t\\\n+\t\t  in_objc_instance_vars,\t\\\n+\t\t  \".objc_instance_vars\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cls_meth_section,\t\\\n+\t\t  in_objc_cls_meth,\t\t\\\n+\t\t  \".objc_cls_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_inst_meth_section,\t\\\n+\t\t  in_objc_inst_meth,\t\t\\\n+\t\t  \".objc_inst_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cat_cls_meth_section,\t\\\n+\t\t  in_objc_cat_cls_meth,\t\t\\\n+\t\t  \".objc_cat_cls_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cat_inst_meth_section,\t\\\n+\t\t  in_objc_cat_inst_meth,\t\\\n+\t\t  \".objc_cat_inst_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_selector_refs_section,\t\\\n+\t\t  in_objc_selector_refs,\t\\\n+\t\t  \".objc_message_refs\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_selector_fixup_section,\t\\\n+\t\t  in_objc_selector_fixup,\t\\\n+\t\t  \".section __OBJC, __sel_fixup\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_symbols_section,\t\t\\\n+\t\t  in_objc_symbols,\t\t\\\n+\t\t  \".objc_symbols\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_module_info_section,\t\\\n+\t\t  in_objc_module_info,\t\t\\\n+\t\t  \".objc_module_info\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_protocol_section,\t\\\n+\t\t  in_objc_protocol,\t\t\\\n+\t\t  \".objc_protocol\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_string_object_section,\t\\\n+\t\t  in_objc_string_object,\t\\\n+\t\t  \".objc_string_object\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_constant_string_object_section,\t\\\n+\t\t  in_objc_constant_string_object,\t\\\n+\t\t  \".section __OBJC, __cstring_object\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_class_names_section,\t\\\n+\t\tin_objc_class_names,\t\t\\\n+\t\t\".objc_class_names\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_meth_var_names_section,\t\\\n+\t\tin_objc_meth_var_names,\t\t\\\n+\t\t\".objc_meth_var_names\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_meth_var_types_section,\t\\\n+\t\tin_objc_meth_var_types,\t\t\\\n+\t\t\".objc_meth_var_types\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cls_refs_section,\t\\\n+\t\tin_objc_cls_refs,\t\t\\\n+\t\t\".objc_cls_refs\", 0, 1)\t\t\\\n+\t\t\t\t\t\t\\\n+SECTION_FUNCTION (machopic_lazy_symbol_ptr_section,\t\\\n+\t\tin_machopic_lazy_symbol_ptr,\t\t\\\n+\t\t\".lazy_symbol_pointer\", 0, 0)      \t\\\n+SECTION_FUNCTION (machopic_nl_symbol_ptr_section,\t\\\n+\t\tin_machopic_nl_symbol_ptr,\t\t\\\n+\t\t\".non_lazy_symbol_pointer\", 0, 0)      \t\\\n+SECTION_FUNCTION (machopic_symbol_stub_section,\t\t\\\n+\t\tin_machopic_symbol_stub,\t\t\\\n+\t\t\".symbol_stub\", 0, 0)      \t\t\\\n+SECTION_FUNCTION (machopic_picsymbol_stub_section,\t\\\n+\t\tin_machopic_picsymbol_stub,\t\t\\\n+\t\t\".picsymbol_stub\", 0, 0)      \t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\\\n+objc_section_init ()\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  static int been_here = 0;\t\t\t\\\n+\t\t\t\t\t\t\\\n+  if (been_here == 0)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      been_here = 1;\t\t\t\t\\\n+          /* written, cold -> hot */\t\t\\\n+      objc_cat_cls_meth_section ();\t\t\\\n+      objc_cat_inst_meth_section ();\t\t\\\n+      objc_string_object_section ();\t\t\\\n+      objc_constant_string_object_section ();\t\\\n+      objc_selector_refs_section ();\t\t\\\n+      objc_selector_fixup_section ();\t\t\\\n+      objc_cls_refs_section ();\t\t\t\\\n+      objc_class_section ();\t\t\t\\\n+      objc_meta_class_section ();\t\t\\\n+          /* shared, hot -> cold */    \t\t\\\n+      objc_cls_meth_section ();\t\t\t\\\n+      objc_inst_meth_section ();\t\t\\\n+      objc_protocol_section ();\t\t\t\\\n+      objc_class_names_section ();\t\t\\\n+      objc_meth_var_types_section ();\t\t\\\n+      objc_meth_var_names_section ();\t\t\\\n+      objc_category_section ();\t\t\t\\\n+      objc_class_vars_section ();\t\t\\\n+      objc_instance_vars_section ();\t\t\\\n+      objc_module_info_section ();\t\t\\\n+      objc_symbols_section ();\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+} \t\t\t\t\t\t\\\n+static tree section_alias[(int) num_sections];\t\\\n+void try_section_alias () \t\t\t\\\n+{\t\t\t\t\t\t\\\n+    if (section_alias[in_section] && asm_out_file) \\\n+      fprintf (asm_out_file, \"%s\\n\",\t\t\\\n+\t       IDENTIFIER_POINTER (section_alias[in_section]));\t\\\n+}      \t\t\t\t\t\t\\\n+void alias_section (name, alias)\t\t\t\\\n+     char *name, *alias;\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+    ALIAS_SECTION (in_data, \"data\");\t\t\t\\\n+    ALIAS_SECTION (in_text, \"text\");\t\t\t\\\n+    ALIAS_SECTION (in_const, \"const\");\t\t\t\\\n+    ALIAS_SECTION (in_const_data, \"const_data\");\t\\\n+    ALIAS_SECTION (in_cstring, \"cstring\");\t\t\\\n+    ALIAS_SECTION (in_literal4, \"literal4\");\t\t\\\n+    ALIAS_SECTION (in_literal8, \"literal8\");\t\t\\\n+}\n+\n+#undef\tREADONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION const_section\n+\n+#undef\tSELECT_SECTION\n+#define SELECT_SECTION(exp,reloc)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TREE_CODE (exp) == STRING_CST)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (flag_writable_strings)\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\\\n+\t  else if (TREE_STRING_LENGTH (exp) !=\t\t\t\\\n+\t\t   strlen (TREE_STRING_POINTER (exp)) + 1)\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    cstring_section ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == INTEGER_CST\t\t\t\\\n+\t       || TREE_CODE (exp) == REAL_CST)\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+\t  tree size = TYPE_SIZE (TREE_TYPE (exp));\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 4 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal4_section ();\t\t\t\t\\\n+\t  else if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 8 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal8_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == CONSTRUCTOR\t\t\t\t\\\n+\t       && TREE_TYPE (exp)\t\t\t\t\t\\\n+\t       && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\t\t\\\n+\t       && TYPE_NAME (TREE_TYPE (exp)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  tree name = TYPE_NAME (TREE_TYPE (exp));\t\t\t\\\n+\t  if (TREE_CODE (name) == TYPE_DECL)\t\t\t\t\\\n+\t    name = DECL_NAME (name);\t\t\t\t\t\\\n+\t  if (!strcmp (IDENTIFIER_POINTER (name), \"NSConstantString\"))\t\\\n+\t    objc_constant_string_object_section ();\t\t\t\\\n+\t  else if (!strcmp (IDENTIFIER_POINTER (name), \"NXConstantString\")) \\\n+\t    objc_string_object_section ();\t\t\t\t\\\n+\t  else if (TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (TREE_SIDE_EFFECTS (exp) || flag_pic && reloc)\t\t\\\n+\t\tconst_data_section ();\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\treadonly_data_section (); \t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == VAR_DECL &&\t\t\t\t\\\n+\t       DECL_NAME (exp) &&\t\t\t\t\t\\\n+\t       TREE_CODE (DECL_NAME (exp)) == IDENTIFIER_NODE &&\t\\\n+\t       IDENTIFIER_POINTER (DECL_NAME (exp)) &&\t\t\t\\\n+\t       !strncmp (IDENTIFIER_POINTER (DECL_NAME (exp)), \"_OBJC_\", 6)) \\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  const char *name = IDENTIFIER_POINTER (DECL_NAME (exp));\t\\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\t\t\\\n+\t    objc_cls_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\t\\\n+\t    objc_inst_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_CLASS_METHODS_\", 20)) \\\n+\t    objc_cat_cls_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_INSTANCE_METHODS_\", 23)) \\\n+\t    objc_cat_inst_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_VARIABLES_\", 22))\t\\\n+\t    objc_class_vars_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_VARIABLES_\", 25))\t\\\n+\t    objc_instance_vars_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_PROTOCOLS_\", 22))\t\\\n+\t    objc_cat_cls_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_NAME_\", 17))\t\t\\\n+\t    objc_class_names_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METH_VAR_NAME_\", 20))\t\t\\\n+\t    objc_meth_var_names_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METH_VAR_TYPE_\", 20))\t\t\\\n+\t    objc_meth_var_types_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_REFERENCES\", 22))\t\\\n+\t    objc_cls_refs_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_\", 12))\t\t\t\\\n+\t    objc_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METACLASS_\", 16))\t\t\\\n+\t    objc_meta_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_\", 15))\t\t\\\n+\t    objc_category_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SELECTOR_REFERENCES\", 25))\t\\\n+\t    objc_selector_refs_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SELECTOR_FIXUP\", 20))\t\t\\\n+\t    objc_selector_fixup_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SYMBOLS\", 13))\t\t\\\n+\t    objc_symbols_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_MODULES\", 13))\t\t\\\n+\t    objc_module_info_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_INSTANCE_METHODS_\", 32)) \\\n+\t    objc_cat_inst_meth_section ();                              \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_CLASS_METHODS_\", 29)) \\\n+\t    objc_cat_cls_meth_section ();                               \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_REFS_\", 20))         \\\n+\t    objc_cat_cls_meth_section ();                               \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_\", 15))              \\\n+\t    objc_protocol_section ();                                   \\\n+\t  else if ((TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\t\\\n+\t\t&& !TREE_SIDE_EFFECTS (exp))     \t\t\t\\\n+             { if (flag_pic && reloc ) const_data_section ();             \\\n+               else readonly_data_section (); }                       \t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (TREE_SIDE_EFFECTS (exp) || flag_pic && reloc)\t\t\\\n+\t    const_data_section ();\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    readonly_data_section (); \t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        data_section ();\t\t\t\t\t\t\\\n+      try_section_alias ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef\tSELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(mode, rtx)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (mode) == 8)\t\t\t\t\t\\\n+\tliteral8_section ();\t\t\t\t\t\t\\\n+      else if (GET_MODE_SIZE (mode) == 4)\t\t\t\t\\\n+\tliteral4_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define DECLARE_UNRESOLVED_REFERENCE(NAME)\t\t\t\t\\\n+    do { extern FILE* asm_out_file; \t\t\t\t\t\\\n+\t if (asm_out_file) {\t\t\t\t\t\t\\\n+\t   if (flag_pic)\t\t\t\t\t\t\\\n+\t     fprintf (asm_out_file, \"\\t.lazy_reference \");\t\t\\\n+\t   else\t\t\t\t\t\t\t\t\\\n+\t     fprintf (asm_out_file, \"\\t.reference \");\t\t\t\\\n+\t   assemble_name (asm_out_file, NAME);\t\t\t\t\\\n+\t   fprintf (asm_out_file, \"\\n\");\t\t\t\t\\\n+\t }                                                              \\\n+       } while (0)\n+\n+#define DECLARE_CLASS_REFERENCE(NAME) \\\n+    do { extern FILE* asm_out_file;\t\t\t\t\t\\\n+\t if (asm_out_file) {\t\t\t\t\t\t\\\n+\t   fprintf (asm_out_file, \"\\t\");\t\t\t\t\\\n+\t   assemble_name (asm_out_file, NAME); \t\t\t\t\\\n+\t   fprintf (asm_out_file, \"=0\\n\");\t\t\t\t\\\n+\t   assemble_global (NAME);\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+       } while (0)\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+ do { const char* _x = (NAME); if (!!strncmp (_x, \"_OBJC_\", 6)) { \\\n+  (fputs (\".globl \", FILE), assemble_name (FILE, _x), fputs (\"\\n\", FILE)); \\\n+ }} while (0)\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an internal numbered label where PREFIX is\n+   the class of label and NUM is the number within the class.  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* Since we have a separate readonly data section, define this so that\n+   jump tables end up in text rather than data.  */\n+\n+#ifndef JUMP_TABLES_IN_TEXT_SECTION\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+#endif\n+\n+/* Symbolic names for various things we might know about a symbol.  */\n+\n+enum machopic_addr_class {\n+  MACHOPIC_UNDEFINED,\n+  MACHOPIC_DEFINED_DATA,\n+  MACHOPIC_UNDEFINED_DATA,\n+  MACHOPIC_DEFINED_FUNCTION,\n+  MACHOPIC_UNDEFINED_FUNCTION\n+};\n+\n+/* Macros defining the various PIC cases.  */\n+\n+#define MACHOPIC_INDIRECT      (flag_pic)\n+#define MACHOPIC_JUST_INDIRECT (flag_pic == 1)\n+#define MACHOPIC_PURE          (flag_pic == 2)\n+\n+#define GEN_BINDER_NAME_FOR_STUB(BUF,STUB,STUB_LENGTH)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *stub_ = (STUB);\t\t\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    strcpy (buffer_, stub_);\t\t\t\t\t\\\n+    if (stub_[0] == '\"')\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_ + (STUB_LENGTH) - 1, \"_binder\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_ + (STUB_LENGTH), \"_binder\");\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define GEN_SYMBOL_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *symbol_ = (SYMBOL);\t\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    if (name_needs_quotes (symbol_) && symbol_[0] != '\"')\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t  sprintf (buffer_, \"\\\"%s\\\"\", symbol_);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_, symbol_);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Given a symbol name string, create the lazy pointer version\n+   of the symbol name.  */\n+\n+#define GEN_LAZY_PTR_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *symbol_ = (SYMBOL);\t\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    if (symbol_[0] == '\"')\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"\\\"L\");\t\t\t\t\t\\\n+        strcpy (buffer_ + 2, symbol_ + 1);\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH), \"$lazy_ptr\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else if (name_needs_quotes (symbol_))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"\\\"L\");\t\t\t\t\\\n+        strcpy (buffer_ + 2, symbol_);\t\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 2, \"$lazy_ptr\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"L\");\t\t\t\t\t\\\n+        strcpy (buffer_ + 1, symbol_);\t\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 1, \"$lazy_ptr\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+"}, {"sha": "aef5d722e82d2ed1b66665793b627d328158ba22", "filename": "gcc/config/rs6000/darwin.h", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -0,0 +1,175 @@\n+/* Target definitions for PowerPC running Darwin (Mac OS X).\n+   Copyright (C) 1997, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Apple Computer Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The \"Darwin ABI\" is mostly like AIX, but with some key differences.  */\n+\n+#define DEFAULT_ABI ABI_DARWIN\n+\n+/* The object file format is Mach-O.  */\n+\n+#define TARGET_OBJECT_FORMAT OBJECT_MACHO\n+\n+/* We're not ever going to do TOCs.  */\n+\n+#define TARGET_TOC 0\n+#define TARGET_NO_TOC 1\n+\n+#define CPP_PREDEFINES \"-D__ppc__ -D__NATURAL_ALIGNMENT__ -D__MACH__ -D__BIG_ENDIAN__ -D__APPLE__\"\n+\n+/* We want -fPIC by default, unless we're using -static to compile for\n+   the kernel or some such.  */\n+\n+#define CC1_SPEC \"%{!static:-fPIC}\"\n+\n+#define FIXED_R13 0\n+\n+#undef  TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_MULTIPLE | MASK_NEW_MNEMONICS \\\n+  | MASK_NO_FP_IN_TOC | MASK_NO_SUM_IN_TOC)\n+\n+/* Base register for access to local variables of the function.  */\n+\n+#undef  FRAME_POINTER_REGNUM\n+#define FRAME_POINTER_REGNUM 30\n+\n+#undef  PIC_OFFSET_TABLE_REGNUM\n+#define PIC_OFFSET_TABLE_REGNUM 31\n+\n+#undef STACK_BOUNDARY\n+#define STACK_BOUNDARY 128\n+\n+/* Pad the outgoing args area to 16 bytes instead of the usual 8.  */\n+\n+#undef STARTING_FRAME_OFFSET\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+  (RS6000_ALIGN (current_function_outgoing_args_size, 16)\t\t\\\n+   + RS6000_VARARGS_AREA\t\t\t\t\t\t\\\n+   + RS6000_SAVE_AREA)\n+\n+#undef STACK_DYNAMIC_OFFSET\n+#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n+  (RS6000_ALIGN (current_function_outgoing_args_size, 16)\t\t\\\n+   + (STACK_POINTER_OFFSET))\n+\n+/* Define cutoff for using external functions to save floating point.\n+   Currently on Darwin, always use inline stores.  */\n+\n+#undef\tFP_SAVE_INLINE\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n+\n+/* Always use the \"debug\" register names, they're what the assembler\n+   wants to see.  */\n+\n+#undef REGISTER_NAMES\n+#define REGISTER_NAMES DEBUG_REGISTER_NAMES\n+\n+/* This outputs NAME to FILE.  */\n+\n+#undef  RS6000_OUTPUT_BASENAME\n+#define RS6000_OUTPUT_BASENAME(FILE, NAME)\t\\\n+    assemble_name (FILE, NAME);\n+\n+/* Output before instructions.  */\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE);\t\\\n+       RS6000_OUTPUT_BASENAME (FILE, NAME); putc ('\\n', FILE);} while (0)\n+\n+/* This is how to output an internal label prefix.  rs6000.c uses this\n+   when generating traceback tables.  */\n+/* Not really used for Darwin?  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL_PREFIX\n+#define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)\t\\\n+  fprintf (FILE, \"%s\", PREFIX)\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* This says how to output an assembler line to define a global common\n+   symbol.  */\n+/* ? */\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do { fputs (\".comm \", (FILE));\t\t\t\\\n+       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n+       fprintf ((FILE), \",%d\\n\", (SIZE)); } while (0)\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", SIZE)\n+\n+/* FP save and restore routines.  */\n+#define\tSAVE_FP_PREFIX \"._savef\"\n+#define SAVE_FP_SUFFIX \"\"\n+#define\tRESTORE_FP_PREFIX \"._restf\"\n+#define RESTORE_FP_SUFFIX \"\"\n+\n+/* Generate insns to call the profiler.  */\n+\n+#define PROFILE_HOOK(LABEL)   output_profile_hook (LABEL)\n+\n+/* Function name to call to do profiling.  */\n+\n+#define RS6000_MCOUNT \"*mcount\"\n+\n+/* Since Darwin doesn't do TOCs, stub this out.  */\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)  0\n+\n+/* Given an rtx X being reloaded into a reg required to be      \n+   in class CLASS, return the class of reg to actually use.     \n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+  \n+   On the RS/6000, we have to return NO_REGS when we want to reload a\n+   floating-point CONST_DOUBLE to force it to be copied to memory.\n+\n+   Don't allow R0 when loading the address of, or otherwise furtling with,\n+   a SYMBOL_REF.  */\n+\n+#undef PREFERRED_RELOAD_CLASS\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n+  (((GET_CODE (X) == CONST_DOUBLE\t\t\t\\\n+    && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\\\n+   ? NO_REGS\t\t\t\t\t\t\\\n+   : (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT \t\\\n+      && (CLASS) == NON_SPECIAL_REGS)\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\\\n+   : (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == HIGH)\t\\\n+   ? BASE_REGS\t\t\t\t\t\t\\\n+   : (CLASS)))\n+\n+/* Fix for emit_group_load (): force large constants to be pushed via regs.  */\n+#define ALWAYS_PUSH_CONSTS_USING_REGS_P\t\t1"}, {"sha": "9f8f984c7b1fd1c0abd488857c0624be80ac04c8", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -108,8 +108,12 @@ extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern void rs6000_select_rtx_section PARAMS ((enum machine_mode, rtx));\n+\n extern rtx rs6000_return_addr PARAMS ((int, rtx));\n extern void rs6000_output_symbol_ref PARAMS ((FILE*, rtx));\n+\n+extern rtx rs6000_machopic_legitimize_pic_address PARAMS ((rtx orig, enum machine_mode mode, rtx reg));\n+\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n@@ -139,6 +143,7 @@ extern void rs6000_unique_section PARAMS ((tree, int));\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n #endif /* ARGS_SIZE_RTX */\n+\n #endif /* TREE_CODE */\n \n extern void optimization_options PARAMS ((int, int));\n@@ -172,3 +177,5 @@ extern void rs6000_emit_load_toc_table PARAMS ((int));\n extern void rs6000_aix_emit_builtin_unwind_init PARAMS ((void));\n extern void rs6000_emit_epilogue PARAMS ((int));\n extern void debug_stack_info PARAMS ((rs6000_stack_t *));\n+\n+extern void machopic_output_stub PARAMS ((FILE *, const char *, const char *));"}, {"sha": "18e117ee3cb5fc149a087e441d241e32679d53f8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 441, "deletions": 12, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -1526,6 +1526,19 @@ rs6000_legitimize_address (x, oldx, mode)\n       emit_insn (gen_elf_high (reg, (x)));\n       return gen_rtx_LO_SUM (Pmode, reg, (x));\n     }\n+  else if (TARGET_MACHO && TARGET_32BIT && TARGET_NO_TOC\n+\t   && ! flag_pic\n+\t   && GET_CODE (x) != CONST_INT\n+\t   && GET_CODE (x) != CONST_DOUBLE \n+\t   && CONSTANT_P (x)\n+\t   && (TARGET_HARD_FLOAT || mode != DFmode)\n+\t   && mode != DImode \n+\t   && mode != TImode)\n+    {\n+      rtx reg = gen_reg_rtx (Pmode);\n+      emit_insn (gen_macho_high (reg, (x)));\n+      return gen_rtx_LO_SUM (Pmode, reg, (x));\n+    }\n   else if (TARGET_TOC \n \t   && CONSTANT_POOL_EXPR_P (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n@@ -1644,7 +1657,8 @@ rs6000_emit_move (dest, source, mode)\n \t  return;\n \t}\n \n-      if (TARGET_ELF && TARGET_NO_TOC && ! flag_pic\n+      if ((TARGET_ELF || DEFAULT_ABI == ABI_DARWIN)\n+\t  && TARGET_NO_TOC && ! flag_pic\n \t  && mode == Pmode\n \t  && CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != HIGH\n@@ -1670,6 +1684,13 @@ rs6000_emit_move (dest, source, mode)\n \t      operands[1] = new_ref;\n \t    }\n \n+\t  if (DEFAULT_ABI == ABI_DARWIN)\n+\t    {\n+\t      emit_insn (gen_macho_high (target, operands[1]));\n+\t      emit_insn (gen_macho_low (operands[0], target, operands[1]));\n+\t      return;\n+\t    }\n+\n \t  emit_insn (gen_elf_high (target, operands[1]));\n \t  emit_insn (gen_elf_low (operands[0], target, operands[1]));\n \t  return;\n@@ -1708,6 +1729,21 @@ rs6000_emit_move (dest, source, mode)\n \t  if (GET_CODE (operands[1]) != LABEL_REF)\n \t    emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n \n+\t  /* Darwin uses a special PIC legitimizer.  */\n+\t  if (DEFAULT_ABI == ABI_DARWIN && flag_pic)\n+\t    {\n+\t      rtx temp_reg = ((reload_in_progress || reload_completed)\n+\t\t\t      ? operands[0] : NULL);\n+\n+#if TARGET_MACHO\n+\t      operands[1] =\n+\t\trs6000_machopic_legitimize_pic_address (operands[1], mode,\n+\t\t\t\t\t\t\t\t    temp_reg);\n+#endif\n+\t      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+\t      return;\n+\t    }\n+\n \t  /* If we are to limit the number of things we put in the TOC and\n \t     this is a symbol plus a constant we can add in one insn,\n \t     just put the symbol in the TOC and add the constant.  Don't do\n@@ -4296,6 +4332,7 @@ print_operand (file, x, code)\n \t    case ABI_V4:\n \t    case ABI_AIX_NODESC:\n \t    case ABI_SOLARIS:\n+\t    case ABI_DARWIN:\n \t      break;\n \t    }\n \t}\n@@ -4655,8 +4692,10 @@ first_reg_to_save ()\n     if (regs_ever_live[first_reg] \n \t&& (! call_used_regs[first_reg]\n \t    || (first_reg == PIC_OFFSET_TABLE_REGNUM\n-\t\t&& (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-\t\t&& flag_pic == 1)))\n+\t\t&& (((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+\t\t     && flag_pic == 1)\n+\t\t    || (DEFAULT_ABI == ABI_DARWIN\n+\t\t\t&& flag_pic)))))\n       break;\n \n   if (profile_flag)\n@@ -4665,7 +4704,7 @@ first_reg_to_save ()\n \t before/after the .__mcount call plus an additional register\n \t for the static chain, if needed; use registers from 30 down to 22\n \t to do this.  */\n-      if (DEFAULT_ABI == ABI_AIX)\n+      if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n \t{\n \t  int last_parm_reg, profile_first_reg;\n \n@@ -4683,6 +4722,12 @@ first_reg_to_save ()\n \t     Skip reg 31 which may contain the frame pointer.  */\n \t  profile_first_reg = (33 - last_parm_reg\n \t\t\t       - (current_function_needs_context ? 1 : 0));\n+#if TARGET_MACHO\n+          /* Need to skip another reg to account for R31 being PICBASE\n+             (when flag_pic is set) or R30 being used as the frame\n+             pointer (when flag_pic is not set).  */\n+          --profile_first_reg;\n+#endif\n \t  /* Do not save frame pointer if no parameters needs to be saved.  */\n \t  if (profile_first_reg == 31)\n \t    profile_first_reg = 32;\n@@ -4700,6 +4745,12 @@ first_reg_to_save ()\n \t}\n     }\n \n+#if TARGET_MACHO\n+  if (flag_pic && current_function_uses_pic_offset_table &&\n+      (first_reg > PIC_OFFSET_TABLE_REGNUM))\n+    return PIC_OFFSET_TABLE_REGNUM;\n+#endif\n+\n   return first_reg;\n }\n \n@@ -4722,7 +4773,7 @@ first_fp_reg_to_save ()\n    complicated by having two separate calling sequences, the AIX calling\n    sequence and the V.4 calling sequence.\n \n-   AIX stack frames look like:\n+   AIX (and Darwin/Mac OS) stack frames look like:\n \t\t\t\t\t\t\t  32-bit  64-bit\n \tSP---->\t+---------------------------------------+\n \t\t| back chain to caller\t\t\t| 0\t  0\n@@ -4821,8 +4872,10 @@ rs6000_stack_info ()\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n   /* Assume that we will have to save PIC_OFFSET_TABLE_REGNUM, \n      even if it currently looks like we won't.  */\n-  if (flag_pic == 1 \n-      && (abi == ABI_V4 || abi == ABI_SOLARIS)\n+  if (((flag_pic == 1\n+\t&& (abi == ABI_V4 || abi == ABI_SOLARIS))\n+       || (flag_pic &&\n+\t   abi == ABI_DARWIN))\n       && info_ptr->first_gp_reg_save > PIC_OFFSET_TABLE_REGNUM)\n     info_ptr->gp_size = reg_size * (32 - PIC_OFFSET_TABLE_REGNUM);\n   else\n@@ -4845,6 +4898,7 @@ rs6000_stack_info ()\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n       || (abi == ABI_V4 && current_function_calls_alloca)\n       || (abi == ABI_SOLARIS && current_function_calls_alloca)\n+      || (DEFAULT_ABI == ABI_DARWIN && flag_pic && current_function_uses_pic_offset_table)\n       || info_ptr->calls_p)\n     {\n       info_ptr->lr_save_p = 1;\n@@ -4886,6 +4940,8 @@ rs6000_stack_info ()\n \t\t\t\t  + info_ptr->cr_size\n \t\t\t\t  + info_ptr->lr_size\n \t\t\t\t  + info_ptr->toc_size, 8);\n+  if (DEFAULT_ABI == ABI_DARWIN)\n+    info_ptr->save_size = RS6000_ALIGN (info_ptr->save_size, 16);\n \n   /* Calculate the offsets */\n   switch (abi)\n@@ -4896,6 +4952,7 @@ rs6000_stack_info ()\n \n     case ABI_AIX:\n     case ABI_AIX_NODESC:\n+    case ABI_DARWIN:\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n       info_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n@@ -4942,7 +4999,7 @@ rs6000_stack_info ()\n \n   else\n     info_ptr->push_p = (frame_pointer_needed\n-\t\t\t|| write_symbols != NO_DEBUG\n+\t\t\t|| (abi != ABI_DARWIN && write_symbols != NO_DEBUG)\n \t\t\t|| ((total_raw_size - info_ptr->fixed_size)\n \t\t\t    > (TARGET_32BIT ? 220 : 288)));\n \n@@ -4985,6 +5042,7 @@ debug_stack_info (info)\n     case ABI_NONE:\t abi_string = \"NONE\";\t\tbreak;\n     case ABI_AIX:\t abi_string = \"AIX\";\t\tbreak;\n     case ABI_AIX_NODESC: abi_string = \"AIX\";\t\tbreak;\n+    case ABI_DARWIN:\t abi_string = \"Darwin\";\t\tbreak;\n     case ABI_V4:\t abi_string = \"V.4\";\t\tbreak;\n     case ABI_SOLARIS:\t abi_string = \"Solaris\";\tbreak;\n     }\n@@ -5740,8 +5798,10 @@ rs6000_emit_prologue ()\n \tif ((regs_ever_live[info->first_gp_reg_save+i] \n \t     && ! call_used_regs[info->first_gp_reg_save+i])\n \t    || (i+info->first_gp_reg_save == PIC_OFFSET_TABLE_REGNUM\n-\t\t&& (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-\t\t&& flag_pic == 1))\n+\t\t&& (((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+\t\t     && flag_pic == 1)\n+\t\t    || (DEFAULT_ABI == ABI_DARWIN\n+\t\t\t&& flag_pic))))\n \t  {\n \t    rtx addr, reg, mem;\n \t    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n@@ -5858,6 +5918,18 @@ rs6000_emit_prologue ()\n       emit_move_insn (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM), \n \t\t      gen_rtx_REG (Pmode, 11));\n   }\n+\n+  if (DEFAULT_ABI == ABI_DARWIN\n+      && flag_pic && current_function_uses_pic_offset_table)\n+    {\n+      rtx dest = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+\n+      rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (dest)));\n+\n+      rs6000_maybe_dead (\n+\temit_move_insn (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM),\n+\t\t\tgen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)));\n+    }\n }\n \n \n@@ -6051,8 +6123,10 @@ rs6000_emit_epilogue (sibcall)\n       if ((regs_ever_live[info->first_gp_reg_save+i] \n \t   && ! call_used_regs[info->first_gp_reg_save+i])\n \t  || (i+info->first_gp_reg_save == PIC_OFFSET_TABLE_REGNUM\n-\t      && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-\t      && flag_pic == 1))\n+\t      && (((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+\t\t   && flag_pic == 1)\n+\t\t  || (DEFAULT_ABI == ABI_DARWIN\n+\t\t      && flag_pic))))\n \t{\n \t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, \n \t\t\t\t   GEN_INT (info->gp_save_offset \n@@ -6626,6 +6700,17 @@ output_mi_thunk (file, thunk_fndecl, delta, function)\n \t  if (flag_pic) fputs (\"@plt\", file);\n \t  putc ('\\n', file);\n \t  break;\n+\n+#if TARGET_MACHO\n+\tcase ABI_DARWIN:\n+\t  fprintf (file, \"\\tb %s\", prefix);\n+\t  if (flag_pic && !machopic_name_defined_p (fname))\n+\t    assemble_name (file, machopic_stub_name (fname));\n+\t  else\n+\t    assemble_name (file, fname);\n+\t  putc ('\\n', file);\n+\t  break;\n+#endif\n \t}\n     }\n }\n@@ -7226,6 +7311,28 @@ output_profile_hook (labelno)\n       emit_library_call (init_one_libfunc (RS6000_MCOUNT), 0, VOIDmode, 1,\n                          fun, Pmode);\n     }\n+  else if (DEFAULT_ABI == ABI_DARWIN)\n+    {\n+      char *mcount_name = RS6000_MCOUNT;\n+      int caller_addr_regno = LINK_REGISTER_REGNUM;\n+\n+      /* Be conservative and always set this, at least for now.  */\n+      current_function_uses_pic_offset_table = 1;\n+\n+#if TARGET_MACHO\n+      /* For PIC code, set up a stub and collect the caller's address\n+\t from r0, which is where the prologue puts it.  */\n+      if (flag_pic)\n+\t{\n+\t  mcount_name = machopic_stub_name (mcount_name);\n+\t  if (current_function_uses_pic_offset_table)\n+\t    caller_addr_regno = 0;\n+\t}\n+#endif\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n+\t\t\t 0, VOIDmode, 1,\n+\t\t\t gen_rtx_REG (Pmode, caller_addr_regno), Pmode);\n+    }\n }\n \n /* Write function profiler code. */\n@@ -7296,6 +7403,7 @@ output_function_profiler (file, labelno)\n       break;\n \n     case ABI_AIX:\n+    case ABI_DARWIN:\n       /* Don't do anything, done in output_profile_hook (). */\n       break;\n \n@@ -7834,4 +7942,325 @@ rs6000_add_gc_roots ()\n   toc_hash_table = htab_create (1021, toc_hash_function, toc_hash_eq, NULL);\n   ggc_add_root (&toc_hash_table, 1, sizeof (toc_hash_table), \n \t\ttoc_hash_mark_table);\n+\n+#if TARGET_MACHO\n+  machopic_add_gc_roots ();\n+#endif\n+}\n+\n+#if TARGET_MACHO\n+\n+#if 0\n+/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+symbolic_operand (op)\n+     register rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (GET_CODE (op) == SYMBOL_REF ||\n+\t      (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n }\n+#endif\n+\n+#ifdef RS6000_LONG_BRANCH\n+\n+static tree stub_list = 0;\n+\n+/* ADD_COMPILER_STUB adds the compiler generated stub for handling \n+   procedure calls to the linked list.  */\n+\n+void \n+add_compiler_stub (label_name, function_name, line_number)\n+     tree label_name;\n+     tree function_name;\n+     int line_number;\n+{\n+  tree stub = build_tree_list (function_name, label_name);\n+  TREE_TYPE (stub) = build_int_2 (line_number, 0);\n+  TREE_CHAIN (stub) = stub_list;\n+  stub_list = stub;\n+}\n+\n+#define STUB_LABEL_NAME(STUB)     TREE_VALUE (STUB)\n+#define STUB_FUNCTION_NAME(STUB)  TREE_PURPOSE (STUB)\n+#define STUB_LINE_NUMBER(STUB)    TREE_INT_CST_LOW (TREE_TYPE (STUB))\n+\n+/* OUTPUT_COMPILER_STUB outputs the compiler generated stub for handling \n+   procedure calls from the linked list and initializes the linked list.  */\n+\n+void output_compiler_stub ()\n+{\n+  char tmp_buf[256];\n+  char label_buf[256];\n+  char *label;\n+  tree tmp_stub, stub;\n+\n+  if (!flag_pic)\n+    for (stub = stub_list; stub; stub = TREE_CHAIN (stub))\n+      {\n+\tfprintf (asm_out_file,\n+\t\t \"%s:\\n\", IDENTIFIER_POINTER(STUB_LABEL_NAME(stub)));\n+\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+\tif (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t  fprintf (asm_out_file, \"\\t.stabd 68,0,%d\\n\", STUB_LINE_NUMBER(stub));\n+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n+\n+\tif (IDENTIFIER_POINTER (STUB_FUNCTION_NAME (stub))[0] == '*')\n+\t  strcpy (label_buf,\n+\t\t  IDENTIFIER_POINTER (STUB_FUNCTION_NAME (stub))+1);\n+\telse\n+\t  {\n+\t    label_buf[0] = '_';\n+\t    strcpy (label_buf+1,\n+\t\t    IDENTIFIER_POINTER (STUB_FUNCTION_NAME (stub)));\n+\t  }\n+\n+\tstrcpy (tmp_buf, \"lis r12,hi16(\");\n+\tstrcat (tmp_buf, label_buf);\n+\tstrcat (tmp_buf, \")\\n\\tori r12,r12,lo16(\");\n+\tstrcat (tmp_buf, label_buf);\n+\tstrcat (tmp_buf, \")\\n\\tmtctr r12\\n\\tbctr\");\n+\toutput_asm_insn (tmp_buf, 0);\n+\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+\tif (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t  fprintf(asm_out_file, \"\\t.stabd 68,0,%d\\n\", STUB_LINE_NUMBER (stub));\n+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n+      }\n+\n+  stub_list = 0;\n+}\n+\n+/* NO_PREVIOUS_DEF checks in the link list whether the function name is\n+   already there or not.  */\n+\n+int no_previous_def (function_name)\n+     tree function_name;\n+{\n+  tree stub;\n+  for (stub = stub_list; stub; stub = TREE_CHAIN (stub))\n+    if (function_name == STUB_FUNCTION_NAME (stub))\n+      return 0;\n+  return 1;\n+}\n+\n+/* GET_PREV_LABEL gets the label name from the previous definition of\n+   the function.  */\n+\n+tree get_prev_label (function_name)\n+     tree function_name;\n+{\n+  tree stub;\n+  for (stub = stub_list; stub; stub = TREE_CHAIN (stub))\n+    if (function_name == STUB_FUNCTION_NAME (stub))\n+      return STUB_LABEL_NAME (stub);\n+  return 0;\n+}\n+\n+/* INSN is either a function call or a millicode call.  It may have an\n+   unconditional jump in its delay slot.  \n+\n+   CALL_DEST is the routine we are calling.  */\n+\n+char *\n+output_call (insn, call_dest, operand_number)\n+     rtx insn;\n+     rtx call_dest;\n+     int operand_number;\n+{\n+  static char buf[256];\n+  if (GET_CODE (call_dest) == SYMBOL_REF && TARGET_LONG_BRANCH && !flag_pic)\n+    {\n+      tree labelname;\n+      tree funname = get_identifier (XSTR (call_dest, 0));\n+      \n+      if (no_previous_def (funname))\n+\t{\n+\t  int line_number;\n+\t  rtx label_rtx = gen_label_rtx ();\n+\t  char *label_buf, temp_buf[256];\n+\t  ASM_GENERATE_INTERNAL_LABEL (temp_buf, \"L\",\n+\t\t\t\t       CODE_LABEL_NUMBER (label_rtx));\n+\t  label_buf = temp_buf[0] == '*' ? temp_buf + 1 : temp_buf;\n+\t  labelname = get_identifier (label_buf);\n+\t  for (; insn && GET_CODE (insn) != NOTE; insn = PREV_INSN (insn));\n+\t  if (insn)\n+\t    line_number = NOTE_LINE_NUMBER (insn);\n+\t  add_compiler_stub (labelname, funname, line_number);\n+\t}\n+      else\n+\tlabelname = get_prev_label (funname);\n+\n+      sprintf (buf, \"jbsr %%z%d,%.246s\",\n+\t       operand_number, IDENTIFIER_POINTER (labelname));\n+      return buf;\n+    }\n+  else\n+    {\n+      sprintf (buf, \"bl %%z%d\", operand_number);\n+      return buf;\n+    }\n+}\n+\n+#endif /* RS6000_LONG_BRANCH */\n+\n+#define GEN_LOCAL_LABEL_FOR_SYMBOL(BUF,SYMBOL,LENGTH,N)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *symbol_ = (SYMBOL);\t\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    if (symbol_[0] == '\"')\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        sprintf(buffer_, \"\\\"L%d$%s\", (N), symbol_+1);\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else if (name_needs_quotes(symbol_))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        sprintf(buffer_, \"\\\"L%d$%s\\\"\", (N), symbol_);\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        sprintf(buffer_, \"L%d$%s\", (N), symbol_);\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Generate PIC and indirect symbol stubs.  */\n+\n+void\n+machopic_output_stub (file, symb, stub)\n+     FILE *file;\n+     const char *symb, *stub;\n+{\n+  unsigned int length;\n+  char *binder_name, *symbol_name, *lazy_ptr_name;\n+  char *local_label_0, *local_label_1, *local_label_2;\n+  static int label = 0;\n+\n+  label += 1;\n+\n+  length = strlen (stub);\n+  binder_name = alloca (length + 32);\n+  GEN_BINDER_NAME_FOR_STUB (binder_name, stub, length);\n+\n+  length = strlen (symb);\n+  symbol_name = alloca (length + 32);\n+  GEN_SYMBOL_NAME_FOR_SYMBOL (symbol_name, symb, length);\n+\n+  lazy_ptr_name = alloca (length + 32);\n+  GEN_LAZY_PTR_NAME_FOR_SYMBOL (lazy_ptr_name, symb, length);\n+\n+  local_label_0 = alloca (length + 32);\n+  GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_0, symb, length, 0);\n+\n+  local_label_1 = alloca (length + 32);\n+  GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_1, symb, length, 1);\n+\n+  local_label_2 = alloca (length + 32);\n+  GEN_LOCAL_LABEL_FOR_SYMBOL (local_label_2, symb, length, 2);\n+\n+  if (flag_pic == 2)\n+    machopic_picsymbol_stub_section ();\n+  else\n+    machopic_symbol_stub_section ();\n+\n+  fprintf (file, \"%s:\\n\", stub);\n+  fprintf (file, \"\\t.indirect_symbol %s\\n\", symbol_name);\n+\n+  if (flag_pic == 2)\n+    {\n+      fprintf (file, \"\\tmflr r0\\n\");\n+      fprintf (file, \"\\tbcl 20,31,%s\\n\", local_label_0);\n+      fprintf (file, \"%s:\\n\\tmflr r11\\n\", local_label_0);\n+      fprintf (file, \"\\taddis r11,r11,ha16(%s-%s)\\n\",\n+\t       lazy_ptr_name, local_label_0);\n+      fprintf (file, \"\\tmtlr r0\\n\");\n+      fprintf (file, \"\\tlwz r12,lo16(%s-%s)(r11)\\n\",\n+\t       lazy_ptr_name, local_label_0);\n+      fprintf (file, \"\\tmtctr r12\\n\");\n+      fprintf (file, \"\\taddi r11,r11,lo16(%s-%s)\\n\",\n+\t       lazy_ptr_name, local_label_0);\n+      fprintf (file, \"\\tbctr\\n\");\n+    }\n+  else\n+    fprintf (file, \"non-pure not supported\\n\");\n+  \n+  machopic_lazy_symbol_ptr_section ();\n+  fprintf (file, \"%s:\\n\", lazy_ptr_name);\n+  fprintf (file, \"\\t.indirect_symbol %s\\n\", symbol_name);\n+  fprintf (file, \"\\t.long dyld_stub_binding_helper\\n\");\n+}\n+\n+/* Legitimize PIC addresses.  If the address is already\n+   position-independent, we return ORIG.  Newly generated\n+   position-independent addresses go into a reg.  This is REG if non\n+   zero, otherwise we allocate register(s) as necessary.  */\n+\n+#define SMALL_INT(X) ((unsigned) (INTVAL(X) + 0x4000) < 0x8000)\n+\n+rtx\n+rs6000_machopic_legitimize_pic_address (orig, mode, reg)\n+     rtx orig;\n+     enum machine_mode mode;\n+     rtx reg;\n+{\n+  rtx base, offset;\n+\n+  if (reg == NULL && ! reload_in_progress && ! reload_completed)\n+    reg = gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (orig) == CONST)\n+    {\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n+\t\t\t\t\t\t\t Pmode, reg);\n+\t  offset = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n+\t\t\t\t\t\t\t   Pmode, reg);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (GET_CODE (offset) == CONST_INT)\n+\t{\n+\t  if (SMALL_INT (offset))\n+\t    return plus_constant_for_output (base, INTVAL (offset));\n+\t  else if (! reload_in_progress && ! reload_completed)\n+\t    offset = force_reg (Pmode, offset);\n+\t  else\n+\t    abort ();\n+\t}\n+      return gen_rtx (PLUS, Pmode, base, offset);\n+    }\n+\n+  /* Fall back on generic machopic code.  */\n+  return machopic_legitimize_pic_address (orig, mode, reg);\n+}\n+\n+/* This is just a placeholder to make linking work without having to\n+   add this to the generic Darwin EXTRA_SECTIONS.  If -mcall-aix is\n+   ever needed for Darwin (not too likely!) this would have to get a\n+   real definition.  */\n+\n+void\n+toc_section ()\n+{\n+}\n+\n+#endif /* TARGET_MACHO */"}, {"sha": "c1b964400cabb7b6fd90cdbe850181ac2c53a41b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -30,10 +30,12 @@ Boston, MA 02111-1307, USA.  */\n #define OBJECT_XCOFF 1\n #define OBJECT_ELF 2\n #define OBJECT_PEF 3\n+#define OBJECT_MACHO 4\n \n #define TARGET_ELF (TARGET_OBJECT_FORMAT == OBJECT_ELF)\n #define TARGET_AIX (TARGET_OBJECT_FORMAT == OBJECT_XCOFF)\n #define TARGET_MACOS (TARGET_OBJECT_FORMAT == OBJECT_PEF)\n+#define TARGET_MACHO (TARGET_OBJECT_FORMAT == OBJECT_MACHO)\n \n /* Print subsidiary information on the compiler version in use.  */\n #define TARGET_VERSION ;\n@@ -861,6 +863,10 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n       && flag_pic == 1)\t\t\t\t\t\t\t\\\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\t\\\n       = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n+  if (DEFAULT_ABI == ABI_DARWIN && flag_pic)\t\t\t\t\\\n+    global_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n+      = fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n+        = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n }\n \n /* Specify the registers used for certain standard purposes.\n@@ -1159,7 +1165,8 @@ enum rs6000_abi {\n   ABI_AIX,\t\t\t/* IBM's AIX */\n   ABI_AIX_NODESC,\t\t/* AIX calling sequence minus function descriptors */\n   ABI_V4,\t\t\t/* System V.4/eabi */\n-  ABI_SOLARIS\t\t\t/* Solaris */\n+  ABI_SOLARIS,\t\t\t/* Solaris */\n+  ABI_DARWIN\t\t\t/* Apple's Darwin (OS X kernel) */\n };\n \n extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n@@ -1210,13 +1217,14 @@ typedef struct rs6000_stack {\n \n /* Size of the outgoing register save area */\n #define RS6000_REG_SAVE ((DEFAULT_ABI == ABI_AIX\t\t\t\\\n-\t\t\t  || DEFAULT_ABI == ABI_AIX_NODESC)\t\t\\\n+\t\t\t  || DEFAULT_ABI == ABI_AIX_NODESC\t\t\\\n+\t\t\t  || DEFAULT_ABI == ABI_DARWIN)\t\t\t\\\n \t\t\t ? (TARGET_64BIT ? 64 : 32)\t\t\t\\\n \t\t\t : 0)\n \n /* Size of the fixed area on the stack */\n #define RS6000_SAVE_AREA \\\n-  (((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_AIX_NODESC) ? 24 : 8)\t\\\n+  (((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_DARWIN) ? 24 : 8)\t\\\n    << (TARGET_64BIT ? 1 : 0))\n \n /* MEM representing address to save the TOC register */\n@@ -1351,7 +1359,8 @@ typedef struct rs6000_stack {\n #define\tFP_ARG_AIX_MAX_REG 45\n #define\tFP_ARG_V4_MAX_REG  40\n #define\tFP_ARG_MAX_REG ((DEFAULT_ABI == ABI_AIX\t\t\t\t\\\n-\t\t\t || DEFAULT_ABI == ABI_AIX_NODESC)\t\t\\\n+\t\t\t || DEFAULT_ABI == ABI_AIX_NODESC\t\t\\\n+\t\t\t || DEFAULT_ABI == ABI_DARWIN)\t\t\t\\\n \t\t\t? FP_ARG_AIX_MAX_REG : FP_ARG_V4_MAX_REG)\n #define FP_ARG_NUM_REG (FP_ARG_MAX_REG - FP_ARG_MIN_REG + 1)\n \n@@ -1645,6 +1654,7 @@ typedef struct rs6000_args\n    abi's store the return address.  */\n #define RETURN_ADDRESS_OFFSET\t\t\t\t\t\t\\\n  ((DEFAULT_ABI == ABI_AIX\t\t\t\t\t\t\\\n+   || DEFAULT_ABI == ABI_DARWIN\t\t\t\t\t\t\\\n    || DEFAULT_ABI == ABI_AIX_NODESC)\t? (TARGET_32BIT ? 8 : 16) :\t\\\n   (DEFAULT_ABI == ABI_V4\t\t\t\t\t\t\\\n    || DEFAULT_ABI == ABI_SOLARIS)\t? (TARGET_32BIT ? 4 : 8) :\t\\"}, {"sha": "6bea69bd8abfdd790f692d64f5ecc0194e9f6b41", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -1449,6 +1449,14 @@\n    {cau|addis} %0,%1,%v2\"\n   [(set_attr \"length\" \"4,4,4,4\")])\n \n+(define_insn \"addsi3_high\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=b\")\n+        (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n+                 (high:SI (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_MACHO && !TARGET_64BIT\"\n+  \"{cau|addis} %0,%1,ha16(%2)\"\n+  [(set_attr \"length\" \"4\")])\n+\n (define_insn \"*addsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,?y,?y\")\n \t(compare:CC (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n@@ -7347,6 +7355,22 @@\n     {cal|la} %0,%2@l(%1)\n     {ai|addic} %0,%1,%K2\")\n \n+;; Mach-O PIC trickery.\n+(define_insn \"macho_high\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=b*r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"TARGET_MACHO && ! TARGET_64BIT\"\n+  \"{liu|lis} %0,ha16(%1)\")\n+\n+(define_insn \"macho_low\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b,!*r\")\n+\t\t   (match_operand 2 \"\" \"\")))]\n+   \"TARGET_MACHO && ! TARGET_64BIT\"\n+   \"@\n+    {cal %0,%a2@l(%1)|la %0,lo16(%2)(%1)}\n+    {cal %0,%a2@l(%1)|addic %0,%1,lo16(%2)}\")\n+\n ;; Set up a register with a value from the GOT table\n \n (define_expand \"movsi_got\"\n@@ -7406,6 +7430,15 @@\n   \"\"\n   \"{ rs6000_emit_move (operands[0], operands[1], SImode); DONE; }\")\n \n+(define_insn \"movsi_low\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+        (mem:SI (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+                           (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_MACHO && ! TARGET_64BIT\"\n+  \"{l|lwz} %0,lo16(%2)(%1)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"*movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n \t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,R,*h,r,r,0\"))]\n@@ -9257,6 +9290,21 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   \"{l|lwz} %0,%2-%3(%1)\"\n   [(set_attr \"type\" \"load\")])\n \n+(define_insn \"load_macho_picbase\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(unspec:SI [(const_int 0)] 15))]\n+  \"(DEFAULT_ABI == ABI_DARWIN) && flag_pic\"\n+  \"*\n+{\n+#if TARGET_MACHO\n+  char *picbase = machopic_function_base_name ();\n+  operands[1] = gen_rtx_SYMBOL_REF (Pmode, ggc_alloc_string (picbase, -1));\n+#endif\n+  return \\\"bcl 20,31,%1\\\\n%1:\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; If the TOC is shared over a translation unit, as happens with all\n ;; the kinds of PIC that we support, we need to restore the TOC\n ;; pointer only when jumping over units of translation.\n@@ -9376,6 +9424,11 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   \"\"\n   \"\n {\n+#if TARGET_MACHO\n+  if (flag_pic)\n+    operands[0] = machopic_indirect_call_target (operands[0]);\n+#endif\n+\n   if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != CONST_INT)\n     abort ();\n \n@@ -9389,6 +9442,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n       if (DEFAULT_ABI == ABI_V4\n           || DEFAULT_ABI == ABI_AIX_NODESC\n+\t  || DEFAULT_ABI == ABI_DARWIN\n \t  || DEFAULT_ABI == ABI_SOLARIS)\n \toperands[0] = force_reg (Pmode, operands[0]);\n \n@@ -9419,6 +9473,11 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   \"\"\n   \"\n {\n+#if TARGET_MACHO\n+  if (flag_pic)\n+    operands[1] = machopic_indirect_call_target (operands[1]);\n+#endif\n+\n   if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != CONST_INT)\n     abort ();\n \n@@ -9432,6 +9491,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n       if (DEFAULT_ABI == ABI_V4\n \t  || DEFAULT_ABI == ABI_AIX_NODESC\n+\t  || DEFAULT_ABI == ABI_DARWIN\n \t  || DEFAULT_ABI == ABI_SOLARIS)\n \toperands[0] = force_reg (Pmode, operands[0]);\n \n@@ -9664,6 +9724,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n    (clobber (match_scratch:SI 3 \"=l,l,l,l\"))]\n   \"DEFAULT_ABI == ABI_AIX_NODESC\n    || DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_DARWIN\n    || DEFAULT_ABI == ABI_SOLARIS\"\n   \"*\n {\n@@ -9696,6 +9757,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n    (clobber (match_scratch:SI 4 \"=l,l,l,l\"))]\n   \"DEFAULT_ABI == ABI_AIX_NODESC\n    || DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_DARWIN\n    || DEFAULT_ABI == ABI_SOLARIS\"\n   \"*\n {"}, {"sha": "c514fdaa000485b9d9248a730d6a088c90bbf6ab", "filename": "gcc/config/rs6000/t-darwin", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fconfig%2Frs6000%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-darwin?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -0,0 +1,26 @@\n+# Do not build libgcc1.\n+LIBGCC1 =\n+CROSS_LIBGCC1 =\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+darwin.o: $(srcdir)/config/darwin.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/darwin.c\n+\n+# Build the libraries for both hard and soft floating point\n+\n+MULTILIB_OPTIONS = msoft-float\n+MULTILIB_DIRNAMES = soft-float\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "081bcb2feb325ad45662dd1b132559565e83e888", "filename": "gcc/ginclude/stddef.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fginclude%2Fstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee890fe2a15b3ed799f92a951ea64825793deec8/gcc%2Fginclude%2Fstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstddef.h?ref=ee890fe2a15b3ed799f92a951ea64825793deec8", "patch": "@@ -234,6 +234,7 @@ typedef long ssize_t;\n #ifndef __WCHAR_T\n #ifndef _WCHAR_T_\n #ifndef _BSD_WCHAR_T_\n+#ifndef _BSD_WCHAR_T_DEFINED_    /* Darwin */\n #ifndef _WCHAR_T_DEFINED_\n #ifndef _WCHAR_T_DEFINED\n #ifndef _WCHAR_T_H\n@@ -298,6 +299,7 @@ typedef __WCHAR_TYPE__ wchar_t;\n #endif\n #endif\n #endif\n+#endif\n #endif /* __wchar_t__ */\n #undef\t__need_wchar_t\n #endif /* _STDDEF_H or __need_wchar_t.  */"}]}