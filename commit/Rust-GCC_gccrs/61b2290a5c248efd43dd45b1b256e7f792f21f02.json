{"sha": "61b2290a5c248efd43dd45b1b256e7f792f21f02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiMjI5MGE1YzI0OGVmZDQzZGQ0NWIxYjI1NmU3Zjc5MmYyMWYwMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-05T19:57:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-05T19:57:18Z"}, "message": "Make mode_for_size return an opt_mode\n\n...to make it consistent with int_mode_for_size etc.\n\nrequire () seems like the right choice in replace_reg_with_saved_mem\nbecause we use the chosen mode for saving and restoring registers,\nwhich cannot be done in BLKmode.  Similarly require () seems like\nthe right choice in calls related to secondary memory reloads (the ones\nin config/, and in get_secondary_mem) because the reload must always\nhave a defined mode, which e.g. determines the size of the slot.\n\nWe can use require () in simplify_subreg_concatn and assemble_integer\nbecause it isn't meaningful to create a subreg with BLKmode (for one\nthing, we couldn't tell then whether it was partial, paradoxical, etc.).\n\nmake_fract_type and make_accum_type must find a mode because that's\nwhat distinguishes accumulator FIXED_POINT_TYPEs from fractional\nFIXED_POINT_TYPEs.\n\n2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* machmode.h (opt_machine_mode): New type.\n\t(opt_mode<T>): Allow construction from anything that can be\n\tconverted to a T.\n\t(is_a, as_a, dyn_cast): Add overloads for opt_mode.\n\t(mode_for_size): Return an opt_machine_mode.\n\t* stor-layout.c (mode_for_size): Likewise.\n\t(mode_for_size_tree): Update call accordingly.\n\t(bitwise_mode_for_mode): Likewise.\n\t(make_fract_type): Likewise.\n\t(make_accum_type): Likewise.\n\t* caller-save.c (replace_reg_with_saved_mem): Update call\n\taccordingly.\n\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n\t* expmed.c (extract_bit_field_1): Likewise.\n\t* reload.c (get_secondary_mem): Likewise.\n\t* varasm.c (assemble_integer): Likewise.\n\t* lower-subreg.c (simplify_subreg_concatn): Likewise.  Move\n\tearly-out.\n\nFrom-SVN: r251728", "tree": {"sha": "d9340114f5023e3bd3cdef8624f2ae51f4132ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9340114f5023e3bd3cdef8624f2ae51f4132ca2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61b2290a5c248efd43dd45b1b256e7f792f21f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b2290a5c248efd43dd45b1b256e7f792f21f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b2290a5c248efd43dd45b1b256e7f792f21f02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b2290a5c248efd43dd45b1b256e7f792f21f02/comments", "author": null, "committer": null, "parents": [{"sha": "7773dca7d22dad2a9e6d2385584411308913ab1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7773dca7d22dad2a9e6d2385584411308913ab1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7773dca7d22dad2a9e6d2385584411308913ab1b"}], "stats": {"total": 165, "additions": 97, "deletions": 68}, "files": [{"sha": "4a7f676a1437080994f18c0d351b15f47c66cac4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -1,3 +1,27 @@\n+2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* machmode.h (opt_machine_mode): New type.\n+\t(opt_mode<T>): Allow construction from anything that can be\n+\tconverted to a T.\n+\t(is_a, as_a, dyn_cast): Add overloads for opt_mode.\n+\t(mode_for_size): Return an opt_machine_mode.\n+\t* stor-layout.c (mode_for_size): Likewise.\n+\t(mode_for_size_tree): Update call accordingly.\n+\t(bitwise_mode_for_mode): Likewise.\n+\t(make_fract_type): Likewise.\n+\t(make_accum_type): Likewise.\n+\t* caller-save.c (replace_reg_with_saved_mem): Update call\n+\taccordingly.\n+\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n+\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n+\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n+\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED_MODE): Likewise.\n+\t* expmed.c (extract_bit_field_1): Likewise.\n+\t* reload.c (get_secondary_mem): Likewise.\n+\t* varasm.c (assemble_integer): Likewise.\n+\t* lower-subreg.c (simplify_subreg_concatn): Likewise.  Move\n+\tearly-out.\n+\n 2017-09-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* machmode.h (decimal_float_mode_for_size): New function."}, {"sha": "619dac9a6894b0645db89ea9c0d3c7a81eb51c46", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -1161,7 +1161,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t    gcc_assert (smode != VOIDmode);\n \t    if (hard_regno_nregs [regno][smode] > 1)\n \t      smode = mode_for_size (GET_MODE_SIZE (mode) / nregs,\n-\t\t\t\t     GET_MODE_CLASS (mode), 0);\n+\t\t\t\t     GET_MODE_CLASS (mode), 0).require ();\n \t    XVECEXP (mem, 0, i) = gen_rtx_REG (smode, regno + i);\n \t  }\n     }"}, {"sha": "8bca5b3408b61c712a60df50c2c3894704cca2ac", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -508,7 +508,7 @@ enum reg_class {\n #define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT ? (MODE)\t\t\\\n    : GET_MODE_SIZE (MODE) >= 4 ? (MODE)\t\t\t\\\n-   : mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0))\n+   : mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0).require ())\n \n /* Return the class of registers that cannot change mode from FROM to TO.  */\n "}, {"sha": "873122caa2b86602aad2980c8fcae08959a07fdb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -1548,7 +1548,7 @@ enum reg_class\n    for integral modes that can be moved using 32 bit move.  */\n #define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\\\n   (GET_MODE_BITSIZE (MODE) < 32 && INTEGRAL_MODE_P (MODE)\t\\\n-   ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\t\\\n+   ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\\\n    : MODE)\n \n /* Return a class of registers that cannot change FROM mode to TO mode.  */"}, {"sha": "a52f866628af664556ec5668d849f5ba34e0c7ab", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -624,9 +624,9 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n \n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n    because the movsi and movsf patterns don't handle r/f moves.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n- (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n-  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\\\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\\\n+ (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\t\\\n+  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\\\n   : (MODE))\n \n "}, {"sha": "3c71a3fe1566a3698be0f99a22d1da24f71f9e3f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -1077,13 +1077,13 @@ extern char leaf_reg_remap[];\n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n    because the movsi and movsf patterns don't handle r/f moves.\n    For v8 we copy the default definition.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE) \\\n-  (TARGET_ARCH64\t\t\t\t\t\t\\\n-   ? (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n-      ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\t\\\n-      : MODE)\t\t\t\t\t\t\t\\\n-   : (GET_MODE_BITSIZE (MODE) < BITS_PER_WORD\t\t\t\\\n-      ? mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0)\t\\\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\t   \\\n+  (TARGET_ARCH64\t\t\t\t\t\t\t   \\\n+   ? (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\t   \\\n+      ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\t   \\\n+      : MODE)\t\t\t\t\t\t\t\t   \\\n+   : (GET_MODE_BITSIZE (MODE) < BITS_PER_WORD\t\t\t\t   \\\n+      ? mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0).require () \\\n       : MODE))\n \n /* Return the maximum number of consecutive registers"}, {"sha": "894e3698b32997730e902281f2b1a7e531d3e9c5", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -1711,14 +1711,9 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Get the mode of the field to use for atomic access or subreg\n      conversion.  */\n-  mode1 = mode;\n-  if (SCALAR_INT_MODE_P (tmode))\n-    {\n-      machine_mode try_mode = mode_for_size (bitsize,\n-\t\t\t\t\t\t  GET_MODE_CLASS (tmode), 0);\n-      if (try_mode != BLKmode)\n-\tmode1 = try_mode;\n-    }\n+  if (!SCALAR_INT_MODE_P (tmode)\n+      || !mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0).exists (&mode1))\n+    mode1 = mode;\n   gcc_assert (mode1 != BLKmode);\n \n   /* Extraction of a full MODE1 value can be done with a subreg as long"}, {"sha": "e34746b3fe4a66f472692299db53b6d452dea95c", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -616,20 +616,18 @@ simplify_subreg_concatn (machine_mode outermode, rtx op,\n   part = XVECEXP (op, 0, byte / inner_size);\n   partmode = GET_MODE (part);\n \n+  final_offset = byte % inner_size;\n+  if (final_offset + GET_MODE_SIZE (outermode) > inner_size)\n+    return NULL_RTX;\n+\n   /* VECTOR_CSTs in debug expressions are expanded into CONCATN instead of\n      regular CONST_VECTORs.  They have vector or integer modes, depending\n      on the capabilities of the target.  Cope with them.  */\n   if (partmode == VOIDmode && VECTOR_MODE_P (innermode))\n     partmode = GET_MODE_INNER (innermode);\n   else if (partmode == VOIDmode)\n-    {\n-      enum mode_class mclass = GET_MODE_CLASS (innermode);\n-      partmode = mode_for_size (inner_size * BITS_PER_UNIT, mclass, 0);\n-    }\n-\n-  final_offset = byte % inner_size;\n-  if (final_offset + GET_MODE_SIZE (outermode) > inner_size)\n-    return NULL_RTX;\n+    partmode = mode_for_size (inner_size * BITS_PER_UNIT,\n+\t\t\t      GET_MODE_CLASS (innermode), 0).require ();\n \n   return simplify_gen_subreg (outermode, part, partmode, final_offset);\n }"}, {"sha": "956e2c086f164242678e043f9b8e938c2e97cabb", "filename": "gcc/machmode.h", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef HAVE_MACHINE_MODES\n #define HAVE_MACHINE_MODES\n \n+typedef opt_mode<machine_mode> opt_machine_mode;\n+\n extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n@@ -237,6 +239,8 @@ class opt_mode\n \n   ALWAYS_INLINE opt_mode () : m_mode (E_VOIDmode) {}\n   ALWAYS_INLINE opt_mode (const T &m) : m_mode (m) {}\n+  template<typename U>\n+  ALWAYS_INLINE opt_mode (const U &m) : m_mode (T (m)) {}\n   ALWAYS_INLINE opt_mode (from_int m) : m_mode (machine_mode (m)) {}\n \n   machine_mode else_void () const;\n@@ -325,6 +329,13 @@ is_a (machine_mode m)\n   return T::includes_p (m);\n }\n \n+template<typename T, typename U>\n+inline bool\n+is_a (const opt_mode<U> &m)\n+{\n+  return T::includes_p (m.else_void ());\n+}\n+\n /* Assert that mode M has type T, and return it in that form.  */\n \n template<typename T>\n@@ -335,6 +346,13 @@ as_a (machine_mode m)\n   return typename mode_traits<T>::from_int (m);\n }\n \n+template<typename T, typename U>\n+inline T\n+as_a (const opt_mode<U> &m)\n+{\n+  return as_a <T> (m.else_void ());\n+}\n+\n /* Convert M to an opt_mode<T>.  */\n \n template<typename T>\n@@ -346,6 +364,13 @@ dyn_cast (machine_mode m)\n   return opt_mode<T> ();\n }\n \n+template<typename T, typename U>\n+inline opt_mode<T>\n+dyn_cast (const opt_mode<U> &m)\n+{\n+  return dyn_cast <T> (m.else_void ());\n+}\n+\n /* Return true if mode M has type T, storing it as a T in *RESULT\n    if so.  */\n \n@@ -627,11 +652,7 @@ GET_MODE_2XWIDER_MODE (const T &m)\n extern const unsigned char mode_complex[NUM_MACHINE_MODES];\n #define GET_MODE_COMPLEX_MODE(MODE) ((machine_mode) mode_complex[MODE])\n \n-/* Return the mode for data of a given size SIZE and mode class CLASS.\n-   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n-   The value is BLKmode if no other mode is found.  */\n-\n-extern machine_mode mode_for_size (unsigned int, enum mode_class, int);\n+extern opt_machine_mode mode_for_size (unsigned int, enum mode_class, int);\n \n /* Return the machine mode to use for a MODE_INT of SIZE bits, if one\n    exists.  If LIMIT is nonzero, modes wider than MAX_FIXED_MODE_SIZE"}, {"sha": "9d96700209ff0da12146c479edc3e9c2128df6da", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -578,7 +578,8 @@ get_secondary_mem (rtx x ATTRIBUTE_UNUSED, machine_mode mode,\n   mode = SECONDARY_MEMORY_NEEDED_MODE (mode);\n #else\n   if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD && INTEGRAL_MODE_P (mode))\n-    mode = mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0);\n+    mode = mode_for_size (BITS_PER_WORD,\n+\t\t\t  GET_MODE_CLASS (mode), 0).require ();\n #endif\n \n   /* If we already have made a MEM for this operand in MODE, return it.  */"}, {"sha": "f9a28e7c849636ea1bf0a14fb07d37be4c458f27", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -291,19 +291,19 @@ finalize_size_functions (void)\n   vec_free (size_functions);\n }\n \f\n-/* Return the machine mode to use for a nonscalar of SIZE bits.  The\n-   mode must be in class MCLASS, and have exactly that many value bits;\n-   it may have padding as well.  If LIMIT is nonzero, modes of wider\n-   than MAX_FIXED_MODE_SIZE will not be used.  */\n+/* Return a machine mode of class MCLASS with SIZE bits of precision,\n+   if one exists.  The mode may have padding bits as well the SIZE\n+   value bits.  If LIMIT is nonzero, disregard modes wider than\n+   MAX_FIXED_MODE_SIZE.  */\n \n-machine_mode\n+opt_machine_mode\n mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n {\n   machine_mode mode;\n   int i;\n \n   if (limit && size > MAX_FIXED_MODE_SIZE)\n-    return BLKmode;\n+    return opt_machine_mode ();\n \n   /* Get the first mode which has this size, in the specified class.  */\n   FOR_EACH_MODE_IN_CLASS (mode, mclass)\n@@ -316,7 +316,7 @@ mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n \t  && int_n_enabled_p[i])\n \treturn int_n_data[i].m;\n \n-  return BLKmode;\n+  return opt_machine_mode ();\n }\n \n /* Similar, except passed a tree node.  */\n@@ -333,11 +333,11 @@ mode_for_size_tree (const_tree size, enum mode_class mclass, int limit)\n   ui = uhwi;\n   if (uhwi != ui)\n     return BLKmode;\n-  return mode_for_size (ui, mclass, limit);\n+  return mode_for_size (ui, mclass, limit).else_blk ();\n }\n \n-/* Similar, but never return BLKmode; return the narrowest mode that\n-   contains at least the requested number of value bits.  */\n+/* Return the narrowest mode of class MCLASS that contains at least\n+   SIZE bits.  Abort if no such mode exists.  */\n \n machine_mode\n smallest_mode_for_size (unsigned int size, enum mode_class mclass)\n@@ -426,9 +426,8 @@ bitwise_mode_for_mode (machine_mode mode)\n   if (COMPLEX_MODE_P (mode))\n     {\n       machine_mode trial = mode;\n-      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT)\n-\ttrial = mode_for_size (bitsize, MODE_COMPLEX_INT, false);\n-      if (trial != BLKmode\n+      if ((GET_MODE_CLASS (trial) == MODE_COMPLEX_INT\n+\t   || mode_for_size (bitsize, MODE_COMPLEX_INT, false).exists (&trial))\n \t  && have_regs_of_mode[GET_MODE_INNER (trial)])\n \treturn trial;\n     }\n@@ -438,16 +437,15 @@ bitwise_mode_for_mode (machine_mode mode)\n   if (VECTOR_MODE_P (mode) || bitsize > MAX_FIXED_MODE_SIZE)\n     {\n       machine_mode trial = mode;\n-      if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n-\ttrial = mode_for_size (bitsize, MODE_VECTOR_INT, 0);\n-      if (trial != BLKmode\n+      if ((GET_MODE_CLASS (trial) == MODE_VECTOR_INT\n+\t   || mode_for_size (bitsize, MODE_VECTOR_INT, 0).exists (&trial))\n \t  && have_regs_of_mode[trial]\n \t  && targetm.vector_mode_supported_p (trial))\n \treturn trial;\n     }\n \n   /* Otherwise fall back on integers while honoring MAX_FIXED_MODE_SIZE.  */\n-  return mode_for_size (bitsize, MODE_INT, true);\n+  return mode_for_size (bitsize, MODE_INT, true).else_blk ();\n }\n \n /* Find a type that can be used for efficient bitwise operations on MODE.\n@@ -2543,13 +2541,9 @@ make_fract_type (int precision, int unsignedp, int satp)\n     TYPE_SATURATING (type) = 1;\n \n   /* Lay out the type: set its alignment, size, etc.  */\n-  if (unsignedp)\n-    {\n-      TYPE_UNSIGNED (type) = 1;\n-      SET_TYPE_MODE (type, mode_for_size (precision, MODE_UFRACT, 0));\n-    }\n-  else\n-    SET_TYPE_MODE (type, mode_for_size (precision, MODE_FRACT, 0));\n+  TYPE_UNSIGNED (type) = unsignedp;\n+  enum mode_class mclass = unsignedp ? MODE_UFRACT : MODE_FRACT;\n+  SET_TYPE_MODE (type, mode_for_size (precision, mclass, 0).require ());\n   layout_type (type);\n \n   return type;\n@@ -2569,13 +2563,9 @@ make_accum_type (int precision, int unsignedp, int satp)\n     TYPE_SATURATING (type) = 1;\n \n   /* Lay out the type: set its alignment, size, etc.  */\n-  if (unsignedp)\n-    {\n-      TYPE_UNSIGNED (type) = 1;\n-      SET_TYPE_MODE (type, mode_for_size (precision, MODE_UACCUM, 0));\n-    }\n-  else\n-    SET_TYPE_MODE (type, mode_for_size (precision, MODE_ACCUM, 0));\n+  TYPE_UNSIGNED (type) = unsignedp;\n+  enum mode_class mclass = unsignedp ? MODE_UACCUM : MODE_ACCUM;\n+  SET_TYPE_MODE (type, mode_for_size (precision, mclass, 0).require ());\n   layout_type (type);\n \n   return type;"}, {"sha": "f2a12f0495f229ac608cc21cf88aae980eaea416", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b2290a5c248efd43dd45b1b256e7f792f21f02/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=61b2290a5c248efd43dd45b1b256e7f792f21f02", "patch": "@@ -2780,8 +2780,8 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n       else\n \tmclass = MODE_INT;\n \n-      omode = mode_for_size (subsize * BITS_PER_UNIT, mclass, 0);\n-      imode = mode_for_size (size * BITS_PER_UNIT, mclass, 0);\n+      omode = mode_for_size (subsize * BITS_PER_UNIT, mclass, 0).require ();\n+      imode = mode_for_size (size * BITS_PER_UNIT, mclass, 0).require ();\n \n       for (i = 0; i < size; i += subsize)\n \t{"}]}