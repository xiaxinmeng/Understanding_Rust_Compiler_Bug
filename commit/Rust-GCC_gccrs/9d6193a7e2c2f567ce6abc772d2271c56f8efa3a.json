{"sha": "9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ2MTkzYTdlMmMyZjU2N2NlNmFiYzc3MmQyMjcxYzU2ZjhlZmEzYQ==", "commit": {"author": {"name": "Chen Liqin", "email": "liqin.gcc@gmail.com", "date": "2011-03-11T05:59:07Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2011-03-11T05:59:07Z"}, "message": "config.gcc (score-*-elf): add extra_parts .., update tmake_file, extra_objs.\n\n\t* config.gcc (score-*-elf): add extra_parts .., update tmake_file, extra_objs.\n\t* config/score/score3.c: Delete.\n\t* config/score/score3.h: Delete.\n\t* config/score/mul-div.S: Delete.\n\t* config/score/sfp-machine.h: Add new file.\n\t* config/score/constraints.md: Add new file.\n\t* config/score/t-score-softfp: Add new file.\n\t* config/score/t-score-elf: Remove score3.o and multilib generate.\n\t* config/score/score7.c (score7_const_ok_for_letter_p): Delete.\n\t(score7_extra_constraint): Delete.\n\t(score7_option_override): Remove unused code which mode to constraint.md.\n\t* config/score/score.c: Remove score3 and score5 define and code.\n\t* config/score/score.h: Remove score3 and score5 define and code.\n\t* config/score/score.md: Remove score3 template and unusal insn generate.\n\t* config/score/score.opt: Remove score3 and score5 options.\n\nFrom-SVN: r170864", "tree": {"sha": "444aeb9ddd49c6c2ae57f2bca8d5d3f2467a0e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/444aeb9ddd49c6c2ae57f2bca8d5d3f2467a0e11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/comments", "author": null, "committer": null, "parents": [{"sha": "fdc1806ad1a7f52470cb6c327b95b27c307d5917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc1806ad1a7f52470cb6c327b95b27c307d5917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc1806ad1a7f52470cb6c327b95b27c307d5917"}], "stats": {"total": 5660, "additions": 430, "deletions": 5230}, "files": [{"sha": "a76aca897001d49cec196a3211a5a5bb2b9707b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,3 +1,21 @@\n+2011-03-11  Chen Liqin <liqin.gcc@gmail.com>\n+\n+\t* config.gcc (score-*-elf): add extra_parts .., update tmake_file, extra_objs.\n+\t* config/score/score3.c: Delete.\n+\t* config/score/score3.h: Delete.\n+\t* config/score/mul-div.S: Delete.\n+\t* config/score/sfp-machine.h: Add new file.\n+\t* config/score/constraints.md: Add new file.\n+\t* config/score/t-score-softfp: Add new file.\n+\t* config/score/t-score-elf: Remove score3.o and multilib generate.\n+\t* config/score/score7.c (score7_const_ok_for_letter_p): Delete.\n+\t(score7_extra_constraint): Delete.\n+\t(score7_option_override): Remove unused code which mode to constraint.md.\n+\t* config/score/score.c: Remove score3 and score5 define and code.\n+\t* config/score/score.h: Remove score3 and score5 define and code.\n+\t* config/score/score.md: Remove score3 template and unusal insn generate.\n+\t* config/score/score.opt: Remove score3 and score5 options.\n+\n 2011-03-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/pa-hpux10.h (TARGET_OS_CPP_BUILTINS): Define _REENTRANT"}, {"sha": "24289d7c5786a2ce11da45036736dbf146211b89", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -2306,9 +2306,12 @@ s390x-ibm-tpf*)\n \textra_options=\"${extra_options} s390/tpf.opt\"\n \t;;\n score-*-elf)\n+\tgas=yes\n+\tgnu_ld=yes\n         tm_file=\"dbxelf.h elfos.h score/elf.h score/score.h newlib-stdint.h\"\n-        tmake_file=score/t-score-elf\n-        extra_objs=\"score7.o score3.o\"\n+\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n+        tmake_file=\"${tmake_file} score/t-score-elf score/t-score-softfp soft-fp/t-softfp\"\n+        extra_objs=\"score7.o\"\n         ;;\n sh-*-elf* | sh[12346l]*-*-elf* | \\\n sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\"}, {"sha": "d642e1278cb4f558adde760c90524702b68c191e", "filename": "gcc/config/score/constraints.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fconstraints.md?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -0,0 +1,93 @@\n+;; Constraint definitions for S+CORE\n+;; Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+;; Contributed by Sunnorth.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; -------------------------------------------------------------------------\n+;; Constraints\n+;; -------------------------------------------------------------------------\n+\n+;; Register constraints.\n+(define_register_constraint \"d\" \"G32_REGS\"\n+  \"r0 to r31\")\n+\n+(define_register_constraint \"e\" \"G16_REGS\"\n+  \"r0 to r15\")\n+\n+(define_register_constraint \"t\" \"T32_REGS\"\n+  \"r8 to r11 | r22 to r27\")\n+\n+(define_register_constraint \"h\" \"HI_REG\"\n+  \"hi\")\n+\n+(define_register_constraint \"l\" \"LO_REG\"\n+  \"lo\")\n+\n+(define_register_constraint \"x\" \"CE_REGS\"\n+  \"hi + lo\")\n+\n+(define_register_constraint \"q\" \"CN_REG\"\n+  \"cnt\")\n+\n+(define_register_constraint \"y\" \"LC_REG\"\n+  \"lcb\")\n+\n+(define_register_constraint \"z\" \"SC_REG\"\n+  \"scb\")\n+\n+(define_register_constraint \"a\" \"SP_REGS\"\n+  \"cnt + lcb + scb\")\n+\n+(define_register_constraint \"c\" \"CR_REGS\"\n+  \"cr0 to cr15\")\n+\n+;; Integer constant constraints.\n+(define_constraint \"I\"\n+  \"High 16-bit constant (32-bit constant with 16 LSBs zero).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xffff) == 0\")))\n+\n+(define_constraint \"J\"\n+  \"Unsigned 5 bit integer (in the range 0 to 31).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 31\")))\n+\n+(define_constraint \"K\"\n+  \"Unsigned 16 bit integer (in the range 0 to 65535).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 65535\")))\n+\n+(define_constraint \"L\"\n+  \"Signed 16 bit integer (in the range \u221232768 to 32767).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"M\"\n+  \"Unsigned 14 bit integer (in the range 0 to 16383).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 16383\")))\n+\n+(define_constraint \"N\"\n+  \"Signed 14 bit integer (in the range \u22128192 to 8191).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -8192 && ival <= 8191\")))\n+\n+(define_constraint \"Z\"\n+  \"Any SYMBOL_REF.\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"GET_CODE (op) == SYMBOL_REF\")))"}, {"sha": "4cd00cf99143cda9667a10530f43aa6c757b3338", "filename": "gcc/config/score/crti.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrti.asm?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,6 +1,6 @@\n # crti.asm for Sunplus S+CORE\n #\n-#   Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+#   Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.\n #\n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by the"}, {"sha": "8132388a0c7c99e97f47864e0fe6f88e34357cd0", "filename": "gcc/config/score/crtn.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrtn.asm?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,6 +1,6 @@\n # crtn.asm for Sunplus S+CORE\n \n-#   Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+#   Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.\n #\n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by the"}, {"sha": "2015b3b79d9c2705e61803496ba4004462b0b333", "filename": "gcc/config/score/mul-div.S", "status": "removed", "additions": 0, "deletions": 412, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fmul-div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fmul-div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmul-div.S?ref=fdc1806ad1a7f52470cb6c327b95b27c307d5917", "patch": "@@ -1,412 +0,0 @@\n-/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define ra r3\n-#define a0 r4\n-#define a1 r5\n-#define a2 r6\n-#define a3 r7\n-#define v0 r23\n-\n-#define t0 r8\n-#define t1 r9\n-#define t2 r10\n-#define t3 r11\n-#define t4 r22\n-\n-#ifndef __pic__\n-#if !defined(L_mulsi3) && !defined(L_divsi3)\n-       .text\n-       .global _flush_cache\n-#ifdef __score3__\n-_flush_cache:\n-        br      r3\n-#else\n-_flush_cache:\n-        srli    r9, r5, 4\n-        mv      r8, r4\n-        mtsr    r9, sr0\n-1:\n-        cache   0xe, [r8, 0]            # write back invalid dcache\n-        addi    r8, 16\n-        bcnz    1b\n-        mfcr    r8, cr4\n-        bittst! r8, 0x3                 # if LDM is enable, write back LDM\n-        beq!    6f\n-        ldi     r10, 0\n-        cache   0xc, [r10, 0]\n-6:\n-        bittst! r8, 0x2                 # if LIM is enable, refill it\n-        beq!    7f\n-        cache   0x4, [r10, 0]\n-7:\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        mv      r8, r4\n-        mtsr    r9, sr0\n-2:\n-        cache   0x2, [r8, 0]            # invalid unlock icache\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        addi    r8, 16\n-        bcnz    2b\n-        br      r3\n-#endif\n-#endif\n-\n-/* FUNCTION\n-   (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n-   REGISTERS:\n-        use     t0\n-        modify  a0\n-        a1      -> become 0\n-   NOTE:\n-   this seems to give better performance to just rotate and add.  */\n-\n-#ifdef L_mulsi3\n-        .text\n-        .global __umulsi3\n-        .global __mulsi3\n-        /* signed multiplication (32x32)  */\n-        .ent    __mulsi3\n-__umulsi3:\n-__mulsi3:\n-        li      t1, 0\n-__mulsi3_loop:\n-        andri.c t0, a1, 1               # t0 = multiplier[0]\n-        srli    a1, a1, 1               # a1 /= 2\n-        beq     __mulsi3_loop2          # skip if (t0 == 0)\n-        add     t1, t1, a0              # add multiplicand\n-__mulsi3_loop2:\n-        slli    a0, a0, 1               # multiplicand mul 2\n-        cmpi.c  a1, 0\n-        bne     __mulsi3_loop\n-        mv      r4, t1\n-        br      ra\n-        .end    __mulsi3\n-#endif /* L_mulsi3 */\n-\n-/* FUNCTION\n-   UINT32 (v0) = __udivsi3 (UINT32 (a0), UINT32 (a1));\n-   INT32 (v0) = __divsi3 (INT32 (a0),  INT32 (a1));\n-   UINT32 (v0) = __umodsi3 (UINT32 (a0), UINT32 (a1));\n-   INT32 (v0) = __modsi3 (INT32 (a0),  INT32 (a1));\n-   DESCRIPTION\n-   performs 32-bit division/modulo.\n-   REGISTERS\n-   used t0      bit-index\n-        t1\n-   modify a0    becomes remainer  */\n-#ifdef L_divsi3\n-        .text\n-        .global __udivsi3\n-        .global __umodsi3\n-        .global __divsi3\n-        .global __modsi3\n-\n-        /* unsigned division  */\n-        .ent    __udivsi3\n-__udivsi3:\n-        li      t4, 0\n-        cmpi.c  a1, 0\n-        beq     __uds_exit\n-        li      t0, 1\n-        blt     __uds_ok\n-__uds_normalize:\n-        cmp.c   a0, a1\n-        bcc     __uds_ok\n-        slli    a1, a1, 1\n-        slli    t0, t0, 1\n-        cmpi.c  a1, 0\n-        bge     __uds_normalize\n-__uds_ok:\n-__uds_loop2:\n-        cmp.c   a0, a1\n-        bcc     __uds_loop3\n-        sub     a0, a0, a1\n-        or      t4, t4, t0\n-__uds_loop3:\n-        srli    t0, t0, 1\n-        srli    a1, a1, 1\n-        cmpi.c  t0, 0\n-        bne     __uds_loop2\n-__uds_exit:\n-        mv      a1, a0\n-        mv      r4, t4\n-        br      ra\n-        .end    __udivsi3\n-\n-        /* unsigned modulus  */\n-        .ent    __umodsi3\n-__umodsi3:\n-        mv      t3, ra\n-        jl      __udivsi3\n-        mv      r4, a1\n-        br      t3\n-        .end    __umodsi3\n-\n-        /* abs and div  */\n-        .ent    __orgsi3\n-__orgsi3:\n-        cmpi.c  a0, 0\n-        bge     __orgsi3_a0p\n-        neg     a0, a0\n-__orgsi3_a0p:\n-        cmpi.c  a1, 0\n-        bge     __udivsi3\n-        neg     a1, a1\n-        b       __udivsi3               # goto udivsi3\n-        .end    __orgsi3\n-\n-        /* signed division  */\n-        .ent    __divsi3\n-__divsi3:\n-        mv      t3, ra\n-        xor     t2, a0, a1\n-        jl      __orgsi3\n-__divsi3_adjust:\n-        cmpi.c  t2, 0\n-        bge     __divsi3_exit\n-        neg     r4, r4\n-__divsi3_exit:\n-        br      t3\n-        .end    __divsi3\n-\n-        /* signed modulus  */\n-        .ent    __modsi3\n-__modsi3:\n-        mv      t3, ra\n-        mv      t2, a0\n-        jl      __orgsi3\n-        mv      r4, a1\n-        b       __divsi3_adjust\n-        .end    __modsi3\n-\n-#endif /* L_divsi3 */\n-#else /* -fPIC */\n-#if !defined(L_mulsi3) && !defined(L_divsi3)\n-        .set pic\n-        .text\n-        .global _flush_cache\n-#ifdef __score3__\n-_flush_cache:\n-        br      r3\n-#else\n-_flush_cache:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        srli    r9, r5, 4\n-        mv      r8, r4\n-        mtsr    r9, sr0\n-1:\n-        cache   0xe, [r8, 0]            # write back invalid dcache\n-        addi    r8, 16\n-        bcnz    1b\n-        mfcr    r8, cr4\n-        bittst! r8, 0x3                 # if LDM is enable, write back LDM\n-        beq!    6f\n-        ldi     r10, 0\n-        cache   0xc, [r10, 0]\n-6:\n-        bittst! r8, 0x2                 # if LIM is enable, refill it\n-        beq!    7f\n-        cache   0x4, [r10, 0]\n-7:\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        mv      r8, r4\n-        mtsr    r9, sr0\n-2:\n-        cache   0x2, [r8, 0]            # invalid unlock icache\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        #nop!\n-        addi    r8, 16\n-        bcnz    2b\n-        .cprestore r0, 12               # pic used\n-        addi    r0, 8                   # pic used\n-        br      r3\n-#endif\n-#endif\n-\n-/* FUNCTION\n-   (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n-   REGISTERS:\n-        use     t0\n-        modify  a0\n-        a1      -> become 0\n-   NOTE:\n-   this seems to give better performance to just rotate and add.  */\n-\n-#ifdef L_mulsi3\n-        .set pic\n-        .text\n-        .global __umulsi3\n-        .global __mulsi3\n-        /* signed multiplication (32x32)  */\n-        .ent    __mulsi3\n-__umulsi3:\n-__mulsi3:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        li      t1, 0\n-__mulsi3_loop:\n-        andri.c t0, a1, 1               # t0 = multiplier[0]\n-        srli    a1, a1, 1               # a1 /= 2\n-        beq     __mulsi3_loop2          # skip if (t0 == 0)\n-        add     t1, t1, a0              # add multiplicand\n-__mulsi3_loop2:\n-        slli    a0, a0, 1               # multiplicand mul 2\n-        cmpi.c  a1, 0\n-        bne     __mulsi3_loop\n-        mv      r4, t1\n-        .cprestore r0, 12               # pic used\n-        addi    r0, 8                   # pic used\n-        br      ra\n-        .end    __mulsi3\n-#endif /* L_mulsi3 */\n-\n-/* FUNCTION\n-   UINT32 (v0) = __udivsi3 (UINT32 (a0), UINT32 (a1));\n-   INT32 (v0) = __divsi3 (INT32 (a0),  INT32 (a1));\n-   UINT32 (v0) = __umodsi3 (UINT32 (a0), UINT32 (a1));\n-   INT32 (v0) = __modsi3 (INT32 (a0),  INT32 (a1));\n-   DESCRIPTION\n-   performs 32-bit division/modulo.\n-   REGISTERS\n-   used t0      bit-index\n-        t1\n-   modify a0    becomes remainer  */\n-#ifdef L_divsi3\n-        .set pic\n-        .text\n-        .global __udivsi3\n-        .global __umodsi3\n-        .global __divsi3\n-        .global __modsi3\n-\n-        /* unsigned division  */\n-        .ent    __udivsi3\n-__udivsi3:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        li      t4, 0\n-        cmpi.c  a1, 0\n-        beq     __uds_exit\n-        li      t0, 1\n-        blt     __uds_ok\n-__uds_normalize:\n-        cmp.c   a0, a1\n-        bcc     __uds_ok\n-        slli    a1, a1, 1\n-        slli    t0, t0, 1\n-        cmpi.c  a1, 0\n-        bge     __uds_normalize\n-__uds_ok:\n-__uds_loop2:\n-        cmp.c   a0, a1\n-        bcc     __uds_loop3\n-        sub     a0, a0, a1\n-        or      t4, t4, t0\n-__uds_loop3:\n-        srli    t0, t0, 1\n-        srli    a1, a1, 1\n-        cmpi.c  t0, 0\n-        bne     __uds_loop2\n-__uds_exit:\n-        mv      a1, a0\n-        mv      r4, t4\n-        .cprestore r0, 12               # pic used\n-        addi    r0, 8                   # pic used\n-        br      ra\n-        .end    __udivsi3\n-\n-        /* unsigned modulus  */\n-        .ent    __umodsi3\n-__umodsi3:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        li      t1, 0\n-        mv      t3, ra\n-        la      r29, __udivsi3\n-        brl     r29\n-        mv      r4, a1\n-        .cprestore r0, 12               # pic used\n-        addi    r0, 8                   # pic used\n-        br      t3\n-        .end    __umodsi3\n-\n-        /* abs and div  */\n-        .ent    __orgsi3\n-__orgsi3:\n-        cmpi.c  a0, 0\n-        bge     __orgsi3_a0p\n-        neg     a0, a0\n-__orgsi3_a0p:\n-        cmpi.c  a1, 0\n-        bge     __udivsi3\n-        neg     a1, a1\n-        b       __udivsi3               # goto udivsi3\n-        .end    __orgsi3\n-\n-        /* signed division  */\n-        .ent    __divsi3\n-__divsi3:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        mv      t3, ra\n-        xor     t2, a0, a1\n-        la      r29, __orgsi3\n-        brl     r29\n-__divsi3_adjust:\n-        cmpi.c  t2, 0\n-        bge     __divsi3_exit\n-        neg     r4, r4\n-__divsi3_exit:\n-        .cprestore r0, 12               # pic used\n-        addi    r0, 8                   # pic used\n-        br      t3\n-        .end    __divsi3\n-\n-        /* signed modulus  */\n-        .ent    __modsi3\n-__modsi3:\n-        addi    r0, -8                  # pic used\n-        .cpload r29                     # pic used\n-        mv      t3, ra\n-        mv      t2, a0\n-        la      r29, __orgsi3\n-        brl     r29\n-        mv      r4, a1\n-        b       __divsi3_adjust\n-        .end    __modsi3\n-\n-#endif /*L_divsi3 */\n-#endif"}, {"sha": "4ddc05b1bcbb71a096b6797e5ea9acc1fa65f0b5", "filename": "gcc/config/score/score-generic.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-generic.md?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,6 +1,6 @@\n ;;  Machine description for Sunplus S+CORE\n ;;  Sunplus S+CORE Pipeline Description\n-;;  Copyright (C) 2005, 2007\n+;;  Copyright (C) 2005, 2007, 2010\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Sunnorth.\n "}, {"sha": "01031881a1ee0deb8e33ba09f356501597057e62", "filename": "gcc/config/score/score-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-modes.def?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,5 +1,5 @@\n /* score-modes.def for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n "}, {"sha": "99695bfc5cbddbd2e0baed02d9ec69f7a9bc89f5", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 104, "deletions": 613, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -47,7 +47,6 @@\n #include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"score7.h\"\n-#include \"score3.h\"\n #include \"df.h\"\n \n static void score_option_override (void);\n@@ -73,10 +72,13 @@ static const struct default_options score_option_optimization_table[] =\n \n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS     TARGET_DEFAULT\n+\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION            score_handle_option\n+\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE          score_option_override\n+\n #undef TARGET_OPTION_OPTIMIZATION_TABLE\n #define TARGET_OPTION_OPTIMIZATION_TABLE score_option_optimization_table\n \n@@ -156,12 +158,10 @@ enum reg_class score_char_to_class[256];\n static bool\n score_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_return_in_memory (type, fndecl);\n-  else if (TARGET_SCORE3)\n-    return score3_return_in_memory (type, fndecl);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Return nonzero when an argument must be passed by reference.  */\n@@ -181,10 +181,8 @@ score_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n                        tree function)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function);\n-  else if (TARGET_SCORE3)\n-    score3_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function);\n   else\n     gcc_unreachable ();\n }\n@@ -201,10 +199,8 @@ score_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n static void\n score_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_function_prologue (file, size);\n-  else if (TARGET_SCORE3)\n-    score3_function_prologue (file, size);\n   else\n     gcc_unreachable ();\n }\n@@ -215,10 +211,8 @@ static void\n score_function_epilogue (FILE *file,\n                          HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_function_epilogue (file, size);\n-  else if (TARGET_SCORE3)\n-    score3_function_epilogue (file, size);\n   else\n     gcc_unreachable ();\n }\n@@ -236,48 +230,32 @@ static section *\n score_select_rtx_section (enum machine_mode mode, rtx x,\n                           unsigned HOST_WIDE_INT align)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_select_rtx_section (mode, x, align);\n-  else if (TARGET_SCORE3)\n-    return score3_select_rtx_section (mode, x, align);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_IN_SMALL_DATA_P.  */\n static bool\n score_in_small_data_p (const_tree decl)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_in_small_data_p (decl);\n-  else if (TARGET_SCORE3)\n-    return score3_in_small_data_p (decl);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_ASM_FILE_START.  */\n static void\n score_asm_file_start (void)\n {\n-  if (TARGET_SCORE5)\n-    fprintf (asm_out_file, \"# Sunplus S+core5 %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else if (TARGET_SCORE5U)\n-    fprintf (asm_out_file, \"# Sunplus S+core5u %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else if (TARGET_SCORE7D)\n+  if (TARGET_SCORE7D)\n     fprintf (asm_out_file, \"# Sunplus S+core7d %s rev=%s\\n\",\n              TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n   else if (TARGET_SCORE7)\n     fprintf (asm_out_file, \"# Sunplus S+core7 %s rev=%s\\n\",\n              TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else if (TARGET_SCORE3D)\n-    fprintf (asm_out_file, \"# Sunplus S+core3d %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else if (TARGET_SCORE3)\n-    fprintf (asm_out_file, \"# Sunplus S+core3 %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n   else\n     fprintf (asm_out_file, \"# Sunplus S+core unknown %s rev=%s\\n\",\n              TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n@@ -293,17 +271,13 @@ score_asm_file_start (void)\n static void\n score_asm_file_end (void)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_asm_file_end ();\n-  else if (TARGET_SCORE3)\n-    score3_asm_file_end ();\n   else\n     gcc_unreachable ();\n }\n \n-#define MASK_ALL_CPU_BITS \\\n-  (MASK_SCORE5 | MASK_SCORE5U | MASK_SCORE7 | MASK_SCORE7D \\\n-   | MASK_SCORE3 | MASK_SCORE3D)\n+#define MASK_ALL_CPU_BITS\t(MASK_SCORE7 | MASK_SCORE7D)\n \n /* Implement TARGET_HANDLE_OPTION.  */\n static bool\n@@ -316,25 +290,8 @@ score_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n       target_flags |= MASK_SCORE7 | MASK_SCORE7D;\n       return true;\n \n-    case OPT_mscore3d:\n-      target_flags &= ~(MASK_ALL_CPU_BITS);\n-      target_flags |= MASK_SCORE3 | MASK_SCORE3D;\n-      return true;\n-\n     case OPT_march_:\n-      if (strcmp (arg, \"score5\") == 0)\n-        {\n-          target_flags &= ~(MASK_ALL_CPU_BITS);\n-          target_flags |= MASK_SCORE5;\n-          return true;\n-        }\n-      else if (strcmp (arg, \"score5u\") == 0)\n-        {\n-          target_flags &= ~(MASK_ALL_CPU_BITS);\n-          target_flags |= MASK_SCORE5U;\n-          return true;\n-        }\n-      else if (strcmp (arg, \"score7\") == 0)\n+      if (strcmp (arg, \"score7\") == 0)\n         {\n           target_flags &= ~(MASK_ALL_CPU_BITS);\n           target_flags |= MASK_SCORE7;\n@@ -346,18 +303,6 @@ score_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n           target_flags |= MASK_SCORE7 | MASK_SCORE7D;\n           return true;\n         }\n-      else if (strcmp (arg, \"score3\") == 0)\n-        {\n-          target_flags &= ~(MASK_ALL_CPU_BITS);\n-          target_flags |= MASK_SCORE3;\n-          return true;\n-        }\n-      else if (strcmp (arg, \"score3d\") == 0)\n-        {\n-          target_flags &= ~(MASK_ALL_CPU_BITS);\n-          target_flags |= MASK_SCORE3 | MASK_SCORE3D;\n-          return true;\n-        }\n       else\n         return false;\n \n@@ -370,36 +315,28 @@ score_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n static void\n score_option_override (void)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_option_override ();\n-  else if (TARGET_SCORE3)\n-    score3_option_override ();\n-  else\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_option_override ();\n }\n \n /* Implement REGNO_REG_CLASS macro.  */\n int\n score_reg_class (int regno)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_reg_class (regno);\n-  else if (TARGET_SCORE3)\n-    return score3_reg_class (regno);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_preferred_reload_class (x, rclass);\n-  else if (TARGET_SCORE3)\n-    return score3_preferred_reload_class (x, rclass);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n@@ -409,49 +346,22 @@ score_secondary_reload_class (enum reg_class rclass,\n                               enum machine_mode mode ATTRIBUTE_UNUSED,\n                               rtx x)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_secondary_reload_class (rclass, mode, x);\n-  else if (TARGET_SCORE3)\n-    return score3_secondary_reload_class (rclass, mode, x);\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Implement CONST_OK_FOR_LETTER_P macro.  */\n-int\n-score_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n-{\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_const_ok_for_letter_p (value, c);\n-  else if (TARGET_SCORE3)\n-    return score3_const_ok_for_letter_p (value, c);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n-/* Implement EXTRA_CONSTRAINT macro.  */\n-int\n-score_extra_constraint (rtx op, char c)\n-{\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_extra_constraint (op, c);\n-  else if (TARGET_SCORE3)\n-    return score3_extra_constraint (op, c);\n-\n-  gcc_unreachable ();\n-}\n \n /* Return truth value on whether or not a given hard register\n    can support a given mode.  */\n int\n score_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_hard_regno_mode_ok (regno, mode);\n-  else if (TARGET_SCORE3)\n-    return score3_hard_regno_mode_ok (regno, mode);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* We can always eliminate to the hard frame pointer.  We can eliminate\n@@ -471,12 +381,10 @@ HOST_WIDE_INT\n score_initial_elimination_offset (int from,\n                                   int to ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_initial_elimination_offset (from, to);\n-  else if (TARGET_SCORE3)\n-    return score3_initial_elimination_offset (from, to);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Argument support functions.  */\n@@ -495,10 +403,8 @@ static void\n score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n                             const_tree type, bool named)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_function_arg_advance (cum, mode, type, named);\n-  else if (TARGET_SCORE3)\n-    score3_function_arg_advance (cum, mode, type, named);\n   else\n     gcc_unreachable ();\n }\n@@ -508,25 +414,21 @@ int\n score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n                          enum machine_mode mode, tree type, bool named)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_arg_partial_bytes (cum, mode, type, named);\n-  else if (TARGET_SCORE3)\n-    return score3_arg_partial_bytes (cum, mode, type, named);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_FUNCTION_ARG hook.  */\n static rtx\n score_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n                     const_tree type, bool named)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_function_arg (cum, mode, type, named);\n-  else if (TARGET_SCORE3)\n-    return score3_function_arg (cum, mode, type, named);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n@@ -536,22 +438,18 @@ rtx\n score_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n                       enum machine_mode mode)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_function_value (valtype, func, mode);\n-  else if (TARGET_SCORE3)\n-    return score3_function_value (valtype, func, mode);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.  */\n static void\n score_asm_trampoline_template (FILE *f)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_asm_trampoline_template (f);\n-  else if (TARGET_SCORE3)\n-    score3_asm_trampoline_template (f);\n   else\n     gcc_unreachable ();\n }\n@@ -560,37 +458,30 @@ score_asm_trampoline_template (FILE *f)\n static void\n score_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n-  /* ??? These two routines are identical.  */\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if ( TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_trampoline_init (m_tramp, fndecl, chain_value);\n-  else if (TARGET_SCORE3)\n-    score3_trampoline_init (m_tramp, fndecl, chain_value);\n-  else\n+  else  \n     gcc_unreachable ();\n }\n \n /* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n int\n score_regno_mode_ok_for_base_p (int regno, int strict)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_regno_mode_ok_for_base_p (regno, strict);\n-  else if (TARGET_SCORE3)\n-    return score3_regno_mode_ok_for_base_p (regno, strict);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_LEGITIMIZE_ADDRESS_P.  */\n static bool\n score_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_legitimate_address_p (mode, x, strict);\n-  else if (TARGET_SCORE3)\n-    return score3_legitimate_address_p (mode, x, strict);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n@@ -600,12 +491,10 @@ static rtx\n score_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_legitimize_address (x);\n-  else if (TARGET_SCORE3)\n-    return score3_legitimize_address (x);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Return a number assessing the cost of moving a register in class\n@@ -614,74 +503,62 @@ int\n score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                           enum reg_class from, enum reg_class to)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_register_move_cost (mode, from, to);\n-  else if (TARGET_SCORE3)\n-    return score3_register_move_cost (mode, from, to);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_RTX_COSTS macro.  */\n bool\n score_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t\t bool speed ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_rtx_costs (x, code, outer_code, total, speed);\n-  else if (TARGET_SCORE3)\n-    return score3_rtx_costs (x, code, outer_code, total, speed);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement TARGET_ADDRESS_COST macro.  */\n int\n score_address_cost (rtx addr,\n \t\t    bool speed ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_address_cost (addr);\n-  else if (TARGET_SCORE3)\n-    return score3_address_cost (addr);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement ASM_OUTPUT_EXTERNAL macro.  */\n int\n score_output_external (FILE *file ATTRIBUTE_UNUSED,\n                        tree decl, const char *name)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_output_external (file, decl, name);\n-  else if (TARGET_SCORE3)\n-    return score3_output_external (file, decl, name);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n    back to a previous frame.  */\n rtx\n score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_return_addr (count, frame);\n-  else if (TARGET_SCORE3)\n-    return score3_return_addr (count, frame);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Implement PRINT_OPERAND macro.  */\n void\n score_print_operand (FILE *file, rtx op, int c)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_print_operand (file, op, c);\n-  else if (TARGET_SCORE3)\n-    score3_print_operand (file, op, c);\n   else\n     gcc_unreachable ();\n }\n@@ -690,10 +567,8 @@ score_print_operand (FILE *file, rtx op, int c)\n void\n score_print_operand_address (FILE *file, rtx x)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_print_operand_address (file, x);\n-  else if (TARGET_SCORE3)\n-    score3_print_operand_address (file, x);\n   else\n     gcc_unreachable ();\n }\n@@ -702,12 +577,10 @@ score_print_operand_address (FILE *file, rtx x)\n enum machine_mode\n score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_select_cc_mode (op, x, y);\n-  else if (TARGET_SCORE3)\n-    return score3_select_cc_mode (op, x, y);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Return true if X is a symbolic constant that can be calculated in\n@@ -716,22 +589,18 @@ score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n int\n score_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_symbolic_constant_p (x, symbol_type);\n-  else if (TARGET_SCORE3)\n-    return score3_symbolic_constant_p (x, symbol_type);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Generate the prologue instructions for entry into a S+core function.  */\n void\n score_prologue (void)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_prologue ();\n-  else if (TARGET_SCORE3)\n-    score3_prologue ();\n   else\n     gcc_unreachable ();\n }\n@@ -740,10 +609,8 @@ score_prologue (void)\n void\n score_epilogue (int sibcall_p)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_epilogue (sibcall_p);\n-  else if (TARGET_SCORE3)\n-    score3_epilogue (sibcall_p);\n   else\n     gcc_unreachable ();\n }\n@@ -752,10 +619,8 @@ score_epilogue (int sibcall_p)\n void\n score_call (rtx *ops, bool sib)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_call (ops, sib);\n-  else if (TARGET_SCORE3)\n-    score3_call (ops, sib);\n   else\n     gcc_unreachable ();\n }\n@@ -764,21 +629,17 @@ score_call (rtx *ops, bool sib)\n void\n score_call_value (rtx *ops, bool sib)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_call_value (ops, sib);\n-  else if (TARGET_SCORE3)\n-    score3_call_value (ops, sib);\n   else\n     gcc_unreachable ();\n }\n \n void\n score_movsicc (rtx *ops)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_movsicc (ops);\n-  else if (TARGET_SCORE3)\n-    score3_movsicc (ops);\n   else\n     gcc_unreachable ();\n }\n@@ -787,21 +648,17 @@ score_movsicc (rtx *ops)\n void\n score_movdi (rtx *ops)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_movdi (ops);\n-  else if (TARGET_SCORE3)\n-    score3_movdi (ops);\n   else\n     gcc_unreachable ();\n }\n \n void\n score_zero_extract_andi (rtx *ops)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     score7_zero_extract_andi (ops);\n-  else if (TARGET_SCORE3)\n-    score3_zero_extract_andi (ops);\n   else\n     gcc_unreachable ();\n }\n@@ -810,428 +667,62 @@ score_zero_extract_andi (rtx *ops)\n const char *\n score_move (rtx *ops)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_move (ops);\n-  else if (TARGET_SCORE3)\n-    return score3_move (ops);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Output asm insn for load.  */\n const char *\n score_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_linsn (ops, unit, sign);\n-  else if (TARGET_SCORE3)\n-    return score3_linsn (ops, unit, sign);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Output asm insn for store.  */\n const char *\n score_sinsn (rtx *ops, enum score_mem_unit unit)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_sinsn (ops, unit);\n-  else if (TARGET_SCORE3)\n-    return score3_sinsn (ops, unit);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Output asm insn for load immediate.  */\n const char *\n score_limm (rtx *ops)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_limm (ops);\n-  else if (TARGET_SCORE3)\n-    return score3_limm (ops);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n \n /* Generate add insn.  */\n const char *\n score_select_add_imm (rtx *ops, bool set_cc)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_select_add_imm (ops, set_cc);\n-  else if (TARGET_SCORE3)\n-    return score3_select_add_imm (ops, set_cc);\n-\n-  gcc_unreachable ();\n+  else\n+    gcc_unreachable ();\n }\n \n /* Output arith insn.  */\n const char *\n score_select (rtx *ops, const char *inst_pre,\n             bool commu, const char *letter, bool set_cc)\n {\n-  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+  if (TARGET_SCORE7 || TARGET_SCORE7D)\n     return score7_select (ops, inst_pre, commu, letter, set_cc);\n-  else if (TARGET_SCORE3)\n-    return score3_select (ops, inst_pre, commu, letter, set_cc);\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Output switch case insn, only supported in score3.  */\n-const char *\n-score_output_casesi (rtx *operands)\n-{\n-  if (TARGET_SCORE3)\n-    return score3_output_casesi (operands);\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Output rpush insn, only supported in score3.  */\n-const char *\n-score_rpush (rtx *operands)\n-{\n-  if (TARGET_SCORE3)\n-    return score3_rpush (operands);\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Output rpop insn, only supported in score3.  */\n-const char *\n-score_rpop (rtx *operands)\n-{\n-  if (TARGET_SCORE3)\n-    return score3_rpop (operands);\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Emit lcb/lce insns.  */\n-bool\n-score_unaligned_load (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx len = ops[2];\n-  rtx off = ops[3];\n-  rtx addr_reg;\n-\n-  if (INTVAL (len) != BITS_PER_WORD\n-      || (INTVAL (off) % BITS_PER_UNIT) != 0)\n-    return false;\n-\n-  gcc_assert (GET_MODE_SIZE (GET_MODE (dst)) == GET_MODE_SIZE (SImode));\n-\n-  addr_reg = copy_addr_to_reg (XEXP (src, 0));\n-  emit_insn (gen_move_lcb (addr_reg, addr_reg));\n-  emit_insn (gen_move_lce (addr_reg, addr_reg, dst));\n-\n-  return true;\n-}\n-\n-/* Emit scb/sce insns.  */\n-bool\n-score_unaligned_store (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx len = ops[1];\n-  rtx off = ops[2];\n-  rtx src = ops[3];\n-  rtx addr_reg;\n-\n-  if (INTVAL(len) != BITS_PER_WORD\n-      || (INTVAL(off) % BITS_PER_UNIT) != 0)\n-    return false;\n-\n-  gcc_assert (GET_MODE_SIZE (GET_MODE (src)) == GET_MODE_SIZE (SImode));\n-\n-  addr_reg = copy_addr_to_reg (XEXP (dst, 0));\n-  emit_insn (gen_move_scb (addr_reg, addr_reg, src));\n-  emit_insn (gen_move_sce (addr_reg, addr_reg));\n-\n-  return true;\n-}\n-\n-/* If length is short, generate move insns straight.  */\n-static void\n-score_block_move_straight (rtx dst, rtx src, HOST_WIDE_INT length)\n-{\n-  HOST_WIDE_INT leftover;\n-  int i, reg_count;\n-  rtx *regs;\n-\n-  leftover = length % UNITS_PER_WORD;\n-  length -= leftover;\n-  reg_count = length / UNITS_PER_WORD;\n-\n-  regs = XALLOCAVEC (rtx, reg_count);\n-  for (i = 0; i < reg_count; i++)\n-    regs[i] = gen_reg_rtx (SImode);\n-\n-  /* Load from src to regs.  */\n-  if (MEM_ALIGN (src) >= BITS_PER_WORD)\n-    {\n-      HOST_WIDE_INT offset = 0;\n-      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n-        emit_move_insn (regs[i], adjust_address (src, SImode, offset));\n-    }\n-  else if (reg_count >= 1)\n-    {\n-      rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n-\n-      emit_insn (gen_move_lcb (src_reg, src_reg));\n-      for (i = 0; i < (reg_count - 1); i++)\n-        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n-      emit_insn (gen_move_lce (src_reg, src_reg, regs[i]));\n-    }\n-\n-  /* Store regs to dest.  */\n-  if (MEM_ALIGN (dst) >= BITS_PER_WORD)\n-    {\n-      HOST_WIDE_INT offset = 0;\n-      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n-        emit_move_insn (adjust_address (dst, SImode, offset), regs[i]);\n-    }\n-  else if (reg_count >= 1)\n-    {\n-      rtx dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n-\n-      emit_insn (gen_move_scb (dst_reg, dst_reg, regs[0]));\n-      for (i = 1; i < reg_count; i++)\n-        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n-      emit_insn (gen_move_sce (dst_reg, dst_reg));\n-    }\n-\n-  /* Mop up any left-over bytes.  */\n-  if (leftover > 0)\n-    {\n-      src = adjust_address (src, BLKmode, length);\n-      dst = adjust_address (dst, BLKmode, length);\n-      move_by_pieces (dst, src, leftover,\n-                      MIN (MEM_ALIGN (src), MEM_ALIGN (dst)), 0);\n-    }\n-}\n-\n-/* Generate loop head when dst or src is unaligned.  */\n-static void\n-score_block_move_loop_head (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                            rtx src_reg, HOST_WIDE_INT src_align,\n-                            HOST_WIDE_INT length)\n-{\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  rtx temp = gen_reg_rtx (SImode);\n-\n-  gcc_assert (length == UNITS_PER_WORD);\n-\n-  if (src_unaligned)\n-    {\n-      emit_insn (gen_move_lcb (src_reg, src_reg));\n-      emit_insn (gen_move_lcw (src_reg, src_reg, temp));\n-    }\n-  else\n-    emit_insn (gen_move_lw_a (src_reg,\n-                              src_reg, gen_int_mode (4, SImode), temp));\n-\n-  if (dst_unaligned)\n-    emit_insn (gen_move_scb (dst_reg, dst_reg, temp));\n-  else\n-    emit_insn (gen_move_sw_a (dst_reg,\n-                              dst_reg, gen_int_mode (4, SImode), temp));\n-}\n-\n-/* Generate loop body, copy length bytes per iteration.  */\n-static void\n-score_block_move_loop_body (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                            rtx src_reg, HOST_WIDE_INT src_align,\n-                            HOST_WIDE_INT length)\n-{\n-  int reg_count = length / UNITS_PER_WORD;\n-  rtx *regs = XALLOCAVEC (rtx, reg_count);\n-  int i;\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  for (i = 0; i < reg_count; i++)\n-    regs[i] = gen_reg_rtx (SImode);\n-\n-  if (src_unaligned)\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n-    }\n-  else\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_lw_a (src_reg,\n-                                  src_reg, gen_int_mode (4, SImode), regs[i]));\n-    }\n-\n-  if (dst_unaligned)\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n-    }\n   else\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_sw_a (dst_reg,\n-                                  dst_reg, gen_int_mode (4, SImode), regs[i]));\n-    }\n-}\n-\n-/* Generate loop foot, copy the leftover bytes.  */\n-static void\n-score_block_move_loop_foot (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                            rtx src_reg, HOST_WIDE_INT src_align,\n-                            HOST_WIDE_INT length)\n-{\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  HOST_WIDE_INT leftover;\n-\n-  leftover = length % UNITS_PER_WORD;\n-  length -= leftover;\n-\n-  if (length > 0)\n-    score_block_move_loop_body (dst_reg, dst_align,\n-                              src_reg, src_align, length);\n-\n-  if (dst_unaligned)\n-    emit_insn (gen_move_sce (dst_reg, dst_reg));\n-\n-  if (leftover > 0)\n-    {\n-      HOST_WIDE_INT src_adj = src_unaligned ? -4 : 0;\n-      HOST_WIDE_INT dst_adj = dst_unaligned ? -4 : 0;\n-      rtx temp;\n-\n-      gcc_assert (leftover < UNITS_PER_WORD);\n-\n-      if (leftover >= UNITS_PER_WORD / 2\n-          && src_align >= BITS_PER_WORD / 2\n-          && dst_align >= BITS_PER_WORD / 2)\n-        {\n-          temp = gen_reg_rtx (HImode);\n-          emit_insn (gen_move_lhu_b (src_reg, src_reg,\n-                                     gen_int_mode (src_adj, SImode), temp));\n-          emit_insn (gen_move_sh_b (dst_reg, dst_reg,\n-                                    gen_int_mode (dst_adj, SImode), temp));\n-          leftover -= UNITS_PER_WORD / 2;\n-          src_adj = UNITS_PER_WORD / 2;\n-          dst_adj = UNITS_PER_WORD / 2;\n-        }\n-\n-      while (leftover > 0)\n-        {\n-          temp = gen_reg_rtx (QImode);\n-          emit_insn (gen_move_lbu_b (src_reg, src_reg,\n-                                     gen_int_mode (src_adj, SImode), temp));\n-          emit_insn (gen_move_sb_b (dst_reg, dst_reg,\n-                                    gen_int_mode (dst_adj, SImode), temp));\n-          leftover--;\n-          src_adj = 1;\n-          dst_adj = 1;\n-        }\n-    }\n-}\n-\n-#define MIN_MOVE_REGS 3\n-#define MIN_MOVE_BYTES (MIN_MOVE_REGS * UNITS_PER_WORD)\n-#define MAX_MOVE_REGS 4\n-#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n-\n-/* The length is large, generate a loop if necessary.\n-   The loop is consisted by loop head/body/foot.  */\n-static void\n-score_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n-{\n-  HOST_WIDE_INT src_align = MEM_ALIGN (src);\n-  HOST_WIDE_INT dst_align = MEM_ALIGN (dst);\n-  HOST_WIDE_INT loop_mov_bytes;\n-  HOST_WIDE_INT iteration = 0;\n-  HOST_WIDE_INT head_length = 0, leftover;\n-  rtx label, src_reg, dst_reg, final_dst, test;\n-\n-  bool gen_loop_head = (src_align < BITS_PER_WORD\n-                        || dst_align < BITS_PER_WORD);\n-\n-  if (gen_loop_head)\n-    head_length += UNITS_PER_WORD;\n-\n-  for (loop_mov_bytes = MAX_MOVE_BYTES;\n-       loop_mov_bytes >= MIN_MOVE_BYTES;\n-       loop_mov_bytes -= UNITS_PER_WORD)\n-    {\n-      iteration = (length - head_length) / loop_mov_bytes;\n-      if (iteration > 1)\n-        break;\n-    }\n-  if (iteration <= 1)\n-    {\n-      score_block_move_straight (dst, src, length);\n-      return;\n-    }\n-\n-  leftover = (length - head_length) % loop_mov_bytes;\n-  length -= leftover;\n-\n-  src_reg = copy_addr_to_reg (XEXP (src, 0));\n-  dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n-  final_dst = expand_simple_binop (Pmode, PLUS, dst_reg, GEN_INT (length),\n-                                   0, 0, OPTAB_WIDEN);\n-\n-  if (gen_loop_head)\n-    score_block_move_loop_head (dst_reg, dst_align,\n-                              src_reg, src_align, head_length);\n-\n-  label = gen_label_rtx ();\n-  emit_label (label);\n-\n-  score_block_move_loop_body (dst_reg, dst_align,\n-                            src_reg, src_align, loop_mov_bytes);\n-\n-  test = gen_rtx_NE (VOIDmode, dst_reg, final_dst);\n-  emit_jump_insn (gen_cbranchsi4 (test, dst_reg, final_dst, label));\n-\n-  score_block_move_loop_foot (dst_reg, dst_align,\n-                            src_reg, src_align, leftover);\n-}\n-\n-/* Generate block move, for misc.md: \"movmemsi\".  */\n-bool\n-score_block_move (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx length = ops[2];\n-\n-  if (TARGET_LITTLE_ENDIAN\n-      && (MEM_ALIGN (src) < BITS_PER_WORD || MEM_ALIGN (dst) < BITS_PER_WORD)\n-      && INTVAL (length) >= UNITS_PER_WORD)\n-    return false;\n-\n-  if (GET_CODE (length) == CONST_INT)\n-    {\n-      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n-        {\n-          score_block_move_straight (dst, src, INTVAL (length));\n-          return true;\n-        }\n-      else if (optimize &&\n-               !(flag_unroll_loops || flag_unroll_all_loops))\n-        {\n-          score_block_move_loop (dst, src, INTVAL (length));\n-          return true;\n-        }\n-    }\n-  return false;\n+    gcc_unreachable ();\n }\n \n static void"}, {"sha": "4554e2673441ba8b38d0e743b0e4bcaca31f6a98", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -20,14 +20,9 @@\n \n #include \"score-conv.h\"\n \n-#undef CPP_SPEC\n-#define CPP_SPEC                 \"%{mscore3:-D__score3__} %{G*}\"\n-\n #undef CC1_SPEC\n #define CC1_SPEC                 \"%{!mel:-meb} %{mel:-mel } \\\n %{!mscore*:-mscore7}    \\\n-%{mscore3:-mscore3}     \\\n-%{mscore3d:-mscore3d}   \\\n %{mscore7:-mscore7}     \\\n %{mscore7d:-mscore7d}   \\\n %{G*}\"\n@@ -37,29 +32,17 @@\n %{!mscore*:-march=score7}         \\\n %{mscore7:-march=score7}          \\\n %{mscore7d:-march=score7}         \\\n-%{mscore3:-march=score3}          \\\n-%{mscore3d:-march=score3}         \\\n-%{march=score5:-march=score7}     \\\n-%{march=score5u:-march=score7}    \\\n %{march=score7:-march=score7}     \\\n %{march=score7d:-march=score7}    \\\n-%{march=score3:-march=score3}     \\\n-%{march=score3d:-march=score3}    \\\n %{G*}\"\n \n #undef LINK_SPEC\n #define LINK_SPEC                \"%{!mel:-EB} %{mel:-EL} \\\n %{!mscore*:-mscore7_elf}          \\\n %{mscore7:-mscore7_elf}           \\\n %{mscore7d:-mscore7_elf}          \\\n-%{mscore3:-mscore3_elf}           \\\n-%{mscore3d:-mscore3_elf}          \\\n-%{march=score5:-mscore7_elf}      \\\n-%{march=score5u:-mscore7_elf}     \\\n %{march=score7:-mscore7_elf}      \\\n %{march=score7d:-mscore7_elf}     \\\n-%{march=score3:-mscore3_elf}      \\\n-%{march=score3d:-mscore3_elf}     \\\n %{G*}\"\n \n /* Run-time Target Specification.  */\n@@ -72,18 +55,10 @@\n       builtin_define (\"__scorele__\");           \\\n     else                                        \\\n       builtin_define (\"__scorebe__\");           \\\n-    if (TARGET_SCORE5)                          \\\n-      builtin_define (\"__score5__\");            \\\n-    if (TARGET_SCORE5U)                         \\\n-      builtin_define (\"__score5u__\");           \\\n     if (TARGET_SCORE7)                          \\\n       builtin_define (\"__score7__\");            \\\n     if (TARGET_SCORE7D)                         \\\n       builtin_define (\"__score7d__\");           \\\n-    if (TARGET_SCORE3)                          \\\n-      builtin_define (\"__score3__\");            \\\n-    if (TARGET_SCORE3D)                         \\\n-      builtin_define (\"__score3d__\");           \\\n   } while (0)\n \n #define TARGET_DEFAULT         0\n@@ -466,25 +441,6 @@ extern enum reg_class score_char_to_class[256];\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)        \\\n    ? reg_classes_intersect_p (HI_REG, (CLASS)) : 0)\n \n-/* The letters I, J, K, L, M, N, O, and P in a register constraint\n-   string can be used to stand for particular ranges of immediate\n-   operands.  This macro defines what the ranges are.  C is the\n-   letter, and VALUE is a constant value.  Return 1 if VALUE is\n-   in the range specified by C.  */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) score_const_ok_for_letter_p (VALUE, C)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)        \\\n-  ((C) == 'G' && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n-\n-/* Letters in the range `Q' through `U' may be defined in a\n-   machine-dependent fashion to stand for arbitrary operand types.\n-   The machine description macro `EXTRA_CONSTRAINT' is passed the\n-   operand as its first argument and the constraint letter as its\n-   second operand.  */\n-#define EXTRA_CONSTRAINT(VALUE, C)      score_extra_constraint (VALUE, C)\n \n /* Basic Stack Layout.  */\n /* Stack layout; function entry, exit and calling.  */\n@@ -514,6 +470,7 @@ extern enum reg_class score_char_to_class[256];\n \n /* The register that holds the return address in exception handlers.  */\n #define EH_RETURN_STACKADJ_RTX          gen_rtx_REG (Pmode, EH_REGNUM)\n+#define EH_RETURN_HANDLER_RTX  \t\tgen_rtx_REG (SImode, 30)\n \n /* Registers That Address the Stack Frame.  */\n /* Register to use for pushing function arguments.  */\n@@ -615,14 +572,6 @@ typedef struct score_args\n         fprintf (FILE, \" jl   _mcount \\n\");                           \\\n         fprintf (FILE, \" .set nor1 \\n\");                              \\\n       }                                                               \\\n-    else if (TARGET_SCORE3)                                           \\\n-      {                                                               \\\n-        fprintf (FILE, \" .set r1  \\n\");                               \\\n-        fprintf (FILE, \" mv!   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);    \\\n-        fprintf (FILE, \" addi! r%d, %d \\n\", STACK_POINTER_REGNUM, -8);\\\n-        fprintf (FILE, \" jl   _mcount \\n\");                           \\\n-        fprintf (FILE, \" .set nor1 \\n\");                              \\\n-      }                                                               \\\n   } while (0)\n \n /* Trampolines for Nested Functions.  */\n@@ -825,9 +774,6 @@ typedef struct score_args\n         fprintf (STREAM, \"\\tpush! %s,[%s]\\n\",        \\\n                  reg_names[REGNO],                   \\\n                  reg_names[STACK_POINTER_REGNUM]);   \\\n-    else if (TARGET_SCORE3)                          \\\n-        fprintf (STREAM, \"\\tpush!\\t%s\\n\",            \\\n-                 reg_names[REGNO]);                  \\\n   } while (0)\n \n /* This is how to output an insn to pop a register from the stack.  */\n@@ -837,9 +783,6 @@ typedef struct score_args\n       fprintf (STREAM, \"\\tpop! %s,[%s]\\n\",           \\\n                reg_names[REGNO],                     \\\n                reg_names[STACK_POINTER_REGNUM]);     \\\n-    else if (TARGET_SCORE3)                          \\\n-      fprintf (STREAM, \"\\tpop!\\t%s\\n\",               \\\n-               reg_names[REGNO]);                    \\\n   } while (0)\n \n /* Output of Dispatch Tables.  */\n@@ -852,28 +795,6 @@ typedef struct score_args\n         fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n       else                                                                \\\n         fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n-    else if (TARGET_SCORE3)                                               \\\n-      {                                                                   \\\n-        switch (GET_MODE(BODY))                                           \\\n-          {                                                               \\\n-          case QImode: /* TBB */                                          \\\n-            asm_fprintf (STREAM, \"\\t.byte\\t(%LL%d-%LL%d_tbb)/2\\n\",        \\\n-                         VALUE, REL);                                     \\\n-            break;                                                        \\\n-          case HImode: /* TBH */                                          \\\n-            asm_fprintf (STREAM, \"\\t.2byte\\t(%LL%d-%LL%d_tbb)/2\\n\",       \\\n-                         VALUE, REL);                                     \\\n-            break;                                                        \\\n-          case SImode:                                                    \\\n-            if (flag_pic)                                                 \\\n-              fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n-            else                                                          \\\n-              fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n-            break;                                                        \\\n-          default:                                                        \\\n-            gcc_unreachable();                                            \\\n-          }                                                               \\\n-      }                                                                   \\\n   } while (0)\n \n /* Jump table alignment is explicit in ASM_OUTPUT_CASE_LABEL.  */\n@@ -894,13 +815,6 @@ typedef struct score_args\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE                SImode\n \n-#define CASE_VECTOR_PC_RELATIVE         (TARGET_SCORE3)\n-\n-#define CASE_VECTOR_SHORTEN_MODE(min, max, body)                \\\n-   ((min < 0 || max >= 0x2000 || TARGET_SCORE7) ? SImode        \\\n-   : (max >= 0x200) ? HImode                                    \\\n-   : QImode)\n-\n /* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n   fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)"}, {"sha": "9ae046ed5c9299d95ecd4ad395c692d7030e595e", "filename": "gcc/config/score/score.md", "status": "modified", "additions": 124, "deletions": 1858, "changes": 1982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a"}, {"sha": "dc8cd351e2c24de4145d87da7d56f1712949423b", "filename": "gcc/config/score/score.opt", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.opt?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -1,6 +1,6 @@\n ; Options for the Sunnorth port of the compiler.\n \n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2010 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -34,14 +34,6 @@ muls\n Target RejectNegative Report Mask(ULS)\n Enable unaligned load/store instruction\n \n-mscore5\n-Target RejectNegative Report Mask(SCORE5)\n-Support SCORE 5 ISA\n-\n-mscore5u\n-Target RejectNegative Report Mask(SCORE5U)\n-Support SCORE 5U ISA\n-\n mscore7\n Target RejectNegative Report Mask(SCORE7)\n Support SCORE 7 ISA\n@@ -50,14 +42,6 @@ mscore7d\n Target RejectNegative Report Mask(SCORE7D)\n Support SCORE 7D ISA\n \n-mscore3\n-Target RejectNegative Report Mask(SCORE3)\n-Support SCORE 3 ISA\n-\n-mscore3d\n-Target RejectNegative Report Mask(SCORE3D)\n-Support SCORE 3d ISA\n-\n march=\n Target RejectNegative Joined\n Specify the name of the target architecture"}, {"sha": "5403adf1a44b1f15189082bd0f1a3e59f8d2cb3c", "filename": "gcc/config/score/score3.c", "status": "removed", "additions": 0, "deletions": 1961, "changes": 1961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=fdc1806ad1a7f52470cb6c327b95b27c307d5917", "patch": "@@ -1,1961 +0,0 @@\n-/* score3.c for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"output.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"flags.h\"\n-#include \"reload.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"gstab.h\"\n-#include \"hashtab.h\"\n-#include \"debug.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"integrate.h\"\n-#include \"langhooks.h\"\n-#include \"cfglayout.h\"\n-#include \"score3.h\"\n-#include \"df.h\"\n-\n-#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n-#define INS_BUF_SZ                128\n-\n-extern enum reg_class score_char_to_class[256];\n-\n-static int score3_sdata_max;\n-static char score3_ins[INS_BUF_SZ + 8];\n-\n-/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL.  */\n-static int\n-score3_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n-{\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return 0;\n-\n-  if (CONSTANT_POOL_ADDRESS_P (symbol)\n-      && offset >= 0\n-      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n-    return 1;\n-\n-  if (SYMBOL_REF_DECL (symbol) != 0\n-      && offset >= 0\n-      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Split X into a base and a constant offset, storing them in *BASE\n-   and *OFFSET respectively.  */\n-static void\n-score3_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n-{\n-  *offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      *offset += INTVAL (XEXP (x, 1));\n-      x = XEXP (x, 0);\n-    }\n-\n-  *base = x;\n-}\n-\n-/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n-static enum score_symbol_type\n-score3_classify_symbol (rtx x)\n-{\n-  if (GET_CODE (x) == LABEL_REF)\n-    return SYMBOL_GENERAL;\n-\n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  if (CONSTANT_POOL_ADDRESS_P (x))\n-    {\n-      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE3_SDATA_MAX)\n-        return SYMBOL_SMALL_DATA;\n-      return SYMBOL_GENERAL;\n-    }\n-  if (SYMBOL_REF_SMALL_P (x))\n-    return SYMBOL_SMALL_DATA;\n-  return SYMBOL_GENERAL;\n-}\n-\n-/* Return true if the current function must save REGNO.  */\n-static int\n-score3_save_reg_p (unsigned int regno)\n-{\n-  /* Check call-saved registers.  */\n-  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-    return 1;\n-\n-  /* We need to save the old frame pointer before setting up a new one.  */\n-  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n-    return 1;\n-\n-  /* We need to save the incoming return address if it is ever clobbered\n-     within the function.  */\n-  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return one word of double-word value OP, taking into account the fixed\n-   endianness of certain registers.  HIGH_P is true to select the high part,\n-   false to select the low part.  */\n-static rtx\n-score3_subw (rtx op, int high_p)\n-{\n-  unsigned int byte;\n-  enum machine_mode mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode)\n-    mode = DImode;\n-\n-  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n-\n-  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n-    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n-\n-  if (GET_CODE (op) == MEM)\n-    return adjust_address (op, SImode, byte);\n-\n-  return simplify_gen_subreg (SImode, op, mode, byte);\n-}\n-\n-static struct score3_frame_info *\n-score3_cached_frame (void)\n-{\n-  static struct score3_frame_info _frame_info;\n-  return &_frame_info;\n-}\n-\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n-static struct score3_frame_info *\n-score3_compute_frame_size (HOST_WIDE_INT size)\n-{\n-  unsigned int regno;\n-  struct score3_frame_info *f = score3_cached_frame ();\n-\n-  memset (f, 0, sizeof (struct score3_frame_info));\n-  f->gp_reg_size = 0;\n-  f->mask = 0;\n-  f->var_size = SCORE3_STACK_ALIGN (size);\n-  f->args_size = crtl->outgoing_args_size;\n-  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n-\n-  if (f->var_size == 0 && current_function_is_leaf)\n-    f->args_size = f->cprestore_size = 0;\n-\n-  if (f->args_size == 0 && cfun->calls_alloca)\n-    f->args_size = UNITS_PER_WORD;\n-\n-  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n-  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-    {\n-      if (score3_save_reg_p (regno))\n-        {\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  if (crtl->calls_eh_return)\n-    {\n-      unsigned int i;\n-      for (i = 0;; ++i)\n-        {\n-          regno = EH_RETURN_DATA_REGNO (i);\n-          if (regno == INVALID_REGNUM)\n-            break;\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  f->total_size += f->gp_reg_size;\n-  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n-\n-  if (f->mask)\n-    {\n-      HOST_WIDE_INT offset;\n-      offset = (f->args_size + f->cprestore_size + f->var_size\n-                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n-      f->gp_sp_offset = offset;\n-    }\n-  else\n-    f->gp_sp_offset = 0;\n-\n-  return f;\n-}\n-\n-/* Return true if X is a valid base register for the given mode.\n-   Allow only hard registers if STRICT.  */\n-static int\n-score3_valid_base_register_p (rtx x, int strict)\n-{\n-  if (!strict && GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-\n-  return (GET_CODE (x) == REG\n-          && score3_regno_mode_ok_for_base_p (REGNO (x), strict));\n-}\n-\n-/* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT is true if we should only accept\n-   hard base registers.  */\n-static int\n-score3_classify_address (struct score3_address_info *info,\n-                         enum machine_mode mode, rtx x, int strict)\n-{\n-  info->code = GET_CODE (x);\n-\n-  switch (info->code)\n-    {\n-    case REG:\n-    case SUBREG:\n-      info->type = SCORE3_ADD_REG;\n-      info->reg = x;\n-      info->offset = const0_rtx;\n-      return score3_valid_base_register_p (info->reg, strict);\n-    case PLUS:\n-      info->type = SCORE3_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = XEXP (x, 1);\n-      return (score3_valid_base_register_p (info->reg, strict)\n-              && GET_CODE (info->offset) == CONST_INT\n-              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n-    case PRE_DEC:\n-    case POST_DEC:\n-    case PRE_INC:\n-    case POST_INC:\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n-        return false;\n-      info->type = SCORE3_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n-      return score3_valid_base_register_p (info->reg, strict);\n-    case CONST_INT:\n-      info->type = SCORE3_ADD_CONST_INT;\n-      return 1;\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      info->type = SCORE3_ADD_SYMBOLIC;\n-      return (score3_symbolic_constant_p (x, &info->symbol_type)\n-              && (info->symbol_type == SYMBOL_GENERAL\n-                  || info->symbol_type == SYMBOL_SMALL_DATA));\n-    default:\n-      return 0;\n-    }\n-}\n-\n-bool\n-score3_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n-{\n-    return ((TYPE_MODE (type) == BLKmode)\n-            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n-            || (int_size_in_bytes (type) == -1));\n-}\n-\n-/* Return a legitimate address for REG + OFFSET.  */\n-static rtx\n-score3_add_offset (rtx reg, HOST_WIDE_INT offset)\n-{\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    {\n-      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-                                 gen_int_mode (offset & 0xffffc000,\n-                                               GET_MODE (reg)),\n-                                 reg, NULL, 0, OPTAB_WIDEN);\n-      offset &= 0x3fff;\n-    }\n-\n-  return plus_constant (reg, offset);\n-}\n-\n-/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n-   in order to avoid duplicating too much logic from elsewhere.  */\n-void\n-score3_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n-                        tree function)\n-{\n-  rtx this_rtx, temp1, insn, fnaddr;\n-\n-  /* Pretend to be a post-reload pass while generating rtl.  */\n-  reload_completed = 1;\n-\n-  /* Mark the end of the (empty) prologue.  */\n-  emit_note (NOTE_INSN_PROLOGUE_END);\n-\n-  /* We need two temporary registers in some cases.  */\n-  temp1 = gen_rtx_REG (Pmode, 8);\n-\n-  /* Find out which register contains the \"this\" pointer.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n-  else\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n-\n-  /* Add DELTA to THIS_RTX.  */\n-  if (delta != 0)\n-    {\n-      rtx offset = GEN_INT (delta);\n-      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n-        {\n-          emit_move_insn (temp1, offset);\n-          offset = temp1;\n-        }\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n-    }\n-\n-  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n-  if (vcall_offset != 0)\n-    {\n-      rtx addr;\n-\n-      /* Set TEMP1 to *THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n-\n-      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n-      addr = score3_add_offset (temp1, vcall_offset);\n-\n-      /* Load the offset and add it to THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n-    }\n-\n-  /* Jump to the target function.  */\n-  fnaddr = XEXP (DECL_RTL (function), 0);\n-  insn = emit_call_insn (gen_sibcall_internal_score3 (fnaddr, const0_rtx));\n-  SIBLING_CALL_P (insn) = 1;\n-\n-  /* Run just enough of rest_of_compilation.  This sequence was\n-     \"borrowed\" from alpha.c.  */\n-  insn = get_insns ();\n-  insn_locators_alloc ();\n-  split_all_insns_noflow ();\n-  shorten_branches (insn);\n-  final_start_function (insn, file, 1);\n-  final (insn, file, 1);\n-  final_end_function ();\n-\n-  /* Clean up the vars set above.  Note that final_end_function resets\n-     the global pointer for us.  */\n-  reload_completed = 0;\n-}\n-\n-/* Copy VALUE to a register and return that register.  If new psuedos\n-   are allowed, copy it into a new register, otherwise use DEST.  */\n-static rtx\n-score3_force_temporary (rtx dest, rtx value)\n-{\n-  if (can_create_pseudo_p ())\n-    return force_reg (Pmode, value);\n-  else\n-    {\n-      emit_move_insn (copy_rtx (dest), value);\n-      return dest;\n-    }\n-}\n-\n-/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n-   and is used to load the high part into a register.  */\n-static rtx\n-score3_split_symbol (rtx temp, rtx addr)\n-{\n-  rtx high = score3_force_temporary (temp,\n-                                     gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n-  return gen_rtx_LO_SUM (Pmode, high, addr);\n-}\n-\n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n-   be legitimized in a way that the generic machinery might not expect,\n-   return the new address.  */\n-rtx\n-score3_legitimize_address (rtx x)\n-{\n-  enum score_symbol_type symbol_type;\n-\n-  if (score3_symbolic_constant_p (x, &symbol_type)\n-      && symbol_type == SYMBOL_GENERAL)\n-    return score3_split_symbol (0, x);\n-\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      rtx reg = XEXP (x, 0);\n-      if (!score3_valid_base_register_p (reg, 0))\n-        reg = copy_to_mode_reg (Pmode, reg);\n-      return score3_add_offset (reg, INTVAL (XEXP (x, 1)));\n-    }\n-\n-  return x;\n-}\n-\n-/* Fill INFO with information about a single argument.  CUM is the\n-   cumulative state for earlier arguments.  MODE is the mode of this\n-   argument and TYPE is its type (if known).  NAMED is true if this\n-   is a named (fixed) argument rather than a variable one.  */\n-static void\n-score3_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                     const_tree type, bool named, struct score3_arg_info *info)\n-{\n-  int even_reg_p;\n-  unsigned int num_words, max_regs;\n-\n-  even_reg_p = 0;\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n-  else\n-    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n-      even_reg_p = 1;\n-\n-  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n-    info->reg_offset = ARG_REG_NUM;\n-  else\n-    {\n-      info->reg_offset = cum->num_gprs;\n-      if (even_reg_p)\n-        info->reg_offset += info->reg_offset & 1;\n-    }\n-\n-  if (mode == BLKmode)\n-    info->num_bytes = int_size_in_bytes (type);\n-  else\n-    info->num_bytes = GET_MODE_SIZE (mode);\n-\n-  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  max_regs = ARG_REG_NUM - info->reg_offset;\n-\n-  /* Partition the argument between registers and stack.  */\n-  info->reg_words = MIN (num_words, max_regs);\n-  info->stack_words = num_words - info->reg_words;\n-\n-  /* The alignment applied to registers is also applied to stack arguments.  */\n-  if (info->stack_words)\n-    {\n-      info->stack_offset = cum->stack_words;\n-      if (even_reg_p)\n-        info->stack_offset += info->stack_offset & 1;\n-    }\n-}\n-\n-/* Set up the stack and frame (if desired) for the function.  */\n-void\n-score3_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  const char *fnname;\n-  struct score3_frame_info *f = score3_cached_frame ();\n-  HOST_WIDE_INT tsize = f->total_size;\n-\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fputs (\"\\t.ent\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-  assemble_name (file, fnname);\n-  fputs (\":\\n\", file);\n-\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fprintf (file,\n-               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n-               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n-               \", args= \" HOST_WIDE_INT_PRINT_DEC\n-               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-               (reg_names[(frame_pointer_needed)\n-                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n-               tsize,\n-               reg_names[RA_REGNUM],\n-               current_function_is_leaf ? 1 : 0,\n-               f->var_size,\n-               f->num_gp,\n-               f->args_size,\n-               f->cprestore_size);\n-\n-      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-              f->mask,\n-              (f->gp_sp_offset - f->total_size));\n-    }\n-}\n-\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n-void\n-score3_function_epilogue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  if (!flag_inhibit_size_directive)\n-    {\n-      const char *fnname;\n-      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-      fputs (\"\\t.end\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-}\n-\n-/* Returns true if X contains a SYMBOL_REF.  */\n-static bool\n-score3_symbolic_expression_p (rtx x)\n-{\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return true;\n-\n-  if (GET_CODE (x) == CONST)\n-    return score3_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (UNARY_P (x))\n-    return score3_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (ARITHMETIC_P (x))\n-    return (score3_symbolic_expression_p (XEXP (x, 0))\n-            || score3_symbolic_expression_p (XEXP (x, 1)));\n-\n-  return false;\n-}\n-\n-/* Choose the section to use for the constant rtx expression X that has\n-   mode MODE.  */\n-section *\n-score3_select_rtx_section (enum machine_mode mode, rtx x,\n-                           unsigned HOST_WIDE_INT align)\n-{\n-  if (GET_MODE_SIZE (mode) <= SCORE3_SDATA_MAX)\n-    return get_named_section (0, \".sdata\", 0);\n-  else if (flag_pic && score3_symbolic_expression_p (x))\n-    return get_named_section (0, \".data.rel.ro\", 3);\n-  else\n-    return mergeable_constant_section (mode, align, 0);\n-}\n-\n-/* Implement TARGET_IN_SMALL_DATA_P.  */\n-bool\n-score3_in_small_data_p (const_tree decl)\n-{\n-  HOST_WIDE_INT size;\n-\n-  if (TREE_CODE (decl) == STRING_CST\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n-    return false;\n-\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n-    {\n-      const char *name;\n-      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n-      if (strcmp (name, \".sdata\") != 0\n-          && strcmp (name, \".sbss\") != 0)\n-        return true;\n-      if (!DECL_EXTERNAL (decl))\n-        return false;\n-    }\n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  return (size > 0 && size <= SCORE3_SDATA_MAX);\n-}\n-\n-/* Implement TARGET_ASM_FILE_START.  */\n-void\n-score3_asm_file_start (void)\n-{\n-  default_file_start ();\n-  fprintf (asm_out_file, ASM_COMMENT_START\n-           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n-\n-  if (flag_pic)\n-    fprintf (asm_out_file, \"\\t.set pic\\n\");\n-}\n-\n-/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n-   .externs for any small-data variables that turned out to be external.  */\n-void\n-score3_asm_file_end (void)\n-{\n-  tree name_tree;\n-  struct extern_list *p;\n-  if (extern_head)\n-    {\n-      fputs (\"\\n\", asm_out_file);\n-      for (p = extern_head; p != 0; p = p->next)\n-        {\n-          name_tree = get_identifier (p->name);\n-          if (!TREE_ASM_WRITTEN (name_tree)\n-              && TREE_SYMBOL_REFERENCED (name_tree))\n-            {\n-              TREE_ASM_WRITTEN (name_tree) = 1;\n-              fputs (\"\\t.extern\\t\", asm_out_file);\n-              assemble_name (asm_out_file, p->name);\n-              fprintf (asm_out_file, \", %d\\n\", p->size);\n-            }\n-        }\n-    }\n-}\n-\n-/* Implement TARGET_OPTION_OVERRIDE hook.  */\n-void\n-score3_option_override (void)\n-{\n-  flag_pic = false;\n-  if (!flag_pic)\n-    score3_sdata_max = (global_options_set.x_g_switch_value\n-\t\t\t? g_switch_value\n-\t\t\t: SCORE3_DEFAULT_SDATA_MAX);\n-  else\n-    {\n-      score3_sdata_max = 0;\n-      if (global_options_set.x_g_switch_value && (g_switch_value != 0))\n-        warning (0, \"-fPIC and -G are incompatible\");\n-    }\n-\n-  score_char_to_class['d'] = G32_REGS;\n-  score_char_to_class['e'] = G16_REGS;\n-  score_char_to_class['t'] = T32_REGS;\n-\n-  score_char_to_class['h'] = HI_REG;\n-  score_char_to_class['l'] = LO_REG;\n-  score_char_to_class['x'] = CE_REGS;\n-\n-  score_char_to_class['q'] = CN_REG;\n-  score_char_to_class['y'] = LC_REG;\n-  score_char_to_class['z'] = SC_REG;\n-  score_char_to_class['a'] = SP_REGS;\n-\n-  score_char_to_class['c'] = CR_REGS;\n-}\n-\n-/* Implement REGNO_REG_CLASS macro.  */\n-int\n-score3_reg_class (int regno)\n-{\n-  int c;\n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-\n-  if (regno == FRAME_POINTER_REGNUM\n-      || regno == ARG_POINTER_REGNUM)\n-    return ALL_REGS;\n-\n-  for (c = 0; c < N_REG_CLASSES; c++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n-      return c;\n-\n-  return NO_REGS;\n-}\n-\n-/* Implement PREFERRED_RELOAD_CLASS macro.  */\n-enum reg_class\n-score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n-{\n-  if (reg_class_subset_p (G16_REGS, rclass))\n-    return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, rclass))\n-    return G32_REGS;\n-  return rclass;\n-}\n-\n-/* Implement SECONDARY_INPUT_RELOAD_CLASS\n-   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n-enum reg_class\n-score3_secondary_reload_class (enum reg_class rclass,\n-                               enum machine_mode mode ATTRIBUTE_UNUSED,\n-                               rtx x)\n-{\n-  int regno = -1;\n-  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n-    regno = true_regnum (x);\n-\n-  if (!GR_REG_CLASS_P (rclass))\n-    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n-  return NO_REGS;\n-}\n-\n-/* Implement CONST_OK_FOR_LETTER_P macro.  */\n-/* imm constraints\n-   I        imm16 << 16\n-   J        uimm5\n-   K        uimm16\n-   L        simm16\n-   M        uimm14\n-   N        simm14\n-   O        simm14\n-   P        simm5\n-   Q        uimm32  */\n-int\n-score3_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n-{\n-  switch (c)\n-    {\n-    case 'I': return ((value & 0xffff) == 0);\n-    case 'J': return IMM_IN_RANGE (value, 5, 0);\n-    case 'K': return IMM_IN_RANGE (value, 16, 0);\n-    case 'L': return IMM_IN_RANGE (value, 16, 1);\n-    case 'M': return IMM_IN_RANGE (value, 14, 0);\n-    case 'N': return IMM_IN_RANGE (value, 14, 1);\n-    case 'O': return IMM_IN_RANGE (value, 5, 1);\n-    case 'P': return IMM_IN_RANGE (value, 6, 1);\n-    case 'Q': return score_extra_constraint (GEN_INT(value), c);\n-    default : return 0;\n-    }\n-}\n-\n-/* Implement EXTRA_CONSTRAINT macro.  */\n-/*\n-   Q        uimm32\n-   Z        symbol_ref  */\n-int\n-score3_extra_constraint (rtx op, char c)\n-{\n-  switch (c)\n-    {\n-    case 'Q': return IMM_IN_RANGE (INTVAL(op), 32, 0);\n-    case 'Z':\n-      return GET_CODE (op) == SYMBOL_REF;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return truth value on whether or not a given hard register\n-   can support a given mode.  */\n-int\n-score3_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n-{\n-  int size = GET_MODE_SIZE (mode);\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-\n-  if (mclass == MODE_CC)\n-    return regno == CC_REGNUM;\n-  else if (regno == FRAME_POINTER_REGNUM\n-           || regno == ARG_POINTER_REGNUM)\n-    return mclass == MODE_INT;\n-  else if (GP_REG_P (regno))\n-    return !(regno & 1) || (size <= UNITS_PER_WORD);\n-  else if (CE_REG_P (regno))\n-    return (mclass == MODE_INT\n-            && ((size <= UNITS_PER_WORD)\n-                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n-  else\n-    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n-}\n-\n-/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n-   pointer or argument pointer.  TO is either the stack pointer or\n-   hard frame pointer.  */\n-HOST_WIDE_INT\n-score3_initial_elimination_offset (int from,\n-                                   int to ATTRIBUTE_UNUSED)\n-{\n-  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n-  switch (from)\n-    {\n-    case ARG_POINTER_REGNUM:\n-      return f->total_size;\n-    case FRAME_POINTER_REGNUM:\n-      return 0;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG_ADVANCE hook.  */\n-void\n-score3_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                             const_tree type, bool named)\n-{\n-  struct score3_arg_info info;\n-  score3_classify_arg (cum, mode, type, named, &info);\n-  cum->num_gprs = info.reg_offset + info.reg_words;\n-  if (info.stack_words > 0)\n-    cum->stack_words = info.stack_offset + info.stack_words;\n-  cum->arg_number++;\n-}\n-\n-/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n-int\n-score3_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n-                          enum machine_mode mode, tree type, bool named)\n-{\n-  struct score3_arg_info info;\n-  score3_classify_arg (cum, mode, type, named, &info);\n-  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG hook.  */\n-rtx\n-score3_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                     const_tree type, bool named)\n-{\n-  struct score3_arg_info info;\n-\n-  if (mode == VOIDmode || !named)\n-    return 0;\n-\n-  score3_classify_arg (cum, mode, type, named, &info);\n-\n-  if (info.reg_offset == ARG_REG_NUM)\n-    return 0;\n-\n-  if (!info.stack_words)\n-    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n-  else\n-    {\n-      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n-      unsigned int i, part_offset = 0;\n-      for (i = 0; i < info.reg_words; i++)\n-        {\n-          rtx reg;\n-          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n-          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n-                                                   GEN_INT (part_offset));\n-          part_offset += UNITS_PER_WORD;\n-        }\n-      return ret;\n-    }\n-}\n-\n-/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n-   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n-   VALTYPE is null and MODE is the mode of the return value.  */\n-rtx\n-score3_function_value (const_tree valtype, const_tree func,\n-\t\t       enum machine_mode mode)\n-{\n-  if (valtype)\n-    {\n-      int unsignedp;\n-      mode = TYPE_MODE (valtype);\n-      unsignedp = TYPE_UNSIGNED (valtype);\n-      mode = promote_function_mode (valtype, mode, &unsignedp, func, 1);\n-    }\n-  return gen_rtx_REG (mode, RT_REGNUM);\n-}\n-\n-/* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.  */\n-\n-void\n-score3_asm_trampoline_template (FILE *f)\n-{\n-  fprintf (f, \"\\t.set r1\\n\");\n-  fprintf (f, \"\\tmv! r31, r3\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\tbl nextinsn\\n\");\n-  fprintf (f, \"nextinsn:\\n\");\n-  fprintf (f, \"\\tlw! r1, [r3, 6*4-8]\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\tlw r23, [r3, 6*4-4]\\n\");\n-  fprintf (f, \"\\tmv! r3, r31\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\tbr! r1\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\t.set nor1\\n\");\n-}\n-\n-/* Implement TARGET_TRAMPOLINE_INIT.  */\n-void\n-score3_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n-{\n-#define FFCACHE          \"_flush_cache\"\n-#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n-\n-  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n-  rtx addr = XEXP (m_tramp, 0);\n-  rtx mem;\n-\n-  emit_block_move (m_tramp, assemble_trampoline_template (),\n-\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n-\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE);\n-  emit_move_insn (mem, fnaddr);\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE + GET_MODE_SIZE (SImode));\n-  emit_move_insn (mem, chain_value);\n-\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n-                     LCT_NORMAL, VOIDmode, 2,\n-                     addr, Pmode,\n-                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n-#undef FFCACHE\n-#undef CODE_SIZE\n-}\n-\n-/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n-int\n-score3_regno_mode_ok_for_base_p (int regno, int strict)\n-{\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (!strict)\n-        return 1;\n-      regno = reg_renumber[regno];\n-    }\n-  if (regno == ARG_POINTER_REGNUM\n-      || regno == FRAME_POINTER_REGNUM)\n-    return 1;\n-  return GP_REG_P (regno);\n-}\n-\n-/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n-bool\n-score3_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n-{\n-  struct score3_address_info addr;\n-\n-  return score3_classify_address (&addr, mode, x, strict);\n-}\n-\n-/* Return a number assessing the cost of moving a register in class\n-   FROM to class TO. */\n-int\n-score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                           enum reg_class from, enum reg_class to)\n-{\n-  if (GR_REG_CLASS_P (from))\n-    {\n-      if (GR_REG_CLASS_P (to))\n-        return 2;\n-      else if (SP_REG_CLASS_P (to))\n-        return 4;\n-      else if (CP_REG_CLASS_P (to))\n-        return 5;\n-      else if (CE_REG_CLASS_P (to))\n-        return 6;\n-    }\n-  if (GR_REG_CLASS_P (to))\n-    {\n-      if (GR_REG_CLASS_P (from))\n-        return 2;\n-      else if (SP_REG_CLASS_P (from))\n-        return 4;\n-      else if (CP_REG_CLASS_P (from))\n-        return 5;\n-      else if (CE_REG_CLASS_P (from))\n-        return 6;\n-    }\n-  return 12;\n-}\n-\n-/* Return the number of instructions needed to load a symbol of the\n-   given type into a register.  */\n-static int\n-score3_symbol_insns (enum score_symbol_type type)\n-{\n-  switch (type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 2;\n-\n-    case SYMBOL_SMALL_DATA:\n-      return 1;\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Return the number of instructions needed to load or store a value\n-   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n-static int\n-score3_address_insns (rtx x, enum machine_mode mode)\n-{\n-  struct score3_address_info addr;\n-  int factor;\n-\n-  if (mode == BLKmode)\n-    factor = 1;\n-  else\n-    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (score3_classify_address (&addr, mode, x, false))\n-    switch (addr.type)\n-      {\n-      case SCORE3_ADD_REG:\n-      case SCORE3_ADD_CONST_INT:\n-        return factor;\n-\n-      case SCORE3_ADD_SYMBOLIC:\n-        return factor * score3_symbol_insns (addr.symbol_type);\n-      }\n-  return 0;\n-}\n-\n-/* Implement TARGET_RTX_COSTS macro.  */\n-bool\n-score3_rtx_costs (rtx x, int code, int outer_code, int *total,\n-\t\t  bool speed ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (outer_code == SET)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n-            *total = COSTS_N_INSNS (1);\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == PLUS || outer_code == MINUS)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n-            *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == AND || outer_code == IOR)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n-            *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else\n-        {\n-          *total = 0;\n-        }\n-      return true;\n-\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MEM:\n-      {\n-        /* If the address is legitimate, return the number of\n-           instructions it needs, otherwise use the default handling.  */\n-        int n = score3_address_insns (XEXP (x, 0), GET_MODE (x));\n-        if (n > 0)\n-          {\n-            *total = COSTS_N_INSNS (n + 1);\n-            return true;\n-          }\n-        return false;\n-      }\n-\n-    case FFS:\n-      *total = COSTS_N_INSNS (6);\n-      return true;\n-\n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (2);\n-          return true;\n-        }\n-      return false;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n-                                  ? 4 : 12);\n-          return true;\n-        }\n-      return false;\n-\n-    case ABS:\n-      *total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case PLUS:\n-    case MINUS:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case NEG:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      return false;\n-\n-    case MULT:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n-      return true;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      switch (GET_MODE (XEXP (x, 0)))\n-        {\n-        case QImode:\n-        case HImode:\n-          if (GET_CODE (XEXP (x, 0)) == MEM)\n-            {\n-              *total = COSTS_N_INSNS (2);\n-\n-              if (!TARGET_LITTLE_ENDIAN &&\n-                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n-                *total = 100;\n-            }\n-          else\n-            *total = COSTS_N_INSNS (1);\n-          break;\n-\n-        default:\n-          *total = COSTS_N_INSNS (1);\n-          break;\n-        }\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Implement TARGET_ADDRESS_COST macro.  */\n-int\n-score3_address_cost (rtx addr)\n-{\n-  return score3_address_insns (addr, SImode);\n-}\n-\n-/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n-int\n-score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                        tree decl, const char *name)\n-{\n-  register struct extern_list *p;\n-\n-  if (score3_in_small_data_p (decl))\n-    {\n-      p = ggc_alloc_extern_list ();\n-      p->next = extern_head;\n-      p->name = name;\n-      p->size = int_size_in_bytes (TREE_TYPE (decl));\n-      extern_head = p;\n-    }\n-  return 0;\n-}\n-\n-/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n-   back to a previous frame.  */\n-rtx\n-score3_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n-{\n-  if (count != 0)\n-    return const0_rtx;\n-  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n-}\n-\n-/* Implement PRINT_OPERAND macro.  */\n-/* Score-specific operand codes:\n-   '['        print .set nor1 directive\n-   ']'        print .set r1 directive\n-   'U'        print hi part of a CONST_INT rtx\n-   'E'        print log2(v)\n-   'F'        print log2(~v)\n-   'D'        print SFmode const double\n-   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n-   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n-   'L'        low  part of DImode reg operand\n-   'H'        high part of DImode reg operand\n-   'C'        print part of opcode for a branch condition.  */\n-void\n-score3_print_operand (FILE *file, rtx op, int c)\n-{\n-  enum rtx_code code = UNKNOWN;\n-  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n-    code = GET_CODE (op);\n-\n-  if (c == '[')\n-    {\n-      fprintf (file, \".set r1\\n\");\n-    }\n-  else if (c == ']')\n-    {\n-      fprintf (file, \"\\n\\t.set nor1\");\n-    }\n-  else if (c == 'U')\n-    {\n-      gcc_assert (code == CONST_INT);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-               (INTVAL (op) >> 16) & 0xffff);\n-    }\n-  else if (c == 'D')\n-    {\n-      if (GET_CODE (op) == CONST_DOUBLE)\n-        {\n-          rtx temp = gen_lowpart (SImode, op);\n-          gcc_assert (GET_MODE (op) == SFmode);\n-          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n-        }\n-      else\n-        output_addr_const (file, op);\n-    }\n-  else if (c == 'S')\n-    {\n-      gcc_assert (code == REG);\n-      if (G16_REG_P (REGNO (op)))\n-        fprintf (file, \"!\");\n-    }\n-  else if (c == 'V')\n-    {\n-      gcc_assert (code == REG);\n-      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n-    }\n-  else if (c == 'C')\n-    {\n-      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-\n-      switch (code)\n-        {\n-        case EQ: fputs (\"eq!\", file); break;\n-        case NE: fputs (\"ne!\", file); break;\n-        case GT: fputs (\"gt!\", file); break;\n-        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n-        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n-        case LE: fputs (\"le!\", file); break;\n-        case GTU: fputs (\"gtu!\", file); break;\n-        case GEU: fputs (\"cs\", file); break;\n-        case LTU: fputs (\"cc\", file); break;\n-        case LEU: fputs (\"leu!\", file); break;\n-        default:\n-          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n-        }\n-    }\n-  else if (c == 'G')  /* Seperate from b<cond>, use for mv<cond>.  */\n-    {\n-      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-\n-      switch (code)\n-        {\n-        case EQ: fputs (\"eq\", file); break;\n-        case NE: fputs (\"ne\", file); break;\n-        case GT: fputs (\"gt\", file); break;\n-        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n-        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n-        case LE: fputs (\"le\", file); break;\n-        case GTU: fputs (\"gtu\", file); break;\n-        case GEU: fputs (\"cs\", file); break;\n-        case LTU: fputs (\"cc\", file); break;\n-        case LEU: fputs (\"leu\", file); break;\n-        default:\n-          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n-        }\n-    }\n-  else if (c == 'E')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (c == 'F')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = ~INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (code == REG)\n-    {\n-      int regnum = REGNO (op);\n-      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n-          || (c == 'L' && WORDS_BIG_ENDIAN))\n-        regnum ++;\n-      fprintf (file, \"%s\", reg_names[regnum]);\n-    }\n-  else\n-    {\n-      switch (code)\n-        {\n-        case MEM:\n-          score3_print_operand_address (file, op);\n-          break;\n-        default:\n-          output_addr_const (file, op);\n-        }\n-    }\n-}\n-\n-/* Implement PRINT_OPERAND_ADDRESS macro.  */\n-void\n-score3_print_operand_address (FILE *file, rtx x)\n-{\n-  struct score3_address_info addr;\n-  enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  if (code == MEM)\n-    x = XEXP (x, 0);\n-\n-  if (score3_classify_address (&addr, mode, x, true))\n-    {\n-      switch (addr.type)\n-        {\n-        case SCORE3_ADD_REG:\n-          {\n-            switch (addr.code)\n-              {\n-              case PRE_DEC:\n-                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_DEC:\n-                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case PRE_INC:\n-                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_INC:\n-                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              default:\n-                if (INTVAL(addr.offset) == 0)\n-                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n-                else\n-                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n-                          INTVAL(addr.offset));\n-                break;\n-              }\n-          }\n-          return;\n-        case SCORE3_ADD_CONST_INT:\n-        case SCORE3_ADD_SYMBOLIC:\n-          output_addr_const (file, x);\n-          return;\n-        }\n-    }\n-  print_rtl (stderr, x);\n-  gcc_unreachable ();\n-}\n-\n-/* Implement SELECT_CC_MODE macro.  */\n-enum machine_mode\n-score3_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n-{\n-  if ((op == EQ || op == NE || op == LT || op == GE)\n-      && y == const0_rtx\n-      && GET_MODE (x) == SImode)\n-    {\n-      switch (GET_CODE (x))\n-        {\n-        case PLUS:\n-        case MINUS:\n-        case NEG:\n-        case AND:\n-        case IOR:\n-        case XOR:\n-        case NOT:\n-        case ASHIFT:\n-        case LSHIFTRT:\n-        case ASHIFTRT:\n-          return CC_NZmode;\n-\n-        case SIGN_EXTEND:\n-        case ZERO_EXTEND:\n-        case ROTATE:\n-        case ROTATERT:\n-          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n-\n-        default:\n-          return CCmode;\n-        }\n-    }\n-\n-  if ((op == EQ || op == NE)\n-      && (GET_CODE (y) == NEG)\n-      && register_operand (XEXP (y, 0), SImode)\n-      && register_operand (x, SImode))\n-    {\n-      return CC_NZmode;\n-    }\n-\n-  return CCmode;\n-}\n-\n-#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n-/* return 0, no more bit set in mask.  */\n-static int rpush_first (int mask, int sb, int *rd)\n-{\n-  int i, cnt = 1;\n-\n-  if ((mask & (1 << sb)) == 0)\n-    return 0;\n-\n-  *rd = sb;\n-\n-  for (i = sb-1; i >= 0; i--)\n-    {\n-      if (mask & (1 << i))\n-        {\n-          cnt ++;\n-          continue;\n-        }\n-\n-      *rd = i+1;\n-      break;;\n-    }\n-\n-  return cnt;\n-}\n-\n-static void\n-rpush (int rd, int cnt)\n-{\n-  rtx mem = gen_rtx_MEM (SImode, gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n-  rtx reg = gen_rtx_REG (SImode, rd);\n-\n-  if (!crtl->calls_eh_return)\n-    MEM_READONLY_P (mem) = 1;\n-\n-  if (cnt == 1)\n-    EMIT_PL (emit_insn (gen_pushsi_score3 (mem, reg)));\n-  else\n-    {\n-      int i;\n-      rtx insn = gen_store_multiple (gen_rtx_MEM (SImode, stack_pointer_rtx),\n-                                     gen_rtx_REG (SImode, rd),\n-                                     GEN_INT (cnt));\n-\n-      rtx pat = PATTERN (insn);\n-\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-        if (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n-          RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n-\n-      EMIT_PL (emit_insn (insn));\n-    }\n-}\n-\n-/* Generate the prologue instructions for entry into a S+core function.  */\n-void\n-score3_prologue (void)\n-{\n-  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (flag_pic)\n-    emit_insn (gen_cpload_score3 ());\n-\n-  {\n-    int cnt, rd;\n-\n-    for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n-      {\n-        cnt = rpush_first (f->mask, regno, &rd);\n-        if (cnt != 0)\n-          {\n-            rpush (rd, cnt);\n-            regno = regno - cnt;\n-          }\n-      }\n-  }\n-\n-  if (size > 0)\n-    {\n-      rtx insn;\n-\n-      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n-        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                                           stack_pointer_rtx,\n-                                           GEN_INT (-size))));\n-      else\n-        {\n-          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE3_PROLOGUE_TEMP_REGNUM),\n-                                   GEN_INT (size)));\n-          EMIT_PL (emit_insn\n-                   (gen_sub3_insn (stack_pointer_rtx,\n-                                   stack_pointer_rtx,\n-                                   gen_rtx_REG (Pmode,\n-                                                SCORE3_PROLOGUE_TEMP_REGNUM))));\n-        }\n-      insn = get_last_insn ();\n-      REG_NOTES (insn) =\n-        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                      plus_constant (stack_pointer_rtx,\n-                                                     -size)),\n-                                      REG_NOTES (insn));\n-    }\n-\n-  if (frame_pointer_needed)\n-    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n-\n-  if (flag_pic && f->cprestore_size)\n-    {\n-      if (frame_pointer_needed)\n-        emit_insn (gen_cprestore_use_fp_score3 (GEN_INT (size - f->cprestore_size)));\n-      else\n-        emit_insn (gen_cprestore_use_sp_score3 (GEN_INT (size - f->cprestore_size)));\n-    }\n-}\n-\n-/* return 0, no more bit set in mask.  */\n-static int\n-rpop_first (int mask, int sb, int *rd)\n-{\n-  int i, cnt = 1;\n-\n-  if ((mask & (1 << sb)) == 0)\n-    return 0;\n-\n-  *rd = sb;\n-\n-  for (i = sb+1; i < 32; i++)\n-    if (mask & (1 << i))\n-      cnt++;\n-    else\n-      break;;\n-\n-  return cnt;\n-}\n-\n-static void\n-rpop (int rd, int cnt)\n-{\n-  rtx mem = gen_rtx_MEM (SImode, gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n-  rtx reg = gen_rtx_REG (SImode, rd);\n-\n-  if (!crtl->calls_eh_return)\n-    MEM_READONLY_P (mem) = 1;\n-\n-  if (cnt == 1)\n-    emit_insn (gen_popsi_score3 (reg, mem));\n-  else\n-    emit_insn (gen_load_multiple (reg,\n-                                  gen_rtx_MEM (SImode, stack_pointer_rtx),\n-                                  GEN_INT (cnt)));\n-}\n-\n-/* Generate the epilogue instructions in a S+core function.  */\n-void\n-score3_epilogue (int sibcall_p)\n-{\n-  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-  rtx base;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (!frame_pointer_needed)\n-    base = stack_pointer_rtx;\n-  else\n-    base = hard_frame_pointer_rtx;\n-\n-  if (size)\n-    {\n-      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n-        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n-      else\n-        {\n-          emit_move_insn (gen_rtx_REG (Pmode, SCORE3_EPILOGUE_TEMP_REGNUM),\n-                          GEN_INT (size));\n-          emit_insn (gen_add3_insn (base, base,\n-                                    gen_rtx_REG (Pmode,\n-                                                 SCORE3_EPILOGUE_TEMP_REGNUM)));\n-        }\n-    }\n-\n-  if (base != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, base);\n-\n-  if (crtl->calls_eh_return)\n-    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                              stack_pointer_rtx,\n-                              EH_RETURN_STACKADJ_RTX));\n-\n-  {\n-    int cnt, rd;\n-\n-    for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n-      {\n-        cnt = rpop_first (f->mask, regno, &rd);\n-        if (cnt != 0)\n-          {\n-            rpop (rd, cnt);\n-            regno = regno + cnt;\n-          }\n-      }\n-  }\n-\n-  if (!sibcall_p)\n-    emit_jump_insn (gen_return_internal_score3 (gen_rtx_REG (Pmode, RA_REGNUM)));\n-}\n-\n-/* Return true if X is a symbolic constant that can be calculated in\n-   the same way as a bare symbol.  If it is, store the type of the\n-   symbol in *SYMBOL_TYPE.  */\n-int\n-score3_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n-{\n-  HOST_WIDE_INT offset;\n-\n-  score3_split_const (x, &x, &offset);\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    *symbol_type = score3_classify_symbol (x);\n-  else\n-    return 0;\n-\n-  if (offset == 0)\n-    return 1;\n-\n-  /* if offset > 15bit, must reload  */\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    return 0;\n-\n-  switch (*symbol_type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 1;\n-    case SYMBOL_SMALL_DATA:\n-      return score3_offset_within_object_p (x, offset);\n-    }\n-  gcc_unreachable ();\n-}\n-\n-void\n-score3_movsicc (rtx *ops)\n-{\n-  enum machine_mode mode;\n-\n-  mode = score3_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n-\t\t\t\t\t   XEXP (ops[1], 1))));\n-}\n-\n-/* Call and sibcall pattern all need call this function.  */\n-void\n-score3_call (rtx *ops, bool sib)\n-{\n-  rtx addr = XEXP (ops[0], 0);\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_internal_score3 (addr, ops[1]));\n-  else\n-    emit_call_insn (gen_call_internal_score3 (addr, ops[1]));\n-}\n-\n-/* Call value and sibcall value pattern all need call this function.  */\n-void\n-score3_call_value (rtx *ops, bool sib)\n-{\n-  rtx result = ops[0];\n-  rtx addr = XEXP (ops[1], 0);\n-  rtx arg = ops[2];\n-\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_value_internal_score3 (result, addr, arg));\n-  else\n-    emit_call_insn (gen_call_value_internal_score3 (result, addr, arg));\n-}\n-\n-/* Machine Split  */\n-void\n-score3_movdi (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx dst0 = score3_subw (dst, 0);\n-  rtx dst1 = score3_subw (dst, 1);\n-  rtx src0 = score3_subw (src, 0);\n-  rtx src1 = score3_subw (src, 1);\n-\n-  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n-    {\n-      emit_move_insn (dst1, src1);\n-      emit_move_insn (dst0, src0);\n-    }\n-  else\n-    {\n-      emit_move_insn (dst0, src0);\n-      emit_move_insn (dst1, src1);\n-    }\n-}\n-\n-void\n-score3_zero_extract_andi (rtx *ops)\n-{\n-  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n-    emit_insn (gen_zero_extract_bittst_score3 (ops[0], ops[2]));\n-  else\n-    {\n-      unsigned HOST_WIDE_INT mask;\n-      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n-      mask = mask << INTVAL (ops[2]);\n-      emit_insn (gen_andsi3_cmp_score3 (ops[3], ops[0],\n-                                        gen_int_mode (mask, SImode)));\n-    }\n-}\n-\n-const char *\n-score3_rpush (rtx *ops)\n-{\n-  snprintf (score3_ins, INS_BUF_SZ, \"rpush!\\t%%1, %d\", XVECLEN (ops[0], 0));\n-  return score3_ins;\n-}\n-\n-const char *\n-score3_rpop (rtx *ops)\n-{\n-  snprintf (score3_ins, INS_BUF_SZ, \"rpop!\\t%%1, %d\", XVECLEN (ops[0], 0));\n-  return score3_ins;\n-}\n-\n-/* Output asm code for ld/sw insn.  */\n-static int\n-score3_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip,\n-                     enum score_mem_unit unit ATTRIBUTE_UNUSED)\n-{\n-  struct score3_address_info ai;\n-\n-  gcc_assert (GET_CODE (ops[idata]) == REG);\n-  gcc_assert (score3_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n-\n-  if (ai.type == SCORE3_ADD_REG\n-      && ai.code == REG\n-      && GET_CODE (ai.offset) == CONST_INT\n-      && G16_REG_P (REGNO (ops[idata]))\n-      && G8_REG_P (REGNO (ai.reg))\n-      && ((INTVAL (ai.offset) & 3) == 0)\n-      && (IMM_IN_RANGE (INTVAL (ai.offset), 7, 0)))\n-    {\n-      ops[iaddr] = ai.reg;\n-      return snprintf (ip, INS_BUF_SZ, \"!\\t%%%d, [%%%d, \"\n-                       HOST_WIDE_INT_PRINT_DEC \"]\",\n-                       idata, iaddr, INTVAL (ai.offset));\n-    }\n-\n-  if (ai.type == SCORE3_ADD_SYMBOLIC)\n-    return snprintf (ip, INS_BUF_SZ, \"48\\t%%%d, %%a%d\", idata, iaddr);\n-\n-  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n-}\n-\n-/* Output asm insn for load.  */\n-const char *\n-score3_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n-{\n-  const char *pre_ins[] =\n-    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n-  char *ip;\n-\n-  strcpy (score3_ins, pre_ins[(sign ? 4 : 0) + unit]);\n-  ip = score3_ins + strlen (score3_ins);\n-\n-  if (unit == SCORE_WORD)\n-    score3_pr_addr_post (ops, 0, 1, ip, unit);\n-  else\n-    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n-\n-  return score3_ins;\n-}\n-\n-/* Output asm insn for store.  */\n-const char *\n-score3_sinsn (rtx *ops, enum score_mem_unit unit)\n-{\n-  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n-  char *ip;\n-\n-  strcpy (score3_ins, pre_ins[unit]);\n-  ip = score3_ins + strlen (score3_ins);\n-\n-  if (unit == SCORE_WORD)\n-    score3_pr_addr_post (ops, 1, 0, ip, unit);\n-  else\n-    snprintf (ip, INS_BUF_SZ, \"\\t%%1, %%a0\");\n-\n-  return score3_ins;\n-}\n-\n-/* Output asm insn for load immediate.  */\n-const char *\n-score3_limm (rtx *ops)\n-{\n-  HOST_WIDE_INT v;\n-\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n-\n-  v = INTVAL (ops[1]);\n-  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 5, 0))\n-    return \"ldiu!\\t%0, %c1\";\n-  else if (IMM_IN_RANGE (v, 16, 1))\n-    return \"ldi\\t%0, %c1\";\n-  else if ((v & 0xffff) == 0)\n-    return \"ldis\\t%0, %U1\";\n-  else\n-    return \"li\\t%0, %c1\";\n-}\n-\n-/* Output asm insn for move.  */\n-const char *\n-score3_move (rtx *ops)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  return \"mv!\\t%0, %1\";\n-}\n-\n-/* Generate add insn.  */\n-const char *\n-score3_select_add_imm (rtx *ops, bool set_cc)\n-{\n-  HOST_WIDE_INT v = INTVAL (ops[2]);\n-\n-  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n-  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n-\n-  if (set_cc)\n-    return \"addi.c\\t%0, %c2\";\n-  else\n-    if (IMM_IN_RANGE (v, 6, 1) && G16_REG_P (REGNO (ops[0])))\n-      return \"addi!\\t%0, %c2\";\n-    else\n-      return \"addi\\t%0, %c2\";\n-}\n-\n-/* Output arith insn.  */\n-const char *\n-score3_select (rtx *ops, const char *inst_pre, bool commu ATTRIBUTE_UNUSED,\n-               const char *letter, bool set_cc)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (set_cc)\n-    snprintf (score3_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  else\n-    snprintf (score3_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  return score3_ins;\n-}\n-\n-/* Output a Score3 casesi instruction.  */\n-const char *\n-score3_output_casesi (rtx *operands)\n-{\n-  rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n-  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n-\n-  output_asm_insn (\"cmpi.c\\t%0, %1\", operands);\n-  output_asm_insn (\"bgtu\\t%3\", operands);\n-  switch (GET_MODE(diff_vec))\n-    {\n-    case QImode:\n-      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n-      output_asm_insn (\"ltbb\\t%4, [%4, %0]\\n%2_tbb:\", operands);\n-      return \"brr!\\t%4\";\n-    case HImode:\n-      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n-      output_asm_insn (\"ltbh\\t%4, [%4, %0]\\n%2_tbb:\", operands);\n-      return \"brr!\\t%4\";\n-    case SImode:\n-      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n-      output_asm_insn (\"ltbw\\t%4, [%4, %0]\", operands);\n-      return \"br!\\t%4\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}"}, {"sha": "47d20e627bbe498111bdf2670d19800e79a692f1", "filename": "gcc/config/score/score3.h", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc1806ad1a7f52470cb6c327b95b27c307d5917/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=fdc1806ad1a7f52470cb6c327b95b27c307d5917", "patch": "@@ -1,160 +0,0 @@\n-/* score3.h for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_SCORE3_H\n-#define GCC_SCORE3_H\n-\n-enum score3_address_type\n-{\n-  SCORE3_ADD_REG,\n-  SCORE3_ADD_CONST_INT,\n-  SCORE3_ADD_SYMBOLIC\n-};\n-\n-struct score3_frame_info\n-{\n-  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n-  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n-  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n-  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n-  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n-  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n-  unsigned int  mask;             /* mask of saved gp registers  */\n-  int num_gp;                     /* number of gp registers saved  */\n-};\n-\n-struct score3_arg_info\n-{\n-  unsigned int num_bytes;     /* The argument's size in bytes  */\n-  unsigned int reg_words;     /* The number of words passed in registers  */\n-  unsigned int reg_offset;    /* The offset of the first register from  */\n-                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n-  unsigned int stack_words;   /* The number of words that must be passed  */\n-                              /* on the stack  */\n-  unsigned int stack_offset;  /* The offset from the start of the stack  */\n-                              /* overflow area  */\n-};\n-\n-#ifdef RTX_CODE\n-struct score3_address_info\n-{\n-  enum score3_address_type type;\n-  rtx reg;\n-  rtx offset;\n-  enum rtx_code code;\n-  enum score_symbol_type symbol_type;\n-};\n-#endif\n-\n-#define SCORE3_SDATA_MAX                score3_sdata_max\n-#define SCORE3_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n-#define SCORE3_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE3_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE3_DEFAULT_SDATA_MAX        8\n-\n-extern int score3_symbolic_constant_p (rtx x,\n-                                       enum score_symbol_type *symbol_type);\n-extern bool score3_return_in_memory (const_tree type,\n-                                     const_tree fndecl ATTRIBUTE_UNUSED);\n-extern void score3_output_mi_thunk (FILE *file,\n-                                    tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                                    HOST_WIDE_INT delta,\n-                                    HOST_WIDE_INT vcall_offset,\n-                                    tree function);\n-extern rtx score3_legitimize_address (rtx x);\n-extern void\n-score3_function_prologue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n-extern void\n-score3_function_epilogue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n-extern section *score3_select_rtx_section (enum machine_mode mode, rtx x,\n-                                           unsigned HOST_WIDE_INT align);\n-extern bool score3_in_small_data_p (const_tree decl);\n-extern void score3_asm_file_start (void);\n-extern void score3_asm_file_end (void);\n-extern void score3_option_override (void);\n-extern int score3_reg_class (int regno);\n-extern enum reg_class score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n-                                                     enum reg_class rclass);\n-extern enum reg_class\n-score3_secondary_reload_class (enum reg_class rclass,\n-                               enum machine_mode mode ATTRIBUTE_UNUSED,\n-                               rtx x);\n-extern int score3_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n-extern int score3_extra_constraint (rtx op, char c);\n-extern int score3_hard_regno_mode_ok (unsigned int regno,\n-                                      enum machine_mode mode);\n-extern HOST_WIDE_INT\n-score3_initial_elimination_offset (int from,\n-                                   int to ATTRIBUTE_UNUSED);\n-extern void score3_function_arg_advance (CUMULATIVE_ARGS *cum,\n-                                         enum machine_mode mode,\n-                                         const_tree type,\n-                                         bool named);\n-extern int score3_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n-                                     enum machine_mode mode,\n-                                     tree type,\n-                                     bool named);\n-extern rtx score3_function_arg (const CUMULATIVE_ARGS *cum,\n-                                enum machine_mode mode,\n-                                const_tree type,\n-                                bool named);\n-extern rtx score3_function_value (const_tree valtype,\n-                                  const_tree func ATTRIBUTE_UNUSED,\n-                                  enum machine_mode mode);\n-extern void score3_asm_trampoline_template (FILE *);\n-extern void score3_trampoline_init (rtx, tree, rtx);\n-extern int score3_regno_mode_ok_for_base_p (int regno, int strict);\n-extern bool score3_legitimate_address_p (enum machine_mode mode, rtx x,\n-\t\t\t\t\t bool strict);\n-extern int score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                      enum reg_class from,\n-                                      enum reg_class to);\n-extern bool score3_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed);\n-extern int score3_address_cost (rtx addr);\n-extern int score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                                   tree decl,\n-                                   const char *name);\n-extern rtx score3_return_addr (int count, rtx frame ATTRIBUTE_UNUSED);\n-extern void score3_print_operand (FILE *file, rtx op, int c);\n-extern void score3_print_operand_address (FILE *file, rtx x);\n-extern enum machine_mode\n-score3_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n-extern void score3_prologue (void);\n-extern void score3_epilogue (int sibcall_p);\n-extern void score3_call (rtx *ops, bool sib);\n-extern void score3_call_value (rtx *ops, bool sib);\n-extern void score3_movsicc (rtx *ops);\n-extern void score3_movdi (rtx *ops);\n-extern void score3_zero_extract_andi (rtx *ops);\n-extern const char * score3_select_add_imm (rtx *ops, bool set_cc);\n-extern const char * score3_select (rtx *ops, const char *inst_pre, bool commu,\n-                                   const char *letter, bool set_cc);\n-extern const char * score3_move (rtx *ops);\n-extern const char * score3_limm (rtx *ops);\n-extern const char *\n-score3_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n-extern const char *\n-score3_sinsn (rtx *ops, enum score_mem_unit unit);\n-extern const char * score3_output_casesi (rtx *operands);\n-extern const char * score3_rpush (rtx *ops);\n-extern const char * score3_rpop (rtx *ops);\n-#endif"}, {"sha": "8a57362bab84a9d42ba18f6b099cba2aebfedc89", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 13, "deletions": 78, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -340,7 +340,7 @@ score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   if (delta != 0)\n     {\n       rtx offset = GEN_INT (delta);\n-      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n+      if (!(delta >= -32768 && delta <= 32767))\n         {\n           emit_move_insn (temp1, offset);\n           offset = temp1;\n@@ -638,31 +638,8 @@ void\n score7_option_override (void)\n {\n   flag_pic = false;\n-  if (!flag_pic)\n-    score7_sdata_max = (global_options_set.x_g_switch_value\n-\t\t\t? g_switch_value\n-\t\t\t: SCORE7_DEFAULT_SDATA_MAX);\n-  else\n-    {\n-      score7_sdata_max = 0;\n-      if (global_options_set.x_g_switch_value && (g_switch_value != 0))\n-        warning (0, \"-fPIC and -G are incompatible\");\n-    }\n-\n-  score_char_to_class['d'] = G32_REGS;\n-  score_char_to_class['e'] = G16_REGS;\n-  score_char_to_class['t'] = T32_REGS;\n-\n-  score_char_to_class['h'] = HI_REG;\n-  score_char_to_class['l'] = LO_REG;\n-  score_char_to_class['x'] = CE_REGS;\n+  score7_sdata_max = SCORE7_DEFAULT_SDATA_MAX;\n \n-  score_char_to_class['q'] = CN_REG;\n-  score_char_to_class['y'] = LC_REG;\n-  score_char_to_class['z'] = SC_REG;\n-  score_char_to_class['a'] = SP_REGS;\n-\n-  score_char_to_class['c'] = CR_REGS;\n }\n \n /* Implement REGNO_REG_CLASS macro.  */\n@@ -710,42 +687,6 @@ score7_secondary_reload_class (enum reg_class rclass,\n   return NO_REGS;\n }\n \n-/* Implement CONST_OK_FOR_LETTER_P macro.  */\n-/* imm constraints\n-   I        imm16 << 16\n-   J        uimm5\n-   K        uimm16\n-   L        simm16\n-   M        uimm14\n-   N        simm14  */\n-int\n-score7_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n-{\n-  switch (c)\n-    {\n-    case 'I': return ((value & 0xffff) == 0);\n-    case 'J': return IMM_IN_RANGE (value, 5, 0);\n-    case 'K': return IMM_IN_RANGE (value, 16, 0);\n-    case 'L': return IMM_IN_RANGE (value, 16, 1);\n-    case 'M': return IMM_IN_RANGE (value, 14, 0);\n-    case 'N': return IMM_IN_RANGE (value, 14, 1);\n-    default : return 0;\n-    }\n-}\n-\n-/* Implement EXTRA_CONSTRAINT macro.  */\n-/* Z        symbol_ref  */\n-int\n-score7_extra_constraint (rtx op, char c)\n-{\n-  switch (c)\n-    {\n-    case 'Z':\n-      return GET_CODE (op) == SYMBOL_REF;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n \n /* Return truth value on whether or not a given hard register\n    can support a given mode.  */\n@@ -884,7 +825,6 @@ score7_asm_trampoline_template (FILE *f)\n void\n score7_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n-#define FFCACHE          \"_flush_cache\"\n #define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n \n   rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n@@ -899,11 +839,6 @@ score7_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   mem = adjust_address (m_tramp, SImode, CODE_SIZE + GET_MODE_SIZE (SImode));\n   emit_move_insn (mem, chain_value);\n \n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n-                     LCT_NORMAL, VOIDmode, 2,\n-                     addr, Pmode,\n-                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n-#undef FFCACHE\n #undef CODE_SIZE\n }\n \n@@ -1018,28 +953,28 @@ score7_rtx_costs (rtx x, int code, int outer_code, int *total,\n     case CONST_INT:\n       if (outer_code == SET)\n         {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+          if (((INTVAL (x) & 0xffff) == 0) \n+              || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n             *total = COSTS_N_INSNS (1);\n           else\n             *total = COSTS_N_INSNS (2);\n         }\n       else if (outer_code == PLUS || outer_code == MINUS)\n         {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n+          if (INTVAL (x) >= -8192 && INTVAL (x) <= 8191)\n             *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+          else if (((INTVAL (x) & 0xffff) == 0)\n+                   || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n             *total = 1;\n           else\n             *total = COSTS_N_INSNS (2);\n         }\n       else if (outer_code == AND || outer_code == IOR)\n         {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n+          if (INTVAL (x) >= 0 && INTVAL (x) <= 16383)\n             *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n+          else if (((INTVAL (x) & 0xffff) == 0)\n+                   || (INTVAL (x) >= 0 && INTVAL (x) <= 65535))\n             *total = 1;\n           else\n             *total = COSTS_N_INSNS (2);\n@@ -1456,7 +1391,7 @@ score7_prologue (void)\n     {\n       rtx insn;\n \n-      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n+      if (size >= -32768 && size <= 32767)\n         EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n                                            stack_pointer_rtx,\n                                            GEN_INT (-size))));\n@@ -1511,7 +1446,7 @@ score7_epilogue (int sibcall_p)\n \n   if (size)\n     {\n-      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n+      if (size >= -32768 && size <= 32767)\n         emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n       else\n         {\n@@ -1714,7 +1649,7 @@ score7_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum score_mem_un\n         {\n           HOST_WIDE_INT offset = INTVAL (ai.offset);\n           if (SCORE_ALIGN_UNIT (offset, unit)\n-              && CONST_OK_FOR_LETTER_P (offset >> unit, 'J'))\n+              && (((offset >> unit) >= 0) && ((offset >> unit) <= 31)))\n             {\n               ops[iaddr] = ai.offset;\n               return snprintf (ip, INS_BUF_SZ,"}, {"sha": "98f9f1bf491d427f4b3b22d84eba1ba60f91ef51", "filename": "gcc/config/score/sfp-machine.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fsfp-machine.h?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -0,0 +1,57 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+# define __BYTE_ORDER __BIG_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+"}, {"sha": "f02c482f51d5bba923d40086a631c82eb7a8b862", "filename": "gcc/config/score/t-score-elf", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -19,17 +19,10 @@\n # Additional Backend Files\n score7.o: $(srcdir)/config/score/score7.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n-  expr.h $(TM_P_H)\n+  expr.h toplev.h $(TM_P_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t$(srcdir)/config/score/score7.c\n \n-score3.o: $(srcdir)/config/score/score3.c $(CONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n-  expr.h $(TM_P_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t$(srcdir)/config/score/score3.c\n-\n-\n # Assemble startup files.\n $(T)crti.o: $(srcdir)/config/score/crti.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n@@ -38,33 +31,3 @@ $(T)crti.o: $(srcdir)/config/score/crti.asm $(GCC_PASSES)\n $(T)crtn.o: $(srcdir)/config/score/crtn.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n \t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/score/crtn.asm\n-\n-LIB1ASMSRC = score/mul-div.S\n-\n-LIB1ASMFUNCS = _mulsi3 _divsi3 _flush_cache\n-\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-# If any special flags are necessary when building libgcc2 put them here.\n-TARGET_LIBGCC2_CFLAGS = -g\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-# We must build libgcc2.a with -G 0, in case the user wants to link\n-# without the $gp register.\n-TARGET_LIBGCC2_CFLAGS = -G 0\n-\n-MULTILIB_OPTIONS = mscore3 mel\n-MULTILIB_MATCHES = mscore3=march?score3\n-\n-EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-"}, {"sha": "b658ef89bd304719245a59cb3ea974408fd2da81", "filename": "gcc/config/score/t-score-softfp", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Ft-score-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6193a7e2c2f567ce6abc772d2271c56f8efa3a/gcc%2Fconfig%2Fscore%2Ft-score-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-softfp?ref=9d6193a7e2c2f567ce6abc772d2271c56f8efa3a", "patch": "@@ -0,0 +1,9 @@\n+softfp_float_modes := sf df\n+softfp_int_modes := si di\n+softfp_extensions := sfdf\n+softfp_truncations := dfsf\n+softfp_machine_header := score/sfp-machine.h\n+softfp_exclude_libgcc2 := y\n+\n+# softfp seems to be missing a whole bunch of prototypes.\n+TARGET_LIBGCC2_CFLAGS += -Wno-missing-prototypes"}]}