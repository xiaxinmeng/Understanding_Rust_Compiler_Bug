{"sha": "e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljZDBiMjUxOGZkOGIzZTI2NWZhMzlhODA2ZjBlY2MyZTJhYjExMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-08-10T01:59:37Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-08-10T01:59:37Z"}, "message": "Merge.  See ChangeLog.\n\nFrom-SVN: r5125", "tree": {"sha": "4a0c3ca97075ec42fb850a13d6ecb77f22558130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a0c3ca97075ec42fb850a13d6ecb77f22558130"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/comments", "author": null, "committer": null, "parents": [{"sha": "690ddf3e4ef9900f777f2476decc5f8e3aac401c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690ddf3e4ef9900f777f2476decc5f8e3aac401c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690ddf3e4ef9900f777f2476decc5f8e3aac401c"}], "stats": {"total": 317, "additions": 210, "deletions": 107}, "files": [{"sha": "0908fa70a5900cd5b3d90adb013b319c2328c18a", "filename": "gcc/fix-header.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "patch": "@@ -198,7 +198,7 @@ read_scan_file (scan_file)\n       struct partial_proto *partial;\n       struct fn_decl *fn;\n       int ch;\n-      char *ptr, *fname, *extern_C, *rtype, *args, *file_seen, *line_seen;\n+      char *ptr, *fname, *kind, *rtype, *args, *file_seen, *line_seen;\n       line.ptr = line.base;\n       ch = read_upto (scan_file, &line, '\\n');\n       if (ch == EOF)\n@@ -207,11 +207,11 @@ read_scan_file (scan_file)\n       fname = line.base;\n       for (ptr = fname; *ptr != ';'; ) ptr++;\n       *ptr = 0;\n-      extern_C = ptr + 1;\n-      for (ptr = extern_C; *ptr != ';'; ) ptr++;\n+      kind = ptr + 1;\n+      for (ptr = kind; *ptr != ';'; ) ptr++;\n       *ptr = 0;\n \n-      if (*extern_C == 'X')\n+      if (*kind == 'X')\n \t{\n \t  switch (special_file_handling)\n \t    {\n@@ -222,7 +222,7 @@ read_scan_file (scan_file)\n \t  continue;\n \t}\n \n-      if (*extern_C == 'M')\n+      if (*kind == 'M')\n \t{\n \t  /* The original include file defines fname as a macro. */\n \t  fn = lookup_std_proto (fname);\n@@ -273,7 +273,7 @@ read_scan_file (scan_file)\n       for (ptr = line_seen; *ptr != ';'; ) ptr++;\n       *ptr = 0;\n \n-      if (extern_C[0] == 'f')\n+      if (kind[0] == 'f')\n \tmissing_extern_C_count++;\n \n       fn = lookup_std_proto (fname);\n@@ -289,6 +289,9 @@ read_scan_file (scan_file)\n       if (args[0] != '\\0')\n \tcontinue;\n       \n+      if (kind[0] == 'I')  /* don't edit inline function */\n+\tcontinue;\n+\n       /* If the partial prototype was included from some other file,\n \t we don't need to patch it up (in this run). */\n       i = strlen (file_seen);\n@@ -298,7 +301,7 @@ read_scan_file (scan_file)\n \n       if (fn == NULL)\n \tcontinue;\n-      if (fn->fname[0] == '\\0' || strcmp(fn->fname, \"void\") == 0)\n+      if (fn->params[0] == '\\0' || strcmp(fn->params, \"void\") == 0)\n \tcontinue;\n \n       /* We only have a partial function declaration,\n@@ -329,15 +332,21 @@ read_scan_file (scan_file)\n \tfprintf (stderr, \"%s: OK, nothing needs to be done.\\n\", inc_filename);\n       exit (0);\n     }\n-  if (required_unseen_count)\n-    fprintf (stderr, \"%s: %d missing function declarations.\\n\",\n-\t     inc_filename, required_unseen_count);\n-  if (partial_count)\n-    fprintf (stderr, \"%s: %d non-prototype function declarations.\\n\",\n-\t     inc_filename, partial_count);\n-  if (missing_extern_C_count)\n-    fprintf (stderr, \"%s: %d declarations not protected by extern \\\"C\\\".\\n\",\n-\t     inc_filename, missing_extern_C_count);\n+  if (!verbose)\n+    fprintf (stderr, \"%s: fixing %s\\n\", progname, inc_filename);\n+  else\n+    {\n+      if (required_unseen_count)\n+\tfprintf (stderr, \"%s: %d missing function declarations.\\n\",\n+\t\t inc_filename, required_unseen_count);\n+      if (partial_count)\n+\tfprintf (stderr, \"%s: %d non-prototype function declarations.\\n\",\n+\t\t inc_filename, partial_count);\n+      if (missing_extern_C_count)\n+\tfprintf (stderr,\n+\t\t \"%s: %d declarations not protected by extern \\\"C\\\".\\n\",\n+\t\t inc_filename, missing_extern_C_count);\n+    }\n }\n \n write_rbrac ()\n@@ -652,7 +661,7 @@ main(argc, argv)\n \t\t\t}\n \t\t    }\n \t\t  else\n-\t\t    putc (c, outf);\n+\t\t    fprintf (outf, \" %c\", c);\n \t\t}\n \t    }\n \t  else"}, {"sha": "39849e6b2716d78c376888fce5645baedf1c7503", "filename": "gcc/fixproto", "status": "modified", "additions": 144, "deletions": 82, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Ffixproto", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Ffixproto", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixproto?ref=e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "patch": "@@ -54,9 +54,8 @@\n progname=$0\n progname=`basename $progname`\n original_dir=`pwd`\n-CC=gcc\n CPP=${CPP-./cpp}\n-#CPP=\"${CC} -E\"\n+\n if [ `echo $1 | wc -w` = 0 ] ; then\n   echo $progname\\: usage\\: $progname target-dir \\[ source-dir \\.\\.\\. \\]\n   exit 1\n@@ -70,51 +69,24 @@ else\n   abs_target_dir=$rel_target_dir\n fi\n \n+# Determine whether this system has symbolic links.\n+if ln -s X $rel_target_dir/ShouldNotExist 2>/dev/null; then\n+  rm -f $rel_target_dir/ShouldNotExist\n+  LINKS=true\n+elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n+  rm -f /tmp/ShouldNotExist\n+  LINKS=true\n+else\n+  LINKS=false\n+fi\n+\n if [ \\! -d $abs_target_dir ] ; then\n   echo $progname\\: creating directory $rel_target_dir\n   mkdir $abs_target_dir\n fi\n \n echo $progname\\: populating \\`$rel_target_dir\\'\n \n-required_ctype_h=\"isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper\"\n-required_dirent_h=\"closedir opendir readdir rewinddir\"\n-extra_check_errno_h=\"errno\"\n-required_curses_h=\"box delwin endwin getcurx getcury initscr mvcur mvwprintw mvwscanw newwin overlay overwrite scroll subwin touchwin waddstr wclear wclrtobot wclrtoeol waddch wdelch wdeleteln werase wgetch wgetstr winsch winsertln wmove wprintw wrefresh wscanw wstandend wstandout\"\n-required_fcntl_h=\"creat fcntl open\"\n-# required_float_h=...\n-required_grp_h=\"getgrgid getgrnam\"\n-# Maybe also \"getgrent fgetgrent setgrent endgrent\" */\n-# required_limit_h= /* Lots of macros */\n-required_locale_h=\"localeconv setlocale\"\n-required_math_h=\"acos asin atan atan2 ceil cos cosh exp fabs floor fmod frexp ldexp log10 log modf pow sin sinh sqrt tan tanh\"\n-extra_check_math_h=\"HUGE_VAL\"\n-\n-required_pwd_h=\"getpwnam getpwuid\"\n-required_setjmp_h=\"longjmp setjmp siglongjmp sigsetjmp\"\n-required_signal_h=\"kill raise sigaction sigaddset sigdelset sigemptyset sigfillset sigismember signal sigpending sigprocmask sigsuspend\"\n-# *stdarg_h *stddef.h  - supplied by gcc\n-required_stdio_h=\"clearerr fclose feof ferror fflush fgetc fgetpos fgets fopen fprintf fputc fputs fread freopen fscanf fseek fsetpos ftell fwrite getc getchar gets perror printf putc putchar puts remove rename rewind scanf setbuf setvbuf sprintf sscanf tmpfile tmpnam ungetc vfprintf vprintf vsprintf\"\n-# Should perhaps also handle NULL, EOF, ... ?\n-required_stdlib_h=\"abort abs atexit atof atoi atol bsearch calloc exit free getenv labs malloc qsort rand realloc srand strtod strtol strtoul system\"\n-# \"div ldiv\", - ignored because these depend on div_t, ldiv_t\n-# ignore these: \"mblen mbstowcs mbstowc wcstombs wctomb\"\n-# Should perhaps also add NULL\n-required_string_h=\"memchr memcmp memcpy memmove memset strcat strchr strcmp strcoll strcpy strcspn strerror strlen strncat strncmp\"\n-# Should perhaps also add NULL and size_t\n-required_sys_stat_h=\"chmod fstat mkdir mkfifo stat umask\"\n-extra_check_sys_stat_h=\"S_ISDIR S_ISBLK S_ISCHR S_ISFIFO S_ISREG S_ISLNK S_IFDIR S_IFBLK S_IFCHR S_IFIFO S_IFREG S_IFLNK\"\n-required_sys_times_h=\"times\"\n-# \"sys_types.h\" add types (not in old g++-include)\n-required_sys_resource_h=\"getrusage getrlimit setrlimit getpriority setpriority\"\n-required_sys_utsname_h=\"uname\"\n-required_sys_wait_h=\"wait waitpid\"\n-extra_check_sys_wait_h=\"WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG WNOHANG WNOTRACED\"\n-# required_tar.h= \n-required_termios_h=\"cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain tcflow tcflush tcgetattr tcsendbreak tcsetattr\"\n-required_time_h=\"asctime clock ctime difftime gmtime localtime mktime strftime time tzset\"\n-required_unistd_h=\"_exit access alarm chdir chown close ctermid cuserid dup dup2 execl execle execlp execv execve execvp fork fpathconf getcwd getegid geteuid getgid getgroups getlogin getpgrp getpid getppid getuid isatty link lseek pathconf pause pipe read rmdir setgid setpgid setsid setuid sleep sysconf tcgetpgrp tcsetpgrp ttyname unlink write\"\n-\n include_path=\"\"\n \n if [ `echo $* | wc -w` != 0 ] ; then\n@@ -128,8 +100,14 @@ if [ `echo $* | wc -w` != 0 ] ; then\n   done\n fi\n \n+required_stdlib_h=\"abort abs atexit atof atoi atol bsearch calloc exit free getenv labs malloc qsort rand realloc srand strtod strtol strtoul system\"\n+# \"div ldiv\", - ignored because these depend on div_t, ldiv_t\n+# ignore these: \"mblen mbstowcs mbstowc wcstombs wctomb\"\n+# Should perhaps also add NULL\n+required_unistd_h=\"_exit access alarm chdir chown close ctermid cuserid dup dup2 execl execle execlp execv execve execvp fork fpathconf getcwd getegid geteuid getgid getgroups getlogin getpgrp getpid getppid getuid isatty link lseek pathconf pause pipe read rmdir setgid setpgid setsid setuid sleep sysconf tcgetpgrp tcsetpgrp ttyname unlink write\"\n+\n done_dirs=\"\"\n-done_files=\"\"\n+echo \"\" >fixproto.list\n \n if [ `echo $* | wc -w` != 0 ] ; then\n   for rel_source_dir in $* ; do\n@@ -142,63 +120,145 @@ if [ `echo $* | wc -w` != 0 ] ; then\n       echo $progname\\: warning\\: no such directory\\: \\`$rel_source_dir\\'\n       continue\n     fi\n-    rel_source_subdirs=`cd $abs_source_dir; find . -type d -print | sed -e 's%^\\./%%' -e 's/\\.//'`\n-    if [ `echo $rel_source_subdirs | wc -w` != 0 ] ; then\n-      for rel_source_subdir in $rel_source_subdirs; do\n-        abs_target_subdir=$abs_target_dir/$rel_source_subdir\n-        if [ \\! -d $abs_target_subdir ] ; then\n-          mkdir $abs_target_subdir\n-        fi\n+\n+    dirs=\".\"\n+    levels=2\n+    subdirs=\".\"\n+    while $LINKS && test -n \"$dirs\" -a $levels -gt 0\n+    do\n+      levels=`expr $levels - 1`\n+      newdirs=\n+      for d in $dirs ; do\n+\t# Find all directories under $d, relative to $d, excluding $d itself.\n+        subdirs=\"$subdirs \"`cd $abs_source_dir/$d; find . -type d -print | \\\n+\t\t       sed -e '/^\\.$/d' -e \"s|^\\./|${d}/|\" -e 's|^\\./||'`\n+\tlinks=\n+\tlinks=`cd $abs_source_dir; find $d/. -type l -print | \\\n+\t\t       sed -e \"s|$d/./|$d/|\" -e 's|^\\./||'`\n+\tfor link in $links --dummy-- ; do\n+\t  if test -d $abs_source_dir/$link/. ; then\n+\t    newdirs=\"$newdirs $link\"\n+\t  fi\n+\tdone\n       done\n-    fi\n+      dirs=\"$newdirs\"\n+      subdirs=\"$subdirs $newdirs\"\n+    done\n+\n+    for rel_source_subdir in $subdirs; do\n+      abs_target_subdir=${abs_target_dir}/${rel_source_subdir}\n+      if [ \\! -d $abs_target_subdir ] ; then\n+        mkdir $abs_target_subdir\n+      fi\n+      # Append \"/\"; remove initial \"./\". Hence \".\" -> \"\" and \"sys\" -> \"sys/\".\n+      rel_source_prefix=`echo $rel_source_subdir | sed -e 's|$|/|' -e 's|^./||'`\n \n-    rel_source_files=`cd $abs_source_dir; find . '!' -type d -name \\*.h -print | sed 's%^\\./%%'`\n+      # The 'sed' is in case the *.h matches nothing, which yields \"*.h\"\n+      # which would then get re-globbed in the current directory.  Sigh.\n+      rel_source_files=`cd ${abs_source_dir}/${rel_source_subdir}; echo *.h | sed -e 's|[*].h|NONE|'`\n \n-    if [ `echo $rel_source_files | wc -w` != 0 ] ; then\n-      for rel_source_file in $rel_source_files; do\n+      for filename in $rel_source_files ; do\n+\trel_source_file=${rel_source_prefix}${filename}\n \tabs_source_file=$abs_source_dir/$rel_source_file\n \tabs_target_file=$abs_target_dir/$rel_source_file\n \n+\tif test \"$filename\" = 'NONE' ; then\n+\t  echo \"(No *.h files in $abs_source_dir/$rel_source_subdir)\"\n \t# If target file exists, check if was written while processing one\n \t# of the earlier source directories;  if so ignore it.\n-\tif test -f $abs_target_file -a -n \"$done_dirs\" \\\n-\t  && echo \" $done_files \" |grep \" $rel_source_file \" >/dev/null\n-\tthen\n-\t  echo $abs_target_file exists, $abs_source_file is ignored\n+\telif test -f $abs_target_file -a -n \"$done_dirs\" \\\n+\t  && grep \"$rel_source_file\" fixproto.list >/dev/null\n+\tthen true\n+#\t  echo $abs_target_file exists, $abs_source_file is ignored\n \telse\n \t  # echo doing $rel_source_file from $abs_source_dir\n-\t  rel_source_ident=`echo $rel_source_file | tr ./--- ___`\n-\t  required_list=`eval echo '${required_'${rel_source_ident}'-}'`\n-\t  extra_check_list=`eval echo '${extra_check_'${rel_source_ident}'-}'`\n-\t  rm -f tmp.c tmp.i\n-\t  echo \"#include <${rel_source_file}>\" >tmp.c\n+\t  required_list=\n+\t  extra_check_list=\n+\t  case $rel_source_file in\n+\t    ctype.h)\n+\t      required_list=\"isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper\" ;;\n+\t    dirent.h)\n+\t      required_list=\"closedir opendir readdir rewinddir\" ;;\n+\t    errno.h)\n+\t      extra_check_list=\"errno\" ;;\n+\t    curses.h)\n+\t      required_list=\"box delwin endwin getcurx getcury initscr mvcur mvwprintw mvwscanw newwin overlay overwrite scroll subwin touchwin waddstr wclear wclrtobot wclrtoeol waddch wdelch wdeleteln werase wgetch wgetstr winsch winsertln wmove wprintw wrefresh wscanw wstandend wstandout\" ;;\n+\t    fcntl.h)\n+\t      required_list=\"creat fcntl open\" ;;\n+\t    grp.h)\n+\t      #Maybe also \"getgrent fgetgrent setgrent endgrent\" */\n+\t      required_list=\"getgrgid getgrnam\" ;;\n+\t    limit.h)\n+\t      required_list= /* Lots of macros */ ;;\n+\t    locale.h)\n+\t      required_list=\"localeconv setlocale\" ;;\n+\t    math.h)\n+\t      required_list=\"acos asin atan atan2 ceil cos cosh exp fabs floor fmod frexp ldexp log10 log modf pow sin sinh sqrt tan tanh\"\n+\t      extra_check_list=\"HUGE_VAL\" ;;\n+\t    pwd.h)\n+\t      required_list=\"getpwnam getpwuid\" ;;\n+\t    setjmp.h)\n+\t      required_list=\"longjmp setjmp siglongjmp sigsetjmp\" ;;\n+\t    signal.h)\n+\t      required_list=\"kill raise sigaction sigaddset sigdelset sigemptyset sigfillset sigismember sigpending sigprocmask sigsuspend\" ;;\n+\t      # Left out signal() - its prototype is too complex for us!\n+\t    stdio.h)\n+\t      required_list=\"clearerr fclose feof ferror fflush fgetc fgetpos fgets fopen fprintf fputc fputs fread freopen fscanf fseek fsetpos ftell fwrite getc getchar gets perror printf putc putchar puts remove rename rewind scanf setbuf setvbuf sprintf sscanf tmpfile tmpnam ungetc vfprintf vprintf vsprintf\"\n+\t      if grep _flsbuf <$abs_source_file >/dev/null ; then\n+\t\trequired_list=\"$required_list _flsbuf _filbuf\"\n+\t      fi\n+\t      # Should perhaps also handle NULL, EOF, ... ?\n+\t      ;;\n+\t    stdlib.h)\n+\t      required_list=\"$required_stdlib_h\" ;;\n+\t    string.h)\n+\t      required_list=\"memchr memcmp memcpy memmove memset strcat strchr strcmp strcoll strcpy strcspn strerror strlen strncat strncmp\" ;;\n+# Should perhaps also add NULL and size_t\n+\t    sys/stat.h)\n+\t      required_list=\"chmod fstat mkdir mkfifo stat umask\"\n+\t      extra_check_list=\"S_ISDIR S_ISBLK S_ISCHR S_ISFIFO S_ISREG S_ISLNK S_IFDIR S_IFBLK S_IFCHR S_IFIFO S_IFREG S_IFLNK\" ;;\n+\t    sys/times.h)\n+\t      required_list=\"times\" ;;\n+# \"sys/types.h\" add types (not in old g++-include)\n+\t    sys/resource.h)\n+\t      required_list=\"getrusage getrlimit setrlimit getpriority setpriority\" ;;\n+\t    sys/utsname.h)\n+\t      required_list=\"uname\" ;;\n+\t    sys/wait.h)\n+\t      required_list=\"wait waitpid\"\n+\t      extra_check_list=\"WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG WNOHANG WNOTRACED\" ;;\n+\t    tar.h)\n+\t      required_list=  ;;\n+\t    termios.h)\n+\t      required_list=\"cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain tcflow tcflush tcgetattr tcsendbreak tcsetattr\" ;;\n+\t    time.h)\n+\t      required_list=\"asctime clock ctime difftime gmtime localtime mktime strftime time tzset\" ;;\n+\t    unistd.h)\n+\t      required_list=\"$required_unistd_h\" ;;\n+\t  esac\n+\t  rm -f fixtmp.c fixtmp.i\n+\t  echo \"#include <${rel_source_file}>\" >fixtmp.c\n \t  for macro in ${required_list} ${extra_check_list}\n \t  do\n-\t    echo \"#ifdef ${macro}\" >>tmp.c\n-\t    echo \"__DEFINED_MACRO_${macro};\" >>tmp.c\n-\t    echo \"#endif\" >>tmp.c\n+\t    echo \"#ifdef ${macro}\" >>fixtmp.c\n+\t    echo \"__DEFINED_MACRO_${macro};\" >>fixtmp.c\n+\t    echo \"#endif\" >>fixtmp.c\n \t  done\n-\t  if ${CPP} -D__STDC__ -D__cplusplus -D_POSIX_SOURCE $include_path tmp.c >tmp.i\n+\t  if ${CPP} -D__STDC__ -D__cplusplus -D_POSIX_SOURCE $include_path fixtmp.c >fixtmp.i 2>/dev/null\n \t  then\n-\t    case $rel_source_file in\n-\t      stdio.h)\n-\t\tif grep _flsbuf <$abs_source_file >/dev/null ; then\n-\t\t  required_list=\"$required_list _flsbuf _filbuf\"\n-\t\tfi ;;\n-\t    esac\n-\t    cat $abs_source_file >tmp.c\n-#\t    echo Doing: \"$original_dir/scan-decls <tmp.i | $original_dir/patch-header $rel_source_file tmp.c $abs_target_file \\\"$required_list\\\"\"\n-\n-\t    $original_dir/scan-decls <tmp.i | \\\n-\t     $original_dir/patch-header $rel_source_file tmp.c $abs_target_file \"$required_list\"\n+\t    cat $abs_source_file >fixtmp.c\n+#\t    echo Doing: \"$original_dir/scan-decls <fixtmp.i | $original_dir/patch-header $rel_source_file fixtmp.c $abs_target_file \\\"$required_list\\\"\"\n+\n+\t    $original_dir/scan-decls <fixtmp.i | \\\n+\t     $original_dir/patch-header $rel_source_file fixtmp.c $abs_target_file \"$required_list\"\n \t  else\n-\t    echo \"${progname}: ${CPP} couldn't grok ${abs_source_file}\"\n+\t    echo \"${progname}: cpp could not parse ${abs_source_file} (ignored)\"\n \t  fi\n-\t  done_files=\"${done_files} ${rel_source_file}\"\n+\t  echo \"${rel_source_file}\" >>fixproto.list\n \tfi\n       done\n-      rm -f tmp.c tmp.i\n-    fi\n+      rm -f fixtmp.c fixtmp.i\n+    done\n     # check for broken assert.h that needs stdio.h\n     if test -f $abs_source_dir/assert.h -a \\! -f $abs_target_dir/assert.h \\\n       && grep 'stderr' $abs_source_dir/assert.h >/dev/null\n@@ -215,13 +275,15 @@ if [ `echo $* | wc -w` != 0 ] ; then\n   done\n fi\n \n+# This might be more cleanly moved into the main loop, by adding\n+# a <dummy> source directory at the end.  FIXME!\n for rel_source_file in unistd.h stdlib.h\n do\n-  if echo \" $done_files \" | grep \" $rel_source_file \" >/dev/null\n+  if grep \"$rel_source_file\" fixproto.list >/dev/null\n   then true\n   else\n     echo Adding missing $rel_source_file\n-    rel_source_ident=`echo $rel_source_file | tr ./--- ___`\n+    rel_source_ident=`echo $rel_source_file | tr ./ __`\n     required_list=`eval echo '${required_'${rel_source_ident}'-}'`\n     cat >tmp.h <<EOF\n #ifndef ${rel_source_ident}"}, {"sha": "7c6242243f7ee024a289c683e7ae3566ce8fccde", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=e9cd0b2518fd8b3e265fa39a806f0ecc2e2ab113", "patch": "@@ -21,8 +21,8 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    \tNAME;C;RTYPE;ARGS;FILENAME;LINENO;\n \n    NAME is the function's name.\n-   C is \"F\" if the declaration is nested inside 'extern \"C\"' braces;\n-   otherwise \"f\".\n+   C is \"I\" if the function is declared as inline;  \"F\" if the\n+   declaration is nested inside 'extern \"C\"' braces;  otherwise \"f\".\n    RTYPE is the function's return type.\n    ARGS is the function's argument list.\n    FILENAME and LINENO is where the declarations was seen\n@@ -58,18 +58,36 @@ char extern_C_braces[20];\n    prefixed by extern \"C\". */\n int current_extern_C = 0;\n \n+static void\n+skip_to_closing_brace (fp)\n+     FILE *fp;\n+{\n+  int nesting = 1;\n+  for (;;)\n+    {\n+      int c = get_token (fp, &buf);\n+      if (c == EOF)\n+\tbreak;\n+      if (c == '{')\n+\tnesting++;\n+      if (c == '}' && --nesting == 0)\n+\tbreak;\n+    }\n+}\n+\n int\n main ()\n {\n   FILE *fp = stdin;\n   int c;\n-  int saw_extern;\n+  int saw_extern, saw_inline;\n \n  new_statement:\n   c = get_token (fp, &buf);\n  handle_statement:\n   current_extern_C = 0;\n   saw_extern = 0;\n+  saw_inline = 0;\n   if (c == '}')\n     {\n       /* pop an 'extern \"C\"' nesting level, if appropriate */\n@@ -97,6 +115,11 @@ main ()\n       fprintf (stdout, \"%s;M;\\n\", buf.base+16);\n       goto new_statement;\n     }\n+  if (strcmp (buf.base, \"inline\") == 0)\n+    {\n+      saw_inline = 1;\n+      c = get_token (fp, &buf);\n+    }\n   if (strcmp (buf.base, \"extern\") == 0)\n     {\n       saw_extern = 1;\n@@ -117,19 +140,21 @@ main ()\n   for (;;)\n     {\n       int followingc = getc (fp); /* char following token in buf */\n+\n+      MAKE_SSTRING_SPACE(&rtype, 1);\n+      *rtype.ptr = 0;\n+\n       if (c == IDENTIFIER_TOKEN)\n \t{\n \t  int nextc = skip_spaces (fp, followingc);\n \t  if (nextc == '(')\n \t    {\n \t      int nesting = 1;\n \n-\t      MAKE_SSTRING_SPACE(&rtype, 1);\n-\t      *rtype.ptr = 0;\n-\n  \t      fprintf (stdout, \"%s;%s;%s;\",\n \t\t       buf.base,\n-\t\t       in_extern_C_brace || current_extern_C ? \"F\" : \"f\",\n+\t\t       saw_inline ? \"I\"\n+\t\t       : in_extern_C_brace || current_extern_C ? \"F\" : \"f\",\n \t\t       rtype.base);\n \t      c = skip_spaces (fp, ' ');\n \t      for (;;)\n@@ -148,7 +173,14 @@ main ()\n \t\t}\n \t      fprintf (stdout, \";%s;%d;\\n\",\n \t\t       source_filename.base, source_lineno);\n-\t      goto new_statement;\n+\t      c = get_token (fp, &buf);\n+\t      if (c == '{')\n+\t\t{\n+\t\t  /* skip body of (normally) inline function */\n+\t\t  skip_to_closing_brace (fp);\n+\t\t  goto new_statement;\n+\t\t}\n+\t      goto handle_statement;\n \t    }\n \t  else if (nextc == ';' && saw_extern)\n \t    {"}]}