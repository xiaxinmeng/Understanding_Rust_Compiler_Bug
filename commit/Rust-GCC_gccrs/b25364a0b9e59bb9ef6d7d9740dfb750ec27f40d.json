{"sha": "b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1MzY0YTBiOWU1OWJiOWVmNmQ3ZDk3NDBkZmI3NTBlYzI3ZjQwZA==", "commit": {"author": {"name": "Sumanth G", "email": "sumanth.gundapaneni@kpitcummins.com", "date": "2012-02-02T10:20:32Z"}, "committer": {"name": "Jayant Sonar", "email": "jayants@gcc.gnu.org", "date": "2012-02-02T10:20:32Z"}, "message": "Adding GCC port for National Semicondutor's CR16 architecture\n\nCo-Authored-By: Jayant R Sonar <jayant.sonar@kpitcummins.com>\n\nFrom-SVN: r183832", "tree": {"sha": "6c6a242bece77442e5ca1c66403d5cee85d5584f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c6a242bece77442e5ca1c66403d5cee85d5584f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/comments", "author": null, "committer": null, "parents": [{"sha": "903e49f52065e9547a6e534d1bedbc980f77a5b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903e49f52065e9547a6e534d1bedbc980f77a5b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/903e49f52065e9547a6e534d1bedbc980f77a5b1"}], "stats": {"total": 7179, "additions": 7171, "deletions": 8}, "files": [{"sha": "b51667713397e60822f117e258bfe122b24feab0", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -1,3 +1,9 @@\n+2012-02-02  Sumanth G <sumanth.gundapaneni@kpitcummins.com>\n+\t    Jayant R Sonar <jayant.sonar@kpitcummins.com>\n+\n+\t* configure.ac (cr16-*-*): Remove nonconfigdirs.\n+\t* configure: Regenerate.\n+\n 2012-01-23  Harshit Chopra  <harshit@google.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "9136c24fbe93a580112f002300ee46aaa9093b49", "filename": "configure", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -3453,9 +3453,6 @@ case \"${target}\" in\n   tic54x-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss gdb\"\n     ;;\n-  cr16-*-*)\n-    noconfigdirs=\"$noconfigdirs gdb\"\n-    ;;\n   d10v-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;"}, {"sha": "92e6db39851ba404b7e6c5b0af8fe5b91f4b19ca", "filename": "configure.ac", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -879,9 +879,6 @@ case \"${target}\" in\n   tic54x-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss gdb\"\n     ;;\n-  cr16-*-*)\n-    noconfigdirs=\"$noconfigdirs gdb\"\n-    ;;\n   d10v-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;"}, {"sha": "a639b07405c5fd199affb0b3d3945bf9d3ac0060", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -1,3 +1,8 @@\n+2012-02-02  Sumanth G <sumanth.gundapaneni@kpitcummins.com>\n+\t    Jayant R Sonar <jayant.sonar@kpitcummins.com>\n+\n+\t* config-list.mk (LIST): Add cr16-elf.\n+\n 2012-01-02  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/51345"}, {"sha": "e0e8554351f40868e5613d1a263f18ef820de2fc", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -18,7 +18,7 @@ LIST = alpha-linux-gnu alpha-freebsd6 alpha-netbsd alpha-openbsd \\\n   arm-linux-androideabi arm-uclinux_eabi arm-ecos-elf arm-eabi \\\n   arm-symbianelf arm-rtems arm-elf arm-wince-pe avr-rtems avr-elf \\\n   bfin-elf bfin-uclinux bfin-linux-uclibc bfin-rtems bfin-openbsd \\\n-  c6x-elf c6x-uclinux cris-elf cris-linux crisv32-elf crisv32-linux \\\n+  c6x-elf c6x-uclinux cr16-elf cris-elf cris-linux crisv32-elf crisv32-linux \\\n   epiphany-elf epiphany-elfOPT-with-stack-offset=16 fido-elf \\\n   fr30-elf frv-elf frv-linux h8300-elf h8300-rtems hppa-linux-gnu \\\n   hppa-linux-gnuOPT-enable-sjlj-exceptions=yes hppa64-linux-gnu \\"}, {"sha": "c85aa65252710840848212d816027a6f99b3a139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -1,3 +1,23 @@\n+2012-02-02  Sumanth G <sumanth.gundapaneni@kpitcummins.com>\n+\t    Jayant R Sonar <jayant.sonar@kpitcummins.com>\n+\n+\t* config.gcc: Add cr16-* support.\n+\n+\t* doc/extend.texi: Document cr16 extensions.\n+\t* doc/install.texi: Document cr16 install.\n+\t* doc/invoke.texi: Document cr16 options.\n+\t* doc/md.texi: Document cr16 constraints.\n+\n+\t* common/config/cr16/cr16-common.c: New file.\n+\t* config/cr16/cr16.c: New file.\n+\t* config/cr16/cr16.h: New file.\n+\t* config/cr16/cr16.md: New file.\n+\t* config/cr16/cr16.opt: New file.\n+\t* config/cr16/cr16-protos.h: New file.\n+\t* config/cr16/predicates.md: New file.\n+\t* config/cr16/constraints.md: New file.\n+\t* config/cr16/t-cr16: New file.\n+\n 2012-02-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/52086"}, {"sha": "3baacec758e7007c0e769eda615a61df4c196fc8", "filename": "gcc/common/config/cr16/cr16-common.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.c?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,37 @@\n+/* Common hooks for CR16.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+\n+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n+static const struct default_options cr16_option_optimization_table[] =\n+  {\n+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE cr16_option_optimization_table\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "65a423a0f965074a7b8ddbf3f2239d91c1d25674", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -944,6 +944,11 @@ bfin*-*)\n \tuse_collect2=no\n \tuse_gcc_stdint=wrap\n \t;;\n+cr16-*-elf)\n+        tm_file=\"elfos.h ${tm_file}\"\n+        tmake_file=\"${tmake_file} cr16/t-cr16 \"\n+        use_collect2=no\n+        ;;\n crisv32-*-elf | crisv32-*-none)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \ttmake_file=\"cris/t-cris\""}, {"sha": "0e6e1120ff5da7a418b5b2ffe142906b84cedbe4", "filename": "gcc/config/cr16/constraints.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fconstraints.md?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,81 @@\n+;; Predicates of machine description for CR16.\n+;; Copyright (C) 2012 Free Software Foundation, Inc.\n+;; Contributed by KPIT Cummins Infosystems Limited.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  \n+\n+;; Constraints\n+;; Register constraints\n+(define_register_constraint \"b\" \"NOSP_REGS\"\n+  \"@no sp registers\")\n+\n+(define_register_constraint \"c\" \"SHORT_REGS\"\n+  \"@short registers\")\n+\n+(define_register_constraint \"d\" \"LONG_REGS\"\n+  \"@long registers\")\n+\n+;; Integer constraints.\n+(define_constraint \"I\"\n+  \"A signed 4-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIGNED_INT_FITS_N_BITS (ival, 4)\")))\n+\n+(define_constraint \"J\"\n+  \"A signed 5-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIGNED_INT_FITS_N_BITS (ival, 5)\")))\n+\n+(define_constraint \"K\"\n+  \"A signed 6-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIGNED_INT_FITS_N_BITS (ival, 6)\")))\n+\n+(define_constraint \"L\"\n+  \"A unsigned 4-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UNSIGNED_INT_FITS_N_BITS (ival, 4)\")))\n+\n+(define_constraint \"M\"\n+  \"A unsigned and customized  4-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(IN_RANGE_P (ival, 0, 15) && ((ival != 9) && (ival != 11)))\")))\n+\n+(define_constraint \"N\"\n+  \"A signed 16-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE_P (ival, -32768, 32767)\")))\n+\n+(define_constraint \"O\"\n+  \"A unsigned 20-bit immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE_P (ival, 0, 1048575)\")))\n+\n+(define_constraint \"Q\"\n+  \"A shift QI immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE_P (ival, 0, 7)\")))\n+\n+(define_constraint \"R\"\n+  \"A shift HI immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE_P (ival, 0, 15)\")))\n+\n+(define_constraint \"S\"\n+  \"A shift SI immediate.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE_P (ival, 0, 31)\")))"}, {"sha": "882fc614633008924cb935ac6b33715228bb3c02", "filename": "gcc/config/cr16/cr16-protos.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,101 @@\n+/* Prototypes for exported functions defined in cr16.c\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by KPIT Cummins Infosystems Limited.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CR16_PROTOS_H\n+#define GCC_CR16_PROTOS_H\n+\n+#include \"target.h\"\n+\n+/* Register usage.  */\n+extern enum reg_class cr16_regno_reg_class (int);\n+extern int cr16_hard_regno_mode_ok (int regno, enum machine_mode);\n+\n+/* Passing function arguments.  */\n+extern int cr16_function_arg_regno_p (int);\n+\n+#ifdef TREE_CODE\n+#ifdef RTX_CODE\n+\n+extern void cr16_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+\n+#endif /* RTX_CODE.  */\n+#endif /* TREE_CODE.  */\n+\n+/* Enumeration giving the various data models we support.  */\n+enum data_model_type\n+{\n+  DM_DEFAULT,\t\t/* Default data model (in CR16C/C+ - up to 16M).  */\n+  DM_NEAR,\t\t/* Near data model    (in CR16C/C+ - up to 1M).  */\n+  DM_FAR,\t\t/* Far data model     (in CR16C+   - up to 4G)\n+\t\t\t   (in CR16C    - up to 16M).  */\n+  ILLEGAL_DM\t\t/* Illegal data model.  */\n+};\n+\n+#ifdef RTX_CODE\n+\n+/* Addressing Modes.  */\n+struct cr16_address\n+{\n+  rtx base;\t \t/* Base register: Any register or register pair.  */\n+  rtx index;\t\t/* Index register: If one is present.  */\n+  rtx disp;\t\t/* Displacement or Absolute address.  */\n+  enum data_model_type data;\t/* data ref type.  */\n+  int code;\t\t/* Whether the address is code address. \n+\t\t\t   0 - data, 1 - code label, 2 - function label.  */\n+};\n+\n+enum cr16_addrtype\n+{\n+  CR16_INVALID,\n+  CR16_REG_REL,\n+  CR16_REGP_REL,\n+  CR16_INDEX_REGP_REL,\n+  CR16_ABSOLUTE\n+};\n+\n+extern void notice_update_cc PARAMS ((rtx));\n+extern int cr16_operand_bit_pos (int val, int bitval);\n+extern void cr16_decompose_const (rtx x, int *code,\n+\t\t\t\t  enum data_model_type *data,\n+\t\t\t\t  bool treat_as_const);\n+extern enum cr16_addrtype cr16_decompose_address (rtx addr,\n+\t\t\t\t\t\t  struct cr16_address *out,\n+\t\t\t\t\t\t  bool debug_print,\n+\t\t\t\t\t\t  bool treat_as_const);\n+extern int cr16_const_double_ok (rtx op);\n+extern int legitimate_pic_operand_p (rtx);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+\n+#endif /* RTX_CODE.  */\n+\n+\n+/* Prologue/Epilogue functions.  */\n+extern int cr16_initial_elimination_offset (int, int);\n+extern char *cr16_prepare_push_pop_string (int);\n+extern void cr16_expand_prologue (void);\n+extern void cr16_expand_epilogue (void);\n+extern const char *cr16_emit_add_sub_di (rtx *, enum rtx_code);\n+extern const char *cr16_emit_logical_di (rtx *, enum rtx_code);\n+\n+/* Handling the \"interrupt\" attribute.  */\n+extern int cr16_interrupt_function_p (void);\n+extern bool cr16_is_data_model (enum data_model_type);\n+\n+#endif /* Not GCC_CR16_PROTOS_H.  */ "}, {"sha": "65968f8cda77827feef758acd5af075a2b3ef614", "filename": "gcc/config/cr16/cr16.c", "status": "added", "additions": 2190, "deletions": 0, "changes": 2190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,2190 @@\n+/* Output routines for CR16 processor.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by KPIT Cummins Infosystems Limited.\n+  \n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+ \n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"diagnostic-core.h\"\n+#include \"basic-block.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"df.h\"\n+\n+/* Definitions.  */\n+\n+/* Maximum number of register used for passing parameters.  */\n+#define MAX_REG_FOR_PASSING_ARGS  6\n+\n+/* Minimum number register used for passing parameters.  */\n+#define MIN_REG_FOR_PASSING_ARGS  2\n+\n+/* The maximum count of words supported in the assembly of the architecture in\n+   a push/pop instruction.  */\n+#define MAX_COUNT  8\n+\n+/* Predicate is true if the current function is a 'noreturn' function, \n+   i.e. it is qualified as volatile.  */\n+#define FUNC_IS_NORETURN_P(decl) (TREE_THIS_VOLATILE (decl))\n+\n+/* Predicate that holds when we need to save registers even for 'noreturn'\n+   functions, to accomodate for unwinding.  */\n+#define MUST_SAVE_REGS_P() \\\n+  (flag_unwind_tables || (flag_exceptions && !UI_SJLJ))\n+\n+/* Nonzero if the rtx X is a signed const int of n bits.  */\n+#define RTX_SIGNED_INT_FITS_N_BITS(X, n)                \\\n+  ((GET_CODE (X) == CONST_INT                          \\\n+   && SIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n+\n+/* Nonzero if the rtx X is an unsigned const int of n bits.  */\n+#define RTX_UNSIGNED_INT_FITS_N_BITS(X, n)               \\\n+  ((GET_CODE (X) == CONST_INT                            \\\n+   && UNSIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n+\n+/* Structure for stack computations.  */\n+\n+/* variable definitions in the struture\n+   args_size             Number of bytes saved on the stack for local \n+\t\t\t variables\n+\n+   reg_size\t\t Number of bytes saved on the stack for \n+\t\t\t non-scratch registers\n+\n+   total_size \t\t The sum of 2 sizes: locals vars and padding byte \n+\t\t\t for saving the registers. Used in expand_prologue() \n+\t\t\t and expand_epilogue()\n+\n+   last_reg_to_save      Will hold the number of the last register the \n+\t\t\t prologue saves, -1 if no register is saved\n+\n+   save_regs[16]\t Each object in the array is a register number. \n+\t\t\t Mark 1 for registers that need to be saved\n+\n+   num_regs\t\t Number of registers saved\n+\n+   initialized\t\t Non-zero if frame size already calculated, not \n+\t\t\t used yet\n+\n+   function_makes_calls  Does the function make calls ? not used yet.  */\n+\n+struct cr16_frame_info\n+{\n+  unsigned long var_size;\n+  unsigned long args_size;\n+  unsigned int  reg_size;\n+  unsigned long total_size;\n+  long          last_reg_to_save;\n+  long          save_regs[FIRST_PSEUDO_REGISTER];\n+  int           num_regs;\n+  int           initialized;\n+  int           function_makes_calls;\n+};\n+\n+/* Current frame information calculated by cr16_compute_frame_size.  */\n+static struct cr16_frame_info current_frame_info;\n+\n+/* Static Variables.  */\n+\n+/* Data model that was supplied by user via command line option\n+   This will be overridden in case of invalid combination\n+   of core and data model options are supplied.  */\n+static enum data_model_type data_model = DM_DEFAULT;\n+\n+/* TARGETM Function Prototypes and forward declarations  */\n+static void cr16_print_operand (FILE *, rtx, int);\n+static void cr16_print_operand_address (FILE *, rtx);\n+\n+/* Stack layout and calling conventions.  */\n+#undef  TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX\t\tcr16_struct_value_rtx\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY\t\tcr16_return_in_memory\n+\n+/* Target-specific uses of '__attribute__'.  */\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE \t\tcr16_attribute_table\n+#undef TARGET_NARROW_VOLATILE_BITFIELD\n+#define TARGET_NARROW_VOLATILE_BITFIELD hook_bool_void_false\n+\n+/* EH related.  */\n+#undef TARGET_UNWIND_WORD_MODE\n+#define TARGET_UNWIND_WORD_MODE\t\tcr16_unwind_word_mode\n+\n+/* Override Options.  */\n+#undef TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE  \tcr16_override_options \n+\n+/* Conditional register usuage.  */\n+#undef TARGET_CONDITIONAL_REGISTER_USAGE \n+#define TARGET_CONDITIONAL_REGISTER_USAGE cr16_conditional_register_usage\n+\n+/* Controlling register spills.  */\n+#undef TARGET_CLASS_LIKELY_SPILLED_P\n+#define TARGET_CLASS_LIKELY_SPILLED_P\tcr16_class_likely_spilled_p\n+\n+/* Passing function arguments.  */\n+#undef TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG \t\tcr16_function_arg\n+#undef TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE \tcr16_function_arg_advance\n+#undef TARGET_RETURN_POPS_ARGS\n+#define TARGET_RETURN_POPS_ARGS \tcr16_return_pops_args\n+\n+/* Initialize the GCC target structure.  */\n+#undef TARGET_FRAME_POINTER_REQUIRED\n+#define TARGET_FRAME_POINTER_REQUIRED\tcr16_frame_pointer_required\n+#undef TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE \t\tcr16_can_eliminate\n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS \tcr16_legitimize_address\n+#undef TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P    cr16_legitimate_constant_p\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P     cr16_legitimate_address_p\n+\n+/* Returning function value.  */\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE \t\tcr16_function_value\n+#undef TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE \t\tcr16_libcall_value\n+#undef TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P \tcr16_function_value_regno_p\n+\n+/* printing the values.  */\n+#undef TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND \t\tcr16_print_operand\n+#undef TARGET_PRINT_OPERAND_ADDRESS\n+#define TARGET_PRINT_OPERAND_ADDRESS \tcr16_print_operand_address\n+\n+/* Relative costs of operations.  */\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST \t\tcr16_address_cost\n+#undef TARGET_REGISTER_MOVE_COST\n+#define TARGET_REGISTER_MOVE_COST \tcr16_register_move_cost\n+#undef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST \tcr16_memory_move_cost\n+\n+/* Table of machine attributes.  */\n+static const struct attribute_spec cr16_attribute_table[] = {\n+  /* ISRs have special prologue and epilogue requirements.  */\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity }.  */\n+  {\"interrupt\", 0, 0, false, true, true, NULL, false},\n+  {NULL, 0, 0, false, false, false, NULL, false}\n+};\n+\n+/* TARGET_ASM_UNALIGNED_xx_OP generates .?byte directive\n+   .?byte directive along with @c is not understood by assembler.\n+   Therefore, make all TARGET_ASM_UNALIGNED_xx_OP same\n+   as TARGET_ASM_ALIGNED_xx_OP.  */\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \tTARGET_ASM_ALIGNED_HI_OP\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \tTARGET_ASM_ALIGNED_SI_OP\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \tTARGET_ASM_ALIGNED_DI_OP\n+\n+/* Target hook implementations.  */\n+\n+/* Implements hook TARGET_RETURN_IN_MEMORY.  */\n+static bool\n+cr16_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  const HOST_WIDE_INT size = int_size_in_bytes (type);\n+  return ((size == -1) || (size > 8));\n+}\n+\n+/* Implement TARGET_CLASS_LIKELY_SPILLED_P.  */\n+static bool\n+cr16_class_likely_spilled_p (reg_class_t rclass)\n+{\n+  if ((rclass) == SHORT_REGS || (rclass) == DOUBLE_BASE_REGS \n+      || (rclass) == LONG_REGS || (rclass) == GENERAL_REGS)\n+    return true;\n+\n+  return false;\n+}\n+\n+static int\n+cr16_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n+                       tree funtype ATTRIBUTE_UNUSED, \n+\t\t       int size ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+/* Returns true if data model selected via command line option\n+   is same as function argument.  */\n+bool\n+cr16_is_data_model (enum data_model_type model)\n+{\n+  return (model == data_model);\n+}\n+\n+/* Parse relevant options and override.  */\n+static void\n+cr16_override_options (void)\n+{\n+  /* Disable -fdelete-null-pointer-checks option for CR16 target.\n+     Programs which rely on NULL pointer dereferences _not_ halting the \n+     program may not work properly with this option. So disable this \n+     option.  */\n+  flag_delete_null_pointer_checks = 0;\n+\n+  /* FIXME: To avoid spill_failure ICE during exception handling,\n+   * disable cse_fllow_jumps. The spill error occurs when compiler\n+   * can't find a suitable candidate in GENERAL_REGS class to reload\n+   * a 32bit register.\n+   * Need to find a better way of avoiding this situation. */\n+  if (flag_exceptions)\n+    flag_cse_follow_jumps = 0;\n+\n+  /* If -fpic option, data_model == DM_FAR.  */\n+  if (flag_pic == NEAR_PIC)\n+    {\n+      data_model = DM_FAR;\n+    }\n+\n+  /* The only option we want to examine is data model option.  */\n+  if (cr16_data_model)\n+    {\n+      if (strcmp (cr16_data_model, \"medium\") == 0)\n+\tdata_model = DM_DEFAULT;\n+      else if (strcmp (cr16_data_model, \"near\") == 0)\n+\tdata_model = DM_NEAR;\n+      else if (strcmp (cr16_data_model, \"far\") == 0)\n+\t{\n+\t  if (TARGET_CR16CP)\n+\t    data_model = DM_FAR;\n+\t  else\n+\t    error (\"data-model=far not valid for cr16c architecture\");\n+\t}\n+      else\n+\terror (\"invalid data model option -mdata-model=%s\", cr16_data_model);\n+    }\n+  else\n+    data_model = DM_DEFAULT;\n+}\n+\n+/* Implements the macro  TARGET_CONDITIONAL_REGISTER_USAGE.  */\n+static void\n+cr16_conditional_register_usage (void)\n+{\n+  if (flag_pic)\n+    {\n+      fixed_regs[12] = call_used_regs[12] = 1;\n+    }\n+}\n+\n+/* Stack layout and calling conventions routines.  */\n+\n+/* Return nonzero if the current function being compiled is an interrupt\n+   function as specified by the \"interrupt\" attribute.  */\n+int\n+cr16_interrupt_function_p (void)\n+{\n+  tree attributes;\n+\n+  attributes = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  return (lookup_attribute (\"interrupt\", attributes) != NULL_TREE);\n+}\n+\n+/* Compute values for the array current_frame_info.save_regs and the variable \n+   current_frame_info.reg_size. The index of current_frame_info.save_regs \n+   is numbers of register, each will get 1 if we need to save it in the \n+   current function, 0 if not. current_frame_info.reg_size is the total sum \n+   of the registers being saved.  */\n+static void\n+cr16_compute_save_regs (void)\n+{\n+  unsigned int regno;\n+\n+  /* Initialize here so in case the function is no-return it will be -1.  */\n+  current_frame_info.last_reg_to_save = -1;\n+\n+  /* Initialize the number of bytes to be saved. */\n+  current_frame_info.reg_size = 0;\n+\n+  /* No need to save any registers if the function never returns.  */\n+  if (FUNC_IS_NORETURN_P (current_function_decl) && !MUST_SAVE_REGS_P ())\n+    return;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (fixed_regs[regno])\n+\t{\n+\t  current_frame_info.save_regs[regno] = 0;\n+\t  continue;\n+\t}\n+\n+      /* If this reg is used and not call-used (except RA), save it.  */\n+      if (cr16_interrupt_function_p ())\n+\t{\n+\t  if (!current_function_is_leaf && call_used_regs[regno])\n+\t    /* This is a volatile reg in a non-leaf interrupt routine - save \n+\t       it for the sake of its sons.  */\n+\t    current_frame_info.save_regs[regno] = 1;\n+\t  else if (df_regs_ever_live_p (regno))\n+\t    /* This reg is used - save it.  */\n+\t    current_frame_info.save_regs[regno] = 1;\n+\t  else\n+\t    /* This reg is not used, and is not a volatile - don't save.  */\n+\t    current_frame_info.save_regs[regno] = 0;\n+\t}\n+      else\n+\t{\n+\t  /* If this reg is used and not call-used (except RA), save it.  */\n+\t  if (df_regs_ever_live_p (regno)\n+\t      && (!call_used_regs[regno] || regno == RETURN_ADDRESS_REGNUM))\n+\t    current_frame_info.save_regs[regno] = 1;\n+\t  else\n+\t    current_frame_info.save_regs[regno] = 0;\n+\t}\n+    }\n+\n+  /* Save registers so the exception handler can modify them.  */\n+  if (crtl->calls_eh_return)\n+    {\n+      unsigned int i;\n+\n+      for (i = 0;; ++i)\n+\t{\n+\t  regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (INVALID_REGNUM == regno)\n+\t    break;\n+\t  current_frame_info.save_regs[regno] = 1;\n+\t}\n+    }\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (current_frame_info.save_regs[regno] == 1)\n+      {\n+\tcurrent_frame_info.last_reg_to_save = regno;\n+\tif (regno >= CR16_FIRST_DWORD_REGISTER)\n+\t  current_frame_info.reg_size += CR16_UNITS_PER_DWORD;\n+\telse\n+\t  current_frame_info.reg_size += UNITS_PER_WORD;\n+      }\n+}\n+\n+/* Compute the size of the local area and the size to be adjusted by the\n+   prologue and epilogue.  */\n+static void\n+cr16_compute_frame (void)\n+{\n+  /* For aligning the local variables.  */\n+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+  int padding_locals;\n+\n+  /* Padding needed for each element of the frame.  */\n+  current_frame_info.var_size = get_frame_size ();\n+\n+  /* Align to the stack alignment.  */\n+  padding_locals = current_frame_info.var_size % stack_alignment;\n+  if (padding_locals)\n+    padding_locals = stack_alignment - padding_locals;\n+\n+  current_frame_info.var_size += padding_locals;\n+  current_frame_info.total_size = current_frame_info.var_size \n+\t\t\t          + (ACCUMULATE_OUTGOING_ARGS\n+\t\t\t             ? crtl->outgoing_args_size : 0);\n+}\n+\n+/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.  */\n+int\n+cr16_initial_elimination_offset (int from, int to)\n+{\n+  /* Compute this since we need to use current_frame_info.reg_size.  */\n+  cr16_compute_save_regs ();\n+\n+  /* Compute this since we need to use current_frame_info.var_size.  */\n+  cr16_compute_frame ();\n+\n+  if (((from) == FRAME_POINTER_REGNUM) && ((to) == STACK_POINTER_REGNUM))\n+    return (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+  else if (((from) == ARG_POINTER_REGNUM) && ((to) == FRAME_POINTER_REGNUM))\n+    return (current_frame_info.reg_size + current_frame_info.var_size);\n+  else if (((from) == ARG_POINTER_REGNUM) && ((to) == STACK_POINTER_REGNUM))\n+    return (current_frame_info.reg_size + current_frame_info.var_size \n+\t    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0));\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Register Usage.  */\n+\n+/* Return the class number of the smallest class containing reg number REGNO.\n+   This could be a conditional expression or could index an array.  */\n+enum reg_class\n+cr16_regno_reg_class (int regno)\n+{\n+  if ((regno >= 0) && (regno < CR16_FIRST_DWORD_REGISTER))\n+    return SHORT_REGS;\n+\n+  if ((regno >= CR16_FIRST_DWORD_REGISTER) && (regno < FIRST_PSEUDO_REGISTER))\n+    return LONG_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+int\n+cr16_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  if ((GET_MODE_SIZE (mode) >= 4) && (regno == 11))\n+    return 0;\n+ \n+  if (mode == DImode || mode == DFmode)\n+    {\n+      if ((regno > 8) || (regno & 1))\n+\treturn 0;\n+      return 1;\n+    }\n+\n+  if ((TARGET_INT32)\n+       && ((regno >= 12) && (GET_MODE_SIZE (mode) < 4 )))\n+     return 0;\n+\n+  /* CC can only hold CCmode values.  */\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n+    return 0;\n+  return 1;\n+}\n+\n+/* Returns register number for function return value.*/\n+static inline unsigned int\n+cr16_ret_register (void)\n+{\n+  return 0;\n+}\n+\n+/* Implements hook TARGET_STRUCT_VALUE_RTX.  */\n+static rtx\n+cr16_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n+                       int incoming ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (Pmode, cr16_ret_register ());\n+}\n+\n+/* Returning function value.  */\n+\n+/* Worker function for TARGET_FUNCTION_VALUE_REGNO_P.  */\n+static bool\n+cr16_function_value_regno_p (const unsigned int regno)\n+{\n+  return (regno == cr16_ret_register ());\n+}\n+\n+/* Create an RTX representing the place where a\n+   library function returns a value of mode MODE.  */\n+static rtx\n+cr16_libcall_value (enum machine_mode mode,\n+\t\t    const_rtx func ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (mode, cr16_ret_register ());\n+}\n+\n+/* Create an RTX representing the place where a\n+   function returns a value of data type VALTYPE.  */\n+static rtx\n+cr16_function_value (const_tree type,\n+\t\t     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t     bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (TYPE_MODE (type), cr16_ret_register ());\n+}\n+\n+/* Passing function arguments.  */\n+\n+/* If enough param regs are available for passing the param of type TYPE return\n+   the number of registers needed else 0.  */\n+static int\n+enough_regs_for_param (CUMULATIVE_ARGS * cum, const_tree type,\n+\t\t       enum machine_mode mode)\n+{\n+  int type_size;\n+  int remaining_size;\n+\n+  if (mode != BLKmode)\n+    type_size = GET_MODE_BITSIZE (mode);\n+  else\n+    type_size = int_size_in_bytes (type) * BITS_PER_UNIT;\n+\n+  remaining_size = BITS_PER_WORD * (MAX_REG_FOR_PASSING_ARGS\n+\t\t\t\t    - (MIN_REG_FOR_PASSING_ARGS + cum->ints) +\n+\t\t\t\t    1);\n+\n+  /* Any variable which is too big to pass in two registers, will pass on\n+     stack.  */\n+  if ((remaining_size >= type_size) && (type_size <= 2 * BITS_PER_WORD))\n+    return (type_size + BITS_PER_WORD - 1) / BITS_PER_WORD;\n+\n+  return 0;\n+}\n+\n+/* Implements the macro FUNCTION_ARG defined in cr16.h.  */\n+static rtx\n+cr16_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  cum->last_parm_in_reg = 0;\n+\n+  /* function_arg () is called with this type just after all the args have \n+     had their registers assigned. The rtx that function_arg returns from \n+     this type is supposed to pass to 'gen_call' but currently it is not \n+     implemented (see macro GEN_CALL).  */\n+  if (type == void_type_node)\n+    return NULL_RTX;\n+\n+  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+    return NULL_RTX;\n+\n+  if (mode == BLKmode)\n+    {\n+      /* Enable structures that need padding bytes at the end to pass to a\n+         function in registers.  */\n+      if (enough_regs_for_param (cum, type, mode) != 0)\n+\t{\n+\t  cum->last_parm_in_reg = 1;\n+\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t}\n+    }\n+\n+  if ((MIN_REG_FOR_PASSING_ARGS + cum->ints) > MAX_REG_FOR_PASSING_ARGS)\n+    return NULL_RTX;\n+  else\n+    {\n+      if (enough_regs_for_param (cum, type, mode) != 0)\n+\t{\n+\t  cum->last_parm_in_reg = 1;\n+\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Implements the macro INIT_CUMULATIVE_ARGS defined in cr16.h.  */\n+void\n+cr16_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n+\t\t\t   rtx libfunc ATTRIBUTE_UNUSED)\n+{\n+  tree param, next_param;\n+\n+  cum->ints = 0;\n+\n+  /* Determine if this function has variable arguments.  This is indicated by\n+     the last argument being 'void_type_mode' if there are no variable\n+     arguments.  Change here for a different vararg.  */\n+  for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n+       param != NULL_TREE; param = next_param)\n+    {\n+      next_param = TREE_CHAIN (param);\n+      if ((next_param == NULL_TREE) && (TREE_VALUE (param) != void_type_node))\n+\t{\n+\t  cum->ints = -1;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* Implements the macro FUNCTION_ARG_ADVANCE defined in cr16.h.  */\n+static void\n+cr16_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS * cum = get_cumulative_args (cum_v);\n+\n+  /* l holds the number of registers required.  */\n+  int l = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+\n+  /* If the parameter isn't passed on a register don't advance cum.  */\n+  if (!cum->last_parm_in_reg)\n+    return;\n+\n+  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+    return;\n+\n+  if ((mode == SImode) || (mode == HImode)\n+      || (mode == QImode) || (mode == DImode))\n+    {\n+      if (l <= 1)\n+\tcum->ints += 1;\n+      else\n+\tcum->ints += l;\n+    }\n+  else if ((mode == SFmode) || (mode == DFmode))\n+    cum->ints += l;\n+  else if ((mode) == BLKmode)\n+    {\n+      if ((l = enough_regs_for_param (cum, type, mode)) != 0)\n+\tcum->ints += l;\n+    }\n+  return;\n+}\n+\n+/* Implements the macro FUNCTION_ARG_REGNO_P defined in cr16.h.\n+   Return nonzero if N is a register used for passing parameters.  */\n+int\n+cr16_function_arg_regno_p (int n)\n+{\n+  return ((n <= MAX_REG_FOR_PASSING_ARGS) && (n >= MIN_REG_FOR_PASSING_ARGS));\n+}\n+\n+/* Addressing modes. \n+   Following set of function implement the macro GO_IF_LEGITIMATE_ADDRESS\n+   defined in cr16.h.  */\n+\n+/* Helper function to check if is a valid base register that can\n+   hold address.  */\n+static int\n+cr16_addr_reg_p (rtx addr_reg)\n+{\n+  rtx reg;\n+\n+  if (REG_P (addr_reg))\n+    reg = addr_reg;\n+  else if ((GET_CODE (addr_reg) == SUBREG)\n+\t   && REG_P (SUBREG_REG (addr_reg))\n+\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (addr_reg)))\n+\t       <= UNITS_PER_WORD))\n+    reg = SUBREG_REG (addr_reg);\n+  else\n+    return FALSE;\n+\n+  if (GET_MODE (reg) != Pmode)\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n+/* Helper functions: Created specifically for decomposing operand of CONST\n+   Recursively look into expression x for code or data symbol.\n+   The function expects the expression to contain combination of \n+   SYMBOL_REF, CONST_INT, (PLUS or MINUS)\n+   LABEL_REF, CONST_INT, (PLUS or MINUS)\n+   SYMBOL_REF\n+   LABEL_REF\n+   All other combinations will result in code = -1 and data = ILLEGAL_DM\n+   code data\n+   -1   ILLEGAL_DM   The expression did not contain SYMBOL_REF or LABEL_REF\n+    0   DM_FAR       SYMBOL_REF was found and it was far data reference. \n+    0   DM_DEFAULT   SYMBOL_REF was found and it was medium data reference. \n+    1   ILLEGAL_DM   LABEL_REF was found. \n+    2   ILLEGAL_DM   SYMBOL_REF was found and it was function reference.  */\n+void\n+cr16_decompose_const (rtx x, int *code, enum data_model_type *data,\n+\t\t      bool treat_as_const)\n+{\n+  *code = -1;\n+  *data = ILLEGAL_DM;\n+  switch (GET_CODE (x))\n+    {\n+    case SYMBOL_REF:\n+      *code = SYMBOL_REF_FUNCTION_P (x) ? 2 : 0;\n+      /* 2 indicates func sym.  */\n+      if (*code == 0)\n+\t{\n+\t  if (CR16_TARGET_DATA_NEAR)\n+\t    *data = DM_DEFAULT;\n+\t  else if (CR16_TARGET_DATA_MEDIUM)\n+\t    *data = DM_FAR;\n+\t  else if (CR16_TARGET_DATA_FAR)\n+\t    {\n+\t      if (treat_as_const)\n+\t\t/* This will be used only for printing \n+\t\t   the qualifier. This call is (may be)\n+\t\t   made by cr16_print_operand_address.  */\n+\t\t*data = DM_FAR;\n+\t      else\n+\t\t/* This call is (may be) made by \n+\t\t   cr16_legitimate_address_p.  */\n+\t\t*data = ILLEGAL_DM;\n+\t    }\n+\t}\n+      return;\n+\n+    case LABEL_REF:\n+      /* 1 - indicates non-function symbol.  */\n+      *code = 1;\n+      return;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* Look into the tree nodes.  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\tcr16_decompose_const (XEXP (x, 1), code, data, treat_as_const);\n+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\tcr16_decompose_const (XEXP (x, 0), code, data, treat_as_const);\n+      return;\n+    default:\n+      return;\n+    }\n+}\n+\n+/* Decompose Address\n+   This function decomposes the address returns the type of address\n+   as defined in enum cr16_addrtype.  It also fills the parameter *out.\n+   The decomposed address can be used for two purposes.  One to \n+   check if the address is valid and second to print the address\n+   operand.\n+\n+   Following tables list valid address supported in CR16C/C+ architectures.\n+   Legend: \n+   aN : Absoulte address N-bit address\n+   R  : One 16-bit register\n+   RP : Consecutive two 16-bit registers or one 32-bit register\n+   I  : One 32-bit register\n+   dispN : Signed displacement of N-bits\n+\n+   ----Code addresses----\n+   Branch operands:\n+   disp9        : CR16_ABSOLUTE       (disp)\n+   disp17       : CR16_ABSOLUTE       (disp)\n+   disp25       : CR16_ABSOLUTE       (disp)\n+   RP + disp25  : CR16_REGP_REL       (base, disp)\n+\n+   Jump operands:\n+   RP           : CR16_REGP_REL       (base, disp=0)\n+   a24          : CR16_ABSOLUTE       (disp)\n+\n+   ----Data addresses----\n+   a20          : CR16_ABSOLUTE       (disp)                near (1M)\n+   a24          : CR16_ABSOLUTE       (disp)                medium  (16M)\n+   R  + d20     : CR16_REG_REL        (base,  disp)         near (1M+64K)\n+   RP + d4      : CR16_REGP_REL       (base,  disp)         far  (4G)\n+   RP + d16     : CR16_REGP_REL       (base,  disp)         far  (4G)\n+   RP + d20     : CR16_REGP_REL       (base,  disp)         far  (4G)\n+   I            : *** Valid but port does not support this\n+   I  + a20     : *** Valid but port does not support this\n+   I  + RP + d14: CR16_INDEX_REGP_REL (base,  index, disp)  far  (4G)\n+   I  + RP + d20: CR16_INDEX_REGP_REL (base,  index, disp)  far  (4G)\n+\n+   Decomposing Data model in case of absolute address.\n+\n+   Target Option             Address type Resultant Data ref type\n+   ----------------------    ------------ -----------------------\n+   CR16_TARGET_MODEL_NEAR    ABS20        DM_DEFAULT\n+   CR16_TARGET_MODEL_NEAR    IMM20        DM_DEFAULT\n+   CR16_TARGET_MODEL_NEAR    ABS24        Invalid\n+   CR16_TARGET_MODEL_NEAR    IMM32        Invalid\n+\n+   CR16_TARGET_MODEL_MEDIUM  ABS20        DM_DEFAULT\n+   CR16_TARGET_MODEL_MEDIUM  IMM20        DM_DEFAULT\n+   CR16_TARGET_MODEL_MEDIUM  ABS24        DM_FAR\n+   CR16_TARGET_MODEL_MEDIUM  IMM32        Invalid\n+\n+   CR16_TARGET_MODEL_FAR     ABS20        DM_DEFAULT\n+   CR16_TARGET_MODEL_FAR     IMM20        DM_DEFAULT\n+   CR16_TARGET_MODEL_FAR     ABS24        DM_FAR\n+   CR16_TARGET_MODEL_FAR     IMM32        DM_FAR.  */\n+enum cr16_addrtype\n+cr16_decompose_address (rtx addr, struct cr16_address *out,\n+\t\t\tbool debug_print, bool treat_as_const)\n+{\n+  rtx base = NULL_RTX, disp = NULL_RTX, index = NULL_RTX;\n+  enum data_model_type data = ILLEGAL_DM;\n+  int code = -1;\n+  enum cr16_addrtype retval = CR16_INVALID;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case CONST_INT:\n+      /* Absolute address (known at compile time).  */\n+      code = 0;\n+      if (debug_print)\n+\tfprintf (stderr, \"\\ncode:%d\", code);\n+      disp = addr;\n+\n+      if (debug_print)\n+\t{\n+\t  fprintf (stderr, \"\\ndisp:\");\n+\t  debug_rtx (disp);\n+\t}\n+\n+      if (UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), 20))\n+\t{\n+\t  data = DM_DEFAULT;\n+\t  if (debug_print)\n+\t    fprintf (stderr, \"\\ndata:%d\", data);\n+\t  retval = CR16_ABSOLUTE;\n+\t}\n+      else if (UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), 24))\n+\t{\n+\t  if (!CR16_TARGET_DATA_NEAR)\n+\t    {\n+\t      data = DM_FAR;\n+\t      if (debug_print)\n+\t\tfprintf (stderr, \"\\ndata:%d\", data);\n+\t      retval = CR16_ABSOLUTE;\n+\t    }\n+\t  else\n+\t    return CR16_INVALID;\t/* ABS24 is not support in NEAR model.  */\n+\t}\n+      else\n+\treturn CR16_INVALID;\n+      break;\n+\n+    case CONST:\n+      /* A CONST is an expression of PLUS or MINUS with \n+\t CONST_INT, SYMBOL_REF or LABEL_REF. This is the\n+\t result of assembly-time arithmetic computation.  */\n+      retval = CR16_ABSOLUTE;\n+      disp = addr;\n+      /* Call the helper function to check the validity.  */\n+      cr16_decompose_const (XEXP (addr, 0), &code, &data, treat_as_const);\n+      if ((code == 0) && (data == ILLEGAL_DM))\n+\t/* CONST is not valid code or data address.  */\n+\treturn CR16_INVALID;\n+      if (debug_print)\n+\t{\n+\t  fprintf (stderr, \"\\ndisp:\");\n+\t  debug_rtx (disp);\n+\t  fprintf (stderr, \"\\ncode:%d\", code);\n+\t  fprintf (stderr, \"\\ndata:%d\", data);\n+\t}\n+      break;\n+\n+    case LABEL_REF:\n+      retval = CR16_ABSOLUTE;\n+      disp = addr;\n+      /* 1 - indicates non-function symbol.  */\n+      code = 1;\n+      if (debug_print)\n+\t{\n+\t  fprintf (stderr, \"\\ndisp:\");\n+\t  debug_rtx (disp);\n+\t  fprintf (stderr, \"\\ncode:%d\", code);\n+\t}\n+      break;\n+\n+    case SYMBOL_REF:\n+      /* Absolute address (known at link time).  */\n+      retval = CR16_ABSOLUTE;\n+      disp = addr;\n+      /* This is a code address if symbol_ref is a function.  */\n+      /* 2 indicates func sym.  */\n+      code = SYMBOL_REF_FUNCTION_P (addr) ? 2 : 0;\n+      if (debug_print)\n+\t{\n+\t  fprintf (stderr, \"\\ndisp:\");\n+\t  debug_rtx (disp);\n+\t  fprintf (stderr, \"\\ncode:%d\", code);\n+\t}\n+      /* If not function ref then check if valid data ref.  */\n+      if (code == 0)\n+\t{\n+\t  if (CR16_TARGET_DATA_NEAR)\n+\t    data = DM_DEFAULT;\n+\t  else if (CR16_TARGET_DATA_MEDIUM)\n+\t    data = DM_FAR;\n+\t  else if (CR16_TARGET_DATA_FAR)\n+\t    {\n+\t      if (treat_as_const)\n+\t\t/* This will be used only for printing the \n+\t\t   qualifier. This call is (may be) made\n+\t\t   by cr16_print_operand_address.  */\n+\t\tdata = DM_FAR;\n+\t      else\n+\t\t/* This call is (may be) made by \n+\t\t   cr16_legitimate_address_p.  */\n+\t\treturn CR16_INVALID;\n+\t    }\n+\t  else\n+\t    data = DM_DEFAULT;\n+\t}\n+      if (debug_print)\n+\tfprintf (stderr, \"\\ndata:%d\", data);\n+      break;\n+\n+    case REG:\n+    case SUBREG:\n+      /* Register relative address.  */\n+      /* Assume REG fits in a single register.  */\n+      retval = CR16_REG_REL;\n+      if (GET_MODE_BITSIZE (GET_MODE (addr)) > BITS_PER_WORD)\n+\tif (!LONG_REG_P (REGNO (addr)))\n+\t  /* REG will result in reg pair.  */\n+\t  retval = CR16_REGP_REL;\n+      base = addr;\n+      if (debug_print)\n+\t{\n+\t  fprintf (stderr, \"\\nbase:\");\n+\t  debug_rtx (base);\n+\t}\n+      break;\n+\n+    case PLUS:\n+      switch (GET_CODE (XEXP (addr, 0)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* REG + DISP20.  */\n+\t  /* All Reg relative addresses having a displacement needs \n+\t     to fit in 20-bits.  */\n+\t  disp = XEXP (addr, 1);\n+\t  if (debug_print)\n+\t    {\n+\t      fprintf (stderr, \"\\ndisp:\");\n+\t      debug_rtx (disp);\n+\t    }\n+\t  switch (GET_CODE (XEXP (addr, 1)))\n+\t    {\n+\t    case CONST_INT:\n+\t      /* Shall fit in 20-bits.  */\n+\t      if (!UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), 20))\n+\t\treturn CR16_INVALID;\n+\t      code = 0;\n+\t      if (debug_print)\n+\t\tfprintf (stderr, \"\\ncode:%d\", code);\n+\t      break;\n+\n+\t    case UNSPEC:\n+\t      switch (XINT (XEXP (addr, 1), 1))\n+\t\t{\n+\t\tcase UNSPEC_LIBRARY_OFFSET:\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      break;\n+\n+\t    case LABEL_REF:\n+\t    case SYMBOL_REF:\n+\t    case CONST:\n+\t      /* This is also a valid expression for address.\n+\t         However, we cannot ascertain if the resultant\n+\t         displacement will be valid 20-bit value.  Therefore, \n+\t         lets not allow such an expression for now.  This will \n+\t         be updated when  we find a way to validate this \n+\t         expression as legitimate address. \n+\t         Till then fall through CR16_INVALID.  */\n+\t    default:\n+\t      return CR16_INVALID;\n+\t    }\n+\n+\t  /* Now check if REG can fit into single or pair regs.  */\n+\t  retval = CR16_REG_REL;\n+\t  base = XEXP (addr, 0);\n+\t  if (debug_print)\n+\t    {\n+\t      fprintf (stderr, \"\\nbase:\");\n+\t      debug_rtx (base);\n+\t    }\n+\t  if (GET_MODE_BITSIZE (GET_MODE ((XEXP (addr, 0)))) > BITS_PER_WORD)\n+\t    {\n+\t      if (!LONG_REG_P (REGNO ((XEXP (addr, 0)))))\n+\t\t/* REG will result in reg pair.  */\n+\t\tretval = CR16_REGP_REL;\n+\t    }\n+\t  break;\n+\n+\tcase PLUS:\n+\t  /* Valid expr: \n+\t     plus\n+\t      /\\\n+\t     /  \\\n+\t     plus idx\n+\t      /\\\n+\t     /  \\\n+\t     reg  const_int\n+\n+\t     Check if the operand 1 is valid index register.  */\n+\t  data = ILLEGAL_DM;\n+\t  if (debug_print)\n+\t    fprintf (stderr, \"\\ndata:%d\", data);\n+\t  switch (GET_CODE (XEXP (addr, 1)))\n+\t    {\n+\t    case REG:\n+\t    case SUBREG:\n+\t      if (!REG_OK_FOR_INDEX_P (XEXP (addr, 1)))\n+\t\treturn CR16_INVALID;\n+\t      /* OK. REG is a valid index register.  */\n+\t      index = XEXP (addr, 1);\n+\t      if (debug_print)\n+\t\t{\n+\t\t  fprintf (stderr, \"\\nindex:\");\n+\t\t  debug_rtx (index);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      return CR16_INVALID;\n+\t    }\n+\t  /* Check if operand 0 of operand 0 is REGP.  */\n+\t  switch (GET_CODE (XEXP (XEXP (addr, 0), 0)))\n+\t    {\n+\t    case REG:\n+\t    case SUBREG:\n+\t      /* Now check if REG is a REGP and not in LONG regs.  */\n+\t      if (GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (addr, 0), 0)))\n+\t\t  > BITS_PER_WORD)\n+\t\t{\n+\t\t  if (REGNO (XEXP (XEXP (addr, 0), 0))\n+\t\t      >= CR16_FIRST_DWORD_REGISTER)\n+\t\t    return CR16_INVALID;\n+\t\t  base = XEXP (XEXP (addr, 0), 0);\n+\t\t  if (debug_print)\n+\t\t    {\n+\t\t      fprintf (stderr, \"\\nbase:\");\n+\t\t      debug_rtx (base);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\treturn CR16_INVALID;\n+\t      break;\n+\t    default:\n+\t      return CR16_INVALID;\n+\t    }\n+\t  /* Now check if the operand 1 of operand 0 is const_int.  */\n+\t  if (GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)\n+\t    {\n+\t      disp = XEXP (XEXP (addr, 0), 1);\n+\t      if (debug_print)\n+\t\t{\n+\t\t  fprintf (stderr, \"\\ndisp:\");\n+\t\t  debug_rtx (disp);\n+\t\t}\n+\t      if (!UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), 20))\n+\t\treturn CR16_INVALID;\n+\t    }\n+\t  else\n+\t    return CR16_INVALID;\n+\t  retval = CR16_INDEX_REGP_REL;\n+\t  break;\n+\tdefault:\n+\t  return CR16_INVALID;\n+\t}\n+      break;\n+\n+    default:\n+      return CR16_INVALID;\n+    }\n+\n+  /* Check if the base and index registers are valid.  */\n+  if (base && !(cr16_addr_reg_p (base)))\n+    return CR16_INVALID;\n+  if (base && !(CR16_REG_OK_FOR_BASE_P (base)))\n+    return CR16_INVALID;\n+  if (index && !(REG_OK_FOR_INDEX_P (index)))\n+    return CR16_INVALID;\n+\n+  /* Write the decomposition to out parameter.  */\n+  out->base = base;\n+  out->disp = disp;\n+  out->index = index;\n+  out->data = data;\n+  out->code = code;\n+\n+  return retval;\n+}\n+\n+/* Return non-zero value if 'x' is legitimate PIC operand\n+   when generating PIC code.  */\n+int\n+legitimate_pic_operand_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case SYMBOL_REF:\n+      return 0;\n+      break;\n+    case LABEL_REF:\n+      return 0;\n+      break;\n+    case CONST:\n+      /* REVISIT: Use something like symbol_referenced_p.  */\n+      if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+\t      || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)\n+\t  && (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n+\treturn 0;\n+      break;\n+    case MEM:\n+      return legitimate_pic_operand_p (XEXP (x, 0));\n+      break;\n+    default:\n+      break;\n+    }\n+  return 1;\n+}\n+\n+/* Convert a non-PIC address in `orig' to a PIC address in `reg'.\n+\n+     Input            Output (-f pic)        Output (-f PIC)\n+     orig             reg\n+                                                                                                                             \n+     C1   symbol           symbol@BRO (r12)        symbol@GOT (r12)\n+                                                                                                                             \n+     C2   symbol + offset  symbol+offset@BRO (r12) symbol+offset@GOT (r12)\n+                                                                                                                             \n+     NOTE: @BRO is added using unspec:BRO\n+     NOTE: @GOT is added using unspec:GOT.  */\n+rtx\n+legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\trtx reg)\n+{\n+  /* First handle a simple SYMBOL_REF or LABEL_REF.  */\n+  if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)\n+    {\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      if (flag_pic == NEAR_PIC)\n+\t{\n+\t  /* Unspec to handle -fpic option.  */\n+\t  emit_insn (gen_unspec_bro_addr (reg, orig));\n+\t  emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));\n+\t}\n+      else if (flag_pic == FAR_PIC)\n+\t{\n+\t  /* Unspec to handle -fPIC option.  */\n+\t  emit_insn (gen_unspec_got_addr (reg, orig));\n+\t}\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      /* To handle (symbol + offset).  */\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  gcc_assert (can_create_pseudo_p ());\n+\t  reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+\n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t       base == reg ? 0 : reg);\n+\n+      /* REVISIT: Optimize for const-offsets.  */\n+      emit_insn (gen_addsi3 (reg, base, offset));\n+\n+      return reg;\n+    }\n+  return orig;\n+}\n+\n+/* Implementation of TARGET_LEGITIMATE_ADDRESS_P.  */\n+static bool\n+cr16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   rtx addr, bool strict)\n+{\n+  enum cr16_addrtype addrtype;\n+  struct cr16_address address;\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr,\n+\t       \"\\n======\\nTARGET_LEGITIMATE_ADDRESS_P, mode = %s, strict = %d\",\n+\t       GET_MODE_NAME (mode), strict);\n+      debug_rtx (addr);\n+    }\n+  addrtype = cr16_decompose_address (addr, &address,\n+\t\t\t\t     (TARGET_DEBUG_ADDR ? 1 : 0), FALSE);\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      const char *typestr;\n+\n+      switch (addrtype)\n+\t{\n+\tcase CR16_INVALID:\n+\t  typestr = \"invalid\";\n+\t  break;\n+\tcase CR16_ABSOLUTE:\n+\t  typestr = \"absolute\";\n+\t  break;\n+\tcase CR16_REG_REL:\n+\t  typestr = \"register relative\";\n+\t  break;\n+\tcase CR16_REGP_REL:\n+\t  typestr = \"register pair relative\";\n+\t  break;\n+\tcase CR16_INDEX_REGP_REL:\n+\t  typestr = \"index + register pair relative\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      fprintf (stderr, \"\\ncr16 address type: %s\\n\", typestr);\n+    }\n+\n+  if (addrtype == CR16_INVALID)\n+    return FALSE;\n+\n+  if (strict)\n+    {\n+      if (address.base\n+\t  && !REGNO_MODE_OK_FOR_BASE_P (REGNO (address.base), mode))\n+\t{\n+\t  if (TARGET_DEBUG_ADDR)\n+\t    fprintf (stderr, \"base register not strict\\n\");\n+\t  return FALSE;\n+\t}\n+      if (address.index && !REGNO_OK_FOR_INDEX_P (REGNO (address.index)))\n+\t{\n+\t  if (TARGET_DEBUG_ADDR)\n+\t    fprintf (stderr, \"index register not strict\\n\");\n+\t  return FALSE;\n+\t}\n+    }\n+\n+  /* Return true if addressing mode is register relative.  */\n+  if (flag_pic)\n+    {\n+      if (addrtype == CR16_REG_REL || addrtype == CR16_REGP_REL)\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+    }\n+\n+  return TRUE;\n+}\n+\n+/* Routines to compute costs.  */\n+\n+/* Return cost of the memory address x.  */\n+static int\n+cr16_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n+{\n+  enum cr16_addrtype addrtype;\n+  struct cr16_address address;\n+  int cost = 2;\n+\n+  addrtype = cr16_decompose_address (addr, &address, 0, FALSE);\n+\n+  gcc_assert (addrtype != CR16_INVALID);\n+\n+  /* CR16_ABSOLUTE            : 3\n+     CR16_REG_REL  (disp !=0) : 4\n+     CR16_REG_REL  (disp ==0) : 5\n+     CR16_REGP_REL (disp !=0) : 6\n+     CR16_REGP_REL (disp ==0) : 7\n+     CR16_INDEX_REGP_REL (disp !=0) : 8\n+     CR16_INDEX_REGP_REL (disp ==0) : 9.  */\n+  switch (addrtype)\n+    {\n+    case CR16_ABSOLUTE:\n+      cost += 1;\n+      break;\n+    case CR16_REGP_REL:\n+      cost += 2;\n+      /* Fall through.  */\n+    case CR16_REG_REL:\n+      cost += 3;\n+      if (address.disp)\n+\tcost -= 1;\n+      break;\n+    case CR16_INDEX_REGP_REL:\n+      cost += 7;\n+      if (address.disp)\n+\tcost -= 1;\n+    default:\n+      break;\n+    }\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\n======\\nmacro TARGET_ADDRESS_COST = %d\\n\", cost);\n+      debug_rtx (addr);\n+    }\n+\n+  return cost;\n+}\n+\n+\n+/* Implement `TARGET_REGISTER_MOVE_COST'.  */\n+static int\n+cr16_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t reg_class_t from ATTRIBUTE_UNUSED, reg_class_t to)\n+{\n+  return (to != GENERAL_REGS ? 8 : 2);\n+}\n+\n+/* Implement `TARGET_MEMORY_MOVE_COST'.  */\n+\n+/* Return the cost of moving data of mode MODE between a register of class\n+   CLASS and memory; IN is zero if the value is to be written to memory,\n+   nonzero if it is to be read in. This cost is relative to those in\n+   REGISTER_MOVE_COST.  */\n+static int\n+cr16_memory_move_cost (enum machine_mode mode,\n+\t\t       reg_class_t rclass ATTRIBUTE_UNUSED,\n+\t\t       bool in ATTRIBUTE_UNUSED)\n+{\n+  /* One LD or ST takes twice the time of a simple reg-reg move.  */\n+  if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n+    return (4 * HARD_REGNO_NREGS (0, mode));\n+  else\n+    return (100);\n+}\n+\n+/* Instruction output.  */\n+\n+/* Check if a const_double is ok for cr16 store-immediate instructions.  */\n+int\n+cr16_const_double_ok (rtx op)\n+{\n+  if (GET_MODE (op) == SFmode)\n+    {\n+      REAL_VALUE_TYPE r;\n+      long l;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+      return UNSIGNED_INT_FITS_N_BITS (l, 4) ? 1 : 0;\n+    }\n+\n+  return ((UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_LOW (op), 4)) &&\n+\t  (UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_HIGH (op), 4))) ? 1 : 0;\n+}\n+\n+/* Returns bit position of first 0 or 1 bit.\n+   It is safe to assume val as 16-bit wide.  */\n+int\n+cr16_operand_bit_pos (int val, int bitval)\n+{\n+  int i;\n+  if (bitval == 0)\n+    val = ~val;\n+\n+  for (i = 0; i < 16; i++)\n+    if (val & (1 << i))\n+      break;\n+  return i;\n+}\n+\n+/* Implements the macro PRINT_OPERAND defined in cr16.h.  */\n+static void\n+cr16_print_operand (FILE * file, rtx x, int code)\n+{\n+  int ptr_dereference = 0;\n+\n+  switch (code)\n+    {\n+    case 'd':\n+      {\n+\tconst char *cr16_cmp_str;\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t    /* MD: compare (reg, reg or imm) but CR16: cmp (reg or imm, reg)\n+\t       -> swap all non symmetric ops.  */\n+\t  case EQ:\n+\t    cr16_cmp_str = \"eq\";\n+\t    break;\n+\t  case NE:\n+\t    cr16_cmp_str = \"ne\";\n+\t    break;\n+\t  case GT:\n+\t    cr16_cmp_str = \"lt\";\n+\t    break;\n+\t  case GTU:\n+\t    cr16_cmp_str = \"lo\";\n+\t    break;\n+\t  case LT:\n+\t    cr16_cmp_str = \"gt\";\n+\t    break;\n+\t  case LTU:\n+\t    cr16_cmp_str = \"hi\";\n+\t    break;\n+\t  case GE:\n+\t    cr16_cmp_str = \"le\";\n+\t    break;\n+\t  case GEU:\n+\t    cr16_cmp_str = \"ls\";\n+\t    break;\n+\t  case LE:\n+\t    cr16_cmp_str = \"ge\";\n+\t    break;\n+\t  case LEU:\n+\t    cr16_cmp_str = \"hs\";\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tfprintf (file, \"%s\", cr16_cmp_str);\n+\treturn;\n+      }\n+    case '$':\n+      putc ('$', file);\n+      return;\n+\n+    case 'p':\n+      if (GET_CODE (x) == REG)\n+\t{\n+\t  /* For Push instructions, we should not print register pairs.  */\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  return;\n+\t}\n+      break;\n+\n+    case 'b':\n+      /* Print the immediate address for bal \n+         'b' is used instead of 'a' to avoid compiler calling\n+         the GO_IF_LEGITIMATE_ADDRESS which cannot\n+         perform checks on const_int code addresses as it\n+         assumes all const_int are data addresses.  */\n+      fprintf (file, \"0x%lx\", INTVAL (x));\n+      return;\n+\n+    case 'r':\n+      /* Print bit position of first 0.  */\n+      fprintf (file, \"%d\", cr16_operand_bit_pos (INTVAL (x), 0));\n+      return;\n+\n+    case 's':\n+      /* Print bit position of first 1.  */\n+      fprintf (file, \"%d\", cr16_operand_bit_pos (INTVAL (x), 1));\n+      return;\n+    case 'g':\n+      /* 'g' is used for implicit mem: dereference.  */\n+      ptr_dereference = 1;\n+    case 'f':\n+    case 0:\n+      /* default.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  if (GET_MODE_BITSIZE (GET_MODE (x)) > BITS_PER_WORD)\n+\t    {\n+\t      if (LONG_REG_P (REGNO (x)))\n+\t\tfprintf (file, \"(%s)\", reg_names[REGNO (x)]);\n+\t      else\n+\t\tfprintf (file, \"(%s,%s)\", reg_names[REGNO (x) + 1],\n+\t\t\t reg_names[REGNO (x)]);\n+\t    }\n+\t  else\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  return;\n+\n+\tcase MEM:\n+\t  output_address (XEXP (x, 0));\n+\t  return;\n+\n+\tcase CONST_DOUBLE:\n+\t  {\n+\t    REAL_VALUE_TYPE r;\n+\t    long l;\n+\n+\t    REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t    REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\n+\t    fprintf (file, \"$0x%lx\", l);\n+\t    return;\n+\t  }\n+\tcase CONST_INT:\n+\t  {\n+\t    fprintf (file, \"$%ld\", INTVAL (x));\n+\t    return;\n+\t  }\n+\tcase UNSPEC:\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  if (!ptr_dereference)\n+\t    {\n+\t      putc ('$', file);\n+\t    }\n+\t  cr16_print_operand_address (file, x);\n+\t  return;\n+\t}\n+    default:\n+      output_operand_lossage (\"invalid %%xn code\");\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Implements the macro PRINT_OPERAND_ADDRESS defined in cr16.h.  */\n+\n+static void\n+cr16_print_operand_address (FILE * file, rtx addr)\n+{\n+  enum cr16_addrtype addrtype;\n+  struct cr16_address address;\n+\n+  /* Decompose the address. Also ask it to treat address as constant.  */\n+  addrtype = cr16_decompose_address (addr, &address, 0, TRUE);\n+\n+  if (address.disp && GET_CODE (address.disp) == UNSPEC)\n+    {\n+      debug_rtx (addr);\n+    }\n+\n+  switch (addrtype)\n+    {\n+    case CR16_REG_REL:\n+      if (address.disp)\n+\t{\n+\t  if (GET_CODE (address.disp) == UNSPEC)\n+\t    cr16_print_operand (file, address.disp, 0);\n+\t  else\n+\t    output_addr_const (file, address.disp);\n+\t}\n+      else\n+\tfprintf (file, \"0\");\n+      fprintf (file, \"(%s)\", reg_names[REGNO (address.base)]);\n+      break;\n+\n+    case CR16_ABSOLUTE:\n+      if (address.disp)\n+\toutput_addr_const (file, address.disp);\n+      else\n+\tfprintf (file, \"0\");\n+      break;\n+\n+    case CR16_INDEX_REGP_REL:\n+      fprintf (file, \"[%s]\", reg_names[REGNO (address.index)]);\n+      /* Fall through.  */\n+    case CR16_REGP_REL:\n+      if (address.disp)\n+\t{\n+\t  if (GET_CODE (address.disp) == UNSPEC)\n+\t    cr16_print_operand (file, address.disp, 0);\n+\t  else\n+\t    output_addr_const (file, address.disp);\n+\t}\n+      else\n+\tfprintf (file, \"0\");\n+      fprintf (file, \"(%s,%s)\", reg_names[REGNO (address.base) + 1],\n+\t       reg_names[REGNO (address.base)]);\n+      break;\n+    default:\n+      debug_rtx (addr);\n+      gcc_unreachable ();\n+    }\n+  /* Add qualifiers to the address expression that was just printed.  */\n+  if (flag_pic < NEAR_PIC && address.code == 0)\n+    {\n+      if (address.data == DM_FAR)\n+\t/* Addr contains SYMBOL_REF & far data ptr.  */\n+\tfprintf (file, \"@l\");\n+      else if (address.data == DM_DEFAULT)\n+\t/* Addr contains SYMBOL_REF & medium data ptr.  */\n+\tfprintf (file, \"@m\");\n+      /* Addr contains SYMBOL_REF & medium data ptr.  */\n+      else if (address.data == DM_NEAR)\n+\t/* Addr contains SYMBOL_REF & near data ptr.  */\n+\tfprintf (file, \"@s\");\n+    }\n+  else if (flag_pic == NEAR_PIC\n+\t   && (address.code == 0) && (address.data == DM_FAR\n+\t\t\t\t      || address.data == DM_DEFAULT\n+\t\t\t\t      || address.data == DM_NEAR))\n+    {\n+      fprintf (file, \"@l\");\n+    }\n+  else if (flag_pic == NEAR_PIC && address.code == 2)\n+    {\n+      fprintf (file, \"pic\");\n+    }\n+  else if (flag_pic == NEAR_PIC && address.code == 1)\n+    {\n+      fprintf (file, \"@cpic\");\n+    }\n+\n+  else if (flag_pic == FAR_PIC && address.code == 2)\n+    {\n+      /* REVISIT: cr16 register indirect jump expects a 1-bit right shifted\n+         address ! GOTc tells assembler this symbol is a text-address \n+         This needs to be fixed in such a way that this offset is done \n+         only in the case where an address is being used for indirect jump\n+         or call. Determining the potential usage of loadd is of course not\n+         possible always. Eventually, this has to be fixed in the \n+         processor.  */\n+      fprintf (file, \"GOT (%s)\", reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    }\n+  else if (flag_pic == FAR_PIC && address.code == 1)\n+    {\n+      fprintf (file, \"@cGOT (%s)\", reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    }\n+\n+  else if (flag_pic == FAR_PIC &&\n+\t   (address.data == DM_FAR || address.data == DM_DEFAULT\n+\t    || address.data == DM_NEAR))\n+    {\n+      fprintf (file, \"@GOT (%s)\", reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    }\n+}\n+\n+/* Machine description helper functions.  */\n+\n+/* Called from cr16.md. The return value depends on the parameter push_or_pop:\n+   When push_or_pop is zero -> string for push instructions of prologue.\n+   When push_or_pop is nonzero -> string for pop/popret/retx in epilogue.\n+   Relies on the assumptions:\n+   1. RA is the last register to be saved.\n+   2. The maximal value of the counter is MAX_COUNT.  */\n+char *\n+cr16_prepare_push_pop_string (int push_or_pop)\n+{\n+  /* j is the number of registers being saved, takes care that there won't be\n+     more than 8 in one push/pop instruction.  */\n+\n+  /* For the register mask string.  */\n+  static char one_inst_str[50];\n+\n+  /* i is the index of current_frame_info.save_regs[], going from 0 until \n+     current_frame_info.last_reg_to_save.  */\n+  int i, start_reg;\n+  int word_cnt;\n+  int print_ra;\n+  char *return_str;\n+\n+  /* For reversing on the push instructions if there are more than one.  */\n+  char *temp_str;\n+\n+  return_str = (char *) xmalloc (160);\n+  temp_str = (char *) xmalloc (160);\n+\n+  /* Initialize.  */\n+  memset (return_str, 0, 3);\n+\n+  i = 0;\n+  while (i <= current_frame_info.last_reg_to_save)\n+    {\n+      /* Prepare mask for one instruction.  */\n+      one_inst_str[0] = 0;\n+\n+      /* To count number of words in one instruction.  */\n+      word_cnt = 0;\n+      start_reg = i;\n+      print_ra = 0;\n+      while ((word_cnt < MAX_COUNT) \n+\t     && (i <= current_frame_info.last_reg_to_save))\n+\t{\n+\t  /* For each non consecutive save register, \n+\t     a new instruction shall be generated.  */\n+\t  if (!current_frame_info.save_regs[i])\n+\t    {\n+\t      /* Move to next reg and break.  */\n+\t      ++i;\n+\t      break;\n+\t    }\n+\n+\t  if (i == RETURN_ADDRESS_REGNUM)\n+\t    print_ra = 1;\n+\t  else\n+\t    {\n+\t      /* Check especially if adding 2 does not cross the MAX_COUNT.  */\n+\t      if ((word_cnt + ((i < CR16_FIRST_DWORD_REGISTER) ? 1 : 2))\n+\t\t  >= MAX_COUNT)\n+\t\tbreak;\n+\t      /* Increase word count by 2 for long registers except RA.   */\n+\t      word_cnt += ((i < CR16_FIRST_DWORD_REGISTER) ? 1 : 2);\n+\t    }\n+\t  ++i;\n+\t}\n+\n+      /* No need to generate any instruction as\n+         no register or RA needs to be saved.  */\n+      if ((word_cnt == 0) && (print_ra == 0))\n+\tcontinue;\n+\n+      /* Now prepare the instruction operands.  */\n+      if (word_cnt > 0)\n+\t{\n+\t  sprintf (one_inst_str, \"$%d, %s\", word_cnt, reg_names[start_reg]);\n+\t  if (print_ra)\n+\t    strcat (one_inst_str, \", ra\");\n+\t}\n+      else\n+\tstrcat (one_inst_str, \"ra\");\n+\n+      if (push_or_pop == 1)\n+\t{\n+\t  /* Pop instruction.  */\n+\t  if (print_ra && !cr16_interrupt_function_p ()\n+\t      && !crtl->calls_eh_return)\n+\t    /* Print popret if RA is saved and its not a interrupt \n+\t       function.  */\n+\t    strcpy (temp_str, \"\\n\\tpopret\\t\");\n+\t  else\n+\t    strcpy (temp_str, \"\\n\\tpop\\t\");\n+\n+\t  strcat (temp_str, one_inst_str);\n+\n+\t  /* Add the pop instruction list.  */\n+\t  strcat (return_str, temp_str);\n+\t}\n+      else\n+\t{\n+\t  /* Push instruction.  */\n+\t  strcpy (temp_str, \"\\n\\tpush\\t\");\n+\t  strcat (temp_str, one_inst_str);\n+\n+\t  /* We need to reverse the order of the instructions if there\n+\t     are more than one. (since the pop will not be reversed in \n+\t     the epilogue.  */\n+\t  strcat (temp_str, return_str);\n+\t  strcpy (return_str, temp_str);\n+\t}\n+    }\n+\n+  if (push_or_pop == 1)\n+    {\n+      /* POP.  */\n+      if (cr16_interrupt_function_p ())\n+\tstrcat (return_str, \"\\n\\tretx\\n\");\n+      else if (crtl->calls_eh_return)\n+\t{\n+\t  /* Add stack adjustment before returning to exception handler\n+\t     NOTE: EH_RETURN_STACKADJ_RTX must refer to (r5, r4).  */\n+\t  strcat (return_str, \"\\n\\taddd\\t (r5, r4), (sp)\\t\\n\");\n+\t  strcat (return_str, \"\\n\\tjump\\t (ra)\\n\");\n+\n+\t  /* But before anything else, undo the adjustment addition done in\n+\t     cr16_expand_epilogue ().  */\n+\t  strcpy (temp_str, \"\\n\\tsubd\\t (r5, r4), (sp)\\t\\n\");\n+\t  strcat (temp_str, return_str);\n+\t  strcpy (return_str, temp_str);\n+\t}\n+      else if (!FUNC_IS_NORETURN_P (current_function_decl)\n+\t       && !(current_frame_info.save_regs[RETURN_ADDRESS_REGNUM]))\n+\tstrcat (return_str, \"\\n\\tjump\\t (ra)\\n\");\n+    }\n+\n+  /* Skip the newline and the tab in the start of return_str.  */\n+  return_str += 2;\n+  return return_str;\n+}\n+\n+\n+/* Generate DWARF2 annotation for multi-push instruction.  */\n+static void\n+cr16_create_dwarf_for_multi_push (rtx insn)\n+{\n+  rtx dwarf, reg, tmp;\n+  int i, j, from, to, word_cnt, dwarf_par_index, inc;\n+  enum machine_mode mode;\n+  int num_regs = 0, offset = 0, split_here = 0, total_push_bytes = 0;\n+\n+  for (i = 0; i <= current_frame_info.last_reg_to_save; ++i)\n+    {\n+      if (current_frame_info.save_regs[i])\n+\t{\n+\t  ++num_regs;\n+\t  if (i < CR16_FIRST_DWORD_REGISTER)\n+\t    total_push_bytes += 2;\n+\t  else\n+\t    total_push_bytes += 4;\n+\t}\n+    }\n+\n+  if (!num_regs)\n+    return;\n+\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+  dwarf_par_index = num_regs;\n+\n+  from = current_frame_info.last_reg_to_save + 1;\n+  to = current_frame_info.last_reg_to_save;\n+  word_cnt = 0;\n+\n+  for (i = current_frame_info.last_reg_to_save; i >= 0;)\n+    {\n+      if (!current_frame_info.save_regs[i] || 0 == i || split_here)\n+\t{\n+\t  /* This block of regs is pushed in one instruction.  */\n+\t  if (0 == i && current_frame_info.save_regs[i])\n+\t    from = 0;\n+\n+\t  for (j = to; j >= from; --j)\n+\t    {\n+\t      if (j < CR16_FIRST_DWORD_REGISTER)\n+\t\t{\n+\t\t  mode = HImode;\n+\t\t  inc = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  mode = SImode;\n+\t\t  inc = 2;\n+\t\t}\n+\t      reg = gen_rtx_REG (mode, j);\n+\t      offset += 2 * inc;\n+\t      tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_frame_mem (mode,\n+\t\t\t\t\t\tplus_constant\n+\t\t\t\t\t\t(stack_pointer_rtx,\n+\t\t\t\t\t\t total_push_bytes - offset)),\n+\t\t\t\t reg);\n+\t      RTX_FRAME_RELATED_P (tmp) = 1;\n+\t      XVECEXP (dwarf, 0, dwarf_par_index--) = tmp;\n+\t    }\n+\t  from = i;\n+\t  to = --i;\n+\t  split_here = 0;\n+\t  word_cnt = 0;\n+\t  continue;\n+\t}\n+\n+      if (i != RETURN_ADDRESS_REGNUM)\n+\t{\n+\t  inc = (i < CR16_FIRST_DWORD_REGISTER) ? 1 : 2;\n+\t  if (word_cnt + inc >= MAX_COUNT || FRAME_POINTER_REGNUM == i)\n+\t    {\n+\t      split_here = 1;\n+\t      from = i;\n+\t      continue;\n+\t    }\n+\t  word_cnt += inc;\n+\t}\n+\n+      from = i--;\n+    }\n+\n+  tmp = gen_rtx_SET (SImode, stack_pointer_rtx,\n+\t\t     gen_rtx_PLUS (SImode, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (-offset)));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (dwarf, 0, 0) = tmp;\n+\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+}\n+\n+/*\n+CompactRISC CR16 Architecture stack layout:\n+\n+     0 +---------------------\n+    |\n+    .\n+    .\n+    |\n+    +==================== Sp (x) = Ap (x+1)\n+      A | Args for functions\n+      | | called by X and      Dynamically\n+      | | Dynamic allocations  allocated and\n+      | | (alloca, variable    deallocated\n+  Stack | length arrays).\n+  grows +-------------------- Fp (x)\n+  down| | Local variables of X\n+  ward| +--------------------\n+      | | Regs saved for X-1\n+      | +==================== Sp (x-1) = Ap (x)\n+    | Args for func X\n+    | pushed by X-1\n+    +-------------------- Fp (x-1)\n+    |\n+    |\n+    V\n+*/\n+void\n+cr16_expand_prologue (void)\n+{\n+  rtx insn;\n+\n+  cr16_compute_frame ();\n+  cr16_compute_save_regs ();\n+\n+  /* If there is no need in push and adjustment to sp, return.  */\n+  if ((current_frame_info.total_size + current_frame_info.reg_size) == 0)\n+    return;\n+\n+  if (current_frame_info.last_reg_to_save != -1)\n+    {\n+      /* If there are registers to push.  */\n+      insn = emit_insn (gen_push_for_prologue\n+\t\t\t(GEN_INT (current_frame_info.reg_size)));\n+      cr16_create_dwarf_for_multi_push (insn);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+\n+  if (current_frame_info.total_size > 0)\n+    {\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-current_frame_info.total_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Initialize the frame pointer with the value of the stack pointer\n+         pointing now to the locals.  */\n+      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+    }\n+}\n+\n+/* Generate insn that updates the stack for local variables and padding \n+   for registers we save.   - Generate the appropriate return insn.  */\n+void\n+cr16_expand_epilogue (void)\n+{\n+  rtx insn;\n+\n+  /* Nonzero if we need to return and pop only RA. This will generate a\n+     different insn. This differentiate is for the peepholes for call as \n+     last statement in function.  */\n+  int only_popret_RA = (current_frame_info.save_regs[RETURN_ADDRESS_REGNUM]\n+\t\t\t&& (current_frame_info.reg_size \n+\t\t\t    == CR16_UNITS_PER_DWORD));\n+  \n+  if (frame_pointer_needed)\n+    {\n+      /* Restore the stack pointer with the frame pointers value.  */\n+      insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+    }\n+\n+  if (current_frame_info.total_size > 0)\n+    {\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (current_frame_info.total_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (crtl->calls_eh_return)\n+    {\n+      /* Add this here so that (r5, r4) is actually loaded with the adjustment\n+         value; otherwise, the load might be optimized away...\n+         NOTE: remember to subtract the adjustment before popping the regs\n+         and add it back before returning.  */\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    EH_RETURN_STACKADJ_RTX));\n+    }\n+\n+  if (cr16_interrupt_function_p ())\n+    {\n+      insn = emit_jump_insn (gen_interrupt_return ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else if (crtl->calls_eh_return)\n+    {\n+      /* Special case, pop what's necessary, adjust SP and jump to (RA).  */\n+      insn = emit_jump_insn (gen_pop_and_popret_return \n+\t\t\t     (GEN_INT (current_frame_info.reg_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else if (current_frame_info.last_reg_to_save == -1)\n+    /* Nothing to pop.  */\n+    /* Don't output jump for interrupt routine, only retx.  */\n+    emit_jump_insn (gen_jump_return ());\n+  else if (only_popret_RA)\n+    {\n+      insn = emit_jump_insn (gen_popret_RA_return ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    {\n+      insn = emit_jump_insn (gen_pop_and_popret_return \n+\t\t\t     (GEN_INT (current_frame_info.reg_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+/* Implements FRAME_POINTER_REQUIRED.  */\n+static bool\n+cr16_frame_pointer_required (void)\n+{\n+  return (cfun->calls_alloca || crtl->calls_eh_return\n+\t  || cfun->has_nonlocal_label || crtl->calls_eh_return);\n+}\n+\n+static bool\n+cr16_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n+{\n+  return (to == STACK_POINTER_REGNUM ? !frame_pointer_needed : true);\n+}\n+\n+\n+/* A C compound statement that attempts to replace X with\n+   a valid memory address for an operand of mode MODE. WIN\n+   will be a C statement label elsewhere in the code.\n+   X will always be the result of a call to break_out_memory_refs (),\n+   and OLDX will be the operand that was given to that function to\n+   produce X.\n+   The code generated by this macro should not alter the\n+   substructure of X.  If it transforms X into a more legitimate form, \n+   it should assign X (which will always be a C variable) a new value.  */\n+static rtx\n+cr16_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (flag_pic)\n+    return legitimize_pic_address (orig_x, mode, NULL_RTX);\n+  else\n+    return x;\n+}\n+\n+/* Implement TARGET_LEGITIMATE_CONSTANT_P\n+   Nonzero if X is a legitimate constant for an immediate\n+   operand on the target machine.  You can assume that X\n+   satisfies CONSTANT_P. In cr16c treat legitimize float \n+   constant as an immediate operand.  */\n+static bool\n+cr16_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    rtx x ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+void\n+notice_update_cc (rtx exp)\n+{\n+  if (GET_CODE (exp) == SET)\n+    {\n+      /* Jumps do not alter the cc's.  */\n+      if (SET_DEST (exp) == pc_rtx)\n+\treturn;\n+\n+      /* Moving register or memory into a register:\n+         it doesn't alter the cc's, but it might invalidate\n+         the RTX's which we remember the cc's came from.\n+         (Note that moving a constant 0 or 1 MAY set the cc's).  */\n+      if (REG_P (SET_DEST (exp))\n+\t  && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n+\t{\n+\t  return;\n+\t}\n+\n+      /* Moving register into memory doesn't alter the cc's.\n+         It may invalidate the RTX's which we remember the cc's came from.  */\n+      if (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n+\t{\n+\t  return;\n+\t}\n+    }\n+\n+  CC_STATUS_INIT;\n+  return;\n+}\n+\n+static enum machine_mode\n+cr16_unwind_word_mode (void)\n+{\n+  return SImode;\n+}\n+\n+/* Helper function for md file. This function is used to emit arithmetic \n+   DI instructions. The argument \"num\" decides which instruction to be\n+   printed.  */\n+const char *\n+cr16_emit_add_sub_di (rtx *operands, enum rtx_code code)\n+{\n+  rtx lo_op[2] ;\n+  rtx hi0_op[2] ;\n+  rtx hi1_op[2] ;\n+\n+  lo_op[0] = gen_lowpart (SImode, operands[0]);\n+  hi0_op[0] = simplify_gen_subreg (HImode, operands[0], DImode, 4);\n+  hi1_op[0] = simplify_gen_subreg (HImode, operands[0], DImode, 6);\n+\n+  lo_op[1] = gen_lowpart (SImode, operands[2]);\n+  hi0_op[1] = simplify_gen_subreg (HImode, operands[2], DImode, 4);\n+  hi1_op[1] = simplify_gen_subreg (HImode, operands[2], DImode, 6);\n+\n+  switch (code)\n+  {\n+    case PLUS:\n+      {\n+\toutput_asm_insn (\"addd\\t%1, %0\", lo_op) ;\n+\toutput_asm_insn (\"addcw\\t%1, %0\", hi0_op) ;\n+\toutput_asm_insn (\"addcw\\t%1, %0\", hi1_op) ;\n+\tbreak;\n+      }\n+    case MINUS:\n+      {\n+\toutput_asm_insn (\"subd\\t%1, %0\", lo_op) ;\n+\toutput_asm_insn (\"subcw\\t%1, %0\", hi0_op) ;\n+\toutput_asm_insn (\"subcw\\t%1, %0\", hi1_op) ;\n+\tbreak;\n+      }\n+   default:\n+     break;\n+  }\n+\n+  return \"\";\n+}\n+\n+\n+/* Helper function for md file. This function is used to emit logical \n+   DI instructions. The argument \"num\" decides which instruction to be\n+   printed.  */\n+const char *\n+cr16_emit_logical_di (rtx *operands, enum rtx_code code)\n+{\n+  rtx lo_op[2] ;\n+  rtx hi_op[2] ;\n+\n+  lo_op[0] = gen_lowpart (SImode, operands[0]);\n+  hi_op[0] = simplify_gen_subreg (SImode, operands[0], DImode, 4);\n+\n+  lo_op[1] = gen_lowpart (SImode, operands[2]);\n+  hi_op[1] = simplify_gen_subreg (SImode, operands[2], DImode, 4);\n+\n+  switch (code)\n+  {\n+    case AND:\n+      {\n+\toutput_asm_insn (\"andd\\t%1, %0\", lo_op) ;\n+\toutput_asm_insn (\"andd\\t%1, %0\", hi_op) ;\n+\treturn \"\";\n+      }\n+    case IOR:\n+      {\n+\toutput_asm_insn (\"ord\\t%1, %0\", lo_op) ;\n+\toutput_asm_insn (\"ord\\t%1, %0\", hi_op) ;\n+\treturn \"\";\n+      }\n+    case XOR:\n+      {\n+\toutput_asm_insn (\"xord\\t%1, %0\", lo_op) ;\n+\toutput_asm_insn (\"xord\\t%1, %0\", hi_op) ;\n+\treturn \"\";\n+      }\n+    default:\n+      break;\n+  }\n+\n+  return \"\";\n+}\n+\n+/* Initialize 'targetm' variable which contains pointers to functions \n+   and data relating to the target machine.  */\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "01577ca544867f4bc00fcc27032b49d9990bdd89", "filename": "gcc/config/cr16/cr16.h", "status": "added", "additions": 590, "deletions": 0, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,590 @@\n+/* Definitions of target machine for GNU compiler, for CR16.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by KPIT Cummins Infosystems Limited.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+   \n+#ifndef GCC_CR16_H\n+#define GCC_CR16_H\n+\n+#define OBJECT_FORMAT_ELF\n+\n+/* Controlling the driver.  */\n+\n+/* The GNU C++ standard library requires that these macros be defined.  */\n+#undef CPLUSPLUS_CPP_SPEC\n+#define CPLUSPLUS_CPP_SPEC \"-D_GNU_SOURCE %(cpp)\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt1.o%s crti.o%s crtbegin.o%s crtlibid.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef  MATH_LIBRARY\n+#define MATH_LIBRARY \"\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"-( -lc %{msim*:-lsim}%{!msim*:-lnosys} -) \\\n+%{msim*:%{!T*:-Tsim.ld}} \\\n+%{!T*:%{!msim*: %{-Telf32cr16.x}}}\"\n+\n+/* Run-time target specification.  */\n+#ifndef TARGET_CPU_CPP_BUILTINS\n+#define TARGET_CPU_CPP_BUILTINS()          \\\n+do                                         \\\n+  {                                        \\\n+    builtin_define (\"__CR__\");             \\\n+    builtin_define (\"__CR16__\");           \\\n+    builtin_define (\"__CR16C__\");          \\\n+    if (TARGET_CR16CP)                     \\\n+      builtin_define (\"__CR16CP__\");       \\\n+    else                                   \\\n+      builtin_define (\"__CR16CSTD__\");     \\\n+    if (CR16_TARGET_DATA_NEAR)             \\\n+      builtin_define (\"__DATA_NEAR__\");    \\\n+    if (CR16_TARGET_DATA_MEDIUM)           \\\n+      builtin_define (\"__DATA_MEDIUM__\");  \\\n+    if (CR16_TARGET_DATA_FAR)              \\\n+      builtin_define (\"__DATA_FAR__\");     \\\n+    if (TARGET_INT32)                      \\\n+      builtin_define (\"__INT32__\");        \\\n+  }                                        \\\n+while (0)\n+#endif\n+\n+/* Force the generation of dwarf .debug_frame sections even if not\n+   compiling -g.  This guarantees that we can unwind the stack.  */\n+#define DWARF2_FRAME_INFO 1\n+\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* Generate .file/.loc directives, so that the assembler generates the\n+   line table.  */\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+#define CR16_TARGET_DATA_NEAR   cr16_is_data_model (DM_NEAR)\n+#define CR16_TARGET_DATA_MEDIUM cr16_is_data_model (DM_DEFAULT)\n+#define CR16_TARGET_DATA_FAR    cr16_is_data_model (DM_FAR)\n+\n+/* Storage layout.  */\n+#define BITS_BIG_ENDIAN     0\n+\n+#define BYTES_BIG_ENDIAN    0\n+\n+#define WORDS_BIG_ENDIAN    0\n+\n+#define UNITS_PER_WORD      2\n+\n+/* Units per 32-bit (DWORD).  */\n+#define CR16_UNITS_PER_DWORD 4\n+\n+#define POINTER_SIZE        32\n+\n+#define PARM_BOUNDARY       16\n+\n+#define STACK_BOUNDARY      (MAX (BIGGEST_ALIGNMENT, PARM_BOUNDARY))\n+\n+#define FUNCTION_BOUNDARY   BIGGEST_ALIGNMENT\n+\n+/* Biggest alignment on CR16C+ is 32-bit as internal bus is AMBA based \n+   where as CR16C is proprietary internal bus architecture.  */\n+#define BIGGEST_ALIGNMENT   ((TARGET_CR16CP) ? 32 : 16)\n+\n+#define MAX_FIXED_MODE_SIZE 64\n+\n+/* In CR16 arrays of chars are word-aligned, so strcpy () will be faster.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)              \\\n+  (((TREE_CODE (TYPE) == ARRAY_TYPE)             \\\n+     && (TYPE_MODE (TREE_TYPE (TYPE)) == QImode) \\\n+     && ((ALIGN) < BITS_PER_WORD))               \\\n+     ? (BITS_PER_WORD) : (ALIGN))\n+\n+/* In CR16 strings are word-aligne; strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(CONSTANT, ALIGN)                            \\\n+  (((TREE_CODE (CONSTANT) == STRING_CST) && ((ALIGN) < BITS_PER_WORD)) \\\n+     ? (BITS_PER_WORD) : (ALIGN))\n+\n+#define STRICT_ALIGNMENT 0\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Layout of source language data types.  */\n+#define INT_TYPE_SIZE       (TARGET_INT32 ? 32 : 16)\n+\n+#define SHORT_TYPE_SIZE     16\n+\n+#define LONG_TYPE_SIZE      32\n+\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE     32\n+\n+#define DOUBLE_TYPE_SIZE    64\n+\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define SIZE_TYPE           \"long unsigned int\"\n+\n+#define PTRDIFF_TYPE        \"long int\"\n+\n+#define WCHAR_TYPE          \"short unsigned int\"\n+\n+#define WCHAR_TYPE_SIZE     16\n+\n+/* By default, the C++ compiler will use the lowest bit of the pointer\n+   to function to indicate a pointer-to-member-function points to a\n+   virtual member function.  However, in CR architecture FUNCTION_BOUNDARY\n+   indicates function addresses are always even, but function pointers can be\n+   odd (after right-shifting them when loading them into a register), and the\n+   default doesn't work.  In that case, the lowest bit of the delta\n+   field will be used (the remainder of the field is shifted to the left).  */\n+#define TARGET_PTRMEMFUNC_VBIT_LOCATION     ptrmemfunc_vbit_in_delta\n+\n+/* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n+   values must be in memory.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Register usage.  */\n+\n+/* First 32-bit register is R12.  */\n+#define CR16_FIRST_DWORD_REGISTER   12\n+\n+#define FIRST_PSEUDO_REGISTER       16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the CR16, only the stack pointer (r15) is such.  */\n+#define FIXED_REGISTERS                               \\\n+  {                                                   \\\n+  /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10.  */ \\\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,        \\\n+  /* r11 r12 r13 ra  sp.  */                          \\\n+    0,  0,  0,  0,  1                                 \\\n+  }      \n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+ \n+   On the CR16, calls clobbers r0-r6 (scratch registers), \n+   ra (the return address) and sp (the stack pointer).  */\n+#define CALL_USED_REGISTERS                           \\\n+  {                                                   \\\n+  /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10.  */ \\\n+    1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,        \\\n+  /* r11 r12 r13 ra  sp.  */                          \\\n+    0,  0,  0,  1,  1                                 \\\n+  }\n+\n+/* Returns 1 if the register is longer than word size, 0 otherwise.  */\n+#define LONG_REG_P(REGNO)                                                    \\\n+  (HARD_REGNO_NREGS (REGNO,                                                  \\\n+\t\t     GET_MODE_WIDER_MODE (smallest_mode_for_size\t     \\\n+\t\t\t\t\t (BITS_PER_WORD, MODE_INT))) == 1)\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)                                         \\\n+ ((REGNO >= CR16_FIRST_DWORD_REGISTER)                                        \\\n+  ? ((GET_MODE_SIZE (MODE) + CR16_UNITS_PER_DWORD - 1) / CR16_UNITS_PER_DWORD)\\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD       - 1) / UNITS_PER_WORD))\n+\n+/* Nonzero if it is permissible to store a value of mode @var{mode} in hard\n+   register number @var{regno} (or in several registers starting with that\n+   one).  On the CR16 architecture, all registers can hold all modes,\n+   except that double precision floats (and double ints) must fall on\n+   even-register boundaries.  */ \n+#define HARD_REGNO_MODE_OK(REGNO, MODE) cr16_hard_regno_mode_ok (REGNO, MODE)\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+   notice_update_cc ((EXP))\n+\n+/* Interrupt functions can only use registers that have already been \n+   saved by the prologue, even if they would normally be call-clobbered \n+   Check if sizes are same and then check if it is possible to rename.  */\n+#define HARD_REGNO_RENAME_OK(SRC, DEST)                 \\\n+  (!cr16_interrupt_function_p () || (df_regs_ever_live_p (DEST)))\n+\n+/* Exception handling stuff.  */\n+\n+/*To ensure correct dwarf unwinding.  */\n+#define LIBGCC2_UNWIND_ATTRIBUTE __attribute__((optimize (\"no-gcse\",\"no-dse\")))\n+\n+#define gen_rtx_RA\tgen_rtx_REG (Pmode, RETURN_ADDRESS_REGNUM)\n+\n+/* Use (r8,r7) and (r10,r9) to pass exception handling information.  */\n+#define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? (N*2 + 7) : INVALID_REGNUM)\n+\n+#define DWARF2_UNWIND_INFO 1\n+\n+/* (r5,r4) holds a stack adjustment for returning to a handler.  */\n+#define EH_RETURN_STACKADJ_RTX \t\tgen_rtx_REG (Pmode, 4)\n+\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -4))\n+\n+#define INCOMING_RETURN_ADDR_RTX\tgen_rtx_RA\n+\n+#define DWARF_FRAME_RETURN_COLUMN\t\\\n+  DWARF_FRAME_REGNUM (RETURN_ADDRESS_REGNUM)\n+\n+#define INCOMING_FRAME_SP_OFFSET\t\t0\t\n+#define FRAME_POINTER_CFA_OFFSET(FNDECL)\t0\t\n+\n+/* A C expression whose value is RTL representing the value of the return\n+   address for the frame COUNT steps up from the current frame.  */\n+#define RETURN_ADDR_RTX(COUNT, FRAME) \t\t\t  \t\t\\\n+  (0 == COUNT)\t?  gen_rtx_PLUS (Pmode, gen_rtx_RA, gen_rtx_RA)\t\t\\\n+\t\t:  const0_rtx\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  SHORT_REGS,\n+  LONG_REGS,\n+  NOSP_REGS,\n+  DOUBLE_BASE_REGS,\n+  GENERAL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES\t\\\n+  {\t\t\t\\\n+    \"NO_REGS\",\t\t\\\n+    \"SHORT_REGS\",\t\\\n+    \"LONG_REGS\",\t\\\n+    \"NOSP_REGS\",\t\\\n+    \"DOUBLE_BASE_REGS\",\t\\\n+    \"GENERAL_REGS\",\t\\\n+    \"ALL_REGS\"\t\t\\\n+  }\n+\n+#define REG_CLASS_CONTENTS\t\t\t     \t\t\\\n+  {\t\t\t\t\t\t     \t\t\\\n+    {0x00000000}, /* NO_REGS\t\t             */  \t\\\n+    {0x00000FFF}, /* SHORT_REGS \t: 0 - 11     */   \t\\\n+    {0x0000F000}, /* LONG_REGS \t\t: 12 - 15    */  \t\\\n+    {0x00007FFF}, /* NOSP_REGS \t\t: 0 - 14     */   \t\\\n+    {0x0000F555}, /* DOUBLE_BASE_REGS   : 2,4,6,8,10 */  \t\\\n+    {0x0000FFFF}, /* GENERAL_REGS\t: 0 - 15     */  \t\\\n+    {0x0000FFFF}  /* ALL_REGS \t\t: 0 - 15     */  \t\\\n+  }\n+\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P  hook_bool_mode_true \n+\n+#define REGNO_REG_CLASS(REGNO)  cr16_regno_reg_class (REGNO)\n+\n+#define BASE_REG_CLASS      GENERAL_REGS\n+\n+#define MODE_BASE_REG_CLASS(MODE) \\\n+  (GET_MODE_SIZE (MODE) <= 4 ?  (BASE_REG_CLASS) :  (DOUBLE_BASE_REGS))\n+\n+#define INDEX_REG_CLASS      LONG_REGS\n+\n+#define CR16_REGNO_OK_FOR_BASE_P(REGNO)                  \\\n+  (((REGNO) < FIRST_PSEUDO_REGISTER)                     \\\n+     || (reg_renumber && ((unsigned) reg_renumber[REGNO] \\\n+                        < FIRST_PSEUDO_REGISTER)))\n+\n+/* Use even-numbered reg for 64-bit accesses.  */\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t  \\\n+\t(CR16_REGNO_OK_FOR_BASE_P(REGNO)  &&\t  \\\n+\t  ((GET_MODE_SIZE (MODE) > 4  &&  \t  \\\n+\t     (REGNO) < CR16_FIRST_DWORD_REGISTER) \\\n+\t     ? (0 == ((REGNO) & 1)) \t\t  \\\n+\t     : 1))\n+\n+/* TODO: For now lets not support index addressing mode.  */\n+#define REGNO_OK_FOR_INDEX_P(REGNO)        \\\n+  (((REGNO >= CR16_FIRST_DWORD_REGISTER)   \\\n+     && ((REGNO) < FIRST_PSEUDO_REGISTER)) \\\n+   || (reg_renumber                        \\\n+       && (((unsigned) reg_renumber[REGNO] >= CR16_FIRST_DWORD_REGISTER)  \\\n+            && ((unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER))) \\\n+  )\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS\n+\n+/* The maximum number of consecutive registers of class CLASS needed to\n+   hold a value of mode MODE.\n+   On the CompactRISC architecture, the size of MODE in words.\n+   The size of MODE in double words for the class LONG_REGS.\n+\n+   The following check assumes if the class is not LONG_REGS, then\n+   all (NO_REGS, SHORT_REGS, NOSP_REGS and GENERAL_REGS) other classes are \n+   short.  We may have to check if this can cause any degradation in \n+   performance.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  (CLASS == LONG_REGS \\\n+   ? (GET_MODE_SIZE (MODE) + CR16_UNITS_PER_DWORD - 1) / CR16_UNITS_PER_DWORD\\\n+   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Macros to check the range of integers . These macros were used across\n+   the port, majorly in constraints.md, predicates.md files. */\n+#define SIGNED_INT_FITS_N_BITS(imm, N)           \\\n+  ((((imm) < ((HOST_WIDE_INT) 1 << ((N) - 1)))       \\\n+      && ((imm) >= -((HOST_WIDE_INT) 1 << ((N) - 1)))) ? 1 : 0)\n+\n+#define UNSIGNED_INT_FITS_N_BITS(imm, N) \\\n+  (((imm) < ((HOST_WIDE_INT) 1 << (N)) && (imm) >= (HOST_WIDE_INT) 0) ? 1 : 0)\n+\n+#define IN_RANGE_P(VALUE, LOW, HIGH)                            \\\n+  ((((HOST_WIDE_INT)(VALUE)) >= (HOST_WIDE_INT)(LOW))           \\\n+   && (((HOST_WIDE_INT)(VALUE)) <= ((HOST_WIDE_INT)(HIGH))))\n+\n+#define IN_RAN(VALUE, LOW, HIGH)                             \\\n+  (((((HOST_WIDE_INT)(VALUE)) >= (HOST_WIDE_INT)(LOW))       \\\n+   && (((HOST_WIDE_INT)(VALUE)) <= ((HOST_WIDE_INT)(HIGH)))) ? 1 : 0)\n+\n+/* This check is for sbit/cbit instruction.  */\n+#define OK_FOR_Z(OP) \\\n+  ((GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST_INT) \\\n+   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG) \\\n+   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == PLUS \\\n+       && GET_CODE (XEXP ((XEXP (OP, 0)), 0)) == REG \\\n+       && GET_CODE (XEXP ((XEXP (OP, 0)), 1)) == CONST_INT))\n+\n+/* Stack layout and calling conventions.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+#define STARTING_FRAME_OFFSET   0\n+\n+#define STACK_POINTER_REGNUM    15\n+\n+#define FRAME_POINTER_REGNUM    13\n+\n+#define ARG_POINTER_REGNUM      12\n+\n+#define STATIC_CHAIN_REGNUM     1\n+\n+#define RETURN_ADDRESS_REGNUM   14\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define ELIMINABLE_REGS                            \\\n+  {                                                \\\n+    { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM}, \\\n+    { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM}, \\\n+    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}  \\\n+  }\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)              \\\n+  do                                                              \\\n+    {                                                             \\\n+      (OFFSET) = cr16_initial_elimination_offset ((FROM), (TO));  \\\n+    }                                                             \\\n+  while (0)\n+\n+/* Passing function arguments.  */\n+\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+\n+#define PUSH_ARGS 1\n+\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)\n+\n+#ifndef CUMULATIVE_ARGS\n+struct cumulative_args\n+{\n+  int ints;\n+  int last_parm_in_reg;\n+};\n+\n+#define CUMULATIVE_ARGS struct cumulative_args\n+#endif\n+\n+/* On the CR16 architecture, Varargs routines should receive their parameters \n+   on the stack.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n+  cr16_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME))\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)  cr16_function_arg_regno_p (REGNO)\n+\n+/* Generating code for profiling - NOT IMPLEMENTED.  */\n+#undef  FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(STREAM, LABELNO)      \\\n+{                                               \\\n+  sorry (\"profiler support for CR16\");          \\\n+}\n+\n+/* Trampolines for nested functions - NOT SUPPORTED.  */\n+#define TRAMPOLINE_SIZE    16\n+\n+/* ADDRESSING MODES.  */\n+\n+#define CONSTANT_ADDRESS_P(X)       \\\n+  (GET_CODE (X) == LABEL_REF        \\\n+   || GET_CODE (X) == SYMBOL_REF    \\\n+   || GET_CODE (X) == CONST         \\\n+   || GET_CODE (X) == CONST_INT)\n+\n+#define MAX_REGS_PER_ADDRESS    2\n+\n+#define HAVE_POST_INCREMENT     0\n+#define HAVE_POST_DECREMENT     0\n+#define HAVE_POST_MODIFY_DISP   0\n+#define HAVE_POST_MODIFY_REG    0\n+\n+#ifdef REG_OK_STRICT\n+#define CR16_REG_OK_FOR_BASE_P(X)\tCR16_REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE)\t\\\n+  REGNO_MODE_OK_FOR_BASE_P (REGNO(X), MODE)\n+#define REG_OK_FOR_INDEX_P(X)   REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#else /* not REG_OK_STRICT.  */\n+#define CR16_REG_OK_FOR_BASE_P(X)\t1\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE)\t1\n+#define REG_OK_FOR_INDEX_P(X)   1\n+#endif /* not REG_OK_STRICT.  */\n+\n+/* Go to LABEL if ADDR (a legitimate address expression) has \n+   an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+/* Assume best case (branch predicted).  */\n+#define BRANCH_COST(speed_p, predictable_p)       2\n+\n+#define SLOW_BYTE_ACCESS  1\n+\n+/* It is as good or better to call a constant function address than to\n+   call an address kept in a register.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Dividing the output into sections.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP \"\\t.section\\t.data\"\n+\n+#define BSS_SECTION_ASM_OP  \"\\t.section\\t.bss\"\n+\n+/* Position independent code (PIC).  */\n+/* NEAR_PIC for -fpic option.  */\n+\n+#define NEAR_PIC 1\n+                                      \n+/* FAR_PIC for -fPIC option.  */                                                                                       \n+\n+#define FAR_PIC  2\n+\n+#define PIC_OFFSET_TABLE_REGNUM  12\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)       \n+\n+/* Assembler format.  */\n+\n+/* Character to start a comment.  */\n+#define ASM_COMMENT_START \"#\"\n+\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  asm_fprintf (STREAM, \"%U%s\", (*targetm.strip_name_encoding) (NAME));\n+\n+#define ASM_OUTPUT_SYMBOL_REF(STREAM, SYMBOL)   \\\n+  do                                            \\\n+    {                                           \\\n+      const char *rn = XSTR (SYMBOL, 0);        \\\n+      assemble_name (STREAM, rn);               \\\n+      if (SYMBOL_REF_FUNCTION_P (SYMBOL))       \\\n+      {                                         \\\n+        fprintf ((STREAM), \"@c\");               \\\n+      }                                         \\\n+    }                                           \\\n+  while (0)\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON   \"#APP\\n\"\n+\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF  \"#NO_APP\\n\"\n+\n+/* Switch into a generic section.  */\n+#define TARGET_ASM_NAMED_SECTION\tdefault_elf_asm_named_section\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\t\t\"\\t.section\\t.init\"\n+\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP\t\t\"\\t.section\\t.fini\"\n+\n+/* Instruction output.  */\n+\n+#define REGISTER_NAMES                                     \\\n+  {                                                        \\\n+    \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \\\n+    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"ra\",  \"sp\"  \\\n+  }\n+\n+/* Output of dispatch tables.  */\n+\n+/* Revisit. No PC relative case as label expressions are not \n+   properly supported in binutils else we could have done this:\n+   #define CASE_VECTOR_PC_RELATIVE (optimize_size ? 1 : 0).  */\n+#define CASE_VECTOR_PC_RELATIVE 0\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)    \\\n+  ((GET_MODE (BODY) == QImode)                              \\\n+   ? fprintf ((FILE), \"\\t.byte (.L%d-.L%d) >> 1\\n\",         \\\n+              VALUE, REL)                                   \\\n+   : fprintf ((FILE), \"\\t.word (.L%d-.L%d) >> 1\\n\",         \\\n+              VALUE, REL))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+  asm_fprintf ((STREAM), \"\\t.long\\t.L%d@c\\n\", (VALUE))\n+\n+/* Alignment in assembler file.  */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n+  asm_fprintf ((STREAM), \"\\t.align\\t%d\\n\", 1 << (POWER))\n+\n+/* Miscellaneous parameters.  */\n+\n+#define CASE_VECTOR_MODE  Pmode\n+\n+#define MOVE_MAX 4\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n+\n+#define STORE_FLAG_VALUE  1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE QImode\n+\n+/* Define this boolean macro(s) to indicate whether or not your architecture\n+   has (un)conditional branches that can span all of memory.  It is used in\n+   conjunction with an optimization that partitions hot and cold basic blocks\n+   into separate sections of the executable.\n+   CR16 contains branch instructions that span whole address space.  */\n+#define HAS_LONG_COND_BRANCH    1\n+#define HAS_LONG_UNCOND_BRANCH  1\n+\n+#endif /* End of GCC_CR16_H.  */"}, {"sha": "5e4530c32ceb88a21957e7ba85a760011ae910f8", "filename": "gcc/config/cr16/cr16.md", "status": "added", "additions": 1084, "deletions": 0, "changes": 1084, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.md?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,1084 @@\n+;; GCC machine description for CR16.\n+;; Copyright (C) 2012 Free Software Foundation, Inc.\n+;; Contributed by KPIT Cummins Infosystems Limited.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>. \n+\n+;;  Register numbers\n+(define_constants\n+  [(SP_REGNUM 15); Stack pointer\n+   (RA_REGNUM 14); Return address\n+  ]\n+)\n+\n+;; Predicates & Constraints\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;; UNSPEC usage\n+(define_constants\n+  [(UNSPEC_PIC_ADDR             0)\n+   (UNSPEC_PIC_LOAD_ADDR        1)\n+   (UNSPEC_LIBRARY_OFFSET       2)\n+   (UNSPEC_SH_LIB_PUSH_R12      3)\n+   (UNSPEC_SH_LIB_POP_R12       4)\n+   (UNSPEC_RETURN_ADDR          5)\n+  ]\n+)\n+\n+;; Attributes\n+(define_attr \"length\" \"\" (const_int 2))\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Mode Macro Definitions\n+(define_mode_iterator CR16IM [QI HI SI])\n+(define_mode_iterator LONG   [SI SF])\n+(define_mode_iterator ALLMTD [QI HI SI SF DI DF])\n+(define_mode_iterator DOUBLE [DI DF])\n+(define_mode_iterator SHORT  [QI HI])\n+(define_mode_attr tIsa       [(QI \"b\") (HI \"w\") (SI \"d\") (SF \"d\")])\n+(define_mode_attr lImmArith  [(QI \"4\") (HI \"4\") (SI \"6\") (SF \"6\")])\n+(define_mode_attr lImmArithD [(QI \"4\") (HI \"4\") (SI \"6\") (SF \"6\") (DI \"12\") (DF \"12\")])\n+(define_mode_attr iF         [(QI \"i\") (HI \"i\") (SI \"i\") (SF \"F\")])\n+(define_mode_attr iFD        [(DI \"i\") (DF \"F\")])\n+(define_mode_attr LL         [(QI \"L\") (HI \"L\")])\n+(define_mode_attr shImmBits  [(QI \"3\") (HI \"4\") (SI \"5\")])\n+\n+; In QI mode we push 2 bytes instead of 1 byte.\n+(define_mode_attr pushCnstr [(QI \"X\") (HI \"<\") (SI \"<\") (SF \"<\") (DI \"<\") (DF \"<\")])\n+\n+; tpush will be used to generate the 'number of registers to push' in the \n+; push instruction.\n+(define_mode_attr tpush [(QI \"1\") (HI \"1\") (SI \"2\") (SF \"2\") (DI \"4\") (DF \"4\")])\n+\n+;;  Code Macro Definitions\n+(define_code_attr  sIsa    [(sign_extend \"\")  (zero_extend \"u\")])\n+(define_code_attr  sPat    [(sign_extend \"s\") (zero_extend \"u\")])\n+(define_code_attr  szPat   [(sign_extend \"\")  (zero_extend \"zero_\")])\n+(define_code_attr  szIsa   [(sign_extend \"x\") (zero_extend \"z\")])\n+\n+(define_code_iterator sz_xtnd    [ sign_extend       zero_extend])\n+(define_code_iterator any_cond   [eq ne gt gtu lt ltu ge geu le leu])\n+(define_code_iterator plusminus  [plus minus])\n+\n+(define_code_attr plusminus_insn [(plus \"add\") (minus \"sub\")])\n+(define_code_attr plusminus_flag [(plus \"PLUS\") (minus \"MINUS\")])\n+(define_code_attr comm \t\t [(plus \"%\") (minus \"\")])\n+\n+(define_code_iterator any_logic  [and ior xor])\n+(define_code_attr logic \t [(and \"and\") (ior \"or\") (xor \"xor\")])\n+(define_code_attr any_logic_insn [(and \"and\") (ior \"ior\") (xor \"xor\")])\n+(define_code_attr any_logic_flag [(and \"AND\") (ior \"IOR\") (xor \"XOR\")])\n+\n+(define_mode_iterator QH \t [QI HI])\n+(define_mode_attr qh \t\t [(QI \"qi\") (HI \"hi\")])\n+(define_mode_attr QHsz \t\t [(QI \"2,2,2\") (HI \"2,2,4\")])\n+(define_mode_attr QHsuffix \t [(QI \"b\") (HI \"w\")])\n+\n+\n+;;  Function Prologue and Epilogue\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  {\n+    cr16_expand_prologue ();\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"push_for_prologue\"\n+  [(set (reg:SI SP_REGNUM)\n+\t(minus:SI (reg:SI SP_REGNUM)\n+\t\t  (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n+  \"reload_completed\"\n+  {\n+    return cr16_prepare_push_pop_string (0);\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  {\n+    cr16_expand_epilogue ();\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"pop_and_popret_return\"\n+  [(set (reg:SI SP_REGNUM)\n+\t(plus:SI (reg:SI SP_REGNUM)\n+\t\t (match_operand:SI 0 \"immediate_operand\" \"i\")))\n+   (use (reg:SI RA_REGNUM))\n+   (return)]\n+  \"reload_completed\"\n+  {\n+    return cr16_prepare_push_pop_string (1);\n+  }\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"popret_RA_return\"\n+  [(use (reg:SI RA_REGNUM))\n+   (return)]\n+  \"reload_completed\"\n+  \"popret\\tra\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;; Arithmetic Instuction  Patterns\n+\n+;; Addition-Subtraction \"adddi3/subdi3\" insns.\n+(define_insn \"<plusminus_insn>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plusminus:DI (match_operand:DI 1 \"register_operand\" \"<comm>0\")\n+\t\t      (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  {\n+    return cr16_emit_add_sub_di (operands, <plusminus_flag>);\n+  })\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t (match_operand:SI 2 \"reg_si_int_operand\" \"r,M,N,O,i\")))]\n+  \"\"\n+  \"addd\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2,4,4,6\")]\n+)\n+\n+;; Addition-Subtraction \"addhi3/subhi3\" insns.\n+(define_insn \"<plusminus_insn>hi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c,c,c\")\n+\t(plusminus:HI (match_operand:HI 1 \"register_operand\" \"<comm>0,0,0\")\n+\t\t      (match_operand:HI 2 \"reg_hi_int_operand\" \"c,M,N\")))]\n+  \"\"\n+  \"<plusminus_insn>w\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2,4\")]\n+)\n+\n+;; Addition-Subtraction \"addqi3/subqi3\" insns.\n+(define_insn \"<plusminus_insn>qi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c,c\")\n+\t(plusminus:QI (match_operand:QI 1 \"register_operand\" \"<comm>0,0\")\n+\t\t      (match_operand:QI 2 \"reg_qi_int_operand\" \"c,M\")))]\n+  \"\"\n+  \"<plusminus_insn>b\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2\")]\n+)\n+\n+;;  Subtract Instruction\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:SI 2 \"reg_si_int_operand\" \"r,i\")))]\n+  \"\"\n+  \"subd\\t%2, %0\"\n+  [(set_attr \"length\" \"4,6\")]\n+)\n+\n+;;  Multiply and Accumulate Instructions \"smachisi3/umachisi3\"\n+(define_insn \"<sPat>maddhisi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI\n+\t(mult:SI (sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (sz_xtnd:SI (match_operand:HI 2 \"register_operand\" \"r\")))\n+\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"TARGET_MAC\"\n+  \"mac<sPat>w\\t%1, %2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Multiply Instructions\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c,c,c\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t (match_operand:HI 2 \"reg_or_int_operand\" \"c,M,N\")))]\n+  \"\"\n+  \"mulw\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2,4\")]\n+)\n+\n+(define_insn \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"c\"))))]\n+  \"\"\n+  \"mulsb\\t%2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Bit Set/Clear Instructions\n+(define_expand \"insv\"\n+  [(set (zero_extract (match_operand 0 \"memory_operand\" \"\")\n+\t\t      (match_operand 1 \"immediate_operand\" \"\")\n+\t\t      (match_operand 2 \"immediate_operand\" \"\"))\n+\t(match_operand 3 \"immediate_operand\" \"\"))]\n+  \"TARGET_BIT_OPS\"\n+  {\n+    if (INTVAL (operands[1]) != 1)\n+      FAIL;\n+    if (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 15)\n+      FAIL;\n+    if (INTVAL (operands[3]) == 1)\n+      {\n+\tif (GET_MODE (operands[0]) == QImode)\n+\t  {\n+\t    emit_insn (gen_set_bitqi (operands[0], operands[2]));\n+\t    DONE;\n+\t  }\n+\telse if (GET_MODE (operands[0]) == HImode)\n+\t  {\n+\t    emit_insn (gen_set_bithi (operands[0], operands[2]));\n+\t    DONE;\n+\t  }\n+      }\n+    if (INTVAL (operands[3]) == 0)\n+      {\n+\tif (GET_MODE (operands[0]) == QImode)\n+\t  {\n+\t    emit_insn (gen_clr_bitqi (operands[0], operands[2]));\n+\t    DONE;\n+\t  }\n+\telse if (GET_MODE (operands[0]) == HImode)\n+\t  {\n+\t    emit_insn (gen_clr_bithi (operands[0], operands[2]));\n+\t    DONE;\n+\t  }\n+      }\n+  }\n+)\n+\n+(define_insn \"set_bit<mode>\"\n+  [(set (zero_extract:SHORT (match_operand:SHORT 0 \"memory_operand\" \"+m\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand 1 \"immediate_operand\" \"i\"))\n+\t(const_int 1))]\n+  \"TARGET_BIT_OPS\"\n+  \"sbit<tIsa>\\t%1,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"clr_bit<mode>\"\n+  [(set (zero_extract:SHORT (match_operand:SHORT 0 \"memory_operand\" \"+m\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand 1 \"immediate_operand\" \"i\"))\n+\t(const_int 0))]\n+  \"TARGET_BIT_OPS\"\n+  \"cbit<tIsa>\\t%1,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"set_bit<mode>_mem\"\n+  [(set (match_operand:SHORT 0 \"bit_operand\" \"=m\")\n+\t(ior:SHORT (match_dup 0)\n+\t\t   (match_operand:SHORT 1 \"one_bit_operand\" \"i\"))\n+  )]\n+  \"TARGET_BIT_OPS\"\n+  \"sbit<tIsa>\\t$%s1,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"clear_bit<mode>_mem\"\n+  [(set (match_operand:SHORT 0 \"bit_operand\" \"=m\")\n+\t(and:SHORT (match_dup 0)\n+\t\t   (match_operand:SHORT 1 \"rev_one_bit_operand\" \"i\"))\n+  )]\n+  \"TARGET_BIT_OPS\"\n+  \"cbit<tIsa>\\t$%r1,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Logical Instructions - and/ior/xor \"anddi3/iordi3/xordi3\"\n+(define_insn \"<any_logic_insn>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(any_logic:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t      (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  {\n+    return cr16_emit_logical_di (operands, <any_logic_flag>);\n+  })\n+\n+; Logical and/ior/xor \"andsi3/iorsi3/xorsi3\"\n+(define_insn \"<any_logic_insn>si3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(any_logic:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t      (match_operand:SI 2 \"reg_si_int_operand\" \"r,M,N,i\")))]\n+  \"\"\n+  \"<logic>d\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2,4,6\")]\n+)\n+\n+; Logical and/ior/xor in HImode \"andhi3/iorhi3/xorhi3\"\n+; Logical and/ior/xor in QImode \"andqi3/iorqi3/xorqi3\"\n+(define_insn \"<any_logic_insn><qh>3\"\n+  [(set (match_operand:QH 0 \"register_operand\" \"=c,c,c\")\n+\t(any_logic:QH (match_operand:QH 1 \"register_operand\" \"%0,0,0\")\n+\t\t      (match_operand:QH 2 \"reg_hi_int_operand\" \"c,M,N\")))]\n+  \"\"\n+  \"<logic><QHsuffix>\\t%2, %0\"\n+  [(set_attr \"length\" \"<QHsz>\")]\n+)\n+\n+;;  Sign and Zero Extend Instructions\n+(define_insn \"<szPat>extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mov<szIsa>w\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"<szPat>extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mov<szIsa>b\\t%1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;;  One's Complement\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  {\n+    rtx xoperand ;\n+    int reg0 = REGNO (operands[0]);\n+\n+    xoperand = gen_rtx_REG (SImode, reg0 + 2);\n+    output_asm_insn (\"xord\\t$-1, %0\", operands);\n+    output_asm_insn (\"xord\\t$-1, %0\", &xoperand);\n+    return \"\" ;\n+  }\n+  [(set_attr \"length\" \"12\")]\n+)\n+\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:CR16IM 0 \"register_operand\" \"=r\")\n+\t(not:CR16IM (match_operand:CR16IM 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"xor<tIsa>\\t$-1, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Arithmetic Left and Right Shift Instructions\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c,c\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"c,I\")))]\n+  \"\"\n+  \"ashub\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2\")]\n+)\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c,c\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"c,J\")))]\n+  \"\"\n+  \"ashuw\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2\")]\n+)\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"r,K\")))]\n+  \"\"\n+  \"ashud\\t%2, %0\"\n+  [(set_attr \"length\" \"2,2\")]\n+)\n+\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:CR16IM 0 \"register_operand\" \"\")\n+\t(ashiftrt:CR16IM (match_operand:CR16IM 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_CODE (operands[2]) == CONST_INT)\n+      {\n+\t/* If the constant is not in range, try placing it in a reg */\n+\tif (!UNSIGNED_INT_FITS_N_BITS(INTVAL (operands[2]),<shImmBits>))\n+\toperands[2] = copy_to_mode_reg(QImode, operands[2]);\n+      }\n+\n+    if (GET_CODE (operands[2]) != CONST_INT)\n+      operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n+  }\n+)\n+\n+(define_insn \"ashrqi3_imm_insn\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_qi_imm_operand\" \"i\")))]\n+  \"\"\n+  \"ashub\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"ashrhi3_imm_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_hi_imm_operand\" \"i\")))]\n+  \"\"\n+  \"ashuw\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"ashrsi3_imm_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_si_imm_operand\" \"i\")))]\n+  \"\"\n+  \"ashud\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"ashrqi3_neg_insn\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"c\"))))]\n+  \"\"\n+  \"ashub\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"ashrhi3_neg_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"c\"))))]\n+  \"\"\n+  \"ashuw\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"ashrdi3_neg_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"ashud\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:CR16IM 0 \"register_operand\" \"\")\n+\t(lshiftrt:CR16IM (match_operand:CR16IM 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:QI 2 \"reg_or_int_operand\" \"\")))]\n+  \"\"\n+  {\n+    if (GET_CODE (operands[2]) == CONST_INT)\n+      {\n+\t/* If the constant is not in range, try placing it in a reg */\n+\tif (!UNSIGNED_INT_FITS_N_BITS(INTVAL (operands[2]),<shImmBits>))\n+\toperands[2] = copy_to_mode_reg(QImode, operands[2]);\n+      }\n+\n+\tif (GET_CODE (operands[2]) != CONST_INT)\n+\toperands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n+   }\n+)\n+\n+(define_insn \"lshrqi3_imm_insn\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_qi_operand\" \"Q\")))]\n+  \"\"\n+  \"lshb\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"lshrhi3_imm_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_hi_operand\" \"R\")))]\n+  \"\"\n+  \"lshw\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"lshrsi3_imm_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"shift_si_operand\" \"S\")))]\n+  \"\"\n+  \"lshd\\t$%n2, %0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"lshrqi3_neg_insn\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=c\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"c\"))))]\n+  \"\"\n+  \"lshb\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"lshrhi3_neg_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=c\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"c\"))))]\n+  \"\"\n+  \"lshw\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"lshrsi3_neg_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"lshd\\t%2,%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Move Instructions\n+\n+;; Move any non-immediate operand 0 to a general operand 1.\n+;; This applies only before starting the reload process\n+;; Operand 0 is not a register operand of type mode MODE\n+;; If Operand 0 is a push operand of type mode MODE\n+;; then, if Operand 1 is a non-SP register\n+;; then, Operand 1 = copy_to_mode_reg (<MODE>mode, Operand 1)\n+;; endif\n+;; else\n+;; if Operand 1 is either register or 4-bit immediate constant\n+;; then, Operand 1 = copy_to_mode_reg (<MODE>mode, Operand 1)\n+;; endif\n+;; endif\n+;;\n+;; What does copy_to_mode_reg (mode, rtx val) do?\n+;; Copy the value into new temp reg and return the reg where the\n+;; mode of the new reg is always mode MODE when value is constant\n+;;\n+;; Why should copy_to_mode_reg be called?\n+;; All sorts of move are nor supported by CR16. Therefore, \n+;; when unsupported move is encountered, the additional instructions \n+;; will be introduced for the purpose.\n+;;\n+;; A new move insn is inserted for Op 1 when one of the following\n+;; conditions is met.\n+;; Case 1:  Op 0 is push_operand\n+;;          Op 1 is SP register\n+;;\n+;; Case 2:  Op 0 is not push_operand\n+;;          Op 1 is neither register nor unsigned 4-bit immediate\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:ALLMTD 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:ALLMTD 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (!(reload_in_progress || reload_completed))\n+      {\n+\t/* Only if Op0 is a register operand.  */\n+\tif (!register_operand (operands[0], <MODE>mode))\n+\t  {\n+\t    if (push_operand (operands[0], <MODE>mode)) \n+\t      {\n+\t\t/* Use copy_to_mode_reg only if the register needs \n+\t\tto be pushed is SP as CR16 does not support pushing SP.  */\n+\t\tif (!nosp_reg_operand (operands[1], <MODE>mode))\n+\t\t  operands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Use copy_to_mode_reg if op1 is not register operand\n+\t\t   subject to conditions inside.  */\n+\t\tif (!register_operand (operands[1], <MODE>mode))\n+\t\t  {\n+\t\t    /* CR16 does not support moving immediate to SI or SF \n+\t\t       type memory.  */\n+\t\t    if (<MODE>mode == SImode || <MODE>mode == SFmode ||\n+\t\t\t<MODE>mode == DImode || <MODE>mode == DFmode)\n+\t\t      operands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+\t\t    else\n+\t\t      /* moving imm4 is supported by CR16 instruction.  */\n+\t\t      if (!u4bits_operand (operands[1], <MODE>mode))\n+\t\t\toperands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+\t\t  }\n+\t       }\n+\t  }\n+\n+\t  /* If operand-1 is a symbol, convert it into a BRO or GOT Format.  */\n+\t  if (flag_pic && ! legitimate_pic_operand_p (operands[1]))\n+\t    {\n+\t      operands[1] = legitimize_pic_address (operands[1], <MODE>mode, 0);\n+\t    }\n+      }\n+  }\n+)\n+\n+; ALLMT     : QI,HI,SI,SF\n+; pushCnstr : Push constraints \n+;                QI : X\n+;             HI,SI,SF,DI,DF : <\n+; b         : All non-sp registers\n+; tpush     : Push count\n+;                QI,HI : 1\n+;                SI,SF : 2\n+;                DI,DF : 4\n+(define_insn \"push<mode>_internal\"\n+  [(set (match_operand:ALLMTD 0 \"push_operand\" \"=<pushCnstr>\")\n+\t(match_operand:ALLMTD 1 \"nosp_reg_operand\" \"b\"))]\n+  \"\"\n+  \"push\\t$<tpush>,%p1\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+; (DI, DF) move\n+(define_insn \"*mov<mode>_double\"\n+  [(set (match_operand:DOUBLE 0 \"nonimmediate_operand\" \"=r, r, r, m\")\n+\t(match_operand:DOUBLE 1 \"general_operand\" \"r, <iFD>, m, r\"))]\n+  \"register_operand (operands[0], DImode) \n+   || register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DImode)\n+   || register_operand (operands[1], DFmode)\"\n+  {\n+    if (0 == which_alternative) {\n+      rtx xoperands[2] ;\n+      int reg0 = REGNO (operands[0]);\n+      int reg1 = REGNO (operands[1]);\n+\n+      xoperands[0] = gen_rtx_REG (SImode, reg0 + 2);\n+      xoperands[1] = gen_rtx_REG (SImode, reg1 + 2);\n+      if ((reg1 + 2) != reg0)\n+\t{\n+\t  output_asm_insn (\"movd\\t%1, %0\", operands);\n+\t  output_asm_insn (\"movd\\t%1, %0\", xoperands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"movd\\t%1, %0\", xoperands);\n+\t  output_asm_insn (\"movd\\t%1, %0\", operands);\n+\t}}\n+\n+    else if (1 == which_alternative) {\n+      rtx lo_operands[2] ;\n+      rtx hi_operands[2] ;\n+\n+      lo_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+      hi_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n+      lo_operands[1] = simplify_gen_subreg (SImode, operands[1],\n+\t\t       VOIDmode == GET_MODE (operands[1])\n+\t\t       ? DImode  : GET_MODE (operands[1]), 0);\n+      hi_operands[1] = simplify_gen_subreg (SImode, operands[1],\n+\t\t       VOIDmode == GET_MODE (operands[1])\n+\t\t       ? DImode  : GET_MODE (operands[1]), 4);\n+      output_asm_insn (\"movd\\t%1, %0\", lo_operands);\n+      output_asm_insn (\"movd\\t%1, %0\", hi_operands);}\n+\n+    else if (2 == which_alternative) {\n+      rtx xoperands[2] ;\n+      int reg0 = REGNO (operands[0]), reg1 = -2 ;\n+      rtx addr ;\n+\n+\tif (MEM_P (operands[1]))\n+\t  addr = XEXP (operands[1], 0);\n+\telse\n+\t  addr = NULL_RTX ;\n+\tswitch (GET_CODE (addr))\n+\t  {\n+\t    case REG:\n+\t    case SUBREG:\n+\t      reg1 = REGNO (addr);\n+\t      break ;\n+\t    case PLUS:\n+\t      switch (GET_CODE (XEXP (addr, 0))) {\n+\t\tcase REG:\n+\t\tcase SUBREG:\n+\t\t  reg1 = REGNO (XEXP (addr, 0));\n+\t\t  break ;\n+\t\tcase PLUS:\n+\t\t  reg1 = REGNO (XEXP (XEXP (addr, 0), 0));\n+\t\t  break ;\n+\t\tdefault:\n+\t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"unexpected expression; addr:\");\n+\t\t  debug_rtx (addr);\n+\t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"operands[1]:\");\n+\t\t  debug_rtx (operands[1]);\n+\t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"generated code might now work\\n\");\n+\t\t  break ;}\n+\t      break ;\n+\t    default:\n+\t      break ;\n+\t  }\n+\n+\txoperands[0] = gen_rtx_REG (SImode, reg0 + 2);\n+\txoperands[1] = offset_address (operands[1], GEN_INT (4), 2);\n+\tgcc_assert ((reg0 + 1) != reg1);\n+\tif (reg0 != reg1  &&  (reg1 + 1) != reg0)\n+\t  {\n+\t    output_asm_insn (\"loadd\\t%1, %0\", operands);\n+\t    output_asm_insn (\"loadd\\t%1, %0\", xoperands);\n+\t  }\n+\telse\n+\t  {\n+\t    output_asm_insn (\"loadd\\t%1, %0\", xoperands);\n+\t    output_asm_insn (\"loadd\\t%1, %0\", operands);\n+\t  }}\n+    else\n+      {\n+\trtx xoperands[2] ;\n+\txoperands[0] = offset_address (operands[0], GEN_INT (4), 2);\n+\txoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n+\toutput_asm_insn (\"stord\\t%1, %0\", operands);\n+   \toutput_asm_insn (\"stord\\t%1, %0\", xoperands);\n+      }\n+    return \"\" ;\n+  }\n+  [(set_attr \"length\" \"4, <lImmArithD>, <lImmArithD>, <lImmArithD>\")]\n+)\n+\n+; All long (SI, SF) register move, load and store operations\n+; The print_operand will take care of printing the register pair \n+; when mode is SI/SF and register is in SHORT_REGS\n+(define_insn \"*mov<mode>_long\"\n+  [(set (match_operand:LONG 0 \"nonimmediate_operand\" \"=r, r, r, m\")\n+\t(match_operand:LONG 1 \"general_operand\" \"r, <iF>, m, r\"))]\n+  \"register_operand (operands[0], <MODE>mode)\n+   || register_operand (operands[1], <MODE>mode)\"\n+  \"@\n+  mov<tIsa>\\t%1, %0\n+  mov<tIsa>\\t%1, %0\n+  load<tIsa>\\t%1, %0\n+  stor<tIsa>\\t%1, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>,<lImmArith>,<lImmArith>\")]\n+)\n+\n+;; All short (QI, HI) register move, load and store operations\n+(define_insn \"*mov<mode>_short\"\n+  [(set (match_operand:SHORT 0 \"nonimmediate_operand\" \"=r, r, r, m, m\")\n+\t(match_operand:SHORT 1 \"general_operand\" \"r, <iF>, m, r, <LL>\"))]\n+  \"(register_operand (operands[0], <MODE>mode))\n+    || (store_operand (operands[0], <MODE>mode)\n+\t&& (register_operand (operands[1], <MODE>mode)\n+\t    || u4bits_operand (operands[1], <MODE>mode)))\"\n+  \"@\n+  mov<tIsa>\\t%1, %0\n+  mov<tIsa>\\t%1, %0\n+  load<tIsa>\\t%1, %0\n+  stor<tIsa>\\t%1, %0\n+  stor<tIsa>\\t%1, %0\"\n+  [(set_attr \"length\" \"2,<lImmArith>,<lImmArith>,<lImmArith>,<lImmArith>\")]\n+)\n+\n+;;  Compare Instructions\n+; Instruction generated compares the operands in reverse order\n+; Therefore, while printing the asm, the reverse of the\n+; compare condition shall be printed.\n+(define_insn \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+\t\t      [(match_operand:CR16IM 1 \"register_operand\" \"r,r\")\n+\t\t       (match_operand:CR16IM 2 \"nonmemory_operand\" \"r,n\")])\n+\t\t       (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))\n+   (clobber (cc0))]\n+  \"\"\n+  \"cmp<tIsa>\\t%2, %1\\;b%d0\\t%l3\"\n+  [(set_attr \"length\" \"6,6\")]\n+)\n+\n+(define_expand \"cmp<mode>\"\n+  [(parallel [(set (cc0)\n+    (compare (match_operand:CR16IM 0 \"register_operand\" \"\")\n+\t     (match_operand:CR16IM 1 \"nonmemory_operand\" \"\")))\n+    (clobber (match_scratch:HI 2 \"=r\"))] ) ]\n+  \"\"\n+  \"\")\n+\n+;;  Scond Instructions\n+(define_expand \"cstore<mode>4\"\n+  [(set (cc0)\n+\t(compare (match_operand:CR16IM 2 \"register_operand\" \"\")\n+\t\t (match_operand:CR16IM 3 \"nonmemory_operand\" \"\")))\n+   (set (match_operand:HI 0 \"register_operand\")\n+\t(match_operator:HI 1 \"ordered_comparison_operator\"\n+\t[(cc0) (const_int 0)]))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"*cmp<mode>_insn\"\n+  [(set (cc0)\n+\t(compare (match_operand:CR16IM 0 \"register_operand\" \"r,r\")\n+\t\t (match_operand:CR16IM 1 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"cmp<tIsa>\\t%1, %0\"\n+  [(set_attr \"length\" \"2,4\")]\n+)\n+\n+(define_insn \"sCOND_internal\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operator:HI 1 \"ordered_comparison_operator\"\n+\t[(cc0) (const_int 0)]))]\n+  \"\"\n+  \"s%d1\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Jumps and Branches\n+(define_insn \"indirect_jump_return\"\n+  [(set (pc)\n+\t  (reg:SI RA_REGNUM))\n+   (return)]\n+  \"reload_completed\"\n+  \"jump\\t (ra)\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"jump_return\"\n+  [(unspec:SI [(const_int 0)] UNSPEC_RETURN_ADDR)\n+   (return)]\n+  \"reload_completed\"\n+  \"jump\\t(ra)\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"reg_or_sym_operand\" \"r,i\"))]\n+  \"\"\n+  \"@\n+  jump\\t%0\n+  br\\t%a0\"\n+  [(set_attr \"length\" \"2,6\")]\n+)\n+\n+(define_insn \"interrupt_return\"\n+  [(unspec_volatile [(const_int 0)] 0)\n+   (return)]\n+  \"\"\n+  {\n+    return cr16_prepare_push_pop_string (1);\n+  }\n+  [(set_attr \"length\" \"14\")]\n+)\n+\n+(define_insn \"jump_to_imm\"\n+  [(set (pc)\n+\t(match_operand 0 \"jump_imm_operand\" \"i\"))]\n+  \"\"\n+  \"br\\t%c0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"br\\t%l0\"\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+;;  Table Jump\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref:SI (match_operand 1 \"\" \"\")))]\n+  \"!flag_pic\"\n+  \"jump\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Call Instructions\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  {\n+    if (flag_pic && ! legitimate_pic_operand_p (operands[0]))\n+      {\n+\toperands[0] = gen_const_mem (QImode,\n+\tlegitimize_pic_address (XEXP (operands[0], 0), Pmode, 0));\n+\temit_call_insn (gen_cr16_call (operands[0], operands[1]));\n+      }\n+    else\n+      emit_call_insn (gen_cr16_call (operands[0], operands[1]));\n+      DONE;\n+  }\n+)\n+\n+(define_expand \"cr16_call\"\n+  [(parallel\n+    [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t   (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI RA_REGNUM))])]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"cr16_call_insn_branch_pic\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_imm_operand\" \"i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n+  \"flag_pic == FAR_PIC\"\n+  {\n+    if (GET_CODE (operands[0]) != CONST_INT)\n+      return \"loadd\\t%g0, %2 \\n\\tjal %2\";\n+    else\n+      return \"jal %2\";\n+  }\n+  [(set_attr \"length\" \"8\")]\n+)\n+\n+(define_insn \"cr16_call_insn_branch\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_imm_operand\" \"i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n+  \"flag_pic == 0 || flag_pic == NEAR_PIC\"\n+  {\n+    /* Print the immediate address for bal \n+       'b' is used instead of 'a' to avoid compiler calling\n+       the GO_IF_LEGITIMATE_ADDRESS which cannot\n+       perform checks on const_int code addresses as it\n+       assumes all const_int are data addresses.\n+    */\n+    if (GET_CODE (operands[0]) != CONST_INT)\n+      return \"bal (ra), %a0\";\n+    else\n+      operands[4] = GEN_INT ((INTVAL (operands[0]))>>1);\n+      return \"movd\\t%g4,\\t(r1,r0)\\n\\tjal\\t(r1,r0)\";\t\n+  }\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+(define_insn \"cr16_call_insn_jump\"\n+  [(call (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jal\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;  Call Value Instructions\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"general_operand\" \"\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  {\n+    if (flag_pic && !legitimate_pic_operand_p (operands[1]))\n+      {\n+\toperands[1] = gen_const_mem (QImode,\n+\tlegitimize_pic_address (XEXP (operands[1], 0), Pmode, 0));\n+\temit_call_insn (gen_cr16_call_value (operands[0], operands[1], operands[2]));\n+      }\n+    else\n+\temit_call_insn (gen_cr16_call_value (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"cr16_call_value\"\n+  [(parallel\n+    [(set (match_operand 0 \"general_operand\" \"\")\n+\t  (call (match_operand 1 \"memory_operand\" \"\")\n+\t\t(match_operand 2 \"\" \"\")))\n+     (clobber (reg:SI RA_REGNUM))])]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"cr16_call_value_insn_branch_pic\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_imm_operand\" \"i\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"flag_pic == FAR_PIC\"\n+  {\n+    if (GET_CODE (operands[1]) != CONST_INT)\n+      return \"loadd\\t%g1, %3 \\n\\tjal %3\";\n+    else\n+      return \"jal %3\";\n+  }\n+  [(set_attr \"length\" \"8\")]\n+)\n+\n+(define_insn \"cr16_call_value_insn_branch\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_imm_operand\" \"i\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"flag_pic == 0 || flag_pic == NEAR_PIC\"\n+  {\n+    /* Print the immediate address for bal \n+       'b' is used instead of 'a' to avoid compiler calling\n+       the GO_IF_LEGITIMATE_ADDRESS which cannot\n+       perform checks on const_int code addresses as it\n+       assumes all const_int are data addresses.\n+    */\n+    if (GET_CODE (operands[1]) != CONST_INT) \n+      return \"bal (ra), %a1\";\n+    else\n+      {\n+\toperands[4] = GEN_INT ((INTVAL (operands[1]))>>1);\n+        return \"movd\\t%g4,\\t(r1,r0)\\n\\tjal\\t(r1,r0)\";\t\n+      }\n+  }\n+  [(set_attr \"length\" \"6\")]\n+)\n+\n+\n+(define_insn \"cr16_call_value_insn_jump\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:QI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n+  \"\"\n+  \"jal\\t%1\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+\n+;;  Nop\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\\t\"\n+)\n+\n+;; PIC\n+/* When generating pic, we need to load the symbol offset into a register.\n+   So that the optimizer does not confuse this with a normal symbol load\n+   we use an unspec.  The offset will be loaded from a constant pool entry,\n+   since that is the only type of relocation we can use.  */\n+                                                                                                                            \n+(define_insn \"unspec_bro_addr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\")] UNSPEC_PIC_ADDR))]\n+  \"\"\n+  \"movd \\t%f1, %0\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"unspec_got_addr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\")] UNSPEC_PIC_LOAD_ADDR))]\n+  \"\"\n+  \"loadd \\t%g1, %0\"\n+  [(set_attr \"length\" \"6\")]\n+)"}, {"sha": "a006b01523a8b61a42b62b73d280aefdae164c05", "filename": "gcc/config/cr16/cr16.opt", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fcr16.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.opt?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,51 @@\n+; Options for the National Semiconductor CR16 port of the compiler.\n+; Copyright (C) 2012 Free Software Foundation, Inc.\n+; Contributed by KPIT Cummins Infosystems Limited.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published\n+; by the Free Software Foundation; either version 3, or (at your\n+; option) any later version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+msim\n+Target\n+-msim   Use simulator runtime\n+\n+mbit-ops\n+Target Report Mask(BIT_OPS)\n+Generate SBIT, CBIT instructions\n+\n+mmac\n+Target Report Mask(MAC)\n+Support multiply accumulate instructions\n+\n+mdebug-addr\n+Target RejectNegative Var(TARGET_DEBUG_ADDR) Undocumented\n+\n+mdata-model=\n+Target RejectNegative JoinedOrMissing Var(cr16_data_model)\n+Treat data references as near, far or medium. medium is default\n+\n+mcr16c\n+Target RejectNegative Mask(CR16C)\n+Generate code for CR16C architecture\n+\n+mcr16cplus\n+Target RejectNegative InverseMask(CR16C,CR16CP)\n+Generate code for CR16C+ architecture (Default)\n+\n+mint32\n+Target RejectNegative Mask(INT32)\n+Treat integers as 32-bit.\n+"}, {"sha": "d399c3393474a78989638f19e7ee62ce06e3d924", "filename": "gcc/config/cr16/predicates.md", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fpredicates.md?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,225 @@\n+;; Predicates of machine description for CR16.\n+;; Copyright (C) 2012 Free Software Foundation, Inc.\n+;; Contributed by KPIT Cummins Infosystems Limited.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  \n+\n+;;  Predicates\n+\n+;; Predicates for sbit/cbit instructions\n+;; bit operand used for the generation of bit insn generation\n+(define_predicate \"bit_operand\"\n+  (match_code \"mem\")\n+{\n+  return ((GET_CODE (op) == MEM && OK_FOR_Z (op)));\n+})\n+\n+;; Unsigned 4-bits constant int or double value.\n+(define_predicate \"u4bits_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return cr16_const_double_ok (op);\n+    return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 4)) ? 1 : 0;\n+})\n+\n+;; Operand is a constant integer where\n+;; only one bit is set to 1.\n+(define_predicate \"one_bit_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned int val;\n+\n+  val = INTVAL (op);\n+  if (mode == QImode) \n+    val &= 0xff;\n+  else if (mode == HImode)\n+    val &= 0xffff;\n+  else\n+    gcc_unreachable();\n+\n+  if (val != 0)\n+    return (val & (val - 1)) == 0; /* true if only one bit is set.  */\n+  else\n+    return 0;\n+})\n+\n+;; Operand is a constant integer where\n+;; only one bit is set to 0.\n+(define_predicate \"rev_one_bit_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned int val;\n+\n+  val = ~INTVAL (op); /* Invert and use.  */\n+  if (mode == QImode) \n+    val &= 0xff;\n+  else if (mode == HImode)\n+    val &= 0xffff;\n+  else\n+    gcc_unreachable();\n+\n+  if (val != 0)\n+    return (val & (val - 1)) == 0; /* true if only one bit is set.  */\n+  else\n+    return 0;\n+})\n+\n+;; Predicates for shift instructions\n+;; Immediate operand predicate for count in shift operations.\n+;; Immediate shall be 3-bits in case operand to be operated on\n+;; is a qi mode operand.\n+(define_predicate \"shift_qi_imm_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 3)) ? 1 : 0;\n+})\n+\n+;; Immediate shall be 4-bits in case operand to be operated on\n+;; is a hi mode operand.\n+(define_predicate \"shift_hi_imm_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 4)) ? 1 : 0;\n+})\n+\n+;; Immediate shall be 3-bits in case operand to be operated on\n+;; is a si mode operand.\n+(define_predicate \"shift_si_imm_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 5)) ? 1 : 0;\n+})\n+\n+;; Predicates for jump/call instructions\n+;; Jump immediate cannot be more than 24-bits\n+(define_predicate \"jump_imm_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 24)) ? 1 : 0;\n+})\n+\n+;; Call immediate cannot be more than 24-bits\n+(define_predicate \"call_imm_operand\"\n+  (match_operand 0 \"immediate_operand\")\n+{\n+  if (GET_CODE (op) != CONST_INT) return 1;\n+    return (UNSIGNED_INT_FITS_N_BITS(INTVAL (op), 24)) ? 1 : 0;\n+})\n+\n+;; Operand is register or 4-bit immediate operand\n+(define_predicate \"reg_or_u4bits_operand\"\n+  (ior (match_operand 0 \"u4bits_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Operand is a register or symbol reference\n+(define_predicate \"reg_or_sym_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Operand is a non stack pointer register\n+(define_predicate \"nosp_reg_operand\"\n+  (and (match_operand 0 \"register_operand\")\n+       (match_test \"REGNO (op) != SP_REGNUM\")))\n+\n+(define_predicate \"hard_reg_operand\"\n+  (and (match_operand 0 \"register_operand\")\n+       (match_test \"REGNO (op) <= 15\")))\n+\n+;; Operand is a memory reference and\n+;; not a push operand.\n+(define_predicate \"store_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (not (match_operand 0 \"push_operand\"))))\n+\n+;; Helper predicate \n+(define_predicate \"reg_or_int_operand\"\n+  (ior (match_code \"const_int\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;;\n+;;\n+;; Atithmetic/logical predicates\n+\n+;; QI Helper\n+(define_predicate \"arith_qi_operand\"\n+   (match_code \"const_int\")\n+{\n+        return (IN_RAN(INTVAL (op), 0, 15) && ((INTVAL (op) != 9) \n+                || (INTVAL (op) != 11))) ? 1 : 0 ; \n+})\n+\n+;;QI Reg, subreg(reg) or const_int.\n+(define_predicate \"reg_qi_int_operand\"\n+  (ior (match_operand 0 \"arith_qi_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; HI Helper\n+(define_predicate \"arith_hi_operand\"\n+   (match_code \"const_int\")\n+{\n+        return (IN_RAN(INTVAL (op), -32768, 32768) ) ? 1 : 0 ; \n+})\n+\n+;;HI Reg, subreg(reg) or const_int.\n+(define_predicate \"reg_hi_int_operand\"\n+  (ior (match_operand 0 \"arith_hi_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;;SI Reg, subreg(reg) or const_int.\n+(define_predicate \"reg_si_int_operand\"\n+  (ior (match_operand 0 \"const_int_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;;\n+;; Shift predicates\n+\n+;; QI Helper\n+(define_predicate \"shift_qi_operand\"\n+   (match_code \"const_int\")\n+{\n+        return (IN_RAN(INTVAL (op), 0, 7) ) ? 1 : 0; \n+})\n+\n+;;QI Reg, subreg(reg) or const_int.\n+(define_predicate \"shift_reg_qi_int_operand\"\n+  (ior (match_operand 0 \"shift_qi_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; HI Helper\n+(define_predicate \"shift_hi_operand\"\n+   (match_code \"const_int\")\n+{\n+        return (IN_RAN(INTVAL (op), 0, 15) ) ? 1 : 0 ; \n+})\n+\n+;;HI Reg, subreg(reg) or const_int.\n+(define_predicate \"shift_reg_hi_int_operand\"\n+  (ior (match_operand 0 \"shift_hi_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; SI Helper\n+(define_predicate \"shift_si_operand\"\n+   (match_code \"const_int\")\n+{\n+        return (IN_RAN(INTVAL (op), 0, 31) ) ? 1 : 0; \n+})\n+\n+;;SI Reg, subreg(reg) or const_int.\n+(define_predicate \"shift_reg_si_int_operand\"\n+  (ior (match_operand 0 \"shift_si_operand\")\n+       (match_operand 0 \"register_operand\")))"}, {"sha": "ff9b677b19f1f7677d7f35797da495fc30b58b9e", "filename": "gcc/config/cr16/t-cr16", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Ft-cr16", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fconfig%2Fcr16%2Ft-cr16", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Ft-cr16?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,25 @@\n+# CR16 Target Makefile\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Contributed by KPIT Cummins Infosystems Limited.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.     \n+\n+MULTILIB_OPTIONS     = fPIC mint32 \n+MULTILIB_DIRNAMES    = far-pic int32 \n+MULTILIB_MATCHES     =\n+MULTILIB_EXTRA_OPTS  = mcr16cplus mdata-model=far\n+"}, {"sha": "e821041ee43aaf854d875ecb2176d0d4fc6b4df7", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -2723,7 +2723,7 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n+Use this attribute on the ARM, AVR, CR16, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n RL78, RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute"}, {"sha": "4a85397b702a98491bec825c8d7ba5945b652307", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -3269,6 +3269,29 @@ See ``Blackfin Options'' in the main manual\n More information, and a version of binutils with support for this processor,\n is available at @uref{http://blackfin.uclinux.org}\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{cr16}CR16\n+\n+The CR16 CompactRISC architecture is a 16-bit architecture. This architecture is \n+used in embedded applications.\n+\n+@ifnothtml\n+@xref{CR16 Options,, CR16 Options, gcc, Using and Porting the GNU Compiler\n+Collection (GCC)},\n+@end ifnothtml\n+\n+@ifhtml\n+See ``CR16 Options'' in the main manual for a list of CR16-specific options.\n+@end ifhtml\n+\n+Use @samp{configure --target=cr16-elf --enable-languages=c,c++} to configure\n+GCC@ for building a CR16 elf cross-compiler.\n+\n+Use @samp{configure --target=cr16-uclinux --enable-languages=c,c++} to configure\n+GCC@ for building a CR16 uclinux cross-compiler.\n+\n @html\n <hr />\n @end html"}, {"sha": "610571063a87a82b975f9294747de4074a99586b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -524,6 +524,12 @@ Objective-C and Objective-C++ Dialects}.\n -melf  -maout  -melinux  -mlinux  -sim  -sim2 @gol\n -mmul-bug-workaround  -mno-mul-bug-workaround}\n \n+@emph{CR16 Options}\n+@gccoptlist{-mmac @gol\n+-mcr16cplus -mcr16c @gol\n+-msim -mint32 -mbit-ops\n+-mdata-model=@var{model}}\n+\n @emph{Darwin Options}\n @gccoptlist{-all_load  -allowable_client  -arch  -arch_errors_fatal @gol\n -arch_only  -bind_at_load  -bundle  -bundle_loader @gol\n@@ -10307,6 +10313,7 @@ platform.\n * Blackfin Options::\n * C6X Options::\n * CRIS Options::\n+* CR16 Options::\n * Darwin Options::\n * DEC Alpha Options::\n * DEC Alpha/VMS Options::\n@@ -11634,6 +11641,46 @@ Like @option{-sim}, but pass linker options to locate initialized data at\n 0x40000000 and zero-initialized data at 0x80000000.\n @end table\n \n+@node CR16 Options\n+@subsection CR16 Options\n+@cindex CR16 Options\n+\n+These options are defined specifically for the CR16 ports.\n+\n+@table @gcctabopt\n+\n+@item -mmac\n+@opindex mmac\n+Enable the use of multiply-accumulate instructions. Disabled by default.\n+\n+@item -mcr16cplus\n+@itemx -mcr16c\n+@opindex mcr16cplus\n+@opindex mcr16c\n+Generate code for CR16C or CR16C+ architecture. CR16C+ architecture \n+is default.\n+\n+@item -msim\n+@opindex msim\n+Links the library libsim.a which is in compatible with simulator. Applicable\n+to elf compiler only.\n+\n+@item -mint32\n+@opindex mint32\n+Choose integer type as 32-bit wide.\n+\n+@item -mbit-ops\n+@opindex mbit-ops\n+Generates sbit/cbit instructions for bit manipulations.\n+\n+@item -mdata-model=@var{model}\n+@opindex mdata-model\n+Choose a data model. The choices for @var{model} are @samp{near},\n+@samp{far} or @samp{medium}. @samp{medium} is default.\n+However, @samp{far} is not valid when -mcr16c option is chosen as\n+CR16C architecture does not support far data model.\n+@end table\n+\n @node Darwin Options\n @subsection Darwin Options\n @cindex Darwin options"}, {"sha": "92c1b28137d2cf13c68cab92ff1c7c9706d0c604", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -1843,6 +1843,40 @@ Matches control register values to switch fp mode, which are encapsulated in\n @code{UNSPEC_FP_MODE}.\n @end table\n \n+@item CR16 Architecture---@file{config/cr16/cr16.h}\n+@table @code\n+\n+@item b\n+Registers from r0 to r14 (registers without stack pointer)\n+\n+@item t\n+Register from r0 to r11 (all 16-bit registers)\n+\n+@item p\n+Register from r12 to r15 (all 32-bit registers)\n+\n+@item I\n+Signed constant that fits in 4 bits\n+\n+@item J\n+Signed constant that fits in 5 bits\n+\n+@item K\n+Signed constant that fits in 6 bits\n+\n+@item L\n+Unsigned constant that fits in 4 bits\n+\n+@item M\n+Signed constant that fits in 32 bits\n+\n+@item N\n+Check for 64 bits wide constants for add/sub instructions\n+\n+@item G\n+Floating point constant that is legal for store immediate\n+@end table\n+\n @item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}\n @table @code\n @item a"}, {"sha": "abd2a7fe6b1829a9d5d22a5f43a06599f835732d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -1,3 +1,17 @@\n+2012-02-02  Sumanth G <sumanth.gundapaneni@kpitcummins.com>\n+\t    Jayant R Sonar <jayant.sonar@kpitcummins.com>\n+\n+\t* config.host: Add National Semiconductor CR16 target (cr16-*-*).\n+\t* config/cr16/crti.S: New file.\n+\t* config/cr16/crtlibid.S: New file.\n+\t* config/cr16/crtn.S: New file.\n+\t* config/cr16/lib1funcs.S: New file.\n+\t* config/cr16/t-cr16: New file.\n+\t* config/cr16/t-crtlibid: New file.\n+\t* config/cr16/unwind-dw2.h: New file.\n+\t* config/cr16/unwind-cr16.c: New file.\n+\t* config/cr16/divmodhi3.c: New file.\n+\n 2012-01-25  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/t-linux64: Delete.  Move.."}, {"sha": "14443c10699b17d7555bb60bb4e98da83f54ecfc", "filename": "libgcc/config.host", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -98,6 +98,8 @@ avr-*-*)\n bfin*-*)\n \tcpu_type=bfin\n \t;;\n+cr16-*-*)\n+\t;;\n fido-*-*)\n \tcpu_type=m68k\n \t;;\n@@ -415,6 +417,10 @@ bfin*-*)\n \ttmake_file=\"$tmake_file bfin/t-bfin t-fdpbit\"\n \textra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n         ;;\n+cr16-*-elf)\n+\ttmake_file=\"${tmake_file} cr16/t-cr16 cr16/t-crtlibid t-fdpbit\"\n+\textra_parts=\"$extra_parts crti.o crtn.o crtlibid.o\"\n+        ;;\n crisv32-*-elf)\n \ttmake_file=\"$tmake_file cris/t-cris t-fdpbit\"\n  \t;;"}, {"sha": "305626f354462bec11196334bc020593d4549e54", "filename": "libgcc/config/cr16/crti.S", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Fcrti.S?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,54 @@\n+# Specialized code needed to support construction and destruction of\n+# file-scope objects in C++ and Java code, and to support exception handling.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Contributed by KPIT Cummins Infosystems Limited.\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+/* This file just supplies function prologues for the .init and .fini\n+   sections.  It is linked in before crtbegin.o.  */\n+\n+\t.ident  \"GNU C crti.o\"\n+\n+\t.section .init\n+\t.globl  __init\n+\t.type   __init,@function\n+__init:\n+#if defined (__ID_SHARED_LIB__)\n+\tpush\t$2, r12, ra\n+\tmovd    $__current_shared_library_r12_offset_, (r1,r0)\n+\tloadd   [r12]0(r1,r0), (r12)\n+#else\n+        push\tra\n+#endif\n+\n+\t.section .fini\n+\t.globl  __fini\n+\t.type   __fini,@function\n+__fini:\n+#if defined (__ID_SHARED_LIB__)\n+\tpush\t$2, r12, ra\n+\tmovd    $__current_shared_library_r12_offset_, (r1,r0)\n+\tloadd   [r12]0(r1,r0), (r12)\n+#else\n+        push\tra\n+#endif\n+\t"}, {"sha": "8977fb592e0a12c2752fa3a23d314b285d1f1ae7", "filename": "libgcc/config/cr16/crtlibid.S", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrtlibid.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrtlibid.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Fcrtlibid.S?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,28 @@\n+# Provide a weak definition of the library ID, for the benefit of certain\n+# configure scripts.\t \n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Contributed by KPIT Cummins Infosystems Limited.\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.ident  \"GNU C crtlibid.o\"\n+\n+.weak __current_shared_library_r12_offset_\n+.set __current_shared_library_r12_offset_, 0"}, {"sha": "c4a71fb0d7009b0e3b22cc95ee8b37526832ec7a", "filename": "libgcc/config/cr16/crtn.S", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Fcrtn.S?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,44 @@\n+# Specialized code needed to support construction and destruction of\n+# file-scope objects in C++ and Java code, and to support exception handling.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Contributed by KPIT Cummins Infosystems Limited.\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+/* This file supplies function epilogues for the .init and .fini sections.\n+  It is linked in after all other files.  */\n+\n+\t.ident  \"GNU C crtn.o\"\n+\n+\t.section .init\n+#if defined (__ID_SHARED_LIB__)\n+\tpopret\t$2, r12, ra\n+#else\n+\tpopret\tra\n+#endif\n+\n+\t.section .fini\n+#if defined (__ID_SHARED_LIB__)\n+\tpopret\t$2, r12, ra\n+#else\n+\tpopret\tra\n+#endif\n+"}, {"sha": "12c2cd84224c3b197bc9913cfbb3c4c9114ae07c", "filename": "libgcc/config/cr16/divmodhi3.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fdivmodhi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Fdivmodhi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Fdivmodhi3.c?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,115 @@\n+/* Libgcc Target specific implementation - Emulating div and mod.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by KPIT Cummins Infosystems Limited.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\t \n+\n+/* Emulate the division and modulus operation.  */\n+\n+unsigned short\n+udivmodhi4 (unsigned short num, unsigned short den, short modwanted)\n+{\n+  unsigned short bit = 1;\n+  unsigned short res = 0;\n+\n+  while (den < num && bit && !(den & (1 << 15)))\n+    {\n+      den <<= 1;\n+      bit <<= 1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>= 1;\n+      den >>= 1;\n+    }\n+\n+  if (modwanted)\n+    return num;\n+  return res;\n+}\n+\n+short\n+__divhi3 (short a, short b)\n+{\n+  short neg = 0;\n+  short res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodhi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+short\n+__modhi3 (short a, short b)\n+{\n+  short neg = 0;\n+  short res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodhi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+short\n+__udivhi3 (short a, short b)\n+{\n+  return udivmodhi4 (a, b, 0);\n+}\n+\n+short\n+__umodhi3 (short a, short b)\n+{\n+  return udivmodhi4 (a, b, 1);\n+}"}, {"sha": "da818a67969f2642349faf2f543fc5b5b7305d6e", "filename": "libgcc/config/cr16/lib1funcs.S", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Flib1funcs.S?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,563 @@\n+/* Libgcc Target specific implementation.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by KPIT Cummins Infosystems Limited.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifdef  L_mulsi3\n+\t.text\n+\t.align  4\n+\t.globl  ___mulsi3\n+___mulsi3:\n+\tmovw    r4,r0\n+\tmovw    r2,r1\n+\t/* Extended multiplication between the 2 lower words */\n+\tmuluw   r1,(r1,r0)\n+\n+\t/* Multiply the lower word of each parameter  */  \n+\tmulw    r2,r5   \n+    \n+\t/* With the higher word of the other  */\n+\tmulw    r3,r4     \n+  \n+\t/* Add products to the higher part of the final result  */\n+\taddw    r4,r1       \n+\taddw    r5,r1\n+\tjump    (ra)\n+#endif\n+\n+#ifdef L_divdi3\n+\t.text\n+\t.align 4\n+\t.globl ___divdi3\n+\n+___divdi3:\n+\tpush\t$4, r7, ra\n+\n+\t/* Param #1 Long Long low bit first */\n+\tloadd   12(sp), (r1, r0)\n+\tloadd   16(sp), (r3, r2)\n+\n+\t/* Param #2 Long Long low bit first */\n+\tloadd   20(sp), (r5, r4)\n+\tloadd   24(sp), (r7, r6)\n+\t\n+\t/* Set neg to 0 */\n+\tmovw $0, r10\n+\t\n+\tsubd $16, (sp)\n+\n+\t/* Compare if param1 is greater than 0 */\t\n+\tcmpw $0, r3\n+\tble L4\n+\n+\t/* Invert param1 and neg */\n+\tmovd $-1, (r9, r8) \t/* Temp set to FFFFFFFF */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of param 1 with temp */\n+\txord (r9, r8), (r3, r2)\t/* Xor high bits of param 1 with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of param 1 */\n+\txorw $1, r10\t\t/* Invert neg */\n+\tbcc L4\t\t\t/* If no carry occurred go to L4 */\n+\taddd $1, (r3, r2)\t/* Add 1 to high bits of param 1 */\n+\n+L4:\tstord (r1, r0), 0(sp)\n+\tstord (r3, r2), 4(sp)\n+\t\n+\t/* Compare if param2 is greater than 0 */\t\n+\tcmpw $0, r7\n+\tble L5\n+\n+\t/* Invert param2 and neg */\n+\tmovd $-1, (r9, r8)\t/* Temp set to FFFFFFFF */\n+\txord (r9, r8), (r5, r4)\t/* Xor low bits of param 2 with temp */\n+\txord (r9, r8), (r7, r6)\t/* Xor high bits of param 2 with temp */\n+\taddd $1, (r5, r4)\t/* Add 1 to low bits of param 2 */\n+\txorw $1, r10\t\t/* Invert neg */\n+\tbcc L5\t\t\t/* If no carry occurred go to L5 */\n+\taddd $1, (r7, r6)\t/* Add 1 to high bits of param 2 */\n+\n+L5:\tstord (r5, r4), 8(sp)\n+\tstord (r7, r6), 12(sp)\n+\tmovw $0, r2\n+\n+\t/* Call udivmoddi3 */\n+#ifdef __PIC__\n+\tloadd\t___udivmoddi3@cGOT(r12), (r1,r0)\n+\tjal\t(r1,r0)\n+#else\n+\tbal (ra), ___udivmoddi3\n+#endif\n+\n+\t/* If (neg) */\n+\taddd\t$16, (sp)\n+\tcmpw $0, r10\t\t/* Compare 0 with neg */\n+\tbeq Lexit__\n+\t\n+\t/* Neg = -Neg */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of ures with temp */\n+\txord (r9, r8), (r3, r2)\t/* Xor high bits of ures with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of ures */\n+\tbcc Lexit__\n+\taddd $1, (r3, r2)\t/* Add 1 to high bit of ures */\n+\n+Lexit__:\n+#  ifdef __ID_SHARED_LIB__\n+\tpop\t$2, r12\n+#  endif\n+\tpopret $4, r7, ra\n+#endif\n+\n+#ifdef L_lshrdi3\n+\t.text\n+\t.align 4\n+\t.globl ___lshrdi3\n+\n+___lshrdi3:\n+\tpush\t$3, r7\n+\n+\t/* Load parameters from stack in this order */\n+\tmovw r2, r6\t\t/* Number of shifts */\n+\tloadd\t6(sp), (r1, r0)\t/* Low bits */\n+\tloadd\t10(sp), (r3, r2)/* High bits */\n+\n+\txorw $-1, r6\t\t/* Invert number of shifts */\n+\taddw $1, r6\t\t/* Add 1 by number of shifts */\n+\n+\tmovw r6, r7\t\t/* Copy number of shifts */\n+\n+\ttbit $15, r6\t\t/* Test if number is negative */\n+\tbfs L2\t\t\t/* If negative jump to L2 */\n+\n+\tmovd (r1, r0), (r9, r8)\t/* Copy low bits */\n+\n+\tsubw $32, r7\t\t/* Calc how many bits will overflow */\n+\t/* Shift the temp low bit to the right to see the overflowing bits  */\n+\tlshd r7, (r9, r8)\t\n+\n+\tcmpw $32, r6\t\t/* If number of shifts is higher than 31 */\n+\tblt L1\t\t\t/* Shift by moving */\n+\n+\tlshd r6, (r3, r2)\t/* Shift high bits */\n+\tlshd r6, (r1, r0)\t/* Shift low bits */\n+\taddd (r9, r8), (r3, r2)\t/* Add overflow to the high bits */\n+\tpopret\t$3, r7\t\t/* Return */\n+\n+L1:\tmovd $0, (r1, r0)\t/* Reset low bit */\n+\tmovd (r9, r8), (r3, r2)\t/* Add the overflow from the low bit */\n+\tpopret\t$3, r7\t\t/* Return */\n+\n+L2:\tmovd (r3, r2), (r9, r8)\t/* Copy high bits */\n+\n+\taddw $32, r7\t\t/* Calc how many bits will overflow */\n+\t/* Shift the temp low bit to the left to see the overflowing bits  */\n+\tlshd r7, (r9, r8)\t\n+\n+\tcmpw $-32, r6\t\t/* If number of shifts is lower than -31 */\n+\tbgt L3\t\t\t/* Shift by moving */\n+\n+\tlshd r6, (r1, r0)\t/* Shift low bits */\n+\tlshd r6, (r3, r2)\t/* Shift high bits */\n+\taddd (r9, r8), (r1, r0)\t/* Add overflow to the low bits */\n+\tpopret\t$3, r7\t\t/* Return */\n+\t\n+L3:\tmovd $0, (r3, r2)\t/* Reset the high bit */\n+\tmovd (r9, r8), (r1, r0)\t/* Add the overflow from the high bit */\n+\tpopret\t$3, r7\t\t/* Return */\n+#endif\n+\n+#ifdef L_moddi3\n+\t.text\n+\t.align 4\n+\t.globl ___moddi3\n+\n+___moddi3:\n+\tpush\t$4, r7, ra\n+\n+\t/* Param #1 Long Long low bit first */\n+\tloadd\t12(sp), (r1, r0)\n+\tloadd\t16(sp), (r3, r2)\n+\n+\t/* Param #2 Long Long low bit first */\n+\tloadd\t20(sp), (r5, r4)\n+\tloadd\t24(sp), (r7, r6)\n+\t\n+\tsubd\t$18, (sp)\n+\n+\t/* Set neg to 0 */\n+\tstorw $0, 16(sp)\n+\t\n+\tmovd\t$-1, (r9, r8) \t/* Temp set to FFFFFFFF */\n+\n+\t/* Compare if param1 is greater than 0 */\t\n+\tcmpw $0, r3\n+\tble L4\n+\n+\t/* Invert param1 and neg */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of param 1 with temp */\n+\txord (r9, r8), (r3, r2)\t/* Xor high bits of param 1 with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of param 1 */\n+\tstorw $1, 16(sp)\n+\tbcc L4\t\t\t/* If no carry occurred go to L4 */\n+\taddd $1, (r3, r2)\t/* Add 1 to high bits of param 1 */\n+\n+L4:\tstord (r1, r0), 0(sp)\n+\tstord (r3, r2), 4(sp)\n+\t\n+\t/* Compare if param2 is greater than 0 */\t\n+\tcmpw $0, r7\n+\tble L5\n+\n+\t/* Invert param2 and neg */\n+\txord (r9, r8), (r5, r4)\t/* Xor low bits of param 2 with temp */\n+\txord (r9, r8), (r7, r6)\t/* Xor high bits of param 2 with temp */\n+\taddd $1, (r5, r4)\t/* Add 1 to low bits of param 2 */\n+\tbcc L5\t\t\t/* If no carry occurred go to L5 */\n+\taddd $1, (r7, r6)\t/* Add 1 to high bits of param 2 */\n+\n+L5:\tstord (r5, r4), 8(sp)\n+\tstord (r7, r6), 12(sp)\n+\tmovw $1, r2\n+\n+\t/* Call udivmoddi3 */\n+#ifdef __PIC__\n+\tloadd\t___udivmoddi3@cGOT(r12), (r1,r0)\n+\tjal\t(r1,r0)\n+#else\n+\tbal (ra), ___udivmoddi3\n+#endif\n+\n+\t/* If (neg) */\n+\tloadw 16(sp), r10\t/* Load neg from stack */\n+\taddd\t$18, (sp)\n+\tcmpw $0, r10\t\t/* Compare 0 with neg */\n+\tbeq\tLexit__\n+\t\n+\t/* Neg = -Neg */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of ures with temp */\n+\txord (r9, r8), (r3, r2)\t/* Xor high bits of ures with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of ures */\n+\tbcc\tLexit__\n+\taddd $1, (r3, r2)\t/* Add 1 to high bit of ures */\n+Lexit__:\n+#  ifdef __ID_SHARED_LIB__\n+\tpop\t$2, r12\n+#  endif\n+\tpopret\t$4, r7, ra\n+#endif\n+\n+#ifdef L_muldi3\n+\t.text\n+\t.align 4\n+\t.globl ___muldi3\n+\n+___muldi3:\n+\tpush\t$2, r13\n+\tpush\t$7, r7\n+\n+\t/* Param #1 Long Long low bit first */\n+\tloadd   18(sp), (r1, r0)\n+\tloadd   22(sp), (r3, r2)\n+\n+\t/* Param #2 Long Long low bit first */\n+\tloadd   26(sp), (r5, r4)\n+\tloadd   30(sp), (r7, r6)\n+\n+\t/* Clear r13, r12 */\t\n+\tmovd $0, (r12)\t\n+\tmovd $0, (r13)\n+\n+\t/* Set neg */\n+\tmovw $0, r10\n+\n+\t/* Compare if param1 is greater than 0 */\t\n+\tcmpw $0, r3\n+\tble L1\n+\n+\t/* Invert param1 and neg */\n+\tmovd $-1, (r9, r8) \t/* Temp set to FFFFFFFF */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of param 1 with temp */\n+\txord (r9, r8), (r3, r2)\t/* Xor high bits of param 1 with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of param 1 */\n+\txorw $1, r10\t\t/* Invert neg */\n+\tbcc L1\t\t\t/* If no carry occurred go to L1 */\n+\taddd $1, (r3, r2)\t/* Add 1 to high bits of param 1 */\n+\n+L1:\t/* Compare if param2 is greater than 0 */\t\n+\tcmpw $0, r7\n+\tble L2\t\n+\t\n+\t/* Invert param2 and neg */\n+\tmovd $-1, (r9, r8)\t/* Temp set to FFFFFFFF */\n+\txord (r9, r8), (r5, r4)\t/* Xor low bits of param 2 with temp */\n+\txord (r9, r8), (r7, r6)\t/* Xor high bits of param 2 with temp */\n+\taddd $1, (r5, r4)\t/* Add 1 to low bits of param 2 */\n+\txorw $1, r10\t\t/* Invert neg */\n+\tbcc L2\t\t\t/* If no carry occurred go to L2 */\n+\taddd $1, (r7, r6)\t/* Add 1 to high bits of param 2 */\n+\t\n+L2:\tstorw r10, 18(sp)\t/* Store neg to stack so we can use r10 */\n+\n+\t/* B*D */\n+\t/* Bl*Dl */\n+\tmacuw r0, r4, (r12)\t/* Multiply r0 and r4 and add to r12 */\n+\t\t\n+\t/* Bh*Dl */\n+\tmovd $0, (r9, r8)\t/* Clear r9, r8 */\n+\tmacuw r1, r4, (r9, r8)\t/* Multiply Bh*Dl and add result to (r9, r8) */\n+\tmovw r9,  r10\t\t/* Shift left: r9 to r10 */\n+\tlshd $16, (r9, r8)\t/* Shift left: r8 to r9 */\n+\tmovw $0, r11\t\t/* Clear r11 */\n+\taddd (r9, r8), (r12)\t/* Add (r9, r8) to r12 */\n+\tbcc L3\t\t\t/* If no carry occurred go to L3 */\n+\taddd $1, (r13)\t\t/* If carry occurred add 1 to r13 */\n+\n+L3:\taddd (r11, r10), (r13)\t/* Add (r11, r10) to r13 */\n+\t\t\n+\t/* Bl*Dh */\n+\tmovd $0, (r9, r8)\t/* Clear (r9, r8) */\n+\tmacuw r0, r5, (r9, r8)\t/* Multiply r0 and r5 and stor in (r9, r8) */\n+\tmovw r9, r10\t\t/* Shift left: r9 to r10 */\n+\tlshd $16, (r9, r8)\t/* Shift left: r8 to r9 */\n+\taddd (r9, r8), (r12)\t/* Add (r9, r8) to r12 */\n+\tbcc L4\t\t\t/* If no carry occurred go to L4 */ \n+\taddd $1, (r13)\t\t/* If carry occurred add 1 to r13 */\n+\n+L4:\taddd (r11, r10), (r13)\t/* Add (r11, r10) to r13 */\n+\n+\t/* Bh*Dh */\n+\tmovd $0, (r9, r8)\t/* Clear (r9, r8) */\n+\tmacuw r1, r5, (r9, r8)\t/* Multiply r1 and r5 and add to r13 */\n+\taddd (r9, r8), (r13)\t/* Add (r9, r8) to result */\n+\n+\t/* A*D */\n+\t/* Al*Dl */\n+\tmovd $0, (r11, r10)\t/* Clear (r11, r10) */\n+\tmacuw r2, r4, (r11, r10)/* Multiply r2 and r4 and add to (r11, r10) */\n+\t\n+\taddd (r13), (r11, r10)\t/* Copy r13 to (r11, r10) */\n+\n+\t/* Al*Dh */\n+\tmovd $0, (r9, r8)\t/* Clear (r9, r8) */\n+\tmacuw r2, r5, (r9, r8)\t/* Multiply r2 and r5 and add to (r9, r8) */\n+\taddw r8, r11\t\t/* Add r8 to r11 */\n+\t\n+\t/* Ah*Dl */\n+\tmuluw r3, (r5, r4)\t/* Multiply r3 and r4 and stor in (r5, r4) */\n+\taddw r4, r11\t\t/* Add r4 to r11 */\n+\n+\t/* B*C */\n+\t/* Bl*Cl */\n+\tmovd $0, (r9, r8)\t/* Clear (r9, r8) */\n+\tmacuw r0, r6, (r9, r8)\t/* Multiply r0 and r6 and add to (r9, r8) */\n+\taddd (r9, r8), (r11, r10)/* Add (r9, r8) to result */\n+\n+\t/* Bl*Ch */\n+\tmovd $0, (r9, r8)\t/* Clear (r9, r8) */\n+\tmacuw r0, r7, (r9, r8)\t/* Multiply r0 and r7 and add to (r9, r8) */\n+\taddw r8, r11\t\t/* Add r8 to r11 */\n+\n+\tloadw 18(sp), r8\t/* Load neg from stack */\n+\n+\t/* Bh*Cl */\n+\tmuluw r1, (r7, r6)\t/* Multiply r1 and r6 and stor in (r7, r6) */\n+\taddw r6, r11\t\t/* Add r6 to r11 */\n+\n+E1:\tmovd (r11, r10), (r3, r2)\n+\tmovd (r12), (r1, r0)\t\n+\n+\t/* If (neg) */\n+\tcmpw $0, r8\t\t/* Compare 0 with neg */\n+\tbeq\tLexit__\n+\t\n+\t/* Neg = -Neg */\n+\tmovd $-1, (r9, r8) \t/* Temp set to FFFFFFFF */\n+\txord (r9, r8), (r1, r0)\t/* Xor low bits of result with temp */\n+\txord (r9, r8), (r3, r2) /* Xor high bits of result with temp */\n+\taddd $1, (r1, r0)\t/* Add 1 to low bits of result */\n+\tbcc\tLexit__\n+\taddd $1, (r3, r2)\t/* Add 1 to high bit of result */\n+Lexit__:\n+\tpop\t$7, r7\n+\tpopret\t$2, r13\n+#endif\n+\n+#ifdef L_negdi2\n+\t.text\n+\t.align 4\n+\t.globl ___negdi2\n+\n+___negdi2:\n+\t/* Load parameter from the registers in this order */\n+\tloadd 0(sp), (r1, r0)\n+\tloadd 4(sp), (r3, r2)\n+\t\n+\tmovd $-1, (r6, r5)\t/* Set temp to FFFFFFFF */\n+\txord (r6, r5), (r1, r0)\t/* Xor low bits with temp */\n+\txord (r6, r5), (r3, r2)\t/* Xor high bits with temp */\n+\taddd $1, (r1, r0)\t/* Add one */\n+\tjcc (ra)\n+\taddd $1, (r3, r2)\t/* Add the carry to the high bits */\n+\tjump (ra)\n+#endif\n+\n+#ifdef L_udivdi3\n+\t.text\n+\t.align 4\n+\t.globl ___udivdi3\n+\n+___udivdi3:\n+\tmovw $0, r2\n+\tbr ___udivmoddi3\n+#endif\n+\n+#ifdef L_udivmoddi3\n+\t.text\n+\t.align 4\n+\t.globl ___udivmoddi3\n+\n+___udivmoddi3:\n+\tpush\t$2, r13\n+\tpush\t$7, r7\n+\n+\t/* Param #1 Long Long low bit first */\n+\tloadd\t18(sp), (r1, r0)\n+\tstorw\tr2, 18(sp)\t/* Store modulo on stack */\n+\tloadd\t22(sp), (r3, r2)\n+\n+\t/* Param #2 Long Long low bit first */\n+\tloadd\t26(sp), (r5, r4)\n+\tloadd\t30(sp), (r7, r6)\n+\n+\t/* Set ures to 0 */\n+\tmovd $0, (r13)\n+\tmovd $0, (r12)\n+\t\n+\tcmpd (r12), (r5, r4)\n+\tbeq LE\n+\n+L5:\tmovd $1, (r9, r8)\t/* Store 1 in low bits from bit */\n+\tmovd $0, (r11, r10)\t/* Store 0 in high bits from bit */\n+\t\n+L6:\t/* While (den < num && (!den & (1LL<<63))) */\n+\t/* Compare high bits from param 1 and param 2 */\n+\tcmpd (r7, r6), (r3, r2)\t\n+\tbhi L10\t\t\t/* If param 2 is greater go to L10 */\n+\tbne L8\t\t\t/* If param 1 is greater go to L8 */\n+\tcmpd (r5, r4), (r1, r0)\t/* Compare low bits from param 1 and param 2 */\n+\t/*  If param 2 is greater or the same go to L1 */\n+\tbhs L10\t\t\t \n+\n+L8:\t/* Check if most significant bit of param 2 is set */\n+\ttbit $15, r7\t\t\n+\tbfs L10\t\t\t/* If PSR is set go to L10 */\n+\n+\t/* Shift bit */\n+\tlshd $1, (r11, r10)\t/* Shift left: high bits of bit */ \n+\t/* Check if most significant bit of bit is set */\n+\ttbit $15, r9\t\t\n+\tlshd $1, (r9, r8)\t/* Shift left: low bits of bit */\n+\tbfs L28\t\t\t/* If PSR is set go to L28 */\n+\n+L9:\t/* Shift b */\n+\tlshd $1, (r7, r6)\t/* Shift left: high bits of param 2 */\n+\t/* Check if most significant bit of param 2 is set */\n+\ttbit $15, r5\t\t\n+\tlshd $1, (r5, r4)\t/* Shift left: low bits of param 2 */\n+\tbfc L6\t\t\t/* If PSR is set go to L6 */\n+\taddw $1, r6\t\t/* Add 1 to the highest bits of b */\n+\tbr L6\t\t\t/* Go to L6 */\n+\t\n+L10:\t/* While (bit) */\n+\tcmpd $0, (r11, r10)\t\n+\tbne L11\n+\tcmpd $0, (r9, r8)\n+\tbeq E1\n+\n+L11:\t/* If (num >= den) */\n+\tcmpd (r3, r2), (r7, r6)\t/* Compare high bits of param 1 and param 2 */\n+\tblo L15\t\t\t/* If param 1 lower than param 2 go to L15 */\n+\tbne L12\t\t\t/* If not equal go to L12 */\t\n+\tcmpd (r1, r0), (r5, r4)\t/* Compare low bits of param 1 and param 2 */\n+\tblo L15\t\t\t/* If param 1 lower than param 2 go to L15 */\n+\n+L12:\t/* Ures |= bit */\n+\tord (r11, r10), (r13)\n+\tord (r9, r8), (r12)\t\n+\n+\t/* Num -= den */\n+\tsubd (r7, r6), (r3, r2) /* Subtract highest 32 bits from each other */\n+\tsubd (r5, r4), (r1, r0)\t/* Subtract lowest 32 bits from each other */\n+\tbcc L15\t\t\t/* If no carry occurred go to L15 */\n+\tsubd $1, (r3, r2)\t/* Subtract the carry */\n+\t\n+L15:\t/* Shift bit to the right */\n+\tlshd $-1, (r9, r8)\t/* Shift right: low bits of bit */\n+\t/* Check if least significant bit of high bits is set */\n+\ttbit $0, r10\t\t\n+\tlshd $-1, (r11, r10)\t/* Shift right: high bits of bit */\n+\tbfs L18\t\t\t/* If PSR is set go to L18 */\n+\n+L17:\t/* Shift param#2 to the right */\n+\tlshd $-1, (r5, r4)\t/* Shift right: low bits of param 2 */\n+\t/* Check if least significant bit of high bits is set */\n+\ttbit $0, r6\t\t\n+\tlshd $-1, (r7, r6)\t/* Shift right: high bits of param 2 */\n+\tbfc L10\t\t\t/* If PSR is not set go to L10 */\n+\t/* Or with 0x8000 to set most significant bit */\n+\torw $32768, r5\t\t\n+\tbr L10\t\t\t/* Go to L10 */\n+\n+L18:\t/* Or with 0x8000 to set most significant bit */\n+\torw $32768, r9\t\t\n+\tbr L17\n+\n+L28: \t/* Left shift bit */\n+\taddw $1, r10\t\t/* Add 1 to highest bits of bit */\n+\tbr L9\t\t\t/* Go to L9 */\n+\n+LE:\tcmpd (r12), (r7, r6)\n+\tbne L5\n+\texcp dvz\n+\tbr\tLexit__\n+\n+E1:\tloadw\t18(sp), r4\n+\tcmpw $0, r4\n+\tbne\tLexit__\n+\n+\t/* Return result */\n+\tmovd (r12), (r1, r0)\n+\tmovd (r13), (r3, r2)\n+Lexit__:\n+\tpop\t$7, r7\n+\tpopret\t$2, r13\n+#endif\n+\n+#ifdef L_umoddi3\n+\t.text\n+\t.align 4\n+\t.globl ___umoddi3\n+\n+___umoddi3:\n+\tmovw $1, r2\n+\tbr ___udivmoddi3\n+#endif\n+"}, {"sha": "9ed127628022d50e82669d6439260abd6b852656", "filename": "libgcc/config/cr16/t-cr16", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Ft-cr16", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Ft-cr16", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Ft-cr16?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,29 @@\n+# Makefile fragment for building LIBGCC for the Renesas CR16 target.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB1ASMSRC = cr16/lib1funcs.S\n+LIB1ASMFUNCS =  _mulsi3 _lshrdi3 _muldi3 _divdi3 _udivdi3 _udivmoddi3 \\\n+                _umoddi3 _moddi3\n+\n+LIB2ADD = $(srcdir)/config/cr16/divmodhi3.c  \\\n+\t  $(srcdir)/udivmodsi4.c \\\n+\t  $(srcdir)/udivmod.c   \\\n+\t  $(srcdir)/divmod.c\n+\n+LIB2ADDEH = $(srcdir)/config/cr16/unwind-cr16.c "}, {"sha": "f0d9ac87a2cc9a960af1176ad115f1be13b30e02", "filename": "libgcc/config/cr16/t-crtlibid", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Ft-crtlibid", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Ft-crtlibid", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Ft-crtlibid?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,22 @@\n+# Makefile fragment for building LIBGCC for the Renesas CR16 target.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Assemble startup files.\n+crtlibid.o: $(srcdir)/config/cr16/crtlibid.S\n+\t$(gcc_compile) -c -x assembler-with-cpp $<"}, {"sha": "51430a24c0864631065e1c1d804f3a5fcfbe3172", "filename": "libgcc/config/cr16/unwind-cr16.c", "status": "added", "additions": 1683, "deletions": 0, "changes": 1683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Funwind-cr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Funwind-cr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Funwind-cr16.c?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,1683 @@\n+/* DWARF2 exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n+   2008, 2009, 2010, 2011, 2012  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"dwarf2.h\"\n+#include \"unwind.h\"\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+# define NO_SIZE_OF_ENCODED_VALUE\n+#endif\n+#include \"unwind-pe.h\"\n+#include \"unwind-dw2-fde.h\"\n+#include \"gthr.h\"\n+#include \"unwind-dw2.h\"\n+\n+#ifdef HAVE_SYS_SDT_H\n+#include <sys/sdt.h>\n+#endif\n+\n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+#define STACK_GROWS_DOWNWARD 0\n+#else\n+#undef STACK_GROWS_DOWNWARD\n+#define STACK_GROWS_DOWNWARD 1\n+#endif\n+\n+/* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */\n+#ifndef PRE_GCC3_DWARF_FRAME_REGISTERS\n+#define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS\n+#endif\n+\n+#ifndef DWARF_REG_TO_UNWIND_COLUMN\n+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n+#endif\n+\n+#ifdef REG_VALUE_IN_UNWIND_CONTEXT\n+typedef _Unwind_Word _Unwind_Context_Reg_Val;\n+\n+#ifndef ASSUME_EXTENDED_UNWIND_CONTEXT\n+#define ASSUME_EXTENDED_UNWIND_CONTEXT 1\n+#endif\n+\n+static inline _Unwind_Word\n+_Unwind_Get_Unwind_Word (_Unwind_Context_Reg_Val val)\n+{\n+  return val;\n+}\n+\n+static inline _Unwind_Context_Reg_Val\n+_Unwind_Get_Unwind_Context_Reg_Val (_Unwind_Word val)\n+{\n+  return val;\n+}\n+#else\n+typedef void *_Unwind_Context_Reg_Val;\n+\n+static inline _Unwind_Word\n+_Unwind_Get_Unwind_Word (_Unwind_Context_Reg_Val val)\n+{\n+  return (_Unwind_Word) (_Unwind_Internal_Ptr) val;\n+}\n+\n+static inline _Unwind_Context_Reg_Val\n+_Unwind_Get_Unwind_Context_Reg_Val (_Unwind_Word val)\n+{\n+  return (_Unwind_Context_Reg_Val) (_Unwind_Internal_Ptr) val;\n+}\n+#endif\n+\n+#ifndef ASSUME_EXTENDED_UNWIND_CONTEXT\n+#define ASSUME_EXTENDED_UNWIND_CONTEXT 0\n+#endif\n+\n+/* This is the register and unwind state for a particular frame.  This\n+   provides the information necessary to unwind up past a frame and return\n+   to its caller.  */\n+struct _Unwind_Context\n+{\n+  _Unwind_Context_Reg_Val reg[DWARF_FRAME_REGISTERS+1];\n+  void *cfa;\n+  void *ra;\n+  void *lsda;\n+  struct dwarf_eh_bases bases;\n+  /* Signal frame context.  */\n+#define SIGNAL_FRAME_BIT ((~(_Unwind_Word) 0 >> 1) + 1)\n+  /* Context which has version/args_size/by_value fields.  */\n+#define EXTENDED_CONTEXT_BIT ((~(_Unwind_Word) 0 >> 2) + 1)\n+  _Unwind_Word flags;\n+  /* 0 for now, can be increased when further fields are added to\n+     struct _Unwind_Context.  */\n+  _Unwind_Word version;\n+  _Unwind_Word args_size;\n+  char by_value[DWARF_FRAME_REGISTERS+1];\n+};\n+\n+/* Byte size of every register managed by these routines.  */\n+static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS+1];\n+\n+\f\n+/* Read unaligned data from the instruction buffer.  */\n+\n+union unaligned\n+{\n+  void *p;\n+  unsigned u2 __attribute__ ((mode (HI)));\n+  unsigned u4 __attribute__ ((mode (SI)));\n+  unsigned u8 __attribute__ ((mode (DI)));\n+  signed s2 __attribute__ ((mode (HI)));\n+  signed s4 __attribute__ ((mode (SI)));\n+  signed s8 __attribute__ ((mode (DI)));\n+} __attribute__ ((packed));\n+\n+static void uw_update_context (struct _Unwind_Context *, _Unwind_FrameState *);\n+static _Unwind_Reason_Code uw_frame_state_for (struct _Unwind_Context *,\n+\t\t\t\t\t       _Unwind_FrameState *);\n+\n+static inline void *\n+read_pointer (const void *p) { const union unaligned *up = p; return up->p; }\n+\n+static inline int\n+read_1u (const void *p) { return *(const unsigned char *) p; }\n+\n+static inline int\n+read_1s (const void *p) { return *(const signed char *) p; }\n+\n+static inline int\n+read_2u (const void *p) { const union unaligned *up = p; return up->u2; }\n+\n+static inline int\n+read_2s (const void *p) { const union unaligned *up = p; return up->s2; }\n+\n+static inline unsigned int\n+read_4u (const void *p) { const union unaligned *up = p; return up->u4; }\n+\n+static inline int\n+read_4s (const void *p) { const union unaligned *up = p; return up->s4; }\n+\n+static inline unsigned long\n+read_8u (const void *p) { const union unaligned *up = p; return up->u8; }\n+\n+static inline unsigned long\n+read_8s (const void *p) { const union unaligned *up = p; return up->s8; }\n+\f\n+static inline _Unwind_Word\n+_Unwind_IsSignalFrame (struct _Unwind_Context *context)\n+{\n+  return (context->flags & SIGNAL_FRAME_BIT) ? 1 : 0;\n+}\n+\n+static inline void\n+_Unwind_SetSignalFrame (struct _Unwind_Context *context, int val)\n+{\n+  if (val)\n+    context->flags |= SIGNAL_FRAME_BIT;\n+  else\n+    context->flags &= ~SIGNAL_FRAME_BIT;\n+}\n+\n+static inline _Unwind_Word\n+_Unwind_IsExtendedContext (struct _Unwind_Context *context)\n+{\n+  return (ASSUME_EXTENDED_UNWIND_CONTEXT\n+\t  || (context->flags & EXTENDED_CONTEXT_BIT));\n+}\n+\f\n+/* Get the value of register INDEX as saved in CONTEXT.  */\n+\n+inline _Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+{\n+  int size;\n+  _Unwind_Context_Reg_Val val;\n+\n+#ifdef DWARF_ZERO_REG\n+  if (index == DWARF_ZERO_REG)\n+    return 0;\n+#endif\n+\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n+  size = dwarf_reg_size_table[index];\n+  val = context->reg[index];\n+\n+  if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n+    return _Unwind_Get_Unwind_Word (val);\n+\n+  /* This will segfault if the register hasn't been saved.  */\n+  if (size == sizeof(_Unwind_Ptr))\n+    return * (_Unwind_Ptr *) (_Unwind_Internal_Ptr) val;\n+  else\n+    {\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      return * (_Unwind_Word *) (_Unwind_Internal_Ptr) val;\n+    }\n+}\n+\n+static inline void *\n+_Unwind_GetPtr (struct _Unwind_Context *context, int index)\n+{\n+  return (void *)(_Unwind_Ptr) _Unwind_GetGR (context, index);\n+}\n+\n+/* Get the value of the CFA as saved in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetCFA (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->cfa;\n+}\n+\n+/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n+{\n+  int size;\n+  void *ptr;\n+\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n+  size = dwarf_reg_size_table[index];\n+\n+  if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n+    {\n+      context->reg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);\n+      return;\n+    }\n+\n+  ptr = (void *) (_Unwind_Internal_Ptr) context->reg[index];\n+\n+  if (size == sizeof(_Unwind_Ptr))\n+    * (_Unwind_Ptr *) ptr = val;\n+  else\n+    {\n+#if defined( __CR16C__ )\n+      if (size == sizeof(_Unwind_Word))\n+      * (_Unwind_Word *) ptr = val;\n+      else\n+\t{\n+\t  typedef unsigned _CR16_Unwind_Word __attribute__((__mode__(__word__)));\n+\t  gcc_assert (index + 1  <  (int) sizeof(dwarf_reg_size_table));\n+\t  * (_CR16_Unwind_Word *) ptr = val & 0xffff ;  /* low 16-bit */\n+\t  ptr = context->reg[index + 1];\n+\t  * (_CR16_Unwind_Word *) ptr = val >> 16 ;  /* high 16-bit */\n+\t}\n+#else\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      * (_Unwind_Word *) ptr = val;\n+#endif\t\n+    }\n+}\n+\n+/* Get the pointer to a register INDEX as saved in CONTEXT.  */\n+\n+static inline void *\n+_Unwind_GetGRPtr (struct _Unwind_Context *context, int index)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n+    return &context->reg[index];\n+  return (void *) (_Unwind_Internal_Ptr) context->reg[index];\n+}\n+\n+/* Set the pointer to a register INDEX as saved in CONTEXT.  */\n+\n+static inline void\n+_Unwind_SetGRPtr (struct _Unwind_Context *context, int index, void *p)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  if (_Unwind_IsExtendedContext (context))\n+    context->by_value[index] = 0;\n+  context->reg[index] = (_Unwind_Context_Reg_Val) (_Unwind_Internal_Ptr) p;\n+}\n+\n+/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */\n+\n+static inline void\n+_Unwind_SetGRValue (struct _Unwind_Context *context, int index,\n+\t\t    _Unwind_Word val)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n+  gcc_assert (dwarf_reg_size_table[index] == sizeof (_Unwind_Context_Reg_Val));\n+\n+  context->by_value[index] = 1;\n+  context->reg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);\n+}\n+\n+/* Return nonzero if register INDEX is stored by value rather than\n+   by reference.  */\n+\n+static inline int\n+_Unwind_GRByValue (struct _Unwind_Context *context, int index)\n+{\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  return context->by_value[index];\n+}\n+\n+/* Retrieve the return address for CONTEXT.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n+/* Retrieve the return address and flag whether that IP is before\n+   or after first not yet fully executed instruction.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = _Unwind_IsSignalFrame (context);\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n+/* Overwrite the return address for CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)\n+{\n+  context->ra = (void *) val;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)\n+{\n+  return context->lsda;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.func;\n+}\n+\n+void *\n+_Unwind_FindEnclosingFunction (void *pc)\n+{\n+  struct dwarf_eh_bases bases;\n+  const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, &bases);\n+  if (fde)\n+    return bases.func;\n+  else\n+    return NULL;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetDataRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.dbase;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetTextRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.tbase;\n+}\n+\n+#include \"md-unwind-support.h\"\n+\f\n+/* Extract any interesting information from the CIE for the translation\n+   unit F belongs to.  Return a pointer to the byte after the augmentation,\n+   or NULL if we encountered an undecipherable augmentation.  */\n+\n+static const unsigned char *\n+extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,\n+\t\t  _Unwind_FrameState *fs)\n+{\n+  const unsigned char *aug = cie->augmentation;\n+  const unsigned char *p = aug + strlen ((const char *)aug) + 1;\n+  const unsigned char *ret = NULL;\n+  _uleb128_t utmp;\n+  _sleb128_t stmp;\n+\n+  /* g++ v2 \"eh\" has pointer immediately following augmentation string,\n+     so it must be handled first.  */\n+  if (aug[0] == 'e' && aug[1] == 'h')\n+    {\n+      fs->eh_ptr = read_pointer (p);\n+      p += sizeof (void *);\n+      aug += 2;\n+    }\n+\n+  /* After the augmentation resp. pointer for \"eh\" augmentation\n+     follows for CIE version >= 4 address size byte and\n+     segment size byte.  */\n+  if (__builtin_expect (cie->version >= 4, 0))\n+    {\n+      if (p[0] != sizeof (void *) || p[1] != 0)\n+\treturn NULL;\n+      p += 2;\n+    }\n+  /* Immediately following this are the code and\n+     data alignment and return address column.  */\n+  p = read_uleb128 (p, &utmp);\n+  fs->code_align = (_Unwind_Word)utmp;\n+  p = read_sleb128 (p, &stmp);\n+  fs->data_align = (_Unwind_Sword)stmp;\n+  if (cie->version == 1)\n+    fs->retaddr_column = *p++;\n+  else\n+    {\n+      p = read_uleb128 (p, &utmp);\n+      fs->retaddr_column = (_Unwind_Word)utmp;\n+    }\n+  fs->lsda_encoding = DW_EH_PE_omit;\n+\n+  /* If the augmentation starts with 'z', then a uleb128 immediately\n+     follows containing the length of the augmentation field following\n+     the size.  */\n+  if (*aug == 'z')\n+    {\n+      p = read_uleb128 (p, &utmp);\n+      ret = p + utmp;\n+\n+      fs->saw_z = 1;\n+      ++aug;\n+    }\n+\n+  /* Iterate over recognized augmentation subsequences.  */\n+  while (*aug != '\\0')\n+    {\n+      /* \"L\" indicates a byte showing how the LSDA pointer is encoded.  */\n+      if (aug[0] == 'L')\n+\t{\n+\t  fs->lsda_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"R\" indicates a byte indicating how FDE addresses are encoded.  */\n+      else if (aug[0] == 'R')\n+\t{\n+\t  fs->fde_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"P\" indicates a personality routine in the CIE augmentation.  */\n+      else if (aug[0] == 'P')\n+\t{\n+\t  _Unwind_Ptr personality;\n+\n+\t  p = read_encoded_value (context, *p, p + 1, &personality);\n+\t  fs->personality = (_Unwind_Personality_Fn) personality;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"S\" indicates a signal frame.  */\n+      else if (aug[0] == 'S')\n+\t{\n+\t  fs->signal_frame = 1;\n+\t  aug += 1;\n+\t}\n+\n+      /* Otherwise we have an unknown augmentation string.\n+\t Bail unless we saw a 'z' prefix.  */\n+      else\n+\treturn ret;\n+    }\n+\n+  return ret ? ret : p;\n+}\n+\n+\n+/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL\n+   onto the stack to start.  */\n+\n+static _Unwind_Word\n+execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n+\t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n+{\n+  _Unwind_Word stack[64];\t/* ??? Assume this is enough.  */\n+  int stack_elt;\n+\n+  stack[0] = initial;\n+  stack_elt = 1;\n+\n+  while (op_ptr < op_end)\n+    {\n+      enum dwarf_location_atom op = *op_ptr++;\n+      _Unwind_Word result;\n+      _uleb128_t reg, utmp;\n+      _sleb128_t offset, stmp;\n+\n+      switch (op)\n+\t{\n+\tcase DW_OP_lit0:\n+\tcase DW_OP_lit1:\n+\tcase DW_OP_lit2:\n+\tcase DW_OP_lit3:\n+\tcase DW_OP_lit4:\n+\tcase DW_OP_lit5:\n+\tcase DW_OP_lit6:\n+\tcase DW_OP_lit7:\n+\tcase DW_OP_lit8:\n+\tcase DW_OP_lit9:\n+\tcase DW_OP_lit10:\n+\tcase DW_OP_lit11:\n+\tcase DW_OP_lit12:\n+\tcase DW_OP_lit13:\n+\tcase DW_OP_lit14:\n+\tcase DW_OP_lit15:\n+\tcase DW_OP_lit16:\n+\tcase DW_OP_lit17:\n+\tcase DW_OP_lit18:\n+\tcase DW_OP_lit19:\n+\tcase DW_OP_lit20:\n+\tcase DW_OP_lit21:\n+\tcase DW_OP_lit22:\n+\tcase DW_OP_lit23:\n+\tcase DW_OP_lit24:\n+\tcase DW_OP_lit25:\n+\tcase DW_OP_lit26:\n+\tcase DW_OP_lit27:\n+\tcase DW_OP_lit28:\n+\tcase DW_OP_lit29:\n+\tcase DW_OP_lit30:\n+\tcase DW_OP_lit31:\n+\t  result = op - DW_OP_lit0;\n+\t  break;\n+\n+\tcase DW_OP_addr:\n+\t  result = (_Unwind_Word) (_Unwind_Ptr) read_pointer (op_ptr);\n+\t  op_ptr += sizeof (void *);\n+\t  break;\n+\n+\tcase DW_OP_GNU_encoded_addr:\n+\t  {\n+\t    _Unwind_Ptr presult;\n+\t    op_ptr = read_encoded_value (context, *op_ptr, op_ptr+1, &presult);\n+\t    result = presult;\n+\t  }\n+\t  break;\n+\n+\tcase DW_OP_const1u:\n+\t  result = read_1u (op_ptr);\n+\t  op_ptr += 1;\n+\t  break;\n+\tcase DW_OP_const1s:\n+\t  result = read_1s (op_ptr);\n+\t  op_ptr += 1;\n+\t  break;\n+\tcase DW_OP_const2u:\n+\t  result = read_2u (op_ptr);\n+\t  op_ptr += 2;\n+\t  break;\n+\tcase DW_OP_const2s:\n+\t  result = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  break;\n+\tcase DW_OP_const4u:\n+\t  result = read_4u (op_ptr);\n+\t  op_ptr += 4;\n+\t  break;\n+\tcase DW_OP_const4s:\n+\t  result = read_4s (op_ptr);\n+\t  op_ptr += 4;\n+\t  break;\n+\tcase DW_OP_const8u:\n+\t  result = read_8u (op_ptr);\n+\t  op_ptr += 8;\n+\t  break;\n+\tcase DW_OP_const8s:\n+\t  result = read_8s (op_ptr);\n+\t  op_ptr += 8;\n+\t  break;\n+\tcase DW_OP_constu:\n+\t  op_ptr = read_uleb128 (op_ptr, &utmp);\n+\t  result = (_Unwind_Word)utmp;\n+\t  break;\n+\tcase DW_OP_consts:\n+\t  op_ptr = read_sleb128 (op_ptr, &stmp);\n+\t  result = (_Unwind_Sword)stmp;\n+\t  break;\n+\n+\tcase DW_OP_reg0:\n+\tcase DW_OP_reg1:\n+\tcase DW_OP_reg2:\n+\tcase DW_OP_reg3:\n+\tcase DW_OP_reg4:\n+\tcase DW_OP_reg5:\n+\tcase DW_OP_reg6:\n+\tcase DW_OP_reg7:\n+\tcase DW_OP_reg8:\n+\tcase DW_OP_reg9:\n+\tcase DW_OP_reg10:\n+\tcase DW_OP_reg11:\n+\tcase DW_OP_reg12:\n+\tcase DW_OP_reg13:\n+\tcase DW_OP_reg14:\n+\tcase DW_OP_reg15:\n+\tcase DW_OP_reg16:\n+\tcase DW_OP_reg17:\n+\tcase DW_OP_reg18:\n+\tcase DW_OP_reg19:\n+\tcase DW_OP_reg20:\n+\tcase DW_OP_reg21:\n+\tcase DW_OP_reg22:\n+\tcase DW_OP_reg23:\n+\tcase DW_OP_reg24:\n+\tcase DW_OP_reg25:\n+\tcase DW_OP_reg26:\n+\tcase DW_OP_reg27:\n+\tcase DW_OP_reg28:\n+\tcase DW_OP_reg29:\n+\tcase DW_OP_reg30:\n+\tcase DW_OP_reg31:\n+\t  result = _Unwind_GetGR (context, op - DW_OP_reg0);\n+\t  break;\n+\tcase DW_OP_regx:\n+\t  op_ptr = read_uleb128 (op_ptr, &reg);\n+\t  result = _Unwind_GetGR (context, reg);\n+\t  break;\n+\n+\tcase DW_OP_breg0:\n+\tcase DW_OP_breg1:\n+\tcase DW_OP_breg2:\n+\tcase DW_OP_breg3:\n+\tcase DW_OP_breg4:\n+\tcase DW_OP_breg5:\n+\tcase DW_OP_breg6:\n+\tcase DW_OP_breg7:\n+\tcase DW_OP_breg8:\n+\tcase DW_OP_breg9:\n+\tcase DW_OP_breg10:\n+\tcase DW_OP_breg11:\n+\tcase DW_OP_breg12:\n+\tcase DW_OP_breg13:\n+\tcase DW_OP_breg14:\n+\tcase DW_OP_breg15:\n+\tcase DW_OP_breg16:\n+\tcase DW_OP_breg17:\n+\tcase DW_OP_breg18:\n+\tcase DW_OP_breg19:\n+\tcase DW_OP_breg20:\n+\tcase DW_OP_breg21:\n+\tcase DW_OP_breg22:\n+\tcase DW_OP_breg23:\n+\tcase DW_OP_breg24:\n+\tcase DW_OP_breg25:\n+\tcase DW_OP_breg26:\n+\tcase DW_OP_breg27:\n+\tcase DW_OP_breg28:\n+\tcase DW_OP_breg29:\n+\tcase DW_OP_breg30:\n+\tcase DW_OP_breg31:\n+\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;\n+\t  break;\n+\tcase DW_OP_bregx:\n+\t  op_ptr = read_uleb128 (op_ptr, &reg);\n+\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  result = _Unwind_GetGR (context, reg) + (_Unwind_Word)offset;\n+\t  break;\n+\n+\tcase DW_OP_dup:\n+\t  gcc_assert (stack_elt);\n+\t  result = stack[stack_elt - 1];\n+\t  break;\n+\n+\tcase DW_OP_drop:\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n+\t  goto no_push;\n+\n+\tcase DW_OP_pick:\n+\t  offset = *op_ptr++;\n+\t  gcc_assert (offset < stack_elt - 1);\n+\t  result = stack[stack_elt - 1 - offset];\n+\t  break;\n+\n+\tcase DW_OP_over:\n+\t  gcc_assert (stack_elt >= 2);\n+\t  result = stack[stack_elt - 2];\n+\t  break;\n+\n+\tcase DW_OP_swap:\n+\t  {\n+\t    _Unwind_Word t;\n+\t    gcc_assert (stack_elt >= 2);\n+\t    t = stack[stack_elt - 1];\n+\t    stack[stack_elt - 1] = stack[stack_elt - 2];\n+\t    stack[stack_elt - 2] = t;\n+\t    goto no_push;\n+\t  }\n+\n+\tcase DW_OP_rot:\n+\t  {\n+\t    _Unwind_Word t1, t2, t3;\n+\n+\t    gcc_assert (stack_elt >= 3);\n+\t    t1 = stack[stack_elt - 1];\n+\t    t2 = stack[stack_elt - 2];\n+\t    t3 = stack[stack_elt - 3];\n+\t    stack[stack_elt - 1] = t2;\n+\t    stack[stack_elt - 2] = t3;\n+\t    stack[stack_elt - 3] = t1;\n+\t    goto no_push;\n+\t  }\n+\n+\tcase DW_OP_deref:\n+\tcase DW_OP_deref_size:\n+\tcase DW_OP_abs:\n+\tcase DW_OP_neg:\n+\tcase DW_OP_not:\n+\tcase DW_OP_plus_uconst:\n+\t  /* Unary operations.  */\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n+\n+\t  result = stack[stack_elt];\n+\n+\t  switch (op)\n+\t    {\n+\t    case DW_OP_deref:\n+\t      {\n+\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n+\t\tresult = (_Unwind_Ptr) read_pointer (ptr);\n+\t      }\n+\t      break;\n+\n+\t    case DW_OP_deref_size:\n+\t      {\n+\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n+\t\tswitch (*op_ptr++)\n+\t\t  {\n+\t\t  case 1:\n+\t\t    result = read_1u (ptr);\n+\t\t    break;\n+\t\t  case 2:\n+\t\t    result = read_2u (ptr);\n+\t\t    break;\n+\t\t  case 4:\n+\t\t    result = read_4u (ptr);\n+\t\t    break;\n+\t\t  case 8:\n+\t\t    result = read_8u (ptr);\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    case DW_OP_abs:\n+\t      if ((_Unwind_Sword) result < 0)\n+\t\tresult = -result;\n+\t      break;\n+\t    case DW_OP_neg:\n+\t      result = -result;\n+\t      break;\n+\t    case DW_OP_not:\n+\t      result = ~result;\n+\t      break;\n+\t    case DW_OP_plus_uconst:\n+\t      op_ptr = read_uleb128 (op_ptr, &utmp);\n+\t      result += (_Unwind_Word)utmp;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\n+\tcase DW_OP_and:\n+\tcase DW_OP_div:\n+\tcase DW_OP_minus:\n+\tcase DW_OP_mod:\n+\tcase DW_OP_mul:\n+\tcase DW_OP_or:\n+\tcase DW_OP_plus:\n+\tcase DW_OP_shl:\n+\tcase DW_OP_shr:\n+\tcase DW_OP_shra:\n+\tcase DW_OP_xor:\n+\tcase DW_OP_le:\n+\tcase DW_OP_ge:\n+\tcase DW_OP_eq:\n+\tcase DW_OP_lt:\n+\tcase DW_OP_gt:\n+\tcase DW_OP_ne:\n+\t  {\n+\t    /* Binary operations.  */\n+\t    _Unwind_Word first, second;\n+\t    gcc_assert (stack_elt >= 2);\n+\t    stack_elt -= 2;\n+\n+\t    second = stack[stack_elt];\n+\t    first = stack[stack_elt + 1];\n+\n+\t    switch (op)\n+\t      {\n+\t      case DW_OP_and:\n+\t\tresult = second & first;\n+\t\tbreak;\n+\t      case DW_OP_div:\n+\t\tresult = (_Unwind_Sword) second / (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_minus:\n+\t\tresult = second - first;\n+\t\tbreak;\n+\t      case DW_OP_mod:\n+\t\tresult = second % first;\n+\t\tbreak;\n+\t      case DW_OP_mul:\n+\t\tresult = second * first;\n+\t\tbreak;\n+\t      case DW_OP_or:\n+\t\tresult = second | first;\n+\t\tbreak;\n+\t      case DW_OP_plus:\n+\t\tresult = second + first;\n+\t\tbreak;\n+\t      case DW_OP_shl:\n+\t\tresult = second << first;\n+\t\tbreak;\n+\t      case DW_OP_shr:\n+\t\tresult = second >> first;\n+\t\tbreak;\n+\t      case DW_OP_shra:\n+\t\tresult = (_Unwind_Sword) second >> first;\n+\t\tbreak;\n+\t      case DW_OP_xor:\n+\t\tresult = second ^ first;\n+\t\tbreak;\n+\t      case DW_OP_le:\n+\t\tresult = (_Unwind_Sword) second <= (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_ge:\n+\t\tresult = (_Unwind_Sword) second >= (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_eq:\n+\t\tresult = (_Unwind_Sword) second == (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_lt:\n+\t\tresult = (_Unwind_Sword) second < (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_gt:\n+\t\tresult = (_Unwind_Sword) second > (_Unwind_Sword) first;\n+\t\tbreak;\n+\t      case DW_OP_ne:\n+\t\tresult = (_Unwind_Sword) second != (_Unwind_Sword) first;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase DW_OP_skip:\n+\t  offset = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  op_ptr += offset;\n+\t  goto no_push;\n+\n+\tcase DW_OP_bra:\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n+\n+\t  offset = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  if (stack[stack_elt] != 0)\n+\t    op_ptr += offset;\n+\t  goto no_push;\n+\n+\tcase DW_OP_nop:\n+\t  goto no_push;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Most things push a result value.  */\n+      gcc_assert ((size_t) stack_elt < sizeof(stack)/sizeof(*stack));\n+      stack[stack_elt++] = result;\n+    no_push:;\n+    }\n+\n+  /* We were executing this program to get a value.  It should be\n+     at top of stack.  */\n+  gcc_assert (stack_elt);\n+  stack_elt -= 1;\n+  return stack[stack_elt];\n+}\n+\n+\n+/* Decode DWARF 2 call frame information. Takes pointers the\n+   instruction sequence to decode, current register information and\n+   CIE info, and the PC range to evaluate.  */\n+\n+static void\n+execute_cfa_program (const unsigned char *insn_ptr,\n+\t\t     const unsigned char *insn_end,\n+\t\t     struct _Unwind_Context *context,\n+\t\t     _Unwind_FrameState *fs)\n+{\n+  struct frame_state_reg_info *unused_rs = NULL;\n+\n+  /* Don't allow remember/restore between CIE and FDE programs.  */\n+  fs->regs.prev = NULL;\n+\n+  /* The comparison with the return address uses < rather than <= because\n+     we are only interested in the effects of code before the call; for a\n+     noreturn function, the return address may point to unrelated code with\n+     a different stack configuration that we are not interested in.  We\n+     assume that the call itself is unwind info-neutral; if not, or if\n+     there are delay instructions that adjust the stack, these must be\n+     reflected at the point immediately before the call insn.\n+     In signal frames, return address is after last completed instruction,\n+     so we add 1 to return address to make the comparison <=.  */\n+  while (insn_ptr < insn_end\n+\t && fs->pc < context->ra + _Unwind_IsSignalFrame (context))\n+    {\n+      unsigned char insn = *insn_ptr++;\n+      _uleb128_t reg, utmp;\n+      _sleb128_t offset, stmp;\n+\n+      if ((insn & 0xc0) == DW_CFA_advance_loc)\n+\tfs->pc += (insn & 0x3f) * fs->code_align;\n+      else if ((insn & 0xc0) == DW_CFA_offset)\n+\t{\n+\t  reg = insn & 0x3f;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  offset = (_Unwind_Sword) utmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t}\n+      else if ((insn & 0xc0) == DW_CFA_restore)\n+\t{\n+\t  reg = insn & 0x3f;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_UNSAVED;\n+\t}\n+      else switch (insn)\n+\t{\n+\tcase DW_CFA_set_loc:\n+\t  {\n+\t    _Unwind_Ptr pc;\n+\n+\t    insn_ptr = read_encoded_value (context, fs->fde_encoding,\n+\t\t\t\t\t   insn_ptr, &pc);\n+\t    fs->pc = (void *) pc;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_advance_loc1:\n+\t  fs->pc += read_1u (insn_ptr) * fs->code_align;\n+\t  insn_ptr += 1;\n+\t  break;\n+\tcase DW_CFA_advance_loc2:\n+\t  fs->pc += read_2u (insn_ptr) * fs->code_align;\n+\t  insn_ptr += 2;\n+\t  break;\n+\tcase DW_CFA_advance_loc4:\n+\t  fs->pc += read_4u (insn_ptr) * fs->code_align;\n+\t  insn_ptr += 4;\n+\t  break;\n+\n+\tcase DW_CFA_offset_extended:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  offset = (_Unwind_Sword) utmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  break;\n+\n+\tcase DW_CFA_restore_extended:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  /* FIXME, this is wrong; the CIE might have said that the\n+\t     register was saved somewhere.  */\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n+\t  break;\n+\n+\tcase DW_CFA_same_value:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n+\t  break;\n+\n+\tcase DW_CFA_undefined:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNDEFINED;\n+\t  break;\n+\n+\tcase DW_CFA_nop:\n+\t  break;\n+\n+\tcase DW_CFA_register:\n+\t  {\n+\t    _uleb128_t reg2;\n+\t    insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t    insn_ptr = read_uleb128 (insn_ptr, &reg2);\n+\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_REG;\n+\t    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.reg =\n+\t      (_Unwind_Word)reg2;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_remember_state:\n+\t  {\n+\t    struct frame_state_reg_info *new_rs;\n+\t    if (unused_rs)\n+\t      {\n+\t\tnew_rs = unused_rs;\n+\t\tunused_rs = unused_rs->prev;\n+\t      }\n+\t    else\n+\t      new_rs = alloca (sizeof (struct frame_state_reg_info));\n+\n+\t    *new_rs = fs->regs;\n+\t    fs->regs.prev = new_rs;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_restore_state:\n+\t  {\n+\t    struct frame_state_reg_info *old_rs = fs->regs.prev;\n+\t    fs->regs = *old_rs;\n+\t    old_rs->prev = unused_rs;\n+\t    unused_rs = old_rs;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  fs->regs.cfa_reg = (_Unwind_Word)utmp;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  fs->regs.cfa_offset = (_Unwind_Word)utmp;\n+\t  fs->regs.cfa_how = CFA_REG_OFFSET;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_register:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  fs->regs.cfa_reg = (_Unwind_Word)utmp;\n+\t  fs->regs.cfa_how = CFA_REG_OFFSET;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  fs->regs.cfa_offset = utmp;\n+\t  /* cfa_how deliberately not set.  */\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_expression:\n+\t  fs->regs.cfa_exp = insn_ptr;\n+\t  fs->regs.cfa_how = CFA_EXP;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  insn_ptr += utmp;\n+\t  break;\n+\n+\tcase DW_CFA_expression:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_EXP;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  insn_ptr += utmp;\n+\t  break;\n+\n+\t  /* Dwarf3.  */\n+\tcase DW_CFA_offset_extended_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n+\t  offset = stmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  fs->regs.cfa_reg = (_Unwind_Word)utmp;\n+\t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n+\t  fs->regs.cfa_offset = (_Unwind_Sword)stmp;\n+\t  fs->regs.cfa_how = CFA_REG_OFFSET;\n+\t  fs->regs.cfa_offset *= fs->data_align;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n+\t  fs->regs.cfa_offset = (_Unwind_Sword)stmp;\n+\t  fs->regs.cfa_offset *= fs->data_align;\n+\t  /* cfa_how deliberately not set.  */\n+\t  break;\n+\n+\tcase DW_CFA_val_offset:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  offset = (_Unwind_Sword) utmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_VAL_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  break;\n+\n+\tcase DW_CFA_val_offset_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_sleb128 (insn_ptr, &stmp);\n+\t  offset = stmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_VAL_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;\n+\t  break;\n+\n+\tcase DW_CFA_val_expression:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_VAL_EXP;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  insn_ptr += utmp;\n+\t  break;\n+\n+\tcase DW_CFA_GNU_window_save:\n+\t  /* ??? Hardcoded for SPARC register window configuration.  */\n+\t  for (reg = 16; reg < 32; ++reg)\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);\n+\t    }\n+\t  break;\n+\n+\tcase DW_CFA_GNU_args_size:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  context->args_size = (_Unwind_Word)utmp;\n+\t  break;\n+\n+\tcase DW_CFA_GNU_negative_offset_extended:\n+\t  /* Obsoleted by DW_CFA_offset_extended_sf, but used by\n+\t     older PowerPC code.  */\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &utmp);\n+\t  offset = (_Unwind_Word) utmp * fs->data_align;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how\n+\t    = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = -offset;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\f\n+/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for\n+   its caller and decode it into FS.  This function also sets the\n+   args_size and lsda members of CONTEXT, as they are really information\n+   about the caller's frame.  */\n+\n+static _Unwind_Reason_Code\n+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  const struct dwarf_fde *fde;\n+  const struct dwarf_cie *cie;\n+  const unsigned char *aug, *insn, *end;\n+\n+  memset (fs, 0, sizeof (*fs));\n+  context->args_size = 0;\n+  context->lsda = 0;\n+\n+  if (context->ra == 0)\n+    return _URC_END_OF_STACK;\n+\n+  fde = _Unwind_Find_FDE (context->ra + _Unwind_IsSignalFrame (context) - 1,\n+\t\t\t  &context->bases);\n+  if (fde == NULL)\n+    {\n+#ifdef MD_FALLBACK_FRAME_STATE_FOR\n+      /* Couldn't find frame unwind info for this function.  Try a\n+\t target-specific fallback mechanism.  This will necessarily\n+\t not provide a personality routine or LSDA.  */\n+      return MD_FALLBACK_FRAME_STATE_FOR (context, fs);\n+#else\n+      return _URC_END_OF_STACK;\n+#endif\n+    }\n+\n+  fs->pc = context->bases.func;\n+\n+  cie = get_cie (fde);\n+  insn = extract_cie_info (cie, context, fs);\n+  if (insn == NULL)\n+    /* CIE contained unknown augmentation.  */\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  /* First decode all the insns in the CIE.  */\n+  end = (const unsigned char *) next_fde ((const struct dwarf_fde *) cie);\n+  execute_cfa_program (insn, end, context, fs);\n+\n+  /* Locate augmentation for the fde.  */\n+  aug = (const unsigned char *) fde + sizeof (*fde);\n+  aug += 2 * size_of_encoded_value (fs->fde_encoding);\n+  insn = NULL;\n+  if (fs->saw_z)\n+    {\n+      _uleb128_t i;\n+      aug = read_uleb128 (aug, &i);\n+      insn = aug + i;\n+    }\n+  if (fs->lsda_encoding != DW_EH_PE_omit)\n+    {\n+      _Unwind_Ptr lsda;\n+\n+      aug = read_encoded_value (context, fs->lsda_encoding, aug, &lsda);\n+      context->lsda = (void *) lsda;\n+    }\n+\n+  /* Then the insns in the FDE up to our target PC.  */\n+  if (insn == NULL)\n+    insn = aug;\n+  end = (const unsigned char *) next_fde (fde);\n+  execute_cfa_program (insn, end, context, fs);\n+\n+  return _URC_NO_REASON;\n+}\n+\f\n+typedef struct frame_state\n+{\n+  void *cfa;\n+  void *eh_ptr;\n+  long cfa_offset;\n+  long args_size;\n+  long reg_or_offset[PRE_GCC3_DWARF_FRAME_REGISTERS+1];\n+  unsigned short cfa_reg;\n+  unsigned short retaddr_column;\n+  char saved[PRE_GCC3_DWARF_FRAME_REGISTERS+1];\n+} frame_state;\n+\n+struct frame_state * __frame_state_for (void *, struct frame_state *);\n+\n+/* Called from pre-G++ 3.0 __throw to find the registers to restore for\n+   a given PC_TARGET.  The caller should allocate a local variable of\n+   `struct frame_state' and pass its address to STATE_IN.  */\n+\n+struct frame_state *\n+__frame_state_for (void *pc_target, struct frame_state *state_in)\n+{\n+  struct _Unwind_Context context;\n+  _Unwind_FrameState fs;\n+  int reg;\n+\n+  memset (&context, 0, sizeof (struct _Unwind_Context));\n+  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n+    context.flags = EXTENDED_CONTEXT_BIT;\n+  context.ra = pc_target + 1;\n+\n+  if (uw_frame_state_for (&context, &fs) != _URC_NO_REASON)\n+    return 0;\n+\n+  /* We have no way to pass a location expression for the CFA to our\n+     caller.  It wouldn't understand it anyway.  */\n+  if (fs.regs.cfa_how == CFA_EXP)\n+    return 0;\n+\n+  for (reg = 0; reg < PRE_GCC3_DWARF_FRAME_REGISTERS + 1; reg++)\n+    {\n+      state_in->saved[reg] = fs.regs.reg[reg].how;\n+      switch (state_in->saved[reg])\n+\t{\n+\tcase REG_SAVED_REG:\n+\t  state_in->reg_or_offset[reg] = fs.regs.reg[reg].loc.reg;\n+\t  break;\n+\tcase REG_SAVED_OFFSET:\n+\t  state_in->reg_or_offset[reg] = fs.regs.reg[reg].loc.offset;\n+\t  break;\n+\tdefault:\n+\t  state_in->reg_or_offset[reg] = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  state_in->cfa_offset = fs.regs.cfa_offset;\n+  state_in->cfa_reg = fs.regs.cfa_reg;\n+  state_in->retaddr_column = fs.retaddr_column;\n+  state_in->args_size = context.args_size;\n+  state_in->eh_ptr = fs.eh_ptr;\n+\n+  return state_in;\n+}\n+\f\n+typedef union { _Unwind_Ptr ptr; _Unwind_Word word; } _Unwind_SpTmp;\n+\n+static inline void\n+_Unwind_SetSpColumn (struct _Unwind_Context *context, void *cfa,\n+\t\t     _Unwind_SpTmp *tmp_sp)\n+{\n+  int size = dwarf_reg_size_table[__builtin_dwarf_sp_column ()];\n+\n+  if (size == sizeof(_Unwind_Ptr))\n+    tmp_sp->ptr = (_Unwind_Ptr) cfa;\n+  else\n+    {\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      tmp_sp->word = (_Unwind_Ptr) cfa;\n+    }\n+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), tmp_sp);\n+}\n+\n+static void\n+uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct _Unwind_Context orig_context = *context;\n+  void *cfa;\n+  long i;\n+\n+#ifdef EH_RETURN_STACKADJ_RTX\n+  /* Special handling here: Many machines do not use a frame pointer,\n+     and track the CFA only through offsets from the stack pointer from\n+     one frame to the next.  In this case, the stack pointer is never\n+     stored, so it has no saved address in the context.  What we do\n+     have is the CFA from the previous stack frame.\n+\n+     In very special situations (such as unwind info for signal return),\n+     there may be location expressions that use the stack pointer as well.\n+\n+     Do this conditionally for one frame.  This allows the unwind info\n+     for one frame to save a copy of the stack pointer from the previous\n+     frame, and be able to use much easier CFA mechanisms to do it.\n+     Always zap the saved stack pointer value for the next frame; carrying\n+     the value over from one frame to another doesn't make sense.  */\n+\n+  _Unwind_SpTmp tmp_sp;\n+\n+  if (!_Unwind_GetGRPtr (&orig_context, __builtin_dwarf_sp_column ()))\n+    _Unwind_SetSpColumn (&orig_context, context->cfa, &tmp_sp);\n+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), NULL);\n+#endif\n+\n+  /* Compute this frame's CFA.  */\n+  switch (fs->regs.cfa_how)\n+    {\n+    case CFA_REG_OFFSET:\n+      cfa = _Unwind_GetPtr (&orig_context, fs->regs.cfa_reg);\n+      cfa += fs->regs.cfa_offset;\n+      break;\n+\n+    case CFA_EXP:\n+      {\n+\tconst unsigned char *exp = fs->regs.cfa_exp;\n+\t_uleb128_t len;\n+\n+\texp = read_uleb128 (exp, &len);\n+\tcfa = (void *) (_Unwind_Ptr)\n+\t  execute_stack_op (exp, exp + len, &orig_context, 0);\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  context->cfa = cfa;\n+\n+  /* Compute the addresses of all registers saved in this frame.  */\n+  for (i = 0; i < DWARF_FRAME_REGISTERS + 1; ++i)\n+    switch (fs->regs.reg[i].how)\n+      {\n+      case REG_UNSAVED:\n+      case REG_UNDEFINED:\n+\tbreak;\n+\n+      case REG_SAVED_OFFSET:\n+\t_Unwind_SetGRPtr (context, i,\n+\t\t\t  (void *) (cfa + fs->regs.reg[i].loc.offset));\n+\tbreak;\n+\n+      case REG_SAVED_REG:\n+\tif (_Unwind_GRByValue (&orig_context, fs->regs.reg[i].loc.reg))\n+\t  _Unwind_SetGRValue (context, i,\n+\t\t\t      _Unwind_GetGR (&orig_context,\n+\t\t\t\t\t     fs->regs.reg[i].loc.reg));\n+\telse\n+\t  _Unwind_SetGRPtr (context, i,\n+\t\t\t    _Unwind_GetGRPtr (&orig_context,\n+\t\t\t\t\t      fs->regs.reg[i].loc.reg));\n+\tbreak;\n+\n+      case REG_SAVED_EXP:\n+\t{\n+\t  const unsigned char *exp = fs->regs.reg[i].loc.exp;\n+\t  _uleb128_t len;\n+\t  _Unwind_Ptr val;\n+\n+\t  exp = read_uleb128 (exp, &len);\n+\t  val = execute_stack_op (exp, exp + len, &orig_context,\n+\t\t\t\t  (_Unwind_Ptr) cfa);\n+\t  _Unwind_SetGRPtr (context, i, (void *) val);\n+\t}\n+\tbreak;\n+\n+      case REG_SAVED_VAL_OFFSET:\n+\t_Unwind_SetGRValue (context, i,\n+\t\t\t    (_Unwind_Internal_Ptr)\n+\t\t\t    (cfa + fs->regs.reg[i].loc.offset));\n+\tbreak;\n+\n+      case REG_SAVED_VAL_EXP:\n+\t{\n+\t  const unsigned char *exp = fs->regs.reg[i].loc.exp;\n+\t  _uleb128_t len;\n+\t  _Unwind_Ptr val;\n+\n+\t  exp = read_uleb128 (exp, &len);\n+\t  val = execute_stack_op (exp, exp + len, &orig_context,\n+\t\t\t\t  (_Unwind_Ptr) cfa);\n+\t  _Unwind_SetGRValue (context, i, val);\n+\t}\n+\tbreak;\n+      }\n+\n+  _Unwind_SetSignalFrame (context, fs->signal_frame);\n+\n+#ifdef MD_FROB_UPDATE_CONTEXT\n+  MD_FROB_UPDATE_CONTEXT (context, fs);\n+#endif\n+}\n+\n+/* CONTEXT describes the unwind state for a frame, and FS describes the FDE\n+   of its caller.  Update CONTEXT to refer to the caller as well.  Note\n+   that the args_size and lsda members are not updated here, but later in\n+   uw_frame_state_for.  */\n+\n+static void\n+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  uw_update_context_1 (context, fs);\n+\n+  /* In general this unwinder doesn't make any distinction between\n+     undefined and same_value rule.  Call-saved registers are assumed\n+     to have same_value rule by default and explicit undefined\n+     rule is handled like same_value.  The only exception is\n+     DW_CFA_undefined on retaddr_column which is supposed to\n+     mark outermost frame in DWARF 3.  */\n+  if (fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (fs->retaddr_column)].how\n+      == REG_UNDEFINED)\n+    /* uw_frame_state_for uses context->ra == 0 check to find outermost\n+       stack frame.  */\n+    context->ra = 0;\n+  else\n+    /* Compute the return address now, since the return address column\n+       can change from frame to frame.  */\n+    context->ra = __builtin_extract_return_addr\n+      (_Unwind_GetPtr (context, fs->retaddr_column));\n+#if defined( __CR16C__ )\n+  context->ra = (void*)( ( (unsigned)context->ra ) << 1 ) ;\n+#endif\n+}\n+\n+static void\n+uw_advance_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  uw_update_context (context, fs);\n+}\n+\f\n+/* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n+   level will be the return address and the CFA.  */\n+\n+#define uw_init_context(CONTEXT)\t\t\t\t\t   \\\n+  do\t\t\t\t\t\t\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      /* Do any necessary initialization to access arbitrary stack frames. \\\n+\t On the SPARC, this means flushing the register windows.  */\t   \\\n+      __builtin_unwind_init ();\t\t\t\t\t\t   \\\n+      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),\t\t   \\\n+\t\t\t __builtin_return_address (0));\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+  while (0)\n+\n+static inline void\n+init_dwarf_reg_size_table (void)\n+{\n+  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);\n+}\n+\n+static void __attribute__((noinline))\n+uw_init_context_1 (struct _Unwind_Context *context,\n+\t\t   void *outer_cfa, void *outer_ra)\n+{\n+  void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n+  _Unwind_FrameState fs;\n+  _Unwind_SpTmp sp_slot;\n+  _Unwind_Reason_Code code;\n+\n+  memset (context, 0, sizeof (struct _Unwind_Context));\n+  context->ra = ra;\n+  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n+    context->flags = EXTENDED_CONTEXT_BIT;\n+\n+  code = uw_frame_state_for (context, &fs);\n+  gcc_assert (code == _URC_NO_REASON);\n+\n+#if __GTHREADS\n+  {\n+    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;\n+    if (__gthread_once (&once_regsizes, init_dwarf_reg_size_table) != 0\n+\t&& dwarf_reg_size_table[0] == 0)\n+      init_dwarf_reg_size_table ();\n+  }\n+#else\n+  if (dwarf_reg_size_table[0] == 0)\n+    init_dwarf_reg_size_table ();\n+#endif\n+\n+  /* Force the frame state to use the known cfa value.  */\n+  _Unwind_SetSpColumn (context, outer_cfa, &sp_slot);\n+  fs.regs.cfa_how = CFA_REG_OFFSET;\n+  fs.regs.cfa_reg = __builtin_dwarf_sp_column ();\n+#if !defined( __CR16C__ )\n+  fs.regs.cfa_offset = 0;\n+#else\n+  fs.regs.cfa_offset -= context->args_size ;\n+#endif\n+\n+  uw_update_context_1 (context, &fs);\n+\n+  /* If the return address column was saved in a register in the\n+     initialization context, then we can't see it in the given\n+     call frame data.  So have the initialization context tell us.  */\n+  context->ra = __builtin_extract_return_addr (outer_ra);\n+}\n+\n+static void _Unwind_DebugHook (void *, void *)\n+  __attribute__ ((__noinline__, __used__, __noclone__));\n+\n+/* This function is called during unwinding.  It is intended as a hook\n+   for a debugger to intercept exceptions.  CFA is the CFA of the\n+   target frame.  HANDLER is the PC to which control will be\n+   transferred.  */\n+static void\n+_Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),\n+\t\t   void *handler __attribute__ ((__unused__)))\n+{\n+  /* We only want to use stap probes starting with v3.  Earlier\n+     versions added too much startup cost.  */\n+#if defined (HAVE_SYS_SDT_H) && defined (STAP_PROBE2) && _SDT_NOTE_TYPE >= 3\n+  STAP_PROBE2 (libgcc, unwind, cfa, handler);\n+#else\n+  asm (\"\");\n+#endif\n+}\n+\n+/* Install TARGET into CURRENT so that we can return to it.  This is a\n+   macro because __builtin_eh_return must be invoked in the context of\n+   our caller.  */\n+#if defined( __CR16C__ )\n+\n+#define uw_install_context(CURRENT, TARGET)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      long offset = uw_install_context_1 ((CURRENT), (TARGET));\t\t\\\n+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);\t\\\n+      handler = (void*)( ( (unsigned)handler ) >> 1 ) ;                 \\\n+      _Unwind_DebugHook ((TARGET)->cfa, handler);\t\t\t\\\n+      __builtin_eh_return (offset, handler);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#else\n+#define uw_install_context(CURRENT, TARGET)                             \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      long offset = uw_install_context_1 ((CURRENT), (TARGET));         \\\n+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);        \\\n+      _Unwind_DebugHook ((TARGET)->cfa, handler);                       \\\n+      __builtin_eh_return (offset, handler);                            \\\n+    }                                                                   \\\n+  while (0)\n+#endif  /* __CR16C__ */\n+\n+static long\n+uw_install_context_1 (struct _Unwind_Context *current,\n+\t\t      struct _Unwind_Context *target)\n+{\n+  long i;\n+  _Unwind_SpTmp sp_slot;\n+\n+  /* If the target frame does not have a saved stack pointer,\n+     then set up the target's CFA.  */\n+  if (!_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))\n+    _Unwind_SetSpColumn (target, target->cfa, &sp_slot);\n+\n+  for (i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n+    {\n+      void *c = (void *) (_Unwind_Internal_Ptr) current->reg[i];\n+      void *t = (void *) (_Unwind_Internal_Ptr)target->reg[i];\n+\n+      gcc_assert (current->by_value[i] == 0);\n+      if (target->by_value[i] && c)\n+\t{\n+\t  _Unwind_Word w;\n+\t  _Unwind_Ptr p;\n+\t  if (dwarf_reg_size_table[i] == sizeof (_Unwind_Word))\n+\t    {\n+\t      w = (_Unwind_Internal_Ptr) t;\n+\t      memcpy (c, &w, sizeof (_Unwind_Word));\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (dwarf_reg_size_table[i] == sizeof (_Unwind_Ptr));\n+\t      p = (_Unwind_Internal_Ptr) t;\n+\t      memcpy (c, &p, sizeof (_Unwind_Ptr));\n+\t    }\n+\t}\n+      else if (t && c && t != c)\n+\tmemcpy (c, t, dwarf_reg_size_table[i]);\n+    }\n+\n+  /* If the current frame doesn't have a saved stack pointer, then we\n+     need to rely on EH_RETURN_STACKADJ_RTX to get our target stack\n+     pointer value reloaded.  */\n+  if (!_Unwind_GetGRPtr (current, __builtin_dwarf_sp_column ()))\n+    {\n+      void *target_cfa;\n+\n+      target_cfa = _Unwind_GetPtr (target, __builtin_dwarf_sp_column ());\n+\n+      /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n+      if (STACK_GROWS_DOWNWARD)\n+\treturn target_cfa - current->cfa + target->args_size;\n+      else\n+\treturn current->cfa - target_cfa - target->args_size;\n+    }\n+  return 0;\n+}\n+\n+static inline _Unwind_Ptr\n+uw_identify_context (struct _Unwind_Context *context)\n+{\n+  /* The CFA is not sufficient to disambiguate the context of a function\n+     interrupted by a signal before establishing its frame and the context\n+     of the signal itself.  */\n+  if (STACK_GROWS_DOWNWARD)\n+    return _Unwind_GetCFA (context) - _Unwind_IsSignalFrame (context);\n+  else\n+    return _Unwind_GetCFA (context) + _Unwind_IsSignalFrame (context);\n+}\n+\n+\n+#include \"unwind.inc\"\n+\n+#if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)\n+alias (_Unwind_Backtrace);\n+alias (_Unwind_DeleteException);\n+alias (_Unwind_FindEnclosingFunction);\n+alias (_Unwind_ForcedUnwind);\n+alias (_Unwind_GetDataRelBase);\n+alias (_Unwind_GetTextRelBase);\n+alias (_Unwind_GetCFA);\n+alias (_Unwind_GetGR);\n+alias (_Unwind_GetIP);\n+alias (_Unwind_GetLanguageSpecificData);\n+alias (_Unwind_GetRegionStart);\n+alias (_Unwind_RaiseException);\n+alias (_Unwind_Resume);\n+alias (_Unwind_Resume_or_Rethrow);\n+alias (_Unwind_SetGR);\n+alias (_Unwind_SetIP);\n+#endif\n+\n+#endif /* !USING_SJLJ_EXCEPTIONS */"}, {"sha": "28ff74e14c08d4ad10d07004db52d5102f1be189", "filename": "libgcc/config/cr16/unwind-dw2.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Funwind-dw2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d/libgcc%2Fconfig%2Fcr16%2Funwind-dw2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcr16%2Funwind-dw2.h?ref=b25364a0b9e59bb9ef6d7d9740dfb750ec27f40d", "patch": "@@ -0,0 +1,87 @@\n+/* DWARF2 frame unwind data structure.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2009,\n+   2010, 2011, 2012 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* A target can override (perhaps for backward compatibility) how\n+   many dwarf2 columns are unwound.  */\n+#ifndef DWARF_FRAME_REGISTERS\n+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n+#endif\n+\n+/* The result of interpreting the frame unwind info for a frame.\n+   This is all symbolic at this point, as none of the values can\n+   be resolved until the target pc is located.  */\n+typedef struct\n+{\n+  /* Each register save state can be described in terms of a CFA slot,\n+     another register, or a location expression.  */\n+  struct frame_state_reg_info\n+  {\n+    struct {\n+      union {\n+\t_Unwind_Word reg;\n+\t_Unwind_Sword offset;\n+\tconst unsigned char *exp;\n+      } loc;\n+      enum {\n+\tREG_UNSAVED,\n+\tREG_SAVED_OFFSET,\n+\tREG_SAVED_REG,\n+\tREG_SAVED_EXP,\n+\tREG_SAVED_VAL_OFFSET,\n+\tREG_SAVED_VAL_EXP,\n+\tREG_UNDEFINED\n+      } how;\n+    } reg[DWARF_FRAME_REGISTERS+1];\n+\n+    /* Used to implement DW_CFA_remember_state.  */\n+    struct frame_state_reg_info *prev;\n+\n+    /* The CFA can be described in terms of a reg+offset or a\n+       location expression.  */\n+    _Unwind_Sword cfa_offset;\n+    _Unwind_Word cfa_reg;\n+    const unsigned char *cfa_exp;\n+    enum {\n+      CFA_UNSET,\n+      CFA_REG_OFFSET,\n+      CFA_EXP\n+    } cfa_how;\n+  } regs;\n+\n+  /* The PC described by the current frame state.  */\n+  void *pc;\n+\n+  /* The information we care about from the CIE/FDE.  */\n+  _Unwind_Personality_Fn personality;\n+  _Unwind_Sword data_align;\n+  _Unwind_Word code_align;\n+  _Unwind_Word retaddr_column;\n+  unsigned char fde_encoding;\n+  unsigned char lsda_encoding;\n+  unsigned char saw_z;\n+  unsigned char signal_frame;\n+  void *eh_ptr;\n+} _Unwind_FrameState;\n+"}]}