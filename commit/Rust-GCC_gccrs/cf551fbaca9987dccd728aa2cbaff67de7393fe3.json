{"sha": "cf551fbaca9987dccd728aa2cbaff67de7393fe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y1NTFmYmFjYTk5ODdkY2NkNzI4YWEyY2JhZmY2N2RlNzM5M2ZlMw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-01-16T22:37:49Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-01-16T22:37:49Z"}, "message": "cppcharset.c (one_iso88591_to_utf8): New function.\n\n2004-01-16  Eric Christopher  <echristo@redhat.com>\n\t    Chandrakala Chavva <cchavva@redhat.com>\n\n\t* cppcharset.c (one_iso88591_to_utf8): New function.\n\t(convert_iso88591_utf8): Ditto. Use.\n\t(conversion_tab): Use.\n\t(_cpp_input_to_utf8): New function.\n\t(_cpp_init_iconv_buffer): Ditto.\n\t(_cpp_close_iconv_buffer): Ditto.\n\t* cpphash.h: Prototype new functions.\n\t(cpp_buffer): Add input_cset_desc.\n\t* cppinit.c: Add input_charset default.\n\t* cpplib.c (cpp_push_buffer): Support init and\n\tclose of iconv.\n\t* cpplib.h (cpp_options): Add input_charset.\n\nFrom-SVN: r76000", "tree": {"sha": "95190a526a0984976fac3a95910e9a5e961bea4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95190a526a0984976fac3a95910e9a5e961bea4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf551fbaca9987dccd728aa2cbaff67de7393fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf551fbaca9987dccd728aa2cbaff67de7393fe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf551fbaca9987dccd728aa2cbaff67de7393fe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf551fbaca9987dccd728aa2cbaff67de7393fe3/comments", "author": null, "committer": null, "parents": [{"sha": "2f9c39f8fc04b38b6aac1ad71c83b22cede8b9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9c39f8fc04b38b6aac1ad71c83b22cede8b9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f9c39f8fc04b38b6aac1ad71c83b22cede8b9e9"}], "stats": {"total": 147, "additions": 129, "deletions": 18}, "files": [{"sha": "8a3d1fdfaca3220156d809f77cc71c3f7aff0a33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -1,3 +1,19 @@\n+2004-01-16  Eric Christopher  <echristo@redhat.com>\n+\t    Chandrakala Chavva <cchavva@redhat.com>\n+\n+\t* cppcharset.c (one_iso88591_to_utf8): New function.\n+\t(convert_iso88591_utf8): Ditto. Use.\n+\t(conversion_tab): Use.\n+\t(_cpp_input_to_utf8): New function.\n+\t(_cpp_init_iconv_buffer): Ditto.\n+\t(_cpp_close_iconv_buffer): Ditto.\n+\t* cpphash.h: Prototype new functions.\n+\t(cpp_buffer): Add input_cset_desc.\n+\t* cppinit.c: Add input_charset default.\n+\t* cpplib.c (cpp_push_buffer): Support init and\n+\tclose of iconv.\n+\t* cpplib.h (cpp_options): Add input_charset.\n+\n 2004-01-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* system.h (ASM_OUTPUT_SECTION_NAME): Poison.\n@@ -14,23 +30,23 @@\n \t* fixinc/tests/base/sys/stat.h: Adapt for new hackname.\n \n \t* fixinc/inclhack.def (alpha___extern_prefix,\n-\talpha___extern_prefix_standards): New hacks to obey \n+\talpha___extern_prefix_standards): New hacks to obey\n  \t__PRAGMA_EXTERN_PREFIX.\n \t* fixinc/tests/base/testing.h [ALPHA___EXTERN_PREFIX_CHECK]: New\n \ttest.\n \t* fixinc/tests/base/standards.h: Likewise.\n-\t\n+\n \t* fixincl/inclhack.def (alpha_pthread): Tweak to match more\n \tvariations.\n \tNew testcase.\n \t* fixinc/tests/base/pthread.h: Handle it.\n-\t\n+\n \t* fixincl/inclhack.def (bad_lval): Sort file list.\n \tAdd many missing files up to Tru64 UNIX V5.1B.\n \t* gcc/fixinc/tests/base/libgen.h: Renamed to ...\n \t* gcc/fixinc/tests/base/dirent.h: ... this to match new file list\n \torder.\n-\t\n+\n \t* fixinc/fixincl.x: Regenerate.\n \n 2004-01-16  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "5070366e3a8cfdfe0d4f508068b64cf9d16c2ba9", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 84, "deletions": 7, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -170,7 +170,7 @@ one_utf8_to_cppchar (const uchar **inbufp, size_t *inbytesleftp,\n {\n   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n-  \n+\n   cppchar_t c;\n   const uchar *inbuf = *inbufp;\n   size_t nbytes, i;\n@@ -274,7 +274,7 @@ one_cppchar_to_utf8 (cppchar_t c, uchar **outbufp, size_t *outbytesleftp)\n    The return value is either 0 for success, or an errno value for\n    failure, which may be E2BIG (need more space), EILSEQ (ill-formed\n    input sequence), ir EINVAL (incomplete input sequence).  */\n-   \n+\n static inline int\n one_utf8_to_utf32 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n \t\t   uchar **outbufp, size_t *outbytesleftp)\n@@ -446,6 +446,31 @@ one_utf16_to_utf8 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n   return 0;\n }\n \n+/* The first 256 code points of ISO 8859.1 have the same numeric\n+   values as the first 256 code points of Unicode, therefore the\n+   incoming ISO 8859.1 character can be passed directly to\n+   one_cppchar_to_utf8 (which expects a Unicode value).  */\n+\n+static int\n+one_iso88591_to_utf8 (iconv_t bigend ATTRIBUTE_UNUSED, const uchar **inbufp,\n+\t\t      size_t *inbytesleftp, uchar **outbufp, size_t *outbytesleftp)\n+{\n+  const uchar *inbuf = *inbufp;\n+  int rval;\n+\n+  if (*inbytesleftp > 1)\n+    return EINVAL;\n+\n+  rval = one_cppchar_to_utf8 ((cppchar_t)*inbuf, outbufp, outbytesleftp);\n+  if (rval)\n+    return rval;\n+\n+  *inbufp += 1;\n+  *inbytesleftp -= 1;\n+\n+  return 0;\n+}\n+\n /* Helper routine for the next few functions.  The 'const' on\n    one_conversion means that we promise not to modify what function is\n    pointed to, which lets the inliner see through it.  */\n@@ -489,7 +514,7 @@ conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n       outbuf = to->text + to->asize - outbytesleft;\n     }\n }\n-\t\t \n+\n \n /* These functions convert entire strings between character sets.\n    They all have the signature\n@@ -529,6 +554,14 @@ convert_utf32_utf8 (iconv_t cd, const uchar *from, size_t flen,\n   return conversion_loop (one_utf32_to_utf8, cd, from, flen, to);\n }\n \n+static bool\n+convert_iso88591_utf8 (iconv_t cd, const uchar *from, size_t flen,\n+                       struct _cpp_strbuf *to)\n+{\n+  return conversion_loop (one_iso88591_to_utf8, cd, from, flen, to);\n+}\n+\n+\n /* Identity conversion, used when we have no alternative.  */\n static bool\n convert_no_conversion (iconv_t cd ATTRIBUTE_UNUSED,\n@@ -606,6 +639,7 @@ static const struct conversion conversion_tab[] = {\n   { \"UTF-32BE/UTF-8\", convert_utf32_utf8, (iconv_t)1 },\n   { \"UTF-16LE/UTF-8\", convert_utf16_utf8, (iconv_t)0 },\n   { \"UTF-16BE/UTF-8\", convert_utf16_utf8, (iconv_t)1 },\n+  { \"ISO-8859-1/UTF-8\", convert_iso88591_utf8, (iconv_t)0 },\n };\n \n /* Subroutine of cpp_init_iconv: initialize and return a\n@@ -619,7 +653,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n   struct cset_converter ret;\n   char *pair;\n   size_t i;\n-  \n+\n   if (!strcasecmp (to, from))\n     {\n       ret.func = convert_no_conversion;\n@@ -649,7 +683,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n       if (ret.cd == (iconv_t) -1)\n \t{\n \t  if (errno == EINVAL)\n-\t    cpp_error (pfile, CPP_DL_ERROR, /* XXX should be DL_SORRY */\n+\t    cpp_error (pfile, CPP_DL_ERROR, /* FIXME should be DL_SORRY */\n \t\t       \"conversion from %s to %s not supported by iconv\",\n \t\t       from, to);\n \t  else\n@@ -660,7 +694,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n     }\n   else\n     {\n-      cpp_error (pfile, CPP_DL_ERROR, /* XXX should be DL_SORRY */\n+      cpp_error (pfile, CPP_DL_ERROR, /* FIXME: should be DL_SORRY */\n \t\t \"no iconv implementation, cannot convert from %s to %s\",\n \t\t from, to);\n       ret.func = convert_no_conversion;\n@@ -1270,7 +1304,7 @@ narrow_str_to_charconst (cpp_reader *pfile, cpp_string str,\n   *unsignedp = unsigned_p;\n   return result;\n }\n-\t\t\t \n+\n /* Subroutine of cpp_interpret_charconst which performs the conversion\n    to a number, for wide strings.  STR is the string structure returned\n    by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for\n@@ -1352,3 +1386,46 @@ cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n \n   return result;\n }\n+\n+uchar *\n+_cpp_input_to_utf8 (cpp_reader *pfile, const uchar *input, cppchar_t length)\n+{\n+  struct _cpp_strbuf tbuf;\n+  struct cset_converter cvt = pfile->buffer->input_cset_desc;\n+\n+  tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, length);\n+  tbuf.text = xmalloc (tbuf.asize);\n+  tbuf.len = 0;\n+\n+  if (!APPLY_CONVERSION (cvt, input, length, &tbuf))\n+   {\n+      cpp_error (pfile, CPP_DL_ERROR, \"converting input to source character set.\");\n+      return NULL;\n+   }\n+\n+  if (length)\n+    tbuf.text[tbuf.len] = '\\n';\n+  else\n+    tbuf.text[0] = '\\n';\n+\n+  return tbuf.text;\n+}\n+\n+  /* Check the input file format. At present assuming the input file\n+     is in iso-8859-1 format. Convert this input character set to\n+     source character set format (UTF-8). */\n+\n+void\n+_cpp_init_iconv_buffer (cpp_reader *pfile, const char *from)\n+{\n+  pfile->buffer->input_cset_desc = init_iconv_desc (pfile, SOURCE_CHARSET,\n+\t\t\t\t\t\t    from);\n+}\n+\n+void\n+_cpp_close_iconv_buffer (cpp_reader *pfile)\n+{\n+  if (HAVE_ICONV\n+      && pfile->buffer->input_cset_desc.func == convert_using_iconv)\n+    iconv_close (pfile->buffer->input_cset_desc.cd);\n+}"}, {"sha": "6c13ea1c0b17254dce06070ce0c5eaf43d5c699b", "filename": "gcc/cpphash.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -270,7 +270,7 @@ struct cpp_buffer\n   const uchar *cur;\t\t/* Current location.  */\n   const uchar *line_base;\t/* Start of current physical line.  */\n   const uchar *next_line;\t/* Start of to-be-cleaned logical line.  */\n-  \n+\n   const uchar *buf;\t\t/* Entire character buffer.  */\n   const uchar *rlimit;\t\t/* Writable byte at end of file.  */\n \n@@ -313,6 +313,10 @@ struct cpp_buffer\n \n   /* Used for buffer overlays by cpptrad.c.  */\n   const uchar *saved_cur, *saved_rlimit;\n+\n+  /* Descriptor for converting from the input character set to the\n+     source character set.  */\n+  struct cset_converter input_cset_desc;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n@@ -557,6 +561,9 @@ extern void _cpp_init_internal_pragmas (cpp_reader *);\n extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n \t\t\t\t unsigned int, unsigned int);\n extern void _cpp_pop_buffer (cpp_reader *);\n+extern uchar *_cpp_input_to_utf8 (cpp_reader *, const unsigned char *, cppchar_t);\n+extern void _cpp_init_iconv_buffer (cpp_reader *, const char *);\n+extern void _cpp_close_iconv_buffer (cpp_reader *);\n \n /* In cpptrad.c.  */\n extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *);"}, {"sha": "629da2734a7d13ae5b9c7c7082996e570f0ed7b3", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -161,6 +161,9 @@ cpp_create_reader (enum c_lang lang, hash_table *table)\n   CPP_OPTION (pfile, narrow_charset) = 0;\n   CPP_OPTION (pfile, wide_charset) = 0;\n \n+  /* Default the input character set to iso-8859-1 for now. */\n+  CPP_OPTION (pfile, input_charset) = \"ISO-8859-1\";\n+\n   /* A fake empty \"directory\" used as the starting point for files\n      looked up without a search path.  Name cannot be '/' because we\n      don't want to prepend anything at all to filenames using it.  All"}, {"sha": "feb8717745b8d40803b9e61a5dbafcf953451797", "filename": "gcc/cpplib.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -549,14 +549,14 @@ do_undef (cpp_reader *pfile)\n /* Undefine a single macro/assertion/whatever.  */\n \n static int\n-undefine_macros (cpp_reader *pfile, cpp_hashnode *h, \n+undefine_macros (cpp_reader *pfile, cpp_hashnode *h,\n \t\t void *data_p ATTRIBUTE_UNUSED)\n {\n   switch (h->type)\n     {\n     case NT_VOID:\n       break;\n-      \n+\n     case NT_MACRO:\n       if (pfile->cb.undef)\n         (*pfile->cb.undef) (pfile, pfile->directive_line, h);\n@@ -855,7 +855,7 @@ do_linemarker (cpp_reader *pfile)\n       cpp_string s = { 0, 0 };\n       if (_cpp_interpret_string_notranslate (pfile, &token->val.str, &s))\n \tnew_file = (const char *)s.text;\n-      \n+\n       new_sysp = 0;\n       flag = read_flag (pfile, 0);\n       if (flag == 1)\n@@ -1159,7 +1159,7 @@ do_pragma (cpp_reader *pfile)\n       (*p->u.handler) (pfile);\n       if (pfile->cb.line_change)\n \t(*pfile->cb.line_change) (pfile, pfile->cur_token, false);\n-      \n+\n     }\n   else if (pfile->cb.def_pragma)\n     {\n@@ -1925,6 +1925,7 @@ cpp_push_buffer (cpp_reader *pfile, const uchar *buffer, size_t len,\n \t\t int from_stage3)\n {\n   cpp_buffer *new = xobnew (&pfile->buffer_ob, cpp_buffer);\n+  const char *input = CPP_OPTION (pfile, input_charset);\n \n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n@@ -1936,6 +1937,8 @@ cpp_push_buffer (cpp_reader *pfile, const uchar *buffer, size_t len,\n   new->need_line = true;\n \n   pfile->buffer = new;\n+  _cpp_init_iconv_buffer (pfile, input);\n+\n   return new;\n }\n \n@@ -1957,6 +1960,8 @@ _cpp_pop_buffer (cpp_reader *pfile)\n   /* In case of a missing #endif.  */\n   pfile->state.skipping = 0;\n \n+  _cpp_close_iconv_buffer (pfile);\n+\n   /* _cpp_do_file_change expects pfile->buffer to be the new one.  */\n   pfile->buffer = buffer->prev;\n "}, {"sha": "f7e12d200b7c65a7c04925111e24615da308d12f", "filename": "gcc/cpplib.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf551fbaca9987dccd728aa2cbaff67de7393fe3/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cf551fbaca9987dccd728aa2cbaff67de7393fe3", "patch": "@@ -332,6 +332,9 @@ struct cpp_options\n   /* Holds the name of the target wide character set.  */\n   const char *wide_charset;\n \n+  /* Holds the name of the input character set.  */\n+  const char *input_charset;\n+\n   /* True to warn about precompiled header files we couldn't use.  */\n   bool warn_invalid_pch;\n \n@@ -417,7 +420,7 @@ struct cpp_dir\n   /* Mapping of file names for this directory for MS-DOS and related\n      platforms.  A NULL-terminated array of (from, to) pairs.  */\n   const char **name_map;\n-    \n+\n   /* The C front end uses these to recognize duplicated\n      directories in the search path.  */\n   ino_t ino;\n@@ -481,7 +484,7 @@ struct cpp_hashnode GTY(())\n {\n   struct ht_identifier ident;\n   unsigned int is_directive : 1;\n-  unsigned int directive_index : 7;\t/* If is_directive, \n+  unsigned int directive_index : 7;\t/* If is_directive,\n \t\t\t\t\t   then index into directive table.\n \t\t\t\t\t   Otherwise, a NODE_OPERATOR.  */\n   unsigned char rid_code;\t\t/* Rid code - for front ends.  */"}]}