{"sha": "7bdcf888aaa78808dc2dd4e16e70458244a607be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkY2Y4ODhhYWE3ODgwOGRjMmRkNGUxNmU3MDQ1ODI0NGE2MDdiZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-06-12T08:47:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-06-12T08:47:48Z"}, "message": "re PR c++/3089 (ICE in dfs_accumulate_vtbl_inits)\n\ncp:\n\tPR c++/3089\n\t* class.c (dfs_accumulate_vtbl_inits): Always walk down the\n\thierarchy looking for primary bases for a ctor\n\tvtable. Recursively call oneself, if we meet our primary via\n\tthis route and haven't met it yet via inheritance graph order.\ntestsuite:\n\t* g++.old-deja/g++.abi/vbase4.C: New test.\n\nFrom-SVN: r43248", "tree": {"sha": "8b3d53c05d660b1ff673c9a0fba8a13a8ecbd8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b3d53c05d660b1ff673c9a0fba8a13a8ecbd8ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bdcf888aaa78808dc2dd4e16e70458244a607be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bdcf888aaa78808dc2dd4e16e70458244a607be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bdcf888aaa78808dc2dd4e16e70458244a607be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bdcf888aaa78808dc2dd4e16e70458244a607be/comments", "author": null, "committer": null, "parents": [{"sha": "5a2dd36ccd1ee21ef038ce6f6775a422020787bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2dd36ccd1ee21ef038ce6f6775a422020787bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2dd36ccd1ee21ef038ce6f6775a422020787bd"}], "stats": {"total": 365, "additions": 283, "deletions": 82}, "files": [{"sha": "577038eccc22fc7dd224e66bb530a1cdca4b53d4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7bdcf888aaa78808dc2dd4e16e70458244a607be", "patch": "@@ -1,3 +1,11 @@\n+2001-06-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/3089\n+\t* class.c (dfs_accumulate_vtbl_inits): Always walk down the\n+\thierarchy looking for primary bases for a ctor\n+\tvtable. Recursively call oneself, if we meet our primary via\n+\tthis route and haven't met it yet via inheritance graph order.\n+\n 2001-06-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lang-options.h: Emit documentation for -fno-honor-std, not"}, {"sha": "a0cd2ce1c9e82dd883e5465bc99acbe9ac953298", "filename": "gcc/cp/class.c", "status": "modified", "additions": 106, "deletions": 82, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7bdcf888aaa78808dc2dd4e16e70458244a607be", "patch": "@@ -7409,7 +7409,7 @@ build_ctor_vtbl_group (binfo, t)\n   tree id;\n   tree vbase;\n \n-  /* See if we've already create this construction vtable group.  */\n+  /* See if we've already created this construction vtable group.  */\n   id = mangle_ctor_vtbl_for_type (t, binfo);\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n@@ -7525,91 +7525,118 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n   tree vtbl = NULL_TREE;\n   int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n-  if (ctor_vtbl_p\n-      && TREE_VIA_VIRTUAL (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n+  if (ctor_vtbl_p)\n     {\n-      /* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a primary\n-         virtual base.  If it is not the same primary in the hierarchy of T,\n-         we'll need to generate a ctor vtable for it, to place at its\n-         location in T.  If it is the same primary, we still need a VTT\n-         entry for the vtable, but it should point to the ctor vtable for the\n-\t base it is a primary for within the sub-hierarchy of RTTI_BINFO.\n-\n-\t There are three possible cases:\n-\n-         1) We are in the same place.\n-\t 2) We are a primary base within a lost primary virtual base of\n-\t    RTTI_BINFO.\n-\t 3) We are not primary to anything else in RTTI_BINFO.  */\n-\n-      tree primary = NULL_TREE;\n-      if (tree_int_cst_equal (BINFO_OFFSET (orig_binfo),\n-\t\t\t      size_diffop (BINFO_OFFSET (binfo),\n-\t\t\t\t\t   BINFO_OFFSET (rtti_binfo))))\n+      tree primary = binfo;\n+      tree orig_primary = orig_binfo;\n+      \n+      if (TREE_VIA_VIRTUAL (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n \t{\n-\t  /* Case 1: We're in the same place relative to RTTI_BINFO as we\n-\t     were in the complete type, so we are primary either to\n-\t     RTTI_BINFO or one of its secondary bases.  */\n-\n-\t  tree b = BINFO_PRIMARY_BASE_OF (binfo);\n-\n-\t  /* Walk down our until we either find the last primary base or\n-\t     rtti_binfo.  */\n-\t  for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+\t  /* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a\n+             primary virtual base.  If it is not the same primary in\n+             the hierarchy of T, we'll need to generate a ctor vtable\n+             for it, to place at its location in T.  If it is the same\n+             primary, we still need a VTT entry for the vtable, but it\n+             should point to the ctor vtable for the base it is a\n+             primary for within the sub-hierarchy of RTTI_BINFO.\n+\t      \n+\t     There are three possible cases:\n+\t      \n+             1) We are in the same place.\n+\t     2) We are a primary base within a lost primary virtual base of\n+\t     RTTI_BINFO.\n+\t     3) We are not primary to anything else in RTTI_BINFO.  */\n+\t  \n+\t  if (tree_int_cst_equal (BINFO_OFFSET (orig_binfo),\n+\t\t\t\t  size_diffop (BINFO_OFFSET (binfo),\n+\t\t\t\t\t       BINFO_OFFSET (rtti_binfo))))\n \t    {\n-\t      primary = b;\n-\t      if (b == rtti_binfo)\n-\t\tbreak;\n-\t    }\n-        }\n-      else\n-\t{\n-\t  /* Case 2 or 3: We're not in the same place.  We might still be\n-\t     primary to something within a lost primary virtual base of\n-\t     RTTI_BINFO.  */\n-\n-\t  tree b = BINFO_PRIMARY_BASE_OF (binfo);\n-\t  tree last;\n+\t      /* Case 1: We're in the same place relative to\n+\t     \t RTTI_BINFO as we were in the complete type, so we are\n+\t     \t primary either to RTTI_BINFO or one of its secondary\n+\t     \t bases.  */\n+\t      \n+\t      /* Walk down our until we either find the last\n+\t     \t primary base or rtti_binfo.  */\n+\t      tree b = BINFO_PRIMARY_BASE_OF (binfo);\n \n-\t  /* First, look through the bases we are primary to for a virtual\n-\t     base.  */\n-\t  for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+\t      for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+\t\t{\n+\t\t  primary = b;\n+\t\t  orig_primary = BINFO_PRIMARY_BASE_OF (orig_primary);\n+\t\t  if (b == rtti_binfo)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n-\t      last = b;\n-\t      if (TREE_VIA_VIRTUAL (b))\n-\t\tbreak;\n+\t      /* Case 2 or 3: We're not in the same place.  We might\n+\t         still be primary to something within a lost primary\n+\t         virtual base of RTTI_BINFO.  */\n+\t      tree b;\n+\t      tree last, orig_last;\n+\n+\t      /* First, look through the bases we are primary to for a\n+\t     \t virtual base.  */\n+\t      for (b = BINFO_PRIMARY_BASE_OF (binfo), orig_last = orig_binfo;\n+\t\t   b;\n+\t\t   b = BINFO_PRIMARY_BASE_OF (b))\n+\t\t{\n+\t\t  last = b;\n+\t\t  if (orig_last)\n+\t\t    orig_last = BINFO_PRIMARY_BASE_OF (orig_last);\n+\t\t  if (TREE_VIA_VIRTUAL (b))\n+\t\t    break;\n+\t\t}\n+\t      /* If we run out of primary links, keep looking down our\n+\t     \t inheritance chain; we might be an indirect primary of\n+\t     \t a virtual base.  */\n+\t      if (b == NULL_TREE)\n+\t\tfor (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n+\t\t  if (TREE_VIA_VIRTUAL (b))\n+\t\t    break;\n+\n+\t      /* If we found a virtual base B and it is a base of\n+\t     \t RTTI_BINFO, we share our vtable with LAST, i.e. the\n+\t     \t derived-most base within B of which we are a primary.\n+\t     \t Otherwise, we get our own.  */\n+\t      if (b && binfo_for_vbase (BINFO_TYPE (b),\n+\t\t\t\t\tBINFO_TYPE (rtti_binfo)))\n+\t\t{\n+\t\t  my_friendly_assert (orig_last, 20010611);\n+\t\t  primary = last;\n+\t\t  orig_primary = orig_last;\n+\t\t}\n \t    }\n-\t  /* If we run out of primary links, keep looking down our\n-\t     inheritance chain; we might be an indirect primary of a\n-\t     virtual base.  */\n-\t  if (b == NULL_TREE)\n-\t    for (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n-\t      if (TREE_VIA_VIRTUAL (b))\n-\t\tbreak;\n-\n-\t  /* If we found a virtual base B and it is a base of RTTI_BINFO, we\n-\t     share our vtable with LAST, i.e. the derived-most base within\n-\t     B of which we are a primary.  Otherwise, we get our own.  */\n-\t  if (b && binfo_for_vbase (BINFO_TYPE (b),\n-\t\t\t\t    BINFO_TYPE (rtti_binfo)))\n-\t    primary = last;\n \t}\n-\n-      if (primary)\n+      \n+      vtbl = BINFO_VTABLE (primary);\n+      if (vtbl && TREE_CODE (vtbl) == TREE_LIST\n+\t  && TREE_PURPOSE (vtbl) == rtti_binfo)\n \t{\n-          vtbl = BINFO_VTABLE (primary);\n-\t  /* If we haven't already been here for our primary derivation,\n-\t     all bets are off.  Especially for case 2 above, we need\n-\t     the derived vtable to have been generated.  */\n-\t  my_friendly_assert (TREE_CODE (vtbl) == TREE_LIST\n-\t\t\t      && TREE_PURPOSE (vtbl) == rtti_binfo,\n-\t\t\t      20010126);\n \t  vtbl = TREE_VALUE (vtbl);\n+\t  if (primary == binfo)\n+\t    /* We created this vtable because we met its primary base\n+\t       earlier in the inheritance graph walk of\n+\t       RTTI_BINFO.  */\n+\t    return inits;\n \t}\n+      else if (primary != binfo)\n+\t{\n+\t  /* We're the primary of some binfo that we've not yet\n+\t     met in the inheritance graph walk of RTTI_BINFO. We\n+\t     must create that vtable now. */\n+\t  inits = dfs_accumulate_vtbl_inits (primary, orig_primary,\n+\t\t\t\t\t     rtti_binfo, t, l);\n+\t  vtbl = BINFO_VTABLE (primary);\n+\t  vtbl = TREE_VALUE (vtbl);\n+\t}\n+      else\n+\tvtbl = NULL;\n     }\n   else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo, BINFO_TYPE (rtti_binfo)))\n     return inits;\n-  \n+\n   if (!vtbl)\n     {\n       tree index;\n@@ -7635,19 +7662,16 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n       TREE_CONSTANT (vtbl) = 1;\n     }\n \n-  if (!ctor_vtbl_p)\n-    {\n-      /* For an ordinary vtable, set BINFO_VTABLE.  */\n-      if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo))\n-\tinits = NULL_TREE;\n-      else\n-\tBINFO_VTABLE (binfo) = vtbl;\n-    }\n-  else\n+  if (ctor_vtbl_p)\n     /* For a construction vtable, we can't overwrite BINFO_VTABLE.\n        So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n        straighten this out.  */\n     BINFO_VTABLE (binfo) = tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n+  else if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo))\n+    inits = NULL_TREE;\n+  else\n+     /* For an ordinary vtable, set BINFO_VTABLE.  */\n+    BINFO_VTABLE (binfo) = vtbl;\n \n   return inits;\n }"}, {"sha": "a4dfba0301cf24000436cd6be59d5d4a5f17e985", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7bdcf888aaa78808dc2dd4e16e70458244a607be", "patch": "@@ -1,3 +1,7 @@\n+2001-06-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/vbase4.C: New test.\n+\n 2001-06-11  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* gcc.c-torture/execute/920501-8.x: New file, sprintf() does not"}, {"sha": "116d79bec652264139a1861923e55f0ceb18db4e", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vbase4.C", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdcf888aaa78808dc2dd4e16e70458244a607be/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase4.C?ref=7bdcf888aaa78808dc2dd4e16e70458244a607be", "patch": "@@ -0,0 +1,165 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 9 Jun 2001 <nathan@codesourcery.com>\n+\n+// Bug 3089. We ICE'd in construction vtables.\n+\n+int failed;\n+\n+void fail (int val)\n+{\n+  if (!failed)\n+    failed = val;\n+}\n+\n+struct A\n+{\n+  virtual ~A();\n+  A ();\n+  virtual void check (void *whole, void *base);\n+};\n+\n+A::A ()\n+{\n+  check (this, this);\n+}\n+A::~A ()\n+{\n+  check (this, this);\n+}\n+\n+void A::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (1);\n+  else if (this != base)\n+    fail (2);\n+}\n+\n+struct B\n+{\n+  virtual ~B ();\n+  B ();\n+  virtual void check (void *whole, void *base);\n+};\n+\n+B::B ()\n+{\n+  check (this, this);\n+}\n+B::~B ()\n+{\n+  check (this, this);\n+}\n+void B::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (3);\n+  else if (this != base)\n+    fail (4);\n+}\n+\n+struct C : virtual public B, virtual public A\n+{\n+  virtual ~C ();\n+  C ();\n+  virtual void check (void *whole, void *base);\n+};\n+C::C ()\n+{\n+  check (this, this);\n+}\n+C::~C ()\n+{\n+  check (this, this);\n+}\n+void C::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (5);\n+  else if (this != base)\n+    fail (6);\n+  A::check (whole, static_cast <A *> (this));\n+  B::check (whole, static_cast <B *> (this));\n+}\n+\n+struct D : virtual public A\n+{\n+  virtual ~D ();\n+  D ();\n+  virtual void check (void *whole, void *base);\n+};\n+D::D ()\n+{\n+  check (this, this);\n+}\n+D::~D ()\n+{\n+  check (this, this);\n+}\n+void D::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (5);\n+  else if (this != base)\n+    fail (6);\n+  A::check (whole, static_cast <A *> (this));\n+}\n+\n+struct E : virtual public C, virtual public D\n+{\n+  virtual ~E ();\n+  E ();\n+  virtual void check (void *whole, void *base);\n+};\n+E::E ()\n+{\n+  check (this, this);\n+}\n+E::~E ()\n+{\n+  check (this, this);\n+}\n+void E::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (5);\n+  else if (this != base)\n+    fail (6);\n+  C::check (whole, static_cast <C *> (this));\n+  D::check (whole, static_cast <D *> (this));\n+}\n+\n+struct F : virtual public E\n+{\n+  virtual ~F ();\n+  F ();\n+  virtual void check (void *whole, void *base);\n+};\n+F::F ()\n+{\n+  check (this, this);\n+}\n+F::~F ()\n+{\n+  check (this, this);\n+}\n+void F::check (void *whole, void *base)\n+{\n+  if (dynamic_cast <void *> (this) != whole)\n+    fail (5);\n+  else if (this != base)\n+    fail (6);\n+  E::check (whole, static_cast <F *> (this));\n+}\n+\n+int main ()\n+{\n+  A a;\n+  B b;\n+  C c;\n+  D d;\n+  E e;\n+  F f;\n+  \n+  return failed;\n+}"}]}