{"sha": "00952e9784e41f1ee7a1e4384904a5fd42f610a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5NTJlOTc4NGU0MWYxZWU3YTFlNDM4NDkwNGE1ZmQ0MmY2MTBhNg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-08T12:22:30Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-08T12:22:30Z"}, "message": "re PR rtl-optimization/33928 (30% performance slowdown in floating-point code caused by  r118475)\n\n2009-05-08  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/33928\n\tPR 26854\n\t* fwprop.c (use_def_ref, get_def_for_use, bitmap_only_bit_bitween,\n\tprocess_uses, build_single_def_use_links): New.\n\t(update_df): Update use_def_ref.\n\t(forward_propagate_into): Use get_def_for_use instead of use-def\n\tchains.\n\t(fwprop_init): Call build_single_def_use_links and let it initialize\n\tdataflow.\n\t(fwprop_done): Free use_def_ref.\n\t(fwprop_addr): Eliminate duplicate call to df_set_flags.\n\t* df-problems.c (df_rd_simulate_artificial_defs_at_top, \n\tdf_rd_simulate_one_insn): New.\n\t(df_rd_bb_local_compute_process_def): Update head comment.\n\t(df_chain_create_bb): Use the new RD simulation functions.\n\t* df.h (df_rd_simulate_artificial_defs_at_top, \n\tdf_rd_simulate_one_insn): New.\n\t* opts.c (decode_options): Enable fwprop at -O1.\n\t* doc/invoke.texi (-fforward-propagate): Document this.\n\nFrom-SVN: r147282", "tree": {"sha": "556125bd3f1ec87bfe5654cb4bf76058c22173f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/556125bd3f1ec87bfe5654cb4bf76058c22173f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00952e9784e41f1ee7a1e4384904a5fd42f610a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00952e9784e41f1ee7a1e4384904a5fd42f610a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00952e9784e41f1ee7a1e4384904a5fd42f610a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00952e9784e41f1ee7a1e4384904a5fd42f610a6/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca862e9dd939d7dd686b771f401012fb9ed9bfe"}], "stats": {"total": 270, "additions": 205, "deletions": 65}, "files": [{"sha": "ca1f4832935d1ce91807932541de6b76176f0f4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -1,3 +1,25 @@\n+2009-05-08  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/33928\n+\tPR 26854\n+\t* fwprop.c (use_def_ref, get_def_for_use, bitmap_only_bit_bitween,\n+\tprocess_uses, build_single_def_use_links): New.\n+\t(update_df): Update use_def_ref.\n+\t(forward_propagate_into): Use get_def_for_use instead of use-def\n+\tchains.\n+\t(fwprop_init): Call build_single_def_use_links and let it initialize\n+\tdataflow.\n+\t(fwprop_done): Free use_def_ref.\n+\t(fwprop_addr): Eliminate duplicate call to df_set_flags.\n+\t* df-problems.c (df_rd_simulate_artificial_defs_at_top, \n+\tdf_rd_simulate_one_insn): New.\n+\t(df_rd_bb_local_compute_process_def): Update head comment.\n+\t(df_chain_create_bb): Use the new RD simulation functions.\n+\t* df.h (df_rd_simulate_artificial_defs_at_top, \n+\tdf_rd_simulate_one_insn): New.\n+\t* opts.c (decode_options): Enable fwprop at -O1.\n+\t* doc/invoke.texi (-fforward-propagate): Document this.\n+\n 2009-05-08  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/24581"}, {"sha": "f48da9bc8dc081d7de60b4fee2a7f18221826b56", "filename": "gcc/df-problems.c", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -316,7 +316,61 @@ df_rd_alloc (bitmap all_blocks)\n }\n \n \n-/* Process a list of DEFs for df_rd_bb_local_compute.  */\n+/* Add the effect of the top artificial defs of BB to the reaching definitions\n+   bitmap LOCAL_RD.  */\n+\n+void\n+df_rd_simulate_artificial_defs_at_top (basic_block bb, bitmap local_rd)\n+{\n+  int bb_index = bb->index;\n+  df_ref *def_rec;\n+  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\t{\n+\t  unsigned int dregno = DF_REF_REGNO (def);\n+\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t    bitmap_clear_range (local_rd, \n+\t\t\t\tDF_DEFS_BEGIN (dregno), \n+\t\t\t\tDF_DEFS_COUNT (dregno));\n+\t  bitmap_set_bit (local_rd, DF_REF_ID (def));\n+\t}\n+    }\n+}\n+\n+/* Add the effect of the defs of INSN to the reaching definitions bitmap\n+   LOCAL_RD.  */\n+\n+void\n+df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n+\t\t\t bitmap local_rd)\n+{\n+  unsigned uid = INSN_UID (insn);\n+  df_ref *def_rec;\n+\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      unsigned int dregno = DF_REF_REGNO (def);\n+      if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n+          || (dregno >= FIRST_PSEUDO_REGISTER))\n+        {\n+          if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t    bitmap_clear_range (local_rd, \n+\t\t\t\tDF_DEFS_BEGIN (dregno), \n+\t\t\t\tDF_DEFS_COUNT (dregno));\n+\t  if (!(DF_REF_FLAGS (def) \n+\t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n+\t    bitmap_set_bit (local_rd, DF_REF_ID (def));\n+\t}\n+    }\n+}\n+\n+/* Process a list of DEFs for df_rd_bb_local_compute.  This is a bit\n+   more complicated than just simulating, because we must produce the\n+   gen and kill sets and hence deal with the two possible representations\n+   of kill sets.   */\n \n static void\n df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n@@ -2076,7 +2130,6 @@ df_chain_create_bb (unsigned int bb_index)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx insn;\n   bitmap cpy = BITMAP_ALLOC (NULL);\n-  df_ref *def_rec;\n \n   bitmap_copy (cpy, bb_info->in);\n   bitmap_set_bit (df_chain->out_of_date_transfer_functions, bb_index);\n@@ -2095,57 +2148,23 @@ df_chain_create_bb (unsigned int bb_index)\n \t\t\t\t    DF_REF_AT_TOP);\n #endif\n \n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    bitmap_clear_range (cpy, \n-\t\t\t\tDF_DEFS_BEGIN (dregno), \n-\t\t\t\tDF_DEFS_COUNT (dregno));\n-\t  bitmap_set_bit (cpy, DF_REF_ID (def));\n-\t}\n-    }\n+  df_rd_simulate_artificial_defs_at_top (bb, cpy);\n   \n   /* Process the regular instructions next.  */\n   FOR_BB_INSNS (bb, insn)\n-    {\n-      df_ref *def_rec;\n-      unsigned int uid = INSN_UID (insn);\n-\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      /* Now scan the uses and link them up with the defs that remain\n-\t in the cpy vector.  */\n-      \n-      df_chain_create_bb_process_use (cpy, DF_INSN_UID_USES (uid), 0);\n-\n-      if (df->changeable_flags & DF_EQ_NOTES)\n-\tdf_chain_create_bb_process_use (cpy, DF_INSN_UID_EQ_USES (uid), 0);\n+    if (INSN_P (insn))\n+      {\n+        unsigned int uid = INSN_UID (insn);\n \n+        /* First scan the uses and link them up with the defs that remain\n+\t   in the cpy vector.  */\n+        df_chain_create_bb_process_use (cpy, DF_INSN_UID_USES (uid), 0);\n+        if (df->changeable_flags & DF_EQ_NOTES)\n+\t  df_chain_create_bb_process_use (cpy, DF_INSN_UID_EQ_USES (uid), 0);\n \n-      /* Since we are going forwards, process the defs second.  This\n-         pass only changes the bits in cpy.  */\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  df_ref def = *def_rec;\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n-\t      || (dregno >= FIRST_PSEUDO_REGISTER))\n-\t    {\n-\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\tbitmap_clear_range (cpy, \n-\t\t\t\t    DF_DEFS_BEGIN (dregno), \n-\t\t\t\t    DF_DEFS_COUNT (dregno));\n-\t      if (!(DF_REF_FLAGS (def) \n-\t\t    & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n-\t\tbitmap_set_bit (cpy, DF_REF_ID (def));\n-\t    }\n-\t}\n-    }\n+        /* Since we are going forwards, process the defs second.  */\n+        df_rd_simulate_one_insn (bb, insn, cpy);\n+      }\n \n   /* Create the chains for the artificial uses of the hard registers\n      at the end of the block.  */"}, {"sha": "f8084e022d02c77aaceea1b4747c1811d9449644", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -939,6 +939,8 @@ extern void df_grow_bb_info (struct dataflow *);\n extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n extern void df_rd_add_problem (void);\n+extern void df_rd_simulate_artificial_defs_at_top (basic_block, bitmap);\n+extern void df_rd_simulate_one_insn (basic_block, rtx, bitmap);\n extern void df_lr_add_problem (void);\n extern void df_lr_verify_transfer_functions (void);\n extern void df_live_verify_transfer_functions (void);"}, {"sha": "763654685bffcf066f34fbfe8556745e19a86a4a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -5554,8 +5554,8 @@ instructions and checks if the result can be simplified.  If loop unrolling\n is active, two passes are performed and the second is scheduled after\n loop unrolling.\n \n-This option is enabled by default at optimization levels @option{-O2},\n-@option{-O3}, @option{-Os}.\n+This option is enabled by default at optimization levels @option{-O},\n+@option{-O2}, @option{-O3}, @option{-Os}.\n \n @item -fomit-frame-pointer\n @opindex fomit-frame-pointer"}, {"sha": "669d03cc066e94ad4ccbcfb0e4452d71eeef6dbb", "filename": "gcc/fwprop.c", "status": "modified", "additions": 111, "deletions": 14, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -105,6 +105,111 @@ along with GCC; see the file COPYING3.  If not see\n \n static int num_changes;\n \n+DEF_VEC_P(df_ref);\n+DEF_VEC_ALLOC_P(df_ref,heap);\n+VEC(df_ref,heap) *use_def_ref;\n+\n+\n+/* Return the only def in USE's use-def chain, or NULL if there is\n+   more than one def in the chain.  */\n+\n+static inline df_ref\n+get_def_for_use (df_ref use)\n+{\n+  return VEC_index (df_ref, use_def_ref, DF_REF_ID (use));\n+}\n+\n+\n+/* Return the only bit between FIRST and LAST that is set in B,\n+   or -1 if there are zero or more than one such bits.  */\n+\n+static inline int\n+bitmap_only_bit_between (const_bitmap b, unsigned first, unsigned last)\n+{\n+  bitmap_iterator bi;\n+  unsigned bit, bit2;\n+\n+  if (last < first)\n+    return -1;\n+\n+  bmp_iter_set_init (&bi, b, first, &bit);\n+  if (bmp_iter_set (&bi, &bit) && bit <= last)\n+    {\n+      bit2 = bit;\n+      bmp_iter_next (&bi, &bit2);\n+      if (!bmp_iter_set (&bi, &bit2) || bit2 > last)\n+        return bit;\n+    }\n+  return -1;\n+}\n+\n+\n+/* Fill the use_def_ref vector with values for the uses in USE_REC,\n+   taking reaching definitions info from LOCAL_RD.  TOP_FLAG says\n+   which artificials uses should be used, when USE_REC is an\n+   artificial use vector.  */\n+\n+static void\n+process_uses (bitmap local_rd, df_ref *use_rec, int top_flag)\n+{\n+  df_ref use;\n+  while ((use = *use_rec++) != NULL)\n+    if (top_flag == (DF_REF_FLAGS (use) & DF_REF_AT_TOP))\n+      {\n+\tunsigned int uregno = DF_REF_REGNO (use);\n+\tunsigned int first = DF_DEFS_BEGIN (uregno);\n+\tunsigned int last = first + DF_DEFS_COUNT (uregno) - 1;\n+\tint defno = bitmap_only_bit_between (local_rd, first, last);\n+\tdf_ref def = (defno == -1) ? NULL : DF_DEFS_GET (defno);\n+\n+\tVEC_replace (df_ref, use_def_ref, DF_REF_ID (use), def);\n+      }\n+}\n+\n+\n+/* Do dataflow analysis and use reaching definitions to build\n+   a vector holding the reaching definitions of uses that have a\n+   single RD.  */\n+\n+static void\n+build_single_def_use_links (void)\n+{\n+  basic_block bb;\n+  bitmap local_rd = BITMAP_ALLOC (NULL);\n+\n+  /* We use reaching definitions to compute our restricted use-def chains.  */\n+  df_set_flags (DF_EQ_NOTES);\n+  df_rd_add_problem ();\n+  df_analyze ();\n+  df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n+\n+  use_def_ref = VEC_alloc (df_ref, heap, DF_USES_TABLE_SIZE ());\n+  VEC_safe_grow (df_ref, heap, use_def_ref, DF_USES_TABLE_SIZE ());\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      int bb_index = bb->index;\n+      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+      rtx insn;\n+\n+      bitmap_copy (local_rd, bb_info->in);\n+      process_uses (local_rd, df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n+\n+      df_rd_simulate_artificial_defs_at_top (bb, local_rd);\n+      FOR_BB_INSNS (bb, insn)\n+        if (INSN_P (insn))\n+          {\n+            unsigned int uid = INSN_UID (insn);\n+            process_uses (local_rd, DF_INSN_UID_USES (uid), 0);\n+            process_uses (local_rd, DF_INSN_UID_EQ_USES (uid), 0);\n+            df_rd_simulate_one_insn (bb, insn, local_rd);\n+\t  }\n+\n+      process_uses (local_rd, df_get_artificial_uses (bb_index), 0);\n+    }\n+\n+  BITMAP_FREE (local_rd);\n+}\n \f\n /* Do not try to replace constant addresses or addresses of local and\n    argument slots.  These MEM expressions are made only once and inserted\n@@ -716,7 +821,8 @@ update_df (rtx insn, rtx *loc, df_ref *use_rec, enum df_ref_type type,\n \t\t\t       width, offset, mode);\n \n       /* Set up the use-def chain.  */\n-      df_chain_copy (new_use, DF_REF_CHAIN (orig_use));\n+      gcc_assert (DF_REF_ID (new_use) == (int) VEC_length (df_ref, use_def_ref));\n+      VEC_safe_push (df_ref, heap, use_def_ref, get_def_for_use (orig_use));\n       changed = true;\n     }\n   if (changed)\n@@ -1035,7 +1141,6 @@ forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n static void\n forward_propagate_into (df_ref use)\n {\n-  struct df_link *defs;\n   df_ref def;\n   rtx def_insn, def_set, use_insn;\n   rtx parent;\n@@ -1046,11 +1151,9 @@ forward_propagate_into (df_ref use)\n     return;\n \n   /* Only consider uses that have a single definition.  */\n-  defs = DF_REF_CHAIN (use);\n-  if (!defs || defs->next)\n+  def = get_def_for_use (use);\n+  if (!def)\n     return;\n-\n-  def = defs->ref;\n   if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n     return;\n   if (DF_REF_IS_ARTIFICIAL (def))\n@@ -1096,12 +1199,7 @@ fwprop_init (void)\n      insns (sadly) if we are not working in cfglayout mode.  */\n   loop_optimizer_init (0);\n \n-  /* Now set up the dataflow problem (we only want use-def chains) and\n-     put the dataflow solver to work.  */\n-  df_set_flags (DF_EQ_NOTES);\n-  df_chain_add_problem (DF_UD_CHAIN);\n-  df_analyze ();\n-  df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n+  build_single_def_use_links ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n }\n \n@@ -1110,6 +1208,7 @@ fwprop_done (void)\n {\n   loop_optimizer_finalize ();\n \n+  VEC_free (df_ref, heap, use_def_ref);\n   free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n@@ -1187,8 +1286,6 @@ fwprop_addr (void)\n \n   /* Go through all the uses.  update_df will create new ones at the\n      end, and we'll go through them as well.  */\n-  df_set_flags (DF_DEFER_INSN_RESCAN);\n-\n   for (i = 0; i < DF_USES_TABLE_SIZE (); i++)\n     {\n       df_ref use = DF_USES_GET (i);"}, {"sha": "818acdf8f65ed1dc05ca5b2f5ea8fe2755fb21c1", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00952e9784e41f1ee7a1e4384904a5fd42f610a6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=00952e9784e41f1ee7a1e4384904a5fd42f610a6", "patch": "@@ -848,6 +848,7 @@ decode_options (unsigned int argc, const char **argv)\n #endif\n   flag_guess_branch_prob = opt1;\n   flag_cprop_registers = opt1;\n+  flag_forward_propagate = opt1;\n   flag_if_conversion = opt1;\n   flag_if_conversion2 = opt1;\n   flag_ipa_pure_const = opt1;\n@@ -873,7 +874,6 @@ decode_options (unsigned int argc, const char **argv)\n   flag_thread_jumps = opt2;\n   flag_crossjumping = opt2;\n   flag_optimize_sibling_calls = opt2;\n-  flag_forward_propagate = opt2;\n   flag_cse_follow_jumps = opt2;\n   flag_gcse = opt2;\n   flag_expensive_optimizations = opt2;"}]}