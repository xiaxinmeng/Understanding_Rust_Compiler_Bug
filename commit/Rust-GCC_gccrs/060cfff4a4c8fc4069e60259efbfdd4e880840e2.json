{"sha": "060cfff4a4c8fc4069e60259efbfdd4e880840e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYwY2ZmZjRhNGM4ZmM0MDY5ZTYwMjU5ZWZiZmRkNGU4ODA4NDBlMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-13T06:30:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-13T06:30:04Z"}, "message": "ipa-icf.c (sem_function::equals_wpa): Match CXX_CONSTRUCTOR_P and CXX_DESTURCTOR_P.\n\n\n\t* ipa-icf.c (sem_function::equals_wpa): Match CXX_CONSTRUCTOR_P\n\tand CXX_DESTURCTOR_P. For consutrctors match ODR type of class they\n\tare building; for methods check ODR type of class they belong to if\n\tthey may lead to a polymorphic call.\n\t(sem_function::compare_polymorphic_p): Be bit smarter about testing\n\twhen function may lead to a polymorphic call.\n\t(sem_function::compare_type_list): Remove.\n\t(sem_variable::equals): Update use of compatible_types_p.\n\t(sem_variable::parse_tree_refs): Remove.\n\t(sem_item_optimizer::filter_removed_items): Do not filter out CXX\n\tcdtor.\n\t* ipa-icf-gimple.c (func_checker::compare_decl): Do polymorphic\n\tmatching here.\n\t(func_checker::compatible_polymorphic_types_p): Break out from ...\n\t(unc_checker::compatible_types_p): ... here.\n\t* ipa-icf-gimple.h (func_checker::compatible_polymorphic_types_p):\n\tDeclare.\n\t(unc_checker::compatible_types_p): Update.\n\t* ipa-icf.h (compare_type_list, parse_tree_refs, compare_sections):\n\tRemove.\n\nFrom-SVN: r221406", "tree": {"sha": "490246165d88266159fba519998ff7dc9711af32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/490246165d88266159fba519998ff7dc9711af32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/060cfff4a4c8fc4069e60259efbfdd4e880840e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/060cfff4a4c8fc4069e60259efbfdd4e880840e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/060cfff4a4c8fc4069e60259efbfdd4e880840e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/060cfff4a4c8fc4069e60259efbfdd4e880840e2/comments", "author": null, "committer": null, "parents": [{"sha": "d587bfd1218666725837ba5ad94897ef99f50c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d587bfd1218666725837ba5ad94897ef99f50c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d587bfd1218666725837ba5ad94897ef99f50c63"}], "stats": {"total": 260, "additions": 135, "deletions": 125}, "files": [{"sha": "1cc9905f5548d888e14b07d82091a4e855a88a5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=060cfff4a4c8fc4069e60259efbfdd4e880840e2", "patch": "@@ -1,3 +1,26 @@\n+2015-03-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (sem_function::equals_wpa): Match CXX_CONSTRUCTOR_P\n+\tand CXX_DESTURCTOR_P. For consutrctors match ODR type of class they\n+\tare building; for methods check ODR type of class they belong to if\n+\tthey may lead to a polymorphic call.\n+\t(sem_function::compare_polymorphic_p): Be bit smarter about testing\n+\twhen function may lead to a polymorphic call.\n+\t(sem_function::compare_type_list): Remove.\n+\t(sem_variable::equals): Update use of compatible_types_p.\n+\t(sem_variable::parse_tree_refs): Remove.\n+\t(sem_item_optimizer::filter_removed_items): Do not filter out CXX\n+\tcdtor.\n+\t* ipa-icf-gimple.c (func_checker::compare_decl): Do polymorphic\n+\tmatching here.\n+\t(func_checker::compatible_polymorphic_types_p): Break out from ...\n+\t(unc_checker::compatible_types_p): ... here.\n+\t* ipa-icf-gimple.h (func_checker::compatible_polymorphic_types_p):\n+\tDeclare.\n+\t(unc_checker::compatible_types_p): Update.\n+\t* ipa-icf.h (compare_type_list, parse_tree_refs, compare_sections):\n+\tRemove.\n+\n 2015-03-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/65235"}, {"sha": "568407da2fdc218b9d553214c90db720836dd89b", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=060cfff4a4c8fc4069e60259efbfdd4e880840e2", "patch": "@@ -200,8 +200,22 @@ func_checker::compare_decl (tree t1, tree t2)\n       && DECL_BY_REFERENCE (t1) != DECL_BY_REFERENCE (t2))\n     return return_false_with_msg (\"DECL_BY_REFERENCE flags are different\");\n \n-  if (!compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t   m_compare_polymorphic))\n+  if (!compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+    return return_false ();\n+\n+  /* TODO: we are actually too strict here.  We only need to compare if\n+     T1 can be used in polymorphic call.  */\n+  if (TREE_ADDRESSABLE (t1)\n+      && m_compare_polymorphic\n+      && !compatible_polymorphic_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t  false))\n+    return return_false ();\n+\n+  if ((t == VAR_DECL || t == PARM_DECL || t == RESULT_DECL)\n+      && DECL_BY_REFERENCE (t1)\n+      && m_compare_polymorphic\n+      && !compatible_polymorphic_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t  true))\n     return return_false ();\n \n   bool existed_p;\n@@ -215,11 +229,41 @@ func_checker::compare_decl (tree t1, tree t2)\n   return true;\n }\n \n+/* Return true if T1 and T2 are same for purposes of ipa-polymorphic-call\n+   analysis.  COMPARE_PTR indicates if types of pointers needs to be\n+   considered.  */\n+\n+bool\n+func_checker::compatible_polymorphic_types_p (tree t1, tree t2,\n+\t\t\t\t\t      bool compare_ptr)\n+{\n+  gcc_assert (TREE_CODE (t1) != FUNCTION_TYPE && TREE_CODE (t1) != METHOD_TYPE);\n+\n+  /* Pointer types generally give no information.  */\n+  if (POINTER_TYPE_P (t1))\n+    {\n+      if (!compare_ptr)\n+\treturn true;\n+      return func_checker::compatible_polymorphic_types_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t\t   TREE_TYPE (t2),\n+\t\t\t\t\t\t\t   false);\n+    }\n+\n+  /* If types contain a polymorphic types, match them.  */\n+  bool c1 = contains_polymorphic_type_p (t1);\n+  bool c2 = contains_polymorphic_type_p (t2);\n+  if (!c1 && !c2)\n+    return true;\n+  if (!c1 || !c2)\n+    return return_false_with_msg (\"one type is not polymorphic\");\n+  if (!types_must_be_same_for_odr (t1, t2))\n+    return return_false_with_msg (\"types are not same for ODR\");\n+  return true;\n+}\n+\n /* Return true if types are compatible from perspective of ICF.  */\n bool\n-func_checker::compatible_types_p (tree t1, tree t2,\n-\t\t\t\t  bool compare_polymorphic,\n-\t\t\t\t  bool first_argument)\n+func_checker::compatible_types_p (tree t1, tree t2)\n {\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return return_false_with_msg (\"different tree types\");\n@@ -233,23 +277,6 @@ func_checker::compatible_types_p (tree t1, tree t2,\n   if (get_alias_set (t1) != get_alias_set (t2))\n     return return_false_with_msg (\"alias sets are different\");\n \n-  /* We call contains_polymorphic_type_p with this pointer type.  */\n-  if (first_argument && TREE_CODE (t1) == POINTER_TYPE)\n-    {\n-      t1 = TREE_TYPE (t1);\n-      t2 = TREE_TYPE (t2);\n-    }\n-\n-  if (compare_polymorphic)\n-    if (contains_polymorphic_type_p (t1) || contains_polymorphic_type_p (t2))\n-      {\n-\tif (!contains_polymorphic_type_p (t1) || !contains_polymorphic_type_p (t2))\n-\t  return return_false_with_msg (\"one type is not polymorphic\");\n-\n-\tif (!types_must_be_same_for_odr (t1, t2))\n-\t  return return_false_with_msg (\"types are not same for ODR\");\n-      }\n-\n   return true;\n }\n "}, {"sha": "53a1bfe3c14bae79031def239970b8f61ced8c7f", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=060cfff4a4c8fc4069e60259efbfdd4e880840e2", "patch": "@@ -226,12 +226,16 @@ class func_checker\n   /* Verifies that trees T1 and T2 do correspond.  */\n   bool compare_variable_decl (tree t1, tree t2);\n \n+  /* Return true if types are compatible for polymorphic call analysis.\n+     COMPARE_PTR indicates if polymorphic type comparsion should be\n+     done for pointers, too.  */\n+  static bool compatible_polymorphic_types_p (tree t1, tree t2,\n+\t\t\t\t\t      bool compare_ptr);\n+\n   /* Return true if types are compatible from perspective of ICF.\n      FIRST_ARGUMENT indicates if the comparison is called for\n      first parameter of a function.  */\n-  static bool compatible_types_p (tree t1, tree t2,\n-\t\t\t\t  bool compare_polymorphic = true,\n-\t\t\t\t  bool first_argument = false);\n+  static bool compatible_types_p (tree t1, tree t2);\n \n \n private:"}, {"sha": "25b83062d3f48bdd4bdb9d01a49b55ae1e6e50f3", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 56, "deletions": 88, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=060cfff4a4c8fc4069e60259efbfdd4e880840e2", "patch": "@@ -429,9 +429,29 @@ sem_function::equals_wpa (sem_item *item,\n   if (DECL_NO_LIMIT_STACK (decl) != DECL_NO_LIMIT_STACK (item->decl))\n     return return_false_with_msg (\"no stack limit attributes are different\");\n \n+  if (DECL_CXX_CONSTRUCTOR_P (decl) != DECL_CXX_CONSTRUCTOR_P (item->decl))\n+    return return_false_with_msg (\"DELC_CXX_CONSTRUCTOR mismatch\");\n+\n+  if (DECL_CXX_DESTRUCTOR_P (decl) != DECL_CXX_DESTRUCTOR_P (item->decl))\n+    return return_false_with_msg (\"DELC_CXX_DESTRUCTOR mismatch\");\n+\n   if (flags_from_decl_or_type (decl) != flags_from_decl_or_type (item->decl))\n     return return_false_with_msg (\"decl_or_type flags are different\");\n \n+  /* Do not match polymorphic constructors of different types.  They calls\n+     type memory location for ipa-polymorphic-call and we do not want\n+     it to get confused by wrong type.  */\n+  if (DECL_CXX_CONSTRUCTOR_P (decl)\n+      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n+    {\n+      if (TREE_CODE (TREE_TYPE (item->decl)) != METHOD_TYPE)\n+        return return_false_with_msg (\"DECL_CXX_CONSTURCTOR type mismatch\");\n+      else if (!func_checker::compatible_polymorphic_types_p\n+\t\t (method_class_type (TREE_TYPE (decl)),\n+\t\t  method_class_type (TREE_TYPE (item->decl)), false))\n+        return return_false_with_msg (\"ctor polymorphic type mismatch\");\n+    }\n+\n   /* Checking function TARGET and OPTIMIZATION flags.  */\n   cl_target_option *tar1 = target_opts_for_fn (decl);\n   cl_target_option *tar2 = target_opts_for_fn (item->decl);\n@@ -473,13 +493,8 @@ sem_function::equals_wpa (sem_item *item,\n       if (!arg_types[i] || !m_compared_func->arg_types[i])\n \treturn return_false_with_msg (\"NULL argument type\");\n \n-      /* Polymorphic comparison is executed just for non-leaf functions.  */\n-      bool is_not_leaf = get_node ()->callees != NULL\n-\t\t\t || get_node ()->indirect_calls != NULL;\n-\n       if (!func_checker::compatible_types_p (arg_types[i],\n-\t\t\t\t\t     m_compared_func->arg_types[i],\n-\t\t\t\t\t     is_not_leaf, i == 0))\n+\t\t\t\t\t     m_compared_func->arg_types[i]))\n \treturn return_false_with_msg (\"argument type is different\");\n       if (POINTER_TYPE_P (arg_types[i])\n \t  && (TYPE_RESTRICT (arg_types[i])\n@@ -494,6 +509,24 @@ sem_function::equals_wpa (sem_item *item,\n \t\t\t    TREE_TYPE (item->decl)) != 1)\n     return return_false_with_msg (\"different type attributes\");\n \n+  /* The type of THIS pointer type memory location for\n+     ipa-polymorphic-call-analysis.  */\n+  if (opt_for_fn (decl, flag_devirtualize)\n+      && (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+          || TREE_CODE (TREE_TYPE (item->decl)) == METHOD_TYPE)\n+      && (!flag_ipa_cp\n+\t  || ipa_is_param_used (IPA_NODE_REF (dyn_cast <cgraph_node *>(node)),\n+\t\t\t\t0))\n+      && compare_polymorphic_p ())\n+    {\n+      if (TREE_CODE (TREE_TYPE (decl)) != TREE_CODE (TREE_TYPE (item->decl)))\n+\treturn return_false_with_msg (\"METHOD_TYPE and FUNCTION_TYPE mismatch\");\n+      if (!func_checker::compatible_polymorphic_types_p\n+\t   (method_class_type (TREE_TYPE (decl)),\n+\t    method_class_type (TREE_TYPE (item->decl)), false))\n+\treturn return_false_with_msg (\"THIS pointer ODR type mismatch\");\n+    }\n+\n   ipa_ref *ref = NULL, *ref2 = NULL;\n   for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n     {\n@@ -614,7 +647,6 @@ sem_function::equals_private (sem_item *item,\n   if (decl1 != decl2)\n     return return_false();\n \n-\n   for (arg1 = DECL_ARGUMENTS (decl),\n        arg2 = DECL_ARGUMENTS (m_compared_func->decl);\n        arg1; arg1 = DECL_CHAIN (arg1), arg2 = DECL_CHAIN (arg2))\n@@ -1216,10 +1248,20 @@ sem_function::hash_stmt (gimple stmt, inchash::hash &hstate)\n bool\n sem_function::compare_polymorphic_p (void)\n {\n-  return get_node ()->callees != NULL\n-\t || get_node ()->indirect_calls != NULL\n-\t || m_compared_func->get_node ()->callees != NULL\n-\t || m_compared_func->get_node ()->indirect_calls != NULL;\n+  struct cgraph_edge *e;\n+\n+  if (!opt_for_fn (decl, flag_devirtualize))\n+    return false;\n+  if (get_node ()->indirect_calls != NULL\n+      || m_compared_func->get_node ()->indirect_calls != NULL)\n+    return true;\n+  /* TODO: We can do simple propagation determining what calls may lead to\n+     a polymorphic call.  */\n+  for (e = m_compared_func->get_node ()->callees; e; e = e->next_callee)\n+    if (e->callee->definition\n+\t&& opt_for_fn (e->callee->decl, flag_devirtualize))\n+      return true;\n+  return false;\n }\n \n /* For a given call graph NODE, the function constructs new\n@@ -1374,41 +1416,6 @@ sem_function::bb_dict_test (vec<int> *bb_dict, int source, int target)\n     return (*bb_dict)[source] == target;\n }\n \n-/* Iterates all tree types in T1 and T2 and returns true if all types\n-   are compatible. If COMPARE_POLYMORPHIC is set to true,\n-   more strict comparison is executed.  */\n-\n-bool\n-sem_function::compare_type_list (tree t1, tree t2, bool compare_polymorphic)\n-{\n-  tree tv1, tv2;\n-  tree_code tc1, tc2;\n-\n-  if (!t1 && !t2)\n-    return true;\n-\n-  while (t1 != NULL && t2 != NULL)\n-    {\n-      tv1 = TREE_VALUE (t1);\n-      tv2 = TREE_VALUE (t2);\n-\n-      tc1 = TREE_CODE (tv1);\n-      tc2 = TREE_CODE (tv2);\n-\n-      if (tc1 == NOP_EXPR && tc2 == NOP_EXPR)\n-\t{}\n-      else if (tc1 == NOP_EXPR || tc2 == NOP_EXPR)\n-\treturn false;\n-      else if (!func_checker::compatible_types_p (tv1, tv2, compare_polymorphic))\n-\treturn false;\n-\n-      t1 = TREE_CHAIN (t1);\n-      t2 = TREE_CHAIN (t2);\n-    }\n-\n-  return !(t1 || t2);\n-}\n-\n \n /* Semantic variable constructor that uses STACK as bitmap memory stack.  */\n \n@@ -1586,8 +1593,7 @@ sem_variable::equals (tree t1, tree t2)\n \ttree y1 = TREE_OPERAND (t1, 1);\n \ttree y2 = TREE_OPERAND (t2, 1);\n \n-\tif (!func_checker::compatible_types_p (TREE_TYPE (x1), TREE_TYPE (x2),\n-\t\t\t\t\t       true))\n+\tif (!func_checker::compatible_types_p (TREE_TYPE (x1), TREE_TYPE (x2)))\n \t  return return_false ();\n \n \t/* Type of the offset on MEM_REF does not matter.  */\n@@ -1696,8 +1702,7 @@ sem_variable::equals (tree t1, tree t2)\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n-      if (!func_checker::compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t     true))\n+      if (!func_checker::compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \t  return return_false ();\n       return sem_variable::equals (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n     case ERROR_MARK:\n@@ -1874,40 +1879,6 @@ sem_variable::dump_to_file (FILE *file)\n   fprintf (file, \"\\n\\n\");\n }\n \n-/* Iterates though a constructor and identifies tree references\n-   we are interested in semantic function equality.  */\n-\n-void\n-sem_variable::parse_tree_refs (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case CONSTRUCTOR:\n-      {\n-\tunsigned length = vec_safe_length (CONSTRUCTOR_ELTS (t));\n-\n-\tfor (unsigned i = 0; i < length; i++)\n-\t  parse_tree_refs(CONSTRUCTOR_ELT (t, i)->value);\n-\n-\tbreak;\n-      }\n-    case NOP_EXPR:\n-    case ADDR_EXPR:\n-      {\n-\ttree op = TREE_OPERAND (t, 0);\n-\tparse_tree_refs (op);\n-\tbreak;\n-      }\n-    case FUNCTION_DECL:\n-      {\n-\ttree_refs.safe_push (t);\n-\tbreak;\n-      }\n-    default:\n-      break;\n-    }\n-}\n-\n unsigned int sem_item_optimizer::class_id = 0;\n \n sem_item_optimizer::sem_item_optimizer (): worklist (0), m_classes (0),\n@@ -2185,10 +2156,7 @@ sem_item_optimizer::filter_removed_items (void)\n         {\n \t  cgraph_node *cnode = static_cast <sem_function *>(item)->get_node ();\n \n-\t  bool no_body_function = in_lto_p && (cnode->alias || cnode->body_removed);\n-\t  if (no_body_function || !opt_for_fn (item->decl, flag_ipa_icf_functions)\n-\t      || DECL_CXX_CONSTRUCTOR_P (item->decl)\n-\t      || DECL_CXX_DESTRUCTOR_P (item->decl))\n+\t  if (in_lto_p && (cnode->alias || cnode->body_removed))\n \t    remove_item (item);\n \t  else\n \t    filtered.safe_push (item);"}, {"sha": "c51bb4a4299c3ab245bafa3f15e997ad4bdce207", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/060cfff4a4c8fc4069e60259efbfdd4e880840e2/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=060cfff4a4c8fc4069e60259efbfdd4e880840e2", "patch": "@@ -353,11 +353,6 @@ class sem_function: public sem_item\n      corresponds to TARGET.  */\n   bool bb_dict_test (vec<int> *bb_dict, int source, int target);\n \n-  /* Iterates all tree types in T1 and T2 and returns true if all types\n-     are compatible. If COMPARE_POLYMORPHIC is set to true,\n-     more strict comparison is executed.  */\n-  bool compare_type_list (tree t1, tree t2, bool compare_polymorphic);\n-\n   /* If cgraph edges E1 and E2 are indirect calls, verify that\n      ICF flags are the same.  */\n   bool compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2);\n@@ -415,15 +410,8 @@ class sem_variable: public sem_item\n   static sem_variable *parse (varpool_node *node, bitmap_obstack *stack);\n \n private:\n-  /* Iterates though a constructor and identifies tree references\n-     we are interested in semantic function equality.  */\n-  void parse_tree_refs (tree t);\n-\n   /* Compares trees T1 and T2 for semantic equality.  */\n   static bool equals (tree t1, tree t2);\n-\n-  /* Compare that symbol sections are either NULL or have same name.  */\n-  bool compare_sections (sem_variable *alias);\n }; // class sem_variable\n \n class sem_item_optimizer;"}]}