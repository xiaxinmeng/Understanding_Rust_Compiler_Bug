{"sha": "c45f211ee347bc648b183c5123498c5b7310bb0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1ZjIxMWVlMzQ3YmM2NDhiMTgzYzUxMjM0OThjNWI3MzEwYmIwZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-05-04T19:30:25Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-05-04T19:30:25Z"}, "message": "Initial revision\n\nFrom-SVN: r26770", "tree": {"sha": "e97105783ac15ce06e3efe366d641f3693aa8974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e97105783ac15ce06e3efe366d641f3693aa8974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c45f211ee347bc648b183c5123498c5b7310bb0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45f211ee347bc648b183c5123498c5b7310bb0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c45f211ee347bc648b183c5123498c5b7310bb0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45f211ee347bc648b183c5123498c5b7310bb0e/comments", "author": null, "committer": null, "parents": [{"sha": "3d298f8f0e3934f7951b13281976bb9eda021387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d298f8f0e3934f7951b13281976bb9eda021387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d298f8f0e3934f7951b13281976bb9eda021387"}], "stats": {"total": 21921, "additions": 21921, "deletions": 0}, "files": [{"sha": "57386a26f485d3896ba90984a9eb04df13f9f527", "filename": "zlib/ChangeLog", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,471 @@\n+\n+\t\tChangeLog file for zlib\n+\n+Changes in 1.1.3 (9 July 1998)\n+- fix \"an inflate input buffer bug that shows up on rare but persistent\n+  occasions\" (Mark)\n+- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)\n+- fix gzseek(..., SEEK_SET) in write mode\n+- fix crc check after a gzeek (Frank Faubert)\n+- fix miniunzip when the last entry in a zip file is itself a zip file\n+  (J Lillge)\n+- add contrib/asm586 and contrib/asm686 (Brian Raiter)\n+  See http://www.muppetlabs.com/~breadbox/software/assembly.html\n+- add support for Delphi 3 in contrib/delphi (Bob Dellaca)\n+- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)\n+- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)\n+- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)\n+- added a FAQ file\n+\n+- Support gzdopen on Mac with Metrowerks (Jason Linhart)\n+- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)\n+- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)\n+- avoid some warnings with Borland C (Tom Tanner)\n+- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)\n+- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)\n+- allow several arguments to configure (Tim Mooney, Frodo Looijaard)\n+- use libdir and includedir in Makefile.in (Tim Mooney)\n+- support shared libraries on OSF1 V4 (Tim Mooney)\n+- remove so_locations in \"make clean\"  (Tim Mooney)\n+- fix maketree.c compilation error (Glenn, Mark)\n+- Python interface to zlib now in Python 1.5 (Jeremy Hylton)\n+- new Makefile.riscos (Rich Walker)\n+- initialize static descriptors in trees.c for embedded targets (Nick Smith)\n+- use \"foo-gz\" in example.c for RISCOS and VMS (Nick Smith)\n+- add the OS/2 files in Makefile.in too (Andrew Zabolotny)\n+- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)\n+- fix maketree.c to allow clean compilation of inffixed.h (Mark)\n+- fix parameter check in deflateCopy (Gunther Nikl)\n+- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)\n+- Many portability patches by Christian Spieler:\n+  . zutil.c, zutil.h: added \"const\" for zmem*\n+  . Make_vms.com: fixed some typos\n+  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists\n+  . msdos/Makefile.msc: remove \"default rtl link library\" info from obj files\n+  . msdos/Makefile.*: use model-dependent name for the built zlib library\n+  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:\n+     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)\n+- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)\n+- replace __far with _far for better portability (Christian Spieler, Tom Lane)\n+- fix test for errno.h in configure (Tim Newsham)\n+\n+Changes in 1.1.2 (19 March 98)\n+- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)\n+  See http://www.winimage.com/zLibDll/unzip.html\n+- preinitialize the inflate tables for fixed codes, to make the code\n+  completely thread safe (Mark)\n+- some simplifications and slight speed-up to the inflate code (Mark)\n+- fix gzeof on non-compressed files (Allan Schrum)\n+- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)\n+- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)\n+- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)\n+- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)\n+- do not wrap extern \"C\" around system includes (Tom Lane)\n+- mention zlib binding for TCL in README (Andreas Kupries)\n+- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)\n+- allow \"make install prefix=...\" even after configure (Glenn Randers-Pehrson)\n+- allow \"configure --prefix $HOME\" (Tim Mooney)\n+- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)\n+- move Makefile.sas to amiga/Makefile.sas\n+\n+Changes in 1.1.1 (27 Feb 98)\n+- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)\n+- remove block truncation heuristic which had very marginal effect for zlib\n+  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the\n+  compression ratio on some files. This also allows inlining _tr_tally for\n+  matches in deflate_slow.\n+- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)\n+\n+Changes in 1.1.0 (24 Feb 98)\n+- do not return STREAM_END prematurely in inflate (John Bowler)\n+- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)\n+- compile with -DFASTEST to get compression code optimized for speed only\n+- in minigzip, try mmap'ing the input file first (Miguel Albrecht)\n+- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain\n+  on Sun but significant on HP)\n+\n+- add a pointer to experimental unzip library in README (Gilles Vollant)\n+- initialize variable gcc in configure (Chris Herborth)\n+\n+Changes in 1.0.9 (17 Feb 1998)\n+- added gzputs and gzgets functions\n+- do not clear eof flag in gzseek (Mark Diekhans)\n+- fix gzseek for files in transparent mode (Mark Diekhans)\n+- do not assume that vsprintf returns the number of bytes written (Jens Krinke)\n+- replace EXPORT with ZEXPORT to avoid conflict with other programs\n+- added compress2 in zconf.h, zlib.def, zlib.dnt\n+- new asm code from Gilles Vollant in contrib/asm386\n+- simplify the inflate code (Mark):\n+ . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()\n+ . ZALLOC the length list in inflate_trees_fixed() instead of using stack\n+ . ZALLOC the value area for huft_build() instead of using stack\n+ . Simplify Z_FINISH check in inflate()\n+\n+- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8\n+- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)\n+- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with\n+  the declaration of FAR (Gilles VOllant)\n+- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)\n+- read_buf buf parameter of type Bytef* instead of charf*\n+- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)\n+- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)\n+- fix check for presence of directories in \"make install\" (Ian Willis)\n+\n+Changes in 1.0.8 (27 Jan 1998)\n+- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)\n+- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)\n+- added compress2() to allow setting the compression level\n+- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)\n+- use constant arrays for the static trees in trees.c instead of computing\n+  them at run time (thanks to Ken Raeburn for this suggestion). To create\n+  trees.h, compile with GEN_TREES_H and run \"make test\".\n+- check return code of example in \"make test\" and display result\n+- pass minigzip command line options to file_compress\n+- simplifying code of inflateSync to avoid gcc 2.8 bug\n+\n+- support CC=\"gcc -Wall\" in configure -s (QingLong)\n+- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)\n+- fix test for shared library support to avoid compiler warnings\n+- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)\n+- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)\n+- do not use fdopen for Metrowerks on Mac (Brad Pettit))\n+- add checks for gzputc and gzputc in example.c\n+- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)\n+- use const for the CRC table (Ken Raeburn)\n+- fixed \"make uninstall\" for shared libraries\n+- use Tracev instead of Trace in infblock.c\n+- in example.c use correct compressed length for test_sync\n+- suppress +vnocompatwarnings in configure for HPUX (not always supported)\n+\n+Changes in 1.0.7 (20 Jan 1998)\n+- fix gzseek which was broken in write mode\n+- return error for gzseek to negative absolute position\n+- fix configure for Linux (Chun-Chung Chen)\n+- increase stack space for MSC (Tim Wegner)\n+- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)\n+- define EXPORTVA for gzprintf (Gilles Vollant)\n+- added man page zlib.3 (Rick Rodgers)\n+- for contrib/untgz, fix makedir() and improve Makefile\n+\n+- check gzseek in write mode in example.c\n+- allocate extra buffer for seeks only if gzseek is actually called\n+- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)\n+- add inflateSyncPoint in zconf.h\n+- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def\n+\n+Changes in 1.0.6 (19 Jan 1998)\n+- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and\n+  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)\n+- Fix a deflate bug occuring only with compression level 0 (thanks to\n+  Andy Buckler for finding this one).\n+- In minigzip, pass transparently also the first byte for .Z files.\n+- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()\n+- check Z_FINISH in inflate (thanks to Marc Schluper)\n+- Implement deflateCopy (thanks to Adam Costello)\n+- make static libraries by default in configure, add --shared option.\n+- move MSDOS or Windows specific files to directory msdos\n+- suppress the notion of partial flush to simplify the interface\n+  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)\n+- suppress history buffer provided by application to simplify the interface\n+  (this feature was not implemented anyway in 1.0.4)\n+- next_in and avail_in must be initialized before calling inflateInit or\n+  inflateInit2\n+- add EXPORT in all exported functions (for Windows DLL)\n+- added Makefile.nt (thanks to Stephen Williams)\n+- added the unsupported \"contrib\" directory:\n+   contrib/asm386/ by Gilles Vollant <info@winimage.com>\n+\t386 asm code replacing longest_match().\n+   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>\n+        A C++ I/O streams interface to the zlib gz* functions\n+   contrib/iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n+\tAnother C++ I/O streams interface\n+   contrib/untgz/  by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+\tA very simple tar.gz file extractor using zlib\n+   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n+        How to use compress(), uncompress() and the gz* functions from VB.\n+- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression\n+  level) in minigzip (thanks to Tom Lane)\n+\n+- use const for rommable constants in deflate\n+- added test for gzseek and gztell in example.c\n+- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)\n+- add undocumented function zError to convert error code to string\n+  (for Tim Smithers)\n+- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.\n+- Use default memcpy for Symantec MSDOS compiler.\n+- Add EXPORT keyword for check_func (needed for Windows DLL)\n+- add current directory to LD_LIBRARY_PATH for \"make test\"\n+- create also a link for libz.so.1\n+- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)\n+- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)\n+- added -soname for Linux in configure (Chun-Chung Chen,\n+- assign numbers to the exported functions in zlib.def (for Windows DLL)\n+- add advice in zlib.h for best usage of deflateSetDictionary\n+- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)\n+- allow compilation with ANSI keywords only enabled for TurboC in large model\n+- avoid \"versionString\"[0] (Borland bug)\n+- add NEED_DUMMY_RETURN for Borland\n+- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).\n+- allow compilation with CC\n+- defined STDC for OS/2 (David Charlap)\t\n+- limit external names to 8 chars for MVS (Thomas Lund)\n+- in minigzip.c, use static buffers only for 16-bit systems\n+- fix suffix check for \"minigzip -d foo.gz\"\n+- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)\n+- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)\n+- added makelcc.bat for lcc-win32 (Tom St Denis)\n+- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)\n+- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion.\n+- check for unistd.h in configure (for off_t)\n+- remove useless check parameter in inflate_blocks_free\n+- avoid useless assignment of s->check to itself in inflate_blocks_new\n+- do not flush twice in gzclose (thanks to Ken Raeburn)\n+- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h\n+- use NO_ERRNO_H instead of enumeration of operating systems with errno.h\n+- work around buggy fclose on pipes for HP/UX\n+- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)\n+- fix configure if CC is already equal to gcc\n+\n+Changes in 1.0.5 (3 Jan 98)\n+- Fix inflate to terminate gracefully when fed corrupted or invalid data\n+- Use const for rommable constants in inflate\n+- Eliminate memory leaks on error conditions in inflate\n+- Removed some vestigial code in inflate\n+- Update web address in README\n+  \n+Changes in 1.0.4 (24 Jul 96)\n+- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF\n+  bit, so the decompressor could decompress all the correct data but went\n+  on to attempt decompressing extra garbage data. This affected minigzip too.\n+- zlibVersion and gzerror return const char* (needed for DLL)\n+- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)\n+- use z_error only for DEBUG (avoid problem with DLLs)\n+\n+Changes in 1.0.3 (2 Jul 96)\n+- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS\n+  small and medium models; this makes the library incompatible with previous\n+  versions for these models. (No effect in large model or on other systems.)\n+- return OK instead of BUF_ERROR if previous deflate call returned with\n+  avail_out as zero but there is nothing to do\n+- added memcmp for non STDC compilers\n+- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)\n+- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)\n+- better check for 16-bit mode MSC (avoids problem with Symantec)\n+\n+Changes in 1.0.2 (23 May 96)\n+- added Windows DLL support\n+- added a function zlibVersion (for the DLL support)\n+- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)\n+- Bytef is define's instead of typedef'd only for Borland C\n+- avoid reading uninitialized memory in example.c\n+- mention in README that the zlib format is now RFC1950\n+- updated Makefile.dj2\n+- added algorithm.doc\n+\n+Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]\n+- fix array overlay in deflate.c which sometimes caused bad compressed data\n+- fix inflate bug with empty stored block\n+- fix MSDOS medium model which was broken in 0.99\n+- fix deflateParams() which could generated bad compressed data.\n+- Bytef is define'd instead of typedef'ed (work around Borland bug)\n+- added an INDEX file\n+- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),\n+  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)\n+- speed up adler32 for modern machines without auto-increment\n+- added -ansi for IRIX in configure\n+- static_init_done in trees.c is an int\n+- define unlink as delete for VMS\n+- fix configure for QNX\n+- add configure branch for SCO and HPUX\n+- avoid many warnings (unused variables, dead assignments, etc...)\n+- no fdopen for BeOS\n+- fix the Watcom fix for 32 bit mode (define FAR as empty)\n+- removed redefinition of Byte for MKWERKS\n+- work around an MWKERKS bug (incorrect merge of all .h files)\n+\n+Changes in 0.99 (27 Jan 96)\n+- allow preset dictionary shared between compressor and decompressor\n+- allow compression level 0 (no compression)\n+- add deflateParams in zlib.h: allow dynamic change of compression level\n+  and compression strategy.\n+- test large buffers and deflateParams in example.c\n+- add optional \"configure\" to build zlib as a shared library\n+- suppress Makefile.qnx, use configure instead\n+- fixed deflate for 64-bit systems (detected on Cray)\n+- fixed inflate_blocks for 64-bit systems (detected on Alpha)\n+- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)\n+- always return Z_BUF_ERROR when deflate() has nothing to do\n+- deflateInit and inflateInit are now macros to allow version checking\n+- prefix all global functions and types with z_ with -DZ_PREFIX\n+- make falloc completely reentrant (inftrees.c)\n+- fixed very unlikely race condition in ct_static_init\n+- free in reverse order of allocation to help memory manager\n+- use zlib-1.0/* instead of zlib/* inside the tar.gz\n+- make zlib warning-free with \"gcc -O3 -Wall -Wwrite-strings -Wpointer-arith\n+  -Wconversion -Wstrict-prototypes -Wmissing-prototypes\"\n+- allow gzread on concatenated .gz files\n+- deflateEnd now returns Z_DATA_ERROR if it was premature\n+- deflate is finally (?) fully deterministic (no matches beyond end of input)\n+- Document Z_SYNC_FLUSH\n+- add uninstall in Makefile\n+- Check for __cpluplus in zlib.h\n+- Better test in ct_align for partial flush\n+- avoid harmless warnings for Borland C++\n+- initialize hash_head in deflate.c\n+- avoid warning on fdopen (gzio.c) for HP cc -Aa\n+- include stdlib.h for STDC compilers\n+- include errno.h for Cray\n+- ignore error if ranlib doesn't exist\n+- call ranlib twice for NeXTSTEP\n+- use exec_prefix instead of prefix for libz.a\n+- renamed ct_* as _tr_* to avoid conflict with applications\n+- clear z->msg in inflateInit2 before any error return\n+- initialize opaque in example.c, gzio.c, deflate.c and inflate.c\n+- fixed typo in zconf.h (_GNUC__ => __GNUC__)\n+- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)\n+- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)\n+- in fcalloc, normalize pointer if size > 65520 bytes\n+- don't use special fcalloc for 32 bit Borland C++\n+- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...\n+- use Z_BINARY instead of BINARY\n+- document that gzclose after gzdopen will close the file\n+- allow \"a\" as mode in gzopen.\n+- fix error checking in gzread\n+- allow skipping .gz extra-field on pipes\n+- added reference to Perl interface in README\n+- put the crc table in FAR data (I dislike more and more the medium model :)\n+- added get_crc_table\n+- added a dimension to all arrays (Borland C can't count).\n+- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast\n+- guard against multiple inclusion of *.h (for precompiled header on Mac)\n+- Watcom C pretends to be Microsoft C small model even in 32 bit mode.\n+- don't use unsized arrays to avoid silly warnings by Visual C++:\n+     warning C4746: 'inflate_mask' : unsized array treated as  '__far'\n+     (what's wrong with far data in far model?).\n+- define enum out of inflate_blocks_state to allow compilation with C++\n+\n+Changes in 0.95 (16 Aug 95)\n+- fix MSDOS small and medium model (now easier to adapt to any compiler)\n+- inlined send_bits\n+- fix the final (:-) bug for deflate with flush (output was correct but\n+  not completely flushed in rare occasions).\n+- default window size is same for compression and decompression\n+  (it's now sufficient to set MAX_WBITS in zconf.h).\n+- voidp -> voidpf and voidnp -> voidp (for consistency with other\n+  typedefs and because voidnp was not near in large model).\n+\n+Changes in 0.94 (13 Aug 95)\n+- support MSDOS medium model\n+- fix deflate with flush (could sometimes generate bad output)\n+- fix deflateReset (zlib header was incorrectly suppressed)\n+- added support for VMS\n+- allow a compression level in gzopen()\n+- gzflush now calls fflush\n+- For deflate with flush, flush even if no more input is provided.\n+- rename libgz.a as libz.a\n+- avoid complex expression in infcodes.c triggering Turbo C bug\n+- work around a problem with gcc on Alpha (in INSERT_STRING)\n+- don't use inline functions (problem with some gcc versions)\n+- allow renaming of Byte, uInt, etc... with #define.\n+- avoid warning about (unused) pointer before start of array in deflate.c\n+- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c\n+- avoid reserved word 'new' in trees.c\n+\n+Changes in 0.93 (25 June 95)\n+- temporarily disable inline functions\n+- make deflate deterministic\n+- give enough lookahead for PARTIAL_FLUSH\n+- Set binary mode for stdin/stdout in minigzip.c for OS/2\n+- don't even use signed char in inflate (not portable enough)\n+- fix inflate memory leak for segmented architectures\n+\n+Changes in 0.92 (3 May 95)\n+- don't assume that char is signed (problem on SGI)\n+- Clear bit buffer when starting a stored block\n+- no memcpy on Pyramid\n+- suppressed inftest.c\n+- optimized fill_window, put longest_match inline for gcc\n+- optimized inflate on stored blocks.\n+- untabify all sources to simplify patches\n+\n+Changes in 0.91 (2 May 95)\n+- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h\n+- Document the memory requirements in zconf.h\n+- added \"make install\"\n+- fix sync search logic in inflateSync\n+- deflate(Z_FULL_FLUSH) now works even if output buffer too short\n+- after inflateSync, don't scare people with just \"lo world\"\n+- added support for DJGPP\n+\n+Changes in 0.9 (1 May 95)\n+- don't assume that zalloc clears the allocated memory (the TurboC bug\n+  was Mark's bug after all :)\n+- let again gzread copy uncompressed data unchanged (was working in 0.71)\n+- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented\n+- added a test of inflateSync in example.c\n+- moved MAX_WBITS to zconf.h because users might want to change that.\n+- document explicitly that zalloc(64K) on MSDOS must return a normalized\n+  pointer (zero offset)\n+- added Makefiles for Microsoft C, Turbo C, Borland C++\n+- faster crc32()\n+\n+Changes in 0.8 (29 April 95)\n+- added fast inflate (inffast.c)\n+- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this\n+  is incompatible with previous versions of zlib which returned Z_OK.\n+- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)\n+  (actually that was not a compiler bug, see 0.81 above)\n+- gzread no longer reads one extra byte in certain cases\n+- In gzio destroy(), don't reference a freed structure\n+- avoid many warnings for MSDOS\n+- avoid the ERROR symbol which is used by MS Windows\n+\n+Changes in 0.71 (14 April 95)\n+- Fixed more MSDOS compilation problems :( There is still a bug with\n+  TurboC large model.\n+\n+Changes in 0.7 (14 April 95)\n+- Added full inflate support.\n+- Simplified the crc32() interface. The pre- and post-conditioning\n+  (one's complement) is now done inside crc32(). WARNING: this is\n+  incompatible with previous versions; see zlib.h for the new usage.\n+\n+Changes in 0.61 (12 April 95)\n+- workaround for a bug in TurboC. example and minigzip now work on MSDOS.\n+\n+Changes in 0.6 (11 April 95)\n+- added minigzip.c\n+- added gzdopen to reopen a file descriptor as gzFile\n+- added transparent reading of non-gziped files in gzread.\n+- fixed bug in gzread (don't read crc as data)\n+- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).\n+- don't allocate big arrays in the stack (for MSDOS)\n+- fix some MSDOS compilation problems\n+\n+Changes in 0.5:\n+- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but\n+  not yet Z_FULL_FLUSH.\n+- support decompression but only in a single step (forced Z_FINISH)\n+- added opaque object for zalloc and zfree.\n+- added deflateReset and inflateReset\n+- added a variable zlib_version for consistency checking.\n+- renamed the 'filter' parameter of deflateInit2 as 'strategy'.\n+  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.\n+\n+Changes in 0.4:\n+- avoid \"zip\" everywhere, use zlib instead of ziplib.\n+- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush\n+  if compression method == 8.\n+- added adler32 and crc32\n+- renamed deflateOptions as deflateInit2, call one or the other but not both\n+- added the method parameter for deflateInit2.\n+- added inflateInit2\n+- simplied considerably deflateInit and inflateInit by not supporting\n+  user-provided history buffer. This is supported only in deflateInit2\n+  and inflateInit2.\n+\n+Changes in 0.3:\n+- prefix all macro names with Z_\n+- use Z_FINISH instead of deflateEnd to finish compression.\n+- added Z_HUFFMAN_ONLY\n+- added gzerror()"}, {"sha": "0feb6d3e9bbbe81741dd7b63008740e4bdc12f8e", "filename": "zlib/FAQ", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FFAQ", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FFAQ", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FFAQ?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,72 @@\n+\n+\t\tFrequently Asked Questions about zlib\n+\n+\n+If your question is not there, please check the zlib home page \n+http://www.cdrom.com/pub/infozip/zlib/ which may have more recent information.\n+\n+\n+1) I need a Windows DLL\n+2) I need a Visual Basic interface to zlib\n+3) compress() returns Z_BUF_ERROR\n+4) deflate or inflate returns Z_BUF_ERROR\n+5) Where is the zlib documentation (man pages, etc...)?\n+6) Why don't you use GNU autoconf, libtool, etc...?\n+7) There is a bug in zlib.\n+8) I get \"undefined reference to gzputc\"\n+\n+\n+\n+1) I need a Windows DLL\n+\n+  The zlib sources can be compiled without change to produce a DLL.\n+  If you want a precompiled DLL, see http://www.winimage.com/zLibDll\n+\n+\n+2) I need a Visual Basic interface to zlib\n+\n+  See http://www.tcfb.com/dowseware/cmp-z-it.zip\n+      http://web2.airmail.net/markn/articles/zlibtool/zlibtool.htm\n+  and contrib/visual-basic.txt\n+\n+3) compress() returns Z_BUF_ERROR\n+\n+  Make sure that before the call of compress, the length of the\n+  compressed buffer is equal to the total size of the compressed buffer\n+  and not zero.  For Visual Basic, check that this parameter is passed\n+  by reference (\"as any\"), not by value (\"as long\").\n+\n+\n+4) deflate or inflate returns Z_BUF_ERROR\n+\n+  Make sure that before the call avail_in and avail_out are not zero.\n+\n+\n+5) Where is the zlib documentation (man pages, etc...)?\n+\n+  It's in zlib.h for the moment. Volunteers to transform this\n+  to man pages, please contact jloup@gzip.org. Examples of zlib usage\n+  are in the files example.c and minigzip.c.\n+\n+\n+6) Why don't you use GNU autoconf, libtool, etc...?\n+\n+  Because we would like to keep zlib as a very small and simple package.\n+  zlib is rather portable and doesn't need much configuration.\n+\n+\n+7) There is a bug in zlib.\n+\n+  Most of the time, such problems are due to an incorrect usage\n+  of zlib. Please try to reproduce the problem with a small\n+  program and send us the corresponding source at zlib@quest.jpl.nasa.gov\n+  Do not send multi-megabyte data files without prior agreement.\n+\n+\n+8) I get \"undefined reference to gzputc\"\n+\n+  If \"make test\" produces something like\n+     example.o(.text+0x174): \n+  check that you don't have old files libz.* in /usr/lib, /usr/local/lib\n+  or /usr/X11R6/lib. Remove old versions then do \"make install\".\n+"}, {"sha": "8a24576640269b8f6d872232ad3947cc83e72d4e", "filename": "zlib/INDEX", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FINDEX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FINDEX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FINDEX?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,86 @@\n+ChangeLog\t\thistory of changes\n+INDEX\t\t\tthis file\n+FAQ\t\t\tFrequently Asked Questions about zlib\n+Make_vms.com\t\tscript for Vax/VMS\n+Makefile\t\tmakefile for Unix (generated by configure)\n+Makefile.in\t\tmakefile for Unix (template for configure)\n+Makefile.riscos \tmakefile for RISCOS\n+README\t\t\tguess what\n+algorithm.txt\t\tdescription of the (de)compression algorithm\n+configure\t\tconfigure script for Unix\n+descrip.mms\t\tmakefile for Vax/VMS\n+zlib.3\t\t\tmini man page for zlib (volunteers to write full\n+\t\t\tman pages from zlib.h welcome. write to jloup@gzip.org)\n+\n+amiga/Makefile.sas\tmakefile for Amiga SAS/C\n+amiga/Makefile.pup      makefile for Amiga powerUP SAS/C PPC\n+\n+msdos/Makefile.w32      makefile for Microsoft Visual C++ 32-bit\n+msdos/Makefile.b32\tmakefile for Borland C++   32-bit\n+msdos/Makefile.bor\tmakefile for Borland C/C++ 16-bit\n+msdos/Makefile.dj2\tmakefile for DJGPP 2.x\n+msdos/Makefile.emx\tmakefile for EMX 0.9c (32-bit DOS/OS2)\n+msdos/Makefile.msc\tmakefile for Microsoft C 16-bit\n+msdos/Makefile.tc\tmakefile for Turbo C\n+msdos/Makefile.wat\tmakefile for Watcom C\n+msdos/zlib.def        \tdefinition file for Windows DLL\n+msdos/zlib.rc         \tdefinition file for Windows DLL\n+\n+nt/Makefile.nt\t\tmakefile for Windows NT\n+nt/zlib.dnt\t\tdefinition file for Windows NT DLL\n+nt/Makefile.emx\t\tmakefile for EMX 0.9c/RSXNT 1.41 (Win32 Intel)\n+nt/Makefile.gcc\t\tmakefile for Windows NT using GCC (mingw32)\n+\n+\n+\t\tzlib public header files (must be kept):\n+zconf.h\n+zlib.h\n+\n+\t\tprivate source files used to build the zlib library:\n+adler32.c\n+compress.c\n+crc32.c\n+deflate.c\n+deflate.h\n+gzio.c\n+infblock.c\n+infblock.h\n+infcodes.c\n+infcodes.h\n+inffast.c\n+inffast.h\n+inflate.c\n+inftrees.c\n+inftrees.h\n+infutil.c\n+infutil.h\n+maketree.c\n+trees.c\n+uncompr.c\n+zutil.c\n+zutil.h\n+\n+\t\tsource files for sample programs:\n+example.c\n+minigzip.c\n+\n+\t\tunsupported contribution by third parties\n+\n+contrib/asm386/ by Gilles Vollant <info@winimage.com>\n+\t386 asm code replacing longest_match().\n+\n+contrib/minizip/ by Gilles Vollant <info@winimage.com>\n+\tMini zip and unzip based on zlib\n+        See http://www.winimage.com/zLibDll/unzip.html\n+\n+contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>\n+        A C++ I/O streams interface to the zlib gz* functions\n+\n+contrib/iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n+\tAnother C++ I/O streams interface\n+\n+contrib/untgz/  by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+\tA very simple tar.gz extractor using zlib\n+\n+contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n+        How to use compress(), uncompress() and the gz* functions from VB."}, {"sha": "1c57e8f0e02d2091ac6a7c33d3638c9bf75772eb", "filename": "zlib/Make_vms.com", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMake_vms.com?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,115 @@\n+$! make libz under VMS\n+$! written by Martin P.J. Zinser <m.zinser@gsi.de>\n+$!\n+$! Look for the compiler used\n+$!\n+$ ccopt = \"\"\n+$ if f$getsyi(\"HW_MODEL\").ge.1024\n+$ then\n+$  ccopt = \"/prefix=all\"+ccopt\n+$  comp  = \"__decc__=1\"\n+$  if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n+$ else\n+$  if f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\").eqs.\"\"\n+$   then\n+$    comp  = \"__vaxc__=1\"\n+$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n+$   else\n+$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys decc$library_include:\n+$    ccopt = \"/decc/prefix=all\"+ccopt\n+$    comp  = \"__decc__=1\"\n+$  endif\n+$ endif\n+$!\n+$! Build the thing plain or with mms\n+$!\n+$ write sys$output \"Compiling Zlib sources ...\"\n+$ if f$search(\"SYS$SYSTEM:MMS.EXE\").eqs.\"\"\n+$  then\n+$   dele example.obj;*,minigzip.obj;*\n+$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n+                adler32.c zlib.h zconf.h\n+$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n+                compress.c zlib.h zconf.h\n+$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n+                crc32.c zlib.h zconf.h\n+$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n+                deflate.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE gzio.OBJ \"CC ''CCOPT' gzio\" -\n+                gzio.c zutil.h zlib.h zconf.h\n+$   CALL MAKE infblock.OBJ \"CC ''CCOPT' infblock\" -\n+                infblock.c zutil.h zlib.h zconf.h infblock.h\n+$   CALL MAKE infcodes.OBJ \"CC ''CCOPT' infcodes\" -\n+                infcodes.c zutil.h zlib.h zconf.h inftrees.h\n+$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n+                inffast.c zutil.h zlib.h zconf.h inffast.h\n+$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n+                inflate.c zutil.h zlib.h zconf.h infblock.h\n+$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n+                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+$   CALL MAKE infutil.OBJ \"CC ''CCOPT' infutil\" -\n+                infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n+                trees.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n+                uncompr.c zlib.h zconf.h\n+$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n+                zutil.c zutil.h zlib.h zconf.h\n+$   write sys$output \"Building Zlib ...\"\n+$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n+$   write sys$output \"Building example...\"\n+$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n+                example.c zlib.h zconf.h\n+$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n+$   write sys$output \"Building minigzip...\"\n+$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n+                minigzip.c zlib.h zconf.h\n+$   call make minigzip.exe - \n+                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" - \n+                minigzip.obj libz.olb\n+$  else\n+$   mms/macro=('comp')\n+$  endif\n+$ write sys$output \"Zlib build completed\"\n+$ exit\n+$!\n+$!\n+$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n+$ V = 'F$Verify(0)\n+$! P1 = What we are trying to make\n+$! P2 = Command to make it\n+$! P3 - P8  What it depends on\n+$\n+$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n+$ Time = F$CvTime(F$File(P1,\"RDT\"))\n+$arg=3\n+$Loop:\n+$       Argument = P'arg\n+$       If Argument .Eqs. \"\" Then Goto Exit\n+$       El=0\n+$Loop2:\n+$       File = F$Element(El,\" \",Argument)\n+$       If File .Eqs. \" \" Then Goto Endl\n+$       AFile = \"\"\n+$Loop3:\n+$       OFile = AFile\n+$       AFile = F$Search(File)\n+$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n+$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n+$       Goto Loop3\n+$NextEL:\n+$       El = El + 1\n+$       Goto Loop2\n+$EndL:\n+$ arg=arg+1\n+$ If arg .Le. 8 Then Goto Loop\n+$ Goto Exit\n+$\n+$Makeit:\n+$ VV=F$VERIFY(0)\n+$ write sys$output P2\n+$ 'P2\n+$ VV='F$Verify(VV)\n+$Exit:\n+$ If V Then Set Verify\n+$ENDSUBROUTINE"}, {"sha": "3a3b116f424678f8d2402b1f2f107369488bb895", "filename": "zlib/Makefile", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,174 @@\n+# Makefile for zlib\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile and test, type:\n+#   ./configure; make test\n+# The call of configure is optional if you don't have special requirements\n+# If you wish to build zlib as a shared library, use: ./configure -s\n+\n+# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:\n+#    make install\n+# To install in $HOME instead of /usr/local, use:\n+#    make install prefix=$HOME\n+\n+CC=cc\n+\n+CFLAGS=-O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-g -DDEBUG\n+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+#           -Wstrict-prototypes -Wmissing-prototypes\n+\n+LDFLAGS=-L. -lz\n+LDSHARED=$(CC)\n+CPP=$(CC) -E\n+\n+VER=1.1.3\n+LIBS=libz.a\n+SHAREDLIB=libz.so\n+\n+AR=ar rc\n+RANLIB=ranlib\n+TAR=tar\n+SHELL=/bin/sh\n+\n+prefix = /usr/local\n+exec_prefix = ${prefix}\n+libdir = ${exec_prefix}/lib\n+includedir = ${prefix}/include\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+OBJA =\n+# to use the asm code: make OBJA=match.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+DISTFILES = README FAQ INDEX ChangeLog configure Make*[a-z0-9] *.[ch] *.mms \\\n+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \\\n+  nt/Make*[a-z0-9] nt/zlib.dnt amiga/Make*.??? os2/M*.os2 os2/zlib.def \\\n+  contrib/RE*.contrib contrib/*.txt contrib/asm386/*.asm contrib/asm386/*.c \\\n+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/asm[56]86/*.?86 \\\n+  contrib/asm[56]86/*.S contrib/iostream/*.cpp \\\n+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \\\n+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32 \\\n+  contrib/minizip/[CM]*[pe] contrib/minizip/*.[ch] contrib/minizip/*.[td]?? \\\n+  contrib/delphi*/*.???\n+\n+all: example minigzip\n+\n+test: all\n+\t@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \\\n+\techo hello world | ./minigzip | ./minigzip -d || \\\n+\t  echo '\t\t*** minigzip test FAILED ***' ; \\\n+\tif ./example; then \\\n+\t  echo '\t\t*** zlib test OK ***'; \\\n+\telse \\\n+\t  echo '\t\t*** zlib test FAILED ***'; \\\n+\tfi\n+\n+libz.a: $(OBJS) $(OBJA)\n+\t$(AR) $@ $(OBJS) $(OBJA)\n+\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n+\n+match.o: match.S\n+\t$(CPP) match.S > _match.s\n+\t$(CC) -c _match.s\n+\tmv _match.o match.o\n+\trm -f _match.s\n+\n+$(SHAREDLIB).$(VER): $(OBJS)\n+\t$(LDSHARED) -o $@ $(OBJS)\n+\trm -f $(SHAREDLIB) $(SHAREDLIB).1\n+\tln -s $@ $(SHAREDLIB)\n+\tln -s $@ $(SHAREDLIB).1\n+\n+example: example.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)\n+\n+minigzip: minigzip.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)\n+\n+install: $(LIBS)\n+\t-@if [ ! -d $(includedir)  ]; then mkdir $(includedir); fi\n+\t-@if [ ! -d $(libdir) ]; then mkdir $(libdir); fi\n+\tcp zlib.h zconf.h $(includedir)\n+\tchmod 644 $(includedir)/zlib.h $(includedir)/zconf.h\n+\tcp $(LIBS) $(libdir)\n+\tcd $(libdir); chmod 755 $(LIBS)\n+\t-@(cd $(libdir); $(RANLIB) libz.a || true) >/dev/null 2>&1\n+\tcd $(libdir); if test -f $(SHAREDLIB).$(VER); then \\\n+\t  rm -f $(SHAREDLIB) $(SHAREDLIB).1; \\\n+\t  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB); \\\n+\t  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB).1; \\\n+\t  (ldconfig || true)  >/dev/null 2>&1; \\\n+\tfi\n+# The ranlib in install is needed on NeXTSTEP which checks file times\n+# ldconfig is for Linux\n+\n+uninstall:\n+\tcd $(includedir); \\\n+\tv=$(VER); \\\n+\tif test -f zlib.h; then \\\n+\t  v=`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`; \\\n+          rm -f zlib.h zconf.h; \\\n+\tfi; \\\n+\tcd $(libdir); rm -f libz.a; \\\n+\tif test -f $(SHAREDLIB).$$v; then \\\n+\t  rm -f $(SHAREDLIB).$$v $(SHAREDLIB) $(SHAREDLIB).1; \\\n+\tfi\n+\n+clean:\n+\trm -f *.o *~ example minigzip libz.a libz.so* foo.gz so_locations \\\n+\t   _match.s maketree\n+\n+distclean:\tclean\n+\n+zip:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c contrib/minizip/test.zip\n+\tv=`sed -n -e 's/\\.//g' -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\tzip -ul9 zlib$$v $(DISTFILES)\n+\tmv Makefile~ Makefile\n+\n+dist:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c contrib/minizip/test.zip\n+\td=zlib-`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\trm -f $$d.tar.gz; \\\n+\tif test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \\\n+\tfiles=\"\"; \\\n+\tfor f in $(DISTFILES); do files=\"$$files $$d/$$f\"; done; \\\n+\tcd ..; \\\n+\tGZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \\\n+\tif test ! -d $$d; then rm -f $$d; fi\n+\tmv Makefile~ Makefile\n+\n+tags:\t\n+\tetags *.[ch]\n+\n+depend:\n+\tmakedepend -- $(CFLAGS) -- *.[ch]\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h\n+infcodes.o: zutil.h zlib.h zconf.h\n+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h\n+inffast.o: infblock.h infcodes.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+minigzip.o:  zlib.h zconf.h \n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h  "}, {"sha": "3a3b116f424678f8d2402b1f2f107369488bb895", "filename": "zlib/Makefile.in", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile.in?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,174 @@\n+# Makefile for zlib\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile and test, type:\n+#   ./configure; make test\n+# The call of configure is optional if you don't have special requirements\n+# If you wish to build zlib as a shared library, use: ./configure -s\n+\n+# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:\n+#    make install\n+# To install in $HOME instead of /usr/local, use:\n+#    make install prefix=$HOME\n+\n+CC=cc\n+\n+CFLAGS=-O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-g -DDEBUG\n+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+#           -Wstrict-prototypes -Wmissing-prototypes\n+\n+LDFLAGS=-L. -lz\n+LDSHARED=$(CC)\n+CPP=$(CC) -E\n+\n+VER=1.1.3\n+LIBS=libz.a\n+SHAREDLIB=libz.so\n+\n+AR=ar rc\n+RANLIB=ranlib\n+TAR=tar\n+SHELL=/bin/sh\n+\n+prefix = /usr/local\n+exec_prefix = ${prefix}\n+libdir = ${exec_prefix}/lib\n+includedir = ${prefix}/include\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+OBJA =\n+# to use the asm code: make OBJA=match.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+DISTFILES = README FAQ INDEX ChangeLog configure Make*[a-z0-9] *.[ch] *.mms \\\n+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \\\n+  nt/Make*[a-z0-9] nt/zlib.dnt amiga/Make*.??? os2/M*.os2 os2/zlib.def \\\n+  contrib/RE*.contrib contrib/*.txt contrib/asm386/*.asm contrib/asm386/*.c \\\n+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/asm[56]86/*.?86 \\\n+  contrib/asm[56]86/*.S contrib/iostream/*.cpp \\\n+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \\\n+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32 \\\n+  contrib/minizip/[CM]*[pe] contrib/minizip/*.[ch] contrib/minizip/*.[td]?? \\\n+  contrib/delphi*/*.???\n+\n+all: example minigzip\n+\n+test: all\n+\t@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \\\n+\techo hello world | ./minigzip | ./minigzip -d || \\\n+\t  echo '\t\t*** minigzip test FAILED ***' ; \\\n+\tif ./example; then \\\n+\t  echo '\t\t*** zlib test OK ***'; \\\n+\telse \\\n+\t  echo '\t\t*** zlib test FAILED ***'; \\\n+\tfi\n+\n+libz.a: $(OBJS) $(OBJA)\n+\t$(AR) $@ $(OBJS) $(OBJA)\n+\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n+\n+match.o: match.S\n+\t$(CPP) match.S > _match.s\n+\t$(CC) -c _match.s\n+\tmv _match.o match.o\n+\trm -f _match.s\n+\n+$(SHAREDLIB).$(VER): $(OBJS)\n+\t$(LDSHARED) -o $@ $(OBJS)\n+\trm -f $(SHAREDLIB) $(SHAREDLIB).1\n+\tln -s $@ $(SHAREDLIB)\n+\tln -s $@ $(SHAREDLIB).1\n+\n+example: example.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)\n+\n+minigzip: minigzip.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)\n+\n+install: $(LIBS)\n+\t-@if [ ! -d $(includedir)  ]; then mkdir $(includedir); fi\n+\t-@if [ ! -d $(libdir) ]; then mkdir $(libdir); fi\n+\tcp zlib.h zconf.h $(includedir)\n+\tchmod 644 $(includedir)/zlib.h $(includedir)/zconf.h\n+\tcp $(LIBS) $(libdir)\n+\tcd $(libdir); chmod 755 $(LIBS)\n+\t-@(cd $(libdir); $(RANLIB) libz.a || true) >/dev/null 2>&1\n+\tcd $(libdir); if test -f $(SHAREDLIB).$(VER); then \\\n+\t  rm -f $(SHAREDLIB) $(SHAREDLIB).1; \\\n+\t  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB); \\\n+\t  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB).1; \\\n+\t  (ldconfig || true)  >/dev/null 2>&1; \\\n+\tfi\n+# The ranlib in install is needed on NeXTSTEP which checks file times\n+# ldconfig is for Linux\n+\n+uninstall:\n+\tcd $(includedir); \\\n+\tv=$(VER); \\\n+\tif test -f zlib.h; then \\\n+\t  v=`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`; \\\n+          rm -f zlib.h zconf.h; \\\n+\tfi; \\\n+\tcd $(libdir); rm -f libz.a; \\\n+\tif test -f $(SHAREDLIB).$$v; then \\\n+\t  rm -f $(SHAREDLIB).$$v $(SHAREDLIB) $(SHAREDLIB).1; \\\n+\tfi\n+\n+clean:\n+\trm -f *.o *~ example minigzip libz.a libz.so* foo.gz so_locations \\\n+\t   _match.s maketree\n+\n+distclean:\tclean\n+\n+zip:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c contrib/minizip/test.zip\n+\tv=`sed -n -e 's/\\.//g' -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\tzip -ul9 zlib$$v $(DISTFILES)\n+\tmv Makefile~ Makefile\n+\n+dist:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c contrib/minizip/test.zip\n+\td=zlib-`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\trm -f $$d.tar.gz; \\\n+\tif test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \\\n+\tfiles=\"\"; \\\n+\tfor f in $(DISTFILES); do files=\"$$files $$d/$$f\"; done; \\\n+\tcd ..; \\\n+\tGZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \\\n+\tif test ! -d $$d; then rm -f $$d; fi\n+\tmv Makefile~ Makefile\n+\n+tags:\t\n+\tetags *.[ch]\n+\n+depend:\n+\tmakedepend -- $(CFLAGS) -- *.[ch]\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h\n+infcodes.o: zutil.h zlib.h zconf.h\n+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h\n+inffast.o: infblock.h infcodes.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+minigzip.o:  zlib.h zconf.h \n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h  "}, {"sha": "d97f4492370f1be65002d26866c2312937730a67", "filename": "zlib/Makefile.riscos", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile.riscos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FMakefile.riscos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile.riscos?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,151 @@\n+# Project:   zlib_1_03\n+# Patched for zlib 1.1.2 rw@shadow.org.uk 19980430\n+# test works out-of-the-box, installs `somewhere' on demand\n+\n+# Toolflags:\n+CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah \n+C++flags = -c -depend !Depend -IC: -throwback\n+Linkflags = -aif -c++ -o $@ \n+ObjAsmflags = -throwback -NoCache -depend !Depend\n+CMHGflags = \n+LibFileflags = -c -l -o $@ \n+Squeezeflags = -o $@\n+\n+# change the line below to where _you_ want the library installed.\n+libdest = lib:zlib\n+\n+# Final targets:\n+@.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \\\n+        @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \\\n+        @.o.uncompr @.o.zutil \n+        LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \\\n+        @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \\\n+        @.o.trees @.o.uncompr @.o.zutil \n+test:   @.minigzip @.example @.lib\n+\t@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV\n+\t@echo running tests: hang on.\n+\t@/@.minigzip -f -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -f -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -h -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -h -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -9 libc\n+\t@/@.minigzip -d libc-gz\n+\t@/@.minigzip -1 libc\n+\t@/@.minigzip -d libc-gz\n+\t@diff @.lib @.libc\n+\t@echo that should have reported '@.lib and @.libc identical' if you have diff.\n+\t@/@.example @.fred @.fred\n+\t@echo that will have given lots of hello!'s.\n+\n+@.minigzip:   @.o.minigzip @.lib C:o.Stubs \n+        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs \n+@.example:   @.o.example @.lib C:o.Stubs \n+        Link $(Linkflags) @.o.example @.lib C:o.Stubs\n+\n+install: @.lib\n+\tcdir $(libdest)\n+\tcdir $(libdest).h\n+\t@copy @.h.zlib $(libdest).h.zlib A~C~DF~L~N~P~Q~RS~TV\n+\t@copy @.h.zconf $(libdest).h.zconf A~C~DF~L~N~P~Q~RS~TV\n+\t@copy @.lib $(libdest).lib  A~C~DF~L~N~P~Q~RS~TV\n+\t@echo okay, installed zlib in $(libdest)\n+\n+clean:; remove @.minigzip\n+\tremove @.example\n+\tremove @.libc\n+\t-wipe @.o.* F~r~cV\n+\tremove @.fred\n+\n+# User-editable dependencies:\n+.c.o:\n+        cc $(ccflags) -o $@ $<\n+\n+# Static dependencies:\n+\n+# Dynamic dependencies:\n+o.example:\tc.example\n+o.example:\th.zlib\n+o.example:\th.zconf\n+o.minigzip:\tc.minigzip\n+o.minigzip:\th.zlib\n+o.minigzip:\th.zconf\n+o.adler32:\tc.adler32\n+o.adler32:\th.zlib\n+o.adler32:\th.zconf\n+o.compress:\tc.compress\n+o.compress:\th.zlib\n+o.compress:\th.zconf\n+o.crc32:\tc.crc32\n+o.crc32:\th.zlib\n+o.crc32:\th.zconf\n+o.deflate:\tc.deflate\n+o.deflate:\th.deflate\n+o.deflate:\th.zutil\n+o.deflate:\th.zlib\n+o.deflate:\th.zconf\n+o.gzio:\tc.gzio\n+o.gzio:\th.zutil\n+o.gzio:\th.zlib\n+o.gzio:\th.zconf\n+o.infblock:\tc.infblock\n+o.infblock:\th.zutil\n+o.infblock:\th.zlib\n+o.infblock:\th.zconf\n+o.infblock:\th.infblock\n+o.infblock:\th.inftrees\n+o.infblock:\th.infcodes\n+o.infblock:\th.infutil\n+o.infcodes:\tc.infcodes\n+o.infcodes:\th.zutil\n+o.infcodes:\th.zlib\n+o.infcodes:\th.zconf\n+o.infcodes:\th.inftrees\n+o.infcodes:\th.infblock\n+o.infcodes:\th.infcodes\n+o.infcodes:\th.infutil\n+o.infcodes:\th.inffast\n+o.inffast:\tc.inffast\n+o.inffast:\th.zutil\n+o.inffast:\th.zlib\n+o.inffast:\th.zconf\n+o.inffast:\th.inftrees\n+o.inffast:\th.infblock\n+o.inffast:\th.infcodes\n+o.inffast:\th.infutil\n+o.inffast:\th.inffast\n+o.inflate:\tc.inflate\n+o.inflate:\th.zutil\n+o.inflate:\th.zlib\n+o.inflate:\th.zconf\n+o.inflate:\th.infblock\n+o.inftrees:\tc.inftrees\n+o.inftrees:\th.zutil\n+o.inftrees:\th.zlib\n+o.inftrees:\th.zconf\n+o.inftrees:\th.inftrees\n+o.inftrees:\th.inffixed\n+o.infutil:\tc.infutil\n+o.infutil:\th.zutil\n+o.infutil:\th.zlib\n+o.infutil:\th.zconf\n+o.infutil:\th.infblock\n+o.infutil:\th.inftrees\n+o.infutil:\th.infcodes\n+o.infutil:\th.infutil\n+o.trees:\tc.trees\n+o.trees:\th.deflate\n+o.trees:\th.zutil\n+o.trees:\th.zlib\n+o.trees:\th.zconf\n+o.trees:\th.trees\n+o.uncompr:\tc.uncompr\n+o.uncompr:\th.zlib\n+o.uncompr:\th.zconf\n+o.zutil:\tc.zutil\n+o.zutil:\th.zutil\n+o.zutil:\th.zlib\n+o.zutil:\th.zconf"}, {"sha": "8ff458799b957b342558504fe44409197f23b034", "filename": "zlib/README", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FREADME?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,148 @@\n+zlib 1.1.3 is a general purpose data compression library.  All the code\n+is thread safe.  The data format used by the zlib library\n+is described by RFCs (Request for Comments) 1950 to 1952 in the files \n+ftp://ds.internic.net/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate\n+format) and rfc1952.txt (gzip format). These documents are also available in\n+other formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html\n+\n+All functions of the compression library are documented in the file zlib.h\n+(volunteer to write man pages welcome, contact jloup@gzip.org). A usage\n+example of the library is given in the file example.c which also tests that\n+the library is working correctly. Another example is given in the file\n+minigzip.c. The compression library itself is composed of all source files\n+except example.c and minigzip.c.\n+\n+To compile all files and run the test program, follow the instructions\n+given at the top of Makefile. In short \"make test; make install\"\n+should work for most machines. For Unix: \"configure; make test; make install\"\n+For MSDOS, use one of the special makefiles such as Makefile.msc.\n+For VMS, use Make_vms.com or descrip.mms.\n+\n+Questions about zlib should be sent to <zlib@quest.jpl.nasa.gov>, or to\n+Gilles Vollant <info@winimage.com> for the Windows DLL version.\n+The zlib home page is http://www.cdrom.com/pub/infozip/zlib/\n+The official zlib ftp site is ftp://ftp.cdrom.com/pub/infozip/zlib/\n+Before reporting a problem, please check those sites to verify that\n+you have the latest version of zlib; otherwise get the latest version and\n+check whether the problem still exists or not.\n+\n+Mark Nelson <markn@tiny.com> wrote an article about zlib for the Jan. 1997\n+issue of  Dr. Dobb's Journal; a copy of the article is available in\n+http://web2.airmail.net/markn/articles/zlibtool/zlibtool.htm\n+\n+The changes made in version 1.1.3 are documented in the file ChangeLog.\n+The main changes since 1.1.2 are:\n+\n+- fix \"an inflate input buffer bug that shows up on rare but persistent\n+  occasions\" (Mark)\n+- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)\n+- fix gzseek(..., SEEK_SET) in write mode\n+- fix crc check after a gzeek (Frank Faubert)\n+- fix miniunzip when the last entry in a zip file is itself a zip file\n+  (J Lillge)\n+- add contrib/asm586 and contrib/asm686 (Brian Raiter)\n+  See http://www.muppetlabs.com/~breadbox/software/assembly.html\n+- add support for Delphi 3 in contrib/delphi (Bob Dellaca)\n+- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)\n+- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)\n+- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)\n+- added a FAQ file\n+\n+plus many changes for portability.\n+\n+Unsupported third party contributions are provided in directory \"contrib\".\n+\n+A Java implementation of zlib is available in the Java Development Kit 1.1\n+http://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html\n+See the zlib home page http://www.cdrom.com/pub/infozip/zlib/ for details.\n+\n+A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>\n+is in the CPAN (Comprehensive Perl Archive Network) sites, such as:\n+ftp://ftp.cis.ufl.edu/pub/perl/CPAN/modules/by-module/Compress/Compress-Zlib*\n+\n+A Python interface to zlib written by A.M. Kuchling <amk@magnet.com>\n+is available in Python 1.5 and later versions, see\n+http://www.python.org/doc/lib/module-zlib.html\n+\n+A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com>\n+is availlable at http://www.westend.com/~kupries/doc/trf/man/man.html\n+\n+An experimental package to read and write files in .zip format,\n+written on top of zlib by Gilles Vollant <info@winimage.com>, is\n+available at http://www.winimage.com/zLibDll/unzip.html\n+and also in the contrib/minizip directory of zlib.\n+\n+\n+Notes for some targets:\n+\n+- To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc\n+  and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL\n+  The zlib DLL support was initially done by Alessandro Iacopetti and is\n+  now maintained by Gilles Vollant <info@winimage.com>. Check the zlib DLL\n+  home page at http://www.winimage.com/zLibDll\n+\n+  From Visual Basic, you can call the DLL functions which do not take\n+  a structure as argument: compress, uncompress and all gz* functions.\n+  See contrib/visual-basic.txt for more information, or get\n+  http://www.tcfb.com/dowseware/cmp-z-it.zip\n+\n+- For 64-bit Irix, deflate.c must be compiled without any optimization.\n+  With -O, one libpng test fails. The test works in 32 bit mode (with\n+  the -n32 compiler flag). The compiler bug has been reported to SGI.\n+\n+- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   \n+  it works when compiled with cc.\n+\n+- on Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1\n+  is necessary to get gzprintf working correctly. This is done by configure.\n+\n+- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works\n+  with other compilers. Use \"make test\" to check your compiler.\n+\n+- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.\n+\n+- For Turbo C the small model is supported only with reduced performance to\n+  avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3\n+\n+- For PalmOs, see http://www.cs.uit.no/~perm/PASTA/pilot/software.html\n+  Per Harald Myrvang <perm@stud.cs.uit.no>\n+\n+\n+Acknowledgments:\n+\n+  The deflate format used by zlib was defined by Phil Katz. The deflate\n+  and zlib specifications were written by L. Peter Deutsch. Thanks to all the\n+  people who reported problems and suggested various improvements in zlib;\n+  they are too numerous to cite here.\n+\n+Copyright notice:\n+\n+ (C) 1995-1998 Jean-loup Gailly and Mark Adler\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the authors be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Jean-loup Gailly        Mark Adler\n+  jloup@gzip.org          madler@alumni.caltech.edu\n+\n+If you use the zlib library in a product, we would appreciate *not*\n+receiving lengthy legal documents to sign. The sources are provided\n+for free but without warranty of any kind.  The library has been\n+entirely written by Jean-loup Gailly and Mark Adler; it does not\n+include third-party code.\n+\n+If you redistribute modified sources, we would appreciate that you include\n+in the file ChangeLog history information documenting your changes."}, {"sha": "16cf9a703f7cdedc6715db64715254780ad6414d", "filename": "zlib/adler32.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fadler32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fadler32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fadler32.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,48 @@\n+/* adler32.c -- compute the Adler-32 checksum of a data stream\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"zlib.h\"\n+\n+#define BASE 65521L /* largest prime smaller than 65536 */\n+#define NMAX 5552\n+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n+\n+#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}\n+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n+#define DO16(buf)   DO8(buf,0); DO8(buf,8);\n+\n+/* ========================================================================= */\n+uLong ZEXPORT adler32(adler, buf, len)\n+    uLong adler;\n+    const Bytef *buf;\n+    uInt len;\n+{\n+    unsigned long s1 = adler & 0xffff;\n+    unsigned long s2 = (adler >> 16) & 0xffff;\n+    int k;\n+\n+    if (buf == Z_NULL) return 1L;\n+\n+    while (len > 0) {\n+        k = len < NMAX ? len : NMAX;\n+        len -= k;\n+        while (k >= 16) {\n+            DO16(buf);\n+\t    buf += 16;\n+            k -= 16;\n+        }\n+        if (k != 0) do {\n+            s1 += *buf++;\n+\t    s2 += s1;\n+        } while (--k);\n+        s1 %= BASE;\n+        s2 %= BASE;\n+    }\n+    return (s2 << 16) | s1;\n+}"}, {"sha": "cdc830b5deb8fbbcd41b653db1bb078d95854776", "filename": "zlib/algorithm.txt", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Falgorithm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Falgorithm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Falgorithm.txt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,213 @@\n+1. Compression algorithm (deflate)\n+\n+The deflation algorithm used by gzip (also zip and zlib) is a variation of\n+LZ77 (Lempel-Ziv 1977, see reference below). It finds duplicated strings in\n+the input data.  The second occurrence of a string is replaced by a\n+pointer to the previous string, in the form of a pair (distance,\n+length).  Distances are limited to 32K bytes, and lengths are limited\n+to 258 bytes. When a string does not occur anywhere in the previous\n+32K bytes, it is emitted as a sequence of literal bytes.  (In this\n+description, `string' must be taken as an arbitrary sequence of bytes,\n+and is not restricted to printable characters.)\n+\n+Literals or match lengths are compressed with one Huffman tree, and\n+match distances are compressed with another tree. The trees are stored\n+in a compact form at the start of each block. The blocks can have any\n+size (except that the compressed data for one block must fit in\n+available memory). A block is terminated when deflate() determines that\n+it would be useful to start another block with fresh trees. (This is\n+somewhat similar to the behavior of LZW-based _compress_.)\n+\n+Duplicated strings are found using a hash table. All input strings of\n+length 3 are inserted in the hash table. A hash index is computed for\n+the next 3 bytes. If the hash chain for this index is not empty, all\n+strings in the chain are compared with the current input string, and\n+the longest match is selected.\n+\n+The hash chains are searched starting with the most recent strings, to\n+favor small distances and thus take advantage of the Huffman encoding.\n+The hash chains are singly linked. There are no deletions from the\n+hash chains, the algorithm simply discards matches that are too old.\n+\n+To avoid a worst-case situation, very long hash chains are arbitrarily\n+truncated at a certain length, determined by a runtime option (level\n+parameter of deflateInit). So deflate() does not always find the longest\n+possible match but generally finds a match which is long enough.\n+\n+deflate() also defers the selection of matches with a lazy evaluation\n+mechanism. After a match of length N has been found, deflate() searches for\n+a longer match at the next input byte. If a longer match is found, the\n+previous match is truncated to a length of one (thus producing a single\n+literal byte) and the process of lazy evaluation begins again. Otherwise,\n+the original match is kept, and the next match search is attempted only N\n+steps later.\n+\n+The lazy match evaluation is also subject to a runtime parameter. If\n+the current match is long enough, deflate() reduces the search for a longer\n+match, thus speeding up the whole process. If compression ratio is more\n+important than speed, deflate() attempts a complete second search even if\n+the first match is already long enough.\n+\n+The lazy match evaluation is not performed for the fastest compression\n+modes (level parameter 1 to 3). For these fast modes, new strings\n+are inserted in the hash table only when no match was found, or\n+when the match is not too long. This degrades the compression ratio\n+but saves time since there are both fewer insertions and fewer searches.\n+\n+\n+2. Decompression algorithm (inflate)\n+\n+2.1 Introduction\n+\n+The real question is, given a Huffman tree, how to decode fast.  The most\n+important realization is that shorter codes are much more common than\n+longer codes, so pay attention to decoding the short codes fast, and let\n+the long codes take longer to decode.\n+\n+inflate() sets up a first level table that covers some number of bits of\n+input less than the length of longest code.  It gets that many bits from the\n+stream, and looks it up in the table.  The table will tell if the next\n+code is that many bits or less and how many, and if it is, it will tell\n+the value, else it will point to the next level table for which inflate()\n+grabs more bits and tries to decode a longer code.\n+\n+How many bits to make the first lookup is a tradeoff between the time it\n+takes to decode and the time it takes to build the table.  If building the\n+table took no time (and if you had infinite memory), then there would only\n+be a first level table to cover all the way to the longest code.  However,\n+building the table ends up taking a lot longer for more bits since short\n+codes are replicated many times in such a table.  What inflate() does is\n+simply to make the number of bits in the first table a variable, and set it\n+for the maximum speed.\n+\n+inflate() sends new trees relatively often, so it is possibly set for a\n+smaller first level table than an application that has only one tree for\n+all the data.  For inflate, which has 286 possible codes for the\n+literal/length tree, the size of the first table is nine bits.  Also the\n+distance trees have 30 possible values, and the size of the first table is\n+six bits.  Note that for each of those cases, the table ended up one bit\n+longer than the ``average'' code length, i.e. the code length of an\n+approximately flat code which would be a little more than eight bits for\n+286 symbols and a little less than five bits for 30 symbols.  It would be\n+interesting to see if optimizing the first level table for other\n+applications gave values within a bit or two of the flat code size.\n+\n+\n+2.2 More details on the inflate table lookup\n+\n+Ok, you want to know what this cleverly obfuscated inflate tree actually  \n+looks like.  You are correct that it's not a Huffman tree.  It is simply a  \n+lookup table for the first, let's say, nine bits of a Huffman symbol.  The  \n+symbol could be as short as one bit or as long as 15 bits.  If a particular  \n+symbol is shorter than nine bits, then that symbol's translation is duplicated\n+in all those entries that start with that symbol's bits.  For example, if the  \n+symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a  \n+symbol is nine bits long, it appears in the table once.\n+\n+If the symbol is longer than nine bits, then that entry in the table points  \n+to another similar table for the remaining bits.  Again, there are duplicated  \n+entries as needed.  The idea is that most of the time the symbol will be short\n+and there will only be one table look up.  (That's whole idea behind data  \n+compression in the first place.)  For the less frequent long symbols, there  \n+will be two lookups.  If you had a compression method with really long  \n+symbols, you could have as many levels of lookups as is efficient.  For  \n+inflate, two is enough.\n+\n+So a table entry either points to another table (in which case nine bits in  \n+the above example are gobbled), or it contains the translation for the symbol  \n+and the number of bits to gobble.  Then you start again with the next  \n+ungobbled bit.\n+\n+You may wonder: why not just have one lookup table for how ever many bits the  \n+longest symbol is?  The reason is that if you do that, you end up spending  \n+more time filling in duplicate symbol entries than you do actually decoding.   \n+At least for deflate's output that generates new trees every several 10's of  \n+kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code  \n+would take too long if you're only decoding several thousand symbols.  At the  \n+other extreme, you could make a new table for every bit in the code.  In fact,\n+that's essentially a Huffman tree.  But then you spend two much time  \n+traversing the tree while decoding, even for short symbols.\n+\n+So the number of bits for the first lookup table is a trade of the time to  \n+fill out the table vs. the time spent looking at the second level and above of\n+the table.\n+\n+Here is an example, scaled down:\n+\n+The code being decoded, with 10 symbols, from 1 to 6 bits long:\n+\n+A: 0\n+B: 10\n+C: 1100\n+D: 11010\n+E: 11011\n+F: 11100\n+G: 11101\n+H: 11110\n+I: 111110\n+J: 111111\n+\n+Let's make the first table three bits long (eight entries):\n+\n+000: A,1\n+001: A,1\n+010: A,1\n+011: A,1\n+100: B,2\n+101: B,2\n+110: -> table X (gobble 3 bits)\n+111: -> table Y (gobble 3 bits)\n+\n+Each entry is what the bits decode to and how many bits that is, i.e. how  \n+many bits to gobble.  Or the entry points to another table, with the number of\n+bits to gobble implicit in the size of the table.\n+\n+Table X is two bits long since the longest code starting with 110 is five bits\n+long:\n+\n+00: C,1\n+01: C,1\n+10: D,2\n+11: E,2\n+\n+Table Y is three bits long since the longest code starting with 111 is six  \n+bits long:\n+\n+000: F,2\n+001: F,2\n+010: G,2\n+011: G,2\n+100: H,2\n+101: H,2\n+110: I,3\n+111: J,3\n+\n+So what we have here are three tables with a total of 20 entries that had to  \n+be constructed.  That's compared to 64 entries for a single table.  Or  \n+compared to 16 entries for a Huffman tree (six two entry tables and one four  \n+entry table).  Assuming that the code ideally represents the probability of  \n+the symbols, it takes on the average 1.25 lookups per symbol.  That's compared\n+to one lookup for the single table, or 1.66 lookups per symbol for the  \n+Huffman tree.\n+\n+There, I think that gives you a picture of what's going on.  For inflate, the  \n+meaning of a particular symbol is often more than just a letter.  It can be a  \n+byte (a \"literal\"), or it can be either a length or a distance which  \n+indicates a base value and a number of bits to fetch after the code that is  \n+added to the base value.  Or it might be the special end-of-block code.  The  \n+data structures created in inftrees.c try to encode all that information  \n+compactly in the tables.\n+\n+\n+Jean-loup Gailly        Mark Adler\n+jloup@gzip.org          madler@alumni.caltech.edu\n+\n+\n+References:\n+\n+[LZ77] Ziv J., Lempel A., ``A Universal Algorithm for Sequential Data\n+Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,\n+pp. 337-343.\n+\n+``DEFLATE Compressed Data Format Specification'' available in\n+ftp://ds.internic.net/rfc/rfc1951.txt"}, {"sha": "6cfad1dc04a20b46acde028db563773db849e511", "filename": "zlib/amiga/Makefile.pup", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Famiga%2FMakefile.pup", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Famiga%2FMakefile.pup", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Famiga%2FMakefile.pup?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,66 @@\n+# Amiga powerUP (TM) Makefile\n+# makefile for libpng and SAS C V6.58/7.00 PPC compiler\n+# Copyright (C) 1998 by Andreas R. Kleinert\n+\n+CC       = scppc\n+CFLAGS   = NOSTKCHK NOSINT OPTIMIZE OPTGO OPTPEEP OPTINLOCAL OPTINL \\\n+           OPTLOOP OPTRDEP=8 OPTDEP=8 OPTCOMP=8\n+LIBNAME  = libzip.a\n+AR       = ppc-amigaos-ar\n+AR_FLAGS = cr\n+RANLIB   = ppc-amigaos-ranlib\n+LDFLAGS  = -r -o\n+LDLIBS   = LIB:scppc.a\n+LN       = ppc-amigaos-ld\n+RM       = delete quiet\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example minigzip\n+\n+test: all\n+        example\n+        echo hello world | minigzip | minigzip -d\n+\n+$(LIBNAME): $(OBJS)\n+            $(AR) $(AR_FLAGS) $@ $(OBJS)\n+            $(RANLIB) $@\n+\n+example: example.o $(LIBNAME)\n+        $(LN) $(LDFLAGS) example LIB:c_ppc.o example.o $(LIBNAME) $(LDLIBS) LIB:end.o\n+\n+minigzip: minigzip.o $(LIBNAME)\n+        $(LN) $(LDFLAGS) minigzip LIB:c_ppc.o minigzip.o $(LIBNAME) $(LDLIBS) LIB:end.o\n+\n+clean:\n+        $(RM) *.o example minigzip $(LIBNAME) foo.gz\n+\n+zip:\n+        zip -ul9 zlib README ChangeLog Makefile Make????.??? Makefile.?? \\\n+          descrip.mms *.[ch]\n+\n+tgz:\n+        cd ..; tar cfz zlib/zlib.tgz zlib/README zlib/ChangeLog zlib/Makefile \\\n+          zlib/Make????.??? zlib/Makefile.?? zlib/descrip.mms zlib/*.[ch]\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zutil.h zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zutil.h zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+infcodes.o: zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h inftrees.h infutil.h\n+minigzip.o: zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "5323e821708576b3e78d8f1414cface96880c2f5", "filename": "zlib/amiga/Makefile.sas", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Famiga%2FMakefile.sas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Famiga%2FMakefile.sas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Famiga%2FMakefile.sas?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,64 @@\n+# SMakefile for zlib\n+# Modified from the standard UNIX Makefile Copyright Jean-loup Gailly\n+# Osma Ahvenlampi <Osma.Ahvenlampi@hut.fi>\n+# Amiga, SAS/C 6.56 & Smake\n+\n+CC=sc\n+CFLAGS=OPT\n+#CFLAGS=OPT CPU=68030\n+#CFLAGS=DEBUG=LINE\n+LDFLAGS=LIB z.lib\n+\n+SCOPTIONS=OPTSCHED OPTINLINE OPTALIAS OPTTIME OPTINLOCAL STRMERGE \\\n+       NOICONS PARMS=BOTH NOSTACKCHECK UTILLIB NOVERSION ERRORREXX \n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: SCOPTIONS example minigzip\n+\n+test: all\n+\t`cd`/example\n+\techo hello world | minigzip | minigzip -d \n+\n+install: z.lib\n+\tcopy zlib.h zconf.h INCLUDE: clone\n+\tcopy z.lib LIB: clone\n+\n+z.lib: $(OBJS)\n+\toml z.lib r $(OBJS)\n+\n+example: example.o z.lib\n+\t$(CC) $(CFLAGS) LINK TO $@ example.o $(LDFLAGS)\n+\n+minigzip: minigzip.o z.lib\n+\t$(CC) $(CFLAGS) LINK TO $@ minigzip.o $(LDFLAGS)\n+\n+clean:\n+\t-delete force quiet *.o example minigzip z.lib foo.gz *.lnk SCOPTIONS\n+\n+SCOPTIONS: Smakefile\n+        copy to $@ <from <\n+$(SCOPTIONS)\n+<\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zutil.h zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zutil.h zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+infcodes.o: zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h inftrees.h infutil.h\n+minigzip.o: zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "1cee470913d75a3fa74c998c5638920fc382ec07", "filename": "zlib/compress.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcompress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcompress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcompress.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,68 @@\n+/* compress.c -- compress a memory buffer\n+ * Copyright (C) 1995-1998 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"zlib.h\"\n+\n+/* ===========================================================================\n+     Compresses the source buffer into the destination buffer. The level\n+   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n+   length of the source buffer. Upon entry, destLen is the total size of the\n+   destination buffer, which must be at least 0.1% larger than sourceLen plus\n+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n+\n+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n+   Z_STREAM_ERROR if the level parameter is invalid.\n+*/\n+int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)\n+    Bytef *dest;\n+    uLongf *destLen;\n+    const Bytef *source;\n+    uLong sourceLen;\n+    int level;\n+{\n+    z_stream stream;\n+    int err;\n+\n+    stream.next_in = (Bytef*)source;\n+    stream.avail_in = (uInt)sourceLen;\n+#ifdef MAXSEG_64K\n+    /* Check for source > 64K on 16-bit machine: */\n+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;\n+#endif\n+    stream.next_out = dest;\n+    stream.avail_out = (uInt)*destLen;\n+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;\n+\n+    stream.zalloc = (alloc_func)0;\n+    stream.zfree = (free_func)0;\n+    stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&stream, level);\n+    if (err != Z_OK) return err;\n+\n+    err = deflate(&stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        deflateEnd(&stream);\n+        return err == Z_OK ? Z_BUF_ERROR : err;\n+    }\n+    *destLen = stream.total_out;\n+\n+    err = deflateEnd(&stream);\n+    return err;\n+}\n+\n+/* ===========================================================================\n+ */\n+int ZEXPORT compress (dest, destLen, source, sourceLen)\n+    Bytef *dest;\n+    uLongf *destLen;\n+    const Bytef *source;\n+    uLong sourceLen;\n+{\n+    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n+}"}, {"sha": "e8942359bc15588d1c8dad91dd4573d324a2f971", "filename": "zlib/configure", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fconfigure?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,212 @@\n+#!/bin/sh\n+# configure script for zlib. This script is needed only if\n+# you wish to build a shared library and your system supports them,\n+# of if you need special compiler, flags or install directory.\n+# Otherwise, you can just use directly \"make test; make install\"\n+#\n+# To create a shared library, use \"configure --shared\"; by default a static\n+# library is created. If the primitive shared library support provided here\n+# does not work, use ftp://prep.ai.mit.edu/pub/gnu/libtool-*.tar.gz\n+#\n+# To impose specific compiler or flags or install directory, use for example:\n+#    prefix=$HOME CC=cc CFLAGS=\"-O4\" ./configure\n+# or for csh/tcsh users:\n+#    (setenv prefix $HOME; setenv CC cc; setenv CFLAGS \"-O4\"; ./configure)\n+# LDSHARED is the command to be used to create a shared library\n+\n+# Incorrect settings of CC or CFLAGS may prevent creating a shared library.\n+# If you have problems, try without defining CC and CFLAGS before reporting\n+# an error.\n+\n+LIBS=libz.a\n+SHAREDLIB=libz.so\n+VER=`sed -n -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`\n+AR=${AR-\"ar rc\"}\n+RANLIB=${RANLIB-\"ranlib\"}\n+prefix=${prefix-/usr/local}\n+exec_prefix=${exec_prefix-'${prefix}'}\n+libdir=${libdir-'${exec_prefix}/lib'}\n+includedir=${includedir-'${prefix}/include'}\n+shared_ext='.so'\n+shared=0\n+gcc=0\n+old_cc=\"$CC\"\n+old_cflags=\"$CFLAGS\"\n+\n+while test $# -ge 1\n+do\n+case \"$1\" in\n+    -h* | --h*)\n+      echo 'usage:'\n+      echo '  configure [--shared] [--prefix=PREFIX]  [--exec_prefix=EXPREFIX]'\n+      echo '     [--libdir=LIBDIR] [--includedir=INCLUDEDIR]'\n+        exit 0;;\n+    -p*=* | --p*=*) prefix=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;\n+    -e*=* | --e*=*) exec_prefix=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;\n+    -l*=* | --libdir=*) libdir=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;\n+    -i*=* | --includedir=*) includedir=`echo $1 | sed 's/[-a-z_]*=//'`;shift;;\n+    -p* | --p*) prefix=\"$2\"; shift; shift;;\n+    -e* | --e*) exec_prefix=\"$2\"; shift; shift;;\n+    -l* | --l*) libdir=\"$2\"; shift; shift;;\n+    -i* | --i*) includedir=\"$2\"; shift; shift;;\n+    -s* | --s*) shared=1; shift;;\n+    esac\n+done\n+\n+test=ztest$$\n+cat > $test.c <<EOF\n+extern int getchar();\n+int hello() {return getchar();}\n+EOF\n+\n+test -z \"$CC\" && echo Checking for gcc...\n+cc=${CC-gcc}\n+cflags=${CFLAGS-\"-O3\"}\n+# to force the asm version use: CFLAGS=\"-O3 -DASMV\" ./configure\n+case \"$cc\" in\n+  *gcc*) gcc=1;;\n+esac\n+\n+if test \"$gcc\" -eq 1 && ($cc -c $cflags $test.c) 2>/dev/null; then\n+  CC=\"$cc\"\n+  SFLAGS=${CFLAGS-\"-fPIC -O3\"}\n+  CFLAGS=\"$cflags\"\n+  case `(uname -s || echo unknown) 2>/dev/null` in\n+  Linux | linux) LDSHARED=${LDSHARED-\"gcc -shared -Wl,-soname,libz.so.1\"};;\n+  *)             LDSHARED=${LDSHARED-\"gcc -shared\"};;\n+  esac\n+else\n+  # find system name and corresponding cc options\n+  CC=${CC-cc}\n+  case `(uname -sr || echo unknown) 2>/dev/null` in\n+  HP-UX*)    SFLAGS=${CFLAGS-\"-O +z\"}\n+\t     CFLAGS=${CFLAGS-\"-O\"}\n+#\t     LDSHARED=${LDSHARED-\"ld -b +vnocompatwarnings\"}\n+\t     LDSHARED=${LDSHARED-\"ld -b\"}\n+\t     shared_ext='.sl'\n+\t     SHAREDLIB='libz.sl';;\n+  IRIX*)     SFLAGS=${CFLAGS-\"-ansi -O2 -rpath .\"}\n+\t     CFLAGS=${CFLAGS-\"-ansi -O2\"}\n+\t     LDSHARED=${LDSHARED-\"cc -shared\"};;\n+  OSF1\\ V4*) SFLAGS=${CFLAGS-\"-O -std1\"}\n+\t     CFLAGS=${CFLAGS-\"-O -std1\"}\n+\t     LDSHARED=${LDSHARED-\"cc -shared  -Wl,-soname,$SHAREDLIB -Wl,-msym -Wl,-rpath,$(libdir) -Wl,-set_version,${VER}:1.0\"};;\n+  OSF1*)     SFLAGS=${CFLAGS-\"-O -std1\"}\n+\t     CFLAGS=${CFLAGS-\"-O -std1\"}\n+\t     LDSHARED=${LDSHARED-\"cc -shared\"};;\n+  QNX*)      SFLAGS=${CFLAGS-\"-4 -O\"}\n+             CFLAGS=${CFLAGS-\"-4 -O\"}\n+\t     LDSHARED=${LDSHARED-\"cc\"}\n+             RANLIB=${RANLIB-\"true\"}\n+             AR=\"cc -A\";;\n+  SCO_SV\\ 3.2*) SFLAGS=${CFLAGS-\"-O3 -dy -KPIC \"}\n+\t     CFLAGS=${CFLAGS-\"-O3\"}\n+\t     LDSHARED=${LDSHARED-\"cc -dy -KPIC -G\"};;\n+  SunOS\\ 5*) SFLAGS=${CFLAGS-\"-fast -xcg89 -KPIC -R.\"}\n+             CFLAGS=${CFLAGS-\"-fast -xcg89\"}\n+\t     LDSHARED=${LDSHARED-\"cc -G\"};;\n+  SunOS\\ 4*) SFLAGS=${CFLAGS-\"-O2 -PIC\"}\n+\t     CFLAGS=${CFLAGS-\"-O2\"}\n+\t     LDSHARED=${LDSHARED-\"ld\"};;\n+  UNIX_System_V\\ 4.2.0) \n+\t     SFLAGS=${CFLAGS-\"-KPIC -O\"}\n+\t     CFLAGS=${CFLAGS-\"-O\"}\n+\t     LDSHARED=${LDSHARED-\"cc -G\"};;\n+  UNIX_SV\\ 4.2MP)\n+\t     SFLAGS=${CFLAGS-\"-Kconform_pic -O\"}\n+\t     CFLAGS=${CFLAGS-\"-O\"}\n+\t     LDSHARED=${LDSHARED-\"cc -G\"};;\n+  # send working options for other systems to support@gzip.org\n+  *)         SFLAGS=${CFLAGS-\"-O\"}\n+\t     CFLAGS=${CFLAGS-\"-O\"}\n+\t     LDSHARED=${LDSHARED-\"cc -shared\"};;\n+  esac\n+fi\n+\n+if test $shared -eq 1; then\n+  echo Checking for shared library support...\n+  # we must test in two steps (cc then ld), required at least on SunOS 4.x\n+  if test \"`($CC -c $SFLAGS $test.c) 2>&1`\" = \"\" &&\n+     test \"`($LDSHARED -o $test$shared_ext $test.o) 2>&1`\" = \"\"; then\n+    CFLAGS=\"$SFLAGS\"\n+    LIBS=\"$SHAREDLIB.$VER\"\n+    echo Building shared library $SHAREDLIB.$VER with $CC.\n+  elif test -z \"$old_cc\" -a -z \"$old_cflags\"; then\n+    echo No shared library suppport.\n+    shared=0;\n+  else\n+    echo 'No shared library suppport; try without defining CC and CFLAGS'\n+    shared=0;\n+  fi\n+fi\n+if test $shared -eq 0; then\n+  LDSHARED=\"$CC\"\n+  echo Building static library $LIBS version $VER with $CC.\n+fi\n+\n+cat > $test.c <<EOF\n+#include <unistd.h>\n+int main() { return 0; }\n+EOF\n+if test \"`($CC -c $CFLAGS $test.c) 2>&1`\" = \"\"; then\n+  CFLAGS=\"$CFLAGS -DHAVE_UNISTD_H\"\n+  echo \"Checking for unistd.h... Yes.\"\n+else\n+  echo \"Checking for unistd.h... No.\"\n+fi\n+\n+cat > $test.c <<EOF\n+#include <errno.h>\n+int main() { return 0; }\n+EOF\n+if test \"`($CC -c $CFLAGS $test.c) 2>&1`\" = \"\"; then\n+  echo \"Checking for errno.h...\t Yes.\"\n+else\n+  echo \"Checking for errno.h...\t No.\"\n+  CFLAGS=\"$CFLAGS -DNO_ERRNO_H\"\n+fi\n+\n+cat > $test.c <<EOF\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <sys/stat.h>\n+caddr_t hello() {\n+  return mmap((caddr_t)0, (off_t)0, PROT_READ, MAP_SHARED, 0, (off_t)0); \n+}\n+EOF\n+if test \"`($CC -c $CFLAGS $test.c) 2>&1`\" = \"\"; then\n+  CFLAGS=\"$CFLAGS -DUSE_MMAP\"\n+  echo Checking for mmap support... Yes.\n+else\n+  echo Checking for mmap support... No.\n+fi\n+\n+CPP=${CPP-\"$CC -E\"}\n+case $CFLAGS in\n+  *ASMV*)\n+    if test \"`nm $test.o | grep _hello`\" = \"\"; then\n+      CPP=\"$CPP -DNO_UNDERLINE\"\n+      echo Checking for underline in external names... No.\n+    else\n+      echo Checking for underline in external names... Yes.\n+    fi;;\n+esac\n+\n+rm -f $test.[co] $test$shared_ext\n+\n+# udpate Makefile\n+sed < Makefile.in \"\n+/^CC *=/s%=.*%=$CC%\n+/^CFLAGS *=/s%=.*%=$CFLAGS%\n+/^CPP *=/s%=.*%=$CPP%\n+/^LDSHARED *=/s%=.*%=$LDSHARED%\n+/^LIBS *=/s%=.*%=$LIBS%\n+/^SHAREDLIB *=/s%=.*%=$SHAREDLIB%\n+/^AR *=/s%=.*%=$AR%\n+/^RANLIB *=/s%=.*%=$RANLIB%\n+/^VER *=/s%=.*%=$VER%\n+/^prefix *=/s%=.*%=$prefix%\n+/^exec_prefix *=/s%=.*%=$exec_prefix%\n+/^libdir *=/s%=.*%=$libdir%\n+/^includedir *=/s%=.*%=$includedir%\n+\" > Makefile"}, {"sha": "7ad191cf5986b5a9c87d444c1905aff6f57d22cc", "filename": "zlib/contrib/README.contrib", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2FREADME.contrib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2FREADME.contrib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2FREADME.contrib?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,34 @@\n+All files under this contrib directory are UNSUPPORTED. There were\n+provided by users of zlib and were not tested by the authors of zlib.\n+Use at your own risk. Please contact the authors of the contributions\n+for help about these, not the zlib authors. Thanks.\n+\n+\n+asm386/     by Gilles Vollant <info@winimage.com>\n+\t386 asm code replacing longest_match(), for Visual C++ 4.2 and ML 6.11c\n+\n+asm586/ and asm686/    by Brian Raiter <breadbox@muppetlabs.com> \n+        asm code for Pentium and Pentium Pro\n+        See http://www.muppetlabs.com/~breadbox/software/assembly.html\n+\n+delphi/      by Bob Dellaca <bobdl@xtra.co.nz>\n+\tSupport for Delphi\n+\n+delphi2/     by Davide Moretti <dave@rimini.com>\n+        Another support for C++Builder and Delphi\n+\n+minizip/    by Gilles Vollant <info@winimage.com>\n+\tMini zip and unzip based on zlib\n+        See http://www.winimage.com/zLibDll/unzip.html\n+\n+iostream/   by Kevin Ruland <kevin@rodin.wustl.edu>\n+        A C++ I/O streams interface to the zlib gz* functions\n+\n+iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n+\tAnother C++ I/O streams interface\n+\n+untgz/      by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+\tA very simple tar.gz file extractor using zlib\n+\n+visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n+        How to use compress(), uncompress() and the gz* functions from VB."}, {"sha": "28d527f47f885e4cd957e1c2559f0ef74697b5cd", "filename": "zlib/contrib/asm386/gvmat32.asm", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,559 @@\n+;\n+; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86\n+; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n+; File written by Gilles Vollant, by modifiying the longest_match\n+;  from Jean-loup Gailly in deflate.c\n+; It need wmask == 0x7fff\n+;     (assembly code is faster with a fixed wmask)\n+;\n+; For Visual C++ 4.2 and ML 6.11c (version in directory \\MASM611C of Win95 DDK)\n+;   I compile with : \"ml /coff /Zi /c gvmat32.asm\"\n+;\n+\n+;uInt longest_match_7fff(s, cur_match)\n+;    deflate_state *s;\n+;    IPos cur_match;                             /* current match */\n+\n+        NbStack         equ     76\n+        cur_match       equ     dword ptr[esp+NbStack-0]\n+        str_s           equ     dword ptr[esp+NbStack-4]\n+; 5 dword on top (ret,ebp,esi,edi,ebx)\n+        adrret          equ     dword ptr[esp+NbStack-8]\n+        pushebp         equ     dword ptr[esp+NbStack-12]\n+        pushedi         equ     dword ptr[esp+NbStack-16]\n+        pushesi         equ     dword ptr[esp+NbStack-20]\n+        pushebx         equ     dword ptr[esp+NbStack-24]\n+\n+        chain_length    equ     dword ptr [esp+NbStack-28]\n+        limit           equ     dword ptr [esp+NbStack-32]\n+        best_len        equ     dword ptr [esp+NbStack-36]\n+        window          equ     dword ptr [esp+NbStack-40]\n+        prev            equ     dword ptr [esp+NbStack-44]\n+        scan_start      equ      word ptr [esp+NbStack-48]\n+        wmask           equ     dword ptr [esp+NbStack-52]\n+        match_start_ptr equ     dword ptr [esp+NbStack-56]\n+        nice_match      equ     dword ptr [esp+NbStack-60]\n+        scan            equ     dword ptr [esp+NbStack-64]\n+\n+        windowlen       equ     dword ptr [esp+NbStack-68]\n+        match_start     equ     dword ptr [esp+NbStack-72]\n+        strend          equ     dword ptr [esp+NbStack-76]\n+        NbStackAdd      equ     (NbStack-24)\n+\n+    .386p\n+\n+    name    gvmatch\n+    .MODEL  FLAT\n+\n+\n+\n+;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\n+;  in the deflate_state structure since the asm code was first written\n+;  (if you compile with zlib 1.0.4 or older, remove the +4).\n+;  Note : these value are good with a 8 bytes boundary pack structure\n+    dep_chain_length    equ     70h+4\n+    dep_window          equ     2ch+4\n+    dep_strstart        equ     60h+4\n+    dep_prev_length     equ     6ch+4\n+    dep_nice_match      equ     84h+4\n+    dep_w_size          equ     20h+4\n+    dep_prev            equ     34h+4\n+    dep_w_mask          equ     28h+4\n+    dep_good_match      equ     80h+4\n+    dep_match_start     equ     64h+4\n+    dep_lookahead       equ     68h+4\n+\n+\n+_TEXT                   segment\n+\n+IFDEF NOUNDERLINE\n+                        public  longest_match_7fff\n+;                        public  match_init\n+ELSE\n+                        public  _longest_match_7fff\n+;                        public  _match_init\n+ENDIF\n+\n+    MAX_MATCH           equ     258\n+    MIN_MATCH           equ     3\n+    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\n+\n+\n+\n+IFDEF NOUNDERLINE\n+;match_init      proc near\n+;                ret\n+;match_init      endp\n+ELSE\n+;_match_init     proc near\n+;                ret\n+;_match_init     endp\n+ENDIF\n+\n+\n+IFDEF NOUNDERLINE\n+longest_match_7fff   proc near\n+ELSE\n+_longest_match_7fff  proc near\n+ENDIF\n+\n+        mov     edx,[esp+4]\n+\n+\n+\n+        push    ebp\n+        push    edi\n+        push    esi\n+        push    ebx\n+\n+        sub     esp,NbStackAdd\n+\n+; initialize or check the variables used in match.asm.\n+        mov     ebp,edx\n+\n+; chain_length = s->max_chain_length\n+; if (prev_length>=good_match) chain_length >>= 2\n+        mov     edx,[ebp+dep_chain_length]\n+        mov     ebx,[ebp+dep_prev_length]\n+        cmp     [ebp+dep_good_match],ebx\n+        ja      noshr\n+        shr     edx,2\n+noshr:\n+; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop\n+        inc     edx\n+        mov     edi,[ebp+dep_nice_match]\n+        mov     chain_length,edx\n+        mov     eax,[ebp+dep_lookahead]\n+        cmp     eax,edi\n+; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+        jae     nolookaheadnicematch\n+        mov     edi,eax\n+nolookaheadnicematch:\n+; best_len = s->prev_length\n+        mov     best_len,ebx\n+\n+; window = s->window\n+        mov     esi,[ebp+dep_window]\n+        mov     ecx,[ebp+dep_strstart]\n+        mov     window,esi\n+\n+        mov     nice_match,edi\n+; scan = window + strstart\n+        add     esi,ecx\n+        mov     scan,esi\n+; dx = *window\n+        mov     dx,word ptr [esi]\n+; bx = *(window+best_len-1)\n+        mov     bx,word ptr [esi+ebx-1]\n+        add     esi,MAX_MATCH-1\n+; scan_start = *scan\n+        mov     scan_start,dx\n+; strend = scan + MAX_MATCH-1\n+        mov     strend,esi\n+; bx = scan_end = *(window+best_len-1)\n+\n+;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+;        s->strstart - (IPos)MAX_DIST(s) : NIL;\n+\n+        mov     esi,[ebp+dep_w_size]\n+        sub     esi,MIN_LOOKAHEAD\n+; here esi = MAX_DIST(s)\n+        sub     ecx,esi\n+        ja      nodist\n+        xor     ecx,ecx\n+nodist:\n+        mov     limit,ecx\n+\n+; prev = s->prev\n+        mov     edx,[ebp+dep_prev]\n+        mov     prev,edx\n+\n+;\n+        mov     edx,dword ptr [ebp+dep_match_start]\n+        mov     bp,scan_start\n+        mov     eax,cur_match\n+        mov     match_start,edx\n+\n+        mov     edx,window\n+        mov     edi,edx\n+        add     edi,best_len\n+        mov     esi,prev\n+        dec     edi\n+; windowlen = window + best_len -1\n+        mov     windowlen,edi\n+\n+        jmp     beginloop2\n+        align   4\n+\n+; here, in the loop\n+;       eax = ax = cur_match\n+;       ecx = limit\n+;        bx = scan_end\n+;        bp = scan_start\n+;       edi = windowlen (window + best_len -1)\n+;       esi = prev\n+\n+\n+;// here; chain_length <=16\n+normalbeg0add16:\n+        add     chain_length,16\n+        jz      exitloop\n+normalbeg0:\n+        cmp     word ptr[edi+eax],bx\n+        je      normalbeg2noroll\n+rcontlabnoroll:\n+; cur_match = prev[cur_match & wmask]\n+        and     eax,7fffh\n+        mov     ax,word ptr[esi+eax*2]\n+; if cur_match > limit, go to exitloop\n+        cmp     ecx,eax\n+        jnb     exitloop\n+; if --chain_length != 0, go to exitloop\n+        dec     chain_length\n+        jnz     normalbeg0\n+        jmp     exitloop\n+\n+normalbeg2noroll:\n+; if (scan_start==*(cur_match+window)) goto normalbeg2\n+        cmp     bp,word ptr[edx+eax]\n+        jne     rcontlabnoroll\n+        jmp     normalbeg2\n+\n+contloop3:\n+        mov     edi,windowlen\n+\n+; cur_match = prev[cur_match & wmask]\n+        and     eax,7fffh\n+        mov     ax,word ptr[esi+eax*2]\n+; if cur_match > limit, go to exitloop\n+        cmp     ecx,eax\n+jnbexitloopshort1:\n+        jnb     exitloop\n+; if --chain_length != 0, go to exitloop\n+\n+\n+; begin the main loop\n+beginloop2:\n+        sub     chain_length,16+1\n+; if chain_length <=16, don't use the unrolled loop\n+        jna     normalbeg0add16\n+\n+do16:\n+        cmp     word ptr[edi+eax],bx\n+        je      normalbeg2dc0\n+\n+maccn   MACRO   lab\n+        and     eax,7fffh\n+        mov     ax,word ptr[esi+eax*2]\n+        cmp     ecx,eax\n+        jnb     exitloop\n+        cmp     word ptr[edi+eax],bx\n+        je      lab\n+        ENDM\n+\n+rcontloop0:\n+        maccn   normalbeg2dc1\n+\n+rcontloop1:\n+        maccn   normalbeg2dc2\n+\n+rcontloop2:\n+        maccn   normalbeg2dc3\n+\n+rcontloop3:\n+        maccn   normalbeg2dc4\n+\n+rcontloop4:\n+        maccn   normalbeg2dc5\n+\n+rcontloop5:\n+        maccn   normalbeg2dc6\n+\n+rcontloop6:\n+        maccn   normalbeg2dc7\n+\n+rcontloop7:\n+        maccn   normalbeg2dc8\n+\n+rcontloop8:\n+        maccn   normalbeg2dc9\n+\n+rcontloop9:\n+        maccn   normalbeg2dc10\n+\n+rcontloop10:\n+        maccn   short normalbeg2dc11\n+\n+rcontloop11:\n+        maccn   short normalbeg2dc12\n+\n+rcontloop12:\n+        maccn   short normalbeg2dc13\n+\n+rcontloop13:\n+        maccn   short normalbeg2dc14\n+\n+rcontloop14:\n+        maccn   short normalbeg2dc15\n+\n+rcontloop15:\n+        and     eax,7fffh\n+        mov     ax,word ptr[esi+eax*2]\n+        cmp     ecx,eax\n+        jnb     exitloop\n+\n+        sub     chain_length,16\n+        ja      do16\n+        jmp     normalbeg0add16\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+normbeg MACRO   rcontlab,valsub\n+; if we are here, we know that *(match+best_len-1) == scan_end\n+        cmp     bp,word ptr[edx+eax]\n+; if (match != scan_start) goto rcontlab\n+        jne     rcontlab\n+; calculate the good chain_length, and we'll compare scan and match string\n+        add     chain_length,16-valsub\n+        jmp     iseq\n+        ENDM\n+\n+\n+normalbeg2dc11:\n+        normbeg rcontloop11,11\n+\n+normalbeg2dc12:\n+        normbeg short rcontloop12,12\n+\n+normalbeg2dc13:\n+        normbeg short rcontloop13,13\n+\n+normalbeg2dc14:\n+        normbeg short rcontloop14,14\n+\n+normalbeg2dc15:\n+        normbeg short rcontloop15,15\n+\n+normalbeg2dc10:\n+        normbeg rcontloop10,10\n+\n+normalbeg2dc9:\n+        normbeg rcontloop9,9\n+\n+normalbeg2dc8:\n+        normbeg rcontloop8,8\n+\n+normalbeg2dc7:\n+        normbeg rcontloop7,7\n+\n+normalbeg2dc6:\n+        normbeg rcontloop6,6\n+\n+normalbeg2dc5:\n+        normbeg rcontloop5,5\n+\n+normalbeg2dc4:\n+        normbeg rcontloop4,4\n+\n+normalbeg2dc3:\n+        normbeg rcontloop3,3\n+\n+normalbeg2dc2:\n+        normbeg rcontloop2,2\n+\n+normalbeg2dc1:\n+        normbeg rcontloop1,1\n+\n+normalbeg2dc0:\n+        normbeg rcontloop0,0\n+\n+\n+; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end\n+\n+normalbeg2:\n+        mov     edi,window\n+\n+        cmp     bp,word ptr[edi+eax]\n+        jne     contloop3                   ; if *(ushf*)match != scan_start, continue\n+\n+iseq:\n+; if we are here, we know that *(match+best_len-1) == scan_end\n+; and (match == scan_start)\n+\n+        mov     edi,edx\n+        mov     esi,scan                    ; esi = scan\n+        add     edi,eax                     ; edi = window + cur_match = match\n+\n+        mov     edx,[esi+3]                 ; compare manually dword at match+3\n+        xor     edx,[edi+3]                 ; and scan +3\n+\n+        jz      begincompare                ; if equal, go to long compare\n+\n+; we will determine the unmatch byte and calculate len (in esi)\n+        or      dl,dl\n+        je      eq1rr\n+        mov     esi,3\n+        jmp     trfinval\n+eq1rr:\n+        or      dx,dx\n+        je      eq1\n+\n+        mov     esi,4\n+        jmp     trfinval\n+eq1:\n+        and     edx,0ffffffh\n+        jz      eq11\n+        mov     esi,5\n+        jmp     trfinval\n+eq11:\n+        mov     esi,6\n+        jmp     trfinval\n+\n+begincompare:\n+        ; here we now scan and match begin same\n+        add     edi,6\n+        add     esi,6\n+        mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes\n+        repe    cmpsd                       ; loop until mismatch\n+\n+        je      trfin                       ; go to trfin if not unmatch\n+; we determine the unmatch byte\n+        sub     esi,4\n+        mov     edx,[edi-4]\n+        xor     edx,[esi]\n+\n+        or      dl,dl\n+        jnz     trfin\n+        inc     esi\n+\n+        or      dx,dx\n+        jnz     trfin\n+        inc     esi\n+\n+        and     edx,0ffffffh\n+        jnz     trfin\n+        inc     esi\n+\n+trfin:\n+        sub     esi,scan          ; esi = len\n+trfinval:\n+; here we have finised compare, and esi contain len of equal string\n+        cmp     esi,best_len        ; if len > best_len, go newbestlen\n+        ja      short newbestlen\n+; now we restore edx, ecx and esi, for the big loop\n+        mov     esi,prev\n+        mov     ecx,limit\n+        mov     edx,window\n+        jmp     contloop3\n+\n+newbestlen:\n+        mov     best_len,esi        ; len become best_len\n+\n+        mov     match_start,eax     ; save new position as match_start\n+        cmp     esi,nice_match      ; if best_len >= nice_match, exit\n+        jae     exitloop\n+        mov     ecx,scan\n+        mov     edx,window          ; restore edx=window\n+        add     ecx,esi\n+        add     esi,edx\n+\n+        dec     esi\n+        mov     windowlen,esi       ; windowlen = window + best_len-1\n+        mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end\n+\n+; now we restore ecx and esi, for the big loop :\n+        mov     esi,prev\n+        mov     ecx,limit\n+        jmp     contloop3\n+\n+exitloop:\n+; exit : s->match_start=match_start\n+        mov     ebx,match_start\n+        mov     ebp,str_s\n+        mov     ecx,best_len\n+        mov     dword ptr [ebp+dep_match_start],ebx        \n+        mov     eax,dword ptr [ebp+dep_lookahead]\n+        cmp     ecx,eax\n+        ja      minexlo\n+        mov     eax,ecx\n+minexlo:\n+; return min(best_len,s->lookahead)\n+        \n+; restore stack and register ebx,esi,edi,ebp\n+        add     esp,NbStackAdd\n+\n+        pop     ebx\n+        pop     esi\n+        pop     edi\n+        pop     ebp\n+        ret\n+InfoAuthor:\n+; please don't remove this string !\n+; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!\n+        db     0dh,0ah,\"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant\",0dh,0ah\n+\n+\n+\n+IFDEF NOUNDERLINE\n+longest_match_7fff   endp\n+ELSE\n+_longest_match_7fff  endp\n+ENDIF\n+\n+\n+IFDEF NOUNDERLINE\n+cpudetect32     proc near\n+ELSE\n+_cpudetect32    proc near\n+ENDIF\n+\n+\n+\tpushfd                  ; push original EFLAGS\n+\tpop     eax             ; get original EFLAGS\n+\tmov     ecx, eax        ; save original EFLAGS\n+\txor     eax, 40000h     ; flip AC bit in EFLAGS\n+\tpush    eax             ; save new EFLAGS value on stack\n+\tpopfd                   ; replace current EFLAGS value\n+\tpushfd                  ; get new EFLAGS\n+\tpop     eax             ; store new EFLAGS in EAX\n+\txor     eax, ecx        ; can\ufffdt toggle AC bit, processor=80386\n+\tjz      end_cpu_is_386  ; jump if 80386 processor\n+\tpush    ecx\n+\tpopfd                   ; restore AC bit in EFLAGS first\n+\n+\tpushfd\n+\tpushfd\n+\tpop     ecx\n+\t\t\t\n+\tmov     eax, ecx        ; get original EFLAGS\n+\txor     eax, 200000h    ; flip ID bit in EFLAGS\n+\tpush    eax             ; save new EFLAGS value on stack\n+\tpopfd                   ; replace current EFLAGS value\n+\tpushfd                  ; get new EFLAGS\n+\tpop\t\teax\t            ; store new EFLAGS in EAX\n+\tpopfd                   ; restore original EFLAGS\n+\txor\t\teax, ecx        ; can\ufffdt toggle ID bit,\n+\tje\t\tis_old_486\t\t; processor=old\n+\n+\tmov     eax,1\n+\tdb      0fh,0a2h        ;CPUID   \n+\n+exitcpudetect:\n+\tret\n+\n+end_cpu_is_386:\n+\tmov     eax,0300h\n+\tjmp     exitcpudetect\n+\n+is_old_486:\n+\tmov     eax,0400h\n+\tjmp     exitcpudetect\n+\n+IFDEF NOUNDERLINE\n+cpudetect32     endp\n+ELSE\n+_cpudetect32    endp\n+ENDIF\n+\n+_TEXT   ends\n+end"}, {"sha": "d853bb7ce8ab0b2b4a5aa37fc6ee567e6650bc78", "filename": "zlib/contrib/asm386/gvmat32c.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,200 @@\n+/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86\n+ * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n+ * File written by Gilles Vollant, by modifiying the longest_match\n+ *  from Jean-loup Gailly in deflate.c\n+ *  it prepare all parameters and call the assembly longest_match_gvasm\n+ *  longest_match execute standard C code is wmask != 0x7fff\n+ *     (assembly code is faster with a fixed wmask)\n+ *\n+ */\n+\n+#include \"deflate.h\"\n+\n+#undef FAR\n+#include <windows.h>\n+\n+#ifdef ASMV\n+#define NIL 0\n+\n+#define UNALIGNED_OK\n+\n+\n+/* if your C compiler don't add underline before function name,\n+\t\tdefine ADD_UNDERLINE_ASMFUNC */\n+#ifdef ADD_UNDERLINE_ASMFUNC\n+#define longest_match_7fff _longest_match_7fff\n+#endif\n+\n+\n+\n+void match_init()\n+{\n+}\n+\n+unsigned long cpudetect32();\n+\n+uInt longest_match_c(\n+    deflate_state *s,\n+    IPos cur_match);                             /* current match */\n+\n+\n+uInt longest_match_7fff(\n+    deflate_state *s,\n+    IPos cur_match);                             /* current match */\n+\n+uInt longest_match(\n+    deflate_state *s,\n+    IPos cur_match)                             /* current match */\n+{\n+\tstatic uInt iIsPPro=2;\n+\n+    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\n+        return longest_match_7fff(s,cur_match);\n+\n+\tif (iIsPPro==2)\n+\t\tiIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\n+\n+\treturn longest_match_c(s,cur_match);\n+}\n+\n+\n+\n+uInt longest_match_c(s, cur_match)\n+    deflate_state *s;\n+    IPos cur_match;                             /* current match */\n+{\n+    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n+    register Bytef *scan = s->window + s->strstart; /* current string */\n+    register Bytef *match;                       /* matched string */\n+    register int len;                           /* length of current match */\n+    int best_len = s->prev_length;              /* best match length so far */\n+    int nice_match = s->nice_match;             /* stop if match long enough */\n+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+        s->strstart - (IPos)MAX_DIST(s) : NIL;\n+    /* Stop when cur_match becomes <= limit. To simplify the code,\n+     * we prevent matches with the string of window index 0.\n+     */\n+    Posf *prev = s->prev;\n+    uInt wmask = s->w_mask;\n+\n+#ifdef UNALIGNED_OK\n+    /* Compare two bytes at a time. Note: this is not always beneficial.\n+     * Try with and without -DUNALIGNED_OK to check.\n+     */\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n+    register ush scan_start = *(ushf*)scan;\n+    register ush scan_end   = *(ushf*)(scan+best_len-1);\n+#else\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n+    register Byte scan_end1  = scan[best_len-1];\n+    register Byte scan_end   = scan[best_len];\n+#endif\n+\n+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n+     * It is easy to get rid of this optimization if necessary.\n+     */\n+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n+\n+    /* Do not waste too much time if we already have a good match: */\n+    if (s->prev_length >= s->good_match) {\n+        chain_length >>= 2;\n+    }\n+    /* Do not look for matches beyond the end of the input. This is necessary\n+     * to make deflate deterministic.\n+     */\n+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\n+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n+\n+    do {\n+        Assert(cur_match < s->strstart, \"no future\");\n+        match = s->window + cur_match;\n+\n+        /* Skip to next match if the match length cannot increase\n+         * or if the match length is less than 2:\n+         */\n+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n+        /* This code assumes sizeof(unsigned short) == 2. Do not use\n+         * UNALIGNED_OK if your compiler uses a different size.\n+         */\n+        if (*(ushf*)(match+best_len-1) != scan_end ||\n+            *(ushf*)match != scan_start) continue;\n+\n+        /* It is not necessary to compare scan[2] and match[2] since they are\n+         * always equal when the other bytes match, given that the hash keys\n+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n+         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n+         * lookahead only every 4th comparison; the 128th check will be made\n+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n+         * necessary to put more guard bytes at the end of the window, or\n+         * to check more often for insufficient lookahead.\n+         */\n+        Assert(scan[2] == match[2], \"scan[2]?\");\n+        scan++, match++;\n+        do {\n+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 scan < strend);\n+        /* The funny \"do {}\" generates better code on most compilers */\n+\n+        /* Here, scan <= window+strstart+257 */\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+        if (*scan == *match) scan++;\n+\n+        len = (MAX_MATCH - 1) - (int)(strend-scan);\n+        scan = strend - (MAX_MATCH-1);\n+\n+#else /* UNALIGNED_OK */\n+\n+        if (match[best_len]   != scan_end  ||\n+            match[best_len-1] != scan_end1 ||\n+            *match            != *scan     ||\n+            *++match          != scan[1])      continue;\n+\n+        /* The check at best_len-1 can be removed because it will be made\n+         * again later. (This heuristic is not always a win.)\n+         * It is not necessary to compare scan[2] and match[2] since they\n+         * are always equal when the other bytes match, given that\n+         * the hash keys are equal and that HASH_BITS >= 8.\n+         */\n+        scan += 2, match++;\n+        Assert(*scan == *match, \"match[2]?\");\n+\n+        /* We check for insufficient lookahead only every 8th comparison;\n+         * the 256th check will be made at strstart+258.\n+         */\n+        do {\n+        } while (*++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 scan < strend);\n+\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+\n+        len = MAX_MATCH - (int)(strend - scan);\n+        scan = strend - MAX_MATCH;\n+\n+#endif /* UNALIGNED_OK */\n+\n+        if (len > best_len) {\n+            s->match_start = cur_match;\n+            best_len = len;\n+            if (len >= nice_match) break;\n+#ifdef UNALIGNED_OK\n+            scan_end = *(ushf*)(scan+best_len-1);\n+#else\n+            scan_end1  = scan[best_len-1];\n+            scan_end   = scan[best_len];\n+#endif\n+        }\n+    } while ((cur_match = prev[cur_match & wmask]) > limit\n+             && --chain_length != 0);\n+\n+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n+    return s->lookahead;\n+}\n+\n+#endif /* ASMV */"}, {"sha": "6c5ffd7a024f70e7166474beabfc6710cbe38199", "filename": "zlib/contrib/asm386/mkgvmt32.bat", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1 @@\n+c:\\masm611\\bin\\ml /coff /Zi /c /Flgvmat32.lst gvmat32.asm"}, {"sha": "7e9d60d55d90d410e2d4b519f8bcfeb36027081c", "filename": "zlib/contrib/asm386/zlibvc.def", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,74 @@\n+LIBRARY\t\t\"zlib\"\n+\n+DESCRIPTION\t'\"\"\"zlib data compression library\"\"\"'\n+\n+\n+VERSION\t\t1.11\n+\n+\n+HEAPSIZE\t1048576,8192\n+\n+EXPORTS\n+    adler32                        @1\n+    compress                       @2\n+    crc32                          @3\n+    deflate                        @4\n+    deflateCopy                    @5\n+    deflateEnd                     @6\n+    deflateInit2_                  @7\n+    deflateInit_                   @8\n+    deflateParams                  @9\n+    deflateReset                   @10\n+    deflateSetDictionary           @11\n+    gzclose                        @12\n+    gzdopen                        @13\n+    gzerror                        @14\n+    gzflush                        @15\n+    gzopen                         @16\n+    gzread                         @17\n+    gzwrite                        @18\n+    inflate                        @19\n+    inflateEnd                     @20\n+    inflateInit2_                  @21\n+    inflateInit_                   @22\n+    inflateReset                   @23\n+    inflateSetDictionary           @24\n+    inflateSync                    @25\n+    uncompress                     @26\n+    zlibVersion                    @27\n+    gzprintf                       @28\n+    gzputc                         @29\n+    gzgetc                         @30\n+    gzseek                         @31\n+    gzrewind                       @32\n+    gztell                         @33\n+    gzeof                          @34\n+    gzsetparams                    @35\n+    zError                         @36\n+    inflateSyncPoint               @37\n+    get_crc_table                  @38\n+    compress2                      @39\n+    gzputs                         @40\n+    gzgets                         @41\n+\n+\tunzOpen                       @61\n+\tunzClose                      @62\n+\tunzGetGlobalInfo              @63\n+\tunzGetCurrentFileInfo         @64\n+\tunzGoToFirstFile              @65\n+\tunzGoToNextFile               @66\n+\tunzOpenCurrentFile            @67\n+\tunzReadCurrentFile            @68\n+\tunztell                       @70\n+\tunzeof                        @71\n+\tunzCloseCurrentFile           @72\n+\tunzGetGlobalComment           @73\n+\tunzStringFileNameCompare      @74\n+\tunzLocateFile                 @75\n+\tunzGetLocalExtrafield         @76\n+\n+\tzipOpen                       @80\n+\tzipOpenNewFileInZip           @81\n+\tzipWriteInFileInZip           @82\n+\tzipCloseFileInZip             @83\n+\tzipClose                      @84"}, {"sha": "a70d4d4a6b0ec6ad54f2966c42b445e9b8ded02b", "filename": "zlib/contrib/asm386/zlibvc.dsp", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,651 @@\n+# Microsoft Developer Studio Project File - Name=\"zlibvc\" - Package Owner=<4>\n+# Microsoft Developer Studio Generated Build File, Format Version 5.00\n+# ** DO NOT EDIT **\n+\n+# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n+# TARGTYPE \"Win32 (ALPHA) Dynamic-Link Library\" 0x0602\n+\n+CFG=zlibvc - Win32 Release\n+!MESSAGE This is not a valid makefile. To build this project using NMAKE,\n+!MESSAGE use the Export Makefile command and run\n+!MESSAGE \n+!MESSAGE NMAKE /f \"zlibvc.mak\".\n+!MESSAGE \n+!MESSAGE You can specify a configuration when running NMAKE\n+!MESSAGE by defining the macro CFG on the command line. For example:\n+!MESSAGE \n+!MESSAGE NMAKE /f \"zlibvc.mak\" CFG=\"zlibvc - Win32 Release\"\n+!MESSAGE \n+!MESSAGE Possible choices for configuration are:\n+!MESSAGE \n+!MESSAGE \"zlibvc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseAxp\" (based on\\\n+ \"Win32 (ALPHA) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseWithoutAsm\" (based on\\\n+ \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseWithoutCrtdll\" (based on\\\n+ \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \n+\n+# Begin Project\n+# PROP Scc_ProjName \"\"\n+# PROP Scc_LocalPath \"\"\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \".\\Release\"\n+# PROP BASE Intermediate_Dir \".\\Release\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \".\\Release\"\n+# PROP Intermediate_Dir \".\\Release\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \".\\Debug\"\n+# PROP BASE Intermediate_Dir \".\\Debug\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \".\\Debug\"\n+# PROP Intermediate_Dir \".\\Debug\"\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"_DEBUG\"\n+# ADD RSC /l 0x40c /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:\".\\Debug\\zlib.dll\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc__\"\n+# PROP BASE Intermediate_Dir \"zlibvc__\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc__\"\n+# PROP Intermediate_Dir \"zlibvc__\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\"zlibvc__\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc_0\"\n+# PROP BASE Intermediate_Dir \"zlibvc_0\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc_0\"\n+# PROP Intermediate_Dir \"zlibvc_0\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_0\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc_1\"\n+# PROP BASE Intermediate_Dir \"zlibvc_1\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc_1\"\n+# PROP Intermediate_Dir \"zlibvc_1\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_1\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ENDIF \n+\n+# Begin Target\n+\n+# Name \"zlibvc - Win32 Release\"\n+# Name \"zlibvc - Win32 Debug\"\n+# Name \"zlibvc - Win32 ReleaseAxp\"\n+# Name \"zlibvc - Win32 ReleaseWithoutAsm\"\n+# Name \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+# Begin Group \"Source Files\"\n+\n+# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\"\n+# Begin Source File\n+\n+SOURCE=.\\adler32.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_ADLER=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\compress.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_COMPR=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\crc32.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_CRC32=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\deflate.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_DEFLA=\\\n+\t\".\\deflate.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\gvmat32c.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\gzio.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_GZIO_=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infblock.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFBL=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infcodes.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFCO=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inffast.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inffast.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFFA=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inffast.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inflate.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFLA=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inftrees.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFTR=\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infutil.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFUT=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\trees.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_TREES=\\\n+\t\".\\deflate.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\uncompr.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_UNCOM=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\unzip.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zip.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlib.rc\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlibvc.def\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zutil.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_ZUTIL=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# End Group\n+# Begin Group \"Header Files\"\n+\n+# PROP Default_Filter \"h;hpp;hxx;hm;inl;fi;fd\"\n+# Begin Source File\n+\n+SOURCE=.\\deflate.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infblock.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infcodes.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inffast.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inftrees.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infutil.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zconf.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlib.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zutil.h\n+# End Source File\n+# End Group\n+# Begin Group \"Resource Files\"\n+\n+# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\"\n+# End Group\n+# End Target\n+# End Project"}, {"sha": "493cd870365a5cfb7e0725656d66c3b1d0b3dd21", "filename": "zlib/contrib/asm386/zlibvc.dsw", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,41 @@\n+Microsoft Developer Studio Workspace File, Format Version 5.00\n+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\n+\n+###############################################################################\n+\n+Project: \"zlibstat\"=.\\zlibstat.dsp - Package Owner=<4>\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<4>\n+{{{\n+}}}\n+\n+###############################################################################\n+\n+Project: \"zlibvc\"=.\\zlibvc.dsp - Package Owner=<4>\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<4>\n+{{{\n+}}}\n+\n+###############################################################################\n+\n+Global:\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<3>\n+{{{\n+}}}\n+\n+###############################################################################\n+"}, {"sha": "6bb78f32069be8952917f66c95d63b154ad9c830", "filename": "zlib/contrib/asm586/README.586", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm586%2FREADME.586", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm586%2FREADME.586", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm586%2FREADME.586?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,43 @@\n+This is a patched version of zlib modified to use\n+Pentium-optimized assembly code in the deflation algorithm. The files\n+changed/added by this patch are:\n+\n+README.586\n+match.S\n+\n+The effectiveness of these modifications is a bit marginal, as the the\n+program's bottleneck seems to be mostly L1-cache contention, for which\n+there is no real way to work around without rewriting the basic\n+algorithm. The speedup on average is around 5-10% (which is generally\n+less than the amount of variance between subsequent executions).\n+However, when used at level 9 compression, the cache contention can\n+drop enough for the assembly version to achieve 10-20% speedup (and\n+sometimes more, depending on the amount of overall redundancy in the\n+files). Even here, though, cache contention can still be the limiting\n+factor, depending on the nature of the program using the zlib library.\n+This may also mean that better improvements will be seen on a Pentium\n+with MMX, which suffers much less from L1-cache contention, but I have\n+not yet verified this.\n+\n+Note that this code has been tailored for the Pentium in particular,\n+and will not perform well on the Pentium Pro (due to the use of a\n+partial register in the inner loop).\n+\n+If you are using an assembler other than GNU as, you will have to\n+translate match.S to use your assembler's syntax. (Have fun.)\n+\n+Brian Raiter\n+breadbox@muppetlabs.com\n+April, 1998\n+\n+\n+Added for zlib 1.1.3:\n+\n+The patches come from\n+http://www.muppetlabs.com/~breadbox/software/assembly.html\n+\n+To compile zlib with this asm file, copy match.S to the zlib directory\n+then do:\n+\n+CFLAGS=\"-O3 -DASMV\" ./configure\n+make OBJA=match.o"}, {"sha": "8f1614078f8e49455eadfd37a1f7ca5b868db20b", "filename": "zlib/contrib/asm586/match.S", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm586%2Fmatch.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm586%2Fmatch.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm586%2Fmatch.S?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,354 @@\n+/* match.s -- Pentium-optimized version of longest_match()\n+ * Written for zlib 1.1.2\n+ * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License.\n+ */\n+\n+#ifndef NO_UNDERLINE\n+#define\tmatch_init\t_match_init\n+#define\tlongest_match\t_longest_match\n+#endif\n+\n+#define\tMAX_MATCH\t(258)\n+#define\tMIN_MATCH\t(3)\n+#define\tMIN_LOOKAHEAD\t(MAX_MATCH + MIN_MATCH + 1)\n+#define\tMAX_MATCH_8\t((MAX_MATCH + 7) & ~7)\n+\n+/* stack frame offsets */\n+\n+#define\twmask\t\t\t0\t/* local copy of s->wmask\t*/\n+#define\twindow\t\t\t4\t/* local copy of s->window\t*/\n+#define\twindowbestlen\t\t8\t/* s->window + bestlen\t\t*/\n+#define\tchainlenscanend\t\t12\t/* high word: current chain len\t*/\n+\t\t\t\t\t/* low word: last bytes sought\t*/\n+#define\tscanstart\t\t16\t/* first two bytes of string\t*/\n+#define\tscanalign\t\t20\t/* dword-misalignment of string\t*/\n+#define\tnicematch\t\t24\t/* a good enough match size\t*/\n+#define\tbestlen\t\t\t28\t/* size of best match so far\t*/\n+#define\tscan\t\t\t32\t/* ptr to string wanting match\t*/\n+\n+#define\tLocalVarsSize\t\t(36)\n+/*\tsaved ebx\t\t36 */\n+/*\tsaved edi\t\t40 */\n+/*\tsaved esi\t\t44 */\n+/*\tsaved ebp\t\t48 */\n+/*\treturn address\t\t52 */\n+#define\tdeflatestate\t\t56\t/* the function arguments\t*/\n+#define\tcurmatch\t\t60\n+\n+/* Offsets for fields in the deflate_state structure. These numbers\n+ * are calculated from the definition of deflate_state, with the\n+ * assumption that the compiler will dword-align the fields. (Thus,\n+ * changing the definition of deflate_state could easily cause this\n+ * program to crash horribly, without so much as a warning at\n+ * compile time. Sigh.)\n+ */\n+#define\tdsWSize\t\t\t36\n+#define\tdsWMask\t\t\t44\n+#define\tdsWindow\t\t48\n+#define\tdsPrev\t\t\t56\n+#define\tdsMatchLen\t\t88\n+#define\tdsPrevMatch\t\t92\n+#define\tdsStrStart\t\t100\n+#define\tdsMatchStart\t\t104\n+#define\tdsLookahead\t\t108\n+#define\tdsPrevLen\t\t112\n+#define\tdsMaxChainLen\t\t116\n+#define\tdsGoodMatch\t\t132\n+#define\tdsNiceMatch\t\t136\n+\n+\n+.file \"match.S\"\n+\n+.globl\tmatch_init, longest_match\n+\n+.text\n+\n+/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */\n+\n+longest_match:\n+\n+/* Save registers that the compiler may be using, and adjust %esp to\t*/\n+/* make room for our stack frame.\t\t\t\t\t*/\n+\n+\t\tpushl\t%ebp\n+\t\tpushl\t%edi\n+\t\tpushl\t%esi\n+\t\tpushl\t%ebx\n+\t\tsubl\t$LocalVarsSize, %esp\n+\n+/* Retrieve the function arguments. %ecx will hold cur_match\t\t*/\n+/* throughout the entire function. %edx will hold the pointer to the\t*/\n+/* deflate_state structure during the function's setup (before\t\t*/\n+/* entering the main loop).\t\t\t\t\t\t*/\n+\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tcurmatch(%esp), %ecx\n+\n+/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\t*/\n+\n+\t\tmovl\tdsNiceMatch(%edx), %eax\n+\t\tmovl\tdsLookahead(%edx), %ebx\n+\t\tcmpl\t%eax, %ebx\n+\t\tjl\tLookaheadLess\n+\t\tmovl\t%eax, %ebx\n+LookaheadLess:\tmovl\t%ebx, nicematch(%esp)\n+\n+/* register Bytef *scan = s->window + s->strstart;\t\t\t*/\n+\n+\t\tmovl\tdsWindow(%edx), %esi\n+\t\tmovl\t%esi, window(%esp)\n+\t\tmovl\tdsStrStart(%edx), %ebp\n+\t\tlea\t(%esi,%ebp), %edi\n+\t\tmovl\t%edi, scan(%esp)\n+\n+/* Determine how many bytes the scan ptr is off from being\t\t*/\n+/* dword-aligned.\t\t\t\t\t\t\t*/\n+\n+\t\tmovl\t%edi, %eax\n+\t\tnegl\t%eax\n+\t\tandl\t$3, %eax\n+\t\tmovl\t%eax, scanalign(%esp)\n+\n+/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\t\t\t*/\n+/*     s->strstart - (IPos)MAX_DIST(s) : NIL;\t\t\t\t*/\n+\n+\t\tmovl\tdsWSize(%edx), %eax\n+\t\tsubl\t$MIN_LOOKAHEAD, %eax\n+\t\tsubl\t%eax, %ebp\n+\t\tjg\tLimitPositive\n+\t\txorl\t%ebp, %ebp\n+LimitPositive:\n+\n+/* unsigned chain_length = s->max_chain_length;\t\t\t\t*/\n+/* if (s->prev_length >= s->good_match) {\t\t\t\t*/\n+/*     chain_length >>= 2;\t\t\t\t\t\t*/\n+/* }\t\t\t\t\t\t\t\t\t*/\n+\n+\t\tmovl\tdsPrevLen(%edx), %eax\n+\t\tmovl\tdsGoodMatch(%edx), %ebx\n+\t\tcmpl\t%ebx, %eax\n+\t\tmovl\tdsMaxChainLen(%edx), %ebx\n+\t\tjl\tLastMatchGood\n+\t\tshrl\t$2, %ebx\n+LastMatchGood:\n+\n+/* chainlen is decremented once beforehand so that the function can\t*/\n+/* use the sign flag instead of the zero flag for the exit test.\t*/\n+/* It is then shifted into the high word, to make room for the scanend\t*/\n+/* scanend value, which it will always accompany.\t\t\t*/\n+\n+\t\tdecl\t%ebx\n+\t\tshll\t$16, %ebx\n+\n+/* int best_len = s->prev_length;\t\t\t\t\t*/\n+\n+\t\tmovl\tdsPrevLen(%edx), %eax\n+\t\tmovl\t%eax, bestlen(%esp)\n+\n+/* Store the sum of s->window + best_len in %esi locally, and in %esi.\t*/\n+\n+\t\taddl\t%eax, %esi\n+\t\tmovl\t%esi, windowbestlen(%esp)\n+\n+/* register ush scan_start = *(ushf*)scan;\t\t\t\t*/\n+/* register ush scan_end   = *(ushf*)(scan+best_len-1);\t\t\t*/\n+\n+\t\tmovw\t(%edi), %bx\n+\t\tmovw\t%bx, scanstart(%esp)\n+\t\tmovw\t-1(%edi,%eax), %bx\n+\t\tmovl\t%ebx, chainlenscanend(%esp)\n+\n+/* Posf *prev = s->prev;\t\t\t\t\t\t*/\n+/* uInt wmask = s->w_mask;\t\t\t\t\t\t*/\n+\n+\t\tmovl\tdsPrev(%edx), %edi\n+\t\tmovl\tdsWMask(%edx), %edx\n+\t\tmov\t%edx, wmask(%esp)\n+\n+/* Jump into the main loop.\t\t\t\t\t\t*/\n+\n+\t\tjmp\tLoopEntry\n+\n+.balign 16\n+\n+/* do {\n+ *     match = s->window + cur_match;\n+ *     if (*(ushf*)(match+best_len-1) != scan_end ||\n+ *         *(ushf*)match != scan_start) continue;\n+ *     [...]\n+ * } while ((cur_match = prev[cur_match & wmask]) > limit\n+ *          && --chain_length != 0);\n+ *\n+ * Here is the inner loop of the function. The function will spend the\n+ * majority of its time in this loop, and majority of that time will\n+ * be spent in the first ten instructions.\n+ *\n+ * Within this loop:\n+ * %ebx = chainlenscanend - i.e., ((chainlen << 16) | scanend)\n+ * %ecx = curmatch\n+ * %edx = curmatch & wmask\n+ * %esi = windowbestlen - i.e., (window + bestlen)\n+ * %edi = prev\n+ * %ebp = limit\n+ *\n+ * Two optimization notes on the choice of instructions:\n+ *\n+ * The first instruction uses a 16-bit address, which costs an extra,\n+ * unpairable cycle. This is cheaper than doing a 32-bit access and\n+ * zeroing the high word, due to the 3-cycle misalignment penalty which\n+ * would occur half the time. This also turns out to be cheaper than\n+ * doing two separate 8-bit accesses, as the memory is so rarely in the\n+ * L1 cache.\n+ *\n+ * The window buffer, however, apparently spends a lot of time in the\n+ * cache, and so it is faster to retrieve the word at the end of the\n+ * match string with two 8-bit loads. The instructions that test the\n+ * word at the beginning of the match string, however, are executed\n+ * much less frequently, and there it was cheaper to use 16-bit\n+ * instructions, which avoided the necessity of saving off and\n+ * subsequently reloading one of the other registers.\n+ */\n+LookupLoop:\n+\t\t\t\t\t\t\t/* 1 U & V  */\n+\t\tmovw\t(%edi,%edx,2), %cx\t\t/* 2 U pipe */\n+\t\tmovl\twmask(%esp), %edx\t\t/* 2 V pipe */\n+\t\tcmpl\t%ebp, %ecx\t\t\t/* 3 U pipe */\n+\t\tjbe\tLeaveNow\t\t\t/* 3 V pipe */\n+\t\tsubl\t$0x00010000, %ebx\t\t/* 4 U pipe */\n+\t\tjs\tLeaveNow\t\t\t/* 4 V pipe */\n+LoopEntry:\tmovb\t-1(%esi,%ecx), %al\t\t/* 5 U pipe */\n+\t\tandl\t%ecx, %edx\t\t\t/* 5 V pipe */\n+\t\tcmpb\t%bl, %al\t\t\t/* 6 U pipe */\n+\t\tjnz\tLookupLoop\t\t\t/* 6 V pipe */\n+\t\tmovb\t(%esi,%ecx), %ah\n+\t\tcmpb\t%bh, %ah\n+\t\tjnz\tLookupLoop\n+\t\tmovl\twindow(%esp), %eax\n+\t\tmovw\t(%eax,%ecx), %ax\n+\t\tcmpw\tscanstart(%esp), %ax\n+\t\tjnz\tLookupLoop\n+\n+/* Store the current value of chainlen.\t\t\t\t\t*/\n+\n+\t\tmovl\t%ebx, chainlenscanend(%esp)\n+\n+/* Point %edi to the string under scrutiny, and %esi to the string we\t*/\n+/* are hoping to match it up with. In actuality, %esi and %edi are\t*/\n+/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is\t*/\n+/* initialized to -(MAX_MATCH_8 - scanalign).\t\t\t\t*/\n+\n+\t\tmovl\twindow(%esp), %esi\n+\t\tmovl\tscan(%esp), %edi\n+\t\taddl\t%ecx, %esi\n+\t\tmovl\tscanalign(%esp), %eax\n+\t\tmovl\t$(-MAX_MATCH_8), %edx\n+\t\tlea\tMAX_MATCH_8(%edi,%eax), %edi\n+\t\tlea\tMAX_MATCH_8(%esi,%eax), %esi\n+\n+/* Test the strings for equality, 8 bytes at a time. At the end,\n+ * adjust %edx so that it is offset to the exact byte that mismatched.\n+ *\n+ * We already know at this point that the first three bytes of the\n+ * strings match each other, and they can be safely passed over before\n+ * starting the compare loop. So what this code does is skip over 0-3\n+ * bytes, as much as necessary in order to dword-align the %edi\n+ * pointer. (%esi will still be misaligned three times out of four.)\n+ *\n+ * It should be confessed that this loop usually does not represent\n+ * much of the total running time. Replacing it with a more\n+ * straightforward \"rep cmpsb\" would not drastically degrade\n+ * performance.\n+ */\n+LoopCmps:\n+\t\tmovl\t(%esi,%edx), %eax\n+\t\tmovl\t(%edi,%edx), %ebx\n+\t\txorl\t%ebx, %eax\n+\t\tjnz\tLeaveLoopCmps\n+\t\tmovl\t4(%esi,%edx), %eax\n+\t\tmovl\t4(%edi,%edx), %ebx\n+\t\txorl\t%ebx, %eax\n+\t\tjnz\tLeaveLoopCmps4\n+\t\taddl\t$8, %edx\n+\t\tjnz\tLoopCmps\n+\t\tjmp\tLenMaximum\n+LeaveLoopCmps4:\taddl\t$4, %edx\n+LeaveLoopCmps:\ttestl\t$0x0000FFFF, %eax\n+\t\tjnz\tLenLower\n+\t\taddl\t$2, %edx\n+\t\tshrl\t$16, %eax\n+LenLower:\tsubb\t$1, %al\n+\t\tadcl\t$0, %edx\n+\n+/* Calculate the length of the match. If it is longer than MAX_MATCH,\t*/\n+/* then automatically accept it as the best possible match and leave.\t*/\n+\n+\t\tlea\t(%edi,%edx), %eax\n+\t\tmovl\tscan(%esp), %edi\n+\t\tsubl\t%edi, %eax\n+\t\tcmpl\t$MAX_MATCH, %eax\n+\t\tjge\tLenMaximum\n+\n+/* If the length of the match is not longer than the best match we\t*/\n+/* have so far, then forget it and return to the lookup loop.\t\t*/\n+\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tbestlen(%esp), %ebx\n+\t\tcmpl\t%ebx, %eax\n+\t\tjg\tLongerMatch\n+\t\tmovl\tchainlenscanend(%esp), %ebx\n+\t\tmovl\twindowbestlen(%esp), %esi\n+\t\tmovl\tdsPrev(%edx), %edi\n+\t\tmovl\twmask(%esp), %edx\n+\t\tandl\t%ecx, %edx\n+\t\tjmp\tLookupLoop\n+\n+/*         s->match_start = cur_match;\t\t\t\t\t*/\n+/*         best_len = len;\t\t\t\t\t\t*/\n+/*         if (len >= nice_match) break;\t\t\t\t*/\n+/*         scan_end = *(ushf*)(scan+best_len-1);\t\t\t*/\n+\n+LongerMatch:\tmovl\tnicematch(%esp), %ebx\n+\t\tmovl\t%eax, bestlen(%esp)\n+\t\tmovl\t%ecx, dsMatchStart(%edx)\n+\t\tcmpl\t%ebx, %eax\n+\t\tjge\tLeaveNow\n+\t\tmovl\twindow(%esp), %esi\n+\t\taddl\t%eax, %esi\n+\t\tmovl\t%esi, windowbestlen(%esp)\n+\t\tmovl\tchainlenscanend(%esp), %ebx\n+\t\tmovw\t-1(%edi,%eax), %bx\n+\t\tmovl\tdsPrev(%edx), %edi\n+\t\tmovl\t%ebx, chainlenscanend(%esp)\n+\t\tmovl\twmask(%esp), %edx\n+\t\tandl\t%ecx, %edx\n+\t\tjmp\tLookupLoop\n+\n+/* Accept the current string, with the maximum possible length.\t\t*/\n+\n+LenMaximum:\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\t$MAX_MATCH, bestlen(%esp)\n+\t\tmovl\t%ecx, dsMatchStart(%edx)\n+\n+/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\t\t*/\n+/* return s->lookahead;\t\t\t\t\t\t\t*/\n+\n+LeaveNow:\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tbestlen(%esp), %ebx\n+\t\tmovl\tdsLookahead(%edx), %eax\n+\t\tcmpl\t%eax, %ebx\n+\t\tjg\tLookaheadRet\n+\t\tmovl\t%ebx, %eax\n+LookaheadRet:\n+\n+/* Restore the stack and return from whence we came.\t\t\t*/\n+\n+\t\taddl\t$LocalVarsSize, %esp\n+\t\tpopl\t%ebx\n+\t\tpopl\t%esi\n+\t\tpopl\t%edi\n+\t\tpopl\t%ebp\n+match_init:\tret"}, {"sha": "a593f23afd655086de3e123916b0587ebd2706f6", "filename": "zlib/contrib/asm686/README.686", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm686%2FREADME.686", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm686%2FREADME.686", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm686%2FREADME.686?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,34 @@\n+This is a patched version of zlib, modified to use\n+Pentium-Pro-optimized assembly code in the deflation algorithm. The\n+files changed/added by this patch are:\n+\n+README.686\n+match.S\n+\n+The speedup that this patch provides varies, depending on whether the\n+compiler used to build the original version of zlib falls afoul of the\n+PPro's speed traps. My own tests show a speedup of around 10-20% at\n+the default compression level, and 20-30% using -9, against a version\n+compiled using gcc 2.7.2.3. Your mileage may vary.\n+\n+Note that this code has been tailored for the PPro/PII in particular,\n+and will not perform particuarly well on a Pentium.\n+\n+If you are using an assembler other than GNU as, you will have to\n+translate match.S to use your assembler's syntax. (Have fun.)\n+\n+Brian Raiter\n+breadbox@muppetlabs.com\n+April, 1998\n+\n+\n+Added for zlib 1.1.3:\n+\n+The patches come from\n+http://www.muppetlabs.com/~breadbox/software/assembly.html\n+\n+To compile zlib with this asm file, copy match.S to the zlib directory\n+then do:\n+\n+CFLAGS=\"-O3 -DASMV\" ./configure\n+make OBJA=match.o"}, {"sha": "8e86c33c2882b10b3d48eabb0cfc68048c958ecd", "filename": "zlib/contrib/asm686/match.S", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fasm686%2Fmatch.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm686%2Fmatch.S?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,327 @@\n+/* match.s -- Pentium-Pro-optimized version of longest_match()\n+ * Written for zlib 1.1.2\n+ * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License.\n+ */\n+\n+#ifndef NO_UNDERLINE\n+#define\tmatch_init\t_match_init\n+#define\tlongest_match\t_longest_match\n+#endif\n+\n+#define\tMAX_MATCH\t(258)\n+#define\tMIN_MATCH\t(3)\n+#define\tMIN_LOOKAHEAD\t(MAX_MATCH + MIN_MATCH + 1)\n+#define\tMAX_MATCH_8\t((MAX_MATCH + 7) & ~7)\n+\n+/* stack frame offsets */\n+\n+#define\tchainlenwmask\t\t0\t/* high word: current chain len\t*/\n+\t\t\t\t\t/* low word: s->wmask\t\t*/\n+#define\twindow\t\t\t4\t/* local copy of s->window\t*/\n+#define\twindowbestlen\t\t8\t/* s->window + bestlen\t\t*/\n+#define\tscanstart\t\t16\t/* first two bytes of string\t*/\n+#define\tscanend\t\t\t12\t/* last two bytes of string\t*/\n+#define\tscanalign\t\t20\t/* dword-misalignment of string\t*/\n+#define\tnicematch\t\t24\t/* a good enough match size\t*/\n+#define\tbestlen\t\t\t28\t/* size of best match so far\t*/\n+#define\tscan\t\t\t32\t/* ptr to string wanting match\t*/\n+\n+#define\tLocalVarsSize\t\t(36)\n+/*\tsaved ebx\t\t36 */\n+/*\tsaved edi\t\t40 */\n+/*\tsaved esi\t\t44 */\n+/*\tsaved ebp\t\t48 */\n+/*\treturn address\t\t52 */\n+#define\tdeflatestate\t\t56\t/* the function arguments\t*/\n+#define\tcurmatch\t\t60\n+\n+/* Offsets for fields in the deflate_state structure. These numbers\n+ * are calculated from the definition of deflate_state, with the\n+ * assumption that the compiler will dword-align the fields. (Thus,\n+ * changing the definition of deflate_state could easily cause this\n+ * program to crash horribly, without so much as a warning at\n+ * compile time. Sigh.)\n+ */\n+#define\tdsWSize\t\t\t36\n+#define\tdsWMask\t\t\t44\n+#define\tdsWindow\t\t48\n+#define\tdsPrev\t\t\t56\n+#define\tdsMatchLen\t\t88\n+#define\tdsPrevMatch\t\t92\n+#define\tdsStrStart\t\t100\n+#define\tdsMatchStart\t\t104\n+#define\tdsLookahead\t\t108\n+#define\tdsPrevLen\t\t112\n+#define\tdsMaxChainLen\t\t116\n+#define\tdsGoodMatch\t\t132\n+#define\tdsNiceMatch\t\t136\n+\n+\n+.file \"match.S\"\n+\n+.globl\tmatch_init, longest_match\n+\n+.text\n+\n+/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */\n+\n+longest_match:\n+\n+/* Save registers that the compiler may be using, and adjust %esp to\t*/\n+/* make room for our stack frame.\t\t\t\t\t*/\n+\n+\t\tpushl\t%ebp\n+\t\tpushl\t%edi\n+\t\tpushl\t%esi\n+\t\tpushl\t%ebx\n+\t\tsubl\t$LocalVarsSize, %esp\n+\n+/* Retrieve the function arguments. %ecx will hold cur_match\t\t*/\n+/* throughout the entire function. %edx will hold the pointer to the\t*/\n+/* deflate_state structure during the function's setup (before\t\t*/\n+/* entering the main loop).\t\t\t\t\t\t*/\n+\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tcurmatch(%esp), %ecx\n+\n+/* uInt wmask = s->w_mask;\t\t\t\t\t\t*/\n+/* unsigned chain_length = s->max_chain_length;\t\t\t\t*/\n+/* if (s->prev_length >= s->good_match) {\t\t\t\t*/\n+/*     chain_length >>= 2;\t\t\t\t\t\t*/\n+/* }\t\t\t\t\t\t\t\t\t*/\n+\n+\t\tmovl\tdsPrevLen(%edx), %eax\n+\t\tmovl\tdsGoodMatch(%edx), %ebx\n+\t\tcmpl\t%ebx, %eax\n+\t\tmovl\tdsWMask(%edx), %eax\n+\t\tmovl\tdsMaxChainLen(%edx), %ebx\n+\t\tjl\tLastMatchGood\n+\t\tshrl\t$2, %ebx\n+LastMatchGood:\n+\n+/* chainlen is decremented once beforehand so that the function can\t*/\n+/* use the sign flag instead of the zero flag for the exit test.\t*/\n+/* It is then shifted into the high word, to make room for the wmask\t*/\n+/* value, which it will always accompany.\t\t\t\t*/\n+\n+\t\tdecl\t%ebx\n+\t\tshll\t$16, %ebx\n+\t\torl\t%eax, %ebx\n+\t\tmovl\t%ebx, chainlenwmask(%esp)\n+\n+/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\t*/\n+\n+\t\tmovl\tdsNiceMatch(%edx), %eax\n+\t\tmovl\tdsLookahead(%edx), %ebx\n+\t\tcmpl\t%eax, %ebx\n+\t\tjl\tLookaheadLess\n+\t\tmovl\t%eax, %ebx\n+LookaheadLess:\tmovl\t%ebx, nicematch(%esp)\n+\n+/* register Bytef *scan = s->window + s->strstart;\t\t\t*/\n+\n+\t\tmovl\tdsWindow(%edx), %esi\n+\t\tmovl\t%esi, window(%esp)\n+\t\tmovl\tdsStrStart(%edx), %ebp\n+\t\tlea\t(%esi,%ebp), %edi\n+\t\tmovl\t%edi, scan(%esp)\n+\n+/* Determine how many bytes the scan ptr is off from being\t\t*/\n+/* dword-aligned.\t\t\t\t\t\t\t*/\n+\n+\t\tmovl\t%edi, %eax\n+\t\tnegl\t%eax\n+\t\tandl\t$3, %eax\n+\t\tmovl\t%eax, scanalign(%esp)\n+\n+/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\t\t\t*/\n+/*     s->strstart - (IPos)MAX_DIST(s) : NIL;\t\t\t\t*/\n+\n+\t\tmovl\tdsWSize(%edx), %eax\n+\t\tsubl\t$MIN_LOOKAHEAD, %eax\n+\t\tsubl\t%eax, %ebp\n+\t\tjg\tLimitPositive\n+\t\txorl\t%ebp, %ebp\n+LimitPositive:\n+\n+/* int best_len = s->prev_length;\t\t\t\t\t*/\n+\n+\t\tmovl\tdsPrevLen(%edx), %eax\n+\t\tmovl\t%eax, bestlen(%esp)\n+\n+/* Store the sum of s->window + best_len in %esi locally, and in %esi.\t*/\n+\n+\t\taddl\t%eax, %esi\n+\t\tmovl\t%esi, windowbestlen(%esp)\n+\n+/* register ush scan_start = *(ushf*)scan;\t\t\t\t*/\n+/* register ush scan_end   = *(ushf*)(scan+best_len-1);\t\t\t*/\n+/* Posf *prev = s->prev;\t\t\t\t\t\t*/\n+\n+\t\tmovzwl\t(%edi), %ebx\n+\t\tmovl\t%ebx, scanstart(%esp)\n+\t\tmovzwl\t-1(%edi,%eax), %ebx\n+\t\tmovl\t%ebx, scanend(%esp)\n+\t\tmovl\tdsPrev(%edx), %edi\n+\n+/* Jump into the main loop.\t\t\t\t\t\t*/\n+\n+\t\tmovl\tchainlenwmask(%esp), %edx\n+\t\tjmp\tLoopEntry\n+\n+.balign 16\n+\n+/* do {\n+ *     match = s->window + cur_match;\n+ *     if (*(ushf*)(match+best_len-1) != scan_end ||\n+ *         *(ushf*)match != scan_start) continue;\n+ *     [...]\n+ * } while ((cur_match = prev[cur_match & wmask]) > limit\n+ *          && --chain_length != 0);\n+ *\n+ * Here is the inner loop of the function. The function will spend the\n+ * majority of its time in this loop, and majority of that time will\n+ * be spent in the first ten instructions.\n+ *\n+ * Within this loop:\n+ * %ebx = scanend\n+ * %ecx = curmatch\n+ * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\n+ * %esi = windowbestlen - i.e., (window + bestlen)\n+ * %edi = prev\n+ * %ebp = limit\n+ */\n+LookupLoop:\n+\t\tandl\t%edx, %ecx\n+\t\tmovzwl\t(%edi,%ecx,2), %ecx\n+\t\tcmpl\t%ebp, %ecx\n+\t\tjbe\tLeaveNow\n+\t\tsubl\t$0x00010000, %edx\n+\t\tjs\tLeaveNow\n+LoopEntry:\tmovzwl\t-1(%esi,%ecx), %eax\n+\t\tcmpl\t%ebx, %eax\n+\t\tjnz\tLookupLoop\n+\t\tmovl\twindow(%esp), %eax\n+\t\tmovzwl\t(%eax,%ecx), %eax\n+\t\tcmpl\tscanstart(%esp), %eax\n+\t\tjnz\tLookupLoop\n+\n+/* Store the current value of chainlen.\t\t\t\t\t*/\n+\n+\t\tmovl\t%edx, chainlenwmask(%esp)\n+\n+/* Point %edi to the string under scrutiny, and %esi to the string we\t*/\n+/* are hoping to match it up with. In actuality, %esi and %edi are\t*/\n+/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is\t*/\n+/* initialized to -(MAX_MATCH_8 - scanalign).\t\t\t\t*/\n+\n+\t\tmovl\twindow(%esp), %esi\n+\t\tmovl\tscan(%esp), %edi\n+\t\taddl\t%ecx, %esi\n+\t\tmovl\tscanalign(%esp), %eax\n+\t\tmovl\t$(-MAX_MATCH_8), %edx\n+\t\tlea\tMAX_MATCH_8(%edi,%eax), %edi\n+\t\tlea\tMAX_MATCH_8(%esi,%eax), %esi\n+\n+/* Test the strings for equality, 8 bytes at a time. At the end,\n+ * adjust %edx so that it is offset to the exact byte that mismatched.\n+ *\n+ * We already know at this point that the first three bytes of the\n+ * strings match each other, and they can be safely passed over before\n+ * starting the compare loop. So what this code does is skip over 0-3\n+ * bytes, as much as necessary in order to dword-align the %edi\n+ * pointer. (%esi will still be misaligned three times out of four.)\n+ *\n+ * It should be confessed that this loop usually does not represent\n+ * much of the total running time. Replacing it with a more\n+ * straightforward \"rep cmpsb\" would not drastically degrade\n+ * performance.\n+ */\n+LoopCmps:\n+\t\tmovl\t(%esi,%edx), %eax\n+\t\txorl\t(%edi,%edx), %eax\n+\t\tjnz\tLeaveLoopCmps\n+\t\tmovl\t4(%esi,%edx), %eax\n+\t\txorl\t4(%edi,%edx), %eax\n+\t\tjnz\tLeaveLoopCmps4\n+\t\taddl\t$8, %edx\n+\t\tjnz\tLoopCmps\n+\t\tjmp\tLenMaximum\n+LeaveLoopCmps4:\taddl\t$4, %edx\n+LeaveLoopCmps:\ttestl\t$0x0000FFFF, %eax\n+\t\tjnz\tLenLower\n+\t\taddl\t$2, %edx\n+\t\tshrl\t$16, %eax\n+LenLower:\tsubb\t$1, %al\n+\t\tadcl\t$0, %edx\n+\n+/* Calculate the length of the match. If it is longer than MAX_MATCH,\t*/\n+/* then automatically accept it as the best possible match and leave.\t*/\n+\n+\t\tlea\t(%edi,%edx), %eax\n+\t\tmovl\tscan(%esp), %edi\n+\t\tsubl\t%edi, %eax\n+\t\tcmpl\t$MAX_MATCH, %eax\n+\t\tjge\tLenMaximum\n+\n+/* If the length of the match is not longer than the best match we\t*/\n+/* have so far, then forget it and return to the lookup loop.\t\t*/\n+\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tbestlen(%esp), %ebx\n+\t\tcmpl\t%ebx, %eax\n+\t\tjg\tLongerMatch\n+\t\tmovl\twindowbestlen(%esp), %esi\n+\t\tmovl\tdsPrev(%edx), %edi\n+\t\tmovl\tscanend(%esp), %ebx\n+\t\tmovl\tchainlenwmask(%esp), %edx\n+\t\tjmp\tLookupLoop\n+\n+/*         s->match_start = cur_match;\t\t\t\t\t*/\n+/*         best_len = len;\t\t\t\t\t\t*/\n+/*         if (len >= nice_match) break;\t\t\t\t*/\n+/*         scan_end = *(ushf*)(scan+best_len-1);\t\t\t*/\n+\n+LongerMatch:\tmovl\tnicematch(%esp), %ebx\n+\t\tmovl\t%eax, bestlen(%esp)\n+\t\tmovl\t%ecx, dsMatchStart(%edx)\n+\t\tcmpl\t%ebx, %eax\n+\t\tjge\tLeaveNow\n+\t\tmovl\twindow(%esp), %esi\n+\t\taddl\t%eax, %esi\n+\t\tmovl\t%esi, windowbestlen(%esp)\n+\t\tmovzwl\t-1(%edi,%eax), %ebx\n+\t\tmovl\tdsPrev(%edx), %edi\n+\t\tmovl\t%ebx, scanend(%esp)\n+\t\tmovl\tchainlenwmask(%esp), %edx\n+\t\tjmp\tLookupLoop\n+\n+/* Accept the current string, with the maximum possible length.\t\t*/\n+\n+LenMaximum:\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\t$MAX_MATCH, bestlen(%esp)\n+\t\tmovl\t%ecx, dsMatchStart(%edx)\n+\n+/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\t\t*/\n+/* return s->lookahead;\t\t\t\t\t\t\t*/\n+\n+LeaveNow:\n+\t\tmovl\tdeflatestate(%esp), %edx\n+\t\tmovl\tbestlen(%esp), %ebx\n+\t\tmovl\tdsLookahead(%edx), %eax\n+\t\tcmpl\t%eax, %ebx\n+\t\tjg\tLookaheadRet\n+\t\tmovl\t%ebx, %eax\n+LookaheadRet:\n+\n+/* Restore the stack and return from whence we came.\t\t\t*/\n+\n+\t\taddl\t$LocalVarsSize, %esp\n+\t\tpopl\t%ebx\n+\t\tpopl\t%esi\n+\t\tpopl\t%edi\n+\t\tpopl\t%ebp\n+match_init:\tret"}, {"sha": "ba557e2b9772c764ca04ecbc368932b4f64336dd", "filename": "zlib/contrib/delphi/zlib.mak", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,36 @@\n+# Makefile for zlib32bd.lib\n+# ------------- Borland C++ 4.5 -------------\n+\n+# The (32-bit) zlib32bd.lib made with this makefile is intended for use \n+# in making the (32-bit) DLL, png32bd.dll. It uses the \"stdcall\" calling \n+# convention.\n+\n+CFLAGS= -ps -O2 -C -K -N- -k- -d -3 -r- -w-par -w-aus -WDE\n+CC=f:\\bc45\\bin\\bcc32\n+LIBFLAGS= /C\n+LIB=f:\\bc45\\bin\\tlib\n+ZLIB=zlib32bd.lib\n+\n+.autodepend\n+.c.obj:\n+        $(CC) -c $(CFLAGS) $<\n+\n+OBJ1=adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \n+OBJ2=infcodes.obj inflate.obj inftrees.obj infutil.obj inffast.obj \n+OBJ3=trees.obj uncompr.obj zutil.obj\n+pOBJ1=+adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infblock.obj \n+pOBJ2=+infcodes.obj+inflate.obj+inftrees.obj+infutil.obj+inffast.obj \n+pOBJ3=+trees.obj+uncompr.obj+zutil.obj\n+\n+all: $(ZLIB)\n+\n+$(ZLIB): $(OBJ1) $(OBJ2) $(OBJ3)\n+        @if exist $@ del $@\n+        $(LIB) @&&|\n+$@ $(LIBFLAGS) &\n+$(pOBJ1) &\n+$(pOBJ2) &\n+$(pOBJ3)\n+|\n+\n+# End of makefile for zlib32bd.lib"}, {"sha": "4f96b7d2c5045360b06cd45ccf04b742a895b5eb", "filename": "zlib/contrib/delphi/zlibdef.pas", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,169 @@\n+unit zlibdef;\n+\n+interface\n+\n+uses\n+  Windows;\n+\n+const\n+  ZLIB_VERSION = '1.1.3';\n+\n+type\n+  voidpf = Pointer;\n+  int    = Integer;\n+  uInt   = Cardinal;\n+  pBytef = PChar;\n+  uLong  = Cardinal;\n+\n+  alloc_func = function(opaque: voidpf; items, size: uInt): voidpf;\n+                    stdcall;\n+  free_func  = procedure(opaque, address: voidpf);\n+                    stdcall;\n+\n+  internal_state = Pointer;\n+\n+  z_streamp = ^z_stream;\n+  z_stream = packed record\n+    next_in: pBytef;          // next input byte\n+    avail_in: uInt;           // number of bytes available at next_in\n+    total_in: uLong;          // total nb of input bytes read so far\n+\n+    next_out: pBytef;         // next output byte should be put there\n+    avail_out: uInt;          // remaining free space at next_out\n+    total_out: uLong;         // total nb of bytes output so far\n+\n+    msg: PChar;               // last error message, NULL if no error\n+    state: internal_state;    // not visible by applications\n+\n+    zalloc: alloc_func;       // used to allocate the internal state\n+    zfree: free_func;         // used to free the internal state\n+    opaque: voidpf;           // private data object passed to zalloc and zfree\n+\n+    data_type: int;           // best guess about the data type: ascii or binary\n+    adler: uLong;             // adler32 value of the uncompressed data\n+    reserved: uLong;          // reserved for future use\n+    end;\n+\n+const\n+  Z_NO_FLUSH      = 0;\n+  Z_SYNC_FLUSH    = 2;\n+  Z_FULL_FLUSH    = 3;\n+  Z_FINISH        = 4;\n+\n+  Z_OK            = 0;\n+  Z_STREAM_END    = 1;\n+\n+  Z_NO_COMPRESSION         =  0;\n+  Z_BEST_SPEED             =  1;\n+  Z_BEST_COMPRESSION       =  9;\n+  Z_DEFAULT_COMPRESSION    = -1;\n+\n+  Z_FILTERED            = 1;\n+  Z_HUFFMAN_ONLY        = 2;\n+  Z_DEFAULT_STRATEGY    = 0;\n+\n+  Z_BINARY   = 0;\n+  Z_ASCII    = 1;\n+  Z_UNKNOWN  = 2;\n+\n+  Z_DEFLATED    = 8;\n+\n+  MAX_MEM_LEVEL = 9;\n+\n+function adler32(adler: uLong; const buf: pBytef; len: uInt): uLong;\n+             stdcall;\n+function crc32(crc: uLong; const buf: pBytef; len: uInt): uLong;\n+             stdcall;\n+function deflate(strm: z_streamp; flush: int): int;\n+             stdcall;\n+function deflateCopy(dest, source: z_streamp): int;\n+             stdcall;\n+function deflateEnd(strm: z_streamp): int;\n+             stdcall;\n+function deflateInit2_(strm: z_streamp; level, method,\n+                       windowBits, memLevel, strategy: int;\n+                       const version: PChar; stream_size: int): int;\n+             stdcall;\n+function deflateInit_(strm: z_streamp; level: int;\n+                      const version: PChar; stream_size: int): int;\n+             stdcall;\n+function deflateParams(strm: z_streamp; level, strategy: int): int;\n+             stdcall;\n+function deflateReset(strm: z_streamp): int;\n+             stdcall;\n+function deflateSetDictionary(strm: z_streamp;\n+                              const dictionary: pBytef;\n+                              dictLength: uInt): int;\n+             stdcall;\n+function inflate(strm: z_streamp; flush: int): int;\n+             stdcall;\n+function inflateEnd(strm: z_streamp): int;\n+             stdcall;\n+function inflateInit2_(strm: z_streamp; windowBits: int;\n+                       const version: PChar; stream_size: int): int;\n+             stdcall;\n+function inflateInit_(strm: z_streamp; const version: PChar;\n+                      stream_size: int): int;\n+             stdcall;\n+function inflateReset(strm: z_streamp): int;\n+             stdcall;\n+function inflateSetDictionary(strm: z_streamp;\n+                              const dictionary: pBytef;\n+                              dictLength: uInt): int;\n+             stdcall;\n+function inflateSync(strm: z_streamp): int;\n+             stdcall;\n+\n+function deflateInit(strm: z_streamp; level: int): int;\n+function deflateInit2(strm: z_streamp; level, method, windowBits,\n+                      memLevel, strategy: int): int;\n+function inflateInit(strm: z_streamp): int;\n+function inflateInit2(strm: z_streamp; windowBits: int): int;\n+\n+implementation\n+\n+function deflateInit(strm: z_streamp; level: int): int;\n+begin\n+  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function deflateInit2(strm: z_streamp; level, method, windowBits,\n+                      memLevel, strategy: int): int;\n+begin\n+  Result := deflateInit2_(strm, level, method, windowBits, memLevel,\n+                          strategy, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function inflateInit(strm: z_streamp): int;\n+begin\n+  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));\n+end;\n+\n+function inflateInit2(strm: z_streamp; windowBits: int): int;\n+begin\n+  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION,\n+                          sizeof(z_stream));\n+end;\n+\n+const\n+  zlibDLL = 'png32bd.dll';\n+\n+function adler32; external zlibDLL;\n+function crc32; external zlibDLL;\n+function deflate; external zlibDLL;\n+function deflateCopy; external zlibDLL;\n+function deflateEnd; external zlibDLL;\n+function deflateInit2_; external zlibDLL;\n+function deflateInit_; external zlibDLL;\n+function deflateParams; external zlibDLL;\n+function deflateReset; external zlibDLL;\n+function deflateSetDictionary; external zlibDLL;\n+function inflate; external zlibDLL;\n+function inflateEnd; external zlibDLL;\n+function inflateInit2_; external zlibDLL;\n+function inflateInit_; external zlibDLL;\n+function inflateReset; external zlibDLL;\n+function inflateSetDictionary; external zlibDLL;\n+function inflateSync; external zlibDLL;\n+\n+end."}, {"sha": "78bb254088a5b57eb578afd0fbcd9cbd3963a5b5", "filename": "zlib/contrib/delphi2/d_zlib.bpr", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,224 @@\n+# ---------------------------------------------------------------------------\n+!if !$d(BCB)\n+BCB = $(MAKEDIR)\\..\n+!endif\n+\n+# ---------------------------------------------------------------------------\n+# IDE SECTION\n+# ---------------------------------------------------------------------------\n+# The following section of the project makefile is managed by the BCB IDE.\n+# It is recommended to use the IDE to change any of the values in this\n+# section.\n+# ---------------------------------------------------------------------------\n+\n+VERSION = BCB.03\n+# ---------------------------------------------------------------------------\n+PROJECT = d_zlib.lib\n+OBJFILES = d_zlib.obj adler32.obj deflate.obj infblock.obj infcodes.obj inffast.obj \\\n+  inflate.obj inftrees.obj infutil.obj trees.obj\n+RESFILES =\n+RESDEPEN = $(RESFILES)\n+LIBFILES =\n+LIBRARIES = VCL35.lib\n+SPARELIBS = VCL35.lib\n+DEFFILE =\n+PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n+  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n+  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n+# ---------------------------------------------------------------------------\n+PATHCPP = .;\n+PATHASM = .;\n+PATHPAS = .;\n+PATHRC = .;\n+DEBUGLIBPATH = $(BCB)\\lib\\debug\n+RELEASELIBPATH = $(BCB)\\lib\\release\n+# ---------------------------------------------------------------------------\n+CFLAG1 = -O2 -Ve -d -k- -vi\n+CFLAG2 = -I$(BCB)\\include;$(BCB)\\include\\vcl -H=$(BCB)\\lib\\vcl35.csm\n+CFLAG3 = -ff -pr -5\n+PFLAGS = -U;$(DEBUGLIBPATH) -I$(BCB)\\include;$(BCB)\\include\\vcl -H -W -$I- -v -JPHN -M\n+RFLAGS = -i$(BCB)\\include;$(BCB)\\include\\vcl \n+AFLAGS = /i$(BCB)\\include /i$(BCB)\\include\\vcl /mx /w2 /zn\n+LFLAGS =\n+IFLAGS = -g -Gn\n+# ---------------------------------------------------------------------------\n+ALLOBJ = c0w32.obj $(OBJFILES)\n+ALLRES = $(RESFILES)\n+ALLLIB = $(LIBFILES) $(LIBRARIES) import32.lib cp32mt.lib\n+# ---------------------------------------------------------------------------\n+!!ifdef IDEOPTIONS\n+\n+[Version Info]\n+IncludeVerInfo=0\n+AutoIncBuild=0\n+MajorVer=1\n+MinorVer=0\n+Release=0\n+Build=0\n+Debug=0\n+PreRelease=0\n+Special=0\n+Private=0\n+DLL=0\n+Locale=1040\n+CodePage=1252\n+\n+[Version Info Keys]\n+CompanyName=\n+FileDescription=\n+FileVersion=1.0.0.0\n+InternalName=\n+LegalCopyright=\n+LegalTrademarks=\n+OriginalFilename=\n+ProductName=\n+ProductVersion=1.0.0.0\n+Comments=\n+\n+[HistoryLists\\hlIncludePath]\n+Count=2\n+Item0=$(BCB)\\include\n+Item1=$(BCB)\\include;$(BCB)\\include\\vcl\n+\n+[HistoryLists\\hlLibraryPath]\n+Count=1\n+Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n+\n+[HistoryLists\\hlDebugSourcePath]\n+Count=1\n+Item0=$(BCB)\\source\\vcl\n+\n+[Debugging]\n+DebugSourceDirs=\n+\n+[Parameters]\n+RunParams=\n+HostApplication=\n+\n+!endif\n+\n+ ---------------------------------------------------------------------------\n+# MAKE SECTION\n+# ---------------------------------------------------------------------------\n+# This section of the project file is not used by the BCB IDE.  It is for\n+# the benefit of building from the command-line using the MAKE utility.\n+# ---------------------------------------------------------------------------\n+\n+.autodepend\n+# ---------------------------------------------------------------------------\n+!if !$d(BCC32)\n+BCC32 = bcc32\n+!endif\n+\n+!if !$d(DCC32)\n+DCC32 = dcc32\n+!endif\n+\n+!if !$d(TASM32)\n+TASM32 = tasm32\n+!endif\n+\n+!if !$d(LINKER)\n+LINKER = TLib\n+!endif\n+\n+!if !$d(BRCC32)\n+BRCC32 = brcc32\n+!endif\n+# ---------------------------------------------------------------------------\n+!if $d(PATHCPP)\n+.PATH.CPP = $(PATHCPP)\n+.PATH.C   = $(PATHCPP)\n+!endif\n+\n+!if $d(PATHPAS)\n+.PATH.PAS = $(PATHPAS)\n+!endif\n+\n+!if $d(PATHASM)\n+.PATH.ASM = $(PATHASM)\n+!endif\n+\n+!if $d(PATHRC)\n+.PATH.RC  = $(PATHRC)\n+!endif\n+# ---------------------------------------------------------------------------\n+!ifdef IDEOPTIONS\n+\n+[Version Info]\n+IncludeVerInfo=0\n+AutoIncBuild=0\n+MajorVer=1\n+MinorVer=0\n+Release=0\n+Build=0\n+Debug=0\n+PreRelease=0\n+Special=0\n+Private=0\n+DLL=0\n+Locale=1040\n+CodePage=1252\n+\n+[Version Info Keys]\n+CompanyName=\n+FileDescription=\n+FileVersion=1.0.0.0\n+InternalName=\n+LegalCopyright=\n+LegalTrademarks=\n+OriginalFilename=\n+ProductName=\n+ProductVersion=1.0.0.0\n+Comments=\n+\n+[HistoryLists\\hlIncludePath]\n+Count=2\n+Item0=$(BCB)\\include;$(BCB)\\include\\vcl\n+Item1=$(BCB)\\include\n+\n+[HistoryLists\\hlLibraryPath]\n+Count=1\n+Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n+\n+[HistoryLists\\hlDebugSourcePath]\n+Count=1\n+Item0=$(BCB)\\source\\vcl\n+\n+[Debugging]\n+DebugSourceDirs=\n+\n+[Parameters]\n+RunParams=\n+HostApplication=\n+\n+!endif\n+\n+$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n+    $(BCB)\\BIN\\$(LINKER) @&&!\n+    $(LFLAGS) $(IFLAGS) +\n+    $(ALLOBJ), +\n+    $(PROJECT),, +\n+    $(ALLLIB), +\n+    $(DEFFILE), +\n+    $(ALLRES)\n+!\n+# ---------------------------------------------------------------------------\n+.pas.hpp:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.pas.obj:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.cpp.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.c.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.asm.obj:\n+    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n+\n+.rc.res:\n+    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n+# ---------------------------------------------------------------------------"}, {"sha": "f5dea59b762332ad7f8f875637023b601af6647b", "filename": "zlib/contrib/delphi2/d_zlib.cpp", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,17 @@\n+#include <condefs.h>\n+#pragma hdrstop\n+//---------------------------------------------------------------------------\n+USEUNIT(\"adler32.c\");\n+USEUNIT(\"deflate.c\");\n+USEUNIT(\"infblock.c\");\n+USEUNIT(\"infcodes.c\");\n+USEUNIT(\"inffast.c\");\n+USEUNIT(\"inflate.c\");\n+USEUNIT(\"inftrees.c\");\n+USEUNIT(\"infutil.c\");\n+USEUNIT(\"trees.c\");\n+//---------------------------------------------------------------------------\n+#define Library\n+\n+// To add a file to the library use the Project menu 'Add to Project'.\n+"}, {"sha": "cbd31620d87b42a2b58f4cdb81741c10cdbb39bd", "filename": "zlib/contrib/delphi2/readme.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,17 @@\n+These are files used to compile zlib under Borland C++ Builder 3.\n+\n+zlib.bpg is the main project group that can be loaded in the BCB IDE and\n+loads all other *.bpr projects\n+\n+zlib.bpr is a project used to create a static zlib.lib library with C calling\n+convention for functions.\n+\n+zlib32.bpr creates a zlib32.dll dynamic link library with Windows standard\n+calling convention.\n+\n+d_zlib.bpr creates a set of .obj files with register calling convention.\n+These files are used by zlib.pas to create a Delphi unit containing zlib.\n+The d_zlib.lib file generated isn't useful and can be deleted.\n+\n+zlib.cpp, zlib32.cpp and d_zlib.cpp are used by the above projects.\n+"}, {"sha": "b6c9acdf8c90fd799ea414d64fc42324fe55e1f4", "filename": "zlib/contrib/delphi2/zlib.bpg", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,26 @@\n+#------------------------------------------------------------------------------\n+VERSION = BWS.01\n+#------------------------------------------------------------------------------\n+!ifndef ROOT\n+ROOT = $(MAKEDIR)\\..\n+!endif\n+#------------------------------------------------------------------------------\n+MAKE = $(ROOT)\\bin\\make.exe -$(MAKEFLAGS) -f$**\n+DCC = $(ROOT)\\bin\\dcc32.exe $**\n+BRCC = $(ROOT)\\bin\\brcc32.exe $**\n+#------------------------------------------------------------------------------\n+PROJECTS = zlib zlib32 d_zlib\n+#------------------------------------------------------------------------------\n+default: $(PROJECTS)\n+#------------------------------------------------------------------------------\n+\n+zlib: zlib.bpr\n+  $(MAKE)\n+\n+zlib32: zlib32.bpr\n+  $(MAKE)\n+\n+d_zlib: d_zlib.bpr\n+  $(MAKE)\n+\n+"}, {"sha": "cf3945b2523339928e570a643b1d866ecf15f6ba", "filename": "zlib/contrib/delphi2/zlib.bpr", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,225 @@\n+# ---------------------------------------------------------------------------\n+!if !$d(BCB)\n+BCB = $(MAKEDIR)\\..\n+!endif\n+\n+# ---------------------------------------------------------------------------\n+# IDE SECTION\n+# ---------------------------------------------------------------------------\n+# The following section of the project makefile is managed by the BCB IDE.\n+# It is recommended to use the IDE to change any of the values in this\n+# section.\n+# ---------------------------------------------------------------------------\n+\n+VERSION = BCB.03\n+# ---------------------------------------------------------------------------\n+PROJECT = zlib.lib\n+OBJFILES = zlib.obj adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \\\n+  infcodes.obj inffast.obj inflate.obj inftrees.obj infutil.obj trees.obj \\\n+  uncompr.obj zutil.obj\n+RESFILES =\n+RESDEPEN = $(RESFILES)\n+LIBFILES =\n+LIBRARIES = VCL35.lib\n+SPARELIBS = VCL35.lib\n+DEFFILE =\n+PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n+  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n+  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n+# ---------------------------------------------------------------------------\n+PATHCPP = .;\n+PATHASM = .;\n+PATHPAS = .;\n+PATHRC = .;\n+DEBUGLIBPATH = $(BCB)\\lib\\debug\n+RELEASELIBPATH = $(BCB)\\lib\\release\n+# ---------------------------------------------------------------------------\n+CFLAG1 = -O2 -Ve -d -k- -vi\n+CFLAG2 = -I$(BCB)\\include;$(BCB)\\include\\vcl -H=$(BCB)\\lib\\vcl35.csm\n+CFLAG3 = -ff -5\n+PFLAGS = -U;$(DEBUGLIBPATH) -I$(BCB)\\include;$(BCB)\\include\\vcl -H -W -$I- -v -JPHN -M\n+RFLAGS = -i$(BCB)\\include;$(BCB)\\include\\vcl \n+AFLAGS = /i$(BCB)\\include /i$(BCB)\\include\\vcl /mx /w2 /zn\n+LFLAGS =\n+IFLAGS = -g -Gn\n+# ---------------------------------------------------------------------------\n+ALLOBJ = c0w32.obj $(OBJFILES)\n+ALLRES = $(RESFILES)\n+ALLLIB = $(LIBFILES) $(LIBRARIES) import32.lib cp32mt.lib\n+# ---------------------------------------------------------------------------\n+!!ifdef IDEOPTIONS\n+\n+[Version Info]\n+IncludeVerInfo=0\n+AutoIncBuild=0\n+MajorVer=1\n+MinorVer=0\n+Release=0\n+Build=0\n+Debug=0\n+PreRelease=0\n+Special=0\n+Private=0\n+DLL=0\n+Locale=1040\n+CodePage=1252\n+\n+[Version Info Keys]\n+CompanyName=\n+FileDescription=\n+FileVersion=1.0.0.0\n+InternalName=\n+LegalCopyright=\n+LegalTrademarks=\n+OriginalFilename=\n+ProductName=\n+ProductVersion=1.0.0.0\n+Comments=\n+\n+[HistoryLists\\hlIncludePath]\n+Count=2\n+Item0=$(BCB)\\include\n+Item1=$(BCB)\\include;$(BCB)\\include\\vcl\n+\n+[HistoryLists\\hlLibraryPath]\n+Count=1\n+Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n+\n+[HistoryLists\\hlDebugSourcePath]\n+Count=1\n+Item0=$(BCB)\\source\\vcl\n+\n+[Debugging]\n+DebugSourceDirs=\n+\n+[Parameters]\n+RunParams=\n+HostApplication=\n+\n+!endif\n+\n+ ---------------------------------------------------------------------------\n+# MAKE SECTION\n+# ---------------------------------------------------------------------------\n+# This section of the project file is not used by the BCB IDE.  It is for\n+# the benefit of building from the command-line using the MAKE utility.\n+# ---------------------------------------------------------------------------\n+\n+.autodepend\n+# ---------------------------------------------------------------------------\n+!if !$d(BCC32)\n+BCC32 = bcc32\n+!endif\n+\n+!if !$d(DCC32)\n+DCC32 = dcc32\n+!endif\n+\n+!if !$d(TASM32)\n+TASM32 = tasm32\n+!endif\n+\n+!if !$d(LINKER)\n+LINKER = TLib\n+!endif\n+\n+!if !$d(BRCC32)\n+BRCC32 = brcc32\n+!endif\n+# ---------------------------------------------------------------------------\n+!if $d(PATHCPP)\n+.PATH.CPP = $(PATHCPP)\n+.PATH.C   = $(PATHCPP)\n+!endif\n+\n+!if $d(PATHPAS)\n+.PATH.PAS = $(PATHPAS)\n+!endif\n+\n+!if $d(PATHASM)\n+.PATH.ASM = $(PATHASM)\n+!endif\n+\n+!if $d(PATHRC)\n+.PATH.RC  = $(PATHRC)\n+!endif\n+# ---------------------------------------------------------------------------\n+!ifdef IDEOPTIONS\n+\n+[Version Info]\n+IncludeVerInfo=0\n+AutoIncBuild=0\n+MajorVer=1\n+MinorVer=0\n+Release=0\n+Build=0\n+Debug=0\n+PreRelease=0\n+Special=0\n+Private=0\n+DLL=0\n+Locale=1040\n+CodePage=1252\n+\n+[Version Info Keys]\n+CompanyName=\n+FileDescription=\n+FileVersion=1.0.0.0\n+InternalName=\n+LegalCopyright=\n+LegalTrademarks=\n+OriginalFilename=\n+ProductName=\n+ProductVersion=1.0.0.0\n+Comments=\n+\n+[HistoryLists\\hlIncludePath]\n+Count=2\n+Item0=$(BCB)\\include;$(BCB)\\include\\vcl\n+Item1=$(BCB)\\include\n+\n+[HistoryLists\\hlLibraryPath]\n+Count=1\n+Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n+\n+[HistoryLists\\hlDebugSourcePath]\n+Count=1\n+Item0=$(BCB)\\source\\vcl\n+\n+[Debugging]\n+DebugSourceDirs=\n+\n+[Parameters]\n+RunParams=\n+HostApplication=\n+\n+!endif\n+\n+$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n+    $(BCB)\\BIN\\$(LINKER) @&&!\n+    $(LFLAGS) $(IFLAGS) +\n+    $(ALLOBJ), +\n+    $(PROJECT),, +\n+    $(ALLLIB), +\n+    $(DEFFILE), +\n+    $(ALLRES)\n+!\n+# ---------------------------------------------------------------------------\n+.pas.hpp:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.pas.obj:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.cpp.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.c.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.asm.obj:\n+    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n+\n+.rc.res:\n+    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n+# ---------------------------------------------------------------------------"}, {"sha": "bf6953ba1985710b5b96db20abdf46d3c12c14d1", "filename": "zlib/contrib/delphi2/zlib.cpp", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,22 @@\n+#include <condefs.h>\n+#pragma hdrstop\n+//---------------------------------------------------------------------------\n+USEUNIT(\"adler32.c\");\n+USEUNIT(\"compress.c\");\n+USEUNIT(\"crc32.c\");\n+USEUNIT(\"deflate.c\");\n+USEUNIT(\"gzio.c\");\n+USEUNIT(\"infblock.c\");\n+USEUNIT(\"infcodes.c\");\n+USEUNIT(\"inffast.c\");\n+USEUNIT(\"inflate.c\");\n+USEUNIT(\"inftrees.c\");\n+USEUNIT(\"infutil.c\");\n+USEUNIT(\"trees.c\");\n+USEUNIT(\"uncompr.c\");\n+USEUNIT(\"zutil.c\");\n+//---------------------------------------------------------------------------\n+#define Library\n+\n+// To add a file to the library use the Project menu 'Add to Project'.\n+"}, {"sha": "10ae4cae2568638dfb9c250392da6f3700a5219e", "filename": "zlib/contrib/delphi2/zlib.pas", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,534 @@\n+{*******************************************************}\n+{                                                       }\n+{       Delphi Supplemental Components                  }\n+{       ZLIB Data Compression Interface Unit            }\n+{                                                       }\n+{       Copyright (c) 1997 Borland International        }\n+{                                                       }\n+{*******************************************************}\n+\n+{ Modified for zlib 1.1.3 by Davide Moretti <dave@rimini.com }\n+\n+unit zlib;\n+\n+interface\n+\n+uses Sysutils, Classes;\n+\n+type\n+  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer;\n+  TFree = procedure (AppData, Block: Pointer);\n+\n+  // Internal structure.  Ignore.\n+  TZStreamRec = packed record\n+    next_in: PChar;       // next input byte\n+    avail_in: Integer;    // number of bytes available at next_in\n+    total_in: Integer;    // total nb of input bytes read so far\n+\n+    next_out: PChar;      // next output byte should be put here\n+    avail_out: Integer;   // remaining free space at next_out\n+    total_out: Integer;   // total nb of bytes output so far\n+\n+    msg: PChar;           // last error message, NULL if no error\n+    internal: Pointer;    // not visible by applications\n+\n+    zalloc: TAlloc;       // used to allocate the internal state\n+    zfree: TFree;         // used to free the internal state\n+    AppData: Pointer;     // private data object passed to zalloc and zfree\n+\n+    data_type: Integer;   //  best guess about the data type: ascii or binary\n+    adler: Integer;       // adler32 value of the uncompressed data\n+    reserved: Integer;    // reserved for future use\n+  end;\n+\n+  // Abstract ancestor class\n+  TCustomZlibStream = class(TStream)\n+  private\n+    FStrm: TStream;\n+    FStrmPos: Integer;\n+    FOnProgress: TNotifyEvent;\n+    FZRec: TZStreamRec;\n+    FBuffer: array [Word] of Char;\n+  protected\n+    procedure Progress(Sender: TObject); dynamic;\n+    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;\n+    constructor Create(Strm: TStream);\n+  end;\n+\n+{ TCompressionStream compresses data on the fly as data is written to it, and\n+  stores the compressed data to another stream.\n+\n+  TCompressionStream is write-only and strictly sequential. Reading from the\n+  stream will raise an exception. Using Seek to move the stream pointer\n+  will raise an exception.\n+\n+  Output data is cached internally, written to the output stream only when\n+  the internal output buffer is full.  All pending output data is flushed\n+  when the stream is destroyed.\n+\n+  The Position property returns the number of uncompressed bytes of\n+  data that have been written to the stream so far.\n+\n+  CompressionRate returns the on-the-fly percentage by which the original\n+  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100\n+  If raw data size = 100 and compressed data size = 25, the CompressionRate\n+  is 75%\n+\n+  The OnProgress event is called each time the output buffer is filled and\n+  written to the output stream.  This is useful for updating a progress\n+  indicator when you are writing a large chunk of data to the compression\n+  stream in a single call.}\n+\n+\n+  TCompressionLevel = (clNone, clFastest, clDefault, clMax);\n+\n+  TCompressionStream = class(TCustomZlibStream)\n+  private\n+    function GetCompressionRate: Single;\n+  public\n+    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);\n+    destructor Destroy; override;\n+    function Read(var Buffer; Count: Longint): Longint; override;\n+    function Write(const Buffer; Count: Longint): Longint; override;\n+    function Seek(Offset: Longint; Origin: Word): Longint; override;\n+    property CompressionRate: Single read GetCompressionRate;\n+    property OnProgress;\n+  end;\n+\n+{ TDecompressionStream decompresses data on the fly as data is read from it.\n+\n+  Compressed data comes from a separate source stream.  TDecompressionStream\n+  is read-only and unidirectional; you can seek forward in the stream, but not\n+  backwards.  The special case of setting the stream position to zero is\n+  allowed.  Seeking forward decompresses data until the requested position in\n+  the uncompressed data has been reached.  Seeking backwards, seeking relative\n+  to the end of the stream, requesting the size of the stream, and writing to\n+  the stream will raise an exception.\n+\n+  The Position property returns the number of bytes of uncompressed data that\n+  have been read from the stream so far.\n+\n+  The OnProgress event is called each time the internal input buffer of\n+  compressed data is exhausted and the next block is read from the input stream.\n+  This is useful for updating a progress indicator when you are reading a\n+  large chunk of data from the decompression stream in a single call.}\n+\n+  TDecompressionStream = class(TCustomZlibStream)\n+  public\n+    constructor Create(Source: TStream);\n+    destructor Destroy; override;\n+    function Read(var Buffer; Count: Longint): Longint; override;\n+    function Write(const Buffer; Count: Longint): Longint; override;\n+    function Seek(Offset: Longint; Origin: Word): Longint; override;\n+    property OnProgress;\n+  end;\n+\n+\n+\n+{ CompressBuf compresses data, buffer to buffer, in one call.\n+   In: InBuf = ptr to compressed data\n+       InBytes = number of bytes in InBuf\n+  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n+       OutBytes = number of bytes in OutBuf   }\n+procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n+                      out OutBuf: Pointer; out OutBytes: Integer);\n+\n+\n+{ DecompressBuf decompresses data, buffer to buffer, in one call.\n+   In: InBuf = ptr to compressed data\n+       InBytes = number of bytes in InBuf\n+       OutEstimate = zero, or est. size of the decompressed data\n+  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n+       OutBytes = number of bytes in OutBuf   }\n+procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n+ OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n+\n+const\n+  zlib_version = '1.1.3';\n+\n+type\n+  EZlibError = class(Exception);\n+  ECompressionError = class(EZlibError);\n+  EDecompressionError = class(EZlibError);\n+\n+function adler32(adler: Integer; buf: PChar; len: Integer): Integer;\n+\n+implementation\n+\n+const\n+  Z_NO_FLUSH      = 0;\n+  Z_PARTIAL_FLUSH = 1;\n+  Z_SYNC_FLUSH    = 2;\n+  Z_FULL_FLUSH    = 3;\n+  Z_FINISH        = 4;\n+\n+  Z_OK            = 0;\n+  Z_STREAM_END    = 1;\n+  Z_NEED_DICT     = 2;\n+  Z_ERRNO         = (-1);\n+  Z_STREAM_ERROR  = (-2);\n+  Z_DATA_ERROR    = (-3);\n+  Z_MEM_ERROR     = (-4);\n+  Z_BUF_ERROR     = (-5);\n+  Z_VERSION_ERROR = (-6);\n+\n+  Z_NO_COMPRESSION       =   0;\n+  Z_BEST_SPEED           =   1;\n+  Z_BEST_COMPRESSION     =   9;\n+  Z_DEFAULT_COMPRESSION  = (-1);\n+\n+  Z_FILTERED            = 1;\n+  Z_HUFFMAN_ONLY        = 2;\n+  Z_DEFAULT_STRATEGY    = 0;\n+\n+  Z_BINARY   = 0;\n+  Z_ASCII    = 1;\n+  Z_UNKNOWN  = 2;\n+\n+  Z_DEFLATED = 8;\n+\n+  _z_errmsg: array[0..9] of PChar = (\n+    'need dictionary',      // Z_NEED_DICT      (2)\n+    'stream end',           // Z_STREAM_END     (1)\n+    '',                     // Z_OK             (0)\n+    'file error',           // Z_ERRNO          (-1)\n+    'stream error',         // Z_STREAM_ERROR   (-2)\n+    'data error',           // Z_DATA_ERROR     (-3)\n+    'insufficient memory',  // Z_MEM_ERROR      (-4)\n+    'buffer error',         // Z_BUF_ERROR      (-5)\n+    'incompatible version', // Z_VERSION_ERROR  (-6)\n+    ''\n+  );\n+\n+{$L deflate.obj}\n+{$L inflate.obj}\n+{$L inftrees.obj}\n+{$L trees.obj}\n+{$L adler32.obj}\n+{$L infblock.obj}\n+{$L infcodes.obj}\n+{$L infutil.obj}\n+{$L inffast.obj}\n+\n+procedure _tr_init; external;\n+procedure _tr_tally; external;\n+procedure _tr_flush_block; external;\n+procedure _tr_align; external;\n+procedure _tr_stored_block; external;\n+function adler32; external;\n+procedure inflate_blocks_new; external;\n+procedure inflate_blocks; external;\n+procedure inflate_blocks_reset; external;\n+procedure inflate_blocks_free; external;\n+procedure inflate_set_dictionary; external;\n+procedure inflate_trees_bits; external;\n+procedure inflate_trees_dynamic; external;\n+procedure inflate_trees_fixed; external;\n+procedure inflate_codes_new; external;\n+procedure inflate_codes; external;\n+procedure inflate_codes_free; external;\n+procedure _inflate_mask; external;\n+procedure inflate_flush; external;\n+procedure inflate_fast; external;\n+\n+procedure _memset(P: Pointer; B: Byte; count: Integer);cdecl;\n+begin\n+  FillChar(P^, count, B);\n+end;\n+\n+procedure _memcpy(dest, source: Pointer; count: Integer);cdecl;\n+begin\n+  Move(source^, dest^, count);\n+end;\n+\n+\n+\n+// deflate compresses data\n+function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;\n+  recsize: Integer): Integer; external;\n+function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n+function deflateEnd(var strm: TZStreamRec): Integer; external;\n+\n+// inflate decompresses data\n+function inflateInit_(var strm: TZStreamRec; version: PChar;\n+  recsize: Integer): Integer; external;\n+function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n+function inflateEnd(var strm: TZStreamRec): Integer; external;\n+function inflateReset(var strm: TZStreamRec): Integer; external;\n+\n+\n+function zcalloc(AppData: Pointer; Items, Size: Integer): Pointer;\n+begin\n+  GetMem(Result, Items*Size);\n+end;\n+\n+procedure zcfree(AppData, Block: Pointer);\n+begin\n+  FreeMem(Block);\n+end;\n+\n+function zlibCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise EZlibError.Create('error');    //!!\n+end;\n+\n+function CCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise ECompressionError.Create('error'); //!!\n+end;\n+\n+function DCheck(code: Integer): Integer;\n+begin\n+  Result := code;\n+  if code < 0 then\n+    raise EDecompressionError.Create('error');  //!!\n+end;\n+\n+procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n+                      out OutBuf: Pointer; out OutBytes: Integer);\n+var\n+  strm: TZStreamRec;\n+  P: Pointer;\n+begin\n+  FillChar(strm, sizeof(strm), 0);\n+  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;\n+  GetMem(OutBuf, OutBytes);\n+  try\n+    strm.next_in := InBuf;\n+    strm.avail_in := InBytes;\n+    strm.next_out := OutBuf;\n+    strm.avail_out := OutBytes;\n+    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));\n+    try\n+      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do\n+      begin\n+        P := OutBuf;\n+        Inc(OutBytes, 256);\n+        ReallocMem(OutBuf, OutBytes);\n+        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n+        strm.avail_out := 256;\n+      end;\n+    finally\n+      CCheck(deflateEnd(strm));\n+    end;\n+    ReallocMem(OutBuf, strm.total_out);\n+    OutBytes := strm.total_out;\n+  except\n+    FreeMem(OutBuf);\n+    raise\n+  end;\n+end;\n+\n+\n+procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n+  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n+var\n+  strm: TZStreamRec;\n+  P: Pointer;\n+  BufInc: Integer;\n+begin\n+  FillChar(strm, sizeof(strm), 0);\n+  BufInc := (InBytes + 255) and not 255;\n+  if OutEstimate = 0 then\n+    OutBytes := BufInc\n+  else\n+    OutBytes := OutEstimate;\n+  GetMem(OutBuf, OutBytes);\n+  try\n+    strm.next_in := InBuf;\n+    strm.avail_in := InBytes;\n+    strm.next_out := OutBuf;\n+    strm.avail_out := OutBytes;\n+    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));\n+    try\n+      while DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END do\n+      begin\n+        P := OutBuf;\n+        Inc(OutBytes, BufInc);\n+        ReallocMem(OutBuf, OutBytes);\n+        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n+        strm.avail_out := BufInc;\n+      end;\n+    finally\n+      DCheck(inflateEnd(strm));\n+    end;\n+    ReallocMem(OutBuf, strm.total_out);\n+    OutBytes := strm.total_out;\n+  except\n+    FreeMem(OutBuf);\n+    raise\n+  end;\n+end;\n+\n+\n+// TCustomZlibStream\n+\n+constructor TCustomZLibStream.Create(Strm: TStream);\n+begin\n+  inherited Create;\n+  FStrm := Strm;\n+  FStrmPos := Strm.Position;\n+end;\n+\n+procedure TCustomZLibStream.Progress(Sender: TObject);\n+begin\n+  if Assigned(FOnProgress) then FOnProgress(Sender);\n+end;\n+\n+\n+// TCompressionStream\n+\n+constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;\n+  Dest: TStream);\n+const\n+  Levels: array [TCompressionLevel] of ShortInt =\n+    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);\n+begin\n+  inherited Create(Dest);\n+  FZRec.next_out := FBuffer;\n+  FZRec.avail_out := sizeof(FBuffer);\n+  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));\n+end;\n+\n+destructor TCompressionStream.Destroy;\n+begin\n+  FZRec.next_in := nil;\n+  FZRec.avail_in := 0;\n+  try\n+    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)\n+      and (FZRec.avail_out = 0) do\n+    begin\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n+      FZRec.next_out := FBuffer;\n+      FZRec.avail_out := sizeof(FBuffer);\n+    end;\n+    if FZRec.avail_out < sizeof(FBuffer) then\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);\n+  finally\n+    deflateEnd(FZRec);\n+  end;\n+  inherited Destroy;\n+end;\n+\n+function TCompressionStream.Read(var Buffer; Count: Longint): Longint;\n+begin\n+  raise ECompressionError.Create('Invalid stream operation');\n+end;\n+\n+function TCompressionStream.Write(const Buffer; Count: Longint): Longint;\n+begin\n+  FZRec.next_in := @Buffer;\n+  FZRec.avail_in := Count;\n+  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+  while (FZRec.avail_in > 0) do\n+  begin\n+    CCheck(deflate(FZRec, 0));\n+    if FZRec.avail_out = 0 then\n+    begin\n+      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n+      FZRec.next_out := FBuffer;\n+      FZRec.avail_out := sizeof(FBuffer);\n+      FStrmPos := FStrm.Position;\n+      Progress(Self);\n+    end;\n+  end;\n+  Result := Count;\n+end;\n+\n+function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n+begin\n+  if (Offset = 0) and (Origin = soFromCurrent) then\n+    Result := FZRec.total_in\n+  else\n+    raise ECompressionError.Create('Invalid stream operation');\n+end;\n+\n+function TCompressionStream.GetCompressionRate: Single;\n+begin\n+  if FZRec.total_in = 0 then\n+    Result := 0\n+  else\n+    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;\n+end;\n+\n+\n+// TDecompressionStream\n+\n+constructor TDecompressionStream.Create(Source: TStream);\n+begin\n+  inherited Create(Source);\n+  FZRec.next_in := FBuffer;\n+  FZRec.avail_in := 0;\n+  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));\n+end;\n+\n+destructor TDecompressionStream.Destroy;\n+begin\n+  inflateEnd(FZRec);\n+  inherited Destroy;\n+end;\n+\n+function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;\n+begin\n+  FZRec.next_out := @Buffer;\n+  FZRec.avail_out := Count;\n+  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n+  while (FZRec.avail_out > 0) do\n+  begin\n+    if FZRec.avail_in = 0 then\n+    begin\n+      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));\n+      if FZRec.avail_in = 0 then\n+        begin\n+          Result := Count - FZRec.avail_out;\n+          Exit;\n+        end;\n+      FZRec.next_in := FBuffer;\n+      FStrmPos := FStrm.Position;\n+      Progress(Self);\n+    end;\n+    DCheck(inflate(FZRec, 0));\n+  end;\n+  Result := Count;\n+end;\n+\n+function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;\n+begin\n+  raise EDecompressionError.Create('Invalid stream operation');\n+end;\n+\n+function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n+var\n+  I: Integer;\n+  Buf: array [0..4095] of Char;\n+begin\n+  if (Offset = 0) and (Origin = soFromBeginning) then\n+  begin\n+    DCheck(inflateReset(FZRec));\n+    FZRec.next_in := FBuffer;\n+    FZRec.avail_in := 0;\n+    FStrm.Position := 0;\n+    FStrmPos := 0;\n+  end\n+  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or\n+          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then\n+  begin\n+    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);\n+    if Offset > 0 then\n+    begin\n+      for I := 1 to Offset div sizeof(Buf) do\n+        ReadBuffer(Buf, sizeof(Buf));\n+      ReadBuffer(Buf, Offset mod sizeof(Buf));\n+    end;\n+  end\n+  else\n+    raise EDecompressionError.Create('Invalid stream operation');\n+  Result := FZRec.total_out;\n+end;\n+\n+end."}, {"sha": "cabcec449474e2df0e805fc22375021126d355df", "filename": "zlib/contrib/delphi2/zlib32.bpr", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,174 @@\n+# ---------------------------------------------------------------------------\n+!if !$d(BCB)\n+BCB = $(MAKEDIR)\\..\n+!endif\n+\n+# ---------------------------------------------------------------------------\n+# IDE SECTION\n+# ---------------------------------------------------------------------------\n+# The following section of the project makefile is managed by the BCB IDE.\n+# It is recommended to use the IDE to change any of the values in this\n+# section.\n+# ---------------------------------------------------------------------------\n+\n+VERSION = BCB.03\n+# ---------------------------------------------------------------------------\n+PROJECT = zlib32.dll\n+OBJFILES = zlib32.obj adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \\\n+  infcodes.obj inffast.obj inflate.obj inftrees.obj infutil.obj trees.obj \\\n+  uncompr.obj zutil.obj\n+RESFILES =\n+RESDEPEN = $(RESFILES)\n+LIBFILES =\n+LIBRARIES = \n+SPARELIBS = \n+DEFFILE =\n+PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n+  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n+  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n+# ---------------------------------------------------------------------------\n+PATHCPP = .;\n+PATHASM = .;\n+PATHPAS = .;\n+PATHRC = .;\n+DEBUGLIBPATH = $(BCB)\\lib\\debug\n+RELEASELIBPATH = $(BCB)\\lib\\release\n+# ---------------------------------------------------------------------------\n+CFLAG1 = -WD -O2 -Ve -d -k- -vi -c -tWD\n+CFLAG2 = -D_NO_VCL;ZLIB_DLL -I$(BCB)\\include\n+CFLAG3 = -ff -5\n+PFLAGS = -D_NO_VCL;ZLIB_DLL -U$(BCB)\\lib;$(RELEASELIBPATH) -I$(BCB)\\include -$I- -v \\\n+  -JPHN -M\n+RFLAGS = -D_NO_VCL;ZLIB_DLL -i$(BCB)\\include\n+AFLAGS = /i$(BCB)\\include /d_NO_VCL /dZLIB_DLL /mx /w2 /zn\n+LFLAGS = -L$(BCB)\\lib;$(RELEASELIBPATH) -aa -Tpd -x -Gi\n+IFLAGS = -Gn -g\n+# ---------------------------------------------------------------------------\n+ALLOBJ = c0d32.obj $(OBJFILES)\n+ALLRES = $(RESFILES)\n+ALLLIB = $(LIBFILES)  import32.lib cw32mt.lib\n+# ---------------------------------------------------------------------------\n+!ifdef IDEOPTIONS\n+\n+[Version Info]\n+IncludeVerInfo=0\n+AutoIncBuild=0\n+MajorVer=1\n+MinorVer=0\n+Release=0\n+Build=0\n+Debug=0\n+PreRelease=0\n+Special=0\n+Private=0\n+DLL=1\n+Locale=1040\n+CodePage=1252\n+\n+[Version Info Keys]\n+CompanyName=\n+FileDescription=DLL (GUI)\n+FileVersion=1.0.0.0\n+InternalName=\n+LegalCopyright=\n+LegalTrademarks=\n+OriginalFilename=\n+ProductName=\n+ProductVersion=1.0.0.0\n+Comments=\n+\n+[HistoryLists\\hlIncludePath]\n+Count=1\n+Item0=$(BCB)\\include\n+\n+[HistoryLists\\hlLibraryPath]\n+Count=1\n+Item0=$(BCB)\\lib\n+\n+[HistoryLists\\hlConditionals]\n+Count=1\n+Item0=_NO_VCL;ZLIB_DLL\n+\n+[Debugging]\n+DebugSourceDirs=\n+\n+[Parameters]\n+RunParams=\n+HostApplication=\n+\n+!endif\n+\n+# ---------------------------------------------------------------------------\n+# MAKE SECTION\n+# ---------------------------------------------------------------------------\n+# This section of the project file is not used by the BCB IDE.  It is for\n+# the benefit of building from the command-line using the MAKE utility.\n+# ---------------------------------------------------------------------------\n+\n+.autodepend\n+# ---------------------------------------------------------------------------\n+!if !$d(BCC32)\n+BCC32 = bcc32\n+!endif\n+\n+!if !$d(DCC32)\n+DCC32 = dcc32\n+!endif\n+\n+!if !$d(TASM32)\n+TASM32 = tasm32\n+!endif\n+\n+!if !$d(LINKER)\n+LINKER = ilink32\n+!endif\n+\n+!if !$d(BRCC32)\n+BRCC32 = brcc32\n+!endif\n+# ---------------------------------------------------------------------------\n+!if $d(PATHCPP)\n+.PATH.CPP = $(PATHCPP)\n+.PATH.C   = $(PATHCPP)\n+!endif\n+\n+!if $d(PATHPAS)\n+.PATH.PAS = $(PATHPAS)\n+!endif\n+\n+!if $d(PATHASM)\n+.PATH.ASM = $(PATHASM)\n+!endif\n+\n+!if $d(PATHRC)\n+.PATH.RC  = $(PATHRC)\n+!endif\n+# ---------------------------------------------------------------------------\n+$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n+    $(BCB)\\BIN\\$(LINKER) @&&!\n+    $(LFLAGS) $(IFLAGS) +\n+    $(ALLOBJ), +\n+    $(PROJECT),, +\n+    $(ALLLIB), +\n+    $(DEFFILE), +\n+    $(ALLRES)\n+!\n+# ---------------------------------------------------------------------------\n+.pas.hpp:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.pas.obj:\n+    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n+\n+.cpp.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.c.obj:\n+    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n+\n+.asm.obj:\n+    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n+\n+.rc.res:\n+    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n+# ---------------------------------------------------------------------------"}, {"sha": "7372f6b985f8d57538fca6bc0520f759c1f868f6", "filename": "zlib/contrib/delphi2/zlib32.cpp", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,42 @@\n+\n+#include <windows.h>\n+#pragma hdrstop\n+#include <condefs.h>\n+\n+\n+//---------------------------------------------------------------------------\n+//   Important note about DLL memory management in a VCL DLL:\n+//\n+//\n+//\n+// If your DLL uses VCL and exports any functions that pass VCL String objects\n+// (or structs/classes containing nested Strings) as parameter or function\n+// results, you will need to build both your DLL project and any EXE projects\n+// that use your DLL with the dynamic RTL (the RTL DLL).  This will change your\n+// DLL and its calling EXE's to use BORLNDMM.DLL as their memory manager. In\n+// these cases, the file BORLNDMM.DLL should be deployed along with your DLL\n+// and the RTL DLL (CP3240MT.DLL). To avoid the requiring BORLNDMM.DLL in\n+// these situations, pass string information using \"char *\" or ShortString\n+// parameters and then link with the static RTL.\n+//\n+//---------------------------------------------------------------------------\n+USEUNIT(\"adler32.c\");\n+USEUNIT(\"compress.c\");\n+USEUNIT(\"crc32.c\");\n+USEUNIT(\"deflate.c\");\n+USEUNIT(\"gzio.c\");\n+USEUNIT(\"infblock.c\");\n+USEUNIT(\"infcodes.c\");\n+USEUNIT(\"inffast.c\");\n+USEUNIT(\"inflate.c\");\n+USEUNIT(\"inftrees.c\");\n+USEUNIT(\"infutil.c\");\n+USEUNIT(\"trees.c\");\n+USEUNIT(\"uncompr.c\");\n+USEUNIT(\"zutil.c\");\n+//---------------------------------------------------------------------------\n+#pragma argsused\n+int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void*)\n+{\n+        return 1;\n+}"}, {"sha": "7d265b3b5c0e017bfa7270b766d5354feddf1c4d", "filename": "zlib/contrib/iostream/test.cpp", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Ftest.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Ftest.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream%2Ftest.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,24 @@\n+\n+#include \"zfstream.h\"\n+\n+int main() {\n+\n+  // Construct a stream object with this filebuffer.  Anything sent\n+  // to this stream will go to standard out.\n+  gzofstream os( 1, ios::out );\n+\n+  // This text is getting compressed and sent to stdout.\n+  // To prove this, run 'test | zcat'.\n+  os << \"Hello, Mommy\" << endl;\n+\n+  os << setcompressionlevel( Z_NO_COMPRESSION );\n+  os << \"hello, hello, hi, ho!\" << endl;\n+\n+  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )\n+    << \"I'm compressing again\" << endl;\n+\n+  os.close();\n+\n+  return 0;\n+\n+}"}, {"sha": "a690bbefceb4183dff61c11138386b8bc28306b6", "filename": "zlib/contrib/iostream/zfstream.cpp", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,329 @@\n+\n+#include <memory.h>\n+#include \"zfstream.h\"\n+\n+gzfilebuf::gzfilebuf() :\n+  file(NULL),\n+  mode(0),\n+  own_file_descriptor(0)\n+{ }\n+\n+gzfilebuf::~gzfilebuf() {\n+\n+  sync();\n+  if ( own_file_descriptor )\n+    close();\n+\n+}\n+\n+gzfilebuf *gzfilebuf::open( const char *name,\n+\t\t\t    int io_mode ) {\n+\n+  if ( is_open() )\n+    return NULL;\n+\n+  char char_mode[10];\n+  char *p;\n+  memset(char_mode,'\\0',10);\n+  p = char_mode;\n+\n+  if ( io_mode & ios::in ) {\n+    mode = ios::in;\n+    *p++ = 'r';\n+  } else if ( io_mode & ios::app ) {\n+    mode = ios::app;\n+    *p++ = 'a';\n+  } else {\n+    mode = ios::out;\n+    *p++ = 'w';\n+  }\n+\n+  if ( io_mode & ios::binary ) {\n+    mode |= ios::binary;\n+    *p++ = 'b';\n+  }\n+\n+  // Hard code the compression level\n+  if ( io_mode & (ios::out|ios::app )) {\n+    *p++ = '9';\n+  }\n+\n+  if ( (file = gzopen(name, char_mode)) == NULL )\n+    return NULL;\n+\n+  own_file_descriptor = 1;\n+\n+  return this;\n+\n+}\n+\n+gzfilebuf *gzfilebuf::attach( int file_descriptor,\n+\t\t\t      int io_mode ) {\n+\n+  if ( is_open() )\n+    return NULL;\n+\n+  char char_mode[10];\n+  char *p;\n+  memset(char_mode,'\\0',10);\n+  p = char_mode;\n+\n+  if ( io_mode & ios::in ) {\n+    mode = ios::in;\n+    *p++ = 'r';\n+  } else if ( io_mode & ios::app ) {\n+    mode = ios::app;\n+    *p++ = 'a';\n+  } else {\n+    mode = ios::out;\n+    *p++ = 'w';\n+  }\n+\n+  if ( io_mode & ios::binary ) {\n+    mode |= ios::binary;\n+    *p++ = 'b';\n+  }\n+\n+  // Hard code the compression level\n+  if ( io_mode & (ios::out|ios::app )) {\n+    *p++ = '9';\n+  }\n+\n+  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )\n+    return NULL;\n+\n+  own_file_descriptor = 0;\n+\n+  return this;\n+\n+}\n+\n+gzfilebuf *gzfilebuf::close() {\n+\n+  if ( is_open() ) {\n+\n+    sync();\n+    gzclose( file );\n+    file = NULL;\n+\n+  }\n+\n+  return this;\n+\n+}\n+\n+int gzfilebuf::setcompressionlevel( short comp_level ) {\n+\n+  return gzsetparams(file, comp_level, -2);\n+\n+}\n+\n+int gzfilebuf::setcompressionstrategy( short comp_strategy ) {\n+\n+  return gzsetparams(file, -2, comp_strategy);\n+\n+}\n+\n+\n+streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {\n+\n+  return streampos(EOF);\n+\n+}\n+\n+int gzfilebuf::underflow() {\n+\n+  // If the file hasn't been opened for reading, error.\n+  if ( !is_open() || !(mode & ios::in) )\n+    return EOF;\n+\n+  // if a buffer doesn't exists, allocate one.\n+  if ( !base() ) {\n+\n+    if ( (allocate()) == EOF )\n+      return EOF;\n+    setp(0,0);\n+\n+  } else {\n+\n+    if ( in_avail() )\n+      return (unsigned char) *gptr();\n+\n+    if ( out_waiting() ) {\n+      if ( flushbuf() == EOF )\n+\treturn EOF;\n+    }\n+\n+  }\n+\n+  // Attempt to fill the buffer.\n+\n+  int result = fillbuf();\n+  if ( result == EOF ) {\n+    // disable get area\n+    setg(0,0,0);\n+    return EOF;\n+  }\n+\n+  return (unsigned char) *gptr();\n+\n+}\n+\n+int gzfilebuf::overflow( int c ) {\n+\n+  if ( !is_open() || !(mode & ios::out) )\n+    return EOF;\n+\n+  if ( !base() ) {\n+    if ( allocate() == EOF )\n+      return EOF;\n+    setg(0,0,0);\n+  } else {\n+    if (in_avail()) {\n+\treturn EOF;\n+    }\n+    if (out_waiting()) {\n+      if (flushbuf() == EOF)\n+\treturn EOF;\n+    }\n+  }\n+\n+  int bl = blen();\n+  setp( base(), base() + bl);\n+\n+  if ( c != EOF ) {\n+\n+    *pptr() = c;\n+    pbump(1);\n+\n+  }\n+\n+  return 0;\n+\n+}\n+\n+int gzfilebuf::sync() {\n+\n+  if ( !is_open() )\n+    return EOF;\n+\n+  if ( out_waiting() )\n+    return flushbuf();\n+\n+  return 0;\n+\n+}\n+\n+int gzfilebuf::flushbuf() {\n+\n+  int n;\n+  char *q;\n+\n+  q = pbase();\n+  n = pptr() - q;\n+\n+  if ( gzwrite( file, q, n) < n )\n+    return EOF;\n+\n+  setp(0,0);\n+\n+  return 0;\n+\n+}\n+\n+int gzfilebuf::fillbuf() {\n+\n+  int required;\n+  char *p;\n+\n+  p = base();\n+\n+  required = blen();\n+\n+  int t = gzread( file, p, required );\n+\n+  if ( t <= 0) return EOF;\n+\n+  setg( base(), base(), base()+t);\n+\n+  return t;\n+\n+}\n+\n+gzfilestream_common::gzfilestream_common() :\n+  ios( gzfilestream_common::rdbuf() )\n+{ }\n+\n+gzfilestream_common::~gzfilestream_common()\n+{ }\n+\n+void gzfilestream_common::attach( int fd, int io_mode ) {\n+\n+  if ( !buffer.attach( fd, io_mode) )\n+    clear( ios::failbit | ios::badbit );\n+  else\n+    clear();\n+\n+}\n+\n+void gzfilestream_common::open( const char *name, int io_mode ) {\n+\n+  if ( !buffer.open( name, io_mode ) )\n+    clear( ios::failbit | ios::badbit );\n+  else\n+    clear();\n+\n+}\n+\n+void gzfilestream_common::close() {\n+\n+  if ( !buffer.close() )\n+    clear( ios::failbit | ios::badbit );\n+\n+}\n+\n+gzfilebuf *gzfilestream_common::rdbuf() {\n+\n+  return &buffer;\n+\n+}\n+     \n+gzifstream::gzifstream() :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  clear( ios::badbit );\n+}\n+\n+gzifstream::gzifstream( const char *name, int io_mode ) :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  gzfilestream_common::open( name, io_mode );\n+}\n+\n+gzifstream::gzifstream( int fd, int io_mode ) :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  gzfilestream_common::attach( fd, io_mode );\n+}\n+\n+gzifstream::~gzifstream() { }\n+\n+gzofstream::gzofstream() :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  clear( ios::badbit );\n+}\n+\n+gzofstream::gzofstream( const char *name, int io_mode ) :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  gzfilestream_common::open( name, io_mode );\n+}\n+\n+gzofstream::gzofstream( int fd, int io_mode ) :\n+  ios( gzfilestream_common::rdbuf() )\n+{\n+  gzfilestream_common::attach( fd, io_mode );\n+}\n+\n+gzofstream::~gzofstream() { }"}, {"sha": "c87fa08e9d1b2c6bc6cc9206c0f6e8a3ca5825b3", "filename": "zlib/contrib/iostream/zfstream.h", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Fzfstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream%2Fzfstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream%2Fzfstream.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,142 @@\n+\n+#ifndef _zfstream_h\n+#define _zfstream_h\n+\n+#include <fstream.h>\n+#include \"zlib.h\"\n+\n+class gzfilebuf : public streambuf {\n+\n+public:\n+\n+  gzfilebuf( );\n+  virtual ~gzfilebuf();\n+\n+  gzfilebuf *open( const char *name, int io_mode );\n+  gzfilebuf *attach( int file_descriptor, int io_mode );\n+  gzfilebuf *close();\n+\n+  int setcompressionlevel( short comp_level );\n+  int setcompressionstrategy( short comp_strategy );\n+\n+  inline int is_open() const { return (file !=NULL); }\n+\n+  virtual streampos seekoff( streamoff, ios::seek_dir, int );\n+\n+  virtual int sync();\n+\n+protected:\n+\n+  virtual int underflow();\n+  virtual int overflow( int = EOF );\n+\n+private:\n+\n+  gzFile file;\n+  short mode;\n+  short own_file_descriptor;\n+\n+  int flushbuf();\n+  int fillbuf();\n+\n+};\n+\n+class gzfilestream_common : virtual public ios {\n+\n+  friend class gzifstream;\n+  friend class gzofstream;\n+  friend gzofstream &setcompressionlevel( gzofstream &, int );\n+  friend gzofstream &setcompressionstrategy( gzofstream &, int );\n+\n+public:\n+  virtual ~gzfilestream_common();\n+\n+  void attach( int fd, int io_mode );\n+  void open( const char *name, int io_mode );\n+  void close();\n+\n+protected:\n+  gzfilestream_common();\n+\n+private:\n+  gzfilebuf *rdbuf();\n+\n+  gzfilebuf buffer;\n+\n+};\n+\n+class gzifstream : public gzfilestream_common, public istream {\n+\n+public:\n+\n+  gzifstream();\n+  gzifstream( const char *name, int io_mode = ios::in );\n+  gzifstream( int fd, int io_mode = ios::in );\n+\n+  virtual ~gzifstream();\n+\n+};\n+\n+class gzofstream : public gzfilestream_common, public ostream {\n+\n+public:\n+\n+  gzofstream();\n+  gzofstream( const char *name, int io_mode = ios::out );\n+  gzofstream( int fd, int io_mode = ios::out );\n+\n+  virtual ~gzofstream();\n+\n+};\n+\n+template<class T> class gzomanip {\n+  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);\n+public:\n+  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }\n+private:\n+  gzofstream &(*func)(gzofstream &, T);\n+  T val;\n+};\n+\n+template<class T> gzofstream &operator<<(gzofstream &s,\n+\t\t\t\t\t const gzomanip<T> &m) {\n+  return (*m.func)(s, m.val);\n+  \n+}\n+\n+inline gzofstream &setcompressionlevel( gzofstream &s, int l ) {\n+  (s.rdbuf())->setcompressionlevel(l);\n+  return s;\n+}\n+\n+inline gzofstream &setcompressionstrategy( gzofstream &s, int l ) {\n+  (s.rdbuf())->setcompressionstrategy(l);\n+  return s;\n+}\n+\n+inline gzomanip<int> setcompressionlevel(int l)\n+{\n+  return gzomanip<int>(&setcompressionlevel,l);\n+}\n+\n+inline gzomanip<int> setcompressionstrategy(int l)\n+{\n+  return gzomanip<int>(&setcompressionstrategy,l);\n+}\n+\n+#endif\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "43d2332b79b70bb8ead6d84838e6841e349ec818", "filename": "zlib/contrib/iostream2/zstream.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream2%2Fzstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream2%2Fzstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream2%2Fzstream.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,307 @@\n+/*\n+ *\n+ * Copyright (c) 1997\n+ * Christian Michelsen Research AS\n+ * Advanced Computing\n+ * Fantoftvegen 38, 5036 BERGEN, Norway\n+ * http://www.cmr.no\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Christian Michelsen Research AS makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef ZSTREAM__H\n+#define ZSTREAM__H\n+\n+/*\n+ * zstream.h - C++ interface to the 'zlib' general purpose compression library\n+ * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $\n+ */\n+\n+#include <strstream.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include \"zlib.h\"\n+\n+#if defined(_WIN32)\n+#   include <fcntl.h>\n+#   include <io.h>\n+#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n+#else\n+#   define SET_BINARY_MODE(file)\n+#endif\n+\n+class zstringlen {\n+public:\n+    zstringlen(class izstream&);\n+    zstringlen(class ozstream&, const char*);\n+    size_t value() const { return val.word; }\n+private:\n+    struct Val { unsigned char byte; size_t word; } val;\n+};\n+\n+//  ----------------------------- izstream -----------------------------\n+\n+class izstream\n+{\n+    public:\n+        izstream() : m_fp(0) {}\n+        izstream(FILE* fp) : m_fp(0) { open(fp); }\n+        izstream(const char* name) : m_fp(0) { open(name); }\n+        ~izstream() { close(); }\n+\n+        /* Opens a gzip (.gz) file for reading.\n+         * open() can be used to read a file which is not in gzip format;\n+         * in this case read() will directly read from the file without\n+         * decompression. errno can be checked to distinguish two error\n+         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).\n+         */\n+        void open(const char* name) {\n+            if (m_fp) close();\n+            m_fp = ::gzopen(name, \"rb\");\n+        }\n+\n+        void open(FILE* fp) {\n+            SET_BINARY_MODE(fp);\n+            if (m_fp) close();\n+            m_fp = ::gzdopen(fileno(fp), \"rb\");\n+        }\n+\n+        /* Flushes all pending input if necessary, closes the compressed file\n+         * and deallocates all the (de)compression state. The return value is\n+         * the zlib error number (see function error() below).\n+         */\n+        int close() {\n+            int r = ::gzclose(m_fp);\n+            m_fp = 0; return r;\n+        }\n+\n+        /* Binary read the given number of bytes from the compressed file.\n+         */\n+        int read(void* buf, size_t len) {\n+            return ::gzread(m_fp, buf, len);\n+        }\n+\n+        /* Returns the error message for the last error which occurred on the\n+         * given compressed file. errnum is set to zlib error number. If an\n+         * error occurred in the file system and not in the compression library,\n+         * errnum is set to Z_ERRNO and the application may consult errno\n+         * to get the exact error code.\n+         */\n+        const char* error(int* errnum) {\n+            return ::gzerror(m_fp, errnum);\n+        }\n+\n+        gzFile fp() { return m_fp; }\n+\n+    private:\n+        gzFile m_fp;\n+};\n+\n+/*\n+ * Binary read the given (array of) object(s) from the compressed file.\n+ * If the input file was not in gzip format, read() copies the objects number\n+ * of bytes into the buffer.\n+ * returns the number of uncompressed bytes actually read\n+ * (0 for end of file, -1 for error).\n+ */\n+template <class T, class Items>\n+inline int read(izstream& zs, T* x, Items items) {\n+    return ::gzread(zs.fp(), x, items*sizeof(T));\n+}\n+\n+/*\n+ * Binary input with the '>' operator.\n+ */\n+template <class T>\n+inline izstream& operator>(izstream& zs, T& x) {\n+    ::gzread(zs.fp(), &x, sizeof(T));\n+    return zs;\n+}\n+\n+\n+inline zstringlen::zstringlen(izstream& zs) {\n+    zs > val.byte;\n+    if (val.byte == 255) zs > val.word;\n+    else val.word = val.byte;\n+}\n+\n+/*\n+ * Read length of string + the string with the '>' operator.\n+ */\n+inline izstream& operator>(izstream& zs, char* x) {\n+    zstringlen len(zs);\n+    ::gzread(zs.fp(), x, len.value());\n+    x[len.value()] = '\\0';\n+    return zs;\n+}\n+\n+inline char* read_string(izstream& zs) {\n+    zstringlen len(zs);\n+    char* x = new char[len.value()+1];\n+    ::gzread(zs.fp(), x, len.value());\n+    x[len.value()] = '\\0';\n+    return x;\n+}\n+\n+// ----------------------------- ozstream -----------------------------\n+\n+class ozstream\n+{\n+    public:\n+        ozstream() : m_fp(0), m_os(0) {\n+        }\n+        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)\n+            : m_fp(0), m_os(0) {\n+            open(fp, level);\n+        }\n+        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)\n+            : m_fp(0), m_os(0) {\n+            open(name, level);\n+        }\n+        ~ozstream() {\n+            close();\n+        }\n+\n+        /* Opens a gzip (.gz) file for writing.\n+         * The compression level parameter should be in 0..9\n+         * errno can be checked to distinguish two error cases\n+         * (if errno is zero, the zlib error is Z_MEM_ERROR).\n+         */\n+        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {\n+            char mode[4] = \"wb\\0\";\n+            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n+            if (m_fp) close();\n+            m_fp = ::gzopen(name, mode);\n+        }\n+\n+        /* open from a FILE pointer.\n+         */\n+        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {\n+            SET_BINARY_MODE(fp);\n+            char mode[4] = \"wb\\0\";\n+            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n+            if (m_fp) close();\n+            m_fp = ::gzdopen(fileno(fp), mode);\n+        }\n+\n+        /* Flushes all pending output if necessary, closes the compressed file\n+         * and deallocates all the (de)compression state. The return value is\n+         * the zlib error number (see function error() below).\n+         */\n+        int close() {\n+            if (m_os) {\n+                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n+                delete[] m_os->str(); delete m_os; m_os = 0;\n+            }\n+            int r = ::gzclose(m_fp); m_fp = 0; return r;\n+        }\n+\n+        /* Binary write the given number of bytes into the compressed file.\n+         */\n+        int write(const void* buf, size_t len) {\n+            return ::gzwrite(m_fp, (voidp) buf, len);\n+        }\n+\n+        /* Flushes all pending output into the compressed file. The parameter\n+         * _flush is as in the deflate() function. The return value is the zlib\n+         * error number (see function gzerror below). flush() returns Z_OK if\n+         * the flush_ parameter is Z_FINISH and all output could be flushed.\n+         * flush() should be called only when strictly necessary because it can\n+         * degrade compression.\n+         */\n+        int flush(int _flush) {\n+            os_flush();\n+            return ::gzflush(m_fp, _flush);\n+        }\n+\n+        /* Returns the error message for the last error which occurred on the\n+         * given compressed file. errnum is set to zlib error number. If an\n+         * error occurred in the file system and not in the compression library,\n+         * errnum is set to Z_ERRNO and the application may consult errno\n+         * to get the exact error code.\n+         */\n+        const char* error(int* errnum) {\n+            return ::gzerror(m_fp, errnum);\n+        }\n+\n+        gzFile fp() { return m_fp; }\n+\n+        ostream& os() {\n+            if (m_os == 0) m_os = new ostrstream;\n+            return *m_os;\n+        }\n+\n+        void os_flush() {\n+            if (m_os && m_os->pcount()>0) {\n+                ostrstream* oss = new ostrstream;\n+                oss->fill(m_os->fill());\n+                oss->flags(m_os->flags());\n+                oss->precision(m_os->precision());\n+                oss->width(m_os->width());\n+                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n+                delete[] m_os->str(); delete m_os; m_os = oss;\n+            }\n+        }\n+\n+    private:\n+        gzFile m_fp;\n+        ostrstream* m_os;\n+};\n+\n+/*\n+ * Binary write the given (array of) object(s) into the compressed file.\n+ * returns the number of uncompressed bytes actually written\n+ * (0 in case of error).\n+ */\n+template <class T, class Items>\n+inline int write(ozstream& zs, const T* x, Items items) {\n+    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));\n+}\n+\n+/*\n+ * Binary output with the '<' operator.\n+ */\n+template <class T>\n+inline ozstream& operator<(ozstream& zs, const T& x) {\n+    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));\n+    return zs;\n+}\n+\n+inline zstringlen::zstringlen(ozstream& zs, const char* x) {\n+    val.byte = 255;  val.word = ::strlen(x);\n+    if (val.word < 255) zs < (val.byte = val.word);\n+    else zs < val;\n+}\n+\n+/*\n+ * Write length of string + the string with the '<' operator.\n+ */\n+inline ozstream& operator<(ozstream& zs, const char* x) {\n+    zstringlen len(zs, x);\n+    ::gzwrite(zs.fp(), (voidp) x, len.value());\n+    return zs;\n+}\n+\n+#ifdef _MSC_VER\n+inline ozstream& operator<(ozstream& zs, char* const& x) {\n+    return zs < (const char*) x;\n+}\n+#endif\n+\n+/*\n+ * Ascii write with the << operator;\n+ */\n+template <class T>\n+inline ostream& operator<<(ozstream& zs, const T& x) {\n+    zs.os_flush();\n+    return zs.os() << x;\n+}\n+\n+#endif"}, {"sha": "5bbd56c3ad812cdb14cdc386133e509e116f454b", "filename": "zlib/contrib/iostream2/zstream_test.cpp", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,25 @@\n+#include \"zstream.h\"\n+#include <math.h>\n+#include <stdlib.h>\n+#include <iomanip.h>\n+\n+void main() {\n+\tchar h[256] = \"Hello\";\n+\tchar* g = \"Goodbye\";\n+\tozstream out(\"temp.gz\");\n+    out < \"This works well\" < h < g;\n+    out.close();\n+\n+    izstream in(\"temp.gz\"); // read it back\n+    char *x = read_string(in), *y = new char[256], z[256];\n+    in > y > z;\n+    in.close();\n+    cout << x << endl << y << endl << z << endl;\n+\n+    out.open(\"temp.gz\"); // try ascii output; zcat temp.gz to see the results\n+    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;\n+    out << z << endl << y << endl << x << endl;\n+    out << 1.1234567890123456789 << endl;\n+\n+    delete[] x; delete[] y;\n+}"}, {"sha": "9987c543cdcff494a8e730d601e43a9be41ea38c", "filename": "zlib/contrib/minizip/ChangeLogUnzip", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,38 @@\n+Change in 0.15: (19 Mar 98)\n+- fix memory leak in minizip.c\n+\n+Change in 0.14: (10 Mar 98)\n+- fix bugs in minizip.c sample for zipping big file\n+- fix problem in month in date handling\n+- fix bug in unzlocal_GetCurrentFileInfoInternal in unzip.c for \n+    comment handling\n+\n+Change in 0.13: (6 Mar 98)\n+- fix bugs in zip.c\n+- add real minizip sample\n+\n+Change in 0.12: (4 Mar 98)\n+- add zip.c and zip.h for creates .zip file\n+- fix change_file_date in miniunz.c for Unix (Jean-loup Gailly)\n+- fix miniunz.c for file without specific record for directory\n+\n+Change in 0.11: (3 Mar 98)\n+- fix bug in unzGetCurrentFileInfo for get extra field and comment\n+- enhance miniunz sample, remove the bad unztst.c sample\n+\n+Change in 0.10: (2 Mar 98)\n+- fix bug in unzReadCurrentFile\n+- rename unzip* to unz* function and structure\n+- remove Windows-like hungary notation variable name\n+- modify some structure in unzip.h\n+- add somes comment in source\n+- remove unzipGetcCurrentFile function\n+- replace ZUNZEXPORT by ZEXPORT\n+- add unzGetLocalExtrafield for get the local extrafield info\n+- add a new sample, miniunz.c\n+\n+Change in 0.4: (25 Feb 98)\n+- suppress the type unzipFileInZip. \n+  Only on file in the zipfile can be open at the same time\n+- fix somes typo in code\n+- added tm_unz structure in unzip_file_info (date/time in readable format)"}, {"sha": "a1dfc161437af509c9bf5cfeacef554f924a2875", "filename": "zlib/contrib/minizip/Makefile", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FMakefile?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,25 @@\n+CC=cc\n+CFLAGS=-O -I../..\n+\n+UNZ_OBJS = miniunz.o unzip.o ../../libz.a\n+ZIP_OBJS = minizip.o zip.o   ../../libz.a\n+\n+.c.o:\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+all: miniunz minizip\n+\n+miniunz:  $(UNZ_OBJS)\n+\t$(CC) $(CFLAGS) -o $@ $(UNZ_OBJS)\n+\n+minizip:  $(ZIP_OBJS)\n+\t$(CC) $(CFLAGS) -o $@ $(ZIP_OBJS)\n+\n+test:\tminiunz minizip\n+\t./minizip test readme.txt\n+\t./miniunz -l test.zip\n+\tmv readme.txt readme.old\n+\t./miniunz test.zip\n+\n+clean:\n+\t/bin/rm -f *.o *~ minizip miniunz"}, {"sha": "f3b7832878fc070c176118f82dd84d7e4b96ccf6", "filename": "zlib/contrib/minizip/miniunz.c", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminiunz.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,508 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+\n+#ifdef unix\n+# include <unistd.h>\n+# include <utime.h>\n+#else\n+# include <direct.h>\n+# include <io.h>\n+#endif\n+\n+#include \"unzip.h\"\n+\n+#define CASESENSITIVITY (0)\n+#define WRITEBUFFERSIZE (8192)\n+\n+/*\n+  mini unzip, demo of unzip package\n+\n+  usage :\n+  Usage : miniunz [-exvlo] file.zip [file_to_extract]\n+\n+  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT\n+    if it exists\n+*/\n+\n+\n+/* change_file_date : change the date/time of a file\n+    filename : the filename of the file where date/time must be modified\n+    dosdate : the new date at the MSDos format (4 bytes)\n+    tmu_date : the SAME new date at the tm_unz format */\n+void change_file_date(filename,dosdate,tmu_date)\n+\tconst char *filename;\n+\tuLong dosdate;\n+\ttm_unz tmu_date;\n+{\n+#ifdef WIN32\n+  HANDLE hFile;\n+  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;\n+\n+  hFile = CreateFile(filename,GENERIC_READ | GENERIC_WRITE,\n+                      0,NULL,OPEN_EXISTING,0,NULL);\n+  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);\n+  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);\n+  LocalFileTimeToFileTime(&ftLocal,&ftm);\n+  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);\n+  CloseHandle(hFile);\n+#else\n+#ifdef unix\n+  struct utimbuf ut;\n+  struct tm newdate;\n+  newdate.tm_sec = tmu_date.tm_sec;\n+  newdate.tm_min=tmu_date.tm_min;\n+  newdate.tm_hour=tmu_date.tm_hour;\n+  newdate.tm_mday=tmu_date.tm_mday;\n+  newdate.tm_mon=tmu_date.tm_mon;\n+  if (tmu_date.tm_year > 1900)\n+      newdate.tm_year=tmu_date.tm_year - 1900;\n+  else\n+      newdate.tm_year=tmu_date.tm_year ;\n+  newdate.tm_isdst=-1;\n+\n+  ut.actime=ut.modtime=mktime(&newdate);\n+  utime(filename,&ut);\n+#endif\n+#endif\n+}\n+\n+\n+/* mymkdir and change_file_date are not 100 % portable\n+   As I don't know well Unix, I wait feedback for the unix portion */\n+\n+int mymkdir(dirname)\n+\tconst char* dirname;\n+{\n+    int ret=0;\n+#ifdef WIN32\n+\tret = mkdir(dirname);\n+#else\n+#ifdef unix\n+\tret = mkdir (dirname,0775);\n+#endif\n+#endif\n+\treturn ret;\n+}\n+\n+int makedir (newdir)\n+    char *newdir;\n+{\n+  char *buffer ;\n+  char *p;\n+  int  len = strlen(newdir);  \n+\n+  if (len <= 0) \n+    return 0;\n+\n+  buffer = (char*)malloc(len+1);\n+  strcpy(buffer,newdir);\n+  \n+  if (buffer[len-1] == '/') {\n+    buffer[len-1] = '\\0';\n+  }\n+  if (mymkdir(buffer) == 0)\n+    {\n+      free(buffer);\n+      return 1;\n+    }\n+\n+  p = buffer+1;\n+  while (1)\n+    {\n+      char hold;\n+\n+      while(*p && *p != '\\\\' && *p != '/')\n+        p++;\n+      hold = *p;\n+      *p = 0;\n+      if ((mymkdir(buffer) == -1) && (errno == ENOENT))\n+        {\n+          printf(\"couldn't create directory %s\\n\",buffer);\n+          free(buffer);\n+          return 0;\n+        }\n+      if (hold == 0)\n+        break;\n+      *p++ = hold;\n+    }\n+  free(buffer);\n+  return 1;\n+}\n+\n+void do_banner()\n+{\n+\tprintf(\"MiniUnz 0.15, demo of zLib + Unz package written by Gilles Vollant\\n\");\n+\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n+}\n+\n+void do_help()\n+{\t\n+\tprintf(\"Usage : miniunz [-exvlo] file.zip [file_to_extract]\\n\\n\") ;\n+}\n+\n+\n+int do_list(uf)\n+\tunzFile uf;\n+{\n+\tuLong i;\n+\tunz_global_info gi;\n+\tint err;\n+\n+\terr = unzGetGlobalInfo (uf,&gi);\n+\tif (err!=UNZ_OK)\n+\t\tprintf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n+    printf(\" Length  Method   Size  Ratio   Date    Time   CRC-32     Name\\n\");\n+    printf(\" ------  ------   ----  -----   ----    ----   ------     ----\\n\");\n+\tfor (i=0;i<gi.number_entry;i++)\n+\t{\n+\t\tchar filename_inzip[256];\n+\t\tunz_file_info file_info;\n+\t\tuLong ratio=0;\n+\t\tconst char *string_method;\n+\t\terr = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n+\t\tif (err!=UNZ_OK)\n+\t\t{\n+\t\t\tprintf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (file_info.uncompressed_size>0)\n+\t\t\tratio = (file_info.compressed_size*100)/file_info.uncompressed_size;\n+\n+\t\tif (file_info.compression_method==0)\n+\t\t\tstring_method=\"Stored\";\n+\t\telse\n+\t\tif (file_info.compression_method==Z_DEFLATED)\n+\t\t{\n+\t\t\tuInt iLevel=(uInt)((file_info.flag & 0x6)/2);\n+\t\t\tif (iLevel==0)\n+\t\t\t  string_method=\"Defl:N\";\n+\t\t\telse if (iLevel==1)\n+\t\t\t  string_method=\"Defl:X\";\n+\t\t\telse if ((iLevel==2) || (iLevel==3))\n+\t\t\t  string_method=\"Defl:F\"; /* 2:fast , 3 : extra fast*/\n+\t\t}\n+\t\telse\n+\t\t\tstring_method=\"Unkn. \";\n+\n+\t\tprintf(\"%7lu  %6s %7lu %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\\n\",\n+\t\t\t    file_info.uncompressed_size,string_method,file_info.compressed_size,\n+\t\t\t\tratio,\n+\t\t\t\t(uLong)file_info.tmu_date.tm_mon + 1,\n+                (uLong)file_info.tmu_date.tm_mday,\n+\t\t\t\t(uLong)file_info.tmu_date.tm_year % 100,\n+\t\t\t\t(uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,\n+\t\t\t\t(uLong)file_info.crc,filename_inzip);\n+\t\tif ((i+1)<gi.number_entry)\n+\t\t{\n+\t\t\terr = unzGoToNextFile(uf);\n+\t\t\tif (err!=UNZ_OK)\n+\t\t\t{\n+\t\t\t\tprintf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite)\n+\tunzFile uf;\n+\tconst int* popt_extract_without_path;\n+    int* popt_overwrite;\n+{\n+\tchar filename_inzip[256];\n+\tchar* filename_withoutpath;\n+\tchar* p;\n+    int err=UNZ_OK;\n+    FILE *fout=NULL;\n+    void* buf;\n+    uInt size_buf;\n+\t\n+\tunz_file_info file_info;\n+\tuLong ratio=0;\n+\terr = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n+\n+\tif (err!=UNZ_OK)\n+\t{\n+\t\tprintf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n+\t\treturn err;\n+\t}\n+\n+    size_buf = WRITEBUFFERSIZE;\n+    buf = (void*)malloc(size_buf);\n+    if (buf==NULL)\n+    {\n+        printf(\"Error allocating memory\\n\");\n+        return UNZ_INTERNALERROR;\n+    }\n+\n+\tp = filename_withoutpath = filename_inzip;\n+\twhile ((*p) != '\\0')\n+\t{\n+\t\tif (((*p)=='/') || ((*p)=='\\\\'))\n+\t\t\tfilename_withoutpath = p+1;\n+\t\tp++;\n+\t}\n+\n+\tif ((*filename_withoutpath)=='\\0')\n+\t{\n+\t\tif ((*popt_extract_without_path)==0)\n+\t\t{\n+\t\t\tprintf(\"creating directory: %s\\n\",filename_inzip);\n+\t\t\tmymkdir(filename_inzip);\n+\t\t}\n+\t}\n+\telse\n+\t{\n+\t\tconst char* write_filename;\n+\t\tint skip=0;\n+\n+\t\tif ((*popt_extract_without_path)==0)\n+\t\t\twrite_filename = filename_inzip;\n+\t\telse\n+\t\t\twrite_filename = filename_withoutpath;\n+\n+\t\terr = unzOpenCurrentFile(uf);\n+\t\tif (err!=UNZ_OK)\n+\t\t{\n+\t\t\tprintf(\"error %d with zipfile in unzOpenCurrentFile\\n\",err);\n+\t\t}\n+\n+\t\tif (((*popt_overwrite)==0) && (err==UNZ_OK))\n+\t\t{\n+\t\t\tchar rep;\n+\t\t\tFILE* ftestexist;\n+\t\t\tftestexist = fopen(write_filename,\"rb\");\n+\t\t\tif (ftestexist!=NULL)\n+\t\t\t{\n+\t\t\t\tfclose(ftestexist);\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tchar answer[128];\n+\t\t\t\t\tprintf(\"The file %s exist. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n+\t\t\t\t\tscanf(\"%1s\",answer);\n+\t\t\t\t\trep = answer[0] ;\n+\t\t\t\t\tif ((rep>='a') && (rep<='z'))\n+\t\t\t\t\t\trep -= 0x20;\n+\t\t\t\t}\n+\t\t\t\twhile ((rep!='Y') && (rep!='N') && (rep!='A'));\n+\t\t\t}\n+\n+\t\t\tif (rep == 'N')\n+\t\t\t\tskip = 1;\n+\n+\t\t\tif (rep == 'A')\n+\t\t\t\t*popt_overwrite=1;\n+\t\t}\n+\n+\t\tif ((skip==0) && (err==UNZ_OK))\n+\t\t{\n+\t\t\tfout=fopen(write_filename,\"wb\");\n+\n+            /* some zipfile don't contain directory alone before file */\n+            if ((fout==NULL) && ((*popt_extract_without_path)==0) && \n+                                (filename_withoutpath!=(char*)filename_inzip))\n+            {\n+                char c=*(filename_withoutpath-1);\n+                *(filename_withoutpath-1)='\\0';\n+                makedir(write_filename);\n+                *(filename_withoutpath-1)=c;\n+                fout=fopen(write_filename,\"wb\");\n+            }\n+\n+\t\t\tif (fout==NULL)\n+\t\t\t{\n+\t\t\t\tprintf(\"error opening %s\\n\",write_filename);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (fout!=NULL)\n+\t\t{\n+\t\t\tprintf(\" extracting: %s\\n\",write_filename);\n+\n+\t\t\tdo\n+\t\t\t{\n+\t\t\t\terr = unzReadCurrentFile(uf,buf,size_buf);\n+\t\t\t\tif (err<0)\t\n+\t\t\t\t{\n+\t\t\t\t\tprintf(\"error %d with zipfile in unzReadCurrentFile\\n\",err);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (err>0)\n+\t\t\t\t\tif (fwrite(buf,err,1,fout)!=1)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tprintf(\"error in writing extracted file\\n\");\n+                        err=UNZ_ERRNO;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t}\n+\t\t\twhile (err>0);\n+\t\t\tfclose(fout);\n+\t\t\tif (err==0) \n+\t\t\t\tchange_file_date(write_filename,file_info.dosDate,\n+\t\t\t\t\t             file_info.tmu_date);\n+\t\t}\n+\n+        if (err==UNZ_OK)\n+        {\n+\t\t    err = unzCloseCurrentFile (uf);\n+\t\t    if (err!=UNZ_OK)\n+\t\t    {\n+\t\t\t    printf(\"error %d with zipfile in unzCloseCurrentFile\\n\",err);\n+\t\t    }\n+        }\n+        else\n+            unzCloseCurrentFile(uf); /* don't lose the error */       \n+\t}\n+\n+    free(buf);    \n+    return err;\n+}\n+\n+\n+int do_extract(uf,opt_extract_without_path,opt_overwrite)\n+\tunzFile uf;\n+\tint opt_extract_without_path;\n+    int opt_overwrite;\n+{\n+\tuLong i;\n+\tunz_global_info gi;\n+\tint err;\n+\tFILE* fout=NULL;\t\n+\n+\terr = unzGetGlobalInfo (uf,&gi);\n+\tif (err!=UNZ_OK)\n+\t\tprintf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n+\n+\tfor (i=0;i<gi.number_entry;i++)\n+\t{\n+        if (do_extract_currentfile(uf,&opt_extract_without_path,\n+                                      &opt_overwrite) != UNZ_OK)\n+            break;\n+\n+\t\tif ((i+1)<gi.number_entry)\n+\t\t{\n+\t\t\terr = unzGoToNextFile(uf);\n+\t\t\tif (err!=UNZ_OK)\n+\t\t\t{\n+\t\t\t\tprintf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite)\n+\tunzFile uf;\n+\tconst char* filename;\n+\tint opt_extract_without_path;\n+    int opt_overwrite;\n+{\n+    int err = UNZ_OK;\n+    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)\n+    {\n+        printf(\"file %s not found in the zipfile\\n\",filename);\n+        return 2;\n+    }\n+\n+    if (do_extract_currentfile(uf,&opt_extract_without_path,\n+                                      &opt_overwrite) == UNZ_OK)\n+        return 0;\n+    else\n+        return 1;\n+}\n+\n+\n+int main(argc,argv)\n+\tint argc;\n+\tchar *argv[];\n+{\n+\tconst char *zipfilename=NULL;\n+    const char *filename_to_extract=NULL;\n+\tint i;\n+\tint opt_do_list=0;\n+\tint opt_do_extract=1;\n+\tint opt_do_extract_withoutpath=0;\n+\tint opt_overwrite=0;\n+\tchar filename_try[512];\n+\tunzFile uf=NULL;\n+\n+\tdo_banner();\n+\tif (argc==1)\n+\t{\n+\t\tdo_help();\n+\t\texit(0);\n+\t}\n+\telse\n+\t{\n+\t\tfor (i=1;i<argc;i++)\n+\t\t{\n+\t\t\tif ((*argv[i])=='-')\n+\t\t\t{\n+\t\t\t\tconst char *p=argv[i]+1;\n+\t\t\t\t\n+\t\t\t\twhile ((*p)!='\\0')\n+\t\t\t\t{\t\t\t\n+\t\t\t\t\tchar c=*(p++);;\n+\t\t\t\t\tif ((c=='l') || (c=='L'))\n+\t\t\t\t\t\topt_do_list = 1;\n+\t\t\t\t\tif ((c=='v') || (c=='V'))\n+\t\t\t\t\t\topt_do_list = 1;\n+\t\t\t\t\tif ((c=='x') || (c=='X'))\n+\t\t\t\t\t\topt_do_extract = 1;\n+\t\t\t\t\tif ((c=='e') || (c=='E'))\n+\t\t\t\t\t\topt_do_extract = opt_do_extract_withoutpath = 1;\n+\t\t\t\t\tif ((c=='o') || (c=='O'))\n+\t\t\t\t\t\topt_overwrite=1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+            {\n+\t\t\t\tif (zipfilename == NULL)\n+\t\t\t\t\tzipfilename = argv[i];\n+                else if (filename_to_extract==NULL)\n+                        filename_to_extract = argv[i] ;\n+            }\n+\t\t}\n+\t}\n+\n+\tif (zipfilename!=NULL)\n+\t{\n+\t\tstrcpy(filename_try,zipfilename);\n+\t\tuf = unzOpen(zipfilename);\n+\t\tif (uf==NULL)\n+\t\t{\n+\t\t\tstrcat(filename_try,\".zip\");\n+\t\t\tuf = unzOpen(filename_try);\n+\t\t}\n+\t}\n+\n+\tif (uf==NULL)\n+\t{\n+\t\tprintf(\"Cannot open %s or %s.zip\\n\",zipfilename,zipfilename);\n+\t\texit (1);\n+\t}\n+    printf(\"%s opened\\n\",filename_try);\n+\n+\tif (opt_do_list==1)\n+\t\treturn do_list(uf);\n+\telse if (opt_do_extract==1)\n+    {\n+        if (filename_to_extract == NULL)\n+\t\t    return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite);\n+        else\n+            return do_extract_onefile(uf,filename_to_extract,\n+                                      opt_do_extract_withoutpath,opt_overwrite);\n+    }\n+\tunzCloseCurrentFile(uf);\n+\n+\treturn 0;  /* to avoid warning */\n+}"}, {"sha": "5e492d209b1974bffc07f11340ccf4eeb955219d", "filename": "zlib/contrib/minizip/minizip.c", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminizip.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,302 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+\n+#ifdef unix\n+# include <unistd.h>\n+# include <utime.h>\n+# include <sys/types.h>\n+# include <sys/stat.h>\n+#else\n+# include <direct.h>\n+# include <io.h>\n+#endif\n+\n+#include \"zip.h\"\n+\n+\n+#define WRITEBUFFERSIZE (16384)\n+#define MAXFILENAME (256)\n+\n+#ifdef WIN32\n+uLong filetime(f, tmzip, dt)\n+    char *f;                /* name of file to get info on */\n+    tm_zip *tmzip;             /* return value: access, modific. and creation times */\n+    uLong *dt;             /* dostime */\n+{\n+  int ret = 0;\n+  {\n+      FILETIME ftLocal;\n+      HANDLE hFind;\n+      WIN32_FIND_DATA  ff32;\n+\n+      hFind = FindFirstFile(f,&ff32);\n+      if (hFind != INVALID_HANDLE_VALUE)\n+      {\n+        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);\n+        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);\n+        FindClose(hFind);\n+        ret = 1;\n+      }\n+  }\n+  return ret;\n+}\n+#else\n+#ifdef unix\n+uLong filetime(f, tmzip, dt)\n+    char *f;                /* name of file to get info on */\n+    tm_zip *tmzip;             /* return value: access, modific. and creation times */\n+    uLong *dt;             /* dostime */\n+{\n+  int ret=0;\n+  struct stat s;        /* results of stat() */\n+  struct tm* filedate;\n+  time_t tm_t=0;\n+  \n+  if (strcmp(f,\"-\")!=0)\n+  {\n+    char name[MAXFILENAME];\n+    int len = strlen(f);\n+    strcpy(name, f);\n+    if (name[len - 1] == '/')\n+      name[len - 1] = '\\0';\n+    /* not all systems allow stat'ing a file with / appended */\n+    if (stat(name,&s)==0)\n+    {\n+      tm_t = s.st_mtime;\n+      ret = 1;\n+    }\n+  }\n+  filedate = localtime(&tm_t);\n+\n+  tmzip->tm_sec  = filedate->tm_sec;\n+  tmzip->tm_min  = filedate->tm_min;\n+  tmzip->tm_hour = filedate->tm_hour;\n+  tmzip->tm_mday = filedate->tm_mday;\n+  tmzip->tm_mon  = filedate->tm_mon ;\n+  tmzip->tm_year = filedate->tm_year;\n+\n+  return ret;\n+}\n+#else\n+uLong filetime(f, tmzip, dt)\n+    char *f;                /* name of file to get info on */\n+    tm_zip *tmzip;             /* return value: access, modific. and creation times */\n+    uLong *dt;             /* dostime */\n+{\n+    return 0;\n+}\n+#endif\n+#endif\n+\n+\n+\n+\n+int check_exist_file(filename)\n+    const char* filename;\n+{\n+\tFILE* ftestexist;\n+    int ret = 1;\n+\tftestexist = fopen(filename,\"rb\");\n+\tif (ftestexist==NULL)\n+        ret = 0;\n+    else\n+        fclose(ftestexist);\n+    return ret;\n+}\n+\n+void do_banner()\n+{\n+\tprintf(\"MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\\n\");\n+\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n+}\n+\n+void do_help()\n+{\t\n+\tprintf(\"Usage : minizip [-o] file.zip [files_to_add]\\n\\n\") ;\n+}\n+\n+int main(argc,argv)\n+\tint argc;\n+\tchar *argv[];\n+{\n+\tint i;\n+\tint opt_overwrite=0;\n+    int opt_compress_level=Z_DEFAULT_COMPRESSION;\n+    int zipfilenamearg = 0;\n+\tchar filename_try[MAXFILENAME];\n+    int zipok;\n+    int err=0;\n+    int size_buf=0;\n+    void* buf=NULL,\n+\n+\n+\tdo_banner();\n+\tif (argc==1)\n+\t{\n+\t\tdo_help();\n+\t\texit(0);\n+        return 0;\n+\t}\n+\telse\n+\t{\n+\t\tfor (i=1;i<argc;i++)\n+\t\t{\n+\t\t\tif ((*argv[i])=='-')\n+\t\t\t{\n+\t\t\t\tconst char *p=argv[i]+1;\n+\t\t\t\t\n+\t\t\t\twhile ((*p)!='\\0')\n+\t\t\t\t{\t\t\t\n+\t\t\t\t\tchar c=*(p++);;\n+\t\t\t\t\tif ((c=='o') || (c=='O'))\n+\t\t\t\t\t\topt_overwrite = 1;\n+                    if ((c>='0') && (c<='9'))\n+                        opt_compress_level = c-'0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+\t\t\t\tif (zipfilenamearg == 0)\n+                    zipfilenamearg = i ;\n+\t\t}\n+\t}\n+\n+    size_buf = WRITEBUFFERSIZE;\n+    buf = (void*)malloc(size_buf);\n+    if (buf==NULL)\n+    {\n+        printf(\"Error allocating memory\\n\");\n+        return ZIP_INTERNALERROR;\n+    }\n+\n+\tif (zipfilenamearg==0)\n+        zipok=0;\n+    else\n+\t{\n+        int i,len;\n+        int dot_found=0;\n+\n+        zipok = 1 ;\n+\t\tstrcpy(filename_try,argv[zipfilenamearg]);\n+        len=strlen(filename_try);\n+        for (i=0;i<len;i++)\n+            if (filename_try[i]=='.')\n+                dot_found=1;\n+\n+        if (dot_found==0)\n+            strcat(filename_try,\".zip\");\n+\n+        if (opt_overwrite==0)\n+            if (check_exist_file(filename_try)!=0)\n+\t\t\t{\n+                char rep;\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tchar answer[128];\n+\t\t\t\t\tprintf(\"The file %s exist. Overwrite ? [y]es, [n]o : \",filename_try);\n+\t\t\t\t\tscanf(\"%1s\",answer);\n+\t\t\t\t\trep = answer[0] ;\n+\t\t\t\t\tif ((rep>='a') && (rep<='z'))\n+\t\t\t\t\t\trep -= 0x20;\n+\t\t\t\t}\n+\t\t\t\twhile ((rep!='Y') && (rep!='N'));\n+                if (rep=='N')\n+                    zipok = 0;\n+\t\t\t}\n+    }\n+\n+    if (zipok==1)\n+    {\n+        zipFile zf;\n+        int errclose;\n+        zf = zipOpen(filename_try,0);\n+        if (zf == NULL)\n+        {\n+            printf(\"error opening %s\\n\",filename_try);\n+            err= ZIP_ERRNO;\n+        }\n+        else \n+            printf(\"creating %s\\n\",filename_try);\n+\n+        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)\n+        {\n+            if (((*(argv[i]))!='-') && ((*(argv[i]))!='/'))\n+            {\n+                FILE * fin;\n+                int size_read;\n+                const char* filenameinzip = argv[i];\n+                zip_fileinfo zi;\n+\n+                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour = \n+                zi.tmz_date.tm_mday = zi.tmz_date.tm_min = zi.tmz_date.tm_year = 0;\n+                zi.dosDate = 0;\n+                zi.internal_fa = 0;\n+                zi.external_fa = 0;\n+                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);\n+\n+\n+                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,\n+                                 NULL,0,NULL,0,NULL /* comment*/,\n+                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,\n+                                 opt_compress_level);\n+\n+                if (err != ZIP_OK)\n+                    printf(\"error in opening %s in zipfile\\n\",filenameinzip);\n+                else\n+                {\n+                    fin = fopen(filenameinzip,\"rb\");\n+                    if (fin==NULL)\n+                    {\n+                        err=ZIP_ERRNO;\n+                        printf(\"error in opening %s for reading\\n\",filenameinzip);\n+                    }\n+                }\n+\n+                if (err == ZIP_OK)\n+                    do\n+                    {\n+                        err = ZIP_OK;\n+                        size_read = fread(buf,1,size_buf,fin);\n+                        if (size_read < size_buf)\n+                            if (feof(fin)==0)\n+                        {\n+                            printf(\"error in reading %s\\n\",filenameinzip);\n+                            err = ZIP_ERRNO;\n+                        }\n+\n+                        if (size_read>0)\n+                        {\n+                            err = zipWriteInFileInZip (zf,buf,size_read);\n+                            if (err<0)\n+                            {\n+                                printf(\"error in writing %s in the zipfile\\n\",\n+                                                 filenameinzip);\n+                            }\n+                                \n+                        }\n+                    } while ((err == ZIP_OK) && (size_read>0));\n+\n+                fclose(fin);\n+                if (err<0)\n+                    err=ZIP_ERRNO;\n+                else\n+                {                    \n+                    err = zipCloseFileInZip(zf);\n+                    if (err!=ZIP_OK)\n+                        printf(\"error in closing %s in the zipfile\\n\",\n+                                    filenameinzip);\n+                }\n+            }\n+        }\n+        errclose = zipClose(zf,NULL);\n+        if (errclose != ZIP_OK)\n+            printf(\"error in closing %s\\n\",filename_try);\n+   }\n+\n+    free(buf);\n+    exit(0);\n+\treturn 0;  /* to avoid warning */\n+}"}, {"sha": "1fc023c720b1f8f089559d0b88e772b1362a6878", "filename": "zlib/contrib/minizip/readme.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Freadme.txt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,37 @@\n+\n+UnZip 0.15 additionnal library\n+\n+\n+  This unzip package allow extract file from .ZIP file, compatible with \n+PKZip 2.04g, WinZip, InfoZip tools and compatible.\n+\n+  Multi volume ZipFile (span) are not supported, and old compression used by old \n+PKZip 1.x are not supported.\n+\n+See probdesc.zip from PKWare for specification of .ZIP format.\n+\n+What is Unzip\n+  The Zlib library support the deflate compression and the creation of gzip (.gz) \n+file. Zlib is free and small.\n+  The .Zip format, which can contain several compressed files (.gz can containt\n+only one file) is a very popular format. This is why I've written a package for reading file compressed in Zipfile.\n+\n+Using Unzip package\n+\n+You need source of Zlib (get zlib111.zip and read zlib.h).\n+Get unzlb015.zip and read unzip.h (whith documentation of unzip functions)\n+\n+The Unzip package is only two file : unzip.h and unzip.c. But it use the Zlib \n+  files.\n+unztst.c is a simple sample program, which list file in a zipfile and display\n+  README.TXT or FILE_ID.DIZ (if these files are found).\n+miniunz.c is a mini unzip program.\n+\n+I'm also currenlyt writing a zipping portion (zip.h, zip.c and test with minizip.c)\n+\n+Please email me for feedback.\n+I hope my source is compatible with Unix system, but I need your help for be sure\n+\n+Latest revision : Mar 04th, 1998\n+\n+Check http://www.winimage.com/zLibDll/unzip.html for up to date info."}, {"sha": "ff71a474da12c0358092616e47f2bcb7facbe3d3", "filename": "zlib/contrib/minizip/unzip.c", "status": "added", "additions": 1294, "deletions": 0, "changes": 1294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,1294 @@\n+/* unzip.c -- IO on .zip files using zlib \n+   Version 0.15 beta, Mar 19th, 1998,\n+\n+   Read unzip.h for more info\n+*/\n+\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"zlib.h\"\n+#include \"unzip.h\"\n+\n+#ifdef STDC\n+#  include <stddef.h>\n+#  include <string.h>\n+#  include <stdlib.h>\n+#endif\n+#ifdef NO_ERRNO_H\n+    extern int errno;\n+#else\n+#   include <errno.h>\n+#endif\n+\n+\n+#ifndef local\n+#  define local static\n+#endif\n+/* compile with -Dlocal if your debugger can't find static symbols */\n+\n+\n+\n+#if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES) && \\\n+                      !defined(CASESENSITIVITYDEFAULT_NO)\n+#define CASESENSITIVITYDEFAULT_NO\n+#endif\n+\n+\n+#ifndef UNZ_BUFSIZE\n+#define UNZ_BUFSIZE (16384)\n+#endif\n+\n+#ifndef UNZ_MAXFILENAMEINZIP\n+#define UNZ_MAXFILENAMEINZIP (256)\n+#endif\n+\n+#ifndef ALLOC\n+# define ALLOC(size) (malloc(size))\n+#endif\n+#ifndef TRYFREE\n+# define TRYFREE(p) {if (p) free(p);}\n+#endif\n+\n+#define SIZECENTRALDIRITEM (0x2e)\n+#define SIZEZIPLOCALHEADER (0x1e)\n+\n+\n+/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */\n+\n+#ifndef SEEK_CUR\n+#define SEEK_CUR    1\n+#endif\n+\n+#ifndef SEEK_END\n+#define SEEK_END    2\n+#endif\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET    0\n+#endif\n+\n+const char unz_copyright[] =\n+   \" unzip 0.15 Copyright 1998 Gilles Vollant \";\n+\n+/* unz_file_info_interntal contain internal info about a file in zipfile*/\n+typedef struct unz_file_info_internal_s\n+{\n+    uLong offset_curfile;/* relative offset of local header 4 bytes */\n+} unz_file_info_internal;\n+\n+\n+/* file_in_zip_read_info_s contain internal information about a file in zipfile,\n+    when reading and decompress it */\n+typedef struct\n+{\n+\tchar  *read_buffer;         /* internal buffer for compressed data */\n+\tz_stream stream;            /* zLib stream structure for inflate */\n+\n+\tuLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/\n+\tuLong stream_initialised;   /* flag set if stream structure is initialised*/\n+\n+\tuLong offset_local_extrafield;/* offset of the local extra field */\n+\tuInt  size_local_extrafield;/* size of the local extra field */\n+\tuLong pos_local_extrafield;   /* position in the local extra field in read*/\n+\n+\tuLong crc32;                /* crc32 of all data uncompressed */\n+\tuLong crc32_wait;           /* crc32 we must obtain after decompress all */\n+\tuLong rest_read_compressed; /* number of byte to be decompressed */\n+\tuLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/\n+\tFILE* file;                 /* io structore of the zipfile */\n+\tuLong compression_method;   /* compression method (0==store) */\n+\tuLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+} file_in_zip_read_info_s;\n+\n+\n+/* unz_s contain internal information about the zipfile\n+*/\n+typedef struct\n+{\n+\tFILE* file;                 /* io structore of the zipfile */\n+\tunz_global_info gi;       /* public global information */\n+\tuLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+\tuLong num_file;             /* number of the current file in the zipfile*/\n+\tuLong pos_in_central_dir;   /* pos of the current file in the central dir*/\n+\tuLong current_file_ok;      /* flag about the usability of the current file*/\n+\tuLong central_pos;          /* position of the beginning of the central dir*/\n+\n+\tuLong size_central_dir;     /* size of the central directory  */\n+\tuLong offset_central_dir;   /* offset of start of central directory with\n+\t\t\t\t\t\t\t\t   respect to the starting disk number */\n+\n+\tunz_file_info cur_file_info; /* public info about the current file in zip*/\n+\tunz_file_info_internal cur_file_info_internal; /* private info about it*/\n+    file_in_zip_read_info_s* pfile_in_zip_read; /* structure about the current\n+\t                                    file if we are decompressing it */\n+} unz_s;\n+\n+\n+/* ===========================================================================\n+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n+   for end of file.\n+   IN assertion: the stream s has been sucessfully opened for reading.\n+*/\n+\n+\n+local int unzlocal_getByte(fin,pi)\n+\tFILE *fin;\n+\tint *pi;\n+{\n+    unsigned char c;\n+\tint err = fread(&c, 1, 1, fin);\n+    if (err==1)\n+    {\n+        *pi = (int)c;\n+        return UNZ_OK;\n+    }\n+    else\n+    {\n+        if (ferror(fin)) \n+            return UNZ_ERRNO;\n+        else\n+            return UNZ_EOF;\n+    }\n+}\n+\n+\n+/* ===========================================================================\n+   Reads a long in LSB order from the given gz_stream. Sets \n+*/\n+local int unzlocal_getShort (fin,pX)\n+\tFILE* fin;\n+    uLong *pX;\n+{\n+    uLong x ;\n+    int i;\n+    int err;\n+\n+    err = unzlocal_getByte(fin,&i);\n+    x = (uLong)i;\n+    \n+    if (err==UNZ_OK)\n+        err = unzlocal_getByte(fin,&i);\n+    x += ((uLong)i)<<8;\n+   \n+    if (err==UNZ_OK)\n+        *pX = x;\n+    else\n+        *pX = 0;\n+    return err;\n+}\n+\n+local int unzlocal_getLong (fin,pX)\n+\tFILE* fin;\n+    uLong *pX;\n+{\n+    uLong x ;\n+    int i;\n+    int err;\n+\n+    err = unzlocal_getByte(fin,&i);\n+    x = (uLong)i;\n+    \n+    if (err==UNZ_OK)\n+        err = unzlocal_getByte(fin,&i);\n+    x += ((uLong)i)<<8;\n+\n+    if (err==UNZ_OK)\n+        err = unzlocal_getByte(fin,&i);\n+    x += ((uLong)i)<<16;\n+\n+    if (err==UNZ_OK)\n+        err = unzlocal_getByte(fin,&i);\n+    x += ((uLong)i)<<24;\n+   \n+    if (err==UNZ_OK)\n+        *pX = x;\n+    else\n+        *pX = 0;\n+    return err;\n+}\n+\n+\n+/* My own strcmpi / strcasecmp */\n+local int strcmpcasenosensitive_internal (fileName1,fileName2)\n+\tconst char* fileName1;\n+\tconst char* fileName2;\n+{\n+\tfor (;;)\n+\t{\n+\t\tchar c1=*(fileName1++);\n+\t\tchar c2=*(fileName2++);\n+\t\tif ((c1>='a') && (c1<='z'))\n+\t\t\tc1 -= 0x20;\n+\t\tif ((c2>='a') && (c2<='z'))\n+\t\t\tc2 -= 0x20;\n+\t\tif (c1=='\\0')\n+\t\t\treturn ((c2=='\\0') ? 0 : -1);\n+\t\tif (c2=='\\0')\n+\t\t\treturn 1;\n+\t\tif (c1<c2)\n+\t\t\treturn -1;\n+\t\tif (c1>c2)\n+\t\t\treturn 1;\n+\t}\n+}\n+\n+\n+#ifdef  CASESENSITIVITYDEFAULT_NO\n+#define CASESENSITIVITYDEFAULTVALUE 2\n+#else\n+#define CASESENSITIVITYDEFAULTVALUE 1\n+#endif\n+\n+#ifndef STRCMPCASENOSENTIVEFUNCTION\n+#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal\n+#endif\n+\n+/* \n+   Compare two filename (fileName1,fileName2).\n+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n+                                                                or strcasecmp)\n+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n+        (like 1 on Unix, 2 on Windows)\n+\n+*/\n+extern int ZEXPORT unzStringFileNameCompare (fileName1,fileName2,iCaseSensitivity)\n+\tconst char* fileName1;\n+\tconst char* fileName2;\n+\tint iCaseSensitivity;\n+{\n+\tif (iCaseSensitivity==0)\n+\t\tiCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n+\n+\tif (iCaseSensitivity==1)\n+\t\treturn strcmp(fileName1,fileName2);\n+\n+\treturn STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n+} \n+\n+#define BUFREADCOMMENT (0x400)\n+\n+/*\n+  Locate the Central directory of a zipfile (at the end, just before\n+    the global comment)\n+*/\n+local uLong unzlocal_SearchCentralDir(fin)\n+\tFILE *fin;\n+{\n+\tunsigned char* buf;\n+\tuLong uSizeFile;\n+\tuLong uBackRead;\n+\tuLong uMaxBack=0xffff; /* maximum size of global comment */\n+\tuLong uPosFound=0;\n+\t\n+\tif (fseek(fin,0,SEEK_END) != 0)\n+\t\treturn 0;\n+\n+\n+\tuSizeFile = ftell( fin );\n+\t\n+\tif (uMaxBack>uSizeFile)\n+\t\tuMaxBack = uSizeFile;\n+\n+\tbuf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n+\tif (buf==NULL)\n+\t\treturn 0;\n+\n+\tuBackRead = 4;\n+\twhile (uBackRead<uMaxBack)\n+\t{\n+\t\tuLong uReadSize,uReadPos ;\n+\t\tint i;\n+\t\tif (uBackRead+BUFREADCOMMENT>uMaxBack) \n+\t\t\tuBackRead = uMaxBack;\n+\t\telse\n+\t\t\tuBackRead+=BUFREADCOMMENT;\n+\t\tuReadPos = uSizeFile-uBackRead ;\n+\t\t\n+\t\tuReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? \n+                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);\n+\t\tif (fseek(fin,uReadPos,SEEK_SET)!=0)\n+\t\t\tbreak;\n+\n+\t\tif (fread(buf,(uInt)uReadSize,1,fin)!=1)\n+\t\t\tbreak;\n+\n+                for (i=(int)uReadSize-3; (i--)>0;)\n+\t\t\tif (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && \n+\t\t\t\t((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n+\t\t\t{\n+\t\t\t\tuPosFound = uReadPos+i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\tif (uPosFound!=0)\n+\t\t\tbreak;\n+\t}\n+\tTRYFREE(buf);\n+\treturn uPosFound;\n+}\n+\n+/*\n+  Open a Zip file. path contain the full pathname (by example,\n+     on a Windows NT computer \"c:\\\\test\\\\zlib109.zip\" or on an Unix computer\n+\t \"zlib/zlib109.zip\".\n+\t If the zipfile cannot be opened (file don't exist or in not valid), the\n+\t   return value is NULL.\n+     Else, the return value is a unzFile Handle, usable with other function\n+\t   of this unzip package.\n+*/\n+extern unzFile ZEXPORT unzOpen (path)\n+\tconst char *path;\n+{\n+\tunz_s us;\n+\tunz_s *s;\n+\tuLong central_pos,uL;\n+\tFILE * fin ;\n+\n+\tuLong number_disk;          /* number of the current dist, used for \n+\t\t\t\t\t\t\t\t   spaning ZIP, unsupported, always 0*/\n+\tuLong number_disk_with_CD;  /* number the the disk with central dir, used\n+\t\t\t\t\t\t\t\t   for spaning ZIP, unsupported, always 0*/\n+\tuLong number_entry_CD;      /* total number of entries in\n+\t                               the central dir \n+\t                               (same than number_entry on nospan) */\n+\n+\tint err=UNZ_OK;\n+\n+    if (unz_copyright[0]!=' ')\n+        return NULL;\n+\n+    fin=fopen(path,\"rb\");\n+\tif (fin==NULL)\n+\t\treturn NULL;\n+\n+\tcentral_pos = unzlocal_SearchCentralDir(fin);\n+\tif (central_pos==0)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (fseek(fin,central_pos,SEEK_SET)!=0)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* the signature, already checked */\n+\tif (unzlocal_getLong(fin,&uL)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* number of this disk */\n+\tif (unzlocal_getShort(fin,&number_disk)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* number of the disk with the start of the central directory */\n+\tif (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* total number of entries in the central dir on this disk */\n+\tif (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* total number of entries in the central dir */\n+\tif (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif ((number_entry_CD!=us.gi.number_entry) ||\n+\t\t(number_disk_with_CD!=0) ||\n+\t\t(number_disk!=0))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\t/* size of the central directory */\n+\tif (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* offset of start of central directory with respect to the \n+\t      starting disk number */\n+\tif (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\t/* zipfile comment length */\n+\tif (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif ((central_pos<us.offset_central_dir+us.size_central_dir) && \n+\t\t(err==UNZ_OK))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\tif (err!=UNZ_OK)\n+\t{\n+\t\tfclose(fin);\n+\t\treturn NULL;\n+\t}\n+\n+\tus.file=fin;\n+\tus.byte_before_the_zipfile = central_pos -\n+\t\t                    (us.offset_central_dir+us.size_central_dir);\n+\tus.central_pos = central_pos;\n+    us.pfile_in_zip_read = NULL;\n+\t\n+\n+\ts=(unz_s*)ALLOC(sizeof(unz_s));\n+\t*s=us;\n+\tunzGoToFirstFile((unzFile)s);\t\n+\treturn (unzFile)s;\t\n+}\n+\n+\n+/*\n+  Close a ZipFile opened with unzipOpen.\n+  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n+    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n+  return UNZ_OK if there is no problem. */\n+extern int ZEXPORT unzClose (file)\n+\tunzFile file;\n+{\n+\tunz_s* s;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\n+    if (s->pfile_in_zip_read!=NULL)\n+        unzCloseCurrentFile(file);\n+\n+\tfclose(s->file);\n+\tTRYFREE(s);\n+\treturn UNZ_OK;\n+}\n+\n+\n+/*\n+  Write info about the ZipFile in the *pglobal_info structure.\n+  No preparation of the structure is needed\n+  return UNZ_OK if there is no problem. */\n+extern int ZEXPORT unzGetGlobalInfo (file,pglobal_info)\n+\tunzFile file;\n+\tunz_global_info *pglobal_info;\n+{\n+\tunz_s* s;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\t*pglobal_info=s->gi;\n+\treturn UNZ_OK;\n+}\n+\n+\n+/*\n+   Translate date/time from Dos format to tm_unz (readable more easilty)\n+*/\n+local void unzlocal_DosDateToTmuDate (ulDosDate, ptm)\n+    uLong ulDosDate;\n+    tm_unz* ptm;\n+{\n+    uLong uDate;\n+    uDate = (uLong)(ulDosDate>>16);\n+    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n+    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n+    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n+\n+    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n+    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n+    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n+}\n+\n+/*\n+  Get Info about the current file in the zipfile, with internal only info\n+*/\n+local int unzlocal_GetCurrentFileInfoInternal OF((unzFile file,\n+                                                  unz_file_info *pfile_info,\n+                                                  unz_file_info_internal \n+                                                  *pfile_info_internal,\n+                                                  char *szFileName,\n+\t\t\t\t\t\t\t\t\t\t\t\t  uLong fileNameBufferSize,\n+                                                  void *extraField,\n+\t\t\t\t\t\t\t\t\t\t\t\t  uLong extraFieldBufferSize,\n+                                                  char *szComment,\n+\t\t\t\t\t\t\t\t\t\t\t\t  uLong commentBufferSize));\n+\n+local int unzlocal_GetCurrentFileInfoInternal (file,\n+                                              pfile_info,\n+                                              pfile_info_internal,\n+                                              szFileName, fileNameBufferSize,\n+                                              extraField, extraFieldBufferSize,\n+                                              szComment,  commentBufferSize)\n+\tunzFile file;\n+\tunz_file_info *pfile_info;\n+\tunz_file_info_internal *pfile_info_internal;\n+\tchar *szFileName;\n+\tuLong fileNameBufferSize;\n+\tvoid *extraField;\n+\tuLong extraFieldBufferSize;\n+\tchar *szComment;\n+\tuLong commentBufferSize;\n+{\n+\tunz_s* s;\n+\tunz_file_info file_info;\n+\tunz_file_info_internal file_info_internal;\n+\tint err=UNZ_OK;\n+\tuLong uMagic;\n+\tlong lSeek=0;\n+\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\tif (fseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)\n+\t\terr=UNZ_ERRNO;\n+\n+\n+\t/* we check the magic */\n+\tif (err==UNZ_OK)\n+\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n+\t\t\terr=UNZ_ERRNO;\n+\t\telse if (uMagic!=0x02014b50)\n+\t\t\terr=UNZ_BADZIPFILE;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n+\n+\tif (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tlSeek+=file_info.size_filename;\n+\tif ((err==UNZ_OK) && (szFileName!=NULL))\n+\t{\n+\t\tuLong uSizeRead ;\n+\t\tif (file_info.size_filename<fileNameBufferSize)\n+\t\t{\n+\t\t\t*(szFileName+file_info.size_filename)='\\0';\n+\t\t\tuSizeRead = file_info.size_filename;\n+\t\t}\n+\t\telse\n+\t\t\tuSizeRead = fileNameBufferSize;\n+\n+\t\tif ((file_info.size_filename>0) && (fileNameBufferSize>0))\n+\t\t\tif (fread(szFileName,(uInt)uSizeRead,1,s->file)!=1)\n+\t\t\t\terr=UNZ_ERRNO;\n+\t\tlSeek -= uSizeRead;\n+\t}\n+\n+\t\n+\tif ((err==UNZ_OK) && (extraField!=NULL))\n+\t{\n+\t\tuLong uSizeRead ;\n+\t\tif (file_info.size_file_extra<extraFieldBufferSize)\n+\t\t\tuSizeRead = file_info.size_file_extra;\n+\t\telse\n+\t\t\tuSizeRead = extraFieldBufferSize;\n+\n+\t\tif (lSeek!=0)\n+\t\t\tif (fseek(s->file,lSeek,SEEK_CUR)==0)\n+\t\t\t\tlSeek=0;\n+\t\t\telse\n+\t\t\t\terr=UNZ_ERRNO;\n+\t\tif ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n+\t\t\tif (fread(extraField,(uInt)uSizeRead,1,s->file)!=1)\n+\t\t\t\terr=UNZ_ERRNO;\n+\t\tlSeek += file_info.size_file_extra - uSizeRead;\n+\t}\n+\telse\n+\t\tlSeek+=file_info.size_file_extra; \n+\n+\t\n+\tif ((err==UNZ_OK) && (szComment!=NULL))\n+\t{\n+\t\tuLong uSizeRead ;\n+\t\tif (file_info.size_file_comment<commentBufferSize)\n+\t\t{\n+\t\t\t*(szComment+file_info.size_file_comment)='\\0';\n+\t\t\tuSizeRead = file_info.size_file_comment;\n+\t\t}\n+\t\telse\n+\t\t\tuSizeRead = commentBufferSize;\n+\n+\t\tif (lSeek!=0)\n+\t\t\tif (fseek(s->file,lSeek,SEEK_CUR)==0)\n+\t\t\t\tlSeek=0;\n+\t\t\telse\n+\t\t\t\terr=UNZ_ERRNO;\n+\t\tif ((file_info.size_file_comment>0) && (commentBufferSize>0))\n+\t\t\tif (fread(szComment,(uInt)uSizeRead,1,s->file)!=1)\n+\t\t\t\terr=UNZ_ERRNO;\n+\t\tlSeek+=file_info.size_file_comment - uSizeRead;\n+\t}\n+\telse\n+\t\tlSeek+=file_info.size_file_comment;\n+\n+\tif ((err==UNZ_OK) && (pfile_info!=NULL))\n+\t\t*pfile_info=file_info;\n+\n+\tif ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n+\t\t*pfile_info_internal=file_info_internal;\n+\n+\treturn err;\n+}\n+\n+\n+\n+/*\n+  Write info about the ZipFile in the *pglobal_info structure.\n+  No preparation of the structure is needed\n+  return UNZ_OK if there is no problem.\n+*/\n+extern int ZEXPORT unzGetCurrentFileInfo (file,\n+                                                  pfile_info,\n+                                                  szFileName, fileNameBufferSize,\n+                                                  extraField, extraFieldBufferSize,\n+                                                  szComment,  commentBufferSize)\n+\tunzFile file;\n+\tunz_file_info *pfile_info;\n+\tchar *szFileName;\n+\tuLong fileNameBufferSize;\n+\tvoid *extraField;\n+\tuLong extraFieldBufferSize;\n+\tchar *szComment;\n+\tuLong commentBufferSize;\n+{\n+\treturn unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n+\t\t\t\t\t\t\t\t\t\t\t\tszFileName,fileNameBufferSize,\n+\t\t\t\t\t\t\t\t\t\t\t\textraField,extraFieldBufferSize,\n+\t\t\t\t\t\t\t\t\t\t\t\tszComment,commentBufferSize);\n+}\n+\n+/*\n+  Set the current file of the zipfile to the first file.\n+  return UNZ_OK if there is no problem\n+*/\n+extern int ZEXPORT unzGoToFirstFile (file)\n+\tunzFile file;\n+{\n+\tint err=UNZ_OK;\n+\tunz_s* s;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\ts->pos_in_central_dir=s->offset_central_dir;\n+\ts->num_file=0;\n+\terr=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+\t\t\t\t\t\t\t\t\t\t\t &s->cur_file_info_internal,\n+\t\t\t\t\t\t\t\t\t\t\t NULL,0,NULL,0,NULL,0);\n+\ts->current_file_ok = (err == UNZ_OK);\n+\treturn err;\n+}\n+\n+\n+/*\n+  Set the current file of the zipfile to the next file.\n+  return UNZ_OK if there is no problem\n+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n+*/\n+extern int ZEXPORT unzGoToNextFile (file)\n+\tunzFile file;\n+{\n+\tunz_s* s;\t\n+\tint err;\n+\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\tif (!s->current_file_ok)\n+\t\treturn UNZ_END_OF_LIST_OF_FILE;\n+\tif (s->num_file+1==s->gi.number_entry)\n+\t\treturn UNZ_END_OF_LIST_OF_FILE;\n+\n+\ts->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n+\t\t\ts->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n+\ts->num_file++;\n+\terr = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+\t\t\t\t\t\t\t\t\t\t\t   &s->cur_file_info_internal,\n+\t\t\t\t\t\t\t\t\t\t\t   NULL,0,NULL,0,NULL,0);\n+\ts->current_file_ok = (err == UNZ_OK);\n+\treturn err;\n+}\n+\n+\n+/*\n+  Try locate the file szFileName in the zipfile.\n+  For the iCaseSensitivity signification, see unzipStringFileNameCompare\n+\n+  return value :\n+  UNZ_OK if the file is found. It becomes the current file.\n+  UNZ_END_OF_LIST_OF_FILE if the file is not found\n+*/\n+extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)\n+\tunzFile file;\n+\tconst char *szFileName;\n+\tint iCaseSensitivity;\n+{\n+\tunz_s* s;\t\n+\tint err;\n+\n+\t\n+\tuLong num_fileSaved;\n+\tuLong pos_in_central_dirSaved;\n+\n+\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\n+    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n+        return UNZ_PARAMERROR;\n+\n+\ts=(unz_s*)file;\n+\tif (!s->current_file_ok)\n+\t\treturn UNZ_END_OF_LIST_OF_FILE;\n+\n+\tnum_fileSaved = s->num_file;\n+\tpos_in_central_dirSaved = s->pos_in_central_dir;\n+\n+\terr = unzGoToFirstFile(file);\n+\n+\twhile (err == UNZ_OK)\n+\t{\n+\t\tchar szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n+\t\tunzGetCurrentFileInfo(file,NULL,\n+\t\t\t\t\t\t\t\tszCurrentFileName,sizeof(szCurrentFileName)-1,\n+\t\t\t\t\t\t\t\tNULL,0,NULL,0);\n+\t\tif (unzStringFileNameCompare(szCurrentFileName,\n+\t\t\t\t\t\t\t\t\t\tszFileName,iCaseSensitivity)==0)\n+\t\t\treturn UNZ_OK;\n+\t\terr = unzGoToNextFile(file);\n+\t}\n+\n+\ts->num_file = num_fileSaved ;\n+\ts->pos_in_central_dir = pos_in_central_dirSaved ;\n+\treturn err;\n+}\n+\n+\n+/*\n+  Read the local header of the current zipfile\n+  Check the coherency of the local header and info in the end of central\n+        directory about this file\n+  store in *piSizeVar the size of extra info in local header\n+        (filename and size of extra field data)\n+*/\n+local int unzlocal_CheckCurrentFileCoherencyHeader (s,piSizeVar,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tpoffset_local_extrafield,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tpsize_local_extrafield)\n+\tunz_s* s;\n+\tuInt* piSizeVar;\n+\tuLong *poffset_local_extrafield;\n+\tuInt  *psize_local_extrafield;\n+{\n+\tuLong uMagic,uData,uFlags;\n+\tuLong size_filename;\n+\tuLong size_extra_field;\n+\tint err=UNZ_OK;\n+\n+\t*piSizeVar = 0;\n+\t*poffset_local_extrafield = 0;\n+\t*psize_local_extrafield = 0;\n+\n+\tif (fseek(s->file,s->cur_file_info_internal.offset_curfile +\n+\t\t\t\t\t\t\t\ts->byte_before_the_zipfile,SEEK_SET)!=0)\n+\t\treturn UNZ_ERRNO;\n+\n+\n+\tif (err==UNZ_OK)\n+\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n+\t\t\terr=UNZ_ERRNO;\n+\t\telse if (uMagic!=0x04034b50)\n+\t\t\terr=UNZ_BADZIPFILE;\n+\n+\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+/*\n+\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n+\t\terr=UNZ_BADZIPFILE;\n+*/\n+\tif (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n+                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n+        err=UNZ_BADZIPFILE;\n+\n+\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* date/time */\n+\t\terr=UNZ_ERRNO;\n+\n+\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* crc */\n+\t\terr=UNZ_ERRNO;\n+\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&\n+\t\t                      ((uFlags & 8)==0))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size compr */\n+\t\terr=UNZ_ERRNO;\n+\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&\n+\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size uncompr */\n+\t\terr=UNZ_ERRNO;\n+\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && \n+\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\n+\tif (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\telse if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n+\t\terr=UNZ_BADZIPFILE;\n+\n+\t*piSizeVar += (uInt)size_filename;\n+\n+\tif (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)\n+\t\terr=UNZ_ERRNO;\n+\t*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n+\t\t\t\t\t\t\t\t\tSIZEZIPLOCALHEADER + size_filename;\n+\t*psize_local_extrafield = (uInt)size_extra_field;\n+\n+\t*piSizeVar += (uInt)size_extra_field;\n+\n+\treturn err;\n+}\n+\t\t\t\t\t\t\t\t\t\t\t\t\n+/*\n+  Open for reading data the current file in the zipfile.\n+  If there is no error and the file is opened, the return value is UNZ_OK.\n+*/\n+extern int ZEXPORT unzOpenCurrentFile (file)\n+\tunzFile file;\n+{\n+\tint err=UNZ_OK;\n+\tint Store;\n+\tuInt iSizeVar;\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tuLong offset_local_extrafield;  /* offset of the local extra field */\n+\tuInt  size_local_extrafield;    /* size of the local extra field */\n+\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\tif (!s->current_file_ok)\n+\t\treturn UNZ_PARAMERROR;\n+\n+    if (s->pfile_in_zip_read != NULL)\n+        unzCloseCurrentFile(file);\n+\n+\tif (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,\n+\t\t\t\t&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n+\t\treturn UNZ_BADZIPFILE;\n+\n+\tpfile_in_zip_read_info = (file_in_zip_read_info_s*)\n+\t\t\t\t\t\t\t\t\t    ALLOC(sizeof(file_in_zip_read_info_s));\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_INTERNALERROR;\n+\n+\tpfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n+\tpfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n+\tpfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n+\tpfile_in_zip_read_info->pos_local_extrafield=0;\n+\n+\tif (pfile_in_zip_read_info->read_buffer==NULL)\n+\t{\n+\t\tTRYFREE(pfile_in_zip_read_info);\n+\t\treturn UNZ_INTERNALERROR;\n+\t}\n+\n+\tpfile_in_zip_read_info->stream_initialised=0;\n+\t\n+\tif ((s->cur_file_info.compression_method!=0) &&\n+        (s->cur_file_info.compression_method!=Z_DEFLATED))\n+\t\terr=UNZ_BADZIPFILE;\n+\tStore = s->cur_file_info.compression_method==0;\n+\n+\tpfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n+\tpfile_in_zip_read_info->crc32=0;\n+\tpfile_in_zip_read_info->compression_method =\n+            s->cur_file_info.compression_method;\n+\tpfile_in_zip_read_info->file=s->file;\n+\tpfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n+\n+    pfile_in_zip_read_info->stream.total_out = 0;\n+\n+\tif (!Store)\n+\t{\n+\t  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n+\t  pfile_in_zip_read_info->stream.zfree = (free_func)0;\n+\t  pfile_in_zip_read_info->stream.opaque = (voidpf)0; \n+      \n+\t  err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n+\t  if (err == Z_OK)\n+\t    pfile_in_zip_read_info->stream_initialised=1;\n+        /* windowBits is passed < 0 to tell that there is no zlib header.\n+         * Note that in this case inflate *requires* an extra \"dummy\" byte\n+         * after the compressed stream in order to complete decompression and\n+         * return Z_STREAM_END. \n+         * In unzip, i don't wait absolutely Z_STREAM_END because I known the \n+         * size of both compressed and uncompressed data\n+         */\n+\t}\n+\tpfile_in_zip_read_info->rest_read_compressed = \n+            s->cur_file_info.compressed_size ;\n+\tpfile_in_zip_read_info->rest_read_uncompressed = \n+            s->cur_file_info.uncompressed_size ;\n+\n+\t\n+\tpfile_in_zip_read_info->pos_in_zipfile = \n+            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + \n+\t\t\t  iSizeVar;\n+\t\n+\tpfile_in_zip_read_info->stream.avail_in = (uInt)0;\n+\n+\n+\ts->pfile_in_zip_read = pfile_in_zip_read_info;\n+    return UNZ_OK;\n+}\n+\n+\n+/*\n+  Read bytes from the current file.\n+  buf contain buffer where data must be copied\n+  len the size of buf.\n+\n+  return the number of byte copied if somes bytes are copied\n+  return 0 if the end of file was reached\n+  return <0 with error code if there is an error\n+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n+*/\n+extern int ZEXPORT unzReadCurrentFile  (file, buf, len)\n+\tunzFile file;\n+\tvoidp buf;\n+\tunsigned len;\n+{\n+\tint err=UNZ_OK;\n+\tuInt iRead = 0;\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+    pfile_in_zip_read_info=s->pfile_in_zip_read;\n+\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\n+\n+\tif ((pfile_in_zip_read_info->read_buffer == NULL))\n+\t\treturn UNZ_END_OF_LIST_OF_FILE;\n+\tif (len==0)\n+\t\treturn 0;\n+\n+\tpfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n+\n+\tpfile_in_zip_read_info->stream.avail_out = (uInt)len;\n+\t\n+\tif (len>pfile_in_zip_read_info->rest_read_uncompressed)\n+\t\tpfile_in_zip_read_info->stream.avail_out = \n+\t\t  (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n+\n+\twhile (pfile_in_zip_read_info->stream.avail_out>0)\n+\t{\n+\t\tif ((pfile_in_zip_read_info->stream.avail_in==0) &&\n+            (pfile_in_zip_read_info->rest_read_compressed>0))\n+\t\t{\n+\t\t\tuInt uReadThis = UNZ_BUFSIZE;\n+\t\t\tif (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n+\t\t\t\tuReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n+\t\t\tif (uReadThis == 0)\n+\t\t\t\treturn UNZ_EOF;\n+\t\t\tif (fseek(pfile_in_zip_read_info->file,\n+                      pfile_in_zip_read_info->pos_in_zipfile + \n+                         pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0)\n+\t\t\t\treturn UNZ_ERRNO;\n+\t\t\tif (fread(pfile_in_zip_read_info->read_buffer,uReadThis,1,\n+                         pfile_in_zip_read_info->file)!=1)\n+\t\t\t\treturn UNZ_ERRNO;\n+\t\t\tpfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n+\n+\t\t\tpfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n+\t\t\t\n+\t\t\tpfile_in_zip_read_info->stream.next_in = \n+                (Bytef*)pfile_in_zip_read_info->read_buffer;\n+\t\t\tpfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n+\t\t}\n+\n+\t\tif (pfile_in_zip_read_info->compression_method==0)\n+\t\t{\n+\t\t\tuInt uDoCopy,i ;\n+\t\t\tif (pfile_in_zip_read_info->stream.avail_out < \n+                            pfile_in_zip_read_info->stream.avail_in)\n+\t\t\t\tuDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n+\t\t\telse\n+\t\t\t\tuDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n+\t\t\t\t\n+\t\t\tfor (i=0;i<uDoCopy;i++)\n+\t\t\t\t*(pfile_in_zip_read_info->stream.next_out+i) =\n+                        *(pfile_in_zip_read_info->stream.next_in+i);\n+\t\t\t\t\t\n+\t\t\tpfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n+\t\t\t\t\t\t\t\tpfile_in_zip_read_info->stream.next_out,\n+\t\t\t\t\t\t\t\tuDoCopy);\n+\t\t\tpfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n+\t\t\tpfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n+\t\t\tpfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n+\t\t\tpfile_in_zip_read_info->stream.next_out += uDoCopy;\n+\t\t\tpfile_in_zip_read_info->stream.next_in += uDoCopy;\n+            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n+\t\t\tiRead += uDoCopy;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tuLong uTotalOutBefore,uTotalOutAfter;\n+\t\t\tconst Bytef *bufBefore;\n+\t\t\tuLong uOutThis;\n+\t\t\tint flush=Z_SYNC_FLUSH;\n+\n+\t\t\tuTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n+\t\t\tbufBefore = pfile_in_zip_read_info->stream.next_out;\n+\n+\t\t\t/*\n+\t\t\tif ((pfile_in_zip_read_info->rest_read_uncompressed ==\n+\t\t\t         pfile_in_zip_read_info->stream.avail_out) &&\n+\t\t\t\t(pfile_in_zip_read_info->rest_read_compressed == 0))\n+\t\t\t\tflush = Z_FINISH;\n+\t\t\t*/\n+\t\t\terr=inflate(&pfile_in_zip_read_info->stream,flush);\n+\n+\t\t\tuTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n+\t\t\tuOutThis = uTotalOutAfter-uTotalOutBefore;\n+\t\t\t\n+\t\t\tpfile_in_zip_read_info->crc32 = \n+                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n+                        (uInt)(uOutThis));\n+\n+\t\t\tpfile_in_zip_read_info->rest_read_uncompressed -=\n+                uOutThis;\n+\n+\t\t\tiRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n+            \n+\t\t\tif (err==Z_STREAM_END)\n+\t\t\t\treturn (iRead==0) ? UNZ_EOF : iRead;\n+\t\t\tif (err!=Z_OK) \n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (err==Z_OK)\n+\t\treturn iRead;\n+\treturn err;\n+}\n+\n+\n+/*\n+  Give the current position in uncompressed data\n+*/\n+extern z_off_t ZEXPORT unztell (file)\n+\tunzFile file;\n+{\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+    pfile_in_zip_read_info=s->pfile_in_zip_read;\n+\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\n+\treturn (z_off_t)pfile_in_zip_read_info->stream.total_out;\n+}\n+\n+\n+/*\n+  return 1 if the end of file was reached, 0 elsewhere \n+*/\n+extern int ZEXPORT unzeof (file)\n+\tunzFile file;\n+{\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+    pfile_in_zip_read_info=s->pfile_in_zip_read;\n+\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\t\n+\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n+\t\treturn 1;\n+\telse\n+\t\treturn 0;\n+}\n+\n+\n+\n+/*\n+  Read extra field from the current file (opened by unzOpenCurrentFile)\n+  This is the local-header version of the extra field (sometimes, there is\n+    more info in the local-header version than in the central-header)\n+\n+  if buf==NULL, it return the size of the local extra field that can be read\n+\n+  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n+\tbuf.\n+  the return value is the number of bytes copied in buf, or (if <0) \n+\tthe error code\n+*/\n+extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)\n+\tunzFile file;\n+\tvoidp buf;\n+\tunsigned len;\n+{\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tuInt read_now;\n+\tuLong size_to_read;\n+\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+    pfile_in_zip_read_info=s->pfile_in_zip_read;\n+\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\n+\tsize_to_read = (pfile_in_zip_read_info->size_local_extrafield - \n+\t\t\t\tpfile_in_zip_read_info->pos_local_extrafield);\n+\n+\tif (buf==NULL)\n+\t\treturn (int)size_to_read;\n+\t\n+\tif (len>size_to_read)\n+\t\tread_now = (uInt)size_to_read;\n+\telse\n+\t\tread_now = (uInt)len ;\n+\n+\tif (read_now==0)\n+\t\treturn 0;\n+\t\n+\tif (fseek(pfile_in_zip_read_info->file,\n+              pfile_in_zip_read_info->offset_local_extrafield + \n+\t\t\t  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)\n+\t\treturn UNZ_ERRNO;\n+\n+\tif (fread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)\n+\t\treturn UNZ_ERRNO;\n+\n+\treturn (int)read_now;\n+}\n+\n+/*\n+  Close the file in zip opened with unzipOpenCurrentFile\n+  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n+*/\n+extern int ZEXPORT unzCloseCurrentFile (file)\n+\tunzFile file;\n+{\n+\tint err=UNZ_OK;\n+\n+\tunz_s* s;\n+\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+    pfile_in_zip_read_info=s->pfile_in_zip_read;\n+\n+\tif (pfile_in_zip_read_info==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\n+\n+\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n+\t{\n+\t\tif (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n+\t\t\terr=UNZ_CRCERROR;\n+\t}\n+\n+\n+\tTRYFREE(pfile_in_zip_read_info->read_buffer);\n+\tpfile_in_zip_read_info->read_buffer = NULL;\n+\tif (pfile_in_zip_read_info->stream_initialised)\n+\t\tinflateEnd(&pfile_in_zip_read_info->stream);\n+\n+\tpfile_in_zip_read_info->stream_initialised = 0;\n+\tTRYFREE(pfile_in_zip_read_info);\n+\n+    s->pfile_in_zip_read=NULL;\n+\n+\treturn err;\n+}\n+\n+\n+/*\n+  Get the global comment string of the ZipFile, in the szComment buffer.\n+  uSizeBuf is the size of the szComment buffer.\n+  return the number of byte copied or an error code <0\n+*/\n+extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)\n+\tunzFile file;\n+\tchar *szComment;\n+\tuLong uSizeBuf;\n+{\n+\tint err=UNZ_OK;\n+\tunz_s* s;\n+\tuLong uReadThis ;\n+\tif (file==NULL)\n+\t\treturn UNZ_PARAMERROR;\n+\ts=(unz_s*)file;\n+\n+\tuReadThis = uSizeBuf;\n+\tif (uReadThis>s->gi.size_comment)\n+\t\tuReadThis = s->gi.size_comment;\n+\n+\tif (fseek(s->file,s->central_pos+22,SEEK_SET)!=0)\n+\t\treturn UNZ_ERRNO;\n+\n+\tif (uReadThis>0)\n+    {\n+      *szComment='\\0';\n+\t  if (fread(szComment,(uInt)uReadThis,1,s->file)!=1)\n+\t\treturn UNZ_ERRNO;\n+    }\n+\n+\tif ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n+\t\t*(szComment+s->gi.size_comment)='\\0';\n+\treturn (int)uReadThis;\n+}"}, {"sha": "f6ede89bc96632477951e12966203743e1360088", "filename": "zlib/contrib/minizip/unzip.def", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,15 @@\n+\tunzOpen                       @61\n+\tunzClose                      @62\n+\tunzGetGlobalInfo              @63\n+\tunzGetCurrentFileInfo         @64\n+\tunzGoToFirstFile              @65\n+\tunzGoToNextFile               @66\n+\tunzOpenCurrentFile            @67\n+\tunzReadCurrentFile            @68\n+\tunztell                       @70\n+\tunzeof                        @71\n+\tunzCloseCurrentFile           @72\n+\tunzGetGlobalComment           @73\n+\tunzStringFileNameCompare      @74\n+\tunzLocateFile                 @75\n+\tunzGetLocalExtrafield         @76"}, {"sha": "76692cb703cf3e77f31dc66746afb36c5d83be61", "filename": "zlib/contrib/minizip/unzip.h", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Funzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,275 @@\n+/* unzip.h -- IO for uncompress .zip files using zlib \n+   Version 0.15 beta, Mar 19th, 1998,\n+\n+   Copyright (C) 1998 Gilles Vollant\n+\n+   This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g\n+     WinZip, InfoZip tools and compatible.\n+   Encryption and multi volume ZipFile (span) are not supported.\n+   Old compressions used by old PKZip 1.x are not supported\n+\n+   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE\n+   CAN CHANGE IN FUTURE VERSION !!\n+   I WAIT FEEDBACK at mail info@winimage.com\n+   Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution\n+\n+   Condition of use and distribution are the same than zlib :\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the authors be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+\n+*/\n+/* for more info about .ZIP format, see \n+      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip\n+   PkWare has also a specification at :\n+      ftp://ftp.pkware.com/probdesc.zip */\n+\n+#ifndef _unz_H\n+#define _unz_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifndef _ZLIB_H\n+#include \"zlib.h\"\n+#endif\n+\n+#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)\n+/* like the STRICT of WIN32, we define a pointer that cannot be converted\n+    from (void*) without cast */\n+typedef struct TagunzFile__ { int unused; } unzFile__; \n+typedef unzFile__ *unzFile;\n+#else\n+typedef voidp unzFile;\n+#endif\n+\n+\n+#define UNZ_OK                                  (0)\n+#define UNZ_END_OF_LIST_OF_FILE (-100)\n+#define UNZ_ERRNO               (Z_ERRNO)\n+#define UNZ_EOF                 (0)\n+#define UNZ_PARAMERROR                  (-102)\n+#define UNZ_BADZIPFILE                  (-103)\n+#define UNZ_INTERNALERROR               (-104)\n+#define UNZ_CRCERROR                    (-105)\n+\n+/* tm_unz contain date/time info */\n+typedef struct tm_unz_s \n+{\n+\tuInt tm_sec;            /* seconds after the minute - [0,59] */\n+\tuInt tm_min;            /* minutes after the hour - [0,59] */\n+\tuInt tm_hour;           /* hours since midnight - [0,23] */\n+\tuInt tm_mday;           /* day of the month - [1,31] */\n+\tuInt tm_mon;            /* months since January - [0,11] */\n+\tuInt tm_year;           /* years - [1980..2044] */\n+} tm_unz;\n+\n+/* unz_global_info structure contain global data about the ZIPfile\n+   These data comes from the end of central dir */\n+typedef struct unz_global_info_s\n+{\n+\tuLong number_entry;         /* total number of entries in\n+\t\t\t\t       the central dir on this disk */\n+\tuLong size_comment;         /* size of the global comment of the zipfile */\n+} unz_global_info;\n+\n+\n+/* unz_file_info contain information about a file in the zipfile */\n+typedef struct unz_file_info_s\n+{\n+    uLong version;              /* version made by                 2 bytes */\n+    uLong version_needed;       /* version needed to extract       2 bytes */\n+    uLong flag;                 /* general purpose bit flag        2 bytes */\n+    uLong compression_method;   /* compression method              2 bytes */\n+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n+    uLong crc;                  /* crc-32                          4 bytes */\n+    uLong compressed_size;      /* compressed size                 4 bytes */ \n+    uLong uncompressed_size;    /* uncompressed size               4 bytes */ \n+    uLong size_filename;        /* filename length                 2 bytes */\n+    uLong size_file_extra;      /* extra field length              2 bytes */\n+    uLong size_file_comment;    /* file comment length             2 bytes */\n+\n+    uLong disk_num_start;       /* disk number start               2 bytes */\n+    uLong internal_fa;          /* internal file attributes        2 bytes */\n+    uLong external_fa;          /* external file attributes        4 bytes */\n+\n+    tm_unz tmu_date;\n+} unz_file_info;\n+\n+extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,\n+\t\t\t\t\t\t\t\t\t\t\t\t const char* fileName2,\n+\t\t\t\t\t\t\t\t\t\t\t\t int iCaseSensitivity));\n+/*\n+   Compare two filename (fileName1,fileName2).\n+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n+\t\t\t\t\t\t\t\tor strcasecmp)\n+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n+\t(like 1 on Unix, 2 on Windows)\n+*/\n+\n+\n+extern unzFile ZEXPORT unzOpen OF((const char *path));\n+/*\n+  Open a Zip file. path contain the full pathname (by example,\n+     on a Windows NT computer \"c:\\\\zlib\\\\zlib111.zip\" or on an Unix computer\n+\t \"zlib/zlib111.zip\".\n+\t If the zipfile cannot be opened (file don't exist or in not valid), the\n+\t   return value is NULL.\n+     Else, the return value is a unzFile Handle, usable with other function\n+\t   of this unzip package.\n+*/\n+\n+extern int ZEXPORT unzClose OF((unzFile file));\n+/*\n+  Close a ZipFile opened with unzipOpen.\n+  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),\n+    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n+  return UNZ_OK if there is no problem. */\n+\n+extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,\n+\t\t\t\t\tunz_global_info *pglobal_info));\n+/*\n+  Write info about the ZipFile in the *pglobal_info structure.\n+  No preparation of the structure is needed\n+  return UNZ_OK if there is no problem. */\n+\n+\n+extern int ZEXPORT unzGetGlobalComment OF((unzFile file,\n+\t\t\t\t\t\t\t\t\t\t   char *szComment,\n+\t\t\t\t\t   uLong uSizeBuf));\n+/*\n+  Get the global comment string of the ZipFile, in the szComment buffer.\n+  uSizeBuf is the size of the szComment buffer.\n+  return the number of byte copied or an error code <0\n+*/\n+\n+\n+/***************************************************************************/\n+/* Unzip package allow you browse the directory of the zipfile */\n+\n+extern int ZEXPORT unzGoToFirstFile OF((unzFile file));\n+/*\n+  Set the current file of the zipfile to the first file.\n+  return UNZ_OK if there is no problem\n+*/\n+\n+extern int ZEXPORT unzGoToNextFile OF((unzFile file));\n+/*\n+  Set the current file of the zipfile to the next file.\n+  return UNZ_OK if there is no problem\n+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n+*/\n+\n+extern int ZEXPORT unzLocateFile OF((unzFile file, \n+\t\t\t\t     const char *szFileName,\n+\t\t\t\t     int iCaseSensitivity));\n+/*\n+  Try locate the file szFileName in the zipfile.\n+  For the iCaseSensitivity signification, see unzStringFileNameCompare\n+\n+  return value :\n+  UNZ_OK if the file is found. It becomes the current file.\n+  UNZ_END_OF_LIST_OF_FILE if the file is not found\n+*/\n+\n+\n+extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,\n+\t\t\t\t\t     unz_file_info *pfile_info,\n+\t\t\t\t\t     char *szFileName,\n+\t\t\t\t\t     uLong fileNameBufferSize,\n+\t\t\t\t\t     void *extraField,\n+\t\t\t\t\t     uLong extraFieldBufferSize,\n+\t\t\t\t\t     char *szComment,\n+\t\t\t\t\t     uLong commentBufferSize));\n+/*\n+  Get Info about the current file\n+  if pfile_info!=NULL, the *pfile_info structure will contain somes info about\n+\t    the current file\n+  if szFileName!=NULL, the filemane string will be copied in szFileName\n+\t\t\t(fileNameBufferSize is the size of the buffer)\n+  if extraField!=NULL, the extra field information will be copied in extraField\n+\t\t\t(extraFieldBufferSize is the size of the buffer).\n+\t\t\tThis is the Central-header version of the extra field\n+  if szComment!=NULL, the comment string of the file will be copied in szComment\n+\t\t\t(commentBufferSize is the size of the buffer)\n+*/\n+\n+/***************************************************************************/\n+/* for reading the content of the current zipfile, you can open it, read data\n+   from it, and close it (you can close it before reading all the file)\n+   */\n+\n+extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));\n+/*\n+  Open for reading data the current file in the zipfile.\n+  If there is no error, the return value is UNZ_OK.\n+*/\n+\n+extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));\n+/*\n+  Close the file in zip opened with unzOpenCurrentFile\n+  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n+*/\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\n+extern int ZEXPORT unzReadCurrentFile OF((unzFile file, \n+\t\t\t\t\t  voidp buf,\n+\t\t\t\t\t  unsigned len));\n+/*\n+  Read bytes from the current file (opened by unzOpenCurrentFile)\n+  buf contain buffer where data must be copied\n+  len the size of buf.\n+\n+  return the number of byte copied if somes bytes are copied\n+  return 0 if the end of file was reached\n+  return <0 with error code if there is an error\n+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n+*/\n+\n+extern z_off_t ZEXPORT unztell OF((unzFile file));\n+/*\n+  Give the current position in uncompressed data\n+*/\n+\n+extern int ZEXPORT unzeof OF((unzFile file));\n+/*\n+  return 1 if the end of file was reached, 0 elsewhere \n+*/\n+\n+extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,\n+\t\t\t\t\t\t\t\t\t\t\t voidp buf,\n+\t\t\t\t\t\t\t\t\t\t\t unsigned len));\n+/*\n+  Read extra field from the current file (opened by unzOpenCurrentFile)\n+  This is the local-header version of the extra field (sometimes, there is\n+    more info in the local-header version than in the central-header)\n+\n+  if buf==NULL, it return the size of the local extra field\n+\n+  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n+\tbuf.\n+  the return value is the number of bytes copied in buf, or (if <0) \n+\tthe error code\n+*/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* _unz_H */"}, {"sha": "0cae64ab7b1a3cb2cbe15f5b5560d88e2607c550", "filename": "zlib/contrib/minizip/zip.c", "status": "added", "additions": 718, "deletions": 0, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,718 @@\n+/* zip.c -- IO on .zip files using zlib \n+   Version 0.15 beta, Mar 19th, 1998,\n+\n+   Read zip.h for more info\n+*/\n+\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"zlib.h\"\n+#include \"zip.h\"\n+\n+#ifdef STDC\n+#  include <stddef.h>\n+#  include <string.h>\n+#  include <stdlib.h>\n+#endif\n+#ifdef NO_ERRNO_H\n+    extern int errno;\n+#else\n+#   include <errno.h>\n+#endif\n+\n+\n+#ifndef local\n+#  define local static\n+#endif\n+/* compile with -Dlocal if your debugger can't find static symbols */\n+\n+#ifndef VERSIONMADEBY\n+# define VERSIONMADEBY   (0x0) /* platform depedent */\n+#endif\n+\n+#ifndef Z_BUFSIZE\n+#define Z_BUFSIZE (16384)\n+#endif\n+\n+#ifndef Z_MAXFILENAMEINZIP\n+#define Z_MAXFILENAMEINZIP (256)\n+#endif\n+\n+#ifndef ALLOC\n+# define ALLOC(size) (malloc(size))\n+#endif\n+#ifndef TRYFREE\n+# define TRYFREE(p) {if (p) free(p);}\n+#endif\n+\n+/*\n+#define SIZECENTRALDIRITEM (0x2e)\n+#define SIZEZIPLOCALHEADER (0x1e)\n+*/\n+\n+/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */\n+\n+#ifndef SEEK_CUR\n+#define SEEK_CUR    1\n+#endif\n+\n+#ifndef SEEK_END\n+#define SEEK_END    2\n+#endif\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET    0\n+#endif\n+\n+const char zip_copyright[] =\n+   \" zip 0.15 Copyright 1998 Gilles Vollant \";\n+\n+\n+#define SIZEDATA_INDATABLOCK (4096-(4*4))\n+\n+#define LOCALHEADERMAGIC    (0x04034b50)\n+#define CENTRALHEADERMAGIC  (0x02014b50)\n+#define ENDHEADERMAGIC      (0x06054b50)\n+\n+#define FLAG_LOCALHEADER_OFFSET (0x06)\n+#define CRC_LOCALHEADER_OFFSET  (0x0e)\n+\n+#define SIZECENTRALHEADER (0x2e) /* 46 */\n+\n+typedef struct linkedlist_datablock_internal_s\n+{\n+  struct linkedlist_datablock_internal_s* next_datablock;\n+  uLong  avail_in_this_block;\n+  uLong  filled_in_this_block;\n+  uLong  unused; /* for future use and alignement */\n+  unsigned char data[SIZEDATA_INDATABLOCK];\n+} linkedlist_datablock_internal;\n+\n+typedef struct linkedlist_data_s\n+{\n+    linkedlist_datablock_internal* first_block;\n+    linkedlist_datablock_internal* last_block;\n+} linkedlist_data;\n+\n+\n+typedef struct\n+{\n+\tz_stream stream;            /* zLib stream structure for inflate */\n+    int  stream_initialised;    /* 1 is stream is initialised */\n+    uInt pos_in_buffered_data;  /* last written byte in buffered_data */\n+\n+    uLong pos_local_header;     /* offset of the local header of the file \n+                                     currenty writing */\n+    char* central_header;       /* central header data for the current file */\n+    uLong size_centralheader;   /* size of the central header for cur file */\n+    uLong flag;                 /* flag of the file currently writing */\n+\n+    int  method;                /* compression method of file currenty wr.*/\n+    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/\n+    uLong dosDate;\n+    uLong crc32;\n+} curfile_info;\n+\n+typedef struct\n+{\n+    FILE * filezip;\n+    linkedlist_data central_dir;/* datablock with central dir in construction*/\n+    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/\n+    curfile_info ci;            /* info on the file curretly writing */\n+\n+    uLong begin_pos;            /* position of the beginning of the zipfile */\n+    uLong number_entry;\n+} zip_internal;\n+\n+local linkedlist_datablock_internal* allocate_new_datablock()\n+{\n+    linkedlist_datablock_internal* ldi;\n+    ldi = (linkedlist_datablock_internal*)\n+                 ALLOC(sizeof(linkedlist_datablock_internal));\n+    if (ldi!=NULL)\n+    {\n+        ldi->next_datablock = NULL ;\n+        ldi->filled_in_this_block = 0 ;\n+        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;\n+    }\n+    return ldi;\n+}\n+\n+local void free_datablock(ldi)\n+    linkedlist_datablock_internal* ldi;\n+{\n+    while (ldi!=NULL)\n+    {\n+        linkedlist_datablock_internal* ldinext = ldi->next_datablock;\n+        TRYFREE(ldi);\n+        ldi = ldinext;\n+    }\n+}\n+\n+local void init_linkedlist(ll)\n+    linkedlist_data* ll;\n+{\n+    ll->first_block = ll->last_block = NULL;\n+}\n+\n+local void free_linkedlist(ll)\n+    linkedlist_data* ll;\n+{\n+    free_datablock(ll->first_block);\n+    ll->first_block = ll->last_block = NULL;\n+}\n+\n+\n+local int add_data_in_datablock(ll,buf,len)\n+    linkedlist_data* ll;    \n+    const void* buf;\n+    uLong len;\n+{\n+    linkedlist_datablock_internal* ldi;\n+    const unsigned char* from_copy;\n+\n+    if (ll==NULL)\n+        return ZIP_INTERNALERROR;\n+\n+    if (ll->last_block == NULL)\n+    {\n+        ll->first_block = ll->last_block = allocate_new_datablock();\n+        if (ll->first_block == NULL)\n+            return ZIP_INTERNALERROR;\n+    }\n+\n+    ldi = ll->last_block;\n+    from_copy = (unsigned char*)buf;\n+\n+    while (len>0)\n+    {\n+        uInt copy_this;\n+        uInt i;\n+        unsigned char* to_copy;\n+\n+        if (ldi->avail_in_this_block==0)\n+        {\n+            ldi->next_datablock = allocate_new_datablock();\n+            if (ldi->next_datablock == NULL)\n+                return ZIP_INTERNALERROR;\n+            ldi = ldi->next_datablock ;\n+            ll->last_block = ldi;\n+        }\n+\n+        if (ldi->avail_in_this_block < len)\n+            copy_this = (uInt)ldi->avail_in_this_block;\n+        else\n+            copy_this = (uInt)len;\n+\n+        to_copy = &(ldi->data[ldi->filled_in_this_block]);\n+\n+        for (i=0;i<copy_this;i++)\n+            *(to_copy+i)=*(from_copy+i);\n+\n+        ldi->filled_in_this_block += copy_this;\n+        ldi->avail_in_this_block -= copy_this;\n+        from_copy += copy_this ;\n+        len -= copy_this;\n+    }\n+    return ZIP_OK;\n+}\n+\n+\n+local int write_datablock(fout,ll)\n+    FILE * fout;\n+    linkedlist_data* ll;    \n+{\n+    linkedlist_datablock_internal* ldi;\n+    ldi = ll->first_block;\n+    while (ldi!=NULL)\n+    {\n+        if (ldi->filled_in_this_block > 0)\n+            if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,1,fout)!=1)\n+                return ZIP_ERRNO;\n+        ldi = ldi->next_datablock;\n+    }\n+    return ZIP_OK;\n+}\n+\n+/****************************************************************************/\n+\n+/* ===========================================================================\n+   Outputs a long in LSB order to the given file\n+   nbByte == 1, 2 or 4 (byte, short or long)\n+*/\n+\n+local int ziplocal_putValue OF((FILE *file, uLong x, int nbByte));\n+local int ziplocal_putValue (file, x, nbByte)\n+    FILE *file;\n+    uLong x;\n+    int nbByte;\n+{\n+    unsigned char buf[4];\n+    int n;\n+    for (n = 0; n < nbByte; n++) {\n+        buf[n] = (unsigned char)(x & 0xff);\n+        x >>= 8;\n+    }\n+    if (fwrite(buf,nbByte,1,file)!=1)\n+        return ZIP_ERRNO;\n+    else\n+        return ZIP_OK;\n+}\n+\n+local void ziplocal_putValue_inmemory OF((void* dest, uLong x, int nbByte));\n+local void ziplocal_putValue_inmemory (dest, x, nbByte)\n+    void* dest;\n+    uLong x;\n+    int nbByte;\n+{\n+    unsigned char* buf=(unsigned char*)dest;\n+    int n;\n+    for (n = 0; n < nbByte; n++) {\n+        buf[n] = (unsigned char)(x & 0xff);\n+        x >>= 8;\n+    }\n+}\n+/****************************************************************************/\n+\n+\n+local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)\n+    tm_zip* ptm;\n+    uLong dosDate;\n+{\n+    uLong year = (uLong)ptm->tm_year;\n+    if (year>1980)\n+        year-=1980;\n+    else if (year>80)\n+        year-=80;\n+    return\n+      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |\n+        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));\n+}\n+\n+\n+/****************************************************************************/\n+\n+extern zipFile ZEXPORT zipOpen (pathname, append)\n+    const char *pathname;\n+    int append;\n+{\n+    zip_internal ziinit;\n+    zip_internal* zi;\n+\n+    ziinit.filezip = fopen(pathname,(append == 0) ? \"wb\" : \"ab\");\n+    if (ziinit.filezip == NULL)\n+        return NULL;\n+    ziinit.begin_pos = ftell(ziinit.filezip);\n+    ziinit.in_opened_file_inzip = 0;\n+    ziinit.ci.stream_initialised = 0;\n+    ziinit.number_entry = 0;\n+    init_linkedlist(&(ziinit.central_dir));\n+\n+\n+    zi = (zip_internal*)ALLOC(sizeof(zip_internal));\n+    if (zi==NULL)\n+    {\n+        fclose(ziinit.filezip);\n+        return NULL;\n+    }\n+\n+    *zi = ziinit;\n+    return (zipFile)zi;\n+}\n+\n+extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi, \n+                                        extrafield_local, size_extrafield_local,\n+                                        extrafield_global, size_extrafield_global,\n+                                        comment, method, level)\n+    zipFile file;\n+    const char* filename;\n+    const zip_fileinfo* zipfi;\n+    const void* extrafield_local;\n+    uInt size_extrafield_local;\n+    const void* extrafield_global;\n+    uInt size_extrafield_global;\n+    const char* comment;\n+    int method;\n+    int level;\n+{\n+    zip_internal* zi;\n+    uInt size_filename;\n+    uInt size_comment;\n+    uInt i;\n+    int err = ZIP_OK;\n+\n+    if (file == NULL)\n+        return ZIP_PARAMERROR;\n+    if ((method!=0) && (method!=Z_DEFLATED))\n+        return ZIP_PARAMERROR;\n+\n+    zi = (zip_internal*)file;\n+\n+    if (zi->in_opened_file_inzip == 1)\n+    {\n+        err = zipCloseFileInZip (file);\n+        if (err != ZIP_OK)\n+            return err;\n+    }\n+\n+\n+    if (filename==NULL)\n+        filename=\"-\";\n+\n+    if (comment==NULL)\n+        size_comment = 0;\n+    else\n+        size_comment = strlen(comment);\n+\n+    size_filename = strlen(filename);\n+\n+    if (zipfi == NULL)\n+        zi->ci.dosDate = 0;\n+    else\n+    {\n+        if (zipfi->dosDate != 0)\n+            zi->ci.dosDate = zipfi->dosDate;\n+        else zi->ci.dosDate = ziplocal_TmzDateToDosDate(&zipfi->tmz_date,zipfi->dosDate);\n+    }\n+\n+    zi->ci.flag = 0;\n+    if ((level==8) || (level==9))\n+      zi->ci.flag |= 2;\n+    if ((level==2))\n+      zi->ci.flag |= 4;\n+    if ((level==1))\n+      zi->ci.flag |= 6;\n+\n+    zi->ci.crc32 = 0;\n+    zi->ci.method = method;\n+    zi->ci.stream_initialised = 0;\n+    zi->ci.pos_in_buffered_data = 0;\n+    zi->ci.pos_local_header = ftell(zi->filezip);\n+    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + \n+                                      size_extrafield_global + size_comment;\n+    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader);\n+\n+    ziplocal_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);\n+    /* version info */\n+    ziplocal_putValue_inmemory(zi->ci.central_header+4,(uLong)VERSIONMADEBY,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/\n+    ziplocal_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/\n+    ziplocal_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/\n+    ziplocal_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/\n+\n+    if (zipfi==NULL)\n+        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2); \n+    else\n+        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2); \n+\n+    if (zipfi==NULL)\n+        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4); \n+    else\n+        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);\n+\n+    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header,4);\n+\n+    for (i=0;i<size_filename;i++)\n+        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);\n+\n+    for (i=0;i<size_extrafield_global;i++)\n+        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =\n+              *(((const char*)extrafield_global)+i);\n+\n+    for (i=0;i<size_comment;i++)\n+        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+\n+              size_extrafield_global+i) = *(filename+i);\n+    if (zi->ci.central_header == NULL)\n+        return ZIP_INTERNALERROR;\n+\n+    /* write the local header */\n+    err = ziplocal_putValue(zi->filezip,(uLong)LOCALHEADERMAGIC,4);\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)20,2);/* version needed to extract */\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.flag,2);\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.method,2);\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.dosDate,4);\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* crc 32, unknown */\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* compressed size, unknown */\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* uncompressed size, unknown */\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)size_filename,2);\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_putValue(zi->filezip,(uLong)size_extrafield_local,2);\n+\n+    if ((err==ZIP_OK) && (size_filename>0))\n+        if (fwrite(filename,(uInt)size_filename,1,zi->filezip)!=1)\n+                err = ZIP_ERRNO;\n+\n+    if ((err==ZIP_OK) && (size_extrafield_local>0))\n+        if (fwrite(extrafield_local,(uInt)size_extrafield_local,1,zi->filezip)\n+                                                                           !=1)\n+                err = ZIP_ERRNO;\n+\n+    zi->ci.stream.avail_in = (uInt)0;\n+    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n+    zi->ci.stream.next_out = zi->ci.buffered_data;\n+    zi->ci.stream.total_in = 0;\n+    zi->ci.stream.total_out = 0;\n+\n+    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED))\n+    {\n+        zi->ci.stream.zalloc = (alloc_func)0;\n+        zi->ci.stream.zfree = (free_func)0;\n+        zi->ci.stream.opaque = (voidpf)0;\n+\n+        err = deflateInit2(&zi->ci.stream, level,\n+               Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, 0);\n+\n+        if (err==Z_OK)\n+            zi->ci.stream_initialised = 1;\n+    }\n+\n+\n+    if (err==Z_OK)\n+        zi->in_opened_file_inzip = 1;\n+    return err;\n+}\n+\n+extern int ZEXPORT zipWriteInFileInZip (file, buf, len)\n+    zipFile file;\n+    const voidp buf;\n+    unsigned len;\n+{\n+    zip_internal* zi;\n+    int err=ZIP_OK;\n+\n+    if (file == NULL)\n+        return ZIP_PARAMERROR;\n+    zi = (zip_internal*)file;\n+\n+    if (zi->in_opened_file_inzip == 0)\n+        return ZIP_PARAMERROR;\n+\n+    zi->ci.stream.next_in = buf;\n+    zi->ci.stream.avail_in = len;\n+    zi->ci.crc32 = crc32(zi->ci.crc32,buf,len);\n+\n+    while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))\n+    {\n+        if (zi->ci.stream.avail_out == 0)\n+        {\n+            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n+                                                                           !=1)\n+                err = ZIP_ERRNO;\n+            zi->ci.pos_in_buffered_data = 0;\n+            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n+            zi->ci.stream.next_out = zi->ci.buffered_data;\n+        }\n+\n+        if (zi->ci.method == Z_DEFLATED)\n+        {\n+            uLong uTotalOutBefore = zi->ci.stream.total_out;\n+            err=deflate(&zi->ci.stream,  Z_NO_FLUSH);\n+            zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n+\n+        }\n+        else\n+        {\n+            uInt copy_this,i;\n+            if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)\n+                copy_this = zi->ci.stream.avail_in;\n+            else\n+                copy_this = zi->ci.stream.avail_out;\n+            for (i=0;i<copy_this;i++)\n+                *(((char*)zi->ci.stream.next_out)+i) =\n+                    *(((const char*)zi->ci.stream.next_in)+i);\n+            {\n+                zi->ci.stream.avail_in -= copy_this;\n+                zi->ci.stream.avail_out-= copy_this;\n+                zi->ci.stream.next_in+= copy_this;\n+                zi->ci.stream.next_out+= copy_this;\n+                zi->ci.stream.total_in+= copy_this;\n+                zi->ci.stream.total_out+= copy_this;\n+                zi->ci.pos_in_buffered_data += copy_this;\n+            }\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+extern int ZEXPORT zipCloseFileInZip (file)\n+    zipFile file;\n+{\n+    zip_internal* zi;\n+    int err=ZIP_OK;\n+\n+    if (file == NULL)\n+        return ZIP_PARAMERROR;\n+    zi = (zip_internal*)file;\n+\n+    if (zi->in_opened_file_inzip == 0)    \n+        return ZIP_PARAMERROR;\n+    zi->ci.stream.avail_in = 0;\n+    \n+    if (zi->ci.method == Z_DEFLATED)\n+        while (err==ZIP_OK)\n+    {\n+        uLong uTotalOutBefore;\n+        if (zi->ci.stream.avail_out == 0)\n+        {\n+            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n+                                                                           !=1)\n+                err = ZIP_ERRNO;\n+            zi->ci.pos_in_buffered_data = 0;\n+            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n+            zi->ci.stream.next_out = zi->ci.buffered_data;\n+        }\n+        uTotalOutBefore = zi->ci.stream.total_out;\n+        err=deflate(&zi->ci.stream,  Z_FINISH);\n+        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n+    }\n+\n+    if (err==Z_STREAM_END)\n+        err=ZIP_OK; /* this is normal */\n+\n+    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n+        if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n+                                                                       !=1)\n+            err = ZIP_ERRNO;\n+\n+    if ((zi->ci.method == Z_DEFLATED) && (err==ZIP_OK))\n+    {\n+        err=deflateEnd(&zi->ci.stream);\n+        zi->ci.stream_initialised = 0;\n+    }\n+\n+    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)zi->ci.crc32,4); /*crc*/\n+    ziplocal_putValue_inmemory(zi->ci.central_header+20,\n+                                (uLong)zi->ci.stream.total_out,4); /*compr size*/\n+    ziplocal_putValue_inmemory(zi->ci.central_header+24,\n+                                (uLong)zi->ci.stream.total_in,4); /*uncompr size*/\n+\n+    if (err==ZIP_OK)\n+        err = add_data_in_datablock(&zi->central_dir,zi->ci.central_header,\n+                                       (uLong)zi->ci.size_centralheader);\n+    free(zi->ci.central_header);\n+\n+    if (err==ZIP_OK)\n+    {\n+        long cur_pos_inzip = ftell(zi->filezip);\n+\t    if (fseek(zi->filezip,\n+                  zi->ci.pos_local_header + 14,SEEK_SET)!=0)\n+\t\t    err = ZIP_ERRNO;\n+\n+        if (err==ZIP_OK)\n+            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.crc32,4); /* crc 32, unknown */\n+\n+        if (err==ZIP_OK) /* compressed size, unknown */\n+            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_out,4); \n+\n+        if (err==ZIP_OK) /* uncompressed size, unknown */\n+            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_in,4);\n+\n+\t    if (fseek(zi->filezip,\n+                  cur_pos_inzip,SEEK_SET)!=0)\n+\t\t    err = ZIP_ERRNO;\n+    }\n+\n+    zi->number_entry ++;\n+    zi->in_opened_file_inzip = 0;\n+\n+    return err;\n+}\n+\n+extern int ZEXPORT zipClose (file, global_comment)\n+    zipFile file;\n+    const char* global_comment;\n+{\n+    zip_internal* zi;\n+    int err = 0;\n+    uLong size_centraldir = 0;\n+    uLong centraldir_pos_inzip ;\n+    uInt size_global_comment;\n+    if (file == NULL)\n+        return ZIP_PARAMERROR;\n+    zi = (zip_internal*)file;\n+\n+    if (zi->in_opened_file_inzip == 1)\n+    {\n+        err = zipCloseFileInZip (file);\n+    }\n+\n+    if (global_comment==NULL)\n+        size_global_comment = 0;\n+    else\n+        size_global_comment = strlen(global_comment);\n+\n+\n+    centraldir_pos_inzip = ftell(zi->filezip);\n+    if (err==ZIP_OK)\n+    {\n+        linkedlist_datablock_internal* ldi = zi->central_dir.first_block ;\n+        while (ldi!=NULL)\n+        {\n+            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n+                if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,\n+                                        1,zi->filezip) !=1 )\n+                    err = ZIP_ERRNO;\n+\n+            size_centraldir += ldi->filled_in_this_block;\n+            ldi = ldi->next_datablock;\n+        }\n+    }\n+    free_datablock(zi->central_dir.first_block);\n+\n+    if (err==ZIP_OK) /* Magic End */\n+        err = ziplocal_putValue(zi->filezip,(uLong)ENDHEADERMAGIC,4);\n+\n+    if (err==ZIP_OK) /* number of this disk */\n+        err = ziplocal_putValue(zi->filezip,(uLong)0,2);\n+\n+    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n+        err = ziplocal_putValue(zi->filezip,(uLong)0,2);\n+\n+    if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n+        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);\n+\n+    if (err==ZIP_OK) /* total number of entries in the central dir */\n+        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);\n+\n+    if (err==ZIP_OK) /* size of the central directory */\n+        err = ziplocal_putValue(zi->filezip,(uLong)size_centraldir,4);\n+\n+    if (err==ZIP_OK) /* offset of start of central directory with respect to the \n+\t                        starting disk number */\n+        err = ziplocal_putValue(zi->filezip,(uLong)centraldir_pos_inzip ,4);\n+\n+    if (err==ZIP_OK) /* zipfile comment length */\n+        err = ziplocal_putValue(zi->filezip,(uLong)size_global_comment,2);\n+\n+    if ((err==ZIP_OK) && (size_global_comment>0))\n+        if (fwrite(global_comment,(uInt)size_global_comment,1,zi->filezip) !=1 )\n+                err = ZIP_ERRNO;\n+    fclose(zi->filezip);\n+    TRYFREE(zi);\n+\n+    return err;\n+}"}, {"sha": "5d5079fbcee8ba3eeee8e865d3e3cfbee863a246", "filename": "zlib/contrib/minizip/zip.def", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,5 @@\n+\tzipOpen                       @80\n+\tzipOpenNewFileInZip           @81\n+\tzipWriteInFileInZip           @82\n+\tzipCloseFileInZip             @83\n+\tzipClose                      @84"}, {"sha": "678260b330b9acf994893ed6b84124acb10cd603", "filename": "zlib/contrib/minizip/zip.h", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,150 @@\n+/* zip.h -- IO for compress .zip files using zlib \n+   Version 0.15 alpha, Mar 19th, 1998,\n+\n+   Copyright (C) 1998 Gilles Vollant\n+\n+   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g\n+     WinZip, InfoZip tools and compatible.\n+   Encryption and multi volume ZipFile (span) are not supported.\n+   Old compressions used by old PKZip 1.x are not supported\n+\n+  For uncompress .zip file, look at unzip.h\n+\n+   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE\n+   CAN CHANGE IN FUTURE VERSION !!\n+   I WAIT FEEDBACK at mail info@winimage.com\n+   Visit also http://www.winimage.com/zLibDll/zip.htm for evolution\n+\n+   Condition of use and distribution are the same than zlib :\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the authors be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+\n+*/\n+\n+/* for more info about .ZIP format, see \n+      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip\n+   PkWare has also a specification at :\n+      ftp://ftp.pkware.com/probdesc.zip\n+*/\n+\n+#ifndef _zip_H\n+#define _zip_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifndef _ZLIB_H\n+#include \"zlib.h\"\n+#endif\n+\n+#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)\n+/* like the STRICT of WIN32, we define a pointer that cannot be converted\n+    from (void*) without cast */\n+typedef struct TagzipFile__ { int unused; } zipFile__; \n+typedef zipFile__ *zipFile;\n+#else\n+typedef voidp zipFile;\n+#endif\n+\n+#define ZIP_OK                                  (0)\n+#define ZIP_ERRNO               (Z_ERRNO)\n+#define ZIP_PARAMERROR                  (-102)\n+#define ZIP_INTERNALERROR               (-104)\n+\n+/* tm_zip contain date/time info */\n+typedef struct tm_zip_s \n+{\n+\tuInt tm_sec;            /* seconds after the minute - [0,59] */\n+\tuInt tm_min;            /* minutes after the hour - [0,59] */\n+\tuInt tm_hour;           /* hours since midnight - [0,23] */\n+\tuInt tm_mday;           /* day of the month - [1,31] */\n+\tuInt tm_mon;            /* months since January - [0,11] */\n+\tuInt tm_year;           /* years - [1980..2044] */\n+} tm_zip;\n+\n+typedef struct\n+{\n+\ttm_zip      tmz_date;       /* date in understandable format           */\n+    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */\n+/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */\n+\n+    uLong       internal_fa;    /* internal file attributes        2 bytes */\n+    uLong       external_fa;    /* external file attributes        4 bytes */\n+} zip_fileinfo;\n+\n+extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));\n+/*\n+  Create a zipfile.\n+\t pathname contain on Windows NT a filename like \"c:\\\\zlib\\\\zlib111.zip\" or on\n+\t   an Unix computer \"zlib/zlib111.zip\".\n+\t if the file pathname exist and append=1, the zip will be created at the end\n+\t   of the file. (useful if the file contain a self extractor code)\n+\t If the zipfile cannot be opened, the return value is NULL.\n+     Else, the return value is a zipFile Handle, usable with other function\n+\t   of this zip package.\n+\n+\n+*/\n+\n+extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,\n+\t\t\t\t\t   const char* filename,\n+\t\t\t\t\t   const zip_fileinfo* zipfi,\n+\t\t\t\t\t   const void* extrafield_local,\n+\t\t\t\t\t   uInt size_extrafield_local,\n+\t\t\t\t\t   const void* extrafield_global,\n+\t\t\t\t\t   uInt size_extrafield_global,\n+\t\t\t\t\t   const char* comment,\n+\t\t\t\t\t   int method,\n+\t\t\t\t\t   int level));\n+/*\n+  Open a file in the ZIP for writing.\n+  filename : the filename in zip (if NULL, '-' without quote will be used\n+  *zipfi contain supplemental information\n+  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local\n+    contains the extrafield data the the local header\n+  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global\n+    contains the extrafield data the the local header\n+  if comment != NULL, comment contain the comment string\n+  method contain the compression method (0 for store, Z_DEFLATED for deflate)\n+  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)\n+*/\n+\n+extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,\n+\t\t\t\t\t   const voidp buf,\n+\t\t\t\t\t   unsigned len));\n+/*\n+  Write data in the zipfile\n+*/\n+\n+extern int ZEXPORT zipCloseFileInZip OF((zipFile file));\n+/*\n+  Close the current file in the zipfile\n+*/\n+\n+extern int ZEXPORT zipClose OF((zipFile file,\n+\t\t\t\tconst char* global_comment));\n+/*\n+  Close the zipfile\n+*/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* _zip_H */"}, {"sha": "7e9d60d55d90d410e2d4b519f8bcfeb36027081c", "filename": "zlib/contrib/minizip/zlibvc.def", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,74 @@\n+LIBRARY\t\t\"zlib\"\n+\n+DESCRIPTION\t'\"\"\"zlib data compression library\"\"\"'\n+\n+\n+VERSION\t\t1.11\n+\n+\n+HEAPSIZE\t1048576,8192\n+\n+EXPORTS\n+    adler32                        @1\n+    compress                       @2\n+    crc32                          @3\n+    deflate                        @4\n+    deflateCopy                    @5\n+    deflateEnd                     @6\n+    deflateInit2_                  @7\n+    deflateInit_                   @8\n+    deflateParams                  @9\n+    deflateReset                   @10\n+    deflateSetDictionary           @11\n+    gzclose                        @12\n+    gzdopen                        @13\n+    gzerror                        @14\n+    gzflush                        @15\n+    gzopen                         @16\n+    gzread                         @17\n+    gzwrite                        @18\n+    inflate                        @19\n+    inflateEnd                     @20\n+    inflateInit2_                  @21\n+    inflateInit_                   @22\n+    inflateReset                   @23\n+    inflateSetDictionary           @24\n+    inflateSync                    @25\n+    uncompress                     @26\n+    zlibVersion                    @27\n+    gzprintf                       @28\n+    gzputc                         @29\n+    gzgetc                         @30\n+    gzseek                         @31\n+    gzrewind                       @32\n+    gztell                         @33\n+    gzeof                          @34\n+    gzsetparams                    @35\n+    zError                         @36\n+    inflateSyncPoint               @37\n+    get_crc_table                  @38\n+    compress2                      @39\n+    gzputs                         @40\n+    gzgets                         @41\n+\n+\tunzOpen                       @61\n+\tunzClose                      @62\n+\tunzGetGlobalInfo              @63\n+\tunzGetCurrentFileInfo         @64\n+\tunzGoToFirstFile              @65\n+\tunzGoToNextFile               @66\n+\tunzOpenCurrentFile            @67\n+\tunzReadCurrentFile            @68\n+\tunztell                       @70\n+\tunzeof                        @71\n+\tunzCloseCurrentFile           @72\n+\tunzGetGlobalComment           @73\n+\tunzStringFileNameCompare      @74\n+\tunzLocateFile                 @75\n+\tunzGetLocalExtrafield         @76\n+\n+\tzipOpen                       @80\n+\tzipOpenNewFileInZip           @81\n+\tzipWriteInFileInZip           @82\n+\tzipCloseFileInZip             @83\n+\tzipClose                      @84"}, {"sha": "a70d4d4a6b0ec6ad54f2966c42b445e9b8ded02b", "filename": "zlib/contrib/minizip/zlibvc.dsp", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,651 @@\n+# Microsoft Developer Studio Project File - Name=\"zlibvc\" - Package Owner=<4>\n+# Microsoft Developer Studio Generated Build File, Format Version 5.00\n+# ** DO NOT EDIT **\n+\n+# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n+# TARGTYPE \"Win32 (ALPHA) Dynamic-Link Library\" 0x0602\n+\n+CFG=zlibvc - Win32 Release\n+!MESSAGE This is not a valid makefile. To build this project using NMAKE,\n+!MESSAGE use the Export Makefile command and run\n+!MESSAGE \n+!MESSAGE NMAKE /f \"zlibvc.mak\".\n+!MESSAGE \n+!MESSAGE You can specify a configuration when running NMAKE\n+!MESSAGE by defining the macro CFG on the command line. For example:\n+!MESSAGE \n+!MESSAGE NMAKE /f \"zlibvc.mak\" CFG=\"zlibvc - Win32 Release\"\n+!MESSAGE \n+!MESSAGE Possible choices for configuration are:\n+!MESSAGE \n+!MESSAGE \"zlibvc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseAxp\" (based on\\\n+ \"Win32 (ALPHA) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseWithoutAsm\" (based on\\\n+ \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"zlibvc - Win32 ReleaseWithoutCrtdll\" (based on\\\n+ \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \n+\n+# Begin Project\n+# PROP Scc_ProjName \"\"\n+# PROP Scc_LocalPath \"\"\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \".\\Release\"\n+# PROP BASE Intermediate_Dir \".\\Release\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \".\\Release\"\n+# PROP Intermediate_Dir \".\\Release\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \".\\Debug\"\n+# PROP BASE Intermediate_Dir \".\\Debug\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \".\\Debug\"\n+# PROP Intermediate_Dir \".\\Debug\"\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"_DEBUG\"\n+# ADD RSC /l 0x40c /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:\".\\Debug\\zlib.dll\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc__\"\n+# PROP BASE Intermediate_Dir \"zlibvc__\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc__\"\n+# PROP Intermediate_Dir \"zlibvc__\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\"zlibvc__\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc_0\"\n+# PROP BASE Intermediate_Dir \"zlibvc_0\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc_0\"\n+# PROP Intermediate_Dir \"zlibvc_0\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_0\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"zlibvc_1\"\n+# PROP BASE Intermediate_Dir \"zlibvc_1\"\n+# PROP BASE Ignore_Export_Lib 0\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"zlibvc_1\"\n+# PROP Intermediate_Dir \"zlibvc_1\"\n+# PROP Ignore_Export_Lib 0\n+# PROP Target_Dir \"\"\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /YX /FD /c\n+# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n+# SUBTRACT CPP /YX\n+MTL=midl.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n+RSC=rc.exe\n+# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n+# ADD RSC /l 0x40c /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+LINK32=link.exe\n+# ADD BASE LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n+# SUBTRACT BASE LINK32 /pdb:none\n+# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_1\\zlib.dll\"\n+# SUBTRACT LINK32 /pdb:none\n+\n+!ENDIF \n+\n+# Begin Target\n+\n+# Name \"zlibvc - Win32 Release\"\n+# Name \"zlibvc - Win32 Debug\"\n+# Name \"zlibvc - Win32 ReleaseAxp\"\n+# Name \"zlibvc - Win32 ReleaseWithoutAsm\"\n+# Name \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+# Begin Group \"Source Files\"\n+\n+# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\"\n+# Begin Source File\n+\n+SOURCE=.\\adler32.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_ADLER=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\compress.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_COMPR=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\crc32.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_CRC32=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\deflate.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_DEFLA=\\\n+\t\".\\deflate.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\gvmat32c.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\gzio.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_GZIO_=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infblock.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFBL=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infcodes.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFCO=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inffast.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inffast.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFFA=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inffast.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inflate.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFLA=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inftrees.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFTR=\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infutil.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_INFUT=\\\n+\t\".\\infblock.h\"\\\n+\t\".\\infcodes.h\"\\\n+\t\".\\inftrees.h\"\\\n+\t\".\\infutil.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\trees.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_TREES=\\\n+\t\".\\deflate.h\"\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\uncompr.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_UNCOM=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\unzip.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zip.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlib.rc\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlibvc.def\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zutil.c\n+\n+!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n+\n+DEP_CPP_ZUTIL=\\\n+\t\".\\zconf.h\"\\\n+\t\".\\zlib.h\"\\\n+\t\".\\zutil.h\"\\\n+\t\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n+\n+!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n+\n+!ENDIF \n+\n+# End Source File\n+# End Group\n+# Begin Group \"Header Files\"\n+\n+# PROP Default_Filter \"h;hpp;hxx;hm;inl;fi;fd\"\n+# Begin Source File\n+\n+SOURCE=.\\deflate.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infblock.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infcodes.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inffast.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\inftrees.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\infutil.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zconf.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zlib.h\n+# End Source File\n+# Begin Source File\n+\n+SOURCE=.\\zutil.h\n+# End Source File\n+# End Group\n+# Begin Group \"Resource Files\"\n+\n+# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\"\n+# End Group\n+# End Target\n+# End Project"}, {"sha": "493cd870365a5cfb7e0725656d66c3b1d0b3dd21", "filename": "zlib/contrib/minizip/zlibvc.dsw", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,41 @@\n+Microsoft Developer Studio Workspace File, Format Version 5.00\n+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\n+\n+###############################################################################\n+\n+Project: \"zlibstat\"=.\\zlibstat.dsp - Package Owner=<4>\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<4>\n+{{{\n+}}}\n+\n+###############################################################################\n+\n+Project: \"zlibvc\"=.\\zlibvc.dsp - Package Owner=<4>\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<4>\n+{{{\n+}}}\n+\n+###############################################################################\n+\n+Global:\n+\n+Package=<5>\n+{{{\n+}}}\n+\n+Package=<3>\n+{{{\n+}}}\n+\n+###############################################################################\n+"}, {"sha": "409b4bdeaaed5138107455824cca2f8471cc6d5e", "filename": "zlib/contrib/untgz/Makefile", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2FMakefile?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,14 @@\n+CC=cc\n+CFLAGS=-g\n+\n+untgz: untgz.o  ../../libz.a\n+\t$(CC) $(CFLAGS) -o untgz  untgz.o -L../.. -lz\n+\n+untgz.o: untgz.c ../../zlib.h\n+\t$(CC) $(CFLAGS) -c -I../.. untgz.c\n+\n+../../libz.a:\n+\tcd ../..; make\n+\n+clean:\n+\trm -f untgz untgz.o *~"}, {"sha": "c99dc28cf55a36bebcb9ce3b13ec7e98e0ec18ac", "filename": "zlib/contrib/untgz/makefile.w32", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,63 @@\n+# Makefile for zlib.  Modified for mingw32\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, \n+# \n+#   make -fmakefile.w32\n+# \n+\n+CC=gcc\n+\n+# Generate dependencies (see end of the file)\n+\n+CPPFLAGS=-MMD \n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is not found, replace with copy /Y .\n+CP=cp -f\n+\n+# The default value of RM is \"rm -f.\"  \n+# If \"rm.exe\" is not found, uncomment:\n+# RM=del\n+\n+LD=gcc\n+LDLIBS=-L. -lz\n+LDFLAGS=-s\n+\n+\n+INCL=zlib.h zconf.h\n+LIBS=libz.a\n+\n+AR=ar rcs\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o \\\n+       inffast.o\n+\n+TEST_OBJS = minigzip.o untgz.o\n+\n+all: minigzip.exe untgz.exe\n+\n+rebuild:\tclean\tall\n+\n+libz.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $(LDFLAGS) -o $@ $< $(LDLIBS)\n+\n+.PHONY : clean\n+\n+clean:\n+\t$(RM) *.d *.o *.exe libz.a foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif\n+"}, {"sha": "4a431ff3163f8735246a92237e4321363af55502", "filename": "zlib/contrib/untgz/untgz.c", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2Funtgz.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,522 @@\n+/*\n+ * untgz.c -- Display contents and/or extract file from\n+ * a gzip'd TAR file\n+ * written by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n+ * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#ifdef unix\n+# include <unistd.h>\n+#else\n+# include <direct.h>\n+# include <io.h>\n+#endif\n+\n+#include \"zlib.h\"\n+\n+#ifdef WIN32\n+#  ifndef F_OK\n+#    define F_OK (0)\n+#  endif\n+#  ifdef _MSC_VER\n+#    define mkdir(dirname,mode) _mkdir(dirname)\n+#    define strdup(str)         _strdup(str)\n+#    define unlink(fn)          _unlink(fn)\n+#    define access(path,mode)   _access(path,mode)\n+#  else\n+#    define mkdir(dirname,mode) _mkdir(dirname)\n+#  endif\n+#else\n+#  include <utime.h>\n+#endif\n+\n+\n+/* Values used in typeflag field.  */\n+\n+#define REGTYPE\t '0'\t\t/* regular file */\n+#define AREGTYPE '\\0'\t\t/* regular file */\n+#define LNKTYPE  '1'\t\t/* link */\n+#define SYMTYPE  '2'\t\t/* reserved */\n+#define CHRTYPE  '3'\t\t/* character special */\n+#define BLKTYPE  '4'\t\t/* block special */\n+#define DIRTYPE  '5'\t\t/* directory */\n+#define FIFOTYPE '6'\t\t/* FIFO special */\n+#define CONTTYPE '7'\t\t/* reserved */\n+\n+#define BLOCKSIZE 512\n+\n+struct tar_header\n+{\t\t\t\t/* byte offset */\n+  char name[100];\t\t/*   0 */\n+  char mode[8];\t\t\t/* 100 */\n+  char uid[8];\t\t\t/* 108 */\n+  char gid[8];\t\t\t/* 116 */\n+  char size[12];\t\t/* 124 */\n+  char mtime[12];\t\t/* 136 */\n+  char chksum[8];\t\t/* 148 */\n+  char typeflag;\t\t/* 156 */\n+  char linkname[100];\t\t/* 157 */\n+  char magic[6];\t\t/* 257 */\n+  char version[2];\t\t/* 263 */\n+  char uname[32];\t\t/* 265 */\n+  char gname[32];\t\t/* 297 */\n+  char devmajor[8];\t\t/* 329 */\n+  char devminor[8];\t\t/* 337 */\n+  char prefix[155];\t\t/* 345 */\n+\t\t\t\t/* 500 */\n+};\n+\n+union tar_buffer {\n+  char               buffer[BLOCKSIZE];\n+  struct tar_header  header;\n+};\n+\n+enum { TGZ_EXTRACT = 0, TGZ_LIST };\n+\n+static char *TGZfname\tOF((const char *));\n+void TGZnotfound\tOF((const char *));\n+\n+int getoct\t\tOF((char *, int));\n+char *strtime\t\tOF((time_t *));\n+int ExprMatch\t\tOF((char *,char *));\n+\n+int makedir\t\tOF((char *));\n+int matchname\t\tOF((int,int,char **,char *));\n+\n+void error\t\tOF((const char *));\n+int  tar\t\tOF((gzFile, int, int, int, char **));\n+\n+void help\t\tOF((int));\n+int main\t\tOF((int, char **));\n+\n+char *prog;\n+\n+/* This will give a benign warning */\n+\n+static char *TGZprefix[] = { \"\\0\", \".tgz\", \".tar.gz\", \".tar\", NULL };\n+\n+/* Return the real name of the TGZ archive */\n+/* or NULL if it does not exist. */\n+\n+static char *TGZfname OF((const char *fname))\n+{\n+  static char buffer[1024];\n+  int origlen,i;\n+  \n+  strcpy(buffer,fname);\n+  origlen = strlen(buffer);\n+\n+  for (i=0; TGZprefix[i]; i++)\n+    {\n+       strcpy(buffer+origlen,TGZprefix[i]);\n+       if (access(buffer,F_OK) == 0)\n+         return buffer;\n+    }\n+  return NULL;\n+}\n+\n+/* error message for the filename */\n+\n+void TGZnotfound OF((const char *fname))\n+{\n+  int i;\n+\n+  fprintf(stderr,\"%s : couldn't find \",prog);\n+  for (i=0;TGZprefix[i];i++)\n+    fprintf(stderr,(TGZprefix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n+            fname,\n+            TGZprefix[i]);\n+  exit(1);\n+}\n+\n+\n+/* help functions */\n+\n+int getoct(char *p,int width)\n+{\n+  int result = 0;\n+  char c;\n+  \n+  while (width --)\n+    {\n+      c = *p++;\n+      if (c == ' ')\n+\tcontinue;\n+      if (c == 0)\n+\tbreak;\n+      result = result * 8 + (c - '0');\n+    }\n+  return result;\n+}\n+\n+char *strtime (time_t *t)\n+{\n+  struct tm   *local;\n+  static char result[32];\n+\n+  local = localtime(t);\n+  sprintf(result,\"%2d/%02d/%4d %02d:%02d:%02d\",\n+\t  local->tm_mday, local->tm_mon+1, local->tm_year+1900,\n+\t  local->tm_hour, local->tm_min,   local->tm_sec);\n+  return result;\n+}\n+\n+\n+/* regular expression matching */\n+\n+#define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))\n+\n+int ExprMatch(char *string,char *expr)\n+{\n+  while (1)\n+    {\n+      if (ISSPECIAL(*expr))\n+\t{\n+\t  if (*expr == '/')\n+\t    {\n+\t      if (*string != '\\\\' && *string != '/')\n+\t\treturn 0;\n+\t      string ++; expr++;\n+\t    }\n+\t  else if (*expr == '*')\n+\t    {\n+\t      if (*expr ++ == 0)\n+\t\treturn 1;\n+\t      while (*++string != *expr)\n+\t\tif (*string == 0)\n+\t\t  return 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (*string != *expr)\n+\t    return 0;\n+\t  if (*expr++ == 0)\n+\t    return 1;\n+\t  string++;\n+\t}\n+    }\n+}\n+\n+/* recursive make directory */\n+/* abort if you get an ENOENT errno somewhere in the middle */\n+/* e.g. ignore error \"mkdir on existing directory\" */\n+/* */\n+/* return 1 if OK */\n+/*        0 on error */\n+\n+int makedir (char *newdir)\n+{\n+  char *buffer = strdup(newdir);\n+  char *p;\n+  int  len = strlen(buffer);\n+  \n+  if (len <= 0) {\n+    free(buffer);\n+    return 0;\n+  }\n+  if (buffer[len-1] == '/') {\n+    buffer[len-1] = '\\0';\n+  }\n+  if (mkdir(buffer, 0775) == 0)\n+    {\n+      free(buffer);\n+      return 1;\n+    }\n+\n+  p = buffer+1;\n+  while (1)\n+    {\n+      char hold;\n+      \n+      while(*p && *p != '\\\\' && *p != '/')\n+\tp++;\n+      hold = *p;\n+      *p = 0;\n+      if ((mkdir(buffer, 0775) == -1) && (errno == ENOENT))\n+\t{\n+\t  fprintf(stderr,\"%s: couldn't create directory %s\\n\",prog,buffer);\n+\t  free(buffer);\n+\t  return 0;\n+\t}\n+      if (hold == 0)\n+\tbreak;\n+      *p++ = hold;\n+    }\n+  free(buffer);\n+  return 1;\n+}\n+\n+int matchname (int arg,int argc,char **argv,char *fname)\n+{\n+  if (arg == argc)\t\t/* no arguments given (untgz tgzarchive) */\n+    return 1;\n+\n+  while (arg < argc)\n+    if (ExprMatch(fname,argv[arg++]))\n+      return 1;\n+\n+  return 0; /* ignore this for the moment being */\n+}\n+\n+\n+/* Tar file list or extract */\n+\n+int tar (gzFile in,int action,int arg,int argc,char **argv)\n+{\n+  union  tar_buffer buffer;\n+  int    len;\n+  int    err;\n+  int    getheader = 1;\n+  int    remaining = 0;\n+  FILE   *outfile = NULL;\n+  char   fname[BLOCKSIZE];\n+  time_t tartime;\n+  \n+  if (action == TGZ_LIST)\n+    printf(\"     day      time     size                       file\\n\"\n+\t   \" ---------- -------- --------- -------------------------------------\\n\");\n+  while (1)\n+    {\n+      len = gzread(in, &buffer, BLOCKSIZE);\n+      if (len < 0)\n+\terror (gzerror(in, &err));\n+      /*\n+       * Always expect complete blocks to process\n+       * the tar information.\n+       */\n+      if (len != BLOCKSIZE)\n+\terror(\"gzread: incomplete block read\");\n+      \n+      /*\n+       * If we have to get a tar header\n+       */\n+      if (getheader == 1)\n+\t{\n+\t  /*\n+\t   * if we met the end of the tar\n+\t   * or the end-of-tar block,\n+\t   * we are done\n+\t   */\n+\t  if ((len == 0)  || (buffer.header.name[0]== 0)) break;\n+\n+\t  tartime = (time_t)getoct(buffer.header.mtime,12);\n+\t  strcpy(fname,buffer.header.name);\n+\t  \n+\t  switch (buffer.header.typeflag)\n+\t    {\n+\t    case DIRTYPE:\n+\t      if (action == TGZ_LIST)\n+\t\tprintf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n+\t      if (action == TGZ_EXTRACT)\n+\t\tmakedir(fname);\n+\t      break;\n+\t    case REGTYPE:\n+\t    case AREGTYPE:\n+\t      remaining = getoct(buffer.header.size,12);\n+\t      if (action == TGZ_LIST)\n+\t\tprintf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n+\t      if (action == TGZ_EXTRACT)\n+\t\t{\n+\t\t  if ((remaining) && (matchname(arg,argc,argv,fname)))\n+\t\t    {\n+\t\t      outfile = fopen(fname,\"wb\");\n+\t\t      if (outfile == NULL) {\n+\t\t\t/* try creating directory */\n+\t\t\tchar *p = strrchr(fname, '/');\n+\t\t\tif (p != NULL) {\n+\t\t\t  *p = '\\0';\n+\t\t\t  makedir(fname);\n+\t\t\t  *p = '/';\n+\t\t\t  outfile = fopen(fname,\"wb\");\n+\t\t\t}\n+\t\t      }\n+\t\t      fprintf(stderr,\n+\t\t\t      \"%s %s\\n\",\n+\t\t\t      (outfile) ? \"Extracting\" : \"Couldn't create\",\n+\t\t\t      fname);\n+\t\t    }\n+\t\t  else\n+\t\t    outfile = NULL;\n+\t\t}\n+\t      /*\n+\t       * could have no contents\n+\t       */\n+\t      getheader = (remaining) ? 0 : 1;\n+\t      break;\n+\t    default:\n+\t      if (action == TGZ_LIST)\n+\t\tprintf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n+\n+\t  if ((action == TGZ_EXTRACT) && (outfile != NULL))\n+\t    {\n+\t      if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n+\t\t{\n+\t\t  fprintf(stderr,\"%s : error writing %s skipping...\\n\",prog,fname);\n+\t\t  fclose(outfile);\n+\t\t  unlink(fname);\n+\t\t}\n+\t    }\n+\t  remaining -= bytes;\n+\t  if (remaining == 0)\n+\t    {\n+\t      getheader = 1;\n+\t      if ((action == TGZ_EXTRACT) && (outfile != NULL))\n+\t\t{\n+#ifdef WIN32\n+\t\t  HANDLE hFile;\n+\t\t  FILETIME ftm,ftLocal;\n+\t\t  SYSTEMTIME st;\n+\t\t  struct tm localt;\n+ \n+\t\t  fclose(outfile);\n+\n+\t\t  localt = *localtime(&tartime);\n+\n+\t\t  hFile = CreateFile(fname, GENERIC_READ | GENERIC_WRITE,\n+\t\t\t\t     0, NULL, OPEN_EXISTING, 0, NULL);\n+\t\t  \n+\t\t  st.wYear = (WORD)localt.tm_year+1900;\n+\t\t  st.wMonth = (WORD)localt.tm_mon;\n+\t\t  st.wDayOfWeek = (WORD)localt.tm_wday;\n+\t\t  st.wDay = (WORD)localt.tm_mday;\n+\t\t  st.wHour = (WORD)localt.tm_hour;\n+\t\t  st.wMinute = (WORD)localt.tm_min;\n+\t\t  st.wSecond = (WORD)localt.tm_sec;\n+\t\t  st.wMilliseconds = 0;\n+\t\t  SystemTimeToFileTime(&st,&ftLocal);\n+\t\t  LocalFileTimeToFileTime(&ftLocal,&ftm);\n+\t\t  SetFileTime(hFile,&ftm,NULL,&ftm);\n+\t\t  CloseHandle(hFile);\n+\n+\t\t  outfile = NULL;\n+#else\n+\t\t  struct utimbuf settime;\n+\n+\t\t  settime.actime = settime.modtime = tartime;\n+\n+\t\t  fclose(outfile);\n+\t\t  outfile = NULL;\n+\t\t  utime(fname,&settime);\n+#endif\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  \n+  if (gzclose(in) != Z_OK)\n+    error(\"failed gzclose\");\n+\n+  return 0;\n+}\n+\n+\n+/* =========================================================== */\n+\n+void help(int exitval)\n+{\n+  fprintf(stderr,\n+\t  \"untgz v 0.1\\n\"\n+\t  \" an sample application of zlib 1.0.4\\n\\n\"\n+          \"Usage : untgz TGZfile            to extract all files\\n\"\n+          \"        untgz TGZfile fname ...  to extract selected files\\n\"\n+          \"        untgz -l TGZfile         to list archive contents\\n\"\n+          \"        untgz -h                 to display this help\\n\\n\");\n+  exit(exitval);\n+}\n+\n+void error(const char *msg)\n+{\n+    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n+    exit(1);\n+}\n+\n+\n+/* ====================================================================== */\n+\n+int _CRT_glob = 0;\t/* disable globbing of the arguments */\n+\n+int main(int argc,char **argv)\n+{\n+    int \taction = TGZ_EXTRACT;\n+    int \targ = 1;\n+    char\t*TGZfile;\n+    gzFile\t*f;\n+    \n+\n+    prog = strrchr(argv[0],'\\\\');\n+    if (prog == NULL)\n+      {\n+\tprog = strrchr(argv[0],'/');\n+\tif (prog == NULL)\n+\t  {\n+\t    prog = strrchr(argv[0],':');\n+\t    if (prog == NULL)\n+\t      prog = argv[0];\n+\t    else\n+\t      prog++;\n+\t  }\n+\telse\n+\t  prog++;\n+      }\n+    else\n+      prog++;\n+    \n+    if (argc == 1)\n+      help(0);\n+\n+    if (strcmp(argv[arg],\"-l\") == 0)\n+      {\n+\taction = TGZ_LIST;\n+\tif (argc == ++arg)\n+\t  help(0);\n+      }\n+    else if (strcmp(argv[arg],\"-h\") == 0)\n+      {\n+\thelp(0);\n+      }\n+\n+    if ((TGZfile = TGZfname(argv[arg])) == NULL)\n+      TGZnotfound(argv[arg]);            \n+\n+    ++arg;\n+    if ((action == TGZ_LIST) && (arg != argc))\n+      help(1);\n+\n+/*\n+ *  Process the TGZ file\n+ */\n+    switch(action)\n+      {\n+      case TGZ_LIST:\n+      case TGZ_EXTRACT:\n+\tf = gzopen(TGZfile,\"rb\");\n+\tif (f == NULL)\n+\t  {\n+\t    fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",\n+\t\t    prog,\n+\t\t    TGZfile);\n+\t    return 1;\n+\t  }\n+\texit(tar(f, action, arg, argc, argv));\n+      break;\n+\t\n+      default:\n+\terror(\"Unknown option!\");\n+\texit(1);\n+      }\n+\n+    return 0;\n+}"}, {"sha": "10fb44bc5934ffe07f6fd918671f34cf26b3e728", "filename": "zlib/contrib/visual-basic.txt", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fvisual-basic.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcontrib%2Fvisual-basic.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvisual-basic.txt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,69 @@\n+See below some functions declarations for Visual Basic.\n+\n+Frequently Asked Question:\n+\n+Q: Each time I use the compress function I get the -5 error (not enough\n+   room in the output buffer).\n+\n+A: Make sure that the length of the compressed buffer is passed by\n+   reference (\"as any\"), not by value (\"as long\"). Also check that\n+   before the call of compress this length is equal to the total size of\n+   the compressed buffer and not zero.\n+\n+\n+From: \"Jon Caruana\" <jon-net@usa.net>\n+Subject: Re: How to port zlib declares to vb?\n+Date: Mon, 28 Oct 1996 18:33:03 -0600\n+\n+Got the answer! (I haven't had time to check this but it's what I got, and\n+looks correct):\n+\n+He has the following routines working:\n+        compress\n+        uncompress\n+        gzopen\n+        gzwrite\n+        gzread\n+        gzclose\n+\n+Declares follow: (Quoted from Carlos Rios <c_rios@sonda.cl>, in Vb4 form)\n+\n+#If Win16 Then   'Use Win16 calls.\n+Declare Function compress Lib \"ZLIB.DLL\" (ByVal compr As\n+        String, comprLen As Any, ByVal buf As String, ByVal buflen\n+        As Long) As Integer\n+Declare Function uncompress Lib \"ZLIB.DLL\" (ByVal uncompr\n+        As String, uncomprLen As Any, ByVal compr As String, ByVal\n+        lcompr As Long) As Integer\n+Declare Function gzopen Lib \"ZLIB.DLL\" (ByVal filePath As\n+        String, ByVal mode As String) As Long\n+Declare Function gzread Lib \"ZLIB.DLL\" (ByVal file As\n+        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n+        As Integer\n+Declare Function gzwrite Lib \"ZLIB.DLL\" (ByVal file As\n+        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n+        As Integer\n+Declare Function gzclose Lib \"ZLIB.DLL\" (ByVal file As\n+        Long) As Integer\n+#Else\n+Declare Function compress Lib \"ZLIB32.DLL\"\n+        (ByVal compr As String, comprLen As Any, ByVal buf As\n+        String, ByVal buflen As Long) As Integer\n+Declare Function uncompress Lib \"ZLIB32.DLL\"\n+        (ByVal uncompr As String, uncomprLen As Any, ByVal compr As\n+        String, ByVal lcompr As Long) As Long\n+Declare Function gzopen Lib \"ZLIB32.DLL\"\n+        (ByVal file As String, ByVal mode As String) As Long\n+Declare Function gzread Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long, ByVal uncompr As String, ByVal\n+        uncomprLen As Long) As Long\n+Declare Function gzwrite Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long, ByVal uncompr As String, ByVal\n+        uncomprLen As Long) As Long\n+Declare Function gzclose Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long) As Long\n+#End If\n+\n+-Jon Caruana\n+jon-net@usa.net\n+Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member"}, {"sha": "a91101a81c6ae58913d5f3266e8da4ff75eda936", "filename": "zlib/crc32.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcrc32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fcrc32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,162 @@\n+/* crc32.c -- compute the CRC-32 of a data stream\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"zlib.h\"\n+\n+#define local static\n+\n+#ifdef DYNAMIC_CRC_TABLE\n+\n+local int crc_table_empty = 1;\n+local uLongf crc_table[256];\n+local void make_crc_table OF((void));\n+\n+/*\n+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:\n+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n+\n+  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n+  with the lowest powers in the most significant bit.  Then adding polynomials\n+  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n+  one.  If we call the above polynomial p, and represent a byte as the\n+  polynomial q, also with the lowest power in the most significant bit (so the\n+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,\n+  where a mod b means the remainder after dividing a by b.\n+\n+  This calculation is done using the shift-register method of multiplying and\n+  taking the remainder.  The register is initialized to zero, and for each\n+  incoming bit, x^32 is added mod p to the register if the bit is a one (where\n+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by\n+  x (which is shifting right by one and adding x^32 mod p if the bit shifted\n+  out is a one).  We start with the highest power (least significant bit) of\n+  q and repeat for all eight bits of q.\n+\n+  The table is simply the CRC of all possible eight bit values.  This is all\n+  the information needed to generate CRC's on data a byte at a time for all\n+  combinations of CRC register values and incoming bytes.\n+*/\n+local void make_crc_table()\n+{\n+  uLong c;\n+  int n, k;\n+  uLong poly;            /* polynomial exclusive-or pattern */\n+  /* terms of polynomial defining this crc (except x^32): */\n+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n+\n+  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n+  poly = 0L;\n+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n+    poly |= 1L << (31 - p[n]);\n+ \n+  for (n = 0; n < 256; n++)\n+  {\n+    c = (uLong)n;\n+    for (k = 0; k < 8; k++)\n+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n+    crc_table[n] = c;\n+  }\n+  crc_table_empty = 0;\n+}\n+#else\n+/* ========================================================================\n+ * Table of CRC-32's of all single-byte values (made by make_crc_table)\n+ */\n+local const uLongf crc_table[256] = {\n+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n+  0x2d02ef8dL\n+};\n+#endif\n+\n+/* =========================================================================\n+ * This function can be used by asm versions of crc32()\n+ */\n+const uLongf * ZEXPORT get_crc_table()\n+{\n+#ifdef DYNAMIC_CRC_TABLE\n+  if (crc_table_empty) make_crc_table();\n+#endif\n+  return (const uLongf *)crc_table;\n+}\n+\n+/* ========================================================================= */\n+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);\n+#define DO2(buf)  DO1(buf); DO1(buf);\n+#define DO4(buf)  DO2(buf); DO2(buf);\n+#define DO8(buf)  DO4(buf); DO4(buf);\n+\n+/* ========================================================================= */\n+uLong ZEXPORT crc32(crc, buf, len)\n+    uLong crc;\n+    const Bytef *buf;\n+    uInt len;\n+{\n+    if (buf == Z_NULL) return 0L;\n+#ifdef DYNAMIC_CRC_TABLE\n+    if (crc_table_empty)\n+      make_crc_table();\n+#endif\n+    crc = crc ^ 0xffffffffL;\n+    while (len >= 8)\n+    {\n+      DO8(buf);\n+      len -= 8;\n+    }\n+    if (len) do {\n+      DO1(buf);\n+    } while (--len);\n+    return crc ^ 0xffffffffL;\n+}"}, {"sha": "25d5818e2ece934bfa178d6cf9de7c951876f2da", "filename": "zlib/deflate.c", "status": "added", "additions": 1350, "deletions": 0, "changes": 1350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdeflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdeflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,1350 @@\n+/* deflate.c -- compress data using the deflation algorithm\n+ * Copyright (C) 1995-1998 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/*\n+ *  ALGORITHM\n+ *\n+ *      The \"deflation\" process depends on being able to identify portions\n+ *      of the input text which are identical to earlier input (within a\n+ *      sliding window trailing behind the input currently being processed).\n+ *\n+ *      The most straightforward technique turns out to be the fastest for\n+ *      most input files: try all possible matches and select the longest.\n+ *      The key feature of this algorithm is that insertions into the string\n+ *      dictionary are very simple and thus fast, and deletions are avoided\n+ *      completely. Insertions are performed at each input character, whereas\n+ *      string matches are performed only when the previous match ends. So it\n+ *      is preferable to spend more time in matches to allow very fast string\n+ *      insertions and avoid deletions. The matching algorithm for small\n+ *      strings is inspired from that of Rabin & Karp. A brute force approach\n+ *      is used to find longer strings when a small match has been found.\n+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n+ *      (by Leonid Broukhis).\n+ *         A previous version of this file used a more sophisticated algorithm\n+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n+ *      time, but has a larger average cost, uses more memory and is patented.\n+ *      However the F&G algorithm may be faster for some highly redundant\n+ *      files if the parameter max_chain_length (described below) is too large.\n+ *\n+ *  ACKNOWLEDGEMENTS\n+ *\n+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n+ *      I found it in 'freeze' written by Leonid Broukhis.\n+ *      Thanks to many people for bug reports and testing.\n+ *\n+ *  REFERENCES\n+ *\n+ *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n+ *      Available in ftp://ds.internic.net/rfc/rfc1951.txt\n+ *\n+ *      A description of the Rabin and Karp algorithm is given in the book\n+ *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n+ *\n+ *      Fiala,E.R., and Greene,D.H.\n+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n+ *\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include \"deflate.h\"\n+\n+const char deflate_copyright[] =\n+   \" deflate 1.1.3 Copyright 1995-1998 Jean-loup Gailly \";\n+/*\n+  If you use the zlib library in a product, an acknowledgment is welcome\n+  in the documentation of your product. If for some reason you cannot\n+  include such an acknowledgment, I would appreciate that you keep this\n+  copyright string in the executable of your product.\n+ */\n+\n+/* ===========================================================================\n+ *  Function prototypes.\n+ */\n+typedef enum {\n+    need_more,      /* block not completed, need more input or more output */\n+    block_done,     /* block flush performed */\n+    finish_started, /* finish started, need only more output at next deflate */\n+    finish_done     /* finish done, accept no more input or output */\n+} block_state;\n+\n+typedef block_state (*compress_func) OF((deflate_state *s, int flush));\n+/* Compression function. Returns the block state after the call. */\n+\n+local void fill_window    OF((deflate_state *s));\n+local block_state deflate_stored OF((deflate_state *s, int flush));\n+local block_state deflate_fast   OF((deflate_state *s, int flush));\n+local block_state deflate_slow   OF((deflate_state *s, int flush));\n+local void lm_init        OF((deflate_state *s));\n+local void putShortMSB    OF((deflate_state *s, uInt b));\n+local void flush_pending  OF((z_streamp strm));\n+local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));\n+#ifdef ASMV\n+      void match_init OF((void)); /* asm code initialization */\n+      uInt longest_match  OF((deflate_state *s, IPos cur_match));\n+#else\n+local uInt longest_match  OF((deflate_state *s, IPos cur_match));\n+#endif\n+\n+#ifdef DEBUG\n+local  void check_match OF((deflate_state *s, IPos start, IPos match,\n+                            int length));\n+#endif\n+\n+/* ===========================================================================\n+ * Local data\n+ */\n+\n+#define NIL 0\n+/* Tail of hash chains */\n+\n+#ifndef TOO_FAR\n+#  define TOO_FAR 4096\n+#endif\n+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */\n+\n+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n+/* Minimum amount of lookahead, except at the end of the input file.\n+ * See deflate.c for comments about the MIN_MATCH+1.\n+ */\n+\n+/* Values for max_lazy_match, good_match and max_chain_length, depending on\n+ * the desired pack level (0..9). The values given below have been tuned to\n+ * exclude worst case performance for pathological files. Better values may be\n+ * found for specific files.\n+ */\n+typedef struct config_s {\n+   ush good_length; /* reduce lazy search above this match length */\n+   ush max_lazy;    /* do not perform lazy search above this match length */\n+   ush nice_length; /* quit search above this match length */\n+   ush max_chain;\n+   compress_func func;\n+} config;\n+\n+local const config configuration_table[10] = {\n+/*      good lazy nice chain */\n+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */\n+/* 2 */ {4,    5, 16,    8, deflate_fast},\n+/* 3 */ {4,    6, 32,   32, deflate_fast},\n+\n+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */\n+/* 5 */ {8,   16, 32,   32, deflate_slow},\n+/* 6 */ {8,   16, 128, 128, deflate_slow},\n+/* 7 */ {8,   32, 128, 256, deflate_slow},\n+/* 8 */ {32, 128, 258, 1024, deflate_slow},\n+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */\n+\n+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n+ * meaning.\n+ */\n+\n+#define EQUAL 0\n+/* result of memcmp for equal strings */\n+\n+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */\n+\n+/* ===========================================================================\n+ * Update a hash value with the given input byte\n+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive\n+ *    input characters, so that a running hash key can be computed from the\n+ *    previous key instead of complete recalculation each time.\n+ */\n+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)\n+\n+\n+/* ===========================================================================\n+ * Insert string str in the dictionary and set match_head to the previous head\n+ * of the hash chain (the most recent string with same hash key). Return\n+ * the previous length of the hash chain.\n+ * If this file is compiled with -DFASTEST, the compression level is forced\n+ * to 1, and no hash chains are maintained.\n+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n+ *    input characters and the first MIN_MATCH bytes of str are valid\n+ *    (except for the last MIN_MATCH-1 bytes of the input file).\n+ */\n+#ifdef FASTEST\n+#define INSERT_STRING(s, str, match_head) \\\n+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n+    match_head = s->head[s->ins_h], \\\n+    s->head[s->ins_h] = (Pos)(str))\n+#else\n+#define INSERT_STRING(s, str, match_head) \\\n+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n+    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \\\n+    s->head[s->ins_h] = (Pos)(str))\n+#endif\n+\n+/* ===========================================================================\n+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n+ * prev[] will be initialized on the fly.\n+ */\n+#define CLEAR_HASH(s) \\\n+    s->head[s->hash_size-1] = NIL; \\\n+    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateInit_(strm, level, version, stream_size)\n+    z_streamp strm;\n+    int level;\n+    const char *version;\n+    int stream_size;\n+{\n+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n+\t\t\t Z_DEFAULT_STRATEGY, version, stream_size);\n+    /* To do: ignore strm->next_in if we use it as window */\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n+\t\t  version, stream_size)\n+    z_streamp strm;\n+    int  level;\n+    int  method;\n+    int  windowBits;\n+    int  memLevel;\n+    int  strategy;\n+    const char *version;\n+    int stream_size;\n+{\n+    deflate_state *s;\n+    int noheader = 0;\n+    static const char* my_version = ZLIB_VERSION;\n+\n+    ushf *overlay;\n+    /* We overlay pending_buf and d_buf+l_buf. This works since the average\n+     * output size for (length,distance) codes is <= 24 bits.\n+     */\n+\n+    if (version == Z_NULL || version[0] != my_version[0] ||\n+        stream_size != sizeof(z_stream)) {\n+\treturn Z_VERSION_ERROR;\n+    }\n+    if (strm == Z_NULL) return Z_STREAM_ERROR;\n+\n+    strm->msg = Z_NULL;\n+    if (strm->zalloc == Z_NULL) {\n+\tstrm->zalloc = zcalloc;\n+\tstrm->opaque = (voidpf)0;\n+    }\n+    if (strm->zfree == Z_NULL) strm->zfree = zcfree;\n+\n+    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n+#ifdef FASTEST\n+    level = 1;\n+#endif\n+\n+    if (windowBits < 0) { /* undocumented feature: suppress zlib header */\n+        noheader = 1;\n+        windowBits = -windowBits;\n+    }\n+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n+        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n+\tstrategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n+        return Z_STREAM_ERROR;\n+    }\n+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n+    if (s == Z_NULL) return Z_MEM_ERROR;\n+    strm->state = (struct internal_state FAR *)s;\n+    s->strm = strm;\n+\n+    s->noheader = noheader;\n+    s->w_bits = windowBits;\n+    s->w_size = 1 << s->w_bits;\n+    s->w_mask = s->w_size - 1;\n+\n+    s->hash_bits = memLevel + 7;\n+    s->hash_size = 1 << s->hash_bits;\n+    s->hash_mask = s->hash_size - 1;\n+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\n+\n+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n+\n+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n+\n+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n+    s->pending_buf = (uchf *) overlay;\n+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n+\n+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n+        s->pending_buf == Z_NULL) {\n+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);\n+        deflateEnd (strm);\n+        return Z_MEM_ERROR;\n+    }\n+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n+\n+    s->level = level;\n+    s->strategy = strategy;\n+    s->method = (Byte)method;\n+\n+    return deflateReset(strm);\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n+    z_streamp strm;\n+    const Bytef *dictionary;\n+    uInt  dictLength;\n+{\n+    deflate_state *s;\n+    uInt length = dictLength;\n+    uInt n;\n+    IPos hash_head = 0;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||\n+        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;\n+\n+    s = strm->state;\n+    strm->adler = adler32(strm->adler, dictionary, dictLength);\n+\n+    if (length < MIN_MATCH) return Z_OK;\n+    if (length > MAX_DIST(s)) {\n+\tlength = MAX_DIST(s);\n+#ifndef USE_DICT_HEAD\n+\tdictionary += dictLength - length; /* use the tail of the dictionary */\n+#endif\n+    }\n+    zmemcpy(s->window, dictionary, length);\n+    s->strstart = length;\n+    s->block_start = (long)length;\n+\n+    /* Insert all strings in the hash table (except for the last two bytes).\n+     * s->lookahead stays null, so s->ins_h will be recomputed at the next\n+     * call of fill_window.\n+     */\n+    s->ins_h = s->window[0];\n+    UPDATE_HASH(s, s->ins_h, s->window[1]);\n+    for (n = 0; n <= length - MIN_MATCH; n++) {\n+\tINSERT_STRING(s, n, hash_head);\n+    }\n+    if (hash_head) hash_head = 0;  /* to make compiler happy */\n+    return Z_OK;\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateReset (strm)\n+    z_streamp strm;\n+{\n+    deflate_state *s;\n+    \n+    if (strm == Z_NULL || strm->state == Z_NULL ||\n+        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;\n+\n+    strm->total_in = strm->total_out = 0;\n+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n+    strm->data_type = Z_UNKNOWN;\n+\n+    s = (deflate_state *)strm->state;\n+    s->pending = 0;\n+    s->pending_out = s->pending_buf;\n+\n+    if (s->noheader < 0) {\n+        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */\n+    }\n+    s->status = s->noheader ? BUSY_STATE : INIT_STATE;\n+    strm->adler = 1;\n+    s->last_flush = Z_NO_FLUSH;\n+\n+    _tr_init(s);\n+    lm_init(s);\n+\n+    return Z_OK;\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateParams(strm, level, strategy)\n+    z_streamp strm;\n+    int level;\n+    int strategy;\n+{\n+    deflate_state *s;\n+    compress_func func;\n+    int err = Z_OK;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    s = strm->state;\n+\n+    if (level == Z_DEFAULT_COMPRESSION) {\n+\tlevel = 6;\n+    }\n+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n+\treturn Z_STREAM_ERROR;\n+    }\n+    func = configuration_table[s->level].func;\n+\n+    if (func != configuration_table[level].func && strm->total_in != 0) {\n+\t/* Flush the last buffer: */\n+\terr = deflate(strm, Z_PARTIAL_FLUSH);\n+    }\n+    if (s->level != level) {\n+\ts->level = level;\n+\ts->max_lazy_match   = configuration_table[level].max_lazy;\n+\ts->good_match       = configuration_table[level].good_length;\n+\ts->nice_match       = configuration_table[level].nice_length;\n+\ts->max_chain_length = configuration_table[level].max_chain;\n+    }\n+    s->strategy = strategy;\n+    return err;\n+}\n+\n+/* =========================================================================\n+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n+ * IN assertion: the stream state is correct and there is enough room in\n+ * pending_buf.\n+ */\n+local void putShortMSB (s, b)\n+    deflate_state *s;\n+    uInt b;\n+{\n+    put_byte(s, (Byte)(b >> 8));\n+    put_byte(s, (Byte)(b & 0xff));\n+}   \n+\n+/* =========================================================================\n+ * Flush as much pending output as possible. All deflate() output goes\n+ * through this function so some applications may wish to modify it\n+ * to avoid allocating a large strm->next_out buffer and copying into it.\n+ * (See also read_buf()).\n+ */\n+local void flush_pending(strm)\n+    z_streamp strm;\n+{\n+    unsigned len = strm->state->pending;\n+\n+    if (len > strm->avail_out) len = strm->avail_out;\n+    if (len == 0) return;\n+\n+    zmemcpy(strm->next_out, strm->state->pending_out, len);\n+    strm->next_out  += len;\n+    strm->state->pending_out  += len;\n+    strm->total_out += len;\n+    strm->avail_out  -= len;\n+    strm->state->pending -= len;\n+    if (strm->state->pending == 0) {\n+        strm->state->pending_out = strm->state->pending_buf;\n+    }\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflate (strm, flush)\n+    z_streamp strm;\n+    int flush;\n+{\n+    int old_flush; /* value of flush param for previous deflate call */\n+    deflate_state *s;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL ||\n+\tflush > Z_FINISH || flush < 0) {\n+        return Z_STREAM_ERROR;\n+    }\n+    s = strm->state;\n+\n+    if (strm->next_out == Z_NULL ||\n+        (strm->next_in == Z_NULL && strm->avail_in != 0) ||\n+\t(s->status == FINISH_STATE && flush != Z_FINISH)) {\n+        ERR_RETURN(strm, Z_STREAM_ERROR);\n+    }\n+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n+\n+    s->strm = strm; /* just in case */\n+    old_flush = s->last_flush;\n+    s->last_flush = flush;\n+\n+    /* Write the zlib header */\n+    if (s->status == INIT_STATE) {\n+\n+        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n+        uInt level_flags = (s->level-1) >> 1;\n+\n+        if (level_flags > 3) level_flags = 3;\n+        header |= (level_flags << 6);\n+\tif (s->strstart != 0) header |= PRESET_DICT;\n+        header += 31 - (header % 31);\n+\n+        s->status = BUSY_STATE;\n+        putShortMSB(s, header);\n+\n+\t/* Save the adler32 of the preset dictionary: */\n+\tif (s->strstart != 0) {\n+\t    putShortMSB(s, (uInt)(strm->adler >> 16));\n+\t    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n+\t}\n+\tstrm->adler = 1L;\n+    }\n+\n+    /* Flush as much pending output as possible */\n+    if (s->pending != 0) {\n+        flush_pending(strm);\n+        if (strm->avail_out == 0) {\n+\t    /* Since avail_out is 0, deflate will be called again with\n+\t     * more output space, but possibly with both pending and\n+\t     * avail_in equal to zero. There won't be anything to do,\n+\t     * but this is not an error situation so make sure we\n+\t     * return OK instead of BUF_ERROR at next call of deflate:\n+             */\n+\t    s->last_flush = -1;\n+\t    return Z_OK;\n+\t}\n+\n+    /* Make sure there is something to do and avoid duplicate consecutive\n+     * flushes. For repeated and useless calls with Z_FINISH, we keep\n+     * returning Z_STREAM_END instead of Z_BUFF_ERROR.\n+     */\n+    } else if (strm->avail_in == 0 && flush <= old_flush &&\n+\t       flush != Z_FINISH) {\n+        ERR_RETURN(strm, Z_BUF_ERROR);\n+    }\n+\n+    /* User must not provide more input after the first FINISH: */\n+    if (s->status == FINISH_STATE && strm->avail_in != 0) {\n+        ERR_RETURN(strm, Z_BUF_ERROR);\n+    }\n+\n+    /* Start a new block or continue the current one.\n+     */\n+    if (strm->avail_in != 0 || s->lookahead != 0 ||\n+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n+        block_state bstate;\n+\n+\tbstate = (*(configuration_table[s->level].func))(s, flush);\n+\n+        if (bstate == finish_started || bstate == finish_done) {\n+            s->status = FINISH_STATE;\n+        }\n+        if (bstate == need_more || bstate == finish_started) {\n+\t    if (strm->avail_out == 0) {\n+\t        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n+\t    }\n+\t    return Z_OK;\n+\t    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n+\t     * of deflate should use the same flush parameter to make sure\n+\t     * that the flush is complete. So we don't have to output an\n+\t     * empty block here, this will be done at next call. This also\n+\t     * ensures that for a very small output buffer, we emit at most\n+\t     * one empty block.\n+\t     */\n+\t}\n+        if (bstate == block_done) {\n+            if (flush == Z_PARTIAL_FLUSH) {\n+                _tr_align(s);\n+            } else { /* FULL_FLUSH or SYNC_FLUSH */\n+                _tr_stored_block(s, (char*)0, 0L, 0);\n+                /* For a full flush, this empty block will be recognized\n+                 * as a special marker by inflate_sync().\n+                 */\n+                if (flush == Z_FULL_FLUSH) {\n+                    CLEAR_HASH(s);             /* forget history */\n+                }\n+            }\n+            flush_pending(strm);\n+\t    if (strm->avail_out == 0) {\n+\t      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n+\t      return Z_OK;\n+\t    }\n+        }\n+    }\n+    Assert(strm->avail_out > 0, \"bug2\");\n+\n+    if (flush != Z_FINISH) return Z_OK;\n+    if (s->noheader) return Z_STREAM_END;\n+\n+    /* Write the zlib trailer (adler32) */\n+    putShortMSB(s, (uInt)(strm->adler >> 16));\n+    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n+    flush_pending(strm);\n+    /* If avail_out is zero, the application will call deflate again\n+     * to flush the rest.\n+     */\n+    s->noheader = -1; /* write the trailer only once! */\n+    return s->pending != 0 ? Z_OK : Z_STREAM_END;\n+}\n+\n+/* ========================================================================= */\n+int ZEXPORT deflateEnd (strm)\n+    z_streamp strm;\n+{\n+    int status;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+\n+    status = strm->state->status;\n+    if (status != INIT_STATE && status != BUSY_STATE &&\n+\tstatus != FINISH_STATE) {\n+      return Z_STREAM_ERROR;\n+    }\n+\n+    /* Deallocate in reverse order of allocations: */\n+    TRY_FREE(strm, strm->state->pending_buf);\n+    TRY_FREE(strm, strm->state->head);\n+    TRY_FREE(strm, strm->state->prev);\n+    TRY_FREE(strm, strm->state->window);\n+\n+    ZFREE(strm, strm->state);\n+    strm->state = Z_NULL;\n+\n+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n+}\n+\n+/* =========================================================================\n+ * Copy the source state to the destination state.\n+ * To simplify the source, this is not supported for 16-bit MSDOS (which\n+ * doesn't have enough memory anyway to duplicate compression states).\n+ */\n+int ZEXPORT deflateCopy (dest, source)\n+    z_streamp dest;\n+    z_streamp source;\n+{\n+#ifdef MAXSEG_64K\n+    return Z_STREAM_ERROR;\n+#else\n+    deflate_state *ds;\n+    deflate_state *ss;\n+    ushf *overlay;\n+\n+\n+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {\n+        return Z_STREAM_ERROR;\n+    }\n+\n+    ss = source->state;\n+\n+    *dest = *source;\n+\n+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n+    if (ds == Z_NULL) return Z_MEM_ERROR;\n+    dest->state = (struct internal_state FAR *) ds;\n+    *ds = *ss;\n+    ds->strm = dest;\n+\n+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n+    ds->pending_buf = (uchf *) overlay;\n+\n+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n+        ds->pending_buf == Z_NULL) {\n+        deflateEnd (dest);\n+        return Z_MEM_ERROR;\n+    }\n+    /* following zmemcpy do not work for 16-bit MSDOS */\n+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));\n+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));\n+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n+\n+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n+\n+    ds->l_desc.dyn_tree = ds->dyn_ltree;\n+    ds->d_desc.dyn_tree = ds->dyn_dtree;\n+    ds->bl_desc.dyn_tree = ds->bl_tree;\n+\n+    return Z_OK;\n+#endif\n+}\n+\n+/* ===========================================================================\n+ * Read a new buffer from the current input stream, update the adler32\n+ * and total number of bytes read.  All deflate() input goes through\n+ * this function so some applications may wish to modify it to avoid\n+ * allocating a large strm->next_in buffer and copying from it.\n+ * (See also flush_pending()).\n+ */\n+local int read_buf(strm, buf, size)\n+    z_streamp strm;\n+    Bytef *buf;\n+    unsigned size;\n+{\n+    unsigned len = strm->avail_in;\n+\n+    if (len > size) len = size;\n+    if (len == 0) return 0;\n+\n+    strm->avail_in  -= len;\n+\n+    if (!strm->state->noheader) {\n+        strm->adler = adler32(strm->adler, strm->next_in, len);\n+    }\n+    zmemcpy(buf, strm->next_in, len);\n+    strm->next_in  += len;\n+    strm->total_in += len;\n+\n+    return (int)len;\n+}\n+\n+/* ===========================================================================\n+ * Initialize the \"longest match\" routines for a new zlib stream\n+ */\n+local void lm_init (s)\n+    deflate_state *s;\n+{\n+    s->window_size = (ulg)2L*s->w_size;\n+\n+    CLEAR_HASH(s);\n+\n+    /* Set the default configuration parameters:\n+     */\n+    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n+    s->good_match       = configuration_table[s->level].good_length;\n+    s->nice_match       = configuration_table[s->level].nice_length;\n+    s->max_chain_length = configuration_table[s->level].max_chain;\n+\n+    s->strstart = 0;\n+    s->block_start = 0L;\n+    s->lookahead = 0;\n+    s->match_length = s->prev_length = MIN_MATCH-1;\n+    s->match_available = 0;\n+    s->ins_h = 0;\n+#ifdef ASMV\n+    match_init(); /* initialize the asm code */\n+#endif\n+}\n+\n+/* ===========================================================================\n+ * Set match_start to the longest match starting at the given string and\n+ * return its length. Matches shorter or equal to prev_length are discarded,\n+ * in which case the result is equal to prev_length and match_start is\n+ * garbage.\n+ * IN assertions: cur_match is the head of the hash chain for the current\n+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n+ * OUT assertion: the match length is not greater than s->lookahead.\n+ */\n+#ifndef ASMV\n+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or\n+ * match.S. The code will be functionally equivalent.\n+ */\n+#ifndef FASTEST\n+local uInt longest_match(s, cur_match)\n+    deflate_state *s;\n+    IPos cur_match;                             /* current match */\n+{\n+    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n+    register Bytef *scan = s->window + s->strstart; /* current string */\n+    register Bytef *match;                       /* matched string */\n+    register int len;                           /* length of current match */\n+    int best_len = s->prev_length;              /* best match length so far */\n+    int nice_match = s->nice_match;             /* stop if match long enough */\n+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n+        s->strstart - (IPos)MAX_DIST(s) : NIL;\n+    /* Stop when cur_match becomes <= limit. To simplify the code,\n+     * we prevent matches with the string of window index 0.\n+     */\n+    Posf *prev = s->prev;\n+    uInt wmask = s->w_mask;\n+\n+#ifdef UNALIGNED_OK\n+    /* Compare two bytes at a time. Note: this is not always beneficial.\n+     * Try with and without -DUNALIGNED_OK to check.\n+     */\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n+    register ush scan_start = *(ushf*)scan;\n+    register ush scan_end   = *(ushf*)(scan+best_len-1);\n+#else\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n+    register Byte scan_end1  = scan[best_len-1];\n+    register Byte scan_end   = scan[best_len];\n+#endif\n+\n+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n+     * It is easy to get rid of this optimization if necessary.\n+     */\n+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n+\n+    /* Do not waste too much time if we already have a good match: */\n+    if (s->prev_length >= s->good_match) {\n+        chain_length >>= 2;\n+    }\n+    /* Do not look for matches beyond the end of the input. This is necessary\n+     * to make deflate deterministic.\n+     */\n+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n+\n+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n+\n+    do {\n+        Assert(cur_match < s->strstart, \"no future\");\n+        match = s->window + cur_match;\n+\n+        /* Skip to next match if the match length cannot increase\n+         * or if the match length is less than 2:\n+         */\n+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n+        /* This code assumes sizeof(unsigned short) == 2. Do not use\n+         * UNALIGNED_OK if your compiler uses a different size.\n+         */\n+        if (*(ushf*)(match+best_len-1) != scan_end ||\n+            *(ushf*)match != scan_start) continue;\n+\n+        /* It is not necessary to compare scan[2] and match[2] since they are\n+         * always equal when the other bytes match, given that the hash keys\n+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n+         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n+         * lookahead only every 4th comparison; the 128th check will be made\n+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n+         * necessary to put more guard bytes at the end of the window, or\n+         * to check more often for insufficient lookahead.\n+         */\n+        Assert(scan[2] == match[2], \"scan[2]?\");\n+        scan++, match++;\n+        do {\n+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n+                 scan < strend);\n+        /* The funny \"do {}\" generates better code on most compilers */\n+\n+        /* Here, scan <= window+strstart+257 */\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+        if (*scan == *match) scan++;\n+\n+        len = (MAX_MATCH - 1) - (int)(strend-scan);\n+        scan = strend - (MAX_MATCH-1);\n+\n+#else /* UNALIGNED_OK */\n+\n+        if (match[best_len]   != scan_end  ||\n+            match[best_len-1] != scan_end1 ||\n+            *match            != *scan     ||\n+            *++match          != scan[1])      continue;\n+\n+        /* The check at best_len-1 can be removed because it will be made\n+         * again later. (This heuristic is not always a win.)\n+         * It is not necessary to compare scan[2] and match[2] since they\n+         * are always equal when the other bytes match, given that\n+         * the hash keys are equal and that HASH_BITS >= 8.\n+         */\n+        scan += 2, match++;\n+        Assert(*scan == *match, \"match[2]?\");\n+\n+        /* We check for insufficient lookahead only every 8th comparison;\n+         * the 256th check will be made at strstart+258.\n+         */\n+        do {\n+        } while (*++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 *++scan == *++match && *++scan == *++match &&\n+                 scan < strend);\n+\n+        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+\n+        len = MAX_MATCH - (int)(strend - scan);\n+        scan = strend - MAX_MATCH;\n+\n+#endif /* UNALIGNED_OK */\n+\n+        if (len > best_len) {\n+            s->match_start = cur_match;\n+            best_len = len;\n+            if (len >= nice_match) break;\n+#ifdef UNALIGNED_OK\n+            scan_end = *(ushf*)(scan+best_len-1);\n+#else\n+            scan_end1  = scan[best_len-1];\n+            scan_end   = scan[best_len];\n+#endif\n+        }\n+    } while ((cur_match = prev[cur_match & wmask]) > limit\n+             && --chain_length != 0);\n+\n+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n+    return s->lookahead;\n+}\n+\n+#else /* FASTEST */\n+/* ---------------------------------------------------------------------------\n+ * Optimized version for level == 1 only\n+ */\n+local uInt longest_match(s, cur_match)\n+    deflate_state *s;\n+    IPos cur_match;                             /* current match */\n+{\n+    register Bytef *scan = s->window + s->strstart; /* current string */\n+    register Bytef *match;                       /* matched string */\n+    register int len;                           /* length of current match */\n+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n+\n+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n+     * It is easy to get rid of this optimization if necessary.\n+     */\n+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n+\n+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n+\n+    Assert(cur_match < s->strstart, \"no future\");\n+\n+    match = s->window + cur_match;\n+\n+    /* Return failure if the match length is less than 2:\n+     */\n+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;\n+\n+    /* The check at best_len-1 can be removed because it will be made\n+     * again later. (This heuristic is not always a win.)\n+     * It is not necessary to compare scan[2] and match[2] since they\n+     * are always equal when the other bytes match, given that\n+     * the hash keys are equal and that HASH_BITS >= 8.\n+     */\n+    scan += 2, match += 2;\n+    Assert(*scan == *match, \"match[2]?\");\n+\n+    /* We check for insufficient lookahead only every 8th comparison;\n+     * the 256th check will be made at strstart+258.\n+     */\n+    do {\n+    } while (*++scan == *++match && *++scan == *++match &&\n+\t     *++scan == *++match && *++scan == *++match &&\n+\t     *++scan == *++match && *++scan == *++match &&\n+\t     *++scan == *++match && *++scan == *++match &&\n+\t     scan < strend);\n+\n+    Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+\n+    len = MAX_MATCH - (int)(strend - scan);\n+\n+    if (len < MIN_MATCH) return MIN_MATCH - 1;\n+\n+    s->match_start = cur_match;\n+    return len <= s->lookahead ? len : s->lookahead;\n+}\n+#endif /* FASTEST */\n+#endif /* ASMV */\n+\n+#ifdef DEBUG\n+/* ===========================================================================\n+ * Check that the match at match_start is indeed a match.\n+ */\n+local void check_match(s, start, match, length)\n+    deflate_state *s;\n+    IPos start, match;\n+    int length;\n+{\n+    /* check that the match is indeed a match */\n+    if (zmemcmp(s->window + match,\n+                s->window + start, length) != EQUAL) {\n+        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n+\t\tstart, match, length);\n+        do {\n+\t    fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n+\t} while (--length != 0);\n+        z_error(\"invalid match\");\n+    }\n+    if (z_verbose > 1) {\n+        fprintf(stderr,\"\\\\[%d,%d]\", start-match, length);\n+        do { putc(s->window[start++], stderr); } while (--length != 0);\n+    }\n+}\n+#else\n+#  define check_match(s, start, match, length)\n+#endif\n+\n+/* ===========================================================================\n+ * Fill the window when the lookahead becomes insufficient.\n+ * Updates strstart and lookahead.\n+ *\n+ * IN assertion: lookahead < MIN_LOOKAHEAD\n+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n+ *    At least one byte has been read, or avail_in == 0; reads are\n+ *    performed for at least two bytes (required for the zip translate_eol\n+ *    option -- not supported here).\n+ */\n+local void fill_window(s)\n+    deflate_state *s;\n+{\n+    register unsigned n, m;\n+    register Posf *p;\n+    unsigned more;    /* Amount of free space at the end of the window. */\n+    uInt wsize = s->w_size;\n+\n+    do {\n+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n+\n+        /* Deal with !@#$% 64K limit: */\n+        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n+            more = wsize;\n+\n+        } else if (more == (unsigned)(-1)) {\n+            /* Very unlikely, but possible on 16 bit machine if strstart == 0\n+             * and lookahead == 1 (input done one byte at time)\n+             */\n+            more--;\n+\n+        /* If the window is almost full and there is insufficient lookahead,\n+         * move the upper half to the lower one to make room in the upper half.\n+         */\n+        } else if (s->strstart >= wsize+MAX_DIST(s)) {\n+\n+            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);\n+            s->match_start -= wsize;\n+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n+            s->block_start -= (long) wsize;\n+\n+            /* Slide the hash table (could be avoided with 32 bit values\n+               at the expense of memory usage). We slide even when level == 0\n+               to keep the hash table consistent if we switch back to level > 0\n+               later. (Using level 0 permanently is not an optimal usage of\n+               zlib, so we don't care about this pathological case.)\n+             */\n+\t    n = s->hash_size;\n+\t    p = &s->head[n];\n+\t    do {\n+\t\tm = *--p;\n+\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n+\t    } while (--n);\n+\n+\t    n = wsize;\n+#ifndef FASTEST\n+\t    p = &s->prev[n];\n+\t    do {\n+\t\tm = *--p;\n+\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n+\t\t/* If n is not on any hash chain, prev[n] is garbage but\n+\t\t * its value will never be used.\n+\t\t */\n+\t    } while (--n);\n+#endif\n+            more += wsize;\n+        }\n+        if (s->strm->avail_in == 0) return;\n+\n+        /* If there was no sliding:\n+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n+         *    more == window_size - lookahead - strstart\n+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n+         * => more >= window_size - 2*WSIZE + 2\n+         * In the BIG_MEM or MMAP case (not yet supported),\n+         *   window_size == input_size + MIN_LOOKAHEAD  &&\n+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n+         * Otherwise, window_size == 2*WSIZE so more >= 2.\n+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n+         */\n+        Assert(more >= 2, \"more < 2\");\n+\n+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n+        s->lookahead += n;\n+\n+        /* Initialize the hash value now that we have some input: */\n+        if (s->lookahead >= MIN_MATCH) {\n+            s->ins_h = s->window[s->strstart];\n+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n+#if MIN_MATCH != 3\n+            Call UPDATE_HASH() MIN_MATCH-3 more times\n+#endif\n+        }\n+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n+         * but this is not important since only literal bytes will be emitted.\n+         */\n+\n+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n+}\n+\n+/* ===========================================================================\n+ * Flush the current block, with given end-of-file flag.\n+ * IN assertion: strstart is set to the end of the current match.\n+ */\n+#define FLUSH_BLOCK_ONLY(s, eof) { \\\n+   _tr_flush_block(s, (s->block_start >= 0L ? \\\n+                   (charf *)&s->window[(unsigned)s->block_start] : \\\n+                   (charf *)Z_NULL), \\\n+\t\t(ulg)((long)s->strstart - s->block_start), \\\n+\t\t(eof)); \\\n+   s->block_start = s->strstart; \\\n+   flush_pending(s->strm); \\\n+   Tracev((stderr,\"[FLUSH]\")); \\\n+}\n+\n+/* Same but force premature exit if necessary. */\n+#define FLUSH_BLOCK(s, eof) { \\\n+   FLUSH_BLOCK_ONLY(s, eof); \\\n+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \\\n+}\n+\n+/* ===========================================================================\n+ * Copy without compression as much as possible from the input stream, return\n+ * the current block state.\n+ * This function does not insert new strings in the dictionary since\n+ * uncompressible data is probably not useful. This function is used\n+ * only for the level=0 compression option.\n+ * NOTE: this function should be optimized to avoid extra copying from\n+ * window to pending_buf.\n+ */\n+local block_state deflate_stored(s, flush)\n+    deflate_state *s;\n+    int flush;\n+{\n+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n+     * to pending_buf_size, and each stored block has a 5 byte header:\n+     */\n+    ulg max_block_size = 0xffff;\n+    ulg max_start;\n+\n+    if (max_block_size > s->pending_buf_size - 5) {\n+        max_block_size = s->pending_buf_size - 5;\n+    }\n+\n+    /* Copy as much as possible from input to output: */\n+    for (;;) {\n+        /* Fill the window as much as possible: */\n+        if (s->lookahead <= 1) {\n+\n+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n+\t\t   s->block_start >= (long)s->w_size, \"slide too late\");\n+\n+            fill_window(s);\n+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\n+\n+            if (s->lookahead == 0) break; /* flush the current block */\n+        }\n+\tAssert(s->block_start >= 0L, \"block gone\");\n+\n+\ts->strstart += s->lookahead;\n+\ts->lookahead = 0;\n+\n+\t/* Emit a stored block if pending_buf will be full: */\n+ \tmax_start = s->block_start + max_block_size;\n+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {\n+\t    /* strstart == 0 is possible when wraparound on 16-bit machine */\n+\t    s->lookahead = (uInt)(s->strstart - max_start);\n+\t    s->strstart = (uInt)max_start;\n+            FLUSH_BLOCK(s, 0);\n+\t}\n+\t/* Flush if we may have to slide, otherwise block_start may become\n+         * negative and the data will be gone:\n+         */\n+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {\n+            FLUSH_BLOCK(s, 0);\n+\t}\n+    }\n+    FLUSH_BLOCK(s, flush == Z_FINISH);\n+    return flush == Z_FINISH ? finish_done : block_done;\n+}\n+\n+/* ===========================================================================\n+ * Compress as much as possible from the input stream, return the current\n+ * block state.\n+ * This function does not perform lazy evaluation of matches and inserts\n+ * new strings in the dictionary only for unmatched strings or for short\n+ * matches. It is used only for the fast compression options.\n+ */\n+local block_state deflate_fast(s, flush)\n+    deflate_state *s;\n+    int flush;\n+{\n+    IPos hash_head = NIL; /* head of the hash chain */\n+    int bflush;           /* set if current block must be flushed */\n+\n+    for (;;) {\n+        /* Make sure that we always have enough lookahead, except\n+         * at the end of the input file. We need MAX_MATCH bytes\n+         * for the next match, plus MIN_MATCH bytes to insert the\n+         * string following the next match.\n+         */\n+        if (s->lookahead < MIN_LOOKAHEAD) {\n+            fill_window(s);\n+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n+\t        return need_more;\n+\t    }\n+            if (s->lookahead == 0) break; /* flush the current block */\n+        }\n+\n+        /* Insert the string window[strstart .. strstart+2] in the\n+         * dictionary, and set hash_head to the head of the hash chain:\n+         */\n+        if (s->lookahead >= MIN_MATCH) {\n+            INSERT_STRING(s, s->strstart, hash_head);\n+        }\n+\n+        /* Find the longest match, discarding those <= prev_length.\n+         * At this point we have always match_length < MIN_MATCH\n+         */\n+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n+            /* To simplify the code, we prevent matches with the string\n+             * of window index 0 (in particular we have to avoid a match\n+             * of the string with itself at the start of the input file).\n+             */\n+            if (s->strategy != Z_HUFFMAN_ONLY) {\n+                s->match_length = longest_match (s, hash_head);\n+            }\n+            /* longest_match() sets match_start */\n+        }\n+        if (s->match_length >= MIN_MATCH) {\n+            check_match(s, s->strstart, s->match_start, s->match_length);\n+\n+            _tr_tally_dist(s, s->strstart - s->match_start,\n+                           s->match_length - MIN_MATCH, bflush);\n+\n+            s->lookahead -= s->match_length;\n+\n+            /* Insert new strings in the hash table only if the match length\n+             * is not too large. This saves time but degrades compression.\n+             */\n+#ifndef FASTEST\n+            if (s->match_length <= s->max_insert_length &&\n+                s->lookahead >= MIN_MATCH) {\n+                s->match_length--; /* string at strstart already in hash table */\n+                do {\n+                    s->strstart++;\n+                    INSERT_STRING(s, s->strstart, hash_head);\n+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n+                     * always MIN_MATCH bytes ahead.\n+                     */\n+                } while (--s->match_length != 0);\n+                s->strstart++; \n+            } else\n+#endif\n+\t    {\n+                s->strstart += s->match_length;\n+                s->match_length = 0;\n+                s->ins_h = s->window[s->strstart];\n+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n+#if MIN_MATCH != 3\n+                Call UPDATE_HASH() MIN_MATCH-3 more times\n+#endif\n+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n+                 * matter since it will be recomputed at next deflate call.\n+                 */\n+            }\n+        } else {\n+            /* No match, output a literal byte */\n+            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n+            _tr_tally_lit (s, s->window[s->strstart], bflush);\n+            s->lookahead--;\n+            s->strstart++; \n+        }\n+        if (bflush) FLUSH_BLOCK(s, 0);\n+    }\n+    FLUSH_BLOCK(s, flush == Z_FINISH);\n+    return flush == Z_FINISH ? finish_done : block_done;\n+}\n+\n+/* ===========================================================================\n+ * Same as above, but achieves better compression. We use a lazy\n+ * evaluation for matches: a match is finally adopted only if there is\n+ * no better match at the next window position.\n+ */\n+local block_state deflate_slow(s, flush)\n+    deflate_state *s;\n+    int flush;\n+{\n+    IPos hash_head = NIL;    /* head of hash chain */\n+    int bflush;              /* set if current block must be flushed */\n+\n+    /* Process the input block. */\n+    for (;;) {\n+        /* Make sure that we always have enough lookahead, except\n+         * at the end of the input file. We need MAX_MATCH bytes\n+         * for the next match, plus MIN_MATCH bytes to insert the\n+         * string following the next match.\n+         */\n+        if (s->lookahead < MIN_LOOKAHEAD) {\n+            fill_window(s);\n+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n+\t        return need_more;\n+\t    }\n+            if (s->lookahead == 0) break; /* flush the current block */\n+        }\n+\n+        /* Insert the string window[strstart .. strstart+2] in the\n+         * dictionary, and set hash_head to the head of the hash chain:\n+         */\n+        if (s->lookahead >= MIN_MATCH) {\n+            INSERT_STRING(s, s->strstart, hash_head);\n+        }\n+\n+        /* Find the longest match, discarding those <= prev_length.\n+         */\n+        s->prev_length = s->match_length, s->prev_match = s->match_start;\n+        s->match_length = MIN_MATCH-1;\n+\n+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&\n+            s->strstart - hash_head <= MAX_DIST(s)) {\n+            /* To simplify the code, we prevent matches with the string\n+             * of window index 0 (in particular we have to avoid a match\n+             * of the string with itself at the start of the input file).\n+             */\n+            if (s->strategy != Z_HUFFMAN_ONLY) {\n+                s->match_length = longest_match (s, hash_head);\n+            }\n+            /* longest_match() sets match_start */\n+\n+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||\n+                 (s->match_length == MIN_MATCH &&\n+                  s->strstart - s->match_start > TOO_FAR))) {\n+\n+                /* If prev_match is also MIN_MATCH, match_start is garbage\n+                 * but we will ignore the current match anyway.\n+                 */\n+                s->match_length = MIN_MATCH-1;\n+            }\n+        }\n+        /* If there was a match at the previous step and the current\n+         * match is not better, output the previous match:\n+         */\n+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\n+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n+            /* Do not insert strings in hash table beyond this. */\n+\n+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);\n+\n+            _tr_tally_dist(s, s->strstart -1 - s->prev_match,\n+\t\t\t   s->prev_length - MIN_MATCH, bflush);\n+\n+            /* Insert in hash table all strings up to the end of the match.\n+             * strstart-1 and strstart are already inserted. If there is not\n+             * enough lookahead, the last two strings are not inserted in\n+             * the hash table.\n+             */\n+            s->lookahead -= s->prev_length-1;\n+            s->prev_length -= 2;\n+            do {\n+                if (++s->strstart <= max_insert) {\n+                    INSERT_STRING(s, s->strstart, hash_head);\n+                }\n+            } while (--s->prev_length != 0);\n+            s->match_available = 0;\n+            s->match_length = MIN_MATCH-1;\n+            s->strstart++;\n+\n+            if (bflush) FLUSH_BLOCK(s, 0);\n+\n+        } else if (s->match_available) {\n+            /* If there was no match at the previous position, output a\n+             * single literal. If there was a match but the current match\n+             * is longer, truncate the previous match to a single literal.\n+             */\n+            Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n+\t    _tr_tally_lit(s, s->window[s->strstart-1], bflush);\n+\t    if (bflush) {\n+                FLUSH_BLOCK_ONLY(s, 0);\n+            }\n+            s->strstart++;\n+            s->lookahead--;\n+            if (s->strm->avail_out == 0) return need_more;\n+        } else {\n+            /* There is no previous match to compare with, wait for\n+             * the next step to decide.\n+             */\n+            s->match_available = 1;\n+            s->strstart++;\n+            s->lookahead--;\n+        }\n+    }\n+    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n+    if (s->match_available) {\n+        Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n+        _tr_tally_lit(s, s->window[s->strstart-1], bflush);\n+        s->match_available = 0;\n+    }\n+    FLUSH_BLOCK(s, flush == Z_FINISH);\n+    return flush == Z_FINISH ? finish_done : block_done;\n+}"}, {"sha": "962676da8696da7f7afbd92b7951c20548d49759", "filename": "zlib/deflate.h", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdeflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdeflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,318 @@\n+/* deflate.h -- internal compression state\n+ * Copyright (C) 1995-1998 Jean-loup Gailly\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#ifndef _DEFLATE_H\n+#define _DEFLATE_H\n+\n+#include \"zutil.h\"\n+\n+/* ===========================================================================\n+ * Internal compression state.\n+ */\n+\n+#define LENGTH_CODES 29\n+/* number of length codes, not counting the special END_BLOCK code */\n+\n+#define LITERALS  256\n+/* number of literal bytes 0..255 */\n+\n+#define L_CODES (LITERALS+1+LENGTH_CODES)\n+/* number of Literal or Length codes, including the END_BLOCK code */\n+\n+#define D_CODES   30\n+/* number of distance codes */\n+\n+#define BL_CODES  19\n+/* number of codes used to transfer the bit lengths */\n+\n+#define HEAP_SIZE (2*L_CODES+1)\n+/* maximum heap size */\n+\n+#define MAX_BITS 15\n+/* All codes must not exceed MAX_BITS bits */\n+\n+#define INIT_STATE    42\n+#define BUSY_STATE   113\n+#define FINISH_STATE 666\n+/* Stream status */\n+\n+\n+/* Data structure describing a single value and its code string. */\n+typedef struct ct_data_s {\n+    union {\n+        ush  freq;       /* frequency count */\n+        ush  code;       /* bit string */\n+    } fc;\n+    union {\n+        ush  dad;        /* father node in Huffman tree */\n+        ush  len;        /* length of bit string */\n+    } dl;\n+} FAR ct_data;\n+\n+#define Freq fc.freq\n+#define Code fc.code\n+#define Dad  dl.dad\n+#define Len  dl.len\n+\n+typedef struct static_tree_desc_s  static_tree_desc;\n+\n+typedef struct tree_desc_s {\n+    ct_data *dyn_tree;           /* the dynamic tree */\n+    int     max_code;            /* largest code with non zero frequency */\n+    static_tree_desc *stat_desc; /* the corresponding static tree */\n+} FAR tree_desc;\n+\n+typedef ush Pos;\n+typedef Pos FAR Posf;\n+typedef unsigned IPos;\n+\n+/* A Pos is an index in the character window. We use short instead of int to\n+ * save space in the various tables. IPos is used only for parameter passing.\n+ */\n+\n+typedef struct internal_state {\n+    z_streamp strm;      /* pointer back to this zlib stream */\n+    int   status;        /* as the name implies */\n+    Bytef *pending_buf;  /* output still pending */\n+    ulg   pending_buf_size; /* size of pending_buf */\n+    Bytef *pending_out;  /* next pending byte to output to the stream */\n+    int   pending;       /* nb of bytes in the pending buffer */\n+    int   noheader;      /* suppress zlib header and adler32 */\n+    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */\n+    Byte  method;        /* STORED (for zip only) or DEFLATED */\n+    int   last_flush;    /* value of flush param for previous deflate call */\n+\n+                /* used by deflate.c: */\n+\n+    uInt  w_size;        /* LZ77 window size (32K by default) */\n+    uInt  w_bits;        /* log2(w_size)  (8..16) */\n+    uInt  w_mask;        /* w_size - 1 */\n+\n+    Bytef *window;\n+    /* Sliding window. Input bytes are read into the second half of the window,\n+     * and move to the first half later to keep a dictionary of at least wSize\n+     * bytes. With this organization, matches are limited to a distance of\n+     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n+     * performed with a length multiple of the block size. Also, it limits\n+     * the window size to 64K, which is quite useful on MSDOS.\n+     * To do: use the user input buffer as sliding window.\n+     */\n+\n+    ulg window_size;\n+    /* Actual size of window: 2*wSize, except when the user input buffer\n+     * is directly used as sliding window.\n+     */\n+\n+    Posf *prev;\n+    /* Link to older string with same hash index. To limit the size of this\n+     * array to 64K, this link is maintained only for the last 32K strings.\n+     * An index in this array is thus a window index modulo 32K.\n+     */\n+\n+    Posf *head; /* Heads of the hash chains or NIL. */\n+\n+    uInt  ins_h;          /* hash index of string to be inserted */\n+    uInt  hash_size;      /* number of elements in hash table */\n+    uInt  hash_bits;      /* log2(hash_size) */\n+    uInt  hash_mask;      /* hash_size-1 */\n+\n+    uInt  hash_shift;\n+    /* Number of bits by which ins_h must be shifted at each input\n+     * step. It must be such that after MIN_MATCH steps, the oldest\n+     * byte no longer takes part in the hash key, that is:\n+     *   hash_shift * MIN_MATCH >= hash_bits\n+     */\n+\n+    long block_start;\n+    /* Window position at the beginning of the current output block. Gets\n+     * negative when the window is moved backwards.\n+     */\n+\n+    uInt match_length;           /* length of best match */\n+    IPos prev_match;             /* previous match */\n+    int match_available;         /* set if previous match exists */\n+    uInt strstart;               /* start of string to insert */\n+    uInt match_start;            /* start of matching string */\n+    uInt lookahead;              /* number of valid bytes ahead in window */\n+\n+    uInt prev_length;\n+    /* Length of the best match at previous step. Matches not greater than this\n+     * are discarded. This is used in the lazy match evaluation.\n+     */\n+\n+    uInt max_chain_length;\n+    /* To speed up deflation, hash chains are never searched beyond this\n+     * length.  A higher limit improves compression ratio but degrades the\n+     * speed.\n+     */\n+\n+    uInt max_lazy_match;\n+    /* Attempt to find a better match only when the current match is strictly\n+     * smaller than this value. This mechanism is used only for compression\n+     * levels >= 4.\n+     */\n+#   define max_insert_length  max_lazy_match\n+    /* Insert new strings in the hash table only if the match length is not\n+     * greater than this length. This saves time but degrades compression.\n+     * max_insert_length is used only for compression levels <= 3.\n+     */\n+\n+    int level;    /* compression level (1..9) */\n+    int strategy; /* favor or force Huffman coding*/\n+\n+    uInt good_match;\n+    /* Use a faster search when the previous match is longer than this */\n+\n+    int nice_match; /* Stop searching when current match exceeds this */\n+\n+                /* used by trees.c: */\n+    /* Didn't use ct_data typedef below to supress compiler warning */\n+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n+\n+    struct tree_desc_s l_desc;               /* desc. for literal tree */\n+    struct tree_desc_s d_desc;               /* desc. for distance tree */\n+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n+\n+    ush bl_count[MAX_BITS+1];\n+    /* number of codes at each bit length for an optimal tree */\n+\n+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n+    int heap_len;               /* number of elements in the heap */\n+    int heap_max;               /* element of largest frequency */\n+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n+     * The same heap array is used to build all trees.\n+     */\n+\n+    uch depth[2*L_CODES+1];\n+    /* Depth of each subtree used as tie breaker for trees of equal frequency\n+     */\n+\n+    uchf *l_buf;          /* buffer for literals or lengths */\n+\n+    uInt  lit_bufsize;\n+    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n+     * limiting lit_bufsize to 64K:\n+     *   - frequencies can be kept in 16 bit counters\n+     *   - if compression is not successful for the first block, all input\n+     *     data is still in the window so we can still emit a stored block even\n+     *     when input comes from standard input.  (This can also be done for\n+     *     all blocks if lit_bufsize is not greater than 32K.)\n+     *   - if compression is not successful for a file smaller than 64K, we can\n+     *     even emit a stored file instead of a stored block (saving 5 bytes).\n+     *     This is applicable only for zip (not gzip or zlib).\n+     *   - creating new Huffman trees less frequently may not provide fast\n+     *     adaptation to changes in the input data statistics. (Take for\n+     *     example a binary file with poorly compressible code followed by\n+     *     a highly compressible string table.) Smaller buffer sizes give\n+     *     fast adaptation but have of course the overhead of transmitting\n+     *     trees more frequently.\n+     *   - I can't count above 4\n+     */\n+\n+    uInt last_lit;      /* running index in l_buf */\n+\n+    ushf *d_buf;\n+    /* Buffer for distances. To simplify the code, d_buf and l_buf have\n+     * the same number of elements. To use different lengths, an extra flag\n+     * array would be necessary.\n+     */\n+\n+    ulg opt_len;        /* bit length of current block with optimal trees */\n+    ulg static_len;     /* bit length of current block with static trees */\n+    uInt matches;       /* number of string matches in current block */\n+    int last_eob_len;   /* bit length of EOB code for last block */\n+\n+#ifdef DEBUG\n+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n+#endif\n+\n+    ush bi_buf;\n+    /* Output buffer. bits are inserted starting at the bottom (least\n+     * significant bits).\n+     */\n+    int bi_valid;\n+    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n+     * are always zero.\n+     */\n+\n+} FAR deflate_state;\n+\n+/* Output a byte on the stream.\n+ * IN assertion: there is enough room in pending_buf.\n+ */\n+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}\n+\n+\n+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n+/* Minimum amount of lookahead, except at the end of the input file.\n+ * See deflate.c for comments about the MIN_MATCH+1.\n+ */\n+\n+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)\n+/* In order to simplify the code, particularly on 16 bit machines, match\n+ * distances are limited to MAX_DIST instead of WSIZE.\n+ */\n+\n+        /* in trees.c */\n+void _tr_init         OF((deflate_state *s));\n+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));\n+void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,\n+\t\t\t  int eof));\n+void _tr_align        OF((deflate_state *s));\n+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,\n+                          int eof));\n+\n+#define d_code(dist) \\\n+   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])\n+/* Mapping from a distance to a distance code. dist is the distance - 1 and\n+ * must not have side effects. _dist_code[256] and _dist_code[257] are never\n+ * used.\n+ */\n+\n+#ifndef DEBUG\n+/* Inline versions of _tr_tally for speed: */\n+\n+#if defined(GEN_TREES_H) || !defined(STDC)\n+  extern uch _length_code[];\n+  extern uch _dist_code[];\n+#else\n+  extern const uch _length_code[];\n+  extern const uch _dist_code[];\n+#endif\n+\n+# define _tr_tally_lit(s, c, flush) \\\n+  { uch cc = (c); \\\n+    s->d_buf[s->last_lit] = 0; \\\n+    s->l_buf[s->last_lit++] = cc; \\\n+    s->dyn_ltree[cc].Freq++; \\\n+    flush = (s->last_lit == s->lit_bufsize-1); \\\n+   }\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+  { uch len = (length); \\\n+    ush dist = (distance); \\\n+    s->d_buf[s->last_lit] = dist; \\\n+    s->l_buf[s->last_lit++] = len; \\\n+    dist--; \\\n+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n+    s->dyn_dtree[d_code(dist)].Freq++; \\\n+    flush = (s->last_lit == s->lit_bufsize-1); \\\n+  }\n+#else\n+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+              flush = _tr_tally(s, distance, length) \n+#endif\n+\n+#endif"}, {"sha": "9d364598a2716431b789b260974354adaeafc771", "filename": "zlib/descrip.mms", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdescrip.mms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fdescrip.mms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdescrip.mms?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,48 @@\n+# descrip.mms: MMS description file for building zlib on VMS\n+# written by Martin P.J. Zinser <m.zinser@gsi.de>\n+\n+cc_defs = \n+c_deb = \n+\n+.ifdef __DECC__\n+pref = /prefix=all\n+.endif\n+\n+OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj,\\\n+       deflate.obj, trees.obj, zutil.obj, inflate.obj, infblock.obj,\\\n+       inftrees.obj, infcodes.obj, infutil.obj, inffast.obj\n+\n+CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)\n+\n+all : example.exe minigzip.exe\n+        @ write sys$output \" Example applications available\"\n+libz.olb : libz.olb($(OBJS))\n+\t@ write sys$output \" libz available\"\n+\n+example.exe : example.obj libz.olb\n+              link example,libz.olb/lib\n+\n+minigzip.exe : minigzip.obj libz.olb\n+              link minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\n+\n+clean : \n+\tdelete *.obj;*,libz.olb;*\n+\n+\n+# Other dependencies.\n+adler32.obj : zutil.h zlib.h zconf.h\n+compress.obj : zlib.h zconf.h\n+crc32.obj : zutil.h zlib.h zconf.h\n+deflate.obj : deflate.h zutil.h zlib.h zconf.h\n+example.obj : zlib.h zconf.h\n+gzio.obj : zutil.h zlib.h zconf.h\n+infblock.obj : zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+infcodes.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n+inffast.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+inflate.obj : zutil.h zlib.h zconf.h infblock.h\n+inftrees.obj : zutil.h zlib.h zconf.h inftrees.h\n+infutil.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h\n+minigzip.obj : zlib.h zconf.h\n+trees.obj : deflate.h zutil.h zlib.h zconf.h\n+uncompr.obj : zlib.h zconf.h\n+zutil.obj : zutil.h zlib.h zconf.h"}, {"sha": "8307c841e4a83916b595a3ba744513305e54de9e", "filename": "zlib/example.c", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fexample.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fexample.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexample.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,556 @@\n+/* example.c -- usage example of the zlib compression library\n+ * Copyright (C) 1995-1998 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include <stdio.h>\n+#include \"zlib.h\"\n+\n+#ifdef STDC\n+#  include <string.h>\n+#  include <stdlib.h>\n+#else\n+   extern void exit  OF((int));\n+#endif\n+\n+#if defined(VMS) || defined(RISCOS)\n+#  define TESTFILE \"foo-gz\"\n+#else\n+#  define TESTFILE \"foo.gz\"\n+#endif\n+\n+#define CHECK_ERR(err, msg) { \\\n+    if (err != Z_OK) { \\\n+        fprintf(stderr, \"%s error: %d\\n\", msg, err); \\\n+        exit(1); \\\n+    } \\\n+}\n+\n+const char hello[] = \"hello, hello!\";\n+/* \"hello world\" would be more standard, but the repeated \"hello\"\n+ * stresses the compression code better, sorry...\n+ */\n+\n+const char dictionary[] = \"hello\";\n+uLong dictId; /* Adler32 value of the dictionary */\n+\n+void test_compress      OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+void test_gzio          OF((const char *out, const char *in, \n+\t\t            Byte *uncompr, int uncomprLen));\n+void test_deflate       OF((Byte *compr, uLong comprLen));\n+void test_inflate       OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+void test_large_deflate OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+void test_large_inflate OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+void test_flush         OF((Byte *compr, uLong *comprLen));\n+void test_sync          OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+void test_dict_deflate  OF((Byte *compr, uLong comprLen));\n+void test_dict_inflate  OF((Byte *compr, uLong comprLen,\n+\t\t            Byte *uncompr, uLong uncomprLen));\n+int  main               OF((int argc, char *argv[]));\n+\n+/* ===========================================================================\n+ * Test compress() and uncompress()\n+ */\n+void test_compress(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    uLong len = strlen(hello)+1;\n+\n+    err = compress(compr, &comprLen, (const Bytef*)hello, len);\n+    CHECK_ERR(err, \"compress\");\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n+    CHECK_ERR(err, \"uncompress\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad uncompress\\n\");\n+\texit(1);\n+    } else {\n+        printf(\"uncompress(): %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test read/write of .gz files\n+ */\n+void test_gzio(out, in, uncompr, uncomprLen)\n+    const char *out; /* compressed output file */\n+    const char *in;  /* compressed input file */\n+    Byte *uncompr;\n+    int  uncomprLen;\n+{\n+    int err;\n+    int len = strlen(hello)+1;\n+    gzFile file;\n+    z_off_t pos;\n+\n+    file = gzopen(out, \"wb\");\n+    if (file == NULL) {\n+        fprintf(stderr, \"gzopen error\\n\");\n+        exit(1);\n+    }\n+    gzputc(file, 'h');\n+    if (gzputs(file, \"ello\") != 4) {\n+        fprintf(stderr, \"gzputs err: %s\\n\", gzerror(file, &err));\n+\texit(1);\n+    }\n+    if (gzprintf(file, \", %s!\", \"hello\") != 8) {\n+        fprintf(stderr, \"gzprintf err: %s\\n\", gzerror(file, &err));\n+\texit(1);\n+    }\n+    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */\n+    gzclose(file);\n+\n+    file = gzopen(in, \"rb\");\n+    if (file == NULL) {\n+        fprintf(stderr, \"gzopen error\\n\");\n+    }\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);\n+    if (uncomprLen != len) {\n+        fprintf(stderr, \"gzread err: %s\\n\", gzerror(file, &err));\n+\texit(1);\n+    }\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad gzread: %s\\n\", (char*)uncompr);\n+\texit(1);\n+    } else {\n+        printf(\"gzread(): %s\\n\", (char *)uncompr);\n+    }\n+\n+    pos = gzseek(file, -8L, SEEK_CUR);\n+    if (pos != 6 || gztell(file) != pos) {\n+\tfprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n+\t\t(long)pos, (long)gztell(file));\n+\texit(1);\n+    }\n+\n+    if (gzgetc(file) != ' ') {\n+\tfprintf(stderr, \"gzgetc error\\n\");\n+\texit(1);\n+    }\n+\n+    gzgets(file, (char*)uncompr, uncomprLen);\n+    uncomprLen = strlen((char*)uncompr);\n+    if (uncomprLen != 6) { /* \"hello!\" */\n+        fprintf(stderr, \"gzgets err after gzseek: %s\\n\", gzerror(file, &err));\n+\texit(1);\n+    }\n+    if (strcmp((char*)uncompr, hello+7)) {\n+        fprintf(stderr, \"bad gzgets after gzseek\\n\");\n+\texit(1);\n+    } else {\n+        printf(\"gzgets() after gzseek: %s\\n\", (char *)uncompr);\n+    }\n+\n+    gzclose(file);\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with small buffers\n+ */\n+void test_deflate(compr, comprLen)\n+    Byte *compr;\n+    uLong comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+    int len = strlen(hello)+1;\n+\n+    c_stream.zalloc = (alloc_func)0;\n+    c_stream.zfree = (free_func)0;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_in  = (Bytef*)hello;\n+    c_stream.next_out = compr;\n+\n+    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {\n+        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */\n+        err = deflate(&c_stream, Z_NO_FLUSH);\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+    /* Finish the stream, still forcing small buffers: */\n+    for (;;) {\n+        c_stream.avail_out = 1;\n+        err = deflate(&c_stream, Z_FINISH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with small buffers\n+ */\n+void test_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = (alloc_func)0;\n+    d_stream.zfree = (free_func)0;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = 0;\n+    d_stream.next_out = uncompr;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {\n+        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"inflate\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad inflate\\n\");\n+\texit(1);\n+    } else {\n+        printf(\"inflate(): %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with large buffers and dynamic change of compression level\n+ */\n+void test_large_deflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+\n+    c_stream.zalloc = (alloc_func)0;\n+    c_stream.zfree = (free_func)0;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_BEST_SPEED);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_out = compr;\n+    c_stream.avail_out = (uInt)comprLen;\n+\n+    /* At this point, uncompr is still mostly zeroes, so it should compress\n+     * very well:\n+     */\n+    c_stream.next_in = uncompr;\n+    c_stream.avail_in = (uInt)uncomprLen;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+    if (c_stream.avail_in != 0) {\n+        fprintf(stderr, \"deflate not greedy\\n\");\n+\texit(1);\n+    }\n+\n+    /* Feed in already compressed data and switch to no compression: */\n+    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);\n+    c_stream.next_in = compr;\n+    c_stream.avail_in = (uInt)comprLen/2;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    /* Switch back to compressing mode: */\n+    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);\n+    c_stream.next_in = uncompr;\n+    c_stream.avail_in = (uInt)uncomprLen;\n+    err = deflate(&c_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n+\texit(1);\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with large buffers\n+ */\n+void test_large_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = (alloc_func)0;\n+    d_stream.zfree = (free_func)0;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = (uInt)comprLen;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    for (;;) {\n+        d_stream.next_out = uncompr;            /* discard the output */\n+\td_stream.avail_out = (uInt)uncomprLen;\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+        CHECK_ERR(err, \"large inflate\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {\n+        fprintf(stderr, \"bad large inflate: %ld\\n\", d_stream.total_out);\n+\texit(1);\n+    } else {\n+        printf(\"large_inflate(): OK\\n\");\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with full flush\n+ */\n+void test_flush(compr, comprLen)\n+    Byte *compr;\n+    uLong *comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+    int len = strlen(hello)+1;\n+\n+    c_stream.zalloc = (alloc_func)0;\n+    c_stream.zfree = (free_func)0;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    c_stream.next_in  = (Bytef*)hello;\n+    c_stream.next_out = compr;\n+    c_stream.avail_in = 3;\n+    c_stream.avail_out = (uInt)*comprLen;\n+    err = deflate(&c_stream, Z_FULL_FLUSH);\n+    CHECK_ERR(err, \"deflate\");\n+\n+    compr[3]++; /* force an error in first compressed block */\n+    c_stream.avail_in = len - 3;\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        CHECK_ERR(err, \"deflate\");\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+\n+    *comprLen = c_stream.total_out;\n+}\n+\n+/* ===========================================================================\n+ * Test inflateSync()\n+ */\n+void test_sync(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = (alloc_func)0;\n+    d_stream.zfree = (free_func)0;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = 2; /* just read the zlib header */\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    d_stream.next_out = uncompr;\n+    d_stream.avail_out = (uInt)uncomprLen;\n+\n+    inflate(&d_stream, Z_NO_FLUSH);\n+    CHECK_ERR(err, \"inflate\");\n+\n+    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */\n+    err = inflateSync(&d_stream);           /* but skip the damaged part */\n+    CHECK_ERR(err, \"inflateSync\");\n+\n+    err = inflate(&d_stream, Z_FINISH);\n+    if (err != Z_DATA_ERROR) {\n+        fprintf(stderr, \"inflate should report DATA_ERROR\\n\");\n+        /* Because of incorrect adler32 */\n+\texit(1);\n+    }\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    printf(\"after inflateSync(): hel%s\\n\", (char *)uncompr);\n+}\n+\n+/* ===========================================================================\n+ * Test deflate() with preset dictionary\n+ */\n+void test_dict_deflate(compr, comprLen)\n+    Byte *compr;\n+    uLong comprLen;\n+{\n+    z_stream c_stream; /* compression stream */\n+    int err;\n+\n+    c_stream.zalloc = (alloc_func)0;\n+    c_stream.zfree = (free_func)0;\n+    c_stream.opaque = (voidpf)0;\n+\n+    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);\n+    CHECK_ERR(err, \"deflateInit\");\n+\n+    err = deflateSetDictionary(&c_stream,\n+\t\t\t       (const Bytef*)dictionary, sizeof(dictionary));\n+    CHECK_ERR(err, \"deflateSetDictionary\");\n+\n+    dictId = c_stream.adler;\n+    c_stream.next_out = compr;\n+    c_stream.avail_out = (uInt)comprLen;\n+\n+    c_stream.next_in = (Bytef*)hello;\n+    c_stream.avail_in = (uInt)strlen(hello)+1;\n+\n+    err = deflate(&c_stream, Z_FINISH);\n+    if (err != Z_STREAM_END) {\n+        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n+\texit(1);\n+    }\n+    err = deflateEnd(&c_stream);\n+    CHECK_ERR(err, \"deflateEnd\");\n+}\n+\n+/* ===========================================================================\n+ * Test inflate() with a preset dictionary\n+ */\n+void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)\n+    Byte *compr, *uncompr;\n+    uLong comprLen, uncomprLen;\n+{\n+    int err;\n+    z_stream d_stream; /* decompression stream */\n+\n+    strcpy((char*)uncompr, \"garbage\");\n+\n+    d_stream.zalloc = (alloc_func)0;\n+    d_stream.zfree = (free_func)0;\n+    d_stream.opaque = (voidpf)0;\n+\n+    d_stream.next_in  = compr;\n+    d_stream.avail_in = (uInt)comprLen;\n+\n+    err = inflateInit(&d_stream);\n+    CHECK_ERR(err, \"inflateInit\");\n+\n+    d_stream.next_out = uncompr;\n+    d_stream.avail_out = (uInt)uncomprLen;\n+\n+    for (;;) {\n+        err = inflate(&d_stream, Z_NO_FLUSH);\n+        if (err == Z_STREAM_END) break;\n+\tif (err == Z_NEED_DICT) {\n+\t    if (d_stream.adler != dictId) {\n+\t\tfprintf(stderr, \"unexpected dictionary\");\n+\t\texit(1);\n+\t    }\n+\t    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,\n+\t\t\t\t       sizeof(dictionary));\n+\t}\n+        CHECK_ERR(err, \"inflate with dict\");\n+    }\n+\n+    err = inflateEnd(&d_stream);\n+    CHECK_ERR(err, \"inflateEnd\");\n+\n+    if (strcmp((char*)uncompr, hello)) {\n+        fprintf(stderr, \"bad inflate with dict\\n\");\n+\texit(1);\n+    } else {\n+        printf(\"inflate with dictionary: %s\\n\", (char *)uncompr);\n+    }\n+}\n+\n+/* ===========================================================================\n+ * Usage:  example [output.gz  [input.gz]]\n+ */\n+\n+int main(argc, argv)\n+    int argc;\n+    char *argv[];\n+{\n+    Byte *compr, *uncompr;\n+    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */\n+    uLong uncomprLen = comprLen;\n+    static const char* myVersion = ZLIB_VERSION;\n+\n+    if (zlibVersion()[0] != myVersion[0]) {\n+        fprintf(stderr, \"incompatible zlib version\\n\");\n+        exit(1);\n+\n+    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {\n+        fprintf(stderr, \"warning: different zlib version\\n\");\n+    }\n+\n+    compr    = (Byte*)calloc((uInt)comprLen, 1);\n+    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);\n+    /* compr and uncompr are cleared to avoid reading uninitialized\n+     * data and to ensure that uncompr compresses well.\n+     */\n+    if (compr == Z_NULL || uncompr == Z_NULL) {\n+        printf(\"out of memory\\n\");\n+\texit(1);\n+    }\n+    test_compress(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_gzio((argc > 1 ? argv[1] : TESTFILE),\n+              (argc > 2 ? argv[2] : TESTFILE),\n+\t      uncompr, (int)uncomprLen);\n+\n+    test_deflate(compr, comprLen);\n+    test_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_large_deflate(compr, comprLen, uncompr, uncomprLen);\n+    test_large_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    test_flush(compr, &comprLen);\n+    test_sync(compr, comprLen, uncompr, uncomprLen);\n+    comprLen = uncomprLen;\n+\n+    test_dict_deflate(compr, comprLen);\n+    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);\n+\n+    exit(0);\n+    return 0; /* to avoid warning */\n+}"}, {"sha": "f7c336a55a0911bdd45fcd9caa10c8570b3c5d6c", "filename": "zlib/gzio.c", "status": "added", "additions": 875, "deletions": 0, "changes": 875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fgzio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fgzio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzio.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,875 @@\n+/* gzio.c -- IO on .gz files\n+ * Copyright (C) 1995-1998 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ *\n+ * Compile this file with -DNO_DEFLATE to avoid the compression code.\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include <stdio.h>\n+\n+#include \"zutil.h\"\n+\n+struct internal_state {int dummy;}; /* for buggy compilers */\n+\n+#ifndef Z_BUFSIZE\n+#  ifdef MAXSEG_64K\n+#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */\n+#  else\n+#    define Z_BUFSIZE 16384\n+#  endif\n+#endif\n+#ifndef Z_PRINTF_BUFSIZE\n+#  define Z_PRINTF_BUFSIZE 4096\n+#endif\n+\n+#define ALLOC(size) malloc(size)\n+#define TRYFREE(p) {if (p) free(p);}\n+\n+static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */\n+\n+/* gzip flag byte */\n+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */\n+#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */\n+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n+#define COMMENT      0x10 /* bit 4 set: file comment present */\n+#define RESERVED     0xE0 /* bits 5..7: reserved */\n+\n+typedef struct gz_stream {\n+    z_stream stream;\n+    int      z_err;   /* error code for last stream operation */\n+    int      z_eof;   /* set if end of input file */\n+    FILE     *file;   /* .gz file */\n+    Byte     *inbuf;  /* input buffer */\n+    Byte     *outbuf; /* output buffer */\n+    uLong    crc;     /* crc32 of uncompressed data */\n+    char     *msg;    /* error message */\n+    char     *path;   /* path name for debugging only */\n+    int      transparent; /* 1 if input file is not a .gz file */\n+    char     mode;    /* 'w' or 'r' */\n+    long     startpos; /* start of compressed data in file (header skipped) */\n+} gz_stream;\n+\n+\n+local gzFile gz_open      OF((const char *path, const char *mode, int  fd));\n+local int do_flush        OF((gzFile file, int flush));\n+local int    get_byte     OF((gz_stream *s));\n+local void   check_header OF((gz_stream *s));\n+local int    destroy      OF((gz_stream *s));\n+local void   putLong      OF((FILE *file, uLong x));\n+local uLong  getLong      OF((gz_stream *s));\n+\n+/* ===========================================================================\n+     Opens a gzip (.gz) file for reading or writing. The mode parameter\n+   is as in fopen (\"rb\" or \"wb\"). The file is given either by file descriptor\n+   or path name (if fd == -1).\n+     gz_open return NULL if the file could not be opened or if there was\n+   insufficient memory to allocate the (de)compression state; errno\n+   can be checked to distinguish the two cases (if errno is zero, the\n+   zlib error is Z_MEM_ERROR).\n+*/\n+local gzFile gz_open (path, mode, fd)\n+    const char *path;\n+    const char *mode;\n+    int  fd;\n+{\n+    int err;\n+    int level = Z_DEFAULT_COMPRESSION; /* compression level */\n+    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */\n+    char *p = (char*)mode;\n+    gz_stream *s;\n+    char fmode[80]; /* copy of mode, without the compression level */\n+    char *m = fmode;\n+\n+    if (!path || !mode) return Z_NULL;\n+\n+    s = (gz_stream *)ALLOC(sizeof(gz_stream));\n+    if (!s) return Z_NULL;\n+\n+    s->stream.zalloc = (alloc_func)0;\n+    s->stream.zfree = (free_func)0;\n+    s->stream.opaque = (voidpf)0;\n+    s->stream.next_in = s->inbuf = Z_NULL;\n+    s->stream.next_out = s->outbuf = Z_NULL;\n+    s->stream.avail_in = s->stream.avail_out = 0;\n+    s->file = NULL;\n+    s->z_err = Z_OK;\n+    s->z_eof = 0;\n+    s->crc = crc32(0L, Z_NULL, 0);\n+    s->msg = NULL;\n+    s->transparent = 0;\n+\n+    s->path = (char*)ALLOC(strlen(path)+1);\n+    if (s->path == NULL) {\n+        return destroy(s), (gzFile)Z_NULL;\n+    }\n+    strcpy(s->path, path); /* do this early for debugging */\n+\n+    s->mode = '\\0';\n+    do {\n+        if (*p == 'r') s->mode = 'r';\n+        if (*p == 'w' || *p == 'a') s->mode = 'w';\n+        if (*p >= '0' && *p <= '9') {\n+\t    level = *p - '0';\n+\t} else if (*p == 'f') {\n+\t  strategy = Z_FILTERED;\n+\t} else if (*p == 'h') {\n+\t  strategy = Z_HUFFMAN_ONLY;\n+\t} else {\n+\t    *m++ = *p; /* copy the mode */\n+\t}\n+    } while (*p++ && m != fmode + sizeof(fmode));\n+    if (s->mode == '\\0') return destroy(s), (gzFile)Z_NULL;\n+    \n+    if (s->mode == 'w') {\n+#ifdef NO_DEFLATE\n+        err = Z_STREAM_ERROR;\n+#else\n+        err = deflateInit2(&(s->stream), level,\n+                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);\n+        /* windowBits is passed < 0 to suppress zlib header */\n+\n+        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n+#endif\n+        if (err != Z_OK || s->outbuf == Z_NULL) {\n+            return destroy(s), (gzFile)Z_NULL;\n+        }\n+    } else {\n+        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);\n+\n+        err = inflateInit2(&(s->stream), -MAX_WBITS);\n+        /* windowBits is passed < 0 to tell that there is no zlib header.\n+         * Note that in this case inflate *requires* an extra \"dummy\" byte\n+         * after the compressed stream in order to complete decompression and\n+         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are\n+         * present after the compressed stream.\n+         */\n+        if (err != Z_OK || s->inbuf == Z_NULL) {\n+            return destroy(s), (gzFile)Z_NULL;\n+        }\n+    }\n+    s->stream.avail_out = Z_BUFSIZE;\n+\n+    errno = 0;\n+    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);\n+\n+    if (s->file == NULL) {\n+        return destroy(s), (gzFile)Z_NULL;\n+    }\n+    if (s->mode == 'w') {\n+        /* Write a very simple .gz header:\n+         */\n+        fprintf(s->file, \"%c%c%c%c%c%c%c%c%c%c\", gz_magic[0], gz_magic[1],\n+             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);\n+\ts->startpos = 10L;\n+\t/* We use 10L instead of ftell(s->file) to because ftell causes an\n+         * fflush on some systems. This version of the library doesn't use\n+         * startpos anyway in write mode, so this initialization is not\n+         * necessary.\n+         */\n+    } else {\n+\tcheck_header(s); /* skip the .gz header */\n+\ts->startpos = (ftell(s->file) - s->stream.avail_in);\n+    }\n+    \n+    return (gzFile)s;\n+}\n+\n+/* ===========================================================================\n+     Opens a gzip (.gz) file for reading or writing.\n+*/\n+gzFile ZEXPORT gzopen (path, mode)\n+    const char *path;\n+    const char *mode;\n+{\n+    return gz_open (path, mode, -1);\n+}\n+\n+/* ===========================================================================\n+     Associate a gzFile with the file descriptor fd. fd is not dup'ed here\n+   to mimic the behavio(u)r of fdopen.\n+*/\n+gzFile ZEXPORT gzdopen (fd, mode)\n+    int fd;\n+    const char *mode;\n+{\n+    char name[20];\n+\n+    if (fd < 0) return (gzFile)Z_NULL;\n+    sprintf(name, \"<fd:%d>\", fd); /* for debugging */\n+\n+    return gz_open (name, mode, fd);\n+}\n+\n+/* ===========================================================================\n+ * Update the compression level and strategy\n+ */\n+int ZEXPORT gzsetparams (file, level, strategy)\n+    gzFile file;\n+    int level;\n+    int strategy;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n+\n+    /* Make room to allow flushing */\n+    if (s->stream.avail_out == 0) {\n+\n+\ts->stream.next_out = s->outbuf;\n+\tif (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n+\t    s->z_err = Z_ERRNO;\n+\t}\n+\ts->stream.avail_out = Z_BUFSIZE;\n+    }\n+\n+    return deflateParams (&(s->stream), level, strategy);\n+}\n+\n+/* ===========================================================================\n+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n+   for end of file.\n+   IN assertion: the stream s has been sucessfully opened for reading.\n+*/\n+local int get_byte(s)\n+    gz_stream *s;\n+{\n+    if (s->z_eof) return EOF;\n+    if (s->stream.avail_in == 0) {\n+\terrno = 0;\n+\ts->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n+\tif (s->stream.avail_in == 0) {\n+\t    s->z_eof = 1;\n+\t    if (ferror(s->file)) s->z_err = Z_ERRNO;\n+\t    return EOF;\n+\t}\n+\ts->stream.next_in = s->inbuf;\n+    }\n+    s->stream.avail_in--;\n+    return *(s->stream.next_in)++;\n+}\n+\n+/* ===========================================================================\n+      Check the gzip header of a gz_stream opened for reading. Set the stream\n+    mode to transparent if the gzip magic header is not present; set s->err\n+    to Z_DATA_ERROR if the magic header is present but the rest of the header\n+    is incorrect.\n+    IN assertion: the stream s has already been created sucessfully;\n+       s->stream.avail_in is zero for the first time, but may be non-zero\n+       for concatenated .gz files.\n+*/\n+local void check_header(s)\n+    gz_stream *s;\n+{\n+    int method; /* method byte */\n+    int flags;  /* flags byte */\n+    uInt len;\n+    int c;\n+\n+    /* Check the gzip magic header */\n+    for (len = 0; len < 2; len++) {\n+\tc = get_byte(s);\n+\tif (c != gz_magic[len]) {\n+\t    if (len != 0) s->stream.avail_in++, s->stream.next_in--;\n+\t    if (c != EOF) {\n+\t\ts->stream.avail_in++, s->stream.next_in--;\n+\t\ts->transparent = 1;\n+\t    }\n+\t    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;\n+\t    return;\n+\t}\n+    }\n+    method = get_byte(s);\n+    flags = get_byte(s);\n+    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {\n+\ts->z_err = Z_DATA_ERROR;\n+\treturn;\n+    }\n+\n+    /* Discard time, xflags and OS code: */\n+    for (len = 0; len < 6; len++) (void)get_byte(s);\n+\n+    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */\n+\tlen  =  (uInt)get_byte(s);\n+\tlen += ((uInt)get_byte(s))<<8;\n+\t/* len is garbage if EOF but the loop below will quit anyway */\n+\twhile (len-- != 0 && get_byte(s) != EOF) ;\n+    }\n+    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */\n+\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n+    }\n+    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */\n+\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n+    }\n+    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */\n+\tfor (len = 0; len < 2; len++) (void)get_byte(s);\n+    }\n+    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;\n+}\n+\n+ /* ===========================================================================\n+ * Cleanup then free the given gz_stream. Return a zlib error code.\n+   Try freeing in the reverse order of allocations.\n+ */\n+local int destroy (s)\n+    gz_stream *s;\n+{\n+    int err = Z_OK;\n+\n+    if (!s) return Z_STREAM_ERROR;\n+\n+    TRYFREE(s->msg);\n+\n+    if (s->stream.state != NULL) {\n+\tif (s->mode == 'w') {\n+#ifdef NO_DEFLATE\n+\t    err = Z_STREAM_ERROR;\n+#else\n+\t    err = deflateEnd(&(s->stream));\n+#endif\n+\t} else if (s->mode == 'r') {\n+\t    err = inflateEnd(&(s->stream));\n+\t}\n+    }\n+    if (s->file != NULL && fclose(s->file)) {\n+#ifdef ESPIPE\n+\tif (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */\n+#endif\n+\t    err = Z_ERRNO;\n+    }\n+    if (s->z_err < 0) err = s->z_err;\n+\n+    TRYFREE(s->inbuf);\n+    TRYFREE(s->outbuf);\n+    TRYFREE(s->path);\n+    TRYFREE(s);\n+    return err;\n+}\n+\n+/* ===========================================================================\n+     Reads the given number of uncompressed bytes from the compressed file.\n+   gzread returns the number of bytes actually read (0 for end of file).\n+*/\n+int ZEXPORT gzread (file, buf, len)\n+    gzFile file;\n+    voidp buf;\n+    unsigned len;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+    Bytef *start = (Bytef*)buf; /* starting point for crc computation */\n+    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */\n+\n+    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;\n+\n+    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;\n+    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */\n+\n+    next_out = (Byte*)buf;\n+    s->stream.next_out = (Bytef*)buf;\n+    s->stream.avail_out = len;\n+\n+    while (s->stream.avail_out != 0) {\n+\n+\tif (s->transparent) {\n+\t    /* Copy first the lookahead bytes: */\n+\t    uInt n = s->stream.avail_in;\n+\t    if (n > s->stream.avail_out) n = s->stream.avail_out;\n+\t    if (n > 0) {\n+\t\tzmemcpy(s->stream.next_out, s->stream.next_in, n);\n+\t\tnext_out += n;\n+\t\ts->stream.next_out = next_out;\n+\t\ts->stream.next_in   += n;\n+\t\ts->stream.avail_out -= n;\n+\t\ts->stream.avail_in  -= n;\n+\t    }\n+\t    if (s->stream.avail_out > 0) {\n+\t\ts->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n+\t\t\t\t\t     s->file);\n+\t    }\n+\t    len -= s->stream.avail_out;\n+\t    s->stream.total_in  += (uLong)len;\n+\t    s->stream.total_out += (uLong)len;\n+            if (len == 0) s->z_eof = 1;\n+\t    return (int)len;\n+\t}\n+        if (s->stream.avail_in == 0 && !s->z_eof) {\n+\n+            errno = 0;\n+            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n+            if (s->stream.avail_in == 0) {\n+                s->z_eof = 1;\n+\t\tif (ferror(s->file)) {\n+\t\t    s->z_err = Z_ERRNO;\n+\t\t    break;\n+\t\t}\n+            }\n+            s->stream.next_in = s->inbuf;\n+        }\n+        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);\n+\n+\tif (s->z_err == Z_STREAM_END) {\n+\t    /* Check CRC and original size */\n+\t    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n+\t    start = s->stream.next_out;\n+\n+\t    if (getLong(s) != s->crc) {\n+\t\ts->z_err = Z_DATA_ERROR;\n+\t    } else {\n+\t        (void)getLong(s);\n+                /* The uncompressed length returned by above getlong() may\n+                 * be different from s->stream.total_out) in case of\n+\t\t * concatenated .gz files. Check for such files:\n+\t\t */\n+\t\tcheck_header(s);\n+\t\tif (s->z_err == Z_OK) {\n+\t\t    uLong total_in = s->stream.total_in;\n+\t\t    uLong total_out = s->stream.total_out;\n+\n+\t\t    inflateReset(&(s->stream));\n+\t\t    s->stream.total_in = total_in;\n+\t\t    s->stream.total_out = total_out;\n+\t\t    s->crc = crc32(0L, Z_NULL, 0);\n+\t\t}\n+\t    }\n+\t}\n+\tif (s->z_err != Z_OK || s->z_eof) break;\n+    }\n+    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n+\n+    return (int)(len - s->stream.avail_out);\n+}\n+\n+\n+/* ===========================================================================\n+      Reads one byte from the compressed file. gzgetc returns this byte\n+   or -1 in case of end of file or error.\n+*/\n+int ZEXPORT gzgetc(file)\n+    gzFile file;\n+{\n+    unsigned char c;\n+\n+    return gzread(file, &c, 1) == 1 ? c : -1;\n+}\n+\n+\n+/* ===========================================================================\n+      Reads bytes from the compressed file until len-1 characters are\n+   read, or a newline character is read and transferred to buf, or an\n+   end-of-file condition is encountered.  The string is then terminated\n+   with a null character.\n+      gzgets returns buf, or Z_NULL in case of error.\n+\n+      The current implementation is not optimized at all.\n+*/\n+char * ZEXPORT gzgets(file, buf, len)\n+    gzFile file;\n+    char *buf;\n+    int len;\n+{\n+    char *b = buf;\n+    if (buf == Z_NULL || len <= 0) return Z_NULL;\n+\n+    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\\n') ;\n+    *buf = '\\0';\n+    return b == buf && len > 0 ? Z_NULL : b;\n+}\n+\n+\n+#ifndef NO_DEFLATE\n+/* ===========================================================================\n+     Writes the given number of uncompressed bytes into the compressed file.\n+   gzwrite returns the number of bytes actually written (0 in case of error).\n+*/\n+int ZEXPORT gzwrite (file, buf, len)\n+    gzFile file;\n+    const voidp buf;\n+    unsigned len;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n+\n+    s->stream.next_in = (Bytef*)buf;\n+    s->stream.avail_in = len;\n+\n+    while (s->stream.avail_in != 0) {\n+\n+        if (s->stream.avail_out == 0) {\n+\n+            s->stream.next_out = s->outbuf;\n+            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n+                s->z_err = Z_ERRNO;\n+                break;\n+            }\n+            s->stream.avail_out = Z_BUFSIZE;\n+        }\n+        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);\n+        if (s->z_err != Z_OK) break;\n+    }\n+    s->crc = crc32(s->crc, (const Bytef *)buf, len);\n+\n+    return (int)(len - s->stream.avail_in);\n+}\n+\n+/* ===========================================================================\n+     Converts, formats, and writes the args to the compressed file under\n+   control of the format string, as in fprintf. gzprintf returns the number of\n+   uncompressed bytes actually written (0 in case of error).\n+*/\n+#ifdef STDC\n+#include <stdarg.h>\n+\n+int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n+{\n+    char buf[Z_PRINTF_BUFSIZE];\n+    va_list va;\n+    int len;\n+\n+    va_start(va, format);\n+#ifdef HAS_vsnprintf\n+    (void)vsnprintf(buf, sizeof(buf), format, va);\n+#else\n+    (void)vsprintf(buf, format, va);\n+#endif\n+    va_end(va);\n+    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n+    if (len <= 0) return 0;\n+\n+    return gzwrite(file, buf, (unsigned)len);\n+}\n+#else /* not ANSI C */\n+\n+int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n+\t               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n+    gzFile file;\n+    const char *format;\n+    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n+\ta11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n+{\n+    char buf[Z_PRINTF_BUFSIZE];\n+    int len;\n+\n+#ifdef HAS_snprintf\n+    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n+\t     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+#else\n+    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n+\t    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+#endif\n+    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */\n+    if (len <= 0) return 0;\n+\n+    return gzwrite(file, buf, len);\n+}\n+#endif\n+\n+/* ===========================================================================\n+      Writes c, converted to an unsigned char, into the compressed file.\n+   gzputc returns the value that was written, or -1 in case of error.\n+*/\n+int ZEXPORT gzputc(file, c)\n+    gzFile file;\n+    int c;\n+{\n+    unsigned char cc = (unsigned char) c; /* required for big endian systems */\n+\n+    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;\n+}\n+\n+\n+/* ===========================================================================\n+      Writes the given null-terminated string to the compressed file, excluding\n+   the terminating null character.\n+      gzputs returns the number of characters written, or -1 in case of error.\n+*/\n+int ZEXPORT gzputs(file, s)\n+    gzFile file;\n+    const char *s;\n+{\n+    return gzwrite(file, (char*)s, (unsigned)strlen(s));\n+}\n+\n+\n+/* ===========================================================================\n+     Flushes all pending output into the compressed file. The parameter\n+   flush is as in the deflate() function.\n+*/\n+local int do_flush (file, flush)\n+    gzFile file;\n+    int flush;\n+{\n+    uInt len;\n+    int done = 0;\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n+\n+    s->stream.avail_in = 0; /* should be zero already anyway */\n+\n+    for (;;) {\n+        len = Z_BUFSIZE - s->stream.avail_out;\n+\n+        if (len != 0) {\n+            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {\n+                s->z_err = Z_ERRNO;\n+                return Z_ERRNO;\n+            }\n+            s->stream.next_out = s->outbuf;\n+            s->stream.avail_out = Z_BUFSIZE;\n+        }\n+        if (done) break;\n+        s->z_err = deflate(&(s->stream), flush);\n+\n+\t/* Ignore the second of two consecutive flushes: */\n+\tif (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;\n+\n+        /* deflate has finished flushing only when it hasn't used up\n+         * all the available space in the output buffer: \n+         */\n+        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);\n+ \n+        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;\n+    }\n+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n+}\n+\n+int ZEXPORT gzflush (file, flush)\n+     gzFile file;\n+     int flush;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+    int err = do_flush (file, flush);\n+\n+    if (err) return err;\n+    fflush(s->file);\n+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n+}\n+#endif /* NO_DEFLATE */\n+\n+/* ===========================================================================\n+      Sets the starting position for the next gzread or gzwrite on the given\n+   compressed file. The offset represents a number of bytes in the\n+      gzseek returns the resulting offset location as measured in bytes from\n+   the beginning of the uncompressed stream, or -1 in case of error.\n+      SEEK_END is not implemented, returns error.\n+      In this version of the library, gzseek can be extremely slow.\n+*/\n+z_off_t ZEXPORT gzseek (file, offset, whence)\n+    gzFile file;\n+    z_off_t offset;\n+    int whence;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || whence == SEEK_END ||\n+\ts->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {\n+\treturn -1L;\n+    }\n+    \n+    if (s->mode == 'w') {\n+#ifdef NO_DEFLATE\n+\treturn -1L;\n+#else\n+\tif (whence == SEEK_SET) {\n+\t    offset -= s->stream.total_in;\n+\t}\n+\tif (offset < 0) return -1L;\n+\n+\t/* At this point, offset is the number of zero bytes to write. */\n+\tif (s->inbuf == Z_NULL) {\n+\t    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */\n+\t    zmemzero(s->inbuf, Z_BUFSIZE);\n+\t}\n+\twhile (offset > 0)  {\n+\t    uInt size = Z_BUFSIZE;\n+\t    if (offset < Z_BUFSIZE) size = (uInt)offset;\n+\n+\t    size = gzwrite(file, s->inbuf, size);\n+\t    if (size == 0) return -1L;\n+\n+\t    offset -= size;\n+\t}\n+\treturn (z_off_t)s->stream.total_in;\n+#endif\n+    }\n+    /* Rest of function is for reading only */\n+\n+    /* compute absolute position */\n+    if (whence == SEEK_CUR) {\n+\toffset += s->stream.total_out;\n+    }\n+    if (offset < 0) return -1L;\n+\n+    if (s->transparent) {\n+\t/* map to fseek */\n+\ts->stream.avail_in = 0;\n+\ts->stream.next_in = s->inbuf;\n+        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;\n+\n+\ts->stream.total_in = s->stream.total_out = (uLong)offset;\n+\treturn offset;\n+    }\n+\n+    /* For a negative seek, rewind and use positive seek */\n+    if ((uLong)offset >= s->stream.total_out) {\n+\toffset -= s->stream.total_out;\n+    } else if (gzrewind(file) < 0) {\n+\treturn -1L;\n+    }\n+    /* offset is now the number of bytes to skip. */\n+\n+    if (offset != 0 && s->outbuf == Z_NULL) {\n+\ts->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n+    }\n+    while (offset > 0)  {\n+\tint size = Z_BUFSIZE;\n+\tif (offset < Z_BUFSIZE) size = (int)offset;\n+\n+\tsize = gzread(file, s->outbuf, (uInt)size);\n+\tif (size <= 0) return -1L;\n+\toffset -= size;\n+    }\n+    return (z_off_t)s->stream.total_out;\n+}\n+\n+/* ===========================================================================\n+     Rewinds input file. \n+*/\n+int ZEXPORT gzrewind (file)\n+    gzFile file;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+    \n+    if (s == NULL || s->mode != 'r') return -1;\n+\n+    s->z_err = Z_OK;\n+    s->z_eof = 0;\n+    s->stream.avail_in = 0;\n+    s->stream.next_in = s->inbuf;\n+    s->crc = crc32(0L, Z_NULL, 0);\n+\t\n+    if (s->startpos == 0) { /* not a compressed file */\n+\trewind(s->file);\n+\treturn 0;\n+    }\n+\n+    (void) inflateReset(&s->stream);\n+    return fseek(s->file, s->startpos, SEEK_SET);\n+}\n+\n+/* ===========================================================================\n+     Returns the starting position for the next gzread or gzwrite on the\n+   given compressed file. This position represents a number of bytes in the\n+   uncompressed data stream.\n+*/\n+z_off_t ZEXPORT gztell (file)\n+    gzFile file;\n+{\n+    return gzseek(file, 0L, SEEK_CUR);\n+}\n+\n+/* ===========================================================================\n+     Returns 1 when EOF has previously been detected reading the given\n+   input stream, otherwise zero.\n+*/\n+int ZEXPORT gzeof (file)\n+    gzFile file;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+    \n+    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;\n+}\n+\n+/* ===========================================================================\n+   Outputs a long in LSB order to the given file\n+*/\n+local void putLong (file, x)\n+    FILE *file;\n+    uLong x;\n+{\n+    int n;\n+    for (n = 0; n < 4; n++) {\n+        fputc((int)(x & 0xff), file);\n+        x >>= 8;\n+    }\n+}\n+\n+/* ===========================================================================\n+   Reads a long in LSB order from the given gz_stream. Sets z_err in case\n+   of error.\n+*/\n+local uLong getLong (s)\n+    gz_stream *s;\n+{\n+    uLong x = (uLong)get_byte(s);\n+    int c;\n+\n+    x += ((uLong)get_byte(s))<<8;\n+    x += ((uLong)get_byte(s))<<16;\n+    c = get_byte(s);\n+    if (c == EOF) s->z_err = Z_DATA_ERROR;\n+    x += ((uLong)c)<<24;\n+    return x;\n+}\n+\n+/* ===========================================================================\n+     Flushes all pending output if necessary, closes the compressed file\n+   and deallocates all the (de)compression state.\n+*/\n+int ZEXPORT gzclose (file)\n+    gzFile file;\n+{\n+    int err;\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL) return Z_STREAM_ERROR;\n+\n+    if (s->mode == 'w') {\n+#ifdef NO_DEFLATE\n+\treturn Z_STREAM_ERROR;\n+#else\n+        err = do_flush (file, Z_FINISH);\n+        if (err != Z_OK) return destroy((gz_stream*)file);\n+\n+        putLong (s->file, s->crc);\n+        putLong (s->file, s->stream.total_in);\n+#endif\n+    }\n+    return destroy((gz_stream*)file);\n+}\n+\n+/* ===========================================================================\n+     Returns the error message for the last error which occured on the\n+   given compressed file. errnum is set to zlib error number. If an\n+   error occured in the file system and not in the compression library,\n+   errnum is set to Z_ERRNO and the application may consult errno\n+   to get the exact error code.\n+*/\n+const char*  ZEXPORT gzerror (file, errnum)\n+    gzFile file;\n+    int *errnum;\n+{\n+    char *m;\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL) {\n+        *errnum = Z_STREAM_ERROR;\n+        return (const char*)ERR_MSG(Z_STREAM_ERROR);\n+    }\n+    *errnum = s->z_err;\n+    if (*errnum == Z_OK) return (const char*)\"\";\n+\n+    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);\n+\n+    if (m == NULL || *m == '\\0') m = (char*)ERR_MSG(s->z_err);\n+\n+    TRYFREE(s->msg);\n+    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);\n+    strcpy(s->msg, s->path);\n+    strcat(s->msg, \": \");\n+    strcat(s->msg, m);\n+    return (const char*)s->msg;\n+}"}, {"sha": "f4920faa5ea06bee242cbb36c51e47ae0c82f434", "filename": "zlib/infblock.c", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfblock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfblock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfblock.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,398 @@\n+/* infblock.c -- interpret and process block types to last block\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"infblock.h\"\n+#include \"inftrees.h\"\n+#include \"infcodes.h\"\n+#include \"infutil.h\"\n+\n+struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n+\n+/* simplify the use of the inflate_huft type with some defines */\n+#define exop word.what.Exop\n+#define bits word.what.Bits\n+\n+/* Table for deflate from PKZIP's appnote.txt. */\n+local const uInt border[] = { /* Order of the bit length code lengths */\n+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n+\n+/*\n+   Notes beyond the 1.93a appnote.txt:\n+\n+   1. Distance pointers never point before the beginning of the output\n+      stream.\n+   2. Distance pointers can point back across blocks, up to 32k away.\n+   3. There is an implied maximum of 7 bits for the bit length table and\n+      15 bits for the actual data.\n+   4. If only one code exists, then it is encoded using one bit.  (Zero\n+      would be more efficient, but perhaps a little confusing.)  If two\n+      codes exist, they are coded using one bit each (0 and 1).\n+   5. There is no way of sending zero distance codes--a dummy must be\n+      sent if there are none.  (History: a pre 2.0 version of PKZIP would\n+      store blocks with no distance codes, but this was discovered to be\n+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n+      zero distance codes, which is sent as one code of zero bits in\n+      length.\n+   6. There are up to 286 literal/length codes.  Code 256 represents the\n+      end-of-block.  Note however that the static length tree defines\n+      288 codes just to fill out the Huffman codes.  Codes 286 and 287\n+      cannot be used though, since there is no length base or extra bits\n+      defined for them.  Similarily, there are up to 30 distance codes.\n+      However, static trees define 32 codes (all 5 bits) to fill out the\n+      Huffman codes, but the last two had better not show up in the data.\n+   7. Unzip can check dynamic Huffman blocks for complete code sets.\n+      The exception is that a single code would not be complete (see #4).\n+   8. The five bits following the block type is really the number of\n+      literal codes sent minus 257.\n+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n+      (1+6+6).  Therefore, to output three times the length, you output\n+      three codes (1+1+1), whereas to output four times the same length,\n+      you only need two codes (1+3).  Hmm.\n+  10. In the tree reconstruction algorithm, Code = Code + Increment\n+      only if BitLength(i) is not zero.  (Pretty obvious.)\n+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n+  12. Note: length code 284 can represent 227-258, but length code 285\n+      really is 258.  The last length deserves its own, short code\n+      since it gets used a lot in very redundant files.  The length\n+      258 is special since 258 - 3 (the min match length) is 255.\n+  13. The literal/length and distance code bit lengths are read as a\n+      single stream of lengths.  It is possible (and advantageous) for\n+      a repeat code (16, 17, or 18) to go across the boundary between\n+      the two sets of lengths.\n+ */\n+\n+\n+void inflate_blocks_reset(s, z, c)\n+inflate_blocks_statef *s;\n+z_streamp z;\n+uLongf *c;\n+{\n+  if (c != Z_NULL)\n+    *c = s->check;\n+  if (s->mode == BTREE || s->mode == DTREE)\n+    ZFREE(z, s->sub.trees.blens);\n+  if (s->mode == CODES)\n+    inflate_codes_free(s->sub.decode.codes, z);\n+  s->mode = TYPE;\n+  s->bitk = 0;\n+  s->bitb = 0;\n+  s->read = s->write = s->window;\n+  if (s->checkfn != Z_NULL)\n+    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);\n+  Tracev((stderr, \"inflate:   blocks reset\\n\"));\n+}\n+\n+\n+inflate_blocks_statef *inflate_blocks_new(z, c, w)\n+z_streamp z;\n+check_func c;\n+uInt w;\n+{\n+  inflate_blocks_statef *s;\n+\n+  if ((s = (inflate_blocks_statef *)ZALLOC\n+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)\n+    return s;\n+  if ((s->hufts =\n+       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)\n+  {\n+    ZFREE(z, s);\n+    return Z_NULL;\n+  }\n+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)\n+  {\n+    ZFREE(z, s->hufts);\n+    ZFREE(z, s);\n+    return Z_NULL;\n+  }\n+  s->end = s->window + w;\n+  s->checkfn = c;\n+  s->mode = TYPE;\n+  Tracev((stderr, \"inflate:   blocks allocated\\n\"));\n+  inflate_blocks_reset(s, z, Z_NULL);\n+  return s;\n+}\n+\n+\n+int inflate_blocks(s, z, r)\n+inflate_blocks_statef *s;\n+z_streamp z;\n+int r;\n+{\n+  uInt t;               /* temporary storage */\n+  uLong b;              /* bit buffer */\n+  uInt k;               /* bits in bit buffer */\n+  Bytef *p;             /* input data pointer */\n+  uInt n;               /* bytes available there */\n+  Bytef *q;             /* output window write pointer */\n+  uInt m;               /* bytes to end of window or read pointer */\n+\n+  /* copy input/output information to locals (UPDATE macro restores) */\n+  LOAD\n+\n+  /* process input based on current state */\n+  while (1) switch (s->mode)\n+  {\n+    case TYPE:\n+      NEEDBITS(3)\n+      t = (uInt)b & 7;\n+      s->last = t & 1;\n+      switch (t >> 1)\n+      {\n+        case 0:                         /* stored */\n+          Tracev((stderr, \"inflate:     stored block%s\\n\",\n+                 s->last ? \" (last)\" : \"\"));\n+          DUMPBITS(3)\n+          t = k & 7;                    /* go to byte boundary */\n+          DUMPBITS(t)\n+          s->mode = LENS;               /* get length of stored block */\n+          break;\n+        case 1:                         /* fixed */\n+          Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n+                 s->last ? \" (last)\" : \"\"));\n+          {\n+            uInt bl, bd;\n+            inflate_huft *tl, *td;\n+\n+            inflate_trees_fixed(&bl, &bd, &tl, &td, z);\n+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);\n+            if (s->sub.decode.codes == Z_NULL)\n+            {\n+              r = Z_MEM_ERROR;\n+              LEAVE\n+            }\n+          }\n+          DUMPBITS(3)\n+          s->mode = CODES;\n+          break;\n+        case 2:                         /* dynamic */\n+          Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n+                 s->last ? \" (last)\" : \"\"));\n+          DUMPBITS(3)\n+          s->mode = TABLE;\n+          break;\n+        case 3:                         /* illegal */\n+          DUMPBITS(3)\n+          s->mode = BAD;\n+          z->msg = (char*)\"invalid block type\";\n+          r = Z_DATA_ERROR;\n+          LEAVE\n+      }\n+      break;\n+    case LENS:\n+      NEEDBITS(32)\n+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))\n+      {\n+        s->mode = BAD;\n+        z->msg = (char*)\"invalid stored block lengths\";\n+        r = Z_DATA_ERROR;\n+        LEAVE\n+      }\n+      s->sub.left = (uInt)b & 0xffff;\n+      b = k = 0;                      /* dump bits */\n+      Tracev((stderr, \"inflate:       stored length %u\\n\", s->sub.left));\n+      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);\n+      break;\n+    case STORED:\n+      if (n == 0)\n+        LEAVE\n+      NEEDOUT\n+      t = s->sub.left;\n+      if (t > n) t = n;\n+      if (t > m) t = m;\n+      zmemcpy(q, p, t);\n+      p += t;  n -= t;\n+      q += t;  m -= t;\n+      if ((s->sub.left -= t) != 0)\n+        break;\n+      Tracev((stderr, \"inflate:       stored end, %lu total out\\n\",\n+              z->total_out + (q >= s->read ? q - s->read :\n+              (s->end - s->read) + (q - s->window))));\n+      s->mode = s->last ? DRY : TYPE;\n+      break;\n+    case TABLE:\n+      NEEDBITS(14)\n+      s->sub.trees.table = t = (uInt)b & 0x3fff;\n+#ifndef PKZIP_BUG_WORKAROUND\n+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n+      {\n+        s->mode = BAD;\n+        z->msg = (char*)\"too many length or distance symbols\";\n+        r = Z_DATA_ERROR;\n+        LEAVE\n+      }\n+#endif\n+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)\n+      {\n+        r = Z_MEM_ERROR;\n+        LEAVE\n+      }\n+      DUMPBITS(14)\n+      s->sub.trees.index = 0;\n+      Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n+      s->mode = BTREE;\n+    case BTREE:\n+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))\n+      {\n+        NEEDBITS(3)\n+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;\n+        DUMPBITS(3)\n+      }\n+      while (s->sub.trees.index < 19)\n+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;\n+      s->sub.trees.bb = 7;\n+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,\n+                             &s->sub.trees.tb, s->hufts, z);\n+      if (t != Z_OK)\n+      {\n+        ZFREE(z, s->sub.trees.blens);\n+        r = t;\n+        if (r == Z_DATA_ERROR)\n+          s->mode = BAD;\n+        LEAVE\n+      }\n+      s->sub.trees.index = 0;\n+      Tracev((stderr, \"inflate:       bits tree ok\\n\"));\n+      s->mode = DTREE;\n+    case DTREE:\n+      while (t = s->sub.trees.table,\n+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))\n+      {\n+        inflate_huft *h;\n+        uInt i, j, c;\n+\n+        t = s->sub.trees.bb;\n+        NEEDBITS(t)\n+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);\n+        t = h->bits;\n+        c = h->base;\n+        if (c < 16)\n+        {\n+          DUMPBITS(t)\n+          s->sub.trees.blens[s->sub.trees.index++] = c;\n+        }\n+        else /* c == 16..18 */\n+        {\n+          i = c == 18 ? 7 : c - 14;\n+          j = c == 18 ? 11 : 3;\n+          NEEDBITS(t + i)\n+          DUMPBITS(t)\n+          j += (uInt)b & inflate_mask[i];\n+          DUMPBITS(i)\n+          i = s->sub.trees.index;\n+          t = s->sub.trees.table;\n+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n+              (c == 16 && i < 1))\n+          {\n+            ZFREE(z, s->sub.trees.blens);\n+            s->mode = BAD;\n+            z->msg = (char*)\"invalid bit length repeat\";\n+            r = Z_DATA_ERROR;\n+            LEAVE\n+          }\n+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;\n+          do {\n+            s->sub.trees.blens[i++] = c;\n+          } while (--j);\n+          s->sub.trees.index = i;\n+        }\n+      }\n+      s->sub.trees.tb = Z_NULL;\n+      {\n+        uInt bl, bd;\n+        inflate_huft *tl, *td;\n+        inflate_codes_statef *c;\n+\n+        bl = 9;         /* must be <= 9 for lookahead assumptions */\n+        bd = 6;         /* must be <= 9 for lookahead assumptions */\n+        t = s->sub.trees.table;\n+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),\n+                                  s->sub.trees.blens, &bl, &bd, &tl, &td,\n+                                  s->hufts, z);\n+        ZFREE(z, s->sub.trees.blens);\n+        if (t != Z_OK)\n+        {\n+          if (t == (uInt)Z_DATA_ERROR)\n+            s->mode = BAD;\n+          r = t;\n+          LEAVE\n+        }\n+        Tracev((stderr, \"inflate:       trees ok\\n\"));\n+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)\n+        {\n+          r = Z_MEM_ERROR;\n+          LEAVE\n+        }\n+        s->sub.decode.codes = c;\n+      }\n+      s->mode = CODES;\n+    case CODES:\n+      UPDATE\n+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)\n+        return inflate_flush(s, z, r);\n+      r = Z_OK;\n+      inflate_codes_free(s->sub.decode.codes, z);\n+      LOAD\n+      Tracev((stderr, \"inflate:       codes end, %lu total out\\n\",\n+              z->total_out + (q >= s->read ? q - s->read :\n+              (s->end - s->read) + (q - s->window))));\n+      if (!s->last)\n+      {\n+        s->mode = TYPE;\n+        break;\n+      }\n+      s->mode = DRY;\n+    case DRY:\n+      FLUSH\n+      if (s->read != s->write)\n+        LEAVE\n+      s->mode = DONE;\n+    case DONE:\n+      r = Z_STREAM_END;\n+      LEAVE\n+    case BAD:\n+      r = Z_DATA_ERROR;\n+      LEAVE\n+    default:\n+      r = Z_STREAM_ERROR;\n+      LEAVE\n+  }\n+}\n+\n+\n+int inflate_blocks_free(s, z)\n+inflate_blocks_statef *s;\n+z_streamp z;\n+{\n+  inflate_blocks_reset(s, z, Z_NULL);\n+  ZFREE(z, s->window);\n+  ZFREE(z, s->hufts);\n+  ZFREE(z, s);\n+  Tracev((stderr, \"inflate:   blocks freed\\n\"));\n+  return Z_OK;\n+}\n+\n+\n+void inflate_set_dictionary(s, d, n)\n+inflate_blocks_statef *s;\n+const Bytef *d;\n+uInt  n;\n+{\n+  zmemcpy(s->window, d, n);\n+  s->read = s->write = s->window + n;\n+}\n+\n+\n+/* Returns true if inflate is currently at the end of a block generated\n+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. \n+ * IN assertion: s != Z_NULL\n+ */\n+int inflate_blocks_sync_point(s)\n+inflate_blocks_statef *s;\n+{\n+  return s->mode == LENS;\n+}"}, {"sha": "bd25c807536f574b01b802baf2bb139e0c58d925", "filename": "zlib/infblock.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfblock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfblock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfblock.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,39 @@\n+/* infblock.h -- header to use infblock.c\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+struct inflate_blocks_state;\n+typedef struct inflate_blocks_state FAR inflate_blocks_statef;\n+\n+extern inflate_blocks_statef * inflate_blocks_new OF((\n+    z_streamp z,\n+    check_func c,               /* check function */\n+    uInt w));                   /* window size */\n+\n+extern int inflate_blocks OF((\n+    inflate_blocks_statef *,\n+    z_streamp ,\n+    int));                      /* initial return code */\n+\n+extern void inflate_blocks_reset OF((\n+    inflate_blocks_statef *,\n+    z_streamp ,\n+    uLongf *));                  /* check value on output */\n+\n+extern int inflate_blocks_free OF((\n+    inflate_blocks_statef *,\n+    z_streamp));\n+\n+extern void inflate_set_dictionary OF((\n+    inflate_blocks_statef *s,\n+    const Bytef *d,  /* dictionary */\n+    uInt  n));       /* dictionary length */\n+\n+extern int inflate_blocks_sync_point OF((\n+    inflate_blocks_statef *s));"}, {"sha": "d4e5ee9a55439aa1c506572666ebbbbb07991d1c", "filename": "zlib/infcodes.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfcodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfcodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfcodes.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,257 @@\n+/* infcodes.c -- process literals and length/distance pairs\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+#include \"infblock.h\"\n+#include \"infcodes.h\"\n+#include \"infutil.h\"\n+#include \"inffast.h\"\n+\n+/* simplify the use of the inflate_huft type with some defines */\n+#define exop word.what.Exop\n+#define bits word.what.Bits\n+\n+typedef enum {        /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n+      START,    /* x: set up for LEN */\n+      LEN,      /* i: get length/literal/eob next */\n+      LENEXT,   /* i: getting length extra (have base) */\n+      DIST,     /* i: get distance next */\n+      DISTEXT,  /* i: getting distance extra */\n+      COPY,     /* o: copying bytes in window, waiting for space */\n+      LIT,      /* o: got literal, waiting for output space */\n+      WASH,     /* o: got eob, possibly still output waiting */\n+      END,      /* x: got eob and all data flushed */\n+      BADCODE}  /* x: got error */\n+inflate_codes_mode;\n+\n+/* inflate codes private state */\n+struct inflate_codes_state {\n+\n+  /* mode */\n+  inflate_codes_mode mode;      /* current inflate_codes mode */\n+\n+  /* mode dependent information */\n+  uInt len;\n+  union {\n+    struct {\n+      inflate_huft *tree;       /* pointer into tree */\n+      uInt need;                /* bits needed */\n+    } code;             /* if LEN or DIST, where in tree */\n+    uInt lit;           /* if LIT, literal */\n+    struct {\n+      uInt get;                 /* bits to get for extra */\n+      uInt dist;                /* distance back to copy from */\n+    } copy;             /* if EXT or COPY, where and how much */\n+  } sub;                /* submode */\n+\n+  /* mode independent information */\n+  Byte lbits;           /* ltree bits decoded per branch */\n+  Byte dbits;           /* dtree bits decoder per branch */\n+  inflate_huft *ltree;          /* literal/length/eob tree */\n+  inflate_huft *dtree;          /* distance tree */\n+\n+};\n+\n+\n+inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)\n+uInt bl, bd;\n+inflate_huft *tl;\n+inflate_huft *td; /* need separate declaration for Borland C++ */\n+z_streamp z;\n+{\n+  inflate_codes_statef *c;\n+\n+  if ((c = (inflate_codes_statef *)\n+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)\n+  {\n+    c->mode = START;\n+    c->lbits = (Byte)bl;\n+    c->dbits = (Byte)bd;\n+    c->ltree = tl;\n+    c->dtree = td;\n+    Tracev((stderr, \"inflate:       codes new\\n\"));\n+  }\n+  return c;\n+}\n+\n+\n+int inflate_codes(s, z, r)\n+inflate_blocks_statef *s;\n+z_streamp z;\n+int r;\n+{\n+  uInt j;               /* temporary storage */\n+  inflate_huft *t;      /* temporary pointer */\n+  uInt e;               /* extra bits or operation */\n+  uLong b;              /* bit buffer */\n+  uInt k;               /* bits in bit buffer */\n+  Bytef *p;             /* input data pointer */\n+  uInt n;               /* bytes available there */\n+  Bytef *q;             /* output window write pointer */\n+  uInt m;               /* bytes to end of window or read pointer */\n+  Bytef *f;             /* pointer to copy strings from */\n+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */\n+\n+  /* copy input/output information to locals (UPDATE macro restores) */\n+  LOAD\n+\n+  /* process input and output based on current state */\n+  while (1) switch (c->mode)\n+  {             /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n+    case START:         /* x: set up for LEN */\n+#ifndef SLOW\n+      if (m >= 258 && n >= 10)\n+      {\n+        UPDATE\n+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);\n+        LOAD\n+        if (r != Z_OK)\n+        {\n+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;\n+          break;\n+        }\n+      }\n+#endif /* !SLOW */\n+      c->sub.code.need = c->lbits;\n+      c->sub.code.tree = c->ltree;\n+      c->mode = LEN;\n+    case LEN:           /* i: get length/literal/eob next */\n+      j = c->sub.code.need;\n+      NEEDBITS(j)\n+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n+      DUMPBITS(t->bits)\n+      e = (uInt)(t->exop);\n+      if (e == 0)               /* literal */\n+      {\n+        c->sub.lit = t->base;\n+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n+                 \"inflate:         literal '%c'\\n\" :\n+                 \"inflate:         literal 0x%02x\\n\", t->base));\n+        c->mode = LIT;\n+        break;\n+      }\n+      if (e & 16)               /* length */\n+      {\n+        c->sub.copy.get = e & 15;\n+        c->len = t->base;\n+        c->mode = LENEXT;\n+        break;\n+      }\n+      if ((e & 64) == 0)        /* next table */\n+      {\n+        c->sub.code.need = e;\n+        c->sub.code.tree = t + t->base;\n+        break;\n+      }\n+      if (e & 32)               /* end of block */\n+      {\n+        Tracevv((stderr, \"inflate:         end of block\\n\"));\n+        c->mode = WASH;\n+        break;\n+      }\n+      c->mode = BADCODE;        /* invalid code */\n+      z->msg = (char*)\"invalid literal/length code\";\n+      r = Z_DATA_ERROR;\n+      LEAVE\n+    case LENEXT:        /* i: getting length extra (have base) */\n+      j = c->sub.copy.get;\n+      NEEDBITS(j)\n+      c->len += (uInt)b & inflate_mask[j];\n+      DUMPBITS(j)\n+      c->sub.code.need = c->dbits;\n+      c->sub.code.tree = c->dtree;\n+      Tracevv((stderr, \"inflate:         length %u\\n\", c->len));\n+      c->mode = DIST;\n+    case DIST:          /* i: get distance next */\n+      j = c->sub.code.need;\n+      NEEDBITS(j)\n+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n+      DUMPBITS(t->bits)\n+      e = (uInt)(t->exop);\n+      if (e & 16)               /* distance */\n+      {\n+        c->sub.copy.get = e & 15;\n+        c->sub.copy.dist = t->base;\n+        c->mode = DISTEXT;\n+        break;\n+      }\n+      if ((e & 64) == 0)        /* next table */\n+      {\n+        c->sub.code.need = e;\n+        c->sub.code.tree = t + t->base;\n+        break;\n+      }\n+      c->mode = BADCODE;        /* invalid code */\n+      z->msg = (char*)\"invalid distance code\";\n+      r = Z_DATA_ERROR;\n+      LEAVE\n+    case DISTEXT:       /* i: getting distance extra */\n+      j = c->sub.copy.get;\n+      NEEDBITS(j)\n+      c->sub.copy.dist += (uInt)b & inflate_mask[j];\n+      DUMPBITS(j)\n+      Tracevv((stderr, \"inflate:         distance %u\\n\", c->sub.copy.dist));\n+      c->mode = COPY;\n+    case COPY:          /* o: copying bytes in window, waiting for space */\n+#ifndef __TURBOC__ /* Turbo C bug for following expression */\n+      f = (uInt)(q - s->window) < c->sub.copy.dist ?\n+          s->end - (c->sub.copy.dist - (q - s->window)) :\n+          q - c->sub.copy.dist;\n+#else\n+      f = q - c->sub.copy.dist;\n+      if ((uInt)(q - s->window) < c->sub.copy.dist)\n+        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));\n+#endif\n+      while (c->len)\n+      {\n+        NEEDOUT\n+        OUTBYTE(*f++)\n+        if (f == s->end)\n+          f = s->window;\n+        c->len--;\n+      }\n+      c->mode = START;\n+      break;\n+    case LIT:           /* o: got literal, waiting for output space */\n+      NEEDOUT\n+      OUTBYTE(c->sub.lit)\n+      c->mode = START;\n+      break;\n+    case WASH:          /* o: got eob, possibly more output */\n+      if (k > 7)        /* return unused byte, if any */\n+      {\n+        Assert(k < 16, \"inflate_codes grabbed too many bytes\")\n+        k -= 8;\n+        n++;\n+        p--;            /* can always return one */\n+      }\n+      FLUSH\n+      if (s->read != s->write)\n+        LEAVE\n+      c->mode = END;\n+    case END:\n+      r = Z_STREAM_END;\n+      LEAVE\n+    case BADCODE:       /* x: got error */\n+      r = Z_DATA_ERROR;\n+      LEAVE\n+    default:\n+      r = Z_STREAM_ERROR;\n+      LEAVE\n+  }\n+#ifdef NEED_DUMMY_RETURN\n+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n+#endif\n+}\n+\n+\n+void inflate_codes_free(c, z)\n+inflate_codes_statef *c;\n+z_streamp z;\n+{\n+  ZFREE(z, c);\n+  Tracev((stderr, \"inflate:       codes free\\n\"));\n+}"}, {"sha": "6c750d896f92fbb783587c8987195fb9685c01f9", "filename": "zlib/infcodes.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfcodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfcodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfcodes.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,27 @@\n+/* infcodes.h -- header to use infcodes.c\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+struct inflate_codes_state;\n+typedef struct inflate_codes_state FAR inflate_codes_statef;\n+\n+extern inflate_codes_statef *inflate_codes_new OF((\n+    uInt, uInt,\n+    inflate_huft *, inflate_huft *,\n+    z_streamp ));\n+\n+extern int inflate_codes OF((\n+    inflate_blocks_statef *,\n+    z_streamp ,\n+    int));\n+\n+extern void inflate_codes_free OF((\n+    inflate_codes_statef *,\n+    z_streamp ));\n+"}, {"sha": "61a78ee933fcd7963fdb2c60638de2a4bda1947a", "filename": "zlib/inffast.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffast.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,170 @@\n+/* inffast.c -- process literals and length/distance pairs fast\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+#include \"infblock.h\"\n+#include \"infcodes.h\"\n+#include \"infutil.h\"\n+#include \"inffast.h\"\n+\n+struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n+\n+/* simplify the use of the inflate_huft type with some defines */\n+#define exop word.what.Exop\n+#define bits word.what.Bits\n+\n+/* macros for bit input with no checking and for returning unused bytes */\n+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n+#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}\n+\n+/* Called with number of bytes left to write in window at least 258\n+   (the maximum string length) and number of input bytes available\n+   at least ten.  The ten bytes are six bytes for the longest length/\n+   distance pair plus four bytes for overloading the bit buffer. */\n+\n+int inflate_fast(bl, bd, tl, td, s, z)\n+uInt bl, bd;\n+inflate_huft *tl;\n+inflate_huft *td; /* need separate declaration for Borland C++ */\n+inflate_blocks_statef *s;\n+z_streamp z;\n+{\n+  inflate_huft *t;      /* temporary pointer */\n+  uInt e;               /* extra bits or operation */\n+  uLong b;              /* bit buffer */\n+  uInt k;               /* bits in bit buffer */\n+  Bytef *p;             /* input data pointer */\n+  uInt n;               /* bytes available there */\n+  Bytef *q;             /* output window write pointer */\n+  uInt m;               /* bytes to end of window or read pointer */\n+  uInt ml;              /* mask for literal/length tree */\n+  uInt md;              /* mask for distance tree */\n+  uInt c;               /* bytes to copy */\n+  uInt d;               /* distance back to copy from */\n+  Bytef *r;             /* copy source pointer */\n+\n+  /* load input, output, bit values */\n+  LOAD\n+\n+  /* initialize masks */\n+  ml = inflate_mask[bl];\n+  md = inflate_mask[bd];\n+\n+  /* do until not enough input or output space for fast loop */\n+  do {                          /* assume called with m >= 258 && n >= 10 */\n+    /* get literal/length code */\n+    GRABBITS(20)                /* max bits for literal/length code */\n+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)\n+    {\n+      DUMPBITS(t->bits)\n+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n+                \"inflate:         * literal '%c'\\n\" :\n+                \"inflate:         * literal 0x%02x\\n\", t->base));\n+      *q++ = (Byte)t->base;\n+      m--;\n+      continue;\n+    }\n+    do {\n+      DUMPBITS(t->bits)\n+      if (e & 16)\n+      {\n+        /* get extra bits for length */\n+        e &= 15;\n+        c = t->base + ((uInt)b & inflate_mask[e]);\n+        DUMPBITS(e)\n+        Tracevv((stderr, \"inflate:         * length %u\\n\", c));\n+\n+        /* decode distance base of block to copy */\n+        GRABBITS(15);           /* max bits for distance code */\n+        e = (t = td + ((uInt)b & md))->exop;\n+        do {\n+          DUMPBITS(t->bits)\n+          if (e & 16)\n+          {\n+            /* get extra bits to add to distance base */\n+            e &= 15;\n+            GRABBITS(e)         /* get extra bits (up to 13) */\n+            d = t->base + ((uInt)b & inflate_mask[e]);\n+            DUMPBITS(e)\n+            Tracevv((stderr, \"inflate:         * distance %u\\n\", d));\n+\n+            /* do the copy */\n+            m -= c;\n+            if ((uInt)(q - s->window) >= d)     /* offset before dest */\n+            {                                   /*  just copy */\n+              r = q - d;\n+              *q++ = *r++;  c--;        /* minimum count is three, */\n+              *q++ = *r++;  c--;        /*  so unroll loop a little */\n+            }\n+            else                        /* else offset after destination */\n+            {\n+              e = d - (uInt)(q - s->window); /* bytes from offset to end */\n+              r = s->end - e;           /* pointer to offset */\n+              if (c > e)                /* if source crosses, */\n+              {\n+                c -= e;                 /* copy to end of window */\n+                do {\n+                  *q++ = *r++;\n+                } while (--e);\n+                r = s->window;          /* copy rest from start of window */\n+              }\n+            }\n+            do {                        /* copy all or what's left */\n+              *q++ = *r++;\n+            } while (--c);\n+            break;\n+          }\n+          else if ((e & 64) == 0)\n+          {\n+            t += t->base;\n+            e = (t += ((uInt)b & inflate_mask[e]))->exop;\n+          }\n+          else\n+          {\n+            z->msg = (char*)\"invalid distance code\";\n+            UNGRAB\n+            UPDATE\n+            return Z_DATA_ERROR;\n+          }\n+        } while (1);\n+        break;\n+      }\n+      if ((e & 64) == 0)\n+      {\n+        t += t->base;\n+        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)\n+        {\n+          DUMPBITS(t->bits)\n+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n+                    \"inflate:         * literal '%c'\\n\" :\n+                    \"inflate:         * literal 0x%02x\\n\", t->base));\n+          *q++ = (Byte)t->base;\n+          m--;\n+          break;\n+        }\n+      }\n+      else if (e & 32)\n+      {\n+        Tracevv((stderr, \"inflate:         * end of block\\n\"));\n+        UNGRAB\n+        UPDATE\n+        return Z_STREAM_END;\n+      }\n+      else\n+      {\n+        z->msg = (char*)\"invalid literal/length code\";\n+        UNGRAB\n+        UPDATE\n+        return Z_DATA_ERROR;\n+      }\n+    } while (1);\n+  } while (m >= 258 && n >= 10);\n+\n+  /* not enough input or output--restore pointers and return */\n+  UNGRAB\n+  UPDATE\n+  return Z_OK;\n+}"}, {"sha": "8facec553147642d165d2ba011ea5d13760b3aee", "filename": "zlib/inffast.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffast.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,17 @@\n+/* inffast.h -- header to use inffast.c\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+extern int inflate_fast OF((\n+    uInt,\n+    uInt,\n+    inflate_huft *,\n+    inflate_huft *,\n+    inflate_blocks_statef *,\n+    z_streamp ));"}, {"sha": "77f7e76314521eefb9f74d40ced4e2c5b21e6992", "filename": "zlib/inffixed.h", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffixed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finffixed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffixed.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,151 @@\n+/* inffixed.h -- table for decoding fixed codes\n+ * Generated automatically by the maketree.c program\n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+local uInt fixed_bl = 9;\n+local uInt fixed_bd = 5;\n+local inflate_huft fixed_tl[] = {\n+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},\n+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},\n+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},\n+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},\n+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},\n+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},\n+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},\n+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},\n+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},\n+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},\n+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},\n+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},\n+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},\n+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},\n+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},\n+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},\n+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},\n+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},\n+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},\n+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},\n+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},\n+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},\n+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},\n+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},\n+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},\n+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},\n+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},\n+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},\n+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},\n+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},\n+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},\n+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},\n+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},\n+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},\n+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},\n+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},\n+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},\n+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},\n+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},\n+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},\n+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},\n+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},\n+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},\n+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},\n+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},\n+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},\n+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},\n+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},\n+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},\n+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},\n+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},\n+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},\n+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},\n+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},\n+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},\n+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},\n+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},\n+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},\n+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},\n+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},\n+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},\n+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},\n+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},\n+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},\n+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},\n+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},\n+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},\n+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},\n+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},\n+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},\n+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},\n+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},\n+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},\n+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},\n+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},\n+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},\n+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},\n+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},\n+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},\n+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},\n+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},\n+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},\n+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},\n+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},\n+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},\n+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},\n+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},\n+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},\n+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},\n+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},\n+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},\n+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},\n+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},\n+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},\n+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},\n+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},\n+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},\n+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},\n+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},\n+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},\n+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},\n+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},\n+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},\n+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},\n+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},\n+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},\n+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},\n+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},\n+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},\n+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},\n+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},\n+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}\n+  };\n+local inflate_huft fixed_td[] = {\n+    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},\n+    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},\n+    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},\n+    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},\n+    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},\n+    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},\n+    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},\n+    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}\n+  };"}, {"sha": "32e9b8de6797af89beaec309143ee059cbdf9abf", "filename": "zlib/inflate.c", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,366 @@\n+/* inflate.c -- zlib interface to inflate modules\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"infblock.h\"\n+\n+struct inflate_blocks_state {int dummy;}; /* for buggy compilers */\n+\n+typedef enum {\n+      METHOD,   /* waiting for method byte */\n+      FLAG,     /* waiting for flag byte */\n+      DICT4,    /* four dictionary check bytes to go */\n+      DICT3,    /* three dictionary check bytes to go */\n+      DICT2,    /* two dictionary check bytes to go */\n+      DICT1,    /* one dictionary check byte to go */\n+      DICT0,    /* waiting for inflateSetDictionary */\n+      BLOCKS,   /* decompressing blocks */\n+      CHECK4,   /* four check bytes to go */\n+      CHECK3,   /* three check bytes to go */\n+      CHECK2,   /* two check bytes to go */\n+      CHECK1,   /* one check byte to go */\n+      DONE,     /* finished check, done */\n+      BAD}      /* got an error--stay here */\n+inflate_mode;\n+\n+/* inflate private state */\n+struct internal_state {\n+\n+  /* mode */\n+  inflate_mode  mode;   /* current inflate mode */\n+\n+  /* mode dependent information */\n+  union {\n+    uInt method;        /* if FLAGS, method byte */\n+    struct {\n+      uLong was;                /* computed check value */\n+      uLong need;               /* stream check value */\n+    } check;            /* if CHECK, check values to compare */\n+    uInt marker;        /* if BAD, inflateSync's marker bytes count */\n+  } sub;        /* submode */\n+\n+  /* mode independent information */\n+  int  nowrap;          /* flag for no wrapper */\n+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */\n+  inflate_blocks_statef \n+    *blocks;            /* current inflate_blocks state */\n+\n+};\n+\n+\n+int ZEXPORT inflateReset(z)\n+z_streamp z;\n+{\n+  if (z == Z_NULL || z->state == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  z->total_in = z->total_out = 0;\n+  z->msg = Z_NULL;\n+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;\n+  inflate_blocks_reset(z->state->blocks, z, Z_NULL);\n+  Tracev((stderr, \"inflate: reset\\n\"));\n+  return Z_OK;\n+}\n+\n+\n+int ZEXPORT inflateEnd(z)\n+z_streamp z;\n+{\n+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  if (z->state->blocks != Z_NULL)\n+    inflate_blocks_free(z->state->blocks, z);\n+  ZFREE(z, z->state);\n+  z->state = Z_NULL;\n+  Tracev((stderr, \"inflate: end\\n\"));\n+  return Z_OK;\n+}\n+\n+\n+int ZEXPORT inflateInit2_(z, w, version, stream_size)\n+z_streamp z;\n+int w;\n+const char *version;\n+int stream_size;\n+{\n+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n+      stream_size != sizeof(z_stream))\n+      return Z_VERSION_ERROR;\n+\n+  /* initialize state */\n+  if (z == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  z->msg = Z_NULL;\n+  if (z->zalloc == Z_NULL)\n+  {\n+    z->zalloc = zcalloc;\n+    z->opaque = (voidpf)0;\n+  }\n+  if (z->zfree == Z_NULL) z->zfree = zcfree;\n+  if ((z->state = (struct internal_state FAR *)\n+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)\n+    return Z_MEM_ERROR;\n+  z->state->blocks = Z_NULL;\n+\n+  /* handle undocumented nowrap option (no zlib header or check) */\n+  z->state->nowrap = 0;\n+  if (w < 0)\n+  {\n+    w = - w;\n+    z->state->nowrap = 1;\n+  }\n+\n+  /* set window size */\n+  if (w < 8 || w > 15)\n+  {\n+    inflateEnd(z);\n+    return Z_STREAM_ERROR;\n+  }\n+  z->state->wbits = (uInt)w;\n+\n+  /* create inflate_blocks state */\n+  if ((z->state->blocks =\n+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))\n+      == Z_NULL)\n+  {\n+    inflateEnd(z);\n+    return Z_MEM_ERROR;\n+  }\n+  Tracev((stderr, \"inflate: allocated\\n\"));\n+\n+  /* reset state */\n+  inflateReset(z);\n+  return Z_OK;\n+}\n+\n+\n+int ZEXPORT inflateInit_(z, version, stream_size)\n+z_streamp z;\n+const char *version;\n+int stream_size;\n+{\n+  return inflateInit2_(z, DEF_WBITS, version, stream_size);\n+}\n+\n+\n+#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}\n+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)\n+\n+int ZEXPORT inflate(z, f)\n+z_streamp z;\n+int f;\n+{\n+  int r;\n+  uInt b;\n+\n+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n+  r = Z_BUF_ERROR;\n+  while (1) switch (z->state->mode)\n+  {\n+    case METHOD:\n+      NEEDBYTE\n+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)\n+      {\n+        z->state->mode = BAD;\n+        z->msg = (char*)\"unknown compression method\";\n+        z->state->sub.marker = 5;       /* can't try inflateSync */\n+        break;\n+      }\n+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)\n+      {\n+        z->state->mode = BAD;\n+        z->msg = (char*)\"invalid window size\";\n+        z->state->sub.marker = 5;       /* can't try inflateSync */\n+        break;\n+      }\n+      z->state->mode = FLAG;\n+    case FLAG:\n+      NEEDBYTE\n+      b = NEXTBYTE;\n+      if (((z->state->sub.method << 8) + b) % 31)\n+      {\n+        z->state->mode = BAD;\n+        z->msg = (char*)\"incorrect header check\";\n+        z->state->sub.marker = 5;       /* can't try inflateSync */\n+        break;\n+      }\n+      Tracev((stderr, \"inflate: zlib header ok\\n\"));\n+      if (!(b & PRESET_DICT))\n+      {\n+        z->state->mode = BLOCKS;\n+        break;\n+      }\n+      z->state->mode = DICT4;\n+    case DICT4:\n+      NEEDBYTE\n+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n+      z->state->mode = DICT3;\n+    case DICT3:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n+      z->state->mode = DICT2;\n+    case DICT2:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n+      z->state->mode = DICT1;\n+    case DICT1:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE;\n+      z->adler = z->state->sub.check.need;\n+      z->state->mode = DICT0;\n+      return Z_NEED_DICT;\n+    case DICT0:\n+      z->state->mode = BAD;\n+      z->msg = (char*)\"need dictionary\";\n+      z->state->sub.marker = 0;       /* can try inflateSync */\n+      return Z_STREAM_ERROR;\n+    case BLOCKS:\n+      r = inflate_blocks(z->state->blocks, z, r);\n+      if (r == Z_DATA_ERROR)\n+      {\n+        z->state->mode = BAD;\n+        z->state->sub.marker = 0;       /* can try inflateSync */\n+        break;\n+      }\n+      if (r == Z_OK)\n+        r = f;\n+      if (r != Z_STREAM_END)\n+        return r;\n+      r = f;\n+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);\n+      if (z->state->nowrap)\n+      {\n+        z->state->mode = DONE;\n+        break;\n+      }\n+      z->state->mode = CHECK4;\n+    case CHECK4:\n+      NEEDBYTE\n+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n+      z->state->mode = CHECK3;\n+    case CHECK3:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n+      z->state->mode = CHECK2;\n+    case CHECK2:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n+      z->state->mode = CHECK1;\n+    case CHECK1:\n+      NEEDBYTE\n+      z->state->sub.check.need += (uLong)NEXTBYTE;\n+\n+      if (z->state->sub.check.was != z->state->sub.check.need)\n+      {\n+        z->state->mode = BAD;\n+        z->msg = (char*)\"incorrect data check\";\n+        z->state->sub.marker = 5;       /* can't try inflateSync */\n+        break;\n+      }\n+      Tracev((stderr, \"inflate: zlib check ok\\n\"));\n+      z->state->mode = DONE;\n+    case DONE:\n+      return Z_STREAM_END;\n+    case BAD:\n+      return Z_DATA_ERROR;\n+    default:\n+      return Z_STREAM_ERROR;\n+  }\n+#ifdef NEED_DUMMY_RETURN\n+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n+#endif\n+}\n+\n+\n+int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)\n+z_streamp z;\n+const Bytef *dictionary;\n+uInt  dictLength;\n+{\n+  uInt length = dictLength;\n+\n+  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)\n+    return Z_STREAM_ERROR;\n+\n+  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;\n+  z->adler = 1L;\n+\n+  if (length >= ((uInt)1<<z->state->wbits))\n+  {\n+    length = (1<<z->state->wbits)-1;\n+    dictionary += dictLength - length;\n+  }\n+  inflate_set_dictionary(z->state->blocks, dictionary, length);\n+  z->state->mode = BLOCKS;\n+  return Z_OK;\n+}\n+\n+\n+int ZEXPORT inflateSync(z)\n+z_streamp z;\n+{\n+  uInt n;       /* number of bytes to look at */\n+  Bytef *p;     /* pointer to bytes */\n+  uInt m;       /* number of marker bytes found in a row */\n+  uLong r, w;   /* temporaries to save total_in and total_out */\n+\n+  /* set up */\n+  if (z == Z_NULL || z->state == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  if (z->state->mode != BAD)\n+  {\n+    z->state->mode = BAD;\n+    z->state->sub.marker = 0;\n+  }\n+  if ((n = z->avail_in) == 0)\n+    return Z_BUF_ERROR;\n+  p = z->next_in;\n+  m = z->state->sub.marker;\n+\n+  /* search */\n+  while (n && m < 4)\n+  {\n+    static const Byte mark[4] = {0, 0, 0xff, 0xff};\n+    if (*p == mark[m])\n+      m++;\n+    else if (*p)\n+      m = 0;\n+    else\n+      m = 4 - m;\n+    p++, n--;\n+  }\n+\n+  /* restore */\n+  z->total_in += p - z->next_in;\n+  z->next_in = p;\n+  z->avail_in = n;\n+  z->state->sub.marker = m;\n+\n+  /* return no joy or set up to restart on a new block */\n+  if (m != 4)\n+    return Z_DATA_ERROR;\n+  r = z->total_in;  w = z->total_out;\n+  inflateReset(z);\n+  z->total_in = r;  z->total_out = w;\n+  z->state->mode = BLOCKS;\n+  return Z_OK;\n+}\n+\n+\n+/* Returns true if inflate is currently at the end of a block generated\n+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n+ * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n+ * but removes the length bytes of the resulting empty stored block. When\n+ * decompressing, PPP checks that at the end of input packet, inflate is\n+ * waiting for these length bytes.\n+ */\n+int ZEXPORT inflateSyncPoint(z)\n+z_streamp z;\n+{\n+  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)\n+    return Z_STREAM_ERROR;\n+  return inflate_blocks_sync_point(z->state->blocks);\n+}"}, {"sha": "ef1e0b6b873291725fd657ecb0cb65e9abaa1591", "filename": "zlib/inftrees.c", "status": "added", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,455 @@\n+/* inftrees.c -- generate Huffman trees for efficient decoding\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+\n+#if !defined(BUILDFIXED) && !defined(STDC)\n+#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */\n+#endif\n+\n+const char inflate_copyright[] =\n+   \" inflate 1.1.3 Copyright 1995-1998 Mark Adler \";\n+/*\n+  If you use the zlib library in a product, an acknowledgment is welcome\n+  in the documentation of your product. If for some reason you cannot\n+  include such an acknowledgment, I would appreciate that you keep this\n+  copyright string in the executable of your product.\n+ */\n+struct internal_state  {int dummy;}; /* for buggy compilers */\n+\n+/* simplify the use of the inflate_huft type with some defines */\n+#define exop word.what.Exop\n+#define bits word.what.Bits\n+\n+\n+local int huft_build OF((\n+    uIntf *,            /* code lengths in bits */\n+    uInt,               /* number of codes */\n+    uInt,               /* number of \"simple\" codes */\n+    const uIntf *,      /* list of base values for non-simple codes */\n+    const uIntf *,      /* list of extra bits for non-simple codes */\n+    inflate_huft * FAR*,/* result: starting table */\n+    uIntf *,            /* maximum lookup bits (returns actual) */\n+    inflate_huft *,     /* space for trees */\n+    uInt *,             /* hufts used in space */\n+    uIntf * ));         /* space for values */\n+\n+/* Tables for deflate from PKZIP's appnote.txt. */\n+local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */\n+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n+        /* see note #13 above about 258 */\n+local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */\n+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */\n+local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */\n+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n+        8193, 12289, 16385, 24577};\n+local const uInt cpdext[30] = { /* Extra bits for distance codes */\n+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n+        12, 12, 13, 13};\n+\n+/*\n+   Huffman code decoding is performed using a multi-level table lookup.\n+   The fastest way to decode is to simply build a lookup table whose\n+   size is determined by the longest code.  However, the time it takes\n+   to build this table can also be a factor if the data being decoded\n+   is not very long.  The most common codes are necessarily the\n+   shortest codes, so those codes dominate the decoding time, and hence\n+   the speed.  The idea is you can have a shorter table that decodes the\n+   shorter, more probable codes, and then point to subsidiary tables for\n+   the longer codes.  The time it costs to decode the longer codes is\n+   then traded against the time it takes to make longer tables.\n+\n+   This results of this trade are in the variables lbits and dbits\n+   below.  lbits is the number of bits the first level table for literal/\n+   length codes can decode in one step, and dbits is the same thing for\n+   the distance codes.  Subsequent tables are also less than or equal to\n+   those sizes.  These values may be adjusted either when all of the\n+   codes are shorter than that, in which case the longest code length in\n+   bits is used, or when the shortest code is *longer* than the requested\n+   table size, in which case the length of the shortest code in bits is\n+   used.\n+\n+   There are two different values for the two tables, since they code a\n+   different number of possibilities each.  The literal/length table\n+   codes 286 possible values, or in a flat code, a little over eight\n+   bits.  The distance table codes 30 possible values, or a little less\n+   than five bits, flat.  The optimum values for speed end up being\n+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n+   The optimum values may differ though from machine to machine, and\n+   possibly even between compilers.  Your mileage may vary.\n+ */\n+\n+\n+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */\n+#define BMAX 15         /* maximum bit length of any code */\n+\n+local int huft_build(b, n, s, d, e, t, m, hp, hn, v)\n+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */\n+uInt n;                 /* number of codes (assumed <= 288) */\n+uInt s;                 /* number of simple-valued codes (0..s-1) */\n+const uIntf *d;         /* list of base values for non-simple codes */\n+const uIntf *e;         /* list of extra bits for non-simple codes */\n+inflate_huft * FAR *t;  /* result: starting table */\n+uIntf *m;               /* maximum lookup bits, returns actual */\n+inflate_huft *hp;       /* space for trees */\n+uInt *hn;               /* hufts used in space */\n+uIntf *v;               /* working area: values in order of bit length */\n+/* Given a list of code lengths and a maximum table size, make a set of\n+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n+   if the given code set is incomplete (the tables are still built in this\n+   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n+   lengths), or Z_MEM_ERROR if not enough memory. */\n+{\n+\n+  uInt a;                       /* counter for codes of length k */\n+  uInt c[BMAX+1];               /* bit length count table */\n+  uInt f;                       /* i repeats in table every f entries */\n+  int g;                        /* maximum code length */\n+  int h;                        /* table level */\n+  register uInt i;              /* counter, current code */\n+  register uInt j;              /* counter */\n+  register int k;               /* number of bits in current code */\n+  int l;                        /* bits per table (returned in m) */\n+  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */\n+  register uIntf *p;            /* pointer into c[], b[], or v[] */\n+  inflate_huft *q;              /* points to current table */\n+  struct inflate_huft_s r;      /* table entry for structure assignment */\n+  inflate_huft *u[BMAX];        /* table stack */\n+  register int w;               /* bits before this table == (l * h) */\n+  uInt x[BMAX+1];               /* bit offsets, then code stack */\n+  uIntf *xp;                    /* pointer into x */\n+  int y;                        /* number of dummy codes added */\n+  uInt z;                       /* number of entries in current table */\n+\n+\n+  /* Generate counts for each bit length */\n+  p = c;\n+#define C0 *p++ = 0;\n+#define C2 C0 C0 C0 C0\n+#define C4 C2 C2 C2 C2\n+  C4                            /* clear c[]--assume BMAX+1 is 16 */\n+  p = b;  i = n;\n+  do {\n+    c[*p++]++;                  /* assume all entries <= BMAX */\n+  } while (--i);\n+  if (c[0] == n)                /* null input--all zero length codes */\n+  {\n+    *t = (inflate_huft *)Z_NULL;\n+    *m = 0;\n+    return Z_OK;\n+  }\n+\n+\n+  /* Find minimum and maximum length, bound *m by those */\n+  l = *m;\n+  for (j = 1; j <= BMAX; j++)\n+    if (c[j])\n+      break;\n+  k = j;                        /* minimum code length */\n+  if ((uInt)l < j)\n+    l = j;\n+  for (i = BMAX; i; i--)\n+    if (c[i])\n+      break;\n+  g = i;                        /* maximum code length */\n+  if ((uInt)l > i)\n+    l = i;\n+  *m = l;\n+\n+\n+  /* Adjust last length count to fill out codes, if needed */\n+  for (y = 1 << j; j < i; j++, y <<= 1)\n+    if ((y -= c[j]) < 0)\n+      return Z_DATA_ERROR;\n+  if ((y -= c[i]) < 0)\n+    return Z_DATA_ERROR;\n+  c[i] += y;\n+\n+\n+  /* Generate starting offsets into the value table for each length */\n+  x[1] = j = 0;\n+  p = c + 1;  xp = x + 2;\n+  while (--i) {                 /* note that i == g from above */\n+    *xp++ = (j += *p++);\n+  }\n+\n+\n+  /* Make a table of values in order of bit lengths */\n+  p = b;  i = 0;\n+  do {\n+    if ((j = *p++) != 0)\n+      v[x[j]++] = i;\n+  } while (++i < n);\n+  n = x[g];                     /* set n to length of v */\n+\n+\n+  /* Generate the Huffman codes and for each, make the table entries */\n+  x[0] = i = 0;                 /* first Huffman code is zero */\n+  p = v;                        /* grab values in bit order */\n+  h = -1;                       /* no tables yet--level -1 */\n+  w = -l;                       /* bits decoded == (l * h) */\n+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */\n+  q = (inflate_huft *)Z_NULL;   /* ditto */\n+  z = 0;                        /* ditto */\n+\n+  /* go through the bit lengths (k already is bits in shortest code) */\n+  for (; k <= g; k++)\n+  {\n+    a = c[k];\n+    while (a--)\n+    {\n+      /* here i is the Huffman code of length k bits for value *p */\n+      /* make tables up to required level */\n+      while (k > w + l)\n+      {\n+        h++;\n+        w += l;                 /* previous table always l bits */\n+\n+        /* compute minimum size table less than or equal to l bits */\n+        z = g - w;\n+        z = z > (uInt)l ? l : z;        /* table size upper limit */\n+        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n+        {                       /* too few codes for k-w bit table */\n+          f -= a + 1;           /* deduct codes from patterns left */\n+          xp = c + k;\n+          if (j < z)\n+            while (++j < z)     /* try smaller tables up to z bits */\n+            {\n+              if ((f <<= 1) <= *++xp)\n+                break;          /* enough codes to use up j bits */\n+              f -= *xp;         /* else deduct codes from patterns */\n+            }\n+        }\n+        z = 1 << j;             /* table entries for j-bit table */\n+\n+        /* allocate new table */\n+        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */\n+          return Z_MEM_ERROR;   /* not enough memory */\n+        u[h] = q = hp + *hn;\n+        *hn += z;\n+\n+        /* connect to last table, if there is one */\n+        if (h)\n+        {\n+          x[h] = i;             /* save pattern for backing up */\n+          r.bits = (Byte)l;     /* bits to dump before this table */\n+          r.exop = (Byte)j;     /* bits in this table */\n+          j = i >> (w - l);\n+          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */\n+          u[h-1][j] = r;        /* connect to last table */\n+        }\n+        else\n+          *t = q;               /* first table is returned result */\n+      }\n+\n+      /* set up table entry in r */\n+      r.bits = (Byte)(k - w);\n+      if (p >= v + n)\n+        r.exop = 128 + 64;      /* out of values--invalid code */\n+      else if (*p < s)\n+      {\n+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */\n+        r.base = *p++;          /* simple code is just the value */\n+      }\n+      else\n+      {\n+        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */\n+        r.base = d[*p++ - s];\n+      }\n+\n+      /* fill code-like entries with r */\n+      f = 1 << (k - w);\n+      for (j = i >> w; j < z; j += f)\n+        q[j] = r;\n+\n+      /* backwards increment the k-bit code i */\n+      for (j = 1 << (k - 1); i & j; j >>= 1)\n+        i ^= j;\n+      i ^= j;\n+\n+      /* backup over finished tables */\n+      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */\n+      while ((i & mask) != x[h])\n+      {\n+        h--;                    /* don't need to update q */\n+        w -= l;\n+        mask = (1 << w) - 1;\n+      }\n+    }\n+  }\n+\n+\n+  /* Return Z_BUF_ERROR if we were given an incomplete table */\n+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n+}\n+\n+\n+int inflate_trees_bits(c, bb, tb, hp, z)\n+uIntf *c;               /* 19 code lengths */\n+uIntf *bb;              /* bits tree desired/actual depth */\n+inflate_huft * FAR *tb; /* bits tree result */\n+inflate_huft *hp;       /* space for trees */\n+z_streamp z;            /* for messages */\n+{\n+  int r;\n+  uInt hn = 0;          /* hufts used in space */\n+  uIntf *v;             /* work area for huft_build */\n+\n+  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)\n+    return Z_MEM_ERROR;\n+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,\n+                 tb, bb, hp, &hn, v);\n+  if (r == Z_DATA_ERROR)\n+    z->msg = (char*)\"oversubscribed dynamic bit lengths tree\";\n+  else if (r == Z_BUF_ERROR || *bb == 0)\n+  {\n+    z->msg = (char*)\"incomplete dynamic bit lengths tree\";\n+    r = Z_DATA_ERROR;\n+  }\n+  ZFREE(z, v);\n+  return r;\n+}\n+\n+\n+int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)\n+uInt nl;                /* number of literal/length codes */\n+uInt nd;                /* number of distance codes */\n+uIntf *c;               /* that many (total) code lengths */\n+uIntf *bl;              /* literal desired/actual bit depth */\n+uIntf *bd;              /* distance desired/actual bit depth */\n+inflate_huft * FAR *tl; /* literal/length tree result */\n+inflate_huft * FAR *td; /* distance tree result */\n+inflate_huft *hp;       /* space for trees */\n+z_streamp z;            /* for messages */\n+{\n+  int r;\n+  uInt hn = 0;          /* hufts used in space */\n+  uIntf *v;             /* work area for huft_build */\n+\n+  /* allocate work area */\n+  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n+    return Z_MEM_ERROR;\n+\n+  /* build literal/length tree */\n+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);\n+  if (r != Z_OK || *bl == 0)\n+  {\n+    if (r == Z_DATA_ERROR)\n+      z->msg = (char*)\"oversubscribed literal/length tree\";\n+    else if (r != Z_MEM_ERROR)\n+    {\n+      z->msg = (char*)\"incomplete literal/length tree\";\n+      r = Z_DATA_ERROR;\n+    }\n+    ZFREE(z, v);\n+    return r;\n+  }\n+\n+  /* build distance tree */\n+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);\n+  if (r != Z_OK || (*bd == 0 && nl > 257))\n+  {\n+    if (r == Z_DATA_ERROR)\n+      z->msg = (char*)\"oversubscribed distance tree\";\n+    else if (r == Z_BUF_ERROR) {\n+#ifdef PKZIP_BUG_WORKAROUND\n+      r = Z_OK;\n+    }\n+#else\n+      z->msg = (char*)\"incomplete distance tree\";\n+      r = Z_DATA_ERROR;\n+    }\n+    else if (r != Z_MEM_ERROR)\n+    {\n+      z->msg = (char*)\"empty distance tree with lengths\";\n+      r = Z_DATA_ERROR;\n+    }\n+    ZFREE(z, v);\n+    return r;\n+#endif\n+  }\n+\n+  /* done */\n+  ZFREE(z, v);\n+  return Z_OK;\n+}\n+\n+\n+/* build fixed tables only once--keep them here */\n+#ifdef BUILDFIXED\n+local int fixed_built = 0;\n+#define FIXEDH 544      /* number of hufts used by fixed tables */\n+local inflate_huft fixed_mem[FIXEDH];\n+local uInt fixed_bl;\n+local uInt fixed_bd;\n+local inflate_huft *fixed_tl;\n+local inflate_huft *fixed_td;\n+#else\n+#include \"inffixed.h\"\n+#endif\n+\n+\n+int inflate_trees_fixed(bl, bd, tl, td, z)\n+uIntf *bl;               /* literal desired/actual bit depth */\n+uIntf *bd;               /* distance desired/actual bit depth */\n+inflate_huft * FAR *tl;  /* literal/length tree result */\n+inflate_huft * FAR *td;  /* distance tree result */\n+z_streamp z;             /* for memory allocation */\n+{\n+#ifdef BUILDFIXED\n+  /* build fixed tables if not already */\n+  if (!fixed_built)\n+  {\n+    int k;              /* temporary variable */\n+    uInt f = 0;         /* number of hufts used in fixed_mem */\n+    uIntf *c;           /* length list for huft_build */\n+    uIntf *v;           /* work area for huft_build */\n+\n+    /* allocate memory */\n+    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n+      return Z_MEM_ERROR;\n+    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n+    {\n+      ZFREE(z, c);\n+      return Z_MEM_ERROR;\n+    }\n+\n+    /* literal table */\n+    for (k = 0; k < 144; k++)\n+      c[k] = 8;\n+    for (; k < 256; k++)\n+      c[k] = 9;\n+    for (; k < 280; k++)\n+      c[k] = 7;\n+    for (; k < 288; k++)\n+      c[k] = 8;\n+    fixed_bl = 9;\n+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,\n+               fixed_mem, &f, v);\n+\n+    /* distance table */\n+    for (k = 0; k < 30; k++)\n+      c[k] = 5;\n+    fixed_bd = 5;\n+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,\n+               fixed_mem, &f, v);\n+\n+    /* done */\n+    ZFREE(z, v);\n+    ZFREE(z, c);\n+    fixed_built = 1;\n+  }\n+#endif\n+  *bl = fixed_bl;\n+  *bd = fixed_bd;\n+  *tl = fixed_tl;\n+  *td = fixed_td;\n+  return Z_OK;\n+}"}, {"sha": "85853e097b373d319cae33e4fb1c63ca04cf0ada", "filename": "zlib/inftrees.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finftrees.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finftrees.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,58 @@\n+/* inftrees.h -- header to use inftrees.c\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* Huffman code lookup table entry--this entry is four bytes for machines\n+   that have 16-bit pointers (e.g. PC's in the small or medium model). */\n+\n+typedef struct inflate_huft_s FAR inflate_huft;\n+\n+struct inflate_huft_s {\n+  union {\n+    struct {\n+      Byte Exop;        /* number of extra bits or operation */\n+      Byte Bits;        /* number of bits in this code or subcode */\n+    } what;\n+    uInt pad;           /* pad structure to a power of 2 (4 bytes for */\n+  } word;               /*  16-bit, 8 bytes for 32-bit int's) */\n+  uInt base;            /* literal, length base, distance base,\n+                           or table offset */\n+};\n+\n+/* Maximum size of dynamic tree.  The maximum found in a long but non-\n+   exhaustive search was 1004 huft structures (850 for length/literals\n+   and 154 for distances, the latter actually the result of an\n+   exhaustive search).  The actual maximum is not known, but the\n+   value below is more than safe. */\n+#define MANY 1440\n+\n+extern int inflate_trees_bits OF((\n+    uIntf *,                    /* 19 code lengths */\n+    uIntf *,                    /* bits tree desired/actual depth */\n+    inflate_huft * FAR *,       /* bits tree result */\n+    inflate_huft *,             /* space for trees */\n+    z_streamp));                /* for messages */\n+\n+extern int inflate_trees_dynamic OF((\n+    uInt,                       /* number of literal/length codes */\n+    uInt,                       /* number of distance codes */\n+    uIntf *,                    /* that many (total) code lengths */\n+    uIntf *,                    /* literal desired/actual bit depth */\n+    uIntf *,                    /* distance desired/actual bit depth */\n+    inflate_huft * FAR *,       /* literal/length tree result */\n+    inflate_huft * FAR *,       /* distance tree result */\n+    inflate_huft *,             /* space for trees */\n+    z_streamp));                /* for messages */\n+\n+extern int inflate_trees_fixed OF((\n+    uIntf *,                    /* literal desired/actual bit depth */\n+    uIntf *,                    /* distance desired/actual bit depth */\n+    inflate_huft * FAR *,       /* literal/length tree result */\n+    inflate_huft * FAR *,       /* distance tree result */\n+    z_streamp));                /* for memory allocation */"}, {"sha": "824dab57128486c77061637bcd6ffb62df47baa1", "filename": "zlib/infutil.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfutil.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,87 @@\n+/* inflate_util.c -- data and routines common to blocks and codes\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+#include \"zutil.h\"\n+#include \"infblock.h\"\n+#include \"inftrees.h\"\n+#include \"infcodes.h\"\n+#include \"infutil.h\"\n+\n+struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n+\n+/* And'ing with mask[n] masks the lower n bits */\n+uInt inflate_mask[17] = {\n+    0x0000,\n+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n+};\n+\n+\n+/* copy as much as possible from the sliding window to the output area */\n+int inflate_flush(s, z, r)\n+inflate_blocks_statef *s;\n+z_streamp z;\n+int r;\n+{\n+  uInt n;\n+  Bytef *p;\n+  Bytef *q;\n+\n+  /* local copies of source and destination pointers */\n+  p = z->next_out;\n+  q = s->read;\n+\n+  /* compute number of bytes to copy as far as end of window */\n+  n = (uInt)((q <= s->write ? s->write : s->end) - q);\n+  if (n > z->avail_out) n = z->avail_out;\n+  if (n && r == Z_BUF_ERROR) r = Z_OK;\n+\n+  /* update counters */\n+  z->avail_out -= n;\n+  z->total_out += n;\n+\n+  /* update check information */\n+  if (s->checkfn != Z_NULL)\n+    z->adler = s->check = (*s->checkfn)(s->check, q, n);\n+\n+  /* copy as far as end of window */\n+  zmemcpy(p, q, n);\n+  p += n;\n+  q += n;\n+\n+  /* see if more to copy at beginning of window */\n+  if (q == s->end)\n+  {\n+    /* wrap pointers */\n+    q = s->window;\n+    if (s->write == s->end)\n+      s->write = s->window;\n+\n+    /* compute bytes to copy */\n+    n = (uInt)(s->write - q);\n+    if (n > z->avail_out) n = z->avail_out;\n+    if (n && r == Z_BUF_ERROR) r = Z_OK;\n+\n+    /* update counters */\n+    z->avail_out -= n;\n+    z->total_out += n;\n+\n+    /* update check information */\n+    if (s->checkfn != Z_NULL)\n+      z->adler = s->check = (*s->checkfn)(s->check, q, n);\n+\n+    /* copy */\n+    zmemcpy(p, q, n);\n+    p += n;\n+    q += n;\n+  }\n+\n+  /* update pointers */\n+  z->next_out = p;\n+  s->read = q;\n+\n+  /* done */\n+  return r;\n+}"}, {"sha": "99d1135d06a3573784a48685c4c35f2b1fb2a6cf", "filename": "zlib/infutil.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Finfutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfutil.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,98 @@\n+/* infutil.h -- types and macros common to blocks and codes\n+ * Copyright (C) 1995-1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+#ifndef _INFUTIL_H\n+#define _INFUTIL_H\n+\n+typedef enum {\n+      TYPE,     /* get type bits (3, including end bit) */\n+      LENS,     /* get lengths for stored */\n+      STORED,   /* processing stored block */\n+      TABLE,    /* get table lengths */\n+      BTREE,    /* get bit lengths tree for a dynamic block */\n+      DTREE,    /* get length, distance trees for a dynamic block */\n+      CODES,    /* processing fixed or dynamic block */\n+      DRY,      /* output remaining window bytes */\n+      DONE,     /* finished last block, done */\n+      BAD}      /* got a data error--stuck here */\n+inflate_block_mode;\n+\n+/* inflate blocks semi-private state */\n+struct inflate_blocks_state {\n+\n+  /* mode */\n+  inflate_block_mode  mode;     /* current inflate_block mode */\n+\n+  /* mode dependent information */\n+  union {\n+    uInt left;          /* if STORED, bytes left to copy */\n+    struct {\n+      uInt table;               /* table lengths (14 bits) */\n+      uInt index;               /* index into blens (or border) */\n+      uIntf *blens;             /* bit lengths of codes */\n+      uInt bb;                  /* bit length tree depth */\n+      inflate_huft *tb;         /* bit length decoding tree */\n+    } trees;            /* if DTREE, decoding info for trees */\n+    struct {\n+      inflate_codes_statef \n+         *codes;\n+    } decode;           /* if CODES, current state */\n+  } sub;                /* submode */\n+  uInt last;            /* true if this block is the last block */\n+\n+  /* mode independent information */\n+  uInt bitk;            /* bits in bit buffer */\n+  uLong bitb;           /* bit buffer */\n+  inflate_huft *hufts;  /* single malloc for tree space */\n+  Bytef *window;        /* sliding window */\n+  Bytef *end;           /* one byte after sliding window */\n+  Bytef *read;          /* window read pointer */\n+  Bytef *write;         /* window write pointer */\n+  check_func checkfn;   /* check function */\n+  uLong check;          /* check on output */\n+\n+};\n+\n+\n+/* defines for inflate input/output */\n+/*   update pointers and return */\n+#define UPDBITS {s->bitb=b;s->bitk=k;}\n+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}\n+#define UPDOUT {s->write=q;}\n+#define UPDATE {UPDBITS UPDIN UPDOUT}\n+#define LEAVE {UPDATE return inflate_flush(s,z,r);}\n+/*   get bytes and bits */\n+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}\n+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}\n+#define NEXTBYTE (n--,*p++)\n+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n+#define DUMPBITS(j) {b>>=(j);k-=(j);}\n+/*   output bytes */\n+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)\n+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}\n+#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}\n+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}\n+#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}\n+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}\n+/*   load local pointers */\n+#define LOAD {LOADIN LOADOUT}\n+\n+/* masks for lower bits (size given to avoid silly warnings with Visual C++) */\n+extern uInt inflate_mask[17];\n+\n+/* copy as much as possible from the sliding window to the output area */\n+extern int inflate_flush OF((\n+    inflate_blocks_statef *,\n+    z_streamp ,\n+    int));\n+\n+struct internal_state      {int dummy;}; /* for buggy compilers */\n+\n+#endif"}, {"sha": "949d786418513e2c492ebeb53a9a67673158e49f", "filename": "zlib/maketree.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmaketree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmaketree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmaketree.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,85 @@\n+/* maketree.c -- make inffixed.h table for decoding fixed codes\n+ * Copyright (C) 1998 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/* WARNING: this file should *not* be used by applications. It is\n+   part of the implementation of the compression library and is\n+   subject to change. Applications should only use zlib.h.\n+ */\n+\n+/* This program is included in the distribution for completeness.\n+   You do not need to compile or run this program since inffixed.h\n+   is already included in the distribution.  To use this program\n+   you need to compile zlib with BUILDFIXED defined and then compile\n+   and link this program with the zlib library.  Then the output of\n+   this program can be piped to inffixed.h. */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"zutil.h\"\n+#include \"inftrees.h\"\n+\n+/* simplify the use of the inflate_huft type with some defines */\n+#define exop word.what.Exop\n+#define bits word.what.Bits\n+\n+/* generate initialization table for an inflate_huft structure array */\n+void maketree(uInt b, inflate_huft *t)\n+{\n+  int i, e;\n+\n+  i = 0;\n+  while (1)\n+  {\n+    e = t[i].exop;\n+    if (e && (e & (16+64)) == 0)        /* table pointer */\n+    {\n+      fprintf(stderr, \"maketree: cannot initialize sub-tables!\\n\");\n+      exit(1);\n+    }\n+    if (i % 4 == 0)\n+      printf(\"\\n   \");\n+    printf(\" {{{%u,%u}},%u}\", t[i].exop, t[i].bits, t[i].base);\n+    if (++i == (1<<b))\n+      break;\n+    putchar(',');\n+  }\n+  puts(\"\");\n+}\n+\n+/* create the fixed tables in C initialization syntax */\n+void main(void)\n+{\n+  int r;\n+  uInt bl, bd;\n+  inflate_huft *tl, *td;\n+  z_stream z;\n+\n+  z.zalloc = zcalloc;\n+  z.opaque = (voidpf)0;\n+  z.zfree = zcfree;\n+  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);\n+  if (r)\n+  {\n+    fprintf(stderr, \"inflate_trees_fixed error %d\\n\", r);\n+    return;\n+  }\n+  puts(\"/* inffixed.h -- table for decoding fixed codes\");\n+  puts(\" * Generated automatically by the maketree.c program\");\n+  puts(\" */\");\n+  puts(\"\");\n+  puts(\"/* WARNING: this file should *not* be used by applications. It is\");\n+  puts(\"   part of the implementation of the compression library and is\");\n+  puts(\"   subject to change. Applications should only use zlib.h.\");\n+  puts(\" */\");\n+  puts(\"\");\n+  printf(\"local uInt fixed_bl = %d;\\n\", bl);\n+  printf(\"local uInt fixed_bd = %d;\\n\", bd);\n+  printf(\"local inflate_huft fixed_tl[] = {\");\n+  maketree(bl, tl);\n+  puts(\"  };\");\n+  printf(\"local inflate_huft fixed_td[] = {\");\n+  maketree(bd, td);\n+  puts(\"  };\");\n+}"}, {"sha": "7215eaeb0fc42be602d34ed572ad44ad71f642db", "filename": "zlib/minigzip.c", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fminigzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fminigzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fminigzip.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,320 @@\n+/* minigzip.c -- simulate gzip using the zlib compression library\n+ * Copyright (C) 1995-1998 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h \n+ */\n+\n+/*\n+ * minigzip is a minimal implementation of the gzip utility. This is\n+ * only an example of using zlib and isn't meant to replace the\n+ * full-featured gzip. No attempt is made to deal with file systems\n+ * limiting names to 14 or 8+3 characters, etc... Error checking is\n+ * very limited. So use minigzip only for testing; use gzip for the\n+ * real thing. On MSDOS, use only on file names without extension\n+ * or in pipe mode.\n+ */\n+\n+/* @(#) $Id$ */\n+\n+#include <stdio.h>\n+#include \"zlib.h\"\n+\n+#ifdef STDC\n+#  include <string.h>\n+#  include <stdlib.h>\n+#else\n+   extern void exit  OF((int));\n+#endif\n+\n+#ifdef USE_MMAP\n+#  include <sys/types.h>\n+#  include <sys/mman.h>\n+#  include <sys/stat.h>\n+#endif\n+\n+#if defined(MSDOS) || defined(OS2) || defined(WIN32)\n+#  include <fcntl.h>\n+#  include <io.h>\n+#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n+#else\n+#  define SET_BINARY_MODE(file)\n+#endif\n+\n+#ifdef VMS\n+#  define unlink delete\n+#  define GZ_SUFFIX \"-gz\"\n+#endif\n+#ifdef RISCOS\n+#  define unlink remove\n+#  define GZ_SUFFIX \"-gz\"\n+#  define fileno(file) file->__file\n+#endif\n+#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n+#  include <unix.h> /* for fileno */\n+#endif\n+\n+#ifndef WIN32 /* unlink already in stdio.h for WIN32 */\n+  extern int unlink OF((const char *));\n+#endif\n+\n+#ifndef GZ_SUFFIX\n+#  define GZ_SUFFIX \".gz\"\n+#endif\n+#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)\n+\n+#define BUFLEN      16384\n+#define MAX_NAME_LEN 1024\n+\n+#ifdef MAXSEG_64K\n+#  define local static\n+   /* Needed for systems with limitation on stack size. */\n+#else\n+#  define local\n+#endif\n+\n+char *prog;\n+\n+void error            OF((const char *msg));\n+void gz_compress      OF((FILE   *in, gzFile out));\n+#ifdef USE_MMAP\n+int  gz_compress_mmap OF((FILE   *in, gzFile out));\n+#endif\n+void gz_uncompress    OF((gzFile in, FILE   *out));\n+void file_compress    OF((char  *file, char *mode));\n+void file_uncompress  OF((char  *file));\n+int  main             OF((int argc, char *argv[]));\n+\n+/* ===========================================================================\n+ * Display error message and exit\n+ */\n+void error(msg)\n+    const char *msg;\n+{\n+    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n+    exit(1);\n+}\n+\n+/* ===========================================================================\n+ * Compress input to output then close both files.\n+ */\n+\n+void gz_compress(in, out)\n+    FILE   *in;\n+    gzFile out;\n+{\n+    local char buf[BUFLEN];\n+    int len;\n+    int err;\n+\n+#ifdef USE_MMAP\n+    /* Try first compressing with mmap. If mmap fails (minigzip used in a\n+     * pipe), use the normal fread loop.\n+     */\n+    if (gz_compress_mmap(in, out) == Z_OK) return;\n+#endif\n+    for (;;) {\n+        len = fread(buf, 1, sizeof(buf), in);\n+        if (ferror(in)) {\n+            perror(\"fread\");\n+            exit(1);\n+        }\n+        if (len == 0) break;\n+\n+        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));\n+    }\n+    fclose(in);\n+    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n+}\n+\n+#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */\n+\n+/* Try compressing the input file at once using mmap. Return Z_OK if\n+ * if success, Z_ERRNO otherwise.\n+ */\n+int gz_compress_mmap(in, out)\n+    FILE   *in;\n+    gzFile out;\n+{\n+    int len;\n+    int err;\n+    int ifd = fileno(in);\n+    caddr_t buf;    /* mmap'ed buffer for the entire input file */\n+    off_t buf_len;  /* length of the input file */\n+    struct stat sb;\n+\n+    /* Determine the size of the file, needed for mmap: */\n+    if (fstat(ifd, &sb) < 0) return Z_ERRNO;\n+    buf_len = sb.st_size;\n+    if (buf_len <= 0) return Z_ERRNO;\n+\n+    /* Now do the actual mmap: */\n+    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); \n+    if (buf == (caddr_t)(-1)) return Z_ERRNO;\n+\n+    /* Compress the whole file at once: */\n+    len = gzwrite(out, (char *)buf, (unsigned)buf_len);\n+\n+    if (len != (int)buf_len) error(gzerror(out, &err));\n+\n+    munmap(buf, buf_len);\n+    fclose(in);\n+    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n+    return Z_OK;\n+}\n+#endif /* USE_MMAP */\n+\n+/* ===========================================================================\n+ * Uncompress input to output then close both files.\n+ */\n+void gz_uncompress(in, out)\n+    gzFile in;\n+    FILE   *out;\n+{\n+    local char buf[BUFLEN];\n+    int len;\n+    int err;\n+\n+    for (;;) {\n+        len = gzread(in, buf, sizeof(buf));\n+        if (len < 0) error (gzerror(in, &err));\n+        if (len == 0) break;\n+\n+        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {\n+\t    error(\"failed fwrite\");\n+\t}\n+    }\n+    if (fclose(out)) error(\"failed fclose\");\n+\n+    if (gzclose(in) != Z_OK) error(\"failed gzclose\");\n+}\n+\n+\n+/* ===========================================================================\n+ * Compress the given file: create a corresponding .gz file and remove the\n+ * original.\n+ */\n+void file_compress(file, mode)\n+    char  *file;\n+    char  *mode;\n+{\n+    local char outfile[MAX_NAME_LEN];\n+    FILE  *in;\n+    gzFile out;\n+\n+    strcpy(outfile, file);\n+    strcat(outfile, GZ_SUFFIX);\n+\n+    in = fopen(file, \"rb\");\n+    if (in == NULL) {\n+        perror(file);\n+        exit(1);\n+    }\n+    out = gzopen(outfile, mode);\n+    if (out == NULL) {\n+        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, outfile);\n+        exit(1);\n+    }\n+    gz_compress(in, out);\n+\n+    unlink(file);\n+}\n+\n+\n+/* ===========================================================================\n+ * Uncompress the given file and remove the original.\n+ */\n+void file_uncompress(file)\n+    char  *file;\n+{\n+    local char buf[MAX_NAME_LEN];\n+    char *infile, *outfile;\n+    FILE  *out;\n+    gzFile in;\n+    int len = strlen(file);\n+\n+    strcpy(buf, file);\n+\n+    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {\n+        infile = file;\n+        outfile = buf;\n+        outfile[len-3] = '\\0';\n+    } else {\n+        outfile = file;\n+        infile = buf;\n+        strcat(infile, GZ_SUFFIX);\n+    }\n+    in = gzopen(infile, \"rb\");\n+    if (in == NULL) {\n+        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, infile);\n+        exit(1);\n+    }\n+    out = fopen(outfile, \"wb\");\n+    if (out == NULL) {\n+        perror(file);\n+        exit(1);\n+    }\n+\n+    gz_uncompress(in, out);\n+\n+    unlink(infile);\n+}\n+\n+\n+/* ===========================================================================\n+ * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]\n+ *   -d : decompress\n+ *   -f : compress with Z_FILTERED\n+ *   -h : compress with Z_HUFFMAN_ONLY\n+ *   -1 to -9 : compression level\n+ */\n+\n+int main(argc, argv)\n+    int argc;\n+    char *argv[];\n+{\n+    int uncompr = 0;\n+    gzFile file;\n+    char outmode[20];\n+\n+    strcpy(outmode, \"wb6 \");\n+\n+    prog = argv[0];\n+    argc--, argv++;\n+\n+    while (argc > 0) {\n+      if (strcmp(*argv, \"-d\") == 0)\n+\tuncompr = 1;\n+      else if (strcmp(*argv, \"-f\") == 0)\n+\toutmode[3] = 'f';\n+      else if (strcmp(*argv, \"-h\") == 0)\n+\toutmode[3] = 'h';\n+      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&\n+\t       (*argv)[2] == 0)\n+\toutmode[2] = (*argv)[1];\n+      else\n+\tbreak;\n+      argc--, argv++;\n+    }\n+    if (argc == 0) {\n+        SET_BINARY_MODE(stdin);\n+        SET_BINARY_MODE(stdout);\n+        if (uncompr) {\n+            file = gzdopen(fileno(stdin), \"rb\");\n+            if (file == NULL) error(\"can't gzdopen stdin\");\n+            gz_uncompress(file, stdout);\n+        } else {\n+            file = gzdopen(fileno(stdout), outmode);\n+            if (file == NULL) error(\"can't gzdopen stdout\");\n+            gz_compress(stdin, file);\n+        }\n+    } else {\n+        do {\n+            if (uncompr) {\n+                file_uncompress(*argv);\n+            } else {\n+                file_compress(*argv, outmode);\n+            }\n+        } while (argv++, --argc);\n+    }\n+    exit(0);\n+    return 0; /* to avoid warning */\n+}"}, {"sha": "f476da916491d0d14b622ca712e0c74a81036e56", "filename": "zlib/msdos/Makefile.b32", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.b32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.b32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.b32?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,104 @@\n+# Makefile for zlib\n+# Borland C++   \n+\n+# This version of the zlib makefile was adapted by Chris Young for use\n+# with Borland C 4.5x with the Dos Power Pack for a 32-bit protected mode\n+# flat memory model.  It was created for use with POV-Ray ray tracer and\n+# you may choose to edit the CFLAGS to suit your needs but the\n+# switches -WX and -DMSDOS are required.\n+# -- Chris Young 76702.1655@compuserve.com\n+\n+# To use, do \"make -fmakefile.b32\"\n+\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Borland C++ -------------\n+MODEL=-WX \n+CFLAGS= $(MODEL) -P-C -K -N- -k- -d -3 -r- -v- -f -DMSDOS\n+CC=bcc32\n+LD=bcc32\n+LIB=tlib\n+LDFLAGS= $(MODEL)\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n+  infutil$(O)+inffast$(O)\n+\n+all: test\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c zutil.h zlib.h zconf.h infblock.h inftrees.h\\\n+   infcodes.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c zutil.h zlib.h zconf.h inftrees.h infutil.h\\\n+   infcodes.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h infblock.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+example.obj: example.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+zlib.lib: $(OBJ1) $(OBJ2)\n+\tdel zlib.lib\n+\t$(LIB) zlib +$(OBJP1)\n+\t$(LIB) zlib +$(OBJP2)\n+\n+example.exe: example.obj zlib.lib\n+\t$(LD) $(LDFLAGS) example.obj zlib.lib\n+\n+minigzip.exe: minigzip.obj zlib.lib\n+\t$(LD) $(LDFLAGS) minigzip.obj zlib.lib\n+\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d \n+\n+#clean:\n+#\tdel *.obj\n+#\tdel *.exe"}, {"sha": "f5651b40fec88bf2d5ab937518fe093d2e1bcdb8", "filename": "zlib/msdos/Makefile.bor", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.bor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.bor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.bor?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,125 @@\n+# Makefile for zlib\n+# Borland C++   ************ UNTESTED ***********\n+\n+# To use, do \"make -fmakefile.bor\"\n+# To compile in small model, set below: MODEL=s\n+\n+# WARNING: the small model is supported but only for small values of\n+# MAX_WBITS and MAX_MEM_LEVEL. For example:\n+#    -DMAX_WBITS=11 -DDEF_WBITS=11 -DMAX_MEM_LEVEL=3\n+# If you wish to reduce the memory requirements (default 256K for big\n+# objects plus a few K), you can add to the LOC macro below:\n+#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Turbo C++, Borland C++ -------------\n+\n+#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)\n+#    should be added to the environment via \"set LOCAL_ZLIB=-DFOO\" or added\n+#    to the declaration of LOC here:\n+LOC = $(LOCAL_ZLIB)\n+\n+# Type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.\n+CPU_TYP = 0\n+\n+# Memory model: one of s, m, c, l (small, medium, compact, large)\n+MODEL=l\n+\n+CC=bcc\n+#   replace bcc with tcc for Turbo C++ 1.0, with bcc32 for the 32 bit version\n+LD=$(CC)\n+AR=tlib\n+\n+# compiler flags\n+CFLAGS=-O2 -Z -m$(MODEL) $(LOC)\n+#   replace \"-O2\" by \"-O -G -a -d\" for Turbo C++ 1.0\n+\n+LDFLAGS=-m$(MODEL)\n+\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n+  infutil$(O)+inffast$(O)\n+\n+ZLIB_H = zlib.h zconf.h\n+ZUTIL_H = zutil.h $(ZLIB_H)\n+\n+ZLIB_LIB = zlib_$(MODEL).lib\n+\n+all: test\n+\n+# individual dependencies and action rules:\n+adler32.obj: adler32.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+compress.obj: compress.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c $(ZUTIL_H) infblock.h inftrees.h infcodes.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c $(ZUTIL_H) inftrees.h infutil.h infcodes.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c $(ZUTIL_H) infblock.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c $(ZUTIL_H) inftrees.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c $(ZUTIL_H) inftrees.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c $(ZUTIL_H) inftrees.h infutil.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+example.obj: example.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2)\n+\tdel $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) +$(OBJP1)\n+\t$(AR) $(ZLIB_LIB) +$(OBJP2)\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)\n+\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d \n+\n+#clean:\n+#\tdel *.obj\n+#\tdel *.exe"}, {"sha": "0ab431c8a118ea61b9c7a61864402681fa6c9f8f", "filename": "zlib/msdos/Makefile.dj2", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.dj2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.dj2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.dj2?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,100 @@\n+# Makefile for zlib.  Modified for djgpp v2.0 by F. J. Donahoe, 3/15/96.\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, or to compile and test, type:\n+# \n+#   make -fmakefile.dj2;  make test -fmakefile.dj2\n+# \n+# To install libz.a, zconf.h and zlib.h in the djgpp directories, type:\n+# \n+#    make install -fmakefile.dj2\n+# \n+# after first defining LIBRARY_PATH and INCLUDE_PATH in djgpp.env as\n+# in the sample below if the pattern of the DJGPP distribution is to\n+# be followed.  Remember that, while <sp>'es around <=> are ignored in\n+# makefiles, they are *not* in batch files or in djgpp.env.\n+# - - - - -\n+# [make]\n+# INCLUDE_PATH=%\\>;INCLUDE_PATH%%\\DJDIR%\\include\n+# LIBRARY_PATH=%\\>;LIBRARY_PATH%%\\DJDIR%\\lib\n+# BUTT=-m486\n+# - - - - -\n+# Alternately, these variables may be defined below, overriding the values\n+# in djgpp.env, as\n+# INCLUDE_PATH=c:\\usr\\include\n+# LIBRARY_PATH=c:\\usr\\lib\n+\n+CC=gcc\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lz\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=libz.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d \n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+libz.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+# INCLUDE_PATH and LIBRARY_PATH were set for [make] in djgpp.env .\n+\n+.PHONY : uninstall clean\n+\n+install: $(INCL) $(LIBS)\n+\t-@if not exist $(INCLUDE_PATH)\\nul mkdir $(INCLUDE_PATH)\n+\t-@if not exist $(LIBRARY_PATH)\\nul mkdir $(LIBRARY_PATH)\n+\t$(INSTALL) zlib.h $(INCLUDE_PATH)\n+\t$(INSTALL) zconf.h $(INCLUDE_PATH)\n+\t$(INSTALL) libz.a $(LIBRARY_PATH)\n+\n+uninstall:\n+\t$(RM) $(INCLUDE_PATH)\\zlib.h\n+\t$(RM) $(INCLUDE_PATH)\\zconf.h\n+\t$(RM) $(LIBRARY_PATH)\\libz.a\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) libz.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif"}, {"sha": "0e5e5cc43383f15f96b66ed65e7496c3629076ab", "filename": "zlib/msdos/Makefile.emx", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.emx?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,69 @@\n+# Makefile for zlib.  Modified for emx 0.9c by Chr. Spieler, 6/17/98.\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, or to compile and test, type:\n+# \n+#   make -fmakefile.emx;  make test -fmakefile.emx\n+# \n+\n+CC=gcc\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lzlib\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=zlib.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d \n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+zlib.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+\n+.PHONY : clean\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) zlib.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif"}, {"sha": "562201d87eac39990d64f7ef3bcb23f402eac018", "filename": "zlib/msdos/Makefile.msc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.msc?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,121 @@\n+# Makefile for zlib\n+# Microsoft C 5.1 or later\n+\n+# To use, do \"make makefile.msc\"\n+# To compile in small model, set below: MODEL=S\n+\n+# If you wish to reduce the memory requirements (default 256K for big\n+# objects plus a few K), you can add to the LOC macro below:\n+#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Microsoft C 5.1 and later -------------\n+\n+#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)\n+#    should be added to the environment via \"set LOCAL_ZLIB=-DFOO\" or added\n+#    to the declaration of LOC here:\n+LOC = $(LOCAL_ZLIB)\n+\n+# Type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.\n+CPU_TYP = 0\n+\n+# Memory model: one of S, M, C, L (small, medium, compact, large)\n+MODEL=L\n+\n+CC=cl\n+CFLAGS=-nologo -A$(MODEL) -G$(CPU_TYP) -W3 -Oait -Gs $(LOC)\n+#-Ox generates bad code with MSC 5.1\n+LIB_CFLAGS=-Zl $(CFLAGS)\n+\n+LD=link\n+LDFLAGS=/noi/e/st:0x1500/noe/farcall/packcode\n+# \"/farcall/packcode\" are only useful for `large code' memory models\n+# but should be a \"no-op\" for small code models.\n+\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n+  infutil$(O)+inffast$(O)\n+\n+ZLIB_H = zlib.h zconf.h\n+ZUTIL_H = zutil.h $(ZLIB_H)\n+\n+ZLIB_LIB = zlib_$(MODEL).lib\n+\n+all:  $(ZLIB_LIB) example.exe minigzip.exe\n+\n+# individual dependencies and action rules:\n+adler32.obj: adler32.c $(ZLIB_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+compress.obj: compress.c $(ZLIB_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+crc32.obj: crc32.c $(ZLIB_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+gzio.obj: gzio.c $(ZUTIL_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+infblock.obj: infblock.c $(ZUTIL_H) infblock.h inftrees.h infcodes.h infutil.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c $(ZUTIL_H) inftrees.h infutil.h infcodes.h inffast.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+inflate.obj: inflate.c $(ZUTIL_H) infblock.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c $(ZUTIL_H) inftrees.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+infutil.obj: infutil.c $(ZUTIL_H) inftrees.h infutil.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+inffast.obj: inffast.c $(ZUTIL_H) inftrees.h infutil.h inffast.h\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c $(ZLIB_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+zutil.obj: zutil.c $(ZUTIL_H)\n+\t$(CC) -c $(LIB_CFLAGS) $*.c\n+\n+example.obj: example.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2)\n+\tif exist $(ZLIB_LIB) del $(ZLIB_LIB)\n+\tlib $(ZLIB_LIB) $(OBJ1);\n+\tlib $(ZLIB_LIB) $(OBJ2);\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) example.obj,,,$(ZLIB_LIB);\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) minigzip.obj,,,$(ZLIB_LIB);\n+\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d \n+\n+#clean:\n+#\tdel *.obj\n+#\tdel *.exe"}, {"sha": "63e0550359f9d434619bfffb582f57c9ca9de970", "filename": "zlib/msdos/Makefile.tc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.tc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.tc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.tc?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,108 @@\n+# Makefile for zlib\n+# TurboC 2.0\n+\n+# To use, do \"make -fmakefile.tc\"\n+# To compile in small model, set below: MODEL=-ms\n+\n+# WARNING: the small model is supported but only for small values of\n+# MAX_WBITS and MAX_MEM_LEVEL. For example:\n+#    -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3\n+# If you wish to reduce the memory requirements (default 256K for big\n+# objects plus a few K), you can add to CFLAGS below:\n+#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Turbo C 2.0 -------------\n+MODEL=l\n+# CFLAGS=-O2 -G -Z -m$(MODEL) -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3\n+CFLAGS=-O2 -G -Z -m$(MODEL)\n+CC=tcc -I\\tc\\include\n+LD=tcc -L\\tc\\lib\n+AR=tlib\n+LDFLAGS=-m$(MODEL) -f-\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n+  infutil$(O)+inffast$(O)\n+\n+ZLIB_H = zlib.h zconf.h\n+ZUTIL_H = zutil.h $(ZLIB_H)\n+\n+ZLIB_LIB = zlib_$(MODEL).lib\n+\n+all: test\n+\n+adler32.obj: adler32.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+compress.obj: compress.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c $(ZUTIL_H) infblock.h inftrees.h infcodes.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c $(ZUTIL_H) inftrees.h infutil.h infcodes.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c $(ZUTIL_H) infblock.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c $(ZUTIL_H) inftrees.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c $(ZUTIL_H) inftrees.h infutil.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c $(ZUTIL_H) inftrees.h infutil.h inffast.h\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c $(ZUTIL_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+example.obj: example.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c $(ZLIB_H)\n+\t$(CC) -c $(CFLAGS) $*.c\n+\n+# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+$(ZLIB_LIB): $(OBJ1) $(OBJ2)\n+\tdel $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) +$(OBJP1)\n+\t$(AR) $(ZLIB_LIB) +$(OBJP2)\n+\n+example.exe: example.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) -eexample.exe example.obj $(ZLIB_LIB)\n+\n+minigzip.exe: minigzip.obj $(ZLIB_LIB)\n+\t$(LD) $(LDFLAGS) -eminigzip.exe minigzip.obj $(ZLIB_LIB)\n+\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d \n+\n+#clean:\n+#\tdel *.obj\n+#\tdel *.exe"}, {"sha": "0a05fa9a46968a12d242ecf75453070a5a52be39", "filename": "zlib/msdos/Makefile.w32", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.w32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.w32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.w32?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,97 @@\n+# Makefile for zlib\n+# Microsoft 32-bit Visual C++ 4.0 or later (may work on earlier versions)\n+\n+# To use, do \"nmake /f makefile.w32\"\n+\n+# If you wish to reduce the memory requirements (default 256K for big\n+# objects plus a few K), you can add to CFLAGS below: \n+#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Microsoft Visual C++ 4.0 and later -------------\n+MODEL=\n+CFLAGS=-Ox -GA3s -nologo -W3\n+CC=cl\n+LD=link\n+LDFLAGS=\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n+  infutil$(O)+inffast$(O)\n+\n+all:  zlib.lib example.exe minigzip.exe\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+compress.obj: compress.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c zutil.h zlib.h zconf.h infblock.h inftrees.h\\\n+   infcodes.h infutil.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c zutil.h zlib.h zconf.h inftrees.h infutil.h\\\n+   infcodes.h inffast.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h infblock.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+example.obj: example.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+  $(CC) -c $(CFLAGS) $*.c\n+\n+zlib.lib: $(OBJ1) $(OBJ2)\n+  if exist zlib.lib del zlib.lib\n+  lib /OUT:zlib.lib $(OBJ1) $(OBJ2)\n+\n+example.exe: example.obj zlib.lib\n+  $(LD) $(LDFLAGS) example.obj zlib.lib /OUT:example.exe /SUBSYSTEM:CONSOLE\n+\n+minigzip.exe: minigzip.obj zlib.lib\n+  $(LD) $(LDFLAGS) minigzip.obj zlib.lib /OUT:minigzip.exe /SUBSYSTEM:CONSOLE\n+\n+test: example.exe minigzip.exe\n+  example\n+  echo hello world | minigzip | minigzip -d \n+\n+#clean:\n+#  del *.obj\n+#  del *.exe"}, {"sha": "44bf8607f6f0060789c90f3656860adca868f18d", "filename": "zlib/msdos/Makefile.wat", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.wat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2FMakefile.wat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.wat?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,103 @@\n+# Makefile for zlib\n+# Watcom 10a\n+\n+# This version of the zlib makefile was adapted by Chris Young for use\n+# with Watcom 10a 32-bit protected mode flat memory model.  It was created \n+# for use with POV-Ray ray tracer and you may choose to edit the CFLAGS to \n+# suit your needs but the -DMSDOS is required.\n+# -- Chris Young 76702.1655@compuserve.com\n+\n+# To use, do \"wmake -f makefile.wat\"\n+\n+# See zconf.h for details about the memory requirements.\n+\n+# ------------- Watcom 10a -------------\n+MODEL=-mf \n+CFLAGS= $(MODEL) -fpi87 -fp5 -zp4 -5r -w5 -oneatx -DMSDOS\n+CC=wcc386\n+LD=wcl386\n+LIB=wlib -b -c \n+LDFLAGS= \n+O=.obj\n+\n+# variables\n+OBJ1=adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \n+OBJ2=trees$(O) zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \n+OBJ3=infutil$(O) inffast$(O)\n+OBJP1=adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)\n+OBJP2=trees$(O)+zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)\n+OBJP3=infutil$(O)+inffast$(O)\n+\n+all: test\n+\n+adler32.obj: adler32.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c zutil.h zlib.h zconf.h infblock.h inftrees.h &\n+  infcodes.h infutil.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c zutil.h zlib.h zconf.h inftrees.h infutil.h &\n+  infcodes.h inffast.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h infblock.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+example.obj: example.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\t$(CC) $(CFLAGS) $*.c\n+\n+# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+zlib.lib: $(OBJ1) $(OBJ2) $(OBJ3) \n+\tdel zlib.lib\n+\t$(LIB) zlib.lib +$(OBJP1)\n+\t$(LIB) zlib.lib +$(OBJP2)\n+\t$(LIB) zlib.lib +$(OBJP3)\n+\n+example.exe: example.obj zlib.lib\n+\t$(LD) $(LDFLAGS) example.obj zlib.lib\n+\n+minigzip.exe: minigzip.obj zlib.lib\n+\t$(LD) $(LDFLAGS) minigzip.obj zlib.lib\n+\n+test: minigzip.exe example.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d >test\n+\ttype test\n+\n+#clean:\n+#\tdel *.obj\n+#\tdel *.exe"}, {"sha": "6c04412f9b00380763e54499b90d49e282e7f1c3", "filename": "zlib/msdos/zlib.def", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2Fzlib.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,60 @@\n+LIBRARY\t\t\"zlib\"\n+\n+DESCRIPTION\t'\"\"\"zlib data compression library\"\"\"'\n+\n+EXETYPE\t\tNT\n+\n+SUBSYSTEM\tWINDOWS\n+\n+STUB\t\t'WINSTUB.EXE'\n+\n+VERSION\t\t1.13\n+\n+CODE\t\t EXECUTE READ\n+\n+DATA\t\t READ WRITE\n+\n+HEAPSIZE\t1048576,4096\n+\n+EXPORTS\n+    adler32                        @1\n+    compress                       @2\n+    crc32                          @3\n+    deflate                        @4\n+    deflateCopy                    @5\n+    deflateEnd                     @6\n+    deflateInit2_                  @7\n+    deflateInit_                   @8\n+    deflateParams                  @9\n+    deflateReset                   @10\n+    deflateSetDictionary           @11\n+    gzclose                        @12\n+    gzdopen                        @13\n+    gzerror                        @14\n+    gzflush                        @15\n+    gzopen                         @16\n+    gzread                         @17\n+    gzwrite                        @18\n+    inflate                        @19\n+    inflateEnd                     @20\n+    inflateInit2_                  @21\n+    inflateInit_                   @22\n+    inflateReset                   @23\n+    inflateSetDictionary           @24\n+    inflateSync                    @25\n+    uncompress                     @26\n+    zlibVersion                    @27\n+    gzprintf                       @28\n+    gzputc                         @29\n+    gzgetc                         @30\n+    gzseek                         @31\n+    gzrewind                       @32\n+    gztell                         @33\n+    gzeof                          @34\n+    gzsetparams                    @35\n+    zError                         @36\n+    inflateSyncPoint               @37\n+    get_crc_table                  @38\n+    compress2                      @39\n+    gzputs                         @40\n+    gzgets                         @41"}, {"sha": "556d4ff950ab5a26410d5f71d1f11575a5c39e56", "filename": "zlib/msdos/zlib.rc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fmsdos%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2Fzlib.rc?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,32 @@\n+#include <windows.h>\n+\n+#define IDR_VERSION1  1\n+IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\n+  FILEVERSION\t 1,1,3,0\n+  PRODUCTVERSION 1,1,3,0\n+  FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\n+  FILEFLAGS\t0\n+  FILEOS\tVOS_DOS_WINDOWS32\n+  FILETYPE\tVFT_DLL\n+  FILESUBTYPE\t0\t// not used\n+BEGIN\n+  BLOCK \"StringFileInfo\"\n+  BEGIN\n+    BLOCK \"040904E4\"\n+    //language ID = U.S. English, char set = Windows, Multilingual\n+\n+    BEGIN\n+      VALUE \"FileDescription\", \"zlib data compression library\\0\"\n+      VALUE \"FileVersion\",\t\"1.1.3\\0\"\n+      VALUE \"InternalName\",\t\"zlib\\0\"\n+      VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\n+      VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\n+      VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\n+      VALUE \"LegalCopyright\", \"(C) 1995-1998 Jean-loup Gailly & Mark Adler\\0\"\n+    END\n+  END\n+  BLOCK \"VarFileInfo\"\n+  BEGIN\n+    VALUE \"Translation\", 0x0409, 1252\n+  END\n+END"}, {"sha": "2d475b1847e11f1ee53b44603a3c1000d55415f2", "filename": "zlib/nt/Makefile.emx", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.emx?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,138 @@\n+# Makefile for zlib.  Modified for emx/rsxnt by Chr. Spieler, 6/16/98.\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, or to compile and test, type:\n+# \n+#   make -fmakefile.emx;  make test -fmakefile.emx\n+# \n+\n+CC=gcc -Zwin32\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lzlib\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=zlib.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d \n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+zlib.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+\n+.PHONY : clean\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) zlib.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif\n+# Makefile for zlib.  Modified for emx 0.9c by Chr. Spieler, 6/17/98.\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, or to compile and test, type:\n+# \n+#   make -fmakefile.emx;  make test -fmakefile.emx\n+# \n+\n+CC=gcc\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lzlib\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=zlib.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d \n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+zlib.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+\n+.PHONY : clean\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) zlib.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif"}, {"sha": "cdd652f236028439ef45ebea059d36ccf526caec", "filename": "zlib/nt/Makefile.gcc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.gcc?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,87 @@\n+# Makefile for zlib.  Modified for mingw32 by C. Spieler, 6/16/98.\n+# (This Makefile is directly derived from Makefile.dj2)\n+# Copyright (C) 1995-1998 Jean-loup Gailly.\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile, or to compile and test, type:\n+# \n+#   make -fmakefile.gcc;  make test -fmakefile.gcc\n+# \n+# To install libz.a, zconf.h and zlib.h in the mingw32 directories, type:\n+# \n+#    make install -fmakefile.gcc\n+# \n+\n+CC=gcc\n+\n+#CFLAGS=-MMD -O\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-MMD -g -DDEBUG\n+CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+             -Wstrict-prototypes -Wmissing-prototypes\n+\n+# If cp.exe is available, replace \"copy /Y\" with \"cp -fp\" .\n+CP=copy /Y\n+# If gnu install.exe is available, replace $(CP) with ginstall.\n+INSTALL=$(CP)\n+# The default value of RM is \"rm -f.\"  If \"rm.exe\" is found, comment out:\n+RM=del\n+LDLIBS=-L. -lz\n+LD=$(CC) -s -o\n+LDSHARED=$(CC)\n+\n+INCL=zlib.h zconf.h\n+LIBS=libz.a\n+\n+AR=ar rcs\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t./example\n+\techo hello world | .\\minigzip | .\\minigzip -d \n+\n+%.o : %.c\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+\n+libz.a: $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\n+%.exe : %.o $(LIBS)\n+\t$(LD) $@ $< $(LDLIBS)\n+\n+# INCLUDE_PATH and LIBRARY_PATH were set for [make] in djgpp.env .\n+\n+.PHONY : uninstall clean\n+\n+install: $(INCL) $(LIBS)\n+\t-@if not exist $(INCLUDE_PATH)\\nul mkdir $(INCLUDE_PATH)\n+\t-@if not exist $(LIBRARY_PATH)\\nul mkdir $(LIBRARY_PATH)\n+\t$(INSTALL) zlib.h $(INCLUDE_PATH)\n+\t$(INSTALL) zconf.h $(INCLUDE_PATH)\n+\t$(INSTALL) libz.a $(LIBRARY_PATH)\n+\n+uninstall:\n+\t$(RM) $(INCLUDE_PATH)\\zlib.h\n+\t$(RM) $(INCLUDE_PATH)\\zconf.h\n+\t$(RM) $(LIBRARY_PATH)\\libz.a\n+\n+clean:\n+\t$(RM) *.d\n+\t$(RM) *.o\n+\t$(RM) *.exe\n+\t$(RM) libz.a\n+\t$(RM) foo.gz\n+\n+DEPS := $(wildcard *.d)\n+ifneq ($(DEPS),)\n+include $(DEPS)\n+endif"}, {"sha": "b250f2ac7d2aab67fa45ea00fff2ca4f8bf59ba8", "filename": "zlib/nt/Makefile.nt", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.nt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2FMakefile.nt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.nt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,88 @@\n+# Makefile for zlib\n+\n+!include <ntwin32.mak>\n+\n+CC=cl\n+LD=link\n+CFLAGS=-O -nologo\n+LDFLAGS=\n+O=.obj\n+\n+# variables\n+OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n+  trees$(O)\n+OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n+  infutil$(O) inffast$(O)\n+\n+all:  zlib.dll example.exe minigzip.exe\n+\n+adler32.obj: adler32.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+compress.obj: compress.c zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+crc32.obj: crc32.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+infblock.obj: infblock.c zutil.h zlib.h zconf.h infblock.h inftrees.h\\\n+   infcodes.h infutil.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+infcodes.obj: infcodes.c zutil.h zlib.h zconf.h inftrees.h infutil.h\\\n+   infcodes.h inffast.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h infblock.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+infutil.obj: infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+uncompr.obj: uncompr.c zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+example.obj: example.c zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n+\t$(CC) -c $(cvarsdll) $(CFLAGS) $*.c\n+\n+zlib.dll: $(OBJ1) $(OBJ2) zlib.dnt\n+\tlink $(dlllflags) -out:$@ -def:zlib.dnt $(OBJ1) $(OBJ2) $(guilibsdll)\n+\n+zlib.lib: zlib.dll\n+\n+example.exe: example.obj zlib.lib\n+\t$(LD) $(LDFLAGS) example.obj zlib.lib\n+\n+minigzip.exe: minigzip.obj zlib.lib\n+\t$(LD) $(LDFLAGS) minigzip.obj zlib.lib\n+\n+test: example.exe minigzip.exe\n+\texample\n+\techo hello world | minigzip | minigzip -d \n+\n+clean:\n+\tdel *.obj\n+\tdel *.exe\n+\tdel *.dll\n+\tdel *.lib"}, {"sha": "7f9475cfb0ee39b4653f03cc5d8a2ceb48ca1eec", "filename": "zlib/nt/zlib.dnt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2Fzlib.dnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fnt%2Fzlib.dnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2Fzlib.dnt?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,47 @@\n+LIBRARY\t\tzlib.dll\n+EXETYPE WINDOWS\n+CODE\t\t PRELOAD MOVEABLE DISCARDABLE\n+DATA\t\t PRELOAD MOVEABLE MULTIPLE\n+\n+EXPORTS\n+    adler32                        @1\n+    compress                       @2\n+    crc32                          @3\n+    deflate                        @4\n+    deflateCopy                    @5\n+    deflateEnd                     @6\n+    deflateInit2_                  @7\n+    deflateInit_                   @8\n+    deflateParams                  @9\n+    deflateReset                   @10\n+    deflateSetDictionary           @11\n+    gzclose                        @12\n+    gzdopen                        @13\n+    gzerror                        @14\n+    gzflush                        @15\n+    gzopen                         @16\n+    gzread                         @17\n+    gzwrite                        @18\n+    inflate                        @19\n+    inflateEnd                     @20\n+    inflateInit2_                  @21\n+    inflateInit_                   @22\n+    inflateReset                   @23\n+    inflateSetDictionary           @24\n+    inflateSync                    @25\n+    uncompress                     @26\n+    zlibVersion                    @27\n+    gzprintf                       @28\n+    gzputc                         @29\n+    gzgetc                         @30\n+    gzseek                         @31\n+    gzrewind                       @32\n+    gztell                         @33\n+    gzeof                          @34\n+    gzsetparams                    @35\n+    zError                         @36\n+    inflateSyncPoint               @37\n+    get_crc_table                  @38\n+    compress2                      @39\n+    gzputs                         @40\n+    gzgets                         @41"}, {"sha": "4f569471ecab93be6d411066c7dc3ed647ec04cc", "filename": "zlib/os2/Makefile.os2", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fos2%2FMakefile.os2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fos2%2FMakefile.os2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2FMakefile.os2?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,136 @@\n+# Makefile for zlib under OS/2 using GCC (PGCC)\n+# For conditions of distribution and use, see copyright notice in zlib.h \n+\n+# To compile and test, type:\n+#   cp Makefile.os2 ..\n+#   cd ..\n+#   make -f Makefile.os2 test\n+\n+# This makefile will build a static library z.lib, a shared library\n+# z.dll and a import library zdll.lib. You can use either z.lib or\n+# zdll.lib by specifying either -lz or -lzdll on gcc's command line\n+\n+CC=gcc -Zomf -s\n+\n+CFLAGS=-O6 -Wall\n+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n+#CFLAGS=-g -DDEBUG\n+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n+#           -Wstrict-prototypes -Wmissing-prototypes\n+\n+#################### BUG WARNING: #####################\n+## infcodes.c hits a bug in pgcc-1.0, so you have to use either\n+## -O# where # <= 4 or one of (-fno-ommit-frame-pointer or -fno-force-mem)\n+## This bug is reportedly fixed in pgcc >1.0, but this was not tested\n+CFLAGS+=-fno-force-mem\n+\n+LDFLAGS=-s -L. -lzdll -Zcrtdll\n+LDSHARED=$(CC) -s -Zomf -Zdll -Zcrtdll\n+\n+VER=1.1.0\n+ZLIB=z.lib\n+SHAREDLIB=z.dll\n+SHAREDLIBIMP=zdll.lib\n+LIBS=$(ZLIB) $(SHAREDLIB) $(SHAREDLIBIMP)\n+\n+AR=emxomfar cr\n+IMPLIB=emximp\n+RANLIB=echo\n+TAR=tar\n+SHELL=bash\n+\n+prefix=/usr/local\n+exec_prefix = $(prefix)\n+\n+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+\n+TEST_OBJS = example.o minigzip.o\n+\n+DISTFILES = README INDEX ChangeLog configure Make*[a-z0-9] *.[ch] descrip.mms \\\n+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \\\n+  nt/Makefile.nt nt/zlib.dnt  contrib/README.contrib contrib/*.txt \\\n+  contrib/asm386/*.asm contrib/asm386/*.c \\\n+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/iostream/*.cpp \\\n+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \\\n+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32\n+\n+all: example.exe minigzip.exe\n+\n+test: all\n+\t@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \\\n+\techo hello world | ./minigzip | ./minigzip -d || \\\n+\t  echo '\t\t*** minigzip test FAILED ***' ; \\\n+\tif ./example; then \\\n+\t  echo '\t\t*** zlib test OK ***'; \\\n+\telse \\\n+\t  echo '\t\t*** zlib test FAILED ***'; \\\n+\tfi\n+\n+$(ZLIB): $(OBJS)\n+\t$(AR) $@ $(OBJS)\n+\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n+\n+$(SHAREDLIB): $(OBJS) os2/z.def\n+\t$(LDSHARED) -o $@ $^\n+\n+$(SHAREDLIBIMP): os2/z.def\n+\t$(IMPLIB) -o $@ $^\n+\n+example.exe: example.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)\n+\n+minigzip.exe: minigzip.o $(LIBS)\n+\t$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)\n+\n+clean:\n+\trm -f *.o *~ example minigzip libz.a libz.so* foo.gz\n+\n+distclean:\tclean\n+\n+zip:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c\n+\tv=`sed -n -e 's/\\.//g' -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\tzip -ul9 zlib$$v $(DISTFILES)\n+\tmv Makefile~ Makefile\n+\n+dist:\n+\tmv Makefile Makefile~; cp -p Makefile.in Makefile\n+\trm -f test.c ztest*.c\n+\td=zlib-`sed -n '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < zlib.h`;\\\n+\trm -f $$d.tar.gz; \\\n+\tif test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \\\n+\tfiles=\"\"; \\\n+\tfor f in $(DISTFILES); do files=\"$$files $$d/$$f\"; done; \\\n+\tcd ..; \\\n+\tGZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \\\n+\tif test ! -d $$d; then rm -f $$d; fi\n+\tmv Makefile~ Makefile\n+\n+tags:\t\n+\tetags *.[ch]\n+\n+depend:\n+\tmakedepend -- $(CFLAGS) -- *.[ch]\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+adler32.o: zlib.h zconf.h\n+compress.o: zlib.h zconf.h\n+crc32.o: zlib.h zconf.h\n+deflate.o: deflate.h zutil.h zlib.h zconf.h\n+example.o: zlib.h zconf.h\n+gzio.o: zutil.h zlib.h zconf.h\n+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h\n+infcodes.o: zutil.h zlib.h zconf.h\n+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h\n+inffast.o: infblock.h infcodes.h infutil.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n+minigzip.o:  zlib.h zconf.h \n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n+uncompr.o: zlib.h zconf.h\n+zutil.o: zutil.h zlib.h zconf.h  "}, {"sha": "4c753f1a3b993842030429bbdeccdb48f8a86ebe", "filename": "zlib/os2/zlib.def", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fos2%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fos2%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2Fzlib.def?ref=c45f211ee347bc648b183c5123498c5b7310bb0e", "patch": "@@ -0,0 +1,51 @@\n+;\n+; Slightly modified version of ../nt/zlib.dnt :-)\n+;\n+\n+LIBRARY\t\tZ\n+DESCRIPTION\t\"Zlib compression library for OS/2\"\n+CODE\t\tPRELOAD MOVEABLE DISCARDABLE\n+DATA\t\tPRELOAD MOVEABLE MULTIPLE\n+\n+EXPORTS\n+    adler32\n+    compress\n+    crc32\n+    deflate\n+    deflateCopy\n+    deflateEnd\n+    deflateInit2_\n+    deflateInit_\n+    deflateParams\n+    deflateReset\n+    deflateSetDictionary\n+    gzclose\n+    gzdopen\n+    gzerror\n+    gzflush\n+    gzopen\n+    gzread\n+    gzwrite\n+    inflate\n+    inflateEnd\n+    inflateInit2_\n+    inflateInit_\n+    inflateReset\n+    inflateSetDictionary\n+    inflateSync\n+    uncompress\n+    zlibVersion\n+    gzprintf\n+    gzputc\n+    gzgetc\n+    gzseek\n+    gzrewind\n+    gztell\n+    gzeof\n+    gzsetparams\n+    zError\n+    inflateSyncPoint\n+    get_crc_table\n+    compress2\n+    gzputs\n+    gzgets"}, {"sha": "f01fb30d85515b8b74b997d826c01f10fd45a635", "filename": "zlib/trees.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Ftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Ftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftrees.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "72facf900f7787e26fe05781e08ecf26b42fbd3a", "filename": "zlib/trees.h", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Ftrees.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Ftrees.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftrees.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "d1033213781eecf2dbd78f088b03845c5c13c085", "filename": "zlib/uncompr.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Funcompr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Funcompr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Funcompr.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "6d450fc793dd867c5d4bf3966f316775bff32469", "filename": "zlib/zconf.h", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzconf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzconf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "25c8495d25f1fd566305f221ce4826bc43eeaafc", "filename": "zlib/zlib.3", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzlib.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzlib.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.3?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "49f56b43bc6c5bc89b103c4760a23330d6525086", "filename": "zlib/zlib.h", "status": "added", "additions": 893, "deletions": 0, "changes": 893, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "b3de4e8837023d2d05756b62895efbe849e45189", "filename": "zlib/zutil.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.c?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}, {"sha": "6f2cb97ca11ff23c92c0e7a84079d6494ce81669", "filename": "zlib/zutil.h", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45f211ee347bc648b183c5123498c5b7310bb0e/zlib%2Fzutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.h?ref=c45f211ee347bc648b183c5123498c5b7310bb0e"}]}