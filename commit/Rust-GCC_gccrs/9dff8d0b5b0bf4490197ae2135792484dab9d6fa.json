{"sha": "9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmZjhkMGI1YjBiZjQ0OTAxOTdhZTIxMzU3OTI0ODRkYWI5ZDZmYQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-07-08T09:14:24Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-07-08T09:14:24Z"}, "message": "[ARM] Initialise cost to COSTS_N_INSNS (1) and increment in arm rtx costs\n\n\t* config/arm/arm.c (arm_new_rtx_costs): Initialise cost to\n\tCOSTS_N_INSNS (1) and increment it appropriately throughout the\n\tfunction.\n\nFrom-SVN: r225537", "tree": {"sha": "d035aba494f5bc6360c12040682920bbe8f5f39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d035aba494f5bc6360c12040682920bbe8f5f39f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dff8d0b5b0bf4490197ae2135792484dab9d6fa/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d1e4f66cf99e6ca1f039cef62ef305918ff9e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d1e4f66cf99e6ca1f039cef62ef305918ff9e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d1e4f66cf99e6ca1f039cef62ef305918ff9e61"}], "stats": {"total": 131, "additions": 45, "deletions": 86}, "files": [{"sha": "796706cafe7ce9f1599ba4113c5939fa26d04ca8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff8d0b5b0bf4490197ae2135792484dab9d6fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff8d0b5b0bf4490197ae2135792484dab9d6fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "patch": "@@ -1,3 +1,9 @@\n+2015-07-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/arm.c (arm_new_rtx_costs): Initialise cost to\n+\tCOSTS_N_INSNS (1) and increment it appropriately throughout the\n+\tfunction.\n+\n 2015-07-08  Richard Biener  <rguenther@suse.de>\n \n \t* fold-const.c (fold_widened_comparison): Fix inverted comparison."}, {"sha": "16bda3b2ed8a074daa14bd3ff45505ed46808512", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 39, "deletions": 86, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dff8d0b5b0bf4490197ae2135792484dab9d6fa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dff8d0b5b0bf4490197ae2135792484dab9d6fa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9dff8d0b5b0bf4490197ae2135792484dab9d6fa", "patch": "@@ -9355,7 +9355,6 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)\n     case UNSPEC_VRINTR:\n     case UNSPEC_VRINTX:\n     case UNSPEC_VRINTA:\n-      *cost = COSTS_N_INSNS (1);\n       if (speed_p)\n         *cost += extra_cost->fp[GET_MODE (x) == DFmode].roundint;\n \n@@ -9418,6 +9417,8 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n {\n   machine_mode mode = GET_MODE (x);\n \n+  *cost = COSTS_N_INSNS (1);\n+\n   if (TARGET_THUMB1)\n     {\n       if (speed_p)\n@@ -9519,8 +9520,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       bool is_ldm = load_multiple_operation (x, SImode);\n       bool is_stm = store_multiple_operation (x, SImode);\n \n-      *cost = COSTS_N_INSNS (1);\n-\n       if (is_ldm || is_stm)\n         {\n \t  if (speed_p)\n@@ -9547,10 +9546,10 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case UDIV:\n       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t*cost = COSTS_N_INSNS (speed_p\n-\t\t\t       ? extra_cost->fp[mode != SFmode].div : 1);\n+\t*cost += COSTS_N_INSNS (speed_p\n+\t\t\t       ? extra_cost->fp[mode != SFmode].div : 0);\n       else if (mode == SImode && TARGET_IDIV)\n-\t*cost = COSTS_N_INSNS (speed_p ? extra_cost->mult[0].idiv : 1);\n+\t*cost += COSTS_N_INSNS (speed_p ? extra_cost->mult[0].idiv : 0);\n       else\n \t*cost = LIBCALL_COST (2);\n       return false;\t/* All arguments must be in registers.  */\n@@ -9563,7 +9562,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case ROTATE:\n       if (mode == SImode && REG_P (XEXP (x, 1)))\n \t{\n-\t  *cost = (COSTS_N_INSNS (2)\n+\t  *cost += (COSTS_N_INSNS (1)\n \t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.shift_reg;\n@@ -9576,16 +9575,15 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case ASHIFTRT:\n       if (mode == DImode && CONST_INT_P (XEXP (x, 1)))\n \t{\n-\t  *cost = (COSTS_N_INSNS (3)\n+\t  *cost += (COSTS_N_INSNS (2)\n \t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n \t  return true;\n \t}\n       else if (mode == SImode)\n \t{\n-\t  *cost = (COSTS_N_INSNS (1)\n-\t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n+\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t  /* Slightly disparage register shifts at -Os, but not by much.  */\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    *cost += (speed_p ? extra_cost->alu.shift_reg : 1\n@@ -9597,8 +9595,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  if (code == ASHIFT)\n \t    {\n-\t      *cost = (COSTS_N_INSNS (1)\n-\t\t       + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t      /* Slightly disparage register shifts at -Os, but not by\n \t         much.  */\n \t      if (!CONST_INT_P (XEXP (x, 1)))\n@@ -9610,14 +9607,13 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (arm_arch_thumb2 && CONST_INT_P (XEXP (x, 1)))\n \t\t{\n \t\t  /* Can use SBFX/UBFX.  */\n-\t\t  *cost = COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.bfx;\n \t\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t\t}\n \t      else\n \t\t{\n-\t\t  *cost = COSTS_N_INSNS (2);\n+\t\t  *cost += COSTS_N_INSNS (1);\n \t\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t\t  if (speed_p)\n \t\t    {\n@@ -9634,7 +9630,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t    }\n \t  else /* Rotates.  */\n \t    {\n-\t      *cost = COSTS_N_INSNS (3 + !CONST_INT_P (XEXP (x, 1)));\n+\t      *cost = COSTS_N_INSNS (2 + !CONST_INT_P (XEXP (x, 1)));\n \t      *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t      if (speed_p)\n \t\t{\n@@ -9658,7 +9654,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n         {\n           if (mode == SImode)\n             {\n-              *cost = COSTS_N_INSNS (1);\n               if (speed_p)\n                 *cost += extra_cost->alu.rev;\n \n@@ -9671,7 +9666,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n            and thumb_legacy_rev for the form of RTL used then.  */\n           if (TARGET_THUMB)\n             {\n-              *cost = COSTS_N_INSNS (10);\n+              *cost += COSTS_N_INSNS (9);\n \n               if (speed_p)\n                 {\n@@ -9681,7 +9676,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n             }\n           else\n             {\n-              *cost = COSTS_N_INSNS (5);\n+              *cost += COSTS_N_INSNS (4);\n \n               if (speed_p)\n                 {\n@@ -9698,7 +9693,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (GET_CODE (XEXP (x, 0)) == MULT\n \t      || GET_CODE (XEXP (x, 1)) == MULT)\n \t    {\n@@ -9743,8 +9737,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  rtx shift_op;\n \t  rtx non_shift_op;\n \n-\t  *cost = COSTS_N_INSNS (1);\n-\n \t  shift_op = shifter_op_p (XEXP (x, 0), &shift_by_reg);\n \t  if (shift_op == NULL)\n \t    {\n@@ -9812,7 +9804,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  HANDLE_NARROW_SHIFT_ARITH (MINUS, 1)\n \n \t  /* Slightly disparage, as we might need to widen the result.  */\n-\t  *cost = 1 + COSTS_N_INSNS (1);\n+\t  *cost += 1;\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \n@@ -9827,7 +9819,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n       if (mode == DImode)\n \t{\n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \n \t  if (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND)\n \t    {\n@@ -9882,7 +9874,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (GET_CODE (XEXP (x, 0)) == MULT)\n \t    {\n \t      rtx mul_op0, mul_op1, add_op;\n@@ -9939,7 +9930,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n \t  /* Slightly penalize a narrow operation as the result may\n \t     need widening.  */\n-\t  *cost = 1 + COSTS_N_INSNS (1);\n+\t  *cost += 1;\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \n@@ -9950,7 +9941,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  rtx shift_op, shift_reg;\n \n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (TARGET_INT_SIMD\n \t      && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n \t\t  || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n@@ -9985,8 +9975,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t    {\n \t      rtx mul_op = XEXP (x, 0);\n \n-\t      *cost = COSTS_N_INSNS (1);\n-\n \t      if (TARGET_DSP_MULTIPLY\n \t\t  && ((GET_CODE (XEXP (mul_op, 0)) == SIGN_EXTEND\n \t\t       && (GET_CODE (XEXP (mul_op, 1)) == SIGN_EXTEND\n@@ -10046,7 +10034,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  || (GET_CODE (XEXP (XEXP (x, 0), 0)) == SIGN_EXTEND\n \t\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == SIGN_EXTEND)))\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[1].extend_add;\n \t      *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), mode,\n@@ -10057,7 +10044,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      return true;\n \t    }\n \n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \n \t  if (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n \t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n@@ -10085,7 +10072,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case IOR:\n       if (mode == SImode && arm_arch6 && aarch_rev16_p (x))\n         {\n-          *cost = COSTS_N_INSNS (1);\n           if (speed_p)\n             *cost += extra_cost->alu.rev;\n \n@@ -10099,8 +10085,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  rtx op0 = XEXP (x, 0);\n \t  rtx shift_op, shift_reg;\n \n-\t  *cost = COSTS_N_INSNS (1);\n-\n \t  if (subcode == NOT\n \t      && (code == AND\n \t\t  || (code == IOR && TARGET_THUMB2)))\n@@ -10149,7 +10133,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  rtx op0 = XEXP (x, 0);\n \t  enum rtx_code subcode = GET_CODE (op0);\n \n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \n \t  if (subcode == NOT\n \t      && (code == AND\n@@ -10193,8 +10177,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  rtx op0 = XEXP (x, 0);\n \n-\t  *cost = COSTS_N_INSNS (1);\n-\n \t  if (GET_CODE (op0) == NEG)\n \t    op0 = XEXP (op0, 0);\n \n@@ -10213,7 +10195,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n       if (mode == SImode)\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (TARGET_DSP_MULTIPLY\n \t      && ((GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n \t\t   && (GET_CODE (XEXP (x, 1)) == SIGN_EXTEND\n@@ -10249,7 +10230,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  || (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n \t\t      && GET_CODE (XEXP (x, 1)) == SIGN_EXTEND)))\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[1].extend;\n \t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode,\n@@ -10271,7 +10251,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode != SFmode].neg;\n \n@@ -10287,7 +10266,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == ABS)\n \t    {\n-\t      *cost = COSTS_N_INSNS (2);\n+\t      *cost += COSTS_N_INSNS (1);\n \t      /* Assume the non-flag-changing variant.  */\n \t      if (speed_p)\n \t\t*cost += (extra_cost->alu.log_shift\n@@ -10299,7 +10278,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMPARE\n \t      || GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMM_COMPARE)\n \t    {\n-\t      *cost = COSTS_N_INSNS (2);\n+\t      *cost += COSTS_N_INSNS (1);\n \t      /* No extra cost for MOV imm and MVN imm.  */\n \t      /* If the comparison op is using the flags, there's no further\n \t\t cost, otherwise we need to add the cost of the comparison.  */\n@@ -10318,7 +10297,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t}\n \t      return true;\n \t    }\n-\t  *cost = COSTS_N_INSNS (1);\n+\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \t  return false;\n@@ -10328,15 +10307,15 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  && GET_MODE_SIZE (mode) < 4)\n \t{\n \t  /* Slightly disparage, as we might need an extend operation.  */\n-\t  *cost = 1 + COSTS_N_INSNS (1);\n+\t  *cost += 1;\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.arith;\n \t  return false;\n \t}\n \n       if (mode == DImode)\n \t{\n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.arith;\n \t  return false;\n@@ -10352,7 +10331,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  rtx shift_op;\n \t  rtx shift_reg = NULL;\n \n-\t  *cost = COSTS_N_INSNS (1);\n \t  shift_op = shifter_op_p (XEXP (x, 0), &shift_reg);\n \n \t  if (shift_op)\n@@ -10375,7 +10353,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t}\n       if (mode == DImode)\n \t{\n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \t  return false;\n \t}\n \n@@ -10388,7 +10366,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       {\n         if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n \t  {\n-\t    *cost = COSTS_N_INSNS (4);\n+\t    *cost += COSTS_N_INSNS (3);\n \t    return true;\n \t  }\n \tint op1cost = rtx_cost (XEXP (x, 1), mode, SET, 1, speed_p);\n@@ -10431,7 +10409,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (TARGET_HARD_FLOAT && GET_MODE_CLASS (op0mode) == MODE_FLOAT\n \t      && (op0mode == SFmode || !TARGET_VFP_SINGLE))\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->fp[op0mode != SFmode].compare;\n \n@@ -10452,7 +10429,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  /* DImode compares normally take two insns.  */\n \t  if (op0mode == DImode)\n \t    {\n-\t      *cost = COSTS_N_INSNS (2);\n+\t      *cost += COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += 2 * extra_cost->alu.arith;\n \t      return false;\n@@ -10490,7 +10467,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      shift_op = shifter_op_p (XEXP (x, 0), &shift_reg);\n \t      if (shift_op != NULL)\n \t\t{\n-\t\t  *cost = COSTS_N_INSNS (1);\n \t\t  if (shift_reg != NULL)\n \t\t    {\n \t\t      *cost += rtx_cost (shift_reg, op0mode, ASHIFT,\n@@ -10505,7 +10481,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  return true;\n \t\t}\n \n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->alu.arith;\n \t      if (CONST_INT_P (XEXP (x, 1))\n@@ -10549,7 +10524,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      && XEXP (x, 1) == const0_rtx)\n \t    {\n \t      /* Thumb also needs an IT insn.  */\n-\t      *cost = COSTS_N_INSNS (TARGET_THUMB ? 3 : 2);\n+\t      *cost += COSTS_N_INSNS (TARGET_THUMB ? 2 : 1);\n \t      return true;\n \t    }\n \t  if (XEXP (x, 1) == const0_rtx)\n@@ -10558,7 +10533,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t{\n \t\tcase LT:\n \t\t  /* LSR Rd, Rn, #31.  */\n-\t\t  *cost = COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.shift;\n \t\t  break;\n@@ -10570,21 +10544,21 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\tcase NE:\n \t\t  /* SUBS T1, Rn, #1\n \t\t     SBC  Rd, Rn, T1.  */\n-\t\t  *cost = COSTS_N_INSNS (2);\n+\t\t  *cost += COSTS_N_INSNS (1);\n \t\t  break;\n \n \t\tcase LE:\n \t\t  /* RSBS T1, Rn, Rn, LSR #31\n \t\t     ADC  Rd, Rn, T1. */\n-\t\t  *cost = COSTS_N_INSNS (2);\n+\t\t  *cost += COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.arith_shift;\n \t\t  break;\n \n \t\tcase GT:\n \t\t  /* RSB  Rd, Rn, Rn, ASR #1\n \t\t     LSR  Rd, Rd, #31.  */\n-\t\t  *cost = COSTS_N_INSNS (2);\n+\t\t  *cost += COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += (extra_cost->alu.arith_shift\n \t\t\t      + extra_cost->alu.shift);\n@@ -10593,7 +10567,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\tcase GE:\n \t\t  /* ASR  Rd, Rn, #31\n \t\t     ADD  Rd, Rn, #1.  */\n-\t\t  *cost = COSTS_N_INSNS (2);\n+\t\t  *cost += COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.shift;\n \t\t  break;\n@@ -10609,7 +10583,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t    }\n \t  else\n \t    {\n-\t      *cost = COSTS_N_INSNS (TARGET_THUMB ? 4 : 3);\n+\t      *cost += COSTS_N_INSNS (TARGET_THUMB ? 3 : 2);\n \t      if (CONST_INT_P (XEXP (x, 1))\n \t\t  && const_ok_for_op (INTVAL (XEXP (x, 1)), COMPARE))\n \t\t{\n@@ -10637,7 +10611,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode != SFmode].neg;\n \n@@ -10651,7 +10624,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n       if (mode == SImode)\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.log_shift + extra_cost->alu.arith_shift;\n \t  return false;\n@@ -10687,15 +10659,14 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (GET_MODE (XEXP (x, 0)) != SImode && arm_arch6)\n \t{\n \t  /* We have SXTB/SXTH.  */\n-\t  *cost = COSTS_N_INSNS (1);\n \t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.extend;\n \t}\n       else if (GET_MODE (XEXP (x, 0)) != SImode)\n \t{\n \t  /* Needs two shifts.  */\n-\t  *cost = COSTS_N_INSNS (2);\n+\t  *cost += COSTS_N_INSNS (1);\n \t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n@@ -10733,14 +10704,12 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t     optimizing for speed it should never be slower to use\n \t     AND, and we don't really model 16-bit vs 32-bit insns\n \t     here.  */\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.logical;\n \t}\n       else if (GET_MODE (XEXP (x, 0)) != SImode && arm_arch6)\n \t{\n \t  /* We have UXTB/UXTH.  */\n-\t  *cost = COSTS_N_INSNS (1);\n \t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.extend;\n@@ -10756,8 +10725,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n \t}\n-      else  /* GET_MODE (XEXP (x, 0)) == SImode.  */\n-        *cost = COSTS_N_INSNS (1);\n \n       /* Widening beyond 32-bits requires one more insn.  */\n       if (mode == DImode)\n@@ -10815,12 +10782,12 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (speed_p)\n \t{\n \t  if (arm_arch_thumb2 && !flag_pic)\n-\t    *cost = COSTS_N_INSNS (2);\n+\t    *cost += COSTS_N_INSNS (1);\n \t  else\n-\t    *cost = COSTS_N_INSNS (1) + extra_cost->ldst.load;\n+\t    *cost += extra_cost->ldst.load;\n \t}\n       else\n-\t*cost = COSTS_N_INSNS (2);\n+\t*cost += COSTS_N_INSNS (1);\n \n       if (flag_pic)\n \t{\n@@ -10842,22 +10809,20 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  if (vfp3_const_double_rtx (x))\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->fp[mode == DFmode].fpconst;\n \t      return true;\n \t    }\n \n \t  if (speed_p)\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (mode == DFmode)\n \t\t*cost += extra_cost->ldst.loadd;\n \t      else\n \t\t*cost += extra_cost->ldst.loadf;\n \t    }\n \t  else\n-\t    *cost = COSTS_N_INSNS (2 + (mode == DFmode));\n+\t    *cost += COSTS_N_INSNS (1 + (mode == DFmode));\n \n \t  return true;\n \t}\n@@ -10877,23 +10842,20 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n     case HIGH:\n     case LO_SUM:\n-      *cost = COSTS_N_INSNS (1);\n       /* When optimizing for size, we prefer constant pool entries to\n \t MOVW/MOVT pairs, so bump the cost of these slightly.  */\n       if (!speed_p)\n \t*cost += 1;\n       return true;\n \n     case CLZ:\n-      *cost = COSTS_N_INSNS (1);\n       if (speed_p)\n \t*cost += extra_cost->alu.clz;\n       return false;\n \n     case SMIN:\n       if (XEXP (x, 1) == const0_rtx)\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.log_shift;\n \t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n@@ -10903,7 +10865,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case SMAX:\n     case UMIN:\n     case UMAX:\n-      *cost = COSTS_N_INSNS (2);\n+      *cost += COSTS_N_INSNS (1);\n       return false;\n \n     case TRUNCATE:\n@@ -10917,7 +10879,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t\t      == ZERO_EXTEND))))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->mult[1].extend;\n \t  *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), VOIDmode,\n@@ -10948,14 +10909,13 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && CONST_INT_P (XEXP (x, 2)))\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.bfx;\n \t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t  return true;\n \t}\n       /* Without UBFX/SBFX, need to resort to shift operations.  */\n-      *cost = COSTS_N_INSNS (2);\n+      *cost += COSTS_N_INSNS (1);\n       if (speed_p)\n \t*cost += 2 * extra_cost->alu.shift;\n       *cost += rtx_cost (XEXP (x, 0), mode, ASHIFT, 0, speed_p);\n@@ -10964,7 +10924,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case FLOAT_EXTEND:\n       if (TARGET_HARD_FLOAT)\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode == DFmode].widen;\n \t  if (!TARGET_FPU_ARMV8\n@@ -10986,7 +10945,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case FLOAT_TRUNCATE:\n       if (TARGET_HARD_FLOAT)\n \t{\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode == DFmode].narrow;\n \t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n@@ -11003,7 +10961,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n           rtx op1 = XEXP (x, 1);\n           rtx op2 = XEXP (x, 2);\n \n-          *cost = COSTS_N_INSNS (1);\n \n           /* vfms or vfnma.  */\n           if (GET_CODE (op0) == NEG)\n@@ -11032,7 +10989,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  if (GET_MODE_CLASS (mode) == MODE_INT)\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      mode = GET_MODE (XEXP (x, 0));\n \t      if (speed_p)\n \t\t*cost += extra_cost->fp[mode == DFmode].toint;\n@@ -11049,7 +11005,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t\t   && TARGET_FPU_ARMV8)\n \t    {\n-\t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->fp[mode == DFmode].roundint;\n \t      return false;\n@@ -11065,7 +11020,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  /* ??? Increase the cost to deal with transferring from CORE\n \t     -> FP registers?  */\n-\t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode == DFmode].fromint;\n \t  return false;\n@@ -11074,7 +11028,6 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case CALL:\n-      *cost = COSTS_N_INSNS (1);\n       return true;\n \n     case ASM_OPERANDS:"}]}