{"sha": "d9175b871cddac9b9d3c7216bf3a8f665539d782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxNzViODcxY2RkYWM5YjlkM2M3MjE2YmYzYThmNjY1NTM5ZDc4Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-04-01T01:40:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-04-01T01:40:43Z"}, "message": "hashtab.c (htab_size): Move to top of file; mark inline.\n\n        * hashtab.c (htab_size): Move to top of file; mark inline.\n        (htab_elements): Likewise.\n        (htab_mod, htab_mod_m2): New.\n        (htab_delete): Refactor htab->size and htab->entries.\n        (htab_empty): Likewise.\n        (find_empty_slot_for_expand): Use htab_size, htab_mod, htab_mod_m2.\n        (htab_find_with_hash, htab_find_slot_with_hash): Likewise.\n        (htab_clear_slot): Use htab_size, htab_elements.\n        (htab_traverse_noresize, htab_traverse): Likewise.\n\nFrom-SVN: r80278", "tree": {"sha": "6621dae6302a88c77859f3d2bab1c1eb7c59a27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6621dae6302a88c77859f3d2bab1c1eb7c59a27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9175b871cddac9b9d3c7216bf3a8f665539d782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9175b871cddac9b9d3c7216bf3a8f665539d782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9175b871cddac9b9d3c7216bf3a8f665539d782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9175b871cddac9b9d3c7216bf3a8f665539d782/comments", "author": null, "committer": null, "parents": [{"sha": "2cbf9f609b249ed4fd6ddc56194ff84be680e6de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbf9f609b249ed4fd6ddc56194ff84be680e6de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbf9f609b249ed4fd6ddc56194ff84be680e6de"}], "stats": {"total": 132, "additions": 83, "deletions": 49}, "files": [{"sha": "661ca4b45b98deb813acfa5236cbcaeaf96d373e", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9175b871cddac9b9d3c7216bf3a8f665539d782/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9175b871cddac9b9d3c7216bf3a8f665539d782/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d9175b871cddac9b9d3c7216bf3a8f665539d782", "patch": "@@ -1,3 +1,15 @@\n+2004-03-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* hashtab.c (htab_size): Move to top of file; mark inline.\n+\t(htab_elements): Likewise.\n+\t(htab_mod, htab_mod_m2): New.\n+\t(htab_delete): Refactor htab->size and htab->entries.\n+\t(htab_empty): Likewise.\n+\t(find_empty_slot_for_expand): Use htab_size, htab_mod, htab_mod_m2.\n+\t(htab_find_with_hash, htab_find_slot_with_hash): Likewise.\n+\t(htab_clear_slot): Use htab_size, htab_elements.\n+\t(htab_traverse_noresize, htab_traverse): Likewise.\n+\n 2004-03-17  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* pex-unix.c (pexecute): Use vfork instead of fork, with"}, {"sha": "f7751664f04fd8e83e5db54bf1b05c4d49ac2162", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 71, "deletions": 49, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9175b871cddac9b9d3c7216bf3a8f665539d782/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9175b871cddac9b9d3c7216bf3a8f665539d782/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=d9175b871cddac9b9d3c7216bf3a8f665539d782", "patch": "@@ -159,6 +159,44 @@ eq_pointer (p1, p2)\n   return p1 == p2;\n }\n \n+/* Return the current size of given hash table. */\n+\n+inline size_t\n+htab_size (htab)\n+     htab_t htab;\n+{\n+  return htab->size;\n+}\n+\n+/* Return the current number of elements in given hash table. */\n+\n+inline size_t\n+htab_elements (htab)\n+     htab_t htab;\n+{\n+  return htab->n_elements - htab->n_deleted;\n+}\n+\n+/* Compute the primary hash for HASH given HTAB's current size.  */\n+\n+static inline hashval_t\n+htab_mod (hash, htab)\n+     hashval_t hash;\n+     htab_t htab;\n+{\n+  return hash % htab_size (htab);\n+}\n+\n+/* Compute the secondary hash for HASH given HTAB's current size.  */\n+\n+static inline hashval_t\n+htab_mod_m2 (hash, htab)\n+     hashval_t hash;\n+     htab_t htab;\n+{\n+  return 1 + hash % (htab_size (htab) - 2);\n+}\n+\n /* This function creates table with length slightly longer than given\n    source length.  Created hash table is initiated as empty (all the\n    hash table entries are EMPTY_ENTRY).  The function returns the\n@@ -282,22 +320,23 @@ void\n htab_delete (htab)\n      htab_t htab;\n {\n+  size_t size = htab_size (htab);\n+  PTR *entries = htab->entries;\n   int i;\n \n   if (htab->del_f)\n-    for (i = htab->size - 1; i >= 0; i--)\n-      if (htab->entries[i] != EMPTY_ENTRY\n-\t  && htab->entries[i] != DELETED_ENTRY)\n-\t(*htab->del_f) (htab->entries[i]);\n+    for (i = size - 1; i >= 0; i--)\n+      if (entries[i] != EMPTY_ENTRY && entries[i] != DELETED_ENTRY)\n+\t(*htab->del_f) (entries[i]);\n \n   if (htab->free_f != NULL)\n     {\n-      (*htab->free_f) (htab->entries);\n+      (*htab->free_f) (entries);\n       (*htab->free_f) (htab);\n     }\n   else if (htab->free_with_arg_f != NULL)\n     {\n-      (*htab->free_with_arg_f) (htab->alloc_arg, htab->entries);\n+      (*htab->free_with_arg_f) (htab->alloc_arg, entries);\n       (*htab->free_with_arg_f) (htab->alloc_arg, htab);\n     }\n }\n@@ -308,15 +347,16 @@ void\n htab_empty (htab)\n      htab_t htab;\n {\n+  size_t size = htab_size (htab);\n+  PTR *entries = htab->entries;\n   int i;\n \n   if (htab->del_f)\n-    for (i = htab->size - 1; i >= 0; i--)\n-      if (htab->entries[i] != EMPTY_ENTRY\n-\t  && htab->entries[i] != DELETED_ENTRY)\n-\t(*htab->del_f) (htab->entries[i]);\n+    for (i = size - 1; i >= 0; i--)\n+      if (entries[i] != EMPTY_ENTRY && entries[i] != DELETED_ENTRY)\n+\t(*htab->del_f) (entries[i]);\n \n-  memset (htab->entries, 0, htab->size * sizeof (PTR));\n+  memset (entries, 0, size * sizeof (PTR));\n }\n \n /* Similar to htab_find_slot, but without several unwanted side effects:\n@@ -331,8 +371,8 @@ find_empty_slot_for_expand (htab, hash)\n      htab_t htab;\n      hashval_t hash;\n {\n-  size_t size = htab->size;\n-  unsigned int index = hash % size;\n+  hashval_t index = htab_mod (hash, htab);\n+  size_t size = htab_size (htab);\n   PTR *slot = htab->entries + index;\n   hashval_t hash2;\n \n@@ -341,7 +381,7 @@ find_empty_slot_for_expand (htab, hash)\n   else if (*slot == DELETED_ENTRY)\n     abort ();\n \n-  hash2 = 1 + hash % (size - 2);\n+  hash2 = htab_mod_m2 (hash, htab);\n   for (;;)\n     {\n       index += hash2;\n@@ -431,22 +471,20 @@ htab_find_with_hash (htab, element, hash)\n      const PTR element;\n      hashval_t hash;\n {\n-  unsigned int index;\n-  hashval_t hash2;\n+  hashval_t index, hash2;\n   size_t size;\n   PTR entry;\n \n   htab->searches++;\n-  size = htab->size;\n-  index = hash % size;\n+  size = htab_size (htab);\n+  index = htab_mod (hash, htab);\n \n   entry = htab->entries[index];\n   if (entry == EMPTY_ENTRY\n       || (entry != DELETED_ENTRY && (*htab->eq_f) (entry, element)))\n     return entry;\n \n-  hash2 = 1 + hash % (size - 2);\n-\n+  hash2 = htab_mod_m2 (hash, htab);\n   for (;;)\n     {\n       htab->collisions++;\n@@ -488,17 +526,19 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n      enum insert_option insert;\n {\n   PTR *first_deleted_slot;\n-  unsigned int index;\n-  hashval_t hash2;\n+  hashval_t index, hash2;\n   size_t size;\n   PTR entry;\n \n-  if (insert == INSERT && htab->size * 3 <= htab->n_elements * 4\n-      && htab_expand (htab) == 0)\n-    return NULL;\n+  size = htab_size (htab);\n+  if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n+    {\n+      if (htab_expand (htab) == 0)\n+\treturn NULL;\n+      size = htab_size (htab);\n+    }\n \n-  size = htab->size;\n-  index = hash % size;\n+  index = htab_mod (hash, htab);\n \n   htab->searches++;\n   first_deleted_slot = NULL;\n@@ -511,7 +551,7 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n   else if ((*htab->eq_f) (entry, element))\n     return &htab->entries[index];\n       \n-  hash2 = 1 + hash % (size - 2);\n+  hash2 = htab_mod_m2 (hash, htab);\n   for (;;)\n     {\n       htab->collisions++;\n@@ -590,7 +630,7 @@ htab_clear_slot (htab, slot)\n      htab_t htab;\n      PTR *slot;\n {\n-  if (slot < htab->entries || slot >= htab->entries + htab->size\n+  if (slot < htab->entries || slot >= htab->entries + htab_size (htab)\n       || *slot == EMPTY_ENTRY || *slot == DELETED_ENTRY)\n     abort ();\n \n@@ -616,7 +656,7 @@ htab_traverse_noresize (htab, callback, info)\n   PTR *limit;\n \n   slot = htab->entries;\n-  limit = slot + htab->size;\n+  limit = slot + htab_size (htab);\n \n   do\n     {\n@@ -638,30 +678,12 @@ htab_traverse (htab, callback, info)\n      htab_trav callback;\n      PTR info;\n {\n-  if ((htab->n_elements - htab->n_deleted) * 8 < htab->size)\n+  if (htab_elements (htab) * 8 < htab_size (htab))\n     htab_expand (htab);\n \n   htab_traverse_noresize (htab, callback, info);\n }\n \n-/* Return the current size of given hash table. */\n-\n-size_t\n-htab_size (htab)\n-     htab_t htab;\n-{\n-  return htab->size;\n-}\n-\n-/* Return the current number of elements in given hash table. */\n-\n-size_t\n-htab_elements (htab)\n-     htab_t htab;\n-{\n-  return htab->n_elements - htab->n_deleted;\n-}\n-\n /* Return the fraction of fixed collisions during all work with given\n    hash table. */\n "}]}