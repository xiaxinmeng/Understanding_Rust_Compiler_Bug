{"sha": "a0ae8e8de301170f16a6ebb54c5ecb9067ae4375", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhZThlOGRlMzAxMTcwZjE2YTZlYmI1NGM1ZWNiOTA2N2FlNDM3NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-30T22:26:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-30T22:26:03Z"}, "message": "(add_insn_after): Abort if can't find AFTER and it has no NEXT_INSN.\n\n(add_insn_before): New function.\n(emit_{insn,insns,jump_insn,call_insn,barrier,note}_before): Call it.\n\nFrom-SVN: r8188", "tree": {"sha": "ff4ee8502d1472d0a0b4a3e6e0476396e275ad6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff4ee8502d1472d0a0b4a3e6e0476396e275ad6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375/comments", "author": null, "committer": null, "parents": [{"sha": "9086a9bc1ced017c2c70d5a44a4bc9d4bd36d274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9086a9bc1ced017c2c70d5a44a4bc9d4bd36d274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9086a9bc1ced017c2c70d5a44a4bc9d4bd36d274"}], "stats": {"total": 66, "additions": 56, "deletions": 10}, "files": [{"sha": "8a00d6b0498b35008dcb1450b69f93539aeb595b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ae8e8de301170f16a6ebb54c5ecb9067ae4375/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a0ae8e8de301170f16a6ebb54c5ecb9067ae4375", "patch": "@@ -2130,9 +2130,10 @@ add_insn (insn)\n   last_insn = insn;\n }\n \n-/* Add INSN into the doubly-linked list after insn AFTER.  This should be the\n-   only function called to insert an insn once delay slots have been filled\n-   since only it knows how to update a SEQUENCE.  */\n+/* Add INSN into the doubly-linked list after insn AFTER.  This and\n+   the next should be the only functions called to insert an insn once\n+   delay slots have been filled since only they knows how to update a\n+   SEQUENCE.  */\n \n void\n add_insn_after (insn, after)\n@@ -2158,6 +2159,9 @@ add_insn_after (insn, after)\n       for (; stack; stack = stack->next)\n \tif (after == stack->last)\n \t  stack->last = insn;\n+\n+      if (stack == 0)\n+\tabort ();\n     }\n \n   NEXT_INSN (after) = insn;\n@@ -2168,6 +2172,48 @@ add_insn_after (insn, after)\n     }\n }\n \n+/* Add INSN into the doubly-linked list before insn BEFORE.  This and\n+   the previous should be the only functions called to insert an insn once\n+   delay slots have been filled since only they knows how to update a\n+   SEQUENCE.  */\n+\n+void\n+add_insn_before (insn, before)\n+     rtx insn, before;\n+{\n+  rtx prev = PREV_INSN (before);\n+\n+  PREV_INSN (insn) = prev;\n+  NEXT_INSN (insn) = before;\n+\n+  if (prev)\n+    {\n+      NEXT_INSN (prev) = insn;\n+      if (GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\t{\n+\t  rtx sequence = PATTERN (prev);\n+\t  NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n+\t}\n+    }\n+  else if (first_insn == before)\n+    first_insn = insn;\n+  else\n+    {\n+      struct sequence_stack *stack = sequence_stack;\n+      /* Scan all pending sequences too.  */\n+      for (; stack; stack = stack->next)\n+\tif (before == stack->first)\n+\t  stack->first = insn;\n+\n+      if (stack == 0)\n+\tabort ();\n+    }\n+\n+  PREV_INSN (before) = insn;\n+  if (GET_CODE (before) == INSN && GET_CODE (PATTERN (before)) == SEQUENCE)\n+    PREV_INSN (XVECEXP (PATTERN (before), 0, 0)) = insn;\n+}\n+\n /* Delete all insns made since FROM.\n    FROM becomes the new last instruction.  */\n \n@@ -2279,15 +2325,15 @@ emit_insn_before (pattern, before)\n       for (i = 0; i < XVECLEN (pattern, 0); i++)\n \t{\n \t  insn = XVECEXP (pattern, 0, i);\n-\t  add_insn_after (insn, PREV_INSN (before));\n+\t  add_insn_before (insn, before);\n \t}\n       if (XVECLEN (pattern, 0) < SEQUENCE_RESULT_SIZE)\n \tsequence_result[XVECLEN (pattern, 0)] = pattern;\n     }\n   else\n     {\n       insn = make_insn_raw (pattern);\n-      add_insn_after (insn, PREV_INSN (before));\n+      add_insn_before (insn, before);\n     }\n \n   return insn;\n@@ -2307,7 +2353,7 @@ emit_jump_insn_before (pattern, before)\n   else\n     {\n       insn = make_jump_insn_raw (pattern);\n-      add_insn_after (insn, PREV_INSN (before));\n+      add_insn_before (insn, before);\n     }\n \n   return insn;\n@@ -2327,7 +2373,7 @@ emit_call_insn_before (pattern, before)\n   else\n     {\n       insn = make_call_insn_raw (pattern);\n-      add_insn_after (insn, PREV_INSN (before));\n+      add_insn_before (insn, before);\n       PUT_CODE (insn, CALL_INSN);\n     }\n \n@@ -2345,7 +2391,7 @@ emit_barrier_before (before)\n \n   INSN_UID (insn) = cur_insn_uid++;\n \n-  add_insn_after (insn, PREV_INSN (before));\n+  add_insn_before (insn, before);\n   return insn;\n }\n \n@@ -2361,7 +2407,7 @@ emit_note_before (subtype, before)\n   NOTE_SOURCE_FILE (note) = 0;\n   NOTE_LINE_NUMBER (note) = subtype;\n \n-  add_insn_after (note, PREV_INSN (before));\n+  add_insn_before (note, before);\n   return note;\n }\n \f\n@@ -2577,7 +2623,7 @@ emit_insns_before (insn, before)\n   while (insn)\n     {\n       rtx next = NEXT_INSN (insn);\n-      add_insn_after (insn, PREV_INSN (before));\n+      add_insn_before (insn, before);\n       last = insn;\n       insn = next;\n     }"}]}