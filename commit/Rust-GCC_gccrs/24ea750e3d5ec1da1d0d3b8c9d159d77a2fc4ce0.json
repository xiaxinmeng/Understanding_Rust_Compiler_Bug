{"sha": "24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRlYTc1MGUzZDVlYzFkYTFkMGQzYjhjOWQxNTlkNzdhMmZjNGNlMA==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2001-12-19T18:06:38Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2001-12-19T18:06:38Z"}, "message": "rs6000.h: LEGITIMIZE_RELOAD_ADDRESS: redefine in terms of rs6000_legitimize_reload_address().\n\n         * config/rs6000/rs6000.h: LEGITIMIZE_RELOAD_ADDRESS:\n         redefine in terms of rs6000_legitimize_reload_address().\n         * config/rs6000/rs6000-protos.h: Add this function.\n         * config/rs6000/rs6000.c: Add this function.  Includes\n         handling for Darwin FP constants.\n\nFrom-SVN: r48181", "tree": {"sha": "06fdc86eec621292a8af4b62aa5aec80f478aa9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06fdc86eec621292a8af4b62aa5aec80f478aa9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/comments", "author": null, "committer": null, "parents": [{"sha": "e476127441b636b9cb59ec5a7c09c112a92bcc01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e476127441b636b9cb59ec5a7c09c112a92bcc01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e476127441b636b9cb59ec5a7c09c112a92bcc01"}], "stats": {"total": 195, "additions": 145, "deletions": 50}, "files": [{"sha": "e5aa14daed1f2a85d362060977e97b15829ad00f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "patch": "@@ -1,3 +1,11 @@\n+2001-12-19  Dale Johannesen  <dalej@apple.com>\n+\n+\t * config/rs6000/rs6000.h: LEGITIMIZE_RELOAD_ADDRESS:\n+\t redefine in terms of rs6000_legitimize_reload_address().\n+\t * config/rs6000/rs6000-protos.h: Add this function.\n+\t * config/rs6000/rs6000.c: Add this function.  Includes\n+\t handling for Darwin FP constants.\n+\n Wed Dec 19 11:01:21 2001  Jeffrey A Law  (law@redhat.com)\n \n \t* config/pa/t-hpux-shlib: New file."}, {"sha": "c40689e9069c65e6b444357c4eda8bd808658304", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "patch": "@@ -114,6 +114,8 @@ extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern rtx rs6000_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n+\t\t\t    int, int, int, int *));\n extern int rs6000_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n extern void rs6000_select_rtx_section PARAMS ((enum machine_mode, rtx));\n "}, {"sha": "4a661fcbefaa918aecd9f32d77c588c728893f5c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\"\n+#include \"reload.h\"\n \n #ifndef TARGET_NO_PROTOTYPE\n #define TARGET_NO_PROTOTYPE 0\n@@ -1757,6 +1758,133 @@ rs6000_legitimize_address (x, oldx, mode)\n     return NULL_RTX;\n }\n \n+/* The convention appears to be to define this wherever it is used.\n+   With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P\n+   is now used here.  */\n+#ifndef REG_MODE_OK_FOR_BASE_P\n+#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n+#endif\n+\n+/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n+   replace the input X, or the original X if no replacement is called for.\n+   The output parameter *WIN is 1 if the calling macro should goto WIN,\n+   0 if it should not.\n+\n+   For RS/6000, we wish to handle large displacements off a base\n+   register by splitting the addend across an addiu/addis and the mem insn.\n+   This cuts number of extra insns needed from 3 to 1.\n+\n+   On Darwin, we use this to generate code for floating point constants.\n+   A movsf_low is generated so we wind up with 2 instructions rather than 3.\n+   The Darwin code is inside #if TARGET_MACHO because only then is\n+   machopic_function_base_name() defined.  */\n+rtx\n+rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n+    rtx x;\n+    enum machine_mode mode;\n+    int opnum;\n+    int type;\n+    int ind_levels ATTRIBUTE_UNUSED;\n+    int *win;\n+{\n+  /* We must recognize output that we have already generated ourselves.  */ \n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+                   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+                   opnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+#if TARGET_MACHO\n+  if (DEFAULT_ABI == ABI_DARWIN && flag_pic\n+      && GET_CODE (x) == LO_SUM\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && XEXP (XEXP (x, 0), 0) == pic_offset_table_rtx\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == HIGH\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 0)) == CONST\n+      && XEXP (XEXP (XEXP (x, 0), 1), 0) == XEXP (x, 1)\n+      && GET_CODE (XEXP (XEXP (x, 1), 0)) == MINUS\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 1)) == SYMBOL_REF)\n+    {\n+      /* Result of previous invocation of this function on Darwin\n+\t floating point constant. */\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\tBASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\topnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+#endif\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n+      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n+      HOST_WIDE_INT high\n+        = (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\n+      /* Check for 32-bit overflow.  */\n+      if (high + low != val)\n+        {\n+\t  *win = 0;\n+\t  return x;\n+\t}\n+\n+      /* Reload the high part into a base reg; leave the low part\n+         in the mem directly.  */\n+\n+      x = gen_rtx_PLUS (GET_MODE (x),\n+                        gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n+                                      GEN_INT (high)),\n+                        GEN_INT (low));\n+\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+                   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+                   opnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+#if TARGET_MACHO\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && DEFAULT_ABI == ABI_DARWIN\n+      && flag_pic)\n+    {\n+      /* Darwin load of floating point constant.  */\n+      rtx offset = gen_rtx (CONST, Pmode,\n+\t\t    gen_rtx (MINUS, Pmode, x,\n+\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\tmachopic_function_base_name ())));\n+      x = gen_rtx (LO_SUM, GET_MODE (x),\n+\t    gen_rtx (PLUS, Pmode, pic_offset_table_rtx,\n+\t\tgen_rtx (HIGH, Pmode, offset)), offset);\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\tBASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\topnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+#endif\n+  if (TARGET_TOC\n+\t   && CONSTANT_POOL_EXPR_P (x)\n+\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), mode))\n+    {\n+      (x) = create_TOC_reference (x);\n+      *win = 1;\n+      return x;\n+    }\n+  *win = 0;\n+  return x;\n+}    \n+\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression"}, {"sha": "40769a0178b026dee0a42af46e527d917e43df42", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=24ea750e3d5ec1da1d0d3b8c9d159d77a2fc4ce0", "patch": "@@ -2058,59 +2058,16 @@ typedef struct rs6000_args\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.\n \n-   For RS/6000, we wish to handle large displacements off a base\n-   register by splitting the addend across an addiu/addis and the mem insn.\n-   This cuts number of extra insns needed from 3 to 1.  */\n+   Implemented on rs6000 by rs6000_legitimize_reload_address.  \n+   Note that (X) is evaluated twice; this is safe in current usage.  */\n    \n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n do {\t\t\t\t\t\t\t\t\t     \\\n-  /* We must recognize output that we have already generated ourselves.  */  \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t     \\\n-      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t     \\\n-      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t     \\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t     \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\t     \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t     \\\n-                   OPNUM, TYPE);\t\t\t\t\t     \\\n-      goto WIN; \t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t     \\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t     \\\n-      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t     \\\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t     \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t     \\\n-      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\t\t     \\\n-      HOST_WIDE_INT high\t\t\t\t\t\t     \\\n-        = (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-      /* Check for 32-bit overflow.  */\t\t\t\t\t     \\\n-      if (high + low != val)\t\t\t\t\t\t     \\\n-        break;\t\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-      /* Reload the high part into a base reg; leave the low part\t     \\\n-         in the mem directly.  */\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t     \\\n-                        gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t     \\\n-                                      GEN_INT (high)),\t\t\t     \\\n-                        GEN_INT (low));\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\t     \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t     \\\n-                   OPNUM, TYPE);\t\t\t\t\t     \\\n-      goto WIN;\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-  else if (TARGET_TOC\t\t\t\t\t\t\t     \\\n-\t   && CONSTANT_POOL_EXPR_P (X)\t\t\t\t\t     \\\n-\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X), MODE)) \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      (X) = create_TOC_reference (X);\t\t\t\t\t     \\\n-      goto WIN;\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n+  int win;\t\t\t\t\t\t\t\t     \\\n+  (X) = rs6000_legitimize_reload_address ((X), (MODE), (OPNUM),\t\t     \\\n+\t\t\t(int)(TYPE), (IND_LEVELS), &win);\t\t     \\\n+  if ( win )\t\t\t\t\t\t\t\t     \\\n+    goto WIN;\t\t\t\t\t\t\t\t     \\\n } while (0)\n \n /* Go to LABEL if ADDR (a legitimate address expression)"}]}