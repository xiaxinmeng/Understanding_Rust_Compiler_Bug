{"sha": "545548257d8ad0c0663f70c61a1fd189eaf896b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ1NTQ4MjU3ZDhhZDBjMDY2M2Y3MGM2MWExZmQxODllYWY4OTZiOA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-06-18T06:36:45Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-06-18T06:36:45Z"}, "message": "re PR fortran/19310 ([4.1 Only] unnecessary error for overflowing results)\n\n2006-06-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/19310\n\t* arith.c (gfc_range_check): Return ARITH_OK if -fno-range-check. Add\n\treturn of ARITH_NAN, ARITH_UNDERFLOW, and ARITH_OVERFLOW.\n\t(gfc_arith_divide): If -fno-range-check allow mpfr to divide by zero.\n\t* gfortran.h (gfc_option_t): Add new flag.\n\t* invoke.texi: Document new flag.\n\t* lang.opt: Add option -frange-check.\n\t* options.c (gfc_init_options): Initialize new flag.\n\t(gfc_handle_options): Set flag if invoked.\n\t* simplify.c (range_check): Add error messages for\n\toverflow, underflow, and other errors.\n\t* trans-const.c (gfc_conv_mpfr_to_tree): Build NaN and Inf from mpfr\n\tresult.\n\nFrom-SVN: r114752", "tree": {"sha": "9f73b7afa27dd254cb18534c5d1ceda6349bf744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f73b7afa27dd254cb18534c5d1ceda6349bf744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/545548257d8ad0c0663f70c61a1fd189eaf896b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545548257d8ad0c0663f70c61a1fd189eaf896b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/545548257d8ad0c0663f70c61a1fd189eaf896b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545548257d8ad0c0663f70c61a1fd189eaf896b8/comments", "author": null, "committer": null, "parents": [{"sha": "37b4da102f718345282ca7f9b5c7bf9be857fd47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b4da102f718345282ca7f9b5c7bf9be857fd47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b4da102f718345282ca7f9b5c7bf9be857fd47"}], "stats": {"total": 147, "additions": 127, "deletions": 20}, "files": [{"sha": "0f35d86bb04873ed64705b6c9b498e6d33ddcd96", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -1,3 +1,19 @@\n+2006-06-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/19310\n+\t* arith.c (gfc_range_check): Return ARITH_OK if -fno-range-check. Add\n+\treturn of ARITH_NAN, ARITH_UNDERFLOW, and ARITH_OVERFLOW.\n+\t(gfc_arith_divide): If -fno-range-check allow mpfr to divide by zero.\n+\t* gfortran.h (gfc_option_t): Add new flag.\n+\t* invoke.texi: Document new flag.\n+\t* lang.opt: Add option -frange-check.\n+\t* options.c (gfc_init_options): Initialize new flag.\n+\t(gfc_handle_options): Set flag if invoked.\n+\t* simplify.c (range_check): Add error messages for\n+\toverflow, underflow, and other errors.\n+\t* trans-const.c (gfc_conv_mpfr_to_tree): Build NaN and Inf from mpfr\n+\tresult.\n+\n 2006-06-17  Karl Berry  <karl@gnu.org>\n \n \t* gfortran.texi (@dircategory): Use \"Software development\""}, {"sha": "55289b49cf01334f2c51067983d73470816f5001", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -379,12 +379,36 @@ gfc_check_real_range (mpfr_t p, int kind)\n   mpfr_init (q);\n   mpfr_abs (q, p, GFC_RND_MODE);\n \n-  if (mpfr_sgn (q) == 0)\n+  if (mpfr_inf_p (p))\n+    {\n+      if (gfc_option.flag_range_check == 0)\n+        retval = ARITH_OK;\n+      else\n+        retval = ARITH_OVERFLOW;\n+    }\n+  else if (mpfr_nan_p (p))\n+    {\n+      if (gfc_option.flag_range_check == 0)\n+        retval = ARITH_OK;\n+      else\n+        retval = ARITH_NAN;\n+    }\n+  else if (mpfr_sgn (q) == 0)\n     retval = ARITH_OK;\n   else if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n-    retval = ARITH_OVERFLOW;\n+    {\n+      if (gfc_option.flag_range_check == 0)\n+        retval = ARITH_OK;\n+      else\n+        retval = ARITH_OVERFLOW;\n+    }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].subnormal) < 0)\n-    retval = ARITH_UNDERFLOW;\n+    {\n+      if (gfc_option.flag_range_check == 0)\n+        retval = ARITH_OK;\n+      else\n+        retval = ARITH_UNDERFLOW;\n+    }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     {\n       /* MPFR operates on a numbers with a given precision and enormous\n@@ -564,19 +588,29 @@ gfc_range_check (gfc_expr * e)\n     case BT_REAL:\n       rc = gfc_check_real_range (e->value.real, e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-        mpfr_set_ui (e->value.real, 0, GFC_RND_MODE);\n+\tmpfr_set_ui (e->value.real, 0, GFC_RND_MODE);\n+      if (rc == ARITH_OVERFLOW)\n+\tmpfr_set_inf (e->value.real, mpfr_sgn (e->value.real));\n+      if (rc == ARITH_NAN)\n+\tmpfr_set_nan (e->value.real);\n       break;\n \n     case BT_COMPLEX:\n       rc = gfc_check_real_range (e->value.complex.r, e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-        mpfr_set_ui (e->value.complex.r, 0, GFC_RND_MODE);\n-      if (rc == ARITH_OK || rc == ARITH_UNDERFLOW)\n-        {\n-          rc = gfc_check_real_range (e->value.complex.i, e->ts.kind);\n-          if (rc == ARITH_UNDERFLOW)\n-            mpfr_set_ui (e->value.complex.i, 0, GFC_RND_MODE);\n-        }\n+\tmpfr_set_ui (e->value.complex.r, 0, GFC_RND_MODE);\n+      if (rc == ARITH_OVERFLOW)\n+\tmpfr_set_inf (e->value.complex.r, mpfr_sgn (e->value.complex.r));\n+      if (rc == ARITH_NAN)\n+\tmpfr_set_nan (e->value.complex.r);\n+\n+      rc = gfc_check_real_range (e->value.complex.i, e->ts.kind);\n+      if (rc == ARITH_UNDERFLOW)\n+\tmpfr_set_ui (e->value.complex.i, 0, GFC_RND_MODE);\n+      if (rc == ARITH_OVERFLOW)\n+\tmpfr_set_inf (e->value.complex.i, mpfr_sgn (e->value.complex.i));\n+      if (rc == ARITH_NAN)\n+\tmpfr_set_nan (e->value.complex.i);\n \n       break;\n \n@@ -813,8 +847,8 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      /* FIXME: MPFR correctly generates NaN.  This may not be needed.  */\n-      if (mpfr_sgn (op2->value.real) == 0)\n+      if (mpfr_sgn (op2->value.real) == 0\n+\t  && gfc_option.flag_range_check == 1)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n@@ -825,9 +859,9 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_COMPLEX:\n-      /* FIXME: MPFR correctly generates NaN.  This may not be needed.  */\n       if (mpfr_sgn (op2->value.complex.r) == 0\n-\t  && mpfr_sgn (op2->value.complex.i) == 0)\n+\t  && mpfr_sgn (op2->value.complex.i) == 0\n+\t  && gfc_option.flag_range_check == 1)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;"}, {"sha": "834d23f913466964d71351137f420d0add714ae6", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -1627,6 +1627,7 @@ typedef struct\n   int flag_max_stack_var_size;\n   int flag_module_access_private;\n   int flag_no_backend;\n+  int flag_range_check;\n   int flag_pack_derived;\n   int flag_repack_arrays;\n   int flag_preprocessed;"}, {"sha": "7b8036cf630bf1f3a9a611f11e788cfb5bd88ab4", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -122,7 +122,7 @@ by type.  Explanations are in the following sections.\n -ffixed-line-length-@var{n}  -ffixed-line-length-none @gol\n -ffree-line-length-@var{n}  -ffree-line-length-none @gol\n -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8 @gol\n--fcray-pointer  -fopenmp }\n+-fcray-pointer  -fopenmp  -frange-check }\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n@@ -308,6 +308,15 @@ and @code{c$}, @code{*$} and @code{!$} sentinels in fixed form\n and when linking arranges for the OpenMP runtime library to be linked\n in.\n \n+@cindex -frange-check\n+@cindex options, -frange-check\n+@item -frange-check\n+Enable range checking on results of simplification of constant expressions\n+during compilation.  For example, by default, @command{gfortran} will give\n+an overflow error at compile time when simplifying @code{a = EXP(1000)}.\n+With @samp{-fno-range-check}, no error will be given and the variable @code{a}\n+will be assigned the value @code{+Infinity}.\n+\n @cindex -std=@var{std} option\n @cindex option, -std=@var{std}\n @item -std=@var{std}"}, {"sha": "2857ec87074146fcd623a8b498b71a44ee8670e6", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -181,6 +181,10 @@ fno-backend\n Fortran RejectNegative\n Don't generate code, just do syntax and semantics checking\n \n+frange-check\n+Fortran\n+Enable range checking during compilation\n+\n fpack-derived\n Fortran\n Try to layout derived types as compact as possible"}, {"sha": "cd550d449e6c3eb3edc20e98fe6e48754c9522b7", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -73,6 +73,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.flag_max_stack_var_size = 32768;\n   gfc_option.flag_module_access_private = 0;\n   gfc_option.flag_no_backend = 0;\n+  gfc_option.flag_range_check = 1;\n   gfc_option.flag_pack_derived = 0;\n   gfc_option.flag_repack_arrays = 0;\n   gfc_option.flag_preprocessed = 0;\n@@ -519,6 +520,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.flag_no_backend = value;\n       break;\n \n+    case OPT_frange_check:\n+      gfc_option.flag_range_check = value;\n+      break;\n+\n     case OPT_fpack_derived:\n       gfc_option.flag_pack_derived = value;\n       break;"}, {"sha": "f8bf372d905cd475eec78d7696a6a64141c53799", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -95,10 +95,29 @@ static int xascii_table[256];\n static gfc_expr *\n range_check (gfc_expr * result, const char *name)\n {\n-  if (gfc_range_check (result) == ARITH_OK)\n-    return result;\n \n-  gfc_error (\"Result of %s overflows its kind at %L\", name, &result->where);\n+  switch (gfc_range_check (result))\n+    {\n+      case ARITH_OK:\n+\treturn result;\n+ \n+      case ARITH_OVERFLOW:\n+\tgfc_error (\"Result of %s overflows its kind at %L\", name, &result->where);\n+\tbreak;\n+\n+      case ARITH_UNDERFLOW:\n+\tgfc_error (\"Result of %s underflows its kind at %L\", name, &result->where);\n+\tbreak;\n+\n+      case ARITH_NAN:\n+\tgfc_error (\"Result of %s is NaN at %L\", name, &result->where);\n+\tbreak;\n+\n+      default:\n+\tgfc_error (\"Result of %s gives range error for its kind at %L\", name, &result->where);\n+\tbreak;\n+    }\n+\n   gfc_free_expr (result);\n   return &gfc_bad_expr;\n }"}, {"sha": "c1c966197155d4603b6b7982f14c4ea304541651", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545548257d8ad0c0663f70c61a1fd189eaf896b8/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=545548257d8ad0c0663f70c61a1fd189eaf896b8", "patch": "@@ -209,11 +209,31 @@ gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n   mp_exp_t exp;\n   char *p, *q;\n   int n;\n+  REAL_VALUE_TYPE real;\n \n   n = gfc_validate_kind (BT_REAL, kind, false);\n \n   gcc_assert (gfc_real_kinds[n].radix == 2);\n \n+  type = gfc_get_real_type (kind);\n+\n+  /* Take care of Infinity and NaN.  */\n+  if (mpfr_inf_p (f))\n+    {\n+      real_inf (&real);\n+      if (mpfr_sgn (f) < 0)\n+\treal = REAL_VALUE_NEGATE(real);\n+      res = build_real (type , real);\n+      return res;\n+    }\n+\n+  if (mpfr_nan_p (f))\n+    {\n+      real_nan (&real, \"\", 0, TYPE_MODE (type));\n+      res = build_real (type , real);\n+      return res;\n+    }\n+\n   /* mpfr chooses too small a number of hexadecimal digits if the\n      number of binary digits is not divisible by four, therefore we\n      have to explicitly request a sufficient number of digits here.  */\n@@ -234,7 +254,6 @@ gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n   else\n     sprintf (q, \"0x.%sp%d\", p, (int) exp);\n \n-  type = gfc_get_real_type (kind);\n   res = build_real (type, REAL_VALUE_ATOF (q, TYPE_MODE (type)));\n \n   gfc_free (q);"}]}