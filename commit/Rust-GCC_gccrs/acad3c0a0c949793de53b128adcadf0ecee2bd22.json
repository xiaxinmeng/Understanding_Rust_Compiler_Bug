{"sha": "acad3c0a0c949793de53b128adcadf0ecee2bd22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhZDNjMGEwYzk0OTc5M2RlNTNiMTI4YWRjYWRmMGVjZWUyYmQyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:17:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:17:59Z"}, "message": "[multiple changes]\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Overflow_Check_Mode): New function\n\t(Apply_Overflow_Check): New procedure (Is_Check_Suppressed):\n\tMoved here from Sem, Overflow_Check case now specially treated.\n\t* checks.ads (Overflow_Check_Mode): New function\n\t(Is_Check_Suppressed): Moved here from Sem (more logical)\n\t* exp_ch4.adb (Substitute_Valid_Check): Suppress warning about\n\toptimization if we are in MINIMIZED or ELIMINATED overflow\n\tchecking mode and within an assertiom expression.\n\t* rtsfind.ads: Add entries for Bignum stuff.\n\t* s-bignum.ads, s-bignum.adb: New files.\n\t* sem.ads, sem.adb (Is_Check_Suppressed): Moved to Checks, more logical.\n\t* sem_prag.adb (Process_Suppress_Unsuppress): New behavior for\n\tUnsuppress of Overflow_Check (sets Checked instead of Minimized)\n\t* sem_res.adb: Update comments.\n\t* sinfo.ads (N_Op): Add documentation on overflow handling.\n\t* tbuild.ads, tbuild.adb (Convert_To_And_Rewrite): New procedure.\n\t* types.ads (Minimized_Or_Eliminated): New subtype.\n\n2012-10-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.adb (Layout_Type): Do not set twice the address size\n\ton an access-to-unconstrained array if Debug_Flag_6 is set.\n\nFrom-SVN: r191912", "tree": {"sha": "c12dcb5d92664b2a69c5bff0a305c50b1caeaa9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c12dcb5d92664b2a69c5bff0a305c50b1caeaa9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acad3c0a0c949793de53b128adcadf0ecee2bd22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acad3c0a0c949793de53b128adcadf0ecee2bd22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acad3c0a0c949793de53b128adcadf0ecee2bd22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acad3c0a0c949793de53b128adcadf0ecee2bd22/comments", "author": null, "committer": null, "parents": [{"sha": "d976bf74f0b426dc4f17228e181421e695f49c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d976bf74f0b426dc4f17228e181421e695f49c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d976bf74f0b426dc4f17228e181421e695f49c05"}], "stats": {"total": 2119, "additions": 2013, "deletions": 106}, "files": [{"sha": "0eba9d90da52d1e2008bbded9075206956cb9dc9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -1,3 +1,28 @@\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Overflow_Check_Mode): New function\n+\t(Apply_Overflow_Check): New procedure (Is_Check_Suppressed):\n+\tMoved here from Sem, Overflow_Check case now specially treated.\n+\t* checks.ads (Overflow_Check_Mode): New function\n+\t(Is_Check_Suppressed): Moved here from Sem (more logical)\n+\t* exp_ch4.adb (Substitute_Valid_Check): Suppress warning about\n+\toptimization if we are in MINIMIZED or ELIMINATED overflow\n+\tchecking mode and within an assertiom expression.\n+\t* rtsfind.ads: Add entries for Bignum stuff.\n+\t* s-bignum.ads, s-bignum.adb: New files.\n+\t* sem.ads, sem.adb (Is_Check_Suppressed): Moved to Checks, more logical.\n+\t* sem_prag.adb (Process_Suppress_Unsuppress): New behavior for\n+\tUnsuppress of Overflow_Check (sets Checked instead of Minimized)\n+\t* sem_res.adb: Update comments.\n+\t* sinfo.ads (N_Op): Add documentation on overflow handling.\n+\t* tbuild.ads, tbuild.adb (Convert_To_And_Rewrite): New procedure.\n+\t* types.ads (Minimized_Or_Eliminated): New subtype.\n+\n+2012-10-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.adb (Layout_Type): Do not set twice the address size\n+\ton an access-to-unconstrained array if Debug_Flag_6 is set.\n+\n 2012-10-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb (Analyze_Declarations): Remove the specialized"}, {"sha": "196cd73182b8c9cb96422e3424351738376d1c02", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 662, "deletions": 22, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -201,6 +201,16 @@ package body Checks is\n    --  have to raise an exception when the operand is a NaN, and rounding must\n    --  be taken into account to determine the safe bounds of the operand.\n \n+   procedure Apply_Arithmetic_Overflow_Normal (N : Node_Id);\n+   --  Used to apply arithmetic overflow checks for all cases except operators\n+   --  on signed arithmetic types in Minimized/Eliminate case (for which we\n+   --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below).\n+\n+   procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id);\n+   --  Used to apply arithmetic overflow checks for the case where the overflow\n+   --  checking mode is Minimized or Eliminated (and the Do_Overflow_Check flag\n+   --  is known to be set) and we have an signed integer arithmetic op.\n+\n    procedure Apply_Selected_Length_Checks\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n@@ -289,6 +299,11 @@ package body Checks is\n    --  Called by Apply_{Length,Range}_Checks to rewrite the tree with the\n    --  Constraint_Error node.\n \n+   function Is_Signed_Integer_Arithmetic_Op (N : Node_Id) return Boolean;\n+   --  Returns True if node N is for an arithmetic operation with signed\n+   --  integer operands. This is the kind of node for which special handling\n+   --  applies in MINIMIZED or EXTENDED overflow checking mode.\n+\n    function Range_Or_Validity_Checks_Suppressed\n      (Expr : Node_Id) return Boolean;\n    --  Returns True if either range or validity checks or both are suppressed\n@@ -731,14 +746,49 @@ package body Checks is\n    -- Apply_Arithmetic_Overflow_Check --\n    -------------------------------------\n \n+   procedure Apply_Arithmetic_Overflow_Check (N : Node_Id) is\n+   begin\n+      --  Use old routine in almost all cases (the only case we are treating\n+      --  specially is the case of an signed integer arithmetic op with the\n+      --  Do_Overflow_Check flag set on the node, and the overflow checking\n+      --  mode is either Minimized_Or_Eliminated.\n+\n+      if Overflow_Check_Mode (Etype (N)) not in Minimized_Or_Eliminated\n+        or else not Do_Overflow_Check (N)\n+        or else not Is_Signed_Integer_Arithmetic_Op (N)\n+      then\n+         Apply_Arithmetic_Overflow_Normal (N);\n+\n+      --  Otherwise use the new routine for Minimized/Eliminated modes for\n+      --  the case of a signed integer arithmetic op, with Do_Overflow_Check\n+      --  set True, and the checking mode is Minimized_Or_Eliminated.\n+\n+      else\n+         Apply_Arithmetic_Overflow_Minimized_Eliminated (N);\n+      end if;\n+   end Apply_Arithmetic_Overflow_Check;\n+\n+   --------------------------------------\n+   -- Apply_Arithmetic_Overflow_Normal --\n+   --------------------------------------\n+\n    --  This routine is called only if the type is an integer type, and a\n    --  software arithmetic overflow check may be needed for op (add, subtract,\n    --  or multiply). This check is performed only if Software_Overflow_Checking\n    --  is enabled and Do_Overflow_Check is set. In this case we expand the\n    --  operation into a more complex sequence of tests that ensures that\n    --  overflow is properly caught.\n \n-   procedure Apply_Arithmetic_Overflow_Check (N : Node_Id) is\n+   --  This is used in SUPPRESSED/CHECKED modes. It is identical to the\n+   --  code for these cases before the big overflow earthquake, thus ensuring\n+   --  that in these modes we have compatible behavior (and realibility) to\n+   --  what was there before. It is also called for types other than signed\n+   --  integers, and if the Do_Overflow_Check flag is off.\n+\n+   --  Note: we also call this routine if we decide in the MINIMIZED case\n+   --  to give up and just generate an overflow check without any fuss.\n+\n+   procedure Apply_Arithmetic_Overflow_Normal (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Typ   : constant Entity_Id  := Etype (N);\n       Rtyp  : constant Entity_Id  := Root_Type (Typ);\n@@ -1001,7 +1051,148 @@ package body Checks is\n          when RE_Not_Available =>\n             return;\n       end;\n-   end Apply_Arithmetic_Overflow_Check;\n+   end Apply_Arithmetic_Overflow_Normal;\n+\n+   ----------------------------------------------------\n+   -- Apply_Arithmetic_Overflow_Minimized_Eliminated --\n+   ----------------------------------------------------\n+\n+   procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id) is\n+      pragma Assert (Is_Signed_Integer_Arithmetic_Op (Op));\n+      pragma Assert (Do_Overflow_Check (Op));\n+\n+      Loc : constant Source_Ptr := Sloc (Op);\n+      P   : constant Node_Id    := Parent (Op);\n+\n+      Result_Type : constant Entity_Id := Etype (Op);\n+      --  Original result type\n+\n+      Check_Mode : constant Overflow_Check_Type :=\n+        Overflow_Check_Mode (Etype (Op));\n+      pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n+\n+      Lo, Hi : Uint;\n+      --  Ranges of values for result\n+\n+   begin\n+      --  Nothing to do if our parent is one of the following:\n+\n+      --    Another signed integer arithmetic operation\n+      --    A membership operation\n+      --    A comparison operation\n+\n+      --  In all these cases, we will process at the higher level (and then\n+      --  this node will be processed during the downwards recursion that\n+      --  is part of the processing in Minimize_Eliminate_Overflow_Checks.\n+\n+      if Is_Signed_Integer_Arithmetic_Op (P)\n+        or else Nkind (Op) in N_Membership_Test\n+        or else Nkind (Op) in N_Op_Compare\n+      then\n+         return;\n+      end if;\n+\n+      --  Otherwise, we have a top level arithmetic operator node, and this\n+      --  is where we commence the special processing for minimize/eliminate.\n+\n+      Minimize_Eliminate_Overflow_Checks (Op, Lo, Hi);\n+\n+      --  That call may but does not necessarily change the result type of Op.\n+      --  It is the job of this routine to undo such changes, so that at the\n+      --  top level, we have the proper type. This \"undoing\" is a point at\n+      --  which a final overflow check may be applied.\n+\n+      --  If the result type was not fiddled we are all set\n+\n+      if Etype (Op) = Result_Type then\n+         return;\n+\n+      --  Bignum case\n+\n+      elsif Etype (Op) = RTE (RE_Bignum) then\n+\n+         --  We need a sequence that looks like\n+\n+         --    Rnn : Result_Type;\n+\n+         --    declare\n+         --       M   : Mark_Id := SS_Mark;\n+         --    begin\n+         --       Rnn := Long_Long_Integer (From_Bignum (Op));\n+         --       SS_Release (M);\n+         --    end;\n+\n+         --  This block is inserted (using Insert_Actions), and then the node\n+         --  is replaced with a reference to Rnn.\n+\n+         --  A special case arises if our parent is a conversion node. In this\n+         --  case no point in generating a conversion to Result_Type, we will\n+         --  let the parent handle this. Note that this special case is not\n+         --  just about optimization. Consider\n+\n+         --      A,B,C : Integer;\n+         --      ...\n+         --      X := Long_Long_Integer (A * (B ** C));\n+\n+         --  Now the product may fit in Long_Long_Integer but not in Integer.\n+         --  In Minimize/Eliminate mode, we don't want to introduce an overflow\n+         --  exception for this intermediate value.\n+\n+         declare\n+            Blk  : constant Node_Id  := Make_Bignum_Block (Loc);\n+            Rnn : constant Entity_Id := Make_Temporary (Loc, 'R', Op);\n+            RHS : Node_Id;\n+\n+            Rtype : Entity_Id;\n+\n+         begin\n+            RHS := Convert_From_Bignum (Op);\n+\n+            if Nkind (P) /= N_Type_Conversion then\n+               RHS := Convert_To (Result_Type, Op);\n+               Rtype := Result_Type;\n+\n+               --  Interesting question, do we need a check on that conversion\n+               --  operation. Answer, not if we know the result is in range.\n+               --  At the moment we are not taking advantage of this. To be\n+               --  looked at later ???\n+\n+            else\n+               Rtype := Standard_Long_Long_Integer;\n+            end if;\n+\n+            Insert_Before\n+              (First (Statements (Handled_Statement_Sequence (Blk))),\n+               Make_Assignment_Statement (Loc,\n+                 Name       => New_Occurrence_Of (Rnn, Loc),\n+                 Expression => RHS));\n+\n+            Insert_Actions (Op, New_List (\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Rnn,\n+                Object_Definition   => New_Occurrence_Of (Rtype, Loc)),\n+              Blk));\n+\n+            Rewrite (Op, New_Occurrence_Of (Rnn, Loc));\n+            Analyze_And_Resolve (Op);\n+         end;\n+\n+         --  Here if the result is Long_Long_Integer\n+\n+      else\n+         pragma Assert (Etype (Op) = Standard_Long_Long_Integer);\n+\n+         --  All we need to do here is to convert the result to the proper\n+         --  result type. As explained above for the Bignum case, we can\n+         --  omit this if our parent is a type conversion.\n+\n+         if Nkind (P) /= N_Type_Conversion then\n+            Convert_To_And_Rewrite (Result_Type, Op);\n+         end if;\n+\n+         Analyze_And_Resolve (Op);\n+      end if;\n+   end Apply_Arithmetic_Overflow_Minimized_Eliminated;\n \n    ----------------------------\n    -- Apply_Constraint_Check --\n@@ -1418,8 +1609,8 @@ package body Checks is\n \n       Cond := Build_Discriminant_Checks (N, T_Typ);\n \n-      --  If Lhs is set and is a parameter, then the condition is\n-      --  guarded by: lhs'constrained and then (condition built above)\n+      --  If Lhs is set and is a parameter, then the condition is guarded by:\n+      --  lhs'constrained and then (condition built above)\n \n       if Present (Param_Entity (Lhs)) then\n          Cond :=\n@@ -3358,6 +3549,52 @@ package body Checks is\n       Saved_Checks_TOS := Saved_Checks_TOS - 1;\n    end Conditional_Statements_End;\n \n+   -------------------------\n+   -- Convert_From_Bignum --\n+   -------------------------\n+\n+   function Convert_From_Bignum (N : Node_Id) return Node_Id is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      pragma Assert (Is_RTE (Etype (N), RE_Bignum));\n+\n+      --  Construct call From Bignum\n+\n+      return\n+        Make_Function_Call (Loc,\n+          Name                   =>\n+            New_Occurrence_Of (RTE (RE_From_Bignum), Loc),\n+          Parameter_Associations => New_List (Relocate_Node (N)));\n+   end Convert_From_Bignum;\n+\n+   -----------------------\n+   -- Convert_To_Bignum --\n+   -----------------------\n+\n+   function Convert_To_Bignum (N : Node_Id) return Node_Id is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      --  Nothing to do if Bignum already\n+\n+      if Is_RTE (Etype (N), RE_Bignum) then\n+         return Relocate_Node (N);\n+\n+         --  Otherwise construct call to To_Bignum, converting the operand to\n+         --  the required Long_Long_Integer form.\n+\n+      else\n+         pragma Assert (Is_Signed_Integer_Type (Etype (N)));\n+         return\n+           Make_Function_Call (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_To_Bignum), Loc),\n+             Parameter_Associations => New_List (\n+               Convert_To (Standard_Long_Long_Integer, Relocate_Node (N))));\n+      end if;\n+   end Convert_To_Bignum;\n+\n    ---------------------\n    -- Determine_Range --\n    ---------------------\n@@ -3945,13 +4182,14 @@ package body Checks is\n    ---------------------------\n \n    procedure Enable_Overflow_Check (N : Node_Id) is\n-      Typ : constant Entity_Id  := Base_Type (Etype (N));\n-      Chk : Nat;\n-      OK  : Boolean;\n-      Ent : Entity_Id;\n-      Ofs : Uint;\n-      Lo  : Uint;\n-      Hi  : Uint;\n+      Typ  : constant Entity_Id           := Base_Type (Etype (N));\n+      Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Etype (N));\n+      Chk  : Nat;\n+      OK   : Boolean;\n+      Ent  : Entity_Id;\n+      Ofs  : Uint;\n+      Lo   : Uint;\n+      Hi   : Uint;\n \n    begin\n       if Debug_Flag_CC then\n@@ -3963,22 +4201,48 @@ package body Checks is\n \n       --  No check if overflow checks suppressed for type of node\n \n-      if Present (Etype (N))\n-        and then Overflow_Checks_Suppressed (Etype (N))\n-      then\n+      if Mode = Suppressed then\n          return;\n \n       --  Nothing to do for unsigned integer types, which do not overflow\n \n       elsif Is_Modular_Integer_Type (Typ) then\n          return;\n+      end if;\n+\n+      --  This is the point at which processing for CHECKED mode diverges from\n+      --  processing for MINIMIZED/ELIMINATED mode. This divergence is probably\n+      --  more extreme that it needs to be, but what is going on here is that\n+      --  when we introduced MINIMIZED/ELININATED modes, we wanted to leave the\n+      --  processing for CHECKED mode untouched. There were two reasons for\n+      --  this. First it avoided any incomptible change of behavior. Second,\n+      --  it guaranteed that CHECKED mode continued to be legacy reliable.\n+\n+      --  The big difference is that in CHECKED mode there is a fair amount of\n+      --  circuitry to try to avoid setting the Do_Overflow_Check flag if we\n+      --  know that no check is needed. We skip all that in the two new modes,\n+      --  since really overflow checking happens over a whole subtree, and we\n+      --  do the corresponding optimizations later on when applying the checks.\n+\n+      if Mode in Minimized_Or_Eliminated then\n+         Activate_Overflow_Check (N);\n+\n+         if Debug_Flag_CC then\n+            w (\"Minimized/Eliminated mode\");\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  Remainder of processing is for Checked case, and is unchanged from\n+      --  earlier versions preceding the addition of Minimized/Eliminated.\n \n       --  Nothing to do if the range of the result is known OK. We skip this\n       --  for conversions, since the caller already did the check, and in any\n       --  case the condition for deleting the check for a type conversion is\n       --  different.\n \n-      elsif Nkind (N) /= N_Type_Conversion then\n+      if Nkind (N) /= N_Type_Conversion then\n          Determine_Range (N, OK, Lo, Hi, Assume_Valid => True);\n \n          --  Note in the test below that we assume that the range is not OK\n@@ -5755,6 +6019,23 @@ package body Checks is\n       end;\n    end Insert_Valid_Check;\n \n+   -------------------------------------\n+   -- Is_Signed_Integer_Arithmetic_Op --\n+   -------------------------------------\n+\n+   function Is_Signed_Integer_Arithmetic_Op (N : Node_Id) return Boolean is\n+   begin\n+      case Nkind (N) is\n+         when N_Op_Abs   | N_Op_Add      | N_Op_Divide   | N_Op_Expon |\n+              N_Op_Minus | N_Op_Mod      | N_Op_Multiply | N_Op_Plus  |\n+              N_Op_Rem   | N_Op_Subtract =>\n+            return Is_Signed_Integer_Type (Etype (N));\n+\n+         when others =>\n+            return False;\n+      end case;\n+   end Is_Signed_Integer_Arithmetic_Op;\n+\n    ----------------------------------\n    -- Install_Null_Excluding_Check --\n    ----------------------------------\n@@ -6022,6 +6303,61 @@ package body Checks is\n       Possible_Local_Raise (R_Cno, Standard_Constraint_Error);\n    end Install_Static_Check;\n \n+   -------------------------\n+   -- Is_Check_Suppressed --\n+   -------------------------\n+\n+   function Is_Check_Suppressed (E : Entity_Id; C : Check_Id) return Boolean is\n+      Ptr : Suppress_Stack_Entry_Ptr;\n+\n+   begin\n+      --  First search the local entity suppress stack. We search this from the\n+      --  top of the stack down so that we get the innermost entry that applies\n+      --  to this case if there are nested entries.\n+\n+      Ptr := Local_Suppress_Stack_Top;\n+      while Ptr /= null loop\n+         if (Ptr.Entity = Empty or else Ptr.Entity = E)\n+           and then (Ptr.Check = All_Checks or else Ptr.Check = C)\n+         then\n+            return Ptr.Suppress;\n+         end if;\n+\n+         Ptr := Ptr.Prev;\n+      end loop;\n+\n+      --  Now search the global entity suppress table for a matching entry.\n+      --  We also search this from the top down so that if there are multiple\n+      --  pragmas for the same entity, the last one applies (not clear what\n+      --  or whether the RM specifies this handling, but it seems reasonable).\n+\n+      Ptr := Global_Suppress_Stack_Top;\n+      while Ptr /= null loop\n+         if (Ptr.Entity = Empty or else Ptr.Entity = E)\n+           and then (Ptr.Check = All_Checks or else Ptr.Check = C)\n+         then\n+            return Ptr.Suppress;\n+         end if;\n+\n+         Ptr := Ptr.Prev;\n+      end loop;\n+\n+      --  If we did not find a matching entry, then use the normal scope\n+      --  suppress value after all (actually this will be the global setting\n+      --  since it clearly was not overridden at any point). For a predefined\n+      --  check, we test the specific flag. For a user defined check, we check\n+      --  the All_Checks flag. The Overflow flag requires special handling to\n+      --  deal with the General vs Assertion case\n+\n+      if C = Overflow_Check then\n+         return Overflow_Checks_Suppressed (Empty);\n+      elsif C in Predefined_Check_Id then\n+         return Scope_Suppress.Suppress (C);\n+      else\n+         return Scope_Suppress.Suppress (All_Checks);\n+      end if;\n+   end Is_Check_Suppressed;\n+\n    ---------------------\n    -- Kill_All_Checks --\n    ---------------------\n@@ -6080,27 +6416,331 @@ package body Checks is\n       end if;\n    end Length_Checks_Suppressed;\n \n-   --------------------------------\n-   -- Overflow_Checks_Suppressed --\n-   --------------------------------\n+   -----------------------\n+   -- Make_Bignum_Block --\n+   -----------------------\n+\n+   function Make_Bignum_Block (Loc : Source_Ptr) return Node_Id is\n+      M : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uM);\n \n-   function Overflow_Checks_Suppressed (E : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Make_Block_Statement (Loc,\n+          Declarations => New_List (\n+            Make_Object_Declaration (Loc,\n+              Defining_Identifier => M,\n+              Object_Definition   =>\n+                New_Occurrence_Of (RTE (RE_Mark_Id), Loc),\n+              Expression          =>\n+                Make_Function_Call (Loc,\n+                  Name => New_Reference_To (RTE (RE_SS_Mark), Loc)))),\n+\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (\n+                Make_Procedure_Call_Statement (Loc,\n+                  Name => New_Occurrence_Of (RTE (RE_SS_Release), Loc),\n+                  Parameter_Associations => New_List (\n+                    New_Reference_To (M, Loc))))));\n+   end Make_Bignum_Block;\n+\n+   ----------------------------------------\n+   -- Minimize_Eliminate_Overflow_Checks --\n+   ----------------------------------------\n+\n+   procedure Minimize_Eliminate_Overflow_Checks\n+     (N  : Node_Id;\n+      Lo : out Uint;\n+      Hi : out Uint)\n+   is\n+      pragma Assert (Is_Signed_Integer_Type (Etype (N)));\n+\n+      Check_Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Empty);\n+      pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n+\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Rlo, Rhi : Uint;\n+      --  Ranges of values for right operand\n+\n+      Llo, Lhi : Uint;\n+      --  Ranges of values for left operand\n+\n+      LLLo, LLHi : Uint;\n+      --  Bounds of Long_Long_Integer\n+\n+      Binary : constant Boolean := Nkind (N) in N_Binary_Op;\n+      --  Indicates binary operator case\n+\n+      OK : Boolean;\n+      --  Used in call to Determine_Range\n+\n+   begin\n+      --  Case where we do not have an arithmetic operator.\n+\n+      if not Is_Signed_Integer_Arithmetic_Op (N) then\n+\n+         --  Use the normal Determine_Range routine to get the range. We\n+         --  don't require operands to be valid, invalid values may result in\n+         --  rubbish results where the result has not been properly checked for\n+         --  overflow, that's fine!\n+\n+         Determine_Range (N, OK, Lo, Hi, Assume_Valid => False);\n+\n+         --  If Deterine_Range did not work (can this in fact happen? Not\n+         --  clear but might as well protect), use type bounds.\n+\n+         if not OK then\n+            Lo := Intval (Type_Low_Bound  (Base_Type (Etype (N))));\n+            Hi := Intval (Type_High_Bound (Base_Type (Etype (N))));\n+         end if;\n+\n+         --  If we don't have a binary operator, all we have to do is to set\n+         --  the Hi/Lo range, so we are done\n+\n+         return;\n+\n+      --  If we have an arithmetic oeprator we make recursive calls on the\n+      --  operands to get the ranges (and to properly process the subtree\n+      --  that lies below us!)\n+\n+      else\n+         Minimize_Eliminate_Overflow_Checks (Right_Opnd (N), Rlo, Rhi);\n+\n+         if Binary then\n+            Minimize_Eliminate_Overflow_Checks (Left_Opnd (N), Llo, Lhi);\n+         end if;\n+      end if;\n+\n+      --  If either operand is a bignum, then result will be a bignum\n+\n+      if Rlo = No_Uint or else (Binary and then Llo = No_Uint) then\n+         Lo := No_Uint;\n+         Hi := No_Uint;\n+\n+      --  Otherwise compute result range\n+\n+      else\n+         case Nkind (N) is\n+\n+            --  Absolute value\n+\n+            when N_Op_Abs =>\n+               Lo := Uint_0;\n+               Hi := UI_Max (UI_Abs (Rlo), UI_Abs (Rhi));\n+\n+            --  Addition\n+\n+            when N_Op_Add =>\n+               Lo := Llo + Rlo;\n+               Hi := Lhi + Rhi;\n+\n+            --  Division\n+\n+            when N_Op_Divide =>\n+               raise Program_Error;\n+\n+            --  Exponentiation\n+\n+            when N_Op_Expon =>\n+               raise Program_Error;\n+\n+            --  Negation\n+\n+            when N_Op_Minus =>\n+               Lo := -Rhi;\n+               Hi := -Rlo;\n+\n+            --  Mod\n+\n+            when N_Op_Mod =>\n+               raise Program_Error;\n+\n+            --  Multiplication\n+\n+            when N_Op_Multiply =>\n+               raise Program_Error;\n+\n+            --  Plus operator (affirmation)\n+\n+            when N_Op_Plus =>\n+               Lo := Rlo;\n+               Hi := Rhi;\n+\n+            --  Remainder\n+\n+            when N_Op_Rem =>\n+               raise Program_Error;\n+\n+            --  Subtract\n+\n+            when N_Op_Subtract =>\n+               Lo := Llo - Rhi;\n+               Hi := Lhi - Rlo;\n+\n+            --  Nothing else should be possible\n+\n+            when others =>\n+               raise Program_Error;\n+\n+         end case;\n+      end if;\n+\n+      --  Case where we do the operation in Bignum mode. This happens either\n+      --  because one of our operands is in Bignum mode already, or because\n+      --  the computed bounds are outside the bounds of Long_Long_Integer.\n+\n+      --  Note: we could do better here and in some cases switch back from\n+      --  Bignum mode to normal mode, e.g. big mod 2 must be in the range\n+      --  0 .. 1, but the cases are rare and it is not worth the effort.\n+      --  Failing to do this switching back is only an efficiency issue.\n+\n+      LLLo := Intval (Type_Low_Bound  (Standard_Long_Long_Integer));\n+      LLHi := Intval (Type_High_Bound (Standard_Long_Long_Integer));\n+\n+      if Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n+\n+         --  In MINIMIZED mode, just give up and apply an overflow check\n+         --  Note that we know we don't have a Bignum, since Bignums only\n+         --  appear in Eliminated mode.\n+\n+         if Check_Mode = Minimized then\n+            pragma Assert (Lo /= No_Uint);\n+            Enable_Overflow_Check (N);\n+\n+            --  It's fine to just return here, we may generate an overflow\n+            --  exception, but this is the case in MINIMIZED mode where we\n+            --  can't avoid this possibility.\n+\n+            Apply_Arithmetic_Overflow_Normal (N);\n+            return;\n+\n+         --  Otherwise we are in ELIMINATED mode, switch to bignum\n+\n+         else\n+            pragma Assert (Check_Mode = Eliminated);\n+\n+            declare\n+               Fent : Entity_Id;\n+               Args : List_Id;\n+\n+            begin\n+               case Nkind (N) is\n+                  when N_Op_Abs      =>\n+                     Fent := RTE (RE_Big_Abs);\n+\n+                  when N_Op_Add      =>\n+                     Fent := RTE (RE_Big_Add);\n+\n+                  when N_Op_Divide   =>\n+                     Fent := RTE (RE_Big_Div);\n+\n+                  when N_Op_Expon    =>\n+                     Fent := RTE (RE_Big_Exp);\n+\n+                  when N_Op_Minus    =>\n+                     Fent := RTE (RE_Big_Neg);\n+\n+                  when N_Op_Mod      =>\n+                     Fent := RTE (RE_Big_Mod);\n+\n+                  when N_Op_Multiply =>\n+                     Fent := RTE (RE_Big_Mul);\n+\n+                  when N_Op_Rem      =>\n+                     Fent := RTE (RE_Big_Rem);\n+\n+                  when N_Op_Subtract =>\n+                     Fent := RTE (RE_Big_Sub);\n+\n+                  --  Anything else is an internal error, this includes the\n+                  --  N_Op_Plus case, since how can plus cause the result\n+                  --  to be out of range if the operand is in range?\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+\n+               --  Construct argument list for Bignum call, converting our\n+               --  operands to Bignum form if they are not already there.\n+\n+               Args := New_List;\n+\n+               if Binary then\n+                  Append_To (Args, Convert_To_Bignum (Left_Opnd (N)));\n+               end if;\n+\n+               Append_To (Args, Convert_To_Bignum (Right_Opnd (N)));\n+\n+               --  Now rewrite the arithmetic operator with a call to the\n+               --  corresponding bignum function.\n+\n+               Rewrite (N,\n+                 Make_Function_Call (Loc,\n+                   Name                   => New_Occurrence_Of (Fent, Loc),\n+                   Parameter_Associations => Args));\n+               Analyze_And_Resolve (N, RTE (RE_Bignum));\n+            end;\n+         end if;\n+\n+      --  Otherwise we are in range of Long_Long_Integer, so no overflow\n+      --  check is required, at least not yet. Adjust the operands to\n+      --  Long_Long_Integer and mark the result type as Long_Long_Integer.\n+\n+      else\n+         Convert_To_And_Rewrite\n+           (Standard_Long_Long_Integer, Right_Opnd (N));\n+\n+         if Binary then\n+            Convert_To_And_Rewrite\n+              (Standard_Long_Long_Integer, Left_Opnd (N));\n+         end if;\n+\n+         Set_Etype (N, Standard_Long_Long_Integer);\n+\n+         --  Clear entity field, since we have modified the type and mark\n+         --  the node as analyzed to prevent junk infinite recursion\n+\n+         Set_Entity (N, Empty);\n+         Set_Analyzed (N, True);\n+\n+         --  Turn off the overflow check flag, since this is precisely the\n+         --  case where we have avoided an intermediate overflow check.\n+\n+         Set_Do_Overflow_Check (N, False);\n+      end if;\n+   end Minimize_Eliminate_Overflow_Checks;\n+\n+   -------------------------\n+   -- Overflow_Check_Mode --\n+   -------------------------\n+\n+   function Overflow_Check_Mode (E : Entity_Id) return Overflow_Check_Type is\n    begin\n       --  Check overflow suppressed on entity\n \n       if Present (E) and then Checks_May_Be_Suppressed (E) then\n          if Is_Check_Suppressed (E, Overflow_Check) then\n-            return True;\n+            return Suppressed;\n          end if;\n       end if;\n \n       --  Else return appropriate scope setting\n \n       if In_Assertion_Expr = 0 then\n-         return Scope_Suppress.Overflow_Checks_General = Suppressed;\n+         return Scope_Suppress.Overflow_Checks_General;\n       else\n-         return Scope_Suppress.Overflow_Checks_Assertions = Suppressed;\n+         return Scope_Suppress.Overflow_Checks_Assertions;\n       end if;\n+   end Overflow_Check_Mode;\n+\n+   --------------------------------\n+   -- Overflow_Checks_Suppressed --\n+   --------------------------------\n+\n+   function Overflow_Checks_Suppressed (E : Entity_Id) return Boolean is\n+   begin\n+      return Overflow_Check_Mode (E) = Suppressed;\n    end Overflow_Checks_Suppressed;\n \n    -----------------------------"}, {"sha": "fb8fc1466eff85187c3f2b7bb51b7c4792448a61", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 114, "deletions": 9, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -67,6 +67,18 @@ package Checks is\n    --  reason we insist on specifying Empty is to force the caller to think\n    --  about whether there is any relevant entity that should be checked.\n \n+   function Is_Check_Suppressed (E : Entity_Id; C : Check_Id) return Boolean;\n+   --  This function is called if Checks_May_Be_Suppressed (E) is True to\n+   --  determine whether check C is suppressed either on the entity E or\n+   --  as the result of a scope suppress pragma. If Checks_May_Be_Suppressed\n+   --  is False, then the status of the check can be determined simply by\n+   --  examining Scope_Checks (C), so this routine is not called in that case.\n+\n+   function Overflow_Check_Mode (E : Entity_Id) return Overflow_Check_Type;\n+   --  Returns current overflow checking mode, taking into account whether\n+   --  we are inside an assertion expression. Always returns Suppressed if\n+   --  overflow checks are suppressed for entity E.\n+\n    -------------------------------------------\n    -- Procedures to Activate Checking Flags --\n    -------------------------------------------\n@@ -164,14 +176,6 @@ package Checks is\n    --  for Typ, if Typ has a predicate function. The check is applied only\n    --  if the type of N does not match Typ.\n \n-   function Build_Discriminant_Checks\n-     (N     : Node_Id;\n-      T_Typ : Entity_Id)\n-      return  Node_Id;\n-   --  Subsidiary routine for Apply_Discriminant_Check. Builds the expression\n-   --  that compares discriminants of the expression with discriminants of the\n-   --  type. Also used directly for membership tests (see Exp_Ch4.Expand_N_In).\n-\n    procedure Apply_Divide_Check (N : Node_Id);\n    --  The node kind is N_Op_Divide, N_Op_Mod, or N_Op_Rem. An appropriate\n    --  check is generated to ensure that the right operand is non-zero. In\n@@ -194,6 +198,25 @@ package Checks is\n    --  result type. This routine deals with range and overflow checks needed\n    --  to make sure that the universal result is in range.\n \n+   function Build_Discriminant_Checks\n+     (N     : Node_Id;\n+      T_Typ : Entity_Id)\n+      return  Node_Id;\n+   --  Subsidiary routine for Apply_Discriminant_Check. Builds the expression\n+   --  that compares discriminants of the expression with discriminants of the\n+   --  type. Also used directly for membership tests (see Exp_Ch4.Expand_N_In).\n+\n+   function Convert_From_Bignum (N : Node_Id) return Node_Id;\n+   --  Returns result of converting node N from Bignum. The returned value is\n+   --  not analyzed, the caller takes responsibility for this. Node N must be\n+   --  a subexpression node of type Bignum. The result is Long_Long_Integer.\n+\n+   function Convert_To_Bignum (N : Node_Id) return Node_Id;\n+   --  Returns result of converting node N to Bignum. The returned value is not\n+   --  analyzed, the caller takes responsibility for this. Node N must be a\n+   --  subexpression node of a signed integer type or Bignum type (if it is\n+   --  already a Bignnum, the returned value is Relocate_Node (N).\n+\n    procedure Determine_Range\n      (N            : Node_Id;\n       OK           : out Boolean;\n@@ -218,6 +241,86 @@ package Checks is\n    --  Determines whether an access node requires a runtime access check and\n    --  if so inserts the appropriate run-time check.\n \n+   function Make_Bignum_Block (Loc : Source_Ptr) return Node_Id;\n+   --  This function is used by top level overflow checking routines to do a\n+   --  mark/release operation on the secondary stack around bignum operations.\n+   --  The block created looks like:\n+   --\n+   --    declare\n+   --       M : Mark_Id := SS_Mark;\n+   --    begin\n+   --       SS_Release (M);\n+   --    end;\n+   --\n+   --  The idea is that the caller will insert any needed extra declarations\n+   --  after the declaration of M, and any needed statements (in particular\n+   --  the bignum operations) before the call to SS_Release, and then do an\n+   --  Insert_Action of the whole block (it is returned unanalyzed). The Loc\n+   --  parameter is used to supply Sloc values for the constructed tree.\n+\n+   procedure Minimize_Eliminate_Overflow_Checks\n+     (N  : Node_Id;\n+      Lo : out Uint;\n+      Hi : out Uint);\n+   --  This is the main routine for handling MINIMIZED and ELIMINATED overflow\n+   --  checks. On entry N is a node whose result is a signed integer subtype.\n+   --  If the node is an artihmetic operation, then a range analysis is carried\n+   --  out, and there are three possibilities:\n+   --\n+   --    The node is left unchanged (apart from expansion of an exponentiation\n+   --    operation). This happens if the routine can determine that the result\n+   --    is definitely in range. The Do_Overflow_Check flag is turned off in\n+   --    this case.\n+   --\n+   --    The node is transformed into an arithmetic operation with a result\n+   --    type of Long_Long_Integer.\n+   --\n+   --    The node is transformed into a function call that calls an appropriate\n+   --    function in the System.Bignums package to compute a Bignum result.\n+   --\n+   --  In the first two cases, Lo and Hi are set to the bounds of the possible\n+   --  range of results, computed as accurately as possible. In the third case\n+   --  Lo and Hi are set to No_Uint (there are some cases where we cold get an\n+   --  advantage from keeping result ranges for Bignum values, but it could use\n+   --  a lot of space and is very unlikely to be valuable).\n+   --\n+   --  If the node is not an arithmetic operation, then it is unchanged but\n+   --  Lo and Hi are still set (to the bounds of the result subtype if nothing\n+   --  better can be determined.\n+   --\n+   --  Note: this function is recursive, if called with an arithmetic operator,\n+   --  recursive calls are made to process the operands using this procedure.\n+   --  So we end up doing things top down. Nothing happens to an arithmetic\n+   --  expression until this procedure is called on the top level node and\n+   --  then the recursive calls process all the children. We have to do it\n+   --  this way. If we try to do it bottom up in natural expansion order, then\n+   --  there are two problems. First, where do we stash the bounds, and more\n+   --  importantly, semantic processing will be messed up. Consider A+B+C where\n+   --  A,B,C are all of type integer, if we processed A+B before doing semantic\n+   --  analysis of the addition of this result to C, that addition could end up\n+   --  with a Long_Long_Integer left operand and an Integer right operand, and\n+   --  we would get a semantic error.\n+   --\n+   --  The routine is called in three situations if we are operating in\n+   --  either MINIMIZED or ELIMINATED modes.\n+   --\n+   --    Overflow checks applied to the top node of an expression tree when\n+   --    that node is an arithmetic operator. In this case the result is\n+   --    converted to the appropriate result type (there is special processing\n+   --    when the parent is a conversion, see body for details).\n+   --\n+   --    Overflow checks are applied to the operands of a comparison operation.\n+   --    In this case, the comparison is done on the result Long_Long_Integer\n+   --    or Bignum values, without raising any exceptions.\n+   --\n+   --    Overflow checks are applied to the left operand of a membership test.\n+   --    In this case no exception is raised if a Long_Long_Integer or Bignum\n+   --    result is outside the range of the type of that left operand (it is\n+   --    just that the result of IN is false in that case).\n+   --\n+   --  Note that if Bignum values appear, the caller must take care of doing\n+   --  the appropriate mark/release operation on the secondary stack.\n+\n    -------------------------------------------------------\n    -- Control and Optimization of Range/Overflow Checks --\n    -------------------------------------------------------\n@@ -248,7 +351,9 @@ package Checks is\n    --  has no effect. If a check is needed then this routine sets the flag\n    --  Do_Overflow_Check in node N to True, unless it can be determined that\n    --  the check is not needed. The only condition under which this is the\n-   --  case is if there was an identical check earlier on.\n+   --  case is if there was an identical check earlier on. These optimziations\n+   --  apply to CHECKED mode, but not to MINIMIZED/ELIMINATED modes. See the\n+   --  body for a full explanation.\n \n    procedure Enable_Range_Check (N : Node_Id);\n    --  Set Do_Range_Check flag in node N True, unless it can be determined"}, {"sha": "7bad0dc82508a0df8a77c9c53a588a34c9efe644", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -4867,9 +4867,16 @@ package body Exp_Ch4 is\n \n          Analyze_And_Resolve (N, Restyp);\n \n-         Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n-         Error_Msg_N -- CODEFIX\n-           (\"\\?use ''Valid attribute instead\", N);\n+         --  Give warning unless overflow checking is MINIMIZED or ELIMINATED,\n+         --  in which case, this usage makes sense, and in any case, we have\n+         --  actually eliminated the danger of optimization above.\n+\n+         if Overflow_Check_Mode (Restyp) not in Minimized_Or_Eliminated then\n+            Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n+            Error_Msg_N -- CODEFIX\n+              (\"\\?use ''Valid attribute instead\", N);\n+         end if;\n+\n          return;\n       end Substitute_Valid_Check;\n "}, {"sha": "46f50905f440e9b0f11e63a686d62b5a9dab0e98", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -2448,6 +2448,7 @@ package body Layout is\n             and then\n               Nkind (Type_Definition (Parent (Desig_Type)))\n                  = N_Unconstrained_Array_Definition\n+            and then not Debug_Flag_6\n          then\n             Init_Size (E, 2 * System_Address_Size);\n "}, {"sha": "b2e757ed3f1c3075453f88a695606e85c525616f", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -213,6 +213,7 @@ package Rtsfind is\n       System_Assertions,\n       System_Atomic_Primitives,\n       System_Aux_DEC,\n+      System_Bignums,\n       System_Bit_Ops,\n       System_Boolean_Array_Operations,\n       System_Byte_Swapping,\n@@ -759,6 +760,27 @@ package Rtsfind is\n      RE_Type_Class_Task,                 -- System.Aux_DEC\n      RE_Type_Class_Address,              -- System.Aux_DEC\n \n+     RE_Big_Abs,                         -- System.Bignums\n+     RE_Big_Add,                         -- System.Bignums\n+     RE_Big_Div,                         -- System.Bignums\n+     RE_Big_Exp,                         -- System.Bignums\n+     RE_Big_Mod,                         -- System.Bignums\n+     RE_Big_Mul,                         -- System.Bignums\n+     RE_Big_Neg,                         -- System.Bignums\n+     RE_Big_Rem,                         -- System.Bignums\n+     RE_Big_Sub,                         -- System.Bignums\n+\n+     RE_Big_EQ,                          -- System.Bignums\n+     RE_Big_GE,                          -- System.Bignums\n+     RE_Big_GT,                          -- System.Bignums\n+     RE_Big_LE,                          -- System.Bignums\n+     RE_Big_LT,                          -- System.Bignums\n+     RE_Big_NE,                          -- System.Bignums\n+\n+     RE_Bignum,                          -- System.Bignums\n+     RE_To_Bignum,                       -- System.Bignums\n+     RE_From_Bignum,                     -- System.Bignums\n+\n      RE_Bit_And,                         -- System.Bit_Ops\n      RE_Bit_Eq,                          -- System.Bit_Ops\n      RE_Bit_Not,                         -- System.Bit_Ops\n@@ -783,18 +805,14 @@ package Rtsfind is\n      RE_Compare_Array_S8_Unaligned,      -- System.Compare_Array_Signed_8\n \n      RE_Compare_Array_S16,               -- System.Compare_Array_Signed_16\n-\n      RE_Compare_Array_S32,               -- System.Compare_Array_Signed_16\n-\n      RE_Compare_Array_S64,               -- System.Compare_Array_Signed_16\n \n      RE_Compare_Array_U8,                -- System.Compare_Array_Unsigned_8\n      RE_Compare_Array_U8_Unaligned,      -- System.Compare_Array_Unsigned_8\n \n      RE_Compare_Array_U16,               -- System.Compare_Array_Unsigned_16\n-\n      RE_Compare_Array_U32,               -- System.Compare_Array_Unsigned_16\n-\n      RE_Compare_Array_U64,               -- System.Compare_Array_Unsigned_16\n \n      RE_Str_Concat_2,                    -- System.Concat_2\n@@ -1985,6 +2003,27 @@ package Rtsfind is\n      RE_Type_Class_Task                  => System_Aux_DEC,\n      RE_Type_Class_Address               => System_Aux_DEC,\n \n+     RE_Big_Abs                          => System_Bignums,\n+     RE_Big_Add                          => System_Bignums,\n+     RE_Big_Div                          => System_Bignums,\n+     RE_Big_Exp                          => System_Bignums,\n+     RE_Big_Mod                          => System_Bignums,\n+     RE_Big_Mul                          => System_Bignums,\n+     RE_Big_Neg                          => System_Bignums,\n+     RE_Big_Rem                          => System_Bignums,\n+     RE_Big_Sub                          => System_Bignums,\n+\n+     RE_Big_EQ                           => System_Bignums,\n+     RE_Big_GE                           => System_Bignums,\n+     RE_Big_GT                           => System_Bignums,\n+     RE_Big_LE                           => System_Bignums,\n+     RE_Big_LT                           => System_Bignums,\n+     RE_Big_NE                           => System_Bignums,\n+\n+     RE_Bignum                           => System_Bignums,\n+     RE_To_Bignum                        => System_Bignums,\n+     RE_From_Bignum                      => System_Bignums,\n+\n      RE_Bit_And                          => System_Bit_Ops,\n      RE_Bit_Eq                           => System_Bit_Ops,\n      RE_Bit_Not                          => System_Bit_Ops,"}, {"sha": "e82fce2cfc166f75f44d359439546911f8e9fe2c", "filename": "gcc/ada/s-bignum.adb", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -0,0 +1,1005 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . B I G N U M S                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2012, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides arbitrary precision signed integer arithmetic for\n+--  use in computing intermediate values in expressions for the case where\n+--  pragma Overflow_Check (Eliminate) is in effect.\n+\n+with System;                  use System;\n+with System.Secondary_Stack;  use System.Secondary_Stack;\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+with Unchecked_Conversion;\n+\n+package body System.Bignums is\n+\n+   use Interfaces;\n+   --  So that operations on Unsigned_32 are available\n+\n+   type DD is mod SD'Modulus ** 2;\n+   --  Double length digit used for intermediate computations\n+\n+   function MSD (X : DD) return SD is (SD (X / Base));\n+   function LSD (X : DD) return SD is (SD (X mod Base));\n+   --  Most significant and least significant digit of double digit value\n+\n+   function \"&\" (X, Y : SD) return DD is (DD (X) * Base + DD (Y));\n+   --  Compose double digit value from two single digit values\n+\n+   subtype LLI is Long_Long_Integer;\n+\n+   One_Data : constant Digit_Vector (1 .. 1) := (1 => 1);\n+   --  Constant one\n+\n+   Zero_Data : constant Digit_Vector (1 .. 0) := (1 .. 0 => 0);\n+   --  Constant zero\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Add (X, Y : Digit_Vector; X_Neg, Y_Neg : Boolean) return Bignum\n+   with Pre => X'First = 1 and then Y'First = 1;\n+   --  This procedure adds two signed numbers returning the Sum, it is used\n+   --  for both addition and subtraction. The value computed is X + Y, with\n+   --  X_Neg and Y_Neg giving the signs of the operands.\n+\n+   function Allocate_Bignum (Len : Length) return Bignum\n+   with Post => Allocate_Bignum'Result.Len = Len;\n+   --  Allocate Bignum value of indicated length on secondary stack. On return\n+   --  the Neg and D fields are left uninitialized.\n+\n+   type Compare_Result is (LT, EQ, GT);\n+   --  Indicates result of comparison in following call\n+\n+   function Compare\n+     (X, Y         : Digit_Vector;\n+      X_Neg, Y_Neg : Boolean) return Compare_Result\n+   with Pre => X'First = 1 and then X'Last = 1;\n+   --  Compare (X with sign X_Neg) with (Y with sign Y_Neg), and return the\n+   --  result of the signed comparison.\n+\n+   procedure Div_Rem\n+     (X, Y              : Bignum;\n+      Quotient          : out Bignum;\n+      Remainder         : out Bignum;\n+      Discard_Quotient  : Boolean := False;\n+      Discard_Remainder : Boolean := False);\n+   --  Returns the Quotient and Remainder from dividing abs (X) by abs (Y). The\n+   --  values of X and Y are not modified. If Discard_Quotient is True, then\n+   --  Quotient is undefined on return, and if Discard_Remainder is True, then\n+   --  Remainder is undefined on return. Service routine for Big_Div/Rem/Mod.\n+\n+   procedure Free_Bignum (X : Bignum) is null;\n+   --  Called to free a Bignum value used in intermediate computations. In\n+   --  this implementation using the secondary stack, does nothing at all,\n+   --  because we rely on Mark/Release, but it may be of use for some\n+   --  alternative implementation.\n+\n+   function Normalize\n+     (X   : Digit_Vector;\n+      Neg : Boolean := False) return Bignum\n+   with Pre  => X'First = 1;\n+   --  Given a digit vector and sign, allocate and construct a Bignum value.\n+   --  Note that X may have leading zeroes which must be removed, and if the\n+   --  result is zero, the sign is forced positive.\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (X, Y : Digit_Vector; X_Neg, Y_Neg : Boolean) return Bignum is\n+   begin\n+      --  If signs are the same we are doing an addition, it is convenient to\n+      --  ensure that the first operand is the longer of the two,\n+\n+      if X_Neg = Y_Neg then\n+         if X'Last < Y'Last then\n+            return Add (Y => X, X => Y, X_Neg => Y_Neg, Y_Neg => X_Neg);\n+\n+         --  Here signs are the same, and the first operand is the longer\n+\n+         else\n+            pragma Assert (X_Neg = Y_Neg and then X'Last >= Y'Last);\n+\n+            --  Do addition, putting result in Sum (allowing for carry)\n+\n+            declare\n+               Sum : Digit_Vector (0 .. X'Last);\n+               RD  : DD;\n+\n+            begin\n+               RD := 0;\n+               for J in reverse 1 .. X'Last loop\n+                  RD := RD + DD (X (J));\n+\n+                  if J >= 1 + (X'Last - Y'Last)  then\n+                     RD := RD + DD (Y (J - (X'Last - Y'Last)));\n+                  end if;\n+\n+                  Sum (J) := LSD (RD);\n+                  RD := RD / Base;\n+               end loop;\n+\n+               Sum (0) := SD (RD);\n+               return Normalize (Sum, X_Neg);\n+            end;\n+         end if;\n+\n+         --  Signs are different so really this is an subtraction, we want to\n+         --  make sure that the largest magnitude operand is the first one, and\n+         --  then the result will have the sign of the first operand.\n+\n+      else\n+         declare\n+            CR : constant Compare_Result := Compare (X, Y, False, False);\n+\n+         begin\n+            if CR = EQ then\n+               return Normalize (Zero_Data);\n+\n+            elsif CR = LT then\n+               return Add (Y => X, X => Y, X_Neg => Y_Neg, Y_Neg => X_Neg);\n+\n+            else\n+               pragma Assert (X_Neg /= Y_Neg and then CR = GT);\n+\n+               --  Do subtraction, putting result in Diff\n+\n+               declare\n+                  Diff : Digit_Vector (1 .. X'Length);\n+                  RD    : DD;\n+\n+               begin\n+                  RD := 0;\n+                  for J in reverse 1 .. X'Last loop\n+                     RD := RD + DD (X (J));\n+\n+                     if J >= 1 + (X'Last - Y'Last)  then\n+                        RD := RD - DD (Y (J - (X'Last - Y'Last)));\n+                     end if;\n+\n+                     Diff (J) := LSD (RD);\n+                     RD := (if RD < Base then 0 else -1);\n+                  end loop;\n+\n+                  return Normalize (Diff, X_Neg);\n+               end;\n+            end if;\n+         end;\n+      end if;\n+   end Add;\n+\n+   ---------------------\n+   -- Allocate_Bignum --\n+   ---------------------\n+\n+   function Allocate_Bignum (Len : Length) return Bignum is\n+      Addr : Address;\n+\n+      --  The following definitions are to allow us to set the discriminant\n+\n+      type Header is record\n+         Len : Length;\n+         Neg : Boolean;\n+      end record;\n+\n+      for Header use record\n+         Len at 0 range 0 .. 23;\n+         Neg at 3 range 0 .. 7;\n+      end record;\n+\n+      type Header_Ptr is access all Header;\n+\n+      function To_Header_Ptr is new Unchecked_Conversion (Address, Header_Ptr);\n+      function To_Bignum     is new Unchecked_Conversion (Address, Bignum);\n+\n+   begin\n+      if True then\n+         declare\n+            B : Bignum;\n+         begin\n+            B := new Bignum_Data'(Len, False, (others => 0));\n+            return B;\n+         end;\n+\n+      else\n+         SS_Allocate (Addr, Storage_Offset (4 + 4 * Len));\n+         To_Header_Ptr (Addr).Len := Len;\n+         return To_Bignum (Addr);\n+      end if;\n+   end Allocate_Bignum;\n+\n+   -------------\n+   -- Big_Abs --\n+   -------------\n+\n+   function Big_Abs (X : Bignum) return Bignum is\n+   begin\n+      return Normalize (X.D);\n+   end Big_Abs;\n+\n+   -------------\n+   -- Big_Add --\n+   -------------\n+\n+   function Big_Add  (X, Y : Bignum) return Bignum is\n+   begin\n+      return Add (X.D, Y.D, X.Neg, Y.Neg);\n+   end Big_Add;\n+\n+   -------------\n+   -- Big_Div --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  varies with the signs of the operands.\n+\n+   --   A      B   A/B      A     B    A/B\n+   --\n+   --   10     5    2      -10    5    -2\n+   --   11     5    2      -11    5    -2\n+   --   12     5    2      -12    5    -2\n+   --   13     5    2      -13    5    -2\n+   --   14     5    2      -14    5    -2\n+   --\n+   --   A      B   A/B      A     B    A/B\n+   --\n+   --   10    -5   -2      -10   -5     2\n+   --   11    -5   -2      -11   -5     2\n+   --   12    -5   -2      -12   -5     2\n+   --   13    -5   -2      -13   -5     2\n+   --   14    -5   -2      -14   -5     2\n+\n+   function Big_Div  (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+   begin\n+      Div_Rem (X, Y, Q, R, Discard_Remainder => True);\n+      Q.Neg := Q.Len > 0 and then (X.Neg xor Y.Neg);\n+      return Q;\n+   end Big_Div;\n+\n+   -------------\n+   -- Big_Exp --\n+   -------------\n+\n+   function Big_Exp  (X, Y : Bignum) return Bignum is\n+\n+      function \"**\" (X : Bignum; Y : SD) return Bignum;\n+      --  Internal routine where we know right operand is one word\n+\n+      ----------\n+      -- \"**\" --\n+      ----------\n+\n+      function \"**\" (X : Bignum; Y : SD) return Bignum is\n+      begin\n+         case Y is\n+\n+            --  X ** 0 is 1\n+\n+            when 0 =>\n+               return Normalize (One_Data);\n+\n+            --  X ** 1 is X\n+\n+            when 1 =>\n+               return Normalize (X.D);\n+\n+            --  X ** 2 is X * X\n+\n+            when 2 =>\n+               return Big_Mul (X, X);\n+\n+            --  For X greater than 2, use the recursion\n+\n+            --  X even, X ** Y = (X ** (Y/2)) ** 2;\n+            --  X odd,  X ** Y = (X ** (Y/2)) ** 2 * X;\n+\n+            when others =>\n+               declare\n+                  XY2  : constant Bignum := X ** (Y / 2);\n+                  XY2S : constant Bignum := Big_Mul (XY2, XY2);\n+                  Res  : Bignum;\n+\n+               begin\n+                  Free_Bignum (XY2);\n+\n+                  if (Y and 1) = 0 then\n+                     return XY2S;\n+\n+                  else\n+                     Res := Big_Mul (XY2S, X);\n+                     Free_Bignum (XY2S);\n+                     return Res;\n+                  end if;\n+               end;\n+         end case;\n+      end \"**\";\n+\n+   --  Start of processing for Big_Exp\n+\n+   begin\n+      --  Error if right operand negative\n+\n+      if Y.Neg then\n+         raise Constraint_Error with \"exponentiation to negative power\";\n+\n+      --  0 ** X is always 0\n+\n+      elsif X.Len = 0 then\n+         return Normalize (Zero_Data);\n+\n+      --  (+1) ** Y = 1\n+      --  (-1) ** Y = +/-1 depending on whether Y is even or odd\n+\n+      elsif X.Len = 1 and then X.D (1) = 1 then\n+         return Normalize\n+           (X.D, Neg => X.Neg and then ((Y.D (Y.Len) and 1) = 1));\n+\n+      --  If the absolute value of the base is greater than 1, then the\n+      --  exponent must not be bigger than one word, otherwise the result\n+      --  is ludicrously large, and we just signal Storage_Error right away.\n+\n+      elsif Y.Len > 1 then\n+         raise Storage_Error with \"exponentiation result is too large\";\n+\n+      --  Special case (+/-)2 ** K, where K is 31 or less using a shift\n+\n+      elsif X.Len = 1 and then X.D (1) = 2 and then Y.D (1) < 32 then\n+         declare\n+            D : constant Digit_Vector (1 .. 1) :=\n+                  (1 => Shift_Left (SD'(1), Natural (Y.D (1) - 1)));\n+         begin\n+            return Normalize (D, X.Neg);\n+         end;\n+\n+      --  Remaining cases have right operand of one word\n+\n+      else\n+         return X ** Y.D (1);\n+      end if;\n+   end Big_Exp;\n+\n+   ------------\n+   -- Big_EQ --\n+   ------------\n+\n+   function Big_EQ  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = EQ;\n+   end Big_EQ;\n+\n+   ------------\n+   -- Big_GE --\n+   ------------\n+\n+   function Big_GE  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= LT;\n+   end Big_GE;\n+\n+   ------------\n+   -- Big_GT --\n+   ------------\n+\n+   function Big_GT  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = GT;\n+   end Big_GT;\n+\n+   ------------\n+   -- Big_LE --\n+   ------------\n+\n+   function Big_LE  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= GT;\n+   end Big_LE;\n+\n+   ------------\n+   -- Big_LT --\n+   ------------\n+\n+   function Big_LT  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) = LT;\n+   end Big_LT;\n+\n+   -------------\n+   -- Big_Mod --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  of Rem and Mod vary with the signs of the operands.\n+\n+   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n+\n+   --   10     5       0        0       -10    5       0        0\n+   --   11     5       1        1       -11    5       4       -1\n+   --   12     5       2        2       -12    5       3       -2\n+   --   13     5       3        3       -13    5       2       -3\n+   --   14     5       4        4       -14    5       1       -4\n+\n+   --   A      B    A mod B  A rem B     A     B    A mod B  A rem B\n+\n+   --   10    -5       0        0       -10   -5       0        0\n+   --   11    -5      -4        1       -11   -5      -1       -1\n+   --   12    -5      -3        2       -12   -5      -2       -2\n+   --   13    -5      -2        3       -13   -5      -3       -3\n+   --   14    -5      -1        4       -14   -5      -4       -4\n+\n+   function Big_Mod  (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+\n+   begin\n+      --  If signs are same, result is same as Rem\n+\n+      if X.Neg = Y.Neg then\n+         return Big_Rem (X, Y);\n+\n+      --  Case where mod is different\n+\n+      else\n+         --  Do division\n+\n+         Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n+\n+         --  Zero result is unchanged\n+\n+         if R.Len = 0 then\n+            return R;\n+\n+         --  Otherwise adjust result\n+\n+         else\n+            declare\n+               T1 : constant Bignum := Big_Sub (Y, R);\n+            begin\n+               T1.Neg := X.Neg;\n+               Free_Bignum (R);\n+               return T1;\n+            end;\n+         end if;\n+      end if;\n+   end Big_Mod;\n+\n+   -------------\n+   -- Big_Mul --\n+   -------------\n+\n+   function Big_Mul (X, Y : Bignum) return Bignum is\n+      Result : Digit_Vector (1 .. X.Len + Y.Len) := (others => 0);\n+      --  Accumulate result (max length of result is sum of operand lengths)\n+\n+      L : Length;\n+      --  Current result digit\n+\n+      D : DD;\n+      --  Result digit\n+\n+   begin\n+      for J in 1 .. X.Len loop\n+         for K in 1 .. Y.Len loop\n+            L := Result'Last - (X.Len - J) - (Y.Len - K);\n+            D := DD (X.D (J)) * DD (Y.D (K)) + DD (Result (L));\n+            Result (L) := LSD (D);\n+            D := D / Base;\n+\n+            --  D is carry which must be propagated\n+\n+            while D /= 0 and then L >= 1 loop\n+               L := L - 1;\n+               D := D + DD (Result (L));\n+               Result (L) := LSD (D);\n+               D := D / Base;\n+            end loop;\n+\n+            --  Must not have a carry trying to extend max length\n+\n+            pragma Assert (D = 0);\n+         end loop;\n+      end loop;\n+\n+      --  Return result\n+\n+      return Normalize (Result, X.Neg xor Y.Neg);\n+   end Big_Mul;\n+\n+   ------------\n+   -- Big_NE --\n+   ------------\n+\n+   function Big_NE  (X, Y : Bignum) return Boolean is\n+   begin\n+      return Compare (X.D, Y.D, X.Neg, Y.Neg) /= EQ;\n+   end Big_NE;\n+\n+   -------------\n+   -- Big_Neg --\n+   -------------\n+\n+   function Big_Neg (X : Bignum) return Bignum is\n+   begin\n+      return Normalize (X.D, not X.Neg);\n+   end Big_Neg;\n+\n+   -------------\n+   -- Big_Rem --\n+   -------------\n+\n+   --  This table is excerpted from RM 4.5.5(28-30) and shows how the result\n+   --  varies with the signs of the operands.\n+\n+   --   A      B   A rem B   A     B   A rem B\n+\n+   --   10     5      0     -10    5      0\n+   --   11     5      1     -11    5     -1\n+   --   12     5      2     -12    5     -2\n+   --   13     5      3     -13    5     -3\n+   --   14     5      4     -14    5     -4\n+\n+   --   A      B  A rem B    A     B   A rem B\n+\n+   --   10    -5     0      -10   -5      0\n+   --   11    -5     1      -11   -5     -1\n+   --   12    -5     2      -12   -5     -2\n+   --   13    -5     3      -13   -5     -3\n+   --   14    -5     4      -14   -5     -4\n+\n+   function Big_Rem  (X, Y : Bignum) return Bignum is\n+      Q, R : Bignum;\n+   begin\n+      Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n+      R.Neg :=  R.Len > 0 and then X.Neg;\n+      return R;\n+   end Big_Rem;\n+\n+   -------------\n+   -- Big_Sub --\n+   -------------\n+\n+   function Big_Sub (X, Y : Bignum) return Bignum is\n+   begin\n+      --  If right operand zero, return left operand\n+\n+      if Y.Len = 0 then\n+         return Normalize (X.D, X.Neg);\n+\n+      --  Otherwise add negative of right operand\n+\n+      else\n+         return Add (X.D, Y.D, X.Neg, not Y.Neg);\n+      end if;\n+   end Big_Sub;\n+\n+   -------------\n+   -- Compare --\n+   -------------\n+\n+   function Compare\n+     (X, Y         : Digit_Vector;\n+      X_Neg, Y_Neg : Boolean) return Compare_Result\n+   is\n+   begin\n+      --  Signs are different, that's decisive, since 0 is always plus\n+\n+      if X_Neg /= Y_Neg then\n+         return (if X_Neg then LT else GT);\n+\n+      --  Lengths are different, that's decisive since no leading zeroes\n+\n+      elsif X'Last /= Y'Last then\n+         return (if (X'Last > Y'Last) xor X_Neg then GT else LT);\n+\n+      --  Need to compare data\n+\n+      else\n+         for J in X'Range loop\n+            if X (J) /= Y (J) then\n+               return (if (X (J) > Y (J)) xor X_Neg then GT else LT);\n+            end if;\n+         end loop;\n+\n+         return EQ;\n+      end if;\n+   end Compare;\n+\n+   -------------\n+   -- Div_Rem --\n+   -------------\n+\n+   procedure Div_Rem\n+     (X, Y              : Bignum;\n+      Quotient          : out Bignum;\n+      Remainder         : out Bignum;\n+      Discard_Quotient  : Boolean := False;\n+      Discard_Remainder : Boolean := False)\n+   is\n+   begin\n+      --  Error if division by zero\n+\n+      if Y.Len = 0 then\n+         raise Constraint_Error with \"division by zero\";\n+      end if;\n+\n+      --  Handle simple cases with special tests\n+\n+      --  If X < Y then quotient is zero and remainder is X\n+\n+      if Compare (X.D, Y.D, False, False) = LT then\n+         Remainder := Normalize (X.D);\n+         Quotient := Normalize (Zero_Data);\n+         return;\n+\n+      --  If both X and Y are comfortably less than 2**63-1 we can just use\n+      --  Long_Long_Integer arithmetic. Note it is good not to do an accurate\n+      --  range check here since -2**63 / -1 overflows!\n+\n+      elsif (X.Len <= 1 or else (X.Len = 2 and then X.D (1) <= 2**31))\n+              and then\n+            (Y.Len <= 1 or else (Y.Len = 2 and then Y.D (1) <= 2**31))\n+      then\n+         declare\n+            A : constant LLI := abs (From_Bignum (X));\n+            B : constant LLI := abs (From_Bignum (Y));\n+         begin\n+            Quotient  := To_Bignum (A / B);\n+            Remainder := To_Bignum (A rem B);\n+            return;\n+         end;\n+\n+      --  Easy case if divisor is one digit\n+\n+      elsif Y.Len = 1 then\n+         declare\n+            ND  : DD;\n+            Div : constant DD := DD (Y.D (1));\n+\n+            Result : Digit_Vector (1 .. X.Len);\n+            Remdr  : Digit_Vector (1 .. 1);\n+\n+         begin\n+            ND := 0;\n+            for J in 1 .. X.Len loop\n+               ND := Base * ND + DD (X.D (J));\n+               Result (J) := SD (ND / Div);\n+               ND := ND rem Div;\n+            end loop;\n+\n+            Quotient := Normalize (Result);\n+            Remdr (1) := SD (ND);\n+            Remainder := Normalize (Remdr);\n+            return;\n+         end;\n+      end if;\n+\n+      --  The complex full multi-precision case. We will employ algorithm\n+      --  D defined in the section \"The Classical Algorithms\" (sec. 4.3.1)\n+      --  of Donald Knuth's \"The Art of Computer Programming\", Vol. 2. The\n+      --  terminology is adjusted for this section to match that reference.\n+\n+      --  We are dividing X.Len digits of X (called u here) by Y.Len digits\n+      --  of Y (called v here), developing the quotient and remainder. The\n+      --  numbers are represented using Base, which was chosen so that we have\n+      --  the operations of multiplying to single digits (SD) to form a double\n+      --  digit (DD), and dividing a double digit (DD) by a single digit (SD)\n+      --  to give a single digit quotient and a single digit remainder.\n+\n+      --  Algorithm D from Knuth\n+\n+      --  Comments here with square brackets are directly from Knuth\n+\n+      Algorithm_D : declare\n+\n+         --  The following lower case variables correspond exactly to the\n+         --  terminology used in algorithm D.\n+\n+         m : constant Length := X.Len - Y.Len;\n+         n : constant Length := Y.Len;\n+         b : constant DD     := Base;\n+\n+         u : Digit_Vector (0 .. m + n);\n+         v : Digit_Vector (1 .. n);\n+         q : Digit_Vector (0 .. m);\n+         r : Digit_Vector (1 .. n);\n+\n+         u0 : SD renames u (0);\n+         v1 : SD renames v (1);\n+         v2 : SD renames v (2);\n+\n+         d    : DD;\n+         j    : Length;\n+         qhat : SD;\n+\n+      begin\n+         --  Initialize data of left and right operands\n+\n+         for J in 1 .. m + n loop\n+            u (J) := X.D (J);\n+         end loop;\n+\n+         for J in 1 .. n loop\n+            v (J) := Y.D (J);\n+         end loop;\n+\n+         --  [Division of nonnegative integers]. Given nonnegative integers u\n+         --  = (ul,u2..um+n) and v = (v1,v2..vn), where v1 /= 0 and n > 1, we\n+         --  form the quotient u / v = (q0,ql..qm) and the remainder u mod v =\n+         --  (r1,r2..rn).\n+\n+         pragma Assert (v (1) /= 0);\n+         pragma Assert (n > 1);\n+\n+         --  Dl. [Normalize.] Set d = b/(vl + 1). Then set (u0,u1,u2..um+n)\n+         --  equal to (u1,u2..um+n) times d, and set (v1,v2..vn) equal to\n+         --  (v1,v2..vn) times d. Note the introduction of a new digit position\n+         --  u0 at the left of u1; if d = 1 all we need to do in this step is\n+         --  to set u0 = 0.\n+\n+         d := b / DD (v1 + 1);\n+\n+         if d = 1 then\n+            u0 := 0;\n+\n+         else\n+            declare\n+               Carry : DD;\n+               Tmp   : DD;\n+\n+            begin\n+               --  Multiply Dividend (u) by d\n+\n+               Carry := 0;\n+               for J in reverse 1 .. m + n loop\n+                  Tmp   := DD (u (J)) * d + Carry;\n+                  u (J) := LSD (Tmp);\n+                  Carry := Tmp / Base;\n+               end loop;\n+\n+               u0 := SD (Carry);\n+\n+               --  Multiply Divisor (v) by d\n+\n+               Carry := 0;\n+               for J in reverse 1 .. n loop\n+                  Tmp    := DD (v (J)) * d + Carry;\n+                  v (J)  := LSD (Tmp);\n+                  Carry  := Tmp / Base;\n+               end loop;\n+\n+               pragma Assert (Carry = 0);\n+            end;\n+         end if;\n+\n+         --  D2. [Initialize j.] Set j = 0. The loop on j, steps D2 through D7,\n+         --  will be essentially a division of (uj, uj+1..uj+n) by (v1,v2..vn)\n+         --  to get a single quotient digit qj;\n+\n+         j := 0;\n+\n+         --  Loop through digits\n+\n+         loop\n+            --  D3. [Calculate qhat] If uj = v1, set qhat to b-l; otherwise set\n+            --  qhat to (uj,uj+1)/v1.\n+\n+            if u (j) = v1 then\n+               qhat := -1;\n+            else\n+               qhat := SD ((u (j) & u (j + 1)) / DD (v1));\n+            end if;\n+\n+            --  D3 (continued). Now test if v2 * qhat is greater than (uj*b +\n+            --  uj+1 - qhat*v1)*b + uj+2. If so, decrease qhat by 1 and repeat\n+            --  this test, which determines at high speed most of the cases in\n+            --  which the trial value qhat is one too large, and it eliminates\n+            --  all cases where qhat is two too large.\n+\n+            while DD (v2) * DD (qhat) >\n+                   ((u (j) & u (j + 1)) -\n+                     DD (qhat) * DD (v1)) * b + DD (u (j + 2))\n+            loop\n+               qhat := qhat - 1;\n+            end loop;\n+\n+            --  D4. [Multiply and subtract.] Replace (uj,uj+1..uj+n) by\n+            --  (uj,uj+1..uj+n) minus qhat times (v1,v2..vn). This step\n+            --  consists of a simple multiplication by a one-place number,\n+            --  combined with a subtraction.\n+\n+            --  The digits (uj,uj+1..uj+n) are always kept positive; if the\n+            --  result of this step is actually negative then (uj,uj+1..uj+n)\n+            --  is left as the true value plus b**(n+1), i.e. as the b's\n+            --  complement of the true value, and a \"borrow\" to the left is\n+            --  remembered.\n+\n+            declare\n+               Borrow : SD;\n+               Carry  : DD;\n+               Temp   : DD;\n+\n+               Negative : Boolean;\n+               --  Records if subtraction causes a negative result, requiring\n+               --  an add back (case where qhat turned out to be 1 too large).\n+\n+            begin\n+               Borrow := 0;\n+               for K in reverse 1 .. n loop\n+                  Temp := DD (qhat) * DD (v (K)) + DD (Borrow);\n+                  Borrow := MSD (Temp);\n+\n+                  if LSD (Temp) > u (j + K) then\n+                     Borrow := Borrow + 1;\n+                  end if;\n+\n+                  u (j + K) := u (j + K) - LSD (Temp);\n+               end loop;\n+\n+               Negative := u (j) < Borrow;\n+               u (j) := u (j) - Borrow;\n+\n+               --  D5. [Test remainder.] Set qj = qhat. If the result of step\n+               --  D4 was negative, we will do the add back step (step D6).\n+\n+               q (j) := qhat;\n+\n+               if Negative then\n+\n+                  --  D6. [Add back.] Decrease qj by 1, and add (0,v1,v2..vn)\n+                  --  to (uj,uj+1,uj+2..uj+n). (A carry will occur to the left\n+                  --  of uj, and it is be ignored since it cancels with the\n+                  --  borrow that occurred in D4.)\n+\n+                  q (j) := q (j) - 1;\n+\n+                  Carry := 0;\n+                  for K in reverse 1 .. n loop\n+                     Temp := DD (v (K)) + DD (u (j + K)) + Carry;\n+                     u (j + K) := LSD (Temp);\n+                     Carry := Temp / Base;\n+                  end loop;\n+\n+                  u (j) := u (j) + SD (Carry);\n+               end if;\n+            end;\n+\n+            --  D7. [Loop on j.] Increase j by one. Now if j <= m, go back to\n+            --  D3 (the start of the loop on j).\n+\n+            j := j + 1;\n+            exit when not (j <= m);\n+         end loop;\n+\n+         --  D8. [Unnormalize.] Now (qo,ql..qm) is the desired quotient, and\n+         --  the desired remainder may be obtained by dividing (um+1..um+n)\n+         --  by d.\n+\n+         if not Discard_Quotient then\n+            Quotient := Normalize (q);\n+         end if;\n+\n+         if not Discard_Remainder then\n+            declare\n+               Remdr : DD;\n+\n+            begin\n+               Remdr := 0;\n+               for K in 1 .. n loop\n+                  Remdr := Base * Remdr + DD (u (m + K));\n+                  r (K) := SD (Remdr / d);\n+                  Remdr := Remdr rem d;\n+               end loop;\n+\n+               pragma Assert (Remdr = 0);\n+            end;\n+\n+            Remainder := Normalize (r);\n+         end if;\n+      end Algorithm_D;\n+   end Div_Rem;\n+\n+   -----------------\n+   -- From_Bignum --\n+   -----------------\n+\n+   function From_Bignum (X : Bignum) return Long_Long_Integer is\n+   begin\n+      if X.Len = 0 then\n+         return 0;\n+\n+      elsif X.Len = 1 then\n+         return (if X.Neg then -LLI (X.D (1)) else LLI (X.D (1)));\n+\n+      elsif X.Len = 2 then\n+         declare\n+            Mag : constant DD := X.D (1) & X.D (2);\n+         begin\n+            if X.Neg and then Mag <= 2 ** 63 then\n+               return -LLI (Mag);\n+            elsif Mag < 2 ** 63 then\n+               return LLI (Mag);\n+            end if;\n+         end;\n+      end if;\n+\n+      raise Constraint_Error with \"expression value out of range\";\n+   end From_Bignum;\n+\n+   ---------------\n+   -- Normalize --\n+   ---------------\n+\n+   function Normalize\n+     (X   : Digit_Vector;\n+      Neg : Boolean := False) return Bignum\n+   is\n+      B : Bignum;\n+      J : Length;\n+\n+   begin\n+      J := X'First;\n+      while J <= X'Last and then X (J) = 0 loop\n+         J := J + 1;\n+      end loop;\n+\n+      B := Allocate_Bignum (X'Last - J + 1);\n+      B.Neg :=  B.Len > 0 and then Neg;\n+      B.D := X (J .. X'Last);\n+      return B;\n+   end Normalize;\n+\n+   ---------------\n+   -- To_Bignum --\n+   ---------------\n+\n+   function To_Bignum (X : Long_Long_Integer) return Bignum is\n+      R : Bignum;\n+\n+   begin\n+      if X = 0 then\n+         R := Allocate_Bignum (0);\n+\n+      elsif X in -(2 ** 32 - 1) .. +(2 ** 32 - 1) then\n+         R := Allocate_Bignum (1);\n+         R.D (1) := SD (abs (X));\n+\n+      else\n+         R := Allocate_Bignum (2);\n+         R.D (2) := SD (abs (X) mod Base);\n+         R.D (1) := SD (abs (X) / Base);\n+      end if;\n+\n+      R.Neg := X < 0;\n+      return R;\n+   end To_Bignum;\n+\n+end System.Bignums;"}, {"sha": "de414a571e8ec01e110e656f96f56ecefff95695", "filename": "gcc/ada/s-bignum.ads", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fs-bignum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fs-bignum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -0,0 +1,102 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . B I G N U M S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2012, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides arbitrary precision signed integer arithmetic for\n+--  use in computing intermediate values in expressions for the case where\n+--  pragma Overflow_Check (Eliminate) is in effect.\n+\n+with Interfaces;\n+\n+package System.Bignums is\n+\n+   subtype Length is Natural range 0 .. 2 ** 23 - 1;\n+   --  Represent number of words in Digit_Vector\n+\n+   Base : constant := 2 ** 32;\n+   --  Digit vectors use this base\n+\n+   subtype SD is Interfaces.Unsigned_32;\n+   --  Single length digit\n+\n+   type Digit_Vector is array (Length range <>) of SD;\n+   --  Represent digits of a number (most significant digit first)\n+\n+   type Bignum_Data (Len : Length) is record\n+      Neg : Boolean;\n+      --  Set if value is negative, never set for zero\n+\n+      D : Digit_Vector (1 .. Len);\n+      --  Digits of number, most significant first, represented in base\n+      --  2**Base. No leading zeroes are stored, and the value of zero is\n+      --  represented using an empty vector for D.\n+   end record;\n+\n+   for Bignum_Data use record\n+      Len at 0 range 0 .. 23;\n+      Neg at 3 range 0 .. 7;\n+   end record;\n+\n+   type Bignum is access all Bignum_Data;\n+\n+   --  Note: none of the subprograms in this package modify the Bignum_Data\n+   --  records referenced by Bignum arguments of mode IN.\n+\n+   function Big_Add (X, Y : Bignum) return Bignum;  --  \"+\"\n+   function Big_Sub (X, Y : Bignum) return Bignum;  --  \"-\"\n+   function Big_Mul (X, Y : Bignum) return Bignum;  --  \"*\"\n+   function Big_Div (X, Y : Bignum) return Bignum;  --  \"/\"\n+   function Big_Exp (X, Y : Bignum) return Bignum;  --  \"**\"\n+   function Big_Mod (X, Y : Bignum) return Bignum;  --  \"mod\"\n+   function Big_Rem (X, Y : Bignum) return Bignum;  --  \"rem\"\n+   function Big_Neg (X    : Bignum) return Bignum;  --  \"-\"\n+   function Big_Abs (X    : Bignum) return Bignum;  --  \"abs\"\n+   --  Perform indicated arithmetic operation on bignum values. No exception\n+   --  raised except for Div/Mod/Rem by 0 which raises Constraint_Error with\n+   --  an appropriate message.\n+\n+   function Big_EQ  (X, Y : Bignum) return Boolean;  -- \"=\"\n+   function Big_NE  (X, Y : Bignum) return Boolean;  -- \"/=\"\n+   function Big_GE  (X, Y : Bignum) return Boolean;  -- \">=\"\n+   function Big_LE  (X, Y : Bignum) return Boolean;  -- \"<=\"\n+   function Big_GT  (X, Y : Bignum) return Boolean;  --  \">\"\n+   function Big_LT  (X, Y : Bignum) return Boolean;  --  \"<\"\n+   --  Perform indicated comparison on bignums, returning result as Boolean.\n+   --  No exception raised for any input arguments.\n+\n+   function To_Bignum (X : Long_Long_Integer) return Bignum;\n+   --  Convert Long_Long_Integer to Bignum. No exception can be raised for any\n+   --  input argument.\n+\n+   function From_Bignum (X : Bignum) return Long_Long_Integer;\n+   --  Convert Bignum to Long_Long_Integer. Constraint_Error raised with\n+   --  appropriate message if value is out of range of Long_Long_Integer.\n+\n+end System.Bignums;"}, {"sha": "fc0d74a022e70e7cb8e5a562ed1c77f0cf1c10b6", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -1218,59 +1218,6 @@ package body Sem is\n       end if;\n    end Insert_List_Before_And_Analyze;\n \n-   -------------------------\n-   -- Is_Check_Suppressed --\n-   -------------------------\n-\n-   function Is_Check_Suppressed (E : Entity_Id; C : Check_Id) return Boolean is\n-\n-      Ptr : Suppress_Stack_Entry_Ptr;\n-\n-   begin\n-      --  First search the local entity suppress stack. We search this from the\n-      --  top of the stack down so that we get the innermost entry that applies\n-      --  to this case if there are nested entries.\n-\n-      Ptr := Local_Suppress_Stack_Top;\n-      while Ptr /= null loop\n-         if (Ptr.Entity = Empty or else Ptr.Entity = E)\n-           and then (Ptr.Check = All_Checks or else Ptr.Check = C)\n-         then\n-            return Ptr.Suppress;\n-         end if;\n-\n-         Ptr := Ptr.Prev;\n-      end loop;\n-\n-      --  Now search the global entity suppress table for a matching entry.\n-      --  We also search this from the top down so that if there are multiple\n-      --  pragmas for the same entity, the last one applies (not clear what\n-      --  or whether the RM specifies this handling, but it seems reasonable).\n-\n-      Ptr := Global_Suppress_Stack_Top;\n-      while Ptr /= null loop\n-         if (Ptr.Entity = Empty or else Ptr.Entity = E)\n-           and then (Ptr.Check = All_Checks or else Ptr.Check = C)\n-         then\n-            return Ptr.Suppress;\n-         end if;\n-\n-         Ptr := Ptr.Prev;\n-      end loop;\n-\n-      --  If we did not find a matching entry, then use the normal scope\n-      --  suppress value after all (actually this will be the global setting\n-      --  since it clearly was not overridden at any point). For a predefined\n-      --  check, we test the specific flag. For a user defined check, we check\n-      --  the All_Checks flag.\n-\n-      if C in Predefined_Check_Id then\n-         return Scope_Suppress.Suppress (C);\n-      else\n-         return Scope_Suppress.Suppress (All_Checks);\n-      end if;\n-   end Is_Check_Suppressed;\n-\n    ----------\n    -- Lock --\n    ----------"}, {"sha": "31fc37b95af9e056e9929617ec5528f30925fcf7", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -641,13 +641,6 @@ package Sem is\n    --  This function returns True if an explicit pragma Suppress for check C\n    --  is present in the package defining E.\n \n-   function Is_Check_Suppressed (E : Entity_Id; C : Check_Id) return Boolean;\n-   --  This function is called if Checks_May_Be_Suppressed (E) is True to\n-   --  determine whether check C is suppressed either on the entity E or\n-   --  as the result of a scope suppress pragma. If Checks_May_Be_Suppressed\n-   --  is False, then the status of the check can be determined simply by\n-   --  examining Scope_Checks (C), so this routine is not called in that case.\n-\n    procedure Preanalyze (N : Node_Id);\n    --  Performs a pre-analysis of node N. During pre-analysis no expansion is\n    --  carried out for N or its children. For more info on pre-analysis read"}, {"sha": "7de11fd428c0fdfa42b34f327e96dad48d483f1f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -5685,8 +5685,8 @@ package body Sem_Prag is\n                Scope_Suppress.Overflow_Checks_General    := Suppressed;\n                Scope_Suppress.Overflow_Checks_Assertions := Suppressed;\n             else\n-               Scope_Suppress.Overflow_Checks_General    := Minimized;\n-               Scope_Suppress.Overflow_Checks_Assertions := Minimized;\n+               Scope_Suppress.Overflow_Checks_General    := Checked;\n+               Scope_Suppress.Overflow_Checks_Assertions := Checked;\n             end if;\n          end if;\n "}, {"sha": "d3563480aae65437edb38b1a2c07853abb6a7823", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -4965,10 +4965,7 @@ package body Sem_Res is\n            (\"operation should be qualified or explicitly converted\", N);\n       end if;\n \n-      --  Set overflow and division checking bit. Much cleverer code needed\n-      --  here eventually and perhaps the Resolve routines should be separated\n-      --  for the various arithmetic operations, since they will need\n-      --  different processing. ???\n+      --  Set overflow and division checking bit\n \n       if Nkind (N) in N_Op then\n          if not Overflow_Checks_Suppressed (Etype (N)) then"}, {"sha": "e8a3d9a7df952a0e33c676e608ee7d19dcc64eda", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -408,6 +408,14 @@ package Sinfo is\n    --       Do_Overflow_Check        (Flag17-Sem) set if overflow check needed\n    --       Has_Private_View         (Flag11-Sem) set in generic units.\n \n+   --       Note on use of entity field. This field is set during analysis\n+   --       and is used in carrying out semantic checking, but it has no\n+   --       significance to the back end, which is driven by the Etype's\n+   --       of the operands, and the Etype of the result. During processing\n+   --       in the exapander for overflow checks, these types may be modified\n+   --       and there is no point in trying to set a proper Entity value, so\n+   --       it just gets cleared to Empty in this situation.\n+\n    --    \"plus fields for unary operator\"\n    --       Chars                    (Name1)      Name_Id for the operator\n    --       Right_Opnd               (Node3)      right operand expression\n@@ -416,6 +424,8 @@ package Sinfo is\n    --       Do_Overflow_Check        (Flag17-Sem) set if overflow check needed\n    --       Has_Private_View         (Flag11-Sem) set in generic units.\n \n+   --       See note on use of Entity field above (same situation).\n+\n    --    \"plus fields for expression\"\n    --       Paren_Count                           number of parentheses levels\n    --       Etype                    (Node5-Sem)  type of the expression\n@@ -3849,6 +3859,22 @@ package Sinfo is\n       --  point operands if the Treat_Fixed_As_Integer flag is set and will\n       --  thus treat these nodes in identical manner, ignoring small values.\n \n+      --  Note on overflow handling: When the overflow checking mode is set to\n+      --  MINIMIZED or ELIMINATED, nodes for signed arithmetic operations may\n+      --  be modified to use a larger type for the operands and result. In\n+      --  these cases, the back end does not need the Entity field anyway, so\n+      --  there is no point in setting it. In fact we reuse the Entity field to\n+      --  record the possible range of the result. Entity points to an N_Range\n+      --  node whose Low_Bound and High_Bound fields point to integer literal\n+      --  nodes containing the computed bounds. These range nodes are only set\n+      --  for intermediate nodes whose parents are themselves either arithmetic\n+      --  operators, or comparison or membership tests. The computed ranges are\n+      --  then used in processing the parent operation. In the case where the\n+      --  computed range exceeds that of Long_Long_Integer, and we are running\n+      --  in ELIMINATED mode, the operator node will be changed to be a call to\n+      --  the appropriate routine in System.Bignums, and in this case we forget\n+      --  about keeping track of the range.\n+\n       ---------------------------------\n       -- 4.5.9 Quantified Expression --\n       ---------------------------------"}, {"sha": "3343d7c81c501f7a8cdc966270bbcdf1b2f38e9c", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -129,6 +129,15 @@ package body Tbuild is\n       end if;\n    end Convert_To;\n \n+   ----------------------------\n+   -- Convert_To_And_Rewrite --\n+   ----------------------------\n+\n+   procedure Convert_To_And_Rewrite (Typ : Entity_Id; Expr : Node_Id) is\n+   begin\n+      Rewrite (Expr, Convert_To (Typ, Expr));\n+   end Convert_To_And_Rewrite;\n+\n    ------------------\n    -- Discard_List --\n    ------------------"}, {"sha": "0feebe70cc50a3798e02dc255f89fe84e03d2e28", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,6 +48,12 @@ package Tbuild is\n    --  Exp. This means that it is safe to replace a node by a Convert_To\n    --  of itself to some other type.\n \n+   procedure Convert_To_And_Rewrite (Typ : Entity_Id; Expr : Node_Id);\n+   pragma Inline (Convert_To_And_Rewrite);\n+   --  Like the function, except that there is an extra step of calling\n+   --  Rewrite on the Expr node and replacing it with the converted result.\n+   --  As noted above, this is safe, because Relocate_Node is called.\n+\n    procedure Discard_Node (N : Node_Or_Entity_Id);\n    pragma Inline (Discard_Node);\n    --  This is a dummy procedure that simply returns and does nothing. It is"}, {"sha": "73b11ac2d6911c7170257d1de52b06fb6a500c82", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad3c0a0c949793de53b128adcadf0ecee2bd22/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=acad3c0a0c949793de53b128adcadf0ecee2bd22", "patch": "@@ -735,6 +735,11 @@ package Types is\n       --  overflow. Again the final value of an expression must fit in the base\n       --  type of the whole expression.\n \n+   subtype Minimized_Or_Eliminated is\n+     Overflow_Check_Type range Minimized .. Eliminated;\n+   --  Definte subtypes so that clients don't need to know ordering. Note that\n+   --  Overflow_Check_Type is not marked as an ordered enumeration type.\n+\n    --  The following structure captures the state of check suppression or\n    --  activation at a particular point in the program execution.\n "}]}