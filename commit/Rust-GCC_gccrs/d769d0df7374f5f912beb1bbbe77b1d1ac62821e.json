{"sha": "d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2OWQwZGY3Mzc0ZjVmOTEyYmViMWJiYmU3N2IxZDFhYzYyODIxZQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:53:42Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:53:42Z"}, "message": "trans-array.c (outermost_loop): New function.\n\n\t* trans-array.c (outermost_loop): New function.\n\t(gfc_trans_array_constructor, gfc_set_vector_loop_bounds,\n\tgfc_add_loop_ss_code): Put generated code out of the outermost loop.\n\nFrom-SVN: r180902", "tree": {"sha": "c757bf8b501e4683a2896011ce3bf95d93a12999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c757bf8b501e4683a2896011ce3bf95d93a12999"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d769d0df7374f5f912beb1bbbe77b1d1ac62821e/comments", "author": null, "committer": null, "parents": [{"sha": "f03077b0195ce62bdf0819c14e4a55ce10c13f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03077b0195ce62bdf0819c14e4a55ce10c13f77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f03077b0195ce62bdf0819c14e4a55ce10c13f77"}], "stats": {"total": 72, "additions": 47, "deletions": 25}, "files": [{"sha": "e073ddf916a44a1b634148cdf5440e5ea27bfab6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d769d0df7374f5f912beb1bbbe77b1d1ac62821e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d769d0df7374f5f912beb1bbbe77b1d1ac62821e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "patch": "@@ -1,3 +1,9 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (outermost_loop): New function.\n+\t(gfc_trans_array_constructor, gfc_set_vector_loop_bounds,\n+\tgfc_add_loop_ss_code): Put generated code out of the outermost loop.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (constant_array_constructor_loop_size):"}, {"sha": "0f3d1718521f2bdb02a915760970eed1ed51e48a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d769d0df7374f5f912beb1bbbe77b1d1ac62821e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d769d0df7374f5f912beb1bbbe77b1d1ac62821e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d769d0df7374f5f912beb1bbbe77b1d1ac62821e", "patch": "@@ -2108,6 +2108,16 @@ get_loop_upper_bound_for_array (gfc_ss *array, int array_dim)\n }\n \n \n+static gfc_loopinfo *\n+outermost_loop (gfc_loopinfo * loop)\n+{\n+  while (loop->parent != NULL)\n+    loop = loop->parent;\n+\n+  return loop;\n+}\n+\n+\n /* Array constructors are handled by constructing a temporary, then using that\n    within the scalarization loop.  This is not optimal, but seems by far the\n    simplest method.  */\n@@ -2125,7 +2135,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   bool dynamic;\n   bool old_first_len, old_typespec_chararray_ctor;\n   tree old_first_len_val;\n-  gfc_loopinfo *loop;\n+  gfc_loopinfo *loop, *outer_loop;\n   gfc_ss_info *ss_info;\n   gfc_expr *expr;\n   gfc_ss *s;\n@@ -2136,6 +2146,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   old_typespec_chararray_ctor = typespec_chararray_ctor;\n \n   loop = ss->loop;\n+  outer_loop = outermost_loop (loop);\n   ss_info = ss->info;\n   expr = ss_info->expr;\n \n@@ -2171,11 +2182,11 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t  gfc_conv_expr_type (&length_se, expr->ts.u.cl->length,\n \t\t\t      gfc_charlen_type_node);\n \t  ss_info->string_length = length_se.expr;\n-\t  gfc_add_block_to_block (&loop->pre, &length_se.pre);\n-\t  gfc_add_block_to_block (&loop->post, &length_se.post);\n+\t  gfc_add_block_to_block (&outer_loop->pre, &length_se.pre);\n+\t  gfc_add_block_to_block (&outer_loop->post, &length_se.post);\n \t}\n       else\n-\tconst_string = get_array_ctor_strlen (&loop->pre, c,\n+\tconst_string = get_array_ctor_strlen (&outer_loop->pre, c,\n \t\t\t\t\t      &ss_info->string_length);\n \n       /* Complex character array constructors should have been taken care of\n@@ -2252,15 +2263,15 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   if (TREE_CODE (*loop_ubound0) == VAR_DECL)\n     dynamic = true;\n \n-  gfc_trans_create_temp_array (&loop->pre, &loop->post, ss, type, NULL_TREE,\n-\t\t\t       dynamic, true, false, where);\n+  gfc_trans_create_temp_array (&outer_loop->pre, &outer_loop->post, ss, type,\n+\t\t\t       NULL_TREE, dynamic, true, false, where);\n \n   desc = ss_info->data.array.descriptor;\n   offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n   TREE_NO_WARNING (offsetvar) = 1;\n   TREE_USED (offsetvar) = 0;\n-  gfc_trans_array_constructor_value (&loop->pre, type, desc, c,\n+  gfc_trans_array_constructor_value (&outer_loop->pre, type, desc, c,\n \t\t\t\t     &offset, &offsetvar, dynamic);\n \n   /* If the array grows dynamically, the upper bound of the loop variable\n@@ -2270,10 +2281,10 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type,\n \t\t\t     offsetvar, gfc_index_one_node);\n-      tmp = gfc_evaluate_now (tmp, &loop->pre);\n+      tmp = gfc_evaluate_now (tmp, &outer_loop->pre);\n       gfc_conv_descriptor_ubound_set (&loop->pre, desc, gfc_rank_cst[0], tmp);\n       if (*loop_ubound0 && TREE_CODE (*loop_ubound0) == VAR_DECL)\n-\tgfc_add_modify (&loop->pre, *loop_ubound0, tmp);\n+\tgfc_add_modify (&outer_loop->pre, *loop_ubound0, tmp);\n       else\n \t*loop_ubound0 = tmp;\n     }\n@@ -2307,7 +2318,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n static void\n set_vector_loop_bounds (gfc_ss * ss)\n {\n-  gfc_loopinfo *loop;\n+  gfc_loopinfo *loop, *outer_loop;\n   gfc_array_info *info;\n   gfc_se se;\n   tree tmp;\n@@ -2316,6 +2327,8 @@ set_vector_loop_bounds (gfc_ss * ss)\n   int n;\n   int dim;\n \n+  outer_loop = outermost_loop (ss->loop);\n+\n   info = &ss->info->data.array;\n \n   for (; ss; ss = ss->parent)\n@@ -2343,7 +2356,7 @@ set_vector_loop_bounds (gfc_ss * ss)\n \t\t\t     gfc_array_index_type,\n \t\t\t     gfc_conv_descriptor_ubound_get (desc, zero),\n \t\t\t     gfc_conv_descriptor_lbound_get (desc, zero));\n-\t  tmp = gfc_evaluate_now (tmp, &loop->pre);\n+\t  tmp = gfc_evaluate_now (tmp, &outer_loop->pre);\n \t  loop->to[n] = tmp;\n \t}\n     }\n@@ -2358,14 +2371,16 @@ static void\n gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t\t      locus * where)\n {\n-  gfc_loopinfo *nested_loop;\n+  gfc_loopinfo *nested_loop, *outer_loop;\n   gfc_se se;\n   gfc_ss_info *ss_info;\n   gfc_array_info *info;\n   gfc_expr *expr;\n   bool skip_nested = false;\n   int n;\n \n+  outer_loop = outermost_loop (loop);\n+\n   /* TODO: This can generate bad code if there are ordering dependencies,\n      e.g., a callee allocated function and an unknown size constructor.  */\n   gcc_assert (ss != NULL);\n@@ -2389,7 +2404,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t     dimension indices, but not array section bounds.  */\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, expr);\n-\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n+\t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \n \t  if (expr->ts.type != BT_CHARACTER)\n \t    {\n@@ -2398,11 +2413,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t      if (subscript)\n \t\tse.expr = convert(gfc_array_index_type, se.expr);\n \t      if (!ss_info->where)\n-\t\tse.expr = gfc_evaluate_now (se.expr, &loop->pre);\n-\t      gfc_add_block_to_block (&loop->pre, &se.post);\n+\t\tse.expr = gfc_evaluate_now (se.expr, &outer_loop->pre);\n+\t      gfc_add_block_to_block (&outer_loop->pre, &se.post);\n \t    }\n \t  else\n-\t    gfc_add_block_to_block (&loop->post, &se.post);\n+\t    gfc_add_block_to_block (&outer_loop->post, &se.post);\n \n \t  ss_info->data.scalar.value = se.expr;\n \t  ss_info->string_length = se.string_length;\n@@ -2413,10 +2428,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t     now.  */\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, expr);\n-\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n-\t  gfc_add_block_to_block (&loop->post, &se.post);\n+\t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n+\t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n \n-\t  ss_info->data.scalar.value = gfc_evaluate_now (se.expr, &loop->pre);\n+\t  ss_info->data.scalar.value = gfc_evaluate_now (se.expr,\n+\t\t\t\t\t\t\t &outer_loop->pre);\n \t  ss_info->string_length = se.string_length;\n \t  break;\n \n@@ -2438,8 +2454,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  /* Get the vector's descriptor and store it in SS.  */\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_descriptor (&se, expr, gfc_walk_expr (expr));\n-\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n-\t  gfc_add_block_to_block (&loop->post, &se.post);\n+\t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n+\t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n \t  info->descriptor = se.expr;\n \t  break;\n \n@@ -2454,8 +2470,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  se.loop = loop;\n \t  se.ss = ss;\n \t  gfc_conv_expr (&se, expr);\n-\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n-\t  gfc_add_block_to_block (&loop->post, &se.post);\n+\t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n+\t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n \t  ss_info->string_length = se.string_length;\n \t  break;\n \n@@ -2469,8 +2485,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t      gfc_conv_expr_type (&se, expr->ts.u.cl->length,\n \t\t\t\t  gfc_charlen_type_node);\n \t      ss_info->string_length = se.expr;\n-\t      gfc_add_block_to_block (&loop->pre, &se.pre);\n-\t      gfc_add_block_to_block (&loop->post, &se.post);\n+\t      gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n+\t      gfc_add_block_to_block (&outer_loop->post, &se.post);\n \t    }\n \t  trans_array_constructor (ss, where);\n \t  break;"}]}