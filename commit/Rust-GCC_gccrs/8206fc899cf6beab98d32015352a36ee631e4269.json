{"sha": "8206fc899cf6beab98d32015352a36ee631e4269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwNmZjODk5Y2Y2YmVhYjk4ZDMyMDE1MzUyYTM2ZWU2MzFlNDI2OQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2001-05-22T20:04:58Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2001-05-22T20:04:58Z"}, "message": "builtins.c (expand_builtin_longjmp): A longjmp can be a call too.\n\n\n2001-05-22  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* builtins.c (expand_builtin_longjmp): A longjmp can be a call too.\n\t* config/ia64/ia64.md (nonlocal_goto): Reverse label and frame pointer\n\tparameters to __ia64_nonlocal_goto. Flag as NO_RETURN.\n\t* config/ia64/ia64.c (ia64_expand_epilogue): Make sure we are issuing\n\t\"r2\" to the assembly file. Only issue allocs with non-zero parameters.\n\nFrom-SVN: r42467", "tree": {"sha": "5fec888856d3a7d12e30354c553560ca9fe0423b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fec888856d3a7d12e30354c553560ca9fe0423b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8206fc899cf6beab98d32015352a36ee631e4269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8206fc899cf6beab98d32015352a36ee631e4269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8206fc899cf6beab98d32015352a36ee631e4269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8206fc899cf6beab98d32015352a36ee631e4269/comments", "author": null, "committer": null, "parents": [{"sha": "0401d4997a27f495b52e2a5af5f172fc10cf9a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0401d4997a27f495b52e2a5af5f172fc10cf9a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0401d4997a27f495b52e2a5af5f172fc10cf9a1b"}], "stats": {"total": 65, "additions": 45, "deletions": 20}, "files": [{"sha": "d9af40274e09d2676a78beab26d153d70089fa08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8206fc899cf6beab98d32015352a36ee631e4269", "patch": "@@ -1,3 +1,11 @@\n+2001-05-22  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* builtins.c (expand_builtin_longjmp): A longjmp can be a call too.\n+\t* config/ia64/ia64.md (nonlocal_goto): Reverse label and frame pointer\n+\tparameters to __ia64_nonlocal_goto. Flag as NO_RETURN.\n+\t* config/ia64/ia64.c (ia64_expand_epilogue): Make sure we are issuing \n+\t\"r2\" to the assembly file. Only issue allocs with non-zero parameters.\n+\n 2001-05-22  Loren J. Rittle  <ljrittle@acm.org>\n \t    David O'Brien  <obrien@freebsd.org>\n "}, {"sha": "7b4cd7593c9b32a6a8e463b2922a983c1c8351d8", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8206fc899cf6beab98d32015352a36ee631e4269", "patch": "@@ -718,12 +718,17 @@ expand_builtin_longjmp (buf_addr, value)\n      __builtin_setjmp target in the same function.  However, we've\n      already cautioned the user that these functions are for\n      internal exception handling use only.  */\n-  for (insn = get_last_insn ();\n-       GET_CODE (insn) != JUMP_INSN;\n-       insn = PREV_INSN (insn))\n-    continue;\n-  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO, const0_rtx,\n-\t\t\t\t      REG_NOTES (insn));\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO, const0_rtx,\n+\t\t\t\t\t      REG_NOTES (insn));\n+\t  break;\n+\t}\n+      else if (GET_CODE (insn) == CALL_INSN)\n+        break;\n+    }\n }\n \n /* Get a MEM rtx for expression EXP which is the address of an operand"}, {"sha": "e9af4fff4be6ddb44e69fc5eea3ac3425d3d16ab", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8206fc899cf6beab98d32015352a36ee631e4269", "patch": "@@ -2400,17 +2400,29 @@ ia64_expand_epilogue (sibcall_p)\n   if (! sibcall_p)\n     emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n   else\n-    /* We must emit an alloc to force the input registers to become output\n-       registers.  Otherwise, if the callee tries to pass its parameters\n-       through to another call without an intervening alloc, then these\n-       values get lost.  */\n-    /* ??? We don't need to preserve all input registers.  We only need to\n-       preserve those input registers used as arguments to the sibling call.\n-       It is unclear how to compute that number here.  */\n-    emit_insn (gen_alloc (gen_rtx_REG (DImode, GR_REG (2)),\n-\t\t\t  GEN_INT (0), GEN_INT (0),\n-\t\t\t  GEN_INT (current_frame_info.n_input_regs),\n-\t\t\t  GEN_INT (0)));\n+    {\n+      int fp = GR_REG (2);\n+      /* We need a throw away register here, r0 and r1 are reserved, so r2 is the\n+\t first available call clobbered register.  If there was a frame_pointer \n+\t register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM, \n+\t so we have to make sure we're using the string \"r2\" when emitting\n+\t the register name for the assmbler.  */\n+      if (current_frame_info.reg_fp && current_frame_info.reg_fp == GR_REG (2))\n+\tfp = HARD_FRAME_POINTER_REGNUM;\n+\n+      /* We must emit an alloc to force the input registers to become output\n+\t registers.  Otherwise, if the callee tries to pass its parameters\n+\t through to another call without an intervening alloc, then these\n+\t values get lost.  */\n+      /* ??? We don't need to preserve all input registers.  We only need to\n+\t preserve those input registers used as arguments to the sibling call.\n+\t It is unclear how to compute that number here.  */\n+      if (current_frame_info.n_input_regs != 0)\n+\temit_insn (gen_alloc (gen_rtx_REG (DImode, fp),\n+\t\t\t      GEN_INT (0), GEN_INT (0),\n+\t\t\t      GEN_INT (current_frame_info.n_input_regs),\n+\t\t\t      GEN_INT (0)));\n+    }\n }\n \n /* Return 1 if br.ret can do all the work required to return from a"}, {"sha": "e43bcc537a21bf9560b002b40159a840ac802145", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8206fc899cf6beab98d32015352a36ee631e4269/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=8206fc899cf6beab98d32015352a36ee631e4269", "patch": "@@ -4971,10 +4971,10 @@\n   \"\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \\\"__ia64_nonlocal_goto\\\"),\n-\t\t     0, VOIDmode, 3,\n-\t\t     operands[1], Pmode,\n+\t\t     LCT_NORETURN, VOIDmode, 3,\n+\t\t     operands[3], Pmode,\n \t\t     copy_to_reg (XEXP (operands[2], 0)), Pmode,\n-\t\t     operands[3], Pmode);\n+\t\t     operands[1], Pmode);\n   emit_barrier ();\n   DONE;\n }\")"}]}