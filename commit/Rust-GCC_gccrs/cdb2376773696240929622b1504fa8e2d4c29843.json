{"sha": "cdb2376773696240929622b1504fa8e2d4c29843", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiMjM3Njc3MzY5NjI0MDkyOTYyMmIxNTA0ZmE4ZTJkNGMyOTg0Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-04-23T14:05:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-23T14:05:11Z"}, "message": "Makefile.in (LIBGCC_DEPS): Add gcov headers.\n\n\t* Makefile.in (LIBGCC_DEPS): Add gcov headers.\n\t(libgcov.a): Depends on LIBGCC_DEPS.\n\t* basic-block.h (profile_info): Moved here from coverage.h. Made\n\ta pointer.\n\t* coverage.c (struct function_list): Fixed array of counter types.\n\t(struct counts_entry): Keyed by counter type, contains summary.\n\t(profile_info): Moved to profile.c.\n\t(prg_ctr_mask, prg_n_ctrs, fn_ctr_mask, fn_n_ctrs): New global\n\tvars.\n\t(profiler_label): Remove.\n\t(ctr_labels): New.\n\t(set_purpose, label_for_tag, build_counter_section_fields,\n\tbuild_counter_section_value, build_counter_section_data_fields,\n\tbuild_counter_section_data_values, build_function_info_fields,\n\tbuild_function_info_value, gcov_info_fields, gcov_info_value): Remove.\n\t(build_fn_info_type, build_fn_info_value, build_ctr_info_type,\n\tbuild_ctr_info_value, build_gcov_info): New.\n\t(htab_counts_entry_hash, htab_counts_entry_eq): Adjust.\n\t(reads_counts_file): Adjust.\n\t(get_coverage_counts): Takes counter number. Add summary\n\tparameter. Adjust.\n\t(coverage_counter_ref): Tkaes counter number. Adjust. Lazily\n\tcreate counter array labels.\n\t(coverage_end_function): Adjust.\n\t(create_coverage): Adjust.\n\t(find_counters_section): Remove.\n\t* coverage.h (MAX_COUNTER_SECTIONS): Remove.\n\t(struct section_info, struct profile_info): Remove.\n\t(profile_info): Moved to basic-block.h.\n\t(coverage_counter_ref): Takes a counter number.\n\t(get_coverage_counts): Takes a counter number. Added summary\n\tparameter.\n\t(find_counters_section): Remove.\n\t* gcov-dump.c (tag_arc_counts): Rename to ...\n\t(tag_counters): ... here. Adjust.\n\t(tag_table): Move tag_counters to 3rd entry. Remove\n\tPROGRAM_PLACEHOLDER and PROGRAM_INCORRECT entries.\n\t(dump_file): Check for counter tag values here.\n\t(tag_summary): Adjust.\n\t* gcov-io.c (gcov_write_summary, gcov_read_summary): Adjust.\n\t* gcov-io.h (GCOV_LOCKED): New.\n\t(GCOV_TAG_ARC_COUNTS): Rename to ...\n\t(GCOV_TAG_COUNTS_BASE): ... here.\n\t(GCOV_TAG_PLACEHOLDER_SUMMARY, GCOV_TAG_INCORRECT_SUMMARY):\n\tRemove.\n\t(GCOV_COUNTER_ARCS, GCOV_COUNTERS, GCOV_NAMES): New.\n\t(GCOV_TAG_FOR_COUNTER, GCOV_COUNTER_FOR_TAG,\n\tGCOV_TAG_IS_COUNTER): New.\n\t(struct gcov_ctr_summary): New.\n\t(struct gcov_summary): Adjust.\n\t(struct gcov_counter_section): Remove.\n\tstruct gcov_counter_section_data): Remove.\n\t(struct gcov_function_info): Rename to ...\n\t(struct gcov_fn_info): ... here. Adjust.\n\t(struct gcov_ctr_info): New.\n\t(struct gcov_info): Adjust.\n\t* gcov.c (read_count_file): Adjust.\n\t(output_lines): Adjust.\n\t* libgcov.c (gcov_exit): Adjust.\n\t(__gcov_flush): Adjust.\n\t* mklibgcc.in (libgcc2_c_dep): Add gcov headers.\n\t* predict.c (maybe_hot_bb_p, probably_cold_bb_p,\n\tprobably_never_executed_bb_p, compute_frequency_function): Adjust\n\tprofile_info use.\n\t* profile.c (struct counts_entry): Remove.\n\t(profile_info): Define here.\n\t(get_exec_counts): Adjust get_coverage_counts call.\n\t(compute_branch_probablilities): Remove find_counters_section\n\tcall.\n\t(gen_edge_profiler): Adjust coverage_counter_ref call.\n\t* tracer.c (tail_duplicate): Adjust profile_info use.\n\nFrom-SVN: r65990", "tree": {"sha": "120a1c15af28d004dc01bf0ac13ef734a28142cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120a1c15af28d004dc01bf0ac13ef734a28142cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdb2376773696240929622b1504fa8e2d4c29843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb2376773696240929622b1504fa8e2d4c29843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb2376773696240929622b1504fa8e2d4c29843", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb2376773696240929622b1504fa8e2d4c29843/comments", "author": null, "committer": null, "parents": [{"sha": "2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566"}], "stats": {"total": 1622, "additions": 698, "deletions": 924}, "files": [{"sha": "0c18f2f07123afad2431256394eeeef72dff4f6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -1,3 +1,77 @@\n+2003-04-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Makefile.in (LIBGCC_DEPS): Add gcov headers.\n+\t(libgcov.a): Depends on LIBGCC_DEPS.\n+\t* basic-block.h (profile_info): Moved here from coverage.h. Made\n+\ta pointer.\n+\t* coverage.c (struct function_list): Fixed array of counter types.\n+\t(struct counts_entry): Keyed by counter type, contains summary.\n+\t(profile_info): Moved to profile.c.\n+\t(prg_ctr_mask, prg_n_ctrs, fn_ctr_mask, fn_n_ctrs): New global\n+\tvars.\n+\t(profiler_label): Remove.\n+\t(ctr_labels): New.\n+\t(set_purpose, label_for_tag, build_counter_section_fields,\n+\tbuild_counter_section_value, build_counter_section_data_fields,\n+\tbuild_counter_section_data_values, build_function_info_fields,\n+\tbuild_function_info_value, gcov_info_fields, gcov_info_value): Remove.\n+\t(build_fn_info_type, build_fn_info_value, build_ctr_info_type,\n+\tbuild_ctr_info_value, build_gcov_info): New.\n+\t(htab_counts_entry_hash, htab_counts_entry_eq): Adjust.\n+\t(reads_counts_file): Adjust.\n+\t(get_coverage_counts): Takes counter number. Add summary\n+\tparameter. Adjust.\n+\t(coverage_counter_ref): Tkaes counter number. Adjust. Lazily\n+\tcreate counter array labels.\n+\t(coverage_end_function): Adjust.\n+\t(create_coverage): Adjust.\n+\t(find_counters_section): Remove.\n+\t* coverage.h (MAX_COUNTER_SECTIONS): Remove.\n+\t(struct section_info, struct profile_info): Remove.\n+\t(profile_info): Moved to basic-block.h.\n+\t(coverage_counter_ref): Takes a counter number.\n+\t(get_coverage_counts): Takes a counter number. Added summary\n+\tparameter.\n+\t(find_counters_section): Remove.\n+\t* gcov-dump.c (tag_arc_counts): Rename to ...\n+\t(tag_counters): ... here. Adjust.\n+\t(tag_table): Move tag_counters to 3rd entry. Remove\n+\tPROGRAM_PLACEHOLDER and PROGRAM_INCORRECT entries.\n+\t(dump_file): Check for counter tag values here.\n+\t(tag_summary): Adjust.\n+\t* gcov-io.c (gcov_write_summary, gcov_read_summary): Adjust.\n+\t* gcov-io.h (GCOV_LOCKED): New.\n+\t(GCOV_TAG_ARC_COUNTS): Rename to ...\n+\t(GCOV_TAG_COUNTS_BASE): ... here.\n+\t(GCOV_TAG_PLACEHOLDER_SUMMARY, GCOV_TAG_INCORRECT_SUMMARY):\n+\tRemove.\n+\t(GCOV_COUNTER_ARCS, GCOV_COUNTERS, GCOV_NAMES): New.\n+\t(GCOV_TAG_FOR_COUNTER, GCOV_COUNTER_FOR_TAG,\n+\tGCOV_TAG_IS_COUNTER): New.\n+\t(struct gcov_ctr_summary): New.\n+\t(struct gcov_summary): Adjust.\n+\t(struct gcov_counter_section): Remove.\n+\tstruct gcov_counter_section_data): Remove.\n+\t(struct gcov_function_info): Rename to ...\n+\t(struct gcov_fn_info): ... here. Adjust.\n+\t(struct gcov_ctr_info): New.\n+\t(struct gcov_info): Adjust.\n+\t* gcov.c (read_count_file): Adjust.\n+\t(output_lines): Adjust.\n+\t* libgcov.c (gcov_exit): Adjust.\n+\t(__gcov_flush): Adjust.\n+\t* mklibgcc.in (libgcc2_c_dep): Add gcov headers.\n+\t* predict.c (maybe_hot_bb_p, probably_cold_bb_p,\n+\tprobably_never_executed_bb_p, compute_frequency_function): Adjust\n+\tprofile_info use.\n+\t* profile.c (struct counts_entry): Remove.\n+\t(profile_info): Define here.\n+\t(get_exec_counts): Adjust get_coverage_counts call.\n+\t(compute_branch_probablilities): Remove find_counters_section\n+\tcall.\n+\t(gen_edge_profiler): Adjust coverage_counter_ref call.\n+\t* tracer.c (tail_duplicate): Adjust profile_info use.\n+\n 2003-04-23  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/10339"}, {"sha": "d82f5b009ed123e7d8d4c056c7a0e7984594f742", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -1112,9 +1112,9 @@ LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \\\n \t$(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs \\\n \ttsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \\\n \t$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \\\n-\t$(srcdir)/config/$(LIB1ASMSRC)\n+\t$(srcdir)/config/$(LIB1ASMSRC) gcov-io.h gcov-io.c gcov-iov.h\n \n-libgcov.a: libgcc.a; @true\n+libgcov.a: $(LIBGCC_DEPS); @true\n \n libgcc.a: $(LIBGCC_DEPS)\n \t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\"}, {"sha": "4c8d5e34dec0a64fc083633b98e97cabb1b9dbd2", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -155,6 +155,10 @@ typedef struct edge_def {\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n+/* Counter summary from the last set of coverage counts read by\n+   profile.c. */\n+extern const struct gcov_ctr_summary *profile_info;\n+\n /* Declared in cfgloop.h.  */\n struct loop;\n struct loops;"}, {"sha": "421b3b1a04e530e0e7f114f0ee23c72214d0f383", "filename": "gcc/coverage.c", "status": "modified", "additions": 294, "deletions": 547, "changes": 841, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -49,28 +49,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n struct function_list\n {\n-  struct function_list *next; \t/* next function */\n-  const char *name; \t\t/* function name */\n-  unsigned cfg_checksum;\t/* function checksum */\n-  unsigned n_counter_sections;\t/* number of counter sections */\n-  struct gcov_counter_section counter_sections[MAX_COUNTER_SECTIONS];\n-  \t\t\t\t/* the sections */\n+  struct function_list *next; \t /* next function */\n+  const char *name; \t\t /* function name */\n+  unsigned checksum;\t         /* function checksum */\n+  unsigned n_ctrs[GCOV_COUNTERS];/* number of counters.  */\n };\n \n /* Counts information for a function.  */\n typedef struct counts_entry\n {\n   /* We hash by  */\n   char *function_name;\n-  unsigned section;\n+  unsigned ctr;\n   \n   /* Store  */\n   unsigned checksum;\n-  unsigned n_counts;\n   gcov_type *counts;\n-  unsigned merged;\n-  gcov_type max_counter;\n-  gcov_type max_counter_sum;\n+  struct gcov_ctr_summary summary;\n \n   /* Workspace */\n   struct counts_entry *chain;\n@@ -80,9 +75,13 @@ typedef struct counts_entry\n static struct function_list *functions_head = 0;\n static struct function_list **functions_tail = &functions_head;\n \n-/* Instantiate the profile info structure.  */\n+/* Cumulative counter information for whole program.  */\n+static unsigned prg_ctr_mask; /* Mask of counter types generated.  */\n+static unsigned prg_n_ctrs[GCOV_COUNTERS];\n \n-struct profile_info profile_info;\n+/* Counter information for current function.  */\n+static unsigned fn_ctr_mask;\n+static unsigned fn_n_ctrs[GCOV_COUNTERS];\n \n /* Name of the output file for coverage output file.  */\n static char *bbg_file_name;\n@@ -95,8 +94,8 @@ static char *da_file_name;\n /* Hash table of count data.  */\n static htab_t counts_hash = NULL;\n \n-/* The name of the count table. Used by the edge profiling code.  */\n-static GTY(()) rtx profiler_label;\n+/* The names of the counter tables.  */\n+static GTY(()) rtx ctr_labels[GCOV_COUNTERS];\n \n /* Forward declarations.  */\n static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n@@ -105,16 +104,11 @@ static void htab_counts_entry_del PARAMS ((void *));\n static void read_counts_file PARAMS ((void));\n static unsigned compute_checksum PARAMS ((void));\n static unsigned checksum_string PARAMS ((unsigned, const char *));\n-static void set_purpose PARAMS ((tree, tree));\n-static rtx label_for_tag PARAMS ((unsigned));\n-static tree build_counter_section_fields PARAMS ((void));\n-static tree build_counter_section_value PARAMS ((unsigned, unsigned));\n-static tree build_counter_section_data_fields PARAMS ((void));\n-static tree build_counter_section_data_value PARAMS ((unsigned, unsigned));\n-static tree build_function_info_fields PARAMS ((void));\n-static tree build_function_info_value PARAMS ((struct function_list *));\n-static tree build_gcov_info_fields PARAMS ((tree));\n-static tree build_gcov_info_value PARAMS ((void));\n+static tree build_fn_info_type PARAMS ((unsigned));\n+static tree build_fn_info_value PARAMS ((const struct function_list *, tree));\n+static tree build_ctr_info_type PARAMS ((void));\n+static tree build_ctr_info_value PARAMS ((unsigned, tree));\n+static tree build_gcov_info PARAMS ((void));\n static void create_coverage PARAMS ((void));\n \n \f\n@@ -124,7 +118,7 @@ htab_counts_entry_hash (of)\n {\n   const counts_entry_t *entry = of;\n \n-  return htab_hash_string (entry->function_name) ^ entry->section;\n+  return htab_hash_string (entry->function_name) ^ entry->ctr;\n }\n \n static int\n@@ -136,7 +130,7 @@ htab_counts_entry_eq (of1, of2)\n   const counts_entry_t *entry2 = of2;\n \n   return !strcmp (entry1->function_name, entry2->function_name)\n-    && entry1->section == entry2->section;\n+    && entry1->ctr == entry2->ctr;\n }\n \n static void\n@@ -213,8 +207,6 @@ read_counts_file ()\n \t      for (entry = summaried; entry; entry = chain)\n \t\t{\n \t\t  chain = entry->chain;\n-\t\t  \n-\t\t  entry->max_counter_sum += entry->max_counter;\n \t\t  entry->chain = NULL;\n \t\t}\n \t      summaried = NULL;\n@@ -230,34 +222,38 @@ read_counts_file ()\n \t  seen_summary = 1;\n \t  for (entry = summaried; entry; entry = entry->chain)\n \t    {\n-\t      entry->merged += summary.runs;\n-\t      if (entry->max_counter < summary.arc_sum_max)\n-\t\tentry->max_counter = summary.arc_sum_max;\n+\t      struct gcov_ctr_summary *csum = &summary.ctrs[entry->ctr];\n+\t      \n+\t      entry->summary.runs += csum->runs;\n+\t      entry->summary.sum_all += csum->sum_all;\n+\t      if (entry->summary.run_max < csum->run_max)\n+\t\tentry->summary.run_max = csum->run_max;\n+\t      entry->summary.sum_max += csum->sum_max;\n \t    }\n \t}\n-      else if (GCOV_TAG_IS_SUBTAG (GCOV_TAG_FUNCTION, tag)\n-\t       && function_name_buffer)\n+      else if (GCOV_TAG_IS_COUNTER (tag) && function_name_buffer)\n \t{\n \t  counts_entry_t **slot, *entry, elt;\n \t  unsigned n_counts = length / 8;\n \t  unsigned ix;\n \n \t  elt.function_name = function_name_buffer;\n-\t  elt.section = tag;\n+\t  elt.ctr = GCOV_COUNTER_FOR_TAG (tag);\n \n \t  slot = (counts_entry_t **) htab_find_slot\n \t    (counts_hash, &elt, INSERT);\n \t  entry = *slot;\n \t  if (!entry)\n \t    {\n-\t      *slot = entry = xmalloc (sizeof (counts_entry_t));\n-\t      entry->function_name = xstrdup (function_name_buffer);\n-\t      entry->section = tag;\n+\t      *slot = entry = xcalloc (1, sizeof (counts_entry_t));\n+\t      entry->function_name = xstrdup (elt.function_name);\n+\t      entry->ctr = elt.ctr;\n \t      entry->checksum = checksum;\n-\t      entry->n_counts = n_counts;\n+\t      entry->summary.num = n_counts;\n \t      entry->counts = xcalloc (n_counts, sizeof (gcov_type));\n \t    }\n-\t  else if (entry->checksum != checksum || entry->n_counts != n_counts)\n+\t  else if (entry->checksum != checksum\n+\t\t   || entry->summary.num != n_counts)\n \t    {\n \t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n \t      htab_delete (counts_hash);\n@@ -292,13 +288,11 @@ read_counts_file ()\n /* Returns the counters for a particular tag.  */\n \n gcov_type *\n-get_coverage_counts (unsigned tag, unsigned expected)\n+get_coverage_counts (unsigned counter, unsigned expected,\n+\t\t     const struct gcov_ctr_summary **summary)\n {\n   counts_entry_t *entry, elt;\n \n-  profile_info.max_counter_in_program = 0;\n-  profile_info.count_profiles_merged = 0;\n-\n   /* No hash table, no counts. */\n   if (!counts_hash)\n     {\n@@ -313,26 +307,57 @@ get_coverage_counts (unsigned tag, unsigned expected)\n   elt.function_name\n     = (char *) IDENTIFIER_POINTER\n     (DECL_ASSEMBLER_NAME (current_function_decl));\n-  elt.section = tag;\n+  elt.ctr = counter;\n   entry = htab_find (counts_hash, &elt);\n   if (!entry)\n     {\n       warning (\"No profile for function '%s' found.\", elt.function_name);\n       return 0;\n     }\n   \n-  if (expected != entry->n_counts\n+  if (expected != entry->summary.num\n       || compute_checksum () != entry->checksum)\n     {\n       warning (\"profile mismatch for `%s'\", elt.function_name);\n       return NULL;\n     }\n \n-  profile_info.count_profiles_merged = entry->merged;\n-  profile_info.max_counter_in_program = entry->max_counter_sum;\n+  if (summary)\n+    *summary = &entry->summary;\n \n   return entry->counts;\n }\n+\n+/* Generate a MEM rtl to access COUNTER NO .  */\n+\n+rtx\n+coverage_counter_ref (unsigned counter, unsigned no)\n+{\n+  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n+  rtx ref;\n+\n+  if (!ctr_labels[counter])\n+    {\n+      /* Generate and save a copy of this so it can be shared.  */\n+      char buf[20];\n+      \n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n+      ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n+    }\n+  if (no + 1 > fn_n_ctrs[counter])\n+    {\n+      fn_n_ctrs[counter] = no + 1;\n+      fn_ctr_mask |= 1 << counter;\n+    }\n+\n+  no += prg_n_ctrs[counter];\n+  ref = plus_constant (ctr_labels[counter],\n+\t\t       GCOV_TYPE_SIZE / BITS_PER_UNIT * no);\n+  ref = gen_rtx_MEM (mode, ref);\n+  set_mem_alias_set (ref, new_alias_set ());\n+\n+  return ref;\n+}\n \f\n /* Generate a checksum for a string.  CHKSUM is the current\n    checksum. */\n@@ -426,415 +451,236 @@ coverage_end_function ()\n       warning (\"error writing `%s'\", bbg_file_name);\n       bbg_file_opened = -1;\n     }\n-  \n-  for (i = 0; i != profile_info.n_sections; i++)\n-    if (profile_info.section_info[i].n_counters_now)\n-      {\n-\tstruct function_list *item;\n+\n+  if (fn_ctr_mask)\n+    {\n+      struct function_list *item;\n       \n-\t/* ??? Probably should re-use the existing struct function.  */\n-\titem = xmalloc (sizeof (struct function_list));\n+      /* ??? Probably should re-use the existing struct function.  */\n+      item = xmalloc (sizeof (struct function_list));\n       \n-\t*functions_tail = item;\n-\tfunctions_tail = &item->next;\n+      *functions_tail = item;\n+      functions_tail = &item->next;\n \t\n-\titem->next = 0;\n-\titem->name = xstrdup (IDENTIFIER_POINTER\n-\t\t\t      (DECL_ASSEMBLER_NAME (current_function_decl)));\n-\titem->cfg_checksum = compute_checksum ();\n-\titem->n_counter_sections = 0;\n-\tfor (i = 0; i < profile_info.n_sections; i++)\n-\t  if (profile_info.section_info[i].n_counters_now)\n-\t    {\n-\t      item->counter_sections[item->n_counter_sections].tag = \n-\t\tprofile_info.section_info[i].tag;\n-\t      item->counter_sections[item->n_counter_sections].n_counters =\n-\t\tprofile_info.section_info[i].n_counters_now;\n-\t      item->n_counter_sections++;\n-\t      profile_info.section_info[i].n_counters\n-\t\t+= profile_info.section_info[i].n_counters_now;\n-\t      profile_info.section_info[i].n_counters_now = 0;\n-\t    }\n-\tbreak;\n-      }\n+      item->next = 0;\n+      item->name = xstrdup (IDENTIFIER_POINTER\n+\t\t\t    (DECL_ASSEMBLER_NAME (current_function_decl)));\n+      item->checksum = compute_checksum ();\n+      for (i = 0; i != GCOV_COUNTERS; i++)\n+\t{\n+\t  item->n_ctrs[i] = fn_n_ctrs[i];\n+\t  prg_n_ctrs[i] += fn_n_ctrs[i];\n+\t  fn_n_ctrs[i] = 0;\n+\t}\n+      prg_ctr_mask |= fn_ctr_mask;\n+      fn_ctr_mask = 0;\n+    }\n   bbg_function_announced = 0;\n }\n \n-/* Set FIELDS as purpose to VALUE.  */\n-static void\n-set_purpose (value, fields)\n-     tree value;\n-     tree fields;\n-{\n-  tree act_field, act_value;\n-  \n-  for (act_field = fields, act_value = value;\n-       act_field;\n-       act_field = TREE_CHAIN (act_field), act_value = TREE_CHAIN (act_value))\n-    TREE_PURPOSE (act_value) = act_field;\n-}\n+/* Creates the gcov_fn_info RECORD_TYPE.  */\n \n-/* Returns label for base of counters inside TAG section.  */\n-static rtx\n-label_for_tag (tag)\n-     unsigned tag;\n-{\n-  switch (tag)\n-    {\n-    case GCOV_TAG_ARC_COUNTS:\n-      return profiler_label;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Creates fields of struct counter_section (in gcov-io.h).  */\n static tree\n-build_counter_section_fields ()\n+build_fn_info_type (counters)\n+     unsigned counters;\n {\n+  tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   tree field, fields;\n-\n-  /* tag */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-\n-  /* n_counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates value of struct counter_section (in gcov-io.h).  */\n-static tree\n-build_counter_section_value (tag, n_counters)\n-     unsigned tag;\n-     unsigned n_counters;\n-{\n-  tree value = NULL_TREE;\n-\n-  /* tag */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (tag, 0)),\n-\t\t     value);\n-  \n-  /* n_counters */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_counters, 0)),\n-\t\t     value);\n-\n-  return value;\n-}\n-\n-/* Creates fields of struct counter_section_data (in gcov-io.h).  */\n-static tree\n-build_counter_section_data_fields ()\n-{\n-  tree field, fields, gcov_type, gcov_ptr_type;\n-\n-  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n-  gcov_ptr_type =\n-\t  build_pointer_type (build_qualified_type (gcov_type,\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n \t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree array_type;\n+  \n+  /* name */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, string_type);\n \n-  /* tag */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-\n-  /* n_counters */\n+  /* checksum */\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n+  array_type = build_index_type (build_int_2 (counters - 1, 0));\n+  array_type = build_array_type (unsigned_type_node, array_type);\n+  \n   /* counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n+  field = build_decl (FIELD_DECL, NULL_TREE, array_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n-  return fields;\n+  finish_builtin_struct (type, \"__gcov_fn_info\", fields, NULL_TREE);\n+\n+  return type;\n }\n \n-/* Creates value of struct counter_section_data (in gcov-io.h).  */\n+/* Creates a CONSTRUCTOR for a gcov_fn_info. FUNCTION is\n+   the function being processed and TYPE is the gcov_fn_info\n+   RECORD_TYPE.  */\n+\n static tree\n-build_counter_section_data_value (tag, n_counters)\n-     unsigned tag;\n-     unsigned n_counters;\n+build_fn_info_value (function, type)\n+     const struct function_list *function;\n+     tree type;\n {\n-  tree value = NULL_TREE, counts_table, gcov_type, gcov_ptr_type;\n-\n-  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n-  gcov_ptr_type\n-    = build_pointer_type (build_qualified_type\n-\t\t\t  (gcov_type, TYPE_QUAL_CONST));\n-\n-  /* tag */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (tag, 0)),\n+  tree value = NULL_TREE;\n+  tree fields = TYPE_FIELDS (type);\n+  size_t name_len = strlen (function->name);\n+  tree fname = build_string (name_len + 1, function->name);\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  unsigned ix;\n+  tree array_value = NULL_TREE;\n+  \n+  /* name */\n+  TREE_TYPE (fname) =\n+\t  build_array_type (char_type_node,\n+\t\t\t    build_index_type (build_int_2 (name_len, 0)));\n+  value = tree_cons (fields,\n+\t\t     build1 (ADDR_EXPR, string_type, fname),\n \t\t     value);\n+  fields = TREE_CHAIN (fields);\n   \n-  /* n_counters */\n-  value = tree_cons (NULL_TREE,\n+  /* checksum */\n+  value = tree_cons (fields,\n \t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_counters, 0)),\n+\t\t\t      build_int_2 (function->checksum, 0)),\n \t\t     value);\n-\n+  fields = TREE_CHAIN (fields);\n+  \n   /* counters */\n-  if (n_counters)\n-    {\n-      tree gcov_type_array_type =\n-\t      build_array_type (gcov_type,\n-\t\t\t\tbuild_index_type (build_int_2 (n_counters - 1,\n-\t\t\t\t\t\t\t       0)));\n-      counts_table =\n-\t      build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n-      TREE_STATIC (counts_table) = 1;\n-      DECL_NAME (counts_table) = get_identifier (XSTR (label_for_tag (tag), 0));\n-      assemble_variable (counts_table, 0, 0, 0);\n-      counts_table = build1 (ADDR_EXPR, gcov_ptr_type, counts_table);\n-    }\n-  else\n-    counts_table = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, counts_table, value);\n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n+    if (prg_ctr_mask & (1 << ix))\n+      {\n+\ttree counters = convert (unsigned_type_node,\n+\t\t\t\t build_int_2 (function->n_ctrs[ix], 0));\n+\t\n+\tarray_value = tree_cons (NULL_TREE, counters, array_value);\n+      }\n+  \n+  array_value = build_constructor (TREE_TYPE (fields), nreverse (array_value));\n+  value = tree_cons (fields, array_value, value);\n \n+  value = build_constructor (type, nreverse (value));\n+  \n   return value;\n }\n \n-/* Creates fields for struct function_info type (in gcov-io.h).  */\n+/* Creates the gcov_ctr_info RECORD_TYPE.  */\n+\n static tree\n-build_function_info_fields ()\n+build_ctr_info_type ()\n {\n-  tree field, fields, counter_section_fields, counter_section_type;\n-  tree counter_sections_ptr_type;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  /* name */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-\n-  /* checksum */\n+  tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  tree field, fields = NULL_TREE;\n+  \n+  /* counters */\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n-  /* n_counter_sections */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  /* values */\n+  field = build_decl (FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (make_signed_type (GCOV_TYPE_SIZE)));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n-  /* counter_sections */\n-  counter_section_fields = build_counter_section_fields ();\n-  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (counter_section_type, \"__counter_section\",\n-\t\t\t counter_section_fields, NULL_TREE);\n-  counter_sections_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, counter_sections_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n+  finish_builtin_struct (type, \"__gcov_ctr_info\", fields, NULL_TREE);\n \n-  return fields;\n+  return type;\n }\n \n-/* Creates value for struct function_info (in gcov-io.h).  */\n+/* Creates a CONSTRUCTOR for a gcov_ctr_info. COUNTER is\n+   the counter being processed and TYPE is the gcov_ctr_info\n+   RECORD_TYPE.  */\n+\n static tree\n-build_function_info_value (function)\n-     struct function_list *function;\n+build_ctr_info_value (counter, type)\n+     unsigned counter;\n+     tree type;\n {\n   tree value = NULL_TREE;\n-  size_t name_len = strlen (function->name);\n-  tree fname = build_string (name_len + 1, function->name);\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree counter_section_fields, counter_section_type, counter_sections_value;\n-  tree counter_sections_ptr_type, counter_sections_array_type;\n-  unsigned i;\n-\n-  /* name */\n-  TREE_TYPE (fname) =\n-\t  build_array_type (char_type_node,\n-\t\t\t    build_index_type (build_int_2 (name_len, 0)));\n-  value = tree_cons (NULL_TREE,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     string_type,\n-\t\t\t     fname),\n-\t\t     value);\n+  tree fields = TYPE_FIELDS (type);\n \n-  /* checksum */\n-  value = tree_cons (NULL_TREE,\n+  /* counters */\n+  value = tree_cons (fields,\n \t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (function->cfg_checksum, 0)),\n+\t\t\t      build_int_2 (prg_n_ctrs[counter], 0)),\n \t\t     value);\n+  fields = TREE_CHAIN (fields);\n \n-  /* n_counter_sections */\n-\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (function->n_counter_sections, 0)),\n-\t    \t    value);\n-\n-  /* counter_sections */\n-  counter_section_fields = build_counter_section_fields ();\n-  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  counter_sections_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  counter_sections_array_type =\n-\t  build_array_type (counter_section_type,\n-\t\t\t    build_index_type (\n-      \t\t\t\tbuild_int_2 (function->n_counter_sections - 1,\n-\t\t  \t\t\t     0)));\n-\n-  counter_sections_value = NULL_TREE;\n-  for (i = 0; i < function->n_counter_sections; i++)\n-    {\n-      tree counter_section_value\n-\t= build_counter_section_value (function->counter_sections[i].tag,\n-\t\t\t\t       function->counter_sections[i].n_counters);\n-      set_purpose (counter_section_value, counter_section_fields);\n-      counter_sections_value =\n-\ttree_cons (NULL_TREE,\n-\t\t   build_constructor (counter_section_type,\n-\t\t\t\t      nreverse (counter_section_value)),\n-\t\t   counter_sections_value);\n-    }\n-  finish_builtin_struct (counter_section_type, \"__counter_section\",\n-\t\t\t counter_section_fields, NULL_TREE);\n-\n-  if (function->n_counter_sections)\n+  if (prg_n_ctrs[counter])\n     {\n-      counter_sections_value = \n-\t      build_constructor (counter_sections_array_type,\n-\t\t\t\t nreverse (counter_sections_value)),\n-      counter_sections_value = build1 (ADDR_EXPR,\n-\t\t\t\t       counter_sections_ptr_type,\n-\t\t\t\t       counter_sections_value);\n+      tree array_type, array;\n+      \n+      array_type = build_index_type (build_int_2 (prg_n_ctrs[counter] - 1, 0));\n+      array_type = build_array_type (TREE_TYPE (TREE_TYPE (fields)),\n+\t\t\t\t     array_type);\n+      \n+      array = build (VAR_DECL, array_type, NULL_TREE, NULL_TREE);\n+      TREE_STATIC (array) = 1;\n+      DECL_NAME (array) = get_identifier (XSTR (ctr_labels[counter], 0));\n+      assemble_variable (array, 0, 0, 0);\n+      \n+      value = tree_cons (fields,\n+\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields), array),\n+\t\t\t value);\n     }\n   else\n-    counter_sections_value = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, counter_sections_value, value);\n+    value = tree_cons (fields, null_pointer_node, value);\n \n+  value = build_constructor (type, nreverse (value));\n+  \n   return value;\n }\n \n-/* Creates fields of struct gcov_info type (in gcov-io.h).  */\n+/* Creates the gcov_info RECORD_TYPE and initializer for it. Returns a\n+   CONSTRUCTOR.  */\n+\n static tree\n-build_gcov_info_fields (gcov_info_type)\n-     tree gcov_info_type;\n+build_gcov_info ()\n {\n-  tree field, fields;\n+  unsigned n_ctr_types, ix;\n+  tree type, const_type;\n+  tree fn_info_type, fn_info_value = NULL_TREE;\n+  tree fn_info_ptr_type;\n+  tree ctr_info_type, ctr_info_ary_type, ctr_info_value = NULL_TREE;\n+  tree field, fields = NULL_TREE;\n+  tree value = NULL_TREE;\n+  tree filename_string;\n   char *filename;\n   int filename_len;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree function_info_fields, function_info_type, function_info_ptr_type;\n-  tree counter_section_data_fields, counter_section_data_type;\n-  tree counter_section_data_ptr_type;\n-\n-  /* Version ident */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n-\n-  /* next -- NULL */\n-  field = build_decl (FIELD_DECL, NULL_TREE,\n-\t\t      build_pointer_type\n-\t\t      (build_qualified_type\n-\t\t       (gcov_info_type, TYPE_QUAL_CONST)));\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n+  unsigned n_fns;\n+  const struct function_list *fn;\n+  tree string_type;\n   \n-  /* Filename */\n-  filename = getpwd ();\n-  filename = (filename && da_file_name[0] != '/'\n-\t      ? concat (filename, \"/\", da_file_name, NULL)\n-\t      : da_file_name);\n-  filename_len = strlen (filename);\n-  if (filename != da_file_name)\n-    free (filename);\n-\n-  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n+  /* Count the number of active counters.  */\n+  for (n_ctr_types = 0, ix = 0; ix != GCOV_COUNTERS; ix++)\n+    if (prg_ctr_mask & (1 << ix))\n+      n_ctr_types++;\n   \n-  /* Workspace */\n-  field = build_decl (FIELD_DECL, NULL_TREE, long_integer_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  /* number of functions */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-      \n-  /* function_info table */\n-  function_info_fields = build_function_info_fields ();\n-  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (function_info_type, \"__function_info\",\n-\t\t\t function_info_fields, NULL_TREE);\n-  function_info_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (function_info_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, function_info_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-    \n-  /* n_counter_sections  */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n+  type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n   \n-  /* counter sections */\n-  counter_section_data_fields = build_counter_section_data_fields ();\n-  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n-\t\t\t counter_section_data_fields, NULL_TREE);\n-  counter_section_data_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_data_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, counter_section_data_ptr_type);\n+  /* Version ident */\n+  field = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates struct gcov_info value (in gcov-io.h).  */\n-static tree\n-build_gcov_info_value ()\n-{\n-  tree value = NULL_TREE;\n-  tree filename_string;\n-  char *filename;\n-  int filename_len;\n-  unsigned n_functions, i;\n-  struct function_list *item;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree function_info_fields, function_info_type, function_info_ptr_type;\n-  tree functions;\n-  tree counter_section_data_fields, counter_section_data_type;\n-  tree counter_section_data_ptr_type, counter_sections;\n-\n-  /* Version ident */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (long_unsigned_type_node,\n-\t\t\t      build_int_2 (GCOV_VERSION, 0)),\n+  value = tree_cons (field, convert (long_unsigned_type_node,\n+\t\t\t\t     build_int_2 (GCOV_VERSION, 0)),\n \t\t     value);\n-\n+  \n   /* next -- NULL */\n-  value = tree_cons (NULL_TREE, null_pointer_node, value);\n+  field = build_decl (FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  value = tree_cons (field, null_pointer_node, value);\n   \n   /* Filename */\n+  string_type = build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n   filename = getpwd ();\n   filename = (filename && da_file_name[0] != '/'\n \t      ? concat (filename, \"/\", da_file_name, NULL)\n@@ -846,144 +692,99 @@ build_gcov_info_value ()\n   TREE_TYPE (filename_string) =\n \t  build_array_type (char_type_node,\n \t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n-  value = tree_cons (NULL_TREE,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     string_type,\n-\t\t       \t     filename_string),\n+  value = tree_cons (field, build1 (ADDR_EXPR, string_type, filename_string),\n \t\t     value);\n   \n-  /* Workspace */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (long_integer_type_node, integer_zero_node),\n-\t\t     value);\n-      \n-  /* number of functions */\n-  n_functions = 0;\n-  for (item = functions_head; item != 0; item = item->next, n_functions++)\n-    continue;\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_functions, 0)),\n-\t\t     value);\n-\n-  /* function_info table */\n-  function_info_fields = build_function_info_fields ();\n-  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  function_info_ptr_type =\n-\t  build_pointer_type (\n-\t\tbuild_qualified_type (function_info_type,\n-\t       \t\t\t      TYPE_QUAL_CONST));\n-  functions = NULL_TREE;\n-  for (item = functions_head; item != 0; item = item->next)\n-    {\n-      tree function_info_value = build_function_info_value (item);\n-      set_purpose (function_info_value, function_info_fields);\n-      functions\n-\t= tree_cons (NULL_TREE,\n-\t\t     build_constructor (function_info_type,\n-\t\t\t\t\tnreverse (function_info_value)),\n-\t\t     functions);\n-    }\n-  finish_builtin_struct (function_info_type, \"__function_info\",\n-\t\t\t function_info_fields, NULL_TREE);\n-\n-  /* Create constructor for array.  */\n-  if (n_functions)\n+  /* Build the fn_info type and initializer.  */\n+  fn_info_type = build_fn_info_type (n_ctr_types);\n+  fn_info_ptr_type = build_pointer_type (build_qualified_type\n+\t\t\t\t\t (fn_info_type, TYPE_QUAL_CONST));\n+  for (fn = functions_head, n_fns = 0; fn; fn = fn->next, n_fns++)\n+    fn_info_value = tree_cons (NULL_TREE,\n+\t\t\t       build_fn_info_value (fn, fn_info_type),\n+\t\t\t       fn_info_value);\n+  if (n_fns)\n     {\n       tree array_type;\n \n-      array_type = build_array_type (\n-\t\t\tfunction_info_type,\n-   \t\t\tbuild_index_type (build_int_2 (n_functions - 1, 0)));\n-      functions = build_constructor (array_type, nreverse (functions));\n-      functions = build1 (ADDR_EXPR,\n-\t\t\t  function_info_ptr_type,\n-\t\t\t  functions);\n+      array_type = build_index_type (build_int_2 (n_fns - 1, 0));\n+      array_type = build_array_type (fn_info_type, array_type);\n+      \n+      fn_info_value = build_constructor (array_type, nreverse (fn_info_value));\n+      fn_info_value = build1 (ADDR_EXPR, fn_info_ptr_type, fn_info_value);\n     }\n   else\n-    functions = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, functions, value);\n+    fn_info_value = null_pointer_node;\n+  \n+  /* number of functions */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  value = tree_cons (field,\n+\t\t     convert (unsigned_type_node, build_int_2 (n_fns, 0)),\n+\t\t     value);\n+  \n+  /* fn_info table */\n+  field = build_decl (FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  value = tree_cons (field, fn_info_value, value);\n \n-  /* n_counter_sections  */\n-  value = tree_cons (NULL_TREE,\n+  /* counter_mask */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  value = tree_cons (field,\n \t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (profile_info.n_sections, 0)),\n+\t\t\t      build_int_2 (prg_ctr_mask, 0)),\n \t\t     value);\n   \n-  /* counter sections */\n-  counter_section_data_fields = build_counter_section_data_fields ();\n-  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  counter_sections = NULL_TREE;\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    {\n-      tree counter_sections_value =\n-\t      build_counter_section_data_value (\n-\t\tprofile_info.section_info[i].tag,\n-\t\tprofile_info.section_info[i].n_counters);\n-      set_purpose (counter_sections_value, counter_section_data_fields);\n-      counter_sections =\n-\ttree_cons (NULL_TREE,\n-\t\t   build_constructor (counter_section_data_type,\n-\t\t\t\t      nreverse (counter_sections_value)),\n-\t\t   counter_sections);\n-    }\n-  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n-\t\t\t counter_section_data_fields, NULL_TREE);\n-  counter_section_data_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_data_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-\n-  if (profile_info.n_sections)\n-    {\n-      tree cst_type = build_index_type (build_int_2 (profile_info.n_sections-1,\n-\t\t\t\t\t\t     0));\n-      cst_type = build_array_type (counter_section_data_type, cst_type);\n-      counter_sections = build_constructor (cst_type,\n-\t\t\t\t\t    nreverse (counter_sections));\n-      counter_sections = build1 (ADDR_EXPR,\n-\t\t\t\t counter_section_data_ptr_type,\n-\t\t\t\t counter_sections);\n-    }\n-  else\n-    counter_sections = null_pointer_node;\n-  value = tree_cons (NULL_TREE, counter_sections, value);\n+  /* counters */\n+  ctr_info_type = build_ctr_info_type ();\n+  ctr_info_ary_type = build_index_type (build_int_2 (n_ctr_types, 0));\n+  ctr_info_ary_type = build_array_type (ctr_info_type, ctr_info_ary_type);\n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n+    if (prg_ctr_mask & (1 << ix))\n+      ctr_info_value = tree_cons (NULL_TREE,\n+\t\t\t\t  build_ctr_info_value (ix, ctr_info_type),\n+\t\t\t\t  ctr_info_value);\n+  ctr_info_value = build_constructor (ctr_info_ary_type,\n+\t\t\t\t      nreverse (ctr_info_value));\n+\n+  field = build_decl (FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  value = tree_cons (field, ctr_info_value, value);\n+  \n+  finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n \n+  value = build_constructor (type, nreverse (value));\n+  \n   return value;\n }\n \n-/* Write out the structure which libgcc uses to locate all the arc\n+/* Write out the structure which libgcov uses to locate all the\n    counters.  The structures used here must match those defined in\n    gcov-io.h.  Write out the constructor to call __gcov_init.  */\n \n static void\n create_coverage ()\n {\n-  tree gcov_info_fields, gcov_info_type, gcov_info_value, gcov_info;\n+  tree gcov_info, gcov_info_value;\n   char name[20];\n   char *ctor_name;\n   tree ctor;\n   rtx gcov_info_address;\n   int save_flag_inline_functions = flag_inline_functions;\n-  unsigned i;\n \n-  for (i = 0; i < profile_info.n_sections; i++)\n-    if (profile_info.section_info[i].n_counters)\n-      break;\n-  if (i == profile_info.n_sections)\n+  if (!prg_ctr_mask)\n     return;\n   \n-  gcov_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  gcov_info_fields = build_gcov_info_fields (gcov_info_type);\n-  gcov_info_value = build_gcov_info_value ();\n-  set_purpose (gcov_info_value, gcov_info_fields);\n-  finish_builtin_struct (gcov_info_type, \"__gcov_info\",\n-\t\t\t gcov_info_fields, NULL_TREE);\n+  gcov_info_value = build_gcov_info ();\n \n-  gcov_info = build (VAR_DECL, gcov_info_type, NULL_TREE, NULL_TREE);\n-  DECL_INITIAL (gcov_info) =\n-    build_constructor (gcov_info_type, nreverse (gcov_info_value));\n+  gcov_info = build (VAR_DECL, TREE_TYPE (gcov_info_value),\n+\t\t     NULL_TREE, NULL_TREE);\n+  DECL_INITIAL (gcov_info) = gcov_info_value;\n \n   TREE_STATIC (gcov_info) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n@@ -1043,59 +844,6 @@ create_coverage ()\n     (* targetm.asm_out.constructor) (XEXP (DECL_RTL (ctor), 0),\n \t\t\t\t     DEFAULT_INIT_PRIORITY);\n }\n-\f\n-/* Find (and create if not present) a section with TAG for the current\n-   function.  */\n-struct section_info *\n-find_counters_section (tag)\n-     unsigned tag;\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    if (profile_info.section_info[i].tag == tag)\n-      return profile_info.section_info + i;\n-\n-  if (i == MAX_COUNTER_SECTIONS)\n-    abort ();\n-\n-  profile_info.section_info[i].tag = tag;\n-  profile_info.section_info[i].present = 0;\n-  profile_info.section_info[i].n_counters = 0;\n-  profile_info.section_info[i].n_counters_now = 0;\n-  profile_info.n_sections++;\n-\n-  return profile_info.section_info + i;\n-}\n-\n-/* Generate a MEM rtl to access counter NO in counter section TAG.  */\n-\n-rtx\n-coverage_counter_ref (unsigned tag, unsigned no)\n-{\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  struct section_info *sect = find_counters_section (tag);\n-  rtx ref;\n-\n-  if (!profiler_label)\n-    {\n-      /* Generate and save a copy of this so it can be shared.  */\n-      char buf[20];\n-      \n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 2);\n-      profiler_label = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n-    }\n-  if (no + 1 > (unsigned) sect->n_counters_now)\n-    sect->n_counters_now = no + 1;\n-\n-  no += sect->n_counters;\n-  ref = plus_constant (profiler_label, GCOV_TYPE_SIZE / BITS_PER_UNIT * no);\n-  ref = gen_rtx_MEM (mode, ref);\n-  set_mem_alias_set (ref, new_alias_set ());\n-\n-  return ref;\n-}\n-\n \f\n /* Perform file-level initialization. Read in data file, generate name\n    of graph file. */\n@@ -1142,5 +890,4 @@ coverage_finish ()\n     }\n }\n \n-\n #include \"gt-coverage.h\""}, {"sha": "8817b80381624c364348a6d76ee6b6d248022b0e", "filename": "gcc/coverage.h", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -23,50 +23,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"gcov-io.h\"\n \n-/* The number of different counter sections.  */\n-#define MAX_COUNTER_SECTIONS\t1\n-\n-/* Info about number of counters in the section.  */\n-struct section_info\n-{\n-  unsigned tag;\t\t/* Section tag.  */\n-  int present;\t\t/* Are the data from this section read into gcc?  */\n-  int n_counters;\t/* Total number of counters.  */\n-  int n_counters_now;\t/* Number of counters in the current function.  */\n-};\n-\n-struct profile_info\n-  {\n-    /* Information about numbers of counters in counter sections, for\n-       allocating the storage and storing the sizes.  */\n-    unsigned n_sections;\n-    struct section_info section_info[MAX_COUNTER_SECTIONS];\n-    \n-    /* Checksum of the cfg. Used for 'identification' of code.\n-       Used by final.  */\n-\n-    unsigned current_function_cfg_checksum;\n-\n-    /* Max. value of counter in program corresponding to the profile data\n-       for the current function.  */\n-\n-    gcov_type max_counter_in_program;\n-\n-    /* The number of profiles merged to form the profile data for the current\n-       function.  */\n-    int count_profiles_merged;\n-  };\n-\n-extern struct profile_info profile_info;\n-\n extern void coverage_init (const char *);\n extern void coverage_finish (void);\n extern void coverage_end_function (void);\n extern int coverage_begin_output (void);\n-extern rtx coverage_counter_ref (unsigned /*tag*/, unsigned/*num*/);\n-\n-gcov_type *get_coverage_counts (unsigned /*tag*/, unsigned /*expected*/);\n-struct section_info *find_counters_section\tPARAMS ((unsigned));\n \n+extern rtx coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n+extern gcov_type *get_coverage_counts (unsigned /*counter*/,\n+\t\t\t\t       unsigned /*expected*/,\n+\t\t\t\t       const struct gcov_ctr_summary **);\n \n #endif"}, {"sha": "5c0dd3a367658773336fbb996bea2990a23e99ac", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -35,7 +35,7 @@ static void tag_function PARAMS ((const char *, unsigned, unsigned));\n static void tag_blocks PARAMS ((const char *, unsigned, unsigned));\n static void tag_arcs PARAMS ((const char *, unsigned, unsigned));\n static void tag_lines PARAMS ((const char *, unsigned, unsigned));\n-static void tag_arc_counts PARAMS ((const char *, unsigned, unsigned));\n+static void tag_counters PARAMS ((const char *, unsigned, unsigned));\n static void tag_summary PARAMS ((const char *, unsigned, unsigned));\n extern int main PARAMS ((int, char **));\n \n@@ -59,15 +59,13 @@ static const tag_format_t tag_table[] =\n {\n   {0, \"NOP\", NULL},\n   {0, \"UNKNOWN\", NULL},\n+  {0, \"COUNTERS\", tag_counters},\n   {GCOV_TAG_FUNCTION, \"FUNCTION\", tag_function},\n   {GCOV_TAG_BLOCKS, \"BLOCKS\", tag_blocks},\n   {GCOV_TAG_ARCS, \"ARCS\", tag_arcs},\n   {GCOV_TAG_LINES, \"LINES\", tag_lines},\n-  {GCOV_TAG_ARC_COUNTS, \"ARC_COUNTS\", tag_arc_counts},\n   {GCOV_TAG_OBJECT_SUMMARY, \"OBJECT_SUMMARY\", tag_summary},\n   {GCOV_TAG_PROGRAM_SUMMARY, \"PROGRAM_SUMMARY\", tag_summary},\n-  {GCOV_TAG_PLACEHOLDER_SUMMARY, \"PROGRAM_PLACEHOLDER\", tag_summary},\n-  {GCOV_TAG_INCORRECT_SUMMARY, \"PROGRAM_INCORRECT\", tag_summary},\n   {0, NULL, NULL}\n };\n \n@@ -208,7 +206,7 @@ dump_file (filename)\n       for (format = tag_table; format->name; format++)\n \tif (format->tag == tag)\n \t  goto found;\n-      format = &tag_table[1];\n+      format = &tag_table[GCOV_TAG_IS_COUNTER (tag) ? 2 : 1];\n     found:;\n       if (tag)\n \t{\n@@ -364,14 +362,16 @@ tag_lines (filename, tag, length)\n }\n \n static void\n-tag_arc_counts (filename, tag, length)\n+tag_counters (filename, tag, length)\n      const char *filename ATTRIBUTE_UNUSED;\n      unsigned tag ATTRIBUTE_UNUSED;\n      unsigned length ATTRIBUTE_UNUSED;\n {\n+  static const char *const counter_names[] = GCOV_COUNTER_NAMES;\n   unsigned n_counts = length / 8;\n   \n-  printf (\" %u counts\", n_counts);\n+  printf (\" %s %u counts\",\n+\t  counter_names[GCOV_COUNTER_FOR_TAG (tag)], n_counts);\n   if (flag_dump_contents)\n     {\n       unsigned ix;\n@@ -395,20 +395,21 @@ tag_summary (filename, tag, length)\n      unsigned length ATTRIBUTE_UNUSED;\n {\n   struct gcov_summary summary;\n-\n-  gcov_read_summary (&summary);\n+  unsigned ix;\n   \n+  gcov_read_summary (&summary);\n   printf (\" checksum=0x%08x\", summary.checksum);\n   \n-  printf (\"\\n%s:\\t\\truns=%u, arcs=%u\", filename,\n-\t  summary.runs, summary.arcs);\n-  printf (\"\\n%s:\\t\\tarc_sum=\", filename);\n-  printf (HOST_WIDEST_INT_PRINT_DEC, \n-\t  (HOST_WIDEST_INT)summary.arc_sum);\n-  printf (\", arc_max_one=\");\n-  printf (HOST_WIDEST_INT_PRINT_DEC, \n-\t  (HOST_WIDEST_INT)summary.arc_max_one);\n-  printf (\", sum_max=\");\n-  printf (HOST_WIDEST_INT_PRINT_DEC, \n-\t  (HOST_WIDEST_INT)summary.arc_sum_max);\n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n+    {\n+      printf (\"\\n%sL\\t\\tcounts=%u, runs=%u\", filename,\n+\t      summary.ctrs[ix].num, summary.ctrs[ix].runs);\n+      \n+      printf (\", sum_all=\" HOST_WIDEST_INT_PRINT_DEC,\n+\t      (HOST_WIDEST_INT)summary.ctrs[ix].sum_all);\n+      printf (\", run_max=\" HOST_WIDEST_INT_PRINT_DEC,\n+\t      (HOST_WIDEST_INT)summary.ctrs[ix].run_max);\n+      printf (\", sum_max=\" HOST_WIDEST_INT_PRINT_DEC,\n+\t      (HOST_WIDEST_INT)summary.ctrs[ix].sum_max);\n+    }\n }"}, {"sha": "b59521745171524d84a022aaad2ebdc8142a6c21", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -305,15 +305,20 @@ gcov_write_length (unsigned long position)\n GCOV_LINKAGE void\n gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n {\n+  unsigned ix;\n+  const struct gcov_ctr_summary *csum;\n   unsigned long base;\n \n   base = gcov_write_tag (tag);\n   gcov_write_unsigned (summary->checksum);\n-  gcov_write_unsigned (summary->runs);\n-  gcov_write_unsigned (summary->arcs);\n-  gcov_write_counter (summary->arc_sum);\n-  gcov_write_counter (summary->arc_max_one);\n-  gcov_write_counter (summary->arc_sum_max);\n+  for (csum = summary->ctrs, ix = GCOV_COUNTERS; ix--; csum++)\n+    {\n+      gcov_write_unsigned (csum->num);\n+      gcov_write_unsigned (csum->runs);\n+      gcov_write_counter (csum->sum_all);\n+      gcov_write_counter (csum->run_max);\n+      gcov_write_counter (csum->sum_max);\n+    }\n   gcov_write_length (base);\n }\n #endif /* IN_LIBGCOV */\n@@ -406,15 +411,20 @@ gcov_read_string ()\n GCOV_LINKAGE void\n gcov_read_summary (struct gcov_summary *summary)\n {\n+  unsigned ix;\n+  struct gcov_ctr_summary *csum;\n+  \n   summary->checksum = gcov_read_unsigned ();\n-  summary->runs = gcov_read_unsigned ();\n-  summary->arcs = gcov_read_unsigned ();\n-  summary->arc_sum = gcov_read_counter ();\n-  summary->arc_max_one = gcov_read_counter ();\n-  summary->arc_sum_max = gcov_read_counter ();\n+  for (csum = summary->ctrs, ix = GCOV_COUNTERS; ix--; csum++)\n+    {\n+      csum->num = gcov_read_unsigned ();\n+      csum->runs = gcov_read_unsigned ();\n+      csum->sum_all = gcov_read_counter ();\n+      csum->run_max = gcov_read_counter ();\n+      csum->sum_max = gcov_read_counter ();\n+    }\n }\n \n-\n #if IN_GCOV > 0\n /* Return the modification time of the current gcov file.  */\n "}, {"sha": "7f881999779f007157a3e21043babc48c3361a1a", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -127,8 +127,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         function-data:\tannounce_function arc_counts\n \tannounce_function: header string:name int32:checksum\n \tarc_counts: header int64:count*\n-\tsummary: in32:checksum int32:runs int32:arcs int64:sum int64:max \\\n-\t\tint64:sum_max\n+\tsummary: int32:checksum {count-summary}GCOV_COUNTERS\n+\tcount-summary:\tint32:num int32:runs int64:sum\n+\t\t\tint64:max int64:sum_max\n \n    The ANNOUNCE_FUNCTION record is the same as that in the BBG file,\n    but without the source location.\n@@ -160,6 +161,11 @@ typedef long gcov_type;\n #else\n typedef long long gcov_type;\n #endif\n+#if defined (TARGET_HAS_F_SETLKW)\n+#define GCOV_LOCKED 1\n+#else\n+#define GCOV_LOCKED 0\n+#endif\n #endif /* IN_LIBGCOV */\n #if IN_GCOV\n typedef HOST_WIDEST_INT gcov_type;\n@@ -201,11 +207,26 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_TAG_BLOCKS\t\t ((unsigned)0x01410000)\n #define GCOV_TAG_ARCS\t\t ((unsigned)0x01430000)\n #define GCOV_TAG_LINES\t\t ((unsigned)0x01450000)\n-#define GCOV_TAG_ARC_COUNTS  \t ((unsigned)0x01a10000)\n+#define GCOV_TAG_COUNTER_BASE \t ((unsigned)0x01a10000) /* First counter */\n #define GCOV_TAG_OBJECT_SUMMARY  ((unsigned)0xa1000000)\n #define GCOV_TAG_PROGRAM_SUMMARY ((unsigned)0xa3000000)\n-#define GCOV_TAG_PLACEHOLDER_SUMMARY ((unsigned)0xa5000000)\n-#define GCOV_TAG_INCORRECT_SUMMARY ((unsigned)0xa7000000)\n+\n+/* Counters that are collected.  */\n+#define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n+#define GCOV_COUNTERS\t\t1\n+\n+/* A list of human readable names of the counters */\n+#define GCOV_COUNTER_NAMES\t{\"arcs\"}\n+\n+/* Convert a counter index to a tag. */\n+#define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n+\t(GCOV_TAG_COUNTER_BASE + ((COUNT) << 17))\n+/* Convert a tag to a counter.  */\n+#define GCOV_COUNTER_FOR_TAG(TAG)\t\t\t\t\t\\\n+\t(((TAG) - GCOV_TAG_COUNTER_BASE) >> 17)\n+/* Check whether a tag is a counter tag.  */\n+#define GCOV_TAG_IS_COUNTER(TAG)\t\t\t\t\\\n+\t(!((TAG) & 0xFFFF) && GCOV_COUNTER_FOR_TAG (TAG) < GCOV_COUNTERS)\n \n /* The tag level mask has 1's in the position of the inner levels, &\n    the lsb of the current level, and zero on the current and outer\n@@ -231,44 +252,43 @@ typedef HOST_WIDEST_INT gcov_type;\n \n /* Structured records.  */\n \n+/* Cumulative counter data.   */\n+struct gcov_ctr_summary\n+{\n+  unsigned num;\t\t/* number of counters.  */\n+  unsigned runs;\t/* number of program runs */\n+  gcov_type sum_all;\t/* sum of all counters accumulated. */\n+  gcov_type run_max;\t/* maximum value on a single run.  */\n+  gcov_type sum_max;    /* sum of individual run max values. */\n+};\n+\n /* Object & program summary record.  */\n struct gcov_summary\n {\n   unsigned checksum;\t  /* checksum of program */\n-  unsigned runs;\t  /* number of program runs */\n-  unsigned arcs;\t  /* number of instrumented arcs */\n-  gcov_type arc_sum;      /* sum of all arc counters */\n-  gcov_type arc_max_one;  /* max counter on any one run */\n-  gcov_type arc_sum_max;  /* sum of max_one */\n+  struct gcov_ctr_summary ctrs[GCOV_COUNTERS];\n };\n \n /* Structures embedded in coveraged program.  The structures generated\n    by write_profile must match these.  */\n \n-/* Information about section of counters for a function.  */\n-struct gcov_counter_section\n-{\n-  unsigned tag;\t\t/* Tag of the section.  */\n-  unsigned n_counters;\t/* Number of counters in the section.  */\n-};\n-\n #if IN_LIBGCOV\n-/* Information about section of counters for an object file.  */\n-struct gcov_counter_section_data\n+/* Information about a single function.  This uses the trailing array\n+   idiom. The number of counters is determined from the counter_mask\n+   in gcov_info.  We hold an array of function info, so have to\n+   explicitly calculate the correct array stride.  */\n+struct gcov_fn_info\n {\n-  unsigned tag;\t\t/* Tag of the section.  */\n-  unsigned n_counters;\t/* Number of counters in the section.  */\n-  gcov_type *counters;\t/* The data.  */\n+  const char *name;\t        /* (mangled) name of function */\n+  unsigned checksum;\t\t/* function checksum */\n+  unsigned n_ctrs[0];\t\t/* instrumented counters */\n };\n \n-/* Information about a single function.  */\n-struct gcov_function_info\n+/* Information about counters.  */\n+struct gcov_ctr_info\n {\n-  const char *name;\t        /* (mangled) name of function */\n-  unsigned checksum;\t\t/* function checksum */\n-  unsigned n_counter_sections;\t/* Number of types of counters */\n-  const struct gcov_counter_section *counter_sections;\n-  \t\t\t\t/* The section descriptions */\n+  unsigned num;\t\t/* number of counters.  */\n+  gcov_type *values;\t/* their values.  */\n };\n \n /* Information about a single object file.  */\n@@ -278,14 +298,15 @@ struct gcov_info\n   struct gcov_info *next;\t/* link to next, used by libgcc */\n \n   const char *filename;\t\t/* output file name */\n-  long wkspc;\t  \t        /* libgcc workspace */\n \n   unsigned n_functions;             /* number of functions */\n-  const struct gcov_function_info *functions; /* table of functions */\n+  const struct gcov_fn_info *functions; /* table of functions */\n \n-  unsigned n_counter_sections;\t/* Number of types of counters */\n-  const struct gcov_counter_section_data *counter_sections;\n-  \t\t\t\t/* The data to be put into the sections.  */\n+  unsigned ctr_mask;              /* mask of counters instrumented.  */\n+  struct gcov_ctr_info counts[0]; /* count data. The number of bits\n+\t\t\t\t     set in the ctr_mask field\n+\t\t\t\t     determines how big this array\n+\t\t\t\t     is.  */\n };\n \n /* Register a new object file module.  */"}, {"sha": "572292364b2fb63d85eba3785ea191606aca27a3", "filename": "gcc/gcov.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -1011,8 +1011,7 @@ read_count_file ()\n \n       if (tag == GCOV_TAG_OBJECT_SUMMARY)\n \tgcov_read_summary (&object_summary);\n-      else if (tag == GCOV_TAG_PROGRAM_SUMMARY\n-\t       || tag == GCOV_TAG_INCORRECT_SUMMARY)\n+      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n \tprogram_count++;\n       else if (tag == GCOV_TAG_FUNCTION)\n \t{\n@@ -1045,7 +1044,7 @@ read_count_file ()\n \t      goto cleanup;\n \t    }\n \t}\n-      else if (tag == GCOV_TAG_ARC_COUNTS && fn)\n+      else if (tag == GCOV_TAG_FOR_COUNTER (GCOV_COUNTER_ARCS) && fn)\n \t{\n \t  if (length != 8 * fn->num_counts)\n \t    goto mismatch;\n@@ -1801,7 +1800,8 @@ output_lines (gcov_file, src)\n   fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, src->name);\n   fprintf (gcov_file, \"%9s:%5d:Graph:%s\\n\", \"-\", 0, bbg_file_name);\n   fprintf (gcov_file, \"%9s:%5d:Data:%s\\n\", \"-\", 0, da_file_name);\n-  fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0, object_summary.runs);\n+  fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0,\n+\t   object_summary.ctrs[GCOV_COUNTER_ARCS].runs);\n   fprintf (gcov_file, \"%9s:%5d:Programs:%u\\n\", \"-\", 0, program_count);\n   \n   source_file = fopen (src->name, \"r\");"}, {"sha": "a2c831e819881c15192bb329edce919834f21be2", "filename": "gcc/libgcov.c", "status": "modified", "additions": 200, "deletions": 220, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -96,93 +96,91 @@ gcov_version_mismatch (struct gcov_info *ptr, unsigned version)\n static void\n gcov_exit (void)\n {\n-  struct gcov_info *ptr;\n-  unsigned ix, jx;\n-  gcov_type program_max_one = 0;\n-  gcov_type program_sum = 0;\n-  unsigned program_arcs = 0;\n-  struct gcov_summary last_prg;\n-  \n-  last_prg.runs = 0;\n-\n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+  struct gcov_info *gi_ptr;\n+  struct gcov_summary this_program;\n+  struct gcov_summary all;\n+\n+  memset (&all, 0, sizeof (all));\n+  /* Find the totals for this execution.  */\n+  memset (&this_program, 0, sizeof (this_program));\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      unsigned arc_data_index;\n-      gcov_type *count_ptr;\n-\n-      if (!ptr->filename)\n-\tcontinue;\n-\n-      for (arc_data_index = 0;\n-\t   arc_data_index < ptr->n_counter_sections\n-\t   && ptr->counter_sections[arc_data_index].tag != GCOV_TAG_ARC_COUNTS;\n-\t   arc_data_index++)\n-\tcontinue;\n-\n-      for (ix = ptr->counter_sections[arc_data_index].n_counters,\n-\t   count_ptr = ptr->counter_sections[arc_data_index].counters; ix--;)\n-\t{\n-\t  gcov_type count = *count_ptr++;\n-\n-\t  if (count > program_max_one)\n-\t    program_max_one = count;\n-\t  program_sum += count;\n-\t}\n-      program_arcs += ptr->counter_sections[arc_data_index].n_counters;\n+      const struct gcov_ctr_info *ci_ptr;\n+      struct gcov_ctr_summary *cs_ptr;\n+      unsigned t_ix;\n+      \n+      for (t_ix = 0, ci_ptr = gi_ptr->counts, cs_ptr = this_program.ctrs;\n+\t   t_ix != GCOV_COUNTERS; t_ix++, cs_ptr++)\n+\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t  {\n+\t    const gcov_type *c_ptr;\n+\t    unsigned c_num;\n+\n+\t    cs_ptr->num += ci_ptr->num;\n+\t    for (c_num = ci_ptr->num, c_ptr = ci_ptr->values; c_num--; c_ptr++)\n+\t      {\n+\t\tcs_ptr->sum_all += *c_ptr;\n+\t\tif (cs_ptr->run_max < *c_ptr)\n+\t\t  cs_ptr->run_max = *c_ptr;\n+\t      }\n+\t    ci_ptr++;\n+\t  }\n     }\n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+\n+  /* Now write the data  */\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      struct gcov_summary object;\n-      struct gcov_summary local_prg;\n+      struct gcov_summary this_object;\n+      struct gcov_summary object, program;\n+      gcov_type *values[GCOV_COUNTERS];\n+      const struct gcov_fn_info *fi_ptr;\n+      unsigned fi_stride;\n+      unsigned c_ix, t_ix, f_ix;\n+      const struct gcov_ctr_info *ci_ptr;\n+      struct gcov_ctr_summary *cs_ptr;\n+      struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n       int error;\n       int merging;\n       unsigned long base;\n-      const struct gcov_function_info *fn_info;\n-      gcov_type **counters;\n-      gcov_type *count_ptr;\n-      gcov_type object_max_one = 0;\n       unsigned tag, length;\n-      unsigned arc_data_index, f_sect_index, sect_index;\n-      long summary_pos = 0;\n-\n-      if (!ptr->filename)\n-\tcontinue;\n-\n-      counters = malloc (sizeof (gcov_type *) * ptr->n_counter_sections);\n-      for (ix = 0; ix < ptr->n_counter_sections; ix++)\n-\tcounters[ix] = ptr->counter_sections[ix].counters;\n-\n-      for (arc_data_index = 0;\n-\t   arc_data_index < ptr->n_counter_sections\n-\t   && ptr->counter_sections[arc_data_index].tag != GCOV_TAG_ARC_COUNTS;\n-\t   arc_data_index++)\n-\tcontinue;\n-\n-      if (arc_data_index == ptr->n_counter_sections)\n+      unsigned long summary_pos = 0;\n+\n+      /* Totals for this object file.  */\n+      memset (&this_object, 0, sizeof (this_object));\n+      for (t_ix = c_ix = 0,\n+\t     ci_ptr = gi_ptr->counts, cs_ptr = this_object.ctrs;\n+\t   t_ix != GCOV_COUNTERS; t_ix++, cs_ptr++)\n+\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t  {\n+\t    const gcov_type *c_ptr;\n+\t    unsigned c_num;\n+\n+\t    cs_ptr->num += ci_ptr->num;\n+\t    values[c_ix] = ci_ptr->values;\n+\t    for (c_num = ci_ptr->num, c_ptr = ci_ptr->values; c_num--; c_ptr++)\n+\t      {\n+\t\tcs_ptr->sum_all += *c_ptr;\n+\t\tif (cs_ptr->run_max < *c_ptr)\n+\t\t  cs_ptr->run_max = *c_ptr;\n+\t      }\n+\t    c_ix++;\n+\t    ci_ptr++;\n+\t  }\n+\n+      /* Calculate the function_info stride. This depends on the\n+\t number of counter types being measured.  */\n+      fi_stride = sizeof (struct gcov_fn_info) + c_ix * sizeof (unsigned);\n+      if (__alignof__ (struct gcov_fn_info) > sizeof (unsigned))\n \t{\n-\t  /* For now; later we may want to just measure other profiles,\n-\t     but now I am lazy to check for all consequences.  */\n-\t  abort ();\n+\t  fi_stride += __alignof__ (struct gcov_fn_info) - 1;\n+\t  fi_stride &= ~(__alignof__ (struct gcov_fn_info) - 1);\n \t}\n-      for (ix = ptr->counter_sections[arc_data_index].n_counters,\n-\t   count_ptr = ptr->counter_sections[arc_data_index].counters; ix--;)\n-\t{\n-\t  gcov_type count = *count_ptr++;\n-\n-\t  if (count > object_max_one)\n-\t    object_max_one = count;\n-\t}\n-      \n-      memset (&local_prg, 0, sizeof (local_prg));\n-      memset (&object, 0, sizeof (object));\n-      \n-      /* Open for modification */\n-      merging = gcov_open (ptr->filename, 0);\n       \n+      /* Open for modification, if possible */\n+      merging = gcov_open (gi_ptr->filename, 0);\n       if (!merging)\n \t{\n-\t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n+\t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_ptr->filename);\n \t  continue;\n \t}\n       \n@@ -192,22 +190,22 @@ gcov_exit (void)\n \t  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n-\t\t       ptr->filename);\n+\t\t       gi_ptr->filename);\n \t    read_fatal:;\n \t      gcov_close ();\n-\t      ptr->filename = 0;\n \t      continue;\n \t    }\n \t  length = gcov_read_unsigned ();\n \t  if (length != GCOV_VERSION)\n \t    {\n-\t      gcov_version_mismatch (ptr, length);\n+\t      gcov_version_mismatch (gi_ptr, length);\n \t      goto read_fatal;\n \t    }\n \t  \n \t  /* Merge execution counts for each function.  */\n-\t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n-\t       ix--; fn_info++)\n+\t  for (f_ix = gi_ptr->n_functions, fi_ptr = gi_ptr->functions; f_ix--;\n+\t       fi_ptr = (const struct gcov_fn_info *)\n+\t\t ((const char *) fi_ptr + fi_stride))\n \t    {\n \t      tag = gcov_read_unsigned ();\n \t      length = gcov_read_unsigned ();\n@@ -216,42 +214,34 @@ gcov_exit (void)\n \t      if (tag != GCOV_TAG_FUNCTION)\n \t\t{\n \t\tread_mismatch:;\n-\t\t  fprintf (stderr, \"profiling:%s:Merge mismatch at %s\\n\",\n-\t\t\t   ptr->filename, fn_info->name);\n+\t\t  fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n+\t\t\t   gi_ptr->filename,\n+\t\t\t   fi_ptr ? fi_ptr->name : \"summaries\");\n \t\t  goto read_fatal;\n \t\t}\n \n-\t      if (strcmp (gcov_read_string (), fn_info->name)\n-\t\t  || gcov_read_unsigned () != fn_info->checksum)\n+\t      if (strcmp (gcov_read_string (), fi_ptr->name)\n+\t\t  || gcov_read_unsigned () != fi_ptr->checksum)\n \t\tgoto read_mismatch;\n \n-\t      /* Counters.  */\n-\t      for (f_sect_index = 0;\n-\t\t   f_sect_index < fn_info->n_counter_sections;\n-\t\t   f_sect_index++)\n-\t\t{\n-\t\t  unsigned n_counters;\n-\n-\t\t  tag = gcov_read_unsigned ();\n-\t\t  length = gcov_read_unsigned ();\n-\t\t  \n-\t\t  for (sect_index = 0;\n-\t\t       sect_index < ptr->n_counter_sections;\n-\t\t       sect_index++)\n-\t\t    if (ptr->counter_sections[sect_index].tag == tag)\n-\t\t      break;\n-\t\t  if (sect_index == ptr->n_counter_sections\n-\t\t      || fn_info->counter_sections[f_sect_index].tag != tag)\n-\t\t    goto read_mismatch;\n-\n-\t\t  n_counters = fn_info->counter_sections[f_sect_index].n_counters;\n-\t\t  if (n_counters != length / 8)\n-\t\t    goto read_mismatch;\n-\t\t \n-\t\t  for (jx = 0; jx < n_counters; jx++)\n-\t\t    counters[sect_index][jx] += gcov_read_counter ();\n-\t\t  \n-\t\t  counters[sect_index] += n_counters;\n+\t      for (c_ix = t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+\t\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t\t  {\n+\t\t    unsigned n_counts;\n+\t\t    gcov_type *c_ptr;\n+\t\t    \n+\t\t    tag = gcov_read_unsigned ();\n+\t\t    length = gcov_read_unsigned ();\n+\n+\t\t    if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n+\t\t\t|| fi_ptr->n_ctrs[c_ix] * 8 != length)\n+\t\t      goto read_mismatch;\n+\t\t    c_ptr = values[c_ix];\n+\t\t    for (n_counts = fi_ptr->n_ctrs[c_ix];\n+\t\t\t n_counts--; c_ptr++)\n+\t\t      *c_ptr += gcov_read_counter ();\n+\t\t    values[c_ix] = c_ptr;\n+\t\t    c_ix++;\n \t\t}\n \t      if ((error = gcov_is_error ()))\n \t\tgoto read_error;\n@@ -266,148 +256,134 @@ gcov_exit (void)\n \t  /* Check program summary */\n \t  while (!gcov_is_eof ())\n \t    {\n-\t      unsigned long base = gcov_position ();\n-\t      \n+\t      base = gcov_position ();\n \t      tag = gcov_read_unsigned ();\n \t      gcov_read_unsigned ();\n \t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n \t\tgoto read_mismatch;\n-\t      gcov_read_summary (&local_prg);\n+\t      gcov_read_summary (&program);\n \t      if ((error = gcov_is_error ()))\n \t\t{\n \t\tread_error:;\n \t\t  fprintf (stderr, error < 0 ?\n \t\t\t   \"profiling:%s:Overflow merging\\n\" :\n \t\t\t   \"profiling:%s:Error merging\\n\",\n-\t\t\t   ptr->filename);\n+\t\t\t   gi_ptr->filename);\n \t\t  goto read_fatal;\n \t\t}\n \t      \n-\t      if (local_prg.checksum != gcov_crc32)\n-\t\t{\n-\t          memset (&local_prg, 0, sizeof (local_prg));\n-\t\t  continue;\n-\t\t}\n-\t      merging = 0;\n-\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n-\t\tbreak;\n-\t      \n-\t      /* If everything done correctly, the summaries should be\n-\t         computed equal for each module.  */\n-\t      if (last_prg.runs\n-#ifdef TARGET_HAS_F_SETLKW\n-\t\t  && last_prg.runs == local_prg.runs\n-#endif\n-\t\t  && memcmp (&last_prg, &local_prg, sizeof (last_prg)))\n-\t\t{\n-#ifdef TARGET_HAS_F_SETLKW\n-\t\t  fprintf (stderr, \"profiling:%s:Invocation mismatch\\n\\\n-Probably some files were removed\\n\",\n-\t\t\t   ptr->filename);\n-#else\n-\t\t  fprintf (stderr, \"profiling:%s:Invocation mismatch\\n\\\n-Probably some files were removed or parallel race happent because libgcc\\n\\\n-is compiled without file locking support.\\n\",\n-\t\t\t   ptr->filename);\n-#endif\n-\t\t  local_prg.runs = 0;\n-\t\t}\n-\t      else\n-\t\tmemcpy (&last_prg, &local_prg, sizeof (last_prg));\n+\t      if (program.checksum != gcov_crc32)\n+\t\tcontinue;\n \t      summary_pos = base;\n \t      break;\n \t    }\n \t  gcov_seek (0, 0);\n \t}\n+      else\n+\tmemset (&object, 0, sizeof (object));\n+      if (!summary_pos)\n+\tmemset (&program, 0, sizeof (program));\n \n-      object.runs++;\n-      object.arcs = ptr->counter_sections[arc_data_index].n_counters;\n-      object.arc_sum = 0;\n-      if (object.arc_max_one < object_max_one)\n-\tobject.arc_max_one = object_max_one;\n-      object.arc_sum_max += object_max_one;\n+      fi_ptr = 0;\n+      \n+      /* Merge the summaries.  */\n+      for (t_ix = c_ix = 0,\n+\t     cs_obj = object.ctrs, cs_tobj = this_object.ctrs,\n+\t     cs_prg = program.ctrs, cs_tprg = this_program.ctrs,\n+\t     cs_all = all.ctrs;\n+\t   t_ix != GCOV_COUNTERS;\n+\t   t_ix++, cs_obj++, cs_tobj++, cs_prg++, cs_tprg++, cs_all++)\n+\t{\n+\t  if ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t    {\n+\t      if (!cs_obj->runs++)\n+\t\tcs_obj->num = cs_tobj->num;\n+\t      else if (cs_obj->num != cs_tobj->num)\n+\t\tgoto read_mismatch;\n+\t      cs_obj->sum_all += cs_tobj->sum_all;\n+\t      if (cs_obj->run_max < cs_tobj->run_max)\n+\t\tcs_obj->run_max = cs_tobj->run_max;\n+\t      cs_obj->sum_max += cs_tobj->run_max;\n+\t      \n+\t      if (!cs_prg->runs++)\n+\t\tcs_prg->num = cs_tprg->num;\n+\t      else if (cs_prg->num != cs_tprg->num)\n+\t\tgoto read_mismatch;\n+\t      cs_prg->sum_all += cs_tprg->sum_all;\n+\t      if (cs_prg->run_max < cs_tprg->run_max)\n+\t\tcs_prg->run_max = cs_tprg->run_max;\n+\t      cs_prg->sum_max += cs_tprg->run_max;\n+\t      \n+\t      values[c_ix] = gi_ptr->counts[c_ix].values;\n+\t      c_ix++;\n+\t    }\n+\t  else if (cs_obj->num || cs_prg->num)\n+\t    goto read_mismatch;\n+\t  \n+\t  if (!cs_all->runs && cs_prg->runs)\n+\t    memcpy (cs_all, cs_prg, sizeof (*cs_all));\n+\t  else if (!all.checksum\n+\t\t   && (!GCOV_LOCKED || cs_all->runs == cs_prg->runs)\n+\t\t   && memcmp (cs_all, cs_prg, sizeof (*cs_all)))\n+\t    {\n+\t      fprintf (stderr, \"profiling:%s:Invocation mismatch - some data files may have been removed%s\",\n+\t\t       gi_ptr->filename, GCOV_LOCKED\n+\t\t       ? \"\" : \" or concurrent update without locking support\");\n+\t      all.checksum = ~0u;\n+\t    }\n+\t}\n+      \n+      program.checksum = gcov_crc32;\n       \n       /* Write out the data.  */\n       gcov_write_unsigned (GCOV_DATA_MAGIC);\n       gcov_write_unsigned (GCOV_VERSION);\n       \n       /* Write execution counts for each function.  */\n-      for (ix = 0; ix < ptr->n_counter_sections; ix++)\n-\tcounters[ix] = ptr->counter_sections[ix].counters;\n-      for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n+      for (f_ix = gi_ptr->n_functions, fi_ptr = gi_ptr->functions; f_ix--;\n+\t   fi_ptr = (const struct gcov_fn_info *)\n+\t     ((const char *) fi_ptr + fi_stride))\n \t{\n \t  /* Announce function.  */\n \t  base = gcov_write_tag (GCOV_TAG_FUNCTION);\n-\t  gcov_write_string (fn_info->name);\n-\t  gcov_write_unsigned (fn_info->checksum);\n+\t  gcov_write_string (fi_ptr->name);\n+\t  gcov_write_unsigned (fi_ptr->checksum);\n \t  gcov_write_length (base);\n \n-\t  /* counters.  */\n-\t  for (f_sect_index = 0;\n-\t       f_sect_index < fn_info->n_counter_sections;\n-\t       f_sect_index++)\n-\t    {\n-\t      tag = fn_info->counter_sections[f_sect_index].tag;\n-\t      for (sect_index = 0;\n-    \t\t   sect_index < ptr->n_counter_sections;\n-\t\t   sect_index++)\n-\t\tif (ptr->counter_sections[sect_index].tag == tag)\n-\t\t  break;\n-\t      if (sect_index == ptr->n_counter_sections)\n-\t\tabort ();\n-\n-\t      base = gcov_write_tag (tag);\n-    \t      for (jx = fn_info->counter_sections[f_sect_index].n_counters; jx--;)\n-\t\t{\n-\t\t  gcov_type count = *counters[sect_index]++;\n-\t      \n-\t\t  if (tag == GCOV_TAG_ARC_COUNTS)\n-\t\t    {\n-\t\t      object.arc_sum += count;\n-\t\t    }\n-\t\t  gcov_write_counter (count);\n-\t\t}\n-\t      gcov_write_length (base);\n-\t    }\n+\t  for (c_ix = t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+\t    if ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t      {\n+\t\tunsigned n_counts;\n+\t\tgcov_type *c_ptr;\n+\t\t    \n+\t\tbase = gcov_write_tag (GCOV_TAG_FOR_COUNTER (t_ix));\n+\t\tc_ptr = values[c_ix];\n+\t\tfor (n_counts = fi_ptr->n_ctrs[c_ix]; n_counts--; c_ptr++)\n+\t\t  gcov_write_counter (*c_ptr);\n+\t\tvalues[c_ix] = c_ptr;\n+\t\tgcov_write_length (base);\n+\t\tc_ix++;\n+\t      }\n \t}\n \n       /* Object file summary.  */\n       gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, &object);\n \n       /* Generate whole program statistics.  */\n-      local_prg.runs++;\n-      local_prg.checksum = gcov_crc32;\n-      local_prg.arcs = program_arcs;\n-      local_prg.arc_sum += program_sum;\n-      if (local_prg.arc_max_one < program_max_one)\n-\tlocal_prg.arc_max_one = program_max_one;\n-      local_prg.arc_sum_max += program_max_one;\n-\n-      if (merging)\n-\t{\n-  \t  gcov_seek_end ();\n-\t  gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &local_prg);\n-\t}\n-      else if (summary_pos)\n-\t{\n-\t  /* Zap trailing program summary */\n-\t  gcov_seek (summary_pos, 0);\n-\t  if (!local_prg.runs)\n-\t    ptr->wkspc = 0;\n-\t  gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &local_prg);\n-\t}\n-      if (gcov_close ())\n+      if (summary_pos)\n+\tgcov_seek (summary_pos, 0);\n+      else\n+\tgcov_seek_end ();\n+      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program);\n+      if ((error = gcov_close ()))\n \t{\n-\t  fprintf (stderr, \"profiling:%s:Error writing\\n\", ptr->filename);\n-\t  ptr->filename = 0;\n+\t  fprintf (stderr, error  < 0 ?\n+\t\t   \"profiling:%s:Overflow writing\\n\" :\n+\t\t   \"profiling:%s:Error writing\\n\",\n+\t\t   gi_ptr->filename);\n+\t  gi_ptr->filename = 0;\n \t}\n     }\n-  /* All statistic we gather can be done in one pass trought the file.\n-     Originally we did two - one for counts and other for the statistics.  This\n-     brings problem with the file locking interface, but it is possible to\n-     implement so if need appears in the future - first pass updates local\n-     statistics and number of runs.  Second pass then overwrite global\n-     statistics only when number of runs match.  */\n }\n \n /* Add a new object file onto the bb chain.  Invoked automatically\n@@ -459,16 +435,20 @@ __gcov_init (struct gcov_info *info)\n void\n __gcov_flush (void)\n {\n-  struct gcov_info *ptr;\n+  const struct gcov_info *gi_ptr;\n \n   gcov_exit ();\n-  for (ptr = gcov_list; ptr; ptr = ptr->next)\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      unsigned i, j;\n+      unsigned t_ix;\n+      const struct gcov_ctr_info *ci_ptr;\n       \n-      for (j = 0; j < ptr->n_counter_sections; j++)\n-\tfor (i = ptr->counter_sections[j].n_counters; i--;)\n-\t  ptr->counter_sections[j].counters[i] = 0;\n+      for (t_ix = 0, ci_ptr = gi_ptr->counts; t_ix != GCOV_COUNTERS; t_ix++)\n+\tif ((1 << t_ix) & gi_ptr->ctr_mask)\n+\t  {\n+\t    memset (ci_ptr->values, 0, sizeof (gcov_type) * ci_ptr->num);\n+\t    ci_ptr++;\n+\t  }\n     }\n }\n "}, {"sha": "9cf67ccd67e2ce8853c5947f67a20d2b95ef5c30", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -75,7 +75,7 @@ make_compile='$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n libgcc2_c_dep='stmp-dirs $(srcdir)/libgcc2.c $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\" $LIB2ADDEHDEP\"\n \n # Dependencies for libgcov.c\n-libgcov_c_dep='stmp-dirs $(srcdir)/libgcov.c $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\n+libgcov_c_dep='stmp-dirs $(srcdir)/libgcov.c $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h gcov-io.h gcov-io.c gcov-iov.h'\n \n # Dependencies for fp-bit.c\n fpbit_c_dep='stmp-dirs config.status tsystem.h'"}, {"sha": "80ad41e1c99c68067ff9df7b0601e5bdfe82fcf2", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -120,11 +120,9 @@ bool\n maybe_hot_bb_p (bb)\n      basic_block bb;\n {\n-  if (profile_info.count_profiles_merged\n-      && flag_branch_probabilities\n+  if (profile_info && flag_branch_probabilities\n       && (bb->count\n-\t  < profile_info.max_counter_in_program\n-\t  / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n+\t  < profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n     return false;\n   if (bb->frequency < BB_FREQ_MAX / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION))\n     return false;\n@@ -137,11 +135,9 @@ bool\n probably_cold_bb_p (bb)\n      basic_block bb;\n {\n-  if (profile_info.count_profiles_merged\n-      && flag_branch_probabilities\n+  if (profile_info && flag_branch_probabilities\n       && (bb->count\n-\t  < profile_info.max_counter_in_program\n-\t  / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n+\t  < profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n     return true;\n   if (bb->frequency < BB_FREQ_MAX / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION))\n     return true;\n@@ -153,10 +149,8 @@ bool\n probably_never_executed_bb_p (bb)\n \tbasic_block bb;\n {\n-  if (profile_info.count_profiles_merged\n-      && flag_branch_probabilities)\n-    return ((bb->count + profile_info.count_profiles_merged / 2)\n-\t    / profile_info.count_profiles_merged) == 0;\n+  if (profile_info && flag_branch_probabilities)\n+    return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n   return false;\n }\n \n@@ -1266,8 +1260,7 @@ compute_function_frequency ()\n {\n   basic_block bb;\n \n-  if (!profile_info.count_profiles_merged\n-      || !flag_branch_probabilities)\n+  if (!profile_info || !flag_branch_probabilities)\n     return;\n   cfun->function_frequency = FUNCTION_FREQUENCY_UNLIKELY_EXECUTED;\n   FOR_EACH_BB (bb)"}, {"sha": "6a5548b47a9e3aa661252e77b14fcd7386916289", "filename": "gcc/profile.c", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -81,26 +81,6 @@ struct bb_info {\n   gcov_type pred_count;\n };\n \n-/* Counts information for a function.  */\n-typedef struct counts_entry\n-{\n-  /* We hash by  */\n-  char *function_name;\n-  unsigned section;\n-  \n-  /* Store  */\n-  unsigned checksum;\n-  unsigned n_counts;\n-  gcov_type *counts;\n-  unsigned merged;\n-  gcov_type max_counter;\n-  gcov_type max_counter_sum;\n-\n-  /* Workspace */\n-  struct counts_entry *chain;\n-  \n-} counts_entry_t;\n-\n #define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n #define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n \n@@ -110,6 +90,10 @@ typedef struct counts_entry\n \t\t\t       : ((bb) == EXIT_BLOCK_PTR\t\t\\\n \t\t\t\t  ? last_basic_block + 1 : (bb)->index + 1))\n \n+/* Counter summary from the last set of coverage counts read. */\n+\n+const struct gcov_ctr_summary *profile_info;\n+\n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n \n@@ -195,16 +179,13 @@ get_exec_counts ()\n \t  num_edges++;\n     }\n \n-  counts = get_coverage_counts (GCOV_TAG_ARC_COUNTS, num_edges);\n+  counts = get_coverage_counts (GCOV_COUNTER_ARCS, num_edges, &profile_info);\n   if (!counts)\n     return NULL;\n \n-  if (rtl_dump_file)\n-    {\n-      fprintf(rtl_dump_file, \"Merged %i profiles with maximal count %i.\\n\",\n-\t      profile_info.count_profiles_merged,\n-\t      (int)profile_info.max_counter_in_program);\n-    }\n+  if (rtl_dump_file && profile_info)\n+    fprintf(rtl_dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n+\t    profile_info->runs, (unsigned) profile_info->sum_max);\n \n   return counts;\n }\n@@ -547,7 +528,6 @@ compute_branch_probabilities ()\n     }\n \n   free_aux_for_blocks ();\n-  find_counters_section (GCOV_TAG_ARC_COUNTS)->present = 1;\n }\n \n /* Instrument and/or analyze program behavior based on program flow graph.\n@@ -1013,7 +993,7 @@ static rtx\n gen_edge_profiler (edgeno)\n      int edgeno;\n {\n-  rtx ref = coverage_counter_ref (GCOV_TAG_ARC_COUNTS, edgeno);\n+  rtx ref = coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   rtx tmp;\n   enum machine_mode mode = GET_MODE (ref);\n   rtx sequence;"}, {"sha": "701c16a93953fa5c2de652ef538780d91eb930a3", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2376773696240929622b1504fa8e2d4c29843/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=cdb2376773696240929622b1504fa8e2d4c29843", "patch": "@@ -211,7 +211,7 @@ tail_duplicate ()\n   int max_dup_insns;\n   basic_block bb;\n \n-  if (profile_info.count_profiles_merged && flag_branch_probabilities)\n+  if (profile_info && flag_branch_probabilities)\n     probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n   else\n     probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n@@ -232,7 +232,7 @@ tail_duplicate ()\n       weighted_insns += n * bb->frequency;\n     }\n \n-  if (profile_info.count_profiles_merged && flag_branch_probabilities)\n+  if (profile_info && flag_branch_probabilities)\n     cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE_FEEDBACK);\n   else\n     cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE);"}]}