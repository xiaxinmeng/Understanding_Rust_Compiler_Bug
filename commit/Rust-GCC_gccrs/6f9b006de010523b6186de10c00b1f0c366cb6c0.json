{"sha": "6f9b006de010523b6186de10c00b1f0c366cb6c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY5YjAwNmRlMDEwNTIzYjYxODZkZTEwYzAwYjFmMGMzNjZjYjZjMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-06-01T00:19:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-01T00:19:10Z"}, "message": "configure.in (HAVE_AS_TLS): Add alpha tests.\n\n\t* configure.in (HAVE_AS_TLS): Add alpha tests.\n\t* configure: Rebuild.\n\t* config/alpha/alpha.c (TARGET_AS_TLS): New.\n\t(alpha_tls_size, alpha_tls_size_string): New.\n\t(overide_options): Set it.  Always install machine_status hooks.\n\t(input_operand): Accept got tls predicates.\n\t(local_symbol_p): Merge into ...\n\t(local_symbolic_operand): ... here.  Reject tls symbols.\n\t(global_symbolic_operand): Likewise.\n\t(tls_symbolic_operand_1, dtp16_symbolic_operand): New.\n\t(dtp32_symbolic_operand, gotdtp_symbolic_operand): New.\n\t(tp16_symbolic_operand, tp32_symbolic_operand): New.\n\t(gottp_symbolic_operand, tls_symbolic_operand_type): New.\n\t(alpha_encode_section_info): Handle TLS symbols.\n\t(alpha_strip_name_encoding): Likewise.\n\t(alpha_legitimate_address_p): Likewise.\n\t(alpha_legitimize_address): Likewise.\n\t(alpha_expand_mov): Early exit to avoid nop moves.\n\t(struct machine_function): Move from unicosmk.h.  Add some_ld_name.\n\t(alpha_init_machine_status, alpha_mark_machine_status,\n\talpha_free_machine_status): Always define.\n\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): New.\n\t(print_operand, print_operand_address): Add TLS relocs.\n\t* config/alpha/alpha.h (HAVE_AS_TLS): Default 0.\n\t(MASK_TLS_KERNEL, TARGET_TLS_KERNEL): New.\n\t(TARGET_SWITCHES): Add -mtls-kernel.\n\t(alpha_tls_size, alpha_tls_size_string): New.\n\t(TARGET_OPTIONS): Add -mtls-size=.\n\t(reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,\n\tREGNO_REG_CLASS, REG_CLASS_FROM_LETTER): Add R0_REG.\n\t(ASM_OUTPUT_LABELREF): Skip %.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Add &.\n\t(PREDICATE_CODES): Update.\n\t* config/alpha/alpha.md (UNSPEC_TLSGD_CALL, UNSPEC_TLSLDM_CALL,\n\tUNSPEC_TLSGD, UNSPEC_TLSLDM, UNSPEC_DTPREL, UNSPEC_TPREL,\n\tUNSPEC_TP, UNSPECV_SET_TP): New.\n\t(adddi_er_lo16_dtp, adddi_er_hi32_dtp, adddi_er_lo32_dtp,\n\tadddi_er_lo16_tp, adddi_er_hi32_tp, adddi_er_lo32_tp, load_tp,\n\tset_tp, movdi_er_tlsgd, movdi_er_tlsldm, movdi_er_gotdtp,\n\tmovdi_er_gottp, call_value_osf_tlsgd, call_value_osf_tlsldm): New.\n\t(call_value_osf_2_er): Accept anything as op4.\n\t* config/alpha/alpha-protos.h: Update.\n\t* config/alpha/unicosmk.h (struct machine_function): Move to alpha.c.\n\nFrom-SVN: r54125", "tree": {"sha": "a1943ec632b73b43e8c2df8b6aedeb318c0f7e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1943ec632b73b43e8c2df8b6aedeb318c0f7e90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f9b006de010523b6186de10c00b1f0c366cb6c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9b006de010523b6186de10c00b1f0c366cb6c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9b006de010523b6186de10c00b1f0c366cb6c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9b006de010523b6186de10c00b1f0c366cb6c0/comments", "author": null, "committer": null, "parents": [{"sha": "39e5db1a7c9714f7a6c3f5f24617c81e8f8d87b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e5db1a7c9714f7a6c3f5f24617c81e8f8d87b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39e5db1a7c9714f7a6c3f5f24617c81e8f8d87b2"}], "stats": {"total": 952, "additions": 862, "deletions": 90}, "files": [{"sha": "efd25dd41262da3541fc35a523b3155f11d4b1ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -1,3 +1,49 @@\n+2002-05-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.in (HAVE_AS_TLS): Add alpha tests.\n+\t* configure: Rebuild.\n+\t* config/alpha/alpha.c (TARGET_AS_TLS): New.\n+\t(alpha_tls_size, alpha_tls_size_string): New.\n+\t(overide_options): Set it.  Always install machine_status hooks.\n+\t(input_operand): Accept got tls predicates.\n+\t(local_symbol_p): Merge into ...\n+\t(local_symbolic_operand): ... here.  Reject tls symbols.\n+\t(global_symbolic_operand): Likewise.\n+\t(tls_symbolic_operand_1, dtp16_symbolic_operand): New.\n+\t(dtp32_symbolic_operand, gotdtp_symbolic_operand): New.\n+\t(tp16_symbolic_operand, tp32_symbolic_operand): New.\n+\t(gottp_symbolic_operand, tls_symbolic_operand_type): New.\n+\t(alpha_encode_section_info): Handle TLS symbols.\n+\t(alpha_strip_name_encoding): Likewise.\n+\t(alpha_legitimate_address_p): Likewise.\n+\t(alpha_legitimize_address): Likewise.\n+\t(alpha_expand_mov): Early exit to avoid nop moves.\n+\t(struct machine_function): Move from unicosmk.h.  Add some_ld_name.\n+\t(alpha_init_machine_status, alpha_mark_machine_status,\n+\talpha_free_machine_status): Always define.\n+\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): New.\n+\t(print_operand, print_operand_address): Add TLS relocs.\n+\t* config/alpha/alpha.h (HAVE_AS_TLS): Default 0.\n+\t(MASK_TLS_KERNEL, TARGET_TLS_KERNEL): New.\n+\t(TARGET_SWITCHES): Add -mtls-kernel.\n+\t(alpha_tls_size, alpha_tls_size_string): New.\n+\t(TARGET_OPTIONS): Add -mtls-size=.\n+\t(reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,\n+\tREGNO_REG_CLASS, REG_CLASS_FROM_LETTER): Add R0_REG.\n+\t(ASM_OUTPUT_LABELREF): Skip %.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Add &.\n+\t(PREDICATE_CODES): Update.\n+\t* config/alpha/alpha.md (UNSPEC_TLSGD_CALL, UNSPEC_TLSLDM_CALL,\n+\tUNSPEC_TLSGD, UNSPEC_TLSLDM, UNSPEC_DTPREL, UNSPEC_TPREL,\n+\tUNSPEC_TP, UNSPECV_SET_TP): New.\n+\t(adddi_er_lo16_dtp, adddi_er_hi32_dtp, adddi_er_lo32_dtp,\n+\tadddi_er_lo16_tp, adddi_er_hi32_tp, adddi_er_lo32_tp, load_tp,\n+\tset_tp, movdi_er_tlsgd, movdi_er_tlsldm, movdi_er_gotdtp,\n+\tmovdi_er_gottp, call_value_osf_tlsgd, call_value_osf_tlsldm): New.\n+\t(call_value_osf_2_er): Accept anything as op4.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/unicosmk.h (struct machine_function): Move to alpha.c.\n+\n 2002-05-31  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cppinit.c (append_include_chain): Always pay attention to"}, {"sha": "cbe8e3437b075dec7e1bee7ccecba4c628f7c824", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -61,6 +61,12 @@ extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int some_small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int global_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int dtp16_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int dtp32_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int gotdtp_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int tp16_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int tp32_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int gottp_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));"}, {"sha": "bee3dc1d5553db047f1d17674993a9925cbe12fe", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 501, "deletions": 55, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -69,6 +69,10 @@ enum alpha_fp_rounding_mode alpha_fprm;\n \n enum alpha_fp_trap_mode alpha_fptm;\n \n+/* Specify bit size of immediate TLS offsets.  */\n+\n+int alpha_tls_size = 32;\n+\n /* Strings decoded into the above options.  */\n \n const char *alpha_cpu_string;\t/* -mcpu= */\n@@ -77,6 +81,7 @@ const char *alpha_tp_string;\t/* -mtrap-precision=[p|s|i] */\n const char *alpha_fprm_string;\t/* -mfp-rounding-mode=[n|m|c|d] */\n const char *alpha_fptm_string;\t/* -mfp-trap-mode=[n|u|su|sui] */\n const char *alpha_mlat_string;\t/* -mmemory-latency= */\n+const char *alpha_tls_size_string; /* -mtls-size=[16|32|64] */\n \n /* Save information from a \"cmpxx\" operation until the branch or scc is\n    emitted.  */\n@@ -113,6 +118,10 @@ int alpha_this_literal_sequence_number;\n int alpha_this_gpdisp_sequence_number;\n \n /* Declarations of static functions.  */\n+static int tls_symbolic_operand_1\n+  PARAMS ((rtx, enum machine_mode, int, int));\n+static enum tls_model tls_symbolic_operand_type\n+  PARAMS ((rtx));\n static bool decl_in_text_section\n   PARAMS ((tree));\n static bool alpha_in_small_data_p\n@@ -125,8 +134,6 @@ static int some_small_symbolic_operand_1\n   PARAMS ((rtx *, void *));\n static int split_small_symbolic_operand_1\n   PARAMS ((rtx *, void *));\n-static bool local_symbol_p\n-  PARAMS ((rtx));\n static void alpha_set_memflags_1\n   PARAMS ((rtx, int, int, int));\n static rtx alpha_emit_set_const_1\n@@ -147,6 +154,10 @@ static const char *get_trap_mode_suffix\n   PARAMS ((void));\n static const char *get_round_mode_suffix\n   PARAMS ((void));\n+static const char *get_some_local_dynamic_name\n+  PARAMS ((void));\n+static int get_some_local_dynamic_name_1\n+  PARAMS ((rtx *, void *));\n static rtx set_frame_related_p\n   PARAMS ((void));\n static const char *alpha_lookup_xfloating_lib_func\n@@ -173,14 +184,12 @@ static void alpha_elf_select_rtx_section\n   PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n #endif\n \n-#if TARGET_ABI_UNICOSMK\n static void alpha_init_machine_status\n   PARAMS ((struct function *p));\n static void alpha_mark_machine_status\n   PARAMS ((struct function *p));\n static void alpha_free_machine_status\n   PARAMS ((struct function *p));\n-#endif\n \n static void unicosmk_output_deferred_case_vectors PARAMS ((FILE *));\n static void unicosmk_gen_dsib PARAMS ((unsigned long *imaskP));\n@@ -266,6 +275,9 @@ static void unicosmk_unique_section PARAMS ((tree, int));\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   alpha_multipass_dfa_lookahead\n \n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS HAVE_AS_TLS\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse target option strings.  */\n@@ -385,6 +397,18 @@ override_options ()\n \terror (\"bad value `%s' for -mfp-trap-mode switch\", alpha_fptm_string);\n     }\n \n+  if (alpha_tls_size_string)\n+    {\n+      if (strcmp (alpha_tls_size_string, \"16\") == 0)\n+\talpha_tls_size = 16;\n+      else if (strcmp (alpha_tls_size_string, \"32\") == 0)\n+\talpha_tls_size = 32;\n+      else if (strcmp (alpha_tls_size_string, \"64\") == 0)\n+\talpha_tls_size = 64;\n+      else\n+\terror (\"bad value `%s' for -mtls-size switch\", alpha_tls_size_string);\n+    }\n+\n   alpha_cpu\n     = TARGET_CPU_DEFAULT & MASK_CPU_EV6 ? PROCESSOR_EV6\n       : (TARGET_CPU_DEFAULT & MASK_CPU_EV5 ? PROCESSOR_EV5 : PROCESSOR_EV4);\n@@ -527,12 +551,10 @@ override_options ()\n \n   /* Register variables and functions with the garbage collector.  */\n \n-#if TARGET_ABI_UNICOSMK\n   /* Set up function hooks.  */\n   init_machine_status = alpha_init_machine_status;\n   mark_machine_status = alpha_mark_machine_status;\n   free_machine_status = alpha_free_machine_status;\n-#endif\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -857,7 +879,9 @@ input_operand (op, mode)\n \t     symbolic operands to be reconstructed from their high/lo_sum\n \t     form.  */\n \t  return (small_symbolic_operand (op, mode)\n-\t\t  || global_symbolic_operand (op, mode));\n+\t\t  || global_symbolic_operand (op, mode)\n+\t\t  || gotdtp_symbolic_operand (op, mode)\n+\t\t  || gottp_symbolic_operand (op, mode));\n \t}\n \n       /* This handles both the Windows/NT and OSF cases.  */\n@@ -946,29 +970,13 @@ direct_call_operand (op, mode)\n /* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n    a variable known to be defined in this file.  */\n \n-static bool\n-local_symbol_p (op)\n-     rtx op;\n-{\n-  const char *str = XSTR (op, 0);\n-\n-  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n-     run into problems with the rtl inliner in that the symbol was\n-     once external, but is local after inlining, which results in\n-     unrecognizable insns.  */\n-\n-  return (CONSTANT_POOL_ADDRESS_P (op)\n-\t  /* If @, then alpha_encode_section_info sez it's local.  */\n-\t  || str[0] == '@'\n-\t  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n-\t  || (str[0] == '*' && str[1] == '$'));\n-}\n-\n int\n local_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  const char *str;\n+\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -983,7 +991,26 @@ local_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n-  return local_symbol_p (op);\n+  /* Easy pickings.  */\n+  if (CONSTANT_POOL_ADDRESS_P (op) || STRING_POOL_ADDRESS_P (op))\n+    return 1;\n+\n+  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n+     run into problems with the rtl inliner in that the symbol was\n+     once external, but is local after inlining, which results in\n+     unrecognizable insns.  */\n+\n+  str = XSTR (op, 0);\n+\n+  /* If @[VS], then alpha_encode_section_info sez it's local.  */\n+  if (str[0] == '@' && (str[1] == 'L' || str[1] == 'S'))\n+    return 1;\n+\n+  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n+  if (str[0] == '*' && str[1] == '$')\n+    return 1;\n+\n+  return 0;\n }\n \n /* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n@@ -1015,7 +1042,7 @@ small_symbolic_operand (op, mode)\n   else\n     {\n       str = XSTR (op, 0);\n-      return str[0] == '@' && str[1] == 's';\n+      return str[0] == '@' && str[1] == 'S';\n     }\n }\n \n@@ -1027,6 +1054,8 @@ global_symbolic_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  const char *str;\n+\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n@@ -1038,7 +1067,12 @@ global_symbolic_operand (op, mode)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n \n-  return ! local_symbol_p (op);\n+  if (local_symbolic_operand (op, mode))\n+    return 0;\n+\n+  /* Also verify that it's not a TLS symbol.  */\n+  str = XSTR (op, 0);\n+  return str[0] != '%' && str[0] != '@';\n }\n \n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -1091,6 +1125,110 @@ symbolic_operand (op, mode)\n   return 0;\n }\n \n+/* Return true if OP is valid for a particular TLS relocation.  */\n+\n+static int\n+tls_symbolic_operand_1 (op, mode, size, unspec)\n+     rtx op;\n+     enum machine_mode mode;\n+     int size, unspec;\n+{\n+  const char *str;\n+  int letter;\n+\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_CODE (op) != CONST)\n+    return 0;\n+  op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != UNSPEC || XINT (op, 1) != unspec)\n+    return 0;\n+  op = XVECEXP (op, 0, 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  str = XSTR (op, 0);\n+\n+  if (str[0] == '%')\n+    {\n+      if (size != 64)\n+\treturn 0;\n+    }\n+  else if (str[0] == '@')\n+    {\n+      if (alpha_tls_size > size)\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  letter = (unspec == UNSPEC_DTPREL ? 'D' : 'T');\n+\n+  return str[1] == letter;\n+}\n+\n+/* Return true if OP is valid for 16-bit DTP relative relocations.  */\n+\n+int\n+dtp16_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_DTPREL);\n+}\n+\n+/* Return true if OP is valid for 32-bit DTP relative relocations.  */\n+\n+int\n+dtp32_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_DTPREL);\n+}\n+\n+/* Return true if OP is valid for 64-bit DTP relative relocations.  */\n+\n+int\n+gotdtp_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_DTPREL);\n+}\n+\n+/* Return true if OP is valid for 16-bit TP relative relocations.  */\n+\n+int\n+tp16_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_TPREL);\n+}\n+\n+/* Return true if OP is valid for 32-bit TP relative relocations.  */\n+\n+int\n+tp32_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_TPREL);\n+}\n+\n+/* Return true if OP is valid for 64-bit TP relative relocations.  */\n+\n+int\n+gottp_symbolic_operand (op, mode)\n+      rtx op;\n+      enum machine_mode mode;\n+{\n+  return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_TPREL);\n+}\n+\n /* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n    comparisons are valid in which insn.  */\n \n@@ -1561,6 +1699,54 @@ alpha_tablejump_best_label (insn)\n \n   return best_label ? best_label : const0_rtx;\n }\n+\n+/* Return the TLS model to use for SYMBOL.  */\n+\n+static enum tls_model\n+tls_symbolic_operand_type (symbol)\n+     rtx symbol;\n+{\n+  const char *str;\n+\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return 0;\n+  str = XSTR (symbol, 0);\n+\n+  if (str[0] == '%')\n+    {\n+      /* ??? Be prepared for -ftls-model=local-dynamic.  Perhaps we shouldn't\n+\t have separately encoded local-ness.  On well, maybe the user will use\n+\t attribute visibility next time.  At least we don't crash...  */\n+      if (str[1] == 'G' || str[1] == 'D')\n+\treturn TLS_MODEL_GLOBAL_DYNAMIC;\n+      if (str[1] == 'T')\n+\treturn TLS_MODEL_INITIAL_EXEC;\n+    }\n+  else if (str[0] == '@')\n+    {\n+      if (str[1] == 'D')\n+\t{\n+\t  /* Local dynamic is a waste if we're not going to combine\n+\t     the __tls_get_addr calls.  So avoid it if not optimizing.  */\n+\t  if (optimize)\n+\t    return TLS_MODEL_LOCAL_DYNAMIC;\n+\t  else\n+\t    return TLS_MODEL_GLOBAL_DYNAMIC;\n+\t}\n+      if (str[1] == 'T')\n+\t{\n+\t  /* 64-bit local exec is the same as initial exec except without\n+\t     the dynamic relocation.  In either case we use a got entry.  */\n+\t  if (alpha_tls_size == 64)\n+\t    return TLS_MODEL_INITIAL_EXEC;\n+\t  else\n+\t    return TLS_MODEL_LOCAL_EXEC;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n \f\n /* Return true if the function DECL will be placed in the default text\n    section.  */\n@@ -1622,7 +1808,8 @@ alpha_encode_section_info (decl, first)\n      int first ATTRIBUTE_UNUSED;\n {\n   const char *symbol_str;\n-  bool is_local, is_small;\n+  bool is_local;\n+  char encoding = 0;\n   rtx rtl, symbol;\n \n   rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n@@ -1659,37 +1846,69 @@ alpha_encode_section_info (decl, first)\n   /* A variable is considered \"local\" if it is defined in this module.  */\n   is_local = (*targetm.binds_local_p) (decl);\n \n-  /* Determine if DECL will wind up in .sdata/.sbss.  */\n-  is_small = alpha_in_small_data_p (decl);\n+  /* Care for TLS variables.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n+    {\n+      enum tls_model kind;\n+      if (!flag_pic)\n+\t{\n+\t  if (is_local)\n+\t    kind = TLS_MODEL_LOCAL_EXEC;\n+\t  else\n+\t    kind = TLS_MODEL_INITIAL_EXEC;\n+\t}\n+      else if (is_local)\n+\tkind = TLS_MODEL_LOCAL_DYNAMIC;\n+      else\n+\tkind = TLS_MODEL_GLOBAL_DYNAMIC;\n+      if (kind < flag_tls_default)\n+\tkind = flag_tls_default;\n+\n+      switch (kind)\n+\t{\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\t  encoding = 'G';\n+\t  break;\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n+\t  encoding = 'D';\n+\t  break;\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  encoding = 'T';\n+\t  break;\n+\t}\n+    }\n+  else if (is_local)\n+    {\n+      /* Determine if DECL will wind up in .sdata/.sbss.  */\n+      if (alpha_in_small_data_p (decl))\n+\tencoding = 'S';\n+      else\n+\tencoding = 'L';\n+    }\n \n   /* Finally, encode this into the symbol string.  */\n-  if (is_local)\n+  if (encoding)\n     {\n       char *newstr;\n       size_t len;\n \n-      if (symbol_str[0] == '@')\n+      if (symbol_str[0] == (is_local ? '@' : '%'))\n \t{\n-\t  if (symbol_str[1] == (is_small ? 's' : 'v'))\n+\t  if (symbol_str[1] == encoding)\n \t    return;\n \t  symbol_str += 2;\n \t}\n \n       len = strlen (symbol_str) + 1;\n       newstr = alloca (len + 2);\n \n-      newstr[0] = '@';\n-      newstr[1] = (is_small ? 's' : 'v');\n+      newstr[0] = (is_local ? '@' : '%');\n+      newstr[1] = encoding;\n       memcpy (newstr + 2, symbol_str, len);\n \t  \n       XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n     }\n-  else if (symbol_str[0] == '@')\n-    {\n-      /* We're hosed.  This can happen when the user adds a weak\n-\t attribute after rtl generation.  They should have gotten\n-\t a warning about unspecified behaviour from varasm.c.  */\n-    }\n }\n \n /* Undo the effects of the above.  */\n@@ -1698,7 +1917,7 @@ static const char *\n alpha_strip_name_encoding (str)\n      const char *str;\n {\n-  if (str[0] == '@')\n+  if (str[0] == '@' || str[0] == '%')\n     str += 2;\n   if (str[0] == '*')\n     str++;\n@@ -1799,7 +2018,9 @@ alpha_legitimate_address_p (mode, x, strict)\n \t    return false;\n \n \t  /* The symbol must be local.  */\n-\t  if (local_symbolic_operand (ofs, Pmode))\n+\t  if (local_symbolic_operand (ofs, Pmode)\n+\t      || dtp32_symbolic_operand (ofs, Pmode)\n+\t      || tp32_symbolic_operand (ofs, Pmode))\n \t    return true;\n \t}\n     }\n@@ -1865,6 +2086,100 @@ alpha_legitimize_address (x, scratch, mode)\n   /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */\n   if (TARGET_EXPLICIT_RELOCS && symbolic_operand (x, Pmode))\n     {\n+      rtx r0, r16, eqv, tga, tp, insn, dest, seq;\n+\n+      switch (tls_symbolic_operand_type (x))\n+\t{\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\t  start_sequence ();\n+\n+\t  r0 = gen_rtx_REG (Pmode, 0);\n+\t  r16 = gen_rtx_REG (Pmode, 16);\n+\t  tga = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_addr\");\n+\t  dest = gen_reg_rtx (Pmode);\n+\t  seq = GEN_INT (alpha_next_sequence_number++);\n+\t  \n+\t  emit_insn (gen_movdi_er_tlsgd (r16, pic_offset_table_rtx, x, seq));\n+\t  insn = gen_call_value_osf_tlsgd (r0, tga, seq);\n+\t  insn = emit_call_insn (insn);\n+\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n+\n+          insn = get_insns ();\n+\t  end_sequence ();\n+\n+\t  emit_libcall_block (insn, dest, r0, x);\n+\t  return dest;\n+\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n+\t  start_sequence ();\n+\n+\t  r0 = gen_rtx_REG (Pmode, 0);\n+\t  r16 = gen_rtx_REG (Pmode, 16);\n+\t  tga = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_addr\");\n+\t  scratch = gen_reg_rtx (Pmode);\n+\t  seq = GEN_INT (alpha_next_sequence_number++);\n+\n+\t  emit_insn (gen_movdi_er_tlsldm (r16, pic_offset_table_rtx, seq));\n+\t  insn = gen_call_value_osf_tlsldm (r0, tga, seq);\n+\t  insn = emit_call_insn (insn);\n+\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n+\n+          insn = get_insns ();\n+\t  end_sequence ();\n+\n+\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\tUNSPEC_TLSLDM_CALL);\n+\t  emit_libcall_block (insn, scratch, r0, eqv);\n+\n+\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPREL);\n+\t  eqv = gen_rtx_CONST (Pmode, eqv);\n+\n+\t  if (alpha_tls_size == 64)\n+\t    {\n+\t      dest = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest, eqv));\n+\t      emit_insn (gen_adddi3 (dest, dest, scratch));\n+\t      return dest;\n+\t    }\n+\t  if (alpha_tls_size == 32)\n+\t    {\n+\t      insn = gen_rtx_HIGH (Pmode, eqv);\n+\t      insn = gen_rtx_PLUS (Pmode, scratch, insn);\n+\t      scratch = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, scratch, insn));\n+\t    }\n+\t  return gen_rtx_LO_SUM (Pmode, scratch, eqv);\n+\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_TPREL);\n+\t  eqv = gen_rtx_CONST (Pmode, eqv);\n+\t  tp = gen_reg_rtx (Pmode);\n+\t  scratch = gen_reg_rtx (Pmode);\n+\t  dest = gen_reg_rtx (Pmode);\n+\n+\t  emit_insn (gen_load_tp (tp));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, scratch, eqv));\n+\t  emit_insn (gen_adddi3 (dest, tp, scratch));\n+\t  return dest;\n+\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_TPREL);\n+\t  eqv = gen_rtx_CONST (Pmode, eqv);\n+\t  tp = gen_reg_rtx (Pmode);\n+\n+\t  emit_insn (gen_load_tp (tp));\n+\t  if (alpha_tls_size == 32)\n+\t    {\n+\t      insn = gen_rtx_HIGH (Pmode, eqv);\n+\t      insn = gen_rtx_PLUS (Pmode, tp, insn);\n+\t      tp = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, tp, insn));\n+\t    }\n+\t  return gen_rtx_LO_SUM (Pmode, tp, eqv);\n+\t}\n+\n       if (local_symbolic_operand (x, Pmode))\n \t{\n \t  if (small_symbolic_operand (x, Pmode))\n@@ -2589,6 +2904,8 @@ alpha_expand_mov (mode, operands)\n       tmp = alpha_legitimize_address (operands[1], operands[0], mode);\n       if (tmp)\n \t{\n+\t  if (tmp == operands[0])\n+\t    return true;\n \t  operands[1] = tmp;\n \t  return false;\n \t}\n@@ -4906,21 +5223,47 @@ alpha_multipass_dfa_lookahead ()\n   return (alpha_cpu == PROCESSOR_EV6 ? 4 : 2);\n }\n \f\n+/* Machine-specific function data.  */\n+\n+struct machine_function\n+{\n+#if TARGET_ABI_UNICOSMK\n+  /* List of call information words for calls from this function.  */\n+  struct rtx_def *first_ciw;\n+  struct rtx_def *last_ciw;\n+  int ciw_count;\n+\n+  /* List of deferred case vectors.  */\n+  struct rtx_def *addr_list;\n+#else\n+#if TARGET_ABI_OSF\n+  const char *some_ld_name;\n+#else\n+  /* Non-empty struct.  */\n+  char dummy;\n+#endif\n+#endif\n+};\n+\n /* Register global variables and machine-specific functions with the\n    garbage collector.  */\n \n-#if TARGET_ABI_UNICOSMK\n static void\n alpha_init_machine_status (p)\n      struct function *p;\n {\n   p->machine =\n     (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n \n+#if TARGET_ABI_UNICOSMK\n   p->machine->first_ciw = NULL_RTX;\n   p->machine->last_ciw = NULL_RTX;\n   p->machine->ciw_count = 0;\n   p->machine->addr_list = NULL_RTX;\n+#endif\n+#if TARGET_ABI_OSF\n+  p->machine->some_ld_name = NULL;\n+#endif\n }\n \n static void\n@@ -4931,8 +5274,10 @@ alpha_mark_machine_status (p)\n \n   if (machine)\n     {\n+#if TARGET_ABI_UNICOSMK\n       ggc_mark_rtx (machine->first_ciw);\n       ggc_mark_rtx (machine->addr_list);\n+#endif\n     }\n }\n \n@@ -4943,7 +5288,6 @@ alpha_free_machine_status (p)\n   free (p->machine);\n   p->machine = NULL;\n }\n-#endif /* TARGET_ABI_UNICOSMK */\n \n /* Functions to save and restore alpha_return_addr_rtx.  */\n \n@@ -5087,6 +5431,45 @@ get_round_mode_suffix ()\n   abort ();\n }\n \n+/* Locate some local-dynamic symbol still in use by this function\n+   so that we can print its name in some movdi_er_tlsldm pattern.  */\n+\n+static const char *\n+get_some_local_dynamic_name ()\n+{\n+  rtx insn;\n+\n+  if (cfun->machine->some_ld_name)\n+    return cfun->machine->some_ld_name;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+\t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n+      return cfun->machine->some_ld_name;\n+\n+  abort ();\n+}\n+\n+static int\n+get_some_local_dynamic_name_1 (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      const char *str = XSTR (x, 0);\n+      if (str[0] == '@' && str[1] == 'D')\n+\t{\n+          cfun->machine->some_ld_name = str;\n+          return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Print an operand.  Recognize special options, documented below.  */\n \n void\n@@ -5104,6 +5487,10 @@ print_operand (file, x, code)\n       assemble_name (file, alpha_fnname);\n       break;\n \n+    case '&':\n+      assemble_name (file, get_some_local_dynamic_name ());\n+      break;\n+\n     case '/':\n       {\n \tconst char *trap = get_trap_mode_suffix ();\n@@ -5145,13 +5532,30 @@ print_operand (file, x, code)\n       break;\n \n     case 'J':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  if (INTVAL (x) != 0)\n-\t    fprintf (file, \"\\t\\t!lituse_jsr!%d\", (int) INTVAL (x));\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid %%J value\");\n+      {\n+\tconst char *lituse;\n+\n+        if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSGD_CALL)\n+\t  {\n+\t    x = XVECEXP (x, 0, 0);\n+\t    lituse = \"lituse_tlsgd\";\n+\t  }\n+\telse if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSLDM_CALL)\n+\t  {\n+\t    x = XVECEXP (x, 0, 0);\n+\t    lituse = \"lituse_tlsldm\";\n+\t  }\n+\telse if (GET_CODE (x) == CONST_INT)\n+\t  lituse = \"lituse_jsr\";\n+\telse\n+\t  {\n+\t    output_operand_lossage (\"invalid %%J value\");\n+\t    break;\n+\t  }\n+\n+\tif (x != const0_rtx)\n+\t  fprintf (file, \"\\t\\t!%s!%d\", lituse, (int) INTVAL (x));\n+      }\n       break;\n \n     case 'r':\n@@ -5385,6 +5789,19 @@ print_operand (file, x, code)\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n       else if (GET_CODE (x) == MEM)\n \toutput_address (XEXP (x, 0));\n+      else if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == UNSPEC)\n+\t{\n+\t  switch (XINT (XEXP (x, 0), 1))\n+\t    {\n+\t    case UNSPEC_DTPREL:\n+\t    case UNSPEC_TPREL:\n+\t      output_addr_const (file, XVECEXP (XEXP (x, 0), 0, 0));\n+\t      break;\n+\t    default:\n+\t      output_operand_lossage (\"unknown relocation unspec\");\n+\t      break;\n+\t    }\n+\t}\n       else\n \toutput_addr_const (file, x);\n       break;\n@@ -5414,7 +5831,36 @@ print_operand_address (file, addr)\n \n   if (GET_CODE (addr) == LO_SUM)\n     {\n-      output_addr_const (file, XEXP (addr, 1));\n+      const char *reloc16, *reloclo;\n+      rtx op1 = XEXP (addr, 1);\n+\n+      if (GET_CODE (op1) == CONST && GET_CODE (XEXP (op1, 0)) == UNSPEC)\n+\t{\n+\t  op1 = XEXP (op1, 0);\n+\t  switch (XINT (op1, 1))\n+\t    {\n+\t    case UNSPEC_DTPREL:\n+\t      reloc16 = NULL;\n+\t      reloclo = (alpha_tls_size == 16 ? \"dtprel\" : \"dtprello\");\n+\t      break;\n+\t    case UNSPEC_TPREL:\n+\t      reloc16 = NULL;\n+\t      reloclo = (alpha_tls_size == 16 ? \"tprel\" : \"tprello\");\n+\t      break;\n+\t    default:\n+\t      output_operand_lossage (\"unknown relocation unspec\");\n+\t      return;\n+\t    }\n+\n+\t  output_addr_const (file, XVECEXP (op1, 0, 0));\n+\t}\n+      else\n+\t{\n+\t  reloc16 = \"gprel\";\n+\t  reloclo = \"gprellow\";\n+\t  output_addr_const (file, op1);\n+\t}\n+\n       if (offset)\n \t{\n \t  fputc ('+', file);\n@@ -5431,7 +5877,7 @@ print_operand_address (file, addr)\n \tabort ();\n \n       fprintf (file, \"($%d)\\t\\t!%s\", basereg,\n-\t       (basereg == 29 ? \"gprel\" : \"gprellow\"));\n+\t       (basereg == 29 ? reloc16 : reloclo));\n       return;\n     }\n "}, {"sha": "94e773295b93440a1e820f942e5feb2a0039a94f", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -137,6 +137,7 @@ extern int target_flags;\n extern enum alpha_trap_precision alpha_tp;\n extern enum alpha_fp_rounding_mode alpha_fprm;\n extern enum alpha_fp_trap_mode alpha_fptm;\n+extern int alpha_tls_size;\n \n /* This means that floating-point support exists in the target implementation\n    of the Alpha architecture.  This is usually the default.  */\n@@ -208,6 +209,10 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define MASK_SMALL_DATA (1 << 13)\n #define TARGET_SMALL_DATA (target_flags & MASK_SMALL_DATA)\n \n+/* This means emit thread pointer loads for kernel not user.  */\n+#define MASK_TLS_KERNEL\t(1 << 14)\n+#define TARGET_TLS_KERNEL (target_flags & MASK_TLS_KERNEL)\n+\n /* This means that the processor is an EV5, EV56, or PCA56.\n    Unlike alpha_cpu this is not affected by -mtune= setting.  */\n #define MASK_CPU_EV5\t(1 << 28)\n@@ -251,6 +256,9 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #ifndef TARGET_FIXUP_EV5_PREFETCH\n #define TARGET_FIXUP_EV5_PREFETCH 0\n #endif\n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -293,6 +301,8 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n      N_(\"Emit 16-bit relocations to the small data areas\")},\t\t\\\n     {\"large-data\", -MASK_SMALL_DATA,\t\t\t\t\t\\\n      N_(\"Emit 32-bit relocations to the small data areas\")},\t\t\\\n+    {\"tls-kernel\", MASK_TLS_KERNEL,\t\t\t\t\t\\\n+     N_(\"Emit rdval instead of rduniq for thread pointer\")},\t\t\\\n     {\"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT\t\t\t\t\\\n \t | TARGET_DEFAULT_EXPLICIT_RELOCS, \"\"} }\n \n@@ -316,6 +326,7 @@ extern const char *alpha_fprm_string;\t/* For -mfp-rounding-mode=[n|m|c|d] */\n extern const char *alpha_fptm_string;\t/* For -mfp-trap-mode=[n|u|su|sui]  */\n extern const char *alpha_tp_string;\t/* For -mtrap-precision=[p|f|i] */\n extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n+extern const char *alpha_tls_size_string; /* For -mtls-size= */\n \n #define TARGET_OPTIONS\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n@@ -331,6 +342,8 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n    N_(\"Control the precision given to fp exceptions\")},\t\\\n   {\"memory-latency=\",\t&alpha_mlat_string,\t\t\\\n    N_(\"Tune expected memory latency\")},\t\t\t\\\n+  {\"tls-size=\",\t\t&alpha_tls_size_string,\t\t\\\n+   N_(\"Specify bit size of immediate TLS offsets\")},\t\\\n }\n \n /* This macro defines names of additional specifications to put in the\n@@ -681,7 +694,7 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n    class that represents their union.  */\n    \n enum reg_class {\n-  NO_REGS, R24_REG, R25_REG, R27_REG,\n+  NO_REGS, R0_REG, R24_REG, R25_REG, R27_REG,\n   GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -690,8 +703,8 @@ enum reg_class {\n \n /* Give names of register classes as strings for dump file.  */\n \n-#define REG_CLASS_NAMES\t\t\t\t\\\n- {\"NO_REGS\", \"R24_REG\", \"R25_REG\", \"R27_REG\",\t\\\n+#define REG_CLASS_NAMES\t\t\t\t\t\\\n+ {\"NO_REGS\", \"R0_REG\", \"R24_REG\", \"R25_REG\", \"R27_REG\",\t\\\n   \"GENERAL_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n@@ -700,6 +713,7 @@ enum reg_class {\n \n #define REG_CLASS_CONTENTS\t\t\t\t\\\n { {0x00000000, 0x00000000},\t/* NO_REGS */\t\t\\\n+  {0x00000001, 0x00000000},\t/* R0_REG */\t\t\\\n   {0x01000000, 0x00000000},\t/* R24_REG */\t\t\\\n   {0x02000000, 0x00000000},\t/* R25_REG */\t\t\\\n   {0x08000000, 0x00000000},\t/* R27_REG */\t\t\\\n@@ -713,7 +727,8 @@ enum reg_class {\n    or could index an array.  */\n \n #define REGNO_REG_CLASS(REGNO)\t\t\t\\\n- ((REGNO) == 24 ? R24_REG\t\t\t\\\n+ ((REGNO) == 0 ? R0_REG\t\t\t\t\\\n+  : (REGNO) == 24 ? R24_REG\t\t\t\\\n   : (REGNO) == 25 ? R25_REG\t\t\t\\\n   : (REGNO) == 27 ? R27_REG\t\t\t\\\n   : (REGNO) >= 32 && (REGNO) <= 62 ? FLOAT_REGS\t\\\n@@ -730,6 +745,7 @@ enum reg_class {\n   : (C) == 'b' ? R25_REG\t\t\\\n   : (C) == 'c' ? R27_REG\t\t\\\n   : (C) == 'f' ? FLOAT_REGS\t\t\\\n+  : (C) == 'v' ? R0_REG\t\t\t\\\n   : NO_REGS)\n \n /* Define this macro to change register usage conditional on target flags.  */\n@@ -1710,7 +1726,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define ASM_OUTPUT_LABELREF(STREAM, NAME)\t\\\n do {\t\t\t\t\t\t\\\n   const char *name_ = NAME;\t\t\t\\\n-  if (*name_ == '@')\t\t\t\t\\\n+  if (*name_ == '@' || *name == '%')\t\t\\\n     name_ += 2;\t\t\t\t\t\\\n   if (*name_ == '*')\t\t\t\t\\\n     name_++;\t\t\t\t\t\\\n@@ -1893,7 +1909,7 @@ do {\t\t\t\t\t\t\\\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '/' || (CODE) == ',' || (CODE) == '-' || (CODE) == '~' \\\n-   || (CODE) == '#' || (CODE) == '*')\n+   || (CODE) == '#' || (CODE) == '*' || (CODE) == '&')\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n \n@@ -1929,6 +1945,12 @@ do {\t\t\t\t\t\t\\\n   {\"local_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n   {\"small_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n   {\"global_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n+  {\"dtp16_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"dtp32_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"gotdtp_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"tp16_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"tp32_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"gottp_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n \t\t     SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\t\\"}, {"sha": "85e5f4cfcc5a08d3073bbe69799ac77a80611eac", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 224, "deletions": 3, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description for DEC Alpha for GNU C compiler\n ;; Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-;; 2000, 2001 Free Software Foundation, Inc.\n+;; 2000, 2001, 2002 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n ;;\n ;; This file is part of GNU CC.\n@@ -40,6 +40,15 @@\n    (UNSPEC_LITUSE\t12)\n    (UNSPEC_SIBCALL\t13)\n    (UNSPEC_SYMBOL\t14)\n+\n+   ;; TLS Support\n+   (UNSPEC_TLSGD_CALL\t15)\n+   (UNSPEC_TLSLDM_CALL\t16)\n+   (UNSPEC_TLSGD\t17)\n+   (UNSPEC_TLSLDM\t18)\n+   (UNSPEC_DTPREL\t19)\n+   (UNSPEC_TPREL\t20)\n+   (UNSPEC_TP\t\t21)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -57,6 +66,7 @@\n    (UNSPECV_FORCE_MOV\t9)\n    (UNSPECV_LDGP1\t10)\n    (UNSPECV_PLDGP2\t11)\t; prologue ldgp\n+   (UNSPECV_SET_TP\t12)\n   ])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n@@ -335,6 +345,48 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   \"\"\n   \"\")\n \n+(define_insn \"*adddi_er_lo16_dtp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"dtp16_symbolic_operand\" \"\")))]\n+  \"HAVE_AS_TLS\"\n+  \"lda %0,%2(%1)\\t\\t!dtprel\")\n+\n+(define_insn \"*adddi_er_hi32_dtp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (high:DI (match_operand:DI 2 \"dtp32_symbolic_operand\" \"\"))))]\n+  \"HAVE_AS_TLS\"\n+  \"ldah %0,%2(%1)\\t\\t!dtprelhi\")\n+\n+(define_insn \"*adddi_er_lo32_dtp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"dtp32_symbolic_operand\" \"\")))]\n+  \"HAVE_AS_TLS\"\n+  \"lda %0,%2(%1)\\t\\t!dtprello\")\n+\n+(define_insn \"*adddi_er_lo16_tp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"tp16_symbolic_operand\" \"\")))]\n+  \"HAVE_AS_TLS\"\n+  \"lda %0,%2(%1)\\t\\t!tprel\")\n+\n+(define_insn \"*adddi_er_hi32_tp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (high:DI (match_operand:DI 2 \"tp32_symbolic_operand\" \"\"))))]\n+  \"HAVE_AS_TLS\"\n+  \"ldah %0,%2(%1)\\t\\t!tprelhi\")\n+\n+(define_insn \"*adddi_er_lo32_tp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"tp32_symbolic_operand\" \"\")))]\n+  \"HAVE_AS_TLS\"\n+  \"lda %0,%2(%1)\\t\\t!tprello\")\n+\n (define_insn \"*adddi_er_high_l\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -4805,6 +4857,43 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   \"!TARGET_ABI_WINDOWS_NT\"\n   \"call_pal 0x81\"\n   [(set_attr \"type\" \"ibr\")])\n+\n+;; For userland, we load the thread pointer from the TCB.\n+;; For the kernel, we load the per-cpu private value.\n+\n+(define_insn \"load_tp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=v\")\n+\t(unspec:DI [(const_int 0)] UNSPEC_TP))]\n+  \"TARGET_ABI_OSF\"\n+{\n+  if (TARGET_TLS_KERNEL)\n+    return \"call_pal 0x32\";\n+  else\n+    return \"call_pal 0x9e\";\n+}\n+  [(set_attr \"type\" \"ibr\")])\n+\n+;; For completeness, and possibly a __builtin function, here's how to\n+;; set the thread pointer.  Since we don't describe enough of this\n+;; quantity for CSE, we have to use a volatile unspec, and then there's\n+;; not much point in creating an R16_REG register class.\n+\n+(define_expand \"set_tp\"\n+  [(set (reg:DI 16) (match_operand:DI 0 \"input_operand\" \"\"))\n+   (unspec_volatile [(reg:DI 16)] UNSPECV_SET_TP)]\n+  \"TARGET_ABI_OSF\"\n+  \"\")\n+\n+(define_insn \"*set_tp\"\n+  [(unspec_volatile [(reg:DI 16)] UNSPECV_SET_TP)]\n+  \"TARGET_ABI_OSF\"\n+{\n+  if (TARGET_TLS_KERNEL)\n+    return \"call_pal 0x31\";\n+  else\n+    return \"call_pal 0x9f\";\n+}\n+  [(set_attr \"type\" \"ibr\")])\n \f\n ;; Finally, we have the basic data motion insns.  The byte and word insns\n ;; are done via define_expand.  Start with the floating-point insns, since\n@@ -5282,6 +5371,75 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n     }\n })\n \n+(define_insn \"movdi_er_tlsgd\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"symbolic_operand\" \"\")\n+\t\t    (match_operand 3 \"const_int_operand\" \"\")]\n+\t\t   UNSPEC_TLSGD))]\n+  \"HAVE_AS_TLS\"\n+{\n+  if (INTVAL (operands[3]) == 0)\n+    return \"lda %0,%2(%1)\\t\\t!tlsgd\";\n+  else\n+    return \"lda %0,%2(%1)\\t\\t!tlsgd!%3\";\n+})\n+\n+(define_insn \"movdi_er_tlsldm\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t   UNSPEC_TLSLDM))]\n+  \"HAVE_AS_TLS\"\n+{\n+  if (INTVAL (operands[2]) == 0)\n+    return \"lda %0,%&(%1)\\t\\t!tlsldm\";\n+  else\n+    return \"lda %0,%&(%1)\\t\\t!tlsldm!%2\";\n+})\n+\n+(define_insn \"*movdi_er_gotdtp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_DTPREL))]\n+  \"HAVE_AS_TLS\"\n+  \"ldq %0,%2(%1)\\t\\t!gotdtprel\"\n+  [(set_attr \"type\" \"ild\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"gotdtp_symbolic_operand\" \"\"))]\n+  \"HAVE_AS_TLS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:DI [(match_dup 2)\n+\t\t    (match_dup 1)] UNSPEC_DTPREL))]\n+{\n+  operands[1] = XVECEXP (XEXP (operands[1], 0), 0, 0);\n+  operands[2] = pic_offset_table_rtx;\n+})\n+\n+(define_insn \"*movdi_er_gottp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TPREL))]\n+  \"HAVE_AS_TLS\"\n+  \"ldq %0,%2(%1)\\t\\t!gottprel\"\n+  [(set_attr \"type\" \"ild\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"gottp_symbolic_operand\" \"\"))]\n+  \"HAVE_AS_TLS && reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:DI [(match_dup 2)\n+\t\t    (match_dup 1)] UNSPEC_TPREL))]\n+{\n+  operands[1] = XVECEXP (XEXP (operands[1], 0), 0, 0);\n+  operands[2] = pic_offset_table_rtx;\n+})\n+\n (define_insn \"*movdi_er_nofix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n \t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f\"))]\n@@ -6720,7 +6878,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n \t(plus:DI (pc) (const_int 4)))\n    (unspec_volatile [(reg:DI 29)] UNSPECV_BLOCKAGE)\n    (use (match_operand 3 \"\" \"\"))\n-   (use (match_operand 4 \"const_int_operand\" \"\"))]\n+   (use (match_operand 4 \"\" \"\"))]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n   \"jsr $26,(%1),%3%J4\"\n   [(set_attr \"type\" \"jsr\")])\n@@ -6740,6 +6898,70 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"*,*,8\")])\n \n+(define_insn_and_split \"call_value_osf_tlsgd\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"symbolic_operand\" \"\"))\n+\t      (const_int 0)))\n+   (unspec [(match_operand:DI 2 \"const_int_operand\" \"\")] UNSPEC_TLSGD_CALL)\n+   (use (reg:DI 29))\n+   (clobber (reg:DI 26))]\n+  \"HAVE_AS_TLS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(unspec:DI [(match_dup 5)\n+\t\t    (match_dup 1)\n+\t\t    (match_dup 2)] UNSPEC_LITERAL))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:DI (match_dup 3))\n+\t\t\t (const_int 0)))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(match_dup 5)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 1))\n+\t      (use (unspec [(match_dup 2)] UNSPEC_TLSGD_CALL))])\n+   (set (match_dup 5)\n+\t(unspec_volatile:DI [(reg:DI 26) (match_dup 4)] UNSPECV_LDGP1))\n+   (set (match_dup 5)\n+\t(unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP2))]\n+{\n+  operands[3] = gen_rtx_REG (Pmode, 27);\n+  operands[4] = GEN_INT (alpha_next_sequence_number++);\n+  operands[5] = pic_offset_table_rtx;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"call_value_osf_tlsldm\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"symbolic_operand\" \"\"))\n+\t      (const_int 0)))\n+   (unspec [(match_operand:DI 2 \"const_int_operand\" \"\")] UNSPEC_TLSLDM_CALL)\n+   (use (reg:DI 29))\n+   (clobber (reg:DI 26))]\n+  \"HAVE_AS_TLS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3)\n+\t(unspec:DI [(match_dup 5)\n+\t\t    (match_dup 1)\n+\t\t    (match_dup 2)] UNSPEC_LITERAL))\n+   (parallel [(set (match_dup 0)\n+\t\t   (call (mem:DI (match_dup 3))\n+\t\t\t (const_int 0)))\n+\t      (set (reg:DI 26) (plus:DI (pc) (const_int 4)))\n+\t      (unspec_volatile [(match_dup 5)] UNSPECV_BLOCKAGE)\n+\t      (use (match_dup 1))\n+\t      (use (unspec [(match_dup 2)] UNSPEC_TLSLDM_CALL))])\n+   (set (reg:DI 29)\n+\t(unspec_volatile:DI [(reg:DI 26) (match_dup 4)] UNSPECV_LDGP1))\n+   (set (reg:DI 29)\n+\t(unspec:DI [(reg:DI 29) (match_dup 4)] UNSPEC_LDGP2))]\n+{\n+  operands[3] = gen_rtx_REG (Pmode, 27);\n+  operands[4] = GEN_INT (alpha_next_sequence_number++);\n+  operands[5] = pic_offset_table_rtx;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_insn \"*call_value_osf_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,s\"))\n@@ -6815,4 +7037,3 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   \"TARGET_ABI_UNICOSMK\"\n   \"jsr $26,(%1)\"\n   [(set_attr \"type\" \"jsr\")])\n-"}, {"sha": "d21ba8844c4d1eb5e43454f552261eaaa58a43d2", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -293,19 +293,6 @@ do {\t\t\t\t\t\t\t\t\\\n #undef EPILOGUE_USES\n #define EPILOGUE_USES(REGNO)  ((REGNO) == 26 || (REGNO) == 15)\n \n-/* Machine-specific function data.  */\n-\n-struct machine_function\n-{\n-  /* List of call information words for calls from this function.  */\n-  struct rtx_def *first_ciw;\n-  struct rtx_def *last_ciw;\n-  int ciw_count;\n-\n-  /* List of deferred case vectors.  */\n-  struct rtx_def *addr_list;\n-};\n-\n /* Would have worked, only the stack doesn't seem to be executable\n #undef TRAMPOLINE_TEMPLATE\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\"}, {"sha": "e9bdc235b51f7ade65a2b1fdfa567d82efb69479", "filename": "gcc/configure", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -7399,6 +7399,28 @@ conftest_s=\n tls_first_major=\n tls_first_minor=\n case \"$target\" in\n+  alpha*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tldq\t$27,__tls_get_addr($29)\t\t!literal!1\n+\tlda\t$16,foo($29)\t\t\t!tlsgd!1\n+\tjsr\t$26,($27),__tls_get_addr\t!lituse_tlsgd!1\n+\tldq\t$27,__tls_get_addr($29)\t\t!literal!2\n+\tlda\t$16,foo($29)\t\t\t!tlsldm!2\n+\tjsr\t$26,($27),__tls_get_addr\t!lituse_tlsldm!2\n+\tldq\t$1,foo($29)\t\t\t!gotdtprel\n+\tldah\t$2,foo($29)\t\t\t!dtprelhi\n+\tlda\t$3,foo($2)\t\t\t!dtprello\n+\tlda\t$4,foo($29)\t\t\t!dtprel\n+\tldq\t$1,foo($29)\t\t\t!gottprel\n+\tldah\t$2,foo($29)\t\t\t!tprelhi\n+\tlda\t$3,foo($2)\t\t\t!tprello\n+\tlda\t$4,foo($29)\t\t\t!tprel'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n   i[34567]86-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n@@ -7463,7 +7485,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:7467: checking assembler supports explicit relocations\" >&5\n+echo \"configure:7489: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7513,7 +7535,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:7517: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:7539: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7541,7 +7563,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:7545: checking assembler supports -relax\" >&5\n+echo \"configure:7567: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7569,7 +7591,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:7573: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:7595: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7596,7 +7618,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:7600: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:7622: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7637,7 +7659,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:7641: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:7663: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7677,7 +7699,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:7681: checking assembler instructions\" >&5\n+echo \"configure:7703: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7704,7 +7726,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:7708: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:7730: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -7734,7 +7756,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7738: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:7760: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -7790,7 +7812,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7794: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:7816: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7819,7 +7841,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:7823: checking assembler --gstabs support\" >&5\n+echo \"configure:7845: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7847,7 +7869,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7851: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7873: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8010,7 +8032,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:8014: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:8036: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "c28efa0e6201e0d7df69989e1e14af42f23910ac", "filename": "gcc/configure.in", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f9b006de010523b6186de10c00b1f0c366cb6c0/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=6f9b006de010523b6186de10c00b1f0c366cb6c0", "patch": "@@ -1725,6 +1725,28 @@ tls_first_major=\n tls_first_minor=\n case \"$target\" in\n changequote(,)dnl\n+  alpha*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tldq\t$27,__tls_get_addr($29)\t\t!literal!1\n+\tlda\t$16,foo($29)\t\t\t!tlsgd!1\n+\tjsr\t$26,($27),__tls_get_addr\t!lituse_tlsgd!1\n+\tldq\t$27,__tls_get_addr($29)\t\t!literal!2\n+\tlda\t$16,foo($29)\t\t\t!tlsldm!2\n+\tjsr\t$26,($27),__tls_get_addr\t!lituse_tlsldm!2\n+\tldq\t$1,foo($29)\t\t\t!gotdtprel\n+\tldah\t$2,foo($29)\t\t\t!dtprelhi\n+\tlda\t$3,foo($2)\t\t\t!dtprello\n+\tlda\t$4,foo($29)\t\t\t!dtprel\n+\tldq\t$1,foo($29)\t\t\t!gottprel\n+\tldah\t$2,foo($29)\t\t\t!tprelhi\n+\tlda\t$3,foo($2)\t\t\t!tprello\n+\tlda\t$4,foo($29)\t\t\t!tprel'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n   i[34567]86-*-*)\n changequote([,])dnl\n     conftest_s='"}]}