{"sha": "c2ba97097b567d97c5c00435d2e9f0fc1079e355", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiYTk3MDk3YjU2N2Q5N2M1YzAwNDM1ZDJlOWYwZmMxMDc5ZTM1NQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-09-11T22:32:51Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-09-11T22:32:51Z"}, "message": "Add parallel mode.\n\n2007-09-11  Johannes Singler  <singler@ira.uka.de>\n\t    Leonor Frias Moya  <lfrias@lsi.upc.edu>\n            Felix Putze  <kontakt@felix-putze.de>\n            Marius Elvert  <marius.elvert@ira.uka.de>\n\t    Felix Bondarenko  <f.bondarenko@web.de>\n\t    Robert Geisberger  <robert.geisberger@stud.uni-karlsruhe.de>\n\t    Robin Dapp  <r.dapp@freenet.de>\n  \t    Benjamin Kosnik  <bkoz@redhat.com>\n\n\tAdd parallel mode.\n\t* include/parallel: New.\n\t* include/parallel/iterator.h: New.\n\t* include/parallel/multiway_merge.h: New.\n\t* include/parallel/parallel.h: New.\n\t* include/parallel/algorithm\n\t* include/parallel/find_selectors.h: New.\n\t* include/parallel/losertree.h: New.\n\t* include/parallel/list_partition.h: New.\n\t* include/parallel/types.h: New.\n\t* include/parallel/for_each.h: New.\n\t* include/parallel/multiseq_selection.h: New.\n\t* include/parallel/workstealing.h: New.\n\t* include/parallel/base.h: New.\n\t* include/parallel/par_loop.h: New.\n\t* include/parallel/numeric\n\t* include/parallel/features.h: New.\n\t* include/parallel/quicksort.h: New.\n\t* include/parallel/algorithmfwd.h: New.\n\t* include/parallel/equally_split.h: New.\n\t* include/parallel/compiletime_settings.h: New.\n\t* include/parallel/for_each_selectors.h: New.\n\t* include/parallel/basic_iterator.h: New.\n\t* include/parallel/omp_loop_static.h: New.\n\t* include/parallel/random_shuffle.h: New.\n\t* include/parallel/balanced_quicksort.h: New.\n\t* include/parallel/set_operations.h: New.\n\t* include/parallel/tags.h: New.\n\t* include/parallel/merge.h: New.\n\t* include/parallel/tree.h: New.\n\t* include/parallel/settings.h: New.\n\t* include/parallel/unique_copy.h: New.\n\t* include/parallel/multiway_mergesort.h: New.\n\t* include/parallel/numericfwd.h: New.\n\t* include/parallel/search.h: New.\n\t* include/parallel/partition.h: New.\n\t* include/parallel/compatibility.h: New.\n\t* include/parallel/algobase.h: New.\n\t* include/parallel/find.h: New.\n\t* include/parallel/partial_sum.h: New.\n\t* include/parallel/algo.h: New.\n\t* include/parallel/omp_loop.h: New.\n\t* include/parallel/queue.h: New.\n\t* include/parallel/timing.h: New.\n\t* include/parallel/sort.h: New.\n\t* include/parallel/checkers.h: New.\n\t* include/parallel/random_number.h: New.\n\t* include/bits/algorithmfwd.h: New.\n\n\t* acinclude.m4 (GLIBCXX_ENABLE_PARALLEL): New.\n\t* configure.host: Add atomic_flags.\n\t* configure.ac: Export ATOMIC_FLAGS, call GLIBCXX_ENABLE_PARALLEL.\n\t* src/Makefile.am: Add parallel_list rules.\n\t* include/Makefile.am: Add parallel files.\n\t* testsuite/Makefile.am (check-parallel): Add.\n\t(check-performance-parallel): Add.\n\t* config.h.in: Regenerate.\n\t* configure: Same.\n\t* libsupc++/Makefile.in: Same.\n\t* testsuite/Makefile.in: Same.\n\t* Makefile.in: Same.\n\t* libmath/Makefile.in: Same.\n\t* include/Makefile.in: Same.\n\t* src/Makefile.in: Same.\n\t* po/Makefile.in: Same.\n\t\n\t* config/abi/pre/gnu.ver: Export parallel list bits.\n\n\t* docs/html/parallel_mode.html: New.\n\t* docs/html/documentation.html: Add link.\n\t* docs/doxygen/user.cfg.in: Adjust for new files and directory.\n\t* docs/doxygen/doxygroups.cc: Adjust namespace markup.\n\n\t* include/debug/set.h: Adjust for _GLIBCXX_STD_D or _P change.\n\t* include/debug/bitset: Same.\n\t* include/debug/multiset.h: Same.\n\t* include/debug/vector: Same.\n\t* include/debug/map.h: Same.\n\t* include/debug/deque: Same.\n\t* include/debug/list: Same.\n\t* include/debug/debug.h: Same.\n\t* include/debug/multimap.h: Same.\n\t* include/std/algorithm: Same.\n\t* include/std/numeric: Same.\n\t* include/std/bitset: Same.\n\t* include/std/string: Same.\n\t* include/ext/hash_map: Same.\n\t* include/ext/hash_set: Same.\n\t* include/bits/stl_list.h: Same.\n\t* include/bits/stl_map.h: Same.\n\t* include/bits/stl_algobase.h: Same.\n\t* include/bits/stl_set.h: Same.\n\t* include/bits/stl_multimap.h: Same.\n\t* include/bits/stl_vector.h: Same.\n\t* include/bits/stl_numeric.h: Same.\n\t* include/bits/stl_deque.h: Same.\n\t* include/bits/stl_multiset.h: Same.\n\t* include/bits/char_traits.h: Same.\n\t* include/bits/stl_algo.h: Same.\n\t* include/bits/c++config: Same.\n\t* include/bits/vector.tcc: Same.\n\t* include/bits/deque.tcc: Same.\n\t* include/bits/stl_bvector.h: Same.\n\t* include/bits/list.tcc: Same.\n\t* src/list.cc: Same.\n\t* src/parallel_list.cc: New.\n\n\t* testsuite/lib/libstdc++.exp (check_v3_target_parallel_mode): New.\n\t* testsuite/lib/dg-options.exp (dg-require-parallel-mode): New.\n\t* scripts/testsuite_flags.in (--cxxparallelflags): New.\n\t* scripts/check_performance: Adjust.\n\t* testsuite/25_algorithms/headers/parallel_algorithm.cc: New.\n\t* testsuite/25_algorithms/headers/algorithm_parallel_mode.cc: New.\n\t* testsuite/25_algorithms/headers/parallel_algorithm_mixed1.cc: New.\n\t* testsuite/25_algorithms/headers/parallel_algorithm_mixed2.cc: New.\n\t* testsuite/26_numerics/headers/numeric/parallel_numeric.cc: New.\n\t* testsuite/26_numerics/headers/numeric/numeric_parallel_mode.cc: New.\n\t* testsuite/26_numerics/headers/numeric/\n\tparallel_numeric_mixed1.cc: New.\n\t* testsuite/26_numerics/headers/numeric/\n\tparallel_numeric_mixed2.cc: New.\n\t\n\nCo-Authored-By: Benjamin Kosnik <bkoz@redhat.com>\nCo-Authored-By: Felix Bondarenko <f.bondarenko@web.de>\nCo-Authored-By: Felix Putze <kontakt@felix-putze.de>\nCo-Authored-By: Leonor Frias Moya <lfrias@lsi.upc.edu>\nCo-Authored-By: Marius Elvert <marius.elvert@ira.uka.de>\nCo-Authored-By: Robert Geisberger <robert.geisberger@stud.uni-karlsruhe.de>\nCo-Authored-By: Robin Dapp <r.dapp@freenet.de>\n\nFrom-SVN: r128395", "tree": {"sha": "660699dec60831dd9dc3d9f45ef737cfcae5b76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/660699dec60831dd9dc3d9f45ef737cfcae5b76d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2ba97097b567d97c5c00435d2e9f0fc1079e355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ba97097b567d97c5c00435d2e9f0fc1079e355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ba97097b567d97c5c00435d2e9f0fc1079e355", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ba97097b567d97c5c00435d2e9f0fc1079e355/comments", "author": null, "committer": null, "parents": [{"sha": "f6ee8d7b734810950a246330607a1a5973cebd10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ee8d7b734810950a246330607a1a5973cebd10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ee8d7b734810950a246330607a1a5973cebd10"}], "stats": {"total": 27931, "additions": 23951, "deletions": 3980}, "files": [{"sha": "6beffdbb12457fd7130d81b739a9596e5ff96387", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -1,3 +1,134 @@\n+2007-09-11  Johannes Singler  <singler@ira.uka.de>\n+\t    Leonor Frias Moya  <lfrias@lsi.upc.edu>\n+            Felix Putze  <kontakt@felix-putze.de>\n+            Marius Elvert  <marius.elvert@ira.uka.de>\n+\t    Felix Bondarenko  <f.bondarenko@web.de>\n+\t    Robert Geisberger  <robert.geisberger@stud.uni-karlsruhe.de>\n+\t    Robin Dapp  <r.dapp@freenet.de>\n+  \t    Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tAdd parallel mode.\n+\t* include/parallel: New.\n+\t* include/parallel/iterator.h: New.\n+\t* include/parallel/multiway_merge.h: New.\n+\t* include/parallel/parallel.h: New.\n+\t* include/parallel/algorithm\n+\t* include/parallel/find_selectors.h: New.\n+\t* include/parallel/losertree.h: New.\n+\t* include/parallel/list_partition.h: New.\n+\t* include/parallel/types.h: New.\n+\t* include/parallel/for_each.h: New.\n+\t* include/parallel/multiseq_selection.h: New.\n+\t* include/parallel/workstealing.h: New.\n+\t* include/parallel/base.h: New.\n+\t* include/parallel/par_loop.h: New.\n+\t* include/parallel/numeric\n+\t* include/parallel/features.h: New.\n+\t* include/parallel/quicksort.h: New.\n+\t* include/parallel/algorithmfwd.h: New.\n+\t* include/parallel/equally_split.h: New.\n+\t* include/parallel/compiletime_settings.h: New.\n+\t* include/parallel/for_each_selectors.h: New.\n+\t* include/parallel/basic_iterator.h: New.\n+\t* include/parallel/omp_loop_static.h: New.\n+\t* include/parallel/random_shuffle.h: New.\n+\t* include/parallel/balanced_quicksort.h: New.\n+\t* include/parallel/set_operations.h: New.\n+\t* include/parallel/tags.h: New.\n+\t* include/parallel/merge.h: New.\n+\t* include/parallel/tree.h: New.\n+\t* include/parallel/settings.h: New.\n+\t* include/parallel/unique_copy.h: New.\n+\t* include/parallel/multiway_mergesort.h: New.\n+\t* include/parallel/numericfwd.h: New.\n+\t* include/parallel/search.h: New.\n+\t* include/parallel/partition.h: New.\n+\t* include/parallel/compatibility.h: New.\n+\t* include/parallel/algobase.h: New.\n+\t* include/parallel/find.h: New.\n+\t* include/parallel/partial_sum.h: New.\n+\t* include/parallel/algo.h: New.\n+\t* include/parallel/omp_loop.h: New.\n+\t* include/parallel/queue.h: New.\n+\t* include/parallel/timing.h: New.\n+\t* include/parallel/sort.h: New.\n+\t* include/parallel/checkers.h: New.\n+\t* include/parallel/random_number.h: New.\n+\t* include/bits/algorithmfwd.h: New.\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_PARALLEL): New.\n+\t* configure.host: Add atomic_flags.\n+\t* configure.ac: Export ATOMIC_FLAGS, call GLIBCXX_ENABLE_PARALLEL.\n+\t* src/Makefile.am: Add parallel_list rules.\n+\t* include/Makefile.am: Add parallel files.\n+\t* testsuite/Makefile.am (check-parallel): Add.\n+\t(check-performance-parallel): Add.\n+\t* config.h.in: Regenerate.\n+\t* configure: Same.\n+\t* libsupc++/Makefile.in: Same.\n+\t* testsuite/Makefile.in: Same.\n+\t* Makefile.in: Same.\n+\t* libmath/Makefile.in: Same.\n+\t* include/Makefile.in: Same.\n+\t* src/Makefile.in: Same.\n+\t* po/Makefile.in: Same.\n+\t\n+\t* config/abi/pre/gnu.ver: Export parallel list bits.\n+\n+\t* docs/html/parallel_mode.html: New.\n+\t* docs/html/documentation.html: Add link.\n+\t* docs/doxygen/user.cfg.in: Adjust for new files and directory.\n+\t* docs/doxygen/doxygroups.cc: Adjust namespace markup.\n+\n+\t* include/debug/set.h: Adjust for _GLIBCXX_STD_D or _P change.\n+\t* include/debug/bitset: Same.\n+\t* include/debug/multiset.h: Same.\n+\t* include/debug/vector: Same.\n+\t* include/debug/map.h: Same.\n+\t* include/debug/deque: Same.\n+\t* include/debug/list: Same.\n+\t* include/debug/debug.h: Same.\n+\t* include/debug/multimap.h: Same.\n+\t* include/std/algorithm: Same.\n+\t* include/std/numeric: Same.\n+\t* include/std/bitset: Same.\n+\t* include/std/string: Same.\n+\t* include/ext/hash_map: Same.\n+\t* include/ext/hash_set: Same.\n+\t* include/bits/stl_list.h: Same.\n+\t* include/bits/stl_map.h: Same.\n+\t* include/bits/stl_algobase.h: Same.\n+\t* include/bits/stl_set.h: Same.\n+\t* include/bits/stl_multimap.h: Same.\n+\t* include/bits/stl_vector.h: Same.\n+\t* include/bits/stl_numeric.h: Same.\n+\t* include/bits/stl_deque.h: Same.\n+\t* include/bits/stl_multiset.h: Same.\n+\t* include/bits/char_traits.h: Same.\n+\t* include/bits/stl_algo.h: Same.\n+\t* include/bits/c++config: Same.\n+\t* include/bits/vector.tcc: Same.\n+\t* include/bits/deque.tcc: Same.\n+\t* include/bits/stl_bvector.h: Same.\n+\t* include/bits/list.tcc: Same.\n+\t* src/list.cc: Same.\n+\t* src/parallel_list.cc: New.\n+\n+\t* testsuite/lib/libstdc++.exp (check_v3_target_parallel_mode): New.\n+\t* testsuite/lib/dg-options.exp (dg-require-parallel-mode): New.\n+\t* scripts/testsuite_flags.in (--cxxparallelflags): New.\n+\t* scripts/check_performance: Adjust.\n+\t* testsuite/25_algorithms/headers/parallel_algorithm.cc: New.\n+\t* testsuite/25_algorithms/headers/algorithm_parallel_mode.cc: New.\n+\t* testsuite/25_algorithms/headers/parallel_algorithm_mixed1.cc: New.\n+\t* testsuite/25_algorithms/headers/parallel_algorithm_mixed2.cc: New.\n+\t* testsuite/26_numerics/headers/numeric/parallel_numeric.cc: New.\n+\t* testsuite/26_numerics/headers/numeric/numeric_parallel_mode.cc: New.\n+\t* testsuite/26_numerics/headers/numeric/\n+\tparallel_numeric_mixed1.cc: New.\n+\t* testsuite/26_numerics/headers/numeric/\n+\tparallel_numeric_mixed2.cc: New.\n+\t\n 2007-09-11  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* testsuite/lib/libstdc++.exp (libstdc++_init): Revert part of"}, {"sha": "c3d4cc592e0d055f3c38aa98c60c98064fae6169", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -103,6 +103,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -140,6 +141,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@"}, {"sha": "a6343edb4e3067138ad0b73cd63eff61362b5d38", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -1725,6 +1725,23 @@ AC_DEFUN([GLIBCXX_ENABLE_CONCEPT_CHECKS], [\n   fi\n ])\n \n+dnl\n+dnl Check for parallel mode pre-requisites, including OpenMP support.\n+dnl\n+dnl  +  Usage:  GLIBCXX_ENABLE_PARALLEL\n+dnl\n+AC_DEFUN([GLIBCXX_ENABLE_PARALLEL], [\n+\n+  enable_parallel=no;\n+  if test -f \"${glibcxx_builddir}/../libgomp/omp.h\"; then\n+    enable_parallel=yes;\n+  fi\n+\n+  AC_MSG_CHECKING([for parallel mode support])\n+  AC_MSG_RESULT([$enable_parallel])\n+  GLIBCXX_CONDITIONAL(ENABLE_PARALLEL, test $enable_parallel = yes)\n+])\n+\n \n dnl\n dnl Check for which I/O library to use:  stdio, or something specific.\n@@ -2072,7 +2089,7 @@ AC_DEFUN([GLIBCXX_ENABLE_PCH], [\n \n   GLIBCXX_CONDITIONAL(GLIBCXX_BUILD_PCH, test $enable_libstdcxx_pch = yes)\n   if test $enable_libstdcxx_pch = yes; then\n-    glibcxx_PCHFLAGS=\"-include bits/stdtr1c++.h\"\n+    glibcxx_PCHFLAGS=\"-include bits/stdc++.h\"\n   else\n     glibcxx_PCHFLAGS=\"\"\n   fi"}, {"sha": "4a9ffb763cfe5f530423269984cb6dc428c58af7", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -63,6 +63,9 @@\n /* Define if EBADMSG exists. */\n #undef HAVE_EBADMSG\n \n+/* Define if ECANCELED exists. */\n+#undef HAVE_ECANCELED\n+\n /* Define to 1 if you have the <endian.h> header file. */\n #undef HAVE_ENDIAN_H\n "}, {"sha": "cc6252e91c7d64dc5d620ed716c2cb215ec0036e", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -770,6 +770,13 @@ GLIBCXX_3.4.10 {\n     _ZNKSt4hashISsEclESs;\n     _ZNKSt4hashISt10error_codeEclES0_;\n \n+    # for parallel mode\n+    _ZNSt9__cxx199815_List_node_base4hook*;\n+    _ZNSt9__cxx199815_List_node_base4swap*;\n+    _ZNSt9__cxx199815_List_node_base6unhookEv;\n+    _ZNSt9__cxx199815_List_node_base7reverseEv;\n+    _ZNSt9__cxx199815_List_node_base8transfer*;\n+\n } GLIBCXX_3.4.9;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "74d0aaea0a99b7789aa34582e3ac9059bece31c9", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -458,7 +458,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libtool_VERSION multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar glibcxx_builddir glibcxx_srcdir toplevel_srcdir CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LN_S AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM lt_ECHO LDFLAGS CXXCPP enable_shared enable_static GLIBCXX_HOSTED_TRUE GLIBCXX_HOSTED_FALSE GLIBCXX_BUILD_PCH_TRUE GLIBCXX_BUILD_PCH_FALSE glibcxx_PCHFLAGS CSTDIO_H BASIC_FILE_H BASIC_FILE_CC check_msgfmt glibcxx_MOFILES glibcxx_POFILES glibcxx_localedir USE_NLS CLOCALE_H CMESSAGES_H CCODECVT_CC CCOLLATE_CC CCTYPE_CC CMESSAGES_CC CMONEY_CC CNUMERIC_CC CTIME_H CTIME_CC CLOCALE_CC CLOCALE_INTERNAL_H ALLOCATOR_H ALLOCATOR_NAME C_INCLUDE_DIR GLIBCXX_C_HEADERS_C_TRUE GLIBCXX_C_HEADERS_C_FALSE GLIBCXX_C_HEADERS_C_STD_TRUE GLIBCXX_C_HEADERS_C_STD_FALSE GLIBCXX_C_HEADERS_C_GLOBAL_TRUE GLIBCXX_C_HEADERS_C_GLOBAL_FALSE GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE GLIBCXX_C_HEADERS_EXTRA_TRUE GLIBCXX_C_HEADERS_EXTRA_FALSE DEBUG_FLAGS GLIBCXX_BUILD_DEBUG_TRUE GLIBCXX_BUILD_DEBUG_FALSE EXTRA_CXX_FLAGS glibcxx_thread_h WERROR SECTION_FLAGS SECTION_LDFLAGS OPT_LDFLAGS LIBMATHOBJS LIBICONV LTLIBICONV SYMVER_FILE port_specific_symbol_files ENABLE_SYMVERS_TRUE ENABLE_SYMVERS_FALSE ENABLE_SYMVERS_GNU_TRUE ENABLE_SYMVERS_GNU_FALSE ENABLE_SYMVERS_GNU_NAMESPACE_TRUE ENABLE_SYMVERS_GNU_NAMESPACE_FALSE ENABLE_SYMVERS_DARWIN_TRUE ENABLE_SYMVERS_DARWIN_FALSE ENABLE_VISIBILITY_TRUE ENABLE_VISIBILITY_FALSE GLIBCXX_LDBL_COMPAT_TRUE GLIBCXX_LDBL_COMPAT_FALSE baseline_dir ATOMICITY_SRCDIR ATOMIC_WORD_SRCDIR CPU_DEFINES_SRCDIR ABI_TWEAKS_SRCDIR OS_INC_SRCDIR ERROR_CONSTANTS_SRCDIR glibcxx_prefixdir gxx_include_dir glibcxx_toolexecdir glibcxx_toolexeclibdir GLIBCXX_INCLUDES TOPLEVEL_INCLUDES OPTIMIZE_CXXFLAGS WARN_FLAGS LIBSUPCXX_PICFLAGS LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libtool_VERSION multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar glibcxx_builddir glibcxx_srcdir toplevel_srcdir CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LN_S AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM lt_ECHO LDFLAGS CXXCPP enable_shared enable_static GLIBCXX_HOSTED_TRUE GLIBCXX_HOSTED_FALSE GLIBCXX_BUILD_PCH_TRUE GLIBCXX_BUILD_PCH_FALSE glibcxx_PCHFLAGS CSTDIO_H BASIC_FILE_H BASIC_FILE_CC check_msgfmt glibcxx_MOFILES glibcxx_POFILES glibcxx_localedir USE_NLS CLOCALE_H CMESSAGES_H CCODECVT_CC CCOLLATE_CC CCTYPE_CC CMESSAGES_CC CMONEY_CC CNUMERIC_CC CTIME_H CTIME_CC CLOCALE_CC CLOCALE_INTERNAL_H ALLOCATOR_H ALLOCATOR_NAME C_INCLUDE_DIR GLIBCXX_C_HEADERS_C_TRUE GLIBCXX_C_HEADERS_C_FALSE GLIBCXX_C_HEADERS_C_STD_TRUE GLIBCXX_C_HEADERS_C_STD_FALSE GLIBCXX_C_HEADERS_C_GLOBAL_TRUE GLIBCXX_C_HEADERS_C_GLOBAL_FALSE GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE GLIBCXX_C_HEADERS_EXTRA_TRUE GLIBCXX_C_HEADERS_EXTRA_FALSE DEBUG_FLAGS GLIBCXX_BUILD_DEBUG_TRUE GLIBCXX_BUILD_DEBUG_FALSE ENABLE_PARALLEL_TRUE ENABLE_PARALLEL_FALSE EXTRA_CXX_FLAGS glibcxx_thread_h WERROR SECTION_FLAGS SECTION_LDFLAGS OPT_LDFLAGS LIBMATHOBJS LIBICONV LTLIBICONV SYMVER_FILE port_specific_symbol_files ENABLE_SYMVERS_TRUE ENABLE_SYMVERS_FALSE ENABLE_SYMVERS_GNU_TRUE ENABLE_SYMVERS_GNU_FALSE ENABLE_SYMVERS_GNU_NAMESPACE_TRUE ENABLE_SYMVERS_GNU_NAMESPACE_FALSE ENABLE_SYMVERS_DARWIN_TRUE ENABLE_SYMVERS_DARWIN_FALSE ENABLE_VISIBILITY_TRUE ENABLE_VISIBILITY_FALSE GLIBCXX_LDBL_COMPAT_TRUE GLIBCXX_LDBL_COMPAT_FALSE baseline_dir ATOMICITY_SRCDIR ATOMIC_WORD_SRCDIR ATOMIC_FLAGS CPU_DEFINES_SRCDIR ABI_TWEAKS_SRCDIR OS_INC_SRCDIR ERROR_CONSTANTS_SRCDIR glibcxx_prefixdir gxx_include_dir glibcxx_toolexecdir glibcxx_toolexeclibdir GLIBCXX_INCLUDES TOPLEVEL_INCLUDES OPTIMIZE_CXXFLAGS WARN_FLAGS LIBSUPCXX_PICFLAGS LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -13949,7 +13949,7 @@ echo \"${ECHO_T}$enable_libstdcxx_pch\" >&6\n \n \n   if test $enable_libstdcxx_pch = yes; then\n-    glibcxx_PCHFLAGS=\"-include bits/stdtr1c++.h\"\n+    glibcxx_PCHFLAGS=\"-include bits/stdc++.h\"\n   else\n     glibcxx_PCHFLAGS=\"\"\n   fi\n@@ -16468,6 +16468,19 @@ fi;\n echo \"${ECHO_T}$enable_libstdcxx_debug\" >&6\n \n \n+\n+\n+  enable_parallel=no;\n+  if test -f \"${glibcxx_builddir}/../libgomp/omp.h\"; then\n+    enable_parallel=yes;\n+  fi\n+\n+  echo \"$as_me:$LINENO: checking for parallel mode support\" >&5\n+echo $ECHO_N \"checking for parallel mode support... $ECHO_C\" >&6\n+  echo \"$as_me:$LINENO: result: $enable_parallel\" >&5\n+echo \"${ECHO_T}$enable_parallel\" >&6\n+\n+\n   echo \"$as_me:$LINENO: checking for extra compiler flags for building\" >&5\n echo $ECHO_N \"checking for extra compiler flags for building... $ECHO_C\" >&6\n    # Check whether --enable-cxx-flags or --disable-cxx-flags was given.\n@@ -17279,7 +17292,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n \n   # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n-#line 17282 \"configure\"\n+#line 17295 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n@@ -93897,6 +93910,7 @@ done\n # Propagate the target-specific source directories through the build chain.\n ATOMICITY_SRCDIR=config/${atomicity_dir}\n ATOMIC_WORD_SRCDIR=config/${atomic_word_dir}\n+ATOMIC_FLAGS=${atomic_flags}\n CPU_DEFINES_SRCDIR=config/${cpu_defines_dir}\n OS_INC_SRCDIR=config/${os_include_dir}\n ERROR_CONSTANTS_SRCDIR=config/${error_constants_dir}\n@@ -93909,6 +93923,7 @@ ABI_TWEAKS_SRCDIR=config/${abi_tweaks_dir}\n \n \n \n+\n # Determine cross-compile flags and AM_CONDITIONALs.\n #AC_SUBST(GLIBCXX_IS_NATIVE)\n #AM_CONDITIONAL(CANADIAN, test $CANADIAN = yes)\n@@ -94004,6 +94019,17 @@ fi\n \n \n \n+if test $enable_parallel = yes; then\n+  ENABLE_PARALLEL_TRUE=\n+  ENABLE_PARALLEL_FALSE='#'\n+else\n+  ENABLE_PARALLEL_TRUE='#'\n+  ENABLE_PARALLEL_FALSE=\n+fi\n+\n+\n+\n+\n if test $enable_symvers != no; then\n   ENABLE_SYMVERS_TRUE=\n   ENABLE_SYMVERS_FALSE='#'\n@@ -94429,6 +94455,13 @@ echo \"$as_me: error: conditional \\\"GLIBCXX_BUILD_DEBUG\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&2;}\n    { (exit 1); exit 1; }; }\n fi\n+if test -z \"${ENABLE_PARALLEL_TRUE}\" && test -z \"${ENABLE_PARALLEL_FALSE}\"; then\n+  { { echo \"$as_me:$LINENO: error: conditional \\\"ENABLE_PARALLEL\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&5\n+echo \"$as_me: error: conditional \\\"ENABLE_PARALLEL\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n if test -z \"${ENABLE_SYMVERS_TRUE}\" && test -z \"${ENABLE_SYMVERS_FALSE}\"; then\n   { { echo \"$as_me:$LINENO: error: conditional \\\"ENABLE_SYMVERS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&5\n@@ -95474,6 +95507,8 @@ s,@GLIBCXX_C_HEADERS_EXTRA_FALSE@,$GLIBCXX_C_HEADERS_EXTRA_FALSE,;t t\n s,@DEBUG_FLAGS@,$DEBUG_FLAGS,;t t\n s,@GLIBCXX_BUILD_DEBUG_TRUE@,$GLIBCXX_BUILD_DEBUG_TRUE,;t t\n s,@GLIBCXX_BUILD_DEBUG_FALSE@,$GLIBCXX_BUILD_DEBUG_FALSE,;t t\n+s,@ENABLE_PARALLEL_TRUE@,$ENABLE_PARALLEL_TRUE,;t t\n+s,@ENABLE_PARALLEL_FALSE@,$ENABLE_PARALLEL_FALSE,;t t\n s,@EXTRA_CXX_FLAGS@,$EXTRA_CXX_FLAGS,;t t\n s,@glibcxx_thread_h@,$glibcxx_thread_h,;t t\n s,@WERROR@,$WERROR,;t t\n@@ -95500,6 +95535,7 @@ s,@GLIBCXX_LDBL_COMPAT_FALSE@,$GLIBCXX_LDBL_COMPAT_FALSE,;t t\n s,@baseline_dir@,$baseline_dir,;t t\n s,@ATOMICITY_SRCDIR@,$ATOMICITY_SRCDIR,;t t\n s,@ATOMIC_WORD_SRCDIR@,$ATOMIC_WORD_SRCDIR,;t t\n+s,@ATOMIC_FLAGS@,$ATOMIC_FLAGS,;t t\n s,@CPU_DEFINES_SRCDIR@,$CPU_DEFINES_SRCDIR,;t t\n s,@ABI_TWEAKS_SRCDIR@,$ABI_TWEAKS_SRCDIR,;t t\n s,@OS_INC_SRCDIR@,$OS_INC_SRCDIR,;t t"}, {"sha": "72471f15795967eb7692ca24a4e65bb401002755", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -107,6 +107,7 @@ GLIBCXX_ENABLE_C99([yes])\n GLIBCXX_ENABLE_CONCEPT_CHECKS([no])\n GLIBCXX_ENABLE_DEBUG_FLAGS([\"-g3 -O0\"])\n GLIBCXX_ENABLE_DEBUG([no])\n+GLIBCXX_ENABLE_PARALLEL\n GLIBCXX_ENABLE_CXX_FLAGS\n GLIBCXX_ENABLE_FULLY_DYNAMIC_STRING([no])\n \n@@ -327,12 +328,14 @@ GLIBCXX_CONFIGURE_TESTSUITE\n # Propagate the target-specific source directories through the build chain.\n ATOMICITY_SRCDIR=config/${atomicity_dir}\n ATOMIC_WORD_SRCDIR=config/${atomic_word_dir}\n+ATOMIC_FLAGS=${atomic_flags}\n CPU_DEFINES_SRCDIR=config/${cpu_defines_dir}\n OS_INC_SRCDIR=config/${os_include_dir}\n ERROR_CONSTANTS_SRCDIR=config/${error_constants_dir}\n ABI_TWEAKS_SRCDIR=config/${abi_tweaks_dir}\n AC_SUBST(ATOMICITY_SRCDIR)\n AC_SUBST(ATOMIC_WORD_SRCDIR)\n+AC_SUBST(ATOMIC_FLAGS)\n AC_SUBST(CPU_DEFINES_SRCDIR)\n AC_SUBST(ABI_TWEAKS_SRCDIR)\n AC_SUBST(OS_INC_SRCDIR)"}, {"sha": "4031b4e1e257c4fb9690827986e2610ba1685fc4", "filename": "libstdc++-v3/configure.host", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.host?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -39,6 +39,9 @@\n #   atomic_word_dir        location of atomic_word.h\n #                          defaults to generic.\n #\n+#   atomic_flags           extra flags to pass to use atomic instructions\n+#                          defaults to nothing.\n+#\n #   cpu_defines_dir        location of cpu_defines.h\n #                          defaults to generic.\n #\n@@ -71,6 +74,7 @@\n c_model=c_global\n c_compatibility=no\n atomic_word_dir=cpu/generic\n+atomic_flags=\"\"\n atomicity_dir=\"cpu/generic\"\n cpu_defines_dir=\"cpu/generic\"\n try_cpu=generic\n@@ -130,7 +134,8 @@ case \"${host_cpu}\" in\n esac\n \n \n-# Set specific CPU overrides for atomic_word_dir. Most can just use generic.\n+# Set specific CPU overrides for atomic_word_dir and atomic_flags. \n+# Most can just use generic.\n # THIS TABLE IS SORTED.  KEEP IT THAT WAY.\n case \"${host_cpu}\" in\n   alpha*)\n@@ -142,11 +147,15 @@ case \"${host_cpu}\" in\n   ia64)\n     atomic_word_dir=cpu/ia64\n     ;;\n+  i[567]86 | x86_64)\n+    atomic_flags=\"-march=native\"\n+    ;;\n   powerpc* | rs6000)\n     atomic_word_dir=cpu/powerpc\n     ;;\n   sparc* | ultrasparc)\n     atomic_word_dir=cpu/sparc\n+    atomic_flags=\"-mcpu=v9\"\n     ;;\n esac\n "}, {"sha": "68d142fdbfbcf5d3ec8c3026fada7d454ebfc5f0", "filename": "libstdc++-v3/docs/doxygen/doxygroups.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fdoxygroups.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -45,7 +45,7 @@\n  *  export. Used only when anonymous namespaces cannot be substituted.\n */\n /** @namespace __gnu_debug\n- *  @brief GNU debug mode classes for public use.\n+ *  @brief GNU debug classes for public use.\n */\n // // // // // // // // // // // // // // // // // // // // // // // //\n /** @addtogroup SGIextensions STL extensions from SGI"}, {"sha": "ab22db0635e81c7d5d5828a6003c0d07379c68d6", "filename": "libstdc++-v3/docs/doxygen/user.cfg.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -478,6 +478,7 @@ INPUT                  = @srcdir@/docs/doxygen/doxygroups.cc \\\n                          include/@host_alias@/bits \\\n                          include/bits \\\n                          include/debug \\\n+                         include/parallel \\\n                          include/ext \\\n                          include/tr1 \\\n                          include/tr1_impl \\\n@@ -562,6 +563,8 @@ INPUT                  = @srcdir@/docs/doxygen/doxygroups.cc \\\n                          include/ext/slist \\\n                          include/ext/pb_ds \\\n                          include/ext/pb_ds/detail \\\n+                         include/parallel/algorithm \\\n+                         include/parallel/numeric \\\n                          include/tr1/array \\\n                          include/tr1/ccomplex \\\n                          include/tr1/cctype \\"}, {"sha": "2881caff57dd7fa78a814564b6dd25d507d58823", "filename": "libstdc++-v3/docs/html/documentation.html", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -222,13 +222,15 @@ <h2><a name=\"3\">Chapter-Specific Documentation</a></h2>\n    </ul>\n    </li>\n \n-   <li>Extensions to the Standard Library\n+   <li>Extensions\n    <ul>\n+     <li><a href=\"ext/howto.html#4\">Compile-time checks</a></li>\n+     <li><a href=\"debug_mode.html\">Debug mode</a></li>\n+     <li><a href=\"parallel_mode.html\">Parallel mode</a></li>\n      <li><a href=\"ext/pb_ds/index.html\">Policy Based Data Structures</a></li>\n      <li><a href=\"ext/howto.html#1\">Ropes and trees and hashes, oh my!</a></li>\n      <li><a href=\"ext/howto.html#2\">Added members and types</a></li>\n      <li><a href=\"ext/mt_allocator.html\"><code>__mt_alloc</code> </a></li>\n-     <li><a href=\"ext/howto.html#4\">Compile-time checks</a></li>\n      <li><a href=\"ext/howto.html#5\">LWG Issues</a></li>\n      <li><a href=\"ext/../18_support/howto.html#6\">Demangling</a></li>\n    </ul>"}, {"sha": "74db8ca3771e5cefc5d91027ca08b9fb424d56a6", "filename": "libstdc++-v3/docs/html/parallel_mode.html", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fparallel_mode.html?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,457 @@\n+<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n+<!DOCTYPE html\n+          PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n+\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n+<head>\n+   <meta name=\"AUTHOR\" content=\"bkoz@gcc.gnu.org (Benjamin Kosnik)\" />\n+   <meta name=\"KEYWORDS\" content=\"c++, libstdc++, gdb, g++, debug\" />\n+   <meta name=\"DESCRIPTION\" content=\"The libstdc++ parallel mode.\" />\n+   <meta name=\"GENERATOR\" content=\"emacs and ten fingers\" />\n+   <title>The libstdc++ parallel mode</title>\n+<link rel=\"StyleSheet\" href=\"lib3styles.css\" type=\"text/css\" />\n+<link rel=\"Copyright\" href=\"17_intro/license.html\" type=\"text/html\" />\n+</head>\n+<body>\n+\n+<h1 class=\"centered\"><a name=\"top\">The libstdc++ parallel mode</a></h1>\n+\n+<p class=\"fineprint\"><em>\n+   The latest version of this document is always available at\n+   <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/parallel_mode.html\">\n+   http://gcc.gnu.org/onlinedocs/libstdc++/parallel_mode.html</a>.\n+</em></p>\n+\n+<p><em>\n+   To the <a href=\"http://gcc.gnu.org/libstdc++/\">libstdc++-v3 homepage</a>.\n+</em></p>\n+\n+<!-- ####################################################### -->\n+<hr />\n+<p> The libstdc++ parallel mode is an experimental parallel\n+implementation of many algorithms the C++ Standard Library.\n+</p>\n+\n+<p>\n+Several of the standard algorithms, for instance\n+<code>std::search</code>, are made parallel using OpenMP\n+annotations. These parallel mode constructs and can be invoked by\n+explicit source declaration or by compiling existing sources with a\n+specific compiler flag.\n+</p>\n+\n+<h3 class=\"left\"><a name=\"parallel\">The libstdc++ parallel mode</a></h3>\n+\n+<p>The libstdc++ parallel mode performs parallization of algorithms,\n+function objects, classes, and functions in the C++ Standard.</p>\n+\n+<h4 class=\"left\">Using the libstdc++ parallel mode</h4>\n+\n+<p>To use the libstdc++ parallel mode, compile your application with\n+  the compiler flag <code>-D_GLIBCXX_PARALLEL -fopenmp</code>. This\n+  will link in <code>libgomp</code>, the GNU OpenMP <a\n+  href=\"http://gcc.gnu.org/onlinedocs/libgomp\">implementation</a>,\n+  whose presence is mandatory. In addition, hardware capable of atomic\n+  operations is de rigueur. Actually activating these atomic\n+  operations may require explicit compiler flags on some targets\n+  (like sparc and x86), such as <code>-march=i686</code>,\n+  <code>-march=native</code> or <code>-mcpu=v9</code>.\n+</p>\n+\n+<p>Note that the <code>_GLIBCXX_PARALLEL</code> define may change the\n+  sizes and behavior of standard class templates such as\n+  <code>std::search</code>, and therefore one can only link code\n+  compiled with parallel mode and code compiled without parallel mode\n+  if no instantiation of a container is passed between the two\n+  translation units. Parallel mode functionality has distinct linkage,\n+  and cannot be confused with normal mode symbols.</p>\n+\n+\n+<p>The following library components in the include\n+<code>&lt;numeric&gt;</code> are included in the parallel mode:</p>\n+<ul>\n+  <li><code>std::accumulate</code></li>\n+  <li><code>std::adjacent_difference</code></li>\n+  <li><code>std::inner_product</code></li>\n+  <li><code>std::partial_sum</code></li>\n+</ul>\n+\n+<p>The following library components in the include\n+<code>&lt;algorithm&gt;</code> are included in the parallel mode:</p>\n+<ul>\n+  <li><code>std::adjacent_find</code></li>\n+  <li><code>std::count</code></li>\n+  <li><code>std::count_if</code></li>\n+  <li><code>std::equal</code></li>\n+  <li><code>std::find</code></li>\n+  <li><code>std::find_if</code></li>\n+  <li><code>std::find_first_of</code></li>\n+  <li><code>std::for_each</code></li>\n+  <li><code>std::generate</code></li>\n+  <li><code>std::generate_n</code></li>\n+  <li><code>std::lexicographical_compare</code></li>\n+  <li><code>std::mismatch</code></li>\n+  <li><code>std::search</code></li>\n+  <li><code>std::search_n</code></li>\n+  <li><code>std::transform</code></li>\n+  <li><code>std::replace</code></li>\n+  <li><code>std::replace_if</code></li>\n+  <li><code>std::max_element</code></li>\n+  <li><code>std::merge</code></li>\n+  <li><code>std::min_element</code></li>\n+  <li><code>std::nth_element</code></li>\n+  <li><code>std::partial_sort</code></li>\n+  <li><code>std::partition</code></li>\n+  <li><code>std::random_shuffle</code></li>\n+  <li><code>std::set_union</code></li>\n+  <li><code>std::set_intersection</code></li>\n+  <li><code>std::set_symmetric_difference</code></li>\n+  <li><code>std::set_difference</code></li>\n+  <li><code>std::sort</code></li>\n+  <li><code>std::stable_sort</code></li>\n+  <li><code>std::unique_copy</code></li>\n+</ul>\n+\n+\n+<h4 class=\"left\">Using the parallel algorithms without parallel mode</h4>\n+\n+<p>When it is not feasible to recompile your entire application, or\n+  only specific algorithms need to be parallel-aware, individual\n+  parallel algorithms can be made available explicitly. These\n+  parallel algorithms are functionally equivalent to the standard\n+  drop-in algorithms used in parallel mode, but they are available in\n+  a separate namespace as GNU extensions and may be used in programs\n+  compiled with either release mode or with parallel mode. The\n+  following table provides the names and headers of the parallel\n+  algorithms:\n+</p>\n+\n+\n+<table title=\"Parallel algorithms\" border=\"1\">\n+  <tr>\n+    <th>Algorithm</th>\n+    <th>Header</th>\n+    <th>Parallel algorithm</th>\n+    <th>Parallel header</th>\n+  </tr>\n+  <tr>\n+    <td>std::accumulate</td>\n+    <td>&lt;numeric&gt;</td>\n+    <td>__gnu_parallel::accumulate</td>\n+    <td>&lt;parallel/numeric&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::adjacent_difference</td>\n+    <td>&lt;numeric&gt;</td>\n+    <td>__gnu_parallel::adjacent_difference</td>\n+    <td>&lt;parallel/numeric&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::inner_product</td>\n+    <td>&lt;numeric&gt;</td>\n+    <td>__gnu_parallel::inner_product</td>\n+    <td>&lt;parallel/numeric&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::partial_sum</td>\n+    <td>&lt;numeric&gt;</td>\n+    <td>__gnu_parallel::partial_sum</td>\n+    <td>&lt;parallel/numeric&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::adjacent_find</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::adjacent_find</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::count</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::count</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::count_if</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::count_if</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::equal</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::equal</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::find</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::find</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::find_if</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::find_if</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::find_first_of</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::find_first_of</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::for_each</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::for_each</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::generate</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::generate</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::generate_n</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::generate_n</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::lexicographical_compare</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::lexicographical_compare</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::mismatch</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::mismatch</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::search</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::search</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::search_n</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::search_n</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::transform</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::transform</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::replace</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::replace</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::replace_if</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::replace_if</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::max_element</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::max_element</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::merge</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::merge</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::min_element</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::min_element</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::nth_element</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::nth_element</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::partial_sort</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::partial_sort</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::partition</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::partition</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::random_shuffle</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::random_shuffle</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::set_union</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::set_union</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::set_intersection</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::set_intersection</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::set_symmetric_difference</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::set_symmetric_difference</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::set_difference</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::set_difference</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::sort</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::sort</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::stable_sort</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::stable_sort</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+  <tr>\n+    <td>std::unique_copy</td>\n+    <td>&lt;algorithm&gt;</td>\n+    <td>__gnu_parallel::unique_copy</td>\n+    <td>&lt;parallel/algorithm&gt;</td>\n+  </tr>\n+\n+</table>\n+\n+\n+<h4 class=\"left\">Parallel mode semantics</h4>\n+<p> Something about exception safety, interaction with threads,\n+etc. Goal is to have the usual constraints of the STL with respect to\n+exception safety and threads, but add in support for parallel\n+computing.</p>\n+\n+<p> Something about compile-time settings and configuration, ie using\n+<code>__gnu_parallel::Settings</code>. XXX Up in the air.</p>\n+\n+<h4 class=\"left\">Interface basics and relevant namespaces</h4>\n+\n+<p> Two namespaces contain the parallel mode:\n+<code>std::__parallel</code> and <code>__gnu_parallel</code>. \n+</p>\n+\n+<p> One namespace contain versions of code that are explicitly sequential:\n+<code>__gnu_serial</code>.\n+</p>\n+\n+<p> Parallel implementations of the sequential standard components are\n+defined in <code>namespace std::__parallel</code>. For instance,\n+<code>std::transform</code> from &lt;algorithm&gt; has a parallel\n+counterpart in <code>std::__parallel::transform</code> from\n+&lt;parallel/algorithm&gt;. In addition, these parallel\n+implementatations are injected into <code>namespace\n+__gnu_parallel</code> with using declarations. \n+</p>\n+\n+<p> Support and infrastructure is in <code>namespace __gnu_parallel</code>.\n+</p>\n+\n+<p> More information, and an organized index of types and functions\n+related to the parallel mode on a per-namespace basis, can be found in\n+the generated source documentation.\n+</p>\n+\n+<h4 class=\"left\">Testing</h4>\n+\n+<p> Both the normal conformance and regression tests and the\n+supplemental performance tests work.</p>\n+\n+<p> To run the conformance and regression tests with the parallel mode\n+active,</p>\n+<code>make check-parallel</code>\n+\n+<p>The log and summary files for conformance testing are in the\n+<code>testsuite/parallel</code> directory.</p>\n+\n+<p> To run the performance tests  with the parallel mode active, </p>\n+<code>make check-performance-parallel</code>\n+\n+<p>The result file for performance testing are in the\n+<code>testsuite</code> directory, in the file\n+<code>libstdc++_performance.sum</code>. In addition, the policy-based\n+containers have their own visualizations, which have additional\n+software dependencies than the usual bare-boned text file, and can be\n+generated by using the <code>make doc-performance</code> rule in the\n+testsuite's Makefile.</p>\n+\n+<p>Return <a href=\"#top\">to the top of the page</a> or\n+   <a href=\"http://gcc.gnu.org/libstdc++/\">to the libstdc++ homepage</a>.\n+</p>\n+\n+\n+<!-- ####################################################### -->\n+\n+<hr />\n+<p class=\"fineprint\"><em>\n+See <a href=\"17_intro/license.html\">license.html</a> for copying conditions.\n+Comments and suggestions are welcome, and may be sent to\n+<a href=\"mailto:libstdc++@gcc.gnu.org\">the libstdc++ mailing list</a>.\n+</em></p>\n+\n+\n+</body>\n+</html>"}, {"sha": "3dd11b480e7303cc311f5a4b2a806cd5e6c74d6d", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -70,6 +70,7 @@ std_headers = \\\n bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n+        ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n@@ -730,6 +731,58 @@ debug_headers = \\\n \t${debug_srcdir}/string \\\n \t${debug_srcdir}/vector\n \n+# Parallel mode headers\n+parallel_srcdir = ${glibcxx_srcdir}/include/parallel\n+parallel_builddir = ./parallel\n+parallel_headers = \\\n+        ${parallel_srcdir}/algorithm \\\n+        ${parallel_srcdir}/algobase.h \\\n+        ${parallel_srcdir}/algo.h \\\n+        ${parallel_srcdir}/algorithm \\\n+        ${parallel_srcdir}/algorithmfwd.h \\\n+        ${parallel_srcdir}/balanced_quicksort.h \\\n+        ${parallel_srcdir}/base.h \\\n+        ${parallel_srcdir}/basic_iterator.h \\\n+        ${parallel_srcdir}/checkers.h \\\n+        ${parallel_srcdir}/compatibility.h \\\n+        ${parallel_srcdir}/compiletime_settings.h \\\n+        ${parallel_srcdir}/equally_split.h \\\n+        ${parallel_srcdir}/features.h \\\n+        ${parallel_srcdir}/find.h \\\n+        ${parallel_srcdir}/find_selectors.h \\\n+        ${parallel_srcdir}/for_each.h \\\n+        ${parallel_srcdir}/for_each_selectors.h \\\n+        ${parallel_srcdir}/iterator.h \\\n+        ${parallel_srcdir}/list_partition.h \\\n+        ${parallel_srcdir}/losertree.h \\\n+        ${parallel_srcdir}/merge.h \\\n+        ${parallel_srcdir}/multiseq_selection.h \\\n+        ${parallel_srcdir}/multiway_merge.h \\\n+        ${parallel_srcdir}/multiway_mergesort.h \\\n+        ${parallel_srcdir}/numeric \\\n+        ${parallel_srcdir}/numericfwd.h \\\n+        ${parallel_srcdir}/omp_loop.h \\\n+        ${parallel_srcdir}/omp_loop_static.h \\\n+        ${parallel_srcdir}/parallel.h \\\n+        ${parallel_srcdir}/par_loop.h \\\n+        ${parallel_srcdir}/partial_sum.h \\\n+        ${parallel_srcdir}/partition.h \\\n+        ${parallel_srcdir}/queue.h \\\n+        ${parallel_srcdir}/quicksort.h \\\n+        ${parallel_srcdir}/random_number.h \\\n+        ${parallel_srcdir}/random_shuffle.h \\\n+        ${parallel_srcdir}/search.h \\\n+        ${parallel_srcdir}/set_operations.h \\\n+        ${parallel_srcdir}/settings.h \\\n+        ${parallel_srcdir}/sort.h \\\n+        ${parallel_srcdir}/tags.h \\\n+        ${parallel_srcdir}/timing.h \\\n+        ${parallel_srcdir}/tree.h \\\n+        ${parallel_srcdir}/types.h \\\n+        ${parallel_srcdir}/unique_copy.h \\\n+        ${parallel_srcdir}/workstealing.h \n+\n+\n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers.\n # For --enable-cheaders=c_std\n@@ -791,7 +844,8 @@ pch1_output_anchor = ${host_builddir}/stdc++.h\n pch1_output_installdir = ${host_installdir}/stdc++.h.gch\n pch1a_output = ${pch1_output_builddir}/O0g.gch\n pch1b_output = ${pch1_output_builddir}/O2g.gch\n-pch1_output = ${pch1a_output} ${pch1b_output}\n+pch1c_output = ${pch1_output_builddir}/O2gp.gch\n+pch1_output = ${pch1a_output} ${pch1b_output} ${pch1c_output}\n \n pch2_source = ${glibcxx_srcdir}/include/precompiled/stdtr1c++.h\n pch2_output_builddir = ${host_builddir}/stdtr1c++.h.gch\n@@ -823,7 +877,7 @@ endif\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -980,6 +1034,15 @@ stamp-debug: ${debug_headers}\n \tfi ;\\\n \t$(STAMP) stamp-debug\n \n+stamp-parallel: ${parallel_headers}\n+\t@if [ ! -d \"${parallel_builddir}\" ]; then \\\n+\t  mkdir -p ${parallel_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-parallel ]; then \\\n+\t  (cd ${parallel_builddir} && @LN_S@ $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-parallel\n+\n stamp-${host_alias}:\n \t@if [ ! -d ${host_builddir} ]; then \\\n \t  mkdir -p ${host_builddir} ;\\\n@@ -1091,7 +1154,7 @@ ${host_builddir}/gthr-default.h: ${toplevel_srcdir}/gcc/${glibcxx_thread_h} \\\n \t    -e 's,^#include \"\\(.*\\)\",#include <bits/\\1>,g' \\\n \t    < ${toplevel_srcdir}/gcc/${glibcxx_thread_h} > $@\n \n-# Build two precompiled C++ includes, stdc++.h.gch/*.gch\n+# Build three precompiled C++ includes, stdc++.h.gch/*.gch\n ${pch1a_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n \tif [ ! -d \"${pch1_output_builddir}\" ]; then \\\n \t  mkdir -p ${pch1_output_builddir}; \\\n@@ -1106,6 +1169,14 @@ ${pch1b_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n \t$(CXX) $(PCHFLAGS) $(AM_CPPFLAGS) -O2 -g ${pch1_source} -o $@\n \ttouch ${pch1_output_anchor}\n \n+${pch1c_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n+\tif [ ! -d \"${pch1_output_builddir}\" ]; then \\\n+\t  mkdir -p ${pch1_output_builddir}; \\\n+\tfi; \\\n+\tCXX_PARALLEL_FLAGS=\"-fgomp -march=native\";\n+\t$(CXX) $(PCHFLAGS) $(AM_CPPFLAGS) -O2 -g $(CXX_PARALLEL_FLAGS) ${pch1_source} -o $@\n+\ttouch ${pch1_output_anchor}\n+\n # Build a precompiled TR1 include, stdtr1c++.h.gch/O2.gch\n ${pch2_output}: ${pch2_source} ${pch1_output}\n \tif [ ! -d \"${pch2_output_builddir}\" ]; then \\\n@@ -1217,6 +1288,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${debug_builddir}\n \tfor file in ${debug_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${debug_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${parallel_builddir}\n+\tfor file in ${parallel_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${parallel_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "80a7c2409dde718496a74f2505867c4b238fe887", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -71,6 +71,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -108,6 +109,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@\n@@ -316,6 +319,7 @@ std_headers = \\\n bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n+        ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n@@ -965,6 +969,58 @@ debug_headers = \\\n \t${debug_srcdir}/string \\\n \t${debug_srcdir}/vector\n \n+\n+# Parallel mode headers\n+parallel_srcdir = ${glibcxx_srcdir}/include/parallel\n+parallel_builddir = ./parallel\n+parallel_headers = \\\n+        ${parallel_srcdir}/algorithm \\\n+        ${parallel_srcdir}/algobase.h \\\n+        ${parallel_srcdir}/algo.h \\\n+        ${parallel_srcdir}/algorithm \\\n+        ${parallel_srcdir}/algorithmfwd.h \\\n+        ${parallel_srcdir}/balanced_quicksort.h \\\n+        ${parallel_srcdir}/base.h \\\n+        ${parallel_srcdir}/basic_iterator.h \\\n+        ${parallel_srcdir}/checkers.h \\\n+        ${parallel_srcdir}/compatibility.h \\\n+        ${parallel_srcdir}/compiletime_settings.h \\\n+        ${parallel_srcdir}/equally_split.h \\\n+        ${parallel_srcdir}/features.h \\\n+        ${parallel_srcdir}/find.h \\\n+        ${parallel_srcdir}/find_selectors.h \\\n+        ${parallel_srcdir}/for_each.h \\\n+        ${parallel_srcdir}/for_each_selectors.h \\\n+        ${parallel_srcdir}/iterator.h \\\n+        ${parallel_srcdir}/list_partition.h \\\n+        ${parallel_srcdir}/losertree.h \\\n+        ${parallel_srcdir}/merge.h \\\n+        ${parallel_srcdir}/multiseq_selection.h \\\n+        ${parallel_srcdir}/multiway_merge.h \\\n+        ${parallel_srcdir}/multiway_mergesort.h \\\n+        ${parallel_srcdir}/numeric \\\n+        ${parallel_srcdir}/numericfwd.h \\\n+        ${parallel_srcdir}/omp_loop.h \\\n+        ${parallel_srcdir}/omp_loop_static.h \\\n+        ${parallel_srcdir}/parallel.h \\\n+        ${parallel_srcdir}/par_loop.h \\\n+        ${parallel_srcdir}/partial_sum.h \\\n+        ${parallel_srcdir}/partition.h \\\n+        ${parallel_srcdir}/queue.h \\\n+        ${parallel_srcdir}/quicksort.h \\\n+        ${parallel_srcdir}/random_number.h \\\n+        ${parallel_srcdir}/random_shuffle.h \\\n+        ${parallel_srcdir}/search.h \\\n+        ${parallel_srcdir}/set_operations.h \\\n+        ${parallel_srcdir}/settings.h \\\n+        ${parallel_srcdir}/sort.h \\\n+        ${parallel_srcdir}/tags.h \\\n+        ${parallel_srcdir}/timing.h \\\n+        ${parallel_srcdir}/tree.h \\\n+        ${parallel_srcdir}/types.h \\\n+        ${parallel_srcdir}/unique_copy.h \\\n+        ${parallel_srcdir}/workstealing.h \n+\n @GLIBCXX_C_HEADERS_EXTRA_FALSE@c_base_headers_extra = \n \n # Some of the different \"C\" header models need extra files.\n@@ -1020,7 +1076,8 @@ pch1_output_anchor = ${host_builddir}/stdc++.h\n pch1_output_installdir = ${host_installdir}/stdc++.h.gch\n pch1a_output = ${pch1_output_builddir}/O0g.gch\n pch1b_output = ${pch1_output_builddir}/O2g.gch\n-pch1_output = ${pch1a_output} ${pch1b_output}\n+pch1c_output = ${pch1_output_builddir}/O2gp.gch\n+pch1_output = ${pch1a_output} ${pch1b_output} ${pch1c_output}\n pch2_source = ${glibcxx_srcdir}/include/precompiled/stdtr1c++.h\n pch2_output_builddir = ${host_builddir}/stdtr1c++.h.gch\n pch2_output_anchor = ${host_builddir}/stdtr1c++.h\n@@ -1047,7 +1104,7 @@ PCHFLAGS = -Winvalid-pch -Wno-deprecated -x c++-header $(CXXFLAGS)\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_base_extra \\\n \tstamp-c_compatibility  stamp-backward stamp-ext stamp-pb \\\n-\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-host\n+\tstamp-tr1 stamp-tr1-impl stamp-debug stamp-parallel stamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -1374,6 +1431,15 @@ stamp-debug: ${debug_headers}\n \tfi ;\\\n \t$(STAMP) stamp-debug\n \n+stamp-parallel: ${parallel_headers}\n+\t@if [ ! -d \"${parallel_builddir}\" ]; then \\\n+\t  mkdir -p ${parallel_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-parallel ]; then \\\n+\t  (cd ${parallel_builddir} && @LN_S@ $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-parallel\n+\n stamp-${host_alias}:\n \t@if [ ! -d ${host_builddir} ]; then \\\n \t  mkdir -p ${host_builddir} ;\\\n@@ -1476,7 +1542,7 @@ ${host_builddir}/gthr-default.h: ${toplevel_srcdir}/gcc/${glibcxx_thread_h} \\\n \t    -e 's,^#include \"\\(.*\\)\",#include <bits/\\1>,g' \\\n \t    < ${toplevel_srcdir}/gcc/${glibcxx_thread_h} > $@\n \n-# Build two precompiled C++ includes, stdc++.h.gch/*.gch\n+# Build three precompiled C++ includes, stdc++.h.gch/*.gch\n ${pch1a_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n \tif [ ! -d \"${pch1_output_builddir}\" ]; then \\\n \t  mkdir -p ${pch1_output_builddir}; \\\n@@ -1491,6 +1557,14 @@ ${pch1b_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n \t$(CXX) $(PCHFLAGS) $(AM_CPPFLAGS) -O2 -g ${pch1_source} -o $@\n \ttouch ${pch1_output_anchor}\n \n+${pch1c_output}: ${allstamped} ${host_builddir}/c++config.h ${pch1_source}\n+\tif [ ! -d \"${pch1_output_builddir}\" ]; then \\\n+\t  mkdir -p ${pch1_output_builddir}; \\\n+\tfi; \\\n+\tCXX_PARALLEL_FLAGS=\"-fgomp -march=native\";\n+\t$(CXX) $(PCHFLAGS) $(AM_CPPFLAGS) -O2 -g $(CXX_PARALLEL_FLAGS) ${pch1_source} -o $@\n+\ttouch ${pch1_output_anchor}\n+\n # Build a precompiled TR1 include, stdtr1c++.h.gch/O2.gch\n ${pch2_output}: ${pch2_source} ${pch1_output}\n \tif [ ! -d \"${pch2_output_builddir}\" ]; then \\\n@@ -1599,6 +1673,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${debug_builddir}\n \tfor file in ${debug_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${debug_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${parallel_builddir}\n+\tfor file in ${parallel_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${parallel_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "1b2bf23ace6a665c822b2d23adffdb91581e0f64", "filename": "libstdc++-v3/include/bits/algorithmfwd.h", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falgorithmfwd.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,597 @@\n+// <algorithm> declarations  -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+/** @file bits/algorithmfwd.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+\n+/*\n+  adjacent_find\n+  binary_search\n+  copy\n+  copy_backward\n+  count\n+  count_if\n+  equal\n+  equal_range\n+  fill\n+  fill_n\n+  find\n+  find_end\n+  find_first_of\n+  find_if\n+  for_each\n+  generate\n+  generate_n\n+  includes\n+  inplace_merge\n+  iter_swap\n+  lexicographical_compare\n+  lower_bound\n+  make_heap\n+  max\n+  max_element\n+  merge\n+  min\n+  min_element\n+  mismatch\n+  next_permutation\n+  nth_element\n+  parital_sort\n+  partial_sort_copy\n+  partition\n+  pop_heap\n+  prev_permutation\n+  push_heap\n+  random_shuffle\n+  remove\n+  remove_copy\n+  remove_copy_if\n+  remove_if\n+  replace\n+  replace_copy\n+  replace_copy_if\n+  replace_if\n+  reverse\n+  reverse_copy\n+  rotate\n+  rotate_copy\n+  search\n+  search_n\n+  set_differernce\n+  set_intersection\n+  set_symmetric_difference\n+  set_union\n+  sort\n+  sort_heap\n+  stable_partition\n+  stable_sort\n+  stable_sort\n+  swap\n+  swap_ranges\n+  transform\n+  unique\n+  unique_copy\n+  upper_bound\n+*/\n+\n+#ifndef _GLIBCXX_ALGORITHMFWD_H\n+#define _GLIBCXX_ALGORITHMFWD_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <bits/stl_pair.h>\n+#include <bits/stl_iterator_base_types.h>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // adjacent_find\n+\n+  template<typename _FIter, typename _Tp>\n+    bool \n+    binary_search(_FIter, _FIter, const _Tp&);\n+\n+  template<typename _FIter, typename _Tp, typename _Compare>\n+    bool \n+    binary_search(_FIter, _FIter, const _Tp&, _Compare);\n+\n+  template<typename _IIter, typename _OIter>\n+    _OIter \n+    copy(_IIter, _IIter, _OIter);\n+\n+  template<typename _BIter1, typename _BIter2>\n+    _BIter2\n+    copy_backward (_BIter1, _BIter1, _BIter2);\n+\n+  // count\n+  // count_if\n+\n+  template<typename _FIter, typename _Tp>\n+    pair<_FIter, _FIter>\n+    equal_range(_FIter, _FIter, const _Tp&);\n+\n+  template<typename _FIter, typename _Tp, typename _Compare>\n+    pair<_FIter, _FIter>\n+    equal_range(_FIter, _FIter, const _Tp&, _Compare);\n+\n+  template<typename _FIter, typename _Tp>\n+    void \n+    fill(_FIter, _FIter, const _Tp&);\n+\n+/*\n+  XXX NB: return type different from ISO C++.\n+  template<typename _OIter, typename _Size, typename _Tp>\n+    void \n+    fill_n(_OIter, _Size, const _Tp&);\n+*/\n+\n+  template<typename _OIter, typename _Size, typename _Tp>\n+    _OIter\n+    fill_n(_OIter, _Size, const _Tp&);\n+\n+  // find\n+  // find_end\n+  // find_first_of\n+  // find_if\n+  // for_each\n+  // generate\n+  // generate_n\n+\n+  template<typename _IIter1, typename _IIter2>\n+    bool \n+    includes(_IIter1, _IIter1, _IIter2, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Compare>\n+    bool \n+    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);\n+\n+  template<typename _BIter>\n+    void \n+    inplace_merge(_BIter, _BIter, _BIter);\n+\n+  template<typename _BIter, typename _Compare>\n+    void \n+    inplace_merge(_BIter, _BIter, _BIter, _Compare);\n+\n+  template<typename _FIter1, typename _FIter2>\n+    void \n+    iter_swap(_FIter1, _FIter2);\n+\n+  // Specializations for char and unsigned char.\n+  inline bool\n+  lexicographical_compare(const unsigned char*, const unsigned char*, \n+\t\t\t  const unsigned char*, const unsigned char*);\n+\n+  inline bool\n+  lexicographical_compare(const char*, const char*, const char*, const char*);\n+\n+  template<typename _FIter, typename _Tp>\n+    _FIter \n+    lower_bound(_FIter, _FIter, const _Tp&);\n+\n+  template<typename _FIter, typename _Tp, typename _Compare>\n+    _FIter \n+    lower_bound(_FIter, _FIter, const _Tp&, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    make_heap(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    make_heap(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _Tp> \n+    const _Tp& \n+    max(const _Tp&, const _Tp&);\n+\n+  template<typename _Tp, typename _Compare>\n+    const _Tp& \n+    max(const _Tp&, const _Tp&, _Compare);\n+\n+  // max_element\n+  // merge\n+\n+  template<typename _Tp> \n+    const _Tp& \n+    min(const _Tp&, const _Tp&);\n+\n+  template<typename _Tp, typename _Compare>\n+    const _Tp& \n+    min(const _Tp&, const _Tp&, _Compare);\n+\n+  // min_element\n+  // mismatch\n+\n+  template<typename _BIter>\n+    bool \n+    next_permutation(_BIter, _BIter);\n+\n+  template<typename _BIter, typename _Compare>\n+    bool \n+    next_permutation(_BIter, _BIter, _Compare);\n+\n+  // nth_element\n+  // partial_sort\n+\n+  template<typename _IIter, typename _RAIter>\n+    _RAIter\n+    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);\n+\n+  template<typename _IIter, typename _RAIter, typename _Compare>\n+    _RAIter\n+    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    pop_heap(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    pop_heap(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _BIter>\n+    bool \n+    prev_permutation(_BIter, _BIter);\n+\n+  template<typename _BIter, typename _Compare>\n+    bool \n+    prev_permutation(_BIter, _BIter, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    push_heap(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    push_heap(_RAIter, _RAIter, _Compare);\n+\n+  // random_shuffle\n+\n+  template<typename _FIter, typename _Tp>\n+    _FIter \n+    remove(_FIter, _FIter, const _Tp&);\n+\n+  template<typename _FIter, typename _Predicate>\n+    _FIter \n+    remove_if(_FIter, _FIter, _Predicate);\n+\n+  template<typename _IIter, typename _OIter, typename _Tp>\n+    _OIter \n+    remove_copy(_IIter, _IIter, _OIter, const _Tp&);\n+\n+  template<typename _IIter, typename _OIter, typename _Predicate>\n+    _OIter \n+    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);\n+\n+  // replace\n+\n+  template<typename _IIter, typename _OIter, typename _Tp>\n+    _OIter \n+    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);\n+\n+  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>\n+    _OIter \n+    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);\n+\n+  // replace_if\n+\n+  template<typename _BIter>\n+    void \n+    reverse(_BIter, _BIter);\n+\n+  template<typename _BIter, typename _OIter>\n+    _OIter \n+    reverse_copy(_BIter, _BIter, _OIter);\n+\n+  template<typename _FIter>\n+    void \n+    rotate(_FIter, _FIter, _FIter);\n+\n+  template<typename _FIter, typename _OIter>\n+    _OIter \n+    rotate_copy (_FIter, _FIter, _FIter, _OIter);\n+\n+  // search\n+  // search_n\n+  // set_difference\n+  // set_intersection\n+  // set_symmetric_difference\n+  // set_union\n+\n+  template<typename _RAIter>\n+    void \n+    sort_heap(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    sort_heap(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _BIter, typename _Predicate>\n+    _BIter \n+    stable_partition(_BIter, _BIter, _Predicate);\n+\n+  template<typename _Tp> \n+    void \n+    swap(_Tp&, _Tp& b);\n+\n+  template<typename _FIter1, typename _FIter2>\n+    _FIter2 \n+    swap_ranges(_FIter1 first1, _FIter1, _FIter2);\n+\n+  // transform\n+\n+  template<typename _FIter>\n+    _FIter \n+    unique(_FIter, _FIter);\n+\n+  template<typename _FIter, typename _BinaryPredicate>\n+    _FIter \n+    unique(_FIter, _FIter, _BinaryPredicate);\n+\n+  // unique_copy\n+\n+  template<typename _FIter, typename _Tp>\n+    _FIter \n+    upper_bound(_FIter, _FIter, const _Tp&);\n+\n+  template<typename _FIter, typename _Tp, typename _Compare>\n+    _FIter \n+    upper_bound(_FIter, _FIter, const _Tp&, _Compare);\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_P)\n+\n+  template<typename _FIter>\n+    _FIter \n+    adjacent_find(_FIter, _FIter);\n+\n+  template<typename _FIter, typename _BinaryPredicate>\n+    _FIter \n+    adjacent_find(_FIter, _FIter, _BinaryPredicate);\n+\n+  template<typename _IIter, typename _Tp>\n+    typename iterator_traits<_IIter>::difference_type\n+    count(_IIter, _IIter, const _Tp&);\n+\n+  template<typename _IIter, typename _Predicate>\n+    typename iterator_traits<_IIter>::difference_type\n+    count_if(_IIter, _IIter, _Predicate);\n+\n+  template<typename _IIter1, typename _IIter2>\n+    bool \n+    equal(_IIter1, _IIter1, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n+    bool \n+    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);\n+\n+  template<typename _IIter, typename _Tp>\n+    _IIter \n+    find(_IIter, _IIter, const _Tp&);\n+\n+  template<typename _FIter1, typename _FIter2>\n+    _FIter1\n+    find_end(_FIter1, _FIter1, _FIter2, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n+    _FIter1\n+    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n+\n+  template<typename _FIter1, typename _FIter2>\n+    _FIter1\n+    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n+    _FIter1\n+    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n+\n+  template<typename _IIter, typename _Predicate>\n+    _IIter \n+    find_if(_IIter, _IIter, _Predicate);\n+\n+  template<typename _IIter, typename _Funct>\n+    _Funct \n+    for_each(_IIter, _IIter, _Funct);\n+\n+  template<typename _FIter, typename _Generator>\n+    void \n+    generate(_FIter, _FIter, _Generator);\n+\n+  template<typename _OIter, typename _Size, typename _Generator>\n+    void \n+    generate_n(_OIter, _Size, _Generator);\n+\n+  template<typename _IIter1, typename _IIter2>\n+    bool \n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Compare>\n+    bool \n+    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);\n+\n+  template<typename _FIter>\n+    _FIter \n+    max_element(_FIter, _FIter);\n+\n+  template<typename _FIter, typename _Compare>\n+    _FIter \n+    max_element(_FIter, _FIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+    _OIter \n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, \n+\t   typename _Compare>\n+    _OIter \n+    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+\n+  template<typename _FIter>\n+    _FIter \n+    min_element(_FIter, _FIter);\n+\n+  template<typename _FIter, typename _Compare>\n+    _FIter \n+    min_element(_FIter, _FIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2>\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n+    pair<_IIter1, _IIter2>\n+    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);\n+\n+  template<typename _RAIter>\n+    void \n+    nth_element(_RAIter, _RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    partial_sort(_RAIter, _RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n+\n+  template<typename _BIter, typename _Predicate>\n+    _BIter \n+    partition(_BIter, _BIter, _Predicate);\n+\n+  template<typename _RAIter>\n+    void \n+    random_shuffle(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Generator>\n+    void \n+    random_shuffle(_RAIter, _RAIter, _Generator&);\n+\n+  template<typename _FIter, typename _Tp>\n+    void \n+    replace(_FIter, _FIter, const _Tp&, const _Tp&);\n+\n+  template<typename _FIter, typename _Predicate, typename _Tp>\n+    void \n+    replace_if(_FIter, _FIter, _Predicate, const _Tp&);\n+\n+  template<typename _FIter1, typename _FIter2>\n+    _FIter1 \n+    search(_FIter1, _FIter1, _FIter2, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>\n+    _FIter1 \n+    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);\n+\n+  template<typename _FIter, typename _Size, typename _Tp>\n+    _FIter \n+    search_n(_FIter, _FIter, _Size, const _Tp&);\n+\n+  template<typename _FIter, typename _Size, typename _Tp, \n+\t   typename _BinaryPredicate>\n+    _FIter \n+    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+    _OIter \n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, \n+\t   typename _Compare>\n+    _OIter \n+    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+    _OIter \n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare>\n+    _OIter \n+    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+    _OIter\n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, \n+\t   typename _Compare>\n+    _OIter\n+    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, \n+\t\t\t     _OIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+    _OIter \n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter,\n+\t   typename _Compare>\n+    _OIter \n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    sort(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    sort(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+    void \n+    stable_sort(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    stable_sort(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _IIter, typename _OIter, typename _UnaryOperation>\n+    _OIter \n+    transform(_IIter, _IIter, _OIter, _UnaryOperation);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, \n+\t   typename _BinaryOperation>\n+    _OIter \n+    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);\n+\n+  template<typename _IIter, typename _OIter>\n+    _OIter \n+    unique_copy(_IIter, _IIter, _OIter);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryPredicate>\n+    _OIter \n+    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);\n+\n+_GLIBCXX_END_NESTED_NAMESPACE\n+\n+#ifdef _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL\n+# include <parallel/algorithmfwd.h>\n+#endif\n+\n+#endif\n+"}, {"sha": "262834560d1179e8e35bfa5344cfe6674a620a77", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 168, "deletions": 59, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -45,16 +45,7 @@\n // The current version of the C++ library in compressed ISO date format.\n #define __GLIBCXX__ \n \n-// Macro used to indicate that the native \"C\" includes, when compiled\n-// as \"C++\", have declarations in namespace std and not the global\n-// namespace. Note, this is unrelated to possible \"C\" compatibility\n-// includes that inject C90/C99 names into the global namespace.\n-// XXX May not be necessary\n-#if __cplusplus == 199711L\n-# define _GLIBCXX_NAMESPACE_GLOBAL_INJECTION 1\n-#endif\n-\n-// Macros for visibility.\n+// Macros for visibility support.\n #define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY\n \n #if _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY\n@@ -63,36 +54,178 @@\n # define _GLIBCXX_VISIBILITY(V) \n #endif\n \n-// Macros for controlling various namespace association schemes and modes.\n+// Guide to libstdc++ namespaces.\n+/*\n+  namespace std\n+  {\n+    namespace __debug { }\n+    namespace __parallel { }\n+    namespace __norm { } // __normative, __shadow, __replaced\n+    namespace __cxx1998 { }\n+\n+    namespace tr1 { }\n+  }\n+\n+  namespace __gnu_cxx\n+  {\n+    namespace __debug { }\n+    namespace __norm { }\n+  }\n+*/\n+\n+// Macros for activating various namespace association modes.\n // _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n-// _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION \n-// _GLIBCXX_NAMESPACE_ASSOCIATION_CXX200x\n+// _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL\n+// _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n+\n #ifdef _GLIBCXX_DEBUG\n # define _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG 1\n #endif\n \n+#ifdef _GLIBCXX_PARALLEL\n+# define _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL 1\n+#endif\n+\n #define _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION \n \n-// Macros for namespace scope.\n+// Defined if any namespace association modes are active.\n+#if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \\\n+  || _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL \\\n+  || _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n+# define _GLIBCXX_USE_NAMESPACE_ASSOCIATION 1\n+#endif\n+\n+// Macros for namespace scope. Either namespace std:: or __gnu_cxx::,\n+// or the name of some nested namespace within it.\n+// _GLIBCXX_STD\n+// _GLIBCXX_STD_D\n+// _GLIBCXX_STD_P\n+// _GLIBCXX_EXT\n+// _GLIBCXX_EXT_D\n+// _GLIBCXX_EXT_P\n+\n+//\n+// Macros for enclosing namepaces and possibly nested namespaces.\n // _GLIBCXX_BEGIN_NAMESPACE\n // _GLIBCXX_END_NAMESPACE\n // _GLIBCXX_BEGIN_NESTED_NAMESPACE\n // _GLIBCXX_END_NESTED_NAMESPACE\n-#if _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n-# define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y)  namespace X { namespace Y _GLIBCXX_VISIBILITY(default) {\n-# define _GLIBCXX_END_NESTED_NAMESPACE } }\n-# define _GLIBCXX_BEGIN_NAMESPACE(X) _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, _6)\n-# define _GLIBCXX_END_NAMESPACE _GLIBCXX_END_NESTED_NAMESPACE\n+// _GLIBCXX_BEGIN_POTENTIAL_NESTED_NAMESPACE\n+// _GLIBCXX_END_POTENTIAL_NESTED_NAMESPACE\n+#ifndef _GLIBCXX_USE_NAMESPACE_ASSOCIATION\n+# define _GLIBCXX_STD_D _GLIBCXX_STD\n+# define _GLIBCXX_STD_P _GLIBCXX_STD\n+# define _GLIBCXX_STD std\n+# define _GLIBCXX_EXT_D _GLIBCXX_EXT\n+# define _GLIBCXX_EXT_P _GLIBCXX_EXT\n+# define _GLIBCXX_EXT __gnu_cxx\n+# define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y) _GLIBCXX_BEGIN_NAMESPACE(X)\n+# define _GLIBCXX_END_NESTED_NAMESPACE _GLIBCXX_END_NAMESPACE\n+# define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) {\n+# define _GLIBCXX_END_NAMESPACE }\n #else\n-# define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n-# define _GLIBCXX_END_NAMESPACE } \n-# if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n-#  define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y) namespace X { namespace Y _GLIBCXX_VISIBILITY(default) {\n-#  define _GLIBCXX_END_NESTED_NAMESPACE  } }\n-# else\n-#  define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y) _GLIBCXX_BEGIN_NAMESPACE(X)\n-#  define _GLIBCXX_END_NESTED_NAMESPACE _GLIBCXX_END_NAMESPACE\n+\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION // && not anything else\n+#  define _GLIBCXX_STD_D _GLIBCXX_STD\n+#  define _GLIBCXX_STD_P _GLIBCXX_STD\n+#  define _GLIBCXX_STD _6\n+#  define _GLIBCXX_EXT _6\n+#  define _GLIBCXX_BEGIN_NAMESPACE(X) _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, _6)\n+#  define _GLIBCXX_END_NAMESPACE _GLIBCXX_END_NESTED_NAMESPACE\n # endif\n+\n+//  debug\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG && !_GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL\n+#  define _GLIBCXX_STD_D __norm\n+#  define _GLIBCXX_STD_P _GLIBCXX_STD\n+#  define _GLIBCXX_STD __cxx1998\n+#  define _GLIBCXX_EXT_D __norm\n+#  define _GLIBCXX_EXT_P _GLIBCXX_EXT\n+#  define _GLIBCXX_EXT __cxx1998\n+#  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n+#  define _GLIBCXX_END_NAMESPACE }\n+#  define _GLIBCXX_EXTERN_TEMPLATE 0\n+# endif\n+\n+// parallel\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && !_GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \n+#  define _GLIBCXX_STD_D _GLIBCXX_STD\n+#  define _GLIBCXX_STD_P __norm\n+#  define _GLIBCXX_STD __cxx1998\n+#  define _GLIBCXX_EXT_D _GLIBCXX_EXT\n+#  define _GLIBCXX_EXT_P __norm\n+#  define _GLIBCXX_EXT __cxx1998\n+#  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n+#  define _GLIBCXX_END_NAMESPACE }\n+#  define _GLIBCXX_EXTERN_TEMPLATE 0\n+# endif\n+\n+// debug + parallel\n+# if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL && _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG \n+#  define _GLIBCXX_STD_D __norm\n+#  define _GLIBCXX_STD_P __norm\n+#  define _GLIBCXX_STD __cxx1998\n+#  define _GLIBCXX_EXT_D __norm\n+#  define _GLIBCXX_EXT_P __norm\n+#  define _GLIBCXX_EXT __gnu_cxx\n+#  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n+#  define _GLIBCXX_END_NAMESPACE }\n+#  define _GLIBCXX_EXTERN_TEMPLATE 0\n+# endif\n+\n+# if __NO_INLINE__ && !__GXX_WEAK__\n+#  warning currently using namepace associated mode which may fail \\\n+   without inlining due to lack of weak symbols\n+# endif\n+\n+# define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y)  namespace X { namespace Y _GLIBCXX_VISIBILITY(default) {\n+# define _GLIBCXX_END_NESTED_NAMESPACE } }\n+#endif\n+\n+// Namespace associations for debug mode.\n+#if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n+namespace std\n+{ \n+  namespace __norm { } \n+  namespace __debug { }\n+  namespace __cxx1998 { }\n+\n+  using namespace __debug __attribute__ ((strong)); \n+  using namespace __cxx1998 __attribute__ ((strong)); \n+}\n+\n+namespace __gnu_cxx\n+{\n+  namespace __norm { }\n+  namespace __debug { }\n+  namespace __cxx1998 { }\n+\n+  using namespace __debug __attribute__ ((strong)); \n+  using namespace __cxx1998 __attribute__ ((strong)); \n+}\n+#endif\n+\n+// Namespace associations for parallel mode.\n+#if _GLIBCXX_NAMESPACE_ASSOCIATION_PARALLEL\n+namespace std\n+{ \n+  namespace __norm { } \n+  namespace __parallel { }\n+  namespace __cxx1998 { }\n+\n+  using namespace __parallel __attribute__ ((strong));\n+  using namespace __cxx1998 __attribute__ ((strong)); \n+}\n+\n+namespace __gnu_cxx\n+{\n+  namespace __norm { }\n+  namespace __parallel { }\n+  namespace __cxx1998 { }\n+\n+  using namespace __parallel __attribute__ ((strong)); \n+  using namespace __cxx1998 __attribute__ ((strong)); \n+}\n #endif\n \n // Namespace associations for versioning mode.\n@@ -119,38 +252,6 @@ namespace std\n }\n #endif\n \n-// Namespace associations for debug mode.\n-#if _GLIBCXX_NAMESPACE_ASSOCIATION_DEBUG\n-namespace std\n-{ \n-  namespace __norm { }\n-  namespace __debug { }\n-  using namespace __debug __attribute__ ((strong)); \n-}\n-\n-namespace __gnu_cxx\n-{\n-  namespace __norm { }\n-  namespace __debug { }\n-  using namespace __debug __attribute__ ((strong)); \n-}\n-\n-# define _GLIBCXX_STD __norm\n-# define _GLIBCXX_EXT __norm\n-# define _GLIBCXX_EXTERN_TEMPLATE 0\n-# if __NO_INLINE__ && !__GXX_WEAK__\n-#  warning debug mode without inlining may fail due to lack of weak symbols\n-# endif\n-#else\n-#if _GLIBCXX_NAMESPACE_ASSOCIATION_VERSION\n-# define _GLIBCXX_STD _6\n-# define _GLIBCXX_EXT _6\n-#else\n-# define _GLIBCXX_STD std\n-# define _GLIBCXX_EXT __gnu_cxx\n-#endif\n-#endif\n-\n // Define if compatibility should be provided for -mlong-double-64.\n #undef _GLIBCXX_LONG_DOUBLE_COMPAT\n \n@@ -193,6 +294,14 @@ _GLIBCXX_END_NAMESPACE\n # define _GLIBCXX_WEAK_DEFINITION\n #endif\n \n+// Macro used to indicate that the native \"C\" includes, when compiled\n+// as \"C++\", have declarations in namespace std and not the global\n+// namespace. Note, this is unrelated to possible \"C\" compatibility\n+// includes that inject C90/C99 names into the global namespace.\n+#if __cplusplus == 199711L\n+# define _GLIBCXX_NAMESPACE_GLOBAL_INJECTION 1\n+#endif\n+\n // The remainder of the prewritten config is automatic; all the\n // user hooks are listed above.\n "}, {"sha": "daa13b7558cceb5d685553b83c8aadf6ca6c6c7b", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -43,7 +43,7 @@\n \n #pragma GCC system_header\n \n-#include <bits/stl_algobase.h>  // For copy, fill_n\n+#include <bits/algorithmfwd.h>   // std::copy, std::fill_n\n #include <bits/postypes.h>      // For streampos\n #include <cstdio>               // For EOF\n #include <cwchar>               // For WEOF, wmemmove, wmemset, etc.\n@@ -194,6 +194,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     char_traits<_CharT>::\n     copy(char_type* __s1, const char_type* __s2, std::size_t __n)\n     {\n+      // NB: Inline std::copy so no recursive dependencies.\n       std::copy(__s2, __s2 + __n, __s1);\n       return __s1;\n     }\n@@ -203,6 +204,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     char_traits<_CharT>::\n     assign(char_type* __s, std::size_t __n, char_type __a)\n     {\n+      // NB: Inline std::fill_n so no recursive dependencies.\n       std::fill_n(__s, __n, __a);\n       return __s;\n     }"}, {"sha": "b5cacc1e577627073692f6170215f453b645665f", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -62,7 +62,7 @@\n #ifndef _DEQUE_TCC\n #define _DEQUE_TCC 1\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   template <typename _Tp, typename _Alloc>\n     deque<_Tp, _Alloc>&"}, {"sha": "3fdc5bbac558502a9fab18a62ed8380a5b2f090a", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -62,7 +62,7 @@\n #ifndef _LIST_TCC\n #define _LIST_TCC 1\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   template<typename _Tp, typename _Alloc>\n     void"}, {"sha": "d03ae139e56340646d8d0c66f47660e3d712f03e", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 3736, "deletions": 3746, "changes": 7482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355"}, {"sha": "c6648b43b9d69d12d11554fb271a7b7cb9f82e22", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 170, "deletions": 89, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -65,11 +65,10 @@\n #include <bits/c++config.h>\n #include <cstddef>\n #include <bits/functexcept.h>\n-#include <bits/stl_pair.h>\n #include <bits/cpp_type_traits.h>\n #include <ext/type_traits.h>\n #include <ext/numeric_traits.h>\n-#include <bits/stl_iterator_base_types.h>\n+#include <bits/algorithmfwd.h>\n #include <bits/stl_iterator_base_funcs.h>\n #include <bits/stl_iterator.h>\n #include <bits/concept_check.h>\n@@ -596,7 +595,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t      __niter_base<_ForwardIterator>::__b(__last), __value);\n     }\n \n-\n   template<bool>\n     struct __fill_n\n     {\n@@ -678,7 +676,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t\t   __value));\n     }\n \n-\n   template<bool _BoolType>\n     struct __equal\n     {\n@@ -719,6 +716,90 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return std::__equal<__simple>::equal(__first1, __last1, __first2);\n     }\n \n+\n+  template<typename, typename>\n+    struct __lc_rai\n+    {\n+      template<typename _II1, typename _II2>\n+        static _II1\n+        __newlast1(_II1, _II1 __last1, _II2, _II2)\n+        { return __last1; }\n+\n+      template<typename _II>\n+        static bool\n+        __cnd2(_II __first, _II __last)\n+        { return __first != __last; }\n+    };\n+\n+  template<>\n+    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>\n+    {\n+      template<typename _RAI1, typename _RAI2>\n+        static _RAI1\n+        __newlast1(_RAI1 __first1, _RAI1 __last1,\n+\t\t   _RAI2 __first2, _RAI2 __last2)\n+        {\n+\t  const typename iterator_traits<_RAI1>::difference_type\n+\t    __diff1 = __last1 - __first1;\n+\t  const typename iterator_traits<_RAI2>::difference_type\n+\t    __diff2 = __last2 - __first2;\n+\t  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;\n+\t}\n+\n+      template<typename _RAI>\n+        static bool\n+        __cnd2(_RAI, _RAI)\n+        { return true; }\n+    };\n+\n+  // XXX should these be enabled-if'd for signed/unsigned types instead?\n+  inline bool\n+  lexicographical_compare(const unsigned char* __first1,\n+\t\t\t  const unsigned char* __last1,\n+\t\t\t  const unsigned char* __first2,\n+\t\t\t  const unsigned char* __last2)\n+  {\n+    __glibcxx_requires_valid_range(__first1, __last1);\n+    __glibcxx_requires_valid_range(__first2, __last2);\n+\n+    const size_t __len1 = __last1 - __first1;\n+    const size_t __len2 = __last2 - __first2;\n+    const int __result = __builtin_memcmp(__first1, __first2,\n+\t\t\t\t\t  std::min(__len1, __len2));\n+    return __result != 0 ? __result < 0 : __len1 < __len2;\n+  }\n+\n+  inline bool\n+  lexicographical_compare(const char* __first1, const char* __last1,\n+\t\t\t  const char* __first2, const char* __last2)\n+  {\n+    __glibcxx_requires_valid_range(__first1, __last1);\n+    __glibcxx_requires_valid_range(__first2, __last2);\n+\n+    if (__gnu_cxx::__numeric_traits<char>::__is_signed)\n+      {\n+\ttypedef const signed char* value_type;\n+\tvalue_type __f1 = reinterpret_cast<value_type>(__first1);\n+\tvalue_type __l1 = reinterpret_cast<value_type>(__last1);\n+\tvalue_type __f2 = reinterpret_cast<value_type>(__first2);\n+\tvalue_type __l2 = reinterpret_cast<value_type>(__last2);\t\n+\treturn _GLIBCXX_STD_P::lexicographical_compare(__f1, __l1, __f2, __l2);\n+      }\n+    else\n+      {\n+\ttypedef const unsigned char* value_type;\n+\tvalue_type __f1 = reinterpret_cast<value_type>(__first1);\n+\tvalue_type __l1 = reinterpret_cast<value_type>(__last1);\n+\tvalue_type __f2 = reinterpret_cast<value_type>(__first2);\n+\tvalue_type __l2 = reinterpret_cast<value_type>(__last2);\t\n+\treturn _GLIBCXX_STD_P::lexicographical_compare(__f1, __l1, __f2, __l2);\n+      }\n+  }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_P)\n+\n   /**\n    *  @brief Tests a range for element-wise equality.\n    *  @param  first1  An input iterator.\n@@ -752,24 +833,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  @param  first1  An input iterator.\n    *  @param  last1   An input iterator.\n    *  @param  first2  An input iterator.\n-   *  @param  binary_pred  A binary predicate @link s20_3_1_base functor@endlink.\n-   *  @return   A boolean true or false.\n+   *  @param binary_pred A binary predicate @link s20_3_1_base\n+   *                  functor@endlink.\n+   *  @return         A boolean true or false.\n    *\n    *  This compares the elements of two ranges using the binary_pred\n    *  parameter, and returns true or\n    *  false depending on whether all of the corresponding elements of the\n    *  ranges are equal.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2,\n-\t   typename _BinaryPredicate>\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n     inline bool\n-    equal(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t  _InputIterator2 __first2,\n-\t  _BinaryPredicate __binary_pred)\n+    equal(_IIter1 __first1, _IIter1 __last1,\n+\t  _IIter2 __first2, _BinaryPredicate __binary_pred)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n \n       for (; __first1 != __last1; ++__first1, ++__first2)\n@@ -778,43 +858,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return true;\n     }\n \n-\n-  template<typename, typename>\n-    struct __lc_rai\n-    {\n-      template<typename _II1, typename _II2>\n-        static _II1\n-        __newlast1(_II1, _II1 __last1, _II2, _II2)\n-        { return __last1; }\n-\n-      template<typename _II>\n-        static bool\n-        __cnd2(_II __first, _II __last)\n-        { return __first != __last; }\n-    };\n-\n-  template<>\n-    struct __lc_rai<random_access_iterator_tag,\n-\t\t    random_access_iterator_tag>\n-    {\n-      template<typename _RAI1, typename _RAI2>\n-        static _RAI1\n-        __newlast1(_RAI1 __first1, _RAI1 __last1,\n-\t\t   _RAI2 __first2, _RAI2 __last2)\n-        {\n-\t  const typename iterator_traits<_RAI1>::difference_type\n-\t    __diff1 = __last1 - __first1;\n-\t  const typename iterator_traits<_RAI2>::difference_type\n-\t    __diff2 = __last2 - __first2;\n-\t  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;\n-\t}\n-\n-      template<typename _RAI>\n-        static bool\n-        __cnd2(_RAI, _RAI)\n-        { return true; }\n-    };\n-\n   /**\n    *  @brief Performs \"dictionary\" comparison on ranges.\n    *  @param  first1  An input iterator.\n@@ -831,7 +874,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   */\n   template<typename _II1, typename _II2>\n     bool\n-    lexicographical_compare(_II1 __first1, _II1 __last1,\n+    lexicographical_compare(_II1 __first1, _II1 __last1, \n \t\t\t    _II2 __first2, _II2 __last2)\n     {\n       typedef typename iterator_traits<_II1>::iterator_category _Category1;\n@@ -882,19 +925,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     {\n       typedef typename iterator_traits<_II1>::iterator_category _Category1;\n       typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+      typedef __lc_rai<_Category1, _Category2> \t__rai_type;\n \n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      __last1 = __lc_rai<_Category1, _Category2>::__newlast1(__first1,\n-\t\t\t\t\t\t\t     __last1,\n-\t\t\t\t\t\t\t     __first2,\n-\t\t\t\t\t\t\t     __last2);\n-      for (; __first1 != __last1\n-\t     && __lc_rai<_Category1, _Category2>::__cnd2(__first2, __last2);\n+      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);\n+      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n \t   ++__first1, ++__first2)\n \t{\n \t  if (__comp(*__first1, *__first2))\n@@ -905,41 +945,82 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __first1 == __last1 && __first2 != __last2;\n     }\n \n-  inline bool\n-  lexicographical_compare(const unsigned char* __first1,\n-\t\t\t  const unsigned char* __last1,\n-\t\t\t  const unsigned char* __first2,\n-\t\t\t  const unsigned char* __last2)\n-  {\n-    __glibcxx_requires_valid_range(__first1, __last1);\n-    __glibcxx_requires_valid_range(__first2, __last2);\n \n-    const size_t __len1 = __last1 - __first1;\n-    const size_t __len2 = __last2 - __first2;\n-    const int __result = __builtin_memcmp(__first1, __first2,\n-\t\t\t\t\t  std::min(__len1, __len2));\n-    return __result != 0 ? __result < 0 : __len1 < __len2;\n-  }\n+  /**\n+   *  @brief Finds the places in ranges which don't match.\n+   *  @param  first1  An input iterator.\n+   *  @param  last1   An input iterator.\n+   *  @param  first2  An input iterator.\n+   *  @return   A pair of iterators pointing to the first mismatch.\n+   *\n+   *  This compares the elements of two ranges using @c == and returns a pair\n+   *  of iterators.  The first iterator points into the first range, the\n+   *  second iterator points into the second range, and the elements pointed\n+   *  to by the iterators are not equal.\n+  */\n+  template<typename _InputIterator1, typename _InputIterator2>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_function_requires(_EqualOpConcept<\n+\t    typename iterator_traits<_InputIterator1>::value_type,\n+\t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n-  inline bool\n-  lexicographical_compare(const char* __first1, const char* __last1,\n-\t\t\t  const char* __first2, const char* __last2)\n-  {\n-    __glibcxx_requires_valid_range(__first1, __last1);\n-    __glibcxx_requires_valid_range(__first2, __last2);\n+      while (__first1 != __last1 && *__first1 == *__first2)\n+        {\n+\t  ++__first1;\n+\t  ++__first2;\n+        }\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n \n-    if (__gnu_cxx::__numeric_traits<char>::__is_signed)\n-      return std::lexicographical_compare((const signed char*) __first1,\n-\t\t\t\t\t  (const signed char*) __last1,\n-\t\t\t\t\t  (const signed char*) __first2,\n-\t\t\t\t\t  (const signed char*) __last2);\n-    else\n-      return std::lexicographical_compare((const unsigned char*) __first1,\n-\t\t\t\t\t  (const unsigned char*) __last1,\n-\t\t\t\t\t  (const unsigned char*) __first2,\n-\t\t\t\t\t  (const unsigned char*) __last2);\n-  }\n+  /**\n+   *  @brief Finds the places in ranges which don't match.\n+   *  @param  first1  An input iterator.\n+   *  @param  last1   An input iterator.\n+   *  @param  first2  An input iterator.\n+   *  @param binary_pred A binary predicate @link s20_3_1_base\n+   *         functor@endlink.\n+   *  @return   A pair of iterators pointing to the first mismatch.\n+   *\n+   *  This compares the elements of two ranges using the binary_pred\n+   *  parameter, and returns a pair\n+   *  of iterators.  The first iterator points into the first range, the\n+   *  second iterator points into the second range, and the elements pointed\n+   *  to by the iterators are not equal.\n+  */\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n-_GLIBCXX_END_NAMESPACE\n+      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))\n+        {\n+\t  ++__first1;\n+\t  ++__first2;\n+        }\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n+\n+_GLIBCXX_END_NESTED_NAMESPACE\n+\n+// NB: This file is included within many other C++ includes, as a way\n+// of getting the base algorithms. So, make sure that parallel bits\n+// come in too if requested. \n+#ifdef _GLIBCXX_PARALLEL\n+//# include <parallel/algorithm>\n+# include <parallel/algobase.h>\n+#endif\n \n #endif"}, {"sha": "a2a86f26f17e3700c1174339b93bd26e59c6d2d8", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -62,7 +62,7 @@\n #ifndef _STL_BVECTOR_H\n #define _STL_BVECTOR_H 1\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   typedef unsigned long _Bit_type;\n   enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };\n@@ -432,7 +432,7 @@ _GLIBCXX_END_NESTED_NAMESPACE\n // Declare a partial specialization of vector<T, Alloc>.\n #include <bits/stl_vector.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief  A specialization of vector for booleans which offers fixed time"}, {"sha": "a0553961a5bbd3c18ce15e4d63d90c795d8f9a61", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -66,7 +66,7 @@\n #include <bits/stl_iterator_base_types.h>\n #include <bits/stl_iterator_base_funcs.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @if maint"}, {"sha": "dac02c8e61689c0e7dfb2a938a1b70b4bd2d34bf", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -64,7 +64,7 @@\n \n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   // Supporting structures are split into common and templated types; the\n   // latter publicly inherits from the former in an effort to reduce code"}, {"sha": "e1429ef6956795f14b88cd08ffcfb4e431db57f2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -65,7 +65,7 @@\n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be"}, {"sha": "5730854ee6969e60debd7c319300091c85c7d870", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -64,7 +64,7 @@\n \n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be"}, {"sha": "dab8d6f47f3d275edeb23bdda2e10305239fd2f4", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -64,7 +64,7 @@\n \n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief A standard container made up of elements, which can be retrieved"}, {"sha": "3940e4aa97099a62facbc4564dc845d82e0f0999", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -65,7 +65,7 @@\n #include <bits/concept_check.h>\n #include <debug/debug.h>\n \n-_GLIBCXX_BEGIN_NAMESPACE(std)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_P)\n \n   /**\n    *  @brief  Accumulate values in a range.\n@@ -336,6 +336,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return ++__result;\n     }\n \n-_GLIBCXX_END_NAMESPACE\n+_GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_NUMERIC_H */"}, {"sha": "3bddefc635d7428bc3c8ef359b3bafb527733582", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -64,7 +64,7 @@\n \n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief A standard container made up of unique keys, which can be"}, {"sha": "93db4138bdd8c566fb630d2ec6e95c34fa0ef295", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -66,7 +66,7 @@\n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @if maint"}, {"sha": "442447c27f17553d12e118ca5192bc8a64ed6845", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -62,7 +62,7 @@\n #ifndef _VECTOR_TCC\n #define _VECTOR_TCC 1\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   template<typename _Tp, typename _Alloc>\n     void"}, {"sha": "ba677122d74308c7b04a6bce95618a1d455f21b0", "filename": "libstdc++-v3/include/debug/bitset", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -45,10 +45,10 @@ namespace __debug\n {\n   template<size_t _Nb>\n     class bitset\n-    : public _GLIBCXX_STD::bitset<_Nb>, \n+    : public _GLIBCXX_STD_D::bitset<_Nb>, \n       public __gnu_debug::_Safe_sequence_base\n     {\n-      typedef _GLIBCXX_STD::bitset<_Nb> _Base;\n+      typedef _GLIBCXX_STD_D::bitset<_Nb> _Base;\n       typedef __gnu_debug::_Safe_sequence_base  _Safe_base;\n \n     public:"}, {"sha": "d488f1587d892c7ae55a14103ab682d9cdb6a246", "filename": "libstdc++-v3/include/debug/debug.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -113,6 +113,7 @@ namespace std\n #else\n # define _GLIBCXX_DEBUG_PEDASSERT(_Condition)\n #endif\n+\n # define _GLIBCXX_DEBUG_ONLY(_Statement) _Statement\n \n # define __glibcxx_requires_cond(_Cond,_Msg) _GLIBCXX_DEBUG_VERIFY(_Cond,_Msg)"}, {"sha": "2bf4a19cf8bb32f1674429521476617b6b971f05", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -45,10 +45,10 @@ namespace __debug\n {\n   template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class deque\n-    : public _GLIBCXX_STD::deque<_Tp, _Allocator>,\n+    : public _GLIBCXX_STD_D::deque<_Tp, _Allocator>,\n       public __gnu_debug::_Safe_sequence<deque<_Tp, _Allocator> >\n     {\n-      typedef  _GLIBCXX_STD::deque<_Tp, _Allocator> _Base;\n+      typedef  _GLIBCXX_STD_D::deque<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<deque> _Safe_base;\n \n     public:"}, {"sha": "485df086551a2f1c7690bcbb87d9d69bccaeb13f", "filename": "libstdc++-v3/include/debug/list", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -73,10 +73,10 @@ namespace __debug\n {\n   template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class list\n-    : public _GLIBCXX_STD::list<_Tp, _Allocator>,\n+    : public _GLIBCXX_STD_D::list<_Tp, _Allocator>,\n       public __gnu_debug::_Safe_sequence<list<_Tp, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD::list<_Tp, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::list<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<list>  _Safe_base;\n \n     public:"}, {"sha": "d619520866496ef539bf57eaf9d4ed471662a3e1", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -46,10 +46,10 @@ namespace __debug\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class map\n-    : public _GLIBCXX_STD::map<_Key, _Tp, _Compare, _Allocator>,\n+    : public _GLIBCXX_STD_D::map<_Key, _Tp, _Compare, _Allocator>,\n       public __gnu_debug::_Safe_sequence<map<_Key, _Tp, _Compare, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD::map<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::map<_Key, _Tp, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<map> _Safe_base;\n \n     public:"}, {"sha": "5e4962f96603eca21a8e6ac16f16da140e7546b7", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -46,10 +46,10 @@ namespace __debug\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class multimap\n-    : public _GLIBCXX_STD::multimap<_Key, _Tp, _Compare, _Allocator>,\n+    : public _GLIBCXX_STD_D::multimap<_Key, _Tp, _Compare, _Allocator>,\n     public __gnu_debug::_Safe_sequence<multimap<_Key,_Tp,_Compare,_Allocator> >\n     {\n-      typedef _GLIBCXX_STD::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<multimap> _Safe_base;\n \n     public:"}, {"sha": "2ca534a65994bb1f49bde62652068d499051dc73", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -46,10 +46,10 @@ namespace __debug\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class multiset\n-    : public _GLIBCXX_STD::multiset<_Key, _Compare, _Allocator>,\n+    : public _GLIBCXX_STD_D::multiset<_Key, _Compare, _Allocator>,\n       public __gnu_debug::_Safe_sequence<multiset<_Key, _Compare, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD::multiset<_Key, _Compare, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::multiset<_Key, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<multiset> _Safe_base;\n \n     public:"}, {"sha": "d40d319855b130d6f9fe9777bd4b85b9e27b6cfe", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -46,10 +46,10 @@ namespace __debug\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class set\n-    : public _GLIBCXX_STD::set<_Key,_Compare,_Allocator>,\n+    : public _GLIBCXX_STD_D::set<_Key,_Compare,_Allocator>,\n       public __gnu_debug::_Safe_sequence<set<_Key, _Compare, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD::set<_Key,_Compare,_Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::set<_Key,_Compare,_Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<set> _Safe_base;\n \n     public:"}, {"sha": "1365525fef2d779d18e779cee6709dc4d90982f0", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -47,10 +47,10 @@ namespace __debug\n   template<typename _Tp,\n \t   typename _Allocator = std::allocator<_Tp> >\n     class vector\n-    : public _GLIBCXX_STD::vector<_Tp, _Allocator>,\n+    : public _GLIBCXX_STD_D::vector<_Tp, _Allocator>,\n       public __gnu_debug::_Safe_sequence<vector<_Tp, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD::vector<_Tp, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_D::vector<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<vector>              _Safe_base;\n \n       typedef typename _Base::const_iterator _Base_const_iterator;"}, {"sha": "183bff556f4ae65a630726db29d5dddc31c00a42", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -65,7 +65,7 @@\n #include <ext/hashtable.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n \n   using std::equal_to;\n   using std::allocator;"}, {"sha": "b796babd68b1ec3a362b3bf4839674b343111e10", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -65,7 +65,7 @@\n #include <ext/hashtable.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n \n   using std::equal_to;\n   using std::allocator;"}, {"sha": "dcda79090b4f0eeaf0d6f4efe91b65659833e7ec", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "added", "additions": 1585, "deletions": 0, "changes": 1585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,1585 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/algo.h\n+ *  @brief Parallel STL function calls corresponding to the stl_algo.h header.\n+ *\n+ *  The functions defined here mainly do case switches and\n+ *  call the actual parallelized versions in other files.\n+ *  Inlining policy: Functions that basically only contain one function call,\n+ *  are declared inline.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_ALGO_H\n+#define _GLIBCXX_PARALLEL_ALGO_H 1\n+\n+#include <parallel/algorithmfwd.h>\n+#include <bits/stl_algobase.h>\n+#include <bits/stl_algo.h>\n+#include <parallel/iterator.h>\n+#include <parallel/base.h>\n+#include <parallel/sort.h>\n+#include <parallel/workstealing.h>\n+#include <parallel/par_loop.h>\n+#include <parallel/omp_loop.h>\n+#include <parallel/omp_loop_static.h>\n+#include <parallel/for_each_selectors.h>\n+#include <parallel/for_each.h>\n+#include <parallel/find.h>\n+#include <parallel/find_selectors.h>\n+#include <parallel/search.h>\n+#include <parallel/random_shuffle.h>\n+#include <parallel/partition.h>\n+#include <parallel/merge.h>\n+#include <parallel/unique_copy.h>\n+#include <parallel/set_operations.h>\n+\n+namespace std\n+{\n+namespace __parallel\n+{\n+  // Sequential fallback\n+  template<typename InputIterator, typename Function>\n+  inline Function\n+  for_each(InputIterator begin, InputIterator end, Function f, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::for_each<InputIterator, Function>(begin, end, f);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator, typename Function, typename IteratorTag>\n+  Function\n+  for_each_switch(InputIterator begin, InputIterator end, Function f, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    return for_each<InputIterator, Function>(begin, end, f, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator, typename Function>\n+  Function\n+  for_each_switch(RandomAccessIterator begin, RandomAccessIterator end, Function f, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::for_each_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy;\n+\t__gnu_parallel::for_each_selector<RandomAccessIterator> functionality;\n+\treturn __gnu_parallel::for_each_template_random_access(begin, end, f, functionality, __gnu_parallel::dummy_reduct(), true, dummy, -1, parallelism_tag);\n+      }\n+    else\n+      return for_each<RandomAccessIterator, Function>(begin, end, f, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename Iterator, typename Function>\n+  inline Function\n+  for_each(Iterator begin, Iterator end, Function f, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef std::iterator_traits<Iterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+\n+    return for_each_switch(begin, end, f, iterator_category(), parallelism_tag);\n+  }\n+\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename T>\n+  inline InputIterator\n+  find(InputIterator begin, InputIterator end, const T& val, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::find<InputIterator, T>(begin, end, val); }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator, typename T, typename IteratorTag>\n+  inline InputIterator\n+  find_switch(InputIterator begin, InputIterator end, const T& val, IteratorTag)\n+  { return _GLIBCXX_STD_P::find(begin, end, val); }\n+\n+  // Parallel find for random access iterators\n+  template<typename RandomAccessIterator, typename T>\n+  RandomAccessIterator\n+  find_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& val, random_access_iterator_tag)\n+  {\n+    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      {\n+\tbinder2nd<__gnu_parallel::equal_to<value_type, T> > comp(__gnu_parallel::equal_to<value_type, T>(), val);\n+\treturn __gnu_parallel::find_template(begin, end, begin, comp, __gnu_parallel::find_if_selector()).first;\n+      }\n+    else\n+      return _GLIBCXX_STD_P::find(begin, end, val);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename T>\n+  inline InputIterator\n+  find(InputIterator begin, InputIterator end, const T& val)\n+  {\n+    typedef std::iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return find_switch(begin, end, val, iterator_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename Predicate>\n+  inline InputIterator\n+  find_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::find_if<InputIterator, Predicate>(begin, end, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator, typename Predicate, typename IteratorTag>\n+  inline InputIterator\n+  find_if_switch(InputIterator begin, InputIterator end, Predicate pred, IteratorTag)\n+  {\n+    return _GLIBCXX_STD_P::find_if(begin, end, pred);\n+  }\n+\n+  // Parallel find_if for random access iterators\n+  template<typename RandomAccessIterator, typename Predicate>\n+  RandomAccessIterator\n+  find_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      return __gnu_parallel::find_template(begin, end, begin, pred, __gnu_parallel::find_if_selector()).first;\n+    else\n+      return _GLIBCXX_STD_P::find_if(begin, end, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename Predicate>\n+  inline InputIterator\n+  find_if (InputIterator begin, InputIterator end, Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return find_if_switch(begin, end, pred, iterator_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename ForwardIterator>\n+  inline InputIterator\n+  find_first_of(InputIterator begin1, InputIterator end1, ForwardIterator begin2, ForwardIterator end2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename ForwardIterator,\n+\t   typename BinaryPredicate>\n+  inline InputIterator\n+  find_first_of(InputIterator begin1, InputIterator end1,\n+\t\tForwardIterator begin2, ForwardIterator end2,\n+\t\tBinaryPredicate comp, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2, comp);\n+  }\n+\n+  // Sequential fallback for input iterator type\n+  template<typename InputIterator, typename ForwardIterator, typename IteratorTag1, typename IteratorTag2>\n+  inline InputIterator\n+  find_first_of_switch(InputIterator begin1, InputIterator end1,\n+\t\t       ForwardIterator begin2, ForwardIterator end2, IteratorTag1, IteratorTag2)\n+  {\n+    return find_first_of(begin1, end1, begin2, end2, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator, typename ForwardIterator, typename BinaryPredicate, typename IteratorTag>\n+  inline RandomAccessIterator\n+  find_first_of_switch(RandomAccessIterator begin1, RandomAccessIterator end1,\n+\t\t       ForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp, random_access_iterator_tag, IteratorTag)\n+  {\n+    return __gnu_parallel::find_template(begin1, end1, begin1, comp, __gnu_parallel::find_first_of_selector<ForwardIterator>(begin2, end2)).first;\n+  }\n+\n+  // Sequential fallback for input iterator type\n+  template<typename InputIterator, typename ForwardIterator, typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n+  inline\n+  InputIterator\n+  find_first_of_switch(InputIterator begin1, InputIterator end1,\n+\t\t       ForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp, IteratorTag1, IteratorTag2)\n+  {\n+    return find_first_of(begin1, end1, begin2, end2, comp, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename ForwardIterator, typename BinaryPredicate>\n+  inline InputIterator\n+  find_first_of(InputIterator begin1, InputIterator end1,\n+\t\tForwardIterator begin2, ForwardIterator end2, BinaryPredicate comp)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<ForwardIterator> iteratorf_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratorf_traits::iterator_category iteratorf_category;\n+\n+    return find_first_of_switch(begin1, end1, begin2, end2, comp, iteratori_category(), iteratorf_category());\n+  }\n+\n+  // Public interface, insert default comparator\n+  template<typename InputIterator, typename ForwardIterator>\n+  InputIterator\n+  find_first_of(InputIterator begin1, InputIterator end1, ForwardIterator begin2, ForwardIterator end2)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<ForwardIterator> iteratorf_traits;\n+    typedef typename iteratori_traits::value_type valuei_type;\n+    typedef typename iteratorf_traits::value_type valuef_type;\n+\n+    return find_first_of(begin1, end1, begin2, end2, __gnu_parallel::equal_to<valuei_type, valuef_type>());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out,\n+\t      __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::unique_copy<InputIterator, OutputIterator>(begin1, end1, out);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out,\n+\t      Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::unique_copy<InputIterator, OutputIterator, Predicate>(begin1, end1, out, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator, typename OutputIterator, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline OutputIterator\n+  unique_copy_switch(InputIterator begin, InputIterator last, OutputIterator out,\n+\t\t     Predicate pred, IteratorTag1, IteratorTag2)\n+  {\n+    return _GLIBCXX_STD_P::unique_copy(begin, last, out, pred);\n+  }\n+\n+  // Parallel unique_copy for random access iterators\n+  template<typename RandomAccessIterator, typename RandomAccessOutputIterator, typename Predicate>\n+  RandomAccessOutputIterator\n+  unique_copy_switch(RandomAccessIterator begin, RandomAccessIterator last, RandomAccessOutputIterator out,\n+\t\t     Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(last - begin) > __gnu_parallel::Settings::unique_copy_minimal_n))\n+      return __gnu_parallel::parallel_unique_copy(begin, last, out, pred);\n+    else\n+      return _GLIBCXX_STD_P::unique_copy(begin, last, out, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratori_traits::value_type value_type;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return unique_copy_switch(begin1, end1, out, equal_to<value_type>(),\n+\t\t\t      iteratori_category(), iteratoro_category());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  unique_copy(InputIterator begin1, InputIterator end1, OutputIterator out,\n+\t      Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return unique_copy_switch(begin1, end1, out, pred, iteratori_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  set_union(InputIterator1 begin1, InputIterator1 end1,\n+\t    InputIterator2 begin2, InputIterator2 end2,\n+\t    OutputIterator out, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  set_union(InputIterator1 begin1, InputIterator1 end1,\n+\t    InputIterator2 begin2, InputIterator2 end2,\n+\t    OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, out, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate,\n+\t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline OutputIterator \n+  set_union_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t   InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1,\n+\t\t   IteratorTag2, IteratorTag3)\n+  {\n+    return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Parallel set_union for random access iterators\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputRandomAccessIterator, typename Predicate>\n+  OutputRandomAccessIterator \n+  set_union_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n+\t\t   RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n+\t\t   random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_union_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_union_minimal_n))\n+      return __gnu_parallel::parallel_set_union(begin1, end1, begin2, end2, result, pred);\n+    else\n+      return _GLIBCXX_STD_P::set_union(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator \n+  set_union(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+    typedef typename iteratori1_traits::value_type value1_type;\n+    typedef typename iteratori2_traits::value_type value2_type;\n+\n+    return set_union_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t\t    iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator \n+  set_union(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t    InputIterator2 end2, OutputIterator out, Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return set_union_switch(begin1, end1, begin2, end2, out, pred,\n+\t\t\t    iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  set_intersection(InputIterator1 begin1, InputIterator1 end1,\n+\t\t   InputIterator2 begin2, InputIterator2 end2,\n+\t\t   OutputIterator out, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, out);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  set_intersection(InputIterator1 begin1, InputIterator1 end1,\n+\t\t   InputIterator2 begin2, InputIterator2 end2,\n+\t\t   OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, out, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate,\n+\t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline OutputIterator \n+  set_intersection_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t\t  InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1,\n+\t\t\t  IteratorTag2, IteratorTag3)\n+  {\n+    return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Parallel set_intersection for random access iterators\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputRandomAccessIterator, typename Predicate>\n+  OutputRandomAccessIterator \n+  set_intersection_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n+\t\t\t  RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n+\t\t\t  random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_union_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_union_minimal_n))\n+      return __gnu_parallel::parallel_set_intersection(begin1, end1, begin2, end2, result, pred);\n+    else\n+      return _GLIBCXX_STD_P::set_intersection(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator \n+  set_intersection(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+    typedef typename iteratori1_traits::value_type value1_type;\n+    typedef typename iteratori2_traits::value_type value2_type;\n+\n+    return set_intersection_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator \n+  set_intersection(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t   InputIterator2 end2, OutputIterator out, Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return set_intersection_switch(begin1, end1, begin2, end2, out, pred,\n+\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename OutputIterator>\n+  inline OutputIterator\n+  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1,\n+\t\t\t   InputIterator2 begin2, InputIterator2 end2,\n+\t\t\t   OutputIterator out, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1,end1, begin2, end2, out);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2,\n+\t   typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1,\n+\t\t\t   InputIterator2 begin2, InputIterator2 end2,\n+\t\t\t   OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2, out, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate, typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline OutputIterator \n+  set_symmetric_difference_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1, IteratorTag2, IteratorTag3)\n+  {\n+    return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Parallel set_symmetric_difference for random access iterators\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputRandomAccessIterator, typename Predicate>\n+  OutputRandomAccessIterator \n+  set_symmetric_difference_switch(RandomAccessIterator1 begin1,\n+\t\t\t\t  RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n+\t\t\t\t  RandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n+\t\t\t\t  random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n))\n+      return __gnu_parallel::parallel_set_symmetric_difference(begin1, end1, begin2, end2, result, pred);\n+    else\n+      return _GLIBCXX_STD_P::set_symmetric_difference(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator \n+  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+    typedef typename iteratori1_traits::value_type value1_type;\n+    typedef typename iteratori2_traits::value_type value2_type;\n+\n+    return set_symmetric_difference_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t\t\t\t   iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator \n+  set_symmetric_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t\t   InputIterator2 end2, OutputIterator out, Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+   return set_symmetric_difference_switch(begin1, end1, begin2, end2, out, pred,\n+\t\t\t\t\t  iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_difference(begin1,end1, begin2, end2, out);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::set_difference(begin1, end1, begin2, end2, out, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate,\n+\t   typename OutputIterator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline OutputIterator\n+  set_difference_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t\tInputIterator2 end2, OutputIterator result, Predicate pred, IteratorTag1, IteratorTag2, IteratorTag3)\n+  {\n+    return _GLIBCXX_STD_P::set_difference(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Parallel set_difference for random access iterators\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename OutputRandomAccessIterator, typename Predicate>\n+  OutputRandomAccessIterator\n+  set_difference_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2,\n+\t\t\tRandomAccessIterator2 end2, OutputRandomAccessIterator result, Predicate pred,\n+\t\t\trandom_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::set_difference_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::set_difference_minimal_n))\n+      return __gnu_parallel::parallel_set_difference(begin1, end1, begin2, end2, result, pred);\n+    else\n+      return _GLIBCXX_STD_P::set_difference(begin1, end1, begin2, end2, result, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator out)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+    typedef typename iteratori1_traits::value_type value1_type;\n+    typedef typename iteratori2_traits::value_type value2_type;\n+\n+    return set_difference_switch(begin1, end1, begin2, end2, out, __gnu_parallel::less<value1_type, value2_type>(),\n+\t\t\t\t iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate>\n+  inline OutputIterator\n+  set_difference(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t\t InputIterator2 end2, OutputIterator out, Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return set_difference_switch(begin1, end1, begin2, end2, out, pred,\n+\t\t\t\t iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::adjacent_find<ForwardIterator>(begin, end);\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename BinaryPredicate>\n+  inline ForwardIterator\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::adjacent_find<ForwardIterator, BinaryPredicate>(begin, end, binary_pred);\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator>\n+  RandomAccessIterator\n+  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, random_access_iterator_tag)\n+  {\n+    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      {\n+\tRandomAccessIterator spot = __gnu_parallel::find_template(begin, end - 1, begin, equal_to<value_type>(), __gnu_parallel::adjacent_find_selector()).first;\n+\tif (spot == (end - 1))\n+\t  return end;\n+\telse\n+\t  return spot;\n+      }\n+    else\n+      return adjacent_find<RandomAccessIterator>(begin, end, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename IteratorTag>\n+  inline ForwardIterator\n+  adjacent_find_switch(ForwardIterator begin, ForwardIterator end, IteratorTag)\n+  {\n+    return adjacent_find<ForwardIterator>(begin, end, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  adjacent_find(ForwardIterator begin, ForwardIterator end)\n+  {\n+    return adjacent_find_switch(begin, end, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename BinaryPredicate, typename IteratorTag>\n+  inline ForwardIterator\n+  adjacent_find_switch(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred, IteratorTag)\n+  {\n+    return adjacent_find<ForwardIterator, BinaryPredicate>(begin, end, binary_pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator, typename BinaryPredicate>\n+  RandomAccessIterator\n+  adjacent_find_switch(RandomAccessIterator begin, RandomAccessIterator end, BinaryPredicate binary_pred, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      return __gnu_parallel::find_template(begin, end, begin, binary_pred, __gnu_parallel::adjacent_find_selector()).first;\n+    else\n+      return adjacent_find(begin, end, binary_pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename ForwardIterator, typename BinaryPredicate>\n+  inline ForwardIterator\n+  adjacent_find(ForwardIterator begin, ForwardIterator end, BinaryPredicate binary_pred)\n+  {\n+    return adjacent_find_switch<ForwardIterator, BinaryPredicate>(begin, end, binary_pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator, typename T>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count(InputIterator begin, InputIterator end, const T& value, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::count<InputIterator, T>(begin, end, value);\n+  }\n+\n+  // Parallel code for random access iterators\n+  template<typename RandomAccessIterator, typename T>\n+  typename iterator_traits<RandomAccessIterator>::difference_type\n+  count_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    typedef typename iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tdifference_type res = 0;\n+\t__gnu_parallel::count_selector<RandomAccessIterator, difference_type> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, value, functionality, std::plus<__gnu_parallel::sequence_index_t>(), res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return count<RandomAccessIterator, T>(begin, end, value, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename T, typename IteratorTag>\n+  typename iterator_traits<InputIterator>::difference_type\n+  count_switch(InputIterator begin, InputIterator end, const T& value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    return count<InputIterator, T>(begin, end, value, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename T>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count(InputIterator begin, InputIterator end, const T& value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    return count_switch(begin, end, value, typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename Predicate>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::count_if(begin, end, pred);\n+  }\n+\n+  // Parallel count_if for random access iterators\n+  template<typename RandomAccessIterator, typename Predicate>\n+  typename iterator_traits<RandomAccessIterator>::difference_type\n+  count_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    typedef typename iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::count_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tdifference_type res = 0;\n+\t__gnu_parallel::count_if_selector<RandomAccessIterator, difference_type> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, pred, functionality, std::plus<__gnu_parallel::sequence_index_t>(), res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return count_if<RandomAccessIterator, Predicate>(begin, end, pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename Predicate, typename IteratorTag>\n+  typename iterator_traits<InputIterator>::difference_type\n+  count_if_switch(InputIterator begin, InputIterator end, Predicate pred, IteratorTag, __gnu_parallel::parallelism)\n+  {\n+    return count_if<InputIterator, Predicate>(begin, end, pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename Predicate>\n+  inline typename iterator_traits<InputIterator>::difference_type\n+  count_if(InputIterator begin, InputIterator end, Predicate pred, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return count_if_switch(begin, end, pred, iterator_category(), parallelism_tag);\n+  }\n+\n+\n+  // Sequential fallback.\n+  template<typename ForwardIterator1, typename ForwardIterator2>\n+  inline ForwardIterator1\n+  search(ForwardIterator1 begin1, ForwardIterator1 end1, ForwardIterator2 begin2, ForwardIterator2 end2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::search(begin1, end1, begin2, end2);\n+  }\n+\n+  // Parallel algorithm for random access iterator\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2>\n+  RandomAccessIterator1\n+  search_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator1> iterator1_traits;\n+    typedef typename iterator1_traits::value_type value1_type;\n+    typedef std::iterator_traits<RandomAccessIterator2> iterator2_traits;\n+    typedef typename iterator2_traits::value_type value2_type;\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      return __gnu_parallel::search_template(begin1, end1, begin2, end2, __gnu_parallel::equal_to<value1_type, value2_type>());\n+    else\n+      return search(begin1, end1, begin2, end2, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator1, typename ForwardIterator2, typename IteratorTag1, typename IteratorTag2>\n+  inline ForwardIterator1\n+  search_switch(ForwardIterator1 begin1, ForwardIterator1 end1, ForwardIterator2 begin2, ForwardIterator2 end2, IteratorTag1, IteratorTag2)\n+  {\n+    return search(begin1, end1, begin2, end2, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator1, typename ForwardIterator2>\n+  inline ForwardIterator1\n+  search(ForwardIterator1 begin1, ForwardIterator1 end1, ForwardIterator2 begin2, ForwardIterator2 end2)\n+  {\n+    typedef std::iterator_traits<ForwardIterator1> iterator1_traits;\n+    typedef typename iterator1_traits::iterator_category iterator1_category;\n+    typedef std::iterator_traits<ForwardIterator2> iterator2_traits;\n+    typedef typename iterator2_traits::iterator_category iterator2_category;\n+\n+    return search_switch(begin1, end1, begin2, end2, iterator1_category(), iterator2_category());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator1, typename ForwardIterator2, typename BinaryPredicate>\n+  inline ForwardIterator1\n+  search(ForwardIterator1 begin1, ForwardIterator1 end1, ForwardIterator2 begin2, ForwardIterator2 end2, BinaryPredicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::search(begin1, end1, begin2, end2, pred);\n+  }\n+\n+  // Parallel algorithm for random access iterator.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename BinaryPredicate>\n+  RandomAccessIterator1\n+  search_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n+\t\tRandomAccessIterator2 begin2, RandomAccessIterator2 end2, BinaryPredicate  pred, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      return __gnu_parallel::search_template(begin1, end1, begin2, end2, pred);\n+    else\n+      return search(begin1, end1, begin2, end2, pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator1, typename ForwardIterator2,\n+\t   typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n+  inline ForwardIterator1\n+  search_switch(ForwardIterator1 begin1, ForwardIterator1 end1,\n+\t\tForwardIterator2 begin2, ForwardIterator2 end2, BinaryPredicate pred, IteratorTag1, IteratorTag2)\n+  {\n+    return search(begin1, end1, begin2, end2, pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename ForwardIterator1, typename ForwardIterator2, typename BinaryPredicate>\n+  inline ForwardIterator1\n+  search(ForwardIterator1 begin1, ForwardIterator1 end1, ForwardIterator2 begin2, ForwardIterator2 end2, BinaryPredicate  pred)\n+  {\n+    typedef std::iterator_traits<ForwardIterator1> iterator1_traits;\n+    typedef typename iterator1_traits::iterator_category iterator1_category;\n+    typedef std::iterator_traits<ForwardIterator2> iterator2_traits;\n+    typedef typename iterator2_traits::iterator_category iterator2_category;\n+    return search_switch(begin1, end1, begin2, end2, pred, iterator1_category(), iterator2_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Integer, typename T>\n+  inline ForwardIterator\n+  search_n(ForwardIterator begin, ForwardIterator end, Integer count, const T& val, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::search_n(begin, end, count, val); }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Integer, typename T, typename BinaryPredicate>\n+  inline ForwardIterator\n+  search_n(ForwardIterator begin, ForwardIterator end, Integer count, const T& val, BinaryPredicate binary_pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::search_n(begin, end, count, val, binary_pred);\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator, typename Integer, typename T>\n+  inline ForwardIterator\n+  search_n(ForwardIterator begin, ForwardIterator end, Integer count, const T& val)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return search_n(begin, end, count, val, __gnu_parallel::equal_to<value_type, T>());\n+  }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename Integer, typename T, typename BinaryPredicate>\n+  RandomAccessIterator\n+  search_n_switch(RandomAccessIterator begin, RandomAccessIterator end, Integer count, const T& val, BinaryPredicate binary_pred, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      {\n+\t__gnu_parallel::pseudo_sequence<T, Integer> ps(val, count);\n+\treturn __gnu_parallel::search_template(begin, end, ps.begin(), ps.end(), binary_pred);\n+      }\n+    else\n+      return std::__search_n(begin, end, count, val, binary_pred, random_access_iterator_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename ForwardIterator, typename Integer, typename T, typename BinaryPredicate, typename IteratorTag>\n+  inline ForwardIterator\n+  search_n_switch(ForwardIterator begin, ForwardIterator end, Integer count, const T& val, BinaryPredicate binary_pred, IteratorTag)\n+  {\n+    return __search_n(begin, end, count, val, binary_pred, IteratorTag());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator, typename Integer, typename T, typename BinaryPredicate>\n+  inline ForwardIterator\n+  search_n(ForwardIterator begin, ForwardIterator end, Integer count, const T& val, BinaryPredicate binary_pred)\n+  {\n+    return search_n_switch(begin, end, count, val, binary_pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator begin, InputIterator end, OutputIterator result, UnaryOperation unary_op, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::transform(begin, end, result, unary_op);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, OutputIterator result, BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::transform(begin1, end1, begin2, result, binary_op);\n+  }\n+\n+  // Parallel unary transform for random access iterators.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename UnaryOperation>\n+  RandomAccessIterator3\n+  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator3 result, UnaryOperation unary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::transform_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy = true;\n+\ttypedef __gnu_parallel::iterator_pair<RandomAccessIterator1, RandomAccessIterator3, random_access_iterator_tag> ip;\n+\tip begin_pair(begin, result), end_pair(end, result + (end - begin));\n+\t__gnu_parallel::transform1_selector<ip> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin_pair, end_pair, unary_op, functionality, __gnu_parallel::dummy_reduct(), dummy, dummy, -1, parallelism_tag);\n+\treturn functionality.finish_iterator;\n+      }\n+    else\n+      return transform(begin, end, result, unary_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename UnaryOperation, typename IteratorTag1, typename IteratorTag2>\n+  inline RandomAccessIterator3\n+  transform1_switch(RandomAccessIterator1 begin, RandomAccessIterator1 end, RandomAccessIterator3 result, UnaryOperation unary_op, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    return _GLIBCXX_STD_P::transform(begin, end, result, unary_op);\n+  }\n+\n+\n+  // Parallel binary transform for random access iterators.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryOperation>\n+  RandomAccessIterator3\n+  transform2_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator3 result, BinaryOperation binary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION((end1 - begin1) >= __gnu_parallel::Settings::transform_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy = true;\n+\ttypedef __gnu_parallel::iterator_triple<RandomAccessIterator1, RandomAccessIterator2, RandomAccessIterator3, random_access_iterator_tag> ip;\n+\tip begin_triple(begin1, begin2, result), end_triple(end1, begin2 + (end1 - begin1), result + (end1 - begin1));\n+\t__gnu_parallel::transform2_selector<ip> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin_triple, end_triple, binary_op, functionality, __gnu_parallel::dummy_reduct(), dummy, dummy, -1, parallelism_tag);\n+\treturn functionality.finish_iterator;\n+      }\n+    else\n+      return transform(begin1, end1, begin2, result, binary_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename BinaryOperation, typename tag1, typename tag2, typename tag3>\n+  inline RandomAccessIterator3\n+  transform2_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator3 result, BinaryOperation binary_op, tag1, tag2, tag3, __gnu_parallel::parallelism)\n+  {\n+    return _GLIBCXX_STD_P::transform(begin1, end1, begin2, result, binary_op);\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename OutputIterator, typename UnaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator begin, InputIterator end, OutputIterator result,\n+\t    UnaryOperation unary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef std::iterator_traits<InputIterator> iteratori_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori_traits::iterator_category iteratori_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return transform1_switch(begin, end, result, unary_op,\n+\t\t\t     iteratori_category(), iteratoro_category(), parallelism_tag);\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, OutputIterator result, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+\n+    return transform2_switch(begin1, end1, begin2, result, binary_op,\n+\t\t\t     iteratori1_category(), iteratori2_category(), iteratoro_category(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename T>\n+  inline void\n+  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::replace(begin, end, old_value, new_value); }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename T, typename IteratorTag>\n+  void\n+  replace_switch(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { replace(begin, end, old_value, new_value, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel replace for random access iterators\n+  template<typename RandomAccessIterator, typename T>\n+  void\n+  replace_switch(RandomAccessIterator begin, RandomAccessIterator end, const T& old_value, const T& new_value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  { replace(begin, end, old_value, new_value, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface\n+  template<typename ForwardIterator, typename T>\n+  inline void\n+  replace(ForwardIterator begin, ForwardIterator end, const T& old_value, const T& new_value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    replace_switch(begin, end, old_value, new_value, typename std::iterator_traits<ForwardIterator>::iterator_category(), parallelism_tag);\n+  }\n+\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Predicate, typename T>\n+  inline void\n+  replace_if(ForwardIterator begin, ForwardIterator end, Predicate pred, const T& new_value, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::replace_if(begin, end, pred, new_value); }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename Predicate, typename T, typename IteratorTag>\n+  void\n+  replace_if_switch(ForwardIterator begin, ForwardIterator end, Predicate pred, const T& new_value, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { replace_if(begin, end, pred, new_value, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename Predicate, typename T>\n+  void\n+  replace_if_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, const T& new_value, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::replace_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy;\n+\t__gnu_parallel::replace_if_selector<RandomAccessIterator, Predicate, T> functionality(new_value);\n+\t__gnu_parallel::for_each_template_random_access(begin, end, pred, functionality, __gnu_parallel::dummy_reduct(), true, dummy, -1, parallelism_tag);\n+      }\n+    else\n+      replace_if(begin, end, pred, new_value, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator, typename Predicate, typename T>\n+  inline void\n+  replace_if(ForwardIterator begin, ForwardIterator end,\n+\t     Predicate pred, const T& new_value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef std::iterator_traits<ForwardIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+\n+    replace_if_switch(begin, end, pred, new_value, iterator_category(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Generator>\n+  inline void\n+  generate(ForwardIterator begin, ForwardIterator end, Generator gen, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::generate<ForwardIterator, Generator>(begin, end, gen); }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename ForwardIterator, typename Generator, typename IteratorTag>\n+  void\n+  generate_switch(ForwardIterator begin, ForwardIterator end, Generator gen, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { generate(begin, end, gen, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename Generator>\n+  void\n+  generate_switch(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t  Generator gen, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::generate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy;\n+\t__gnu_parallel::generate_selector<RandomAccessIterator> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, gen, functionality, __gnu_parallel::dummy_reduct(), true, dummy, -1, parallelism_tag);\n+      }\n+    else\n+      generate(begin, end, gen, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator, typename Generator>\n+  inline void\n+  generate(ForwardIterator begin, ForwardIterator end,\n+\t   Generator gen, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef std::iterator_traits<ForwardIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    generate_switch(begin, end, gen, iterator_category(), parallelism_tag);\n+  }\n+\n+\n+  // Sequential fallback.\n+  template<typename OutputIterator, typename Size, typename Generator>\n+  inline OutputIterator\n+  generate_n(OutputIterator begin, Size n, Generator gen, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::generate_n(begin, n, gen); }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename OutputIterator, typename Size, typename Generator, typename IteratorTag>\n+  OutputIterator\n+  generate_n_switch(OutputIterator begin, Size n, Generator gen, IteratorTag, __gnu_parallel::parallelism)\n+  { return generate_n(begin, n, gen, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename Size, typename Generator>\n+  RandomAccessIterator\n+  generate_n_switch(RandomAccessIterator begin, Size n, Generator gen, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  { return generate_n(begin, n, gen, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface.\n+  template<typename OutputIterator, typename Size, typename Generator>\n+  inline OutputIterator\n+  generate_n(OutputIterator begin, Size n, Generator gen, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  { \n+    typedef std::iterator_traits<OutputIterator> iterator_traits;\n+    typedef typename iterator_traits::iterator_category iterator_category;\n+    return generate_n_switch(begin, n, gen, iterator_category(), parallelism_tag); \n+  }\n+\n+\n+  // Sequential fallback.\n+  template<typename RandomAccessIterator>\n+  inline void\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::random_shuffle(begin, end); }\n+\n+  // Sequential fallback.\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  inline void\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rand, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::random_shuffle(begin, end, rand); }\n+\n+\n+  /** @brief Functor wrapper for std::rand(). */\n+  template<typename must_be_int = int>\n+  struct c_rand_number\n+  {\n+    inline int operator()(int limit)\n+    { return rand() % limit; }\n+  };\n+\n+  // Fill in random number generator.\n+  template<typename RandomAccessIterator>\n+  inline void\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end)\n+  {\n+    c_rand_number<> r;\n+    // Parallelization still possible.\n+    random_shuffle(begin, end, r);\n+  }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  void\n+  random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rand)\n+  {\n+    if (begin == end)\n+      return;\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::random_shuffle_minimal_n))\n+      __gnu_parallel::parallel_random_shuffle(begin, end, rand);\n+    else\n+      __gnu_parallel::sequential_random_shuffle(begin, end, rand);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename ForwardIterator, typename Predicate>\n+  inline ForwardIterator\n+  partition(ForwardIterator begin, ForwardIterator end, Predicate pred, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::partition(begin, end, pred); }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename ForwardIterator, typename Predicate, typename IteratorTag>\n+  inline ForwardIterator\n+  partition_switch(ForwardIterator begin, ForwardIterator end, Predicate pred, IteratorTag)\n+  { return partition(begin, end, pred, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator, typename Predicate>\n+  RandomAccessIterator\n+  partition_switch(RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::partition_minimal_n))\n+      {\n+\ttypedef typename std::iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+\tdifference_type middle = __gnu_parallel::parallel_partition(begin, end, pred, __gnu_parallel::get_max_threads());\n+\treturn begin + middle;\n+      }\n+    else\n+      return partition(begin, end, pred, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename ForwardIterator, typename Predicate>\n+  inline ForwardIterator\n+  partition(ForwardIterator begin, ForwardIterator end, Predicate pred)\n+  {\n+    return partition_switch(begin, end, pred, typename std::iterator_traits<ForwardIterator>::iterator_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename RandomAccessIterator>\n+  inline void\n+  sort(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::sort<RandomAccessIterator>(begin, end); }\n+\n+  // Sequential fallback\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::sort<RandomAccessIterator, Comparator>(begin, end, comp); }\n+\n+  // Public interface, insert default comparator\n+  template<typename RandomAccessIterator>\n+  inline void\n+  sort(RandomAccessIterator begin, RandomAccessIterator end)\n+  {\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    sort(begin, end, std::less<value_type>());\n+  }\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  void\n+  sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp)\n+  {\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    if (begin != end)\n+      {\n+\tif (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::sort_minimal_n))\n+\t  __gnu_parallel::parallel_sort(begin, end, comp, false);\n+\telse\n+\t  sort<RandomAccessIterator, Comparator>(begin, end, comp, __gnu_parallel::sequential_tag());\n+      }\n+  }\n+\n+  // Sequential fallback.\n+  template<typename RandomAccessIterator>\n+  inline void\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::stable_sort<RandomAccessIterator>(begin, end);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::stable_sort<RandomAccessIterator, Comparator>(begin, end, comp);\n+  }\n+\n+  template<typename RandomAccessIterator>\n+  void\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end)\n+  {\n+    typedef iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    stable_sort(begin, end, std::less<value_type>());\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator, typename Comparator>\n+  void\n+  stable_sort(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp)\n+  {\n+    if (begin != end)\n+      {\n+\tif (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::sort_minimal_n))\n+\t  __gnu_parallel::parallel_sort(begin, end, comp, true);\n+\telse\n+\t  stable_sort<RandomAccessIterator, Comparator>(begin, end, comp, __gnu_parallel::sequential_tag());\n+      }\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result,\n+\t__gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n+  inline OutputIterator\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp,\n+\t__gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline OutputIterator\n+  merge_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp, IteratorTag1, IteratorTag2, IteratorTag3)\n+  {\n+    return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, comp);\n+  }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n+  OutputIterator\n+  merge_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION((static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1) >= __gnu_parallel::Settings::merge_minimal_n || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2) >= __gnu_parallel::Settings::merge_minimal_n)))\n+      return __gnu_parallel::parallel_merge_advance(begin1, end1, begin2, end2, result, (end1 - begin1) + (end2 - begin2), comp);\n+    else\n+      return __gnu_parallel::merge_advance(begin1, end1, begin2, end2, result, (end1 - begin1) + (end2 - begin2), comp);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Comparator>\n+  inline OutputIterator\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result, Comparator comp)\n+  {\n+    typedef typename iterator_traits<InputIterator1>::value_type value_type;\n+\n+    typedef std::iterator_traits<InputIterator1> iteratori1_traits;\n+    typedef std::iterator_traits<InputIterator2> iteratori2_traits;\n+    typedef std::iterator_traits<OutputIterator> iteratoro_traits;\n+    typedef typename iteratori1_traits::iterator_category iteratori1_category;\n+    typedef typename iteratori2_traits::iterator_category iteratori2_category;\n+    typedef typename iteratoro_traits::iterator_category iteratoro_category;\n+\n+    return merge_switch(begin1, end1, begin2, end2, result, comp, iteratori1_category(), iteratori2_category(), iteratoro_category());\n+  }\n+\n+\n+  // Public interface, insert default comparator\n+  template<typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+  inline OutputIterator\n+  merge(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, OutputIterator result)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iterator1_traits;\n+    typedef std::iterator_traits<InputIterator2> iterator2_traits;\n+    typedef typename iterator1_traits::value_type value1_type;\n+    typedef typename iterator2_traits::value_type value2_type;\n+\n+    return merge(begin1, end1, begin2, end2, result, __gnu_parallel::less<value1_type, value2_type>());\n+  }\n+\n+  // Sequential fallback\n+  template<typename RandomAccessIterator>\n+  inline void\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::nth_element(begin, nth, end); }\n+\n+  // Sequential fallback\n+  template<typename RandomAccessIterator, typename Comparator>\n+  void\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::nth_element(begin, nth, end, comp); }\n+\n+  // Public interface\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::nth_element_minimal_n))\n+      __gnu_parallel::parallel_nth_element(begin, nth, end, comp);\n+    else\n+      nth_element(begin, nth, end, comp, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface, insert default comparator\n+  template<typename RandomAccessIterator>\n+  void\n+  nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end)\n+  {\n+    typedef typename iterator_traits<RandomAccessIterator>::value_type value_type;\n+    nth_element(begin, nth, end, std::less<value_type>());\n+  }\n+\n+  // Sequential fallback\n+  template<typename _RandomAccessIterator, typename _Compare>\n+  void\n+  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, _Compare comp, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::partial_sort(begin, middle, end, comp); }\n+\n+  // Sequential fallback\n+  template<typename _RandomAccessIterator>\n+  void\n+  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, __gnu_parallel::sequential_tag)\n+  { _GLIBCXX_STD_P::partial_sort(begin, middle, end); }\n+\n+  // Public interface, parallel algorithm for random access iterators\n+  template<typename _RandomAccessIterator, typename _Compare>\n+  void\n+  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end, _Compare comp)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::partial_sort_minimal_n))\n+      __gnu_parallel::parallel_partial_sort(begin, middle, end, comp);\n+    else\n+      partial_sort(begin, middle, end, comp, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface, insert default comparator\n+  template<typename _RandomAccessIterator>\n+  void\n+  partial_sort(_RandomAccessIterator begin, _RandomAccessIterator middle, _RandomAccessIterator end)\n+  {\n+    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n+    partial_sort(begin, middle, end, std::less<value_type>());\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::max_element(begin, end); }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::max_element(begin, end, comp); }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename Comparator, typename IteratorTag>\n+  ForwardIterator\n+  max_element_switch(ForwardIterator begin, ForwardIterator end, Comparator comp, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { return max_element(begin, end, comp, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface, insert default comparator\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return max_element(begin, end, std::less<value_type>(), parallelism_tag);\n+  }\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  RandomAccessIterator\n+  max_element_switch(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::max_element_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tRandomAccessIterator res(begin);\n+\t__gnu_parallel::identity_selector<RandomAccessIterator> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, __gnu_parallel::nothing(), functionality, __gnu_parallel::max_element_reduct<Comparator, RandomAccessIterator>(comp), res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return max_element(begin, end, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  max_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    return max_element_switch(begin, end, comp, typename std::iterator_traits<ForwardIterator>::iterator_category(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator>\n+  inline\n+  ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::min_element(begin, end); }\n+\n+  // Sequential fallback\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::min_element(begin, end, comp); }\n+\n+  // Public interface\n+  template<typename ForwardIterator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, __gnu_parallel::parallelism parallelism_tag  = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef typename iterator_traits<ForwardIterator>::value_type value_type;\n+    return min_element(begin, end, std::less<value_type>(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename ForwardIterator, typename Comparator, typename IteratorTag>\n+  ForwardIterator\n+  min_element_switch(ForwardIterator begin, ForwardIterator end, Comparator comp, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { return min_element(begin, end, comp, __gnu_parallel::sequential_tag()); }\n+\n+  // Parallel algorithm for random access iterators\n+  template<typename RandomAccessIterator, typename Comparator>\n+  RandomAccessIterator\n+  min_element_switch(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::min_element_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tRandomAccessIterator res(begin);\n+\t__gnu_parallel::identity_selector<RandomAccessIterator> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, __gnu_parallel::nothing(), functionality, __gnu_parallel::min_element_reduct<Comparator, RandomAccessIterator>(comp), res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return min_element(begin, end, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface\n+  template<typename ForwardIterator, typename Comparator>\n+  inline ForwardIterator\n+  min_element(ForwardIterator begin, ForwardIterator end, Comparator comp, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef iterator_traits<ForwardIterator> traits_type;\n+    typedef typename traits_type::iterator_category iterator_category;\n+    return min_element_switch(begin, end, comp, iterator_category(), parallelism_tag);\n+  }\n+} // end namespace\n+} // end namespace\n+\n+#endif /* _GLIBCXX_ALGORITHM_H */\n+"}, {"sha": "0bd8b39afccbdbedd783a18255d226dabd1e57a5", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,256 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/algobase.h\n+ *  @brief Parallel STL function calls corresponding to the\n+ *  stl_algobase.h header.  The functions defined here mainly do case\n+ *  switches and call the actual parallelized versions in other files.\n+ *  Inlining policy: Functions that basically only contain one\n+ *  function call, are declared inline.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_ALGOBASE_H\n+#define _GLIBCXX_PARALLEL_ALGOBASE_H 1\n+\n+#include <parallel/algorithmfwd.h>\n+#include <bits/stl_algobase.h>\n+#include <parallel/base.h>\n+#include <parallel/tags.h>\n+#include <parallel/settings.h>\n+#include <parallel/find.h>\n+#include <parallel/find_selectors.h>\n+#include <parallel/for_each.h>\n+#include <parallel/for_each_selectors.h>\n+\n+namespace std\n+{\n+namespace __parallel\n+{\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline bool\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::equal<InputIterator1, InputIterator2>(begin1, end1, begin2);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline bool\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::equal(begin1, end1, begin2, pred); }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline bool\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n+  { return mismatch(begin1, end1, begin2).first == end1; }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline bool\n+  equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred)\n+  { return mismatch(begin1, end1, begin2, pred).first == end1; }\n+\n+  // NB: lexicographical_compare equires mismatch.\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline pair<InputIterator1, InputIterator2>\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::mismatch<InputIterator1, InputIterator2>(begin1, end1, begin2);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline pair<InputIterator1, InputIterator2>\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline pair<InputIterator1, InputIterator2>\n+  mismatch_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, Predicate pred, IteratorTag1, IteratorTag2)\n+  { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+\n+  // Parallel mismatch for random access iterators\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n+  pair<RandomAccessIterator1, RandomAccessIterator2>\n+  mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      {\n+\tRandomAccessIterator1 res_first =\n+\t  __gnu_parallel::find_template(begin1, end1, begin2, pred, __gnu_parallel::mismatch_selector()).first;\n+\treturn make_pair(res_first, begin2 + (res_first - begin1));\n+      }\n+    else\n+      return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline pair<InputIterator1, InputIterator2>\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iterator1_traits;\n+    typedef std::iterator_traits<InputIterator2> iterator2_traits;\n+    typedef typename iterator1_traits::value_type value1_type;\n+    typedef typename iterator2_traits::value_type value2_type;\n+    typedef typename iterator1_traits::iterator_category iterator1_category;\n+    typedef typename iterator2_traits::iterator_category iterator2_category;\n+\n+    return mismatch_switch(begin1, end1, begin2, __gnu_parallel::equal_to<value1_type, value2_type>(), iterator1_category(), iterator2_category());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline pair<InputIterator1, InputIterator2>\n+  mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+\t   Predicate pred)\n+  {\n+    typedef std::iterator_traits<InputIterator1> iterator1_traits;\n+    typedef std::iterator_traits<InputIterator2> iterator2_traits;\n+    typedef typename iterator1_traits::iterator_category iterator1_category;\n+    typedef typename iterator2_traits::iterator_category iterator2_category;\n+\n+    return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), iterator2_category());\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline bool\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::lexicographical_compare<InputIterator1, InputIterator2>(begin1, end1, begin2, end2);\n+  }\n+\n+  // Sequential fallback\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline bool\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+  }\n+\n+  // Sequential fallback for input iterator case\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline bool\n+  lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred, IteratorTag1, IteratorTag2)\n+  {\n+    return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+  }\n+\n+  // Parallel lexicographical_compare for random access iterators\n+  // Limitation: Both valuetypes must be the same\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Predicate>\n+  bool\n+  lexicographical_compare_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, RandomAccessIterator2 end2, Predicate pred, random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(true))\n+      {\n+\ttypedef iterator_traits<RandomAccessIterator1> traits1_type;\n+\ttypedef typename traits1_type::value_type value1_type;\n+\n+\ttypedef iterator_traits<RandomAccessIterator2> traits2_type;\n+\ttypedef typename traits2_type::value_type value2_type;\n+\t\n+\ttypedef __gnu_parallel::equal_from_less<Predicate, value1_type, value2_type> equal_type;\n+\n+\t// Longer sequence in first place.\n+\tif ((end1 - begin1) < (end2 - begin2))\n+\t  {\n+\t    typedef pair<RandomAccessIterator1, RandomAccessIterator2> pair_type;\n+\t    pair_type mm = mismatch_switch(begin1, end1, begin2, equal_type(pred), random_access_iterator_tag(), random_access_iterator_tag());\n+\n+\t    // Less because shorter.\n+\t    const bool lbs = mm.first == end1;\n+\n+\t    // Less because differing elements less.\n+\t    const bool lbdel = pred(*mm.first, *mm.second);\n+\n+\t    return lbs || lbdel;\n+\t  }\n+\telse\n+\t  {\n+\t    typedef pair<RandomAccessIterator2, RandomAccessIterator1> pair_type;\n+\t    pair_type mm = mismatch_switch(begin2, end2, begin1, equal_type(pred), random_access_iterator_tag(), random_access_iterator_tag());\n+\n+\t    // Less because shorter.\n+\t    const bool lbs = mm.first != end2;\n+\n+\t    // Less because differing element less.\n+\t    const bool lbdel = pred(*mm.second, *mm.first);\n+\n+\t    return lbs && lbdel;\n+\t  }\n+      }\n+    else\n+      return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2>\n+  inline bool\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2)\n+  {\n+    typedef iterator_traits<InputIterator1> traits1_type;\n+    typedef typename traits1_type::value_type value1_type;\n+    typedef typename traits1_type::iterator_category iterator1_category;\n+    \n+    typedef iterator_traits<InputIterator2> traits2_type;\n+    typedef typename traits2_type::value_type value2_type;\n+    typedef typename traits2_type::iterator_category iterator2_category;\n+    typedef __gnu_parallel::less<value1_type, value2_type> less_type;\n+\n+    return lexicographical_compare_switch(begin1, end1, begin2, end2, less_type(), iterator1_category(), iterator2_category());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator1, typename InputIterator2, typename Predicate>\n+  inline bool\n+  lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Predicate pred)\n+  {\n+    typedef iterator_traits<InputIterator1> traits1_type;\n+    typedef typename traits1_type::iterator_category iterator1_category;\n+    \n+    typedef iterator_traits<InputIterator2> traits2_type;\n+    typedef typename traits2_type::iterator_category iterator2_category;\n+\n+    return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, iterator1_category(), iterator2_category());\n+  }\n+} // end namespace\n+} // end namespace\n+\n+#endif /* _GLIBCXX_ALGOBASE_H */"}, {"sha": "0672e372eb9db87611096d547239ed5f21db6e2c", "filename": "libstdc++-v3/include/parallel/algorithm", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithm?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,45 @@\n+// Algorithm extensions -*- C++ -*-\n+\n+// Copyright (C) 2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file parallel/algorithm\n+ *  This file is a GNU extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _PARALLEL_ALGORITHM\n+#define _PARALLEL_ALGORITHM 1\n+\n+#pragma GCC system_header\n+\n+#include <algorithm>\n+#include <parallel/algorithmfwd.h>\n+#include <parallel/algobase.h>\n+#include <parallel/algo.h>\n+\n+#endif"}, {"sha": "319091904cd767ed15bd373715966700a53081f2", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "added", "additions": 719, "deletions": 0, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,719 @@\n+// <algorithm> parallel extensions -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/algorithmfwd.h\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PARALLEL_ALGORITHMFWD_H\n+#define _GLIBCXX_PARALLEL_ALGORITHMFWD_H 1\n+\n+#pragma GCC system_header\n+\n+#include <parallel/tags.h>\n+#include <parallel/settings.h>\n+\n+namespace std\n+{\n+namespace __parallel\n+{\n+  template<typename _FIter>\n+  inline _FIter\n+  adjacent_find(_FIter, _FIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename BinaryPredicate>\n+  inline _FIter\n+  adjacent_find(_FIter, _FIter, BinaryPredicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter>\n+  inline _FIter\n+  adjacent_find(_FIter, _FIter);\n+\n+  template<typename _FIter, typename BinaryPredicate>\n+  inline _FIter\n+  adjacent_find(_FIter, _FIter, BinaryPredicate);\n+\n+  template<typename _RAIter>\n+  _RAIter\n+  adjacent_find_switch(_RAIter, _RAIter, random_access_iterator_tag);\n+\n+  template<typename _FIter, typename IteratorTag>\n+  inline _FIter\n+  adjacent_find_switch(_FIter, _FIter, IteratorTag);\n+\n+  template<typename _FIter, typename BinaryPredicate, typename IteratorTag>\n+  inline _FIter\n+  adjacent_find_switch(_FIter, _FIter, BinaryPredicate, IteratorTag);\n+\n+  template<typename _RAIter, typename BinaryPredicate>\n+  _RAIter\n+  adjacent_find_switch(_RAIter, _RAIter, BinaryPredicate, random_access_iterator_tag);\n+\n+\n+  template<typename _IIter, typename T>\n+  inline typename iterator_traits<_IIter>::difference_type\n+  count(_IIter, _IIter, const T& value, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename T>\n+  inline typename iterator_traits<_IIter>::difference_type\n+  count(_IIter, _IIter, const T& value, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _RAIter, typename T>\n+  typename iterator_traits<_RAIter>::difference_type\n+  count_switch(_RAIter, _RAIter, const T& value, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename T, typename IteratorTag>\n+  typename iterator_traits<_IIter>::difference_type\n+  count_switch(_IIter, _IIter, const T& value, IteratorTag, __gnu_parallel::parallelism);\n+\n+\n+  template<typename _IIter, typename Predicate>\n+  inline typename iterator_traits<_IIter>::difference_type\n+  count_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename Predicate>\n+  inline typename iterator_traits<_IIter>::difference_type\n+  count_if(_IIter, _IIter, Predicate, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _RAIter, typename Predicate>\n+  typename iterator_traits<_RAIter>::difference_type\n+  count_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename Predicate, typename IteratorTag>\n+  typename iterator_traits<_IIter>::difference_type\n+  count_if_switch(_IIter, _IIter, Predicate, IteratorTag, __gnu_parallel::parallelism);\n+\n+  // algobase.h\n+  template<typename _IIter1, typename _IIter2>\n+  inline bool\n+  equal(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline bool\n+  equal(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2>\n+  inline bool\n+  equal(_IIter1, _IIter1, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline bool\n+  equal(_IIter1, _IIter1, _IIter2, Predicate);\n+\n+  template<typename _IIter, typename T>\n+  inline _IIter\n+  find(_IIter, _IIter, const T&, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename T>\n+  inline _IIter\n+  find(_IIter, _IIter, const T& val);\n+\n+  template<typename _IIter, typename T, typename IteratorTag>\n+  inline _IIter\n+  find_switch(_IIter, _IIter, const T&, IteratorTag);\n+\n+  template<typename _RAIter, typename T>\n+  _RAIter\n+  find_switch(_RAIter, _RAIter, const T&, random_access_iterator_tag);\n+\n+  template<typename _IIter, typename Predicate>\n+  inline _IIter\n+  find_if(_IIter, _IIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename Predicate>\n+  inline _IIter\n+  find_if (_IIter, _IIter, Predicate);\n+\n+  template<typename _IIter, typename Predicate, typename IteratorTag>\n+  inline _IIter\n+  find_if_switch(_IIter, _IIter, Predicate, IteratorTag);\n+\n+  template<typename _RAIter, typename Predicate>\n+  _RAIter\n+  find_if_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n+\n+  template<typename _IIter, typename _FIter>\n+  inline _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _FIter, typename BinaryPredicate>\n+  inline _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter, BinaryPredicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _FIter, typename BinaryPredicate>\n+  inline _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter, BinaryPredicate);\n+\n+  template<typename _IIter, typename _FIter>\n+  _IIter\n+  find_first_of(_IIter, _IIter, _FIter, _FIter);\n+\n+  template<typename _IIter, typename _FIter, typename IteratorTag1, typename IteratorTag2>\n+  inline _IIter\n+  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, IteratorTag1, IteratorTag2);\n+\n+  template<typename _RAIter, typename _FIter, typename BinaryPredicate, typename IteratorTag>\n+  inline _RAIter\n+  find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, BinaryPredicate, random_access_iterator_tag, IteratorTag);\n+\n+  template<typename _IIter, typename _FIter, typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n+  inline _IIter\n+  find_first_of_switch(_IIter, _IIter, _FIter, _FIter, BinaryPredicate, IteratorTag1, IteratorTag2);\n+\n+\n+  template<typename _IIter, typename Function>\n+  inline Function\n+  for_each(_IIter, _IIter, Function f, __gnu_parallel::sequential_tag);\n+\n+  template<typename Iterator, typename Function>\n+  inline Function\n+  for_each(Iterator, Iterator, Function f, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _IIter, typename Function, typename IteratorTag>\n+  Function\n+  for_each_switch(_IIter, _IIter, Function f, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename Function>\n+  Function\n+  for_each_switch(_RAIter, _RAIter, Function f, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename Generator>\n+  inline void\n+  generate(_FIter, _FIter, Generator, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename Generator>\n+  inline void\n+  generate(_FIter, _FIter, Generator, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename Generator, typename IteratorTag>\n+  void\n+  generate_switch(_FIter, _FIter, Generator, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename Generator>\n+  void\n+  generate_switch(_RAIter, _RAIter, Generator, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _OIter, typename Size, typename Generator>\n+  inline _OIter\n+  generate_n(_OIter, Size, Generator, __gnu_parallel::sequential_tag);\n+\n+  template<typename _OIter, typename Size, typename Generator>\n+  inline _OIter\n+  generate_n(_OIter, Size, Generator, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _OIter, typename Size, typename Generator, typename IteratorTag>\n+  _OIter\n+  generate_n_switch(_OIter, Size, Generator, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename Size, typename Generator>\n+  _RAIter\n+  generate_n_switch(_RAIter, Size, Generator, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter1, typename _IIter2>\n+  inline bool\n+  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline bool\n+  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2>\n+  inline bool\n+  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline bool\n+  lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline bool\n+  lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2, Predicate, IteratorTag1, IteratorTag2);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Predicate>\n+  bool\n+  lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  // algo.h\n+  template<typename _IIter1, typename _IIter2>\n+  inline pair<_IIter1, _IIter2>\n+  mismatch(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline pair<_IIter1, _IIter2>\n+  mismatch(_IIter1, _IIter1, _IIter2, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2>\n+  inline pair<_IIter1, _IIter2>\n+  mismatch(_IIter1, _IIter1, _IIter2);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  inline pair<_IIter1, _IIter2>\n+  mismatch(_IIter1, _IIter1, _IIter2, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline pair<_IIter1, _IIter2>\n+  mismatch_switch(_IIter1, _IIter1, _IIter2, Predicate, IteratorTag1, IteratorTag2);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Predicate>\n+  pair<_RAIter1, _RAIter2>\n+  mismatch_switch(_RAIter1, _RAIter1, _RAIter2, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _FIter1, typename _FIter2>\n+  inline _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter1, typename _FIter2>\n+  inline _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2);\n+\n+  template<typename _FIter1, typename _FIter2, typename BinaryPredicate>\n+  inline _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter1, typename _FIter2, typename BinaryPredicate>\n+  inline _FIter1\n+  search(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate);\n+\n+  template<typename _RAIter1, typename _RAIter2>\n+  _RAIter1\n+  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _FIter1, typename _FIter2, typename IteratorTag1, typename IteratorTag2>\n+  inline _FIter1\n+  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, IteratorTag1, IteratorTag2);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename BinaryPredicate>\n+  _RAIter1\n+  search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, BinaryPredicate , random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _FIter1, typename _FIter2, typename BinaryPredicate, typename IteratorTag1, typename IteratorTag2>\n+  inline _FIter1\n+  search_switch(_FIter1, _FIter1, _FIter2, _FIter2, BinaryPredicate, IteratorTag1, IteratorTag2);\n+\n+  template<typename _FIter, typename Integer, typename T>\n+  inline _FIter\n+  search_n(_FIter, _FIter, Integer, const T&, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate>\n+  inline _FIter\n+  search_n(_FIter, _FIter, Integer, const T&, BinaryPredicate, __gnu_parallel::sequential_tag);\n+    \n+  template<typename _FIter, typename Integer, typename T>\n+  inline _FIter\n+  search_n(_FIter, _FIter, Integer, const T& val);\n+\n+  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate>\n+  inline _FIter\n+  search_n(_FIter, _FIter, Integer, const T&, BinaryPredicate);\n+\n+  template<typename _RAIter, typename Integer, typename T, typename BinaryPredicate>\n+  _RAIter\n+  search_n_switch(_RAIter, _RAIter, Integer, const T&, BinaryPredicate, random_access_iterator_tag);\n+\n+  template<typename _FIter, typename Integer, typename T, typename BinaryPredicate, typename IteratorTag>\n+  inline _FIter\n+  search_n_switch(_FIter, _FIter, Integer, const T&, BinaryPredicate, IteratorTag);\n+\n+\n+  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+  inline _OIter\n+  transform(_IIter, _IIter, _OIter, UnaryOperation, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename BinaryOperation>\n+  inline _OIter\n+  transform(_IIter1, _IIter1, _IIter2, _OIter, BinaryOperation binary_op, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+  inline _OIter\n+  transform(_IIter, _IIter, _OIter, UnaryOperation, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename BinaryOperation>\n+  inline _OIter\n+  transform(_IIter1, _IIter1, _IIter2, _OIter, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _RAIter1, typename _RAIter3, typename UnaryOperation>\n+  _RAIter3\n+  transform1_switch(_RAIter1, _RAIter1, _RAIter3, UnaryOperation, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _RAIter1, typename _RAIter3, typename UnaryOperation, typename IteratorTag1, typename IteratorTag2>\n+  inline _RAIter3\n+  transform1_switch(_RAIter1, _RAIter1, _RAIter3, UnaryOperation, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+    \n+  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename BinaryOperation>\n+  _RAIter3\n+  transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, BinaryOperation binary_op, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename _RAIter3, typename BinaryOperation, typename tag1, typename tag2, typename tag3>\n+  inline _RAIter3\n+  transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, BinaryOperation binary_op, tag1, tag2, tag3, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter, typename T>\n+  inline void\n+  replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename T>\n+  inline void\n+  replace(_FIter, _FIter, const T&, const T&, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename T, typename IteratorTag>\n+  void\n+  replace_switch(_FIter, _FIter, const T&, const T&, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename T>\n+  void\n+  replace_switch(_RAIter, _RAIter, const T&, const T&, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+\n+  template<typename _FIter, typename Predicate, typename T>\n+  inline void\n+  replace_if(_FIter, _FIter, Predicate, const T&, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename Predicate, typename T>\n+  inline void\n+  replace_if(_FIter, _FIter, Predicate, const T&, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename Predicate, typename T, typename IteratorTag>\n+  void\n+  replace_if_switch(_FIter, _FIter, Predicate, const T&, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename Predicate, typename T>\n+  void\n+  replace_if_switch(_RAIter, _RAIter, Predicate, const T&, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _FIter>\n+  inline _FIter\n+  max_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename _Compare>\n+  inline _FIter\n+  max_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter>\n+  inline _FIter\n+  max_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename _Compare>\n+  inline _FIter\n+  max_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename _Compare, typename IteratorTag>\n+  _FIter\n+  max_element_switch(_FIter, _FIter, _Compare, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename _Compare>\n+  _RAIter\n+  max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  inline _OIter\n+  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  inline _OIter\n+  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline _OIter\n+  merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, IteratorTag1, IteratorTag2, IteratorTag3);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare>\n+  _OIter\n+  merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _FIter>\n+  inline _FIter\n+  min_element(_FIter, _FIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter, typename _Compare>\n+  inline _FIter\n+  min_element(_FIter, _FIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _FIter>\n+  inline _FIter\n+  min_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag  = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename _Compare>\n+  inline _FIter\n+  min_element(_FIter, _FIter, _Compare, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _FIter, typename _Compare, typename IteratorTag>\n+  _FIter\n+  min_element_switch(_FIter, _FIter, _Compare, IteratorTag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter, typename _Compare>\n+  _RAIter\n+  min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter>\n+  inline void\n+  nth_element(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename _Compare>\n+  void\n+  nth_element(_RAIter, _RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename _Compare>\n+  inline void\n+  nth_element(_RAIter, _RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+  void\n+  nth_element(_RAIter, _RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+  void\n+  partial_sort(_RAIter, _RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter>\n+  void\n+  partial_sort(_RAIter, _RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename _Compare>\n+  void\n+  partial_sort(_RAIter, _RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+  void\n+  partial_sort(_RAIter, _RAIter, _RAIter);\n+\n+  template<typename _FIter, typename Predicate>\n+  inline _FIter\n+  partition(_FIter, _FIter, Predicate, __gnu_parallel::sequential_tag);\n+    \n+  template<typename _FIter, typename Predicate>\n+  inline _FIter\n+  partition(_FIter, _FIter, Predicate);\n+\n+  template<typename _FIter, typename Predicate, typename IteratorTag>\n+  inline _FIter\n+  partition_switch(_FIter, _FIter, Predicate, IteratorTag);\n+    \n+  template<typename _RAIter, typename Predicate>\n+  _RAIter\n+  partition_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n+\n+  template<typename _RAIter>\n+  inline void\n+  random_shuffle(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename RandomNumberGenerator>\n+  inline void\n+  random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter>\n+  inline void\n+  random_shuffle(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename RandomNumberGenerator>\n+  void\n+  random_shuffle(_RAIter, _RAIter, RandomNumberGenerator& rand);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter\n+  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter \n+  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter \n+  set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline _OIter \n+  set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n+  Output_RAIter \n+  set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter\n+  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter \n+  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter \n+  set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline _OIter \n+  set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n+  Output_RAIter \n+  set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter\n+  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter \n+  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter \n+  set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline _OIter \n+  set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n+  Output_RAIter \n+  set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter\n+  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter>\n+  inline _OIter\n+  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);\n+\n+  template<typename _IIter1, typename _IIter2, typename _OIter, typename Predicate>\n+  inline _OIter\n+  set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate);\n+\n+  template<typename _IIter1, typename _IIter2, typename Predicate, typename _OIter, typename IteratorTag1, typename IteratorTag2, typename IteratorTag3>\n+  inline _OIter\n+  set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate, IteratorTag1, IteratorTag2, IteratorTag3);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename Output_RAIter, typename Predicate>\n+  Output_RAIter\n+  set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, Output_RAIter, Predicate, random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag);\n+\n+\n+  template<typename _RAIter>\n+  inline void\n+  sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename _Compare>\n+  inline void\n+  sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter>\n+  inline void\n+  sort(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+  void\n+  sort(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _RAIter>\n+  inline void\n+  stable_sort(_RAIter, _RAIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter, typename _Compare>\n+  inline void\n+  stable_sort(_RAIter, _RAIter, _Compare, __gnu_parallel::sequential_tag);\n+\n+  template<typename _RAIter>\n+  void\n+  stable_sort(_RAIter, _RAIter);\n+\n+  template<typename _RAIter, typename _Compare>\n+  void\n+  stable_sort(_RAIter, _RAIter, _Compare);\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  unique_copy(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter, typename Predicate>\n+  inline _OIter\n+  unique_copy(_IIter, _IIter, _OIter, Predicate, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  unique_copy(_IIter, _IIter, _OIter);\n+\n+  template<typename _IIter, typename _OIter, typename Predicate>\n+  inline _OIter\n+  unique_copy(_IIter, _IIter, _OIter, Predicate);\n+\n+  template<typename _IIter, typename _OIter, typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  inline _OIter\n+  unique_copy_switch(_IIter, _IIter, _OIter, Predicate, IteratorTag1, IteratorTag2);\n+\n+  template<typename _RAIter, typename RandomAccess_OIter, typename Predicate>\n+  RandomAccess_OIter\n+  unique_copy_switch(_RAIter, _RAIter, RandomAccess_OIter, Predicate, random_access_iterator_tag, random_access_iterator_tag);\n+} // end namespace __parallel\n+} // end namespace std\n+\n+// NB: cannot use _GLIBCXX_STD_P directly here, as it is both scoped\n+// (std::__norm) and unscoped (std::).\n+namespace __gnu_sequential\n+{\n+#ifdef _GLIBCXX_PARALLEL\n+  using std::__norm::partition;\n+  using std::__norm::sort;\n+  using std::__norm::stable_sort;\n+  using std::__norm::random_shuffle;\n+#else\n+  using std::partition;\n+  using std::sort;\n+  using std::stable_sort;\n+  using std::random_shuffle;    \n+#endif    \n+}\n+\n+#endif"}, {"sha": "94b0e8cd6c6bcbb6caaf7946699fc7142f9cbd05", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,451 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/balanced_quicksort.h\n+ *  @brief Implementation of a dynamically load-balanced parallel quicksort.\n+ *\n+ *  It works in-place and needs only logarithmic extra memory.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_BAL_QUICKSORT_H\n+#define _GLIBCXX_PARALLEL_BAL_QUICKSORT_H 1\n+\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_algo.h>\n+\n+#include <parallel/settings.h>\n+#include <parallel/partition.h>\n+#include <parallel/random_number.h>\n+#include <parallel/queue.h>\n+#include <functional>\n+\n+#if _GLIBCXX_ASSERTIONS\n+#include <parallel/checkers.h>\n+#endif\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Information local to one thread in the parallel quicksort run. */\n+  template<typename RandomAccessIterator>\n+  struct QSBThreadLocal\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    /** @brief Continuous part of the sequence, described by an\n+\titerator pair. */\n+    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+\n+    /** @brief Initial piece to work on. */\n+    Piece initial;\n+\n+    /** @brief Work-stealing queue. */\n+    RestrictedBoundedConcurrentQueue<Piece> leftover_parts;\n+\n+    /** @brief Number of threads involved in this algorithm. */\n+    thread_index_t num_threads;\n+\n+    /** @brief Pointer to a counter of elements left over to sort. */\n+    volatile difference_type* elements_leftover;\n+\n+    /** @brief The complete sequence to sort. */\n+    Piece global;\n+\n+    /** @brief Constructor.\n+     *  @param queue_size Size of the work-stealing queue. */\n+    QSBThreadLocal(int queue_size) : leftover_parts(queue_size) { }\n+  };\n+\n+  /** @brief Initialize the thread local storage.\n+   *  @param tls Array of thread-local storages.\n+   *  @param queue_size Size of the work-stealing queue. */\n+  template<typename RandomAccessIterator>\n+  inline void\n+  qsb_initialize(QSBThreadLocal<RandomAccessIterator>** tls, int queue_size)\n+  {\n+    int iam = omp_get_thread_num();\n+    tls[iam] = new QSBThreadLocal<RandomAccessIterator>(queue_size);\n+  }\n+\n+\n+  /** @brief Balanced quicksort divide step.\n+   *  @param begin Begin iterator of subsequence.\n+   *  @param end End iterator of subsequence.\n+   *  @param comp Comparator.\n+   *  @param num_threads Number of threads that are allowed to work on\n+   *  this part.\n+   *  @pre @c (end-begin)>=1 */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n+  qsb_divide(RandomAccessIterator begin, RandomAccessIterator end,\n+\t     Comparator comp, int num_threads)\n+  {\n+    _GLIBCXX_PARALLEL_ASSERT(num_threads > 0);\n+\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    RandomAccessIterator pivot_pos = median_of_three_iterators(begin, begin + (end - begin) / 2, end  - 1, comp);\n+\n+#if defined(_GLIBCXX_ASSERTIONS)\n+    // Must be in between somewhere.\n+    difference_type n = end - begin;\n+\n+    _GLIBCXX_PARALLEL_ASSERT((!comp(*pivot_pos, *begin) && !comp(*(begin + n / 2), *pivot_pos))\n+\t   || (!comp(*pivot_pos, *begin) && !comp(*end, *pivot_pos))\n+\t   || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*begin, *pivot_pos))\n+\t   || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*end, *pivot_pos))\n+\t   || (!comp(*pivot_pos, *end) && !comp(*begin, *pivot_pos))\n+\t   || (!comp(*pivot_pos, *end) && !comp(*(begin + n / 2), *pivot_pos)));\n+#endif\n+\n+    // Swap pivot value to end.\n+    if (pivot_pos != (end - 1))\n+      std::swap(*pivot_pos, *(end - 1));\n+    pivot_pos = end - 1;\n+\n+    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+\n+    // Divide, returning end - begin - 1 in the worst case.\n+    difference_type split_pos = parallel_partition(begin, end - 1, pred, num_threads);\n+\n+    // Swap back pivot to middle.\n+    std::swap(*(begin + split_pos), *pivot_pos);\n+    pivot_pos = begin + split_pos;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    RandomAccessIterator r;\n+    for (r = begin; r != pivot_pos; r++)\n+      _GLIBCXX_PARALLEL_ASSERT(comp(*r, *pivot_pos));\n+    for (; r != end; r++)\n+      _GLIBCXX_PARALLEL_ASSERT(!comp(*r, *pivot_pos));\n+#endif\n+\n+    return split_pos;\n+  }\n+\n+  /** @brief Quicksort conquer step.\n+   *  @param tls Array of thread-local storages.\n+   *  @param begin Begin iterator of subsequence.\n+   *  @param end End iterator of subsequence.\n+   *  @param comp Comparator.\n+   *  @param iam Number of the thread processing this function.\n+   *  @param num_threads Number of threads that are allowed to work on this part. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  qsb_conquer(QSBThreadLocal<RandomAccessIterator>** tls,\n+\t      RandomAccessIterator begin, RandomAccessIterator end,\n+\t      Comparator comp, thread_index_t iam, thread_index_t num_threads)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type n = end - begin;\n+\n+    if (num_threads <= 1 || n < 2)\n+      {\n+\ttls[iam]->initial.first  = begin;\n+\ttls[iam]->initial.second = end;\n+\n+\tqsb_local_sort_with_helping(tls, comp, iam);\n+\n+\treturn;\n+      }\n+\n+    // Divide step.\n+    difference_type split_pos = qsb_divide(begin, end, comp, num_threads);\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(0 <= split_pos && split_pos < (end - begin));\n+#endif\n+\n+    thread_index_t num_threads_leftside = std::max<thread_index_t>(1, std::min<thread_index_t>(num_threads - 1, split_pos * num_threads / n));\n+\n+#pragma omp atomic\n+    *tls[iam]->elements_leftover -= (difference_type)1;\n+\n+    // Conquer step.\n+#pragma omp parallel sections num_threads(2)\n+    {\n+#pragma omp section\n+      qsb_conquer(tls, begin, begin + split_pos, comp, iam, num_threads_leftside);\n+      // The pivot_pos is left in place, to ensure termination.\n+#pragma omp section\n+      qsb_conquer(tls, begin + split_pos + 1, end, comp,\n+\t\t  iam + num_threads_leftside, num_threads - num_threads_leftside);\n+    }\n+  }\n+\n+  /** \n+   *  @brief Quicksort step doing load-balanced local sort.\n+   *  @param tls Array of thread-local storages.\n+   *  @param comp Comparator.\n+   *  @param iam Number of the thread processing this function. \n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  qsb_local_sort_with_helping(QSBThreadLocal<RandomAccessIterator>** tls,\n+\t\t\t      Comparator& comp, int iam)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+\n+    QSBThreadLocal<RandomAccessIterator>& tl = *tls[iam];\n+\n+    difference_type base_case_n = Settings::sort_qsb_base_case_maximal_n;\n+    if (base_case_n < 2)\n+      base_case_n = 2;\n+    thread_index_t num_threads = tl.num_threads;\n+\n+    // Every thread has its own random number generator.\n+    random_number rng(iam + 1);\n+\n+    Piece current = tl.initial;\n+\n+    difference_type elements_done = 0;\n+#if _GLIBCXX_ASSERTIONS\n+    difference_type total_elements_done = 0;\n+#endif\n+\n+    for (;;)\n+      {\n+\t// Invariant: current must be a valid (maybe empty) range.\n+\tRandomAccessIterator begin = current.first, end = current.second;\n+\tdifference_type n = end - begin;\n+\n+\tif (n > base_case_n)\n+\t  {\n+\t    // Divide.\n+\t    RandomAccessIterator pivot_pos = begin +  rng(n);\n+\n+\t    // Swap pivot_pos value to end.\n+\t    if (pivot_pos != (end - 1))\n+\t      std::swap(*pivot_pos, *(end - 1));\n+\t    pivot_pos = end - 1;\n+\n+\t    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+\n+\t    // Divide, leave pivot unchanged in last place.\n+\t    RandomAccessIterator split_pos1, split_pos2;\n+\t    split_pos1 = __gnu_sequential::partition(begin, end - 1, pred);\n+\n+\t    // Left side: < pivot_pos; right side: >= pivot_pos.\n+#if _GLIBCXX_ASSERTIONS\n+\t    _GLIBCXX_PARALLEL_ASSERT(begin <= split_pos1 && split_pos1 < end);\n+#endif\n+\t    // Swap pivot back to middle.\n+\t    if (split_pos1 != pivot_pos)\n+\t      std::swap(*split_pos1, *pivot_pos);\n+\t    pivot_pos = split_pos1;\n+\n+\t    // In case all elements are equal, split_pos1 == 0.\n+\t    if ((split_pos1 + 1 - begin) < (n >> 7)\n+\t\t|| (end - split_pos1) < (n >> 7))\n+\t      {\n+\t\t// Very unequal split, one part smaller than one 128th\n+\t\t// elements not stricly larger than the pivot.\n+\t\t__gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n+\n+\t\t// Find other end of pivot-equal range.\n+\t\tsplit_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Only skip the pivot.\n+\t\tsplit_pos2 = split_pos1 + 1;\n+\t      }\n+\n+\t    // Elements equal to pivot are done.\n+\t    elements_done += (split_pos2 - split_pos1);\n+#if _GLIBCXX_ASSERTIONS\n+\t    total_elements_done += (split_pos2 - split_pos1);\n+#endif\n+\t    // Always push larger part onto stack.\n+\t    if (((split_pos1 + 1) - begin) < (end - (split_pos2)))\n+\t      {\n+\t\t// Right side larger.\n+\t\tif ((split_pos2) != end)\n+\t\t  tl.leftover_parts.push_front(std::make_pair(split_pos2, end));\n+\n+\t\t//current.first = begin;\t//already set anyway\n+\t\tcurrent.second = split_pos1;\n+\t\tcontinue;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Left side larger.\n+\t\tif (begin != split_pos1)\n+\t\t  tl.leftover_parts.push_front(std::make_pair(begin, split_pos1));\n+\n+\t\tcurrent.first = split_pos2;\n+\t\t//current.second = end;\t//already set anyway\n+\t\tcontinue;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    __gnu_sequential::sort(begin, end, comp);\n+\t    elements_done += n;\n+#if _GLIBCXX_ASSERTIONS\n+\t    total_elements_done += n;\n+#endif\n+\n+\t    // Prefer own stack, small pieces.\n+\t    if (tl.leftover_parts.pop_front(current))\n+\t      continue;\n+\n+#pragma omp atomic\n+\t    *tl.elements_leftover -= elements_done;\n+\t    elements_done = 0;\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    double search_start = omp_get_wtime();\n+#endif\n+\n+\t    // Look for new work.\n+\t    bool success = false;\n+\t    while (*tl.elements_leftover > 0 && !success\n+#if _GLIBCXX_ASSERTIONS\n+\t\t   // Possible dead-lock.\n+\t\t   && (omp_get_wtime() < (search_start + 1.0))\n+#endif\n+\t\t   )\n+\t      {\n+\t\tthread_index_t victim;\n+\t\tvictim = rng(num_threads);\n+\n+\t\t// Large pieces.\n+\t\tsuccess = (victim != iam) && tls[victim]->leftover_parts.pop_back(current);\n+\t\tif (!success)\n+\t\t  yield();\n+#if !defined(__ICC) && !defined(__ECC)\n+#pragma omp flush\n+#endif\n+\t      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    if (omp_get_wtime() >= (search_start + 1.0))\n+\t      {\n+\t\tsleep(1);\n+\t\t_GLIBCXX_PARALLEL_ASSERT(omp_get_wtime() < (search_start + 1.0));\n+\t      }\n+#endif\n+\t    if (!success)\n+\t      {\n+#if _GLIBCXX_ASSERTIONS\n+\t\t_GLIBCXX_PARALLEL_ASSERT(*tl.elements_leftover == 0);\n+#endif\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /** @brief Top-level quicksort routine.\n+   *  @param begin Begin iterator of sequence.\n+   *  @param end End iterator of sequence.\n+   *  @param comp Comparator.\n+   *  @param n Length of the sequence to sort.\n+   *  @param num_threads Number of threads that are allowed to work on\n+   *  this part.\n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort_qsb(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t    Comparator comp,\n+\t\t    typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+\n+    typedef QSBThreadLocal<RandomAccessIterator> tls_type;\n+\n+    if (n <= 1)\n+      return;\n+\n+    // At least one element per processor.\n+    if (num_threads > n)\n+      num_threads = static_cast<thread_index_t>(n);\n+\n+    tls_type** tls = new tls_type*[num_threads];\n+\n+#pragma omp parallel num_threads(num_threads)\n+    // Initialize variables per processor.\n+    qsb_initialize(tls, num_threads * (thread_index_t)(log2(n) + 1));\n+\n+    // There can never be more than ceil(log2(n)) ranges on the stack, because\n+    // 1. Only one processor pushes onto the stack\n+    // 2. The largest range has at most length n\n+    // 3. Each range is larger than half of the range remaining\n+    volatile difference_type elements_leftover = n;\n+    for (int i = 0; i < num_threads; i++)\n+      {\n+\ttls[i]->elements_leftover = &elements_leftover;\n+\ttls[i]->num_threads = num_threads;\n+\ttls[i]->global = std::make_pair(begin, end);\n+\n+\t// Just in case nothing is left to assign.\n+\ttls[i]->initial = std::make_pair(end, end);\n+      }\n+\n+    // Initial splitting, recursively.\n+    int old_nested = omp_get_nested();\n+    omp_set_nested(true);\n+\n+    // Main recursion call.\n+    qsb_conquer(tls, begin, begin + n, comp, 0, num_threads);\n+\n+    omp_set_nested(old_nested);\n+\n+#if _GLIBCXX_ASSERTIONS\n+    // All stack must be empty.\n+    Piece dummy;\n+    for (int i = 1; i < num_threads; i++)\n+      _GLIBCXX_PARALLEL_ASSERT(!tls[i]->leftover_parts.pop_back(dummy));\n+#endif\n+\n+    for (int i = 0; i < num_threads; i++)\n+      delete tls[i];\n+    delete[] tls;\n+  }\n+} // namespace __gnu_parallel\n+\n+#endif"}, {"sha": "117292ba44bbeb4a05e30c81e0d5f0d17dae80e5", "filename": "libstdc++-v3/include/parallel/base.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,358 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/base.h\n+ *  @brief Sequential helper functions.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_BASE_H\n+#define _GLIBCXX_PARALLEL_BASE_H 1\n+\n+#include <parallel/features.h>\n+#include <functional>\n+#include <parallel/basic_iterator.h>\n+#include <parallel/parallel.h>\n+#include <cstdio>\n+\n+namespace __gnu_parallel\n+{\n+  // XXX remove std::duplicates from here if possible,\n+  // XXX but keep minimal dependencies.\n+\n+  /** @brief Calculates the rounded-down logrithm of @c n for base 2.\n+   *  @param n Argument.\n+   *  @return Returns 0 for argument 0.\n+   */\n+  template<typename Size> \n+    inline Size \n+    log2(Size n)\n+    {\n+      Size k;\n+      for (k = 0; n != 1; n >>= 1)\n+\t++k;\n+      return k;\n+    }\n+\n+  /** @brief Encode two integers into one __gnu_parallel::lcas_t.\n+   *  @param a First integer, to be encoded in the most-significant @c\n+   *  lcas_t_bits/2 bits.\n+   *  @param b Second integer, to be encoded in the least-significant\n+   *  @c lcas_t_bits/2 bits.\n+   *  @return __gnu_parallel::lcas_t value encoding @c a and @c b.\n+   *  @see decode2 \n+   */\n+  inline lcas_t\n+  encode2(int a, int b)\t//must all be non-negative, actually\n+  {\n+    return (((lcas_t)a) << (lcas_t_bits / 2)) | (((lcas_t)b) << 0);\n+  }\n+\n+  /** @brief Decode two integers from one __gnu_parallel::lcas_t.\n+   *  @param x __gnu_parallel::lcas_t to decode integers from.\n+   *  @param a First integer, to be decoded from the most-significant\n+   *  @c lcas_t_bits/2 bits of @c x.\n+   *  @param b Second integer, to be encoded in the least-significant\n+   *  @c lcas_t_bits/2 bits of @c x.\n+   *  @see encode2\n+   */\n+  inline void\n+  decode2(lcas_t x, int& a, int& b)\n+  {\n+    a = (int)((x >> (lcas_t_bits / 2)) & lcas_t_mask);\n+    b = (int)((x >>               0 ) & lcas_t_mask);\n+  }\n+\n+  /** @brief Constructs predicate for equality from strict weak\n+   *  ordering predicate\n+   */\n+  // XXX comparator at the end, as per others\n+  template<typename Comparator, typename T1, typename T2>\n+  class equal_from_less : public std::binary_function<T1, T2, bool>\n+  {\n+  private:\n+    Comparator& comp;\n+\n+  public:\n+    equal_from_less(Comparator& _comp) : comp(_comp) { }\n+\n+    bool operator()(const T1& a, const T2& b)\n+    {\n+      // FIXME: wrong in general (T1 != T2)\n+      return !comp(a, b) && !comp(b, a);\n+    }\n+  };\n+\n+\n+  /** @brief Similar to std::equal_to, but allows two different types. */\n+  template<typename T1, typename T2>\n+  struct equal_to : std::binary_function<T1, T2, bool>\n+  {\n+    bool operator()(const T1& t1, const T2& t2) const\n+    { return t1 == t2; }\n+  };\n+\n+  /** @brief Similar to std::binder1st, but giving the argument types explicitly. */\n+  template<typename _Predicate, typename argument_type>\n+    class unary_negate\n+    : public std::unary_function<argument_type, bool>\n+    {\n+    protected:\n+      _Predicate _M_pred;\n+\n+    public:\n+      explicit\n+      unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n+\n+      bool\n+      operator()(const argument_type& __x)\n+      { return !_M_pred(__x); }\n+    };\n+\n+  /** @brief Similar to std::binder1st, but giving the argument types explicitly. */\n+  template<typename _Operation, typename first_argument_type, typename second_argument_type, typename result_type>\n+    class binder1st\n+    : public std::unary_function<second_argument_type, result_type>\n+    {\n+    protected:\n+      _Operation op;\n+      first_argument_type value;\n+\n+    public:\n+      binder1st(const _Operation& __x,\n+\t\tconst first_argument_type& __y)\n+      : op(__x), value(__y) { }\n+\n+      result_type\n+      operator()(const second_argument_type& __x)\n+      { return op(value, __x); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      result_type\n+      operator()(second_argument_type& __x) const\n+      { return op(value, __x); }\n+    };\n+\n+  /** @brief Similar to std::binder2nd, but giving the argument types explicitly. */\n+  template<typename _Operation, typename first_argument_type, typename second_argument_type, typename result_type>\n+    class binder2nd\n+    : public std::unary_function<first_argument_type, result_type>\n+    {\n+    protected:\n+      _Operation op;\n+      second_argument_type value;\n+\n+    public:\n+      binder2nd(const _Operation& __x,\n+\t\tconst second_argument_type& __y)\n+      : op(__x), value(__y) { }\n+\n+      result_type\n+      operator()(const first_argument_type& __x) const\n+      { return op(__x, value); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 109.  Missing binders for non-const sequence elements\n+      result_type\n+      operator()(first_argument_type& __x)\n+      { return op(__x, value); }\n+    };\n+\n+  /** @brief Similar to std::less, but allows two different types. */\n+  template<typename T1, typename T2>\n+  struct less : std::binary_function<T1, T2, bool>\n+  {\n+    bool operator()(const T1& t1, const T2& t2) const\n+    { return t1 < t2; }\n+  };\n+\n+\n+  template<typename T, typename _DifferenceTp>\n+  class pseudo_sequence;\n+\n+  /** @brief Iterator associated with __gnu_parallel::pseudo_sequence.\n+   *  If features the usual random-access iterator functionality.\n+   *  @param T Sequence value type.\n+   *  @param difference_type Sequence difference type. \n+   */\n+  template<typename T, typename _DifferenceTp>\n+  class pseudo_sequence_iterator\n+  {\n+  public:\n+    typedef _DifferenceTp difference_type;\n+\n+  private:\n+    typedef pseudo_sequence_iterator<T, _DifferenceTp> type;\n+\n+    const T& val;\n+    difference_type pos;\n+\n+  public:\n+    pseudo_sequence_iterator(const T& val, difference_type pos)\n+    : val(val), pos(pos) { }\n+\n+    // Pre-increment operator.\n+    type&\n+    operator++()\n+    {\n+      ++pos;\n+      return *this;\n+    }\n+\n+    // Post-increment operator.\n+    const type\n+    operator++(int)\n+    { return type(pos++); }\n+\n+    const T& \n+    operator*() const\n+    { return val; }\n+\n+    const T& \n+    operator[](difference_type) const\n+    { return val; }\n+\n+    bool \n+    operator==(const type& i2)\n+    { return pos == i2.pos; }\n+\n+    difference_type \n+    operator!=(const type& i2)\n+    { return pos != i2.pos; }\n+\n+    difference_type \n+    operator-(const type& i2)\n+    { return pos - i2.pos; }\n+  };\n+\n+  /** @brief Sequence that conceptually consists of multiple copies of\n+      the same element.\n+   *  The copies are not stored explicitly, of course.\n+   *  @param T Sequence value type.\n+   *  @param difference_type Sequence difference type. \n+   */\n+  template<typename T, typename _DifferenceTp>\n+  class pseudo_sequence\n+  {\n+    typedef pseudo_sequence<T, _DifferenceTp> type;\n+\n+  public:\n+    typedef _DifferenceTp difference_type;\n+    typedef pseudo_sequence_iterator<T, uint64> iterator;\t//better case down to uint64, than up to _DifferenceTp\n+\n+    /** @brief Constructor.\n+     *  @param val Element of the sequence.\n+     *  @param count Number of (virtual) copies.\n+     */\n+    pseudo_sequence(const T& val, difference_type count) \n+    : val(val), count(count)  { }\n+\n+    /** @brief Begin iterator. */\n+    iterator\n+    begin() const\n+    { return iterator(val, 0); }\n+\n+    /** @brief End iterator. */\n+    iterator\n+    end() const\n+    { return iterator(val, count); }\n+\n+  private:\n+    const T& val;\n+    difference_type count;\n+  };\n+\n+  /** @brief Functor that does nothing */\n+  template<typename _ValueTp>\n+  class void_functor\n+  {\n+    inline void \n+    operator()(const _ValueTp& v) const { }\n+  };\n+\n+  /** @brief Compute the median of three referenced elements,\n+      according to @c comp.\n+   *  @param a First iterator.\n+   *  @param b Second iterator.\n+   *  @param c Third iterator.\n+   *  @param comp Comparator. \n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  RandomAccessIterator\n+  median_of_three_iterators(RandomAccessIterator a, RandomAccessIterator b, \n+\t\t\t    RandomAccessIterator c, Comparator& comp)\n+  {\n+    if (comp(*a, *b))\n+      if (comp(*b, *c))\n+\treturn b;\n+      else\n+\tif (comp(*a, *c))\n+\t  return c;\n+\telse\n+\t  return a;\n+    else\n+      {\n+\t// Just swap a and b.\n+\tif (comp(*a, *c))\n+\t  return a;\n+\telse\n+\t  if (comp(*b, *c))\n+\t    return c;\n+\t  else\n+\t    return b;\n+      }\n+  }\n+\n+  // Avoid the use of assert, because we're trying to keep the <cassert>\n+  // include out of the mix. (Same as debug mode).\n+  inline void\n+  __replacement_assert(const char* __file, int __line, \n+\t\t       const char* __function, const char* __condition)\n+  {\n+    std::printf(\"%s:%d: %s: Assertion '%s' failed.\\n\", __file, __line,\n+\t\t__function, __condition);\n+    __builtin_abort();\n+  }\n+  \n+#define _GLIBCXX_PARALLEL_ASSERT(_Condition)                            \\\n+  do \t\t\t\t\t\t\t\t        \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!(_Condition))\t\t\t\t\t\t\\\n+\t__gnu_parallel::__replacement_assert(__FILE__, __LINE__,\t\\\n+\t\t\t\t    __PRETTY_FUNCTION__, #_Condition);\t\\\n+    } while (false)\n+  \n+} //namespace __gnu_parallel\n+\n+#endif\n+"}, {"sha": "4b891be80b249ea3fd8ee0c23d0d48a09c5c78d0", "filename": "libstdc++-v3/include/parallel/basic_iterator.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbasic_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbasic_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbasic_iterator.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,48 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/basic_iterator.h\n+ *  @brief Includes the original header files concerned with iterators\n+ *  except for stream iterators.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_BASIC_ITERATOR_H\n+#define _GLIBCXX_PARALLEL_BASIC_ITERATOR_H 1\n+\n+#include <bits/c++config.h>\n+#include <cstddef>\n+#include <bits/stl_iterator_base_types.h>\n+#include <bits/stl_iterator_base_funcs.h>\n+#include <bits/stl_iterator.h>\n+\n+#endif /* _GLIBCXX_BASIC_ITERATOR_H */"}, {"sha": "b34ee0519272a6ba8cef2468854beb2f97d02e7b", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,148 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/checkers.h\n+ *  @brief Routines for checking the correctness of algorithm results.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_CHECKERS\n+#define _GLIBCXX_PARALLEL_CHECKERS 1\n+\n+#include <functional>\n+#include <cstdio>\n+#include <bits/stl_algobase.h>\n+\n+namespace __gnu_parallel\n+{\n+  /**\n+   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n+   * @param begin Begin iterator of sequence.\n+   * @param end End iterator of sequence.\n+   * @param comp Comparator.\n+   * @return @c true if sorted, @c false otherwise.\n+   */\n+  // XXX Comparator default template argument\n+  template<typename InputIterator, typename Comparator>\n+  bool\n+  is_sorted(InputIterator begin, InputIterator end, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n+  {\n+    if (begin == end)\n+      return true;\n+\n+    InputIterator current(begin), recent(begin);\n+\n+    unsigned long long position = 1;\n+    for (current++; current != end; current++)\n+      {\n+\tif (comp(*current, *recent))\n+\t  {\n+\t    printf(\"is_sorted: check failed before position %i.\\n\", position);\n+\t    return false;\n+\t  }\n+\trecent = current;\n+\tposition++;\n+      }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n+   * Prints the position in case an misordered pair is found.\n+   * @param begin Begin iterator of sequence.\n+   * @param end End iterator of sequence.\n+   * @param first_failure The first failure is returned in this variable.\n+   * @param comp Comparator.\n+   * @return @c true if sorted, @c false otherwise.\n+   */\n+  // XXX Comparator default template argument\n+  template<typename InputIterator, typename Comparator>\n+  bool\n+  is_sorted_failure(InputIterator begin, InputIterator end, InputIterator& first_failure, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n+  {\n+    if (begin == end)\n+      return true;\n+\n+    InputIterator current(begin), recent(begin);\n+\n+    unsigned long long position = 1;\n+    for (current++; current != end; current++)\n+      {\n+\tif (comp(*current, *recent))\n+\t  {\n+\t    first_failure = current;\n+\t    printf(\"is_sorted: check failed before position %lld.\\n\", position);\n+\t    return false;\n+\t  }\n+\trecent = current;\n+\tposition++;\n+      }\n+\n+    first_failure = end;\n+    return true;\n+  }\n+\n+  /**\n+   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n+   * Prints all misordered pair, including the surrounding two elements.\n+   * @param begin Begin iterator of sequence.\n+   * @param end End iterator of sequence.\n+   * @param comp Comparator.\n+   * @return @c true if sorted, @c false otherwise.\n+   */\n+  template<typename InputIterator, typename Comparator>\n+  bool\n+  // XXX Comparator default template argument\n+  is_sorted_print_failures(InputIterator begin, InputIterator end, Comparator comp = std::less<typename std::iterator_traits<InputIterator>::value_type>())\n+  {\n+    if (begin == end)\n+      return true;\n+\n+    InputIterator recent(begin);\n+    bool ok = true;\n+\n+    for (InputIterator pos(begin + 1); pos != end; pos++)\n+      {\n+\tif (comp(*pos, *recent))\n+\t  {\n+\t    printf(\"%ld: %d %d %d %d\\n\", pos - begin, *(pos - 2),\n+\t\t   *(pos- 1), *pos, *(pos + 1));\n+\t    ok = false;\n+\t  }\n+\trecent = pos;\n+      }\n+    return ok;\n+  }\n+}\n+\n+#endif"}, {"sha": "ec0c05318856afd0aaa16dbd63e032437cdc6b23", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,338 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/compatibility.h\n+ *  @brief Compatibility layer, mostly concerned with atomic operations.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_COMPATIBILITY_H\n+#define _GLIBCXX_PARALLEL_COMPATIBILITY_H 1\n+\n+#include <parallel/types.h>\n+#include <parallel/base.h>\n+\n+#if defined(__SUNPRO_CC) && defined(__sparc)\n+#include <sys/atomic.h>\n+#endif\n+\n+#if !defined(_WIN32)\n+#include <sched.h>\n+#endif\n+\n+#if defined(_MSC_VER)\n+#include <Windows.h>\n+#include <intrin.h>\n+#undef max\n+#undef min\n+#endif\n+\n+namespace __gnu_parallel\n+{\n+#if defined(__ICC)\n+  template<typename must_be_int = int>\n+  int32 faa32(int32* x, int32 inc)\n+  {\n+    asm volatile(\"lock xadd %0,%1\"\n+\t\t : \"=r\" (inc), \"=m\" (*x)\n+\t\t : \"0\" (inc)\n+\t\t : \"memory\");\n+    return inc;\n+  }\n+#if defined(__x86_64)\n+  template<typename must_be_int = int>\n+  int64 faa64(int64* x, int64 inc)\n+  {\n+    asm volatile(\"lock xadd %0,%1\"\n+\t\t : \"=r\" (inc), \"=m\" (*x)\n+\t\t : \"0\" (inc)\n+\t\t : \"memory\");\n+    return inc;\n+  }\n+#endif\n+#endif\n+\n+  // atomic functions only work on integers\n+\n+  /** @brief Add a value to a variable, atomically.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to a 32-bit signed integer.\n+   *  @param addend Value to add.\n+   */\n+  inline int32\n+  fetch_and_add_32(volatile int32* ptr, int32 addend)\n+  {\n+#if defined(__ICC)\t//x86 version\n+    return _InterlockedExchangeAdd((void*)ptr, addend);\n+#elif defined(__ECC)\t//IA-64 version\n+    return _InterlockedExchangeAdd((void*)ptr, addend);\n+#elif defined(__ICL) || defined(_MSC_VER)\n+    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(ptr), addend);\n+#elif defined(__GNUC__)\n+    return __sync_fetch_and_add(ptr, addend);\n+#elif defined(__SUNPRO_CC) && defined(__sparc)\n+    volatile int32 before, after;\n+    do\n+      {\n+\tbefore = *ptr;\n+\tafter = before + addend;\n+      } while (atomic_cas_32((volatile unsigned int*)ptr, before, after) != before);\n+    return before;\n+#else\t//fallback, slow\n+#pragma message(\"slow fetch_and_add_32\")\n+    int32 res;\n+#pragma omp critical\n+    {\n+      res = *ptr;\n+      *(ptr) += addend;\n+    }\n+    return res;\n+#endif\n+  }\n+\n+  /** @brief Add a value to a variable, atomically.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to a 64-bit signed integer.\n+   *  @param addend Value to add.\n+   */\n+  inline int64\n+  fetch_and_add_64(volatile int64* ptr, int64 addend)\n+  {\n+#if defined(__ICC) && defined(__x86_64)\t//x86 version\n+    return faa64<int>((int64*)ptr, addend);\n+#elif defined(__ECC)\t//IA-64 version\n+    return _InterlockedExchangeAdd64((void*)ptr, addend);\n+#elif defined(__ICL) || defined(_MSC_VER)\n+#ifndef _WIN64\n+    _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n+    return 0;\n+#else\n+    return _InterlockedExchangeAdd64(ptr, addend);\n+#endif\n+#elif defined(__GNUC__) && defined(__x86_64)\n+    return __sync_fetch_and_add(ptr, addend);\n+#elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n+  (defined(__i686) || defined(__pentium4) || defined(__athlon))\n+    return __sync_fetch_and_add(ptr, addend);\n+#elif defined(__SUNPRO_CC) && defined(__sparc)\n+    volatile int64 before, after;\n+    do\n+      {\n+\tbefore = *ptr;\n+\tafter = before + addend;\n+      } while (atomic_cas_64((volatile unsigned long long*)ptr, before, after) != before);\n+    return before;\n+#else\t//fallback, slow\n+#if defined(__GNUC__) && defined(__i386)\n+    // XXX doesn't work with -march=native\n+    //#warning \"please compile with -march=i686 or better\"\n+#endif\n+#pragma message(\"slow fetch_and_add_64\")\n+    int64 res;\n+#pragma omp critical\n+    {\n+      res = *ptr;\n+      *(ptr) += addend;\n+    }\n+    return res;\n+#endif\n+  }\n+\n+  /** @brief Add a value to a variable, atomically.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to a signed integer.\n+   *  @param addend Value to add.\n+   */\n+  template<typename T>\n+  inline T\n+  fetch_and_add(volatile T* ptr, T addend)\n+  {\n+    if (sizeof(T) == sizeof(int32))\n+      return (T)fetch_and_add_32((volatile int32*) ptr, (int32)addend);\n+    else if (sizeof(T) == sizeof(int64))\n+      return (T)fetch_and_add_64((volatile int64*) ptr, (int64)addend);\n+    else\n+      _GLIBCXX_PARALLEL_ASSERT(false);\n+  }\n+\n+\n+#if defined(__ICC)\n+\n+  template<typename must_be_int = int>\n+  inline int32\n+  cas32(volatile int32* ptr, int32 old, int32 nw)\n+  {\n+    int32 before;\n+    __asm__ __volatile__(\"lock; cmpxchgl %1,%2\"\n+\t\t\t : \"=a\"(before)\n+\t\t\t : \"q\"(nw), \"m\"(*(volatile long long*)(ptr)), \"0\"(old)\n+\t\t\t : \"memory\");\n+    return before;\n+  }\n+\n+#if defined(__x86_64)\n+  template<typename must_be_int = int>\n+  inline int64\n+  cas64(volatile int64 *ptr, int64 old, int64 nw)\n+  {\n+    int64 before;\n+    __asm__ __volatile__(\"lock; cmpxchgq %1,%2\"\n+\t\t\t : \"=a\"(before)\n+\t\t\t : \"q\"(nw), \"m\"(*(volatile long long*)(ptr)), \"0\"(old)\n+\t\t\t : \"memory\");\n+    return before;\n+  }\n+#endif\n+\n+#endif\n+\n+  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n+   * *ptr=replacement and return @c true, return @c false otherwise.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to 32-bit signed integer.\n+   *  @param comparand Compare value.\n+   *  @param replacement Replacement value.\n+   */\n+  inline bool\n+  compare_and_swap_32(volatile int32* ptr, int32 comparand, int32 replacement)\n+  {\n+#if defined(__ICC)\t//x86 version\n+    return _InterlockedCompareExchange((void*)ptr, replacement, comparand) == comparand;\n+#elif defined(__ECC)\t//IA-64 version\n+    return _InterlockedCompareExchange((void*)ptr, replacement, comparand) == comparand;\n+#elif defined(__ICL) || defined(_MSC_VER)\n+    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(ptr), replacement, comparand) == comparand;\n+#elif defined(__GNUC__)\n+    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+#elif defined(__SUNPRO_CC) && defined(__sparc)\n+    return atomic_cas_32((volatile unsigned int*)ptr, comparand, replacement) == comparand;\n+#else\n+#pragma message(\"slow compare_and_swap_32\")\n+    bool res = false;\n+#pragma omp critical\n+    {\n+      if (*ptr == comparand)\n+\t{\n+\t  *ptr = replacement;\n+\t  res = true;\n+\t}\n+    }\n+    return res;\n+#endif\n+  }\n+\n+  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n+   * *ptr=replacement and return @c true, return @c false otherwise.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to 64-bit signed integer.\n+   *  @param comparand Compare value.\n+   *  @param replacement Replacement value.\n+   */\n+  inline bool\n+  compare_and_swap_64(volatile int64* ptr, int64 comparand, int64 replacement)\n+  {\n+#if defined(__ICC) && defined(__x86_64)\t//x86 version\n+    return cas64<int>(ptr, comparand, replacement) == comparand;\n+#elif defined(__ECC)\t//IA-64 version\n+    return _InterlockedCompareExchange64((void*)ptr, replacement, comparand) == comparand;\n+#elif defined(__ICL) || defined(_MSC_VER)\n+#ifndef _WIN64\n+    _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n+    return 0;\n+#else\n+    return _InterlockedCompareExchange64(ptr, replacement, comparand) == comparand;\n+#endif\n+\n+#elif defined(__GNUC__) && defined(__x86_64)\n+    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+#elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n+  (defined(__i686) || defined(__pentium4) || defined(__athlon))\n+    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+#elif defined(__SUNPRO_CC) && defined(__sparc)\n+    return atomic_cas_64((volatile unsigned long long*)ptr, comparand, replacement) == comparand;\n+#else\n+#if defined(__GNUC__) && defined(__i386)\n+    // XXX -march=native\n+    //#warning \"please compile with -march=i686 or better\"\n+#endif\n+#pragma message(\"slow compare_and_swap_64\")\n+    bool res = false;\n+#pragma omp critical\n+    {\n+      if (*ptr == comparand)\n+\t{\n+\t  *ptr = replacement;\n+\t  res = true;\n+\t}\n+    }\n+    return res;\n+#endif\n+  }\n+\n+  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n+   * *ptr=replacement and return @c true, return @c false otherwise.\n+   *\n+   *  Implementation is heavily platform-dependent.\n+   *  @param ptr Pointer to signed integer.\n+   *  @param comparand Compare value.\n+   *  @param replacement Replacement value. */\n+  template<typename T>\n+  inline bool\n+  compare_and_swap(volatile T* ptr, T comparand, T replacement)\n+  {\n+    if (sizeof(T) == sizeof(int32))\n+      return compare_and_swap_32((volatile int32*) ptr, (int32)comparand, (int32)replacement);\n+    else if (sizeof(T) == sizeof(int64))\n+      return compare_and_swap_64((volatile int64*) ptr, (int64)comparand, (int64)replacement);\n+    else\n+      _GLIBCXX_PARALLEL_ASSERT(false);\n+  }\n+\n+  /** @brief Yield the control to another thread, without waiting for\n+      the end to the time slice. */\n+  inline void\n+  yield()\n+  {\n+#ifdef _WIN32\n+    Sleep(0);\n+#else\n+    sched_yield();\n+#endif\n+  }\n+} // end namespace\n+\n+#endif"}, {"sha": "6278e44837abe42f31137846422368065d570cfa", "filename": "libstdc++-v3/include/parallel/compiletime_settings.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,76 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/compiletime_settings.h\n+ *  @brief Defines on options concerning debugging and performance, at\n+ *  compile-time.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#include <cstdio>\n+\n+/** @brief Determine verbosity level of the parallel mode.\n+ *  Level 1 prints a message each time when entering a parallel-mode function. */\n+#define _GLIBCXX_VERBOSE_LEVEL 0\n+\n+/** @def _GLIBCXX_CALL\n+ *  @brief Macro to produce log message when entering a function.\n+ *  @param n Input size.\n+ *  @see _GLIBCXX_VERBOSE_LEVEL */\n+#if (_GLIBCXX_VERBOSE_LEVEL == 0)\n+#define _GLIBCXX_CALL(n)\n+#endif\n+#if (_GLIBCXX_VERBOSE_LEVEL == 1)\n+#define _GLIBCXX_CALL(n) printf(\"   %s:\\niam = %d, n = %ld, num_threads = %d\\n\", __PRETTY_FUNCTION__, omp_get_thread_num(), (n), get_max_threads());\n+#endif\n+\n+/** @brief Use floating-point scaling instead of modulo for mapping\n+ *  random numbers to a range.  This can be faster on certain CPUs. */\n+#define _GLIBCXX_SCALE_DOWN_FPU 0\n+\n+/** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n+ *  Should be switched on only locally. */\n+#define _GLIBCXX_ASSERTIONS 0\n+\n+/** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n+ *  Consider the size of the L1 cache for __gnu_parallel::parallel_random_shuffle(). */\n+#define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1 0\n+/** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n+ *  Consider the size of the TLB for __gnu_parallel::parallel_random_shuffle(). */\n+#define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB 0\n+\n+/** @brief First copy the data, sort it locally, and merge it back\n+ * (0); or copy it back after everyting is done (1).\n+ *\n+ *  Recommendation: 0 */\n+#define _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST 0\n+"}, {"sha": "730875d0d52daf527582299b088baaf42f3c05ed", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,68 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/equally_split.h\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_EQUALLY_SPLIT_H\n+#define _GLIBCXX_PARALLEL_EQUALLY_SPLIT_H 1\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Function to split a sequence into parts of almost equal size.\n+   *\n+   *  The resulting sequence s of length p+1 contains the splitting\n+   *  positions when splitting the range [0,n) into parts of almost\n+   *  equal size (plus minus 1).  The first entry is 0, the last one\n+   *  n. There may result empty parts.\n+   *  @param n Number of elements\n+   *  @param p Number of parts\n+   *  @param s Splitters\n+   *  @returns End of splitter sequence, i. e. @c s+p+1 */\n+  template<typename _DifferenceTp, typename OutputIterator>\n+  OutputIterator\n+  equally_split(_DifferenceTp n, thread_index_t p, OutputIterator s)\n+  {\n+    typedef _DifferenceTp difference_type;\n+    difference_type chunk_length = n / p, split = n % p, start = 0;\n+    for (int i = 0; i < p; i++)\n+      {\n+\t*s++ = start;\n+\tstart += (difference_type(i) < split) ? (chunk_length + 1) : chunk_length;\n+      }\n+    *s++ = n;\n+    return s;\n+  }\n+}\n+\n+#endif"}, {"sha": "83771480f696b03c5795fcb6ec96a000870a27a8", "filename": "libstdc++-v3/include/parallel/features.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,170 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/features.h\n+ *  @brief Defines on whether to include algorithm variants.\n+ *\n+ *  Less variants reduce executable size and compile time.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_FEATURES_H\n+#define _GLIBCXX_PARALLEL_FEATURES_H 1\n+\n+#ifndef _GLIBCXX_MERGESORT\n+/** @def _GLIBCXX_MERGESORT\n+ *  @brief Include parallel multi-way mergesort.\n+ *  @see __gnu_parallel::Settings::sort_algorithm */\n+#define _GLIBCXX_MERGESORT 1\n+#endif\n+\n+#ifndef _GLIBCXX_QUICKSORT\n+/** @def _GLIBCXX_QUICKSORT\n+ *  @brief Include parallel unbalanced quicksort.\n+ *  @see __gnu_parallel::Settings::sort_algorithm */\n+#define _GLIBCXX_QUICKSORT 1\n+#endif\n+\n+#ifndef _GLIBCXX_BAL_QUICKSORT\n+/** @def _GLIBCXX_BAL_QUICKSORT\n+ *  @brief Include parallel dynamically load-balanced quicksort.\n+ *  @see __gnu_parallel::Settings::sort_algorithm */\n+#define _GLIBCXX_BAL_QUICKSORT 1\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE\n+/** @def _GLIBCXX_LOSER_TREE\n+ *  @brief Include guarded (sequences may run empty) loser tree,\n+ *  moving objects.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE 1\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_EXPLICIT\n+/** @def _GLIBCXX_LOSER_TREE_EXPLICIT\n+ *  @brief Include standard loser tree, storing two flags for infimum\n+ *  and supremum.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_EXPLICIT 0\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_REFERENCE\n+/** @def _GLIBCXX_LOSER_TREE_REFERENCE\n+ *  @brief Include some loser tree variant.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_REFERENCE 0\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_POINTER\n+/** @def _GLIBCXX_LOSER_TREE_POINTER\n+ *  @brief Include some loser tree variant.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_POINTER 0\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_UNGUARDED\n+/** @def _GLIBCXX_LOSER_TREE_UNGUARDED\n+ *  @brief Include unguarded (sequences must not run empty) loser\n+ *  tree, moving objects.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_UNGUARDED 1\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n+/** @def _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n+ *  @brief Include some loser tree variant.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED 0\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_COMBINED\n+/** @def _GLIBCXX_LOSER_TREE_COMBINED\n+ *  @brief Include some loser tree variant.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_COMBINED 0\n+#endif\n+\n+#ifndef _GLIBCXX_LOSER_TREE_SENTINEL\n+/** @def _GLIBCXX_LOSER_TREE_SENTINEL\n+ *  @brief Include some loser tree variant.\n+ *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n+#define _GLIBCXX_LOSER_TREE_SENTINEL 0\n+#endif\n+\n+\n+#ifndef _GLIBCXX_FIND_GROWING_BLOCKS\n+/** @brief Include the growing blocks variant for std::find.\n+ *  @see __gnu_parallel::Settings::find_distribution */\n+#define _GLIBCXX_FIND_GROWING_BLOCKS 1\n+#endif\n+\n+#ifndef _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS\n+/** @brief Include the equal-sized blocks variant for std::find.\n+ *  @see __gnu_parallel::Settings::find_distribution */\n+#define _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS 1\n+#endif\n+\n+#ifndef _GLIBCXX_FIND_EQUAL_SPLIT\n+/** @def _GLIBCXX_FIND_EQUAL_SPLIT\n+ *  @brief Include the equal splitting variant for std::find.\n+ *  @see __gnu_parallel::Settings::find_distribution */\n+#define _GLIBCXX_FIND_EQUAL_SPLIT 1\n+#endif\n+\n+\n+#ifndef _GLIBCXX_TREE_INITIAL_SPLITTING\n+/** @def _GLIBCXX_TREE_INITIAL_SPLITTING\n+ *  @brief Include the initial splitting variant for\n+ *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end).\n+ *  @see __gnu_parallel::_Rb_tree */\n+#define _GLIBCXX_TREE_INITIAL_SPLITTING 1\n+#endif\n+\n+#ifndef _GLIBCXX_TREE_DYNAMIC_BALANCING\n+/** @def _GLIBCXX_TREE_DYNAMIC_BALANCING\n+ *  @brief Include the dynamic balancing variant for\n+ *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end).\n+ *  @see __gnu_parallel::_Rb_tree */\n+#define _GLIBCXX_TREE_DYNAMIC_BALANCING 1\n+#endif\n+\n+#ifndef _GLIBCXX_TREE_FULL_COPY\n+/** @def _GLIBCXX_TREE_FULL_COPY\n+ *  @brief In order to sort the input sequence of\n+ *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end) a\n+ *  full copy of the input elements is done.\n+ *  @see __gnu_parallel::_Rb_tree */\n+#define _GLIBCXX_TREE_FULL_COPY 1\n+#endif\n+\n+\n+#endif"}, {"sha": "42f179fa6c7ca60585b7b2b76f79a9fcd70381d1", "filename": "libstdc++-v3/include/parallel/find.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,340 @@\n+/// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/find.h\n+ *  @brief Parallel implementation base for std::find(), std::equal()\n+ *  and related functions.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze and Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_FIND_H\n+#define _GLIBCXX_PARALLEL_FIND_H 1\n+\n+#include <bits/stl_algobase.h>\n+\n+#include <parallel/features.h>\n+#include <parallel/parallel.h>\n+#include <parallel/compatibility.h>\n+#include <parallel/equally_split.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** \n+   *  @brief Parallel std::find, switch for different algorithms.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence. Must have same\n+   *  length as first sequence.\n+   *  @param pred Find predicate.\n+   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+   *  @return Place of finding in both sequences. \n+   */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n+\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector)\n+  {\n+    switch (Settings::find_distribution)\n+      {\n+      case Settings::GROWING_BLOCKS:\n+\treturn find_template(begin1, end1, begin2, pred, selector, growing_blocks_tag());\n+      case Settings::CONSTANT_SIZE_BLOCKS:\n+\treturn find_template(begin1, end1, begin2, pred, selector, constant_size_blocks_tag());\n+      case Settings::EQUAL_SPLIT:\n+\treturn find_template(begin1, end1, begin2, pred, selector, equal_split_tag());\n+      default:\n+\t_GLIBCXX_PARALLEL_ASSERT(false);\n+\treturn std::make_pair(begin1, begin2);\n+      }\n+  }\n+\n+#if _GLIBCXX_FIND_EQUAL_SPLIT\n+\n+  /** \n+   *  @brief Parallel std::find, equal splitting variant.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence. Second sequence\n+   *  must have same length as first sequence.\n+   *  @param pred Find predicate.\n+   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+   *  @return Place of finding in both sequences. \n+   */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred, Selector selector, equal_split_tag)\n+  {\n+    _GLIBCXX_CALL(end1 - begin1)\n+\n+    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    difference_type length = end1 - begin1;\n+\n+    difference_type result = length;\n+\n+    const thread_index_t num_threads = get_max_threads();\n+\n+    // XXX VLA error.\n+    difference_type borders[num_threads + 1];\n+    equally_split(length, num_threads, borders);\n+\n+#pragma omp parallel shared(result) num_threads(num_threads)\n+    {\n+      int iam = omp_get_thread_num();\n+      difference_type pos = borders[iam], limit = borders[iam + 1];\n+\n+      RandomAccessIterator1 i1 = begin1 + pos;\n+      RandomAccessIterator2 i2 = begin2 + pos;\n+      for (; pos < limit; pos++)\n+\t{\n+#pragma omp flush(result)\n+\t  // Result has been set to something lower.\n+\t  if (result < pos)\n+\t    break;\n+\n+\t  if (selector(i1, i2, pred))\n+\t    {\n+#pragma omp critical (result)\n+\t      if (result > pos)\n+\t\tresult = pos;\n+\t      break;\n+\t    }\n+\t  i1++;\n+\t  i2++;\n+\t}\n+    }\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+  }\n+\n+#endif\n+\n+#if _GLIBCXX_FIND_GROWING_BLOCKS\n+\n+  /** \n+   *  @brief Parallel std::find, growing block size variant.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence. Second sequence\n+   *  must have same length as first sequence.\n+   *  @param pred Find predicate.\n+   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   *  @see __gnu_parallel::Settings::find_sequential_search_size\n+   *  @see __gnu_parallel::Settings::find_initial_block_size\n+   *  @see __gnu_parallel::Settings::find_maximum_block_size\n+   *  @see __gnu_parallel::Settings::find_increasing_factor\n+   *\n+   *  There are two main differences between the growing blocks and\n+   *  the constant-size blocks variants.\n+   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+\n+   *  2. For GB, the blocks are allocated dynamically;\n+   *     for CSB, the blocks are allocated in a predetermined manner,\n+   *     namely spacial round-robin.\n+   */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n+\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector,\n+\t\tgrowing_blocks_tag)\n+  {\n+    _GLIBCXX_CALL(end1 - begin1)\n+\n+    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    difference_type length = end1 - begin1;\n+\n+    difference_type sequential_search_size = std::min<difference_type>(length, Settings::find_sequential_search_size);\n+\n+    // Try it sequentially first.\n+    std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n+      selector.sequential_algorithm(begin1, begin1 + sequential_search_size, begin2, pred);\n+\n+    if (find_seq_result.first != (begin1 + sequential_search_size))\n+      return find_seq_result;\n+\n+    // Index of beginning of next free block (after sequential find).\n+    difference_type next_block_pos = sequential_search_size;\n+    difference_type result = length;\n+    const thread_index_t num_threads = get_max_threads();\n+\n+#pragma omp parallel shared(result) num_threads(num_threads)\n+    {\n+      // Not within first k elements -> start parallel.\n+      thread_index_t iam = omp_get_thread_num();\n+\n+      difference_type block_size = Settings::find_initial_block_size;\n+      difference_type start = fetch_and_add<difference_type>(&next_block_pos, block_size);\n+\n+      // Get new block, update pointer to next block.\n+      difference_type stop = std::min<difference_type>(length, start + block_size);\n+\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+\n+      while (start < length)\n+\t{\n+#pragma omp flush(result)\n+\t  // Get new value of result.\n+\t  if (result < start)\n+\t    {\n+\t      // No chance to find first element.\n+\t      break;\n+\t    }\n+\n+\t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n+\t  if (local_result.first != (begin1 + stop))\n+\t    {\n+#pragma omp critical(result)\n+\t      if ((local_result.first - begin1) < result)\n+\t\t{\n+\t\t  result = local_result.first - begin1;\n+\n+\t\t  // Result cannot be in future blocks, stop algorithm.\n+\t\t  fetch_and_add<difference_type>(&next_block_pos, length);\n+\t\t}\n+\t    }\n+\n+\t  block_size = std::min<difference_type>(block_size * Settings::find_increasing_factor, Settings::find_maximum_block_size);\n+\n+\t  // Get new block, update pointer to next block.\n+\t  start = fetch_and_add<difference_type>(&next_block_pos, block_size);\n+\t  stop = (length < (start + block_size)) ? length : (start + block_size);\n+\t}\n+    }\n+\n+    // Return iterator on found element.\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+  }\n+\n+#endif\n+\n+#if _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS\n+\n+  /** \n+   *   @brief Parallel std::find, constant block size variant.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence. Second sequence\n+   *  must have same length as first sequence.\n+   *  @param pred Find predicate.\n+   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   *  @see __gnu_parallel::Settings::find_sequential_search_size\n+   *  @see __gnu_parallel::Settings::find_block_size\n+   *  There are two main differences between the growing blocks and the\n+   *  constant-size blocks variants.\n+   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+   *  2. For GB, the blocks are allocated dynamically; for CSB, the\n+   *  blocks are allocated in a predetermined manner, namely spacial\n+   *  round-robin.\n+   */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n+\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector,\n+\t\tconstant_size_blocks_tag)\n+  {\n+    _GLIBCXX_CALL(end1 - begin1)\n+    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    difference_type length = end1 - begin1;\n+\n+    difference_type sequential_search_size = std::min<difference_type>(length, Settings::find_sequential_search_size);\n+\n+    // Try it sequentially first.\n+    std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n+      selector.sequential_algorithm(begin1, begin1 + sequential_search_size, begin2, pred);\n+\n+    if (find_seq_result.first != (begin1 + sequential_search_size))\n+      return find_seq_result;\n+\n+    difference_type result = length;\n+    const thread_index_t num_threads = get_max_threads();\n+\n+    // Not within first sequential_search_size elements -> start parallel.\n+#pragma omp parallel shared(result) num_threads(num_threads)\n+    {\n+      thread_index_t iam = omp_get_thread_num();\n+      difference_type block_size = Settings::find_initial_block_size;\n+\n+      difference_type start, stop;\n+\n+      // First element of thread's current iteration.\n+      difference_type iteration_start = sequential_search_size;\n+\n+      // Where to work (initialization).\n+      start = iteration_start + iam * block_size;\n+      stop = std::min<difference_type>(length, start + block_size);\n+\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+\n+      while (start < length)\n+\t{\n+\t  // Get new value of result.\n+#pragma omp flush(result)\n+\t  // No chance to find first element.\n+\t  if (result < start)\n+\t    break;\n+\n+\t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n+\t  if (local_result.first != (begin1 + stop))\n+\t    {\n+#pragma omp critical(result)\n+\t      if ((local_result.first - begin1) < result)\n+\t\tresult = local_result.first - begin1;\n+\n+\t      // Will not find better value in its interval.\n+\t      break;\n+\t    }\n+\n+\t  iteration_start += num_threads * block_size;\n+\n+\t  // Where to work.\n+\t  start = iteration_start + iam * block_size;\n+\t  stop = std::min<difference_type>(length, start + block_size);\n+\t}\n+    }\n+\n+    // Return iterator on found element.\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+  }\n+#endif\n+} // end namespace\n+\n+#endif\n+"}, {"sha": "fddd8263c0d9bd04936b31279ddc742c73afa322", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,184 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/find_selectors.h\n+ *  @brief Function objects representing different tasks to be plugged\n+ *  into the parallel find algorithm.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_FIND_FUNCTIONS_H\n+#define _GLIBCXX_PARALLEL_FIND_FUNCTIONS_H 1\n+\n+#include <parallel/tags.h>\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_pair.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Base class of all __gnu_parallel::find_template selectors. */\n+  struct generic_find_selector\n+  { };\n+\n+  /** \n+   *  @brief Test predicate on a single element, used for std::find()\n+   *  and std::find_if ().\n+   */\n+  struct find_if_selector : public generic_find_selector\n+  {\n+    /** @brief Test on one position.\n+     * @param i1 Iterator on first sequence.\n+     * @param i2 Iterator on second sequence (unused).\n+     * @param pred Find predicate.\n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline bool \n+    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+    { return pred(*i1); }\n+\n+    /** @brief Corresponding sequential algorithm on a sequence.\n+     *  @param begin1 Begin iterator of first sequence.\n+     *  @param end1 End iterator of first sequence.\n+     *  @param begin2 Begin iterator of second sequence.\n+     *  @param pred Find predicate.\n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline std::pair<RandomAccessIterator1, RandomAccessIterator2> \n+    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n+    {\n+      return std::make_pair(find_if(begin1, end1, pred, sequential_tag()), begin2);\n+    }\n+  };\n+\n+  /** @brief Test predicate on two adjacent elements. */\n+  struct adjacent_find_selector : public generic_find_selector\n+  {\n+    /** @brief Test on one position.\n+     *  @param i1 Iterator on first sequence.\n+     *  @param i2 Iterator on second sequence (unused).\n+     *  @param pred Find predicate.\n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline bool \n+    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+    {\n+      // Passed end iterator is one short.\n+      return pred(*i1, *(i1 + 1));\n+    }\n+\n+    /** @brief Corresponding sequential algorithm on a sequence.\n+     *  @param begin1 Begin iterator of first sequence.\n+     *  @param end1 End iterator of first sequence.\n+     *  @param begin2 Begin iterator of second sequence.\n+     *  @param pred Find predicate.\n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n+    {\n+      // Passed end iterator is one short.\n+      RandomAccessIterator1 spot = adjacent_find(begin1, end1 + 1, pred, sequential_tag());\n+      if (spot == (end1 + 1))\n+\tspot = end1;\n+      return std::make_pair(spot, begin2);\n+    }\n+  };\n+\n+  /** @brief Test inverted predicate on a single element. */\n+  struct mismatch_selector : public generic_find_selector\n+  {\n+    /** \n+     *  @brief Test on one position.\n+     *  @param i1 Iterator on first sequence.\n+     *  @param i2 Iterator on second sequence (unused).\n+     *  @param pred Find predicate. \n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline bool \n+    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+    { return !pred(*i1, *i2); }\n+\n+    /** \n+     *  @brief Corresponding sequential algorithm on a sequence.\n+     *  @param begin1 Begin iterator of first sequence.\n+     *  @param end1 End iterator of first sequence.\n+     *  @param begin2 Begin iterator of second sequence.\n+     *  @param pred Find predicate. \n+     */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n+    { \n+      return mismatch(begin1, end1, begin2, pred, sequential_tag()); \n+    }\n+  };\n+\n+\n+  /** @brief Test predicate on several elements. */\n+  template<typename ForwardIterator>\n+  struct find_first_of_selector : public generic_find_selector\n+  {\n+    ForwardIterator begin;\n+    ForwardIterator end;\n+\n+    explicit find_first_of_selector(ForwardIterator begin, ForwardIterator end)\n+    : begin(begin), end(end) { }\n+\n+    /** @brief Test on one position.\n+     *  @param i1 Iterator on first sequence.\n+     *  @param i2 Iterator on second sequence (unused).\n+     *  @param pred Find predicate. */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline bool \n+    operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+    {\n+      for (ForwardIterator pos_in_candidates = begin; pos_in_candidates != end; pos_in_candidates++)\n+\tif (pred(*i1, *pos_in_candidates))\n+\t  return true;\n+      return false;\n+    }\n+\n+    /** @brief Corresponding sequential algorithm on a sequence.\n+     *  @param begin1 Begin iterator of first sequence.\n+     *  @param end1 End iterator of first sequence.\n+     *  @param begin2 Begin iterator of second sequence.\n+     *  @param pred Find predicate. */\n+    template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred>\n+    inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+    sequential_algorithm(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred)\n+    {\n+      return std::make_pair(find_first_of(begin1, end1, begin, end, pred, sequential_tag()), begin2);\n+    }\n+  };\n+}\n+\n+#endif"}, {"sha": "eb5e04e84f131fdce736cf6b472727971c983478", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,83 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/for_each.h\n+ *  @brief Main interface for embarassingly parallel functions.\n+ *\n+ *  The explicit implementation are in other header files, like\n+ *  workstealing.h, par_loop.h, omp_loop.h, and omp_loop_static.h.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_FOR_EACH_H\n+#define _GLIBCXX_PARALLEL_FOR_EACH_H 1\n+\n+#include <parallel/settings.h>\n+#include <parallel/par_loop.h>\n+#include <parallel/omp_loop.h>\n+#include <parallel/workstealing.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Chose the desired algorithm by evaluating @c parallelism_tag.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param user_op A user-specified functor (comparator, predicate,\n+   *  associative operator,...)\n+   *  @param functionality functor to \"process\" an element with\n+   *  user_op (depends on desired functionality, e. g. accumulate,\n+   *  for_each,...\n+   *  @param reduction Reduction functor.\n+   *  @param reduction_start Initial value for reduction.\n+   *  @param output Output iterator.\n+   *  @param bound Maximum number of elements processed.\n+   *  @param parallelism_tag Parallelization method */\n+  template<typename InputIterator, typename UserOp, typename Functionality, typename Red, typename Result>\n+  UserOp\n+  for_each_template_random_access(InputIterator begin, InputIterator end,\n+\t\t\t\t  UserOp user_op, Functionality& functionality,\n+\t\t\t\t  Red reduction, Result reduction_start,\n+\t\t\t\t  Result& output,\n+\t\t\t\t  typename std::iterator_traits<InputIterator>::difference_type bound, parallelism parallelism_tag)\n+  {\n+    if (parallelism_tag == parallel_unbalanced)\n+      return for_each_template_random_access_ed(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n+    else if (parallelism_tag == parallel_omp_loop)\n+      return for_each_template_random_access_omp_loop(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n+    else if (parallelism_tag == parallel_omp_loop_static)\n+      return for_each_template_random_access_omp_loop(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n+    else\t//e. g. parallel_balanced\n+      return for_each_template_random_access_workstealing(begin, end, user_op, functionality, reduction, reduction_start, output, bound);\n+  }\n+}\n+\n+#endif"}, {"sha": "f1d0abf255baa47347ac20f69f0c26dcb733fbad", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,343 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/for_each_selectors.h\n+ *  @brief Functors representing different tasks to be plugged into the\n+ *  generic parallelization methods for embarrassingly parallel functions.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_FOR_EACH_SELECTORS_H\n+#define _GLIBCXX_PARALLEL_FOR_EACH_SELECTORS_H 1\n+\n+#include <parallel/basic_iterator.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+  /** @brief Generic selector for embarrassingly parallel functions. */\n+  template<typename It>\n+  struct generic_for_each_selector\n+  {\n+    /** @brief Iterator on last element processed; needed for some\n+     *  algorithms (e. g. std::transform()).\n+     */\n+    It finish_iterator;\n+  };\n+\n+\n+  /** @brief std::for_each() selector. */\n+  template<typename It>\n+  struct for_each_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object. */\n+    template<typename Op>\n+    inline bool operator()(Op& o, It i)\n+    {\n+      o(*i);\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::generate() selector. */\n+  template<typename It>\n+  struct generate_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object. */\n+    template<typename Op>\n+    inline bool operator()(Op& o, It i)\n+    {\n+      *i = o();\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::fill() selector. */\n+  template<typename It>\n+  struct fill_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param v Current value.\n+     *  @param i Iterator referencing object. */\n+    template<typename Val>\n+    inline bool operator()(Val& v, It i)\n+    {\n+      *i = v;\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::transform() selector, one input sequence variant. */\n+  template<typename It>\n+  struct transform1_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object. */\n+    template<typename Op>\n+    inline bool operator()(Op& o, It i)\n+    {\n+      *i.second = o(*i.first);\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::transform() selector, two input sequences variant. */\n+  template<typename It>\n+  struct transform2_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object. */\n+    template<typename Op>\n+    inline bool operator()(Op& o, It i)\n+    {\n+      *i.third = o(*i.first, *i.second);\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::replace() selector. */\n+  template<typename It, typename T>\n+  struct replace_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Value to replace with. */\n+    const T& new_val;\n+\n+    /** @brief Constructor\n+     *  @param new_val Value to replace with. */\n+    explicit replace_selector(const T &new_val) : new_val(new_val) {}\n+\n+    /** @brief Functor execution.\n+     *  @param v Current value.\n+     *  @param i Iterator referencing object. */\n+    inline bool operator()(T& v, It i)\n+    {\n+      if (*i == v)\n+\t*i = new_val;\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::replace() selector. */\n+  template<typename It, typename Op, typename T>\n+  struct replace_if_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Value to replace with. */\n+    const T& new_val;\n+\n+    /** @brief Constructor.\n+     *  @param new_val Value to replace with. */\n+    explicit replace_if_selector(const T &new_val) : new_val(new_val) { }\n+\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object. */\n+    inline bool operator()(Op& o, It i)\n+    {\n+      if (o(*i))\n+\t*i = new_val;\n+      return true;\n+    }\n+  };\n+\n+  /** @brief std::count() selector. */\n+  template<typename It, typename Diff>\n+  struct count_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param v Current value.\n+     *  @param i Iterator referencing object.\n+     *  @return 1 if count, 0 if does not count. */\n+    template<typename Val>\n+    inline Diff operator()(Val& v, It i)\n+    { return (v == *i) ? 1 : 0; }\n+  };\n+\n+  /** @brief std::count_if () selector. */\n+  template<typename It, typename Diff>\n+  struct count_if_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator.\n+     *  @param i Iterator referencing object.\n+     *  @return 1 if count, 0 if does not count. */\n+    template<typename Op>\n+    inline Diff operator()(Op& o, It i)\n+    { return (o(*i)) ? 1 : 0; }\n+  };\n+\n+  /** @brief std::accumulate() selector. */\n+  template<typename It>\n+  struct accumulate_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator (unused).\n+     *  @param i Iterator referencing object.\n+     *  @return The current value. */\n+    template<typename Op>\n+    inline typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n+    { return *i; }\n+  };\n+\n+  /** @brief std::inner_product() selector. */\n+  template<typename It, typename It2, typename T>\n+  struct inner_product_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Begin iterator of first sequence. */\n+    It begin1_iterator;\n+\n+    /** @brief Begin iterator of second sequence. */\n+    It2 begin2_iterator;\n+\n+    /** @brief Constructor.\n+     *  @param b1 Begin iterator of first sequence.\n+     *  @param b2 Begin iterator of second sequence. */\n+    explicit inner_product_selector(It b1, It2 b2) : begin1_iterator(b1), begin2_iterator(b2) { }\n+\n+    /** @brief Functor execution.\n+     *  @param mult Multiplication functor.\n+     *  @param current Iterator referencing object.\n+     *  @return Inner product elemental result. */\n+    template<typename Op>\n+    inline T operator()(Op mult, It current)\n+    {\n+      typename std::iterator_traits<It>::difference_type position = current - begin1_iterator;\n+      return mult(*current, *(begin2_iterator + position));\n+    }\n+  };\n+\n+  /** @brief Selector that just returns the passed iterator. */\n+  template<typename It>\n+  struct identity_selector : public generic_for_each_selector<It>\n+  {\n+    /** @brief Functor execution.\n+     *  @param o Operator (unused).\n+     *  @param i Iterator referencing object.\n+     *  @return Passed iterator. */\n+    template<typename Op>\n+    inline It operator()(Op o, It i)\n+    { return i; }\n+  };\n+\n+  /** @brief Selector that returns the difference between two adjacent\n+   *  elements.\n+   */\n+  template<typename It>\n+  struct adjacent_difference_selector : public generic_for_each_selector<It>\n+  {\n+    template<typename Op>\n+    inline bool operator()(Op& o, It i)\n+    {\n+      typename It::first_type go_back_one = i.first;\n+      --go_back_one;\n+      *i.second = o(*i.first, *go_back_one);\n+      return true;\n+    }\n+  };\n+\n+  // XXX move into type_traits?\n+  /** @brief Functor doing nothing\n+   *\n+   *  For some reduction tasks (this is not a function object, but is\n+   *  passed as selector dummy parameter.\n+   */\n+  struct nothing\n+  {\n+    /** @brief Functor execution.\n+     *  @param i Iterator referencing object. */\n+    template<typename It>\n+    inline void operator()(It i)\n+    { }\n+  };\n+\n+  /** @brief Reduction function doing nothing. */\n+  struct dummy_reduct\n+  {\n+    inline bool operator()(bool /*x*/, bool /*y*/) const\n+    { return true; }\n+  };\n+\n+  /** @brief Reduction for finding the maximum element, using a comparator. */\n+  template<typename Comp, typename It>\n+  struct min_element_reduct\n+  {\n+    Comp& comp;\n+\n+    explicit min_element_reduct(Comp &c) : comp(c)\n+    { }\n+\n+    inline It operator()(It x, It y)\n+    {\n+      if (comp(*x, *y))\n+\treturn x;\n+      else\n+\treturn y;\n+    }\n+  };\n+\n+  /** @brief Reduction for finding the maximum element, using a comparator. */\n+  template<typename Comp, typename It>\n+  struct max_element_reduct\n+  {\n+    Comp& comp;\n+\n+    explicit max_element_reduct(Comp& c) : comp(c)\n+    { }\n+\n+    inline It operator()(It x, It y)\n+    {\n+      if (comp(*x, *y))\n+\treturn y;\n+      else\n+\treturn x;\n+    }\n+  };\n+\n+  /** @brief General reduction, using a binary operator. */\n+  template<typename BinOp>\n+  struct accumulate_binop_reduct\n+  {\n+    BinOp& binop;\n+\n+    explicit accumulate_binop_reduct(BinOp& b) : binop(b) {}\n+\n+    template<typename T>\n+    inline T operator()(T x, T y) { return binop(x, y); }\n+  };\n+}\n+\n+#endif"}, {"sha": "26b7f331a82f51bc030803e75b2d02888f2d9b61", "filename": "libstdc++-v3/include/parallel/iterator.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,203 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/iterator.h\n+ * @brief Helper iterator classes for the std::transform() functions.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_ITERATOR_H\n+#define _GLIBCXX_PARALLEL_ITERATOR_H 1\n+\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_pair.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief A pair of iterators. The usual iterator operations are\n+   *  applied to both child iterators.\n+   */\n+  template<typename Iterator1, typename Iterator2, typename IteratorCategory>\n+  class iterator_pair : public std::pair<Iterator1, Iterator2>\n+  {\n+  private:\n+    typedef iterator_pair<Iterator1, Iterator2, IteratorCategory> type;\n+    typedef std::pair<Iterator1, Iterator2> base_type;\n+\n+  public:\n+    typedef IteratorCategory iterator_category;\n+    typedef void value_type;\n+\n+    typedef std::iterator_traits<Iterator1> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef type* pointer;\n+    typedef type& reference;\n+\n+    iterator_pair() { }\n+\n+    iterator_pair(const Iterator1& first, const Iterator2& second) \n+    : base_type(first, second) { }\n+\n+    // Pre-increment operator.\n+    type&\n+    operator++()\n+    {\n+      ++base_type::first;\n+      ++base_type::second;\n+      return *this;\n+    }\n+\n+    // Post-increment operator.\n+    const type\n+    operator++(int)\n+    { return type(base_type::first++, base_type::second++); }\n+\n+    // Pre-decrement operator.\n+    type&\n+    operator--()\n+    {\n+      --base_type::first;\n+      --base_type::second;\n+      return *this;\n+    }\n+\n+    // Post-decrement operator.\n+    const type\n+    operator--(int)\n+    { return type(base_type::first--, base_type::second--); }\n+\n+    // Type conversion.\n+    operator Iterator2() const\n+    { return base_type::second; }\n+\n+    type&\n+    operator=(const type& other)\n+    {\n+      base_type::first = other.first;\n+      base_type::second = other.second;\n+      return *this;\n+    }\n+\n+    type\n+    operator+(difference_type delta) const\n+    { return type(base_type::first + delta, base_type::second + delta); }\n+\n+    difference_type\n+    operator-(const type& other) const\n+    { return base_type::first - other.first; }\n+  };\n+\n+\n+  /** @brief A triple of iterators. The usual iterator operations are\n+      applied to all three child iterators.\n+   */\n+  template<typename Iterator1, typename Iterator2, typename Iterator3, typename IteratorCategory>\n+  class iterator_triple\n+  {\n+  private:\n+    typedef iterator_triple<Iterator1, Iterator2, Iterator3, IteratorCategory> type;\n+\n+  public:\n+    typedef IteratorCategory iterator_category;\n+    typedef void value_type;\n+    typedef typename Iterator1::difference_type difference_type;\n+    typedef type* pointer;\n+    typedef type& reference;\n+\n+    Iterator1 first;\n+    Iterator2 second;\n+    Iterator3 third;\n+\n+    iterator_triple() { }\n+\n+    iterator_triple(const Iterator1& _first, const Iterator2& _second,\n+\t\t    const Iterator3& _third)\n+    {\n+      first = _first;\n+      second = _second;\n+      third = _third;\n+    }\n+\n+    // Pre-increment operator.\n+    type&\n+    operator++()\n+    {\n+      ++first;\n+      ++second;\n+      ++third;\n+      return *this;\n+    }\n+\n+    // Post-increment operator.\n+    const type\n+    operator++(int)\n+    { return type(first++, second++, third++); }\n+\n+    // Pre-decrement operator.\n+    type&\n+    operator--()\n+    {\n+      --first;\n+      --second;\n+      --third;\n+      return *this;\n+    }\n+\n+    // Post-decrement operator.\n+    const type\n+    operator--(int)\n+    { return type(first--, second--, third--); }\n+\n+    // Type conversion.\n+    operator Iterator3() const\n+    { return third; }\n+\n+    type&\n+    operator=(const type& other)\n+    {\n+      first = other.first;\n+      second = other.second;\n+      third = other.third;\n+      return *this;\n+    }\n+\n+    type\n+    operator+(difference_type delta) const\n+    { return type(first + delta, second + delta, third + delta); }\n+\n+    difference_type\n+    operator-(const type& other) const\n+    { return first - other.first; }\n+  };\n+}\n+\n+#endif"}, {"sha": "320b1b8286ad17ec335850b86c458b81ff2c1fb5", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,181 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/list_partition.h\n+ *  @brief Functionality to split sequence referenced by only input\n+ *  iterators.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Leonor Frias Moya and Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_LIST_PARTITION_H\n+#define _GLIBCXX_PARALLEL_LIST_PARTITION_H 1\n+\n+#include <parallel/parallel.h>\n+#include <vector>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Shrinks and doubles the ranges.\n+   *  @param os_starts Start positions worked on (oversampled).\n+   *  @param count_to_two Counts up to 2.\n+   *  @param range_length Current length of a chunk.\n+   *  @param make_twice Whether the @c os_starts is allowed to be\n+   *  grown or not\n+   */\n+  template<typename InputIterator>\n+  void\n+  shrink_and_double(std::vector<InputIterator>& os_starts, size_t& count_to_two, size_t& range_length, const bool make_twice)\n+  {\n+    ++count_to_two;\n+    if (not make_twice or count_to_two < 2)\n+      {\n+\tshrink(os_starts, count_to_two, range_length);\n+      }\n+    else\n+      {\n+\tos_starts.resize((os_starts.size() - 1) * 2 + 1);\n+\tcount_to_two = 0;\n+      }\n+  }\n+\n+  /** @brief Combines two ranges into one and thus halves the number of ranges.\n+   *  @param os_starts Start positions worked on (oversampled).\n+   *  @param count_to_two Counts up to 2.\n+   *  @param range_length Current length of a chunk. */\n+  template<typename InputIterator>\n+  void\n+  shrink(std::vector<InputIterator>& os_starts, size_t& count_to_two,\n+\t size_t& range_length)\n+  {\n+    for (typename std::vector<InputIterator>::size_type i = 0; i <= (os_starts.size() / 2); ++i)\n+      {\n+\tos_starts[i] = os_starts[i * 2];\n+      }\n+    range_length *= 2;\n+  }\n+\n+  /** @brief Splits a sequence given by input iterators into parts of\n+   * almost equal size\n+   *\n+   *  The function needs only one pass over the sequence.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param starts Start iterators for the resulting parts, dimension\n+   *  @c num_parts+1. For convenience, @c starts @c [num_parts]\n+   *  contains the end iterator of the sequence.\n+   *  @param lengths Length of the resulting parts.\n+   *  @param num_parts Number of parts to split the sequence into.\n+   *  @param f Functor to be applied to each element by traversing it\n+   *  @param oversampling Oversampling factor. If 0, then the\n+   *  partitions will differ in at most @f$ \\sqrt{\\mathrm{end} -\n+   *  \\mathrm{begin}} @f$ elements. Otherwise, the ratio between the\n+   *  longest and the shortest part is bounded by @f$\n+   *  1/(\\mathrm{oversampling} \\cdot \\mathrm{num\\_parts}) @f$.\n+   *  @return Length of the whole sequence.\n+   */\n+  template<typename InputIterator, typename FunctorType>\n+  size_t\n+  list_partition(const InputIterator begin, const InputIterator end,\n+\t\t InputIterator* starts, size_t* lengths, const int num_parts,\n+\t\t FunctorType& f, int oversampling = 0)\n+  {\n+    bool make_twice = false;\n+\n+    // According to the oversampling factor, the resizing algorithm is chosen.\n+    if (oversampling == 0)\n+      {\n+\tmake_twice = true;\n+\toversampling = 1;\n+      }\n+\n+    std::vector<InputIterator> os_starts(2 * oversampling * num_parts + 1);\n+\n+    os_starts[0]= begin;\n+    InputIterator prev = begin, it = begin;\n+    size_t dist_limit = 0, dist = 0;\n+    size_t cur = 1, next = 1;\n+    size_t range_length = 1;\n+    size_t count_to_two = 0;\n+    while (it != end){\n+      cur = next;\n+      for (; cur < os_starts.size() and it != end; ++cur)\n+\t{\n+\t  for (dist_limit += range_length; dist < dist_limit and it != end; ++dist)\n+\t    {\n+\t      f(it);\n+\t      ++it;\n+\t    }\n+\t  os_starts[cur] = it;\n+\t}\n+\n+      // Must compare for end and not cur < os_starts.size() , because\n+      // cur could be == os_starts.size() as well\n+      if (it == end)\n+\tbreak;\n+\n+      shrink_and_double(os_starts, count_to_two, range_length, make_twice);\n+      next = os_starts.size()/2 + 1;\n+    }\n+\n+    // Calculation of the parts (one must be extracted from current\n+    // because the partition beginning at end, consists only of\n+    // itself).\n+    size_t size_part = (cur - 1) / num_parts;\n+    int size_greater = static_cast<int>((cur - 1) % num_parts);\n+    starts[0] = os_starts[0];\n+\n+    size_t index = 0;\n+\n+    // Smallest partitions.\n+    for (int i = 1; i < (num_parts + 1 - size_greater); ++i)\n+      {\n+\tlengths[i-1] =  size_part * range_length;\n+\tindex += size_part;\n+\tstarts[i] = os_starts[index];\n+      }\n+\n+    // Biggest partitions.\n+    for (int i = num_parts + 1 - size_greater; i <= num_parts; ++i)\n+      {\n+\tlengths[i-1] =  (size_part+1) * range_length;\n+\tindex += (size_part+1);\n+\tstarts[i] = os_starts[index];\n+      }\n+\n+    // Correction of the end size (the end iteration has not finished).\n+    lengths[num_parts - 1] -= (dist_limit - dist);\n+\n+    return dist;\n+  }\n+}\n+\n+#endif"}, {"sha": "1823282c9d3f23107355c8855e2bfba6e23539aa", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "added", "additions": 1077, "deletions": 0, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,1077 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/losertree.h\n+ *  @brief Many generic loser tree variants.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_LOSERTREE_H\n+#define _GLIBCXX_PARALLEL_LOSERTREE_H\n+\n+#include <functional>\n+\n+#include <bits/stl_algobase.h>\n+#include <parallel/features.h>\n+#include <parallel/base.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+#if _GLIBCXX_LOSER_TREE_EXPLICIT\n+\n+  /** @brief Guarded loser tree, copying the whole element into the\n+   * tree structure.\n+   *\n+   *  Guarding is done explicitly through two flags per element, inf\n+   *  and sup This is a quite slow variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTreeExplicit\n+  {\n+  private:\n+    struct Loser\n+    {\n+      // The relevant element.\n+      T key;\n+\n+      // Is this an infimum or supremum element?\n+      bool inf, sup;\n+\n+      // Number of the sequence the element comes from.\n+      int source;\n+    };\n+\n+    unsigned int size, offset;\n+    Loser* losers;\n+    Comparator comp;\n+\n+  public:\n+    inline LoserTreeExplicit(unsigned int _size, Comparator _comp = std::less<T>()) : comp(_comp)\n+    {\n+      size = _size;\n+      offset = size;\n+      losers = new Loser[size];\n+      for (unsigned int l = 0; l < size; l++)\n+\t{\n+\t  //losers[l].key = ... \tstays unset\n+\t  losers[l].inf = true;\n+\t  losers[l].sup = false;\n+\t  //losers[l].source = -1;\t//sentinel\n+\t}\n+    }\n+\n+    inline ~LoserTreeExplicit()\n+    { delete[] losers; }\n+\n+    inline void\n+    print() { }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(T key, int source, bool sup)\n+    {\n+      bool inf = false;\n+      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup && comp(losers[pos].key, key)) || losers[pos].inf || sup)\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].key, key);\n+\t      std::swap(losers[pos].inf, inf);\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t    }\n+\t}\n+\n+      losers[0].key = key;\n+      losers[0].inf = inf;\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+    }\n+\n+    inline void\n+    init() { }\n+\n+    inline void\n+    delete_min_insert(T key, bool sup)\n+    {\n+      bool inf = false;\n+      int source = losers[0].source;\n+      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup && comp(losers[pos].key, key))\n+\t      || losers[pos].inf || sup)\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].key, key);\n+\t      std::swap(losers[pos].inf, inf);\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t    }\n+\t}\n+\n+      losers[0].key = key;\n+      losers[0].inf = inf;\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+    }\n+\n+    inline void\n+    insert_start_stable(T key, int source, bool sup)\n+    {\n+      bool inf = false;\n+      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup &&\n+\t       ((comp(losers[pos].key, key)) ||\n+\t\t(!comp(key, losers[pos].key) && losers[pos].source < source)))\n+\t      || losers[pos].inf || sup)\n+\t    {\n+\t      // Take next key.\n+\t      std::swap(losers[pos].key, key);\n+\t      std::swap(losers[pos].inf, inf);\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t    }\n+\t}\n+\n+      losers[0].key = key;\n+      losers[0].inf = inf;\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+    }\n+\n+    inline void\n+    init_stable() { }\n+\n+    inline void\n+    delete_min_insert_stable(T key, bool sup)\n+    {\n+      bool inf = false;\n+      int source = losers[0].source;\n+      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n+\t       && ((comp(losers[pos].key, key)) ||\n+\t\t(!comp(key, losers[pos].key) && losers[pos].source < source)))\n+\t      || losers[pos].inf || sup)\n+\t    {\n+\t      std::swap(losers[pos].key, key);\n+\t      std::swap(losers[pos].inf, inf);\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t    }\n+\t}\n+\n+      losers[0].key = key;\n+      losers[0].inf = inf;\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+    }\n+  };\n+\n+#endif\n+\n+#if _GLIBCXX_LOSER_TREE\n+\n+  /** @brief Guarded loser tree, either copying the whole element into\n+   * the tree structure, or looking up the element via the index.\n+   *\n+   *  Guarding is done explicitly through one flag sup per element,\n+   *  inf is not needed due to a better initialization routine.  This\n+   *  is a well-performing variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTree\n+  {\n+  private:\n+    struct Loser\n+    {\n+      bool sup;\n+      int source;\n+      T key;\n+    };\n+\n+    unsigned int ik, k, offset;\n+    Loser* losers;\n+    Comparator comp;\n+\n+  public:\n+    inline LoserTree(unsigned int _k, Comparator _comp = std::less<T>())\n+    : comp(_comp)\n+    {\n+      ik = _k;\n+\n+      // Next greater power of 2.\n+      k = 1 << (log2(ik - 1) + 1);\n+      offset = k;\n+      losers = new Loser[k * 2];\n+      for (unsigned int i = ik - 1; i < k; i++)\n+\tlosers[i + k].sup = true;\n+    }\n+\n+    inline ~LoserTree()\n+    { delete[] losers; }\n+\n+    void\n+    print()\n+    {\n+      for (unsigned int i = 0; i < (k * 2); i++)\n+\tprintf(\"%d    %d from %d,  %d\\n\", i, losers[i].key, losers[i].source, losers[i].sup);\n+    }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(const T& key, int source, bool sup)\n+    {\n+      unsigned int pos = k + source;\n+\n+      losers[pos].sup = sup;\n+      losers[pos].source = source;\n+      losers[pos].key = key;\n+    }\n+\n+    unsigned int\n+    init_winner (unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (losers[right].sup ||\n+\t      (!losers[left].sup && !comp(losers[right].key, losers[left].key)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\t// Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init()\n+    { losers[0] = losers[init_winner(1)]; }\n+\n+    // Do not pass const reference since key will be used as local variable.\n+    inline void\n+    delete_min_insert(T key, bool sup)\n+    {\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].key, key);\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+      losers[0].key = key;\n+    }\n+\n+    inline void\n+    insert_start_stable(const T& key, int source, bool sup)\n+    { return insert_start(key, source, sup); }\n+\n+    unsigned int\n+    init_winner_stable (unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (\tlosers[right].sup ||\n+\t\t(!losers[left].sup && !comp(losers[right].key, losers[left].key)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init_stable()\n+    { losers[0] = losers[init_winner_stable(1)]; }\n+\n+    // Do not pass const reference since key will be used as local variable.\n+    inline void\n+    delete_min_insert_stable(T key, bool sup)\n+    {\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by source.\n+\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+\t\t(!sup && !losers[pos].sup &&\n+\t\t ((comp(losers[pos].key, key)) ||\n+\t\t  (!comp(key, losers[pos].key) && losers[pos].source < source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].key, key);\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+      losers[0].key = key;\n+    }\n+  };\n+\n+#endif\n+\n+#if _GLIBCXX_LOSER_TREE_REFERENCE\n+\n+  /** @brief Guarded loser tree, either copying the whole element into\n+   * the tree structure, or looking up the element via the index.\n+   *\n+   *  Guarding is done explicitly through one flag sup per element,\n+   *  inf is not needed due to a better initialization routine.  This\n+   *  is a well-performing variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTreeReference\n+  {\n+#undef COPY\n+#ifdef COPY\n+#define KEY(i) losers[i].key\n+#define KEY_SOURCE(i) key\n+#else\n+#define KEY(i) keys[losers[i].source]\n+#define KEY_SOURCE(i) keys[i]\n+#endif\n+  private:\n+    struct Loser\n+    {\n+      bool sup;\n+      int source;\n+#ifdef COPY\n+      T key;\n+#endif\n+    };\n+\n+    unsigned int ik, k, offset;\n+    Loser* losers;\n+#ifndef COPY\n+    T* keys;\n+#endif\n+    Comparator comp;\n+\n+  public:\n+    inline LoserTreeReference(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    {\n+      ik = _k;\n+\n+      // Next greater power of 2.\n+      k = 1 << (log2(ik - 1) + 1);\n+      offset = k;\n+      losers = new Loser[k * 2];\n+#ifndef COPY\n+      keys = new T[ik];\n+#endif\n+      for (unsigned int i = ik - 1; i < k; i++)\n+\tlosers[i + k].sup = true;\n+    }\n+\n+    inline ~LoserTreeReference()\n+    {\n+      delete[] losers;\n+#ifndef COPY\n+      delete[] keys;\n+#endif\n+    }\n+\n+    void\n+    print()\n+    {\n+      for (unsigned int i = 0; i < (k * 2); i++)\n+\tprintf(\"%d    %d from %d,  %d\\n\", i, KEY(i), losers[i].source, losers[i].sup);\n+    }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(T key, int source, bool sup)\n+    {\n+      unsigned int pos = k + source;\n+\n+      losers[pos].sup = sup;\n+      losers[pos].source = source;\n+      KEY(pos) = key;\n+    }\n+\n+    unsigned int\n+    init_winner(unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (\tlosers[right].sup ||\n+\t\t(!losers[left].sup && !comp(KEY(right), KEY(left))))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init()\n+    {\n+      losers[0] = losers[init_winner(1)];\n+    }\n+\n+    inline void\n+    delete_min_insert(T key, bool sup)\n+    {\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (sup || (!losers[pos].sup && comp(KEY(pos), KEY_SOURCE(source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+#ifdef COPY\n+\t      std::swap(KEY(pos), KEY_SOURCE(source));\n+#endif\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+#ifdef COPY\n+      KEY(0) = KEY_SOURCE(source);\n+#endif\n+    }\n+\n+    inline void\n+    insert_start_stable(T key, int source, bool sup)\n+    { return insert_start(key, source, sup); }\n+\n+    unsigned int\n+    init_winner_stable(unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (losers[right].sup\n+\t      || (!losers[left].sup && !comp(KEY(right), KEY(left))))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init_stable()\n+    { losers[0] = losers[init_winner_stable(1)]; }\n+\n+    inline void\n+    delete_min_insert_stable(T key, bool sup)\n+    {\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by source.\n+\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+\t\t(!sup && !losers[pos].sup &&\n+\t\t ((comp(KEY(pos), KEY_SOURCE(source))) ||\n+\t\t  (!comp(KEY_SOURCE(source), KEY(pos)) && losers[pos].source < source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+#ifdef COPY\n+\t      std::swap(KEY(pos), KEY_SOURCE(source));\n+#endif\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+#ifdef COPY\n+      KEY(0) = KEY_SOURCE(source);\n+#endif\n+    }\n+  };\n+#undef KEY\n+#undef KEY_SOURCE\n+\n+#endif\n+\n+#if _GLIBCXX_LOSER_TREE_POINTER\n+\n+  /** @brief Guarded loser tree, either copying the whole element into\n+      the tree structure, or looking up the element via the index.\n+   *  Guarding is done explicitly through one flag sup per element,\n+   *  inf is not needed due to a better initialization routine.\n+   *  This is a well-performing variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTreePointer\n+  {\n+  private:\n+    struct Loser\n+    {\n+      bool sup;\n+      int source;\n+      const T* keyp;\n+    };\n+\n+    unsigned int ik, k, offset;\n+    Loser* losers;\n+    Comparator comp;\n+\n+  public:\n+    inline LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    {\n+      ik = _k;\n+\n+      // Next greater power of 2.\n+      k = 1 << (log2(ik - 1) + 1);\n+      offset = k;\n+      losers = new Loser[k * 2];\n+      for (unsigned int i = ik - 1; i < k; i++)\n+\tlosers[i + k].sup = true;\n+    }\n+\n+    inline ~LoserTreePointer()\n+    { delete[] losers; }\n+\n+    void\n+    print()\n+    {\n+      for (unsigned int i = 0; i < (k * 2); i++)\n+\tprintf(\"%d    %d from %d,  %d\\n\", i, losers[i].keyp, losers[i].source, losers[i].sup);\n+    }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(const T& key, int source, bool sup)\n+    {\n+      unsigned int pos = k + source;\n+\n+      losers[pos].sup = sup;\n+      losers[pos].source = source;\n+      losers[pos].keyp = &key;\n+    }\n+\n+    unsigned int\n+    init_winner(unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (\tlosers[right].sup ||\n+\t\t(!losers[left].sup && !comp(*losers[right].keyp, *losers[left].keyp)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init()\n+    { losers[0] = losers[init_winner(1)]; }\n+\n+    inline void delete_min_insert(const T& key, bool sup)\n+    {\n+      const T* keyp = &key;\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].keyp, keyp);\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+      losers[0].keyp = keyp;\n+    }\n+\n+    inline void\n+    insert_start_stable(const T& key, int source, bool sup)\n+    { return insert_start(key, source, sup); }\n+\n+    unsigned int\n+    init_winner_stable (unsigned int root)\n+    {\n+      if (root >= k)\n+\t{\n+\t  return root;\n+\t}\n+      else\n+\t{\n+\t  unsigned int left = init_winner (2 * root);\n+\t  unsigned int right = init_winner (2 * root + 1);\n+\t  if (losers[right].sup\n+\t      || (!losers[left].sup && !comp(*losers[right].keyp, *losers[left].keyp)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init_stable()\n+    { losers[0] = losers[init_winner_stable(1)]; }\n+\n+    inline void\n+    delete_min_insert_stable(const T& key, bool sup)\n+    {\n+      const T* keyp = &key;\n+      int source = losers[0].source;\n+      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by source.\n+\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+\t\t(!sup && !losers[pos].sup &&\n+\t\t ((comp(*losers[pos].keyp, *keyp)) ||\n+\t\t  (!comp(*keyp, *losers[pos].keyp) && losers[pos].source < source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].sup, sup);\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].keyp, keyp);\n+\t    }\n+\t}\n+\n+      losers[0].sup = sup;\n+      losers[0].source = source;\n+      losers[0].keyp = keyp;\n+    }\n+  };\n+\n+#endif\n+\n+#if _GLIBCXX_LOSER_TREE_UNGUARDED\n+\n+  /** @brief Unguarded loser tree, copying the whole element into the\n+   * tree structure.\n+   *\n+   *  No guarding is done, therefore not a single input sequence must\n+   *  run empty.  This is a very fast variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTreeUnguarded\n+  {\n+  private:\n+    struct Loser\n+    {\n+      int source;\n+      T key;\n+    };\n+\n+    unsigned int ik, k, offset;\n+    unsigned int* mapping;\n+    Loser* losers;\n+    Comparator comp;\n+\n+    void\n+    map(unsigned int root, unsigned int begin, unsigned int end)\n+    {\n+      if (begin + 1 == end)\n+\tmapping[begin] = root;\n+      else\n+\t{\n+\t  // Next greater or equal power of 2.\n+\t  unsigned int left = 1 << (log2(end - begin - 1));\n+\t  map(root * 2, begin, begin + left);\n+\t  map(root * 2 + 1, begin + left, end);\n+\t}\n+    }\n+\n+  public:\n+    inline LoserTreeUnguarded(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    {\n+      ik = _k;\n+      // Next greater or equal power of 2.\n+      k = 1 << (log2(ik - 1) + 1);\n+      offset = k;\n+      losers = new Loser[k + ik];\n+      mapping = new unsigned int[ik];\n+      map(1, 0, ik);\n+    }\n+\n+    inline ~LoserTreeUnguarded()\n+    {\n+      delete[] losers;\n+      delete[] mapping;\n+    }\n+\n+    void\n+    print()\n+    {\n+      for (unsigned int i = 0; i < k + ik; i++)\n+\tprintf(\"%d    %d from %d\\n\", i, losers[i].key, losers[i].source);\n+    }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(const T& key, int source, bool)\n+    {\n+      unsigned int pos = mapping[source];\n+      losers[pos].source = source;\n+      losers[pos].key = key;\n+    }\n+\n+    unsigned int\n+    init_winner(unsigned int root, unsigned int begin, unsigned int end)\n+    {\n+      if (begin + 1 == end)\n+\treturn mapping[begin];\n+      else\n+\t{\n+\t  // Next greater or equal power of 2.\n+\t  unsigned int division = 1 << (log2(end - begin - 1));\n+\t  unsigned int left = init_winner(2 * root, begin, begin + division);\n+\t  unsigned int right = init_winner(2 * root + 1, begin + division, end);\n+\t  if (!comp(losers[right].key, losers[left].key))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init()\n+    { losers[0] = losers[init_winner(1, 0, ik)]; }\n+\n+    // Do not pass const reference since key will be used as local variable.\n+    inline void\n+    delete_min_insert(const T& key, bool)\n+    {\n+      losers[0].key = key;\n+      T& keyr = losers[0].key;\n+      int& source = losers[0].source;\n+      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (comp(losers[pos].key, keyr))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].key, keyr);\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    insert_start_stable(const T& key, int source, bool)\n+    { return insert_start(key, source, false); }\n+\n+    inline void\n+    init_stable()\n+    { init(); }\n+\n+    inline void\n+    delete_min_insert_stable(const T& key, bool)\n+    {\n+      losers[0].key = key;\n+      T& keyr = losers[0].key;\n+      int& source = losers[0].source;\n+      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by source.\n+\t  if (comp(losers[pos].key, keyr)\n+\t      || (!comp(keyr, losers[pos].key) && losers[pos].source < source))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].key, keyr);\n+\t    }\n+\t}\n+    }\n+  };\n+\n+#endif\n+\n+#if _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n+\n+  /** @brief Unguarded loser tree, keeping only pointers to the\n+   * elements in the tree structure.\n+   *\n+   *  No guarding is done, therefore not a single input sequence must\n+   *  run empty.  This is a very fast variant.\n+   */\n+  template<typename T, typename Comparator = std::less<T> >\n+  class LoserTreePointerUnguarded\n+  {\n+  private:\n+    struct Loser\n+    {\n+      int source;\n+      const T* keyp;\n+    };\n+\n+    unsigned int ik, k, offset;\n+    unsigned int* mapping;\n+    Loser* losers;\n+    Comparator comp;\n+\n+    void map(unsigned int root, unsigned int begin, unsigned int end)\n+    {\n+      if (begin + 1 == end)\n+\tmapping[begin] = root;\n+      else\n+\t{\n+\t  // Next greater or equal power of 2.\n+\t  unsigned int left = 1 << (log2(end - begin - 1));\n+\t  map(root * 2, begin, begin + left);\n+\t  map(root * 2 + 1, begin + left, end);\n+\t}\n+    }\n+\n+  public:\n+    inline LoserTreePointerUnguarded(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    {\n+      ik = _k;\n+\n+      // Next greater power of 2.\n+      k = 1 << (log2(ik - 1) + 1);\n+      offset = k;\n+      losers = new Loser[k + ik];\n+      mapping = new unsigned int[ik];\n+      map(1, 0, ik);\n+    }\n+\n+    inline ~LoserTreePointerUnguarded()\n+    {\n+      delete[] losers;\n+      delete[] mapping;\n+    }\n+\n+    void\n+    print()\n+    {\n+      for (unsigned int i = 0; i < k + ik; i++)\n+\tprintf(\"%d    %d from %d\\n\", i, *losers[i].keyp, losers[i].source);\n+    }\n+\n+    inline int\n+    get_min_source()\n+    { return losers[0].source; }\n+\n+    inline void\n+    insert_start(const T& key, int source, bool)\n+    {\n+      unsigned int pos = mapping[source];\n+      losers[pos].source = source;\n+      losers[pos].keyp = &key;\n+    }\n+\n+    unsigned int\n+    init_winner(unsigned int root, unsigned int begin, unsigned int end)\n+    {\n+      if (begin + 1 == end)\n+\treturn mapping[begin];\n+      else\n+\t{\n+\t  // Next greater or equal power of 2.\n+\t  unsigned int division = 1 << (log2(end - begin - 1));\n+\t  unsigned int left = init_winner(2 * root, begin, begin + division);\n+\t  unsigned int right = init_winner(2 * root + 1, begin + division, end);\n+\t  if (!comp(*losers[right].keyp, *losers[left].keyp))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      losers[root] = losers[right];\n+\t      return left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      losers[root] = losers[left];\n+\t      return right;\n+\t    }\n+\t}\n+    }\n+\n+    inline void\n+    init()\n+    {\n+      losers[0] = losers[init_winner(1, 0, ik)];\n+    }\n+\n+    inline void\n+    delete_min_insert(const T& key, bool)\n+    {\n+      const T* keyp = &key;\n+      int& source = losers[0].source;\n+      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (comp(*losers[pos].keyp, *keyp))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].keyp, keyp);\n+\t    }\n+\t}\n+\n+      losers[0].keyp = keyp;\n+    }\n+\n+    inline void\n+    insert_start_stable(const T& key, int source, bool)\n+    { return insert_start(key, source, false); }\n+\n+    inline void\n+    init_stable()\n+    { init(); }\n+\n+    inline void\n+    delete_min_insert_stable(const T& key, bool)\n+    {\n+      int& source = losers[0].source;\n+      const T* keyp = &key;\n+      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by source.\n+\t  if (comp(*losers[pos].keyp, *keyp)\n+\t      || (!comp(*keyp, *losers[pos].keyp) && losers[pos].source < source))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(losers[pos].source, source);\n+\t      std::swap(losers[pos].keyp, keyp);\n+\t    }\n+\t}\n+      losers[0].keyp = keyp;\n+    }\n+  };\n+#endif\n+}\n+\n+#endif"}, {"sha": "0bf29497f534e30667901a47ecb174f03557939c", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,230 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/merge.h\n+ *  @brief Parallel implementation of std::merge().\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_MERGE_H\n+#define _GLIBCXX_PARALLEL_MERGE_H 1\n+\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_algo.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Merge routine being able to merge only the @c max_length\n+   * smallest elements.\n+   *\n+   * The @c begin iterators are advanced accordingly, they might not\n+   * reach @c end, in contrast to the usual variant.\n+   * @param begin1 Begin iterator of first sequence.\n+   * @param end1 End iterator of first sequence.\n+   * @param begin2 Begin iterator of second sequence.\n+   * @param end2 End iterator of second sequence.\n+   * @param target Target begin iterator.\n+   * @param max_length Maximum number of elements to merge.\n+   * @param comp Comparator.\n+   * @return Output end iterator. */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n+  OutputIterator\n+  merge_advance_usual(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n+  {\n+    typedef _DifferenceTp difference_type;\n+    while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+      {\n+\t// array1[i1] < array0[i0]\n+\tif (comp(*begin2, *begin1))\n+\t  *target++ = *begin2++;\n+\telse\n+\t  *target++ = *begin1++;\n+\tmax_length--;\n+      }\n+\n+    if (begin1 != end1)\n+      {\n+\ttarget = std::copy(begin1, begin1 + max_length, target);\n+\tbegin1 += max_length;\n+      }\n+    else\n+      {\n+\ttarget = std::copy(begin2, begin2 + max_length, target);\n+\tbegin2 += max_length;\n+      }\n+    return target;\n+  }\n+\n+  /** @brief Merge routine being able to merge only the @c max_length\n+   * smallest elements.\n+   *\n+   * The @c begin iterators are advanced accordingly, they might not\n+   * reach @c end, in contrast to the usual variant.\n+   * Specially designed code should allow the compiler to generate\n+   * conditional moves instead of branches.\n+   * @param begin1 Begin iterator of first sequence.\n+   * @param end1 End iterator of first sequence.\n+   * @param begin2 Begin iterator of second sequence.\n+   * @param end2 End iterator of second sequence.\n+   * @param target Target begin iterator.\n+   * @param max_length Maximum number of elements to merge.\n+   * @param comp Comparator.\n+   * @return Output end iterator. */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n+  OutputIterator\n+  merge_advance_movc(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n+  {\n+    typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type value_type1;\n+    typedef typename std::iterator_traits<RandomAccessIterator2>::value_type value_type2;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(max_length >= 0);\n+#endif\n+\n+    while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+      {\n+\tvalue_type1 element1;\n+\tvalue_type2 element2;\n+\tRandomAccessIterator1 next1;\n+\tRandomAccessIterator2 next2;\n+\n+\tnext1 = begin1 + 1;\n+\tnext2 = begin2 + 1;\n+\telement1 = *begin1;\n+\telement2 = *begin2;\n+\n+\tif (comp(element2, element1))\n+\t  {\n+\t    element1 = element2;\n+\t    begin2 = next2;\n+\t  }\n+\telse\n+\t  {\n+\t    begin1 = next1;\n+\t  }\n+\n+\t*target = element1;\n+\n+\ttarget++;\n+\tmax_length--;\n+      }\n+    if (begin1 != end1)\n+      {\n+\ttarget = std::copy(begin1, begin1 + max_length, target);\n+\tbegin1 += max_length;\n+      }\n+    else\n+      {\n+\ttarget = std::copy(begin2, begin2 + max_length, target);\n+\tbegin2 += max_length;\n+      }\n+    return target;\n+  }\n+\n+  /** @brief Merge routine being able to merge only the @c max_length\n+   * smallest elements.\n+   *\n+   *  The @c begin iterators are advanced accordingly, they might not\n+   *  reach @c end, in contrast to the usual variant.\n+   *  Static switch on whether to use the conditional-move variant.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence.\n+   *  @param end2 End iterator of second sequence.\n+   *  @param target Target begin iterator.\n+   *  @param max_length Maximum number of elements to merge.\n+   *  @param comp Comparator.\n+   *  @return Output end iterator. */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename OutputIterator, typename _DifferenceTp, typename Comparator>\n+  inline OutputIterator\n+  merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator2& begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\n+  {\n+    _GLIBCXX_CALL(max_length)\n+\n+      return merge_advance_movc(begin1, end1, begin2, end2, target, max_length, comp);\n+  }\n+\n+  /** @brief Merge routine fallback to sequential in case the\n+      iterators of the two input sequences are of different type.\n+      *  @param begin1 Begin iterator of first sequence.\n+      *  @param end1 End iterator of first sequence.\n+      *  @param begin2 Begin iterator of second sequence.\n+      *  @param end2 End iterator of second sequence.\n+      *  @param target Target begin iterator.\n+      *  @param max_length Maximum number of elements to merge.\n+      *  @param comp Comparator.\n+      *  @return Output end iterator. */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename RandomAccessIterator3, typename Comparator>\n+  inline RandomAccessIterator3\n+  parallel_merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1,\n+\t\t\t RandomAccessIterator2& begin2, RandomAccessIterator2 end2,\t//different iterators, parallel implementation not available\n+\t\t\t RandomAccessIterator3 target,\n+\t\t\t typename std::iterator_traits<RandomAccessIterator1>::difference_type max_length, Comparator comp)\n+  {\n+    return merge_advance(begin1, end1, begin2, end2, target, max_length, comp);\n+  }\n+\n+  /** @brief Parallel merge routine being able to merge only the @c\n+   * max_length smallest elements.\n+   *\n+   *  The @c begin iterators are advanced accordingly, they might not\n+   *  reach @c end, in contrast to the usual variant.\n+   *  The functionality is projected onto parallel_multiway_merge.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence.\n+   *  @param end2 End iterator of second sequence.\n+   *  @param target Target begin iterator.\n+   *  @param max_length Maximum number of elements to merge.\n+   *  @param comp Comparator.\n+   *  @return Output end iterator.\n+   */\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator3, typename Comparator>\n+  inline RandomAccessIterator3\n+  parallel_merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1, RandomAccessIterator1& begin2, RandomAccessIterator1 end2, RandomAccessIterator3 target, typename std::iterator_traits<RandomAccessIterator1>::difference_type max_length, Comparator comp)\n+  {\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n+      difference_type1 /* == difference_type2 */;\n+    typedef typename std::iterator_traits<RandomAccessIterator3>::difference_type\n+      difference_type3;\n+\n+    std::pair<RandomAccessIterator1, RandomAccessIterator1> seqs[2] = { std::make_pair(begin1, end1), std::make_pair(begin2, end2) };\n+    RandomAccessIterator3 target_end = parallel_multiway_merge(seqs, seqs + 2, target, comp, max_length, true, false);\n+\n+    return target_end;\n+  }\n+}\t//namespace __gnu_parallel\n+\n+#endif"}, {"sha": "5b34173cff284a68f19dd35ccec8b863b63d4563", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,608 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/multiseq_selection.h\n+ *  @brief Functions to find elements of a certain global rank in\n+ *  multiple sorted sequences.  Also serves for splitting such\n+ *  sequence sets.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_MULTISEQ_SELECTION_H\n+#define _GLIBCXX_PARALLEL_MULTISEQ_SELECTION_H 1\n+\n+#include <vector>\n+#include <queue>\n+\n+#include <bits/stl_algo.h>\n+\n+#include <parallel/sort.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Compare a pair of types lexicographically, ascending. */\n+  template<typename T1, typename T2, typename Comparator>\n+  class lexicographic : public std::binary_function<std::pair<T1, T2>, std::pair<T1, T2>, bool>\n+  {\n+  private:\n+    Comparator& comp;\n+\n+  public:\n+    lexicographic(Comparator& _comp) : comp(_comp) { }\n+\n+    // XXX const\n+    inline bool\n+    operator()(const std::pair<T1, T2>& p1, const std::pair<T1, T2>& p2) const\n+    {\n+      if (comp(p1.first, p2.first))\n+\treturn true;\n+\n+      if (comp(p2.first, p1.first))\n+\treturn false;\n+\n+      // Firsts are equal.\n+      return p1.second < p2.second;\n+    }\n+  };\n+\n+  /** @brief Compare a pair of types lexicographically, descending. */\n+  template<typename T1, typename T2, typename Comparator>\n+  class lexicographic_reverse : public std::binary_function<T1, T2, bool>\n+  {\n+  private:\n+    Comparator& comp;\n+\n+  public:\n+    lexicographic_reverse(Comparator& _comp) : comp(_comp) { }\n+\n+    inline bool\n+    operator()(const std::pair<T1, T2>& p1, const std::pair<T1, T2>& p2) const\n+    {\n+      if (comp(p2.first, p1.first))\n+\treturn true;\n+\n+      if (comp(p1.first, p2.first))\n+\treturn false;\n+\n+      // Firsts are equal.\n+      return p2.second < p1.second;\n+    }\n+  };\n+\n+  /** \n+   *  @brief Splits several sorted sequences at a certain global rank,\n+   *  resulting in a splitting point for each sequence.\n+   *  The sequences are passed via a sequence of random-access\n+   *  iterator pairs, none of the sequences may be empty.  If there\n+   *  are several equal elements across the split, the ones on the\n+   *  left side will be chosen from sequences with smaller number.\n+   *  @param begin_seqs Begin of the sequence of iterator pairs.\n+   *  @param end_seqs End of the sequence of iterator pairs.\n+   *  @param rank The global rank to partition at.\n+   *  @param begin_offsets A random-access sequence begin where the\n+   *  result will be stored in. Each element of the sequence is an\n+   *  iterator that points to the first element on the greater part of\n+   *  the respective sequence.\n+   *  @param comp The ordering functor, defaults to std::less<T>. \n+   */\n+  template<typename RanSeqs, typename RankType, typename RankIterator, typename Comparator>\n+  void \n+  multiseq_partition(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n+\t\t     RankIterator begin_offsets,\n+\t\t     Comparator comp = std::less<\n+\t\t     typename std::iterator_traits<typename std::iterator_traits<RanSeqs>::value_type::first_type>::value_type>()) // std::less<T>\n+  {\n+    _GLIBCXX_CALL(end_seqs - begin_seqs)\n+\n+    typedef typename std::iterator_traits<RanSeqs>::value_type::first_type It;\n+    typedef typename std::iterator_traits<It>::difference_type difference_type;\n+    typedef typename std::iterator_traits<It>::value_type T;\n+\n+    lexicographic<T, int, Comparator> lcomp(comp);\n+    lexicographic_reverse<T, int, Comparator> lrcomp(comp);\n+\n+    // Number of sequences, number of elements in total (possibly\n+    // including padding).\n+    difference_type m = std::distance(begin_seqs, end_seqs), N = 0, nmax, n, r;\n+\n+    for (int i = 0; i < m; i++)\n+      N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\n+    if (rank == N)\n+      {\n+\tfor (int i = 0; i < m; i++)\n+\t  begin_offsets[i] = begin_seqs[i].second; // Very end.\n+\t// Return m - 1;\n+      }\n+\n+    _GLIBCXX_PARALLEL_ASSERT(m != 0 && N != 0 && rank >= 0 && rank < N);\n+\n+    difference_type* ns = new difference_type[m];\n+    difference_type* a = new difference_type[m];\n+    difference_type* b = new difference_type[m];\n+    difference_type l;\n+\n+    ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n+    nmax = ns[0];\n+    for (int i = 0; i < m; i++)\n+      {\n+\tns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\tnmax = std::max(nmax, ns[i]);\n+      }\n+\n+    r = log2(nmax) + 1;\n+\n+    // Pad all lists to this length, at least as long as any ns[i],\n+    // equality iff nmax = 2^k - 1.\n+    l = (1ULL << r) - 1;\n+\n+    // From now on, including padding.\n+    N = l * m;\n+\n+    for (int i = 0; i < m; i++)\n+      {\n+\ta[i] = 0;\n+\tb[i] = l;\n+      }\n+    n = l / 2;\n+\n+    // Invariants:\n+    // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+\n+#define S(i) (begin_seqs[i].first)\n+\n+    // Initial partition.\n+    std::vector<std::pair<T, int> > sample;\n+\n+    for (int i = 0; i < m; i++)\n+      if (n < ns[i])\t//sequence long enough\n+\tsample.push_back(std::make_pair(S(i)[n], i));\n+    __gnu_sequential::sort(sample.begin(), sample.end(), lcomp);\n+\n+    for (int i = 0; i < m; i++)\t//conceptual infinity\n+      if (n >= ns[i])\t//sequence too short, conceptual infinity\n+\tsample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+\n+    difference_type localrank = rank * m / N ;\n+\n+    int j;\n+    for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+      a[sample[j].second] += n + 1;\n+    for (; j < m; j++)\n+      b[sample[j].second] -= n + 1;\n+\n+    // Further refinement.\n+    while (n > 0)\n+      {\n+\tn /= 2;\n+\n+\tint lmax_seq = -1;\t// to avoid warning\n+\tconst T* lmax = NULL;\t// impossible to avoid the warning?\n+\tfor (int i = 0; i < m; i++)\n+\t  {\n+\t    if (a[i] > 0)\n+\t      {\n+\t\tif (!lmax)\n+\t\t  {\n+\t\t    lmax = &(S(i)[a[i] - 1]);\n+\t\t    lmax_seq = i;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    // Max, favor rear sequences.\n+\t\t    if (!comp(S(i)[a[i] - 1], *lmax))\n+\t\t      {\n+\t\t\tlmax = &(S(i)[a[i] - 1]);\n+\t\t\tlmax_seq = i;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tint i;\n+\tfor (i = 0; i < m; i++)\n+\t  {\n+\t    difference_type middle = (b[i] + a[i]) / 2;\n+\t    if (lmax && middle < ns[i] &&\n+\t\tlcomp(std::make_pair(S(i)[middle], i), std::make_pair(*lmax, lmax_seq)))\n+\t      a[i] = std::min(a[i] + n + 1, ns[i]);\n+\t    else\n+\t      b[i] -= n + 1;\n+\t  }\n+\n+\tdifference_type leftsize = 0, total = 0;\n+\tfor (int i = 0; i < m; i++)\n+\t  {\n+\t    leftsize += a[i] / (n + 1);\n+\t    total += l / (n + 1);\n+\t  }\n+\n+\tdifference_type skew = static_cast<difference_type>(static_cast<uint64>(total) * rank / N - leftsize);\n+\n+\tif (skew > 0)\n+\t  {\n+\t    // Move to the left, find smallest.\n+\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n+\n+\t    for (int i = 0; i < m; i++)\n+\t      if (b[i] < ns[i])\n+\t\tpq.push(std::make_pair(S(i)[b[i]], i));\n+\n+\t    for (; skew != 0 && !pq.empty(); skew--)\n+\t      {\n+\t\tint source = pq.top().second;\n+\t\tpq.pop();\n+\n+\t\ta[source] = std::min(a[source] + n + 1, ns[source]);\n+\t\tb[source] += n + 1;\n+\n+\t\tif (b[source] < ns[source])\n+\t\t  pq.push(std::make_pair(S(source)[b[source]], source));\n+\t      }\n+\t  }\n+\telse if (skew < 0)\n+\t  {\n+\t    // Move to the right, find greatest.\n+\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic<T, int, Comparator> > pq(lcomp);\n+\n+\t    for (int i = 0; i < m; i++)\n+\t      if (a[i] > 0)\n+\t\tpq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\n+\t    for (; skew != 0; skew++)\n+\t      {\n+\t\tint source = pq.top().second;\n+\t\tpq.pop();\n+\n+\t\ta[source] -= n + 1;\n+\t\tb[source] -= n + 1;\n+\n+\t\tif (a[source] > 0)\n+\t\t  pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t      }\n+\t  }\n+      }\n+\n+    // Postconditions:\n+    // a[i] == b[i] in most cases, except when a[i] has been clamped\n+    // because of having reached the boundary\n+\n+    // Now return the result, calculate the offset.\n+\n+    // Compare the keys on both edges of the border.\n+\n+    // Maximum of left edge, minimum of right edge.\n+    bool maxleftset = false, minrightset = false;\n+    T maxleft, minright;\t// Impossible to avoid the warning?\n+    for (int i = 0; i < m; i++)\n+      {\n+\tif (a[i] > 0)\n+\t  {\n+\t    if (!maxleftset)\n+\t      {\n+\t\tmaxleft = S(i)[a[i] - 1];\n+\t\tmaxleftset = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Max, favor rear sequences.\n+\t\tif (!comp(S(i)[a[i] - 1], maxleft))\n+\t\t  maxleft = S(i)[a[i] - 1];\n+\t      }\n+\t  }\n+\tif (b[i] < ns[i])\n+\t  {\n+\t    if (!minrightset)\n+\t      {\n+\t\tminright = S(i)[b[i]];\n+\t\tminrightset = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Min, favor fore sequences.\n+\t\tif (comp(S(i)[b[i]], minright))\n+\t\t  minright = S(i)[b[i]];\n+\t      }\n+\t  }\n+      }\n+\n+    int seq = 0;\n+    for (int i = 0; i < m; i++)\n+      begin_offsets[i] = S(i) + a[i];\n+\n+    delete[] ns;\n+    delete[] a;\n+    delete[] b;\n+  }\n+\n+\n+\n+  /** \n+   *  @brief Selects the element at a certain global rank from several\n+   *  sorted sequences.\n+   *\n+   *  The sequences are passed via a sequence of random-access\n+   *  iterator pairs, none of the sequences may be empty.\n+   *  @param begin_seqs Begin of the sequence of iterator pairs.\n+   *  @param end_seqs End of the sequence of iterator pairs.\n+   *  @param rank The global rank to partition at.\n+   *  @param offset The rank of the selected element in the global\n+   *  subsequence of elements equal to the selected element. If the\n+   *  selected element is unique, this number is 0.\n+   *  @param comp The ordering functor, defaults to std::less. \n+   */\n+  template<typename T, typename RanSeqs, typename RankType, typename Comparator>\n+  T \n+  multiseq_selection(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n+\t\t     RankType& offset, Comparator comp = std::less<T>())\n+  {\n+    _GLIBCXX_CALL(end_seqs - begin_seqs)\n+\n+    typedef typename std::iterator_traits<RanSeqs>::value_type::first_type It;\n+    typedef typename std::iterator_traits<It>::difference_type difference_type;\n+\n+    lexicographic<T, int, Comparator> lcomp(comp);\n+    lexicographic_reverse<T, int, Comparator> lrcomp(comp);\n+\n+    // Number of sequences, number of elements in total (possibly\n+    // including padding).\n+    difference_type m = std::distance(begin_seqs, end_seqs);\n+    difference_type N = 0;\n+    difference_type nmax, n, r;\n+\n+    for (int i = 0; i < m; i++)\n+      N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\n+    if (m == 0 || N == 0 || rank < 0 || rank >= N)\n+      {\n+\t// Result undefined when there is no data or rank is outside bounds.\n+\tthrow std::exception();\n+      }\n+\n+\n+    difference_type* ns = new difference_type[m];\n+    difference_type* a = new difference_type[m];\n+    difference_type* b = new difference_type[m];\n+    difference_type l;\n+\n+    ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n+    nmax = ns[0];\n+    for (int i = 0; i < m; i++)\n+      {\n+\tns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+\tnmax = std::max(nmax, ns[i]);\n+      }\n+\n+    r = log2(nmax) + 1;\n+\n+    // Pad all lists to this length, at least as long as any ns[i],\n+    // equality iff nmax = 2^k - 1\n+    l = pow2(r) - 1;\n+\n+    // From now on, including padding.\n+    N = l * m;\n+\n+    for (int i = 0; i < m; i++)\n+      {\n+\ta[i] = 0;\n+\tb[i] = l;\n+      }\n+    n = l / 2;\n+\n+    // Invariants:\n+    // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+\n+#define S(i) (begin_seqs[i].first)\n+\n+    // Initial partition.\n+    std::vector<std::pair<T, int> > sample;\n+\n+    for (int i = 0; i < m; i++)\n+      if (n < ns[i])\n+\tsample.push_back(std::make_pair(S(i)[n], i));\n+    __gnu_sequential::sort(sample.begin(), sample.end(), lcomp, sequential_tag());\n+\n+    // Conceptual infinity.\n+    for (int i = 0; i < m; i++)\n+      if (n >= ns[i])\n+\tsample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+\n+    difference_type localrank = rank * m / N ;\n+\n+    int j;\n+    for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+      a[sample[j].second] += n + 1;\n+    for (; j < m; j++)\n+      b[sample[j].second] -= n + 1;\n+\n+    // Further refinement.\n+    while (n > 0)\n+      {\n+\tn /= 2;\n+\n+\tconst T* lmax = NULL;\n+\tfor (int i = 0; i < m; i++)\n+\t  {\n+\t    if (a[i] > 0)\n+\t      {\n+\t\tif (!lmax)\n+\t\t  {\n+\t\t    lmax = &(S(i)[a[i] - 1]);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (comp(*lmax, S(i)[a[i] - 1]))\t//max\n+\t\t      lmax = &(S(i)[a[i] - 1]);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tint i;\n+\tfor (i = 0; i < m; i++)\n+\t  {\n+\t    difference_type middle = (b[i] + a[i]) / 2;\n+\t    if (lmax && middle < ns[i] && comp(S(i)[middle], *lmax))\n+\t      a[i] = std::min(a[i] + n + 1, ns[i]);\n+\t    else\n+\t      b[i] -= n + 1;\n+\t  }\n+\n+\tdifference_type leftsize = 0, total = 0;\n+\tfor (int i = 0; i < m; i++)\n+\t  {\n+\t    leftsize += a[i] / (n + 1);\n+\t    total += l / (n + 1);\n+\t  }\n+\n+\tdifference_type skew = (unsigned long long)total * rank / N - leftsize;\n+\n+\tif (skew > 0)\n+\t  {\n+\t    // Move to the left, find smallest.\n+\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n+\n+\t    for (int i = 0; i < m; i++)\n+\t      if (b[i] < ns[i])\n+\t\tpq.push(std::make_pair(S(i)[b[i]], i));\n+\n+\t    for (; skew != 0 && !pq.empty(); skew--)\n+\t      {\n+\t\tint source = pq.top().second;\n+\t\tpq.pop();\n+\n+\t\ta[source] = std::min(a[source] + n + 1, ns[source]);\n+\t\tb[source] += n + 1;\n+\n+\t\tif (b[source] < ns[source])\n+\t\t  pq.push(std::make_pair(S(source)[b[source]], source));\n+\t      }\n+\t  }\n+\telse if (skew < 0)\n+\t  {\n+\t    // Move to the right, find greatest.\n+\t    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, lexicographic<T, int, Comparator> > pq(lcomp);\n+\n+\t    for (int i = 0; i < m; i++)\n+\t      if (a[i] > 0)\n+\t\tpq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\n+\t    for (; skew != 0; skew++)\n+\t      {\n+\t\tint source = pq.top().second;\n+\t\tpq.pop();\n+\n+\t\ta[source] -= n + 1;\n+\t\tb[source] -= n + 1;\n+\n+\t\tif (a[source] > 0)\n+\t\t  pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t      }\n+\t  }\n+      }\n+\n+    // Postconditions:\n+    // a[i] == b[i] in most cases, except when a[i] has been clamped\n+    // because of having reached the boundary\n+\n+    // Now return the result, calculate the offset.\n+\n+    // Compare the keys on both edges of the border.\n+\n+    // Maximum of left edge, minimum of right edge.\n+    bool maxleftset = false, minrightset = false;\n+\n+    // Impossible to avoid the warning?\n+    T maxleft, minright;\n+    for (int i = 0; i < m; i++)\n+      {\n+\tif (a[i] > 0)\n+\t  {\n+\t    if (!maxleftset)\n+\t      {\n+\t\tmaxleft = S(i)[a[i] - 1];\n+\t\tmaxleftset = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Max.\n+\t\tif (comp(maxleft, S(i)[a[i] - 1]))\n+\t\t  maxleft = S(i)[a[i] - 1];\n+\t      }\n+\t  }\n+\tif (b[i] < ns[i])\n+\t  {\n+\t    if (!minrightset)\n+\t      {\n+\t\tminright = S(i)[b[i]];\n+\t\tminrightset = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Min.\n+\t\tif (comp(S(i)[b[i]], minright))\n+\t\t  minright = S(i)[b[i]];\n+\t      }\n+\t  }\n+      }\n+\n+    // Minright is the splitter, in any case.\n+\n+    if (!maxleftset || comp(minright, maxleft))\n+      {\n+\t// Good luck, everything is split unambigiously.\n+\toffset = 0;\n+      }\n+    else\n+      {\n+\t// We have to calculate an offset.\n+\toffset = 0;\n+\n+\tfor (int i = 0; i < m; i++)\n+\t  {\n+\t    difference_type lb = std::lower_bound(S(i), S(i) + ns[i], minright,\n+\t\t\t\t\t\t  comp) - S(i);\n+\t    offset += a[i] - lb;\n+\t  }\n+      }\n+\n+    delete[] ns;\n+    delete[] a;\n+    delete[] b;\n+\n+    return minright;\n+  }\n+}\n+\n+#undef S\n+\n+#endif\n+"}, {"sha": "cdafacbd7a8deeabfc08f29019568cb92c02edbb", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "added", "additions": 1639, "deletions": 0, "changes": 1639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,1639 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/multiway_merge.h\n+ *  @brief Implementation of sequential and parallel multiway merge.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_MULTIWAY_MERGE_H\n+#define _GLIBCXX_PARALLEL_MULTIWAY_MERGE_H\n+\n+#include <vector>\n+\n+#include <bits/stl_algo.h>\n+#include <parallel/features.h>\n+#include <parallel/parallel.h>\n+#include <parallel/merge.h>\n+#include <parallel/losertree.h>\n+#include <parallel/timing.h>\n+#if _GLIBCXX_ASSERTIONS\n+#include <parallel/checkers.h>\n+#endif\n+\n+/** @brief Length of a sequence described by a pair of iterators. */\n+#define LENGTH(s) ((s).second - (s).first)\n+\n+// XXX need iterator typedefs\n+namespace __gnu_parallel\n+{\n+  template<typename RandomAccessIterator, typename Comparator>\n+  class guarded_iterator;\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t    guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+  /** @brief Iterator wrapper supporting an implicit supremum at the end\n+      of the sequence, dominating all comparisons.\n+      *  Deriving from RandomAccessIterator is not possible since\n+      *  RandomAccessIterator need not be a class.\n+      */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  class guarded_iterator\n+  {\n+  private:\n+    /** @brief Current iterator position. */\n+    RandomAccessIterator current;\n+\n+    /** @brief End iterator of the sequence. */\n+    RandomAccessIterator end;\n+\n+    /** @brief Comparator. */\n+    Comparator& comp;\n+\n+  public:\n+    /** @brief Constructor. Sets iterator to beginning of sequence.\n+     *  @param begin Begin iterator of sequence.\n+     *  @param end End iterator of sequence.\n+     *  @param comp Comparator provided for associated overloaded\n+     *  compare operators. */\n+    inline guarded_iterator(RandomAccessIterator begin, \n+\t\t\t    RandomAccessIterator end, Comparator& comp) \n+    : current(begin), end(end), comp(comp)\n+    { }\n+\n+    /** @brief Pre-increment operator.\n+     *  @return This. */\n+    inline guarded_iterator<RandomAccessIterator, Comparator>&\n+    operator++()\n+    {\n+      ++current;\n+      return *this;\n+    }\n+\n+    /** @brief Dereference operator.\n+     *  @return Referenced element. */\n+    inline typename std::iterator_traits<RandomAccessIterator>::value_type\n+    operator*()\n+    { return *current; }\n+\n+    /** @brief Convert to wrapped iterator.\n+     *  @return Wrapped iterator. */\n+    inline operator RandomAccessIterator()\n+    { return current; }\n+\n+    friend bool\n+    operator< <RandomAccessIterator, Comparator>(guarded_iterator<RandomAccessIterator, Comparator>& bi1, guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+    friend bool\n+    operator<= <RandomAccessIterator, Comparator>(guarded_iterator<RandomAccessIterator, Comparator>& bi1, guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+  };\n+\n+  /** @brief Compare two elements referenced by guarded iterators.\n+   *  @param bi1 First iterator.\n+   *  @param bi2 Second iterator.\n+   *  @return @c True if less. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t    guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+  {\n+    if (bi1.current == bi1.end)\t//bi1 is sup\n+      return bi2.current == bi2.end;\t//bi2 is not sup\n+    if (bi2.current == bi2.end)\t//bi2 is sup\n+      return true;\n+    return (bi1.comp)(*bi1, *bi2);\t//normal compare\n+  }\n+\n+  /** @brief Compare two elements referenced by guarded iterators.\n+   *  @param bi1 First iterator.\n+   *  @param bi2 Second iterator.\n+   *  @return @c True if less equal. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+  {\n+    if (bi2.current == bi2.end)\t//bi1 is sup\n+      return bi1.current != bi1.end;\t//bi2 is not sup\n+    if (bi1.current == bi1.end)\t//bi2 is sup\n+      return false;\n+    return !(bi1.comp)(*bi2, *bi1);\t//normal compare\n+  }\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  class unguarded_iterator;\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t    unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<=(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t     unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+  template<typename RandomAccessIterator, typename Comparator>\n+  class unguarded_iterator\n+  {\n+  private:\n+    /** @brief Current iterator position. */\n+    RandomAccessIterator& current;\n+    /** @brief Comparator. */\n+    mutable Comparator& comp;\n+\n+  public:\n+    /** @brief Constructor. Sets iterator to beginning of sequence.\n+     *  @param begin Begin iterator of sequence.\n+     *  @param end Unused, only for compatibility.\n+     *  @param comp Unused, only for compatibility. */\n+    inline unguarded_iterator(RandomAccessIterator begin, \n+\t\t\t      RandomAccessIterator end, Comparator& comp) \n+    : current(begin), comp(comp)\n+    { }\n+\n+    /** @brief Pre-increment operator.\n+     *  @return This. */\n+    inline  unguarded_iterator<RandomAccessIterator, Comparator>&\n+    operator++()\n+    {\n+      current++;\n+      return *this;\n+    }\n+\n+    /** @brief Dereference operator.\n+     *  @return Referenced element. */\n+    inline typename std::iterator_traits<RandomAccessIterator>::value_type \n+    operator*()\n+    { return *current; }\n+\n+    /** @brief Convert to wrapped iterator.\n+     *  @return Wrapped iterator. */\n+    inline\n+    operator RandomAccessIterator()\n+    { return current; }\n+\n+    friend bool\n+    operator< <RandomAccessIterator, Comparator>(unguarded_iterator<RandomAccessIterator, Comparator>& bi1, unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\n+    friend bool\n+    operator<= <RandomAccessIterator, Comparator>(unguarded_iterator<RandomAccessIterator, Comparator>& bi1, unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+  };\n+\n+  /** @brief Compare two elements referenced by unguarded iterators.\n+   *  @param bi1 First iterator.\n+   *  @param bi2 Second iterator.\n+   *  @return @c True if less. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t    unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+  {\n+    // Normal compare.\n+    return (bi1.comp)(*bi1, *bi2);\n+  }\n+\n+  /** @brief Compare two elements referenced by unguarded iterators.\n+   *  @param bi1 First iterator.\n+   *  @param bi2 Second iterator.\n+   *  @return @c True if less equal. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline bool\n+  operator<=(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+\t     unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+  {\n+    // Normal compare.\n+    return !(bi1.comp)(*bi2, *bi1);\n+  }\n+\n+  /** Prepare a set of sequences to be merged without a (end) guard\n+   *  @param seqs_begin\n+   *  @param seqs_end\n+   *  @param comp\n+   *  @param min_sequence\n+   *  @param stable\n+   *  @pre (seqs_end - seqs_begin > 0) */\n+  template<typename RandomAccessIteratorIterator, typename Comparator>\n+  typename std::iterator_traits<typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n+  prepare_unguarded(RandomAccessIteratorIterator seqs_begin,\n+\t\t    RandomAccessIteratorIterator seqs_end, Comparator comp,\n+\t\t    int& min_sequence, bool stable)\n+  {\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+      typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n+      difference_type;\n+\n+    if ((*seqs_begin).first == (*seqs_begin).second)\n+      {\n+\t// Empty sequence found, it's the first one.\n+\tmin_sequence = 0;\n+\treturn -1;\n+      }\n+\n+    // Last element in sequence.\n+    value_type min = *((*seqs_begin).second - 1);\n+    min_sequence = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin + 1; s != seqs_end; s++)\n+      {\n+\tif ((*s).first == (*s).second)\n+\t  {\n+\t    // Empty sequence found.\n+\t    min_sequence = static_cast<int>(s - seqs_begin);\n+\t    return -1;\n+\t  }\n+\n+\t// Last element in sequence.\n+\tconst value_type& v = *((*s).second - 1);\n+\tif (comp(v, min))\t//strictly smaller\n+\t  {\n+\t    min = v;\n+\t    min_sequence = static_cast<int>(s - seqs_begin);\n+\t  }\n+      }\n+\n+    difference_type overhang_size = 0;\n+\n+    int s = 0;\n+    for (s = 0; s <= min_sequence; s++)\n+      {\n+\tRandomAccessIterator1 split;\n+\tif (stable)\n+\t  split = std::upper_bound(seqs_begin[s].first, seqs_begin[s].second,\n+\t\t\t\t   min, comp);\n+\telse\n+\t  split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second,\n+\t\t\t\t   min, comp);\n+\n+\toverhang_size += seqs_begin[s].second - split;\n+      }\n+\n+    for (; s < (seqs_end - seqs_begin); s++)\n+      {\n+\tRandomAccessIterator1 split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second, min, comp);\n+\toverhang_size += seqs_begin[s].second - split;\n+      }\n+\n+    // So many elements will be left over afterwards.\n+    return overhang_size;\n+  }\n+\n+  /** Prepare a set of sequences to be merged with a (end) guard (sentinel)\n+   *  @param seqs_begin\n+   *  @param seqs_end\n+   *  @param comp */\n+  template<typename RandomAccessIteratorIterator, typename Comparator>\n+  typename std::iterator_traits<typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n+  prepare_unguarded_sentinel(RandomAccessIteratorIterator seqs_begin,\n+\t\t\t     RandomAccessIteratorIterator seqs_end,\n+\t\t\t     Comparator comp)\n+  {\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n+      difference_type;\n+\n+    // Last element in sequence.\n+    value_type max;\n+    bool max_found = false;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+      {\n+\tif ((*s).first == (*s).second)\n+\t  continue;\n+\n+\t// Last element in sequence.\n+\tvalue_type& v = *((*s).second - 1);\n+\n+\t// Strictly greater.\n+\tif (!max_found || comp(max, v))\n+\t  max = v;\n+\tmax_found = true;\n+      }\n+\n+    difference_type overhang_size = 0;\n+\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+      {\n+\tRandomAccessIterator1 split = std::lower_bound((*s).first, (*s).second, max, comp);\n+\toverhang_size += (*s).second - split;\n+\n+\t// Set sentinel.\n+\t*((*s).second) = max;\n+      }\n+\n+    // So many elements will be left over afterwards.\n+    return overhang_size;\n+  }\n+\n+  /** @brief Highly efficient 3-way merging procedure.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Unused, stable anyway.\n+   *  @return End iterator of output sequence. */\n+  template<template<typename RAI, typename C> class iterator, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_3_variant(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length);\n+    \n+    typedef _DifferenceTp difference_type;\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    if (length == 0)\n+      return target;\n+\n+    iterator<RandomAccessIterator1, Comparator>\n+      seq0(seqs_begin[0].first, seqs_begin[0].second, comp),\n+      seq1(seqs_begin[1].first, seqs_begin[1].second, comp),\n+      seq2(seqs_begin[2].first, seqs_begin[2].second, comp);\n+\n+    if (seq0 <= seq1)\n+      {\n+\tif (seq1 <= seq2)\n+\t  goto s012;\n+\telse\n+\t  if (seq2 <  seq0)\n+\t    goto s201;\n+\t  else\n+\t    goto s021;\n+      }\n+    else\n+      {\n+\tif (seq1 <= seq2)\n+\t  {\n+\t    if (seq0 <= seq2)\n+\t      goto s102;\n+\t    else\n+\t      goto s120;\n+\t  }\n+\telse\n+\t  goto s210;\n+      }\n+\n+#define Merge3Case(a,b,c,c0,c1)\t\t\t\t\\\n+    s ## a ## b ## c :\t\t\t\t\t\\\n+      *target = *seq ## a;\t\t\t\t\\\n+    ++target;\t\t\t\t\t\t\\\n+    length--;\t\t\t\t\t\t\\\n+    ++seq ## a;\t\t\t\t\t\t\\\n+    if (length == 0) goto finish;\t\t\t\\\n+    if (seq ## a c0 seq ## b) goto s ## a ## b ## c;\t\\\n+    if (seq ## a c1 seq ## c) goto s ## b ## a ## c;\t\\\n+    goto s ## b ## c ## a;\n+\n+    Merge3Case(0, 1, 2, <=, <=);\n+    Merge3Case(1, 2, 0, <=, < );\n+    Merge3Case(2, 0, 1, < , < );\n+    Merge3Case(1, 0, 2, < , <=);\n+    Merge3Case(0, 2, 1, <=, <=);\n+    Merge3Case(2, 1, 0, < , < );\n+\n+#undef Merge3Case\n+\n+  finish:\n+    ;\n+\n+    seqs_begin[0].first = seq0;\n+    seqs_begin[1].first = seq1;\n+    seqs_begin[2].first = seq2;\n+\n+    return target;\n+  }\n+\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_3_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length);\n+    \n+    typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    int min_seq;\n+    RandomAccessIterator3 target_end;\n+\n+    // Stable anyway.\n+    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n+\n+    difference_type total_length = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n+      total_length += LENGTH(*s);\n+\n+    if (overhang != -1)\n+      {\n+\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n+\ttarget_end = multiway_merge_3_variant<unguarded_iterator>\n+\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+\toverhang = length - unguarded_length;\n+      }\n+    else\n+      {\n+\t// Empty sequence found.\n+\toverhang = length;\n+\ttarget_end = target;\n+      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    switch (min_seq)\n+      {\n+      case 0:\n+\t// Iterators will be advanced accordingly.\n+\ttarget_end = merge_advance(seqs_begin[1].first, seqs_begin[1].second,\n+\t\t\t\t   seqs_begin[2].first, seqs_begin[2].second,\n+\t\t\t\t   target_end, overhang, comp);\n+\tbreak;\n+      case 1:\n+\ttarget_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n+\t\t\t\t   seqs_begin[2].first, seqs_begin[2].second,\n+\t\t\t\t   target_end, overhang, comp);\n+\tbreak;\n+      case 2:\n+\ttarget_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n+\t\t\t\t   seqs_begin[1].first, seqs_begin[1].second,\n+\t\t\t\t   target_end, overhang, comp);\n+\tbreak;\n+      default:\n+\t_GLIBCXX_PARALLEL_ASSERT(false);\n+      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    return target_end;\n+  }\n+\n+  /** @brief Highly efficient 4-way merging procedure.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Unused, stable anyway.\n+   *  @return End iterator of output sequence. */\n+  template<template<typename RAI, typename C> class iterator, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_4_variant(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length);\n+    typedef _DifferenceTp difference_type;\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    iterator<RandomAccessIterator1, Comparator>\n+      seq0(seqs_begin[0].first, seqs_begin[0].second, comp),\n+      seq1(seqs_begin[1].first, seqs_begin[1].second, comp),\n+      seq2(seqs_begin[2].first, seqs_begin[2].second, comp),\n+      seq3(seqs_begin[3].first, seqs_begin[3].second, comp);\n+\n+#define Decision(a,b,c,d) {\t\t\t\t\t\\\n+      if (seq ## d < seq ## a) goto s ## d ## a ## b ## c;\t\\\n+      if (seq ## d < seq ## b) goto s ## a ## d ## b ## c;\t\\\n+      if (seq ## d < seq ## c) goto s ## a ## b ## d ## c;\t\\\n+      goto s ## a ## b ## c ## d;  }\n+\n+    if (seq0 <= seq1)\n+      {\n+\tif (seq1 <= seq2)\n+\t  Decision(0,1,2,3)\n+\t  else\n+\t    if (seq2 < seq0)\n+\t      Decision(2,0,1,3)\n+\t      else\n+\t\tDecision(0,2,1,3)\n+\t\t  }\n+    else\n+      {\n+\tif (seq1 <= seq2)\n+\t  {\n+\t    if (seq0 <= seq2)\n+\t      Decision(1,0,2,3)\n+\t      else\n+\t\tDecision(1,2,0,3)\n+\t\t  }\n+\telse\n+\t  Decision(2,1,0,3)\n+\t    }\n+\n+#define Merge4Case(a,b,c,d,c0,c1,c2)\t\t\t\t\\\n+    s ## a ## b ## c ## d:\t\t\t\t\t\\\n+      if (length == 0) goto finish;\t\t\t\t\\\n+    *target = *seq ## a;\t\t\t\t\t\\\n+    ++target;\t\t\t\t\t\t\t\\\n+    length--;\t\t\t\t\t\t\t\\\n+    ++seq ## a;\t\t\t\t\t\t\t\\\n+    if (seq ## a c0 seq ## b) goto s ## a ## b ## c ## d;\t\\\n+    if (seq ## a c1 seq ## c) goto s ## b ## a ## c ## d;\t\\\n+    if (seq ## a c2 seq ## d) goto s ## b ## c ## a ## d;\t\\\n+    goto s ## b ## c ## d ## a;\n+\n+    Merge4Case(0, 1, 2, 3, <=, <=, <=);\n+    Merge4Case(0, 1, 3, 2, <=, <=, <=);\n+    Merge4Case(0, 2, 1, 3, <=, <=, <=);\n+    Merge4Case(0, 2, 3, 1, <=, <=, <=);\n+    Merge4Case(0, 3, 1, 2, <=, <=, <=);\n+    Merge4Case(0, 3, 2, 1, <=, <=, <=);\n+    Merge4Case(1, 0, 2, 3, < , <=, <=);\n+    Merge4Case(1, 0, 3, 2, < , <=, <=);\n+    Merge4Case(1, 2, 0, 3, <=, < , <=);\n+    Merge4Case(1, 2, 3, 0, <=, <=, < );\n+    Merge4Case(1, 3, 0, 2, <=, < , <=);\n+    Merge4Case(1, 3, 2, 0, <=, <=, < );\n+    Merge4Case(2, 0, 1, 3, < , < , <=);\n+    Merge4Case(2, 0, 3, 1, < , <=, < );\n+    Merge4Case(2, 1, 0, 3, < , < , <=);\n+    Merge4Case(2, 1, 3, 0, < , <=, < );\n+    Merge4Case(2, 3, 0, 1, <=, < , < );\n+    Merge4Case(2, 3, 1, 0, <=, < , < );\n+    Merge4Case(3, 0, 1, 2, < , < , < );\n+    Merge4Case(3, 0, 2, 1, < , < , < );\n+    Merge4Case(3, 1, 0, 2, < , < , < );\n+    Merge4Case(3, 1, 2, 0, < , < , < );\n+    Merge4Case(3, 2, 0, 1, < , < , < );\n+    Merge4Case(3, 2, 1, 0, < , < , < );\n+\n+#undef Merge4Case\n+#undef Decision\n+\n+  finish:\n+    ;\n+\n+    seqs_begin[0].first = seq0;\n+    seqs_begin[1].first = seq1;\n+    seqs_begin[2].first = seq2;\n+    seqs_begin[3].first = seq3;\n+\n+    return target;\n+  }\n+\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_4_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length);\n+    typedef _DifferenceTp difference_type;\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    int min_seq;\n+    RandomAccessIterator3 target_end;\n+\n+    // Stable anyway.\n+    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n+\n+    difference_type total_length = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n+      total_length += LENGTH(*s);\n+\n+    if (overhang != -1)\n+      {\n+\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n+\ttarget_end = multiway_merge_4_variant<unguarded_iterator>\n+\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+\toverhang = length - unguarded_length;\n+      }\n+    else\n+      {\n+\t// Empty sequence found.\n+\toverhang = length;\n+\ttarget_end = target;\n+      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    std::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> > one_missing(seqs_begin, seqs_end);\n+    one_missing.erase(one_missing.begin() + min_seq);\t//remove\n+\n+    target_end = multiway_merge_3_variant<guarded_iterator>(one_missing.begin(), one_missing.end(), target_end, comp, overhang, stable);\n+\n+    // Insert back again.\n+    one_missing.insert(one_missing.begin() + min_seq, seqs_begin[min_seq]);\n+    // Write back modified iterators.\n+    copy(one_missing.begin(), one_missing.end(), seqs_begin);\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    return target_end;\n+  }\n+\n+  /** @brief Basic multi-way merging procedure.\n+   *\n+   *  The head elements are kept in a sorted array, new heads are\n+   *  inserted linearly.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @return End iterator of output sequence. \n+   */\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_bubble(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+    typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    // Num remaining pieces.\n+    int k = static_cast<int>(seqs_end - seqs_begin), nrp;\n+\n+    value_type* pl = new value_type[k];\n+    int* source = new int[k];\n+    difference_type total_length = 0;\n+\n+#define POS(i) seqs_begin[(i)].first\n+#define STOPS(i) seqs_begin[(i)].second\n+\n+    // Write entries into queue.\n+    nrp = 0;\n+    for (int pi = 0; pi < k; pi++)\n+      {\n+\tif (STOPS(pi) != POS(pi))\n+\t  {\n+\t    pl[nrp] = *(POS(pi));\n+\t    source[nrp] = pi;\n+\t    nrp++;\n+\t    total_length += LENGTH(seqs_begin[pi]);\n+\t  }\n+      }\n+\n+    if (stable)\n+      {\n+\tfor (int k = 0; k < nrp - 1; k++)\n+\t  for (int pi = nrp - 1; pi > k; pi--)\n+\t    if (comp(pl[pi], pl[pi - 1]) ||\n+\t\t(!comp(pl[pi - 1], pl[pi]) && source[pi] < source[pi - 1]))\n+\t      {\n+\t\tstd::swap(pl[pi - 1], pl[pi]);\n+\t\tstd::swap(source[pi - 1], source[pi]);\n+\t      }\n+      }\n+    else\n+      {\n+\tfor (int k = 0; k < nrp - 1; k++)\n+\t  for (int pi = nrp - 1; pi > k; pi--)\n+\t    if (comp(pl[pi], pl[pi-1]))\n+\t      {\n+\t\tstd::swap(pl[pi-1], pl[pi]);\n+\t\tstd::swap(source[pi-1], source[pi]);\n+\t      }\n+      }\n+\n+    // Iterate.\n+    if (stable)\n+      {\n+\tint j;\n+\twhile (nrp > 0 && length > 0)\n+\t  {\n+\t    if (source[0] < source[1])\n+\t      {\n+\t\t// pl[0] <= pl[1]\n+\t\twhile ((nrp == 1 || !(comp(pl[1], pl[0]))) && length > 0)\n+\t\t  {\n+\t\t    *target = pl[0];\n+\t\t    ++target;\n+\t\t    ++POS(source[0]);\n+\t\t    length--;\n+\t\t    if (POS(source[0]) == STOPS(source[0]))\n+\t\t      {\n+\t\t\t// Move everything to the left.\n+\t\t\tfor (int s = 0; s < nrp - 1; s++)\n+\t\t\t  {\n+\t\t\t    pl[s] = pl[s + 1];\n+\t\t\t    source[s] = source[s + 1];\n+\t\t\t  }\n+\t\t\tnrp--;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    else\n+\t\t      pl[0] = *(POS(source[0]));\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t// pl[0] < pl[1]\n+\t\twhile ((nrp == 1 || comp(pl[0], pl[1])) && length > 0)\n+\t\t  {\n+\t\t    *target = pl[0];\n+\t\t    ++target;\n+\t\t    ++POS(source[0]);\n+\t\t    length--;\n+\t\t    if (POS(source[0]) == STOPS(source[0]))\n+\t\t      {\n+\t\t\tfor (int s = 0; s < nrp - 1; s++)\n+\t\t\t  {\n+\t\t\t    pl[s] = pl[s + 1];\n+\t\t\t    source[s] = source[s + 1];\n+\t\t\t  }\n+\t\t\tnrp--;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    else\n+\t\t      pl[0] = *(POS(source[0]));\n+\t\t  }\n+\t      }\n+\n+\t    // Sink down.\n+\t    j = 1;\n+\t    while ((j < nrp) && (comp(pl[j], pl[j - 1]) ||\n+\t\t\t\t (!comp(pl[j - 1], pl[j]) && (source[j] < source[j - 1]))))\n+\t      {\n+\t\tstd::swap(pl[j - 1], pl[j]);\n+\t\tstd::swap(source[j - 1], source[j]);\n+\t\tj++;\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\tint j;\n+\twhile (nrp > 0 && length > 0)\n+\t  {\n+\t    // pl[0] <= pl[1]\n+\t    while (nrp == 1 || (!comp(pl[1], pl[0])) && length > 0)\n+\t      {\n+\t\t*target = pl[0];\n+\t\t++target;\n+\t\t++POS(source[0]);\n+\t\tlength--;\n+\t\tif (POS(source[0]) == STOPS(source[0]))\n+\t\t  {\n+\t\t    for (int s = 0; s < (nrp - 1); s++)\n+\t\t      {\n+\t\t\tpl[s] = pl[s + 1];\n+\t\t\tsource[s] = source[s + 1];\n+\t\t      }\n+\t\t    nrp--;\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  pl[0] = *(POS(source[0]));\n+\t      }\n+\n+\t    // Sink down.\n+\t    j = 1;\n+\t    while ((j < nrp) && comp(pl[j], pl[j - 1]))\n+\t      {\n+\t\tstd::swap(pl[j - 1], pl[j]);\n+\t\tstd::swap(source[j - 1], source[j]);\n+\t\tj++;\n+\t      }\n+\t  }\n+      }\n+\n+    delete[] pl;\n+    delete[] source;\n+\n+    return target;\n+  }\n+\n+  /** @brief Multi-way merging procedure for a high branching factor,\n+   * guarded case.\n+   *\n+   *  The head elements are kept in a loser tree.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @return End iterator of output sequence. \n+   */\n+  template<typename LT, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+      typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+    LT lt(k, comp);\n+\n+    difference_type total_length = 0;\n+\n+    for (int t = 0; t < k; t++)\n+      {\n+\tif (stable)\n+\t  {\n+\t    if (seqs_begin[t].first == seqs_begin[t].second)\n+\t      lt.insert_start_stable(value_type(), t, true);\n+\t    else\n+\t      lt.insert_start_stable(*seqs_begin[t].first, t, false);\n+\t  }\n+\telse\n+\t  {\n+\t    if (seqs_begin[t].first == seqs_begin[t].second)\n+\t      lt.insert_start(value_type(), t, true);\n+\t    else\n+\t      lt.insert_start(*seqs_begin[t].first, t, false);\n+\t  }\n+\n+\ttotal_length += LENGTH(seqs_begin[t]);\n+      }\n+\n+    if (stable)\n+      lt.init_stable();\n+    else\n+      lt.init();\n+\n+    total_length = std::min(total_length, length);\n+\n+    int source;\n+\n+    if (stable)\n+      {\n+\tfor (difference_type i = 0; i < total_length; i++)\n+\t  {\n+\t    // Take out.\n+\t    source = lt.get_min_source();\n+\n+\t    *(target++) = *(seqs_begin[source].first++);\n+\n+\t    // Feed.\n+\t    if (seqs_begin[source].first == seqs_begin[source].second)\n+\t      lt.delete_min_insert_stable(value_type(), true);\n+\t    else\n+\t      // Replace from same source.\n+\t      lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n+\n+\t  }\n+      }\n+    else\n+      {\n+\tfor (difference_type i = 0; i < total_length; i++)\n+\t  {\n+\t    //take out\n+\t    source = lt.get_min_source();\n+\n+\t    *(target++) = *(seqs_begin[source].first++);\n+\n+\t    // Feed.\n+\t    if (seqs_begin[source].first == seqs_begin[source].second)\n+\t      lt.delete_min_insert(value_type(), true);\n+\t    else\n+\t      // Replace from same source.\n+\t      lt.delete_min_insert(*seqs_begin[source].first, false);\n+\t  }\n+      }\n+\n+    return target;\n+  }\n+\n+  /** @brief Multi-way merging procedure for a high branching factor,\n+   * unguarded case.\n+   *\n+   *  The head elements are kept in a loser tree.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @return End iterator of output sequence.\n+   *  @pre No input will run out of elements during the merge. \n+   */\n+  template<typename LT, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length)\n+    typedef _DifferenceTp difference_type;\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    int k = seqs_end - seqs_begin;\n+\n+    LT lt(k, comp);\n+\n+    difference_type total_length = 0;\n+\n+    for (int t = 0; t < k; t++)\n+      {\n+#if _GLIBCXX_ASSERTIONS\n+\t_GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n+#endif\n+\tif (stable)\n+\t  lt.insert_start_stable(*seqs_begin[t].first, t, false);\n+\telse\n+\t  lt.insert_start(*seqs_begin[t].first, t, false);\n+\n+\ttotal_length += LENGTH(seqs_begin[t]);\n+      }\n+\n+    if (stable)\n+      lt.init_stable();\n+    else\n+      lt.init();\n+\n+    // Do not go past end.\n+    length = std::min(total_length, length);\n+\n+    int source;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    difference_type i = 0;\n+#endif\n+\n+    if (stable)\n+      {\n+\tRandomAccessIterator3 target_end = target + length;\n+\twhile (target < target_end)\n+\t  {\n+\t    // Take out.\n+\t    source = lt.get_min_source();\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    _GLIBCXX_PARALLEL_ASSERT(i == 0 || !comp(*(seqs_begin[source].first), *(target - 1)));\n+#endif\n+\n+\t    *(target++) = *(seqs_begin[source].first++);\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    _GLIBCXX_PARALLEL_ASSERT((seqs_begin[source].first != seqs_begin[source].second) || (i == length - 1));\n+\t    i++;\n+#endif\n+\t    // Feed.\n+\t    // Replace from same source.\n+\t    lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n+\n+\t  }\n+      }\n+    else\n+      {\n+\tRandomAccessIterator3 target_end = target + length;\n+\twhile (target < target_end)\n+\t  {\n+\t    // Take out.\n+\t    source = lt.get_min_source();\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    if (i > 0 && comp(*(seqs_begin[source].first), *(target - 1)))\n+\t      printf(\"         %i %i %i\\n\", length, i, source);\n+\t    _GLIBCXX_PARALLEL_ASSERT(i == 0 || !comp(*(seqs_begin[source].first), *(target - 1)));\n+#endif\n+\n+\t    *(target++) = *(seqs_begin[source].first++);\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t    if (!((seqs_begin[source].first != seqs_begin[source].second) || (i >= length - 1)))\n+\t      printf(\"         %i %i %i\\n\", length, i, source);\n+\t    _GLIBCXX_PARALLEL_ASSERT((seqs_begin[source].first != seqs_begin[source].second) || (i >= length - 1));\n+\t    i++;\n+#endif\n+\t    // Feed.\n+\t    // Replace from same source.\n+\t    lt.delete_min_insert(*seqs_begin[source].first, false);\n+\t  }\n+      }\n+\n+    return target;\n+  }\n+\n+  template<typename _ValueTp, class Comparator>\n+  struct loser_tree_traits\n+  {\n+    typedef LoserTree/*Pointer*/<_ValueTp, Comparator> LT;\n+  };\n+\n+\n+  /*#define NO_POINTER(T) \\\n+    template<typename Comparator> \\\n+    struct loser_tree_traits<T, Comparator> \\\n+    { \\\n+    typedef LoserTreePointer<T, Comparator> LT; \\\n+    };*/\n+  //\n+  // NO_POINTER(unsigned char)\n+  // NO_POINTER(char)\n+  // NO_POINTER(unsigned short)\n+  // NO_POINTER(short)\n+  // NO_POINTER(unsigned int)\n+  // NO_POINTER(int)\n+  // NO_POINTER(unsigned long)\n+  // NO_POINTER(long)\n+  // NO_POINTER(unsigned long long)\n+  // NO_POINTER(long long)\n+  //\n+  // #undef NO_POINTER\n+\n+  template<typename _ValueTp, class Comparator>\n+  struct loser_tree_traits_unguarded\n+  {\n+    typedef LoserTreeUnguarded<_ValueTp, Comparator> LT;\n+  };\n+\n+  /*#define NO_POINTER_UNGUARDED(T) \\\n+    template<typename Comparator> \\\n+    struct loser_tree_traits_unguarded<T, Comparator> \\\n+    { \\\n+    typedef LoserTreePointerUnguarded<T, Comparator> LT; \\\n+    };*/\n+  //\n+  // NO_POINTER_UNGUARDED(unsigned char)\n+  // NO_POINTER_UNGUARDED(char)\n+  // NO_POINTER_UNGUARDED(unsigned short)\n+  // NO_POINTER_UNGUARDED(short)\n+  // NO_POINTER_UNGUARDED(unsigned int)\n+  // NO_POINTER_UNGUARDED(int)\n+  // NO_POINTER_UNGUARDED(unsigned long)\n+  // NO_POINTER_UNGUARDED(long)\n+  // NO_POINTER_UNGUARDED(unsigned long long)\n+  // NO_POINTER_UNGUARDED(long long)\n+  //\n+  // #undef NO_POINTER_UNGUARDED\n+\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_loser_tree_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+    typedef _DifferenceTp difference_type;\n+\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+    int min_seq;\n+    RandomAccessIterator3 target_end;\n+    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end,\n+\t\t\t\t\t  comp, min_seq, stable);\n+\n+    difference_type total_length = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+      total_length += LENGTH(*s);\n+\n+    if (overhang != -1)\n+      {\n+\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n+\ttarget_end = multiway_merge_loser_tree_unguarded\n+\t  <typename loser_tree_traits_unguarded<value_type, Comparator>::LT>\n+\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+\toverhang = length - unguarded_length;\n+      }\n+    else\n+      {\n+\t// Empty sequence found.\n+\toverhang = length;\n+\ttarget_end = target;\n+      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    target_end = multiway_merge_loser_tree\n+      <typename loser_tree_traits<value_type, Comparator>::LT>\n+      (seqs_begin, seqs_end, target_end, comp, overhang, stable);\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    return target_end;\n+  }\n+\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+    typedef _DifferenceTp difference_type;\n+    typedef std::iterator_traits<RandomAccessIteratorIterator> traits_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+\n+    RandomAccessIterator3 target_end;\n+    difference_type overhang = prepare_unguarded_sentinel(seqs_begin, seqs_end, comp);\n+\n+    difference_type total_length = 0;\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+      {\n+\ttotal_length += LENGTH(*s);\n+\n+\t// Sentinel spot.\n+\t(*s).second++;\n+      }\n+\n+    difference_type unguarded_length = std::min(length, total_length - overhang);\n+    target_end = multiway_merge_loser_tree_unguarded\n+      <typename loser_tree_traits_unguarded<value_type, Comparator>::LT>\n+      (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+    overhang = length - unguarded_length;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    // Copy rest stable.\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end && overhang > 0; s++)\n+      {\n+\t// Restore.\n+\t(*s).second--;\n+\tdifference_type local_length = std::min((difference_type)overhang, (difference_type)LENGTH(*s));\n+\ttarget_end = std::copy((*s).first, (*s).first + local_length, target_end);\n+\t(*s).first += local_length;\n+\toverhang -= local_length;\n+      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(overhang == 0);\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n+#endif\n+\n+    return target_end;\n+  }\n+\n+  /** @brief Sequential multi-way merging switch.\n+   *\n+   *  The decision if based on the branching factor and runtime settings.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @param sentinel The sequences have a sentinel element.\n+   *  @return End iterator of output sequence. */\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable, bool sentinel, sequential_tag)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+    typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n+      _GLIBCXX_PARALLEL_ASSERT(is_sorted((*s).first, (*s).second, comp));\n+#endif\n+\n+    RandomAccessIterator3 return_target = target;\n+    int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+    Settings::MultiwayMergeAlgorithm mwma = Settings::multiway_merge_algorithm;\n+\n+    if (!sentinel && mwma == Settings::LOSER_TREE_SENTINEL)\n+      mwma = Settings::LOSER_TREE_COMBINED;\n+\n+    switch (k)\n+      {\n+      case 0:\n+\tbreak;\n+      case 1:\n+\treturn_target = std::copy(seqs_begin[0].first, seqs_begin[0].first + length, target);\n+\tseqs_begin[0].first += length;\n+\tbreak;\n+      case 2:\n+\treturn_target = merge_advance(seqs_begin[0].first, seqs_begin[0].second, seqs_begin[1].first, seqs_begin[1].second, target, length, comp);\n+\tbreak;\n+      case 3:\n+\tswitch (mwma)\n+\t  {\n+\t  case Settings::LOSER_TREE_COMBINED:\n+\t    return_target = multiway_merge_3_combined(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  case Settings::LOSER_TREE_SENTINEL:\n+\t    return_target = multiway_merge_3_variant<unguarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  default:\n+\t    return_target = multiway_merge_3_variant<guarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  }\n+\tbreak;\n+      case 4:\n+\tswitch (mwma)\n+\t  {\n+\t  case Settings::LOSER_TREE_COMBINED:\n+\t    return_target = multiway_merge_4_combined(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  case Settings::LOSER_TREE_SENTINEL:\n+\t    return_target = multiway_merge_4_variant<unguarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  default:\n+\t    return_target = multiway_merge_4_variant<guarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n+\t    break;\n+\t  }\n+\tbreak;\n+      default:\n+\t{\n+\t  switch (mwma)\n+\t    {\n+\t    case Settings::BUBBLE:\n+\t      return_target = multiway_merge_bubble(seqs_begin, seqs_end, target, comp, length, stable);\n+\t      break;\n+#if _GLIBCXX_LOSER_TREE_EXPLICIT\n+\t    case Settings::LOSER_TREE_EXPLICIT:\n+\t      return_target = multiway_merge_loser_tree<LoserTreeExplicit<value_type, Comparator> >(seqs_begin, seqs_end, target, comp, length, stable);\n+\t      break;\n+#endif\n+#if _GLIBCXX_LOSER_TREE\n+\t    case Settings::LOSER_TREE:\n+\t      return_target = multiway_merge_loser_tree<LoserTree<value_type, Comparator> >(seqs_begin, seqs_end, target, comp, length, stable);\n+\t      break;\n+#endif\n+#if _GLIBCXX_LOSER_TREE_COMBINED\n+\t    case Settings::LOSER_TREE_COMBINED:\n+\t      return_target = multiway_merge_loser_tree_combined(seqs_begin, seqs_end, target, comp, length, stable);\n+\t      break;\n+#endif\n+#if _GLIBCXX_LOSER_TREE_SENTINEL\n+\t    case Settings::LOSER_TREE_SENTINEL:\n+\t      return_target = multiway_merge_loser_tree_sentinel(seqs_begin, seqs_end, target, comp, length, stable);\n+\t      break;\n+#endif\n+\t    default:\n+\t      // multiway_merge algorithm not implemented.\n+\t      _GLIBCXX_PARALLEL_ASSERT(0);\n+\t      break;\n+\t    }\n+\t}\n+      }\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n+#endif\n+\n+    return return_target;\n+  }\n+\n+  /** @brief Parallel multi-way merge routine.\n+   *\n+   *  The decision if based on the branching factor and runtime settings.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @param sentinel Ignored.\n+   *  @return End iterator of output sequence. \n+   */\n+  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  parallel_multiway_merge(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable, bool sentinel)\n+  {\n+    _GLIBCXX_CALL(length)\n+\n+    typedef _DifferenceTp difference_type;\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+      RandomAccessIterator1;\n+    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      value_type;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    for (RandomAccessIteratorIterator rii = seqs_begin; rii != seqs_end; rii++)\n+      _GLIBCXX_PARALLEL_ASSERT(is_sorted((*rii).first, (*rii).second, comp));\n+#endif\n+\n+    // k sequences.\n+    int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+    difference_type total_length = 0;\n+    for (RandomAccessIteratorIterator raii = seqs_begin; raii != seqs_end; raii++)\n+      total_length += LENGTH(*raii);\n+\n+    _GLIBCXX_CALL(total_length)\n+\n+    if (total_length == 0 || k == 0)\n+      return target;\n+\n+    thread_index_t num_threads = static_cast<thread_index_t>(std::min(static_cast<difference_type>(get_max_threads()), total_length));\n+\n+    Timing<sequential_tag>* t = new Timing<sequential_tag>[num_threads];\n+\n+    for (int pr = 0; pr < num_threads; pr++)\n+      t[pr].tic();\n+\n+    bool tight = (total_length == length);\n+\n+    // Thread t will have to merge pieces[iam][0..k - 1]\n+    std::vector<std::pair<difference_type, difference_type> >* pieces = new std::vector<std::pair<difference_type, difference_type> >[num_threads];\n+    for (int s = 0; s < num_threads; s++)\n+      pieces[s].resize(k);\n+\n+    difference_type num_samples = Settings::merge_oversampling * num_threads;\n+\n+    if (Settings::multiway_merge_splitting == Settings::SAMPLING)\n+      {\n+\tvalue_type* samples = new value_type[k * num_samples];\n+\t// Sample.\n+\tfor (int s = 0; s < k; s++)\n+\t  for (int i = 0; (difference_type)i < num_samples; i++)\n+\t    {\n+\t      difference_type sample_index = static_cast<difference_type>(LENGTH(seqs_begin[s]) * (double(i + 1) / (num_samples + 1)) * (double(length) / total_length));\n+\t      samples[s * num_samples + i] = seqs_begin[s].first[sample_index];\n+\t    }\n+\n+\tif (stable)\n+\t  __gnu_sequential::stable_sort(samples, samples + (num_samples * k), comp);\n+\telse\n+\t  __gnu_sequential::sort(samples, samples + (num_samples * k), comp);\n+\n+\tfor (int slab = 0; slab < num_threads; slab++)\n+\t  // For each slab / processor.\n+\t  for (int seq = 0; seq < k; seq++)\n+\t    {\n+\t      // For each sequence.\n+\t      if (slab > 0)\n+\t\tpieces[slab][seq].first = std::upper_bound(seqs_begin[seq].first, seqs_begin[seq].second, samples[num_samples * k * slab / num_threads], comp) - seqs_begin[seq].first;\n+\t      else\n+\t\t{\n+\t\t  // Absolute beginning.\n+\t\t  pieces[slab][seq].first = 0;\n+\t\t}\n+\t      if ((slab + 1) < num_threads)\n+\t\tpieces[slab][seq].second = std::upper_bound(seqs_begin[seq].first, seqs_begin[seq].second, samples[num_samples * k * (slab + 1) / num_threads], comp) - seqs_begin[seq].first;\n+\t      else\n+\t\tpieces[slab][seq].second = LENGTH(seqs_begin[seq]);\t//absolute ending\n+\t    }\n+\tdelete[] samples;\n+      }\n+    else\n+      {\n+\t// (Settings::multiway_merge_splitting == Settings::EXACT).\n+\tstd::vector<RandomAccessIterator1>* offsets = new std::vector<RandomAccessIterator1>[num_threads];\n+\tstd::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> > se(k);\n+\n+\tcopy(seqs_begin, seqs_end, se.begin());\n+\n+\tdifference_type borders[num_threads + 1];\n+\tequally_split(length, num_threads, borders);\n+\n+\tfor (int s = 0; s < (num_threads - 1); s++)\n+\t  {\n+\t    offsets[s].resize(k);\n+\t    multiseq_partition(se.begin(), se.end(), borders[s + 1],\n+\t\t\t       offsets[s].begin(), comp);\n+\n+\t    // Last one also needed and available.\n+\t    if (!tight)\n+\t      {\n+\t\toffsets[num_threads - 1].resize(k);\n+\t\tmultiseq_partition(se.begin(), se.end(), (difference_type)length,\n+\t\t\t\t   offsets[num_threads - 1].begin(),  comp);\n+\t      }\n+\t  }\n+\n+\n+\tfor (int slab = 0; slab < num_threads; slab++)\n+\t  {\n+\t    // For each slab / processor.\n+\t    for (int seq = 0; seq < k; seq++)\n+\t      {\n+\t\t// For each sequence.\n+\t\tif (slab == 0)\n+\t\t  {\n+\t\t    // Absolute beginning.\n+\t\t    pieces[slab][seq].first = 0;\n+\t\t  }\n+\t\telse\n+\t\t  pieces[slab][seq].first = pieces[slab - 1][seq].second;\n+\t\tif (!tight || slab < (num_threads - 1))\n+\t\t  pieces[slab][seq].second = offsets[slab][seq] - seqs_begin[seq].first;\n+\t\telse\n+\t\t  {\n+\t\t    // slab == num_threads - 1\n+\t\t    pieces[slab][seq].second = LENGTH(seqs_begin[seq]);\n+\t\t  }\n+\t      }\n+\t  }\n+\tdelete[] offsets;\n+      }\n+\n+    for (int pr = 0; pr < num_threads; pr++)\n+      t[pr].tic();\n+\n+#\tpragma omp parallel num_threads(num_threads)\n+    {\n+      thread_index_t iam = omp_get_thread_num();\n+\n+      t[iam].tic();\n+\n+      difference_type target_position = 0;\n+\n+      for (int c = 0; c < k; c++)\n+\ttarget_position += pieces[iam][c].first;\n+\n+      if (k > 2)\n+\t{\n+\t  std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks = new std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n+\n+\t  difference_type local_length = 0;\n+\t  for (int s = 0; s < k; s++)\n+\t    {\n+\t      chunks[s] = std::make_pair(seqs_begin[s].first + pieces[iam][s].first, seqs_begin[s].first + pieces[iam][s].second);\n+\t      local_length += LENGTH(chunks[s]);\n+\t    }\n+\n+\t  multiway_merge(chunks, chunks + k, target + target_position, comp,\n+\t\t\t std::min(local_length, length - target_position),\n+\t\t\t stable, false, sequential_tag());\n+\n+\t  delete[] chunks;\n+\t}\n+      else if (k == 2)\n+\t{\n+\t  RandomAccessIterator1 begin0 = seqs_begin[0].first + pieces[iam][0].first, begin1 = seqs_begin[1].first + pieces[iam][1].first;\n+\t  merge_advance(begin0,\n+\t\t\tseqs_begin[0].first + pieces[iam][0].second,\n+\t\t\tbegin1,\n+\t\t\tseqs_begin[1].first + pieces[iam][1].second,\n+\t\t\ttarget + target_position,\n+\t\t\t(pieces[iam][0].second - pieces[iam][0].first) + (pieces[iam][1].second - pieces[iam][1].first),\n+\t\t\tcomp);\n+\t}\n+\n+      t[iam].tic();\n+\n+    }\n+\n+    for (int pr = 0; pr < num_threads; pr++)\n+      t[pr].tic();\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n+#endif\n+\n+    // Update ends of sequences.\n+    for (int s = 0; s < k; s++)\n+      seqs_begin[s].first += pieces[num_threads - 1][s].second;\n+\n+    delete[] pieces;\n+\n+    for (int pr = 0; pr < num_threads; pr++)\n+      t[pr].tic();\n+    for (int pr = 0; pr < num_threads; pr++)\n+      t[pr].print();\n+    delete[] t;\n+\n+    return target + length;\n+  }\n+\n+  /** \n+   *  @brief Multi-way merging front-end.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @return End iterator of output sequence. \n+   */\n+  template<typename RandomAccessIteratorPairIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge(RandomAccessIteratorPairIterator seqs_begin,\n+\t\t RandomAccessIteratorPairIterator seqs_end,\n+\t\t RandomAccessIterator3 target, Comparator comp,\n+\t\t _DifferenceTp length, bool stable)\n+  {\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    if (seqs_begin == seqs_end)\n+      return target;\n+\n+    RandomAccessIterator3 target_end;\n+    if (_GLIBCXX_PARALLEL_CONDITION(((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k) && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge(seqs_begin, seqs_end, target, comp, (difference_type)length, stable, false);\n+    else\n+      target_end = multiway_merge(seqs_begin, seqs_end, target, comp, length, stable, false, sequential_tag());\n+\n+    return target_end;\n+  }\n+\n+  /** @brief Multi-way merging front-end.\n+   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+   *  @param seqs_end End iterator of iterator pair input sequence.\n+   *  @param target Begin iterator out output sequence.\n+   *  @param comp Comparator.\n+   *  @param length Maximum length to merge.\n+   *  @param stable Stable merging incurs a performance penalty.\n+   *  @return End iterator of output sequence.\n+   *  @pre For each @c i, @c seqs_begin[i].second must be the end\n+   *  marker of the sequence, but also reference the one more sentinel\n+   *  element. */\n+  template<typename RandomAccessIteratorPairIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+  RandomAccessIterator3\n+  multiway_merge_sentinel(RandomAccessIteratorPairIterator seqs_begin,\n+\t\t\t  RandomAccessIteratorPairIterator seqs_end,\n+\t\t\t  RandomAccessIterator3 target,\n+\t\t\t  Comparator comp,\n+\t\t\t  _DifferenceTp length,\n+\t\t\t  bool stable)\n+  {\n+    typedef _DifferenceTp difference_type;\n+\n+    if (seqs_begin == seqs_end)\n+      return target;\n+\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    if (_GLIBCXX_PARALLEL_CONDITION(((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k) && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n+      return parallel_multiway_merge(seqs_begin, seqs_end, target, comp, (typename std::iterator_traits<RandomAccessIterator3>::difference_type)length, stable, true);\n+    else\n+      return multiway_merge(seqs_begin, seqs_end, target, comp, length, stable, true, sequential_tag());\n+  }\n+}\n+\n+#endif"}, {"sha": "7f0f3c0692257d83ad99a13ab76fee81fd0ec8f2", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,413 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/multiway_mergesort.h\n+ *  @brief Parallel multiway merge sort.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_MERGESORT_H\n+#define _GLIBCXX_PARALLEL_MERGESORT_H 1\n+\n+#include <vector>\n+\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_algo.h>\n+#include <parallel/parallel.h>\n+#include <parallel/multiway_merge.h>\n+#include <parallel/timing.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+  /** @brief Subsequence description. */\n+  template<typename _DifferenceTp>\n+  struct Piece\n+  {\n+    typedef _DifferenceTp difference_type;\n+\n+    /** @brief Begin of subsequence. */\n+    difference_type begin;\n+\n+    /** @brief End of subsequence. */\n+    difference_type end;\n+  };\n+\n+  /** @brief Data accessed by all threads.\n+   *\n+   *  PMWMS = parallel multiway mergesort */\n+  template<typename RandomAccessIterator>\n+  struct PMWMSSortingData\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    /** @brief Input begin. */\n+    RandomAccessIterator source;\n+\n+    /** @brief Start indices, per thread. */\n+    difference_type* starts;\n+\n+    /** @brief Temporary arrays for each thread.\n+     *\n+     *  Indirection Allows using the temporary storage in different\n+     *  ways, without code duplication.\n+     *  @see _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST */\n+    value_type** temporaries;\n+\n+#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n+    /** @brief Storage in which to sort. */\n+    RandomAccessIterator* sorting_places;\n+\n+    /** @brief Storage into which to merge. */\n+    value_type** merging_places;\n+#else\n+    /** @brief Storage in which to sort. */\n+    value_type** sorting_places;\n+\n+    /** @brief Storage into which to merge. */\n+    RandomAccessIterator* merging_places;\n+#endif\n+    /** @brief Samples. */\n+    value_type* samples;\n+\n+    /** @brief Offsets to add to the found positions. */\n+    difference_type* offsets;\n+\n+    /** @brief Pieces of data to merge @c [thread][sequence] */\n+    std::vector<Piece<difference_type> >* pieces;\n+  };\n+\n+  /** @brief Thread local data for PMWMS. */\n+  template<typename RandomAccessIterator>\n+  struct PMWMSSorterPU\n+  {\n+    /** @brief Total number of thread involved. */\n+    thread_index_t num_threads;\n+    /** @brief Number of owning thread. */\n+    thread_index_t iam;\n+    /** @brief Stable sorting desired. */\n+    bool stable;\n+    /** @brief Pointer to global data. */\n+    PMWMSSortingData<RandomAccessIterator>* sd;\n+  };\n+\n+  /** \n+   *  @brief Select samples from a sequence.\n+   *  @param d Pointer to thread-local data. Result will be placed in\n+   *  @c d->ds->samples.\n+   *  @param num_samples Number of samples to select. \n+   */\n+  template<typename RandomAccessIterator, typename _DifferenceTp>\n+  inline void \n+  determine_samples(PMWMSSorterPU<RandomAccessIterator>* d, \n+\t\t    _DifferenceTp& num_samples)\n+  {\n+    typedef _DifferenceTp difference_type;\n+\n+    PMWMSSortingData<RandomAccessIterator>* sd = d->sd;\n+\n+    num_samples = Settings::sort_mwms_oversampling * d->num_threads - 1;\n+\n+    difference_type es[num_samples + 2];\n+    equally_split(sd->starts[d->iam + 1] - sd->starts[d->iam], num_samples + 1, es);\n+\n+    for (difference_type i = 0; i < num_samples; i++)\n+      sd->samples[d->iam * num_samples + i] = sd->source[sd->starts[d->iam] + es[i + 1]];\n+  }\n+\n+  /** @brief PMWMS code executed by each thread.\n+   *  @param d Pointer to thread-local data.\n+   *  @param comp Comparator. \n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void \n+  parallel_sort_mwms_pu(PMWMSSorterPU<RandomAccessIterator>* d, \n+\t\t\tComparator& comp)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    Timing<sequential_tag> t;\n+\n+    t.tic();\n+\n+    PMWMSSortingData<RandomAccessIterator>* sd = d->sd;\n+    thread_index_t iam = d->iam;\n+\n+    // Length of this thread's chunk, before merging.\n+    difference_type length_local = sd->starts[iam + 1] - sd->starts[iam];\n+\n+#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n+    typedef RandomAccessIterator SortingPlacesIterator;\n+\n+    // Sort in input storage.\n+    sd->sorting_places[iam] = sd->source + sd->starts[iam];\n+#else\n+    typedef value_type* SortingPlacesIterator;\n+\n+    // Sort in temporary storage, leave space for sentinel.\n+    sd->sorting_places[iam] = sd->temporaries[iam] = static_cast<value_type*>(::operator new(sizeof(value_type) *(length_local + 1)));\n+\n+    // Copy there.\n+    std::uninitialized_copy(sd->source + sd->starts[iam], sd->source + sd->starts[iam] + length_local, sd->sorting_places[iam]);\n+#endif\n+\n+    // Sort locally.\n+    if (d->stable)\n+      __gnu_sequential::stable_sort(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp);\n+    else\n+      __gnu_sequential::sort(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp);\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp));\n+#endif\n+\n+    // Invariant: locally sorted subsequence in sd->sorting_places[iam],\n+    // sd->sorting_places[iam] + length_local.\n+    t.tic(\"local sort\");\n+\n+    if (Settings::sort_splitting == Settings::SAMPLING)\n+      {\n+\tdifference_type num_samples;\n+\tdetermine_samples(d, num_samples);\n+\n+#pragma omp barrier\n+\n+\tt.tic(\"sample/wait\");\n+\n+#pragma omp single\n+\t__gnu_sequential::sort(sd->samples, sd->samples + (num_samples * d->num_threads), comp);\n+\n+#pragma omp barrier\n+\n+\tfor (int s = 0; s < d->num_threads; s++)\n+\t  {\n+\t    // For each sequence.\n+\t    if (num_samples * iam > 0)\n+\t      sd->pieces[iam][s].begin = std::lower_bound(sd->sorting_places[s],\n+\t\t\t\t sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n+\t\t\t\t sd->samples[num_samples * iam],\n+\t\t\t\t comp)\n+\t\t- sd->sorting_places[s];\n+\t    else\n+\t      // Absolute beginning.\n+\t      sd->pieces[iam][s].begin = 0;\n+\n+\t    if ((num_samples * (iam + 1)) < (num_samples * d->num_threads))\n+\t      sd->pieces[iam][s].end = std::lower_bound(sd->sorting_places[s],\n+\t\t\t\t\t\t\tsd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s], sd->samples[num_samples * (iam + 1)], comp)\n+\t\t- sd->sorting_places[s];\n+\t    else\n+\t      // Absolute end.\n+\t      sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n+\t  }\n+\n+      }\n+    else if (Settings::sort_splitting == Settings::EXACT)\n+      {\n+#pragma omp barrier\n+\n+\tt.tic(\"wait\");\n+\n+\tstd::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> > seqs(d->num_threads);\n+\tfor (int s = 0; s < d->num_threads; s++)\n+\t  seqs[s] = std::make_pair(sd->sorting_places[s], sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s]);\n+\n+\tstd::vector<SortingPlacesIterator> offsets(d->num_threads);\n+\n+\t// If not last thread.\n+\tif (iam < d->num_threads - 1)\n+\t  multiseq_partition(seqs.begin(), seqs.end(), sd->starts[iam + 1], offsets.begin(), comp);\n+\n+\tfor (int seq = 0; seq < d->num_threads; seq++)\n+\t  {\n+\t    // For each sequence.\n+\t    if (iam < (d->num_threads - 1))\n+\t      sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n+\t    else\n+\t      // Absolute end of this sequence.\n+\t      sd->pieces[iam][seq].end = sd->starts[seq + 1] - sd->starts[seq];\n+\t  }\n+\n+#pragma omp barrier\n+\n+\tfor (int seq = 0; seq < d->num_threads; seq++)\n+\t  {\n+\t    // For each sequence.\n+\t    if (iam > 0)\n+\t      sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n+\t    else\n+\t      // Absolute beginning.\n+\t      sd->pieces[iam][seq].begin = 0;\n+\t  }\n+      }\n+\n+    t.tic(\"split\");\n+\n+    // Offset from target begin, length after merging.\n+    difference_type offset = 0, length_am = 0;\n+    for (int s = 0; s < d->num_threads; s++)\n+      {\n+\tlength_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n+\toffset += sd->pieces[iam][s].begin;\n+      }\n+\n+#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n+    // Merge to temporary storage, uninitialized creation not possible\n+    // since there is no multiway_merge calling the placement new\n+    // instead of the assignment operator.\n+    sd->merging_places[iam] = sd->temporaries[iam] = new value_type[length_am];\n+#else\n+    // Merge directly to target.\n+    sd->merging_places[iam] = sd->source + offset;\n+#endif\n+    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> > seqs(d->num_threads);\n+\n+    for (int s = 0; s < d->num_threads; s++)\n+      {\n+\tseqs[s] = std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin, sd->sorting_places[s] + sd->pieces[iam][s].end);\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t_GLIBCXX_PARALLEL_ASSERT(is_sorted(seqs[s].first, seqs[s].second, comp));\n+#endif\n+      }\n+\n+    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp, length_am, d->stable, false, sequential_tag());\n+\n+    t.tic(\"merge\");\n+\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(sd->merging_places[iam], sd->merging_places[iam] + length_am, comp));\n+#endif\n+\n+#\tpragma omp barrier\n+\n+#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n+    // Write back.\n+    std::copy(sd->merging_places[iam], sd->merging_places[iam] + length_am, \n+\t      sd->source + offset);\n+#endif\n+\n+    delete[] sd->temporaries[iam];\n+\n+    t.tic(\"copy back\");\n+\n+    t.print();\n+  }\n+\n+  /** @brief PMWMS main call.\n+   *  @param begin Begin iterator of sequence.\n+   *  @param end End iterator of sequence.\n+   *  @param comp Comparator.\n+   *  @param n Length of sequence.\n+   *  @param num_threads Number of threads to use.\n+   *  @param stable Stable sorting.\n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads, bool stable)\n+  {\n+    _GLIBCXX_CALL(n)\n+      \n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    if (n <= 1)\n+      return;\n+\n+    // At least one element per thread.\n+    if (num_threads > n)\n+      num_threads = static_cast<thread_index_t>(n);\n+\n+    PMWMSSortingData<RandomAccessIterator> sd;\n+\n+    sd.source = begin;\n+    sd.temporaries = new value_type*[num_threads];\n+\n+#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n+    sd.sorting_places = new RandomAccessIterator[num_threads];\n+    sd.merging_places = new value_type*[num_threads];\n+#else\n+    sd.sorting_places = new value_type*[num_threads];\n+    sd.merging_places = new RandomAccessIterator[num_threads];\n+#endif\n+\n+    if (Settings::sort_splitting == Settings::SAMPLING)\n+      sd.samples = new value_type[num_threads * (Settings::sort_mwms_oversampling * num_threads - 1)];\n+    else\n+      sd.samples = NULL;\n+\n+    sd.offsets = new difference_type[num_threads - 1];\n+    sd.pieces = new std::vector<Piece<difference_type> >[num_threads];\n+    for (int s = 0; s < num_threads; s++)\n+      sd.pieces[s].resize(num_threads);\n+    PMWMSSorterPU<RandomAccessIterator>* pus = new PMWMSSorterPU<RandomAccessIterator>[num_threads];\n+    difference_type* starts = sd.starts = new difference_type[num_threads + 1];\n+\n+    difference_type chunk_length = n / num_threads, split = n % num_threads, start = 0;\n+    for (int i = 0; i < num_threads; i++)\n+      {\n+\tstarts[i] = start;\n+\tstart += (i < split) ? (chunk_length + 1) : chunk_length;\n+\tpus[i].num_threads = num_threads;\n+\tpus[i].iam = i;\n+\tpus[i].sd = &sd;\n+\tpus[i].stable = stable;\n+      }\n+    starts[num_threads] = start;\n+\n+    // Now sort in parallel.\n+#pragma omp parallel num_threads(num_threads)\n+    parallel_sort_mwms_pu(&(pus[omp_get_thread_num()]), comp);\n+\n+    // XXX sd as RAII\n+    delete[] starts;\n+    delete[] sd.temporaries;\n+    delete[] sd.sorting_places;\n+    delete[] sd.merging_places;\n+\n+    if (Settings::sort_splitting == Settings::SAMPLING)\n+      delete[] sd.samples;\n+\n+    delete[] sd.offsets;\n+    delete[] sd.pieces;\n+\n+    delete[] pus;\n+  }\n+\n+}\n+\n+#endif"}, {"sha": "3209a58a3e64fe089216303004bca59d908922be", "filename": "libstdc++-v3/include/parallel/numeric", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,322 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/**\n+ * @file parallel/numeric\n+*\n+ * @brief Parallel STL fucntion calls corresponding to stl_numeric.h.\n+ * The functions defined here mainly do case switches and\n+ * call the actual parallelized versions in other files.\n+ * Inlining policy: Functions that basically only contain one function call,\n+ * are declared inline.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_NUMERIC_H\n+#define _GLIBCXX_PARALLEL_NUMERIC_H 1\n+\n+#include <numeric>\n+#include <functional>\n+#include <parallel/numericfwd.h>\n+#include <parallel/iterator.h>\n+#include <parallel/for_each.h>\n+#include <parallel/for_each_selectors.h>\n+#include <parallel/partial_sum.h>\n+\n+namespace std\n+{\n+namespace __parallel\n+{\n+  // Sequential fallback.\n+  template<typename InputIterator, typename T>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::accumulate(begin, end, init); }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename T, typename BinaryOperation>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init,\n+\t     BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::accumulate(begin, end, init, binary_op); }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename T, typename IteratorTag>\n+  inline T\n+  accumulate_switch(InputIterator begin, InputIterator end, T init, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename T>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    return accumulate_switch(begin, end, init, std::plus<typename std::iterator_traits<InputIterator>::value_type>(), typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename T, typename BinaryOperation, typename IteratorTag>\n+  T\n+  accumulate_switch(InputIterator begin, InputIterator end, T init, BinaryOperation binary_op, IteratorTag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    return accumulate(begin, end, init, binary_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename _RandomAccessIterator, typename T, typename BinaryOperation>\n+  T\n+  accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, T init, BinaryOperation binary_op, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tT res = init;\n+\t__gnu_parallel::accumulate_selector<_RandomAccessIterator> my_selector;\n+\t__gnu_parallel::for_each_template_random_access(begin, end, __gnu_parallel::nothing(), my_selector, __gnu_parallel::accumulate_binop_reduct<BinaryOperation>(binary_op), res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return accumulate(begin, end, init, binary_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename T, typename BinaryOperation>\n+  inline T\n+  accumulate(InputIterator begin, InputIterator end, T init, BinaryOperation binary_op, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    return accumulate_switch(begin, end, init, binary_op, typename std::iterator_traits<InputIterator>::iterator_category(), parallelism_tag);\n+  }\n+\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, binary_op1, binary_op2);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator1, typename InputIterator2, typename T>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init);\n+  }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  T\n+  inner_product_switch(RandomAccessIterator1 first1, RandomAccessIterator1 last1, RandomAccessIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tT res = init;\n+\t__gnu_parallel::inner_product_selector<RandomAccessIterator1, RandomAccessIterator2, T> my_selector(first1, first2);\n+\t__gnu_parallel::for_each_template_random_access(first1, last1, binary_op2, my_selector, binary_op1, res, res, -1, parallelism_tag);\n+\treturn res;\n+      }\n+    else\n+      return inner_product(first1, last1, first2, init, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // No parallelism for input iterators.\n+  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename IteratorTag1, typename IteratorTag2>\n+  inline T\n+  inner_product_switch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, IteratorTag1, IteratorTag2, __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, binary_op1, binary_op2);\n+  }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    typedef iterator_traits<InputIterator1> traits1_type;\n+    typedef typename traits1_type::iterator_category iterator1_category;\n+\n+    typedef iterator_traits<InputIterator2> traits2_type;\n+    typedef typename traits2_type::iterator_category iterator2_category;\n+\n+    return inner_product_switch(first1, last1, first2, init, binary_op1, binary_op2, iterator1_category(), iterator2_category(), parallelism_tag);\n+  }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T>\n+  inline T\n+  inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n+  {\n+    typedef iterator_traits<InputIterator1> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    return inner_product(first1, last1, first2, init, std::plus<value_type>(), \n+\t\t\t std::multiplies<value_type>(), parallelism_tag);\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t      __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::partial_sum(begin, end, result); }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t      BinaryOperation bin_op, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation, typename IteratorTag1, typename IteratorTag2>\n+  inline OutputIterator\n+  partial_sum_switch(InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, IteratorTag1, IteratorTag2)\n+  {\n+    return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op);\n+  }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  OutputIterator\n+  partial_sum_switch(InputIterator begin, InputIterator end,\n+\t\t     OutputIterator result, BinaryOperation bin_op,\n+\t\t     random_access_iterator_tag, random_access_iterator_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::partial_sum_minimal_n))\n+      return __gnu_parallel::parallel_partial_sum(begin, end, result, bin_op);\n+    else\n+      return partial_sum(begin, end, result, bin_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  partial_sum(InputIterator begin, InputIterator end, OutputIterator result)\n+  {\n+    typedef typename iterator_traits<InputIterator>::value_type value_type;\n+    return partial_sum(begin, end, result, std::plus<value_type>());\n+  }\n+\n+  // Public interface\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t      BinaryOperation binary_op)\n+  {\n+    typedef iterator_traits<InputIterator> traitsi_type;\n+    typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+    typedef iterator_traits<OutputIterator> traitso_type;\n+    typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+    return partial_sum_switch(begin, end, result, binary_op,\n+\t\t\t\t   iteratori_category(), iteratoro_category());\n+  }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result, __gnu_parallel::sequential_tag)\n+  { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result); }\n+\n+  // Sequential fallback.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result, BinaryOperation bin_op,\n+\t\t      __gnu_parallel::sequential_tag)\n+  {\n+    return _GLIBCXX_STD_P::adjacent_difference(begin, end, result, bin_op);\n+  }\n+\n+  // Sequential fallback for input iterator case.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation, typename IteratorTag1, typename IteratorTag2>\n+  inline OutputIterator\n+  adjacent_difference_switch(InputIterator begin, InputIterator end,\n+\t\t\t     OutputIterator result, BinaryOperation bin_op,\n+\t\t\t     IteratorTag1, IteratorTag2, __gnu_parallel::parallelism)\n+  { return adjacent_difference(begin, end, result, bin_op); }\n+\n+  // Parallel algorithm for random access iterators.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  OutputIterator\n+  adjacent_difference_switch(InputIterator begin, InputIterator end,\n+\t\t\t     OutputIterator result, BinaryOperation bin_op,\n+\t\t\t     random_access_iterator_tag, random_access_iterator_tag,\n+\t\t\t     __gnu_parallel::parallelism parallelism_tag)\n+  {\n+    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::adjacent_difference_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n+      {\n+\tbool dummy = true;\n+\ttypedef __gnu_parallel::iterator_pair<InputIterator, OutputIterator, random_access_iterator_tag> ip;\n+\t*result = *begin;\n+\tip begin_pair(begin + 1, result + 1), end_pair(end, result + (end - begin));\n+\t__gnu_parallel::adjacent_difference_selector<ip> functionality;\n+\t__gnu_parallel::for_each_template_random_access(begin_pair, end_pair, bin_op, functionality, __gnu_parallel::dummy_reduct(), dummy, dummy, -1, parallelism_tag);\n+\treturn functionality.finish_iterator;\n+      }\n+    else\n+      return adjacent_difference(begin, end, result, bin_op, __gnu_parallel::sequential_tag());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result,\n+\t\t      __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    return adjacent_difference(begin, end, result, std::minus<value_type>());\n+  }\n+\n+  // Public interface.\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t      OutputIterator result, BinaryOperation binary_op,\n+\t\t      __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced)\n+  {\n+    typedef iterator_traits<InputIterator> traitsi_type;\n+    typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+    typedef iterator_traits<OutputIterator> traitso_type;\n+    typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+    return adjacent_difference_switch(begin, end, result, binary_op,\n+\t\t\t\t      iteratori_category(), \n+\t\t\t\t      iteratoro_category(), parallelism_tag);\n+  }\n+} // end namespace\n+} // end namespace\n+\n+#endif /* _GLIBCXX_NUMERIC_H */"}, {"sha": "75fa3505f97fc6fb3cf7b5680b6c19f207277054", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,152 @@\n+// <numeric> parallel extensions -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/numericfwd.h\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PARALLEL_NUMERICFWD_H\n+#define _GLIBCXX_PARALLEL_NUMERICFWD_H 1\n+\n+#pragma GCC system_header\n+\n+#include <parallel/tags.h>\n+#include <parallel/settings.h>\n+\n+namespace std\n+{\n+namespace __parallel\n+{\n+  template<typename _IIter, typename T>\n+  inline T\n+  accumulate(_IIter, _IIter, T, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename T, typename _BinaryOper>\n+  inline T\n+  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename T>\n+  inline T\n+  accumulate(_IIter, _IIter, T, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _IIter, typename T, typename _BinaryOper>\n+  inline T\n+  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _IIter, typename T, typename _Tag>\n+  inline T\n+  accumulate_switch(_IIter, _IIter, T, _Tag, __gnu_parallel::parallelism parallelism_tag);\n+\n+  template<typename _IIter, typename T, typename _BinaryOper, typename _Tag>\n+  T\n+  accumulate_switch(_IIter, _IIter, T, _BinaryOper, _Tag, __gnu_parallel::parallelism parallelism_tag);\n+\n+  template<typename _RAIter, typename T, typename _BinaryOper>\n+  T\n+  accumulate_switch(_RAIter, _RAIter, T, _BinaryOper, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  inline _OIter\n+  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_balanced);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper, typename _Tag1, typename _Tag2>\n+  inline _OIter\n+  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  _OIter\n+  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+\n+\n+  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename T>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _IIter1, typename _IIter2, typename T>\n+  inline T\n+  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n+  T\n+  inner_product_switch(_RAIter1, _RAIter1, _RAIter2, T, BinaryFunction1, BinaryFunction2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename _Tag1, typename _Tag2>\n+  inline T\n+  inner_product_switch(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2, _Tag1, _Tag2, __gnu_parallel::parallelism parallelism_tag);\n+\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  partial_sum(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  inline _OIter\n+  partial_sum(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _OIter>\n+  inline _OIter\n+  partial_sum(_IIter, _IIter, _OIter result);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  inline _OIter\n+  partial_sum(_IIter, _IIter, _OIter, _BinaryOper);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper, typename _Tag1, typename _Tag2>\n+  inline _OIter\n+  partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n+\n+  template<typename _IIter, typename _OIter, typename _BinaryOper>\n+  _OIter\n+  partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, random_access_iterator_tag, random_access_iterator_tag);\n+} // end namespace\n+} // end namespace\n+\n+#endif"}, {"sha": "23fe6f4a95fcef25e169bfce12713ad5862809ec", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,105 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/omp_loop.h\n+ *  @brief Parallelization of embarrassingly parallel execution by\n+ *  means of an OpenMP for loop.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_OMP_LOOP_H\n+#define _GLIBCXX_PARALLEL_OMP_LOOP_H 1\n+\n+#include <omp.h>\n+\n+#include <parallel/settings.h>\n+#include <parallel/basic_iterator.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Embarrassingly parallel algorithm for random access\n+   * iterators, using an OpenMP for loop.\n+   *\n+   *  @param begin Begin iterator of element sequence.\n+   *  @param end End iterator of element sequence.\n+   *  @param o User-supplied functor (comparator, predicate, adding\n+   *  functor, etc.).\n+   *  @param f Functor to \"process\" an element with op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param r Functor to \"add\" a single result to the already\n+   *  processed elements (depends on functionality).\n+   *  @param base Base value for reduction.\n+   *  @param output Pointer to position where final result is written to\n+   *  @param bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+  Op\n+  for_each_template_random_access_omp_loop(RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu& f, Red r, Result base, Result& output, typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  {\n+    typedef typename std::iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+\n+    thread_index_t num_threads = (get_max_threads() < (end - begin)) ? get_max_threads() : static_cast<thread_index_t>((end - begin));\n+    Result *thread_results = new Result[num_threads];\n+    difference_type length = end - begin;\n+\n+    for (thread_index_t i = 0; i < num_threads; i++)\n+      {\n+\tthread_results[i] = r(thread_results[i], f(o, begin+i));\n+      }\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+#pragma omp for schedule(dynamic, Settings::workstealing_chunk_size)\n+      for (difference_type pos = 0; pos < length; pos++)\n+\t{\n+\t  thread_results[omp_get_thread_num()] = r(thread_results[omp_get_thread_num()], f(o, begin+pos));\n+\t}\n+    }\n+\n+    for (thread_index_t i = 0; i < num_threads; i++)\n+      {\n+\toutput = r(output, thread_results[i]);\n+      }\n+\n+    delete [] thread_results;\n+\n+    // Points to last element processed (needed as return value for\n+    // some algorithms like transform).\n+    f.finish_iterator = begin + length;\n+\n+    return o;\n+  }\n+} // end namespace\n+\n+#endif"}, {"sha": "22acb2de348ab238d1866a959fa4689b6a2c68fe", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,111 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/omp_loop_static.h\n+ *  @brief Parallelization of embarrassingly parallel execution by\n+ *  means of an OpenMP for loop with static scheduling.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_OMP_LOOP_STATIC_H\n+#define _GLIBCXX_PARALLEL_OMP_LOOP_STATIC_H 1\n+\n+#include <omp.h>\n+\n+#include <parallel/settings.h>\n+#include <parallel/basic_iterator.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+  /** @brief Embarrassingly parallel algorithm for random access\n+   * iterators, using an OpenMP for loop with static scheduling.\n+   *\n+   *  @param begin Begin iterator of element sequence.\n+   *  @param end End iterator of element sequence.\n+   *  @param o User-supplied functor (comparator, predicate, adding\n+   *  functor, ...).\n+   *  @param f Functor to \"process\" an element with op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param r Functor to \"add\" a single result to the already processed\n+   *  elements (depends on functionality).\n+   *  @param base Base value for reduction.\n+   *  @param output Pointer to position where final result is written to\n+   *  @param bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+  Op\n+  for_each_template_random_access_omp_loop_static(RandomAccessIterator begin,\n+\t\t\t\t\t\t  RandomAccessIterator end,\n+\t\t\t\t\t\t  Op o, Fu& f, Red r,\n+\t\t\t\t\t\t  Result base, Result& output,\n+\t\t\t\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    thread_index_t num_threads = (get_max_threads() < (end - begin)) ? get_max_threads() : (end - begin);\n+    Result *thread_results = new Result[num_threads];\n+    difference_type length = end - begin;\n+\n+    for (thread_index_t i = 0; i < num_threads; i++)\n+      {\n+\tthread_results[i] = r(thread_results[i], f(o, begin+i));\n+      }\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+#pragma omp for schedule(static, Settings::workstealing_chunk_size)\n+      for (difference_type pos = 0; pos < length; pos++)\n+\t{\n+\t  thread_results[omp_get_thread_num()] = r(thread_results[omp_get_thread_num()], f(o, begin+pos));\n+\t}\n+    }\n+\n+    for (thread_index_t i = 0; i < num_threads; i++)\n+      {\n+\toutput = r(output, thread_results[i]);\n+      }\n+\n+    delete [] thread_results;\n+\n+    // Points to last element processed (needed as return value for\n+    // some algorithms like transform).\n+    f.finish_iterator = begin + length;\n+\n+    return o;\n+  }\n+} // end namespace\n+\n+#endif"}, {"sha": "98604cf1da4b58b16e31360fe62d36a26017c5a9", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,120 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/par_loop.h\n+ *  @brief Parallelization of embarrassingly parallel execution by\n+ *  means of equal splitting.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_PAR_LOOP_H\n+#define _GLIBCXX_PARALLEL_PAR_LOOP_H 1\n+\n+#include <omp.h>\n+#include <parallel/settings.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+  /** @brief Embarrassingly parallel algorithm for random access\n+   * iterators, using hand-crafted parallelization by equal splitting\n+   * the work.\n+   *\n+   *  @param begin Begin iterator of element sequence.\n+   *  @param end End iterator of element sequence.\n+   *  @param o User-supplied functor (comparator, predicate, adding\n+   *  functor, ...)\n+   *  @param f Functor to \"process\" an element with op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param r Functor to \"add\" a single result to the already\n+   *  processed elements (depends on functionality).\n+   *  @param base Base value for reduction.\n+   *  @param output Pointer to position where final result is written to\n+   *  @param bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+  Op\n+  for_each_template_random_access_ed(RandomAccessIterator begin,\n+\t\t\t\t     RandomAccessIterator end, Op o, Fu& f,\n+\t\t\t\t     Red r, Result base, Result& output,\n+\t\t\t\t     typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    const difference_type length = end - begin;\n+    const difference_type settings_threads = static_cast<difference_type>(get_max_threads());\n+    const difference_type dmin = settings_threads < length ? settings_threads : length;\n+    const difference_type dmax = dmin > 1 ? dmin : 1;\n+\n+    thread_index_t num_threads = static_cast<thread_index_t>(dmax);\n+\n+\n+    Result *thread_results = new Result[num_threads];\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+      // Neutral element.\n+      Result reduct = Result();\n+\n+      thread_index_t p = num_threads;\n+      thread_index_t iam = omp_get_thread_num();\n+      difference_type start = iam * length / p;\n+      difference_type limit = (iam == p - 1) ? length : (iam + 1) * length / p;\n+\n+      if (start < limit)\n+\t{\n+\t  reduct = f(o, begin + start);\n+\t  start++;\n+\t}\n+\n+      for (; start < limit; start++)\n+\treduct = r(reduct, f(o, begin + start));\n+\n+      thread_results[iam] = reduct;\n+    }\n+\n+    for (thread_index_t i = 0; i < num_threads; i++)\n+      output = r(output, thread_results[i]);\n+\n+    // Points to last element processed (needed as return value for\n+    // some algorithms like transform).\n+    f.finish_iterator = begin + length;\n+\n+    return o;\n+  }\n+\n+} // end namespace\n+\n+#endif"}, {"sha": "63246126b8f03b9316e5374bdc3a55034e5d2aa8", "filename": "libstdc++-v3/include/parallel/parallel.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fparallel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fparallel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fparallel.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,48 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/parallel.h\n+ *  @brief End-user include file. Provides advanced settings and\n+ *  tuning options.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze and Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_PARALLEL_H\n+#define _GLIBCXX_PARALLEL_PARALLEL_H 1\n+\n+#include <parallel/features.h>\n+#include <parallel/compiletime_settings.h>\n+#include <parallel/types.h>\n+#include <parallel/tags.h>\n+#include <parallel/settings.h>\n+\n+#endif"}, {"sha": "909b171d6f4b8e02f893e89afdbdbbb674add1a2", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,191 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/partial_sum.h\n+ *  @brief Parallel implementation of std::partial_sum(), i. e. prefix\n+ *  sums.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_PARTIAL_SUM_H\n+#define _GLIBCXX_PARALLEL_PARTIAL_SUM_H 1\n+\n+\n+#include <omp.h>\n+#include <bits/stl_algobase.h>\n+#include <parallel/parallel.h>\n+#include <parallel/numericfwd.h>\n+\n+namespace __gnu_parallel\n+{\n+  // Problem: there is no 0-element given.\n+\n+  /** @brief Base case prefix sum routine.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param result Begin iterator of output sequence.\n+   *  @param bin_op Associative binary function.\n+   *  @param value Start value. Must be passed since the neutral\n+   *  element is unknown in general.\n+   *  @return End iterator of output sequence. */\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  inline OutputIterator\n+  parallel_partial_sum_basecase(InputIterator begin, InputIterator end,\n+\t\t\t\tOutputIterator result, BinaryOperation bin_op,\n+\t\t\t\ttypename std::iterator_traits<InputIterator>::value_type value)\n+  {\n+    if (begin == end)\n+      return result;\n+\n+    while (begin != end)\n+      {\n+\tvalue = bin_op(value, *begin);\n+\t*result = value;\n+\tresult++;\n+\tbegin++;\n+      }\n+    return result;\n+  }\n+\n+  /** @brief Parallel partial sum implmenetation, two-phase approach,\n+      no recursion.\n+      *  @param begin Begin iterator of input sequence.\n+      *  @param end End iterator of input sequence.\n+      *  @param result Begin iterator of output sequence.\n+      *  @param bin_op Associative binary function.\n+      *  @param n Length of sequence.\n+      *  @param num_threads Number of threads to use.\n+      *  @return End iterator of output sequence.\n+      */\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  OutputIterator\n+  parallel_partial_sum_linear(InputIterator begin, InputIterator end,\n+\t\t\t      OutputIterator result, BinaryOperation bin_op,\n+\t\t\t      typename std::iterator_traits<InputIterator>::difference_type n, int num_threads)\n+  {\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    if (num_threads > (n - 1))\n+      num_threads = static_cast<thread_index_t>(n - 1);\n+    if (num_threads < 2)\n+      {\n+\t*result = *begin;\n+\treturn parallel_partial_sum_basecase(begin + 1, end, result + 1, bin_op, *begin);\n+      }\n+\n+    difference_type borders[num_threads + 2];\n+\n+    if (Settings::partial_sum_dilatation == 1.0f)\n+      equally_split(n, num_threads + 1, borders);\n+    else\n+      {\n+\tdifference_type chunk_length = (int)((double)n / ((double)num_threads + Settings::partial_sum_dilatation)), borderstart = n - num_threads * chunk_length;\n+\tborders[0] = 0;\n+\tfor (int i = 1; i < (num_threads + 1); i++)\n+\t  {\n+\t    borders[i] = borderstart;\n+\t    borderstart += chunk_length;\n+\t  }\n+\tborders[num_threads + 1] = n;\n+      }\n+\n+    value_type* sums = new value_type[num_threads];\n+    OutputIterator target_end;\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+      int id = omp_get_thread_num();\n+      if (id == 0)\n+\t{\n+\t  *result = *begin;\n+\t  parallel_partial_sum_basecase(begin + 1, begin + borders[1], result + 1, bin_op, *begin);\n+\t  sums[0] = *(result + borders[1] - 1);\n+\t}\n+      else\n+\t{\n+\t  sums[id] = std::accumulate(begin + borders[id] + 1, begin + borders[id + 1], *(begin + borders[id]), bin_op, __gnu_parallel::sequential_tag());\n+\t}\n+\n+#pragma omp barrier\n+\n+#pragma omp single\n+      parallel_partial_sum_basecase(sums + 1, sums + num_threads, sums + 1, bin_op, sums[0]);\n+\n+#pragma omp barrier\n+\n+      // Still same team.\n+      parallel_partial_sum_basecase(begin + borders[id + 1], begin + borders[id + 2], result + borders[id + 1], bin_op, sums[id]);\n+    }\n+\n+    delete[] sums;\n+\n+    return result + n;\n+  }\n+\n+  /** @brief Parallel partial sum front-end.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param result Begin iterator of output sequence.\n+   *  @param bin_op Associative binary function.\n+   *  @return End iterator of output sequence. */\n+  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+  OutputIterator\n+  parallel_partial_sum(InputIterator begin, InputIterator end,\n+\t\t       OutputIterator result, BinaryOperation bin_op)\n+  {\n+    _GLIBCXX_CALL(begin - end);\n+\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type n = end - begin;\n+\n+    int num_threads = get_max_threads();\n+\n+    switch (Settings::partial_sum_algorithm)\n+      {\n+      case Settings::LINEAR:\n+\t// Need an initial offset.\n+\treturn parallel_partial_sum_linear(begin, end, result, bin_op,\n+\t\t\t\t\t   n, num_threads);\n+      default:\n+\t// Partial_sum algorithm not implemented.\n+\t_GLIBCXX_PARALLEL_ASSERT(0);\n+\treturn end;\n+      }\n+  }\n+}\n+\n+#endif"}, {"sha": "3c2917f0e2a2e8f66bbb0bfb55eaaff568ccc283", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,389 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/partition.h\n+ *  @brief Parallel implementation of std::partition(),\n+ *  std::nth_element(), and std::partial_sort().\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_PARTITION_H\n+#define _GLIBCXX_PARALLEL_PARTITION_H 1\n+\n+#include <parallel/basic_iterator.h>\n+#include <parallel/sort.h>\n+#include <bits/stl_algo.h>\n+#include <parallel/parallel.h>\n+\n+/** @brief Decide whether to declare certain variable volatile in this file. */\n+#define _GLIBCXX_VOLATILE volatile\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Parallel implementation of std::partition.\n+   *  @param begin Begin iterator of input sequence to split.\n+   *  @param end End iterator of input sequence to split.\n+   *  @param pred Partition predicate, possibly including some kind of pivot.\n+   *  @param max_num_threads Maximum number of threads to use for this task.\n+   *  @return Number of elements not fulfilling the predicate. */\n+  template<typename RandomAccessIterator, typename Predicate>\n+  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n+  parallel_partition(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t     Predicate pred, thread_index_t max_num_threads)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type n = end - begin;\n+\n+    _GLIBCXX_CALL(n)\n+\n+    // Shared.\n+    _GLIBCXX_VOLATILE difference_type left = 0, right = n - 1;\n+    _GLIBCXX_VOLATILE difference_type leftover_left, leftover_right, leftnew, rightnew;\n+    bool* reserved_left, * reserved_right;\n+\n+    reserved_left = new bool[max_num_threads];\n+    reserved_right = new bool[max_num_threads];\n+\n+    difference_type chunk_size;\n+    if (Settings::partition_chunk_share > 0.0)\n+      chunk_size = std::max((difference_type)Settings::partition_chunk_size, (difference_type)((double)n * Settings::partition_chunk_share / (double)max_num_threads));\n+    else\n+      chunk_size = Settings::partition_chunk_size;\n+\n+    // At least good for two processors.\n+    while (right - left + 1 >= 2 * max_num_threads * chunk_size)\n+      {\n+\tdifference_type num_chunks = (right - left + 1) / chunk_size;\n+\tthread_index_t num_threads = (int)std::min((difference_type)max_num_threads, num_chunks / 2);\n+\n+\tfor (int r = 0; r < num_threads; r++)\n+\t  {\n+\t    reserved_left[r] = false;\n+\t    reserved_right[r] = false;\n+\t  }\n+\tleftover_left = 0;\n+\tleftover_right = 0;\n+\n+#pragma omp parallel num_threads(num_threads)\n+\t{\n+\t  // Private.\n+\t  difference_type thread_left, thread_left_border, thread_right, thread_right_border;\n+\t  thread_left = left + 1;\n+\n+\t  // Just to satify the condition below.\n+\t  thread_left_border = thread_left - 1;\n+\t  thread_right = n - 1;\n+\t  thread_right_border = thread_right + 1;\n+\n+\t  bool iam_finished = false;\n+\t  while (!iam_finished)\n+\t    {\n+\t      if (thread_left > thread_left_border)\n+#pragma omp critical\n+\t\t{\n+\t\t  if (left + (chunk_size - 1) > right)\n+\t\t    iam_finished = true;\n+\t\t  else\n+\t\t    {\n+\t\t      thread_left = left;\n+\t\t      thread_left_border = left + (chunk_size - 1);\n+\t\t      left += chunk_size;\n+\t\t    }\n+\t\t}\n+\n+\t      if (thread_right < thread_right_border)\n+#pragma omp critical\n+\t\t{\n+\t\t  if (left > right - (chunk_size - 1))\n+\t\t    iam_finished = true;\n+\t\t  else\n+\t\t    {\n+\t\t      thread_right = right;\n+\t\t      thread_right_border = right - (chunk_size - 1);\n+\t\t      right -= chunk_size;\n+\t\t    }\n+\t\t}\n+\n+\t      if (iam_finished)\n+\t\tbreak;\n+\n+\t      // Swap as usual.\n+\t      while (thread_left < thread_right)\n+\t\t{\n+\t\t  while (pred(begin[thread_left]) && thread_left <= thread_left_border)\n+\t\t    thread_left++;\n+\t\t  while (!pred(begin[thread_right]) && thread_right >= thread_right_border)\n+\t\t    thread_right--;\n+\n+\t\t  if (thread_left > thread_left_border || thread_right < thread_right_border)\n+\t\t    // Fetch new chunk(s).\n+\t\t    break;\n+\n+\t\t  std::swap(begin[thread_left], begin[thread_right]);\n+\t\t  thread_left++;\n+\t\t  thread_right--;\n+\t\t}\n+\t    }\n+\n+\t  // Now swap the leftover chunks to the right places.\n+\t  if (thread_left <= thread_left_border)\n+#pragma omp atomic\n+\t    leftover_left++;\n+\t  if (thread_right >= thread_right_border)\n+#pragma omp atomic\n+\t    leftover_right++;\n+\n+#pragma omp barrier\n+\n+#pragma omp single\n+\t  {\n+\t    leftnew = left - leftover_left * chunk_size;\n+\t    rightnew = right + leftover_right * chunk_size;\n+\t  }\n+\n+#pragma omp barrier\n+\n+\t  // <=> thread_left_border + (chunk_size - 1) >= leftnew\n+\t  if (thread_left <= thread_left_border\n+\t      && thread_left_border >= leftnew)\n+\t    {\n+\t      // Chunk already in place, reserve spot.\n+\t      reserved_left[(left - (thread_left_border + 1)) / chunk_size] = true;\n+\t    }\n+\n+\t  // <=> thread_right_border - (chunk_size - 1) <= rightnew\n+\t  if (thread_right >= thread_right_border\n+\t      && thread_right_border <= rightnew)\n+\t    {\n+\t      // Chunk already in place, reserve spot.\n+\t      reserved_right[((thread_right_border - 1) - right) / chunk_size] = true;\n+\t    }\n+\n+#pragma omp barrier\n+\n+\t  if (thread_left <= thread_left_border && thread_left_border < leftnew)\n+\t    {\n+\t      // Find spot and swap.\n+\t      difference_type swapstart = -1;\n+#pragma omp critical\n+\t      {\n+\t\tfor (int r = 0; r < leftover_left; r++)\n+\t\t  if (!reserved_left[r])\n+\t\t    {\n+\t\t      reserved_left[r] = true;\n+\t\t      swapstart = left - (r + 1) * chunk_size;\n+\t\t      break;\n+\t\t    }\n+\t      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+#endif\n+\n+\t      std::swap_ranges(begin + thread_left_border - (chunk_size - 1), begin + thread_left_border + 1, begin + swapstart);\n+\t    }\n+\n+\t  if (thread_right >= thread_right_border\n+\t      && thread_right_border > rightnew)\n+\t    {\n+\t      // Find spot and swap\n+\t      difference_type swapstart = -1;\n+#pragma omp critical\n+\t      {\n+\t\tfor (int r = 0; r < leftover_right; r++)\n+\t\t  if (!reserved_right[r])\n+\t\t    {\n+\t\t      reserved_right[r] = true;\n+\t\t      swapstart = right + r * chunk_size + 1;\n+\t\t      break;\n+\t\t    }\n+\t      }\n+\n+#if _GLIBCXX_ASSERTIONS\n+\t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+#endif\n+\n+\t      std::swap_ranges(begin + thread_right_border, begin + thread_right_border + chunk_size, begin + swapstart);\n+\t    }\n+#if _GLIBCXX_ASSERTIONS\n+#pragma omp barrier\n+\n+#pragma omp single\n+\t  {\n+\t    for (int r = 0; r < leftover_left; r++)\n+\t      _GLIBCXX_PARALLEL_ASSERT(reserved_left[r]);\n+\t    for (int r = 0; r < leftover_right; r++)\n+\t      _GLIBCXX_PARALLEL_ASSERT(reserved_right[r]);\n+\t  }\n+\n+#pragma omp barrier\n+#endif\n+\n+#pragma omp barrier\n+\t  left = leftnew;\n+\t  right = rightnew;\n+\t}\n+      }\t// end \"recursion\"\n+\n+    difference_type final_left = left, final_right = right;\n+\n+    while (final_left < final_right)\n+      {\n+\t// Go right until key is geq than pivot.\n+\twhile (pred(begin[final_left]) && final_left < final_right)\n+\t  final_left++;\n+\n+\t// Go left until key is less than pivot.\n+\twhile (!pred(begin[final_right]) && final_left < final_right)\n+\t  final_right--;\n+\n+\tif (final_left == final_right)\n+\t  break;\n+\tstd::swap(begin[final_left], begin[final_right]);\n+\tfinal_left++;\n+\tfinal_right--;\n+      }\n+\n+    // All elements on the left side are < piv, all elements on the\n+    // right are >= piv\n+    delete[] reserved_left;\n+    delete[] reserved_right;\n+\n+    // Element \"between\" final_left and final_right might not have\n+    // been regarded yet\n+    if (final_left < n && !pred(begin[final_left]))\n+      // Really swapped.\n+      return final_left;\n+    else\n+      return final_left + 1;\n+  }\n+\n+  /** \n+   *  @brief Parallel implementation of std::nth_element().\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param nth Iterator of element that must be in position afterwards.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator. \n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  void \n+  parallel_nth_element(RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    _GLIBCXX_CALL(end - begin)\n+\n+    RandomAccessIterator split;\n+    value_type pivot;\n+    random_number rng;\n+\n+    difference_type minimum_length = std::max<difference_type>(2, Settings::partition_minimal_n);\n+\n+    // Break if input range to small.\n+    while (static_cast<sequence_index_t>(end - begin) >= minimum_length)\n+      {\n+\tdifference_type n = end - begin;\n+\n+\tRandomAccessIterator pivot_pos = begin +  rng(n);\n+\n+\t// Swap pivot_pos value to end.\n+\tif (pivot_pos != (end - 1))\n+\t  std::swap(*pivot_pos, *(end - 1));\n+\tpivot_pos = end - 1;\n+\n+\t// XXX Comparator must have first_value_type, second_value_type, result_type\n+\t// Comparator == __gnu_parallel::lexicographic<S, int, __gnu_parallel::less<S, S> > \n+\t// pivot_pos == std::pair<S, int>*\n+\t// XXX binder2nd only for RandomAccessIterators??\n+\t__gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+\n+\t// Divide, leave pivot unchanged in last place.\n+\tRandomAccessIterator split_pos1, split_pos2;\n+\tsplit_pos1 = begin + parallel_partition(begin, end - 1, pred, get_max_threads());\n+\n+\t// Left side: < pivot_pos; right side: >= pivot_pos\n+\n+\t// Swap pivot back to middle.\n+\tif (split_pos1 != pivot_pos)\n+\t  std::swap(*split_pos1, *pivot_pos);\n+\tpivot_pos = split_pos1;\n+\n+\t// In case all elements are equal, split_pos1 == 0\n+\tif ((split_pos1 + 1 - begin) < (n >> 7) || (end - split_pos1) < (n >> 7))\n+\t  {\n+\t    // Very unequal split, one part smaller than one 128th\n+\t    // elements not stricly larger than the pivot.\n+\t    __gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n+\n+\t    // Find other end of pivot-equal range.\n+\t    split_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n+\t  }\n+\telse\n+\t  // Only skip the pivot.\n+\t  split_pos2 = split_pos1 + 1;\n+\n+\t// Compare iterators.\n+\tif (split_pos2 <= nth)\n+\t  begin = split_pos2;\n+\telse if (nth < split_pos1)\n+\t  end = split_pos1;\n+\telse\n+\t  break;\n+      }\n+\n+    // Only at most Settings::partition_minimal_n elements left.\n+    __gnu_sequential::sort(begin, end, comp);\n+  }\n+\n+  /** @brief Parallel implementation of std::partial_sort().\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param middle Sort until this position.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator. */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  void\n+  parallel_partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end, Comparator comp)\n+  {\n+    parallel_nth_element(begin, middle, end, comp);\n+    std::sort(begin, middle, comp);\n+  }\n+\n+}\t//namespace __gnu_parallel\n+\n+#undef _GLIBCXX_VOLATILE\n+\n+#endif"}, {"sha": "9d2143b5787eb59f46dd2db35d5d6adcce5520e2", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,153 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/queue.h\n+ *  @brief Lock-free double-ended queue.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_QUEUE_H\n+#define _GLIBCXX_PARALLEL_QUEUE_H 1\n+\n+#include <parallel/types.h>\n+#include <parallel/base.h>\n+#include <parallel/compatibility.h>\n+\n+/** @brief Decide whether to declare certain variable volatile in this file. */\n+#define _GLIBCXX_VOLATILE volatile\n+\n+namespace __gnu_parallel\n+{\n+  /**@brief Double-ended queue of bounded size, allowing lock-free\n+   *  atomic access.  push_front() and pop_front() must not be called\n+   *  concurrently to each other, while pop_back() can be called\n+   *  concurrently at all times.\n+   *  @c empty(), @c size(), and @c top() are intentionally not provided.\n+   *  Calling them would not make sense in a concurrent setting.\n+   *  @param T Contained element type. */\n+  template<typename T>\n+  class RestrictedBoundedConcurrentQueue\n+  {\n+  private:\n+    /** @brief Array of elements, seen as cyclic buffer. */\n+    T* base;\n+\n+    /** @brief Maximal number of elements contained at the same time. */\n+    sequence_index_t max_size;\n+\n+    /** @brief Cyclic begin and end pointers contained in one\n+\tatomically changeable value. */\n+    _GLIBCXX_VOLATILE lcas_t borders;\n+\n+  public:\n+    /** @brief Constructor. Not to be called concurrent, of course.\n+     *  @param max_size Maximal number of elements to be contained. */\n+    RestrictedBoundedConcurrentQueue(sequence_index_t max_size)\n+    {\n+      this->max_size = max_size;\n+      base = new T[max_size];\n+      borders = encode2(0, 0);\n+#pragma omp flush\n+    }\n+\n+    /** @brief Destructor. Not to be called concurrent, of course. */\n+    ~RestrictedBoundedConcurrentQueue()\n+    {\n+      delete[] base;\n+    }\n+\n+    /** @brief Pushes one element into the queue at the front end.\n+     *  Must not be called concurrently with pop_front(). */\n+    void push_front(const T& t)\n+    {\n+      lcas_t former_borders = borders;\n+      int former_front, former_back;\n+      decode2(former_borders, former_front, former_back);\n+      *(base + former_front % max_size) = t;\n+#if _GLIBCXX_ASSERTIONS\n+      // Otherwise: front - back > max_size eventually.\n+      _GLIBCXX_PARALLEL_ASSERT(((former_front + 1) - former_back) <= max_size);\n+#endif\n+      fetch_and_add(&borders, encode2(1, 0));\n+    }\n+\n+    /** @brief Pops one element from the queue at the front end.\n+     *  Must not be called concurrently with pop_front(). */\n+    bool pop_front(T& t)\n+    {\n+      int former_front, former_back;\n+#pragma omp flush\n+      decode2(borders, former_front, former_back);\n+      while (former_front > former_back)\n+\t{\n+\t  // Chance.\n+\t  lcas_t former_borders = encode2(former_front, former_back);\n+\t  lcas_t new_borders = encode2(former_front - 1, former_back);\n+\t  if (compare_and_swap(&borders, former_borders, new_borders))\n+\t    {\n+\t      t = *(base + (former_front - 1) % max_size);\n+\t      return true;\n+\t    }\n+#pragma omp flush\n+\t  decode2(borders, former_front, former_back);\n+\t}\n+      return false;\n+    }\n+\n+    /** @brief Pops one element from the queue at the front end.\n+     *  Must not be called concurrently with pop_front(). */\n+    bool pop_back(T& t)\t//queue behavior\n+    {\n+      int former_front, former_back;\n+#pragma omp flush\n+      decode2(borders, former_front, former_back);\n+      while (former_front > former_back)\n+\t{\n+\t  // Chance.\n+\t  lcas_t former_borders = encode2(former_front, former_back);\n+\t  lcas_t new_borders = encode2(former_front, former_back + 1);\n+\t  if (compare_and_swap(&borders, former_borders, new_borders))\n+\t    {\n+\t      t = *(base + former_back % max_size);\n+\t      return true;\n+\t    }\n+#pragma omp flush\n+\t  decode2(borders, former_front, former_back);\n+\t}\n+      return false;\n+    }\n+  };\n+}\t//namespace __gnu_parallel\n+\n+#undef _GLIBCXX_VOLATILE\n+\n+#endif"}, {"sha": "e3df87a66d6c2987f183071460339a4b2cf5138a", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,172 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/quicksort.h\n+ *  @brief Implementation of a unbalanced parallel quicksort (in-place).\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_QUICKSORT_H\n+#define _GLIBCXX_PARALLEL_QUICKSORT_H 1\n+\n+#include <parallel/parallel.h>\n+#include <parallel/partition.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Unbalanced quicksort divide step.\n+   *  @param begin Begin iterator of subsequence.\n+   *  @param end End iterator of subsequence.\n+   *  @param comp Comparator.\n+   *  @param pivot_rank Desired rank of the pivot.\n+   *  @param num_samples Chosse pivot from that many samples.\n+   *  @param num_threads Number of threads that are allowed to work on\n+   *  this part.\n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n+  parallel_sort_qs_divide(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t\t  Comparator comp,\n+\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type pivot_rank,\n+\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type num_samples, thread_index_t num_threads)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type n = end - begin;\n+    num_samples = std::min(num_samples, n);\n+    value_type samples[num_samples];\n+\n+    for (difference_type s = 0; s < num_samples; s++)\n+      samples[s] = begin[(unsigned long long)s * n / num_samples];\n+\n+    __gnu_sequential::sort(samples, samples + num_samples, comp);\n+\n+    value_type& pivot = samples[pivot_rank * num_samples / n];\n+\n+    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, pivot);\n+    difference_type split = parallel_partition(begin, end, pred, num_threads);\n+\n+    return split;\n+  }\n+\n+  /** @brief Unbalanced quicksort conquer step.\n+   *  @param begin Begin iterator of subsequence.\n+   *  @param end End iterator of subsequence.\n+   *  @param comp Comparator.\n+   *  @param num_threads Number of threads that are allowed to work on\n+   *  this part.\n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort_qs_conquer(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, int num_threads)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    if (num_threads <= 1)\n+      {\n+\t__gnu_sequential::sort(begin, end, comp);\n+\treturn;\n+      }\n+\n+    difference_type n = end - begin, pivot_rank;\n+\n+    if (n <= 1)\n+      return;\n+\n+    thread_index_t num_processors_left;\n+\n+    if ((num_threads % 2) == 1)\n+      num_processors_left = num_threads / 2 + 1;\n+    else\n+      num_processors_left = num_threads / 2;\n+\n+    pivot_rank = n * num_processors_left / num_threads;\n+\n+    difference_type split = parallel_sort_qs_divide(begin, end, comp, pivot_rank,\n+Settings::sort_qs_num_samples_preset, num_threads);\n+\n+#pragma omp parallel sections\n+    {\n+#pragma omp section\n+      parallel_sort_qs_conquer(begin, begin + split, comp, num_processors_left);\n+#pragma omp section\n+      parallel_sort_qs_conquer(begin + split, end, comp, num_threads - num_processors_left);\n+    }\n+  }\n+\n+\n+\n+  /** @brief Unbalanced quicksort main call.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator input sequence, ignored.\n+   *  @param comp Comparator.\n+   *  @param n Length of input sequence.\n+   *  @param num_threads Number of threads that are allowed to work on\n+   *  this part.\n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort_qs(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t   Comparator comp,\n+\t\t   typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads)\n+  {\n+    _GLIBCXX_CALL(n)\n+\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    if (n == 0)\n+      return;\n+\n+    // At least one element per processor.\n+    if (num_threads > n)\n+      num_threads = static_cast<thread_index_t>(n);\n+\n+    Settings::sort_qs_num_samples_preset = 100;\n+\n+    // Hard to avoid.\n+    omp_set_num_threads(num_threads);\n+\n+    bool old_nested = (omp_get_nested() != 0);\n+    omp_set_nested(true);\n+    parallel_sort_qs_conquer(begin, begin + n, comp, num_threads);\n+    omp_set_nested(old_nested);\n+  }\n+\n+}\t//namespace __gnu_parallel\n+\n+#endif"}, {"sha": "266ed0ab25167daf450e4cfcc070ce557ae38a3c", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,386 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/random_number.h\n+ *  @brief Random number generator based on the Mersenne twister.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_RANDOM_NUMBER_H\n+#define _GLIBCXX_PARALLEL_RANDOM_NUMBER_H 1\n+\n+#include <parallel/types.h>\n+\n+namespace __gnu_parallel\n+{\n+  // XXX use tr1 random number.\n+  // http://www.math.keio.ac.jp/matumoto/emt.html\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  class mersenne_twister\n+  {\n+  public:\n+    typedef UIntType result_type;\n+    static const int word_size = w;\n+    static const int state_size = n;\n+    static const int shift_size = m;\n+    static const int mask_bits = r;\n+    static const UIntType parameter_a = a;\n+    static const int output_u = u;\n+    static const int output_s = s;\n+    static const UIntType output_b = b;\n+    static const int output_t = t;\n+    static const UIntType output_c = c;\n+    static const int output_l = l;\n+\n+    static const bool has_fixed_range = false;\n+\n+    mersenne_twister() { seed(); }\n+\n+#if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x520)\n+    // Work around overload resolution problem (Gennadiy E. Rozental)\n+    explicit mersenne_twister(const UIntType& value)\n+#else\n+      explicit mersenne_twister(UIntType value)\n+#endif\n+    { seed(value); }\n+    template<typename It> mersenne_twister(It& first, It last) { seed(first,last); }\n+\n+    template<typename Generator>\n+    explicit mersenne_twister(Generator & gen) { seed(gen); }\n+\n+    // compiler-generated copy ctor and assignment operator are fine\n+\n+    void seed() { seed(UIntType(5489)); }\n+\n+#if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x520)\n+    // Work around overload resolution problem (Gennadiy E. Rozental)\n+    void seed(const UIntType& value)\n+#else\n+      void seed(UIntType value)\n+#endif\n+    {\n+      // New seeding algorithm from\n+      // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\n+      // In the previous versions, MSBs of the seed affected only MSBs of the\n+      // state x[].\n+      const UIntType mask = ~0u;\n+      x[0] = value & mask;\n+      for (i = 1; i < n; i++) {\n+\t// See Knuth \"The Art of Computer Programming\" Vol. 2, 3rd ed., page 106\n+\tx[i] = (1812433253UL * (x[i-1] ^ (x[i-1] >> (w-2))) + i) & mask;\n+      }\n+    }\n+\n+    // For GCC, moving this function out-of-line prevents inlining, which may\n+    // reduce overall object code size.  However, MSVC does not grok\n+    // out-of-line definitions of member function templates.\n+    template<typename Generator>\n+    void seed(Generator & gen)\n+    {\n+      // I could have used std::generate_n, but it takes \"gen\" by value\n+      for (int j = 0; j < n; j++)\n+\tx[j] = gen();\n+      i = n;\n+    }\n+\n+    template<typename It>\n+    void seed(It& first, It last)\n+    {\n+      int j;\n+      for (j = 0; j < n && first != last; ++j, ++first)\n+\tx[j] = *first;\n+      i = n;\n+      /*    if (first == last && j < n)\n+\t    throw std::invalid_argument(\"mersenne_twister::seed\");*/\n+    }\n+\n+    result_type min() const { return 0; }\n+    result_type max() const\n+    {\n+      // avoid \"left shift count >= with of type\" warning\n+      result_type res = 0;\n+      for (int i = 0; i < w; ++i)\n+\tres |= (1u << i);\n+      return res;\n+    }\n+\n+    result_type operator()();\n+    static bool validation(result_type v) { return val == v; }\n+\n+#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE\n+\n+    friend bool operator==(const mersenne_twister& x, const mersenne_twister& y)\n+    {\n+      for (int j = 0; j < state_size; ++j)\n+\tif (x.compute(j) != y.compute(j))\n+\t  return false;\n+      return true;\n+    }\n+\n+    friend bool operator!=(const mersenne_twister& x, const mersenne_twister& y)\n+    { return !(x == y); }\n+#else\n+    // Use a member function; Streamable concept not supported.\n+    bool operator==(const mersenne_twister& rhs) const\n+    {\n+      for (int j = 0; j < state_size; ++j)\n+\tif (compute(j) != rhs.compute(j))\n+\t  return false;\n+      return true;\n+    }\n+\n+    bool operator!=(const mersenne_twister& rhs) const\n+    { return !(*this == rhs); }\n+#endif\n+\n+  private:\n+    // returns x(i-n+index), where index is in 0..n-1\n+    UIntType compute(unsigned int index) const\n+    {\n+      // equivalent to (i-n+index) % 2n, but doesn't produce negative numbers\n+      return x[ (i + n + index) % (2*n) ];\n+    }\n+    void twist(int block);\n+\n+    // state representation: next output is o(x(i))\n+    //   x[0]  ... x[k] x[k+1] ... x[n-1]     x[n]     ... x[2*n-1]   represents\n+    //  x(i-k) ... x(i) x(i+1) ... x(i-k+n-1) x(i-k-n) ... x[i(i-k-1)]\n+    // The goal is to always have x(i-n) ... x(i-1) available for\n+    // operator== and save/restore.\n+\n+    UIntType x[2*n];\n+    int i;\n+  };\n+\n+#ifndef BOOST_NO_INCLASS_MEMBER_INITIALIZATION\n+  //  A definition is required even for integral static constants\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const bool mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::has_fixed_range;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::state_size;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::shift_size;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::mask_bits;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::parameter_a;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_u;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_s;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_b;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_t;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_c;\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_l;\n+#endif\n+\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  void mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::twist(int block)\n+  {\n+    const UIntType upper_mask = (~0u) << r;\n+    const UIntType lower_mask = ~upper_mask;\n+\n+    if (block == 0) {\n+      for (int j = n; j < 2*n; j++) {\n+\tUIntType y = (x[j-n] & upper_mask) | (x[j-(n-1)] & lower_mask);\n+\tx[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n+      }\n+    } else if (block == 1) {\n+      // split loop to avoid costly modulo operations\n+      {  // extra scope for MSVC brokenness w.r.t. for scope\n+\tfor (int j = 0; j < n-m; j++) {\n+\t  UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n+\t  x[j] = x[j+n+m] ^ (y >> 1) ^ (y&1 ? a : 0);\n+\t}\n+      }\n+\n+      for (int j = n-m; j < n-1; j++) {\n+\tUIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n+\tx[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n+      }\n+      // last iteration\n+      UIntType y = (x[2*n-1] & upper_mask) | (x[0] & lower_mask);\n+      x[n-1] = x[m-1] ^ (y >> 1) ^ (y&1 ? a : 0);\n+      i = 0;\n+    }\n+  }\n+\n+  template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n+\t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n+  inline typename mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::result_type\n+  mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::operator()()\n+  {\n+    if (i == n)\n+      twist(0);\n+    else if (i >= 2*n)\n+      twist(1);\n+    // Step 4\n+    UIntType z = x[i];\n+    ++i;\n+    z ^= (z >> u);\n+    z ^= ((z << s) & b);\n+    z ^= ((z << t) & c);\n+    z ^= (z >> l);\n+    return z;\n+  }\n+\n+\n+  typedef mersenne_twister<uint32,32,351,175,19,0xccab8ee7,11,\n+\t\t\t   7,0x31b6ab00,15,0xffe50000,17, 0xa37d3c92> mt11213b;\n+\n+  // validation by experiment from mt19937.c\n+  typedef mersenne_twister<uint32,32,624,397,31,0x9908b0df,11,\n+\t\t\t   7,0x9d2c5680,15,0xefc60000,18, 3346425566U> mt19937;\n+\n+  /** @brief Random number generator, based on the Mersenne twister. */\n+  class random_number\n+  {\n+  private:\n+    mt19937 mt;\n+    uint64 supremum, RAND_SUP;\n+    double supremum_reciprocal, RAND_SUP_REC;\n+\n+    uint64 cache;\t/* assumed to be twice as long as the usual random number */\n+    int bits_left;\t/* bit results */\n+\n+    static inline uint32 scale_down(uint64 x,\n+#if _GLIBCXX_SCALE_DOWN_FPU\n+\t\t\t\t    uint64 /*supremum*/, double supremum_reciprocal)\n+#else\n+      uint64 supremum, double /*supremum_reciprocal*/)\n+#endif\n+\t{\n+#if _GLIBCXX_SCALE_DOWN_FPU\n+\t  return (uint32)(x * supremum_reciprocal);\n+#else\n+\t  return static_cast<uint32>(x % supremum);\n+#endif\n+\t}\n+\n+public:\n+  /** @brief Default constructor. Seed with 0. */\n+  random_number() :\n+    mt(0),\n+    supremum(0x100000000ULL),\n+    RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+    supremum_reciprocal((double)supremum / (double)RAND_SUP),\n+    RAND_SUP_REC(1.0 / (double)RAND_SUP),\n+    cache(0), bits_left(0)\n+  {\n+  }\n+\n+  /** @brief Constructor.\n+   *  @param seed Random seed.\n+   *  @param supremum Generate integer random numbers in the interval @c [0,supremum). */\n+  random_number(uint32 seed, uint64 supremum = 0x100000000ULL) :\n+    mt(seed),\n+    supremum(supremum),\n+    RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+    supremum_reciprocal((double)supremum / (double)RAND_SUP),\n+    RAND_SUP_REC(1.0 / (double)RAND_SUP),\n+    cache(0), bits_left(0)\n+  {\n+  }\n+\n+  /** @brief Generate unsigned random 32-bit integer. */\n+  inline uint32 operator()()\n+  {\n+    return scale_down(mt(), supremum, supremum_reciprocal);\n+  }\n+\n+  /** @brief Generate unsigned random 32-bit integer in the interval @c [0,local_supremum). */\n+  inline uint32 operator()(uint64 local_supremum)\n+  {\n+    return scale_down(mt(), local_supremum, (double)local_supremum * RAND_SUP_REC);\n+  }\n+\n+  /** @brief Set the random seed.\n+   *  @param seed to set. */\n+  inline void set_seed(uint32 seed)\n+  {\n+    mt.seed(seed);\n+    cache = mt();\n+    bits_left = 32;\n+  }\n+\n+  /** @brief Generate a number of random bits, compile-time parameter. */\n+  template<int bits>\n+  inline unsigned long genrand_bits()\n+  {\n+    unsigned long res = cache & ((1 << bits) - 1);\n+    cache = cache >> bits;\n+    bits_left -= bits;\n+    if (bits_left < 32)\n+      {\n+\tcache |= (((uint64)mt()) << bits_left);\n+\tbits_left += 32;\n+      }\n+    return res;\n+  }\n+\n+  /** @brief Generate a number of random bits, run-time parameter.\n+   *  @param bits Number of bits to generate. */\n+  inline unsigned long genrand_bits(int bits)\n+  {\n+    unsigned long res = cache & ((1 << bits) - 1);\n+    cache = cache >> bits;\n+    bits_left -= bits;\n+    if (bits_left < 32)\n+      {\n+\tcache |= (((uint64)mt()) << bits_left);\n+\tbits_left += 32;\n+      }\n+    return res;\n+  }\n+\n+};\n+\n+} // namespace __gnu_parallel\n+\n+#endif"}, {"sha": "f18f7774840176020ef89de91b3c86cb39b4f4e6", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,516 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/random_shuffle.h\n+ *  @brief Parallel implementation of std::random_shuffle().\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_RANDOM_SHUFFLE_H\n+#define _GLIBCXX_PARALLEL_RANDOM_SHUFFLE_H 1\n+\n+#include <limits>\n+\n+#include <parallel/basic_iterator.h>\n+#include <bits/stl_algo.h>\n+\n+#include <parallel/parallel.h>\n+#include <parallel/base.h>\n+#include <parallel/random_number.h>\n+#include <parallel/timing.h>\n+\n+namespace __gnu_parallel\n+{\n+  /** @brief Type to hold the index of a bin.\n+   *\n+   *  Since many variables of this type are allocated, it should be\n+   *  chosen as small as possible.\n+   */\n+  typedef unsigned short bin_index;\n+\n+  /** @brief Data known to every thread participating in\n+      __gnu_parallel::parallel_random_shuffle(). */\n+  template<typename RandomAccessIterator>\n+  struct DRandomShufflingGlobalData\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    /** @brief Begin iterator of the source. */\n+    RandomAccessIterator& source;\n+\n+    /** @brief Temporary arrays for each thread. */\n+    value_type** temporaries;\n+\n+    /** @brief Two-dimensional array to hold the thread-bin distribution.\n+     *\n+     *  Dimensions (num_threads + 1) x (num_bins + 1). */\n+    difference_type** dist;\n+\n+    /** @brief Start indexes of the threads' chunks. */\n+    difference_type* starts;\n+\n+    /** @brief Number of the thread that will further process the\n+\tcorresponding bin. */\n+    thread_index_t* bin_proc;\n+\n+    /** @brief Number of bins to distribute to. */\n+    int num_bins;\n+\n+    /** @brief Number of bits needed to address the bins. */\n+    int num_bits;\n+\n+    /** @brief Constructor. */\n+    DRandomShufflingGlobalData(RandomAccessIterator& _source)\n+    : source(_source) { }\n+  };\n+\n+  /** @brief Local data for a thread participating in\n+      __gnu_parallel::parallel_random_shuffle().\n+   */\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  struct DRSSorterPU\n+  {\n+    /** @brief Number of threads participating in total. */\n+    int num_threads;\n+\n+    /** @brief Number of owning thread. */\n+    int iam;\n+\n+    /** @brief Begin index for bins taken care of by this thread. */\n+    bin_index bins_begin;\n+\n+    /** @brief End index for bins taken care of by this thread. */\n+    bin_index bins_end;\n+\n+    /** @brief Random seed for this thread. */\n+    uint32 seed;\n+\n+    /** @brief Pointer to global data. */\n+    DRandomShufflingGlobalData<RandomAccessIterator>* sd;\n+  };\n+\n+  /** @brief Generate a random number in @c [0,2^logp).\n+   *  @param logp Logarithm (basis 2) of the upper range bound.\n+   *  @param rng Random number generator to use.\n+   */\n+  template<typename RandomNumberGenerator>\n+  inline int random_number_pow2(int logp, RandomNumberGenerator& rng)\n+  {\n+    return rng.genrand_bits(logp);\n+  }\n+\n+  /** @brief Random shuffle code executed by each thread.\n+   *  @param pus Arary of thread-local data records. */\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  inline void parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* pus)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    Timing<sequential_tag> t;\n+    t.tic();\n+\n+    DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* d = &pus[omp_get_thread_num()];\n+    DRandomShufflingGlobalData<RandomAccessIterator>* sd = d->sd;\n+    thread_index_t iam = d->iam;\n+\n+    // Indexing: dist[bin][processor]\n+    difference_type length = sd->starts[iam + 1] - sd->starts[iam];\n+    bin_index* oracles = new bin_index[length];\n+    difference_type* dist = new difference_type[sd->num_bins + 1];\n+    bin_index* bin_proc = new bin_index[sd->num_bins];\n+    value_type** temporaries = new value_type*[d->num_threads];\n+\n+    // Compute oracles and count appearances.\n+    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+      dist[b] = 0;\n+    int num_bits = sd->num_bits;\n+\n+    random_number rng(d->seed);\n+\n+    // First main loop.\n+    for (difference_type i = 0; i < length; i++)\n+      {\n+\tbin_index oracle = random_number_pow2(num_bits, rng);\n+\toracles[i] = oracle;\n+\n+\t// To allow prefix (partial) sum.\n+\tdist[oracle + 1]++;\n+      }\n+\n+    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+      sd->dist[b][iam + 1] = dist[b];\n+\n+    t.tic();\n+\n+#pragma omp barrier\n+\n+    t.tic();\n+\n+#pragma omp single\n+    {\n+      // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n+      // total number of items in bin s\n+      for (bin_index s = 0; s < sd->num_bins; s++)\n+\tpartial_sum(sd->dist[s + 1], sd->dist[s + 1] + d->num_threads + 1, sd->dist[s + 1]);\n+    }\n+\n+#pragma omp barrier\n+\n+    t.tic();\n+\n+    sequence_index_t offset = 0, global_offset = 0;\n+    for (bin_index s = 0; s < d->bins_begin; s++)\n+      global_offset += sd->dist[s + 1][d->num_threads];\n+\n+#pragma omp barrier\n+\n+    for (bin_index s = d->bins_begin; s < d->bins_end; s++)\n+      {\n+\tfor (int t = 0; t < d->num_threads + 1; t++)\n+\t  sd->dist[s + 1][t] += offset;\n+\toffset = sd->dist[s + 1][d->num_threads];\n+      }\n+\n+    sd->temporaries[iam] = new value_type[offset];\n+\n+    t.tic();\n+\n+#pragma omp barrier\n+\n+    t.tic();\n+\n+    // Draw local copies to avoid false sharing.\n+    for (bin_index b = 0; b < sd->num_bins + 1; b++)\n+      dist[b] = sd->dist[b][iam];\n+    for (bin_index b = 0; b < sd->num_bins; b++)\n+      bin_proc[b] = sd->bin_proc[b];\n+    for (thread_index_t t = 0; t < d->num_threads; t++)\n+      temporaries[t] = sd->temporaries[t];\n+\n+    RandomAccessIterator source = sd->source;\n+    difference_type start = sd->starts[iam];\n+\n+    // Distribute according to oracles, second main loop.\n+    for (difference_type i = 0; i < length; i++)\n+      {\n+\tbin_index target_bin = oracles[i];\n+\tthread_index_t target_p = bin_proc[target_bin];\n+\n+\t// Last column [d->num_threads] stays unchanged.\n+\ttemporaries[target_p][dist[target_bin + 1]++] = *(source + i + start);\n+      }\n+\n+    delete[] oracles;\n+    delete[] dist;\n+    delete[] bin_proc;\n+    delete[] temporaries;\n+\n+    t.tic();\n+\n+#pragma omp barrier\n+\n+    t.tic();\n+\n+    // Shuffle bins internally.\n+    for (bin_index b = d->bins_begin; b < d->bins_end; b++)\n+      {\n+\tvalue_type* begin = sd->temporaries[iam] + ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]),\n+\t  * end = sd->temporaries[iam] + sd->dist[b + 1][d->num_threads];\n+\tsequential_random_shuffle(begin, end, rng);\n+\tstd::copy(begin, end, sd->source + global_offset + ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]));\n+      }\n+\n+    delete[] sd->temporaries[iam];\n+\n+    t.tic();\n+\n+    t.print();\n+  }\n+\n+  /** @brief Round up to the next greater power of 2.\n+   *  @param x Integer to round up */\n+  template<typename T>\n+  T round_up_to_pow2(T x)\n+  {\n+    if (x <= 1)\n+      return 1;\n+    else\n+      return (T)1 << (log2(x - 1) + 1);\n+  }\n+\n+  /** @brief Main parallel random shuffle step.\n+   *  @param begin Begin iterator of sequence.\n+   *  @param end End iterator of sequence.\n+   *  @param n Length of sequence.\n+   *  @param num_threads Number of threads to use.\n+   *  @param rng Random number generator to use.\n+   */\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  inline void\n+  parallel_random_shuffle_drs(RandomAccessIterator begin, RandomAccessIterator end, typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads, RandomNumberGenerator& rng)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    _GLIBCXX_CALL(n)\n+\n+    if (num_threads > n)\n+      num_threads = static_cast<thread_index_t>(n);\n+\n+    bin_index num_bins, num_bins_cache;\n+\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n+    // Try the L1 cache first.\n+\n+    // Must fit into L1.\n+    num_bins_cache = std::max((difference_type)1, (difference_type)(n / (Settings::L1_cache_size_lb / sizeof(value_type))));\n+    num_bins_cache = round_up_to_pow2(num_bins_cache);\n+\n+    // No more buckets than TLB entries, power of 2\n+    // Power of 2 and at least one element per bin, at most the TLB size.\n+    num_bins = std::min(n, (difference_type)num_bins_cache);\n+\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n+    // 2 TLB entries needed per bin.\n+    num_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+#endif\n+    num_bins = round_up_to_pow2(num_bins);\n+\n+    if (num_bins < num_bins_cache)\n+      {\n+#endif\n+\t// Now try the L2 cache\n+\t// Must fit into L2\n+\tnum_bins_cache = static_cast<bin_index>(std::max((difference_type)1, (difference_type)(n / (Settings::L2_cache_size / sizeof(value_type)))));\n+\tnum_bins_cache = round_up_to_pow2(num_bins_cache);\n+\n+\t// No more buckets than TLB entries, power of 2.\n+\tnum_bins = static_cast<bin_index>(std::min(n, (difference_type)num_bins_cache));\n+\t// Power of 2 and at least one element per bin, at most the TLB size.\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n+\t// 2 TLB entries needed per bin.\n+\tnum_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+#endif\n+\tnum_bins = round_up_to_pow2(num_bins);\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n+      }\n+#endif\n+\n+    num_threads = std::min((bin_index)num_threads, (bin_index)num_bins);\n+\n+    if (num_threads <= 1)\n+      return sequential_random_shuffle(begin, end, rng);\n+\n+    DRandomShufflingGlobalData<RandomAccessIterator> sd(begin);\n+\n+    DRSSorterPU<RandomAccessIterator, random_number >* pus = new DRSSorterPU<RandomAccessIterator, random_number >[num_threads];\n+\n+    sd.temporaries = new value_type*[num_threads];\n+    //sd.oracles = new bin_index[n];\n+    sd.dist = new difference_type*[num_bins + 1];\n+    sd.bin_proc = new thread_index_t[num_bins];\n+    for (bin_index b = 0; b < num_bins + 1; b++)\n+      sd.dist[b] = new difference_type[num_threads + 1];\n+    for (bin_index b = 0; b < (num_bins + 1); b++)\n+      {\n+\tsd.dist[0][0] = 0;\n+\tsd.dist[b][0] = 0;\n+      }\n+    difference_type* starts = sd.starts = new difference_type[num_threads + 1];\n+    int bin_cursor = 0;\n+    sd.num_bins = num_bins;\n+    sd.num_bits = log2(num_bins);\n+\n+    difference_type chunk_length = n / num_threads, split = n % num_threads, start = 0;\n+    int bin_chunk_length = num_bins / num_threads, bin_split = num_bins % num_threads;\n+    for (int i = 0; i < num_threads; i++)\n+      {\n+\tstarts[i] = start;\n+\tstart += (i < split) ? (chunk_length + 1) : chunk_length;\n+\tint j = pus[i].bins_begin = bin_cursor;\n+\n+\t// Range of bins for this processor.\n+\tbin_cursor += (i < bin_split) ? (bin_chunk_length + 1) : bin_chunk_length;\n+\tpus[i].bins_end = bin_cursor;\n+\tfor (; j < bin_cursor; j++)\n+\t  sd.bin_proc[j] = i;\n+\tpus[i].num_threads = num_threads;\n+\tpus[i].iam = i;\n+\tpus[i].seed = rng(std::numeric_limits<uint32>::max());\n+\tpus[i].sd = &sd;\n+      }\n+    starts[num_threads] = start;\n+\n+    // Now shuffle in parallel.\n+#pragma omp parallel num_threads(num_threads)\n+    parallel_random_shuffle_drs_pu(pus);\n+\n+    delete[] starts;\n+    delete[] sd.bin_proc;\n+    for (int s = 0; s < (num_bins + 1); s++)\n+      delete[] sd.dist[s];\n+    delete[] sd.dist;\n+    delete[] sd.temporaries;\n+\n+    delete[] pus;\n+  }\n+\n+  /** @brief Sequential cache-efficient random shuffle.\n+   *  @param begin Begin iterator of sequence.\n+   *  @param end End iterator of sequence.\n+   *  @param rng Random number generator to use.\n+   */\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  inline void\n+  sequential_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator& rng)\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type n = end - begin;\n+\n+    bin_index num_bins, num_bins_cache;\n+\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n+    // Try the L1 cache first, must fit into L1.\n+    num_bins_cache = std::max((difference_type)1, (difference_type)(n / (Settings::L1_cache_size_lb / sizeof(value_type))));\n+    num_bins_cache = round_up_to_pow2(num_bins_cache);\n+\n+    // No more buckets than TLB entries, power of 2\n+    // Power of 2 and at least one element per bin, at most the TLB size\n+    num_bins = std::min(n, (difference_type)num_bins_cache);\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n+    // 2 TLB entries needed per bin\n+    num_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+#endif\n+    num_bins = round_up_to_pow2(num_bins);\n+\n+    if (num_bins < num_bins_cache)\n+      {\n+#endif\n+\t// Now try the L2 cache, must fit into L2.\n+\tnum_bins_cache = static_cast<bin_index>(std::max((difference_type)1, (difference_type)(n / (Settings::L2_cache_size / sizeof(value_type)))));\n+\tnum_bins_cache = round_up_to_pow2(num_bins_cache);\n+\n+\t// No more buckets than TLB entries, power of 2\n+\t// Power of 2 and at least one element per bin, at most the TLB size.\n+\tnum_bins = static_cast<bin_index>(std::min(n, (difference_type)num_bins_cache));\n+\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n+\t// 2 TLB entries needed per bin\n+\tnum_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+#endif\n+\tnum_bins = round_up_to_pow2(num_bins);\n+#if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n+      }\n+#endif\n+\n+    int num_bits = log2(num_bins);\n+\n+    if (num_bins > 1)\n+      {\n+\tvalue_type* target = new value_type[n];\n+\tbin_index* oracles = new bin_index[n];\n+\tdifference_type* dist0 = new difference_type[num_bins + 1], * dist1 = new difference_type[num_bins + 1];\n+\n+\tfor (int b = 0; b < num_bins + 1; b++)\n+\t  dist0[b] = 0;\n+\n+\tTiming<sequential_tag> t;\n+\tt.tic();\n+\n+\trandom_number bitrng(rng(0xFFFFFFFF));\n+\n+\tfor (difference_type i = 0; i < n; i++)\n+\t  {\n+\t    bin_index oracle = random_number_pow2(num_bits, bitrng);\n+\t    oracles[i] = oracle;\n+\n+\t    // To allow prefix (partial) sum.\n+\t    dist0[oracle + 1]++;\n+\t  }\n+\n+\tt.tic();\n+\n+\t// Sum up bins.\n+\tpartial_sum(dist0, dist0 + num_bins + 1, dist0);\n+\n+\tfor (int b = 0; b < num_bins + 1; b++)\n+\t  dist1[b] = dist0[b];\n+\n+\tt.tic();\n+\n+\t// Distribute according to oracles.\n+\tfor (difference_type i = 0; i < n; i++)\n+\t  target[(dist0[oracles[i]])++] = *(begin + i);\n+\n+\tfor (int b = 0; b < num_bins; b++)\n+\t  {\n+\t    sequential_random_shuffle(target + dist1[b], target + dist1[b + 1],\n+\t\t\t\t      rng);\n+\t    t.tic();\n+\t  }\n+\tt.print();\n+\n+\tdelete[] dist0;\n+\tdelete[] dist1;\n+\tdelete[] oracles;\n+\tdelete[] target;\n+      }\n+    else\n+      __gnu_sequential::random_shuffle(begin, end, rng);\n+  }\n+\n+  /** @brief Parallel random public call.\n+   *  @param begin Begin iterator of sequence.\n+   *  @param end End iterator of sequence.\n+   *  @param rng Random number generator to use.\n+   */\n+  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  inline void\n+  parallel_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator rng = random_number())\n+  {\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    difference_type n = end - begin;\n+    parallel_random_shuffle_drs(begin, end, n, get_max_threads(), rng) ;\n+  }\n+\n+}\n+\n+#endif"}, {"sha": "754150ced9dbcb6b477aa4c8efe782485e64a907", "filename": "libstdc++-v3/include/parallel/search.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,157 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/search.h\n+ *  @brief Parallel implementation base for std::search() and\n+ *  std::search_n().\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_SEARCH_H\n+#define _GLIBCXX_PARALLEL_SEARCH_H 1\n+\n+#include <bits/stl_algobase.h>\n+\n+#include <parallel/parallel.h>\n+#include <parallel/equally_split.h>\n+\n+\n+namespace __gnu_parallel\n+{\n+  /**\n+   *  @brief Precalculate advances for Knuth-Morris-Pratt algorithm.\n+   *  @param elements Begin iterator of sequence to search for.\n+   *  @param length Length of sequence to search for.\n+   *  @param advances Returned offsets. \n+   */\n+  template<typename RandomAccessIterator, typename _DifferenceTp>\n+  void\n+  calc_borders(RandomAccessIterator elements, _DifferenceTp length, _DifferenceTp* off)\n+  {\n+    typedef _DifferenceTp difference_type;\n+\n+    off[0] = -1;\n+    if (length > 1)\n+      off[1] = 0;\n+    difference_type k = 0;\n+    for (difference_type j = 2; j <= length; j++)\n+      {\n+\twhile ((k >= 0) && (elements[k] != elements[j-1]))\n+\t  k = off[k];\n+\toff[j] = ++k;\n+      }\n+  }\n+\n+  // Generic parallel find algorithm (requires random access iterator).\n+\n+  /** @brief Parallel std::search.\n+   *  @param begin1 Begin iterator of first sequence.\n+   *  @param end1 End iterator of first sequence.\n+   *  @param begin2 Begin iterator of second sequence.\n+   *  @param end2 End iterator of second sequence.\n+   *  @param pred Find predicate.\n+   *  @return Place of finding in first sequences. */\n+  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename Pred>\n+  _RandomAccessIterator1\n+  search_template(_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1,\n+\t\t  _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2,\n+\t\t  Pred pred)\n+  {\n+    typedef std::iterator_traits<_RandomAccessIterator1> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    _GLIBCXX_CALL((end1 - begin1) + (end2 - begin2));\n+\n+    difference_type pattern_length = end2 - begin2;\n+\n+    // Pattern too short.\n+    if(pattern_length <= 0)\n+      return end1;\n+\n+    // Last point to start search.\n+    difference_type input_length = (end1 - begin1) - pattern_length;\n+\n+    // Where is first occurence of pattern? defaults to end.\n+    difference_type res = (end1 - begin1);\n+\n+    // Pattern too long.\n+    if (input_length < 0)\n+      return end1;\n+\n+    thread_index_t num_threads = std::max<difference_type>(1, std::min<difference_type>(input_length, __gnu_parallel::get_max_threads()));\n+\n+    difference_type borders[num_threads + 1];\n+    __gnu_parallel::equally_split(input_length, num_threads, borders);\n+\n+    difference_type advances[pattern_length];\n+    calc_borders(begin2, pattern_length, advances);\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+      thread_index_t iam = omp_get_thread_num();\n+\n+      difference_type start = borders[iam], stop = borders[iam + 1];\n+\n+      difference_type pos_in_pattern = 0;\n+      bool found_pattern = false;\n+\n+      while (start <= stop && !found_pattern)\n+\t{\n+\t  // Get new value of res.\n+#pragma omp flush(res)\n+\t  // No chance for this thread to find first occurence.\n+\t  if (res < start)\n+\t    break;\n+\t  while (pred(begin1[start + pos_in_pattern], begin2[pos_in_pattern]))\n+\t    {\n+\t      ++pos_in_pattern;\n+\t      if (pos_in_pattern == pattern_length)\n+\t\t{\n+\t\t  // Found new candidate for res.\n+#pragma omp critical (res)\n+\t\t  res = std::min(res, start);\n+\t\t  found_pattern = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  // Make safe jump.\n+\t  start += (pos_in_pattern - advances[pos_in_pattern]);\n+\t  pos_in_pattern = (advances[pos_in_pattern] < 0) ? 0 : advances[pos_in_pattern];\n+\t}\n+    }\n+\n+    // Return iterator on found element.\n+    return (begin1 + res);\n+  }\n+} // end namespace\n+\n+#endif"}, {"sha": "006176de46f8ca2ffbf01bcedc9d8b1f02fcaea6", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,529 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/**\n+ * @file parallel/set_operations.h\n+ * @brief Parallel implementations of set operations for random-access\n+ * iterators.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Marius Elvert and Felix Bondarenko.\n+\n+#ifndef _GLIBCXX_PARALLEL_SET_OPERATIONS_H\n+#define _GLIBCXX_PARALLEL_SET_OPERATIONS_H 1\n+\n+#include <omp.h>\n+\n+#include <parallel/settings.h>\n+#include <parallel/multiseq_selection.h>\n+\n+namespace __gnu_parallel\n+{\n+  template<typename InputIterator, typename OutputIterator>\n+  inline OutputIterator\n+  copy_tail(std::pair<InputIterator, InputIterator> b,\n+\t    std::pair<InputIterator, InputIterator> e, OutputIterator r)\n+  {\n+    if (b.first != e.first)\n+      {\n+\tdo\n+\t  {\n+\t    *r++ = *b.first++;\n+\t  }\n+\twhile (b.first != e.first);\n+      }\n+    else\n+      {\n+\twhile (b.second != e.second)\n+\t  *r++ = *b.second++;\n+      }\n+    return r;\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  struct symmetric_difference_func\n+  {\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+\n+    symmetric_difference_func(Comparator c) : comp(c) {}\n+\n+    Comparator comp;\n+\n+    inline OutputIterator invoke(InputIterator a, InputIterator b,\n+\t\t\t\t InputIterator c, InputIterator d,\n+\t\t\t\t OutputIterator r) const\n+    {\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    {\n+\t      *r = *a;\n+\t      ++a;\n+\t      ++r;\n+\t    }\n+\t  else if (comp(*c, *a))\n+\t    {\n+\t      *r = *c;\n+\t      ++c;\n+\t      ++r;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++a;\n+\t      ++c;\n+\t    }\n+\t}\n+      return std::copy(c, d, std::copy(a, b, r));\n+    }\n+\n+    inline difference_type\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    {\n+      difference_type counter = 0;\n+\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    {\n+\t      ++a;\n+\t      ++counter;\n+\t    }\n+\t  else if (comp(*c, *a))\n+\t    {\n+\t      ++c;\n+\t      ++counter;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++a;\n+\t      ++c;\n+\t    }\n+\t}\n+\n+      return counter + (b - a) + (d - c);\n+    }\n+\n+    inline OutputIterator\n+    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n+    { return std::copy(c, d, out); }\n+\n+    inline OutputIterator\n+    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n+    { return std::copy(a, b, out); }\n+\n+  };\n+\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  struct difference_func\n+  {\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+\n+    difference_func(Comparator c) : comp(c) {}\n+\n+    Comparator comp;\n+\n+    inline OutputIterator\n+    invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n+\t   OutputIterator r) const\n+    {\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    {\n+\t      *r = *a;\n+\t      ++a;\n+\t      ++r;\n+\t    }\n+\t  else if (comp(*c, *a))\n+\t    { ++c; }\n+\t  else\n+\t    {\n+\t      ++a;\n+\t      ++c;\n+\t    }\n+\t}\n+      return std::copy(a, b, r);\n+    }\n+\n+    inline difference_type\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    {\n+      difference_type counter = 0;\n+\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    {\n+\t      ++a;\n+\t      ++counter;\n+\t    }\n+\t  else if (comp(*c, *a))\n+\t    { ++c; }\n+\t  else\n+\t    { ++a; ++c; }\n+\t}\n+\n+      return counter + (b - a);\n+    }\n+\n+    inline OutputIterator\n+    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n+    { return out; }\n+\n+    inline OutputIterator\n+    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n+    { return std::copy(a, b, out); }\n+  };\n+\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  struct intersection_func\n+  {\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+\n+    intersection_func(Comparator c) : comp(c) {}\n+\n+    Comparator comp;\n+\n+    inline OutputIterator\n+    invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n+\t   OutputIterator r) const\n+    {\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    { ++a; }\n+\t  else if (comp(*c, *a))\n+\t    { ++c; }\n+\t  else\n+\t    {\n+\t      *r = *a;\n+\t      ++a;\n+\t      ++c;\n+\t      ++r;\n+\t    }\n+\t}\n+\n+      return r;\n+    }\n+\n+    inline difference_type\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    {\n+      difference_type counter = 0;\n+\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    { ++a; }\n+\t  else if (comp(*c, *a))\n+\t    { ++c; }\n+\t  else\n+\t    {\n+\t      ++a;\n+\t      ++c;\n+\t      ++counter;\n+\t    }\n+\t}\n+\n+      return counter;\n+    }\n+\n+    inline OutputIterator\n+    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n+    { return out; }\n+\n+    inline OutputIterator\n+    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n+    { return out; }\n+  };\n+\n+  template<class InputIterator, class OutputIterator, class Comparator>\n+  struct union_func\n+  {\n+    typedef typename std::iterator_traits<InputIterator>::difference_type difference_type;\n+\n+    union_func(Comparator c) : comp(c) {}\n+\n+    Comparator comp;\n+\n+    inline OutputIterator\n+    invoke(InputIterator a, const InputIterator b, InputIterator c,\n+\t   const InputIterator d, OutputIterator r) const\n+    {\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    {\n+\t      *r = *a;\n+\t      ++a;\n+\t    }\n+\t  else if (comp(*c, *a))\n+\t    {\n+\t      *r = *c;\n+\t      ++c;\n+\t    }\n+\t  else\n+\t    {\n+\t      *r = *a;\n+\t      ++a;\n+\t      ++c;\n+\t    }\n+\t  ++r;\n+\t}\n+      return std::copy(c, d, std::copy(a, b, r));\n+    }\n+\n+    inline difference_type\n+    count(InputIterator a, const InputIterator b, InputIterator c,\n+\t  const InputIterator d) const\n+    {\n+      difference_type counter = 0;\n+\n+      while (a != b && c != d)\n+\t{\n+\t  if (comp(*a, *c))\n+\t    { ++a; }\n+\t  else if (comp(*c, *a))\n+\t    { ++c; }\n+\t  else\n+\t    {\n+\t      ++a;\n+\t      ++c;\n+\t    }\n+\t  ++counter;\n+\t}\n+\n+      counter += (b - a);\n+      counter += (d - c);\n+      return counter;\n+    }\n+\n+    inline OutputIterator\n+    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n+    { return std::copy(c, d, out); }\n+\n+    inline OutputIterator\n+    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n+    { return std::copy(a, b, out); }\n+  };\n+\n+  template<typename InputIterator, typename OutputIterator, typename Operation>\n+  OutputIterator\n+  parallel_set_operation(InputIterator begin1, InputIterator end1,\n+\t\t\t InputIterator begin2, InputIterator end2,\n+\t\t\t OutputIterator result, Operation op)\n+  {\n+    _GLIBCXX_CALL((end1 - begin1) + (end2 - begin2))\n+\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+\n+\n+    if (begin1 == end1)\n+      return op.first_empty(begin2, end2, result);\n+\n+    if (begin2 == end2)\n+      return op.second_empty(begin1, end1, result);\n+\n+    const difference_type size = (end1 - begin1) + (end2 - begin2);\n+\n+    thread_index_t num_threads = std::min<difference_type>(std::min(end1 - begin1, end2 - begin2), get_max_threads());\n+\n+    difference_type borders[num_threads + 2];\n+    equally_split(size, num_threads + 1, borders);\n+\n+    const iterator_pair sequence[ 2 ] = { std::make_pair(begin1, end1), std::make_pair(begin2, end2) } ;\n+\n+    iterator_pair block_begins[num_threads + 1];\n+\n+    // Very start.\n+    block_begins[0] = std::make_pair(begin1, begin2);\n+    difference_type length[num_threads];\n+\n+    OutputIterator return_value = result;\n+\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+      Timing<sequential_tag> t;\n+\n+      t.tic();\n+\n+      // Result from multiseq_partition.\n+      InputIterator offset[2];\n+      const int iam = omp_get_thread_num();\n+\n+      const difference_type rank = borders[iam + 1];\n+\n+      multiseq_partition(sequence, sequence + 2, rank, offset, op.comp);\n+\n+      // allowed to read?\n+      // together\n+      // *(offset[ 0 ] - 1) == *offset[ 1 ]\n+      if (offset[ 0 ] != begin1 && offset[ 1 ] != end2\n+\t   && !op.comp(*(offset[ 0 ] - 1), *offset[ 1 ])\n+\t   && !op.comp(*offset[ 1 ], *(offset[ 0 ] - 1)))\n+\t{\n+\t  // Avoid split between globally equal elements: move one to\n+\t  // front in first sequence.\n+\t  --offset[ 0 ];\n+\t}\n+\n+      iterator_pair block_end = block_begins[ iam + 1 ] = iterator_pair(offset[ 0 ], offset[ 1 ]);\n+\n+      t.tic();\n+\n+      // Make sure all threads have their block_begin result written out.\n+#pragma omp barrier\n+\n+      t.tic();\n+\n+      iterator_pair block_begin = block_begins[ iam ];\n+\n+      // Begin working for the first block, while the others except\n+      // the last start to count.\n+      if (iam == 0)\n+\t{\n+\t  // The first thread can copy already.\n+\t  length[ iam ] = op.invoke(block_begin.first, block_end.first, block_begin.second, block_end.second, result) - result;\n+\t}\n+      else\n+\t{\n+\t  length[ iam ] = op.count(block_begin.first, block_end.first,\n+\t\t\t\t   block_begin.second, block_end.second);\n+\t}\n+\n+      t.tic();\n+\n+      // Make sure everyone wrote their lengths.\n+#pragma omp barrier\n+\n+      t.tic();\n+      OutputIterator r = result;\n+\n+      if (iam == 0)\n+\t{\n+\t  // Do the last block.\n+\t  for (int i = 0; i < num_threads; ++i)\n+\t    r += length[i];\n+\n+\t  block_begin = block_begins[num_threads];\n+\n+\t  // Return the result iterator of the last block.\n+\t  return_value = op.invoke(block_begin.first, end1, block_begin.second, end2, r);\n+\n+\t}\n+      else\n+\t{\n+\t  for (int i = 0; i < iam; ++i)\n+\t    r += length[ i ];\n+\n+\t  // Reset begins for copy pass.\n+\t  op.invoke(block_begin.first, block_end.first,\n+\t\t    block_begin.second, block_end.second, r);\n+\t}\n+\n+      t.tic();\n+      t.print();\n+    }\n+    return return_value;\n+  }\n+\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  OutputIterator\n+  parallel_set_union(InputIterator begin1, InputIterator end1,\n+\t\t     InputIterator begin2, InputIterator end2,\n+\t\t     OutputIterator result, Comparator comp)\n+  {\n+    return parallel_set_operation(begin1, end1, begin2, end2, result,\n+\t\t\t\t  union_func< InputIterator, OutputIterator, Comparator>(comp));\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  OutputIterator\n+  parallel_set_intersection(InputIterator begin1, InputIterator end1,\n+\t\t\t    InputIterator begin2, InputIterator end2,\n+\t\t\t    OutputIterator result, Comparator comp)\n+  {\n+    return parallel_set_operation(begin1, end1, begin2, end2, result,\n+\t\t\t\t  intersection_func<InputIterator, OutputIterator, Comparator>(comp));\n+  }\n+\n+\n+  template<typename InputIterator, typename OutputIterator>\n+  OutputIterator\n+  set_intersection(InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result)\n+  {\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+\n+    return set_intersection(begin1, end1, begin2, end2, result,\n+\t\t\t    std::less<value_type>());\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  OutputIterator\n+  parallel_set_difference(InputIterator begin1, InputIterator end1,\n+\t\t\t  InputIterator begin2, InputIterator end2,\n+\t\t\t  OutputIterator result, Comparator comp)\n+  {\n+    return parallel_set_operation(begin1, end1, begin2, end2, result,\n+\t\t\t\t  difference_func<InputIterator, OutputIterator, Comparator>(comp));\n+  }\n+\n+  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+  OutputIterator\n+  parallel_set_symmetric_difference(InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)\n+  {\n+    return parallel_set_operation(begin1, end1, begin2, end2, result,\n+\t\t\t\t  symmetric_difference_func<InputIterator, OutputIterator, Comparator>(comp));\n+  }\n+\n+}\n+\n+#endif // _GLIBCXX_SET_ALGORITHM_\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "cec9d8225c99da2ab0d057f74a439515d84c0ebf", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,388 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/settings.h\n+ *  @brief Settings and tuning parameters, heuristics to decide\n+ *  whether to use parallelized algorithms.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ *\n+ *  @section parallelization_decision  The decision whether to run an algorithm in parallel.\n+ *\n+ *  There are several ways the user can switch on and off the \n+ *  parallel execution of an algorithm, both at compile- and \n+ *  run-time.\n+ *\n+ *  Only sequential execution can be forced at compile-time.\n+ *  This reduces code size and protects code parts that have \n+ *  non-thread-safe side effects.\n+ *\n+ *  Ultimately forcing parallel execution at compile-time does \n+ *  make much sense.\n+ *  Often, the sequential algorithm implementation is used as\n+ *  a subroutine, so no reduction in code size can be achieved.\n+ *  Also, the machine the program is run on might have only one\n+ *  processor core, so to avoid overhead, the algorithm is\n+ *  executed sequentially.\n+ *\n+ *  To force sequential execution of an algorithm ultimately\n+ *  at compile-time, the user must add the tag \n+ *  __gnu_parallel::sequential_tag() to the end of the\n+ *  parameter list, e. g.\n+ *\n+ *  \\code\n+ *  std::sort(v.begin(), v.end(), __gnu_parallel::sequential_tag());\n+ *  \\endcode\n+ *\n+ *  This is compatible with all overloaded algorithm variants.\n+ *  No additional code will be instantiated, at all.\n+ *  The same holds for most algorithm calls with iterators \n+ *  not providing random access.\n+ *\n+ *  If the algorithm call is not forced to be executed sequentially\n+ *  at compile-time, the decision is made at run-time, for each call.\n+ *  First, the two (conceptually) global variables \n+ *  __gnu_parallel::Settings::force_sequential and \n+ *  __gnu_parallel::Settings::force_parallel are executed.\n+ *  If the former one is true, the sequential algorithm is executed.\n+ *  If the latter one is true and the former one is false, \n+ *  the algorithm is executed in parallel.\n+ *\n+ *  If none of these conditions has fired so far, a heuristic is used.\n+ *  The parallel algorithm implementation is called only if the\n+ *  input size is sufficiently large.\n+ *  For most algorithms, the input size is the (combined) length of \n+ *  the input sequence(s).\n+ *  The threshold can be set by the user, individually for each\n+ *  algorithm.\n+ *  The according variables are called \n+ *  __gnu_parallel::Settings::[algorithm]_minimal_n .\n+ *\n+ *  For some of the algorithms, there are even more tuning options,\n+ *  e. g. the ability to choose from multiple algorithm variants.\n+ *  See the __gnu_parallel::Settings class for details.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_SETTINGS_H\n+#define _GLIBCXX_PARALLEL_SETTINGS_H 1\n+\n+#include <omp.h>\n+#include <parallel/types.h>\n+\n+/** \n+  * @brief The extensible condition on whether the parallel variant of\n+  * an algorithm sould be called.\n+  * @param c A condition that is overruled by\n+  * __gnu_parallel::Settings::force_parallel, i. e. usually a decision based on\n+  * the input size.\n+  */\n+#define _GLIBCXX_PARALLEL_CONDITION(c) (!(__gnu_parallel::Settings::force_sequential) && ((__gnu_parallel::get_max_threads() > 1 && (c)) || __gnu_parallel::Settings::force_parallel))\n+\n+namespace __gnu_parallel\n+{\n+  // NB: Including this file cannot produce (unresolved) symbols from\n+  // the OpenMP runtime unless the parallel mode is actually invoked\n+  // and active, which imples that the OpenMP runtime is actually\n+  // going to be linked in.\n+  inline int\n+  get_max_threads() \n+  { return omp_get_max_threads() > 1 ? omp_get_max_threads() : 1; }\n+\n+namespace \n+{\n+  // XXX look at _Tune in mt_allocator.h\n+  /** @brief Run-time settings for the parallel mode. */\n+  struct Settings\n+  {\n+    /** @brief Different parallel sorting algorithms to choose\n+\tfrom: multi-way mergesort, quicksort, load-balanced\n+\tquicksort. */\n+    enum SortAlgorithm \n+    { MWMS, QS, QS_BALANCED };\n+\n+    /** @brief Different merging algorithms: bubblesort-alike,\n+\tloser-tree variants, enum sentinel */\n+    enum MultiwayMergeAlgorithm\n+    { BUBBLE, LOSER_TREE_EXPLICIT, LOSER_TREE, LOSER_TREE_COMBINED, LOSER_TREE_SENTINEL, MWM_ALGORITHM_LAST };\n+\n+    /** @brief Different splitting strategies for sorting/merging:\n+\tby sampling, exact */\n+    enum Splitting \n+    { SAMPLING, EXACT };\n+\n+    /** @brief Different partial sum algorithms: recursive, linear */\n+    enum PartialSumAlgorithm \n+    { RECURSIVE, LINEAR };\n+\n+    /** @brief Different find distribution strategies: growing\n+\tblocks, equal-sized blocks, equal splitting. */\n+    enum FindDistribution \n+    { GROWING_BLOCKS, CONSTANT_SIZE_BLOCKS, EQUAL_SPLIT };\n+\n+    /** @brief Force all algorithms to be executed sequentially.\n+     * This setting cannot be overwritten. */\n+    static volatile bool force_sequential;\n+\n+    /** @brief Force all algorithms to be executed in parallel.\n+     * This setting can be overriden by __gnu_parallel::sequential_tag\n+     * (compile-time), and force_sequential (run-time). */\n+    static volatile bool force_parallel;\n+\n+    /** @brief Algorithm to use for sorting. */\n+    static volatile SortAlgorithm sort_algorithm;\n+\n+    /** @brief Strategy to use for splitting the input when\n+\tsorting (MWMS). */\n+    static volatile Splitting sort_splitting;\n+\n+    /** @brief Minimal input size for parallel sorting. */\n+    static volatile sequence_index_t sort_minimal_n;\n+    /** @brief Oversampling factor for parallel std::sort (MWMS). */\n+    static volatile unsigned int sort_mwms_oversampling;\n+    /** @brief Such many samples to take to find a good pivot\n+\t(quicksort). */\n+    static volatile unsigned int sort_qs_num_samples_preset;\n+\n+    /** @brief Maximal subsequence length to swtich to unbalanced\n+     * base case.  Applies to std::sort with dynamically\n+     * load-balanced quicksort. */\n+    static volatile sequence_index_t sort_qsb_base_case_maximal_n;\n+\n+    /** @brief Minimal input size for parallel std::partition. */\n+    static volatile sequence_index_t partition_minimal_n;\n+\n+    /** @brief Chunk size for parallel std::partition. */\n+    static volatile sequence_index_t partition_chunk_size;\n+\n+    /** @brief Chunk size for parallel std::partition, relative to\n+     * input size.  If >0.0, this value overrides\n+     * partition_chunk_size. */\n+    static volatile double partition_chunk_share;\n+\n+    /** @brief Minimal input size for parallel std::nth_element. */\n+    static volatile sequence_index_t nth_element_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::partial_sort. */\n+    static volatile sequence_index_t partial_sort_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::adjacent_difference. */\n+    static volatile unsigned int adjacent_difference_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::partial_sum. */\n+    static volatile unsigned int partial_sum_minimal_n;\n+\n+    /** @brief Algorithm to use for std::partial_sum. */\n+    static volatile PartialSumAlgorithm partial_sum_algorithm;\n+\n+    /** @brief Assume \"sum and write result\" to be that factor\n+     *  slower than just \"sum\".  This value is used for\n+     *  std::partial_sum. */\n+    static volatile float partial_sum_dilatation;\n+\n+    /** @brief Minimal input size for parallel std::random_shuffle. */\n+    static volatile unsigned int random_shuffle_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::merge. */\n+    static volatile sequence_index_t merge_minimal_n;\n+\n+    /** @brief Splitting strategy for parallel std::merge. */\n+    static volatile Splitting merge_splitting;\n+\n+    /** @brief Oversampling factor for parallel std::merge.\n+     * Such many samples per thread are collected. */\n+    static volatile unsigned int merge_oversampling;\n+\n+    /** @brief Algorithm to use for parallel\n+\t__gnu_parallel::multiway_merge. */\n+    static volatile MultiwayMergeAlgorithm multiway_merge_algorithm;\n+\n+    /** @brief Splitting strategy to use for parallel\n+\t__gnu_parallel::multiway_merge. */\n+    static volatile Splitting multiway_merge_splitting;\n+\n+    //// Oversampling factor for parallel __gnu_parallel::multiway_merge.\n+    static volatile unsigned int multiway_merge_oversampling;\n+\n+    /// Minimal input size for parallel __gnu_parallel::multiway_merge.\n+    static volatile sequence_index_t multiway_merge_minimal_n;\n+\n+    /// Oversampling factor for parallel __gnu_parallel::multiway_merge.\n+    static volatile int multiway_merge_minimal_k;\n+\n+    /** @brief Minimal input size for parallel std::unique_copy. */\n+    static volatile sequence_index_t unique_copy_minimal_n;\n+\n+    static volatile sequence_index_t workstealing_chunk_size;\n+\n+    /** @brief Minimal input size for parallel std::for_each. */\n+    static volatile sequence_index_t for_each_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::count and\n+\tstd::count_if. */\n+    static volatile sequence_index_t count_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::transform. */\n+    static volatile sequence_index_t transform_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::replace and\n+\tstd::replace_if. */\n+    static volatile sequence_index_t replace_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::generate. */\n+    static volatile sequence_index_t generate_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::fill. */\n+    static volatile sequence_index_t fill_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::min_element. */\n+    static volatile sequence_index_t min_element_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::max_element. */\n+    static volatile sequence_index_t max_element_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::accumulate. */\n+    static volatile sequence_index_t accumulate_minimal_n;\n+\n+    /** @brief Distribution strategy for parallel std::find. */\n+    static volatile FindDistribution find_distribution;\n+\n+    /** @brief Start with looking for that many elements\n+\tsequentially, for std::find. */\n+    static volatile sequence_index_t find_sequential_search_size;\n+\n+    /** @brief Initial block size for parallel std::find. */\n+    static volatile sequence_index_t find_initial_block_size;\n+\n+    /** @brief Maximal block size for parallel std::find. */\n+    static volatile sequence_index_t find_maximum_block_size;\n+\n+    /** @brief Block size increase factor for parallel std::find. */\n+    static volatile double find_increasing_factor;\n+\n+    //set operations\n+    /** @brief Minimal input size for parallel std::set_union. */\n+    static volatile sequence_index_t set_union_minimal_n;\n+\n+    /** @brief Minimal input size for parallel\n+\tstd::set_symmetric_difference. */\n+    static volatile sequence_index_t set_symmetric_difference_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::set_difference. */\n+    static volatile sequence_index_t set_difference_minimal_n;\n+\n+    /** @brief Minimal input size for parallel std::set_intersection. */\n+    static volatile sequence_index_t set_intersection_minimal_n;\n+\n+    //hardware dependent tuning parameters\n+    /** @brief Size of the L1 cache in bytes (underestimation). */\n+    static volatile unsigned long long L1_cache_size;\n+\n+    /** @brief Size of the L2 cache in bytes (underestimation). */\n+    static volatile unsigned long long L2_cache_size;\n+\n+    /** @brief Size of the Translation Lookaside Buffer\n+\t(underestimation). */\n+    static volatile unsigned int TLB_size;\n+\n+    /** @brief Overestimation of cache line size.  Used to avoid\n+     * false sharing, i. e. elements of different threads are at\n+     * least this amount apart. */\n+    static unsigned int cache_line_size;\n+\n+    //statistics\n+    /** @brief Statistic on the number of stolen ranges in\n+\tload-balanced quicksort.*/\n+    static volatile sequence_index_t qsb_steals;\n+  };\n+\n+  volatile bool Settings::force_parallel = false;\n+  volatile bool Settings::force_sequential = false;\n+  volatile  Settings::SortAlgorithm Settings::sort_algorithm = Settings::MWMS;\n+  volatile  Settings::Splitting Settings::sort_splitting = Settings::EXACT;\n+  volatile sequence_index_t Settings::sort_minimal_n = 1000;\n+\n+  volatile unsigned int Settings::sort_mwms_oversampling = 10;\n+  volatile unsigned int Settings::sort_qs_num_samples_preset = 100;\n+  volatile sequence_index_t Settings::sort_qsb_base_case_maximal_n = 100;\n+  volatile sequence_index_t Settings::partition_minimal_n = 1000;\n+  volatile sequence_index_t Settings::nth_element_minimal_n = 1000;\n+  volatile sequence_index_t Settings::partial_sort_minimal_n = 1000;\n+  volatile sequence_index_t Settings::partition_chunk_size = 1000;\n+  volatile double Settings::partition_chunk_share = 0.0;\n+  volatile unsigned int Settings::adjacent_difference_minimal_n = 1000;\n+  volatile  Settings::PartialSumAlgorithm Settings::partial_sum_algorithm = Settings::LINEAR;\n+  volatile unsigned int Settings::partial_sum_minimal_n = 1000;\n+  volatile float Settings::partial_sum_dilatation = 1.0f;\n+  volatile unsigned int Settings::random_shuffle_minimal_n = 1000;\n+  volatile  Settings::Splitting Settings::merge_splitting = Settings::EXACT;\n+  volatile sequence_index_t Settings::merge_minimal_n = 1000;\n+  volatile unsigned int Settings::merge_oversampling = 10;\n+  volatile sequence_index_t Settings::multiway_merge_minimal_n = 1000;\n+  volatile int Settings::multiway_merge_minimal_k = 2;\n+\n+  // unique copy\n+  volatile sequence_index_t Settings::unique_copy_minimal_n = 10000;\n+  volatile  Settings::MultiwayMergeAlgorithm Settings::multiway_merge_algorithm = Settings::LOSER_TREE;\n+  volatile  Settings::Splitting Settings::multiway_merge_splitting = Settings::EXACT;\n+  volatile unsigned int Settings::multiway_merge_oversampling = 10;\n+  volatile  Settings::FindDistribution Settings::find_distribution = Settings::CONSTANT_SIZE_BLOCKS;\n+  volatile sequence_index_t Settings::find_sequential_search_size = 256;\n+  volatile sequence_index_t Settings::find_initial_block_size = 256;\n+  volatile sequence_index_t Settings::find_maximum_block_size = 8192;\n+  volatile double Settings::find_increasing_factor = 2.0;\n+  volatile sequence_index_t Settings::workstealing_chunk_size = 100;\n+  volatile sequence_index_t Settings::for_each_minimal_n = 1000;\n+  volatile sequence_index_t Settings::count_minimal_n = 1000;\n+  volatile sequence_index_t Settings::transform_minimal_n = 1000;\n+  volatile sequence_index_t Settings::replace_minimal_n = 1000;\n+  volatile sequence_index_t Settings::generate_minimal_n = 1000;\n+  volatile sequence_index_t Settings::fill_minimal_n = 1000;\n+  volatile sequence_index_t Settings::min_element_minimal_n = 1000;\n+  volatile sequence_index_t Settings::max_element_minimal_n = 1000;\n+  volatile sequence_index_t Settings::accumulate_minimal_n = 1000;\n+\n+  //set operations\n+  volatile sequence_index_t Settings::set_union_minimal_n = 1000;\n+  volatile sequence_index_t Settings::set_intersection_minimal_n = 1000;\n+  volatile sequence_index_t Settings::set_difference_minimal_n = 1000;\n+  volatile sequence_index_t Settings::set_symmetric_difference_minimal_n = 1000;\n+  volatile unsigned long long Settings::L1_cache_size = 16 << 10;\n+  volatile unsigned long long Settings::L2_cache_size = 256 << 10;\n+  volatile unsigned int Settings::TLB_size = 128;\n+  unsigned int Settings::cache_line_size = 64;\n+\n+  //statistics\n+  volatile sequence_index_t Settings::qsb_steals = 0;\n+} // end anonymous namespace\n+\n+}\n+\n+#endif /* _GLIBCXX_SETTINGS_H */"}, {"sha": "6b20edd9fabf02f505f43499774521d6c2aab19d", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,104 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/sort.h\n+ *  @brief Parallel sorting algorithm switch.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_SORT_H\n+#define _GLIBCXX_PARALLEL_SORT_H 1\n+\n+#include <parallel/basic_iterator.h>\n+#include <parallel/features.h>\n+#include <parallel/parallel.h>\n+\n+#if _GLIBCXX_ASSERTIONS\n+#include <parallel/checkers.h>\n+#endif\n+\n+#if _GLIBCXX_MERGESORT\n+#include <parallel/multiway_mergesort.h>\n+#endif\n+\n+#if _GLIBCXX_QUICKSORT\n+#include <parallel/quicksort.h>\n+#endif\n+\n+#if _GLIBCXX_BAL_QUICKSORT\n+#include <parallel/balanced_quicksort.h>\n+#endif\n+\n+namespace __gnu_parallel\n+{\n+  /** \n+   *  @brief Choose a parallel sorting algorithm.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @param stable Sort stable.\n+   *  @callgraph \n+   */\n+  template<typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\tComparator comp, bool stable)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    if (begin != end)\n+      {\n+\tdifference_type n = end - begin;\n+\n+\tif (false) ;\n+#if _GLIBCXX_MERGESORT\n+\telse if (Settings::sort_algorithm == Settings::MWMS || stable)\n+\t  parallel_sort_mwms(begin, end, comp, n, get_max_threads(), stable);\n+#endif\n+#if _GLIBCXX_QUICKSORT\n+\telse if (Settings::sort_algorithm == Settings::QS && !stable)\n+\t  parallel_sort_qs(begin, end, comp, n, get_max_threads());\n+#endif\n+#if _GLIBCXX_BAL_QUICKSORT\n+\telse if (Settings::sort_algorithm == Settings::QS_BALANCED && !stable)\n+\t  parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n+#endif\n+\telse\n+\t  __gnu_sequential::sort(begin, end, comp);\n+      }\n+  }\n+} // end namespace __gnu_parallel\n+\n+#endif"}, {"sha": "80926b44384aa092b54db235c77bafb2d495f927", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,124 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/**\n+ * @file parallel/tags.h\n+ * @brief Tags for compile-time options.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_TAGS_H\n+#define _GLIBCXX_PARALLEL_TAGS_H 1\n+\n+// Parallel mode namespaces.\n+namespace std \n+{ \n+  namespace __parallel { } \n+}\n+\n+/**\n+ * @namespace __gnu_sequential\n+ * @brief GNU sequential classes for public use.\n+ */\n+namespace __gnu_sequential { }\n+\n+/**\n+ * @namespace __gnu_parallel\n+ * @brief GNU parallel classes for public use.\n+ */\n+namespace __gnu_parallel\n+{\n+  // Import all the parallel versions of components in namespace std.\n+  using namespace std::__parallel;\n+\n+  enum parallelism\n+    {\n+      /// Not parallel.\n+      sequential,\n+\n+      /// Parallel unbalanced (equal-sized chunks).\n+      parallel_unbalanced,\n+\n+      /// Parallel balanced (work-stealing).\n+      parallel_balanced,\n+\n+      /// Parallel with OpenMP dynamic load-balancing.\n+      parallel_omp_loop,\n+\n+      /// Parallel with OpenMP static load-balancing.\n+      parallel_omp_loop_static,\n+\n+      /// Parallel with OpenMP taskqueue construct.\n+      parallel_taskqueue\n+    };\n+\n+  inline bool \n+  is_parallel(const parallelism __p) { return __p != sequential; }\n+\n+\n+  /** @brief Forces sequential execution at compile time. */\n+  struct sequential_tag { };\n+\n+  /** @brief Recommends parallel execution at compile time. */\n+  struct parallel_tag { };\n+\n+  /** @brief Recommends parallel execution using dynamic\n+      load-balancing at compile time. */\n+  struct balanced_tag : public parallel_tag { };\n+\n+  /** @brief Recommends parallel execution using static\n+      load-balancing at compile time. */\n+  struct unbalanced_tag : public parallel_tag { };\n+\n+  /** @brief Recommends parallel execution using OpenMP dynamic\n+      load-balancing at compile time. */\n+  struct omp_loop_tag : public parallel_tag { };\n+\n+  /** @brief Recommends parallel execution using OpenMP static\n+      load-balancing at compile time. */\n+  struct omp_loop_static_tag : public parallel_tag { };\n+\n+\n+  /** @brief Selects the growing block size variant for std::find().\n+      @see _GLIBCXX_FIND_GROWING_BLOCKS */\n+  struct growing_blocks_tag { };\n+\n+  /** @brief Selects the constant block size variant for std::find().\n+      @see _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS */\n+  struct constant_size_blocks_tag { };\n+\n+  /** @brief Selects the equal splitting variant for std::find().\n+      @see _GLIBCXX_FIND_EQUAL_SPLIT */\n+  struct equal_split_tag { };\n+}\n+\n+#endif /* _GLIBCXX_TAGS_H */"}, {"sha": "f1f75225c156eab16c581fe5a35e61bcf9cb4d12", "filename": "libstdc++-v3/include/parallel/timing.h", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftiming.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,217 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/timing.h\n+ *  @brief Provides a simple tool to do performance debugging, also in\n+ *  parallel code.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler.\n+\n+#ifndef _GLIBCXX_PARALLEL_TIMING_H\n+#define _GLIBCXX_PARALLEL_TIMING_H 1\n+\n+#include <omp.h>\n+#include <cstdio>\n+#include <cstring>\n+#include <parallel/tags.h>\n+\n+namespace __gnu_parallel\n+{\n+  // XXX integrate with existing performance testing infrastructure.\n+  /** @brief Type of of point in time, used for the Timing classes. */\n+  typedef double point_in_time;\n+\n+  template<typename tag, typename must_be_int = int>\n+  class Timing;\n+\n+  /** @brief A class that provides simple run time measurements, also\n+      for parallel code.\n+   *  @param tag If parallel_tag, then the measurements are actually done.\n+   *  Otherwise, no code at all is emitted by the compiler. */\n+  template<typename must_be_int>\n+  class Timing<parallel_tag, must_be_int>\n+  {\n+  private:\n+    static const int max_points_in_time = 100;\n+    point_in_time points_in_time[max_points_in_time];\n+    point_in_time active, last_start;\n+    int pos;\n+    char* str;\n+    const char* tags[max_points_in_time];\n+\n+  public:\n+    Timing()\n+    {\n+      str = NULL;\n+      pos = 0;\n+      active = 0.0;\n+      last_start = -1.0;\n+    }\n+\n+    ~Timing()\n+    {\n+      delete[] str;\n+    }\n+\n+    /** @brief Take a running time measurement.\n+     *  @param tag Optional description that will be output again with\n+     *  the timings.\n+     *  It should describe the operation before the tic(). To time a\n+     *  series of @c n operations, there should be @c n+1 calls to\n+     *  tic(), and one call to print(). */\n+    inline void\n+    tic(const char* tag = NULL)\n+    {\n+      points_in_time[pos] = omp_get_wtime();\n+      tags[pos] = tag;\n+      pos++;\n+    }\n+\n+    /** @brief Start the running time measurement.\n+     *\n+     *  Should be paired with stop(). */\n+    inline void\n+    start()\n+    {\n+      _GLIBCXX_PARALLEL_ASSERT(last_start == -1.0);\n+      last_start = omp_get_wtime();\n+    }\n+\n+    /** @brief Stop the running time measurement.\n+     *\n+     *  Should be paired with start(). */\n+    inline void\n+    stop()\n+    {\n+      _GLIBCXX_PARALLEL_ASSERT(last_start != -1.0);\n+      active += (omp_get_wtime() - last_start);\n+      last_start = -1.0;\n+    }\n+\n+    /** @brief Reset running time accumulation. */\n+    inline void\n+    reset()\n+    {\n+      active = 0.0;\n+      last_start = -1.0;\n+    }\n+\n+    /** @brief Accumulate the time between all pairs of start() and\n+\tstop() so far */\n+    inline point_in_time\n+    active_time()\n+    { return active; }\n+\n+    /** @brief Total time between first and last tic() */\n+    inline point_in_time\n+    total_time()\n+    { return (points_in_time[pos - 1] - points_in_time[0]) * 1000.0; }\n+\n+  private:\n+    /** @brief Construct string to print out, presenting the timings. */\n+    const char*\n+    c_str()\n+    {\n+      // Avoid stream library here, to avoid cyclic dependencies in\n+      // header files.\n+      char tmp[1000];\n+\n+      if (!str)\n+\tstr = new char[pos * 200];\n+      else\n+\tstr[0] = '\\0';\n+\n+      sprintf(str, \"t %2d      T[ms]\", omp_get_thread_num());\n+      strcat(str, \"\\n\");\n+\n+      for (int i = 0; i < pos; )\n+\t{\n+\t  point_in_time last = points_in_time[i];\n+\t  i++;\n+\t  if (i == pos)\n+\t    break;\n+\t  if (tags[i] == NULL)\n+\t    sprintf(tmp, \"%2d:     \", i - 1);\n+\t  else\n+\t    sprintf(tmp, \"%20s:     \", tags[i]);\n+\t  strcat(str, tmp);\n+\n+\t  sprintf(tmp, \"%7.2f     \", (points_in_time[i] - last) * 1000.0);\n+\t  strcat(str, tmp);\n+\t  strcat(str, \"\\n\");\n+\t}\n+\n+      return str;\n+    }\n+\n+  public:\n+    /** @brief Print the running times between the tic()s. */\n+    void\n+    print()\n+    {\n+      printf(\"print\\n\");\n+#pragma omp barrier\n+#pragma omp master\n+      printf(\"\\n\\n\");\n+#pragma omp critical\n+      printf(\"%s\\n\", c_str());\n+    }\n+  };\n+\n+  /** @brief A class that provides simple run time measurements, also\n+      for parallel code.\n+   *  @param tag If parallel_tag, then the measurements are actually done,\n+   *  otherwise, no code at all is emitted by the compiler.\n+   */\n+  template<typename must_be_int>\n+  class Timing<sequential_tag, must_be_int>\n+  {\n+  private:\n+    static const char* empty_string;\n+\n+  public:\n+    inline void tic(const char* /*tag*/ = NULL) { }\n+    inline void start() { }\n+    inline void stop() { }\n+    inline void reset() { }\n+    inline point_in_time active_time() { return -1.0; }\n+    inline point_in_time total_time() { return -1.0; }\n+    inline const char* c_str() { return empty_string; }\n+    inline void print() { }\n+  };\n+\n+  template<typename must_be_int>\n+  const char* Timing<sequential_tag, must_be_int>::empty_string = \"\";\n+\n+}\n+\n+#endif"}, {"sha": "8aa9269394db846d2656f0a900b05f5cce1b576f", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "added", "additions": 3574, "deletions": 0, "changes": 3574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355"}, {"sha": "5f8014f5c71f5e9867ea1b28989988680e8b8f5f", "filename": "libstdc++-v3/include/parallel/types.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,98 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/types.h\n+ *  @brief Basic typedefs.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Johannes Singler and Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_TYPES_H\n+#define _GLIBCXX_PARALLEL_TYPES_H 1\n+\n+#include <cstdlib>\n+\n+namespace __gnu_parallel\n+{\n+  // XXX need to use <cstdint>\n+  /** @brief 8-bit signed integer. */\n+  typedef char int8;\n+\n+  /** @brief 8-bit unsigned integer. */\n+  typedef unsigned char uint8;\n+\n+  /** @brief 16-bit signed integer. */\n+  typedef short int16;\n+\n+  /** @brief 16-bit unsigned integer. */\n+  typedef unsigned short uint16;\n+\n+  /** @brief 32-bit signed integer. */\n+  typedef int int32;\n+\n+  /** @brief 32-bit unsigned integer. */\n+  typedef unsigned int uint32;\n+\n+  /** @brief 64-bit signed integer. */\n+  typedef long long int64;\n+\n+  /** @brief 64-bit unsigned integer. */\n+  typedef unsigned long long uint64;\n+\n+  /**\n+   * @brief Unsigned integer to index elements.\n+   * The total number of elements for each algorithm must fit into this type.\n+   */\n+  typedef uint64 sequence_index_t;\n+\n+  /**\n+   * @brief Unsigned integer to index a thread number.\n+   * The maximum thread number (for each processor) must fit into this type.\n+   */\n+  typedef uint16 thread_index_t;\n+\n+  /**\n+   * @brief Longest compare-and-swappable integer type on this platform.\n+   */\n+  typedef int64 lcas_t;\n+\n+  /**\n+   * @brief Number of bits of ::lcas_t.\n+   */\n+  static const int lcas_t_bits = sizeof(lcas_t) * 8;\n+\n+  /**\n+   * @brief ::lcas_t with the right half of bits set to 1.\n+   */\n+  static const lcas_t lcas_t_mask = (((lcas_t)1 << (lcas_t_bits / 2)) - 1);\n+}\n+\n+#endif /* _GLIBCXX_TYPES_H */"}, {"sha": "93a030429eb542aa6560ecdd2c60aacbb2daf5d2", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,193 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/unique_copy.h\n+ *  @brief Parallel implementations of std::unique_copy().\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Robert Geisberger and Robin Dapp.\n+\n+#ifndef _GLIBCXX_PARALLEL_UNIQUE_H\n+#define _GLIBCXX_PARALLEL_UNIQUE_H 1\n+\n+#include <parallel/parallel.h>\n+#include <parallel/multiseq_selection.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+  /** @brief Parallel std::unique_copy(), without explicit equality predicate.\n+   *  @param first Begin iterator of input sequence.\n+   *  @param last End iterator of input sequence.\n+   *  @param result Begin iterator of result sequence.\n+   *  @param binary_pred Equality predicate.\n+   *  @return End iterator of result sequence. */\n+  template<typename InputIterator, class OutputIterator, class BinaryPredicate>\n+  inline OutputIterator\n+  parallel_unique_copy(InputIterator first, InputIterator last,\n+\t\t       OutputIterator result, BinaryPredicate binary_pred)\n+  {\n+    _GLIBCXX_CALL(last - first)\n+\n+    typedef std::iterator_traits<InputIterator> traits_type;\n+    typedef typename traits_type::value_type value_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+    difference_type size = last - first;\n+    int num_threads = __gnu_parallel::get_max_threads();\n+    difference_type counter[num_threads + 1];\n+\n+    if (size == 0)\n+      return result;\n+\n+    // Let the first thread process two parts.\n+    difference_type borders[num_threads + 2];\n+    __gnu_parallel::equally_split(size, num_threads + 1, borders);\n+\n+    // First part contains at least one element.\n+#pragma omp parallel num_threads(num_threads)\n+    {\n+      int iam = omp_get_thread_num();\n+\n+      difference_type begin, end;\n+\n+      // Check for length without duplicates\n+      // Needed for position in output\n+      difference_type i = 0;\n+      OutputIterator out = result;\n+      if (iam == 0)\n+\t{\n+\t  begin = borders[0] + 1;\t// == 1\n+\t  end = borders[iam + 1];\n+\n+\t  i++;\n+\t  new (static_cast<void *>(&*out)) value_type(*first);\n+\t  out++;\n+\n+\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+\t    {\n+\t      if (!binary_pred(*iter, *(iter-1)))\n+\t\t{\n+\t\t  i++;\n+\t\t  new (static_cast<void *>(&*out)) value_type(*iter);\n+\t\t  out++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  begin = borders[iam]; //one part\n+\t  end = borders[iam + 1];\n+\n+\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+\t    {\n+\t      if (!binary_pred(*iter, *(iter-1)))\n+\t\t{\n+\t\t  i++;\n+\t\t}\n+\t    }\n+\t}\n+      counter[iam] = i;\n+\n+      // Last part still untouched.\n+      difference_type begin_output;\n+\n+#pragma omp barrier\n+\n+      // Store result in output on calculated positions.\n+      begin_output = 0;\n+\n+      if (iam == 0)\n+\t{\n+\t  for (int t = 0; t < num_threads; t++)\n+\t    begin_output += counter[t];\n+\n+\t  i = 0;\n+\n+\t  OutputIterator iter_out = result + begin_output;\n+\n+\t  begin = borders[num_threads];\n+\t  end = size;\n+\n+\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+\t    {\n+\t      if (iter == first || !binary_pred(*iter, *(iter-1)))\n+\t\t{\n+\t\t  i++;\n+\t\t  new (static_cast<void *>(&*iter_out)) value_type(*iter);\n+\t\t  iter_out++;\n+\t\t}\n+\t    }\n+\n+\t  counter[num_threads] = i;\n+\t}\n+      else\n+\t{\n+\t  for (int t = 0; t < iam; t++)\n+\t    begin_output += counter[t];\n+\n+\t  OutputIterator iter_out = result + begin_output;\n+\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+\t    {\n+\t      if (!binary_pred(*iter, *(iter-1)))\n+\t\t{\n+\t\t  new (static_cast<void *> (&*iter_out)) value_type(*iter);\n+\t\t  iter_out++;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    difference_type end_output = 0;\n+    for (int t = 0; t < num_threads + 1; t++)\n+      end_output += counter[t];\n+\n+    return result + end_output;\n+  }\n+\n+  /** @brief Parallel std::unique_copy(), without explicit equality predicate\n+   *  @param first Begin iterator of input sequence.\n+   *  @param last End iterator of input sequence.\n+   *  @param result Begin iterator of result sequence.\n+   *  @return End iterator of result sequence. */\n+  template<typename InputIterator, class OutputIterator>\n+  inline OutputIterator\n+  parallel_unique_copy(InputIterator first, InputIterator last,\n+\t\t       OutputIterator result)\n+  {\n+    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n+\n+    return parallel_unique_copy(first, last, result, std::equal_to<value_type>());\n+  }\n+\n+}//namespace __gnu_parallel\n+\n+#endif"}, {"sha": "cc8f37e8d09f6be1efd67638d5a7ef1577242540", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,289 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file parallel/workstealing.h\n+ *  @brief Parallelization of embarrassingly parallel execution by\n+ *  means of work-stealing.\n+ *  This file is a GNU parallel extension to the Standard C++ Library.\n+ */\n+\n+// Written by Felix Putze.\n+\n+#ifndef _GLIBCXX_PARALLEL_WORKSTEALING_H\n+#define _GLIBCXX_PARALLEL_WORKSTEALING_H 1\n+\n+#include <parallel/parallel.h>\n+#include <parallel/random_number.h>\n+#include <parallel/compatibility.h>\n+\n+namespace __gnu_parallel\n+{\n+\n+#define _GLIBCXX_JOB_VOLATILE volatile\n+\n+  /** @brief One job for a certain thread. */\n+  template<typename _DifferenceTp>\n+  struct Job\n+  {\n+    typedef _DifferenceTp difference_type;\n+\n+    /** @brief First element.\n+     *\n+     *  Changed by owning and stealing thread. By stealing thread,\n+     *  always incremented. */\n+    _GLIBCXX_JOB_VOLATILE difference_type first;\n+\n+    /** @brief Last element.\n+     *\n+     *  Changed by owning thread only. */\n+    _GLIBCXX_JOB_VOLATILE difference_type last;\n+\n+    /** @brief Number of elements, i. e. @c last-first+1.\n+     *\n+     *  Changed by owning thread only. */\n+    _GLIBCXX_JOB_VOLATILE difference_type load;\n+  };\n+\n+  /** @brief Work stealing algorithm for random access iterators.\n+   *\n+   *  Uses O(1) additional memory. Synchronization at job lists is\n+   *  done with atomic operations.\n+   *  @param begin Begin iterator of element sequence.\n+   *  @param end End iterator of element sequence.\n+   *  @param op User-supplied functor (comparator, predicate, adding\n+   *  functor, ...).\n+   *  @param f Functor to \"process\" an element with op (depends on\n+   *  desired functionality, e. g. for std::for_each(), ...).\n+   *  @param r Functor to \"add\" a single result to the already\n+   *  processed elements (depends on functionality).\n+   *  @param base Base value for reduction.\n+   *  @param output Pointer to position where final result is written to\n+   *  @param bound Maximum number of elements processed (e. g. for\n+   *  std::count_n()).\n+   *  @return User-supplied functor (that may contain a part of the result).\n+   */\n+  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+  Op\n+  for_each_template_random_access_workstealing(RandomAccessIterator begin,\n+\t\t\t\t\t       RandomAccessIterator end,\n+\t\t\t\t\t       Op op, Fu& f, Red r,\n+\t\t\t\t\t       Result base, Result& output,\n+\t\t\t\t\t       typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+    typedef typename traits_type::difference_type difference_type;\n+\n+\n+    difference_type chunk_size = static_cast<difference_type>(Settings::workstealing_chunk_size);\n+\n+    // How many jobs?\n+    difference_type length = (bound < 0) ? (end - begin) : bound;\n+\n+    // To avoid false sharing in a cache line.\n+    const int stride = Settings::cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n+\n+    // Total number of threads currently working.\n+    thread_index_t busy = 0;\n+    thread_index_t num_threads = get_max_threads();\n+    difference_type num_threads_min = num_threads < end - begin ? num_threads : end - begin;\n+\n+    // No more threads than jobs, at least one thread.\n+    difference_type num_threads_max = num_threads_min > 1 ? num_threads_min : 1;\n+    num_threads = static_cast<thread_index_t>(num_threads_max);\n+\n+    // Create job description array.\n+    Job<difference_type> *job = new Job<difference_type>[num_threads * stride];\n+\n+    // Write base value to output.\n+    output = base;\n+\n+#pragma omp parallel shared(busy) num_threads(num_threads)\n+    {\n+      // Initialization phase.\n+\n+      // Flags for every thread if it is doing productive work.\n+      bool iam_working = false;\n+\n+      // Thread id.\n+      thread_index_t iam = omp_get_thread_num();\n+\n+      // This job.\n+      Job<difference_type>& my_job = job[iam * stride];\n+\n+      // Random number (for work stealing).\n+      thread_index_t victim;\n+\n+      // Local value for reduction.\n+      Result result = Result();\n+\n+      // Number of elements to steal in one attempt.\n+      difference_type steal;\n+\n+      // Every thread has its own random number generator (modulo num_threads).\n+      random_number rand_gen(iam, num_threads);\n+\n+#pragma omp atomic\n+      // This thread is currently working.\n+      busy++;\n+\n+      iam_working = true;\n+\n+      // How many jobs per thread? last thread gets the rest.\n+      my_job.first = static_cast<difference_type>(iam * (length / num_threads));\n+\n+      my_job.last = (iam == (num_threads - 1)) ? (length - 1) : ((iam + 1) * (length / num_threads) - 1);\n+      my_job.load = my_job.last - my_job.first + 1;\n+\n+      // Init result with first value (to have a base value for reduction).\n+      if (my_job.first <= my_job.last)\n+\t{\n+\t  // Cannot use volatile variable directly.\n+\t  difference_type my_first = my_job.first;\n+\t  result = f(op, begin + my_first);\n+\t  my_job.first++;\n+\t  my_job.load--;\n+\t}\n+\n+      RandomAccessIterator current;\n+\n+#pragma omp barrier\n+\n+      // Actual work phase\n+      // Work on own or stolen start\n+      while (busy > 0)\n+\t{\n+\t  // Work until no productive thread left.\n+#pragma omp flush(busy)\n+\n+\t  // Thread has own work to do\n+\t  while (my_job.first <= my_job.last)\n+\t    {\n+\t      // fetch-and-add call\n+\t      // Reserve current job block (size chunk_size) in my queue.\n+\t      difference_type current_job = fetch_and_add<difference_type>(&(my_job.first), chunk_size);\n+\n+\t      // Update load, to make the three values consistent,\n+\t      // first might have been changed in the meantime\n+\t      my_job.load = my_job.last - my_job.first + 1;\n+\t      for (difference_type job_counter = 0; job_counter < chunk_size && current_job <= my_job.last; job_counter++)\n+\t\t{\n+\t\t  // Yes: process it!\n+\t\t  current = begin + current_job;\n+\t\t  current_job++;\n+\n+\t\t  // Do actual work.\n+\t\t  result = r(result, f(op, current));\n+\t\t}\n+\n+#pragma omp flush(busy)\n+\n+\t    }\n+\n+\t  // After reaching this point, a thread's job list is empty.\n+\t  if (iam_working)\n+\t    {\n+#pragma omp atomic\n+\t      // This thread no longer has work.\n+\t      busy--;\n+\n+\t      iam_working = false;\n+\t    }\n+\n+\t  difference_type supposed_first, supposed_last, supposed_load;\n+\t  do\n+\t    {\n+\t      // Find random nonempty deque (not own) and do consistency check.\n+\t      yield();\n+#pragma omp flush(busy)\n+\t      victim = rand_gen();\n+\t      supposed_first = job[victim * stride].first;\n+\t      supposed_last = job[victim * stride].last;\n+\t      supposed_load = job[victim * stride].load;\n+\t    }\n+\t  while (busy > 0\n+\t\t && ((supposed_load <= 0) || ((supposed_first + supposed_load - 1) != supposed_last)));\n+\n+\t  if (busy == 0)\n+\t    break;\n+\n+\t  if (supposed_load > 0)\n+\t    {\n+\t      // Has work and work to do.\n+\t      // Number of elements to steal (at least one).\n+\t      steal = (supposed_load < 2) ? 1 : supposed_load / 2;\n+\n+\t      // Protects against stealing threads\n+\t      // omp_set_lock(&(job[victim * stride].lock));\n+\n+\t      // Push victim's start forward.\n+\t      difference_type stolen_first = fetch_and_add<difference_type>(&(job[victim * stride].first), steal);\n+\t      difference_type stolen_try = stolen_first + steal - difference_type(1);\n+\n+\t      // Protects against working thread\n+\t      // omp_unset_lock(&(job[victim * stride].lock));\n+\n+\t      my_job.first = stolen_first;\n+\t      \n+\t      // Avoid std::min dependencies.\n+\t      my_job.last = stolen_try < supposed_last ? stolen_try : supposed_last;\n+\n+\t      my_job.load = my_job.last - my_job.first + 1;\n+\n+\t      //omp_unset_lock(&(my_job.lock));\n+\n+#pragma omp atomic\n+\t      // Has potential work again.\n+\t      busy++;\n+\t      iam_working = true;\n+\n+#pragma omp flush(busy)\n+\t    }\n+#pragma omp flush(busy)\n+\t} // end while busy > 0\n+#pragma omp critical(writeOutput)\n+      // Add accumulated result to output.\n+      output = r(output, result);\n+\n+      //omp_destroy_lock(&(my_job.lock));\n+    }\n+\n+    delete[] job;\n+\n+    // Points to last element processed (needed as return value for\n+    // some algorithms like transform)\n+    f.finish_iterator = begin + length;\n+\n+    return op;\n+  }\n+} // end namespace\n+\n+#endif"}, {"sha": "9c61f2854fbf90c4ba528432473481b0f9a17d7c", "filename": "libstdc++-v3/include/std/algorithm", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -66,4 +66,8 @@\n #include <bits/stl_algobase.h>\n #include <bits/stl_algo.h>\n \n+#ifdef _GLIBCXX_PARALLEL\n+# include <parallel/algorithm>\n+#endif\n+\n #endif /* _GLIBCXX_ALGORITHM */"}, {"sha": "c9f911195e9661151ab79fc2277ddf3a797bafa6", "filename": "libstdc++-v3/include/std/bitset", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -62,7 +62,7 @@\n  ((__n) < 1 ? 0 : ((__n) + _GLIBCXX_BITSET_BITS_PER_WORD - 1) \\\n                   / _GLIBCXX_BITSET_BITS_PER_WORD)\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @if maint"}, {"sha": "dcb32943fd91aa27ac4e0071321f92e7ce344712", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -67,4 +67,8 @@\n #include <bits/stl_iterator_base_types.h>\n #include <bits/stl_numeric.h>\n \n+#ifdef _GLIBCXX_PARALLEL\n+# include <parallel/numeric>\n+#endif\n+\n #endif /* _GLIBCXX_NUMERIC */"}, {"sha": "6848326d569169f36ce88c46c1b1309d407216bf", "filename": "libstdc++-v3/include/std/string", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -49,8 +49,12 @@\n #include <bits/cpp_type_traits.h>\n #include <bits/localefwd.h>    // For operators >>, <<, and getline.\n #include <bits/ostream_insert.h>\n+#include <bits/stl_iterator_base_types.h>\n+#include <bits/stl_iterator_base_funcs.h>\n #include <bits/stl_iterator.h>\n #include <bits/stl_function.h> // For less\n+#include <ext/numeric_traits.h> \n+#include <bits/stl_algobase.h> \n #include <bits/basic_string.h>\n \n #ifndef _GLIBCXX_EXPORT_TEMPLATE"}, {"sha": "084d5a5ef71ea4ce2eebf305f78e1511ac5c2875", "filename": "libstdc++-v3/libmath/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -86,6 +86,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -123,6 +124,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@"}, {"sha": "a7437cc55faf9e6a1691ca2c42d7eb6206c6f32c", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -141,6 +141,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -178,6 +179,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@"}, {"sha": "99047c85cb5bfb90b3be7c69993bac05889fca45", "filename": "libstdc++-v3/po/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpo%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -71,6 +71,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -108,6 +109,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@"}, {"sha": "4e70106a00555157ff5cb52d59ca27f7435b0293", "filename": "libstdc++-v3/scripts/check_performance", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -32,10 +32,12 @@ SH_FLAG=\"-Wl,--rpath -Wl,$BUILD_DIR/../../gcc \\\n          -Wl,--rpath -Wl,$BUILD_DIR/src/.libs\"\n ST_FLAG=\"-static\"\n LINK=$SH_FLAG\n-CXX=\"$COMPILER $INCLUDES $PCH_FLAGS $FLAGS $LINK\"\n+CXX=\"$COMPILER $INCLUDES $FLAGS $CXXFLAGS $LINK\"\n LIBS=\"./libtestc++.a\"\n TESTS_FILE=\"testsuite_files_performance\"\n \n+echo CXX is $CXX\n+\n for NAME in `cat $TESTS_FILE`\n do\n   RUN=true\n@@ -79,7 +81,7 @@ do\n     EXE_NAME=\"`echo $FILE_NAME.exe`\"\n     $CXX $TESTNAME $LIBS -o $EXE_NAME\n     if [ -f $EXE_NAME ]; then\n-\t./$EXE_NAME >& tmp.$FILE_NAME\n+      ./$EXE_NAME >& tmp.$FILE_NAME\n     else\n       echo \"compile error:\"\n       echo \"$CXX $TESTNAME $LIBS -o $EXE_NAME\""}, {"sha": "457adaf4d5f0231120dc8a55cb46c3dfcc8bc371", "filename": "libstdc++-v3/scripts/testsuite_flags.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -58,6 +58,13 @@ case ${query} in\n       CXXFLAGS_config=\"@SECTION_FLAGS@ @CXXFLAGS@ @EXTRA_CXX_FLAGS@\"\n       echo ${CXXFLAGS_default} ${CXXFLAGS_config}\n       ;;\n+    --cxxparallelflags)\n+      CXXFLAGS_parallel=\"-D_GLIBCXX_PARALLEL -fopenmp\n+\t\t\t -B${BUILD_DIR}/../libgomp \n+                         -I${BUILD_DIR}/../libgomp \n+\t\t\t -L${BUILD_DIR}/../libgomp/.libs -lgomp\"\n+      echo ${CXXFLAGS_parallel}\n+      ;;\n     --cxxpchflags)\n       PCHFLAGS=\"@glibcxx_PCHFLAGS@\"\n       echo ${PCHFLAGS}"}, {"sha": "0c000b07ba6778674ccfe07727e1a0e650665896", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -112,15 +112,20 @@ atomicity.cc: ${atomicity_file}\n # Source files linked in via configuration/make substitution for a\n # particular host, but with ad hoc naming rules.\n host_sources_extra = \\\n-\tbasic_file.cc \\\n-\tc++locale.cc\n+\tbasic_file.cc c++locale.cc ${ldbl_compat_sources} ${parallel_sources}\n \n c++locale.cc: ${glibcxx_srcdir}/$(CLOCALE_CC)\n \t$(LN_S) ${glibcxx_srcdir}/$(CLOCALE_CC) ./$@ || true\n \n basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \t$(LN_S) ${glibcxx_srcdir}/$(BASIC_FILE_CC) ./$@ || true\n \n+if ENABLE_PARALLEL\n+parallel_sources = parallel_list.cc \n+else\n+parallel_sources =\n+endif\n+\n if GLIBCXX_LDBL_COMPAT\n ldbl_compat_sources = compatibility-ldbl.cc\n else\n@@ -137,7 +142,6 @@ sources = \\\n \tcomplex_io.cc \\\n \tctype.cc \\\n \tdebug.cc \\\n-\tdebug_list.cc \\\n \tfunctexcept.cc \\\n \thash.cc \\\n \thash_c++0x.cc \\\n@@ -148,6 +152,7 @@ sources = \\\n \tios_locale.cc \\\n \tlimits.cc \\\n \tlist.cc \\\n+\tdebug_list.cc \\\n \tlocale.cc \\\n \tlocale_init.cc \\\n \tlocale_facets.cc \\\n@@ -175,8 +180,7 @@ sources = \\\n \twlocale-inst.cc \\\n \twstring-inst.cc \\\n \t${host_sources} \\\n-\t${host_sources_extra} \\\n-\t${ldbl_compat_sources}\n+\t${host_sources_extra} \n \n VPATH = $(top_srcdir)/src:$(top_srcdir)\n \n@@ -207,6 +211,12 @@ concept-inst.lo: concept-inst.cc\n concept-inst.o: concept-inst.cc\n \t$(CXXCOMPILE) -D_GLIBCXX_CONCEPT_CHECKS -fimplicit-templates -c $<\n \n+# Use special rules for parallel_list.cc compile.\n+parallel_list.lo: parallel_list.cc\n+\t$(LTCXXCOMPILE) -I$(glibcxx_builddir)/../libgomp -c $<\n+parallel_list.o: parallel_list.cc\n+\t$(CXXCOMPILE) -I$(glibcxx_builddir)/../libgomp -c $<\n+\n # Use special rules for the C++0x sources so that the proper flags are passed.\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<"}, {"sha": "168be1cf761fee9309b3617d6fc369ef0f5b138b", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -69,9 +69,9 @@ toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__libstdc___la_SOURCES_DIST = bitmap_allocator.cc pool_allocator.cc \\\n \tmt_allocator.cc codecvt.cc compatibility.cc complex_io.cc \\\n-\tctype.cc debug.cc debug_list.cc functexcept.cc hash.cc \\\n-\thash_c++0x.cc globals_io.cc ios.cc ios_failure.cc ios_init.cc \\\n-\tios_locale.cc limits.cc list.cc locale.cc locale_init.cc \\\n+\tctype.cc debug.cc functexcept.cc hash.cc hash_c++0x.cc \\\n+\tglobals_io.cc ios.cc ios_failure.cc ios_init.cc ios_locale.cc \\\n+\tlimits.cc list.cc debug_list.cc locale.cc locale_init.cc \\\n \tlocale_facets.cc localename.cc stdexcept.cc strstream.cc \\\n \tsystem_error.cc tree.cc allocator-inst.cc concept-inst.cc \\\n \tfstream-inst.cc ext-inst.cc ios-inst.cc iostream-inst.cc \\\n@@ -81,25 +81,28 @@ am__libstdc___la_SOURCES_DIST = bitmap_allocator.cc pool_allocator.cc \\\n \twstring-inst.cc atomicity.cc codecvt_members.cc \\\n \tcollate_members.cc ctype_members.cc messages_members.cc \\\n \tmonetary_members.cc numeric_members.cc time_members.cc \\\n-\tbasic_file.cc c++locale.cc compatibility-ldbl.cc\n+\tbasic_file.cc c++locale.cc compatibility-ldbl.cc \\\n+\tparallel_list.cc\n am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n \tctype_members.lo messages_members.lo monetary_members.lo \\\n \tnumeric_members.lo time_members.lo\n-am__objects_2 = basic_file.lo c++locale.lo\n-@GLIBCXX_LDBL_COMPAT_TRUE@am__objects_3 = compatibility-ldbl.lo\n-am__objects_4 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n+@GLIBCXX_LDBL_COMPAT_TRUE@am__objects_2 = compatibility-ldbl.lo\n+@ENABLE_PARALLEL_TRUE@am__objects_3 = parallel_list.lo\n+am__objects_4 = basic_file.lo c++locale.lo $(am__objects_2) \\\n+\t$(am__objects_3)\n+am__objects_5 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n \tcodecvt.lo compatibility.lo complex_io.lo ctype.lo debug.lo \\\n-\tdebug_list.lo functexcept.lo hash.lo hash_c++0x.lo \\\n-\tglobals_io.lo ios.lo ios_failure.lo ios_init.lo ios_locale.lo \\\n-\tlimits.lo list.lo locale.lo locale_init.lo locale_facets.lo \\\n+\tfunctexcept.lo hash.lo hash_c++0x.lo globals_io.lo ios.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n+\tdebug_list.lo locale.lo locale_init.lo locale_facets.lo \\\n \tlocalename.lo stdexcept.lo strstream.lo system_error.lo \\\n \ttree.lo allocator-inst.lo concept-inst.lo fstream-inst.lo \\\n \text-inst.lo ios-inst.lo iostream-inst.lo istream-inst.lo \\\n \tistream.lo locale-inst.lo misc-inst.lo ostream-inst.lo \\\n \tsstream-inst.lo streambuf-inst.lo streambuf.lo string-inst.lo \\\n \tvalarray-inst.lo wlocale-inst.lo wstring-inst.lo \\\n-\t$(am__objects_1) $(am__objects_2) $(am__objects_3)\n-am_libstdc___la_OBJECTS = $(am__objects_4)\n+\t$(am__objects_1) $(am__objects_4)\n+am_libstdc___la_OBJECTS = $(am__objects_5)\n libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)\n depcomp =\n@@ -121,6 +124,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -158,6 +162,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@\n@@ -348,9 +354,10 @@ atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h\n # Source files linked in via configuration/make substitution for a\n # particular host, but with ad hoc naming rules.\n host_sources_extra = \\\n-\tbasic_file.cc \\\n-\tc++locale.cc\n+\tbasic_file.cc c++locale.cc ${ldbl_compat_sources} ${parallel_sources}\n \n+@ENABLE_PARALLEL_FALSE@parallel_sources = \n+@ENABLE_PARALLEL_TRUE@parallel_sources = parallel_list.cc \n @GLIBCXX_LDBL_COMPAT_FALSE@ldbl_compat_sources = \n @GLIBCXX_LDBL_COMPAT_TRUE@ldbl_compat_sources = compatibility-ldbl.cc\n \n@@ -364,7 +371,6 @@ sources = \\\n \tcomplex_io.cc \\\n \tctype.cc \\\n \tdebug.cc \\\n-\tdebug_list.cc \\\n \tfunctexcept.cc \\\n \thash.cc \\\n \thash_c++0x.cc \\\n@@ -375,6 +381,7 @@ sources = \\\n \tios_locale.cc \\\n \tlimits.cc \\\n \tlist.cc \\\n+\tdebug_list.cc \\\n \tlocale.cc \\\n \tlocale_init.cc \\\n \tlocale_facets.cc \\\n@@ -402,8 +409,7 @@ sources = \\\n \twlocale-inst.cc \\\n \twstring-inst.cc \\\n \t${host_sources} \\\n-\t${host_sources_extra} \\\n-\t${ldbl_compat_sources}\n+\t${host_sources_extra} \n \n libstdc___la_SOURCES = $(sources)\n libstdc___la_LIBADD = \\\n@@ -790,6 +796,12 @@ concept-inst.lo: concept-inst.cc\n concept-inst.o: concept-inst.cc\n \t$(CXXCOMPILE) -D_GLIBCXX_CONCEPT_CHECKS -fimplicit-templates -c $<\n \n+# Use special rules for parallel_list.cc compile.\n+parallel_list.lo: parallel_list.cc\n+\t$(LTCXXCOMPILE) -I$(glibcxx_builddir)/../libgomp -c $<\n+parallel_list.o: parallel_list.cc\n+\t$(CXXCOMPILE) -I$(glibcxx_builddir)/../libgomp -c $<\n+\n # Use special rules for the C++0x sources so that the proper flags are passed.\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<"}, {"sha": "0e70d2319985fd625aa929d536326c1781c73476", "filename": "libstdc++-v3/src/list.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2Flist.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2Flist.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flist.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -55,7 +55,7 @@\n \n #include <list>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   void\n   _List_node_base::swap(_List_node_base& __x, _List_node_base& __y)"}, {"sha": "a79a886904c9c7cbc7a0f335a1beb598fc7448ed", "filename": "libstdc++-v3/src/parallel_list.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2Fparallel_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Fsrc%2Fparallel_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fparallel_list.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,32 @@\n+// Parallel mode support code for list -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#define _GLIBCXX_PARALLEL \n+\n+#include \"list.cc\""}, {"sha": "c2e56c2bd35d212ab147ea7e0a77eca839f59c0b", "filename": "libstdc++-v3/testsuite/25_algorithms/headers/algorithm_parallel_mode.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Falgorithm_parallel_mode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Falgorithm_parallel_mode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Falgorithm_parallel_mode.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-D_GLIBCXX_PARALLEL -fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <algorithm>"}, {"sha": "90e02796263f365df0e916f1900d643478a9e867", "filename": "libstdc++-v3/testsuite/25_algorithms/headers/parallel_algorithm.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <parallel/algorithm>"}, {"sha": "c6c4ce2ff4356153944f288b5a010543f546f777", "filename": "libstdc++-v3/testsuite/25_algorithms/headers/parallel_algorithm_mixed1.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed1.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <parallel/algorithm>\n+#include <vector>\n+#include <algorithm>\n+\n+void test()\n+{\n+  typedef unsigned short \tvalue_type;\n+  typedef std::vector<value_type> vector_type;\n+  \n+  const value_type c(0);\n+\n+  vector_type v(10);\n+  std::find(v.begin(), v.end(), c);\n+  __gnu_parallel::find(v.begin(), v.end(), c);\n+}"}, {"sha": "94794d46c9f35027fc2c8c8974b8de45ac21f21d", "filename": "libstdc++-v3/testsuite/25_algorithms/headers/parallel_algorithm_mixed2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheaders%2Fparallel_algorithm_mixed2.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// Make sure to test without _GLIBCXX_PARALLEL\n+#ifdef _GLIBCXX_PARALLEL \n+# undef _GLIBCXX_PARALLEL \n+#endif\n+\n+#include <parallel/algorithm>\n+#include <vector>\n+#include <algorithm>\n+\n+void test()\n+{\n+  typedef unsigned short \tvalue_type;\n+  typedef std::vector<value_type> vector_type;\n+  \n+  const value_type c(0);\n+\n+  vector_type v(10);\n+  std::find(v.begin(), v.end(), c);\n+  __gnu_parallel::find(v.begin(), v.end(), c);\n+}"}, {"sha": "3e3b3de15dd94e5ec012215c169e0191f6c70a00", "filename": "libstdc++-v3/testsuite/26_numerics/headers/numeric/numeric_parallel_mode.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fnumeric_parallel_mode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fnumeric_parallel_mode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fnumeric_parallel_mode.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-D_GLIBCXX_PARALLEL -fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <numeric>"}, {"sha": "d2d531e9ab66320b5667f3d9566ff5e85e002f92", "filename": "libstdc++-v3/testsuite/26_numerics/headers/numeric/parallel_numeric.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <parallel/numeric>"}, {"sha": "425fd59c34be48144db00c7a13b84ae4b576edcb", "filename": "libstdc++-v3/testsuite/26_numerics/headers/numeric/parallel_numeric_mixed1.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed1.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <parallel/numeric>\n+#include <numeric>\n+#include <vector>\n+#include <numeric>\n+\n+void test()\n+{\n+  typedef unsigned short \tvalue_type;\n+  typedef std::vector<value_type> vector_type;\n+  \n+  const value_type c(0);\n+\n+  vector_type v(10);\n+  std::accumulate(v.begin(), v.end(), value_type(1));\n+  __gnu_parallel::accumulate(v.begin(), v.end(), value_type(1));\n+}"}, {"sha": "d7bdfc1a511508672b9c0ec45d35efe2928d7bd8", "filename": "libstdc++-v3/testsuite/26_numerics/headers/numeric/parallel_numeric_mixed2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fnumeric%2Fparallel_numeric_mixed2.cc?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-require-parallel-mode \"\" }\n+// { dg-options \"-fopenmp\" { target *-*-* } }\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// Make sure to test without _GLIBCXX_PARALLEL\n+#ifdef _GLIBCXX_PARALLEL \n+# undef _GLIBCXX_PARALLEL \n+#endif\n+\n+#include <parallel/numeric>\n+#include <numeric>\n+#include <vector>\n+#include <numeric>\n+\n+void test()\n+{\n+  typedef unsigned short \tvalue_type;\n+  typedef std::vector<value_type> vector_type;\n+  \n+  const value_type c(0);\n+\n+  vector_type v(10);\n+  std::accumulate(v.begin(), v.end(), value_type(1));\n+  __gnu_parallel::accumulate(v.begin(), v.end(), value_type(1));\n+}"}, {"sha": "4a4dc442dd3a184363269630e6392984a957f5b8", "filename": "libstdc++-v3/testsuite/Makefile.am", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -123,11 +123,41 @@ doc-performance:\n \t${glibcxx_srcdir}/testsuite/data/make_graph_htmls.xml \\\n \t${glibcxx_srcdir}/testsuite/data/make_graph_test_infos.xml local g++)\n \n+# Runs the testsuite in parallel mode.\n+libgomp_dir=${glibcxx_builddir}/../libgomp\n+libgomp_flags=-B${glibcxx_builddir}/../libgomp \\\n+              -I${glibcxx_builddir}/../libgomp \\\n+\t      -L${glibcxx_builddir}/../libgomp/.libs -lgomp\n+\n+atomic_flags=$(ATOMIC_FLAGS)\n+parallel_flags=\"unix/-D_GLIBCXX_PARALLEL/-fopenmp\"\n+\n+check-parallel: site.exp\n+\t-@(if test ! -d $${libgomp_dir}; then \\\n+\t  echo \"Testing parallel mode failed as libgomp not present.\"; \\\n+\t  exit 1; \\\n+\tfi; \\\n+\toutputdir=parallel; export outputdir; \\\n+\tif test ! -d $${outputdir}; then \\\n+\t  mkdir $${outputdir}; \\\n+\tfi; \\\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\t$(MAKE) CXXFLAGS=\"$(atomic_flags) $(libgomp_flags)\" $(AM_MAKEFLAGS) RUNTESTFLAGS=\"$(RUNTESTFLAGS) conformance.exp --outdir $${outputdir} --objdir $${outputdir} --target_board=$(parallel_flags)\" check-DEJAGNU; )\n+\n+check-performance-parallel: testsuite_files_performance ${performance_script}\n+\t-@(chmod + ${check_performance_script}; \\\n+\tCXXFLAGS=\"-D_GLIBCXX_PARALLEL -fopenmp $(atomic_flags) $(libgomp_flags)\"; export CXXFLAGS; \\\n+\t${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n \n .PHONY: baseline_symbols new-abi-baseline \\\n-\tcheck-abi check-compile check-performance\n+\tcheck-abi check-compile check-performance check-parallel\n \n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n \t     testsuite_* site.exp abi_check baseline_symbols *TEST* *.dat \\\n-\t     *.o *.cc *.a *.so *.xml\n+\t     *.s *.o *.cc *.a *.so *.xml \n+\n+# To remove directories.\n+clean-local:\n+\trm -rf parallel"}, {"sha": "b76a5ed194e3887c75f1d6a104d2ff48ffb71e72", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -75,6 +75,7 @@ AMTAR = @AMTAR@\n AR = @AR@\n AS = @AS@\n ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n AUTOCONF = @AUTOCONF@\n AUTOHEADER = @AUTOHEADER@\n@@ -112,6 +113,8 @@ ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n+ENABLE_PARALLEL_FALSE = @ENABLE_PARALLEL_FALSE@\n+ENABLE_PARALLEL_TRUE = @ENABLE_PARALLEL_TRUE@\n ENABLE_SYMVERS_DARWIN_FALSE = @ENABLE_SYMVERS_DARWIN_FALSE@\n ENABLE_SYMVERS_DARWIN_TRUE = @ENABLE_SYMVERS_DARWIN_TRUE@\n ENABLE_SYMVERS_FALSE = @ENABLE_SYMVERS_FALSE@\n@@ -303,10 +306,19 @@ check_performance_script = ${glibcxx_srcdir}/scripts/check_performance\n # Generates the plots and graphs for performance testing.\n doc_performance_script = ${glibcxx_srcdir}/scripts/make_graphs.py\n \n+# Runs the testsuite in parallel mode.\n+libgomp_dir = ${glibcxx_builddir}/../libgomp\n+libgomp_flags = -B${glibcxx_builddir}/../libgomp \\\n+              -I${glibcxx_builddir}/../libgomp \\\n+\t      -L${glibcxx_builddir}/../libgomp/.libs -lgomp\n+\n+atomic_flags = $(ATOMIC_FLAGS)\n+parallel_flags = \"unix/-D_GLIBCXX_PARALLEL/-fopenmp\"\n+\n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n \t     testsuite_* site.exp abi_check baseline_symbols *TEST* *.dat \\\n-\t     *.o *.cc *.a *.so *.xml\n+\t     *.s *.o *.cc *.a *.so *.xml \n \n all: all-am\n \n@@ -434,7 +446,7 @@ maintainer-clean-generic:\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n clean: clean-am\n \n-clean-am: clean-generic clean-libtool mostlyclean-am\n+clean-am: clean-generic clean-libtool clean-local mostlyclean-am\n \n distclean: distclean-am\n \t-rm -f Makefile\n@@ -480,14 +492,15 @@ ps-am:\n uninstall-am: uninstall-info-am\n \n .PHONY: all all-am check check-DEJAGNU check-am clean clean-generic \\\n-\tclean-libtool distclean distclean-DEJAGNU distclean-generic \\\n-\tdistclean-libtool distdir dvi dvi-am html html-am info info-am \\\n-\tinstall install-am install-data install-data-am install-exec \\\n-\tinstall-exec-am install-info install-info-am install-man \\\n-\tinstall-strip installcheck installcheck-am installdirs \\\n-\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n-\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n-\tuninstall uninstall-am uninstall-info-am\n+\tclean-libtool clean-local distclean distclean-DEJAGNU \\\n+\tdistclean-generic distclean-libtool distdir dvi dvi-am html \\\n+\thtml-am info info-am install install-am install-data \\\n+\tinstall-data-am install-exec install-exec-am install-info \\\n+\tinstall-info-am install-man install-strip installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-generic \\\n+\tmostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am \\\n+\tuninstall-info-am\n \n \n # This rule generates all of the testsuite_files* lists at once.\n@@ -557,8 +570,30 @@ doc-performance:\n \t${glibcxx_srcdir}/testsuite/data/make_graph_htmls.xml \\\n \t${glibcxx_srcdir}/testsuite/data/make_graph_test_infos.xml local g++)\n \n+check-parallel: site.exp\n+\t-@(if test ! -d $${libgomp_dir}; then \\\n+\t  echo \"Testing parallel mode failed as libgomp not present.\"; \\\n+\t  exit 1; \\\n+\tfi; \\\n+\toutputdir=parallel; export outputdir; \\\n+\tif test ! -d $${outputdir}; then \\\n+\t  mkdir $${outputdir}; \\\n+\tfi; \\\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\t$(MAKE) CXXFLAGS=\"$(atomic_flags) $(libgomp_flags)\" $(AM_MAKEFLAGS) RUNTESTFLAGS=\"$(RUNTESTFLAGS) conformance.exp --outdir $${outputdir} --objdir $${outputdir} --target_board=$(parallel_flags)\" check-DEJAGNU; )\n+\n+check-performance-parallel: testsuite_files_performance ${performance_script}\n+\t-@(chmod + ${check_performance_script}; \\\n+\tCXXFLAGS=\"-D_GLIBCXX_PARALLEL -fopenmp $(atomic_flags) $(libgomp_flags)\"; export CXXFLAGS; \\\n+\t${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n+\n .PHONY: baseline_symbols new-abi-baseline \\\n-\tcheck-abi check-compile check-performance\n+\tcheck-abi check-compile check-performance check-parallel\n+\n+# To remove directories.\n+clean-local:\n+\trm -rf parallel\n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "a13fa74cf6323fed299bc7190744cd3a5149c574", "filename": "libstdc++-v3/testsuite/lib/dg-options.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -35,6 +35,15 @@ proc dg-require-debug-mode { args } {\n     return\n }\n \n+proc dg-require-parallel-mode { args } {\n+    if { ![ check_v3_target_parallel_mode ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+\treturn\n+    }\n+    return\n+}\n+\n proc dg-require-fileio { args } {\n     if { ![ check_v3_target_fileio ] } {\n \tupvar dg-do-what dg-do-what"}, {"sha": "136c2f7e7cb699f6619f0f6f10f85fb9900c4577", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ba97097b567d97c5c00435d2e9f0fc1079e355/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=c2ba97097b567d97c5c00435d2e9f0fc1079e355", "patch": "@@ -383,6 +383,7 @@ proc v3_target_compile_as_c { source dest type options } {\n     global flags_file\n     global blddir\n     global cc\n+    global cxxflags\n \n     if { [target_info needs_status_wrapper] != \"\" && [info exists gluefile] } {\n         lappend options \"libs=${gluefile}\"\n@@ -393,6 +394,7 @@ proc v3_target_compile_as_c { source dest type options } {\n     set cc_final $cc\n     set cxxlibglossflags [libgloss_link_flags]\n     set cc_final [concat $cc_final $cxxlibglossflags]\n+    set cc_final [concat $cc_final $cxxflags]\n     set cc_final [concat $cc_final $includes]\n     regsub -all {\\s[-]nostdinc[+][+]} $cc_final \"\" cc_final\n \n@@ -884,3 +886,59 @@ proc check_v3_target_debug_mode { } {\n     verbose \"check_v3_target_debug_mode: $et_debug_mode\" 2\n     return $et_debug_mode\n }\n+\n+proc check_v3_target_parallel_mode { } {\n+    global cxxflags\n+    global DEFAULT_CXXFLAGS\n+    global et_parallel_mode\n+\n+    global tool\t\n+\n+    if { ![info exists et_parallel_mode_target_name] } {\n+\tset et_parallel_mode_target_name \"\"\n+    }\n+\n+    # If the target has changed since we set the cached value, clear it.\n+    set current_target [current_target_name]\n+    if { $current_target != $et_parallel_mode_target_name } {\n+\tverbose \"check_v3_target_parallel_mode: `$et_parallel_mode_target_name'\" 2\n+\tset et_parallel_mode_target_name $current_target\n+\tif [info exists et_parallel_mode] {\n+\t    verbose \"check_v3_target_parallel_mode: removing cached result\" 2\n+\t    unset et_parallel_mode\n+\t}\n+    }\n+\n+    if [info exists et_parallel_mode] {\n+\tverbose \"check_v3_target_parallel_mode: using cached result\" 2\n+    } else {\n+\tset et_parallel_mode 0\n+\n+\t# Set up, compile, and execute a C++ test program that depends\n+\t# on parallel mode working.\n+\tset src parallel_mode[pid].cc\n+\tset exe parallel_mode[pid].exe\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <omp.h>\"\n+\tputs $f \"int main()\"\n+\tputs $f \"{ return 0; }\"\n+\tclose $f\n+\n+\tset cxxflags_saved $cxxflags\n+\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n+\n+\tset lines [v3_target_compile $src $exe executable \"\"]\n+\tset cxxflags $cxxflags_saved\n+\tfile delete $src\n+\n+\tif [string match \"\" $lines] {\n+\t    # No error message, compilation succeeded.\n+\t    set et_parallel_mode 1\n+\t} else {\n+\t    verbose \"check_v3_target_parallel_mode: compilation failed\" 2\n+\t}\n+    }\n+    verbose \"check_v3_target_parallel_mode: $et_parallel_mode\" 2\n+    return $et_parallel_mode\n+}"}]}