{"sha": "8df47bdf99b8eb5d68736fe058559899c4270e4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRmNDdiZGY5OWI4ZWI1ZDY4NzM2ZmUwNTg1NTk4OTljNDI3MGU0Zg==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2018-08-06T09:57:03Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2018-08-06T09:57:03Z"}, "message": "Remaining support for clobber high\n\ngcc/\n\t* alias.c (record_set): Check for clobber high.\n\t* cfgexpand.c (expand_gimple_stmt): Likewise.\n\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n\t* combine.c (find_single_use_1): Likewise.\n\t(set_nonzero_bits_and_sign_copies): Likewise.\n\t(get_combine_src_dest): Likewise.\n\t(is_parallel_of_n_reg_sets): Likewise.\n\t(try_combine): Likewise.\n\t(record_dead_and_set_regs_1): Likewise.\n\t(reg_dead_at_p_1): Likewise.\n\t(reg_dead_at_p): Likewise.\n\t* dce.c (deletable_insn_p): Likewise.\n\t(mark_nonreg_stores_1): Likewise.\n\t(mark_nonreg_stores_2): Likewise.\n\t* df-scan.c (df_find_hard_reg_defs): Likewise.\n\t(df_uses_record): Likewise.\n\t(df_get_call_refs): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t* haifa-sched.c (haifa_classify_rtx): Likewise.\n\t* ira-build.c (create_insn_allocnos): Likewise.\n\t* ira-costs.c (scan_one_insn): Likewise.\n\t* ira.c (equiv_init_movable_p): Likewise.\n\t(rtx_moveable_p): Likewise.\n\t(interesting_dest_for_shprep): Likewise.\n\t* jump.c (mark_jump_label_1): Likewise.\n\t* postreload-gcse.c (record_opr_changes): Likewise.\n\t* postreload.c (reload_cse_simplify): Likewise.\n\t(struct reg_use): Add source expr.\n\t(reload_combine): Check for clobber high.\n\t(reload_combine_note_use): Likewise.\n\t(reload_cse_move2add): Likewise.\n\t(move2add_note_store): Likewise.\n\t* print-rtl.c (print_pattern): Likewise.\n\t* recog.c (decode_asm_operands): Likewise.\n\t(store_data_bypass_p): Likewise.\n\t(if_test_bypass_p): Likewise.\n\t* regcprop.c (kill_clobbered_value): Likewise.\n\t(kill_set_value): Likewise.\n\t* reginfo.c (reg_scan_mark_refs): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\t(eliminate_regs_1): Likewise.\n\t(elimination_effects): Likewise.\n\t(mark_not_eliminable): Likewise.\n\t(scan_paradoxical_subregs): Likewise.\n\t(forget_old_reloads_1): Likewise.\n\t* reorg.c (find_end_label): Likewise.\n\t(try_merge_delay_insns): Likewise.\n\t(redundant_insn): Likewise.\n\t(own_thread_p): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(dbr_schedule): Likewise.\n\t* resource.c (update_live_status): Likewise.\n\t(mark_referenced_resources): Likewise.\n\t(mark_set_resources): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* rtlanal.c (reg_referenced_p): Likewise.\n\t(single_set_2): Likewise.\n\t(noop_move_p): Likewise.\n\t(note_stores): Likewise.\n\t* sched-deps.c (sched_analyze_reg): Likewise.\n\t(sched_analyze_insn): Likewise.\n\nFrom-SVN: r263331", "tree": {"sha": "01a13d22561366cd72c18aa02166ace2364afdff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01a13d22561366cd72c18aa02166ace2364afdff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8df47bdf99b8eb5d68736fe058559899c4270e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df47bdf99b8eb5d68736fe058559899c4270e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df47bdf99b8eb5d68736fe058559899c4270e4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df47bdf99b8eb5d68736fe058559899c4270e4f/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99788e063016c4f8d87dae3de71c646effac654f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99788e063016c4f8d87dae3de71c646effac654f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99788e063016c4f8d87dae3de71c646effac654f"}], "stats": {"total": 330, "additions": 290, "deletions": 40}, "files": [{"sha": "a47e00e5558d25495242075cefc6f84d70dff40a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1,3 +1,68 @@\n+2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* alias.c (record_set): Check for clobber high.\n+\t* cfgexpand.c (expand_gimple_stmt): Likewise.\n+\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n+\t* combine.c (find_single_use_1): Likewise.\n+\t(set_nonzero_bits_and_sign_copies): Likewise.\n+\t(get_combine_src_dest): Likewise.\n+\t(is_parallel_of_n_reg_sets): Likewise.\n+\t(try_combine): Likewise.\n+\t(record_dead_and_set_regs_1): Likewise.\n+\t(reg_dead_at_p_1): Likewise.\n+\t(reg_dead_at_p): Likewise.\n+\t* dce.c (deletable_insn_p): Likewise.\n+\t(mark_nonreg_stores_1): Likewise.\n+\t(mark_nonreg_stores_2): Likewise.\n+\t* df-scan.c (df_find_hard_reg_defs): Likewise.\n+\t(df_uses_record): Likewise.\n+\t(df_get_call_refs): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t* haifa-sched.c (haifa_classify_rtx): Likewise.\n+\t* ira-build.c (create_insn_allocnos): Likewise.\n+\t* ira-costs.c (scan_one_insn): Likewise.\n+\t* ira.c (equiv_init_movable_p): Likewise.\n+\t(rtx_moveable_p): Likewise.\n+\t(interesting_dest_for_shprep): Likewise.\n+\t* jump.c (mark_jump_label_1): Likewise.\n+\t* postreload-gcse.c (record_opr_changes): Likewise.\n+\t* postreload.c (reload_cse_simplify): Likewise.\n+\t(struct reg_use): Add source expr.\n+\t(reload_combine): Check for clobber high.\n+\t(reload_combine_note_use): Likewise.\n+\t(reload_cse_move2add): Likewise.\n+\t(move2add_note_store): Likewise.\n+\t* print-rtl.c (print_pattern): Likewise.\n+\t* recog.c (decode_asm_operands): Likewise.\n+\t(store_data_bypass_p): Likewise.\n+\t(if_test_bypass_p): Likewise.\n+\t* regcprop.c (kill_clobbered_value): Likewise.\n+\t(kill_set_value): Likewise.\n+\t* reginfo.c (reg_scan_mark_refs): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t(eliminate_regs_1): Likewise.\n+\t(elimination_effects): Likewise.\n+\t(mark_not_eliminable): Likewise.\n+\t(scan_paradoxical_subregs): Likewise.\n+\t(forget_old_reloads_1): Likewise.\n+\t* reorg.c (find_end_label): Likewise.\n+\t(try_merge_delay_insns): Likewise.\n+\t(redundant_insn): Likewise.\n+\t(own_thread_p): Likewise.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t(dbr_schedule): Likewise.\n+\t* resource.c (update_live_status): Likewise.\n+\t(mark_referenced_resources): Likewise.\n+\t(mark_set_resources): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* rtlanal.c (reg_referenced_p): Likewise.\n+\t(single_set_2): Likewise.\n+\t(noop_move_p): Likewise.\n+\t(note_stores): Likewise.\n+\t* sched-deps.c (sched_analyze_reg): Likewise.\n+\t(sched_analyze_insn): Likewise.\n+\n 2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n \n \t* cse.c (invalidate_reg): New function extracted from..."}, {"sha": "748da2b6951d39dfa0922fae57bc3068a5ccea90", "filename": "gcc/alias.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1554,6 +1554,17 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n+      /* A CLOBBER_HIGH only wipes out the old value if the mode of the old\n+\t value is greater than that of the clobber.  */\n+      else if (GET_CODE (set) == CLOBBER_HIGH)\n+\t{\n+\t  if (new_reg_base_value[regno] != 0\n+\t      && reg_is_clobbered_by_clobber_high (\n+\t\t   regno, GET_MODE (new_reg_base_value[regno]), XEXP (set, 0)))\n+\t    new_reg_base_value[regno] = 0;\n+\t  return;\n+\t}\n+\n       src = SET_SRC (set);\n     }\n   else"}, {"sha": "3c5b30b79f8702a9222cd0c7d45f8da41f94a5e8", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -3750,6 +3750,7 @@ expand_gimple_stmt (gimple *stmt)\n \t      /* If we want exceptions for non-call insns, any\n \t\t may_trap_p instruction may throw.  */\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH\n \t      && GET_CODE (PATTERN (insn)) != USE\n \t      && insn_could_throw_p (insn))\n \t    make_reg_eh_region_note (insn, 0, lp_nr);"}, {"sha": "bd7f5d0d2eceaaf9049d3a38bfb15dbddabadff9", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -133,6 +133,7 @@ single_set_for_csa (rtx_insn *insn)\n \t  && SET_SRC (this_rtx) == SET_DEST (this_rtx))\n \t;\n       else if (GET_CODE (this_rtx) != CLOBBER\n+\t       && GET_CODE (this_rtx) != CLOBBER_HIGH\n \t       && GET_CODE (this_rtx) != USE)\n \treturn NULL_RTX;\n     }"}, {"sha": "7a0abf2f7433603be7d4d75c8f550625cde35c75", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -570,6 +570,7 @@ find_single_use_1 (rtx dest, rtx *loc)\n     case SYMBOL_REF:\n     CASE_CONST_ANY:\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       return 0;\n \n     case SET:\n@@ -1752,6 +1753,9 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t  return;\n \t}\n \n+      /* Should not happen as we only using pseduo registers.  */\n+      gcc_assert (GET_CODE (set) != CLOBBER_HIGH);\n+\n       /* If this register is being initialized using itself, and the\n \t register is uninitialized in this basic block, and there are\n \t no LOG_LINKS which set the register, then part of the\n@@ -1910,6 +1914,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \n \t      /* We can ignore CLOBBERs.  */\n \t    case CLOBBER:\n+\t    case CLOBBER_HIGH:\n \t      break;\n \n \t    case SET:\n@@ -2570,10 +2575,17 @@ is_parallel_of_n_reg_sets (rtx pat, int n)\n \t|| !REG_P (SET_DEST (XVECEXP (pat, 0, i))))\n       return false;\n   for ( ; i < len; i++)\n-    if (GET_CODE (XVECEXP (pat, 0, i)) != CLOBBER\n-\t|| XEXP (XVECEXP (pat, 0, i), 0) == const0_rtx)\n-      return false;\n-\n+    switch (GET_CODE (XVECEXP (pat, 0, i)))\n+      {\n+      case CLOBBER:\n+\tif (XEXP (XVECEXP (pat, 0, i), 0) == const0_rtx)\n+\t  return false;\n+\tbreak;\n+      case CLOBBER_HIGH:\n+\tbreak;\n+      default:\n+\treturn false;\n+      }\n   return true;\n }\n \n@@ -2860,7 +2872,8 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       for (i = 0; ok && i < XVECLEN (p2, 0); i++)\n \t{\n \t  if ((GET_CODE (XVECEXP (p2, 0, i)) == SET\n-\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER)\n+\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER\n+\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER_HIGH)\n \t      && reg_overlap_mentioned_p (SET_DEST (PATTERN (i3)),\n \t\t\t\t\t  SET_DEST (XVECEXP (p2, 0, i))))\n \t    ok = false;\n@@ -13315,6 +13328,15 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n \t\t\t      ? SET_SRC (setter)\n \t\t\t      : gen_lowpart (GET_MODE (dest),\n \t\t\t\t\t     SET_SRC (setter)));\n+      else if (GET_CODE (setter) == CLOBBER_HIGH)\n+\t{\n+\t  reg_stat_type *rsp = &reg_stat[REGNO (dest)];\n+\t  if (rsp->last_set_value\n+\t      && reg_is_clobbered_by_clobber_high\n+\t\t   (REGNO (dest), GET_MODE (rsp->last_set_value),\n+\t\t    XEXP (setter, 0)))\n+\t    record_value_for_reg (dest, NULL, NULL_RTX);\n+\t}\n       else\n \trecord_value_for_reg (dest, record_dead_insn, NULL_RTX);\n     }\n@@ -13735,6 +13757,7 @@ get_last_value (const_rtx x)\n \n static unsigned int reg_dead_regno, reg_dead_endregno;\n static int reg_dead_flag;\n+rtx reg_dead_reg;\n \n /* Function called via note_stores from reg_dead_at_p.\n \n@@ -13749,6 +13772,10 @@ reg_dead_at_p_1 (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (!REG_P (dest))\n     return;\n \n+  if (GET_CODE (x) == CLOBBER_HIGH\n+      && !reg_is_clobbered_by_clobber_high (reg_dead_reg, XEXP (x, 0)))\n+    return;\n+\n   regno = REGNO (dest);\n   endregno = END_REGNO (dest);\n   if (reg_dead_endregno > regno && reg_dead_regno < endregno)\n@@ -13772,6 +13799,7 @@ reg_dead_at_p (rtx reg, rtx_insn *insn)\n   /* Set variables for reg_dead_at_p_1.  */\n   reg_dead_regno = REGNO (reg);\n   reg_dead_endregno = END_REGNO (reg);\n+  reg_dead_reg = reg;\n \n   reg_dead_flag = 0;\n "}, {"sha": "7fc3fd209b5adaf9c1b3b6051d82d6834bb16488", "filename": "gcc/dce.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -145,6 +145,7 @@ deletable_insn_p (rtx_insn *insn, bool fast, bitmap arg_stores)\n       return false;\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       if (fast)\n \t{\n \t  /* A CLOBBER of a dead pseudo register serves no purpose.\n@@ -213,7 +214,10 @@ static void\n mark_nonreg_stores_1 (rtx dest, const_rtx pattern, void *data)\n {\n   if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n-    mark_insn ((rtx_insn *) data, true);\n+    {\n+      gcc_checking_assert (GET_CODE (pattern) != CLOBBER_HIGH);\n+      mark_insn ((rtx_insn *) data, true);\n+    }\n }\n \n \n@@ -224,7 +228,10 @@ static void\n mark_nonreg_stores_2 (rtx dest, const_rtx pattern, void *data)\n {\n   if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n-    mark_insn ((rtx_insn *) data, false);\n+    {\n+      gcc_checking_assert (GET_CODE (pattern) != CLOBBER_HIGH);\n+      mark_insn ((rtx_insn *) data, false);\n+    }\n }\n \n "}, {"sha": "0b119f211ea7a9e6443338e916756b388953172c", "filename": "gcc/df-scan.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -2778,6 +2778,7 @@ df_find_hard_reg_defs (rtx x, HARD_REG_SET *defs)\n       break;\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       df_find_hard_reg_defs_1 (XEXP (x, 0), defs);\n       break;\n \n@@ -2837,6 +2838,10 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (REG_P (XEXP (x, 0)));\n+      return;\n+\n     case MEM:\n       df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD,\n@@ -3133,6 +3138,7 @@ df_get_call_refs (struct df_collection_rec *collection_rec,\n   for (note = CALL_INSN_FUNCTION_USAGE (insn_info->insn); note;\n        note = XEXP (note, 1))\n     {\n+      gcc_assert (GET_CODE (XEXP (note, 0)) != CLOBBER_HIGH);\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n \t\t\tDF_REF_REG_USE, bb, insn_info, flags);"}, {"sha": "b67481dd2db477857a4b7da61e43dd43e1c9cc0c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -16321,6 +16321,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n     case CONST_FIXED:\n     case CLRSB:\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       /* If delegitimize_address couldn't do anything with the UNSPEC, we\n \t can't express it in the debug info.  This can happen e.g. with some\n \t TLS UNSPECs.  */"}, {"sha": "4f0221f6f43714fdce9119b76ea2f9fb79b46873", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -529,6 +529,9 @@ haifa_classify_rtx (const_rtx x)\n \t  /* Test if it is a 'store'.  */\n \t  tmp_class = may_trap_exp (XEXP (x, 0), 1);\n \t  break;\n+\tcase CLOBBER_HIGH:\n+\t  gcc_assert (REG_P (XEXP (x, 0)));\n+\t  break;\n \tcase SET:\n \t  /* Test if it is a store.  */\n \t  tmp_class = may_trap_exp (SET_DEST (x), 1);"}, {"sha": "da017be5b3de30d0941476e495479637fe4253b7", "filename": "gcc/ira-build.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1876,6 +1876,11 @@ create_insn_allocnos (rtx x, rtx outer, bool output_p)\n       create_insn_allocnos (XEXP (x, 0), NULL, true);\n       return;\n     }\n+  else if (code == CLOBBER_HIGH)\n+    {\n+      gcc_assert (REG_P (XEXP (x, 0)) && HARD_REGISTER_P (XEXP (x, 0)));\n+      return;\n+    }\n   else if (code == MEM)\n     {\n       create_insn_allocnos (XEXP (x, 0), NULL, false);"}, {"sha": "6fa917ab1a1aade107adb9586c949a62b5d26d95", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1444,6 +1444,13 @@ scan_one_insn (rtx_insn *insn)\n       return insn;\n     }\n \n+  if (pat_code == CLOBBER_HIGH)\n+    {\n+      gcc_assert (REG_P (XEXP (PATTERN (insn), 0))\n+\t\t  && HARD_REGISTER_P (XEXP (PATTERN (insn), 0)));\n+      return insn;\n+    }\n+\n   counted_mem = false;\n   set = single_set (insn);\n   extract_insn (insn);"}, {"sha": "def194a0782ca68a9edd5a0e252d49e18f459e4c", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -3086,6 +3086,7 @@ equiv_init_movable_p (rtx x, int regno)\n \n     case CC0:\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       return 0;\n \n     case PRE_INC:\n@@ -4411,6 +4412,7 @@ rtx_moveable_p (rtx *loc, enum op_type type)\n \t      && rtx_moveable_p (&XEXP (x, 2), OP_IN));\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       return rtx_moveable_p (&SET_DEST (x), OP_OUT);\n \n     case UNSPEC_VOLATILE:\n@@ -4863,7 +4865,9 @@ interesting_dest_for_shprep (rtx_insn *insn, basic_block call_dom)\n   for (int i = 0; i < XVECLEN (pat, 0); i++)\n     {\n       rtx sub = XVECEXP (pat, 0, i);\n-      if (GET_CODE (sub) == USE || GET_CODE (sub) == CLOBBER)\n+      if (GET_CODE (sub) == USE\n+\t  || GET_CODE (sub) == CLOBBER\n+\t  || GET_CODE (sub) == CLOBBER_HIGH)\n \tcontinue;\n       if (GET_CODE (sub) != SET\n \t  || side_effects_p (sub))"}, {"sha": "06f7255d24dbc7fb62374077e7e87e1f4d4be9fa", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1094,6 +1094,7 @@ mark_jump_label_1 (rtx x, rtx_insn *insn, bool in_mem, bool is_target)\n     case CC0:\n     case REG:\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n     case CALL:\n       return;\n "}, {"sha": "afa61dcede62b2f37fb851becde21a51774e965c", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -791,15 +791,18 @@ record_opr_changes (rtx_insn *insn)\n \trecord_last_reg_set_info_regno (insn, regno);\n \n       for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-\tif (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t  {\n-\t    x = XEXP (XEXP (link, 0), 0);\n-\t    if (REG_P (x))\n-\t      {\n-\t\tgcc_assert (HARD_REGISTER_P (x));\n-\t\trecord_last_reg_set_info (insn, x);\n-\t      }\n-\t  }\n+\t{\n+\t  gcc_assert (GET_CODE (XEXP (link, 0)) != CLOBBER_HIGH);\n+\t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t    {\n+\t      x = XEXP (XEXP (link, 0), 0);\n+\t      if (REG_P (x))\n+\t\t{\n+\t\t  gcc_assert (HARD_REGISTER_P (x));\n+\t\t  record_last_reg_set_info (insn, x);\n+\t\t}\n+\t    }\n+\t}\n \n       if (! RTL_CONST_OR_PURE_CALL_P (insn))\n \trecord_last_mem_set_info (insn);"}, {"sha": "56cb14dc6760fc2b57d52c855234402a85067252", "filename": "gcc/postreload.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -133,6 +133,8 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    {\n \t      rtx part = XVECEXP (body, 0, i);\n+\t      /* asms can only have full clobbers, not clobber_highs.  */\n+\t      gcc_assert (GET_CODE (part) != CLOBBER_HIGH);\n \t      if (GET_CODE (part) == CLOBBER && REG_P (XEXP (part, 0)))\n \t\tcselib_invalidate_rtx (XEXP (part, 0));\n \t    }\n@@ -156,6 +158,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \t\t}\n \t    }\n \t  else if (GET_CODE (part) != CLOBBER\n+\t\t   && GET_CODE (part) != CLOBBER_HIGH\n \t\t   && GET_CODE (part) != USE)\n \t    break;\n \t}\n@@ -667,7 +670,8 @@ struct reg_use\n    STORE_RUID is always meaningful if we only want to use a value in a\n    register in a different place: it denotes the next insn in the insn\n    stream (i.e. the last encountered) that sets or clobbers the register.\n-   REAL_STORE_RUID is similar, but clobbers are ignored when updating it.  */\n+   REAL_STORE_RUID is similar, but clobbers are ignored when updating it.\n+   EXPR is the expression used when storing the register.  */\n static struct\n   {\n     struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n@@ -677,6 +681,7 @@ static struct\n     int real_store_ruid;\n     int use_ruid;\n     bool all_offsets_match;\n+    rtx expr;\n   } reg_state[FIRST_PSEUDO_REGISTER];\n \n /* Reverse linear uid.  This is increased in reload_combine while scanning\n@@ -1341,6 +1346,10 @@ reload_combine (void)\n \t    {\n \t      rtx setuse = XEXP (link, 0);\n \t      rtx usage_rtx = XEXP (setuse, 0);\n+\t      /* We could support CLOBBER_HIGH and treat it in the same way as\n+\t\t HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n+\t      gcc_assert (GET_CODE (setuse) != CLOBBER_HIGH);\n+\n \t      if ((GET_CODE (setuse) == USE || GET_CODE (setuse) == CLOBBER)\n \t\t  && REG_P (usage_rtx))\n \t        {\n@@ -1516,6 +1525,10 @@ reload_combine_note_use (rtx *xp, rtx_insn *insn, int ruid, rtx containing_mem)\n \t}\n       break;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (REG_P (SET_DEST (x)));\n+      return;\n+\n     case PLUS:\n       /* We are interested in (plus (reg) (const_int)) .  */\n       if (!REG_P (XEXP (x, 0))\n@@ -2135,6 +2148,9 @@ reload_cse_move2add (rtx_insn *first)\n \t    {\n \t      rtx setuse = XEXP (link, 0);\n \t      rtx usage_rtx = XEXP (setuse, 0);\n+\t      /* CALL_INSN_FUNCTION_USAGEs can only have full clobbers, not\n+\t\t clobber_highs.  */\n+\t      gcc_assert (GET_CODE (setuse) != CLOBBER_HIGH);\n \t      if (GET_CODE (setuse) == CLOBBER\n \t\t  && REG_P (usage_rtx))\n \t        {\n@@ -2297,6 +2313,13 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n \n       move2add_record_mode (dst);\n     }\n+  else if (GET_CODE (set) == CLOBBER_HIGH)\n+    {\n+      /* Only invalidate if actually clobbered.  */\n+      if (reg_mode[regno] == BLKmode\n+\t  || reg_is_clobbered_by_clobber_high (regno, reg_mode[regno], dst))\n+\t goto invalidate;\n+    }\n   else\n     {\n     invalidate:"}, {"sha": "ba9ac02fce71a169fa8fe7bafa973c64b5fdcb9d", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1742,6 +1742,7 @@ print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n       print_exp (pp, x, verbose);\n       break;\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n     case USE:\n       pp_printf (pp, \"%s \", GET_RTX_NAME (GET_CODE (x)));\n       print_value (pp, XEXP (x, 0), verbose);"}, {"sha": "d7c69439683ea8b183069fc0d20ede1a1470831e", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1600,6 +1600,7 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n \t      {\n \t\tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n \t\t  break;\t\t/* Past last SET */\n+\t\tgcc_assert (GET_CODE (XVECEXP (body, 0, i)) == SET);\n \t\tif (operands)\n \t\t  operands[i] = SET_DEST (XVECEXP (body, 0, i));\n \t\tif (operand_locs)\n@@ -3715,7 +3716,8 @@ store_data_bypass_p_1 (rtx_insn *out_insn, rtx in_set)\n     {\n       rtx out_exp = XVECEXP (out_pat, 0, i);\n \n-      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE)\n+      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE\n+\t  || GET_CODE (out_exp) == CLOBBER_HIGH)\n \tcontinue;\n \n       gcc_assert (GET_CODE (out_exp) == SET);\n@@ -3746,7 +3748,8 @@ store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n     {\n       rtx in_exp = XVECEXP (in_pat, 0, i);\n \n-      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE)\n+      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE\n+\t  || GET_CODE (in_exp) == CLOBBER_HIGH)\n \tcontinue;\n \n       gcc_assert (GET_CODE (in_exp) == SET);\n@@ -3798,7 +3801,7 @@ if_test_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n \t{\n \t  rtx exp = XVECEXP (out_pat, 0, i);\n \n-\t  if (GET_CODE (exp) == CLOBBER)\n+\t  if (GET_CODE (exp) == CLOBBER  || GET_CODE (exp) == CLOBBER_HIGH)\n \t    continue;\n \n \t  gcc_assert (GET_CODE (exp) == SET);"}, {"sha": "1f805765b9372ea2bdc8828748834c4208684ca1", "filename": "gcc/regcprop.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -237,7 +237,11 @@ static void\n kill_clobbered_value (rtx x, const_rtx set, void *data)\n {\n   struct value_data *const vd = (struct value_data *) data;\n-  if (GET_CODE (set) == CLOBBER)\n+  gcc_assert (GET_CODE (set) != CLOBBER_HIGH || REG_P (x));\n+\n+  if (GET_CODE (set) == CLOBBER\n+      || (GET_CODE (set) == CLOBBER_HIGH\n+\t  && reg_is_clobbered_by_clobber_high (x, XEXP (set, 0))))\n     kill_value (x, vd);\n }\n \n@@ -257,7 +261,9 @@ kill_set_value (rtx x, const_rtx set, void *data)\n   struct kill_set_value_data *ksvd = (struct kill_set_value_data *) data;\n   if (rtx_equal_p (x, ksvd->ignore_set_reg))\n     return;\n-  if (GET_CODE (set) != CLOBBER)\n+\n+  gcc_assert (GET_CODE (set) != CLOBBER_HIGH || REG_P (x));\n+  if (GET_CODE (set) != CLOBBER && GET_CODE (set) != CLOBBER_HIGH)\n     {\n       kill_value (x, ksvd->vd);\n       if (REG_P (x))"}, {"sha": "1f36d141c73a29a0d015922b5bf804532943bd18", "filename": "gcc/reginfo.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1100,6 +1100,10 @@ reg_scan_mark_refs (rtx x, rtx_insn *insn)\n \treg_scan_mark_refs (XEXP (XEXP (x, 0), 0), insn);\n       break;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (!(MEM_P (XEXP (x, 0))));\n+      break;\n+\n     case SET:\n       /* Count a set of the destination if it is a register.  */\n       for (dest = SET_DEST (x);"}, {"sha": "8e15160c6adc7100944f39dd1d161380cec43466", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1339,6 +1339,8 @@ maybe_fix_stack_asms (void)\n \t  rtx t = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (t) == CLOBBER && STACK_REG_P (XEXP (t, 0)))\n \t    SET_HARD_REG_BIT (clobbered, REGNO (XEXP (t, 0)));\n+\t  /* CLOBBER_HIGH is only supported for LRA.  */\n+\t  gcc_assert (GET_CODE (t) != CLOBBER_HIGH);\n \t}\n \n       /* Get the operand values and constraints out of the insn.  */\n@@ -2879,6 +2881,7 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n       return x;\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n     case ASM_OPERANDS:\n       gcc_assert (insn && DEBUG_INSN_P (insn));\n       break;\n@@ -3089,6 +3092,10 @@ elimination_effects (rtx x, machine_mode mem_mode)\n       elimination_effects (XEXP (x, 0), mem_mode);\n       return;\n \n+    case CLOBBER_HIGH:\n+      /* CLOBBER_HIGH is only supported for LRA.  */\n+      return;\n+\n     case SET:\n       /* Check for setting a register that we know about.  */\n       if (REG_P (SET_DEST (x)))\n@@ -3810,6 +3817,9 @@ mark_not_eliminable (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (dest == hard_frame_pointer_rtx)\n     return;\n \n+  /* CLOBBER_HIGH is only supported for LRA.  */\n+  gcc_assert (GET_CODE (x) != CLOBBER_HIGH);\n+\n   for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n     if (reg_eliminate[i].can_eliminate && dest == reg_eliminate[i].to_rtx\n \t&& (GET_CODE (x) != SET\n@@ -4445,6 +4455,7 @@ scan_paradoxical_subregs (rtx x)\n     case PC:\n     case USE:\n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       return;\n \n     case SUBREG:\n@@ -4899,7 +4910,7 @@ reload_as_needed (int live_known)\n    to be forgotten later.  */\n \n static void\n-forget_old_reloads_1 (rtx x, const_rtx ignored ATTRIBUTE_UNUSED,\n+forget_old_reloads_1 (rtx x, const_rtx setter,\n \t\t      void *data)\n {\n   unsigned int regno;\n@@ -4919,6 +4930,9 @@ forget_old_reloads_1 (rtx x, const_rtx ignored ATTRIBUTE_UNUSED,\n   if (!REG_P (x))\n     return;\n \n+  /* CLOBBER_HIGH is only supported for LRA.  */\n+  gcc_assert (GET_CODE (setter) != CLOBBER_HIGH);\n+\n   regno = REGNO (x);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)"}, {"sha": "f8a986cea1de6cb8142dc5e3c58d2e87af002a42", "filename": "gcc/reorg.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -397,7 +397,8 @@ find_end_label (rtx kind)\n   while (NOTE_P (insn)\n \t || (NONJUMP_INSN_P (insn)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n+\t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t\t || GET_CODE (PATTERN (insn)) == CLOBBER_HIGH)))\n     insn = PREV_INSN (insn);\n \n   /* When a target threads its epilogue we might already have a\n@@ -1297,7 +1298,8 @@ try_merge_delay_insns (rtx_insn *insn, rtx_insn *thread)\n \n       /* TRIAL must be a CALL_INSN or INSN.  Skip USE and CLOBBER.  */\n       if (NONJUMP_INSN_P (trial)\n-\t  && (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER))\n+\t  && (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t      || GET_CODE (pat) == CLOBBER_HIGH))\n \tcontinue;\n \n       if (GET_CODE (next_to_match) == GET_CODE (trial)\n@@ -1491,7 +1493,8 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n       --insns_to_search;\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == CLOBBER_HIGH)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -1589,7 +1592,8 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n       --insns_to_search;\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == CLOBBER_HIGH)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -1701,7 +1705,8 @@ own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n \t|| LABEL_P (insn)\n \t|| (NONJUMP_INSN_P (insn)\n \t    && GET_CODE (PATTERN (insn)) != USE\n-\t    && GET_CODE (PATTERN (insn)) != CLOBBER))\n+\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t    && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH))\n       return 0;\n \n   return 1;\n@@ -2024,7 +2029,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      pat = PATTERN (trial);\n \n \t      /* Stand-alone USE and CLOBBER are just for flow.  */\n-\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t\t  || GET_CODE (pat) == CLOBBER_HIGH)\n \t\tcontinue;\n \n \t      /* And DEBUG_INSNs never go into delay slots.  */\n@@ -2150,7 +2156,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      pat = PATTERN (trial);\n \n \t      /* Stand-alone USE and CLOBBER are just for flow.  */\n-\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t\t  || GET_CODE (pat) == CLOBBER_HIGH)\n \t\tcontinue;\n \n \t      /* And DEBUG_INSNs do not go in delay slots.  */\n@@ -2418,7 +2425,8 @@ fill_slots_from_thread (rtx_jump_insn *insn, rtx condition,\n \t}\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == CLOBBER_HIGH)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -3818,7 +3826,8 @@ dbr_schedule (rtx_insn *first)\n \t  if (! insn->deleted ()\n \t      && NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t\t{"}, {"sha": "fdfab6916d44281fed58c3665e45d3dc34f50cdb", "filename": "gcc/resource.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -108,6 +108,11 @@ update_live_status (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (GET_CODE (x) == CLOBBER)\n     for (i = first_regno; i < last_regno; i++)\n       CLEAR_HARD_REG_BIT (current_live_regs, i);\n+  else if (GET_CODE (x) == CLOBBER_HIGH)\n+    /* No current target supports both branch delay slots and CLOBBER_HIGH.\n+       We'd need more elaborate liveness tracking to handle that\n+       combination.  */\n+    gcc_unreachable ();\n   else\n     for (i = first_regno; i < last_regno; i++)\n       {\n@@ -293,6 +298,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n       return;\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n       return;\n \n     case CALL_INSN:\n@@ -668,9 +674,15 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \n \t  for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n \t       link; link = XEXP (link, 1))\n-\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t      mark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n-\t\t\t\t  MARK_SRC_DEST);\n+\t    {\n+\t      /* We could support CLOBBER_HIGH and treat it in the same way as\n+\t\t HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that\n+\t\t yet.  */\n+\t      gcc_assert (GET_CODE (XEXP (link, 0)) != CLOBBER_HIGH);\n+\t      if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t\tmark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n+\t\t\t\t    MARK_SRC_DEST);\n+\t    }\n \n \t  /* Check for a REG_SETJMP.  If it exists, then we must\n \t     assume that this call can clobber any register.  */\n@@ -713,6 +725,12 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n       mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n \n+    case CLOBBER_HIGH:\n+      /* No current target supports both branch delay slots and CLOBBER_HIGH.\n+\t We'd need more elaborate liveness tracking to handle that\n+\t combination.  */\n+      gcc_unreachable ();\n+\n     case SEQUENCE:\n       {\n         rtx_sequence *seq = as_a <rtx_sequence *> (x);"}, {"sha": "f9146afcf2c55164dc8be41f82cc1f312889b388", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -304,6 +304,10 @@ copy_rtx (rtx orig)\n \treturn orig;\n       break;\n \n+    case CLOBBER_HIGH:\n+\tgcc_assert (REG_P (XEXP (orig, 0)));\n+\treturn orig;\n+\n     case CONST:\n       if (shared_const_p (orig))\n \treturn orig;"}, {"sha": "6c620a4a3e50017a72ebab51710f32727500941d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -1198,6 +1198,10 @@ reg_referenced_p (const_rtx x, const_rtx body)\n \t  return 1;\n       return 0;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (REG_P (XEXP (body, 0)));\n+      return 0;\n+\n     case COND_EXEC:\n       if (reg_overlap_mentioned_p (x, COND_EXEC_TEST (body)))\n \treturn 1;\n@@ -1420,7 +1424,11 @@ set_of_1 (rtx x, const_rtx pat, void *data1)\n {\n   struct set_of_data *const data = (struct set_of_data *) (data1);\n   if (rtx_equal_p (x, data->pat)\n-      || (!MEM_P (x) && reg_overlap_mentioned_p (data->pat, x)))\n+      || (GET_CODE (pat) == CLOBBER_HIGH\n+\t  && REGNO(data->pat) == REGNO(XEXP (pat, 0))\n+\t  && reg_is_clobbered_by_clobber_high (data->pat, XEXP (pat, 0)))\n+      || (GET_CODE (pat) != CLOBBER_HIGH && !MEM_P (x)\n+\t  && reg_overlap_mentioned_p (data->pat, x)))\n     data->found = pat;\n }\n \n@@ -1509,6 +1517,7 @@ single_set_2 (const rtx_insn *insn, const_rtx pat)\n \t    {\n \t    case USE:\n \t    case CLOBBER:\n+\t    case CLOBBER_HIGH:\n \t      break;\n \n \t    case SET:\n@@ -1663,7 +1672,8 @@ noop_move_p (const rtx_insn *insn)\n \t  rtx tem = XVECEXP (pat, 0, i);\n \n \t  if (GET_CODE (tem) == USE\n-\t      || GET_CODE (tem) == CLOBBER)\n+\t      || GET_CODE (tem) == CLOBBER\n+\t      || GET_CODE (tem) == CLOBBER_HIGH)\n \t    continue;\n \n \t  if (GET_CODE (tem) != SET || ! set_noop_p (tem))\n@@ -1895,7 +1905,9 @@ note_stores (const_rtx x, void (*fun) (rtx, const_rtx, void *), void *data)\n   if (GET_CODE (x) == COND_EXEC)\n     x = COND_EXEC_CODE (x);\n \n-  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n+  if (GET_CODE (x) == SET\n+      || GET_CODE (x) == CLOBBER\n+      || GET_CODE (x) == CLOBBER_HIGH)\n     {\n       rtx dest = SET_DEST (x);\n "}, {"sha": "f89f28269fd5ecf96688ed255d07b6976d2180c4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df47bdf99b8eb5d68736fe058559899c4270e4f/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=8df47bdf99b8eb5d68736fe058559899c4270e4f", "patch": "@@ -2319,6 +2319,13 @@ sched_analyze_reg (struct deps_desc *deps, int regno, machine_mode mode,\n \t  while (--i >= 0)\n \t    note_reg_use (regno + i);\n \t}\n+      else if (ref == CLOBBER_HIGH)\n+\t{\n+\t  gcc_assert (i == 1);\n+\t  /* We don't know the current state of the register, so have to treat\n+\t     the clobber high as a full clobber.  */\n+\t  note_reg_clobber (regno);\n+\t}\n       else\n \t{\n \t  while (--i >= 0)\n@@ -2342,6 +2349,8 @@ sched_analyze_reg (struct deps_desc *deps, int regno, machine_mode mode,\n       else if (ref == USE)\n \tnote_reg_use (regno);\n       else\n+\t/* For CLOBBER_HIGH, we don't know the current state of the register,\n+\t   so have to treat it as a full clobber.  */\n \tnote_reg_clobber (regno);\n \n       /* Pseudos that are REG_EQUIV to something may be replaced\n@@ -2962,7 +2971,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t      sub = COND_EXEC_CODE (sub);\n \t      code = GET_CODE (sub);\n \t    }\n-\t  if (code == SET || code == CLOBBER)\n+\t  else if (code == SET || code == CLOBBER || code == CLOBBER_HIGH)\n \t    sched_analyze_1 (deps, sub, insn);\n \t  else\n \t    sched_analyze_2 (deps, sub, insn);\n@@ -2978,6 +2987,10 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t{\n \t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n \t    sched_analyze_1 (deps, XEXP (link, 0), insn);\n+\t  else if (GET_CODE (XEXP (link, 0)) == CLOBBER_HIGH)\n+\t    /* We could support CLOBBER_HIGH and treat it in the same way as\n+\t      HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n+\t    gcc_unreachable ();\n \t  else if (GET_CODE (XEXP (link, 0)) != SET)\n \t    sched_analyze_2 (deps, XEXP (link, 0), insn);\n \t}"}]}