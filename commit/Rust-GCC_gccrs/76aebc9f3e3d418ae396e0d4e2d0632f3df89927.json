{"sha": "76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhZWJjOWYzZTNkNDE4YWUzOTZlMGQ0ZTJkMDYzMmYzZGY4OTkyNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-22T11:42:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-22T11:42:30Z"}, "message": "re PR c++/18095 (ICE in cp_lexer_consume_token on missing \";\")\n\ncp:\n\tPR c++/18095\n\t* parser.c (eof_token): Make const, correctly initialize rid and\n\tlocation fields.\n\t(struct cp_lexer): Replace buffer_end pointer with buffer_length\n\tcount. Adjust.\n\t(cp_lexer_new_main): Directly grow lexer's buffer here.  Don't\n\tzero it out.\n\t(cp_lexer_new_from_tokens): Adjust.\n\t(cp_lexer_grow_buffer): Remove.\n\t(cp_lexer_peek_nth_token, cp_lexer_consume_token,\n\tcp_lexer_purge_token): Add const casts.\ntestsuite:\n\tPR c++/18095\n\t* g++.dg/parse/crash18.C: New.\n\t* g++.dg/parse/crash19.C: New.\n\nFrom-SVN: r89439", "tree": {"sha": "eec4e88cf5defc14069be13e67e934ba7f9b5a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec4e88cf5defc14069be13e67e934ba7f9b5a69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/comments", "author": null, "committer": null, "parents": [{"sha": "26630a99dafdef4cd1bba28af0b37bc47d8aed13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26630a99dafdef4cd1bba28af0b37bc47d8aed13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26630a99dafdef4cd1bba28af0b37bc47d8aed13"}], "stats": {"total": 149, "additions": 85, "deletions": 64}, "files": [{"sha": "b5dae4983e1740abe9df2fb65ca73f0ba8565fbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "patch": "@@ -1,3 +1,17 @@\n+2004-10-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18095\n+\t* parser.c (eof_token): Make const, correctly initialize rid and\n+\tlocation fields.\n+\t(struct cp_lexer): Replace buffer_end pointer with buffer_length\n+\tcount. Adjust.\n+\t(cp_lexer_new_main): Directly grow lexer's buffer here.  Don't\n+\tzero it out.\n+\t(cp_lexer_new_from_tokens): Adjust.\n+\t(cp_lexer_grow_buffer): Remove.\n+\t(cp_lexer_peek_nth_token, cp_lexer_consume_token,\n+\tcp_lexer_purge_token): Add const casts.\n+\n 2004-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/18073"}, {"sha": "7109862b2dddcbe3a200d4be261ae511f71bfb30", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 51, "deletions": 64, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "patch": "@@ -67,7 +67,15 @@ typedef struct cp_token GTY (())\n typedef struct cp_token *cp_token_position;\n DEF_VEC_MALLOC_P (cp_token_position);\n \n-static cp_token eof_token = {CPP_EOF, 0, 0, 0, 0, NULL_TREE, {0, 0}};\n+static const cp_token eof_token =\n+{\n+  CPP_EOF, RID_MAX, 0, 0, 0, NULL_TREE,\n+#if USE_MAPPED_LOCATION\n+  0\n+#else\n+  {0, 0}\n+#endif\n+};\n \n /* The cp_lexer structure represents the C++ lexer.  It is responsible\n    for managing the token stream from the preprocessor and supplying\n@@ -78,10 +86,10 @@ typedef struct cp_lexer GTY (())\n {\n   /* The memory allocated for the buffer.  NULL if this lexer does not\n      own the token buffer.  */\n-  cp_token * GTY ((length (\"(%h.buffer_end - %h.buffer)\"))) buffer;\n-  /* If non-null, a pointer just past the end of the memory allocated\n-     for the buffer.  */\n-  cp_token * GTY ((skip)) buffer_end;\n+  cp_token * GTY ((length (\"%h.buffer_length\"))) buffer;\n+  /* If the lexer owns the buffer, this is the number of tokens in the\n+     buffer.  */\n+  size_t buffer_length;\n   \n   /* A pointer just past the last available token.  The tokens\n      in this lexer are [buffer, last_token). */\n@@ -133,8 +141,6 @@ static cp_token_position cp_lexer_token_position\n   (cp_lexer *, bool);\n static cp_token *cp_lexer_token_at\n   (cp_lexer *, cp_token_position);\n-static void cp_lexer_grow_buffer\n-  (cp_lexer *);\n static void cp_lexer_get_preprocessor_token\n   (cp_lexer *, cp_token *);\n static inline cp_token *cp_lexer_peek_token\n@@ -224,8 +230,12 @@ static FILE *cp_lexer_debug_stream;\n static cp_lexer *\n cp_lexer_new_main (void)\n {\n-  cp_lexer *lexer;\n   cp_token first_token;\n+  cp_lexer *lexer;\n+  cp_token *pos;\n+  size_t alloc;\n+  size_t space;\n+  cp_token *buffer;\n \n   /* Tell cpplib we want CPP_PRAGMA tokens. */\n   cpp_get_options (parse_in)->defer_pragmas = true;\n@@ -242,30 +252,38 @@ cp_lexer_new_main (void)\n   /* Allocate the memory.  */\n   lexer = GGC_CNEW (cp_lexer);\n \n-  /* Create the buffer.  */\n-  lexer->buffer = ggc_calloc (CP_LEXER_BUFFER_SIZE, sizeof (cp_token));\n-  lexer->buffer_end = lexer->buffer + CP_LEXER_BUFFER_SIZE;\n- \n-  /* There is one token in the buffer.  */\n-  lexer->last_token = lexer->buffer;\n-  lexer->next_token = lexer->buffer;\n-  *lexer->next_token = first_token;\n-\n-  lexer->saved_tokens = VEC_alloc (cp_token_position, CP_SAVED_TOKEN_STACK);\n-\n #ifdef ENABLE_CHECKING  \n   /* Initially we are not debugging.  */\n   lexer->debugging_p = false;\n #endif /* ENABLE_CHECKING */\n+  lexer->saved_tokens = VEC_alloc (cp_token_position, CP_SAVED_TOKEN_STACK);\n+\t \n+  /* Create the buffer.  */\n+  alloc = CP_LEXER_BUFFER_SIZE;\n+  buffer = ggc_alloc (alloc * sizeof (cp_token));\n \n-  /* Get the rest of the tokens from the preprocessor. */\n-  while (lexer->last_token->type != CPP_EOF)\n+  /* Put the first token in the buffer.  */\n+  space = alloc;\n+  pos = buffer;\n+  *pos = first_token;\n+  \n+  /* Get the remaining tokens from the preprocessor. */\n+  while (pos->type != CPP_EOF)\n     {\n-      lexer->last_token++;\n-      if (lexer->last_token == lexer->buffer_end)\n-\tcp_lexer_grow_buffer (lexer);\n-      cp_lexer_get_preprocessor_token (lexer, lexer->last_token);\n+      pos++;\n+      if (!--space)\n+\t{\n+\t  space = alloc;\n+\t  alloc *= 2;\n+\t  buffer = ggc_realloc (buffer, alloc * sizeof (cp_token));\n+\t  pos = buffer + space;\n+\t}\n+      cp_lexer_get_preprocessor_token (lexer, pos);\n     }\n+  lexer->buffer = buffer;\n+  lexer->buffer_length = alloc - space;\n+  lexer->last_token = pos;\n+  lexer->next_token = lexer->buffer_length ? buffer : (cp_token *)&eof_token;\n \n   /* Pragma processing (via cpp_handle_deferred_pragma) may result in\n      direct calls to c_lex.  Those callers all expect c_lex to do\n@@ -287,8 +305,9 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   cp_lexer *lexer = GGC_CNEW (cp_lexer);\n \n   /* We do not own the buffer.  */\n-  lexer->buffer = lexer->buffer_end = NULL;\n-  lexer->next_token = first == last ? &eof_token : first;\n+  lexer->buffer = NULL;\n+  lexer->buffer_length = 0;\n+  lexer->next_token = first == last ? (cp_token *)&eof_token : first;\n   lexer->last_token = last;\n   \n   lexer->saved_tokens = VEC_alloc (cp_token_position, CP_SAVED_TOKEN_STACK);\n@@ -347,40 +366,8 @@ cp_lexer_saving_tokens (const cp_lexer* lexer)\n   return VEC_length (cp_token_position, lexer->saved_tokens) != 0;\n }\n \n-/* If the buffer is full, make it bigger.  */\n-static void\n-cp_lexer_grow_buffer (cp_lexer* lexer)\n-{\n-  cp_token *old_buffer;\n-  cp_token *new_buffer;\n-  ptrdiff_t buffer_length;\n-\n-  /* This function should only be called when buffer is full. */\n-  gcc_assert (lexer->last_token == lexer->buffer_end);\n-\n-  /* Remember the current buffer pointer.  It will become invalid,\n-     but we will need to do pointer arithmetic involving this\n-     value.  */\n-  old_buffer = lexer->buffer;\n-  /* Compute the current buffer size.  */\n-  buffer_length = lexer->buffer_end - lexer->buffer;\n-  /* Allocate a buffer twice as big.  */\n-  new_buffer = ggc_realloc (lexer->buffer,\n-\t\t\t    2 * buffer_length * sizeof (cp_token));\n-\n-  /* Recompute buffer positions. */\n-  lexer->buffer = new_buffer;\n-  lexer->buffer_end = new_buffer + 2 * buffer_length;\n-  lexer->last_token = new_buffer + (lexer->last_token - old_buffer);\n-  lexer->next_token = new_buffer + (lexer->next_token - old_buffer);\n-\n-  /* Clear the rest of the buffer.  We never look at this storage,\n-     but the garbage collector may.  */\n-  memset (lexer->last_token, 0,\n-\t  (lexer->buffer_end - lexer->last_token) * sizeof(cp_token));\n-}\n-\n-/* Store the next token from the preprocessor in *TOKEN.  */\n+/* Store the next token from the preprocessor in *TOKEN.  Return true\n+   if we reach EOF.  */\n \n static void\n cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n@@ -519,7 +506,7 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n       ++token;\n       if (token == lexer->last_token)\n \t{\n-\t  token = &eof_token;\n+\t  token = (cp_token *)&eof_token;\n \t  break;\n \t}\n       \n@@ -551,7 +538,7 @@ cp_lexer_consume_token (cp_lexer* lexer)\n       lexer->next_token++;\n       if (lexer->next_token == lexer->last_token)\n \t{\n-\t  lexer->next_token = &eof_token;\n+\t  lexer->next_token = (cp_token *)&eof_token;\n \t  break;\n \t}\n       \n@@ -591,7 +578,7 @@ cp_lexer_purge_token (cp_lexer *lexer)\n       tok++;\n       if (tok == lexer->last_token)\n \t{\n-\t  tok = &eof_token;\n+\t  tok = (cp_token *)&eof_token;\n \t  break;\n \t}\n     }"}, {"sha": "205676bc04b3ed64eb043342fda24e378b87031e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "patch": "@@ -1,3 +1,9 @@\n+2004-10-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18095\n+\t* g++.dg/parse/crash18.C: New.\n+\t* g++.dg/parse/crash19.C: New.\n+\n 2004-10-22  Aaron W. LaFramboise  <aaronavay62@aaronwl.com>\n \n \t* g++.dg/ext/dllimport1.C: Move dg-warnings."}, {"sha": "94be360ab1d4eb53414cc6744500bce0a72222ec", "filename": "gcc/testsuite/g++.dg/parse/crash18.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash18.C?ref=76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "patch": "@@ -0,0 +1,7 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 20 Oct 2004 <nathan@codesourcery.com>\n+\n+// PR 18095: ICE\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+struct A // { dg-error \"expected\" \"\" }"}, {"sha": "cc50d9507e83927b623fa35fbda3881e0042cf37", "filename": "gcc/testsuite/g++.dg/parse/crash19.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76aebc9f3e3d418ae396e0d4e2d0632f3df89927/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash19.C?ref=76aebc9f3e3d418ae396e0d4e2d0632f3df89927", "patch": "@@ -0,0 +1,7 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 20 Oct 2004 <nathan@codesourcery.com>\n+\n+// PR 18095: ICE\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+struct A {} // { dg-error \"expected\" \"\" }"}]}