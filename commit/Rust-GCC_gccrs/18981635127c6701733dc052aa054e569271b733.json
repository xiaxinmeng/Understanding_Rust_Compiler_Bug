{"sha": "18981635127c6701733dc052aa054e569271b733", "node_id": "C_kwDOANBUbNoAKDE4OTgxNjM1MTI3YzY3MDE3MzNkYzA1MmFhMDU0ZTU2OTI3MWI3MzM", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-14T02:18:45Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-14T02:18:45Z"}, "message": "c: C2x storage class specifiers in compound literals\n\nImplement the C2x feature of storage class specifiers in compound\nliterals.  Such storage class specifiers (static, register or\nthread_local; also constexpr, but we don't yet have C2x constexpr\nsupport implemented) can be used before the type name (not mixed with\ntype specifiers, unlike in declarations) and have the same semantics\nand constraints as for declarations of named objects.  Also allow GNU\n__thread to be used, given that thread_local can be.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c/\n\t* c-decl.cc (build_compound_literal): Add parameter scspecs.\n\tHandle storage class specifiers.\n\t* c-parser.cc (c_token_starts_compound_literal)\n\t(c_parser_compound_literal_scspecs): New.\n\t(c_parser_postfix_expression_after_paren_type): Add parameter\n\tscspecs.  Call pedwarn_c11 for use of storage class specifiers.\n\tUpdate call to build_compound_literal.\n\t(c_parser_cast_expression, c_parser_sizeof_expression)\n\t(c_parser_alignof_expression): Handle storage class specifiers for\n\tcompound literals.  Update calls to\n\tc_parser_postfix_expression_after_paren_type.\n\t(c_parser_postfix_expression): Update syntax comment.\n\t* c-tree.h (build_compound_literal): Update prototype.\n\t* c-typeck.cc (c_mark_addressable): Diagnose taking address of\n\tregister compound literal.\n\ngcc/testsuite/\n\t* gcc.dg/c11-complit-1.c, gcc.dg/c11-complit-2.c,\n\tgcc.dg/c11-complit-3.c, gcc.dg/c2x-complit-2.c,\n\tgcc.dg/c2x-complit-3.c, gcc.dg/c2x-complit-4.c,\n\tgcc.dg/c2x-complit-5.c, gcc.dg/c2x-complit-6.c,\n\tgcc.dg/c2x-complit-7.c, gcc.dg/c90-complit-2.c,\n\tgcc.dg/gnu2x-complit-1.c, gcc.dg/gnu2x-complit-2.c: New tests.", "tree": {"sha": "b4195c597f07b1ad29a276cfdc7edaa60fb21972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4195c597f07b1ad29a276cfdc7edaa60fb21972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18981635127c6701733dc052aa054e569271b733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18981635127c6701733dc052aa054e569271b733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18981635127c6701733dc052aa054e569271b733", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18981635127c6701733dc052aa054e569271b733/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621a911d336279d21e1e857cfead09af1c61df39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621a911d336279d21e1e857cfead09af1c61df39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621a911d336279d21e1e857cfead09af1c61df39"}], "stats": {"total": 383, "additions": 369, "deletions": 14}, "files": [{"sha": "a7571cc75424cd2d7430558acdb5896edfb4213f", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -6048,34 +6048,61 @@ mark_forward_parm_decls (void)\n    literal.  NON_CONST is true if the initializers contain something\n    that cannot occur in a constant expression.  If ALIGNAS_ALIGN is nonzero,\n    it is the (valid) alignment for this compound literal, as specified\n-   with _Alignas.  */\n+   with _Alignas.  SCSPECS are the storage class specifiers (C2x) from the\n+   compound literal.  */\n \n tree\n build_compound_literal (location_t loc, tree type, tree init, bool non_const,\n-\t\t\tunsigned int alignas_align)\n+\t\t\tunsigned int alignas_align,\n+\t\t\tstruct c_declspecs *scspecs)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n      the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_EXPR.  */\n   tree decl;\n   tree complit;\n   tree stmt;\n+  bool threadp = scspecs ? scspecs->thread_p : false;\n+  enum c_storage_class storage_class = (scspecs\n+\t\t\t\t\t? scspecs->storage_class\n+\t\t\t\t\t: csc_none);\n \n   if (type == error_mark_node\n       || init == error_mark_node)\n     return error_mark_node;\n \n+  if (current_scope == file_scope && storage_class == csc_register)\n+    {\n+      error_at (loc, \"file-scope compound literal specifies %<register%>\");\n+      storage_class = csc_none;\n+    }\n+\n+  if (current_scope != file_scope && threadp && storage_class == csc_none)\n+    {\n+      error_at (loc, \"compound literal implicitly auto and declared %qs\",\n+\t\tscspecs->thread_gnu_p ? \"__thread\" : \"_Thread_local\");\n+      threadp = false;\n+    }\n+\n   decl = build_decl (loc, VAR_DECL, NULL_TREE, type);\n   DECL_EXTERNAL (decl) = 0;\n   TREE_PUBLIC (decl) = 0;\n-  TREE_STATIC (decl) = (current_scope == file_scope);\n+  TREE_STATIC (decl) = (current_scope == file_scope\n+\t\t\t|| storage_class == csc_static);\n   DECL_CONTEXT (decl) = current_function_decl;\n   TREE_USED (decl) = 1;\n   DECL_READ_P (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   C_DECL_COMPOUND_LITERAL_P (decl) = 1;\n   TREE_TYPE (decl) = type;\n+  if (threadp)\n+    set_decl_tls_model (decl, decl_default_tls_model (decl));\n+  if (storage_class == csc_register)\n+    {\n+      C_DECL_REGISTER (decl) = 1;\n+      DECL_REGISTER (decl) = 1;\n+    }\n   c_apply_type_quals_to_decl (TYPE_QUALS (strip_array_types (type)), decl);\n   if (alignas_align)\n     {"}, {"sha": "602e0235f2dab0f617d42041b4f14579c536eb63", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -666,6 +666,30 @@ c_parser_next_tokens_start_typename (c_parser *parser, enum c_lookahead_kind la)\n   return false;\n }\n \n+/* Return true if TOKEN, after an open parenthesis, can start a\n+   compound literal (either a storage class specifier allowed in that\n+   context, or a type name), false otherwise.  */\n+static bool\n+c_token_starts_compound_literal (c_token *token)\n+{\n+  switch (token->type)\n+    {\n+    case CPP_KEYWORD:\n+      switch (token->keyword)\n+\t{\n+\tcase RID_REGISTER:\n+\tcase RID_STATIC:\n+\tcase RID_THREAD:\n+\t  return true;\n+\tdefault:\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+    default:\n+      return c_token_starts_typename (token);\n+    }\n+}\n+\n /* Return true if TOKEN is a type qualifier, false otherwise.  */\n static bool\n c_token_is_qualifier (c_token *token)\n@@ -1563,6 +1587,7 @@ static struct c_expr c_parser_sizeof_expression (c_parser *);\n static struct c_expr c_parser_alignof_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression (c_parser *);\n static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n+\t\t\t\t\t\t\t\t   struct c_declspecs *,\n \t\t\t\t\t\t\t\t   struct c_type_name *,\n \t\t\t\t\t\t\t\t   location_t);\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n@@ -8237,6 +8262,34 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n #undef POP\n }\n \n+/* Parse any storage class specifiers after an open parenthesis in a\n+   context where a compound literal is permitted.  */\n+\n+static struct c_declspecs *\n+c_parser_compound_literal_scspecs (c_parser *parser)\n+{\n+  bool seen_scspec = false;\n+  struct c_declspecs *specs = build_null_declspecs ();\n+  while (c_parser_next_token_is (parser, CPP_KEYWORD))\n+    {\n+      switch (c_parser_peek_token (parser)->keyword)\n+\t{\n+\tcase RID_REGISTER:\n+\tcase RID_STATIC:\n+\tcase RID_THREAD:\n+\t  seen_scspec = true;\n+\t  declspecs_add_scspec (c_parser_peek_token (parser)->location,\n+\t\t\t\tspecs, c_parser_peek_token (parser)->value);\n+\t  c_parser_consume_token (parser);\n+\t  break;\n+\tdefault:\n+\t  goto out;\n+\t}\n+    }\n+ out:\n+  return seen_scspec ? specs : NULL;\n+}\n+\n /* Parse a cast expression (C90 6.3.4, C99 6.5.4, C11 6.5.4).  If AFTER\n    is not NULL then it is an Objective-C message expression which is the\n    primary-expression starting the expression as an initializer.\n@@ -8260,13 +8313,15 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n      an unary expression.  Full detection of unknown typenames here\n      would require a 3-token lookahead.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       struct c_expr expr;\n       matching_parens parens;\n       parens.consume_open (parser);\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n@@ -8281,8 +8336,11 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       used_types_insert (type_name->specs->type);\n \n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-\treturn c_parser_postfix_expression_after_paren_type (parser, type_name,\n+\treturn c_parser_postfix_expression_after_paren_type (parser, scspecs,\n+\t\t\t\t\t\t\t     type_name,\n \t\t\t\t\t\t\t     cast_loc);\n+      if (scspecs)\n+\terror_at (cast_loc, \"storage class specifier in cast\");\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in cast\");\n@@ -8485,14 +8543,16 @@ c_parser_sizeof_expression (c_parser *parser)\n   c_inhibit_evaluation_warnings++;\n   in_sizeof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n       /* Either sizeof ( type-name ) or sizeof unary-expression\n \t starting with a compound literal.  */\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       matching_parens parens;\n       parens.consume_open (parser);\n       expr_loc = c_parser_peek_token (parser)->location;\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       parens.skip_until_found_close (parser);\n       finish = parser->tokens_buf[0].location;\n@@ -8508,13 +8568,15 @@ c_parser_sizeof_expression (c_parser *parser)\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n-\t  expr = c_parser_postfix_expression_after_paren_type (parser,\n+\t  expr = c_parser_postfix_expression_after_paren_type (parser, scspecs,\n \t\t\t\t\t\t\t       type_name,\n \t\t\t\t\t\t\t       expr_loc);\n \t  finish = expr.get_finish ();\n \t  goto sizeof_expr;\n \t}\n       /* sizeof ( type-name ).  */\n+      if (scspecs)\n+\terror_at (expr_loc, \"storage class specifier in %<sizeof%>\");\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in %<sizeof%>\");\n@@ -8572,16 +8634,18 @@ c_parser_alignof_expression (c_parser *parser)\n   c_inhibit_evaluation_warnings++;\n   in_alignof++;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n-      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+      && c_token_starts_compound_literal (c_parser_peek_2nd_token (parser)))\n     {\n       /* Either __alignof__ ( type-name ) or __alignof__\n \t unary-expression starting with a compound literal.  */\n       location_t loc;\n+      struct c_declspecs *scspecs;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       matching_parens parens;\n       parens.consume_open (parser);\n       loc = c_parser_peek_token (parser)->location;\n+      scspecs = c_parser_compound_literal_scspecs (parser);\n       type_name = c_parser_type_name (parser, true);\n       end_loc = c_parser_peek_token (parser)->location;\n       parens.skip_until_found_close (parser);\n@@ -8597,12 +8661,14 @@ c_parser_alignof_expression (c_parser *parser)\n \t}\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t{\n-\t  expr = c_parser_postfix_expression_after_paren_type (parser,\n+\t  expr = c_parser_postfix_expression_after_paren_type (parser, scspecs,\n \t\t\t\t\t\t\t       type_name,\n \t\t\t\t\t\t\t       loc);\n \t  goto alignof_expr;\n \t}\n       /* alignof ( type-name ).  */\n+      if (scspecs)\n+\terror_at (loc, \"storage class specifier in %qE\", alignof_spelling);\n       if (type_name->specs->alignas_p)\n \terror_at (type_name->specs->locations[cdw_alignas],\n \t\t  \"alignment specified for type name in %qE\",\n@@ -9140,8 +9206,8 @@ c_parser_predefined_identifier (c_parser *parser)\n      postfix-expression -> identifier\n      postfix-expression ++\n      postfix-expression --\n-     ( type-name ) { initializer-list }\n-     ( type-name ) { initializer-list , }\n+     ( storage-class-specifiers[opt] type-name ) { initializer-list[opt] }\n+     ( storage-class-specifiers[opt] type-name ) { initializer-list , }\n \n    argument-expression-list:\n      argument-expression\n@@ -10483,6 +10549,7 @@ c_parser_postfix_expression (c_parser *parser)\n \n static struct c_expr\n c_parser_postfix_expression_after_paren_type (c_parser *parser,\n+\t\t\t\t\t      struct c_declspecs *scspecs,\n \t\t\t\t\t      struct c_type_name *type_name,\n \t\t\t\t\t      location_t type_loc)\n {\n@@ -10515,7 +10582,11 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n       type = error_mark_node;\n     }\n \n-  pedwarn_c90 (start_loc, OPT_Wpedantic, \"ISO C90 forbids compound literals\");\n+  if (!pedwarn_c90 (start_loc, OPT_Wpedantic,\n+\t\t    \"ISO C90 forbids compound literals\") && scspecs)\n+    pedwarn_c11 (start_loc, OPT_Wpedantic,\n+\t\t \"ISO C forbids storage class specifiers in compound literals \"\n+\t\t \"before C2X\");\n   non_const = ((init.value && TREE_CODE (init.value) == CONSTRUCTOR)\n \t       ? CONSTRUCTOR_NON_CONST (init.value)\n \t       : init.original_code == C_MAYBE_CONST_EXPR);\n@@ -10534,7 +10605,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t}\n     }\n   expr.value = build_compound_literal (start_loc, type, init.value, non_const,\n-\t\t\t\t       alignas_align);\n+\t\t\t\t       alignas_align, scspecs);\n   set_c_expr_source_range (&expr, init.src_range);\n   expr.m_decimal = 0;\n   expr.original_code = ERROR_MARK;"}, {"sha": "e7cdd2f11dc184905d868972fe03e3f778ea36d6", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -734,7 +734,7 @@ extern void set_init_label (location_t, tree, location_t, struct obstack *);\n extern void process_init_element (location_t, struct c_expr, bool,\n \t\t\t\t  struct obstack *);\n extern tree build_compound_literal (location_t, tree, tree, bool,\n-\t\t\t\t    unsigned int);\n+\t\t\t\t    unsigned int, struct c_declspecs *);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_switch (location_t, location_t, tree, bool);\n extern void c_finish_switch (tree, tree);"}, {"sha": "017658070f4ae928c921ec211a23d062ab52d1e6", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -5114,6 +5114,11 @@ c_mark_addressable (tree exp, bool array_ref_p)\n \tbreak;\n \n       case COMPOUND_LITERAL_EXPR:\n+\tif (C_DECL_REGISTER (COMPOUND_LITERAL_EXPR_DECL (x)))\n+\t  {\n+\t    error (\"address of register compound literal requested\");\n+\t    return false;\n+\t  }\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (x)) = 1;\n \treturn true;"}, {"sha": "e191cebbb6adc1b99634d776cffeffe921b86eee", "filename": "gcc/testsuite/gcc.dg/c11-complit-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-1.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals not permitted for\n+   C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+int *ps = &(static int) { 1 }; /* { dg-error \"forbids storage class specifiers in compound literals\" } */\n+int ss = sizeof (static int) { 1 }; /* { dg-error \"forbids storage class specifiers in compound literals\" } */"}, {"sha": "d4d1f16f62e659c4095af6538d936be5170f841c", "filename": "gcc/testsuite/gcc.dg/c11-complit-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-2.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals not permitted for\n+   C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic\" } */\n+\n+int *ps = &(static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */\n+int ss = sizeof (static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */"}, {"sha": "a73a8ef8ae1cd3e94927fcb2b17763b1f3705552", "filename": "gcc/testsuite/gcc.dg/c11-complit-3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-complit-3.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals not permitted for\n+   C11, but -Wno-c11-c2x-compat disables the -pedantic diagnostic for that.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors -Wno-c11-c2x-compat\" } */\n+\n+int *ps = &(static int) { 1 };\n+int ss = sizeof (static int) { 1 };"}, {"sha": "dcca5e8d34852dc8e410eb72eb84bed56077c7e3", "filename": "gcc/testsuite/gcc.dg/c2x-complit-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-2.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,48 @@\n+/* Test C2x storage class specifiers in compound literals.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+#include <stddef.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+/* static is OK (although redundant) at file scope.  */\n+int *ps = &(static int) { 1 };\n+size_t ss = sizeof (static int) { 1 };\n+int *psa = (static int [3]) { 1, 2, 3 };\n+\n+int\n+main ()\n+{\n+  if (ps[0] != 1)\n+    abort ();\n+  if (ss != sizeof (int))\n+    abort ();\n+  if (psa[0] != 1 || psa[1] != 2 || psa[2] != 3)\n+    abort ();\n+  if ((register int) { 3 } != 3)\n+    abort ();\n+  /* A static compound literal, like a static variable, is initialized once,\n+     but an automatic compound literal is initialized every time it is reached\n+     in the order of execution.  */\n+  int i = 0;\n+ lab:\n+  int *p = &(static int) { 0 };\n+  if (*p != i)\n+    abort ();\n+  i++;\n+  *p = i;\n+  if (i < 5)\n+    goto lab;\n+  i = 0;\n+ lab2:\n+  int *p2 = &(int) { 0 };\n+  if (*p2 != 0)\n+    abort ();\n+  i++;\n+  *p2 = i;\n+  if (i < 5)\n+    goto lab2;\n+  exit (0);\n+}"}, {"sha": "c672525ba6f608179dfa1abd551c4d0cfa4789af", "filename": "gcc/testsuite/gcc.dg/c2x-complit-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-3.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,24 @@\n+/* Test C2x storage class specifiers in compound literals.  Thread-local\n+   cases, compilation tests.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+/* { dg-require-effective-target tls } */\n+\n+#include <stddef.h>\n+\n+/* thread_local is OK at file scope, although of limited use since the\n+   thread-local object and its address are not constant expressions.  */\n+size_t st = sizeof (thread_local int) { 1 };\n+size_t sst = sizeof (static thread_local int) { 1 };\n+\n+int *\n+f ()\n+{\n+  return &(static thread_local int) { 2 };\n+}\n+\n+int *\n+g ()\n+{\n+  return &(thread_local static int) { 3 };\n+}"}, {"sha": "31d741325d9f98187338a56d3d064696b49c325d", "filename": "gcc/testsuite/gcc.dg/c2x-complit-4.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-4.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,60 @@\n+/* Test C2x storage class specifiers in compound literals.  Thread-local\n+   cases, execution tests.  */\n+/* { dg-do run } */\n+/* { dg-options \"-pthread -std=gnu2x -pedantic-errors\" } */\n+/* { dg-require-effective-target pthread_h } */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-require-effective-target tls_runtime } */\n+/* { dg-add-options tls } */\n+\n+#include <pthread.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+int *\n+thread_addr ()\n+{\n+  return (static thread_local int []) { 1, 2 };\n+}\n+\n+int *volatile p, *volatile q, r;\n+\n+void *\n+thread_fn (void *)\n+{\n+  q = thread_addr ();\n+  if (q[0] != 1 || q[1] != 2)\n+    return NULL;\n+  q[0] = 5;\n+  q[1] = 6;\n+  return &r;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  pthread_t tid;\n+  void *ret;\n+  p = thread_addr ();\n+  if (p[0] != 1 || p[1] != 2)\n+    abort ();\n+  p[0] = 3;\n+  p[1] = 4;\n+  if (p != thread_addr ())\n+    abort ();\n+  i = pthread_create (&tid, NULL, thread_fn, NULL);\n+  if (p != thread_addr ())\n+    abort ();\n+  i = pthread_join (tid, &ret);\n+  if (i != 0)\n+    abort ();\n+  if (ret != &r)\n+    abort ();\n+  if (p != thread_addr ())\n+    abort ();\n+  if (p[0] != 3 || p[1] != 4)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "1eb0f8dd760cc32a676056765b793903670ec60d", "filename": "gcc/testsuite/gcc.dg/c2x-complit-5.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-5.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,52 @@\n+/* Test C2x storage class specifiers in compound literals: invalid code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+int *p = &(register int) { 0 }; /* { dg-error \"file-scope compound literal specifies\" } */\n+\n+int v;\n+\n+void\n+f ()\n+{\n+  int *q = &(thread_local int) { 0 }; /* { dg-error \"compound literal implicitly auto and declared\" } */\n+  int *pc = &(static int) { v }; /* { dg-error \"not constant\" } */\n+  int *pt = &(static thread_local int) { v }; /* { dg-error \"not constant\" } */\n+  &(register int) { 0 }; /* { dg-error \"address of register compound literal requested\" } */\n+  struct s { int a, b; };\n+  &((register struct s) { 1, 2 }.b); /* { dg-error \"address of register compound literal requested\" } */\n+}\n+\n+int *s = &(static static int) { 0 }; /* { dg-error \"duplicate\" } */\n+\n+void\n+g ()\n+{\n+  (void) (register register int) { 0 }; /* { dg-error \"duplicate\" } */\n+  (void) (static static int) { 0 }; /* { dg-error \"duplicate\" } */\n+  (void) (static thread_local thread_local int) { 0 }; /* { dg-error \"duplicate\" } */\n+  (void) (static register int) { 0 }; /* { dg-error \"multiple storage classes in declaration specifiers\" } */\n+  (void) (register static int) { 0 }; /* { dg-error \"multiple storage classes in declaration specifiers\" } */\n+  (void) (register thread_local int) { 0 }; /* { dg-error \"used with\" } */\n+  (void) (thread_local register int) { 0 }; /* { dg-error \"used with\" } */\n+}\n+\n+void\n+h ()\n+{\n+  /* The following cases are not part of the C2x syntax, but are detected\n+     specially by the parser.  */\n+  (static int) 0; /* { dg-error \"storage class specifier in cast\" } */\n+  sizeof (static int); /* { dg-error \"storage class specifier in\" } */\n+  alignof (static int); /* { dg-error \"storage class specifier in\" } */\n+}\n+\n+void\n+bad_scspec ()\n+{\n+  /* Storage class specifiers not permitted in compound literals result in a\n+     syntax error.  */\n+  (typedef int) { 0 }; /* { dg-error \"expected\" } */\n+  (auto int) { 0 }; /* { dg-error \"expected\" } */\n+  (extern int) { 0 }; /* { dg-error \"expected\" } */\n+}"}, {"sha": "23a0bb6420bbd6cc8244f5ac7118ae8aedfb1082", "filename": "gcc/testsuite/gcc.dg/c2x-complit-6.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-6.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals diagnosed with\n+   -Wc11-c2x-compat.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat\" } */\n+\n+int *ps = &(static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */\n+int ss = sizeof (static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */"}, {"sha": "0cd0b86c54151b02697e3f594f761c3adb1c99cd", "filename": "gcc/testsuite/gcc.dg/c2x-complit-7.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-complit-7.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals diagnosed with\n+   -Wc11-c2x-compat, but not errors with -pedantic-errors.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat -pedantic-errors\" } */\n+\n+int *ps = &(static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */\n+int ss = sizeof (static int) { 1 }; /* { dg-warning \"forbids storage class specifiers in compound literals\" } */"}, {"sha": "6fcf2a59c43c69a0f7132056d719f3ed4d05b039", "filename": "gcc/testsuite/gcc.dg/c90-complit-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-2.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,8 @@\n+/* Test C2x storage class specifiers in compound literals not permitted for\n+   C90, but without a duplicate diagnostic, just the diagnostic for compound\n+   literals not being permitted in C90 at all.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c90 -pedantic-errors\" } */\n+\n+int *ps = &(static int) { 1 }; /* { dg-error \"ISO C90 forbids compound literals\" } */\n+int ss = sizeof (static int) { 1 }; /* { dg-error \"ISO C90 forbids compound literals\" } */"}, {"sha": "e9da5ad7958b3b31747f66ce6bc768375e02976a", "filename": "gcc/testsuite/gcc.dg/gnu2x-complit-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-1.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,7 @@\n+/* Test C2x storage class specifiers in compound literals: GNU use of alignof\n+   on objects (tested separately since alignof parsing handles the type name of\n+   compound literals).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+int a = alignof (static int) { 0 };"}, {"sha": "20cb38fd94ed5dc40f5c746961afabb67ca6c1ac", "filename": "gcc/testsuite/gcc.dg/gnu2x-complit-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18981635127c6701733dc052aa054e569271b733/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-complit-2.c?ref=18981635127c6701733dc052aa054e569271b733", "patch": "@@ -0,0 +1,18 @@\n+/* Test C2x storage class specifiers in compound literals.  Thread-local\n+   cases, compilation tests, GNU __thread used.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+/* { dg-require-effective-target tls } */\n+\n+#include <stddef.h>\n+\n+/* __thread is OK at file scope, although of limited use since the\n+   thread-local object and its address are not constant expressions.  */\n+size_t st = sizeof (__thread int) { 1 };\n+size_t sst = sizeof (static __thread int) { 1 };\n+\n+int *\n+f ()\n+{\n+  return &(static __thread int) { 2 };\n+}"}]}