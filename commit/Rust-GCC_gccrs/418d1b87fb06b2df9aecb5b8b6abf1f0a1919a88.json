{"sha": "418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4ZDFiODdmYjA2YjJkZjlhZWNiNWI4YjZhYmYxZjBhMTkxOWE4OA==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2013-05-14T17:06:46Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2013-05-14T17:06:46Z"}, "message": "fold-const.c (fold_negate_expr): Handle vectors.\n\n2013-05-14  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n\t* fold-const.c (fold_negate_expr): Handle vectors.\n\t(fold_truth_not_expr): Make it static.\n\t(fold_invert_truthvalue): New static function.\n\t(invert_truthvalue_loc): Handle vectors. Do not call\n\tfold_truth_not_expr directly.\n\t(fold_unary_loc) <BIT_NOT_EXPR>: Handle comparisons.\n\t<TRUTH_NOT_EXPR>: Do not cast to boolean.\n\t(fold_comparison): Handle vector constants.\n\t(fold_binary_loc) <TRUTH_XOR_EXPR>: Remove redundant code.\n\t(fold_ternary_loc) <VEC_COND_EXPR>: Adapt more COND_EXPR optimizations.\n\t* tree.h (fold_truth_not_expr): Remove declaration.\n\ngcc/testsuite/\n\t* g++.dg/ext/vector22.C: New testcase.\n\t* gcc.dg/binop-xor3.c: Remove xfail.\n\nFrom-SVN: r198893", "tree": {"sha": "6429a6c4487e6b5b3413637f8a610234ac156ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6429a6c4487e6b5b3413637f8a610234ac156ab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5244b2ed5ccd1d1697ac1e288a9e1acc4a335cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5244b2ed5ccd1d1697ac1e288a9e1acc4a335cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5244b2ed5ccd1d1697ac1e288a9e1acc4a335cc"}], "stats": {"total": 165, "additions": 112, "deletions": 53}, "files": [{"sha": "6cc7236ac23bb672c026aa5fd2864659db2b4051", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -1,3 +1,17 @@\n+2013-05-14  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* fold-const.c (fold_negate_expr): Handle vectors.\n+\t(fold_truth_not_expr): Make it static.\n+\t(fold_invert_truthvalue): New static function.\n+\t(invert_truthvalue_loc): Handle vectors. Do not call\n+\tfold_truth_not_expr directly.\n+\t(fold_unary_loc) <BIT_NOT_EXPR>: Handle comparisons.\n+\t<TRUTH_NOT_EXPR>: Do not cast to boolean.\n+\t(fold_comparison): Handle vector constants.\n+\t(fold_binary_loc) <TRUTH_XOR_EXPR>: Remove redundant code.\n+\t(fold_ternary_loc) <VEC_COND_EXPR>: Adapt more COND_EXPR optimizations.\n+\t* tree.h (fold_truth_not_expr): Remove declaration.\n+\n 2013-05-14  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-simd.md"}, {"sha": "e02f0c60d9aa29def819d81a423bd4527e09a62e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -526,7 +526,7 @@ fold_negate_expr (location_t loc, tree t)\n     case BIT_NOT_EXPR:\n       if (INTEGRAL_TYPE_P (type))\n         return fold_build2_loc (loc, PLUS_EXPR, type, TREE_OPERAND (t, 0),\n-                            build_int_cst (type, 1));\n+                            build_one_cst (type));\n       break;\n \n     case INTEGER_CST:\n@@ -3085,7 +3085,7 @@ omit_two_operands_loc (location_t loc, tree type, tree result,\n    FIXME: one would think we would fold the result, but it causes\n    problems with the dominator optimizer.  */\n \n-tree\n+static tree\n fold_truth_not_expr (location_t loc, tree arg)\n {\n   tree type = TREE_TYPE (arg);\n@@ -3220,26 +3220,36 @@ fold_truth_not_expr (location_t loc, tree arg)\n     }\n }\n \n+/* Fold the truth-negation of ARG.  This never alters ARG itself.  We\n+   assume that ARG is an operation that returns a truth value (0 or 1\n+   for scalars, 0 or -1 for vectors).  Return the folded expression if\n+   folding is successful.  Otherwise, return NULL_TREE.  */\n+\n+static tree\n+fold_invert_truthvalue (location_t loc, tree arg)\n+{\n+  tree type = TREE_TYPE (arg);\n+  return fold_unary_loc (loc, VECTOR_TYPE_P (type)\n+\t\t\t      ? BIT_NOT_EXPR\n+\t\t\t      : TRUTH_NOT_EXPR,\n+\t\t\t type, arg);\n+}\n+\n /* Return a simplified tree node for the truth-negation of ARG.  This\n    never alters ARG itself.  We assume that ARG is an operation that\n-   returns a truth value (0 or 1).\n-\n-   FIXME: one would think we would fold the result, but it causes\n-   problems with the dominator optimizer.  */\n+   returns a truth value (0 or 1 for scalars, 0 or -1 for vectors).  */\n \n tree\n invert_truthvalue_loc (location_t loc, tree arg)\n {\n-  tree tem;\n-\n   if (TREE_CODE (arg) == ERROR_MARK)\n     return arg;\n \n-  tem = fold_truth_not_expr (loc, arg);\n-  if (!tem)\n-    tem = build1_loc (loc, TRUTH_NOT_EXPR, TREE_TYPE (arg), arg);\n-\n-  return tem;\n+  tree type = TREE_TYPE (arg);\n+  return fold_build1_loc (loc, VECTOR_TYPE_P (type)\n+\t\t\t       ? BIT_NOT_EXPR\n+\t\t\t       : TRUTH_NOT_EXPR,\n+\t\t\t  type, arg);\n }\n \n /* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both\n@@ -8281,14 +8291,22 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t  if (i == count)\n \t    return build_vector (type, elements);\n \t}\n+      else if (COMPARISON_CLASS_P (arg0)\n+\t       && (VECTOR_TYPE_P (type)\n+\t\t   || (INTEGRAL_TYPE_P (type) && TYPE_PRECISION (type) == 1)))\n+\t{\n+\t  tree op_type = TREE_TYPE (TREE_OPERAND (arg0, 0));\n+\t  enum tree_code subcode = invert_tree_comparison (TREE_CODE (arg0),\n+\t\t\t\t     HONOR_NANS (TYPE_MODE (op_type)));\n+\t  if (subcode != ERROR_MARK)\n+\t    return build2_loc (loc, subcode, type, TREE_OPERAND (arg0, 0),\n+\t\t\t       TREE_OPERAND (arg0, 1));\n+\t}\n+\n \n       return NULL_TREE;\n \n     case TRUTH_NOT_EXPR:\n-      /* The argument to invert_truthvalue must have Boolean type.  */\n-      if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n-          arg0 = fold_convert_loc (loc, boolean_type_node, arg0);\n-\n       /* Note that the operand of this must be an int\n \t and its values must be 0 or 1.\n \t (\"true\" is a fixed value perhaps depending on the language,\n@@ -9586,7 +9604,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \n   /* Fold ~X op C as X op' ~C, where op' is the swapped comparison.  */\n   if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-      && TREE_CODE (arg1) == INTEGER_CST)\n+      && (TREE_CODE (arg1) == INTEGER_CST || TREE_CODE (arg1) == VECTOR_CST))\n     {\n       tree cmp_type = TREE_TYPE (TREE_OPERAND (arg0, 0));\n       return fold_build2_loc (loc, swap_tree_comparison (code), type,\n@@ -12678,11 +12696,7 @@ fold_binary_loc (location_t loc,\n       /* If the second arg is constant true, this is a logical inversion.  */\n       if (integer_onep (arg1))\n \t{\n-\t  /* Only call invert_truthvalue if operand is a truth value.  */\n-\t  if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n-\t    tem = fold_build1_loc (loc, TRUTH_NOT_EXPR, TREE_TYPE (arg0), arg0);\n-\t  else\n-\t    tem = invert_truthvalue_loc (loc, arg0);\n+\t  tem = invert_truthvalue_loc (loc, arg0);\n \t  return non_lvalue_loc (loc, fold_convert_loc (loc, type, tem));\n \t}\n       /* Identical arguments cancel to zero.  */\n@@ -14043,7 +14057,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op2))))\n \t{\n \t  location_t loc0 = expr_location_or (arg0, loc);\n-\t  tem = fold_truth_not_expr (loc0, arg0);\n+\t  tem = fold_invert_truthvalue (loc0, arg0);\n \t  if (tem && COMPARISON_CLASS_P (tem))\n \t    {\n \t      tem = fold_cond_expr_with_comparison (loc, type, tem, op2, op1);\n@@ -14052,10 +14066,6 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t    }\n \t}\n \n-      /* ???  Fixup the code below for VEC_COND_EXPR.  */\n-      if (code == VEC_COND_EXPR)\n-\treturn NULL_TREE;\n-\n       /* If the second operand is simpler than the third, swap them\n \t since that produces better jump optimization results.  */\n       if (truth_value_p (TREE_CODE (arg0))\n@@ -14065,13 +14075,15 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  /* See if this can be inverted.  If it can't, possibly because\n \t     it was a floating-point inequality comparison, don't do\n \t     anything.  */\n-\t  tem = fold_truth_not_expr (loc0, arg0);\n+\t  tem = fold_invert_truthvalue (loc0, arg0);\n \t  if (tem)\n \t    return fold_build3_loc (loc, code, type, tem, op2, op1);\n \t}\n \n       /* Convert A ? 1 : 0 to simply A.  */\n-      if (integer_onep (op1)\n+      if ((code == VEC_COND_EXPR ? integer_all_onesp (op1)\n+\t\t\t\t : (integer_onep (op1)\n+\t\t\t\t    && !VECTOR_TYPE_P (type)))\n \t  && integer_zerop (op2)\n \t  /* If we try to convert OP0 to our type, the\n \t     call to fold will try to move the conversion inside\n@@ -14083,7 +14095,9 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR\n \t over COND_EXPR in cases such as floating point comparisons.  */\n       if (integer_zerop (op1)\n-\t  && integer_onep (op2)\n+\t  && (code == VEC_COND_EXPR ? integer_all_onesp (op2)\n+\t\t\t\t    : (integer_onep (op2)\n+\t\t\t\t       && !VECTOR_TYPE_P (type)))\n \t  && truth_value_p (TREE_CODE (arg0)))\n \treturn pedantic_non_lvalue_loc (loc,\n \t\t\t\t    fold_convert_loc (loc, type,\n@@ -14200,46 +14214,53 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n       if (integer_zerop (op2)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (arg1)))\n-\treturn fold_build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n-\t\t\t    fold_convert_loc (loc, type, arg0),\n-\t\t\t    arg1);\n+\t  && truth_value_p (TREE_CODE (arg1))\n+\t  && (code == VEC_COND_EXPR || !VECTOR_TYPE_P (type)))\n+\treturn fold_build2_loc (loc, code == VEC_COND_EXPR ? BIT_AND_EXPR\n+\t\t\t\t\t\t\t   : TRUTH_ANDIF_EXPR,\n+\t\t\t\ttype, fold_convert_loc (loc, type, arg0), arg1);\n \n       /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n-      if (integer_onep (op2)\n+      if (code == VEC_COND_EXPR ? integer_all_onesp (op2) : integer_onep (op2)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (arg1)))\n+\t  && truth_value_p (TREE_CODE (arg1))\n+\t  && (code == VEC_COND_EXPR || !VECTOR_TYPE_P (type)))\n \t{\n \t  location_t loc0 = expr_location_or (arg0, loc);\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n-\t  tem = fold_truth_not_expr (loc0, arg0);\n+\t  tem = fold_invert_truthvalue (loc0, arg0);\n \t  if (tem)\n-\t    return fold_build2_loc (loc, TRUTH_ORIF_EXPR, type,\n-\t\t\t\tfold_convert_loc (loc, type, tem),\n-\t\t\t\targ1);\n+\t    return fold_build2_loc (loc, code == VEC_COND_EXPR\n+\t\t\t\t\t ? BIT_IOR_EXPR\n+\t\t\t\t\t : TRUTH_ORIF_EXPR,\n+\t\t\t\t    type, fold_convert_loc (loc, type, tem),\n+\t\t\t\t    arg1);\n \t}\n \n       /* Convert A ? 0 : B into !A && B if A and B are truth values.  */\n       if (integer_zerop (arg1)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (op2)))\n+\t  && truth_value_p (TREE_CODE (op2))\n+\t  && (code == VEC_COND_EXPR || !VECTOR_TYPE_P (type)))\n \t{\n \t  location_t loc0 = expr_location_or (arg0, loc);\n \t  /* Only perform transformation if ARG0 is easily inverted.  */\n-\t  tem = fold_truth_not_expr (loc0, arg0);\n+\t  tem = fold_invert_truthvalue (loc0, arg0);\n \t  if (tem)\n-\t    return fold_build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n-\t\t\t\tfold_convert_loc (loc, type, tem),\n-\t\t\t\top2);\n+\t    return fold_build2_loc (loc, code == VEC_COND_EXPR\n+\t\t\t\t\t ? BIT_AND_EXPR : TRUTH_ANDIF_EXPR,\n+\t\t\t\t    type, fold_convert_loc (loc, type, tem),\n+\t\t\t\t    op2);\n \t}\n \n       /* Convert A ? 1 : B into A || B if A and B are truth values.  */\n-      if (integer_onep (arg1)\n+      if (code == VEC_COND_EXPR ? integer_all_onesp (arg1) : integer_onep (arg1)\n \t  && truth_value_p (TREE_CODE (arg0))\n-\t  && truth_value_p (TREE_CODE (op2)))\n-\treturn fold_build2_loc (loc, TRUTH_ORIF_EXPR, type,\n-\t\t\t    fold_convert_loc (loc, type, arg0),\n-\t\t\t    op2);\n+\t  && truth_value_p (TREE_CODE (op2))\n+\t  && (code == VEC_COND_EXPR || !VECTOR_TYPE_P (type)))\n+\treturn fold_build2_loc (loc, code == VEC_COND_EXPR\n+\t\t\t\t     ? BIT_IOR_EXPR : TRUTH_ORIF_EXPR,\n+\t\t\t\ttype, fold_convert_loc (loc, type, arg0), op2);\n \n       return NULL_TREE;\n "}, {"sha": "9171c447132612940b3fe218ffa0d4c113ea12ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -1,3 +1,8 @@\n+2013-05-14  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* g++.dg/ext/vector22.C: New testcase.\n+\t* gcc.dg/binop-xor3.c: Remove xfail.\n+\n 2013-05-14  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.target/aarch64/vect-fcm.x: Add cases testing"}, {"sha": "ab569c7dffad5d5333b649c4b19ead98ad65c80a", "filename": "gcc/testsuite/g++.dg/ext/vector22.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-gimple\" } */\n+\n+typedef unsigned vec __attribute__((vector_size(4*sizeof(int))));\n+\n+void f(vec*a,vec*b){\n+  *a=(*a)?-1:(*b<10);\n+  *b=(*b)?(*a<10):0;\n+}\n+void g(vec*a,vec*b){\n+  *a=(*a)?(*a<*a):-1;\n+  *b=(*b)?-1:(*b<*b);\n+}\n+void h(vec*a){\n+  *a=(~*a==5);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"~\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-not \"VEC_COND_EXPR\" \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "ae03f592092339fa2c73dc04e01eeb2290d09ab8", "filename": "gcc/testsuite/gcc.dg/binop-xor3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2Fgcc.dg%2Fbinop-xor3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftestsuite%2Fgcc.dg%2Fbinop-xor3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinop-xor3.c?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -7,5 +7,5 @@ foo (int a, int b)\n   return ((a && !b) || (!a && b));\n }\n \n-/* { dg-final { scan-tree-dump-times \"\\\\\\^\" 1 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\\\^\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f2dc1b10466ef03d65c597ba7c1713681ad020c4", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=418d1b87fb06b2df9aecb5b8b6abf1f0a1919a88", "patch": "@@ -5770,7 +5770,6 @@ extern tree omit_two_operands_loc (location_t, tree, tree, tree, tree);\n #define invert_truthvalue(T)\\\n    invert_truthvalue_loc(UNKNOWN_LOCATION, T)\n extern tree invert_truthvalue_loc (location_t, tree);\n-extern tree fold_truth_not_expr (location_t, tree);\n extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);\n extern tree fold_read_from_constant_string (tree);"}]}