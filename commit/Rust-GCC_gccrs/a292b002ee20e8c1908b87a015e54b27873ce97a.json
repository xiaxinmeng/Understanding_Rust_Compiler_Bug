{"sha": "a292b002ee20e8c1908b87a015e54b27873ce97a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5MmIwMDJlZTIwZThjMTkwOGI4N2EwMTVlNTRiMjc4NzNjZTk3YQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-08-05T20:25:20Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-08-05T20:25:20Z"}, "message": "45th Cygnus<->FSF merge\n\nFrom-SVN: r7862", "tree": {"sha": "4604b0639a7de41e0d17e71dd77adb10b1fc5c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4604b0639a7de41e0d17e71dd77adb10b1fc5c7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a292b002ee20e8c1908b87a015e54b27873ce97a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a292b002ee20e8c1908b87a015e54b27873ce97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a292b002ee20e8c1908b87a015e54b27873ce97a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a292b002ee20e8c1908b87a015e54b27873ce97a/comments", "author": null, "committer": null, "parents": [{"sha": "fd67d2b6203f8e2b580ac6cd10058c76715f1427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd67d2b6203f8e2b580ac6cd10058c76715f1427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd67d2b6203f8e2b580ac6cd10058c76715f1427"}], "stats": {"total": 817, "additions": 541, "deletions": 276}, "files": [{"sha": "7ee24e6d47d78237570ec7e70a2c9d478fd4196d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 139, "deletions": 9, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1,18 +1,148 @@\n+Fri Aug  5 01:12:20 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (get_class_offset_1, get_class_offset): New routine to\n+\tfind the offset of the class where a virtual function is defined,\n+\tfrom the complete type.\n+\t* class.c (modify_one_vtable, fixup_vtable_deltas): Use\n+\tget_class_offset instead of virtual_offset as get_class_offset will\n+\talways provide the right answer.\n+\t* tree.c (virtual_offset): Remove.  It only ever worked some of the\n+\ttime.\n+\n+Tue Aug  2 12:44:21 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Put back unary_complex_lvalue call\n+\tthat I thought was redundant.\n+\n+\t* typeck.c (c_expand_return): Fix a case I missed before.\n+\n+Sun Jul 31 17:54:02 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (unify): Strip cv-quals from template type arguments (when\n+\t'const T*' is matched to 'const char*', that does not mean that T is\n+\t'const char').\n+\n+Fri Jul 29 01:03:06 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (do_type_instantiation): Instantiate nested TAGS, not\n+\ttypedefs.  Third time's the charm?\n+\n+\t* parse.y (template_parm): Support default template parms.\n+\t* pt.c (process_template_parm): Ditto.\n+\t(end_template_parm_list): Ditto.\n+\t(coerce_template_parms): Ditto.\n+\t(mangle_class_name_for_template): Ditto.\n+\t(push_template_decls): Ditto.\n+\t(unify): Ditto.\n+\t* method.c (build_overload_identifier): Ditto.\n+\t* error.c (dump_decl): Ditto.\n+\n+Wed Jul 27 17:47:00 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (do_type_instantiation): Only instantiate nested *classes*.\n+\n+Tue Jul 26 13:22:40 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* search.c (note_debug_info_needed): Also emit debugging information\n+\tfor the types of fields.\n+\n+Mon Jul 25 00:34:44 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (lookup_template_class): Pass 'template' to\n+\tcoerce_template_parms instead of 'in_decl', since it's a more\n+\tmeaningful context.\n+\n+\t* typeck.c (c_expand_return): Make sure any cleanups for the return\n+\texpression get run.\n+\t(build_c_cast): Use CONVERT_EXPR for conversion to void.\n+\n+\t* pt.c (do_type_instantiation): Also instantiate nested types.\n+\n+\t* typeck.c (convert_for_assignment): Don't die when comparing\n+\tpointers with different levels of indirection.\n+\n+\t* decl.c (grokdeclarator): The sub-call to grokdeclarator for\n+\tclass-local typedefs sets DECL_ARGUMENTS, so we need to clear it\n+\tout.\n+\n+\t* decl2.c (finish_anon_union): Don't die if the union has no\n+\tmembers.\n+\n+\t* decl.c (grokdeclarator): Undo changes to declspecs when we're done\n+\tso that 'typedef int foo, bar;' will work.\n+\n+\t* decl2.c (finish_file): Don't call expand_aggr_init for\n+\tnon-aggregates.\n+\n+Mon Jul 25 00:03:10 1994  Teemu Torma  (tot@trema.fi)\n+\n+\t* decl.c (finish_function): We can't inline constructors and\n+\tdestructors under some conditions with -fpic, but don't unset\n+\tDECL_INLINE.\n+\n+Mon Jul 25 00:03:10 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_object_ref): Make sure 'datum' is a valid object.\n+\n+Sun Jul 24 14:19:31 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* class.c (finish_struct): Don't set DECL_FIELD_BITPOS on\n+\tnon-fields.\n+\t(finish_struct_methods): Use copy_assignment_arg_p.\n+\n+\t* cvt.c (cp_convert): If expr is an OFFSET_REF, resolve it instead\n+\tof giving an error.\n+\n+\t* typeck.c (build_binary_op_nodefault): Don't set result_type if we\n+\tdon't know how to compare the operands.\n+\n+\t* decl.c (grokdeclarator): Avoid seg fault when someone uses '__op'\n+\tas a declarator-id in their program.  Like the Linux headers do.\n+\tArrgh.\n+\n+\t* tree.c (lvalue_p): Treat calls to functions returning objects by\n+\tvalue as lvalues again.\n+\n+\t* typeck.c (build_component_addr): Use convert_force to convert the\n+\tpointer in case the component type is also a private base class.\n+\n+\t* search.c (get_matching_virtual): Fix bogus warning of overloaded\n+\tvirtual.\n+\n+\t* pt.c (overload_template_name): Set DECL_ARTIFICIAL on the created\n+\tTYPE_DECL to fix bogus shadowing warnings.\n+\n+Fri Jul 22 01:15:32 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (expand_aggr_init_1): const and volatile mismatches do not\n+\tprevent a TARGET_EXPR from initializing an object directly.\n+\n+Tue Jul 19 17:55:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (build_up_reference): Allow building up references to\n+\t`this', don't warn about making references to artificial variables\n+\t(like `this').\n+\n+\t* tree.c (lvalue_p): `this' is not an lvalue.\n+\n+\t* call.c (build_method_call): Accept using a typedef name (or\n+\ttemplate type parameter) for explicit destructor calls.\n+\n Wed Jul 13 03:57:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n-        * method.c (hack_identifier): Put back old code so lists of\n-        non-functions will be handled properly.\n+\t* method.c (hack_identifier): Put back old code so lists of\n+\tnon-functions will be handled properly.\n \n-        * cp-tree.h (TYPE_NEEDS_CONSTRUCTING): #if 0 out; this macro is now\n-        defined in the language-independent tree.h.\n+\t* cp-tree.h (TYPE_NEEDS_CONSTRUCTING): #if 0 out; this macro is now\n+\tdefined in the language-independent tree.h.\n \n-        * tree.c (count_functions): Avoid bogus warning when compiling this\n-        function.\n+\t* tree.c (count_functions): Avoid bogus warning when compiling this\n+\tfunction.\n \n Mon Jul 11 18:37:20 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n-        * decl.c (grok_reference_init): Always save the initializer of a\n-        reference.\n+\t* decl.c (grok_reference_init): Always save the initializer of a\n+\treference.\n \n Fri Jul  8 17:41:46 1994  Mike Stump  (mrs@cygnus.com)\n \n@@ -36,7 +166,7 @@ Fri Jul  8 02:27:41 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (push_overloaded_decl): Don't create overloads of one when\n \tshadowing a class type.\n-\t* typeck.c (build_x_function_call): Complain about overloads of one\n+\t* typeck.c (build_x_function_call): Complain about overloads of one.\n \n \t* decl.c (grokdeclarator): Don't try to treat a char* as a tree.\n \t(grokdeclarator): Fix setting of TREE_STATIC."}, {"sha": "fa0bd49054d5dcb4bfc05d959f068f77d4a88391", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -193,7 +193,7 @@ parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n   `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n \n $(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n-\t@echo expect 1 shift/reduce confict and 33 reduce/reduce conflicts.\n+\t@echo expect 1 shift/reduce confict and 34 reduce/reduce conflicts.\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n "}, {"sha": "254fd34e34661072d7aaffb835cadef199e987c4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1604,21 +1604,15 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       if (parms)\n \terror (\"destructors take no parameters\");\n       basetype = TREE_TYPE (instance);\n-      if (IS_AGGR_TYPE (basetype))\n+      if (! ((IS_AGGR_TYPE (basetype)\n+\t      && name == constructor_name (basetype))\n+\t     || basetype == get_type_value (name)))\n \t{\n-\t  if (name == constructor_name (basetype))\n-\t    goto huzzah;\n+\t  cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n+\t\t    name, basetype);\n+\t  return void_zero_node;\n \t}\n-      else\n-\t{\n-\t  if (basetype == get_type_value (name))\n-\t    goto huzzah;\n-\t}\n-      cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n-\t\tname, basetype);\n-      return void_zero_node;\n \n-    huzzah:\n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n \treturn void_zero_node;\n       instance = default_conversion (instance);"}, {"sha": "6c767bbe2d31a797a05c0c55b555641377e351e2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 89, "deletions": 22, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1830,8 +1830,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t{\n \t  tree parmtype = TREE_VALUE (FUNCTION_ARG_CHAIN (fn_fields));\n \n-\t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype)) == t)\n+\t  if (copy_assignment_arg_p (parmtype, DECL_VIRTUAL_P (fn_fields)))\n \t    {\n \t      if (TREE_PROTECTED (fn_fields))\n \t\tTYPE_HAS_NONPUBLIC_ASSIGN_REF (t) = 1;\n@@ -2151,6 +2150,86 @@ overrides (fndecl, base_fndecl)\n   return 0;\n }\n \n+static tree\n+get_class_offset_1 (parent, binfo, context, t, fndecl)\n+     tree parent, binfo, context, t, fndecl;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree rval = NULL_TREE;\n+\n+  if (binfo == parent)\n+    return error_mark_node;\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree nrval;\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tbase_binfo = binfo_member (BINFO_TYPE (base_binfo),\n+\t\t\t\t   CLASSTYPE_VBASECLASSES (t));\n+      nrval = get_class_offset_1 (parent, base_binfo, context, t, fndecl);\n+      /* See if we have a new value */\n+      if (nrval && (nrval != error_mark_node || rval==0))\n+\t{\n+\t  /* Only compare if we have two offsets */\n+\t  if (rval && rval != error_mark_node\n+\t      && ! tree_int_cst_equal (nrval, rval))\n+\t    {\n+\t      /* Only give error if the two offsets are different */\n+\t      error (\"every virtual function must have a unique final overrider\");\n+\t      cp_error (\"  found two (or more) `%T' class subobjects in `%T'\", context, t);\n+\t      cp_error (\"  with virtual `%D' from virtual base class\", fndecl);\n+\t      return rval;\n+\t    }\n+\t  rval = nrval;\n+\t}\n+\t\n+      if (rval && BINFO_TYPE (binfo) == context)\n+\t{\n+\t  my_friendly_assert (rval == error_mark_node\n+\t\t\t      || tree_int_cst_equal (rval, BINFO_OFFSET (binfo)), 999);\n+\t  rval = BINFO_OFFSET (binfo);\n+\t}\n+    }\n+  return rval;\n+}\n+\n+/* Get the offset to the CONTEXT subobject that is related to the\n+   given BINFO.  */\n+static tree\n+get_class_offset (context, t, binfo, fndecl)\n+     tree context, t, binfo, fndecl;\n+{\n+  tree first_binfo = binfo;\n+  tree offset;\n+  int i;\n+\n+  if (context == t)\n+    return integer_zero_node;\n+\n+  if (BINFO_TYPE (binfo) == context)\n+    return BINFO_OFFSET (binfo);\n+\n+  /* Check less derived binfos first.  */\n+  while (BINFO_BASETYPES (binfo)\n+\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n+    {\n+      tree binfos = BINFO_BASETYPES (binfo);\n+      binfo = TREE_VEC_ELT (binfos, i);\n+      if (BINFO_TYPE (binfo) == context)\n+\treturn BINFO_OFFSET (binfo);\n+    }\n+\n+  /* Ok, not found in the less derived binfos, now check the more\n+     derived binfos. */\n+  offset = get_class_offset_1 (first_binfo, TYPE_BINFO (t), context, t, fndecl);\n+  if (offset==0 || TREE_CODE (offset) != INTEGER_CST)\n+    my_friendly_abort (999);\t/* we have to find it.  */\n+  return offset;\n+}\n+\n static void\n modify_one_vtable (binfo, t, fndecl, pfn)\n      tree binfo, t, fndecl, pfn;\n@@ -2174,16 +2253,7 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t  tree vfield = CLASSTYPE_VFIELD (t);\n \t  tree this_offset;\n \n-\t  offset = integer_zero_node;\n-\t  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n-\t    {\n-\t      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n-\t      if (offset == NULL_TREE)\n-\t\t{\n-\t\t  tree binfo = get_binfo (context, t, 0);\n-\t\t  offset = BINFO_OFFSET (binfo);\n-\t\t}\n-\t    }\n+\t  offset = get_class_offset (context, t, binfo, fndecl);\n \n \t  /* Find the right offset for the this pointer based on the\n \t     base class we just found.  We have to take into\n@@ -2288,16 +2358,7 @@ fixup_vtable_deltas (binfo, t)\n \t  tree vfield = CLASSTYPE_VFIELD (t);\n \t  tree this_offset;\n \n-\t  offset = integer_zero_node;\n-\t  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n-\t    {\n-\t      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n-\t      if (offset == NULL_TREE)\n-\t\t{\n-\t\t  tree binfo = get_binfo (context, t, 0);\n-\t\t  offset = BINFO_OFFSET (binfo);\n-\t\t}\n-\t    }\n+\t  offset = get_class_offset (context, t, binfo, fndecl);\n \n \t  /* Find the right offset for the this pointer based on the\n \t     base class we just found.  We have to take into\n@@ -3498,6 +3559,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n \t    for (; uelt; uelt = TREE_CHAIN (uelt))\n \t      {\n+\t\tif (TREE_CODE (uelt) != FIELD_DECL)\n+\t\t  continue;\n+\n \t\tDECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n \t\tDECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n \t      }\n@@ -3552,6 +3616,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n \t    for (; uelt; uelt = TREE_CHAIN (uelt))\n \t      {\n+\t\tif (TREE_CODE (uelt) != FIELD_DECL)\n+\t\t  continue;\n+\n \t\tDECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n \t\tDECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n \t      }"}, {"sha": "b6db695419046db3b02ea5926e335edc3ef49850", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -2254,7 +2254,6 @@ extern tree copy_binfo\t\t\t\tPROTO((tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n extern tree reverse_path\t\t\tPROTO((tree));\n extern tree virtual_member\t\t\tPROTO((tree, tree));\n-extern tree virtual_offset\t\t\tPROTO((tree, tree, tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern int decl_list_length\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));"}, {"sha": "04f9bd3eb2c2c6048576002353ce294b83098b3e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -425,10 +425,11 @@ build_up_reference (type, arg, flags, checkconst)\n       break;\n \n     case PARM_DECL:\n+#if 0\n       if (targ == current_class_decl)\n \t{\n \t  error (\"address of `this' not available\");\n-#if 0\n+/* #if 0 */\t  \n \t  /* This code makes the following core dump the compiler on a sun4,\n \t     if the code below is used.\n \n@@ -465,16 +466,18 @@ build_up_reference (type, arg, flags, checkconst)\n \t  TREE_ADDRESSABLE (targ) = 1; /* so compiler doesn't die later */\n \t  put_var_into_stack (targ);\n \t  break;\n-#else\n+/* #else */\n \t  return error_mark_node;\n-#endif\n+/* #endif */\t  \n \t}\n+#endif\n       /* Fall through.  */\n     case VAR_DECL:\n     case CONST_DECL:\n-      if (DECL_REGISTER (targ) && !TREE_ADDRESSABLE (targ))\n-\twarning (\"address needed to build reference for `%s', which is declared `register'\",\n-\t\t IDENTIFIER_POINTER (DECL_NAME (targ)));\n+      if (DECL_REGISTER (targ) && !TREE_ADDRESSABLE (targ)\n+\t  && !DECL_ARTIFICIAL (targ))\n+\tcp_warning (\"address needed to build reference for `%D', which is declared `register'\",\n+\t\t    targ);\n       else if (staticp (targ))\n \tliteral_flag = 1;\n \n@@ -1206,6 +1209,9 @@ cp_convert (type, expr, convtype, flags)\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n+  if (TREE_CODE (e) == OFFSET_REF)\n+    e = resolve_offset_ref (e);\n+\n   if (TREE_READONLY_DECL_P (e))\n     e = decl_constant_value (e);\n \n@@ -1223,10 +1229,7 @@ cp_convert (type, expr, convtype, flags)\n \t  if (flag_pedantic_errors)\n \t    return error_mark_node;\n \t}\n-      if (form == OFFSET_TYPE)\n-\tcp_error_at (\"pointer-to-member expression object not composed with type `%D' object\",\n-\t\t     TYPE_NAME (TYPE_OFFSET_BASETYPE (intype)));\n-      else if (IS_AGGR_TYPE (intype))\n+      if (IS_AGGR_TYPE (intype))\n \t{\n \t  tree rval;\n \t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);"}, {"sha": "11ea6a2ca0afe263a84c5e2ad10079a72fa0f387", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -7091,7 +7091,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  dname = decl;\n \t  decl = NULL_TREE;\n \n-\t  if (IDENTIFIER_OPNAME_P (dname))\n+\t  if (! IDENTIFIER_OPNAME_P (dname)\n+\t      /* Linux headers use '__op'.  Arrgh.  */\n+\t      || IDENTIFIER_TYPENAME_P (dname) && ! TREE_TYPE (dname))\n+\t    name = IDENTIFIER_POINTER (dname);\n+\t  else\n \t    {\n \t      if (IDENTIFIER_TYPENAME_P (dname))\n \t\t{\n@@ -7102,8 +7106,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t}\n \t      name = operator_name_string (dname);\n \t    }\n-\t  else\n-\t    name = IDENTIFIER_POINTER (dname);\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -7688,17 +7690,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tbreak;\n   \t    }\n \n-\t  if (scanner == IDENTIFIER_AS_LIST (ridpointers [(int) RID_TYPEDEF]))\n-\t    {\n-\t      if (previous_declspec)\n-\t\tTREE_CHAIN (previous_declspec)\n-\t\t  = IDENTIFIER_AS_LIST (ridpointers [(int) RID_STATIC]);\n-\t      else\n-\t\tdeclspecs\n-\t\t  = IDENTIFIER_AS_LIST (ridpointers [(int) RID_STATIC]);\n-\t    }\n+\t  if (previous_declspec)\n+\t    TREE_CHAIN (previous_declspec) = TREE_CHAIN (scanner);\n \t  else\n-\t    TREE_VALUE (scanner) = ridpointers[(int) RID_STATIC];\n+\t    declspecs = TREE_CHAIN (scanner);\n+\n+\t  declspecs = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC],\n+\t\t\t\t declspecs);\n \n \t  /* In the recursive call to grokdeclarator we need to know\n \t     whether we are working on a signature-local typedef.  */\n@@ -7707,13 +7705,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   \n \t  loc_typedecl =\n \t    grokdeclarator (declarator, declspecs, FIELD, 0, NULL_TREE);\n+\n+\t  if (previous_declspec)\n+\t    TREE_CHAIN (previous_declspec) = scanner;\n   \n \t  if (loc_typedecl != error_mark_node)\n   \t    {\n \t      register int i = sizeof (struct lang_decl_flags) / sizeof (int);\n \t      register int *pi;\n   \n \t      TREE_SET_CODE (loc_typedecl, TYPE_DECL);\n+\t      /* This is the same field as DECL_ARGUMENTS, which is set for\n+\t\t function typedefs by the above grokdeclarator.  */\n+\t      DECL_NESTED_TYPENAME (loc_typedecl) = 0;\n   \n \t      pi = (int *) permalloc (sizeof (struct lang_decl_flags));\n \t      while (i > 0)\n@@ -11529,20 +11533,19 @@ finish_function (lineno, call_poplevel)\n   /* So we can tell if jump_optimize sets it to 1.  */\n   can_reach_end = 0;\n \n-  /* ??? Compensate for Sun brain damage in dealing with data segments\n-     of PIC code.  */\n-  if (flag_pic\n-      && (DECL_CONSTRUCTOR_P (fndecl)\n-\t  || DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n-      && CLASSTYPE_NEEDS_VIRTUAL_REINIT (TYPE_METHOD_BASETYPE (fntype)))\n-    DECL_INLINE (fndecl) = 0;\n-\n   if (DECL_EXTERNAL (fndecl)\n       /* This function is just along for the ride.  If we can make\n \t it inline, that's great.  Otherwise, just punt it.  */\n       && (DECL_INLINE (fndecl) == 0\n \t  || flag_no_inline\n-\t  || function_cannot_inline_p (fndecl)))\n+\t  || function_cannot_inline_p (fndecl)\n+\t  /* ??? Compensate for Sun brain damage in dealing with\n+\t     data segments of PIC code.  */\n+\t  || (flag_pic\n+\t      && (DECL_CONSTRUCTOR_P (fndecl)\n+\t\t  || DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+\t      && CLASSTYPE_NEEDS_VIRTUAL_REINIT (TYPE_METHOD_BASETYPE (fntype)))))\n+\n     {\n       extern int rtl_dump_and_exit;\n       int old_rtl_dump_and_exit = rtl_dump_and_exit;"}, {"sha": "6579fe77141fac44713d62382e82ca562388aae6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -2100,8 +2100,16 @@ finish_anon_union (anon_union_decl)\n     }\n   if (static_p)\n     {\n-      make_decl_rtl (main_decl, 0, global_bindings_p ());\n-      DECL_RTL (anon_union_decl) = DECL_RTL (main_decl);\n+      if (main_decl)\n+\t{\n+\t  make_decl_rtl (main_decl, 0, global_bindings_p ());\n+\t  DECL_RTL (anon_union_decl) = DECL_RTL (main_decl);\n+\t}\n+      else\n+\t{\n+\t  warning (\"anonymous union with no members\");\n+\t  return;\n+\t}\n     }\n \n   /* The following call assumes that there are never any cleanups\n@@ -2712,7 +2720,6 @@ finish_file ()\n \t\t    }\n \t\t}\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-\t\t  || init == 0\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\texpand_aggr_init (decl, init, 0);\n \t      else if (TREE_CODE (init) == TREE_VEC)"}, {"sha": "c42724396d54a1382e132e5cfc3f9e6d1a66b15a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -671,13 +671,22 @@ dump_decl (t, v)\n \tfor (i = 0; i < len; i++)\n \t  {\n \t    tree arg = TREE_VEC_ELT (args, i);\n-\t    if (TREE_CODE (arg) == IDENTIFIER_NODE)\n+\t    tree defval = TREE_PURPOSE (arg);\n+\t    arg = TREE_VALUE (arg);\n+\t    if (TREE_CODE (arg) == TYPE_DECL)\n \t      {\n \t\tOB_PUTS (\"class \");\n-\t\tOB_PUTID (arg);\n+\t\tOB_PUTID (DECL_NAME (arg));\n \t      }\n \t    else\n \t      dump_decl (arg, 1);\n+\n+\t    if (defval)\n+\t      {\n+\t\tOB_PUTS (\" = \");\n+\t\tdump_decl (defval, 1);\n+\t      }\n+\t\t\n \t    OB_PUTC2 (',', ' ');\n \t  }\n \tOB_UNPUT (2);"}, {"sha": "4aec96a4867d71f14720b449741669f9465885d7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1392,7 +1392,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t     separately from the object being initialized.  */\n \t  if (TREE_CODE (init) == TARGET_EXPR)\n \t    {\n-\t      if (init_type == type)\n+\t      if (TYPE_MAIN_VARIANT (init_type) == TYPE_MAIN_VARIANT (type))\n \t\t{\n \t\t  if (TREE_CODE (exp) == VAR_DECL\n \t\t      || TREE_CODE (exp) == RESULT_DECL)"}, {"sha": "2d41cc614921af11dc4387100e9d856710d49c87", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -2875,7 +2875,7 @@ check_newline ()\n \t\t  if (c_header_level && --c_header_level == 0)\n \t\t    {\n \t\t      if (entering_c_header)\n-\t\t\twarning (\"Badly nested C headers from preprocessor\");\n+\t\t\twarning (\"badly nested C headers from preprocessor\");\n \t\t      --pending_lang_change;\n \t\t    }\n \t\t  if (flag_cadillac)"}, {"sha": "853ada186fe4095b54204ac22c12313ba511838d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -463,9 +463,9 @@ build_overload_identifier (name)\n       icat (nparms);\n       for (i = 0; i < nparms; i++)\n \t{\n-\t  tree parm = TREE_VEC_ELT (parmlist, i);\n+\t  tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n \t  tree arg = TREE_VEC_ELT (arglist, i);\n-\t  if (TREE_CODE (parm) == IDENTIFIER_NODE)\n+\t  if (TREE_CODE (parm) == TYPE_DECL)\n \t    {\n \t      /* This parameter is a type.  */\n \t      OB_PUTC ('Z');"}, {"sha": "9251a34d2eda87366a42a59d3c1ef80961aa834b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -221,7 +221,7 @@ empty_parms ()\n %type <ttype> type_id absdcl type_quals\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_type_id new_declarator direct_new_declarator\n-%type <ttype> xexpr parmlist parms parm bad_parm\n+%type <ttype> xexpr parmlist parms parm bad_parm full_parm\n %type <ttype> identifiers_or_typenames\n %type <ttype> fcast_or_absdcl regcast_or_absdcl sub_cast_expr\n %type <ttype> expr_or_declarator complex_notype_declarator\n@@ -250,6 +250,7 @@ empty_parms ()\n %type <ttype> nonmomentary_expr\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n %type <ttype> template_header template_parm_list template_parm\n+%type <ttype> template_type_parm\n %type <ttype> template_type template_arg_list template_arg\n %type <ttype> template_instantiation template_type_name tmpl.2\n %type <ttype> template_instantiate_once template_instantiate_some\n@@ -373,6 +374,20 @@ template_parm_list:\n \t\t{ $$ = process_template_parm ($1, $3); }\n \t;\n \n+template_type_parm:\n+\t  aggr\n+\t\t{ \n+\t\t  $$ = build_tree_list ($1, NULL_TREE);\n+\t\t ttpa:\n+\t\t  if (TREE_PURPOSE ($$) == signature_type_node)\n+\t\t    sorry (\"signature as template type parameter\");\n+\t\t  else if (TREE_PURPOSE ($$) != class_type_node)\n+\t\t    pedwarn (\"template type parameters must use the keyword `class'\");\n+\t\t}\n+\t| aggr identifier\n+\t\t{ $$ = build_tree_list ($1, $2); goto ttpa; }\n+\t;\n+\n template_parm:\n \t/* The following rules introduce a new reduce/reduce\n \t   conflict on the ',' and '>' input tokens: they are valid\n@@ -381,24 +396,11 @@ template_parm:\n \t   By putting them before the `parm' rule, we get\n \t   their match before considering them nameless parameter\n \t   declarations.  */\n-\t  aggr identifier\n-\t\t{\n-\t\t  if ($1 == signature_type_node)\n-\t\t    sorry (\"signature as template type parameter\");\n-\t\t  else if ($1 != class_type_node)\n-\t\t    error (\"template type parameter must use keyword `class'\");\n-\t\t  $$ = build_tree_list ($2, NULL_TREE);\n-\t\t}\n-\t| aggr identifier_defn ':' base_class.1\n-\t\t{\n-\t\t  if ($1 == signature_type_node)\n-\t\t    sorry (\"signature as template type parameter\");\n-\t\t  else if ($1 != class_type_node)\n-\t\t    error (\"template type parameter must use keyword `class'\");\n-\t\t  warning (\"restricted template type parameters not yet implemented\");\n-\t\t  $$ = build_tree_list ($2, $4);\n-\t\t}\n-\t| parm\n+\t  template_type_parm\n+\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n+\t| template_type_parm '=' typespec\n+\t\t{ $$ = build_tree_list ($3, $$); }\n+\t| full_parm\n \t;\n \n overloaddef:\n@@ -782,6 +784,8 @@ template_type:\n template_type_name:\n \t  PTYPENAME '<' template_arg_list '>'\n \t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n+\t| PTYPENAME '<' '>'\n+\t\t{ $$ = lookup_template_class ($$, NULL_TREE, NULL_TREE); }\n \t| TYPENAME  '<' template_arg_list '>'\n \t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n \t;\n@@ -3550,10 +3554,8 @@ parms:\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| parm '=' init\n \t\t{ $$ = build_tree_list ($3, $$); }\n-\t| parms_comma parm\n-\t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }\n-\t| parms_comma parm '=' init\n-\t\t{ $$ = chainon ($$, build_tree_list ($4, $2)); }\n+\t| parms_comma full_parm\n+\t\t{ $$ = chainon ($$, $2); }\n \t| parms_comma bad_parm\n \t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }\n \t| parms_comma bad_parm '=' init\n@@ -3599,6 +3601,13 @@ named_parm:\n \t\t{ $$ = build_tree_list ($$, $2); }\n \t;\n \n+full_parm:\n+\t  parm\n+\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n+\t| parm '=' init\n+\t\t{ $$ = build_tree_list ($3, $$); }\n+\t;\n+\n parm:\n \tnamed_parm\n \t| type_id"}, {"sha": "e17354adea681c4ed9687f8ee95c6b194a704038", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 108, "deletions": 61, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -81,18 +81,19 @@ process_template_parm (list, next)\n {\n   tree parm;\n   tree decl = 0;\n+  tree defval;\n   int is_type;\n   parm = next;\n   my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 259);\n-  is_type = TREE_CODE (TREE_PURPOSE (parm)) == IDENTIFIER_NODE;\n+  defval = TREE_PURPOSE (parm);\n+  parm = TREE_VALUE (parm);\n+  is_type = TREE_PURPOSE (parm) == class_type_node;\n   if (!is_type)\n     {\n       tree tinfo = 0;\n-      parm = TREE_PURPOSE (parm);\n-      my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 260);\n-      parm = TREE_VALUE (parm);\n+      my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n       /* is a const-param */\n-      parm = grokdeclarator (TREE_VALUE (next), TREE_PURPOSE (next),\n+      parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n \t\t\t     PARM, 0, NULL_TREE);\n       /* A template parameter is not modifiable.  */\n       TREE_READONLY (parm) = 1;\n@@ -117,11 +118,19 @@ process_template_parm (list, next)\n   else\n     {\n       tree t = make_node (TEMPLATE_TYPE_PARM);\n-      decl = build_decl (TYPE_DECL, TREE_PURPOSE (parm), t);\n-      TYPE_NAME (t) = decl;\n-      TREE_VALUE (parm) = t;\n+      decl = build_decl (TYPE_DECL, TREE_VALUE (parm), t);\n+      TYPE_MAIN_DECL (t) = decl;\n+      parm = decl;\n+      if (defval)\n+\t{\n+\t  if (IDENTIFIER_HAS_TYPE_VALUE (defval))\n+\t    defval = IDENTIFIER_TYPE_VALUE (defval);\n+\t  else\n+\t    defval = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (defval));\n+\t}\n     }\n   pushdecl (decl);\n+  parm = build_tree_list (defval, parm);\n   return chainon (list, parm);\n }\n \n@@ -135,6 +144,7 @@ end_template_parm_list (parms)\n      tree parms;\n {\n   int nparms = 0;\n+  int saw_default = 0;\n   tree saved_parmlist;\n   tree parm;\n   for (parm = parms; parm; parm = TREE_CHAIN (parm))\n@@ -143,13 +153,19 @@ end_template_parm_list (parms)\n \n   for (parm = parms, nparms = 0; parm; parm = TREE_CHAIN (parm), nparms++)\n     {\n-      tree p = parm;\n-      if (TREE_CODE (p) == TREE_LIST)\n+      tree p = TREE_VALUE (parm);\n+      if (TREE_PURPOSE (parm))\n+\tsaw_default = 1;\n+      else if (saw_default)\n+\t{\n+\t  error (\"if a default argument is given for one template parameter\");\n+\t  error (\"default arguments must be given for all subsequent\");\n+\t  error (\"parameters as well\");\n+\t}\n+\n+      if (TREE_CODE (p) == TYPE_DECL)\n \t{\n-\t  tree t = TREE_VALUE (p);\n-\t  TREE_VALUE (p) = NULL_TREE;\n-\t  p = TREE_PURPOSE (p);\n-\t  my_friendly_assert (TREE_CODE (p) == IDENTIFIER_NODE, 261);\n+\t  tree t = TREE_TYPE (p);\n \t  TEMPLATE_TYPE_SET_INFO (t, saved_parmlist, nparms);\n \t}\n       else\n@@ -158,7 +174,7 @@ end_template_parm_list (parms)\n \t  DECL_INITIAL (p) = NULL_TREE;\n \t  TEMPLATE_CONST_SET_INFO (tinfo, saved_parmlist, nparms);\n \t}\n-      TREE_VEC_ELT (saved_parmlist, nparms) = p;\n+      TREE_VEC_ELT (saved_parmlist, nparms) = parm;\n     }\n   set_current_level_tags_transparency (1);\n   processing_template_decl++;\n@@ -354,47 +370,63 @@ coerce_template_parms (parms, arglist, in_decl)\n      tree parms, arglist;\n      tree in_decl;\n {\n-  int nparms, i, lost = 0;\n+  int nparms, nargs, i, lost = 0;\n   tree vec;\n \n-  if (TREE_CODE (arglist) == TREE_VEC)\n-    nparms = TREE_VEC_LENGTH (arglist);\n+  if (arglist == NULL_TREE)\n+    nargs = 0;\n+  else if (TREE_CODE (arglist) == TREE_VEC)\n+    nargs = TREE_VEC_LENGTH (arglist);\n   else\n-    nparms = list_length (arglist);\n-  if (nparms != TREE_VEC_LENGTH (parms))\n+    nargs = list_length (arglist);\n+\n+  nparms = TREE_VEC_LENGTH (parms);\n+\n+  if (nargs > nparms\n+      || (nargs < nparms\n+\t  && TREE_PURPOSE (TREE_VEC_ELT (parms, nargs)) == NULL_TREE))\n     {\n       error (\"incorrect number of parameters (%d, should be %d)\",\n-\t     nparms, TREE_VEC_LENGTH (parms));\n+\t     nargs, nparms);\n       if (in_decl)\n \tcp_error_at (\"in template expansion for decl `%D'\", in_decl);\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (arglist) == TREE_VEC)\n+  if (arglist && TREE_CODE (arglist) == TREE_VEC)\n     vec = copy_node (arglist);\n   else\n     {\n       vec = make_tree_vec (nparms);\n       for (i = 0; i < nparms; i++)\n \t{\n-\t  tree arg = arglist;\n-\t  arglist = TREE_CHAIN (arglist);\n-\t  if (arg == error_mark_node)\n-\t    lost++;\n+\t  tree arg;\n+\n+\t  if (arglist)\n+\t    {\n+\t      arg = arglist;\n+\t      arglist = TREE_CHAIN (arglist);\n+\n+\t      if (arg == error_mark_node)\n+\t\tlost++;\n+\t      else\n+\t\targ = TREE_VALUE (arg);\n+\t    }\n \t  else\n-\t    arg = TREE_VALUE (arg);\n+\t    arg = TREE_PURPOSE (TREE_VEC_ELT (parms, i));\n+\n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n     }\n   for (i = 0; i < nparms; i++)\n     {\n       tree arg = TREE_VEC_ELT (vec, i);\n-      tree parm = TREE_VEC_ELT (parms, i);\n+      tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n       tree val = 0;\n       int is_type, requires_type;\n \n       is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n-      requires_type = TREE_CODE (parm) == IDENTIFIER_NODE;\n+      requires_type = TREE_CODE (parm) == TYPE_DECL;\n       if (is_type != requires_type)\n \t{\n \t  if (in_decl)\n@@ -415,7 +447,7 @@ coerce_template_parms (parms, arglist, in_decl)\n \t{\n \t  grok_template_type (vec, &TREE_TYPE (parm));\n \t  val = digest_init (TREE_TYPE (parm), arg, (tree *) 0);\n-\t  \n+\n \t  if (val == error_mark_node)\n \t    ;\n \n@@ -489,12 +521,13 @@ mangle_class_name_for_template (name, parms, arglist)\n   my_friendly_assert (nparms == TREE_VEC_LENGTH (arglist), 268);\n   for (i = 0; i < nparms; i++)\n     {\n-      tree parm = TREE_VEC_ELT (parms, i), arg = TREE_VEC_ELT (arglist, i);\n+      tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n+      tree arg = TREE_VEC_ELT (arglist, i);\n \n       if (i)\n \tccat (',');\n \n-      if (TREE_CODE (parm) == IDENTIFIER_NODE)\n+      if (TREE_CODE (parm) == TYPE_DECL)\n \t{\n \t  cat (type_as_string (arg, 0));\n \t  continue;\n@@ -573,7 +606,7 @@ lookup_template_class (d1, arglist, in_decl)\n     }\n   parmlist = DECL_TEMPLATE_PARMS (template);\n \n-  arglist = coerce_template_parms (parmlist, arglist, in_decl);\n+  arglist = coerce_template_parms (parmlist, arglist, template);\n   if (arglist == error_mark_node)\n     return error_mark_node;\n   if (uses_template_parms (arglist))\n@@ -619,11 +652,11 @@ push_template_decls (parmlist, arglist, class_level)\n   for (i = 0; i < nparms; i++)\n     {\n       int requires_type, is_type;\n-      tree parm = TREE_VEC_ELT (parmlist, i);\n+      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n       tree arg = TREE_VEC_ELT (arglist, i);\n       tree decl = 0;\n \n-      requires_type = TREE_CODE (parm) == IDENTIFIER_NODE;\n+      requires_type = TREE_CODE (parm) == TYPE_DECL;\n       is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n       if (is_type)\n \t{\n@@ -635,7 +668,7 @@ push_template_decls (parmlist, arglist, class_level)\n \t    }\n \t  decl = arg;\n \t  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 't', 273);\n-\t  decl = build_decl (TYPE_DECL, parm, decl);\n+\t  decl = build_decl (TYPE_DECL, DECL_NAME (parm), decl);\n \t}\n       else\n \t{\n@@ -878,9 +911,8 @@ instantiate_member_templates (classname)\n \tcase 1:\n \t  /* Failure.  */\n \tfailure:\n-\t  cp_error (\"type unification error instantiating %T::%D\",\n-\t\t      classname, tdecl);\n-\t  cp_error_at (\"for template declaration `%D'\", tdecl);\n+\t  cp_error_at (\"type unification error instantiating `%D'\", tdecl);\n+\t  cp_error (\"while instantiating members of `%T'\", classname);\n \n \t  continue /* loop of members */;\n \tdefault:\n@@ -1781,6 +1813,7 @@ overload_template_name (id, classlevel)\n \t\t      || TREE_CODE (t) == UNINSTANTIATED_P_TYPE, 286);\n \n   decl = build_decl (TYPE_DECL, template, t);\n+  SET_DECL_ARTIFICIAL (decl);\n \n #if 0 /* fix this later */\n   /* We don't want to call here if the work has already been done.  */\n@@ -2035,22 +2068,20 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \t  return 1;\n \t}\n       idx = TEMPLATE_TYPE_IDX (parm);\n+      /* Template type parameters cannot contain cv-quals; i.e.\n+         template <class T> void f (T& a, T& b) will not generate\n+\t void f (const int& a, const int& b).  */\n+      if (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n+\t  || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))\n+\treturn 1;\n+      arg = TYPE_MAIN_VARIANT (arg);\n       /* Simple cases: Value already set, does match or doesn't.  */\n       if (targs[idx] == arg)\n \treturn 0;\n       else if (targs[idx])\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (targs[idx]) == TYPE_MAIN_VARIANT (arg))\n-\t    /* allow different parms to have different cv-qualifiers */;\n-\t  else\n-\t    return 1;\n-\t}\n-      /* Check for mixed types and values.  */\n-      if (TREE_CODE (TREE_VEC_ELT (tparms, idx)) != IDENTIFIER_NODE)\n \treturn 1;\n-      /* Allow trivial conversions.  */\n-      if (TYPE_READONLY (parm) < TYPE_READONLY (arg)\n-\t  || TYPE_VOLATILE (parm) < TYPE_VOLATILE (arg))\n+      /* Check for mixed types and values.  */\n+      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n \treturn 1;\n       targs[idx] = arg;\n       return 0;\n@@ -2399,12 +2430,11 @@ do_type_instantiation (name, storage)\n   tree t = TREE_TYPE (name);\n   int extern_p;\n \n+  /* With -fexternal-templates, explicit instantiations are treated the same\n+     as implicit ones.  */\n   if (flag_external_templates)\n     return;\n \n-  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t))\n-    return;\n-\n   if (TYPE_SIZE (t) == NULL_TREE)\n     {\n       cp_error (\"explicit instantiation of `%#T' before definition of template\",\n@@ -2423,6 +2453,14 @@ do_type_instantiation (name, storage)\n       extern_p = 0;\n     }\n \n+  /* We've already instantiated this.  */\n+  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t))\n+    {\n+      if (! extern_p)\n+\tcp_pedwarn (\"multiple explicit instantiation of `%#T'\", t);\n+      return;\n+    }\n+\n   SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n   CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n   SET_CLASSTYPE_INTERFACE_KNOWN (t);\n@@ -2436,17 +2474,26 @@ do_type_instantiation (name, storage)\n \n   /* this should really be done by instantiate_member_templates */\n   {\n-    tree method = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n-    for (; method; method = TREE_CHAIN (method))\n+    tree tmp = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n+    for (; tmp; tmp = TREE_CHAIN (tmp))\n       {\n-\tSET_DECL_EXPLICIT_INSTANTIATION (method);\n-\tTREE_PUBLIC (method) = 1;\n-\tDECL_EXTERNAL (method)\n-\t  = (extern_p || (DECL_INLINE (method) && ! flag_implement_inlines));\n+\tSET_DECL_EXPLICIT_INSTANTIATION (tmp);\n+\tTREE_PUBLIC (tmp) = 1;\n+\tDECL_EXTERNAL (tmp)\n+\t  = (extern_p || (DECL_INLINE (tmp) && ! flag_implement_inlines));\n       }\n-  }\n \n-  /* and data member templates, too */\n+#if 0\n+    for (tmp = TYPE_FIELDS (t); tmp; tmp = TREE_CHAIN (tmp))\n+      {\n+\tif (TREE_CODE (tmp) == VAR_DECL)\n+\t  /* eventually do something */;\n+      }\n+#endif\n+\n+    for (tmp = CLASSTYPE_TAGS (t); tmp; tmp = TREE_CHAIN (tmp))\n+      do_type_instantiation (TREE_VALUE (tmp), storage);\n+  }\n }\n \n tree"}, {"sha": "6623ab4214a5a4844565769629e90141cf56e7c3", "filename": "gcc/cp/search.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1913,15 +1913,18 @@ get_matching_virtual (binfo, fndecl, dtorp)\n       if (IDENTIFIER_VIRTUAL_P (declarator) == 0)\n \treturn NULL_TREE;\n \n+      baselink = get_virtuals_named_this (binfo);\n+      if (baselink == NULL_TREE)\n+\treturn NULL_TREE;\n+\n       drettype = TREE_TYPE (TREE_TYPE (fndecl));\n       dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n       if (DECL_STATIC_FUNCTION_P (fndecl))\n \tinstptr_type = NULL_TREE;\n       else\n \tinstptr_type = TREE_TYPE (TREE_VALUE (dtypes));\n \n-      for (baselink = get_virtuals_named_this (binfo);\n-\t   baselink; baselink = next_baselink (baselink))\n+      for (; baselink; baselink = next_baselink (baselink))\n \t{\n \t  for (tmp = TREE_VALUE (baselink); tmp; tmp = DECL_CHAIN (tmp))\n \t    {\n@@ -1945,7 +1948,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t      && ! comptypes (TREE_TYPE (TREE_TYPE (tmp)), drettype, 1))\n \t\t    {\n \t\t      cp_error (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n-\t\t      cp_error (\"overriding definition as `%#D'\", tmp);\n+\t\t      cp_error_at (\"overriding definition as `%#D'\", tmp);\n \t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n \t\t    }\n \t\t  break;\n@@ -2697,13 +2700,22 @@ free_mi_matrix ()\n /* If we want debug info for a type TYPE, make sure all its base types\n    are also marked as being potentially interesting.  This avoids\n    the problem of not writing any debug info for intermediate basetypes\n-   that have abstract virtual functions.  */\n+   that have abstract virtual functions.  Also mark member types.  */\n \n void\n note_debug_info_needed (type)\n      tree type;\n {\n+  tree field;\n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp);\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      tree ttype;\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && IS_AGGR_TYPE (ttype = target_type (TREE_TYPE (field)))\n+\t  && dfs_debug_unmarkedp (TYPE_BINFO (ttype)))\n+\tnote_debug_info_needed (ttype);\n+    }\n }\n \f\n /* Subroutines of push_class_decls ().  */"}, {"sha": "7d92b4e6671e78889ab6713e38d721db73a03d2f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 61, "deletions": 96, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -35,66 +35,75 @@ int\n lvalue_p (ref)\n      tree ref;\n {\n-  register enum tree_code code = TREE_CODE (ref);\n+  if (! language_lvalue_valid (ref))\n+    return 0;\n+  \n+  if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n+    return 1;\n \n-  if (language_lvalue_valid (ref))\n+  if (ref == current_class_decl && flag_this_is_variable <= 0)\n+    return 0;\n+\n+  switch (TREE_CODE (ref))\n     {\n-      if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n+      /* preincrements and predecrements are valid lvals, provided\n+\t what they refer to are valid lvals. */\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case COMPONENT_REF:\n+    case SAVE_EXPR:\n+      return lvalue_p (TREE_OPERAND (ref, 0));\n+\n+    case STRING_CST:\n+      return 1;\n+\n+    case VAR_DECL:\n+      if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n+\t  && DECL_LANG_SPECIFIC (ref)\n+\t  && DECL_IN_AGGR_P (ref))\n+\treturn 0;\n+    case INDIRECT_REF:\n+    case ARRAY_REF:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case ERROR_MARK:\n+      if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n \treturn 1;\n-      \n-      switch (code)\n-\t{\n-\t  /* preincrements and predecrements are valid lvals, provided\n-\t     what they refer to are valid lvals. */\n-\tcase PREINCREMENT_EXPR:\n-\tcase PREDECREMENT_EXPR:\n-\tcase COMPONENT_REF:\n-\tcase SAVE_EXPR:\n-\t  return lvalue_p (TREE_OPERAND (ref, 0));\n-\n-\tcase STRING_CST:\n-\t  return 1;\n-\n-\tcase VAR_DECL:\n-\t  if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n-\t      && DECL_LANG_SPECIFIC (ref)\n-\t      && DECL_IN_AGGR_P (ref))\n-\t    return 0;\n-\tcase INDIRECT_REF:\n-\tcase ARRAY_REF:\n-\tcase PARM_DECL:\n-\tcase RESULT_DECL:\n-\tcase ERROR_MARK:\n-\t  if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n-\t      && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n-\t    return 1;\n-\t  break;\n+      break;\n \n-\tcase TARGET_EXPR:\n-\tcase WITH_CLEANUP_EXPR:\n-\t  return 1;\n-\n-\t  /* A currently unresolved scope ref.  */\n-\tcase SCOPE_REF:\n-\t  my_friendly_abort (103);\n-\tcase OFFSET_REF:\n-\t  if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n-\t    return 1;\n-\t  return lvalue_p (TREE_OPERAND (ref, 0))\n-\t    && lvalue_p (TREE_OPERAND (ref, 1));\n-\t  break;\n+    case WITH_CLEANUP_EXPR:\n+      return lvalue_p (TREE_OPERAND (ref, 0));\n+\n+    case TARGET_EXPR:\n+      return 1;\n \n-\tcase COND_EXPR:\n-\t  return (lvalue_p (TREE_OPERAND (ref, 1))\n-\t\t  && lvalue_p (TREE_OPERAND (ref, 2)));\n+    case CALL_EXPR:\n+      if (TREE_ADDRESSABLE (TREE_TYPE (ref)))\n+\treturn 1;\n+      break;\n \n-\tcase MODIFY_EXPR:\n-\t  return 1;\n+      /* A currently unresolved scope ref.  */\n+    case SCOPE_REF:\n+      my_friendly_abort (103);\n+    case OFFSET_REF:\n+      if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n+\treturn 1;\n+      return lvalue_p (TREE_OPERAND (ref, 0))\n+\t&& lvalue_p (TREE_OPERAND (ref, 1));\n+      break;\n \n-\tcase COMPOUND_EXPR:\n-\t  return lvalue_p (TREE_OPERAND (ref, 1));\n-\t}\n+    case COND_EXPR:\n+      return (lvalue_p (TREE_OPERAND (ref, 1))\n+\t      && lvalue_p (TREE_OPERAND (ref, 2)));\n+\n+    case MODIFY_EXPR:\n+      return 1;\n+\n+    case COMPOUND_EXPR:\n+      return lvalue_p (TREE_OPERAND (ref, 1));\n     }\n+\n   return 0;\n }\n \n@@ -1184,50 +1193,6 @@ virtual_member (elem, list)\n   return rval;\n }\n \n-/* Return the offset (as an INTEGER_CST) for ELEM in LIST.\n-   INITIAL_OFFSET is the value to add to the offset that ELEM's\n-   binfo entry in LIST provides.\n-\n-   Returns NULL if ELEM does not have an binfo value in LIST.  */\n-\n-tree\n-virtual_offset (elem, list, initial_offset)\n-     tree elem;\n-     tree list;\n-     tree initial_offset;\n-{\n-  tree vb, offset;\n-  tree rval, nval;\n-\n-  for (vb = list; vb; vb = TREE_CHAIN (vb))\n-    if (elem == BINFO_TYPE (vb))\n-      return size_binop (PLUS_EXPR, initial_offset, BINFO_OFFSET (vb));\n-  rval = 0;\n-  for (vb = list; vb; vb = TREE_CHAIN (vb))\n-    {\n-      tree binfos = BINFO_BASETYPES (vb);\n-      int i;\n-\n-      if (binfos == NULL_TREE)\n-\tcontinue;\n-\n-      for (i = TREE_VEC_LENGTH (binfos)-1; i >= 0; i--)\n-\t{\n-\t  nval = binfo_value (elem, BINFO_TYPE (TREE_VEC_ELT (binfos, i)));\n-\t  if (nval)\n-\t    {\n-\t      if (rval && BINFO_OFFSET (nval) != BINFO_OFFSET (rval))\n-\t\tmy_friendly_abort (105);\n-\t      offset = BINFO_OFFSET (vb);\n-\t      rval = nval;\n-\t    }\n-\t}\n-    }\n-  if (rval == NULL_TREE)\n-    return rval;\n-  return size_binop (PLUS_EXPR, offset, BINFO_OFFSET (rval));\n-}\n-\n void\n debug_binfo (elem)\n      tree elem;"}, {"sha": "a25e1430505307d558b3565b86516200078e1963", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -1410,8 +1410,19 @@ tree\n build_object_ref (datum, basetype, field)\n      tree datum, basetype, field;\n {\n+  tree dtype;\n   if (datum == error_mark_node)\n     return error_mark_node;\n+\n+  dtype = TREE_TYPE (datum);\n+  if (TREE_CODE (dtype) == REFERENCE_TYPE)\n+    dtype = TREE_TYPE (dtype);\n+  if (! IS_AGGR_TYPE_CODE (TREE_CODE (dtype)))\n+    {\n+      cp_error (\"request for member `%T::%D' in expression of non-aggregate type `%T'\",\n+\t\tbasetype, field, dtype);\n+      return error_mark_node;\n+    }\n   else if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (basetype)))\n     {\n       warning (\"signature name in scope resolution ignored\");\n@@ -3247,6 +3258,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n+      result_type = bool_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshort_compare = 1;\n@@ -3295,7 +3307,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    warning (\"comparison between pointer and integer\");\n \t  op0 = convert (TREE_TYPE (op1), op0);\n \t}\n-      result_type = bool_type_node;\n+      else\n+\tresult_type = 0;\n       converted = 1;\n       break;\n     }\n@@ -3717,7 +3730,7 @@ build_component_addr (arg, argtype, msg)\n     }\n   else\n     /* This conversion is harmless.  */\n-    rval = convert (argtype, rval);\n+    rval = convert_force (argtype, rval);\n \n   if (! integer_zerop (DECL_FIELD_BITPOS (field)))\n     {\n@@ -4939,7 +4952,7 @@ build_c_cast (type, expr)\n     value = TREE_VALUE (value);\n \n   if (TREE_CODE (type) == VOID_TYPE)\n-    value = build1 (NOP_EXPR, type, value);\n+    value = build1 (CONVERT_EXPR, type, value);\n   else if (TREE_TYPE (value) == NULL_TREE\n       || type_unknown_p (value))\n     {\n@@ -6445,7 +6458,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\tadd_quals = 1;\n \t      left_const &= TYPE_READONLY (ttl);\n \n-\t      if (TREE_CODE (ttl) != POINTER_TYPE)\n+\t      if (TREE_CODE (ttl) != POINTER_TYPE\n+\t\t  || TREE_CODE (ttr) != POINTER_TYPE)\n \t\tbreak;\n \t    }\n \t  unsigned_parity = TREE_UNSIGNED (ttl) - TREE_UNSIGNED (ttr);\n@@ -7028,6 +7042,7 @@ c_expand_return (retval)\n \t  && TREE_CODE (TREE_OPERAND (retval, 0)) == TARGET_EXPR)\n \tretval = TREE_OPERAND (retval, 0);\n       expand_aggr_init (result, retval, 0);\n+      expand_cleanups_to (NULL_TREE);\n       DECL_INITIAL (result) = NULL_TREE;\n       retval = 0;\n     }\n@@ -7046,6 +7061,7 @@ c_expand_return (retval)\n \t       && any_pending_cleanups (1))\n \t{\n \t  retval = get_temp_regvar (valtype, retval);\n+\t  expand_cleanups_to (NULL_TREE);\n \t  use_temp = obey_regdecls;\n \t  result = 0;\n \t}\n@@ -7071,7 +7087,10 @@ c_expand_return (retval)\n     {\n       /* Everything's great--RETVAL is in RESULT.  */\n       if (original_result_rtx)\n-\tstore_expr (result, original_result_rtx, 0);\n+\t{\n+\t  store_expr (result, original_result_rtx, 0);\n+\t  expand_cleanups_to (NULL_TREE);\n+\t}\n       else if (retval && retval != result)\n \t{\n \t  /* Clear this out so the later call to decl_function_context\n@@ -7083,6 +7102,7 @@ c_expand_return (retval)\n \t     RESULT from cleanups.  */\n \t  retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n \t  TREE_SIDE_EFFECTS (retval) = 1;\n+\t  retval = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result), retval);\n \t  expand_return (retval);\n \t}\n       else"}, {"sha": "87cf58cbc463496ae3ffaac1d9972cdc44929119", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a292b002ee20e8c1908b87a015e54b27873ce97a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a292b002ee20e8c1908b87a015e54b27873ce97a", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 360.  Free:  */\n+/* First used: 0 (reserved), Last used: 360.  Free: 261.  */\n \n static int abortcount = 0;\n "}]}