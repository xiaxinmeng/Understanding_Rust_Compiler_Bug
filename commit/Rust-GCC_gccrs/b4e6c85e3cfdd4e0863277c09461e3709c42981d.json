{"sha": "b4e6c85e3cfdd4e0863277c09461e3709c42981d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlNmM4NWUzY2ZkZDRlMDg2MzI3N2MwOTQ2MWUzNzA5YzQyOTgxZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:16:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:16:12Z"}, "message": "[46/77] Make widest_int_mode_for_size return a scalar_int_mode\n\nThe comment for widest_int_mode said that it returns \"the widest integer\nmode no wider than SIZE\", but it actually returns the widest integer\nmode that is narrower than SIZE.  In practice SIZE is always greater\nthan 1, so it can always pick QImode in the worst case.  The VOIDmode\npaths seem to be dead.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* expr.c (widest_int_mode_for_size): Make the comment match the code.\n\tReturn a scalar_int_mode and assert that the size is greater than\n\tone byte.\n\t(by_pieces_ninsns): Update accordingly and remove VOIDmode handling.\n\t(op_by_pieces_d::op_by_pieces_d): Likewise.\n\t(op_by_pieces_d::run): Likewise.\n\t(can_store_by_pieces): Likewise.\n\nFrom-SVN: r251498", "tree": {"sha": "36e125ef1d10edd5a08c6baa37321e666ff1ffae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36e125ef1d10edd5a08c6baa37321e666ff1ffae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4e6c85e3cfdd4e0863277c09461e3709c42981d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e6c85e3cfdd4e0863277c09461e3709c42981d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e6c85e3cfdd4e0863277c09461e3709c42981d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e6c85e3cfdd4e0863277c09461e3709c42981d/comments", "author": null, "committer": null, "parents": [{"sha": "646b5f37031fbb22bc4d2c2ae8127e1aa722c4d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646b5f37031fbb22bc4d2c2ae8127e1aa722c4d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646b5f37031fbb22bc4d2c2ae8127e1aa722c4d3"}], "stats": {"total": 35, "additions": 13, "deletions": 22}, "files": [{"sha": "fd519873d0b4d2fd3f96d55ba34f7bc92e95a086", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e6c85e3cfdd4e0863277c09461e3709c42981d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e6c85e3cfdd4e0863277c09461e3709c42981d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b4e6c85e3cfdd4e0863277c09461e3709c42981d", "patch": "@@ -722,19 +722,21 @@ alignment_for_piecewise_move (unsigned int max_pieces, unsigned int align)\n   return align;\n }\n \n-/* Return the widest integer mode no wider than SIZE.  If no such mode\n-   can be found, return VOIDmode.  */\n+/* Return the widest integer mode that is narrower than SIZE bytes.  */\n \n-static machine_mode\n+static scalar_int_mode\n widest_int_mode_for_size (unsigned int size)\n {\n-  machine_mode tmode, mode = VOIDmode;\n+  scalar_int_mode result = NARROWEST_INT_MODE;\n \n+  gcc_checking_assert (size > 1);\n+\n+  opt_scalar_int_mode tmode;\n   FOR_EACH_MODE_IN_CLASS (tmode, MODE_INT)\n-    if (GET_MODE_SIZE (tmode) < size)\n-      mode = tmode;\n+    if (GET_MODE_SIZE (tmode.require ()) < size)\n+      result = tmode.require ();\n \n-  return mode;\n+  return result;\n }\n \n /* Determine whether an operation OP on LEN bytes with alignment ALIGN can\n@@ -771,13 +773,9 @@ by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n \n   while (max_size > 1 && l > 0)\n     {\n-      machine_mode mode;\n+      scalar_int_mode mode = widest_int_mode_for_size (max_size);\n       enum insn_code icode;\n \n-      mode = widest_int_mode_for_size (max_size);\n-\n-      if (mode == VOIDmode)\n-\tbreak;\n       unsigned int modesize = GET_MODE_SIZE (mode);\n \n       icode = optab_handler (mov_optab, mode);\n@@ -1053,7 +1051,7 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n   if (by_pieces_ninsns (len, align, m_max_size, MOVE_BY_PIECES) > 2)\n     {\n       /* Find the mode of the largest comparison.  */\n-      machine_mode mode = widest_int_mode_for_size (m_max_size);\n+      scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n \n       m_from.decide_autoinc (mode, m_reverse, len);\n       m_to.decide_autoinc (mode, m_reverse, len);\n@@ -1073,10 +1071,7 @@ op_by_pieces_d::run ()\n {\n   while (m_max_size > 1 && m_len > 0)\n     {\n-      machine_mode mode = widest_int_mode_for_size (m_max_size);\n-\n-      if (mode == VOIDmode)\n-\tbreak;\n+      scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n \n       if (prepare_mode (mode, m_align))\n \t{\n@@ -1287,7 +1282,6 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n   unsigned HOST_WIDE_INT l;\n   unsigned int max_size;\n   HOST_WIDE_INT offset = 0;\n-  machine_mode mode;\n   enum insn_code icode;\n   int reverse;\n   /* cst is set but not used if LEGITIMATE_CONSTANT doesn't use it.  */\n@@ -1316,10 +1310,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n       max_size = STORE_MAX_PIECES + 1;\n       while (max_size > 1 && l > 0)\n \t{\n-\t  mode = widest_int_mode_for_size (max_size);\n-\n-\t  if (mode == VOIDmode)\n-\t    break;\n+\t  scalar_int_mode mode = widest_int_mode_for_size (max_size);\n \n \t  icode = optab_handler (mov_optab, mode);\n \t  if (icode != CODE_FOR_nothing"}]}