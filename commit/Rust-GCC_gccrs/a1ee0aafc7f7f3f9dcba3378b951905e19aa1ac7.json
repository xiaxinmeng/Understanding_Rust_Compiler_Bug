{"sha": "a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlZTBhYWZjN2Y3ZjNmOWRjYmEzMzc4Yjk1MTkwNWUxOWFhMWFjNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-24T05:00:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-24T05:00:34Z"}, "message": "Implement append([]byte, string...).\n\nFrom-SVN: r180364", "tree": {"sha": "8e3eb8acc4725845f6194fbcd79918bf35440879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e3eb8acc4725845f6194fbcd79918bf35440879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7/comments", "author": null, "committer": null, "parents": [{"sha": "703f56e5cbcfc5d64fac26b2d55f127d363e67b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703f56e5cbcfc5d64fac26b2d55f127d363e67b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703f56e5cbcfc5d64fac26b2d55f127d363e67b6"}], "stats": {"total": 65, "additions": 48, "deletions": 17}, "files": [{"sha": "e61dd3b5be6030f9b3f7ad1b17753083db276920", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=a1ee0aafc7f7f3f9dcba3378b951905e19aa1ac7", "patch": "@@ -8228,6 +8228,17 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t    this->report_error(_(\"too many arguments\"));\n \t    break;\n \t  }\n+\n+\t// The language permits appending a string to a []byte, as a\n+\t// special case.\n+\tif (args->back()->type()->is_string_type())\n+\t  {\n+\t    const Array_type* at = args->front()->type()->array_type();\n+\t    const Type* e = at->element_type()->forwarded();\n+\t    if (e == Type::lookup_integer_type(\"uint8\"))\n+\t      break;\n+\t  }\n+\n \tstd::string reason;\n \tif (!Type::are_assignable(args->front()->type(), args->back()->type(),\n \t\t\t\t  &reason))\n@@ -8766,30 +8777,50 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  return error_mark_node;\n \n \tArray_type* at = arg1->type()->array_type();\n-\tType* element_type = at->element_type();\n+\tType* element_type = at->element_type()->forwarded();\n \n-\targ2_tree = Expression::convert_for_assignment(context, at,\n-\t\t\t\t\t\t       arg2->type(),\n-\t\t\t\t\t\t       arg2_tree,\n-\t\t\t\t\t\t       location);\n-\tif (arg2_tree == error_mark_node)\n-\t  return error_mark_node;\n+\ttree arg2_val;\n+\ttree arg2_len;\n+\ttree element_size;\n+\tif (arg2->type()->is_string_type()\n+\t    && element_type == Type::lookup_integer_type(\"uint8\"))\n+\t  {\n+\t    arg2_tree = save_expr(arg2_tree);\n+\t    arg2_val = String_type::bytes_tree(gogo, arg2_tree);\n+\t    arg2_len = String_type::length_tree(gogo, arg2_tree);\n+\t    element_size = size_int(1);\n+\t  }\n+\telse\n+\t  {\n+\t    arg2_tree = Expression::convert_for_assignment(context, at,\n+\t\t\t\t\t\t\t   arg2->type(),\n+\t\t\t\t\t\t\t   arg2_tree,\n+\t\t\t\t\t\t\t   location);\n+\t    if (arg2_tree == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    arg2_tree = save_expr(arg2_tree);\n+\n+\t     arg2_val = at->value_pointer_tree(gogo, arg2_tree);\n+\t     arg2_len = at->length_tree(gogo, arg2_tree);\n+\n+\t     Btype* element_btype = element_type->get_backend(gogo);\n+\t     tree element_type_tree = type_to_tree(element_btype);\n+\t     if (element_type_tree == error_mark_node)\n+\t       return error_mark_node;\n+\t     element_size = TYPE_SIZE_UNIT(element_type_tree);\n+\t  }\n \n-\targ2_tree = save_expr(arg2_tree);\n-\ttree arg2_val = at->value_pointer_tree(gogo, arg2_tree);\n-\ttree arg2_len = at->length_tree(gogo, arg2_tree);\n-\tif (arg2_val == error_mark_node || arg2_len == error_mark_node)\n-\t  return error_mark_node;\n \targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n \targ2_len = fold_convert_loc(location, size_type_node, arg2_len);\n-\n-\ttree element_type_tree = type_to_tree(element_type->get_backend(gogo));\n-\tif (element_type_tree == error_mark_node)\n-\t  return error_mark_node;\n-\ttree element_size = TYPE_SIZE_UNIT(element_type_tree);\n \telement_size = fold_convert_loc(location, size_type_node,\n \t\t\t\t\telement_size);\n \n+\tif (arg2_val == error_mark_node\n+\t    || arg2_len == error_mark_node\n+\t    || element_size == error_mark_node)\n+\t  return error_mark_node;\n+\n \t// We rebuild the decl each time since the slice types may\n \t// change.\n \ttree append_fndecl = NULL_TREE;"}]}