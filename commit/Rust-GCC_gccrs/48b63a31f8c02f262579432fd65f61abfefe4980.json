{"sha": "48b63a31f8c02f262579432fd65f61abfefe4980", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhiNjNhMzFmOGMwMmYyNjI1Nzk0MzJmZDY1ZjYxYWJmZWZlNDk4MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-20T07:06:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-20T07:06:08Z"}, "message": "tree-vect-stmts.c (enum scan_store_kind): New type.\n\n\t* tree-vect-stmts.c (enum scan_store_kind): New type.\n\t(scan_store_can_perm_p): Change last argument from int * to\n\tvec<enum scan_store_kind> *, record precisely which permutations\n\tneed whole vector left shift or that plus VEC_COND_EXPR.\n\t(vectorizable_scan_store): Adjust caller, use whole vector left shift\n\tand additional VEC_COND_EXPR only for those iterations that need it.\n\nFrom-SVN: r272497", "tree": {"sha": "0fdf6e04e32203576f2c54d32f7c616887fd05a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fdf6e04e32203576f2c54d32f7c616887fd05a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48b63a31f8c02f262579432fd65f61abfefe4980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b63a31f8c02f262579432fd65f61abfefe4980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b63a31f8c02f262579432fd65f61abfefe4980", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b63a31f8c02f262579432fd65f61abfefe4980/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "170f2d181d45b1197a2873d7dd055530e01d424a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170f2d181d45b1197a2873d7dd055530e01d424a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170f2d181d45b1197a2873d7dd055530e01d424a"}], "stats": {"total": 125, "additions": 83, "deletions": 42}, "files": [{"sha": "df803bbf2a0286df0c524a1fcdac5894be097ade", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b63a31f8c02f262579432fd65f61abfefe4980/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b63a31f8c02f262579432fd65f61abfefe4980/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48b63a31f8c02f262579432fd65f61abfefe4980", "patch": "@@ -1,3 +1,12 @@\n+2019-06-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vect-stmts.c (enum scan_store_kind): New type.\n+\t(scan_store_can_perm_p): Change last argument from int * to\n+\tvec<enum scan_store_kind> *, record precisely which permutations\n+\tneed whole vector left shift or that plus VEC_COND_EXPR.\n+\t(vectorizable_scan_store): Adjust caller, use whole vector left shift\n+\tand additional VEC_COND_EXPR only for those iterations that need it.\n+\n 2019-06-20  Alexandre Oliva <oliva@adacore.com>\n \n \t* config.gcc: Fix ARM --with-fpu checking and error message."}, {"sha": "e87c32df8699fc75813270fec783a1346aadb7b6", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b63a31f8c02f262579432fd65f61abfefe4980/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b63a31f8c02f262579432fd65f61abfefe4980/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=48b63a31f8c02f262579432fd65f61abfefe4980", "patch": "@@ -6354,13 +6354,27 @@ scan_operand_equal_p (tree ref1, tree ref2)\n }\n \n \n+enum scan_store_kind {\n+  /* Normal permutation.  */\n+  scan_store_kind_perm,\n+\n+  /* Whole vector left shift permutation with zero init.  */\n+  scan_store_kind_lshift_zero,\n+\n+  /* Whole vector left shift permutation and VEC_COND_EXPR.  */\n+  scan_store_kind_lshift_cond\n+};\n+\n /* Function check_scan_store.\n \n    Verify if we can perform the needed permutations or whole vector shifts.\n-   Return -1 on failure, otherwise exact log2 of vectype's nunits.  */\n+   Return -1 on failure, otherwise exact log2 of vectype's nunits.\n+   USE_WHOLE_VECTOR is a vector of enum scan_store_kind which operation\n+   to do at each step.  */\n \n static int\n-scan_store_can_perm_p (tree vectype, tree init, int *use_whole_vector_p = NULL)\n+scan_store_can_perm_p (tree vectype, tree init,\n+\t\t       vec<enum scan_store_kind> *use_whole_vector = NULL)\n {\n   enum machine_mode vec_mode = TYPE_MODE (vectype);\n   unsigned HOST_WIDE_INT nunits;\n@@ -6371,50 +6385,59 @@ scan_store_can_perm_p (tree vectype, tree init, int *use_whole_vector_p = NULL)\n     return -1;\n \n   int i;\n+  enum scan_store_kind whole_vector_shift_kind = scan_store_kind_perm;\n   for (i = 0; i <= units_log2; ++i)\n     {\n       unsigned HOST_WIDE_INT j, k;\n+      enum scan_store_kind kind = scan_store_kind_perm;\n       vec_perm_builder sel (nunits, nunits, 1);\n       sel.quick_grow (nunits);\n-      if (i == 0)\n+      if (i == units_log2)\n \t{\n \t  for (j = 0; j < nunits; ++j)\n \t    sel[j] = nunits - 1;\n \t}\n       else\n \t{\n-\t  for (j = 0; j < (HOST_WIDE_INT_1U << (i - 1)); ++j)\n+\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n \t    sel[j] = j;\n \t  for (k = 0; j < nunits; ++j, ++k)\n \t    sel[j] = nunits + k;\n \t}\n-      vec_perm_indices indices (sel, i == 0 ? 1 : 2, nunits);\n+      vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n       if (!can_vec_perm_const_p (vec_mode, indices))\n-\tbreak;\n-    }\n-\n-  if (i == 0)\n-    return -1;\n-\n-  if (i <= units_log2)\n-    {\n-      if (optab_handler (vec_shl_optab, vec_mode) == CODE_FOR_nothing)\n-\treturn -1;\n-      int kind = 1;\n-      /* Whole vector shifts shift in zeros, so if init is all zero constant,\n-\t there is no need to do anything further.  */\n-      if ((TREE_CODE (init) != INTEGER_CST\n-\t   && TREE_CODE (init) != REAL_CST)\n-\t  || !initializer_zerop (init))\n \t{\n-\t  tree masktype = build_same_sized_truth_vector_type (vectype);\n-\t  if (!expand_vec_cond_expr_p (vectype, masktype, VECTOR_CST))\n+\t  if (i == units_log2)\n \t    return -1;\n-\t  kind = 2;\n+\n+\t  if (whole_vector_shift_kind == scan_store_kind_perm)\n+\t    {\n+\t      if (optab_handler (vec_shl_optab, vec_mode) == CODE_FOR_nothing)\n+\t\treturn -1;\n+\t      whole_vector_shift_kind = scan_store_kind_lshift_zero;\n+\t      /* Whole vector shifts shift in zeros, so if init is all zero\n+\t\t constant, there is no need to do anything further.  */\n+\t      if ((TREE_CODE (init) != INTEGER_CST\n+\t\t   && TREE_CODE (init) != REAL_CST)\n+\t\t  || !initializer_zerop (init))\n+\t\t{\n+\t\t  tree masktype = build_same_sized_truth_vector_type (vectype);\n+\t\t  if (!expand_vec_cond_expr_p (vectype, masktype, VECTOR_CST))\n+\t\t    return -1;\n+\t\t  whole_vector_shift_kind = scan_store_kind_lshift_cond;\n+\t\t}\n+\t    }\n+\t  kind = whole_vector_shift_kind;\n+\t}\n+      if (use_whole_vector)\n+\t{\n+\t  if (kind != scan_store_kind_perm && use_whole_vector->is_empty ())\n+\t    use_whole_vector->safe_grow_cleared (i);\n+\t  if (kind != scan_store_kind_perm || !use_whole_vector->is_empty ())\n+\t    use_whole_vector->safe_push (kind);\n \t}\n-      if (use_whole_vector_p)\n-\t*use_whole_vector_p = kind;\n     }\n+\n   return units_log2;\n }\n \n@@ -6726,11 +6749,12 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   unsigned HOST_WIDE_INT nunits;\n   if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n     gcc_unreachable ();\n-  int use_whole_vector_p = 0;\n-  int units_log2 = scan_store_can_perm_p (vectype, *init, &use_whole_vector_p);\n+  auto_vec<enum scan_store_kind, 16> use_whole_vector;\n+  int units_log2 = scan_store_can_perm_p (vectype, *init, &use_whole_vector);\n   gcc_assert (units_log2 > 0);\n   auto_vec<tree, 16> perms;\n   perms.quick_grow (units_log2 + 1);\n+  tree zero_vec = NULL_TREE, masktype = NULL_TREE;\n   for (int i = 0; i <= units_log2; ++i)\n     {\n       unsigned HOST_WIDE_INT j, k;\n@@ -6739,23 +6763,28 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (i == units_log2)\n \tfor (j = 0; j < nunits; ++j)\n \t  sel[j] = nunits - 1;\n-\telse\n-\t  {\n-\t    for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n-\t      sel[j] = j;\n-\t    for (k = 0; j < nunits; ++j, ++k)\n-\t      sel[j] = nunits + k;\n-\t  }\n+      else\n+\t{\n+\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n+\t    sel[j] = j;\n+\t  for (k = 0; j < nunits; ++j, ++k)\n+\t    sel[j] = nunits + k;\n+\t}\n       vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n-      if (use_whole_vector_p && i < units_log2)\n-\tperms[i] = vect_gen_perm_mask_any (vectype, indices);\n+      if (!use_whole_vector.is_empty ()\n+\t  && use_whole_vector[i] != scan_store_kind_perm)\n+\t{\n+\t  if (zero_vec == NULL_TREE)\n+\t    zero_vec = build_zero_cst (vectype);\n+\t  if (masktype == NULL_TREE\n+\t      && use_whole_vector[i] == scan_store_kind_lshift_cond)\n+\t    masktype = build_same_sized_truth_vector_type (vectype);\n+\t  perms[i] = vect_gen_perm_mask_any (vectype, indices);\n+\t}\n       else\n \tperms[i] = vect_gen_perm_mask_checked (vectype, indices);\n     }\n \n-  tree zero_vec = use_whole_vector_p ? build_zero_cst (vectype) : NULL_TREE;\n-  tree masktype = (use_whole_vector_p == 2\n-\t\t   ? build_same_sized_truth_vector_type (vectype) : NULL_TREE);\n   stmt_vec_info prev_stmt_info = NULL;\n   tree vec_oprnd1 = NULL_TREE;\n   tree vec_oprnd2 = NULL_TREE;\n@@ -6788,7 +6817,10 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n \t  tree new_temp = make_ssa_name (vectype);\n \t  gimple *g = gimple_build_assign (new_temp, VEC_PERM_EXPR,\n-\t\t\t\t\t   zero_vec ? zero_vec : vec_oprnd1, v,\n+\t\t\t\t\t   (zero_vec\n+\t\t\t\t\t    && (use_whole_vector[i]\n+\t\t\t\t\t\t!= scan_store_kind_perm))\n+\t\t\t\t\t   ? zero_vec : vec_oprnd1, v,\n \t\t\t\t\t   perms[i]);\n \t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n \t  if (prev_stmt_info == NULL)\n@@ -6797,7 +6829,7 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n \t  prev_stmt_info = new_stmt_info;\n \n-\t  if (use_whole_vector_p == 2)\n+\t  if (zero_vec && use_whole_vector[i] == scan_store_kind_lshift_cond)\n \t    {\n \t      /* Whole vector shift shifted in zero bits, but if *init\n \t\t is not initializer_zerop, we need to replace those elements"}]}