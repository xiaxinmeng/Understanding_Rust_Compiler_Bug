{"sha": "c8a05f7c57e777538fe893ba95817c6d2f8b7738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhhMDVmN2M1N2U3Nzc1MzhmZTg5M2JhOTU4MTdjNmQyZjhiNzczOA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-02-25T14:08:14Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-02-25T14:08:14Z"}, "message": "regmove.c (discover_flags_reg, [...]): Delete.\n\n2009-02-25  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* regmove.c (discover_flags_reg, flags_set_1, mark_flags_life_zones,\n\tflags_set_1_rtx, flags_set_1_set): Delete.\n\t(regmove_optimize): Do not call mark_flags_life_zones.\n\nFrom-SVN: r144425", "tree": {"sha": "8dd75b12c1f722b9320ba80b79caef7ea18717c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dd75b12c1f722b9320ba80b79caef7ea18717c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a05f7c57e777538fe893ba95817c6d2f8b7738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a05f7c57e777538fe893ba95817c6d2f8b7738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a05f7c57e777538fe893ba95817c6d2f8b7738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a05f7c57e777538fe893ba95817c6d2f8b7738/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d2538f5f9eeaf3851c35101c8586ac51c772389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2538f5f9eeaf3851c35101c8586ac51c772389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d2538f5f9eeaf3851c35101c8586ac51c772389"}], "stats": {"total": 179, "additions": 6, "deletions": 173}, "files": [{"sha": "cb0b440050543fc157c9dab0c5258574c76904da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a05f7c57e777538fe893ba95817c6d2f8b7738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a05f7c57e777538fe893ba95817c6d2f8b7738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8a05f7c57e777538fe893ba95817c6d2f8b7738", "patch": "@@ -1,3 +1,9 @@\n+2009-02-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* regmove.c (discover_flags_reg, flags_set_1, mark_flags_life_zones,\n+\tflags_set_1_rtx, flags_set_1_set): Delete.\n+\t(regmove_optimize): Do not call mark_flags_life_zones.\n+\n 2009-02-24  Julian Brown  <julian@codesourcery.com>\n \n \tPR target/35965"}, {"sha": "9342cade6249080bced50ae9a3ec43b502b2fdfb", "filename": "gcc/regmove.c", "status": "modified", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a05f7c57e777538fe893ba95817c6d2f8b7738/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a05f7c57e777538fe893ba95817c6d2f8b7738/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=c8a05f7c57e777538fe893ba95817c6d2f8b7738", "patch": "@@ -58,10 +58,6 @@ struct match {\n   int early_clobber[MAX_RECOG_OPERANDS];\n };\n \n-static rtx discover_flags_reg (void);\n-static void mark_flags_life_zones (rtx);\n-static void flags_set_1 (rtx, const_rtx, void *);\n-\n static int find_matches (rtx, struct match *);\n static int regclass_compatible_p (int, int);\n static int fixup_match_2 (rtx, rtx, rtx, rtx);\n@@ -79,171 +75,6 @@ regclass_compatible_p (int class0, int class1)\n }\n \n \f\n-/* Determine if the pattern generated by add_optab has a clobber,\n-   such as might be issued for a flags hard register.  To make the\n-   code elsewhere simpler, we handle cc0 in this same framework.\n-\n-   Return the register if one was discovered.  Return NULL_RTX if\n-   if no flags were found.  Return pc_rtx if we got confused.  */\n-\n-static rtx\n-discover_flags_reg (void)\n-{\n-  rtx tmp;\n-  tmp = gen_rtx_REG (word_mode, 10000);\n-  tmp = gen_add3_insn (tmp, tmp, const2_rtx);\n-\n-  /* If we get something that isn't a simple set, or a\n-     [(set ..) (clobber ..)], this whole function will go wrong.  */\n-  if (GET_CODE (tmp) == SET)\n-    return NULL_RTX;\n-  else if (GET_CODE (tmp) == PARALLEL)\n-    {\n-      int found;\n-\n-      if (XVECLEN (tmp, 0) != 2)\n-\treturn pc_rtx;\n-      tmp = XVECEXP (tmp, 0, 1);\n-      if (GET_CODE (tmp) != CLOBBER)\n-\treturn pc_rtx;\n-      tmp = XEXP (tmp, 0);\n-\n-      /* Don't do anything foolish if the md wanted to clobber a\n-\t scratch or something.  We only care about hard regs.\n-\t Moreover we don't like the notion of subregs of hard regs.  */\n-      if (GET_CODE (tmp) == SUBREG\n-\t  && REG_P (SUBREG_REG (tmp))\n-\t  && REGNO (SUBREG_REG (tmp)) < FIRST_PSEUDO_REGISTER)\n-\treturn pc_rtx;\n-      found = (REG_P (tmp) && REGNO (tmp) < FIRST_PSEUDO_REGISTER);\n-\n-      return (found ? tmp : NULL_RTX);\n-    }\n-\n-  return pc_rtx;\n-}\n-\n-/* It is a tedious task identifying when the flags register is live and\n-   when it is safe to optimize.  Since we process the instruction stream\n-   multiple times, locate and record these live zones by marking the\n-   mode of the instructions --\n-\n-   QImode is used on the instruction at which the flags becomes live.\n-\n-   HImode is used within the range (exclusive) that the flags are\n-   live.  Thus the user of the flags is not marked.\n-\n-   All other instructions are cleared to VOIDmode.  */\n-\n-/* Used to communicate with flags_set_1.  */\n-static rtx flags_set_1_rtx;\n-static int flags_set_1_set;\n-\n-static void\n-mark_flags_life_zones (rtx flags)\n-{\n-  int flags_regno;\n-  int flags_nregs;\n-  basic_block block;\n-\n-#ifdef HAVE_cc0\n-  /* If we found a flags register on a cc0 host, bail.  */\n-  if (flags == NULL_RTX)\n-    flags = cc0_rtx;\n-  else if (flags != cc0_rtx)\n-    flags = pc_rtx;\n-#endif\n-\n-  /* Simple cases first: if no flags, clear all modes.  If confusing,\n-     mark the entire function as being in a flags shadow.  */\n-  if (flags == NULL_RTX || flags == pc_rtx)\n-    {\n-      enum machine_mode mode = (flags ? HImode : VOIDmode);\n-      rtx insn;\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tPUT_MODE (insn, mode);\n-      return;\n-    }\n-\n-#ifdef HAVE_cc0\n-  flags_regno = -1;\n-  flags_nregs = 1;\n-#else\n-  flags_regno = REGNO (flags);\n-  flags_nregs = hard_regno_nregs[flags_regno][GET_MODE (flags)];\n-#endif\n-  flags_set_1_rtx = flags;\n-\n-  /* Process each basic block.  */\n-  FOR_EACH_BB_REVERSE (block)\n-    {\n-      rtx insn, end;\n-      int live;\n-\n-      insn = BB_HEAD (block);\n-      end = BB_END (block);\n-\n-      /* Look out for the (unlikely) case of flags being live across\n-\t basic block boundaries.  */\n-      live = 0;\n-#ifndef HAVE_cc0\n-      {\n-\tint i;\n-\tfor (i = 0; i < flags_nregs; ++i)\n-\t  live |= REGNO_REG_SET_P (df_get_live_in (block), flags_regno + i);\n-      }\n-#endif\n-\n-      while (1)\n-\t{\n-\t  /* Process liveness in reverse order of importance --\n-\t     alive, death, birth.  This lets more important info\n-\t     overwrite the mode of lesser info.  */\n-\n-\t  if (INSN_P (insn))\n-\t    {\n-#ifdef HAVE_cc0\n-\t      /* In the cc0 case, death is not marked in reg notes,\n-\t\t but is instead the mere use of cc0 when it is alive.  */\n-\t      if (live && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-\t\tlive = 0;\n-#else\n-\t      /* In the hard reg case, we watch death notes.  */\n-\t      if (live && find_regno_note (insn, REG_DEAD, flags_regno))\n-\t\tlive = 0;\n-#endif\n-\t      PUT_MODE (insn, (live ? HImode : VOIDmode));\n-\n-\t      /* In either case, birth is denoted simply by its presence\n-\t\t as the destination of a set.  */\n-\t      flags_set_1_set = 0;\n-\t      note_stores (PATTERN (insn), flags_set_1, NULL);\n-\t      if (flags_set_1_set)\n-\t\t{\n-\t\t  live = 1;\n-\t\t  PUT_MODE (insn, QImode);\n-\t\t}\n-\t    }\n-\t  else\n-\t    PUT_MODE (insn, (live ? HImode : VOIDmode));\n-\n-\t  if (insn == end)\n-\t    break;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-}\n-\n-/* A subroutine of mark_flags_life_zones, called through note_stores.  */\n-\n-static void\n-flags_set_1 (rtx x, const_rtx pat, void *data ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (pat) == SET\n-      && reg_overlap_mentioned_p (x, flags_set_1_rtx))\n-    flags_set_1_set = 1;\n-}\n-\n #ifdef AUTO_INC_DEC\n \n /* Find the place in the rtx X where REG is used as a memory address.\n@@ -1077,10 +908,6 @@ regmove_optimize (rtx f, int nregs)\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();\n \n-  /* Find out where a potential flags register is live, and so that we\n-     can suppress some optimizations in those zones.  */\n-  mark_flags_life_zones (discover_flags_reg ());\n-\n   regno_src_regno = XNEWVEC (int, nregs);\n   for (i = nregs; --i >= 0; )\n     regno_src_regno[i] = -1;"}]}