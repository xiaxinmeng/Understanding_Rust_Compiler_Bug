{"sha": "e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ0OTMzMTVmY2IyZWZkYjA2YzZjYmEyMTUwOWYzYWM1ZWQ5NDViOQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2008-08-22T16:04:29Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2008-08-22T16:04:29Z"}, "message": "re PR libgcj/8995 (race cases in interpreter)\n\n2008-08-22  Andrew Haley  <aph@redhat.com>\n\n        PR libgcj/8895:\n\n        * interpret-run.cc (REWRITE_INSN): Null this macro.\n\n        * include/jvm.h (class _Jv_Linker): Declare resolve_mutex, init.\n        (read_cpool_entry, write_cpool_entry): New functions.\n        * link.cc (_Jv_Linker::resolve_mutex): new.\n        (_Jv_Linker::init): New function.\n        (_Jv_Linker::resolve_pool_entry): Use {read,write}_cpool_entry\n        to ensure atomic access to constant pool entries.\n\nFrom-SVN: r139492", "tree": {"sha": "6696718c8f49918771b4fb127ff32d843597aa2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6696718c8f49918771b4fb127ff32d843597aa2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9f1fdfe4cc1e1db47150d6aa145e797569a3109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f1fdfe4cc1e1db47150d6aa145e797569a3109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f1fdfe4cc1e1db47150d6aa145e797569a3109"}], "stats": {"total": 137, "additions": 106, "deletions": 31}, "files": [{"sha": "8aacf4f11d0d8be0029129568f27e06e33ff6e26", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "patch": "@@ -1,3 +1,16 @@\n+2008-08-22  Andrew Haley  <aph@redhat.com>\n+\n+\tPR libgcj/8895:\n+\t\n+\t* interpret-run.cc (REWRITE_INSN): Null this macro.\n+\n+\t* include/jvm.h (class _Jv_Linker): Declare resolve_mutex, init.\n+\t(read_cpool_entry, write_cpool_entry): New functions.\n+\t* link.cc (_Jv_Linker::resolve_mutex): new.\n+\t(_Jv_Linker::init): New function.\n+\t(_Jv_Linker::resolve_pool_entry): Use {read,write}_cpool_entry\n+\tto ensure atomic access to constant pool entries.\n+\n 2008-08-07  Andrew Haley  <aph@redhat.com>\n \n \t* testsuite/libjava.lang/StackTrace2.java: Rewrite to prevent"}, {"sha": "ec74f295a5fde03377a198703c0842a9350b621a", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "patch": "@@ -308,6 +308,9 @@ class _Jv_Linker\n     s = signature;\n   }  \n \n+  static _Jv_Mutex_t resolve_mutex;\n+  static void init (void) __attribute__((constructor));\n+\n public:\n \n   static bool has_field_p (jclass, _Jv_Utf8Const *);\n@@ -325,6 +328,27 @@ class _Jv_Linker\n \t\t\t\t\t     _Jv_Utf8Const *,\n \t\t\t\t\t     bool check_perms = true);\n   static void layout_vtable_methods(jclass);\n+\n+  static jbyte read_cpool_entry (_Jv_word *data,\n+\t\t\t\t const _Jv_Constants *const pool,\n+\t\t\t\t int index)\n+  {\n+    _Jv_MutexLock (&resolve_mutex);\n+    jbyte tags = pool->tags[index];\n+    *data = pool->data[index];\n+    _Jv_MutexUnlock (&resolve_mutex);\n+    return tags;\n+  }\n+\n+  static void write_cpool_entry (_Jv_word data, jbyte tags,\n+\t\t\t\t _Jv_Constants *pool,\n+\t\t\t\t int index)\n+  {\n+    _Jv_MutexLock (&resolve_mutex);\n+    pool->data[index] = data;\n+    pool->tags[index] = tags;\n+    _Jv_MutexUnlock (&resolve_mutex);\n+  }\n };\n \n /* Type of pointer used as finalizer.  */"}, {"sha": "2934b9b89567965de69857f518688e789f02103a", "filename": "libjava/interpret-run.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "patch": "@@ -382,12 +382,24 @@ details.  */\n #else // !DEBUG\n #undef NEXT_INSN\n #define NEXT_INSN goto *((pc++)->insn)\n-#define REWRITE_INSN(INSN,SLOT,VALUE)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    pc[-2].insn = INSN;\t\t\t\t\\\n-    pc[-1].SLOT = VALUE;\t\t\t\\\n-  }\t\t\t\t\t\t\\\n-  while (0)\n+\n+// REWRITE_INSN does nothing.\n+//\n+// Rewriting a multi-word instruction in the presence of multiple\n+// threads leads to a data race if a thread reads part of an\n+// instruction while some other thread is rewriting that instruction.\n+// For example, an invokespecial instruction may be rewritten to\n+// invokespecial_resolved and its operand changed from an index to a\n+// pointer while another thread is executing invokespecial.  This\n+// other thread then reads the pointer that is now the operand of\n+// invokespecial_resolved and tries to use it as an index.\n+//\n+// Fixing this requires either spinlocks, a more elaborate data\n+// structure, or even per-thread allocated pages.  It's clear from the\n+// locking in meth->compile below that the presence of multiple\n+// threads was contemplated when this code was written, but the full\n+// consequences were not fully appreciated.\n+#define REWRITE_INSN(INSN,SLOT,VALUE)\n \n #undef INTERP_REPORT_EXCEPTION\n #define INTERP_REPORT_EXCEPTION(Jthrowable) /* not needed when not debugging */"}, {"sha": "c07b6e15c1c5d563b51ab0e31d4423fdad6c244b", "filename": "libjava/link.cc", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4493315fcb2efdb06c6cba21509f3ac5ed945b9/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=e4493315fcb2efdb06c6cba21509f3ac5ed945b9", "patch": "@@ -380,13 +380,30 @@ _Jv_Linker::resolve_method_entry (jclass klass, jclass &found_class,\n   return the_method;\n }\n \n+_Jv_Mutex_t _Jv_Linker::resolve_mutex;\n+\n+void\n+_Jv_Linker::init (void)\n+{\n+  _Jv_MutexInit (&_Jv_Linker::resolve_mutex);\n+}\n+\n+// Locking in resolve_pool_entry is somewhat subtle.  Constant\n+// resolution is idempotent, so it doesn't matter if two threads\n+// resolve the same entry.  However, it is important that we always\n+// write the resolved flag and the data together, atomically.  It is\n+// also important that we read them atomically.\n _Jv_word\n _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n {\n   using namespace java::lang::reflect;\n \n   if (GC_base (klass) && klass->constants.data\n       && ! GC_base (klass->constants.data))\n+    // If a class is heap-allocated but the constant pool is not this\n+    // is a \"new ABI\" class, i.e. one where the initial constant pool\n+    // is in the read-only data section of an object file.  Copy the\n+    // initial constant pool from there to a new heap-allocated pool.\n     {\n       jsize count = klass->constants.size;\n       if (count)\n@@ -402,14 +419,18 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \n   _Jv_Constants *pool = &klass->constants;\n \n-  if ((pool->tags[index] & JV_CONSTANT_ResolvedFlag) != 0)\n-    return pool->data[index];\n+  jbyte tags;\n+  _Jv_word data;\n+  tags = read_cpool_entry (&data, pool, index);\n \n-  switch (pool->tags[index] & ~JV_CONSTANT_LazyFlag)\n+  if ((tags & JV_CONSTANT_ResolvedFlag) != 0)\n+    return data;\n+\n+  switch (tags & ~JV_CONSTANT_LazyFlag)\n     {\n     case JV_CONSTANT_Class:\n       {\n-\t_Jv_Utf8Const *name = pool->data[index].utf8;\n+\t_Jv_Utf8Const *name = data.utf8;\n \n \tjclass found;\n \tif (name->first() == '[')\n@@ -428,8 +449,8 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \t      {\n \t\tfound = _Jv_NewClass(name, NULL, NULL);\n \t\tfound->state = JV_STATE_PHANTOM;\n-\t\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-\t\tpool->data[index].clazz = found;\n+\t\ttags |= JV_CONSTANT_ResolvedFlag;\n+\t\tdata.clazz = found;\n \t\tbreak;\n \t      }\n \t    else\n@@ -447,8 +468,8 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \t    || (_Jv_ClassNameSamePackage (check->name,\n \t\t\t\t\t  klass->name)))\n \t  {\n-\t    pool->data[index].clazz = found;\n-\t    pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\t    data.clazz = found;\n+\t    tags |= JV_CONSTANT_ResolvedFlag;\n \t  }\n \telse\n \t  {\n@@ -464,16 +485,16 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n     case JV_CONSTANT_String:\n       {\n \tjstring str;\n-\tstr = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n-\tpool->data[index].o = str;\n-\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\tstr = _Jv_NewStringUtf8Const (data.utf8);\n+\tdata.o = str;\n+\ttags |= JV_CONSTANT_ResolvedFlag;\n       }\n       break;\n \n     case JV_CONSTANT_Fieldref:\n       {\n \t_Jv_ushort class_index, name_and_type_index;\n-\t_Jv_loadIndexes (&pool->data[index],\n+\t_Jv_loadIndexes (&data,\n \t\t\t class_index,\n \t\t\t name_and_type_index);\n \tjclass owner = (resolve_pool_entry (klass, class_index, true)).clazz;\n@@ -503,16 +524,16 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \t// Initialize the field's declaring class, not its qualifying\n \t// class.\n \t_Jv_InitClass (found_class);\n-\tpool->data[index].field = the_field;\n-\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\tdata.field = the_field;\n+\ttags |= JV_CONSTANT_ResolvedFlag;\n       }\n       break;\n \n     case JV_CONSTANT_Methodref:\n     case JV_CONSTANT_InterfaceMethodref:\n       {\n \t_Jv_ushort class_index, name_and_type_index;\n-\t_Jv_loadIndexes (&pool->data[index],\n+\t_Jv_loadIndexes (&data,\n \t\t\t class_index,\n \t\t\t name_and_type_index);\n \n@@ -521,18 +542,21 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \tthe_method = resolve_method_entry (klass, found_class,\n \t\t\t\t\t   class_index, name_and_type_index,\n \t\t\t\t\t   true,\n-\t\t\t\t\t   pool->tags[index] == JV_CONSTANT_InterfaceMethodref);\n+\t\t\t\t\t   tags == JV_CONSTANT_InterfaceMethodref);\n       \n-\tpool->data[index].rmethod\n+\tdata.rmethod\n \t  = klass->engine->resolve_method(the_method,\n \t\t\t\t\t  found_class,\n \t\t\t\t\t  ((the_method->accflags\n \t\t\t\t\t    & Modifier::STATIC) != 0));\n-\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\ttags |= JV_CONSTANT_ResolvedFlag;\n       }\n       break;\n     }\n-  return pool->data[index];\n+\n+  write_cpool_entry (data, tags, pool, index);\n+\n+  return data;\n }\n \n // This function is used to lazily locate superclasses and\n@@ -1728,13 +1752,15 @@ _Jv_Linker::ensure_class_linked (jclass klass)\n       // Resolve the remaining constant pool entries.\n       for (int index = 1; index < pool->size; ++index)\n \t{\n-\t  if (pool->tags[index] == JV_CONSTANT_String)\n-\t    {\n-\t      jstring str;\n+\t  jbyte tags;\n+\t  _Jv_word data;\n \n-\t      str = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n-\t      pool->data[index].o = str;\n-\t      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\t  tags = read_cpool_entry (&data, pool, index);\n+\t  if (tags == JV_CONSTANT_String)\n+\t    {\n+\t      data.o = _Jv_NewStringUtf8Const (data.utf8);\n+\t      tags |= JV_CONSTANT_ResolvedFlag;\n+\t      write_cpool_entry (data, tags, pool, index);\n \t    }\n \t}\n "}]}