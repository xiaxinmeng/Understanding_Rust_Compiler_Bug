{"sha": "470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwYjZlNTE2MDgwNDhjZGY5ZTE4ZGFmZTdkZDQxYjA4OWYwY2ZlNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-30T15:53:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-30T15:53:45Z"}, "message": "sparc: Convert to atomic_compare_and_swap.\n\n        * config/sparc/constraints.md (\"w\"): New.\n        * config/sparc/predicates.md (mem_noofs_operand): New.\n        * config/sparc/sparc.c (sparc_expand_compare_and_swap_12): Make static.\n        Generate the boolean result of the atomic_compare_exchange.\n        (sparc_expand_compare_and_swap): New.\n        * config/sparc/sync.md (atomic_compare_and_swap<I>): New.\n        (atomic_compare_and_swap<I48MODE>_1): Rename from\n        *sync_compare_and_swap<I48MODE>, use mem_noofs_operand.\n        (*atomic_compare_and_swapdi_v8plus): Rename from\n        *sync_compare_and_swapdi_v8plus, use mem_noofs_operand.\n        (sync_compare_and_swap<I12MODE>): Remove.\n        (sync_compare_and_swap<I48MODE>): Remove.\n\nFrom-SVN: r181851", "tree": {"sha": "0b9d68c7e11d6da48ca5b48d28b9b306c7fb2823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b9d68c7e11d6da48ca5b48d28b9b306c7fb2823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/comments", "author": null, "committer": null, "parents": [{"sha": "cfe8fee796ae2d675d22b3e6301829772f188711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe8fee796ae2d675d22b3e6301829772f188711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe8fee796ae2d675d22b3e6301829772f188711"}], "stats": {"total": 134, "additions": 100, "deletions": 34}, "files": [{"sha": "62710969480e1fcbf572e13b6e7100898cc7b3da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -1,3 +1,18 @@\n+2011-11-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/sparc/constraints.md (\"w\"): New.\n+\t* config/sparc/predicates.md (mem_noofs_operand): New.\n+\t* config/sparc/sparc.c (sparc_expand_compare_and_swap_12): Make static.\n+\tGenerate the boolean result of the atomic_compare_exchange.\n+\t(sparc_expand_compare_and_swap): New.\n+\t* config/sparc/sync.md (atomic_compare_and_swap<I>): New.\n+\t(atomic_compare_and_swap<I48MODE>_1): Rename from\n+\t*sync_compare_and_swap<I48MODE>, use mem_noofs_operand.\n+\t(*atomic_compare_and_swapdi_v8plus): Rename from\n+\t*sync_compare_and_swapdi_v8plus, use mem_noofs_operand.\n+\t(sync_compare_and_swap<I12MODE>): Remove.\n+\t(sync_compare_and_swap<I48MODE>): Remove.\n+\n 2011-11-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/sparc/predicates.md (register_or_v9_zero_operand): New."}, {"sha": "472490f2624eb222f8afe5bd527a2fa942254892", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;    AB                       \n-;;;    a        jkl    q  tuvwxyz\n+;;;    a        jkl    q  tuv xyz\n \n \n ;; Register constraints\n@@ -44,6 +44,9 @@\n (define_register_constraint \"h\" \"(TARGET_V9 && TARGET_V8PLUS ? I64_REGS : NO_REGS)\"\n  \"64-bit global or out register in V8+ mode\")\n \n+(define_memory_constraint \"w\"\n+  \"A memory with only a base register\"\n+  (match_operand 0 \"mem_noofs_operand\"))\n \n ;; Floating-point constant constraints\n "}, {"sha": "81e5320649846a793bf6458b0fcd57817b55224a", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -471,6 +471,10 @@\n        (match_test \"call_address_operand (XEXP (op, 0), mode)\")))\n \n \n+(define_predicate \"mem_noofs_operand\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")))\n+\n ;; Predicates for operators.\n \n ;; Return true if OP is a comparison operator.  This allows the use of"}, {"sha": "52acc096ce3c1540371b421918e07e8726466303", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -104,7 +104,7 @@ extern int v9_regcmp_p (enum rtx_code);\n    32 bits of REG are 0 before INSN.  */   \n extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n-extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n+extern void sparc_expand_compare_and_swap (rtx op[]);\n extern void sparc_expand_vector_init (rtx, rtx);\n extern void sparc_expand_vec_perm_bmask(enum machine_mode, rtx);\n extern bool sparc_expand_conditional_move (enum machine_mode, rtx *);"}, {"sha": "7db216a7c8677908e553f02cdf1c113a890614b2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -10899,8 +10899,9 @@ sparc_emit_membar_for_model (enum memmodel model,\n /* Expand code to perform a 8 or 16-bit compare and swap by doing 32-bit\n    compare and swap on the word containing the byte or half-word.  */\n \n-void\n-sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n+static void\n+sparc_expand_compare_and_swap_12 (rtx bool_result, rtx result, rtx mem,\n+\t\t\t\t  rtx oldval, rtx newval)\n {\n   rtx addr1 = force_reg (Pmode, XEXP (mem, 0));\n   rtx addr = gen_reg_rtx (Pmode);\n@@ -10925,7 +10926,7 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n   set_mem_alias_set (memsi, ALIAS_SET_MEMORY_BARRIER);\n   MEM_VOLATILE_P (memsi) = MEM_VOLATILE_P (mem);\n \n-  val = force_reg (SImode, memsi);\n+  val = copy_to_reg (memsi);\n \n   emit_insn (gen_rtx_SET (VOIDmode, off,\n \t\t\t  gen_rtx_XOR (SImode, off,\n@@ -10971,14 +10972,18 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n   emit_insn (gen_rtx_SET (VOIDmode, newvalue,\n \t\t\t  gen_rtx_IOR (SImode, newv, val)));\n \n-  emit_insn (gen_sync_compare_and_swapsi (res, memsi, oldvalue, newvalue));\n+  emit_move_insn (bool_result, const1_rtx);\n+\n+  emit_insn (gen_atomic_compare_and_swapsi_1 (res, memsi, oldvalue, newvalue));\n \n   emit_cmp_and_jump_insns (res, oldvalue, EQ, NULL, SImode, 0, end_label);\n \n   emit_insn (gen_rtx_SET (VOIDmode, resv,\n \t\t\t  gen_rtx_AND (SImode, gen_rtx_NOT (SImode, mask),\n \t\t\t\t       res)));\n \n+  emit_move_insn (bool_result, const0_rtx);\n+\n   cc = gen_compare_reg_1 (NE, resv, val);\n   emit_insn (gen_rtx_SET (VOIDmode, val, resv));\n \n@@ -10997,6 +11002,49 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n   emit_move_insn (result, gen_lowpart (GET_MODE (result), res));\n }\n \n+/* Expand code to perform a compare-and-swap.  */\n+\n+void\n+sparc_expand_compare_and_swap (rtx operands[])\n+{\n+  rtx bval, retval, mem, oldval, newval;\n+  enum machine_mode mode;\n+  enum memmodel model;\n+\n+  bval = operands[0];\n+  retval = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  model = (enum memmodel) INTVAL (operands[6]);\n+  mode = GET_MODE (mem);\n+\n+  sparc_emit_membar_for_model (model, 3, 1);\n+\n+  if (reg_overlap_mentioned_p (retval, oldval))\n+    oldval = copy_to_reg (oldval);\n+\n+  if (mode == QImode || mode == HImode)\n+    sparc_expand_compare_and_swap_12 (bval, retval, mem, oldval, newval);\n+  else\n+    {\n+      rtx (*gen) (rtx, rtx, rtx, rtx);\n+      rtx x;\n+\n+      if (mode == SImode)\n+\tgen = gen_atomic_compare_and_swapsi_1;\n+      else\n+\tgen = gen_atomic_compare_and_swapdi_1;\n+      emit_insn (gen (retval, mem, oldval, newval));\n+\n+      x = emit_store_flag (bval, EQ, retval, oldval, mode, 1, 1);\n+      if (x != bval)\n+\tconvert_move (bval, x, 1);\n+    }\n+\n+  sparc_emit_membar_for_model (model, 3, 2);\n+}\n+\n void\n sparc_expand_vec_perm_bmask (enum machine_mode vmode, rtx sel)\n {"}, {"sha": "d7066b01a1cb652ae4c45150a343b8244c39bac3", "filename": "gcc/config/sparc/sync.md", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470b6e51608048cdf9e18dafe7dd41b089f0cfe4/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=470b6e51608048cdf9e18dafe7dd41b089f0cfe4", "patch": "@@ -161,55 +161,49 @@\n   [(set_attr \"type\" \"store,store,fpstore\")\n    (set_attr \"cpu_feature\" \"v9,*,*\")])\n \n-;;;;;;;;\n-\n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n-   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n-   (match_operand:I12MODE 2 \"register_operand\" \"\")\n-   (match_operand:I12MODE 3 \"register_operand\" \"\")]\n-  \"TARGET_V9\"\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool output\n+   (match_operand:I 1 \"register_operand\" \"\")\t\t;; val output\n+   (match_operand:I 2 \"mem_noofs_operand\" \"\")\t\t;; memory\n+   (match_operand:I 3 \"register_operand\" \"\")\t\t;; expected\n+   (match_operand:I 4 \"register_operand\" \"\")\t\t;; desired\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; mod_f\n+  \"TARGET_V9 && (<MODE>mode != DImode || TARGET_ARCH64 || TARGET_V8PLUS)\"\n {\n-  sparc_expand_compare_and_swap_12 (operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3]);\n+  sparc_expand_compare_and_swap (operands);\n   DONE;\n })\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n+(define_expand \"atomic_compare_and_swap<mode>_1\"\n   [(parallel\n      [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n-\t   (match_operand:I48MODE 1 \"memory_operand\" \"\"))\n+\t   (match_operand:I48MODE 1 \"mem_noofs_operand\" \"\"))\n       (set (match_dup 1)\n \t   (unspec_volatile:I48MODE\n \t     [(match_operand:I48MODE 2 \"register_operand\" \"\")\n \t      (match_operand:I48MODE 3 \"register_operand\" \"\")]\n \t     UNSPECV_CAS))])]\n   \"TARGET_V9\"\n-{\n-  if (!REG_P (XEXP (operands[1], 0)))\n-    {\n-      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n-      operands[1] = replace_equiv_address (operands[1], addr);\n-    }\n-  emit_insn (gen_memory_barrier ());\n-})\n+  \"\")\n \n-(define_insn \"*sync_compare_and_swap<mode>\"\n+(define_insn \"*atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n-\t(mem:I48MODE (match_operand 1 \"register_operand\" \"r\")))\n-   (set (mem:I48MODE (match_dup 1))\n+\t(match_operand:I48MODE 1 \"mem_noofs_operand\" \"+w\"))\n+   (set (match_dup 1)\n \t(unspec_volatile:I48MODE\n \t  [(match_operand:I48MODE 2 \"register_operand\" \"r\")\n \t   (match_operand:I48MODE 3 \"register_operand\" \"0\")]\n \t  UNSPECV_CAS))]\n   \"TARGET_V9 && (<MODE>mode == SImode || TARGET_ARCH64)\"\n-  \"cas<modesuffix>\\t[%1], %2, %0\"\n+  \"cas<modesuffix>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn \"*sync_compare_and_swapdi_v8plus\"\n+(define_insn \"*atomic_compare_and_swapdi_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-\t(mem:DI (match_operand 1 \"register_operand\" \"r\")))\n-   (set (mem:DI (match_dup 1))\n+\t(match_operand:DI 1 \"mem_noofs_operand\" \"+w\"))\n+   (set (match_dup 1)\n \t(unspec_volatile:DI\n \t  [(match_operand:DI 2 \"register_operand\" \"h\")\n \t   (match_operand:DI 3 \"register_operand\" \"0\")]\n@@ -224,12 +218,14 @@\n     output_asm_insn (\"srl\\t%L2, 0, %L2\", operands);\n   output_asm_insn (\"sllx\\t%H2, 32, %H3\", operands);\n   output_asm_insn (\"or\\t%L2, %H3, %H3\", operands);\n-  output_asm_insn (\"casx\\t[%1], %H3, %L3\", operands);\n+  output_asm_insn (\"casx\\t%1, %H3, %L3\", operands);\n   return \"srlx\\t%L3, 32, %H3\";\n }\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n+;;;;;;;;\n+\n (define_expand \"sync_lock_test_and_set<mode>\"\n   [(match_operand:I12MODE 0 \"register_operand\" \"\")\n    (match_operand:I12MODE 1 \"memory_operand\" \"\")"}]}