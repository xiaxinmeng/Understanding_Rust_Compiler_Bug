{"sha": "c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhNDQ0NGM1MGE2MWQ2Zjc4N2Q0ZDIzOGVkMDA3YWQ2MjZhM2Y2ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-07-28T21:45:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-07-28T21:45:27Z"}, "message": "cgraph.c (cgraph_clone_edge): New UPDATE_ORIGINAL argument.\n\n\n\t* cgraph.c (cgraph_clone_edge): New UPDATE_ORIGINAL argument.\n\t(cgraph_clone_node): Likewise.\n\t* cgraph.h (cgraph_clone_edge): Update prototype.\n\t(cgraph_clone_node): Likewise.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Update call of\n\tcgraph_clone_node.\n\t(lookup_recursive_calls): Consider profile.\n\t(cgraph_decide_recursive_inlining): Fix updating; use new\n\tprobability argument; use profile.\n\t* params.def (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY): New.\n\t* tree-inline.c (copy_bb): Update clal of clone_edge.\n\t* tree-optimize.c (tree_rest_of_compilation): UPdate cal of clone_node.\n\n\t* invoke.texi (min-inline-recursive-probability): Document.\n\nFrom-SVN: r102521", "tree": {"sha": "a1f5a77fc57f6b24e2832b89c2a840ee9c6bb3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1f5a77fc57f6b24e2832b89c2a840ee9c6bb3f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/comments", "author": null, "committer": null, "parents": [{"sha": "260883c8981dc45d44d9d7a82c238d625a43b813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/260883c8981dc45d44d9d7a82c238d625a43b813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/260883c8981dc45d44d9d7a82c238d625a43b813"}], "stats": {"total": 135, "additions": 111, "deletions": 24}, "files": [{"sha": "6e0a6e2eca2e429cee23c2b4923f3551d44b348d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -1,3 +1,20 @@\n+2005-07-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_clone_edge): New UPDATE_ORIGINAL argument.\n+\t(cgraph_clone_node): Likewise.\n+\t* cgraph.h (cgraph_clone_edge): Update prototype.\n+\t(cgraph_clone_node): Likewise.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Update call of\n+\tcgraph_clone_node.\n+\t(lookup_recursive_calls): Consider profile.\n+\t(cgraph_decide_recursive_inlining): Fix updating; use new\n+\tprobability argument; use profile.\n+\t* params.def (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY): New.\n+\t* tree-inline.c (copy_bb): Update clal of clone_edge.\n+\t* tree-optimize.c (tree_rest_of_compilation): UPdate cal of clone_node.\n+\n+\t* invoke.texi (min-inline-recursive-probability): Document.\n+\n 2005-07-28  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/install.texi (Configuration): Update Valgrind homepage."}, {"sha": "7a67f6d0da88a7e8e287abaa160f93ae9e8e5c95", "filename": "gcc/cgraph.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -884,7 +884,8 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   tree call_stmt, int count_scale, int loop_nest)\n+\t\t   tree call_stmt, int count_scale, int loop_nest,\n+\t\t   bool update_original)\n {\n   struct cgraph_edge *new;\n \n@@ -893,14 +894,20 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t            e->loop_nest + loop_nest);\n \n   new->inline_failed = e->inline_failed;\n-  e->count -= new->count;\n+  if (update_original)\n+    e->count -= new->count;\n   return new;\n }\n \n /* Create node representing clone of N executed COUNT times.  Decrease\n-   the execution counts from original node too.  */\n+   the execution counts from original node too. \n+\n+   When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n+   function's profile to reflect the fact that part of execution is handled\n+   by node.  */\n struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n+cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest,\n+\t\t   bool update_original)\n {\n   struct cgraph_node *new = cgraph_create_node ();\n   struct cgraph_edge *e;\n@@ -923,10 +930,12 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n     count_scale = new->count * REG_BR_PROB_BASE / n->count;\n   else\n     count_scale = 0;\n-  n->count -= count;\n+  if (update_original)\n+    n->count -= count;\n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new, e->call_stmt, count_scale, loop_nest);\n+    cgraph_clone_edge (e, new, e->call_stmt, count_scale, loop_nest,\n+\t\t       update_original);\n \n   new->next_clone = n->next_clone;\n   new->prev_clone = n;"}, {"sha": "81eb10b5f3c1852396480b60569ea76e84fd81b2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -240,8 +240,11 @@ struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n-struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *, struct cgraph_node *, tree, int, int);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int);\n+struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n+\t\t\t\t        struct cgraph_node *,\n+\t\t\t\t        tree, int, int, bool);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type,\n+\t\t\t\t\tint, bool);\n \n struct cgraph_varpool_node *cgraph_varpool_node (tree);\n struct cgraph_varpool_node *cgraph_varpool_node_for_asm (tree asmname);"}, {"sha": "91a32641d371910612e8037d8da7ae6be83e6b22", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -5790,6 +5790,18 @@ happens only when @option{-finline-functions} (included in @option{-O3}) is\n enabled and @option{--param max-inline-recursive-depth-auto} is used.  The\n default value is 450.\n \n+@item min-inline-recursive-probability\n+Recursive inlining is profitable only for function having deep recursion\n+in average and can hurt for function having little recursion depth by\n+increasing the prologue size or complexity of function body to other\n+optimizers.\n+\n+When profile feedback is available (see @option{-fprofile-generate}) the actual\n+recursion depth can be guessed from probability that function will recurse via\n+given call expression.  This parameter limits inlining only to call expression\n+whose probability exceeds given threshold (in percents).  The default value is\n+10.\n+\n @item inline-call-cost\n Specify cost of call instruction relative to simple arithmetics operations\n (having cost of 1).  Increasing this cost disqualifies inlining of non-leaf"}, {"sha": "15a2af0dc277bcb06576a428ea385c02e9f5cd34", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -131,7 +131,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n     }\n    else if (duplicate)\n     {\n-      n = cgraph_clone_node (e->callee, e->count, e->loop_nest);\n+      n = cgraph_clone_node (e->callee, e->count, e->loop_nest, true);\n       cgraph_redirect_edge_callee (e, n);\n     }\n \n@@ -456,10 +456,13 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n   for (e = where->callees; e; e = e->next_callee)\n     if (e->callee == node)\n       {\n-\t/* FIXME: Once counts and frequencies are available we should drive the\n-\t   order by these.  For now force the order to be simple queue since\n-\t   we get order dependent on recursion depth for free by this.  */\n-        fibheap_insert (heap, priority++, e);\n+\t/* When profile feedback is available, prioritize by expected number\n+\t   of calls.  Without profile feedback we maintain simple queue\n+\t   to order candidates via recursive depths.  */\n+        fibheap_insert (heap,\n+\t\t\t!max_count ? priority++\n+\t\t        : -(e->count / ((max_count + (1<<24) - 1) / (1<<24))),\n+\t\t        e);\n       }\n   for (e = where->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n@@ -533,6 +536,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n {\n   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n+  int probability = PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY);\n   fibheap_t heap;\n   struct cgraph_edge *e;\n   struct cgraph_node *master_clone;\n@@ -563,35 +567,68 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t     cgraph_node_name (node));\n \n   /* We need original clone to copy around.  */\n-  master_clone = cgraph_clone_node (node, 0, 1);\n+  master_clone = cgraph_clone_node (node, node->count, 1, false);\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n       cgraph_clone_inlined_nodes (e, true);\n \n   /* Do the inlining and update list of recursive call during process.  */\n   while (!fibheap_empty (heap)\n-\t && cgraph_estimate_size_after_inlining (1, node, master_clone) <= limit)\n+\t && (cgraph_estimate_size_after_inlining (1, node, master_clone)\n+\t     <= limit))\n     {\n       struct cgraph_edge *curr = fibheap_extract_min (heap);\n-      struct cgraph_node *node;\n+      struct cgraph_node *cnode;\n \n-      depth = 0;\n-      for (node = curr->caller;\n-\t   node; node = node->global.inlined_to)\n+      depth = 1;\n+      for (cnode = curr->caller;\n+\t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n \tif (node->decl == curr->callee->decl)\n \t  depth++;\n       if (depth > max_depth)\n-\tcontinue;\n+\t{\n+          if (dump_file)\n+\t    fprintf (dump_file, \n+\t\t     \"   maxmal depth reached\\n\");\n+\t  continue;\n+\t}\n+\n+      if (max_count)\n+\t{\n+          if (!cgraph_maybe_hot_edge_p (curr))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"   Not inlining cold call\\n\");\n+\t      continue;\n+\t    }\n+          if (curr->count * 100 / node->count < probability)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \n+\t\t\t \"   Probability of edge is too small\\n\");\n+\t      continue;\n+\t    }\n+\t}\n \n       if (dump_file)\n-\tfprintf (dump_file, \n-\t\t \"   Inlining call of depth %i\\n\", depth);\n+\t{\n+\t  fprintf (dump_file, \n+\t\t   \"   Inlining call of depth %i\", depth);\n+\t  if (node->count)\n+\t    {\n+\t      fprintf (dump_file, \" called approx. %.2f times per call\",\n+\t\t       (double)curr->count / node->count);\n+\t    }\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n       cgraph_redirect_edge_callee (curr, master_clone);\n       cgraph_mark_inline_edge (curr);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;\n     }\n+  if (!fibheap_empty (heap) && dump_file)\n+    fprintf (dump_file, \"    Recursive inlining growth limit met.\\n\");\n \n   fibheap_delete (heap);\n   if (dump_file)\n@@ -607,6 +644,10 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n     if (node->global.inlined_to == master_clone)\n       cgraph_remove_node (node);\n   cgraph_remove_node (master_clone);\n+  /* FIXME: Recursive inlining actually reduces number of calls of the\n+     function.  At this place we should probably walk the function and\n+     inline clones and compensate the counts accordingly.  This probably\n+     doesn't matter much in practice.  */\n   return true;\n }\n "}, {"sha": "7b9f97c69df8c78d3858279de302bfdcf8da909e", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -116,6 +116,11 @@ DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO,\n \t  \"The maximum depth of recursive inlining for non-inline functions\",\n \t  8, 0, 0)\n \n+DEFPARAM (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY,\n+\t  \"min-inline-recursive-probability\",\n+\t  \"Inline recursively only when the probability of call being executed exceeds the parameter\",\n+\t  10, 0, 0)\n+\n /* Limit the number of expansions created by the variable expansion\n    optimization to avoid register pressure.  */\n DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,"}, {"sha": "fa6970362e2ac9ba982a5e3cee0861661d48ec5e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -752,7 +752,7 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n \t\t  edge = cgraph_edge (id->current_node, orig_stmt);\n \t\t  if (edge)\n \t\t    cgraph_clone_edge (edge, id->node, stmt,\n-\t\t\t\t       REG_BR_PROB_BASE, 1);\n+\t\t\t\t       REG_BR_PROB_BASE, 1, true);\n \t\t}\n \t    }\n \t  /* If you think we can abort here, you are wrong."}, {"sha": "d160e497cdd5b662542bd16f387c45bcbabd9f18", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a4444c50a61d6f787d4d238ed007ad626a3f6d/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=c5a4444c50a61d6f787d4d238ed007ad626a3f6d", "patch": "@@ -372,7 +372,7 @@ tree_rest_of_compilation (tree fndecl)\n \t{\n \t  struct cgraph_edge *e;\n \n-\t  saved_node = cgraph_clone_node (node, node->count, 1);\n+\t  saved_node = cgraph_clone_node (node, node->count, 1, false);\n \t  for (e = saved_node->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      cgraph_clone_inlined_nodes (e, true);"}]}