{"sha": "fbe9724cc368a76c8bb04c822a9877b9096758e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlOTcyNGNjMzY4YTc2YzhiYjA0YzgyMmE5ODc3YjkwOTY3NThlNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-30T02:09:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-30T02:09:24Z"}, "message": "runtime: fixes for -buildmode=c-archive\n    \n    With -buildmode=c-archive, initsig is called before the memory\n    allocator has been initialized.  The code was doing a memory\n    allocation because of the call to funcPC(sigtramp).  When escape\n    analysis is fully implemented, that call should not allocate.  For\n    now, finesse the issue by calling a C function to get the C function\n    pointer value of sigtramp.\n    \n    When returning from a call from C to a Go function, a deferred\n    function is run to go back to syscall mode.  When the call occurs on a\n    non-Go thread, that call sets g to nil, making it impossible to add\n    the _defer struct back to the pool.  Just drop it and let the garbage\n    collector clean it up.\n    \n    Reviewed-on: https://go-review.googlesource.com/33675\n\nFrom-SVN: r242992", "tree": {"sha": "c1565b1daa9faf905ef5d66188008c4603dd4f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1565b1daa9faf905ef5d66188008c4603dd4f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbe9724cc368a76c8bb04c822a9877b9096758e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe9724cc368a76c8bb04c822a9877b9096758e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe9724cc368a76c8bb04c822a9877b9096758e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe9724cc368a76c8bb04c822a9877b9096758e6/comments", "author": null, "committer": null, "parents": [{"sha": "f521b29334903c4e3c27d4ef67fbf602ac427df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f521b29334903c4e3c27d4ef67fbf602ac427df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f521b29334903c4e3c27d4ef67fbf602ac427df7"}], "stats": {"total": 30, "additions": 24, "deletions": 6}, "files": [{"sha": "ead134c5fe307ce913deb7a05169e9c38002149a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe9724cc368a76c8bb04c822a9877b9096758e6/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe9724cc368a76c8bb04c822a9877b9096758e6/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fbe9724cc368a76c8bb04c822a9877b9096758e6", "patch": "@@ -1,4 +1,4 @@\n-4d8e00e730897cc7e73b1582522ecab031cfcaf2\n+1d3e0ceee45012a1c3b4ff7f5119a72f90bfcf6a\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0ad178f45f61dce669d492ac00aac19302b6a4ef", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=fbe9724cc368a76c8bb04c822a9877b9096758e6", "patch": "@@ -141,6 +141,15 @@ func freedefer(d *_defer) {\n \tif d.special {\n \t\treturn\n \t}\n+\n+\t// When C code calls a Go function on a non-Go thread, the\n+\t// deferred call to cgocallBackDone will set g to nil.\n+\t// Don't crash trying to put d on the free list; just let it\n+\t// be garbage collected.\n+\tif getg() == nil {\n+\t\treturn\n+\t}\n+\n \tmp := acquirem()\n \tpp := mp.p.ptr()\n \tif len(pp.deferpool) == cap(pp.deferpool) {"}, {"sha": "d21bf4c31d7ad43ae734362ff7e01f10478a6449", "filename": "libgo/go/runtime/signal1_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal1_unix.go?ref=fbe9724cc368a76c8bb04c822a9877b9096758e6", "patch": "@@ -93,7 +93,7 @@ func initsig(preinit bool) {\n \t\t}\n \n \t\tt.flags |= _SigHandling\n-\t\tsetsig(i, funcPC(sigtramp), true)\n+\t\tsetsig(i, getSigtramp(), true)\n \t}\n }\n \n@@ -137,7 +137,7 @@ func sigenable(sig uint32) {\n \t\tif t.flags&_SigHandling == 0 {\n \t\t\tt.flags |= _SigHandling\n \t\t\tfwdSig[sig] = getsig(int32(sig))\n-\t\t\tsetsig(int32(sig), funcPC(sigtramp), true)\n+\t\t\tsetsig(int32(sig), getSigtramp(), true)\n \t\t}\n \t}\n }\n@@ -265,7 +265,7 @@ func raisebadsignal(sig int32, c *sigctxt) {\n \t// We may receive another instance of the signal before we\n \t// restore the Go handler, but that is not so bad: we know\n \t// that the Go program has been ignoring the signal.\n-\tsetsig(sig, funcPC(sigtramp), true)\n+\tsetsig(sig, getSigtramp(), true)\n }\n \n func crash() {"}, {"sha": "b2f1829feced1234bfeec52507b37e98dbd60594", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=fbe9724cc368a76c8bb04c822a9877b9096758e6", "patch": "@@ -502,8 +502,8 @@ func goexit1()\n func schedtrace(bool)\n func freezetheworld()\n \n-// Signal trampoline, written in C.\n-func sigtramp()\n+// Get signal trampoline, written in C.\n+func getSigtramp() uintptr\n \n // The sa_handler field is generally hidden in a union, so use C accessors.\n func getSigactionHandler(*_sigaction) uintptr"}, {"sha": "711f71e8731b3d5751ba69c6e2f7fd4a8caafa81", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe9724cc368a76c8bb04c822a9877b9096758e6/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=fbe9724cc368a76c8bb04c822a9877b9096758e6", "patch": "@@ -140,6 +140,15 @@ sigtramp(int sig, siginfo_t *info, void *context)\n \n #endif // USING_SPLIT_STACK\n \n+// C function to return the address of the sigtramp function.\n+uintptr getSigtramp(void) __asm__ (GOSYM_PREFIX \"runtime.getSigtramp\");\n+\n+uintptr\n+getSigtramp()\n+{\n+  return (uintptr)(void*)sigtramp;\n+}\n+\n // C code to manage the sigaction sa_sigaction field, which is\n // typically a union and so hard for mksysinfo.sh to handle.\n "}]}