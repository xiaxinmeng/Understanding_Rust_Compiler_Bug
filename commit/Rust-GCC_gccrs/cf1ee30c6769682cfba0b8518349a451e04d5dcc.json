{"sha": "cf1ee30c6769682cfba0b8518349a451e04d5dcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxZWUzMGM2NzY5NjgyY2ZiYTBiODUxODM0OWE0NTFlMDRkNWRjYw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-08-02T12:44:27Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-08-02T12:44:27Z"}, "message": "cppfiles.c (ENOTDIR): Remove.\n\n\t* cppfiles.c (ENOTDIR): Remove.\n\t(open_file_in_dir): Rename find_file_in_dir.  Handle errors\n\tother than ENOENT here.\n\t(once_only_file_p): Rename should_stack_file.\n\t(find_file, open_file_failed, read_file_guts): Report errors\n\twith full path name.\n\t(read_file): Move pch handling to should_stack_file.\n\t(should_stack_file): Handle PCH and once-only issues, and\n\treading the file.\n\t(stack_file): Don't do file reads.\n\nFrom-SVN: r70104", "tree": {"sha": "64be4d0dc2f1507fd9a6f9c68c3620d0534493f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64be4d0dc2f1507fd9a6f9c68c3620d0534493f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf1ee30c6769682cfba0b8518349a451e04d5dcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1ee30c6769682cfba0b8518349a451e04d5dcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf1ee30c6769682cfba0b8518349a451e04d5dcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1ee30c6769682cfba0b8518349a451e04d5dcc/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7318eb21d1fc8ae39dae0e6c4f7c3da8f5ae5865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7318eb21d1fc8ae39dae0e6c4f7c3da8f5ae5865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7318eb21d1fc8ae39dae0e6c4f7c3da8f5ae5865"}], "stats": {"total": 184, "additions": 98, "deletions": 86}, "files": [{"sha": "e0b7577f90147711fb9ee4e9919b2727103f6074", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1ee30c6769682cfba0b8518349a451e04d5dcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1ee30c6769682cfba0b8518349a451e04d5dcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf1ee30c6769682cfba0b8518349a451e04d5dcc", "patch": "@@ -1,3 +1,16 @@\n+2003-08-02  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cppfiles.c (ENOTDIR): Remove.\n+\t(open_file_in_dir): Rename find_file_in_dir.  Handle errors\n+\tother than ENOENT here.\n+\t(once_only_file_p): Rename should_stack_file.\n+\t(find_file, open_file_failed, read_file_guts): Report errors\n+\twith full path name.\n+\t(read_file): Move pch handling to should_stack_file.\n+\t(should_stack_file): Handle PCH and once-only issues, and\n+\treading the file.\n+\t(stack_file): Don't do file reads.\n+\n 2003-08-02  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* libgcov.c (gcov_exit): Cleanup and fix."}, {"sha": "2f0ed343b9bef50354939744f2f1dc4e8c71e0d2", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 85, "deletions": 86, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1ee30c6769682cfba0b8518349a451e04d5dcc/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1ee30c6769682cfba0b8518349a451e04d5dcc/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=cf1ee30c6769682cfba0b8518349a451e04d5dcc", "patch": "@@ -50,9 +50,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #ifndef O_BINARY\n # define O_BINARY 0\n #endif\n-#ifndef ENOTDIR\n-# define ENOTDIR 0\n-#endif\n \n /* This structure represents a file searched for by CPP, whether it\n    exists or not.  An instance may be pointed to by more than one\n@@ -162,13 +159,13 @@ struct file_hash_entry\n \n static bool open_file (_cpp_file *file);\n static bool pch_open_file (cpp_reader *pfile, _cpp_file *file);\n-static bool open_file_in_dir (cpp_reader *pfile, _cpp_file *file);\n+static bool find_file_in_dir (cpp_reader *pfile, _cpp_file *file);\n static _cpp_file *find_file (cpp_reader *, const char *fname,\n \t\t\t     cpp_dir *start_dir, bool fake);\n static bool read_file_guts (cpp_reader *pfile, _cpp_file *file);\n static bool read_file (cpp_reader *pfile, _cpp_file *file);\n static bool stack_file (cpp_reader *, _cpp_file *file, bool import);\n-static bool once_only_file_p (cpp_reader *, _cpp_file *file, bool import);\n+static bool should_stack_file (cpp_reader *, _cpp_file *file, bool import);\n static struct cpp_dir *search_path_head (cpp_reader *, const char *fname,\n \t\t\t\t int angle_brackets, enum include_type);\n static const char *dir_name_of_file (_cpp_file *file);\n@@ -300,9 +297,10 @@ pch_open_file (cpp_reader *pfile, _cpp_file *file)\n }\n \n /* Try to open the path FILE->name appended to FILE->dir.  This is\n-   where remap and PCH intercept the file lookup process.  */\n+   where remap and PCH intercept the file lookup process.  Return true\n+   if the file was found, whether or not the open was successful.  */\n static bool\n-open_file_in_dir (cpp_reader *pfile, _cpp_file *file)\n+find_file_in_dir (cpp_reader *pfile, _cpp_file *file)\n {\n   char *path;\n \n@@ -318,8 +316,14 @@ open_file_in_dir (cpp_reader *pfile, _cpp_file *file)\n   if (open_file (file))\n     return true;\n \n+  if (file->err_no != ENOENT)\n+    {\n+      open_file_failed (pfile, file);\n+      return true;\n+    }\n+\n   free (path);\n-  file->path = NULL;\n+  file->path = file->name;\n   return false;\n }\n \n@@ -360,10 +364,11 @@ find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool fake)\n   /* Try each path in the include chain.  */\n   for (; !fake ;)\n     {\n-      if (open_file_in_dir (pfile, file))\n+      if (find_file_in_dir (pfile, file))\n \tbreak;\n \n-      if (file->err_no != ENOENT || (file->dir = file->dir->next) == NULL)\n+      file->dir = file->dir->next;\n+      if (file->dir == NULL)\n \t{\n \t  open_file_failed (pfile, file);\n \t  break;\n@@ -414,7 +419,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n   \n   if (S_ISBLK (file->st.st_mode))\n     {\n-      cpp_error (pfile, DL_ERROR, \"%s is a block device\", file->name);\n+      cpp_error (pfile, DL_ERROR, \"%s is a block device\", file->path);\n       return false;\n     }\n \n@@ -431,7 +436,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n \t does not bite us.  */\n       if (file->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", file->name);\n+\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", file->path);\n \t  return false;\n \t}\n \n@@ -460,12 +465,12 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n \n   if (count < 0)\n     {\n-      cpp_errno (pfile, DL_ERROR, file->name);\n+      cpp_errno (pfile, DL_ERROR, file->path);\n       return false;\n     }\n \n   if (regular && total != size && STAT_SIZE_RELIABLE (file->st))\n-    cpp_error (pfile, DL_WARNING, \"%s is shorter than expected\", file->name);\n+    cpp_error (pfile, DL_WARNING, \"%s is shorter than expected\", file->path);\n \n   /* Shrink buffer if we allocated substantially too much.  */\n   if (total + 4096 < size)\n@@ -487,19 +492,6 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n static bool\n read_file (cpp_reader *pfile, _cpp_file *file)\n {\n-  /* Skip if the file had a header guard and the macro is defined.  */\n-  if (file->cmacro && file->cmacro->type == NT_MACRO)\n-    return false;\n-\n-  /* PCH files get dealt with immediately.  */\n-  if (include_pch_p (file))\n-    {\n-      pfile->cb.read_pch (pfile, file->path, file->fd, file->pchname);\n-      close (file->fd);\n-      file->fd = -1;\n-      return false;\n-    }\n-\n   /* If we already have its contents in memory, succeed immediately.  */\n   if (file->buffer_valid)\n     return true;\n@@ -521,79 +513,44 @@ read_file (cpp_reader *pfile, _cpp_file *file)\n   return !file->dont_read;\n }\n \n-/* Place the file referenced by FILE into a new buffer on the buffer\n-   stack if possible.  IMPORT is true if this stacking attempt is\n-   because of a #import directive.  Returns true if a buffer is\n-   stacked.  */\n+/* Returns TRUE if FILE's contents have been successfully placed in\n+   FILE->buffer and the file should be stacked, otherwise false.  */\n static bool\n-stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n+should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n {\n-  cpp_buffer *buffer;\n-  int sysp;\n-  const char *fname;\n-\n-  if (once_only_file_p (pfile, file, import))\n-      return false;\n+  _cpp_file *f;\n \n-  if (!read_file (pfile, file))\n+  /* Skip if the file had a header guard and the macro is defined.\n+     PCH relies on this appearing before the PCH handler below.  */\n+  if (file->cmacro && file->cmacro->type == NT_MACRO)\n     return false;\n \n-  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n-\t      (file->dir ? file->dir->sysp : 0));\n-\n-  /* Add the file to the dependencies on its first inclusion.  */\n-  if (CPP_OPTION (pfile, deps.style) > !!sysp && !file->stack_count)\n+  /* Handle PCH files immediately; don't stack them.  */\n+  if (include_pch_p (file))\n     {\n-      if (!file->main_file || !CPP_OPTION (pfile, deps.ignore_main_file))\n-\tdeps_add_dep (pfile->deps, file->path);\n+      pfile->cb.read_pch (pfile, file->path, file->fd, file->pchname);\n+      close (file->fd);\n+      file->fd = -1;\n+      return false;\n     }\n \n-  /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n-  file->buffer_valid = false;\n-  file->stack_count++;\n-\n-  /* Stack the buffer.  */\n-  buffer = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n-\t\t\t    CPP_OPTION (pfile, preprocessed), 0);\n-  buffer->file = file;\n-\n-  /* Initialize controlling macro state.  */\n-  pfile->mi_valid = true;\n-  pfile->mi_cmacro = 0;\n-\n-  /* Generate the call back.  */\n-  fname = file->name;\n-  _cpp_do_file_change (pfile, LC_ENTER, fname, 1, sysp);\n-\n-  return true;\n-}\n-\n-/* Returns TRUE if FILE has been previously read and should not be\n-   read again.  */\n-static bool\n-once_only_file_p (cpp_reader *pfile, _cpp_file *file, bool import)\n-{\n-  _cpp_file *f;\n-\n-  /* Nothing to check if this isn't #import and there haven't been any\n-     #pragma_once directives.  */\n-  if (!import && !pfile->saw_pragma_once)\n-    return false;\n-\n   /* Did this file contain #pragma once?  */\n   if (file->pragma_once)\n-    return true;\n+    return false;\n \n   /* Are we #import-ing a previously #import-ed file?  */\n   if (import && file->import)\n-    return true;\n+    return false;\n \n-  /* Read the file contents now.  stack_file would do it later, and\n-     we're smart enough to not do it twice, so this is no loss.  Note\n-     we don't mark the file once-only if we can't read it.  */\n+  /* Read the file's contents.  */\n   if (!read_file (pfile, file))\n     return false;\n \n+  /* Nothing to check if this isn't #import and there haven't been any\n+     #pragma_once directives.  */\n+  if (!import && !pfile->saw_pragma_once)\n+    return true;\n+\n   /* We may have #imported it under a different name, though.  Look\n      for likely candidates and compare file contents to be sure.  */\n   for (f = pfile->once_only_files; f; f = f->once_only_next)\n@@ -617,7 +574,49 @@ once_only_file_p (cpp_reader *pfile, _cpp_file *file, bool import)\n   if (import || f != NULL)\n     _cpp_mark_file_once_only (pfile, file, import);\n \n-  return f != NULL;\n+  return f == NULL;\n+}\n+\n+/* Place the file referenced by FILE into a new buffer on the buffer\n+   stack if possible.  IMPORT is true if this stacking attempt is\n+   because of a #import directive.  Returns true if a buffer is\n+   stacked.  */\n+static bool\n+stack_file (cpp_reader *pfile, _cpp_file *file, bool import)\n+{\n+  cpp_buffer *buffer;\n+  int sysp;\n+\n+  if (!should_stack_file (pfile, file, import))\n+      return false;\n+\n+  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n+\t      (file->dir ? file->dir->sysp : 0));\n+\n+  /* Add the file to the dependencies on its first inclusion.  */\n+  if (CPP_OPTION (pfile, deps.style) > !!sysp && !file->stack_count)\n+    {\n+      if (!file->main_file || !CPP_OPTION (pfile, deps.ignore_main_file))\n+\tdeps_add_dep (pfile->deps, file->path);\n+    }\n+\n+  /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n+  file->buffer_valid = false;\n+  file->stack_count++;\n+\n+  /* Stack the buffer.  */\n+  buffer = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n+\t\t\t    CPP_OPTION (pfile, preprocessed), 0);\n+  buffer->file = file;\n+\n+  /* Initialize controlling macro state.  */\n+  pfile->mi_valid = true;\n+  pfile->mi_cmacro = 0;\n+\n+  /* Generate the call back.  */\n+  _cpp_do_file_change (pfile, LC_ENTER, file->name, 1, sysp);\n+\n+  return true;\n }\n \n /* Mark FILE to be included once only.  IMPORT is true if because of\n@@ -742,9 +741,9 @@ open_file_failed (cpp_reader *pfile, _cpp_file *file)\n       /* If we are outputting dependencies but not for this file then\n \t don't error because we can still produce correct output.  */\n       if (CPP_OPTION (pfile, deps.style) && ! print_dep)\n-\tcpp_errno (pfile, DL_WARNING, file->name);\n+\tcpp_errno (pfile, DL_WARNING, file->path);\n       else\n-\tcpp_errno (pfile, DL_ERROR, file->name);\n+\tcpp_errno (pfile, DL_ERROR, file->path);\n     }\n }\n "}]}