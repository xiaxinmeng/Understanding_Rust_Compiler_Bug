{"sha": "83afd959dda01e64d5c33430567fc93316b8ed3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhZmQ5NTlkZGEwMWU2NGQ1YzMzNDMwNTY3ZmM5MzMxNmI4ZWQzYw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2016-11-08T13:47:23Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2016-11-08T13:47:23Z"}, "message": "[ARM][2/2] Remove old rtx costs\n\n\t* config/arm/arm.opt (mold-rtx-costs): Delete.\n\t(mnew-generic-costs): Delete.\n\t* config/arm/arm-protos.h (struct tune_params): Delete rtx_costs field.\n\t* config/arm/arm.c (arm_rtx_costs_1): Delete.\n\t(arm_size_rtx_costs): Likewise.\n\t(arm_slowmul_rtx_costs): Likewise.\n\t(arm_fastmul_rtx_costs): Likewise.\n\t(arm_xscale_rtx_costs): Likewise.\n\t(arm_9e_rtx_costs): Likewise.\n\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune,\n\tarm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune,\n\tarm_cortex_a8_tune, arm_cortex_a7_tune, arm_cortex_a15_tune,\n\tarm_cortex_a53_tune, arm_cortex_a57_tune, arm_cortex_a9_tune,\n\tarm_cortex_a12_tune, arm_v7m_tune, arm_v6m_tune, arm_fa726te_tune\n\tarm_cortex_a5_tune, arm_xgene1_tune, arm_marvell_pj4_tune,\n\tarm_cortex_a35_tune, arm_exynosm1_tune, arm_cortex_a73_tune,\n\tarm_cortex_m7_tune):\n\tDelete rtx_costs field.\n\t(arm_new_rtx_costs): Rename to...\n\t(arm_rtx_costs_internal): ... This.\n\t(arm_rtx_costs): Remove old way of doing rtx costs.\n\nFrom-SVN: r241966", "tree": {"sha": "e7b2a2aa172dcf5d6db95932fa5bc6fd52252597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7b2a2aa172dcf5d6db95932fa5bc6fd52252597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83afd959dda01e64d5c33430567fc93316b8ed3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83afd959dda01e64d5c33430567fc93316b8ed3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83afd959dda01e64d5c33430567fc93316b8ed3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83afd959dda01e64d5c33430567fc93316b8ed3c/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "249a3cad8a471d55f0ccd52c88d32706eb9a68ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/249a3cad8a471d55f0ccd52c88d32706eb9a68ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/249a3cad8a471d55f0ccd52c88d32706eb9a68ab"}], "stats": {"total": 1360, "additions": 85, "deletions": 1275}, "files": [{"sha": "926197ec83fff7d5a340967665073abb5301e4d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83afd959dda01e64d5c33430567fc93316b8ed3c", "patch": "@@ -1,3 +1,27 @@\n+2016-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/arm.opt (mold-rtx-costs): Delete.\n+\t(mnew-generic-costs): Delete.\n+\t* config/arm/arm-protos.h (struct tune_params): Delete rtx_costs field.\n+\t* config/arm/arm.c (arm_rtx_costs_1): Delete.\n+\t(arm_size_rtx_costs): Likewise.\n+\t(arm_slowmul_rtx_costs): Likewise.\n+\t(arm_fastmul_rtx_costs): Likewise.\n+\t(arm_xscale_rtx_costs): Likewise.\n+\t(arm_9e_rtx_costs): Likewise.\n+\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune,\n+\tarm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune,\n+\tarm_cortex_a8_tune, arm_cortex_a7_tune, arm_cortex_a15_tune,\n+\tarm_cortex_a53_tune, arm_cortex_a57_tune, arm_cortex_a9_tune,\n+\tarm_cortex_a12_tune, arm_v7m_tune, arm_v6m_tune, arm_fa726te_tune\n+\tarm_cortex_a5_tune, arm_xgene1_tune, arm_marvell_pj4_tune,\n+\tarm_cortex_a35_tune, arm_exynosm1_tune, arm_cortex_a73_tune,\n+\tarm_cortex_m7_tune):\n+\tDelete rtx_costs field.\n+\t(arm_new_rtx_costs): Rename to...\n+\t(arm_rtx_costs_internal): ... This.\n+\t(arm_rtx_costs): Remove old way of doing rtx costs.\n+\n 2016-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.c (arm_slowmul_tune): Use generic_extra_costs."}, {"sha": "95bae5ef57ba4c433c0cce8e0c197959abdf887b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=83afd959dda01e64d5c33430567fc93316b8ed3c", "patch": "@@ -260,7 +260,6 @@ struct cpu_cost_table;\n \n struct tune_params\n {\n-  bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);\n   const struct cpu_cost_table *insn_extra_cost;\n   bool (*sched_adjust_cost) (rtx_insn *, int, rtx_insn *, int *);\n   int (*branch_cost) (bool, bool);"}, {"sha": "13f61f49ff8f4c460529772283be282a354264e4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 61, "deletions": 1266, "changes": 1327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=83afd959dda01e64d5c33430567fc93316b8ed3c", "patch": "@@ -165,12 +165,6 @@ static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n static bool arm_have_conditional_execution (void);\n static bool arm_cannot_force_const_mem (machine_mode, rtx);\n static bool arm_legitimate_constant_p (machine_mode, rtx);\n-static bool arm_rtx_costs_1 (rtx, enum rtx_code, int*, bool);\n-static bool arm_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);\n-static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n-static bool arm_fastmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n-static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n-static bool arm_9e_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int arm_address_cost (rtx, machine_mode, addr_space_t, bool);\n static int arm_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n@@ -1703,7 +1697,6 @@ const struct cpu_cost_table v7m_extra_costs =\n \n const struct tune_params arm_slowmul_tune =\n {\n-  arm_slowmul_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1726,7 +1719,6 @@ const struct tune_params arm_slowmul_tune =\n \n const struct tune_params arm_fastmul_tune =\n {\n-  arm_fastmul_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1752,7 +1744,6 @@ const struct tune_params arm_fastmul_tune =\n \n const struct tune_params arm_strongarm_tune =\n {\n-  arm_fastmul_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1775,7 +1766,6 @@ const struct tune_params arm_strongarm_tune =\n \n const struct tune_params arm_xscale_tune =\n {\n-  arm_xscale_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   xscale_sched_adjust_cost,\n   arm_default_branch_cost,\n@@ -1798,7 +1788,6 @@ const struct tune_params arm_xscale_tune =\n \n const struct tune_params arm_9e_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1821,7 +1810,6 @@ const struct tune_params arm_9e_tune =\n \n const struct tune_params arm_marvell_pj4_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1844,7 +1832,6 @@ const struct tune_params arm_marvell_pj4_tune =\n \n const struct tune_params arm_v6t2_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1869,7 +1856,6 @@ const struct tune_params arm_v6t2_tune =\n /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */\n const struct tune_params arm_cortex_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1892,7 +1878,6 @@ const struct tune_params arm_cortex_tune =\n \n const struct tune_params arm_cortex_a8_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa8_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1915,7 +1900,6 @@ const struct tune_params arm_cortex_a8_tune =\n \n const struct tune_params arm_cortex_a7_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa7_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1938,7 +1922,6 @@ const struct tune_params arm_cortex_a7_tune =\n \n const struct tune_params arm_cortex_a15_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa15_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1961,7 +1944,6 @@ const struct tune_params arm_cortex_a15_tune =\n \n const struct tune_params arm_cortex_a35_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa53_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -1984,7 +1966,6 @@ const struct tune_params arm_cortex_a35_tune =\n \n const struct tune_params arm_cortex_a53_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa53_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2007,7 +1988,6 @@ const struct tune_params arm_cortex_a53_tune =\n \n const struct tune_params arm_cortex_a57_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa57_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2030,7 +2010,6 @@ const struct tune_params arm_cortex_a57_tune =\n \n const struct tune_params arm_exynosm1_tune =\n {\n-  arm_9e_rtx_costs,\n   &exynosm1_extra_costs,\n   NULL,\t\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2053,7 +2032,6 @@ const struct tune_params arm_exynosm1_tune =\n \n const struct tune_params arm_xgene1_tune =\n {\n-  arm_9e_rtx_costs,\n   &xgene1_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2076,7 +2054,6 @@ const struct tune_params arm_xgene1_tune =\n \n const struct tune_params arm_qdf24xx_tune =\n {\n-  arm_9e_rtx_costs,\n   &qdf24xx_extra_costs,\n   NULL,                                         /* Scheduler cost adjustment.  */\n   arm_default_branch_cost,\n@@ -2102,7 +2079,6 @@ const struct tune_params arm_qdf24xx_tune =\n \n const struct tune_params arm_cortex_a5_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa5_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_cortex_a5_branch_cost,\n@@ -2125,7 +2101,6 @@ const struct tune_params arm_cortex_a5_tune =\n \n const struct tune_params arm_cortex_a9_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa9_extra_costs,\n   cortex_a9_sched_adjust_cost,\n   arm_default_branch_cost,\n@@ -2148,7 +2123,6 @@ const struct tune_params arm_cortex_a9_tune =\n \n const struct tune_params arm_cortex_a12_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa12_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2171,7 +2145,6 @@ const struct tune_params arm_cortex_a12_tune =\n \n const struct tune_params arm_cortex_a73_tune =\n {\n-  arm_9e_rtx_costs,\n   &cortexa57_extra_costs,\n   NULL,\t\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2201,7 +2174,6 @@ const struct tune_params arm_cortex_a73_tune =\n \n const struct tune_params arm_v7m_tune =\n {\n-  arm_9e_rtx_costs,\n   &v7m_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_cortex_m_branch_cost,\n@@ -2226,7 +2198,6 @@ const struct tune_params arm_v7m_tune =\n \n const struct tune_params arm_cortex_m7_tune =\n {\n-  arm_9e_rtx_costs,\n   &v7m_extra_costs,\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_cortex_m7_branch_cost,\n@@ -2252,7 +2223,6 @@ const struct tune_params arm_cortex_m7_tune =\n    cortex-m23.  */\n const struct tune_params arm_v6m_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\t\t\t/* Insn extra costs.  */\n   NULL,\t\t\t\t\t/* Sched adj cost.  */\n   arm_default_branch_cost,\n@@ -2275,7 +2245,6 @@ const struct tune_params arm_v6m_tune =\n \n const struct tune_params arm_fa726te_tune =\n {\n-  arm_9e_rtx_costs,\n   &generic_extra_costs,\t\t\t\t/* Insn extra costs.  */\n   fa726te_sched_adjust_cost,\n   arm_default_branch_cost,\n@@ -8474,621 +8443,6 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n     }\n }\n \n-static inline bool\n-arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n-{\n-  machine_mode mode = GET_MODE (x);\n-  enum rtx_code subcode;\n-  rtx operand;\n-  enum rtx_code code = GET_CODE (x);\n-  *total = 0;\n-\n-  switch (code)\n-    {\n-    case MEM:\n-      /* Memory costs quite a lot for the first word, but subsequent words\n-\t load at the equivalent of a single insn each.  */\n-      *total = COSTS_N_INSNS (2 + ARM_NUM_REGS (mode));\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      if (TARGET_HARD_FLOAT && mode == SFmode)\n-\t*total = COSTS_N_INSNS (2);\n-      else if (TARGET_HARD_FLOAT && mode == DFmode && !TARGET_VFP_SINGLE)\n-\t*total = COSTS_N_INSNS (4);\n-      else\n-\t*total = COSTS_N_INSNS (20);\n-      return false;\n-\n-    case ROTATE:\n-      if (REG_P (XEXP (x, 1)))\n-\t*total = COSTS_N_INSNS (1); /* Need to subtract from 32 */\n-      else if (!CONST_INT_P (XEXP (x, 1)))\n-\t*total = rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\n-      /* Fall through */\n-    case ROTATERT:\n-      if (mode != SImode)\n-\t{\n-\t  *total += COSTS_N_INSNS (4);\n-\t  return true;\n-\t}\n-\n-      /* Fall through */\n-    case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n-      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-      if (mode == DImode)\n-\t{\n-\t  *total += COSTS_N_INSNS (3);\n-\t  return true;\n-\t}\n-\n-      *total += COSTS_N_INSNS (1);\n-      /* Increase the cost of complex shifts because they aren't any faster,\n-         and reduce dual issue opportunities.  */\n-      if (arm_tune_cortex_a9\n-\t  && outer != SET && !CONST_INT_P (XEXP (x, 1)))\n-\t++*total;\n-\n-      return true;\n-\n-    case MINUS:\n-      if (mode == DImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-\t  if (CONST_INT_P (XEXP (x, 0))\n-\t      && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n-\t    {\n-\t      *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t      return true;\n-\t    }\n-\n-\t  if (CONST_INT_P (XEXP (x, 1))\n-\t      && const_ok_for_arm (INTVAL (XEXP (x, 1))))\n-\t    {\n-\t      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t      return true;\n-\t    }\n-\n-\t  return false;\n-\t}\n-\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      if (CONST_DOUBLE_P (XEXP (x, 0))\n-\t\t  && arm_const_double_rtx (XEXP (x, 0)))\n-\t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t\t  return true;\n-\t\t}\n-\n-\t      if (CONST_DOUBLE_P (XEXP (x, 1))\n-\t\t  && arm_const_double_rtx (XEXP (x, 1)))\n-\t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t\t  return true;\n-\t\t}\n-\n-\t      return false;\n-\t    }\n-\t  *total = COSTS_N_INSNS (20);\n-\t  return false;\n-\t}\n-\n-      *total = COSTS_N_INSNS (1);\n-      if (CONST_INT_P (XEXP (x, 0))\n-\t  && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  return true;\n-\t}\n-\n-      subcode = GET_CODE (XEXP (x, 1));\n-      if (subcode == ASHIFT || subcode == ASHIFTRT\n-\t  || subcode == LSHIFTRT\n-\t  || subcode == ROTATE || subcode == ROTATERT)\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      /* A shift as a part of RSB costs no more than RSB itself.  */\n-      if (GET_CODE (XEXP (x, 0)) == MULT\n-\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n-\t{\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, code, 0, speed);\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  return true;\n-\t}\n-\n-      if (subcode == MULT\n-\t  && power_of_two_operand (XEXP (XEXP (x, 1), 1), SImode))\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == RTX_COMPARE\n-\t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == RTX_COMM_COMPARE)\n-\t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, speed);\n-\t  if (REG_P (XEXP (XEXP (x, 1), 0))\n-\t      && REGNO (XEXP (XEXP (x, 1), 0)) != CC_REGNUM)\n-\t    *total += COSTS_N_INSNS (1);\n-\n-\t  return true;\n-\t}\n-\n-      /* Fall through */\n-\n-    case PLUS:\n-      if (code == PLUS && arm_arch6 && mode == SImode\n-\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n-\t{\n-\t  *total = COSTS_N_INSNS (1);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode,\n-\t\t\t      GET_CODE (XEXP (x, 0)), 0, speed);\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  return true;\n-\t}\n-\n-      /* MLA: All arguments must be registers.  We filter out\n-\t multiplication by a power of two, so that we fall down into\n-\t the code below.  */\n-      if (GET_CODE (XEXP (x, 0)) == MULT\n-\t  && !power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n-\t{\n-\t  /* The cost comes from the cost of the multiply.  */\n-\t  return false;\n-\t}\n-\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      if (CONST_DOUBLE_P (XEXP (x, 1))\n-\t\t  && arm_const_double_rtx (XEXP (x, 1)))\n-\t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t\t  return true;\n-\t\t}\n-\n-\t      return false;\n-\t    }\n-\n-\t  *total = COSTS_N_INSNS (20);\n-\t  return false;\n-\t}\n-\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMPARE\n-\t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMM_COMPARE)\n-\t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 1), mode, code,\n-\t\t\t\t\t\t 1, speed);\n-\t  if (REG_P (XEXP (XEXP (x, 0), 0))\n-\t      && REGNO (XEXP (XEXP (x, 0), 0)) != CC_REGNUM)\n-\t    *total += COSTS_N_INSNS (1);\n-\t  return true;\n-\t}\n-\n-      /* Fall through */\n-\n-    case AND: case XOR: case IOR:\n-\n-      /* Normally the frame registers will be spilt into reg+const during\n-\t reload, so it is a bad idea to combine them with other instructions,\n-\t since then they might not be moved outside of loops.  As a compromise\n-\t we allow integration with ops that have a constant as their second\n-\t operand.  */\n-      if (REG_OR_SUBREG_REG (XEXP (x, 0))\n-\t  && ARM_FRAME_RTX (REG_OR_SUBREG_RTX (XEXP (x, 0)))\n-\t  && !CONST_INT_P (XEXP (x, 1)))\n-\t*total = COSTS_N_INSNS (1);\n-\n-      if (mode == DImode)\n-\t{\n-\t  *total += COSTS_N_INSNS (2);\n-\t  if (CONST_INT_P (XEXP (x, 1))\n-\t      && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n-\t    {\n-\t      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t      return true;\n-\t    }\n-\n-\t  return false;\n-\t}\n-\n-      *total += COSTS_N_INSNS (1);\n-      if (CONST_INT_P (XEXP (x, 1))\n-\t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t  return true;\n-\t}\n-      subcode = GET_CODE (XEXP (x, 0));\n-      if (subcode == ASHIFT || subcode == ASHIFTRT\n-\t  || subcode == LSHIFTRT\n-\t  || subcode == ROTATE || subcode == ROTATERT)\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      if (subcode == MULT\n-\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      if (subcode == UMIN || subcode == UMAX\n-\t  || subcode == SMIN || subcode == SMAX)\n-\t{\n-\t  *total = COSTS_N_INSNS (3);\n-\t  return true;\n-\t}\n-\n-      return false;\n-\n-    case MULT:\n-      /* This should have been handled by the CPU specific routines.  */\n-      gcc_unreachable ();\n-\n-    case TRUNCATE:\n-      if (arm_arch3m && mode == SImode\n-\t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n-\t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0))\n-\t      == GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n-\t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == SIGN_EXTEND))\n-\t{\n-\t  *total = rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, LSHIFTRT,\n-\t\t\t     0, speed);\n-\t  return true;\n-\t}\n-      *total = COSTS_N_INSNS (2); /* Plus the cost of the MULT */\n-      return false;\n-\n-    case NEG:\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return false;\n-\t    }\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return false;\n-\t}\n-\n-      /* Fall through */\n-    case NOT:\n-      *total = COSTS_N_INSNS (ARM_NUM_REGS(mode));\n-      if (mode == SImode && code == NOT)\n-\t{\n-\t  subcode = GET_CODE (XEXP (x, 0));\n-\t  if (subcode == ASHIFT || subcode == ASHIFTRT\n-\t      || subcode == LSHIFTRT\n-\t      || subcode == ROTATE || subcode == ROTATERT\n-\t      || (subcode == MULT\n-\t\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode)))\n-\t    {\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode,\n-\t\t\t\t  0, speed);\n-\t      /* Register shifts cost an extra cycle.  */\n-\t      if (!CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n-\t\t*total += COSTS_N_INSNS (1) + rtx_cost (XEXP (XEXP (x, 0), 1),\n-\t\t\t\t\t\t\tmode, subcode,\n-\t\t\t\t\t\t\t1, speed);\n-\t      return true;\n-\t    }\n-\t}\n-\n-      return false;\n-\n-    case IF_THEN_ELSE:\n-      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n-\t{\n-\t  *total = COSTS_N_INSNS (4);\n-\t  return true;\n-\t}\n-\n-      operand = XEXP (x, 0);\n-\n-      if (!((GET_RTX_CLASS (GET_CODE (operand)) == RTX_COMPARE\n-\t     || GET_RTX_CLASS (GET_CODE (operand)) == RTX_COMM_COMPARE)\n-\t    && REG_P (XEXP (operand, 0))\n-\t    && REGNO (XEXP (operand, 0)) == CC_REGNUM))\n-\t*total += COSTS_N_INSNS (1);\n-      *total += rtx_cost (XEXP (x, 1), VOIDmode, code, 1, speed);\n-      *total += rtx_cost (XEXP (x, 2), VOIDmode, code, 2, speed);\n-      return true;\n-\n-    case NE:\n-      if (mode == SImode && XEXP (x, 1) == const0_rtx)\n-\t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, speed);\n-\t  return true;\n-\t}\n-      goto scc_insn;\n-\n-    case GE:\n-      if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n-\t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n-\t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, speed);\n-\t  return true;\n-\t}\n-      goto scc_insn;\n-\n-    case LT:\n-      if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n-\t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n-\t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, speed);\n-\t  return true;\n-\t}\n-      goto scc_insn;\n-\n-    case EQ:\n-    case GT:\n-    case LE:\n-    case GEU:\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-    case UNORDERED:\n-    case ORDERED:\n-    case UNEQ:\n-    case UNGE:\n-    case UNLT:\n-    case UNGT:\n-    case UNLE:\n-    scc_insn:\n-      /* SCC insns.  In the case where the comparison has already been\n-\t performed, then they cost 2 instructions.  Otherwise they need\n-\t an additional comparison before them.  */\n-      *total = COSTS_N_INSNS (2);\n-      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) == CC_REGNUM)\n-\t{\n-\t  return true;\n-\t}\n-\n-      /* Fall through */\n-    case COMPARE:\n-      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) == CC_REGNUM)\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-\n-      *total += COSTS_N_INSNS (1);\n-      if (CONST_INT_P (XEXP (x, 1))\n-\t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n-\t{\n-\t  *total += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed);\n-\t  return true;\n-\t}\n-\n-      subcode = GET_CODE (XEXP (x, 0));\n-      if (subcode == ASHIFT || subcode == ASHIFTRT\n-\t  || subcode == LSHIFTRT\n-\t  || subcode == ROTATE || subcode == ROTATERT)\n-\t{\n-\t  mode = GET_MODE (XEXP (x, 0));\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      if (subcode == MULT\n-\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n-\t{\n-\t  mode = GET_MODE (XEXP (x, 0));\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n-\t  return true;\n-\t}\n-\n-      return false;\n-\n-    case UMIN:\n-    case UMAX:\n-    case SMIN:\n-    case SMAX:\n-      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-      if (!CONST_INT_P (XEXP (x, 1))\n-\t  || !const_ok_for_arm (INTVAL (XEXP (x, 1))))\n-\t*total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n-      return true;\n-\n-    case ABS:\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return false;\n-\t    }\n-\t  *total = COSTS_N_INSNS (20);\n-\t  return false;\n-\t}\n-      *total = COSTS_N_INSNS (1);\n-      if (mode == DImode)\n-\t*total += COSTS_N_INSNS (3);\n-      return false;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      *total = 0;\n-      if (GET_MODE_CLASS (mode) == MODE_INT)\n-\t{\n-\t  rtx op = XEXP (x, 0);\n-\t  machine_mode opmode = GET_MODE (op);\n-\n-\t  if (mode == DImode)\n-\t    *total += COSTS_N_INSNS (1);\n-\n-\t  if (opmode != SImode)\n-\t    {\n-\t      if (MEM_P (op))\n-\t\t{\n-\t\t  /* If !arm_arch4, we use one of the extendhisi2_mem\n-\t\t     or movhi_bytes patterns for HImode.  For a QImode\n-\t\t     sign extension, we first zero-extend from memory\n-\t\t     and then perform a shift sequence.  */\n-\t\t  if (!arm_arch4 && (opmode != QImode || code == SIGN_EXTEND))\n-\t\t    *total += COSTS_N_INSNS (2);\n-\t\t}\n-\t      else if (arm_arch6)\n-\t\t*total += COSTS_N_INSNS (1);\n-\n-\t      /* We don't have the necessary insn, so we need to perform some\n-\t\t other operation.  */\n-\t      else if (TARGET_ARM && code == ZERO_EXTEND && mode == QImode)\n-\t\t/* An and with constant 255.  */\n-\t\t*total += COSTS_N_INSNS (1);\n-\t      else\n-\t\t/* A shift sequence.  Increase costs slightly to avoid\n-\t\t   combining two shifts into an extend operation.  */\n-\t\t*total += COSTS_N_INSNS (2) + 1;\n-\t    }\n-\n-\t  return false;\n-\t}\n-\n-      switch (GET_MODE (XEXP (x, 0)))\n-\t{\n-\tcase V8QImode:\n-\tcase V4HImode:\n-\tcase V2SImode:\n-\tcase V4QImode:\n-\tcase V2HImode:\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return false;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      gcc_unreachable ();\n-\n-    case ZERO_EXTRACT:\n-    case SIGN_EXTRACT:\n-      mode = GET_MODE (XEXP (x, 0));\n-      *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-      return true;\n-\n-    case CONST_INT:\n-      if (const_ok_for_arm (INTVAL (x))\n-\t  || const_ok_for_arm (~INTVAL (x)))\n-\t*total = COSTS_N_INSNS (1);\n-      else\n-\t*total = COSTS_N_INSNS (arm_gen_constant (SET, mode, NULL_RTX,\n-\t\t\t\t\t\t  INTVAL (x), NULL_RTX,\n-\t\t\t\t\t\t  NULL_RTX, 0, 0));\n-      return true;\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = COSTS_N_INSNS (3);\n-      return true;\n-\n-    case HIGH:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case LO_SUM:\n-      *total = COSTS_N_INSNS (1);\n-      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x)\n-\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t*total = COSTS_N_INSNS (1);\n-      else\n-\t*total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case SET:\n-      /* The vec_extract patterns accept memory operands that require an\n-\t address reload.  Account for the cost of that reload to give the\n-\t auto-inc-dec pass an incentive to try to replace them.  */\n-      if (TARGET_NEON && MEM_P (SET_DEST (x))\n-\t  && GET_CODE (SET_SRC (x)) == VEC_SELECT)\n-\t{\n-\t  mode = GET_MODE (SET_DEST (x));\n-\t  *total = rtx_cost (SET_DEST (x), mode, code, 0, speed);\n-\t  if (!neon_vector_mem_operand (SET_DEST (x), 2, true))\n-\t    *total += COSTS_N_INSNS (1);\n-\t  return true;\n-\t}\n-      /* Likewise for the vec_set patterns.  */\n-      if (TARGET_NEON && GET_CODE (SET_SRC (x)) == VEC_MERGE\n-\t  && GET_CODE (XEXP (SET_SRC (x), 0)) == VEC_DUPLICATE\n-\t  && MEM_P (XEXP (XEXP (SET_SRC (x), 0), 0)))\n-\t{\n-\t  rtx mem = XEXP (XEXP (SET_SRC (x), 0), 0);\n-\t  mode = GET_MODE (SET_DEST (x));\n-\t  *total = rtx_cost (mem, mode, code, 0, speed);\n-\t  if (!neon_vector_mem_operand (mem, 2, true))\n-\t    *total += COSTS_N_INSNS (1);\n-\t  return true;\n-\t}\n-      return false;\n-\n-    case UNSPEC:\n-      /* We cost this as high as our memory costs to allow this to\n-\t be hoisted from loops.  */\n-      if (XINT (x, 1) == UNSPEC_PIC_UNIFIED)\n-\t{\n-\t  *total = COSTS_N_INSNS (2 + ARM_NUM_REGS (mode));\n-\t}\n-      return true;\n-\n-    case CONST_VECTOR:\n-      if (TARGET_NEON\n-\t  && TARGET_HARD_FLOAT\n-\t  && outer == SET\n-\t  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))\n-\t  && neon_immediate_valid_for_move (x, mode, NULL, NULL))\n-\t*total = COSTS_N_INSNS (1);\n-      else\n-\t*total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    default:\n-      *total = COSTS_N_INSNS (4);\n-      return false;\n-    }\n-}\n-\n /* Estimates the size cost of thumb1 instructions.\n    For now most of the code is copied from thumb1_rtx_costs. We need more\n    fine grain tuning when we have more related test cases.  */\n@@ -9182,308 +8536,69 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n           int i;\n           /* This duplicates the tests in the andsi3 expander.  */\n           for (i = 9; i <= 31; i++)\n-            if ((HOST_WIDE_INT_1 << i) - 1 == INTVAL (x)\n-                || (HOST_WIDE_INT_1 << i) - 1 == ~INTVAL (x))\n-              return COSTS_N_INSNS (2);\n-        }\n-      else if (outer == ASHIFT || outer == ASHIFTRT\n-               || outer == LSHIFTRT)\n-        return 0;\n-      return COSTS_N_INSNS (2);\n-\n-    case CONST:\n-    case CONST_DOUBLE:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      return COSTS_N_INSNS (3);\n-\n-    case UDIV:\n-    case UMOD:\n-    case DIV:\n-    case MOD:\n-      return 100;\n-\n-    case TRUNCATE:\n-      return 99;\n-\n-    case AND:\n-    case XOR:\n-    case IOR:\n-      return COSTS_N_INSNS (1);\n-\n-    case MEM:\n-      return (COSTS_N_INSNS (1)\n-\t      + COSTS_N_INSNS (1)\n-\t\t* ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n-              + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n-                 ? COSTS_N_INSNS (1) : 0));\n-\n-    case IF_THEN_ELSE:\n-      /* XXX a guess.  */\n-      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n-        return 14;\n-      return 2;\n-\n-    case ZERO_EXTEND:\n-      /* XXX still guessing.  */\n-      switch (GET_MODE (XEXP (x, 0)))\n-        {\n-          case QImode:\n-            return (1 + (mode == DImode ? 4 : 0)\n-                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n-\n-          case HImode:\n-            return (4 + (mode == DImode ? 4 : 0)\n-                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n-\n-          case SImode:\n-            return (1 + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n-\n-          default:\n-            return 99;\n-        }\n-\n-    default:\n-      return 99;\n-    }\n-}\n-\n-/* RTX costs when optimizing for size.  */\n-static bool\n-arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-\t\t    int *total)\n-{\n-  machine_mode mode = GET_MODE (x);\n-  if (TARGET_THUMB1)\n-    {\n-      *total = thumb1_size_rtx_costs (x, code, outer_code);\n-      return true;\n-    }\n-\n-  /* FIXME: This makes no attempt to prefer narrow Thumb-2 instructions.  */\n-  switch (code)\n-    {\n-    case MEM:\n-      /* A memory access costs 1 insn if the mode is small, or the address is\n-\t a single register, otherwise it costs one insn per word.  */\n-      if (REG_P (XEXP (x, 0)))\n-\t*total = COSTS_N_INSNS (1);\n-      else if (flag_pic\n-\t       && GET_CODE (XEXP (x, 0)) == PLUS\n-\t       && will_be_in_index_register (XEXP (XEXP (x, 0), 1)))\n-\t/* This will be split into two instructions.\n-\t   See arm.md:calculate_pic_address.  */\n-\t*total = COSTS_N_INSNS (2);\n-      else\n-\t*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      /* Needs a libcall, so it costs about this.  */\n-      *total = COSTS_N_INSNS (2);\n-      return false;\n-\n-    case ROTATE:\n-      if (mode == SImode && REG_P (XEXP (x, 1)))\n-\t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, false);\n-\t  return true;\n-\t}\n-      /* Fall through */\n-    case ROTATERT:\n-    case ASHIFT:\n-    case LSHIFTRT:\n-    case ASHIFTRT:\n-      if (mode == DImode && CONST_INT_P (XEXP (x, 1)))\n-\t{\n-\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, false);\n-\t  return true;\n-\t}\n-      else if (mode == SImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n-\t\t\t\t\t\t 0, false);\n-\t  /* Slightly disparage register shifts, but not by much.  */\n-\t  if (!CONST_INT_P (XEXP (x, 1)))\n-\t    *total += 1 + rtx_cost (XEXP (x, 1), mode, code, 1, false);\n-\t  return true;\n-\t}\n-\n-      /* Needs a libcall.  */\n-      *total = COSTS_N_INSNS (2);\n-      return false;\n-\n-    case MINUS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t{\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return false;\n-\t}\n-\n-      if (mode == SImode)\n-\t{\n-\t  enum rtx_code subcode0 = GET_CODE (XEXP (x, 0));\n-\t  enum rtx_code subcode1 = GET_CODE (XEXP (x, 1));\n-\n-\t  if (subcode0 == ROTATE || subcode0 == ROTATERT || subcode0 == ASHIFT\n-\t      || subcode0 == LSHIFTRT || subcode0 == ASHIFTRT\n-\t      || subcode1 == ROTATE || subcode1 == ROTATERT\n-\t      || subcode1 == ASHIFT || subcode1 == LSHIFTRT\n-\t      || subcode1 == ASHIFTRT)\n-\t    {\n-\t      /* It's just the cost of the two operands.  */\n-\t      *total = 0;\n-\t      return false;\n-\t    }\n-\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return false;\n-\t}\n-\n-      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-      return false;\n-\n-    case PLUS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t{\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return false;\n-\t}\n-\n-      /* A shift as a part of ADD costs nothing.  */\n-      if (GET_CODE (XEXP (x, 0)) == MULT\n-\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n-\t{\n-\t  *total = COSTS_N_INSNS (TARGET_THUMB2 ? 2 : 1);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, code, 0, false);\n-\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, false);\n-\t  return true;\n-\t}\n-\n-      /* Fall through */\n-    case AND: case XOR: case IOR:\n-      if (mode == SImode)\n-\t{\n-\t  enum rtx_code subcode = GET_CODE (XEXP (x, 0));\n-\n-\t  if (subcode == ROTATE || subcode == ROTATERT || subcode == ASHIFT\n-\t      || subcode == LSHIFTRT || subcode == ASHIFTRT\n-\t      || (code == AND && subcode == NOT))\n-\t    {\n-\t      /* It's just the cost of the two operands.  */\n-\t      *total = 0;\n-\t      return false;\n-\t    }\n-\t}\n-\n-      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-      return false;\n-\n-    case MULT:\n-      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-      return false;\n-\n-    case NEG:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t{\n-\t  *total = COSTS_N_INSNS (1);\n-\t  return false;\n-\t}\n-\n-      /* Fall through */\n-    case NOT:\n-      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-\n-      return false;\n-\n-    case IF_THEN_ELSE:\n-      *total = 0;\n-      return false;\n-\n-    case COMPARE:\n-      if (cc_register (XEXP (x, 0), VOIDmode))\n-\t* total = 0;\n-      else\n-\t*total = COSTS_N_INSNS (1);\n-      return false;\n-\n-    case ABS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n-\t*total = COSTS_N_INSNS (1);\n-      else\n-\t*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));\n-      return false;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      return arm_rtx_costs_1 (x, outer_code, total, 0);\n-\n-    case CONST_INT:\n-      if (const_ok_for_arm (INTVAL (x)))\n-\t/* A multiplication by a constant requires another instruction\n-\t   to load the constant to a register.  */\n-\t*total = COSTS_N_INSNS ((outer_code == SET || outer_code == MULT)\n-\t\t\t\t? 1 : 0);\n-      else if (const_ok_for_arm (~INTVAL (x)))\n-\t*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);\n-      else if (const_ok_for_arm (-INTVAL (x)))\n-\t{\n-\t  if (outer_code == COMPARE || outer_code == PLUS\n-\t      || outer_code == MINUS)\n-\t    *total = 0;\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t}\n-      else\n-\t*total = COSTS_N_INSNS (2);\n-      return true;\n+            if ((HOST_WIDE_INT_1 << i) - 1 == INTVAL (x)\n+                || (HOST_WIDE_INT_1 << i) - 1 == ~INTVAL (x))\n+              return COSTS_N_INSNS (2);\n+        }\n+      else if (outer == ASHIFT || outer == ASHIFTRT\n+               || outer == LSHIFTRT)\n+        return 0;\n+      return COSTS_N_INSNS (2);\n \n     case CONST:\n+    case CONST_DOUBLE:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n+      return COSTS_N_INSNS (3);\n \n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (4);\n-      return true;\n+    case UDIV:\n+    case UMOD:\n+    case DIV:\n+    case MOD:\n+      return 100;\n \n-    case CONST_VECTOR:\n-      if (TARGET_NEON\n-\t  && TARGET_HARD_FLOAT\n-\t  && outer_code == SET\n-\t  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))\n-\t  && neon_immediate_valid_for_move (x, mode, NULL, NULL))\n-\t*total = COSTS_N_INSNS (1);\n-      else\n-\t*total = COSTS_N_INSNS (4);\n-      return true;\n+    case TRUNCATE:\n+      return 99;\n \n-    case HIGH:\n-    case LO_SUM:\n-      /* We prefer constant pool entries to MOVW/MOVT pairs, so bump the\n-\t cost of these slightly.  */\n-      *total = COSTS_N_INSNS (1) + 1;\n-      return true;\n+    case AND:\n+    case XOR:\n+    case IOR:\n+      return COSTS_N_INSNS (1);\n \n-    case SET:\n-      return false;\n+    case MEM:\n+      return (COSTS_N_INSNS (1)\n+\t      + COSTS_N_INSNS (1)\n+\t\t* ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n+              + ((GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+                 ? COSTS_N_INSNS (1) : 0));\n+\n+    case IF_THEN_ELSE:\n+      /* XXX a guess.  */\n+      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n+        return 14;\n+      return 2;\n+\n+    case ZERO_EXTEND:\n+      /* XXX still guessing.  */\n+      switch (GET_MODE (XEXP (x, 0)))\n+        {\n+          case QImode:\n+            return (1 + (mode == DImode ? 4 : 0)\n+                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n+\n+          case HImode:\n+            return (4 + (mode == DImode ? 4 : 0)\n+                    + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n+\n+          case SImode:\n+            return (1 + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n+\n+          default:\n+            return 99;\n+        }\n \n     default:\n-      if (mode != VOIDmode)\n-\t*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-      else\n-\t*total = COSTS_N_INSNS (4); /* How knows?  */\n-      return false;\n+      return 99;\n     }\n }\n \n@@ -9610,7 +8725,7 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)\n    flags are live or not, and thus no realistic way to determine what\n    the size will eventually be.  */\n static bool\n-arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n+arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t   const struct cpu_cost_table *extra_cost,\n \t\t   int *cost, bool speed_p)\n {\n@@ -11293,41 +10408,20 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n #undef HANDLE_NARROW_SHIFT_ARITH\n \n-/* RTX costs when optimizing for size.  */\n+/* RTX costs entry point.  */\n+\n static bool\n arm_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n \t       int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n   bool result;\n   int code = GET_CODE (x);\n+  gcc_assert (current_tune->insn_extra_cost);\n \n-  if (TARGET_OLD_RTX_COSTS\n-      || (!current_tune->insn_extra_cost && !TARGET_NEW_GENERIC_COSTS))\n-    {\n-      /* Old way.  (Deprecated.)  */\n-      if (!speed)\n-\tresult = arm_size_rtx_costs (x, (enum rtx_code) code,\n-\t\t\t\t     (enum rtx_code) outer_code, total);\n-      else\n-\tresult = current_tune->rtx_costs (x,  (enum rtx_code) code,\n-\t\t\t\t\t  (enum rtx_code) outer_code, total,\n-\t\t\t\t\t  speed);\n-    }\n-  else\n-    {\n-    /* New way.  */\n-      if (current_tune->insn_extra_cost)\n-        result =  arm_new_rtx_costs (x, (enum rtx_code) code,\n-\t\t\t\t     (enum rtx_code) outer_code,\n-\t\t\t\t     current_tune->insn_extra_cost,\n-\t\t\t\t     total, speed);\n-    /* TARGET_NEW_GENERIC_COSTS && !TARGET_OLD_RTX_COSTS\n-       && current_tune->insn_extra_cost != NULL  */\n-      else\n-        result =  arm_new_rtx_costs (x, (enum rtx_code) code,\n-\t\t\t\t    (enum rtx_code) outer_code,\n-\t\t\t\t    &generic_extra_costs, total, speed);\n-    }\n+  result =  arm_rtx_costs_internal (x, (enum rtx_code) code,\n+\t\t\t\t(enum rtx_code) outer_code,\n+\t\t\t\tcurrent_tune->insn_extra_cost,\n+\t\t\t\ttotal, speed);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -11338,305 +10432,6 @@ arm_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n   return result;\n }\n \n-/* RTX costs for cores with a slow MUL implementation.  Thumb-2 is not\n-   supported on any \"slowmul\" cores, so it can be ignored.  */\n-\n-static bool\n-arm_slowmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-\t\t       int *total, bool speed)\n-{\n-  machine_mode mode = GET_MODE (x);\n-\n-  if (TARGET_THUMB)\n-    {\n-      *total = thumb1_rtx_costs (x, code, outer_code);\n-      return true;\n-    }\n-\n-  switch (code)\n-    {\n-    case MULT:\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t  || mode == DImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (20);\n-\t  return false;\n-\t}\n-\n-      if (CONST_INT_P (XEXP (x, 1)))\n-\t{\n-\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n-\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n-\t  int cost, const_ok = const_ok_for_arm (i);\n-\t  int j, booth_unit_size;\n-\n-\t  /* Tune as appropriate.  */\n-\t  cost = const_ok ? 4 : 8;\n-\t  booth_unit_size = 2;\n-\t  for (j = 0; i && j < 32; j += booth_unit_size)\n-\t    {\n-\t      i >>= booth_unit_size;\n-\t      cost++;\n-\t    }\n-\n-\t  *total = COSTS_N_INSNS (cost);\n-\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n-\t  return true;\n-\t}\n-\n-      *total = COSTS_N_INSNS (20);\n-      return false;\n-\n-    default:\n-      return arm_rtx_costs_1 (x, outer_code, total, speed);;\n-    }\n-}\n-\n-\n-/* RTX cost for cores with a fast multiply unit (M variants).  */\n-\n-static bool\n-arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-\t\t       int *total, bool speed)\n-{\n-  machine_mode mode = GET_MODE (x);\n-\n-  if (TARGET_THUMB1)\n-    {\n-      *total = thumb1_rtx_costs (x, code, outer_code);\n-      return true;\n-    }\n-\n-  /* ??? should thumb2 use different costs?  */\n-  switch (code)\n-    {\n-    case MULT:\n-      /* There is no point basing this on the tuning, since it is always the\n-\t fast variant if it exists at all.  */\n-      if (mode == DImode\n-\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n-\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n-\t{\n-\t  *total = COSTS_N_INSNS(2);\n-\t  return false;\n-\t}\n-\n-\n-      if (mode == DImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (5);\n-\t  return false;\n-\t}\n-\n-      if (CONST_INT_P (XEXP (x, 1)))\n-\t{\n-\t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n-\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n-\t  int cost, const_ok = const_ok_for_arm (i);\n-\t  int j, booth_unit_size;\n-\n-\t  /* Tune as appropriate.  */\n-\t  cost = const_ok ? 4 : 8;\n-\t  booth_unit_size = 8;\n-\t  for (j = 0; i && j < 32; j += booth_unit_size)\n-\t    {\n-\t      i >>= booth_unit_size;\n-\t      cost++;\n-\t    }\n-\n-\t  *total = COSTS_N_INSNS(cost);\n-\t  return false;\n-\t}\n-\n-      if (mode == SImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (4);\n-\t  return false;\n-\t}\n-\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return false;\n-\t    }\n-\t}\n-\n-      /* Requires a lib call */\n-      *total = COSTS_N_INSNS (20);\n-      return false;\n-\n-    default:\n-      return arm_rtx_costs_1 (x, outer_code, total, speed);\n-    }\n-}\n-\n-\n-/* RTX cost for XScale CPUs.  Thumb-2 is not supported on any xscale cores,\n-   so it can be ignored.  */\n-\n-static bool\n-arm_xscale_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-\t\t      int *total, bool speed)\n-{\n-  machine_mode mode = GET_MODE (x);\n-\n-  if (TARGET_THUMB)\n-    {\n-      *total = thumb1_rtx_costs (x, code, outer_code);\n-      return true;\n-    }\n-\n-  switch (code)\n-    {\n-    case COMPARE:\n-      if (GET_CODE (XEXP (x, 0)) != MULT)\n-\treturn arm_rtx_costs_1 (x, outer_code, total, speed);\n-\n-      /* A COMPARE of a MULT is slow on XScale; the muls instruction\n-\t will stall until the multiplication is complete.  */\n-      *total = COSTS_N_INSNS (3);\n-      return false;\n-\n-    case MULT:\n-      /* There is no point basing this on the tuning, since it is always the\n-\t fast variant if it exists at all.  */\n-      if (mode == DImode\n-\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n-\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n-\t{\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return false;\n-\t}\n-\n-\n-      if (mode == DImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (5);\n-\t  return false;\n-\t}\n-\n-      if (CONST_INT_P (XEXP (x, 1)))\n-\t{\n-\t  /* If operand 1 is a constant we can more accurately\n-\t     calculate the cost of the multiply.  The multiplier can\n-\t     retire 15 bits on the first cycle and a further 12 on the\n-\t     second.  We do, of course, have to load the constant into\n-\t     a register first.  */\n-\t  unsigned HOST_WIDE_INT i = INTVAL (XEXP (x, 1));\n-\t  /* There's a general overhead of one cycle.  */\n-\t  int cost = 1;\n-\t  unsigned HOST_WIDE_INT masked_const;\n-\n-\t  if (i & 0x80000000)\n-\t    i = ~i;\n-\n-\t  i &= (unsigned HOST_WIDE_INT) 0xffffffff;\n-\n-\t  masked_const = i & 0xffff8000;\n-\t  if (masked_const != 0)\n-\t    {\n-\t      cost++;\n-\t      masked_const = i & 0xf8000000;\n-\t      if (masked_const != 0)\n-\t\tcost++;\n-\t    }\n-\t  *total = COSTS_N_INSNS (cost);\n-\t  return false;\n-\t}\n-\n-      if (mode == SImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (3);\n-\t  return false;\n-\t}\n-\n-      /* Requires a lib call */\n-      *total = COSTS_N_INSNS (20);\n-      return false;\n-\n-    default:\n-      return arm_rtx_costs_1 (x, outer_code, total, speed);\n-    }\n-}\n-\n-\n-/* RTX costs for 9e (and later) cores.  */\n-\n-static bool\n-arm_9e_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-\t\t  int *total, bool speed)\n-{\n-  machine_mode mode = GET_MODE (x);\n-\n-  if (TARGET_THUMB1)\n-    {\n-      switch (code)\n-\t{\n-\tcase MULT:\n-\t  /* Small multiply: 32 cycles for an integer multiply inst.  */\n-\t  if (arm_arch6m && arm_m_profile_small_mul)\n-\t    *total = COSTS_N_INSNS (32);\n-\t  else\n-\t    *total = COSTS_N_INSNS (3);\n-\t  return true;\n-\n-\tdefault:\n-\t  *total = thumb1_rtx_costs (x, code, outer_code);\n-\t  return true;\n-\t}\n-    }\n-\n-  switch (code)\n-    {\n-    case MULT:\n-      /* There is no point basing this on the tuning, since it is always the\n-\t fast variant if it exists at all.  */\n-      if (mode == DImode\n-\t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n-\t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n-\t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n-\t{\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return false;\n-\t}\n-\n-\n-      if (mode == DImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (5);\n-\t  return false;\n-\t}\n-\n-      if (mode == SImode)\n-\t{\n-\t  *total = COSTS_N_INSNS (2);\n-\t  return false;\n-\t}\n-\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (TARGET_HARD_FLOAT\n-\t      && (mode == SFmode\n-\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n-\t    {\n-\t      *total = COSTS_N_INSNS (1);\n-\t      return false;\n-\t    }\n-\t}\n-\n-      *total = COSTS_N_INSNS (20);\n-      return false;\n-\n-    default:\n-      return arm_rtx_costs_1 (x, outer_code, total, speed);\n-    }\n-}\n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):"}, {"sha": "54d84dc9f3aa0e156742a4a364abcfdcfd3da4b9", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83afd959dda01e64d5c33430567fc93316b8ed3c/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=83afd959dda01e64d5c33430567fc93316b8ed3c", "patch": "@@ -253,14 +253,6 @@ mrestrict-it\n Target Report Var(arm_restrict_it) Init(2) Save\n Generate IT blocks appropriate for ARMv8.\n \n-mold-rtx-costs\n-Target Report Mask(OLD_RTX_COSTS)\n-Use the old RTX costing tables (transitional).\n-\n-mnew-generic-costs\n-Target Report Mask(NEW_GENERIC_COSTS)\n-Use the new generic RTX cost tables if new core-specific cost table not available (transitional).\n-\n mfix-cortex-m3-ldrd\n Target Report Var(fix_cm3_ldrd) Init(2)\n Avoid overlapping destination and address registers on LDRD instructions"}]}