{"sha": "2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ1Y2E5YTAxN2Y0Y2E1OTAyNDliM2JjOTg3ZmM3YzE4MDNiMDBlZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-01-15T18:57:29Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-01-15T18:57:29Z"}, "message": "pa-protos.h (prefetch_operand): Delete.\n\n\t* pa-protos.h (prefetch_operand): Delete.\n\t(prefetch_cc_operand, prefetch_nocc_operand): New declations.\n\t* pa.c (prefetch_operand): Delete.\n\t(prefetch_cc_operand, prefetch_nocc_operand): New functions.\n\t* pa.h (EXTRA_CONSTRAINT): Add `W' constraint.\n\t(PREDICATE_CODES): Delete prefetch_operand.  Add prefetch_cc_operand\n\tand prefetch_nocc_operand.\n\t* pa.md (prefetch): Rework to avoid reload problems handling short\n\tdisplacements when a cache control completer needs to be provided.\n\t(prefetch_32, prefetch_64): Delete.\n\t(prefetch_cc, prefetch_nocc): New patterns.\n\nFrom-SVN: r93702", "tree": {"sha": "b7d3dc9a86910317266f385ff932710e7f1ebca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7d3dc9a86910317266f385ff932710e7f1ebca2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/comments", "author": null, "committer": null, "parents": [{"sha": "6a9836b1cd7bc1a599df3f8af8bf1f93a7b38e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9836b1cd7bc1a599df3f8af8bf1f93a7b38e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a9836b1cd7bc1a599df3f8af8bf1f93a7b38e9c"}], "stats": {"total": 236, "additions": 125, "deletions": 111}, "files": [{"sha": "81cfd921c038ac867e0efba76061ebe0764ee9b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "patch": "@@ -1,3 +1,17 @@\n+2005-01-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa-protos.h (prefetch_operand): Delete.\n+\t(prefetch_cc_operand, prefetch_nocc_operand): New declations.\n+\t* pa.c (prefetch_operand): Delete.\n+\t(prefetch_cc_operand, prefetch_nocc_operand): New functions.\n+\t* pa.h (EXTRA_CONSTRAINT): Add `W' constraint.\n+\t(PREDICATE_CODES): Delete prefetch_operand.  Add prefetch_cc_operand\n+\tand prefetch_nocc_operand.\n+\t* pa.md (prefetch): Rework to avoid reload problems handling short\n+\tdisplacements when a cache control completer needs to be provided.\n+\t(prefetch_32, prefetch_64): Delete.\n+\t(prefetch_cc, prefetch_nocc): New patterns.\n+\n 2005-01-15  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/aix52.h (CPLUSPLUS_CPP_SPEC): Revert previous change."}, {"sha": "bb49ca3b688997406400ddf562135442f1500fbc", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "patch": "@@ -79,7 +79,8 @@ extern int arith_operand (rtx, enum machine_mode);\n extern int read_only_operand (rtx, enum machine_mode);\n extern int move_dest_operand (rtx, enum machine_mode);\n extern int move_src_operand (rtx, enum machine_mode);\n-extern int prefetch_operand (rtx, enum machine_mode);\n+extern int prefetch_cc_operand (rtx, enum machine_mode);\n+extern int prefetch_nocc_operand (rtx, enum machine_mode);\n extern int and_operand (rtx, enum machine_mode);\n extern int ior_operand (rtx, enum machine_mode);\n extern int arith32_operand (rtx, enum machine_mode);"}, {"sha": "7d0dff5ccf0c9662ae1f97c6d2e8a3cbf3af58d8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "patch": "@@ -752,24 +752,59 @@ move_src_operand (rtx op, enum machine_mode mode)\n }\n \n /* Accept anything that can be used as the source operand for a prefetch\n-   instruction.  */\n+   instruction with a cache-control completer.  */\n int\n-prefetch_operand (rtx op, enum machine_mode mode)\n+prefetch_cc_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n \n+  op = XEXP (op, 0);\n+\n+  /* We must reject virtual registers as we don't allow REG+D.  */\n+  if (op == virtual_incoming_args_rtx\n+      || op == virtual_stack_vars_rtx\n+      || op == virtual_stack_dynamic_rtx\n+      || op == virtual_outgoing_args_rtx\n+      || op == virtual_cfa_rtx)\n+    return 0;\n+\n+  if (!REG_P (op) && !IS_INDEX_ADDR_P (op))\n+    return 0;\n+\n   /* Until problems with management of the REG_POINTER flag are resolved,\n      we need to delay creating prefetch insns with unscaled indexed addresses\n      until CSE is not expected.  */\n   if (!TARGET_NO_SPACE_REGS\n       && !cse_not_expected\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (op, 0), 0))\n-      && REG_P (XEXP (XEXP (op, 0), 1)))\n+      && GET_CODE (op) == PLUS\n+      && REG_P (XEXP (op, 0)))\n     return 0;\n \n-  return memory_address_p (mode, XEXP (op, 0));\n+  return memory_address_p (mode, op);\n+}\n+\n+/* Accept anything that can be used as the source operand for a prefetch\n+   instruction with no cache-control completer.  */\n+int\n+prefetch_nocc_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating prefetch insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (op) == PLUS\n+      && REG_P (XEXP (op, 0))\n+      && REG_P (XEXP (op, 1)))\n+    return 0;\n+\n+  return memory_address_p (mode, op);\n }\n \n /* Accept REG and any CONST_INT that can be moved in one instruction into a"}, {"sha": "61a33258e2c3a7bb31c289f1cfdbe2090864c855", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "patch": "@@ -1296,7 +1296,12 @@ extern int may_call_alloca;\n \n    `T' is for floating-point loads and stores.\n \n-   `U' is the constant 63.  */\n+   `U' is the constant 63.\n+\n+   `W' is a register indirect memory operand.  We could allow short\n+       displacements but GO_IF_LEGITIMATE_ADDRESS can't tell when a\n+       long displacement is valid.  This is only used for prefetch\n+       instructions with the `sl' completer.  */\n \n #define EXTRA_CONSTRAINT(OP, C) \\\n   ((C) == 'Q' ?\t\t\t\t\t\t\t\t\\\n@@ -1307,6 +1312,10 @@ extern int may_call_alloca;\n \t&& !symbolic_memory_operand (OP, VOIDmode)\t\t\t\\\n \t&& !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n \t&& !IS_INDEX_ADDR_P (XEXP (OP, 0))))\t\t\t\t\\\n+   : ((C) == 'W' ?\t\t\t\t\t\t\t\\\n+      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n+       && REG_P (XEXP (OP, 0))\t\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\t\t\\\n    : ((C) == 'A' ?\t\t\t\t\t\t\t\\\n       (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n        && IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0)))\t\t\t\t\\\n@@ -1336,7 +1345,7 @@ extern int may_call_alloca;\n    : ((C) == 'S' ?\t\t\t\t\t\t\t\\\n       (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31)\t\t\t\\\n    : ((C) == 'U' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63) : 0))))))\n+      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63) : 0)))))))\n \t\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -2102,7 +2111,8 @@ forget_section (void)\t\t\t\t\t\t\t\\\n \t\t\t\t       CONST_DOUBLE}},\t\t\t\\\n   {\"move_dest_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n   {\"move_src_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n-  {\"prefetch_operand\", {MEM}},\t\t\t\t\t\t\\\n+  {\"prefetch_cc_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"prefetch_nocc_operand\", {MEM}},\t\t\t\t\t\\\n   {\"reg_or_cint_move_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"pic_label_operand\", {LABEL_REF, CONST}},\t\t\t\t\\\n   {\"fp_reg_operand\", {REG}},\t\t\t\t\t\t\\"}, {"sha": "c79c982a53ec32cab1828bc72117f0a9d2720a39", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 55, "deletions": 101, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5ca9a017f4ca590249b3bc987fc7c1803b00ee/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=2d5ca9a017f4ca590249b3bc987fc7c1803b00ee", "patch": "@@ -9283,134 +9283,88 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (match_operand 2 \"const_int_operand\" \"\")]\n   \"TARGET_PA_20\"\n {\n-  /* The PA 2.0 prefetch instructions only support short displacements\n-     when a cache control completer needs to be supplied.  Thus, we\n-     can't use LO_SUM DLT addresses with the spatial locality completer.  */\n-  if (operands[2] == const0_rtx && IS_LO_SUM_DLT_ADDR_P (operands[0]))\n-    FAIL;\n+  int locality = INTVAL (operands[2]);\n \n-  /* We change operand0 to a MEM as we don't have the infrastructure to\n-     output all the supported address modes for ldw/ldd but we do have\n-     it for MEMs.  */\n-  operands[0] = gen_rtx_MEM (Pmode, operands[0]);\n-\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (XEXP (operands[0], 0)) == PLUS\n-      && REG_P (XEXP (XEXP (operands[0], 0), 0))\n-      && REG_P (XEXP (XEXP (operands[0], 0), 1)))\n-    operands[0]\n-      = replace_equiv_address (operands[0],\n-\t\t\t       copy_to_mode_reg (Pmode,\n-\t\t\t\t\t \t XEXP (operands[0], 0)));\n+  if (locality < 0 || locality > 3)\n+    abort ();\n \n-  if (TARGET_64BIT)\n-    emit_insn (gen_prefetch_64 (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_prefetch_32 (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n+  /* Change operand[0] to a MEM as we don't have the infrastructure\n+     to output all the supported address modes for ldw/ldd when we use\n+     the address directly.  However, we do have it for MEMs.  */\n+  operands[0] = gen_rtx_MEM (QImode, operands[0]);\n \n-(define_insn \"prefetch_64\"\n-  [(prefetch (match_operand:DI 0 \"prefetch_operand\" \"A,RQ\")\n-\t     (match_operand:DI 1 \"const_int_operand\" \"n,n\")\n-\t     (match_operand:DI 2 \"const_int_operand\" \"n,n\"))]\n-  \"TARGET_64BIT\n-   && (operands[2] != const0_rtx\n-       || GET_CODE (XEXP (operands[0], 0)) != PLUS\n-       || GET_CODE (XEXP (XEXP (operands[0], 0), 1)) != CONST_INT\n-       || INT_5_BITS (XEXP (XEXP (operands[0], 0), 1)))\"\n-{\n-  /* The SL completor indicates good spatial locality but poor temporal\n-     locality.  The ldw instruction with a target of general register 0\n-     prefetches a cache line for a read.  The ldd instruction prefetches\n-     a cache line for a write.  */\n-  static const char * const instr[2][2][2] = {\n+  /* If the address isn't valid for the prefetch, replace it.  */\n+  if (locality)\n     {\n-      {\n-\t\"\",\n-\t\"ldw RT'%A0,%%r0\",\n-      },\n-      {\n-\t\"\",\n-\t\"ldd RT'%A0,%%r0\",\n-      },\n-    },\n+      if (!prefetch_nocc_operand (operands[0], QImode))\n+\toperands[0]\n+\t  = replace_equiv_address (operands[0],\n+\t\t\t\t   copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t     XEXP (operands[0], 0)));\n+      emit_insn (gen_prefetch_nocc (operands[0], operands[1], operands[2]));\n+    }\n+  else\n     {\n-      {\n-\t\"ldw%M0,sl %0,%%r0\",\n-\t\"ldw%M0 %0,%%r0\",\n-      },\n-      {\n-\t\"ldd%M0,sl %0,%%r0\",\n-\t\"ldd%M0 %0,%%r0\",\n-      }\n+      if (!prefetch_cc_operand (operands[0], QImode))\n+\toperands[0]\n+\t  = replace_equiv_address (operands[0],\n+\t\t\t\t   copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t     XEXP (operands[0], 0)));\n+      emit_insn (gen_prefetch_cc (operands[0], operands[1], operands[2]));\n     }\n+  DONE;\n+})\n+\n+(define_insn \"prefetch_cc\"\n+  [(prefetch (match_operand:QI 0 \"prefetch_cc_operand\" \"RW\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_PA_20 && operands[2] == const0_rtx\"\n+{\n+  /* The SL cache-control completor indicates good spatial locality but\n+     poor temporal locality.  The ldw instruction with a target of general\n+     register 0 prefetches a cache line for a read.  The ldd instruction\n+     prefetches a cache line for a write.  */\n+  static const char * const instr[2] = {\n+    \"ldw%M0,sl %0,%%r0\",\n+    \"ldd%M0,sl %0,%%r0\"\n   };\n   int read_or_write = INTVAL (operands[1]);\n-  int locality = INTVAL (operands[2]);\n \n-  if ((which_alternative != 0 && which_alternative != 1)\n-      || (read_or_write != 0 && read_or_write != 1)\n-      || (locality < 0 || locality > 3))\n+  if (read_or_write < 0 || read_or_write > 1)\n     abort ();\n \n-  if (which_alternative == 0 && locality == 0)\n-    abort ();\n-\n-  return instr [which_alternative][read_or_write][locality == 0 ? 0 : 1];\n+  return instr [read_or_write];\n }\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"prefetch_32\"\n-  [(prefetch (match_operand:SI 0 \"prefetch_operand\" \"A,RQ\")\n+(define_insn \"prefetch_nocc\"\n+  [(prefetch (match_operand:QI 0 \"prefetch_nocc_operand\" \"A,RQ\")\n \t     (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n \t     (match_operand:SI 2 \"const_int_operand\" \"n,n\"))]\n-  \"TARGET_PA_20\n-   && (operands[2] != const0_rtx\n-       || GET_CODE (XEXP (operands[0], 0)) != PLUS\n-       || GET_CODE (XEXP (XEXP (operands[0], 0), 1)) != CONST_INT\n-       || INT_5_BITS (XEXP (XEXP (operands[0], 0), 1)))\"\n-{\n-  /* The SL completor indicates good spatial locality but poor temporal\n-     locality.  The ldw instruction with a target of general register 0\n-     prefetches a cache line for a read.  The ldd instruction prefetches\n-     a cache line for a write.  */\n-  static const char * const instr[2][2][2] = {\n+  \"TARGET_PA_20 && operands[2] != const0_rtx\"\n+{\n+  /* The ldw instruction with a target of general register 0 prefetches\n+     a cache line for a read.  The ldd instruction prefetches a cache line\n+     for a write.  */\n+  static const char * const instr[2][2] = {\n     {\n-      {\n-\t\"\",\n-\t\"ldw RT'%A0,%%r0\",\n-      },\n-      {\n-\t\"\",\n-\t\"ldd RT'%A0,%%r0\",\n-      },\n+      \"ldw RT'%A0,%%r0\",\n+      \"ldd RT'%A0,%%r0\",\n     },\n     {\n-      {\n-\t\"ldw%M0,sl %0,%%r0\",\n-\t\"ldw%M0 %0,%%r0\",\n-      },\n-      {\n-\t\"ldd%M0,sl %0,%%r0\",\n-\t\"ldd%M0 %0,%%r0\",\n-      }\n+      \"ldw%M0 %0,%%r0\",\n+      \"ldd%M0 %0,%%r0\",\n     }\n   };\n   int read_or_write = INTVAL (operands[1]);\n-  int locality = INTVAL (operands[2]);\n \n   if ((which_alternative != 0 && which_alternative != 1)\n-      || (read_or_write != 0 && read_or_write != 1)\n-      || (locality < 0 || locality > 3))\n-    abort ();\n-\n-  if (which_alternative == 0 && locality == 0)\n+      || (read_or_write < 0 || read_or_write > 1))\n     abort ();\n \n-  return instr [which_alternative][read_or_write][locality == 0 ? 0 : 1];\n+  return instr [which_alternative][read_or_write];\n }\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])"}]}