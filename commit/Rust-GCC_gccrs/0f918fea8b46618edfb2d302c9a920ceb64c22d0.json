{"sha": "0f918fea8b46618edfb2d302c9a920ceb64c22d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5MThmZWE4YjQ2NjE4ZWRmYjJkMzAyYzlhOTIwY2ViNjRjMjJkMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-04T08:46:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-04T08:46:52Z"}, "message": "[multiple changes]\n\n2000-01-04  Tom Tromey  <tromey@cygnus.com>\n\n\t* java/lang/reflect/natConstructor.cc (newInstance): Pass\n\tdeclaring class as return_type argument to\n\t_Jv_CallNonvirtualMethodA.\n\t* java/lang/reflect/natMethod.cc (_Jv_CallNonvirtualMethodA): In\n\tconstructor case, create object and use it as `this' argument.\n\t* java/lang/Class.h (_getConstructors): Declare.\n\t(_getFields): Declare.\n\t* java/lang/Class.java (getConstructors): Wrote.\n\t(_getConstructors): New native method.\n\t(getDeclaredConstructors): Wrote.\n\t(_getFields): Declare new native method.\n\t* java/lang/natClass.cc (_Jv_LookupInterfaceMethod): Removed\n\tincorrect comment.\n\t(getMethod): Work correctly when class is primitive.\n\t(getDeclaredMethods): Likewise.  Compute offset using `method',\n\tnot `mptr'.\n\t(getDeclaredMethod): Likewise.\n\t(getConstructor): Wrote.\n\t(ConstructorClass): New define.\n\t(getDeclaredConstructor): Wrote.\n\t(_getConstructors): New method.\n\t(_getFields): New method.\n\t(getFields): Wrote.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (AM_CXXFLAGS): Added -D_GNU_SOURCE.\n\n\t* prims.cc: Remove `#pragma implementation'.\n\t* gcj/array.h: Remove `#pragma interface'.\n\n\t* prims.cc (_Jv_equaln): New function.\n\t* java/lang/Class.java (getSignature): Declare.\n\t* resolve.cc (_Jv_LookupDeclaredMethod): Moved to natClass.cc.\n\t* java/lang/natClass.cc (_Jv_LookupDeclaredMethod): Moved from\n\tresolve.cc.\n\t(getSignature): New method.\n\t(getDeclaredMethod): Wrote.\n\t(getMethod): Wrote.\n\tInclude StringBuffer.h.\n\t* java/lang/Class.h (Class): Added _Jv_FromReflectedConstructor\n\tas a friend.  Unconditionally declare _Jv_LookupDeclaredMethod as\n\ta friend.\n\t(getSignature): Declare.\n\t* include/jvm.h (_Jv_GetTypesFromSignature): Declare.\n\t(_Jv_equaln): Declare.\n\t(_Jv_CallNonvirtualMethodA): Declare.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (nat_source_files): Added natConstructor.cc.\n\t(java/lang/reflect/Constructor.h): New target.\n\t* java/lang/reflect/natConstructor.cc: New file.\n\t* java/lang/reflect/Constructor.java (newInstance): Now native.\n\t(declaringClass): Renamed from decl_class.\n\t(offset): Renamed from index.\n\t(getType): New native method.\n\t(getModifiers): Now native.\n\t(getParameterTypes): Call getType if required.\n\t(hashCode): Include hash code from declaring class.\n\t(modifiers): Removed.\n\t(toString): Call getType if required.\n\t* gcj/method.h (_Jv_FromReflectedConstructor): New function.\n\t* java/lang/reflect/natMethod.cc (hack_call): New method.\n\tRemoved `#if 0' around FFI code.\n\tInclude <gnu/gcj/RawData.h>.\n\t(invoke): Use _Jv_CallNonvirtualMethodA.  Throw\n\tIllegalArgumentException when argument object and class disagree.\n\t(_Jv_GetTypesFromSignature): New function.\n\t(getType): Use it.\n\t(ObjectClass): New define.\n\t(_Jv_CallNonvirtualMethodA): New function.\n\t* java/lang/reflect/Method.java (hack_trampoline): New method.\n\t(hack_call): New native method.\n\n1999-12-21  Per Bothner  <per@bothner.com>\n\n\t* java/lang/natClass.cc (getDeclaredMethods): Correctly compute\n\toffset in new Method.\n\nFrom-SVN: r31199", "tree": {"sha": "b6bce78d53cdae8796dafac92444a6291ac4777a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6bce78d53cdae8796dafac92444a6291ac4777a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f918fea8b46618edfb2d302c9a920ceb64c22d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f918fea8b46618edfb2d302c9a920ceb64c22d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f918fea8b46618edfb2d302c9a920ceb64c22d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f918fea8b46618edfb2d302c9a920ceb64c22d0/comments", "author": null, "committer": null, "parents": [{"sha": "00da7781ffb8ac0b1dfb6a6a187d1b22ac5d6f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00da7781ffb8ac0b1dfb6a6a187d1b22ac5d6f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00da7781ffb8ac0b1dfb6a6a187d1b22ac5d6f5f"}], "stats": {"total": 961, "additions": 734, "deletions": 227}, "files": [{"sha": "5cd39d244495a931d95f9981e7e8fbefc08b263c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -1,3 +1,82 @@\n+2000-01-04  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/reflect/natConstructor.cc (newInstance): Pass\n+\tdeclaring class as return_type argument to\n+\t_Jv_CallNonvirtualMethodA.\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallNonvirtualMethodA): In\n+\tconstructor case, create object and use it as `this' argument.\n+\t* java/lang/Class.h (_getConstructors): Declare.\n+\t(_getFields): Declare.\n+\t* java/lang/Class.java (getConstructors): Wrote.\n+\t(_getConstructors): New native method.\n+\t(getDeclaredConstructors): Wrote.\n+\t(_getFields): Declare new native method.\n+\t* java/lang/natClass.cc (_Jv_LookupInterfaceMethod): Removed\n+\tincorrect comment.\n+\t(getMethod): Work correctly when class is primitive.\n+\t(getDeclaredMethods): Likewise.  Compute offset using `method',\n+\tnot `mptr'.\n+\t(getDeclaredMethod): Likewise.\n+\t(getConstructor): Wrote.\n+\t(ConstructorClass): New define.\n+\t(getDeclaredConstructor): Wrote.\n+\t(_getConstructors): New method.\n+\t(_getFields): New method.\n+\t(getFields): Wrote.\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (AM_CXXFLAGS): Added -D_GNU_SOURCE.\n+\n+\t* prims.cc: Remove `#pragma implementation'.\n+\t* gcj/array.h: Remove `#pragma interface'.\n+\n+\t* prims.cc (_Jv_equaln): New function.\n+\t* java/lang/Class.java (getSignature): Declare.\n+\t* resolve.cc (_Jv_LookupDeclaredMethod): Moved to natClass.cc.\n+\t* java/lang/natClass.cc (_Jv_LookupDeclaredMethod): Moved from\n+\tresolve.cc.\n+\t(getSignature): New method.\n+\t(getDeclaredMethod): Wrote.\n+\t(getMethod): Wrote.\n+\tInclude StringBuffer.h.\n+\t* java/lang/Class.h (Class): Added _Jv_FromReflectedConstructor\n+\tas a friend.  Unconditionally declare _Jv_LookupDeclaredMethod as\n+\ta friend.\n+\t(getSignature): Declare.\n+\t* include/jvm.h (_Jv_GetTypesFromSignature): Declare.\n+\t(_Jv_equaln): Declare.\n+\t(_Jv_CallNonvirtualMethodA): Declare.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (nat_source_files): Added natConstructor.cc.\n+\t(java/lang/reflect/Constructor.h): New target.\n+\t* java/lang/reflect/natConstructor.cc: New file.\n+\t* java/lang/reflect/Constructor.java (newInstance): Now native.\n+\t(declaringClass): Renamed from decl_class.\n+\t(offset): Renamed from index.\n+\t(getType): New native method.\n+\t(getModifiers): Now native.\n+\t(getParameterTypes): Call getType if required.\n+\t(hashCode): Include hash code from declaring class.\n+\t(modifiers): Removed.\n+\t(toString): Call getType if required.\n+\t* gcj/method.h (_Jv_FromReflectedConstructor): New function.\n+\t* java/lang/reflect/natMethod.cc (hack_call): New method.\n+\tRemoved `#if 0' around FFI code.\n+\tInclude <gnu/gcj/RawData.h>.\n+\t(invoke): Use _Jv_CallNonvirtualMethodA.  Throw\n+\tIllegalArgumentException when argument object and class disagree.\n+\t(_Jv_GetTypesFromSignature): New function.\n+\t(getType): Use it.\n+\t(ObjectClass): New define.\n+\t(_Jv_CallNonvirtualMethodA): New function.\n+\t* java/lang/reflect/Method.java (hack_trampoline): New method.\n+\t(hack_call): New native method.\n+\n+1999-12-21  Per Bothner  <per@bothner.com>\n+\n+\t* java/lang/natClass.cc (getDeclaredMethods): Correctly compute\n+\toffset in new Method.\n+\n 1999-12-22  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/lang/natObject.cc (notify): Throw message with"}, {"sha": "d15784dfb421901c66053ad4a01ffddb652e95d1", "filename": "libjava/Makefile.am", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -74,8 +74,10 @@ JAVAC = $(GCJ) -C\n EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n \n WARNINGS = -W -Wall\n+## We need _GNU_SOURCE defined for some Linux builds.  It doesn't hurt\n+## to always define it.\n AM_CXXFLAGS = -fno-rtti -fvtable-thunks @LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ \\\n-\t$(WARNINGS)\n+\t$(WARNINGS) -D_GNU_SOURCE\n if USING_GCC\n AM_CFLAGS = @LIBGCJ_CFLAGS@ $(WARNINGS)\n else\n@@ -229,6 +231,12 @@ java/lang/String.h: java/lang/String.class libgcj.zip\n \t    -friend 'jstring _Jv_AllocString (jsize);' \\\n \t    $(basename $<)\n \n+java/lang/reflect/Constructor.h: java/lang/reflect/Constructor.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\\n@@ -797,6 +805,7 @@ java/lang/natString.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/reflect/natArray.cc \\\n+java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natInetAddress.cc \\"}, {"sha": "feb516de38de75cc5a549b03522a0cdb40a4a6fd", "filename": "libjava/Makefile.in", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -158,7 +158,7 @@ EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n \n WARNINGS = -W -Wall\n AM_CXXFLAGS = -fno-rtti -fvtable-thunks @LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ \\\n-\t$(WARNINGS)\n+\t$(WARNINGS) -D_GNU_SOURCE\n \n @USING_GCC_TRUE@AM_CFLAGS = \\\n @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n@@ -619,6 +619,7 @@ java/lang/natString.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/reflect/natArray.cc \\\n+java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natInetAddress.cc \\\n@@ -726,7 +727,7 @@ THANKS acinclude.m4 aclocal.m4 configure configure.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  testsuite gcj include gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1267,7 +1268,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n@@ -1513,6 +1514,12 @@ java/lang/String.h: java/lang/String.class libgcj.zip\n \t    -friend 'jstring _Jv_AllocString (jsize);' \\\n \t    $(basename $<)\n \n+java/lang/reflect/Constructor.h: java/lang/reflect/Constructor.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);' \\\n+\t    -friend 'java::lang::Class;' \\\n+\t    $(basename $<)\n+\n java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\"}, {"sha": "a149935cf1e7883f9add7b0c629cc0dfcc4c81f8", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -76,12 +76,14 @@ DLLTOOL = @DLLTOOL@\n EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n+FORCELIBGCCSPEC = @FORCELIBGCCSPEC@\n GCDEPS = @GCDEPS@\n GCINCS = @GCINCS@\n GCLIBS = @GCLIBS@\n GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n LD = @LD@\n+LIBDATASTARTSPEC = @LIBDATASTARTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n@@ -90,7 +92,6 @@ LN_S = @LN_S@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n NM = @NM@\n-OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n@@ -100,6 +101,7 @@ THREADINCS = @THREADINCS@\n THREADLIBS = @THREADLIBS@\n THREADOBJS = @THREADOBJS@\n THREADSPEC = @THREADSPEC@\n+USE_SYMBOL_UNDERSCORE = @USE_SYMBOL_UNDERSCORE@\n VERSION = @VERSION@\n ZDEPS = @ZDEPS@\n ZINCS = @ZINCS@"}, {"sha": "76a75f61e0d95ba439eea333249a5f86728fac6b", "filename": "libjava/gcj/array.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Farray.h?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -11,8 +11,6 @@ details.  */\n #ifndef __GCJ_ARRAY_H__\n #define __GCJ_ARRAY_H__\n \n-#pragma interface\n-\n #include <java/lang/Object.h>\n \n extern \"Java\" {"}, {"sha": "e5402a0ed8ae70393f7ab43a070e1cef6d6496a3", "filename": "libjava/gcj/method.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2Fmethod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fgcj%2Fmethod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fmethod.h?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -18,4 +18,11 @@ _Jv_FromReflectedMethod(java::lang::reflect::Method *method)\n     ((char *) method->declaringClass->methods + method->offset);\n }\n \n+extern inline jmethodID\n+_Jv_FromReflectedConstructor (java::lang::reflect::Constructor *constructor)\n+{\n+  return (jmethodID)\n+    ((char *) constructor->declaringClass->methods + constructor->offset);\n+}\n+\n #endif /* __GCJ_METHOD_H__ */"}, {"sha": "38af4a5872b6ecbc5ed6c09eb0af438c057e1626", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -76,12 +76,14 @@ DLLTOOL = @DLLTOOL@\n EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n+FORCELIBGCCSPEC = @FORCELIBGCCSPEC@\n GCDEPS = @GCDEPS@\n GCINCS = @GCINCS@\n GCLIBS = @GCLIBS@\n GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n LD = @LD@\n+LIBDATASTARTSPEC = @LIBDATASTARTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n@@ -90,7 +92,6 @@ LN_S = @LN_S@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n NM = @NM@\n-OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n@@ -100,6 +101,7 @@ THREADINCS = @THREADINCS@\n THREADLIBS = @THREADLIBS@\n THREADOBJS = @THREADOBJS@\n THREADSPEC = @THREADSPEC@\n+USE_SYMBOL_UNDERSCORE = @USE_SYMBOL_UNDERSCORE@\n VERSION = @VERSION@\n ZDEPS = @ZDEPS@\n ZINCS = @ZINCS@"}, {"sha": "3b59b8dfe7c391991bd30f9fa0e7cfc755fa6684", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -53,6 +53,7 @@ _Jv_Utf8Const *_Jv_makeUtf8Const (char *s, int len);\n _Jv_Utf8Const *_Jv_makeUtf8Const (jstring string);\n extern jboolean _Jv_equalUtf8Consts (_Jv_Utf8Const *, _Jv_Utf8Const *);\n extern jboolean _Jv_equal (_Jv_Utf8Const *, jstring, jint);\n+extern jboolean _Jv_equaln (_Jv_Utf8Const *, jstring, jint);\n \n #define StringClass _CL_Q34java4lang6String\n extern java::lang::Class StringClass;\n@@ -161,6 +162,13 @@ extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t\t     java::lang::ClassLoader *loader);\n extern jclass _Jv_FindClassFromSignature (char *,\n \t\t\t\t\t  java::lang::ClassLoader *loader);\n+extern void _Jv_GetTypesFromSignature (jmethodID method,\n+\t\t\t\t       jclass declaringClass,\n+\t\t\t\t       JArray<jclass> **arg_types_out,\n+\t\t\t\t       jclass *return_type_out);\n+extern jobject _Jv_CallNonvirtualMethodA (jobject, jclass,\n+\t\t\t\t\t  jmethodID, jboolean,\n+\t\t\t\t\t  JArray<jclass> *, jobjectArray);\n \n extern jobject _Jv_NewMultiArray (jclass, jint ndims, jint* dims)\n   __attribute__((__malloc__));"}, {"sha": "dfdbf72c831ed7acbdc83c99d045dcadba9b718b", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -1,6 +1,6 @@\n // Class.h - Header file for java.lang.Class.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999  Cygnus Solutions\n+/* Copyright (C) 1998, 1999, 2000  Cygnus Solutions\n \n    This file is part of libgcj.\n \n@@ -94,12 +94,16 @@ class java::lang::Class : public java::lang::Object\n \n   java::lang::reflect::Field *getField (jstring);\n private:\n+  jint _getFields (JArray<java::lang::reflect::Field *> *result, jint offset);\n+  JArray<java::lang::reflect::Constructor *> *_getConstructors (jboolean);\n   java::lang::reflect::Field *getField (jstring, jint);\n public:\n   JArray<java::lang::reflect::Field *> *getFields (void);\n \n   JArray<jclass> *getInterfaces (void);\n \n+  void getSignature (java::lang::StringBuffer *buffer);\n+  static jstring getSignature (JArray<jclass> *);\n   java::lang::reflect::Method *getMethod (jstring, JArray<jclass> *);\n   JArray<java::lang::reflect::Method *> *getMethods (void);\n \n@@ -156,6 +160,8 @@ class java::lang::Class : public java::lang::Object\n   // Friend functions implemented in natClass.cc.\n   friend _Jv_Method *_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t\t\t\t _Jv_Utf8Const *signature);\n+  friend _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n+\t\t\t\t\t       _Jv_Utf8Const*);\n   friend void _Jv_InitClass (jclass klass);\n \n   friend jfieldID JvGetFirstInstanceField (jclass);\n@@ -166,6 +172,7 @@ class java::lang::Class : public java::lang::Object\n   friend jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv *, jclass, jfieldID);\n   friend jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);\n   friend jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n+  friend jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);\n \n   friend class _Jv_PrimClass;\n \n@@ -190,8 +197,6 @@ class java::lang::Class : public java::lang::Object\n #ifdef INTERPRETER\n   friend jboolean _Jv_IsInterpretedClass (jclass);\n   friend void _Jv_InitField (jobject, jclass, _Jv_Field*);\n-  friend _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n-\t\t\t\t\t       _Jv_Utf8Const*);\n   friend int _Jv_DetermineVTableIndex (jclass, _Jv_Utf8Const *, \n \t\t\t\t       _Jv_Utf8Const*);\n   friend void _Jv_InitField (jobject, jclass, int);"}, {"sha": "a304e6c01137150ecc5be9bfb0fec9400ab0f530", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -1,6 +1,6 @@\n // Class.java - Representation of a Java class.\n \n-/* Copyright (C) 1998, 1999  Cygnus Solutions\n+/* Copyright (C) 1998, 1999, 2000  Cygnus Solutions\n \n    This file is part of libgcj.\n \n@@ -36,14 +36,27 @@ public static native Class forName (String className)\n \n   public native Constructor getConstructor (Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException;\n-  public native Constructor[] getConstructors () throws SecurityException;\n \n-  public native Class[] getDeclaredClasses () throws SecurityException;\n+  // This is used to implement getConstructors and\n+  // getDeclaredConstructors.\n+  private native Constructor[] _getConstructors (boolean declared)\n+    throws SecurityException;\n+\n+  public Constructor[] getConstructors () throws SecurityException\n+  {\n+    return _getConstructors (false);\n+  }\n \n   public native Constructor getDeclaredConstructor (Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException;\n-  public native Constructor[] getDeclaredConstructors ()\n-    throws SecurityException;\n+\n+  public native Class[] getDeclaredClasses () throws SecurityException;\n+\n+  public Constructor[] getDeclaredConstructors () throws SecurityException\n+  {\n+    return _getConstructors (true);\n+  }\n+\n   public native Field getDeclaredField (String fieldName)\n     throws NoSuchFieldException, SecurityException;\n   public native Field[] getDeclaredFields () throws SecurityException;\n@@ -69,10 +82,15 @@ public Field getField (String fieldName)\n       throw new NoSuchFieldException(fieldName);\n     return fld;\n   }\n+\n+  private native Field[] _getFields (Field[] result, int offset);\n   public native Field[] getFields () throws SecurityException;\n \n   public native Class[] getInterfaces ();\n \n+  private final native void getSignature (StringBuffer buffer);\n+  private static final native String getSignature (Class[] parameterTypes);\n+\n   public native Method getMethod (String methodName, Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException;\n   public native Method[] getMethods () throws SecurityException;"}, {"sha": "939fe387e7aef0c4c0a2b207170c860ccd4a65ec", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 229, "deletions": 32, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -1,6 +1,6 @@\n // natClass.cc - Implementation of java.lang.Class native methods.\n \n-/* Copyright (C) 1998, 1999  Cygnus Solutions\n+/* Copyright (C) 1998, 1999, 2000  Cygnus Solutions\n \n    This file is part of libgcj.\n \n@@ -38,6 +38,7 @@ details.  */\n #include <java/lang/NullPointerException.h>\n #include <java/lang/System.h>\n #include <java/lang/SecurityManager.h>\n+#include <java/lang/StringBuffer.h>\n \n #include <java-cpool.h>\n \n@@ -55,6 +56,8 @@ extern java::lang::Class ClassClass;\n extern java::lang::Class MethodClass;\n #define FieldClass _CL_Q44java4lang7reflect5Field\n extern java::lang::Class FieldClass;\n+#define ConstructorClass _CL_Q44java4lang7reflect11Constructor\n+extern java::lang::Class ConstructorClass;\n \n // Some constants we use to look up the class initializer.\n static _Jv_Utf8Const *void_signature = _Jv_makeUtf8Const (\"()V\", 3);\n@@ -96,27 +99,95 @@ java::lang::Class::forName (jstring className)\n }\n \n java::lang::reflect::Constructor *\n-java::lang::Class::getConstructor (JArray<jclass> *)\n+java::lang::Class::getConstructor (JArray<jclass> *param_types)\n {\n-  JvFail (\"java::lang::Class::getConstructor not implemented\");\n+  jstring partial_sig = getSignature (param_types);\n+  jint hash = partial_sig->hashCode ();\n+\n+  int i = isPrimitive () ? 0 : method_count;\n+  while (--i >= 0)\n+    {\n+      // FIXME: access checks.\n+      if (_Jv_equalUtf8Consts (methods[i].name, init_name)\n+\t  && _Jv_equal (methods[i].signature, partial_sig, hash))\n+\t{\n+\t  // Found it.  For getConstructor, the constructor must be\n+\t  // public.\n+\t  using namespace java::lang::reflect;\n+\t  if (Modifier::isPublic(methods[i].accflags))\n+\t    break;\n+\t  Constructor *cons = new Constructor ();\n+\t  cons->offset = (char *) (&methods[i]) - (char *) methods;\n+\t  cons->declaringClass = this;\n+\t  return cons;\n+\t}\n+    }\n+  JvThrow (new java::lang::NoSuchMethodException);\n }\n \n JArray<java::lang::reflect::Constructor *> *\n-java::lang::Class::getConstructors (void)\n+java::lang::Class::_getConstructors (jboolean declared)\n {\n-  JvFail (\"java::lang::Class::getConstructors not implemented\");\n+  // FIXME: this method needs access checks.\n+\n+  int numConstructors = 0;\n+  int max = isPrimitive () ? 0 : method_count;\n+  int i;\n+  for (i = max; --i >= 0; )\n+    {\n+      _Jv_Method *method = &methods[i];\n+      if (method->name == NULL\n+\t  && ! _Jv_equalUtf8Consts (method->name, init_name))\n+\tcontinue;\n+      if (declared\n+\t  && ! java::lang::reflect::Modifier::isPublic(method->accflags))\n+\tcontinue;\n+      numConstructors++;\n+    }\n+  JArray<java::lang::reflect::Constructor *> *result\n+    = (JArray<java::lang::reflect::Constructor *> *)\n+    JvNewObjectArray (numConstructors, &ConstructorClass, NULL);\n+  java::lang::reflect::Constructor** cptr = elements (result);\n+  for (i = 0;  i < max;  i++)\n+    {\n+      _Jv_Method *method = &methods[i];\n+      if (method->name == NULL\n+\t  && ! _Jv_equalUtf8Consts (method->name, init_name))\n+\tcontinue;\n+      if (declared\n+\t  && ! java::lang::reflect::Modifier::isPublic(method->accflags))\n+\tcontinue;\n+      java::lang::reflect::Constructor *cons\n+\t= new java::lang::reflect::Constructor ();\n+      cons->offset = (char *) method - (char *) methods;\n+      cons->declaringClass = this;\n+      *cptr++ = cons;\n+    }\n+  return result;\n }\n \n java::lang::reflect::Constructor *\n-java::lang::Class::getDeclaredConstructor (JArray<jclass> *)\n+java::lang::Class::getDeclaredConstructor (JArray<jclass> *param_types)\n {\n-  JvFail (\"java::lang::Class::getDeclaredConstructor not implemented\");\n-}\n+  jstring partial_sig = getSignature (param_types);\n+  jint hash = partial_sig->hashCode ();\n \n-JArray<java::lang::reflect::Constructor *> *\n-java::lang::Class::getDeclaredConstructors (void)\n-{\n-  JvFail (\"java::lang::Class::getDeclaredConstructors not implemented\");\n+  int i = isPrimitive () ? 0 : method_count;\n+  while (--i >= 0)\n+    {\n+      // FIXME: access checks.\n+      if (_Jv_equalUtf8Consts (methods[i].name, init_name)\n+\t  && _Jv_equal (methods[i].signature, partial_sig, hash))\n+\t{\n+\t  // Found it.\n+\t  using namespace java::lang::reflect;\n+\t  Constructor *cons = new Constructor ();\n+\t  cons->offset = (char *) (&methods[i]) - (char *) methods;\n+\t  cons->declaringClass = this;\n+\t  return cons;\n+\t}\n+    }\n+  JvThrow (new java::lang::NoSuchMethodException);\n }\n \n java::lang::reflect::Field *\n@@ -187,18 +258,67 @@ java::lang::Class::getDeclaredFields (void)\n   return result;\n }\n \n-java::lang::reflect::Method *\n-java::lang::Class::getDeclaredMethod (jstring, JArray<jclass> *)\n+void\n+java::lang::Class::getSignature (java::lang::StringBuffer *buffer)\n {\n-  JvFail (\"java::lang::Class::getDeclaredMethod not implemented\");\n+  if (isPrimitive())\n+    buffer->append((jchar) method_count);\n+  else\n+    {\n+      jstring name = getName();\n+      if (name->charAt(0) != '[')\n+\tbuffer->append((jchar) 'L');\n+      buffer->append(name);\n+      if (name->charAt(0) != '[')\n+\tbuffer->append((jchar) ';');\n+    }\n+}\n+\n+// This doesn't have to be native.  It is an implementation detail\n+// only called from the C++ code, though, so maybe this is clearer.\n+jstring\n+java::lang::Class::getSignature (JArray<jclass> *param_types)\n+{\n+  java::lang::StringBuffer *buf = new java::lang::StringBuffer ();\n+  buf->append((jchar) '(');\n+  jclass *v = elements (param_types);\n+  for (int i = 0; i < param_types->length; ++i)\n+    v[i]->getSignature(buf);\n+  buf->append((jchar) ')');\n+  return buf->toString();\n+}\n+\n+java::lang::reflect::Method *\n+java::lang::Class::getDeclaredMethod (jstring name,\n+\t\t\t\t      JArray<jclass> *param_types)\n+{\n+  jstring partial_sig = getSignature (param_types);\n+  jint p_len = partial_sig->length();\n+  _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n+  int i = isPrimitive () ? 0 : method_count;\n+  while (--i >= 0)\n+    {\n+      // FIXME: access checks.\n+      if (_Jv_equalUtf8Consts (methods[i].name, utf_name)\n+\t  && _Jv_equaln (methods[i].signature, partial_sig, p_len))\n+\t{\n+\t  // Found it.\n+\t  using namespace java::lang::reflect;\n+\t  Method *rmethod = new Method ();\n+\t  rmethod->offset = (char*) (&methods[i]) - (char*) methods;\n+\t  rmethod->declaringClass = this;\n+\t}\n+    }\n+  JvThrow (new java::lang::NoSuchMethodException);\n }\n \n JArray<java::lang::reflect::Method *> *\n java::lang::Class::getDeclaredMethods (void)\n {\n   int numMethods = 0;\n+  int max = isPrimitive () ? 0 : method_count;\n   int i;\n-  for (i = method_count;  --i >= 0; )\n+  for (i = max; --i >= 0; )\n     {\n       _Jv_Method *method = &methods[i];\n       if (method->name == NULL\n@@ -211,15 +331,16 @@ java::lang::Class::getDeclaredMethods (void)\n     = (JArray<java::lang::reflect::Method *> *)\n     JvNewObjectArray (numMethods, &MethodClass, NULL);\n   java::lang::reflect::Method** mptr = elements (result);\n-  for (i = 0;  i < method_count;  i++)\n+  for (i = 0;  i < max;  i++)\n     {\n       _Jv_Method *method = &methods[i];\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n \t  || _Jv_equalUtf8Consts (method->name, init_name))\n \tcontinue;\n-      java::lang::reflect::Method* rmethod = new java::lang::reflect::Method ();\n-      rmethod->offset = (char*) mptr - (char*) elements (result);\n+      java::lang::reflect::Method* rmethod\n+\t= new java::lang::reflect::Method ();\n+      rmethod->offset = (char*) method - (char*) methods;\n       rmethod->declaringClass = this;\n       *mptr++ = rmethod;\n     }\n@@ -258,10 +379,58 @@ java::lang::Class::getDeclaringClass (void)\n   return NULL;\t\t\t// Placate compiler.\n }\n \n+jint\n+java::lang::Class::_getFields (JArray<java::lang::reflect::Field *> *result,\n+\t\t\t       jint offset)\n+{\n+  int count = 0;\n+  for (int i = 0;  i < field_count;  i++)\n+    {\n+      _Jv_Field *field = &fields[i];\n+      if (! (field->getModifiers() & java::lang::reflect::Modifier::PUBLIC))\n+\tcontinue;\n+      ++count;\n+\n+      if (result != NULL)\n+\t{\n+\t  java::lang::reflect::Field *rfield\n+\t    = new java::lang::reflect::Field ();\n+\t  rfield->offset = (char *) field - (char *) fields;\n+\t  rfield->declaringClass = this;\n+\t  rfield->name = _Jv_NewStringUtf8Const (field->name);\n+\t  (elements (result))[offset + i] = rfield;\n+\t}\n+    }\n+  jclass superclass = getSuperclass();\n+  if (superclass != NULL)\n+    {\n+      int s_count = superclass->_getFields (result, offset);\n+      count += s_count;\n+      offset += s_count;\n+    }\n+  for (int i = 0; i < interface_count; ++i)\n+    {\n+      int f_count = interfaces[i]->_getFields (result, offset);\n+      count += f_count;\n+      offset += f_count;\n+    }\n+  return count;\n+}\n+\n JArray<java::lang::reflect::Field *> *\n java::lang::Class::getFields (void)\n {\n-  JvFail (\"java::lang::Class::getFields not implemented\");\n+  using namespace java::lang::reflect;\n+\n+  int count = _getFields (NULL, 0);\n+\n+  JArray<java::lang::reflect::Field *> *result\n+    = ((JArray<java::lang::reflect::Field *> *)\n+       JvNewObjectArray (count, &FieldClass, NULL));\n+\n+  _getFields (result, 0);\n+\n+  return result;\n }\n \n JArray<jclass> *\n@@ -275,9 +444,30 @@ java::lang::Class::getInterfaces (void)\n }\n \n java::lang::reflect::Method *\n-java::lang::Class::getMethod (jstring, JArray<jclass> *)\n+java::lang::Class::getMethod (jstring name, JArray<jclass> *param_types)\n {\n-  JvFail (\"java::lang::Class::getMethod not implemented\");\n+  jstring partial_sig = getSignature (param_types);\n+  jint p_len = partial_sig->length();\n+  _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n+  for (Class *klass = this; klass; klass = klass->getSuperclass())\n+    {\n+      int i = klass->isPrimitive () ? 0 : klass->method_count;\n+      while (--i >= 0)\n+\t{\n+\t  // FIXME: access checks.\n+\t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n+\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len))\n+\t    {\n+\t      // Found it.\n+\t      using namespace java::lang::reflect;\n+\t      Method *rmethod = new Method ();\n+\t      rmethod->offset = (char*) (&klass->methods[i]) - (char*) methods;\n+\t      rmethod->declaringClass = klass;\n+\t      return rmethod;\n+\t    }\n+\t}\n+    }\n+  JvThrow (new java::lang::NoSuchMethodException);\n }\n \n JArray<java::lang::reflect::Method *> *\n@@ -494,6 +684,8 @@ java::lang::Class::initializeClass (void)\n // Some class-related convenience functions.\n //\n \n+// Find a method declared in the class.  If it is not declared locally\n+// (or if it is inherited), return NULL.\n _Jv_Method *\n _Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t    _Jv_Utf8Const *signature)\n@@ -507,6 +699,21 @@ _Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n   return NULL;\n }\n \n+_Jv_Method *\n+_Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n+\t\t\t_Jv_Utf8Const *signature)\n+{\n+  for (; klass; klass = klass->getSuperclass())\n+    {\n+      _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n+\n+      if (meth)\n+\treturn meth;\n+    }\n+\n+  return NULL;\n+}\n+\n // NOTE: MCACHE_SIZE should be a power of 2 minus one.\n #define MCACHE_SIZE 1023\n \n@@ -553,16 +760,6 @@ void *\n _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n \t\t\t   _Jv_Utf8Const *signature)\n {\n-  // FIXME: can't do this until we have a working class loader.\n-  // This probably isn't the right thing to do anyway, since we can't\n-  // call a method of a class until the class is linked.  But this\n-  // captures the general idea.\n-  // klass->getClassLoader()->resolveClass(klass);\n-  // \n-  // KKT: This is unnessecary, exactly for the reason you present: \n-  // _Jv_LookupInterfaceMethod is only called on object instances, and\n-  // such have already been initialized (which includes resolving).\n-\n   void *ncode = _Jv_FindMethodInCache (klass, name, signature);\n   if (ncode != 0)\n     return ncode;"}, {"sha": "7815d7cedc6874bdc2039a79ddafdceb1e896b9a", "filename": "libjava/java/lang/reflect/Constructor.java", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -28,53 +28,52 @@ public boolean equals (Object obj)\n       if (! (obj instanceof Constructor))\n \treturn false;\n       Constructor c = (Constructor) obj;\n-      return decl_class == c.decl_class && index == c.index;\n+      return declaringClass == c.declaringClass && offset == c.offset;\n     }\n \n   public Class getDeclaringClass ()\n     {\n-      return decl_class;\n+      return declaringClass;\n     }\n \n   public Class[] getExceptionTypes ()\n     {\n       return (Class[]) exception_types.clone();\n     }\n \n-  public int getModifiers ()\n-    {\n-      return modifiers;\n-    }\n+  public native int getModifiers ();\n \n   public String getName ()\n-    {\n-      return decl_class.getName();\n-    }\n+  {\n+    return declaringClass.getName();\n+  }\n \n   public Class[] getParameterTypes ()\n     {\n+      if (parameter_types == null)\n+\tgetType ();\n       return (Class[]) parameter_types.clone();\n     }\n \n   public int hashCode ()\n     {\n       // FIXME.\n-      return getName().hashCode();\n+      return getName().hashCode() + declaringClass.getName().hashCode();\n     }\n \n-  // FIXME: this must be native.  Should share implementation with\n-  // Method.invoke.\n-  public Object newInstance (Object[] args)\n+  // Update cached values from method descriptor in class.\n+  private native void getType ();\n+\n+  public native Object newInstance (Object[] args)\n     throws InstantiationException, IllegalAccessException,\n-           IllegalArgumentException, InvocationTargetException\n-    {\n-      return null;\n-    }\n+           IllegalArgumentException, InvocationTargetException;\n \n   public String toString ()\n     {\n+      if (parameter_types == null)\n+\tgetType ();\n       StringBuffer b = new StringBuffer ();\n-      b.append(Modifier.toString(modifiers));\n+      b.append(Modifier.toString(getModifiers()));\n       b.append(\" \");\n       b.append(getName());\n       b.append(\"(\");\n@@ -88,19 +87,19 @@ public String toString ()\n       return b.toString();\n     }\n \n-  // Can't create these.  FIXME.\n+  // Can't create these.\n   private Constructor ()\n     {\n     }\n \n   // Declaring class.\n-  private Class decl_class;\n+  private Class declaringClass;\n+\n   // Exception types.\n   private Class[] exception_types;\n-  // Modifiers.\n-  private int modifiers;\n   // Parameter types.\n   private Class[] parameter_types;\n-  // Index of this method in declaring class' method table.\n-  private int index;\n+\n+  // Offset in bytes from the start of declaringClass's methods array.\n+  private int offset;\n }"}, {"sha": "dd87816a40dba8b9bba9be8cf256d9776a454c55", "filename": "libjava/java/lang/reflect/Method.java", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMethod.java?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -10,14 +10,16 @@\n  \n package java.lang.reflect;\n \n+import gnu.gcj.RawData;\n+\n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n  * @date December 12, 1998\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Incomplete: invoke() needs to be finished.\n+ * Status:  Complete, but not correct: access checks aren't done.\n  */\n \n public final class Method extends AccessibleObject implements Member\n@@ -66,6 +68,30 @@ public int hashCode ()\n       return name.hashCode() + declaringClass.getName().hashCode();\n     }\n \n+  // This is used to perform an actual method call via ffi.\n+  private static final native void hack_call (RawData cif,\n+\t\t\t\t\t      RawData method,\n+\t\t\t\t\t      RawData ret_value,\n+\t\t\t\t\t      RawData values);\n+\n+  // Perform an ffi call while capturing exceptions.  We have to do\n+  // this because we can't catch Java exceptions from C++.\n+  static final Throwable hack_trampoline (RawData cif,\n+\t\t\t\t\t  RawData method,\n+\t\t\t\t\t  RawData ret_value,\n+\t\t\t\t\t  RawData values)\n+  {\n+    try\n+      {\n+\thack_call (cif, method, ret_value, values);\n+      }\n+    catch (Throwable x)\n+      {\n+\treturn x;\n+      }\n+    return null;\n+  }\n+\n   public native Object invoke (Object obj, Object[] args)\n     throws IllegalAccessException, IllegalArgumentException,\n            InvocationTargetException;"}, {"sha": "1197e68c90a110edc1a04bdd7ac3eb651e757755", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -0,0 +1,53 @@\n+// natConstructor.cc - Native code for Constructor class.\n+\n+/* Copyright (C) 1999, 2000  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <java/lang/reflect/Constructor.h>\n+#include <java/lang/reflect/Method.h>\n+#include <java/lang/reflect/InvocationTargetException.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java/lang/InstantiationException.h>\n+#include <gcj/method.h>\n+\n+jint\n+java::lang::reflect::Constructor::getModifiers ()\n+{\n+  return _Jv_FromReflectedConstructor (this)->accflags;\n+}\n+\n+void\n+java::lang::reflect::Constructor::getType ()\n+{\n+  _Jv_GetTypesFromSignature (_Jv_FromReflectedConstructor (this),\n+\t\t\t     declaringClass,\n+\t\t\t     &parameter_types,\n+\t\t\t     NULL);\n+}\n+\n+jobject\n+java::lang::reflect::Constructor::newInstance (jobjectArray args)\n+{\n+  if (parameter_types == NULL)\n+    getType ();\n+\n+  using namespace java::lang::reflect;\n+  if (Modifier::isAbstract (declaringClass->getModifiers()))\n+    JvThrow (new InstantiationException);\n+\n+  jmethodID meth = _Jv_FromReflectedConstructor (this);\n+  // In the constructor case the return type is the type of the\n+  // constructor.\n+  return _Jv_CallNonvirtualMethodA (NULL, declaringClass, meth, true,\n+\t\t\t\t    parameter_types, args);\n+}"}, {"sha": "5635b9fe33d14c8822d9409962f212f384b3681f", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 228, "deletions": 136, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -1,21 +1,20 @@\n // natMethod.cc - Native code for Method class.\n \n-/* Copyright (C) 1998, 1999  Cygnus Solutions\n+/* Copyright (C) 1998, 1999, 2000  Cygnus Solutions\n \n    This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n-// This is about 90% done.  Search for FIXME to see what remains.\n-\n #include <config.h>\n \n #include <gcj/cni.h>\n #include <jvm.h>\n \n #include <java/lang/reflect/Method.h>\n+#include <java/lang/reflect/Constructor.h>\n #include <java/lang/reflect/InvocationTargetException.h>\n #include <java/lang/reflect/Modifier.h>\n \n@@ -32,14 +31,15 @@ details.  */\n #include <java/lang/NullPointerException.h>\n #include <java/lang/Class.h>\n #include <gcj/method.h>\n+#include <gnu/gcj/RawData.h>\n \n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n #define ClassClass _CL_Q34java4lang5Class\n extern java::lang::Class ClassClass;\n \n #include <stdlib.h>\n \n-#if 0\n-\n #include <ffi.h>\n \n #define VoidClass _CL_Q34java4lang4Void\n@@ -145,37 +145,225 @@ get_ffi_type (jclass klass)\n   return r;\n }\n \n-// FIXME: the body of this method should be a separate function so\n-// that Constructor can use it too.\n+// Actually perform an FFI call.\n+void\n+java::lang::reflect::Method::hack_call (gnu::gcj::RawData *rcif,\n+\t\t\t\t\tgnu::gcj::RawData *rmethod,\n+\t\t\t\t\tgnu::gcj::RawData *rret_value,\n+\t\t\t\t\tgnu::gcj::RawData *rvalues)\n+{\n+  ffi_cif *cif = (ffi_cif *) rcif;\n+  void (*method) (...) = (void (*) (...)) rmethod;\n+  void *ret_value = (void *) rret_value;\n+  void **values = (void **) rvalues;\n+\n+  ffi_call (cif, method, ret_value, values);\n+}\n+\n jobject\n-java::lang::reflect::Method::invoke (jobject obj,\n-\t\t\t\t     jobjectArray args)\n+java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n {\n-  // FIXME: we need to be a friend of Class here.\n-  _Jv_Method *meth = decl_class->methods[index];\n-  if (! java::lang::reflect::Modifier::isStatic(modifiers))\n+  if (parameter_types == NULL)\n+    getType ();\n+\n+  jmethodID meth = _Jv_FromReflectedMethod (this);\n+  if (! java::lang::reflect::Modifier::isStatic(meth->accflags))\n     {\n       jclass k = obj ? obj->getClass() : NULL;\n-      if (! obj || ! decl_class->isAssignableFrom(k))\n+      if (! obj)\n \tJvThrow (new java::lang::NullPointerException);\n+      if (! declaringClass->isAssignableFrom(k))\n+\tJvThrow (new java::lang::IllegalArgumentException);\n       // FIXME: access checks.\n-      meth = _Jv_LookupMethod (k, meth->name, meth->signature);\n+\n+      // Find the possibly overloaded method based on the runtime type\n+      // of the object.\n+      meth = _Jv_LookupDeclaredMethod (k, meth->name, meth->signature);\n     }\n \n+  return _Jv_CallNonvirtualMethodA (obj, return_type, meth, false,\n+\t\t\t\t    parameter_types, args);\n+}\n+\n+jint\n+java::lang::reflect::Method::getModifiers ()\n+{\n+  return _Jv_FromReflectedMethod (this)->accflags;\n+}\n+\n+jstring\n+java::lang::reflect::Method::getName ()\n+{\n+  if (name == NULL)\n+    name = _Jv_NewStringUtf8Const (_Jv_FromReflectedMethod (this)->name);\n+  return name;\n+}\n+\n+/* Internal method to set return_type and parameter_types fields. */\n+\n+void\n+java::lang::reflect::Method::getType ()\n+{\n+  _Jv_GetTypesFromSignature (_Jv_FromReflectedMethod (this),\n+\t\t\t     declaringClass,\n+\t\t\t     &parameter_types,\n+\t\t\t     &return_type);\n+}\n+\n+void\n+_Jv_GetTypesFromSignature (jmethodID method,\n+\t\t\t   jclass declaringClass,\n+\t\t\t   JArray<jclass> **arg_types_out,\n+\t\t\t   jclass *return_type_out)\n+{\n+\n+  _Jv_Utf8Const* sig = method->signature;\n+  java::lang::ClassLoader *loader = declaringClass->getClassLoader();\n+  char *ptr = sig->data;\n+  int numArgs = 0;\n+  /* First just count the number of parameters. */\n+  for (; ; ptr++)\n+    {\n+      switch (*ptr)\n+\t{\n+\tcase 0:\n+\tcase ')':\n+\tcase 'V':\n+\t  break;\n+\tcase '[':\n+\tcase '(':\n+\t  continue;\n+\tcase 'B':\n+\tcase 'C':\n+\tcase 'D':\n+\tcase 'F':\n+\tcase 'S':\n+\tcase 'I':\n+\tcase 'J':\n+\tcase 'Z':\n+\t  numArgs++;\n+\t  continue;\n+\tcase 'L':\n+\t  numArgs++;\n+\t  do \n+\t    ptr++;\n+\t  while (*ptr != ';' && ptr[1] != '\\0');\n+\t  continue;\n+\t}\n+      break;\n+    }\n+\n+  JArray<jclass> *args = (JArray<jclass> *)\n+    JvNewObjectArray (numArgs, &ClassClass, NULL);\n+  jclass* argPtr = elements (args);\n+  for (ptr = sig->data; *ptr != '\\0'; ptr++)\n+    {\n+      int num_arrays = 0;\n+      jclass type;\n+      for (; *ptr == '[';  ptr++)\n+\tnum_arrays++;\n+      switch (*ptr)\n+\t{\n+\tdefault:\n+\t  return;\n+\tcase ')':\n+\t  argPtr = return_type_out;\n+\t  continue;\n+\tcase '(':\n+\t  continue;\n+\tcase 'V':\n+\tcase 'B':\n+\tcase 'C':\n+\tcase 'D':\n+\tcase 'F':\n+\tcase 'S':\n+\tcase 'I':\n+\tcase 'J':\n+\tcase 'Z':\n+\t  type = _Jv_FindClassFromSignature(ptr, loader);\n+\t  break;\n+\tcase 'L':\n+\t  type = _Jv_FindClassFromSignature(ptr, loader);\n+\t  do \n+\t    ptr++;\n+\t  while (*ptr != ';' && ptr[1] != '\\0');\n+\t  break;\n+\t}\n+\n+      // FIXME: 2'nd argument should be \"current loader\"\n+      while (--num_arrays >= 0)\n+\ttype = _Jv_FindArrayClass (type, 0);\n+      // ARGPTR can be NULL if we are processing the return value of a\n+      // call from Constructor.\n+      if (argPtr)\n+\t*argPtr++ = type;\n+    }\n+  *arg_types_out = args;\n+}\n+\n+// This is a very rough analog of the JNI CallNonvirtual<type>MethodA\n+// functions.  It handles both Methods and Constructors, and it can\n+// handle any return type.  In the Constructor case, the `obj'\n+// argument is unused and should be NULL; also, the `return_type' is\n+// the class that the constructor will construct.\n+jobject\n+_Jv_CallNonvirtualMethodA (jobject obj,\n+\t\t\t   jclass return_type,\n+\t\t\t   jmethodID meth,\n+\t\t\t   jboolean is_constructor,\n+\t\t\t   JArray<jclass> *parameter_types,\n+\t\t\t   jobjectArray args)\n+{\n+  JvAssert (! is_constructor || ! obj);\n+  JvAssert (! is_constructor || ! return_type);\n+\n   // FIXME: access checks.\n \n   if (parameter_types->length != args->length)\n     JvThrow (new java::lang::IllegalArgumentException);\n \n+  // See whether call needs an object as the first argument.  A\n+  // constructor does need a `this' argument, but it is one we create.\n+  jboolean needs_this = false;\n+  if (is_constructor\n+      || ! java::lang::reflect::Modifier::isStatic(meth->accflags))\n+    needs_this = true;\n+\n+  int param_count = parameter_types->length;\n+  if (needs_this)\n+    ++param_count;\n+\n   ffi_type *rtype = get_ffi_type (return_type);\n-  ffi_type **argtypes = (ffi_type **) alloca (parameter_types->length\n+  ffi_type **argtypes = (ffi_type **) alloca (param_count\n \t\t\t\t\t      * sizeof (ffi_type *));\n \n-  jobject *paramelts = elements (parameter_types);\n+  jclass *paramelts = elements (parameter_types);\n   jobject *argelts = elements (args);\n \n+  // FIXME: at some point the compiler is going to add extra arguments\n+  // to some functions.  In particular we are going to do this for\n+  // handling access checks in reflection.  We must add these hidden\n+  // arguments here.\n+\n+  // Special case for the `this' argument of a constructor.  Note that\n+  // the JDK 1.2 docs specify that the new object must be allocated\n+  // before argument conversions are done.\n+  if (is_constructor)\n+    {\n+      // FIXME: must special-case String, arrays, maybe others here.\n+      obj = JvAllocObject (return_type);\n+    }\n+\n+  int i = 0;\n   int size = 0;\n-  for (int i = 0; i < parameter_types->length; ++i)\n+  if (needs_this)\n+    {\n+      // The `NULL' type is `Object'.\n+      argtypes[i++] = get_ffi_type (NULL);\n+      size += sizeof (jobject);\n+    }\n+\n+  for (; i < param_count; ++i)\n     {\n       jclass k = argelts[i] ? argelts[i]->getClass() : NULL;\n       argtypes[i] = get_ffi_type (k);\n@@ -196,7 +384,7 @@ java::lang::reflect::Method::invoke (jobject obj,\n     }\n \n   ffi_cif cif;\n-  if (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, parameter_types->length,\n+  if (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, param_count,\n \t\t    rtype, argtypes) != FFI_OK)\n     {\n       // FIXME: throw some kind of VirtualMachineError here.\n@@ -212,7 +400,14 @@ java::lang::reflect::Method::invoke (jobject obj,\n     Where += sizeof (Type); \\\n   } while (0)\n \n-  for (int i = 0; i < parameter_types->length; ++i)\n+  i = 0;\n+  if (needs_this)\n+    {\n+      COPY (p, obj, jobject);\n+      ++i;\n+    }\n+\n+  for (; i < param_count; ++i)\n     {\n       java::lang::Number *num = (java::lang::Number *) paramelts[i];\n       if (paramelts[i] == JvPrimClass (byte))\n@@ -228,7 +423,8 @@ java::lang::reflect::Method::invoke (jobject obj,\n       else if (paramelts[i] == JvPrimClass (double))\n \tCOPY (p, num->doubleValue(), jdouble);\n       else if (paramelts[i] == JvPrimClass (boolean))\n-\tCOPY (p, ((java::lang::Boolean *) argelts[i])->booleanValue(), jboolean);\n+\tCOPY (p, ((java::lang::Boolean *) argelts[i])->booleanValue(),\n+\t      jboolean);\n       else if (paramelts[i] == JvPrimClass (char))\n \tCOPY (p, ((java::lang::Character *) argelts[i])->charValue(), jchar);\n       else\n@@ -238,11 +434,17 @@ java::lang::reflect::Method::invoke (jobject obj,\n \t}\n     }\n \n-  // FIXME: exception handling.\n+  // FIXME: initialize class here.\n+\n+  // Largest possible value.  Hopefully it is aligned!\n+  jdouble ret_value;\n   java::lang::Throwable *ex;\n-  jdouble ret_value;\t\t// Largest possible value.  Hopefully\n-\t\t\t\t// it is aligned!\n-  ex = TRAMP_CALL (ffi_call (&cif, meth->ncode, &ret_value, (void *) values));\n+  using namespace java::lang;\n+  using namespace java::lang::reflect;\n+  ex = Method::hack_trampoline ((gnu::gcj::RawData *) &cif,\n+\t\t\t\t(gnu::gcj::RawData *) meth->ncode,\n+\t\t\t\t(gnu::gcj::RawData *) &ret_value,\n+\t\t\t\t(gnu::gcj::RawData *) values);\n \n   if (ex)\n     JvThrow (new InvocationTargetException (ex));\n@@ -269,119 +471,9 @@ java::lang::reflect::Method::invoke (jobject obj,\n     r = NULL;\n   else\n     {\n-      JvAssert (! return_type->isPrimitive());\n-      r = VAL (java::lang::Object, jobject);\n+      JvAssert (return_type == NULL || ! return_type->isPrimitive());\n+      r = * (Object **) &ret_value;\n     }\n \n   return r;\n }\n-\n-#else /* 0 */\n-\n-jobject\n-java::lang::reflect::Method::invoke (jobject, jobjectArray)\n-{\n-  JvFail (\"not enabled yet\");\n-}\n-\n-#endif /* 0 */\n-\n-jint\n-java::lang::reflect::Method::getModifiers ()\n-{\n-  return _Jv_FromReflectedMethod (this)->accflags;\n-}\n-\n-jstring\n-java::lang::reflect::Method::getName ()\n-{\n-  if (name == NULL)\n-    name = _Jv_NewStringUtf8Const (_Jv_FromReflectedMethod (this)->name);\n-  return name;\n-}\n-\n-/* Internal method to set return_type and parameter_types fields. */\n-\n-void\n-java::lang::reflect::Method::getType ()\n-{\n-  _Jv_Utf8Const* sig = _Jv_FromReflectedMethod (this)->signature;\n-  java::lang::ClassLoader *loader = declaringClass->getClassLoader();\n-  char *ptr = sig->data;\n-  int numArgs = 0;\n-  /* First just count the number of parameters. */\n-  for (; ; ptr++)\n-    {\n-      switch (*ptr)\n-\t{\n-\tcase 0:\n-\tcase ')':\n-\tcase 'V':\n-\t  break;\n-\tcase '[':\n-\tcase '(':\n-\t  continue;\n-\tcase 'B':\n-\tcase 'C':\n-\tcase 'D':\n-\tcase 'F':\n-\tcase 'S':\n-\tcase 'I':\n-\tcase 'J':\n-\tcase 'Z':\n-\t  numArgs++;\n-\t  continue;\n-\tcase 'L':\n-\t  numArgs++;\n-\t  do \n-\t    ptr++;\n-\t  while (*ptr != ';' && ptr[1] != '\\0');\n-\t  continue;\n-\t}\n-      break;\n-    }\n-\n-  JArray<jclass> *args = (JArray<jclass> *)\n-    JvNewObjectArray (numArgs, &ClassClass, NULL);\n-  jclass* argPtr = elements (args);\n-  for (ptr = sig->data; *ptr != '\\0'; ptr++)\n-    {\n-      int num_arrays = 0;\n-      jclass type;\n-      for (; *ptr == '[';  ptr++)\n-\tnum_arrays++;\n-      switch (*ptr)\n-\t{\n-\tdefault:\n-\t  return;\n-\tcase ')':\n-\t  argPtr = &return_type;\n-\t  continue;\n-\tcase '(':\n-\t  continue;\n-\tcase 'V':\n-\tcase 'B':\n-\tcase 'C':\n-\tcase 'D':\n-\tcase 'F':\n-\tcase 'S':\n-\tcase 'I':\n-\tcase 'J':\n-\tcase 'Z':\n-\t  type = _Jv_FindClassFromSignature(ptr, loader);\n-\t  break;\n-\tcase 'L':\n-\t  type = _Jv_FindClassFromSignature(ptr, loader);\n-\t  do \n-\t    ptr++;\n-\t  while (*ptr != ';' && ptr[1] != '\\0');\n-\t  break;\n-\t}\n-\n-      // FIXME: 2'nd argument should be \"current loader\"\n-      while (--num_arrays >= 0)\n-\ttype = _Jv_FindArrayClass (type, 0);\n-      *argPtr++ = type;\n-    }\n-  parameter_types = args;\n-}"}, {"sha": "2a413ae3403671da234c9d40e246227322083131", "filename": "libjava/prims.cc", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -16,8 +16,6 @@ details.  */\n #include <string.h>\n #include <signal.h>\n \n-#pragma implementation \"gcj/array.h\"\n-\n #include <gcj/cni.h>\n #include <jvm.h>\n #include <java-signal.h>\n@@ -143,6 +141,26 @@ _Jv_equal (Utf8Const* a, jstring str, jint hash)\n   return true;\n }\n \n+/* Like _Jv_equal, but stop after N characters.  */\n+jboolean\n+_Jv_equaln (Utf8Const *a, jstring str, jint n)\n+{\n+  jint len = str->length();\n+  jint i = 0;\n+  jchar *sptr = _Jv_GetStringChars (str);\n+  register unsigned char* ptr = (unsigned char*) a->data;\n+  register unsigned char* limit = ptr + a->length;\n+  for (; n-- > 0; i++, sptr++)\n+    {\n+      int ch = UTF8_GET (ptr, limit);\n+      if (i == len)\n+\treturn ch < 0;\n+      if (ch != *sptr)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Count the number of Unicode chars encoded in a given Ut8 string. */\n int\n _Jv_strLengthUtf8(char* str, int len)"}, {"sha": "e39cb9346a0a006860ea1ff4aa2a5e745754c5c4", "filename": "libjava/resolve.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -321,21 +321,6 @@ _Jv_ResolveField (_Jv_Field *field, java::lang::ClassLoader *loader)\n     }\n }\n \n-_Jv_Method*\n-_Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n-\t\t\t_Jv_Utf8Const *signature)\n-{\n-  for (; klass; klass = klass->getSuperclass())\n-    {\n-      _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n-\n-      if (meth)\n-\treturn meth;\n-    }\n-\n-  return NULL;\n-}\n-\n /** FIXME: this is a terribly inefficient algorithm!  It would improve\n     things if compiled classes to know vtable offset, and _Jv_Method had\n     a field for this."}, {"sha": "25d7a3de50e94a6e3c14581485016fa0ff4bb0a5", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f918fea8b46618edfb2d302c9a920ceb64c22d0/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=0f918fea8b46618edfb2d302c9a920ceb64c22d0", "patch": "@@ -76,12 +76,14 @@ DLLTOOL = @DLLTOOL@\n EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n+FORCELIBGCCSPEC = @FORCELIBGCCSPEC@\n GCDEPS = @GCDEPS@\n GCINCS = @GCINCS@\n GCLIBS = @GCLIBS@\n GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n LD = @LD@\n+LIBDATASTARTSPEC = @LIBDATASTARTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n@@ -90,7 +92,6 @@ LN_S = @LN_S@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n NM = @NM@\n-OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n PERL = @PERL@\n RANLIB = @RANLIB@\n@@ -100,6 +101,7 @@ THREADINCS = @THREADINCS@\n THREADLIBS = @THREADLIBS@\n THREADOBJS = @THREADOBJS@\n THREADSPEC = @THREADSPEC@\n+USE_SYMBOL_UNDERSCORE = @USE_SYMBOL_UNDERSCORE@\n VERSION = @VERSION@\n ZDEPS = @ZDEPS@\n ZINCS = @ZINCS@"}]}