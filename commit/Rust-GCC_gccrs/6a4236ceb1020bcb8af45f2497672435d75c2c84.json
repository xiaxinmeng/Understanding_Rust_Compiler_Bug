{"sha": "6a4236ceb1020bcb8af45f2497672435d75c2c84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0MjM2Y2ViMTAyMGJjYjhhZjQ1ZjI0OTc2NzI0MzVkNzVjMmM4NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-10-25T21:31:12Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-10-25T21:31:12Z"}, "message": "re PR fortran/67171 (sourced allocation)\n\n2015-01-25  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67171\n\t* trans-array.c (structure_alloc_comps): On deallocation of\n\tclass components, reset the vptr to the declared type vtable\n\tand reset the _len field of unlimited polymorphic components.\n\t*trans-expr.c (gfc_find_and_cut_at_last_class_ref): Bail out on\n\tallocatable component references to the right of part reference\n\twith non-zero rank and return NULL.\n\t(gfc_reset_vptr): Simplify this function by using the function\n\tgfc_get_vptr_from_expr. Return if the vptr is NULL_TREE.\n\t(gfc_reset_len): If gfc_find_and_cut_at_last_class_ref returns\n\tNULL return.\n\t* trans-stmt.c (gfc_trans_allocate): Rely on the use of\n\tgfc_trans_assignment if expr3 is a variable expression since\n\tthis deals correctly with array sections.\n\n2015-01-25  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67171\n\t* gfortran.dg/allocate_with_source_12.f03: New test\n\n\tPR fortran/61819\n\t* gfortran.dg/allocate_with_source_13.f03: New test\n\n\tPR fortran/61830\n\t* gfortran.dg/allocate_with_source_14.f03: New test\n\nFrom-SVN: r229303", "tree": {"sha": "dad621aa8de0b50bc5d3198c9849d312a7e7ddca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dad621aa8de0b50bc5d3198c9849d312a7e7ddca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a4236ceb1020bcb8af45f2497672435d75c2c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4236ceb1020bcb8af45f2497672435d75c2c84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a4236ceb1020bcb8af45f2497672435d75c2c84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4236ceb1020bcb8af45f2497672435d75c2c84/comments", "author": null, "committer": null, "parents": [{"sha": "9621d52481aef48baf90fb0008b4e2ff403bc90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9621d52481aef48baf90fb0008b4e2ff403bc90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9621d52481aef48baf90fb0008b4e2ff403bc90b"}], "stats": {"total": 615, "additions": 579, "deletions": 36}, "files": [{"sha": "668013d7dcd4841d4f16da635c0080828a8b7474", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -1,8 +1,25 @@\n+2015-01-25  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67171\n+\t* trans-array.c (structure_alloc_comps): On deallocation of\n+\tclass components, reset the vptr to the declared type vtable\n+\tand reset the _len field of unlimited polymorphic components.\n+\t*trans-expr.c (gfc_find_and_cut_at_last_class_ref): Bail out on\n+\tallocatable component references to the right of part reference\n+\twith non-zero rank and return NULL.\n+\t(gfc_reset_vptr): Simplify this function by using the function\n+\tgfc_get_vptr_from_expr. Return if the vptr is NULL_TREE.\n+\t(gfc_reset_len): If gfc_find_and_cut_at_last_class_ref returns\n+\tNULL return.\n+\t* trans-stmt.c (gfc_trans_allocate): Rely on the use of\n+\tgfc_trans_assignment if expr3 is a variable expression since\n+\tthis deals correctly with array sections.\n+\n 2015-10-25  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/66927\n-\tPR fortran/67044\t\n-\t* trans-array.c (build_array_ref): Modified call to \n+\tPR fortran/67044\n+\t* trans-array.c (build_array_ref): Modified call to\n \tgfc_get_class_array_ref to adhere to new interface.\n \t(gfc_conv_expr_descriptor): For one-based arrays that\n \tare filled by a loop starting at one the start index of the"}, {"sha": "b726998cfcd221dae27300f229a17644474a8a68", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -8024,6 +8024,38 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t}\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\n+\t      /* Finally, reset the vptr to the declared type vtable and, if\n+\t\t necessary reset the _len field.\n+\n+\t\t First recover the reference to the component and obtain\n+\t\t the vptr.  */\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t     decl, cdecl, NULL_TREE);\n+\t      tmp = gfc_class_vptr_get (comp);\n+\n+\t      if (UNLIMITED_POLY (c))\n+\t\t{\n+\t\t  /* Both vptr and _len field should be nulled.  */\n+\t\t  gfc_add_modify (&tmpblock, tmp,\n+\t\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n+\t\t  tmp = gfc_class_len_get (comp);\n+\t\t  gfc_add_modify (&tmpblock, tmp,\n+\t\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Build the vtable address and set the vptr with it.  */\n+\t\t  tree vtab;\n+\t\t  gfc_symbol *vtable;\n+\t\t  vtable = gfc_find_derived_vtab (c->ts.u.derived);\n+\t\t  vtab = vtable->backend_decl;\n+\t\t  if (vtab == NULL_TREE)\n+\t\t    vtab = gfc_get_symbol_decl (vtable);\n+\t\t  vtab = gfc_build_addr_expr (NULL, vtab);\n+\t\t  vtab = fold_convert (TREE_TYPE (tmp), vtab);\n+\t\t  gfc_add_modify (&tmpblock, tmp, vtab);\n+\t\t}\n \t    }\n \n \t  if (cmp_has_alloc_comps"}, {"sha": "f8ed0df8beb48f63f618cba5e2c97bef763ca309", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -271,15 +271,29 @@ gfc_expr *\n gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n {\n   gfc_expr *base_expr;\n-  gfc_ref *ref, *class_ref, *tail;\n+  gfc_ref *ref, *class_ref, *tail, *array_ref;\n \n   /* Find the last class reference.  */\n   class_ref = NULL;\n+  array_ref = NULL;\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n+      if (ref->type == REF_ARRAY\n+\t  && ref->u.ar.type != AR_ELEMENT)\n+\tarray_ref = ref;\n+\n       if (ref->type == REF_COMPONENT\n \t  && ref->u.c.component->ts.type == BT_CLASS)\n+\t{\n+\t  /* Component to the right of a part reference with nonzero rank\n+\t     must not have the ALLOCATABLE attribute.  If attempts are\n+\t     made to reference such a component reference, an error results\n+\t     followed by anICE.  */\n+\t  if (array_ref\n+\t      && CLASS_DATA (ref->u.c.component)->attr.allocatable)\n+\t    return NULL;\n \tclass_ref = ref;\n+\t}\n \n       if (ref->next == NULL)\n \tbreak;\n@@ -320,47 +334,37 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n void\n gfc_reset_vptr (stmtblock_t *block, gfc_expr *e)\n {\n-  gfc_expr *rhs, *lhs = gfc_copy_expr (e);\n   gfc_symbol *vtab;\n-  tree tmp;\n-  gfc_ref *ref;\n+  tree vptr;\n+  tree vtable;\n+  gfc_se se;\n \n-  /* If we have a class array, we need go back to the class\n-     container.  */\n-  if (lhs->ref && lhs->ref->next && !lhs->ref->next->next\n-      && lhs->ref->next->type == REF_ARRAY\n-      && lhs->ref->next->u.ar.type == AR_FULL\n-      && lhs->ref->type == REF_COMPONENT\n-      && strcmp (lhs->ref->u.c.component->name, \"_data\") == 0)\n-    {\n-      gfc_free_ref_list (lhs->ref);\n-      lhs->ref = NULL;\n-    }\n+  /* Evaluate the expression and obtain the vptr from it.  */\n+  gfc_init_se (&se, NULL);\n+  if (e->rank)\n+    gfc_conv_expr_descriptor (&se, e);\n   else\n-    for (ref = lhs->ref; ref; ref = ref->next)\n-      if (ref->next && ref->next->next && !ref->next->next->next\n-\t  && ref->next->next->type == REF_ARRAY\n-\t  && ref->next->next->u.ar.type == AR_FULL\n-\t  && ref->next->type == REF_COMPONENT\n-\t  && strcmp (ref->next->u.c.component->name, \"_data\") == 0)\n-\t{\n-\t  gfc_free_ref_list (ref->next);\n-\t  ref->next = NULL;\n-\t}\n+    gfc_conv_expr (&se, e);\n+  gfc_add_block_to_block (block, &se.pre);\n+  vptr = gfc_get_vptr_from_expr (se.expr);\n \n-  gfc_add_vptr_component (lhs);\n+  /* If a vptr is not found, we can do nothing more.  */\n+  if (vptr == NULL_TREE)\n+    return;\n \n   if (UNLIMITED_POLY (e))\n-    rhs = gfc_get_null_expr (NULL);\n+    gfc_add_modify (block, vptr, build_int_cst (TREE_TYPE (vptr), 0));\n   else\n     {\n+      /* Return the vptr to the address of the declared type.  */\n       vtab = gfc_find_derived_vtab (e->ts.u.derived);\n-      rhs = gfc_lval_expr_from_sym (vtab);\n+      vtable = vtab->backend_decl;\n+      if (vtable == NULL_TREE)\n+\tvtable = gfc_get_symbol_decl (vtab);\n+      vtable = gfc_build_addr_expr (NULL, vtable);\n+      vtable = fold_convert (TREE_TYPE (vptr), vtable);\n+      gfc_add_modify (block, vptr, vtable);\n     }\n-  tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-  gfc_add_expr_to_block (block, tmp);\n-  gfc_free_expr (lhs);\n-  gfc_free_expr (rhs);\n }\n \n \n@@ -372,6 +376,8 @@ gfc_reset_len (stmtblock_t *block, gfc_expr *expr)\n   gfc_expr *e;\n   gfc_se se_len;\n   e = gfc_find_and_cut_at_last_class_ref (expr);\n+  if (e == NULL)\n+    return;\n   gfc_add_len_component (e);\n   gfc_init_se (&se_len, NULL);\n   gfc_conv_expr (&se_len, e);"}, {"sha": "85558f0e8920f5f7c6069f9c294df6a47483208c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -5379,8 +5379,13 @@ gfc_trans_allocate (gfc_code * code)\n \t     will benefit of every enhancements gfc_trans_assignment ()\n \t     gets.\n \t     No need to check whether e3_is is E3_UNSET, because that is\n-\t     done by expr3 != NULL_TREE.  */\n-\t  if (e3_is != E3_MOLD && expr3 != NULL_TREE\n+\t     done by expr3 != NULL_TREE.\n+\t     Exclude variables since the following block does not handle\n+\t     array sections. In any case, there is no harm in sending\n+\t     variables to gfc_trans_assignment because there is no\n+\t     evaluation of variables.  */\n+\t  if (code->expr3->expr_type != EXPR_VARIABLE\n+\t      && e3_is != E3_MOLD && expr3 != NULL_TREE\n \t      && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n \t    {\n \t      /* Build a temporary symtree and symbol.  Do not add it to"}, {"sha": "8ecfd0967811e764bdef12a1df8fd5d68a280588", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -1,3 +1,14 @@\n+2015-01-25  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67171\n+\t* gfortran.dg/allocate_with_source_12.f03: New test\n+\n+\tPR fortran/61819\n+\t* gfortran.dg/allocate_with_source_13.f03: New test\n+\n+\tPR fortran/61830\n+\t* gfortran.dg/allocate_with_source_14.f03: New test\n+\n 2015-10-25  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* g++.dg/Wno-frame-address.C: Skip on hppa*-*-*."}, {"sha": "76deb6174db96f85bd09368325d64aab3941ca14", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_12.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_12.f03?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+!\n+! Checks the fix for PR67171, where the second ALLOCATE with and array section\n+! SOURCE produced a zero index based temporary, which threw the assignment.\n+!\n+! Contributed by Anton Shterenlikht  <mexas@bristol.ac.uk>\n+!\n+program z\n+  implicit none\n+  integer, parameter :: DIM1_SIZE = 10\n+  real, allocatable :: d(:,:), tmp(:,:)\n+  integer :: i, errstat\n+\n+  allocate (d(DIM1_SIZE, 2), source = 0.0, stat=errstat )\n+\n+  d(:,1) = [( real (i), i=1,DIM1_SIZE)]\n+  d(:,2) = [( real(2*i), i=1,DIM1_SIZE)]\n+!  write (*,*) d(1, :)\n+\n+  call move_alloc (from = d, to = tmp)\n+!  write (*,*) tmp( 1, :)\n+\n+  allocate (d(DIM1_SIZE / 2, 2), source = tmp(1 : DIM1_SIZE / 2, :) , stat=errstat)\n+  if (any (d .ne. tmp(1:DIM1_SIZE/2,:))) call abort\n+  deallocate (d)\n+\n+  allocate (d(DIM1_SIZE / 2, 2), source = foo (tmp(1 : DIM1_SIZE / 2, :)) , stat=errstat)\n+  if (any (d .ne. tmp(1 : DIM1_SIZE / 2, :))) call abort\n+\n+  deallocate (tmp , d)\n+\n+contains\n+  function foo (arg) result (res)\n+    real :: arg(:,:)\n+    real :: res(size (arg, 1), size (arg, 2))\n+    res = arg\n+  end function\n+end program z"}, {"sha": "27b5c1775bc0ac2af7c8f8024d57364ef6c372e8", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_13.f03", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_13.f03?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -0,0 +1,220 @@\n+! { dg-do compile }\n+!\n+! Tests the fix for PR61819.\n+!\n+! Contributed by Salvatore Filippone  <sfilippone@uniroma2.it>\n+!\n+module foo_base_mod\n+  integer, parameter :: foo_ipk_ = kind(1)\n+  integer, parameter :: foo_dpk_ = kind(1.d0)\n+  type foo_d_base_vect_type\n+    real(foo_dpk_), allocatable :: v(:)\n+  contains\n+    procedure :: free     => d_base_free\n+    procedure :: get_vect => d_base_get_vect\n+    procedure :: allocate => d_base_allocate\n+  end type foo_d_base_vect_type\n+\n+\n+  type foo_d_vect_type\n+    class(foo_d_base_vect_type), allocatable :: v\n+  contains\n+    procedure :: free     => d_vect_free\n+    procedure :: get_vect => d_vect_get_vect\n+  end type foo_d_vect_type\n+\n+  type foo_desc_type\n+    integer(foo_ipk_) :: nl=-1\n+  end type foo_desc_type\n+\n+\n+contains\n+\n+  subroutine foo_init(ictxt)\n+    integer :: ictxt\n+  end subroutine foo_init\n+\n+\n+  subroutine foo_exit(ictxt)\n+    integer :: ictxt\n+  end subroutine foo_exit\n+\n+  subroutine foo_info(ictxt,iam,np)\n+    integer(foo_ipk_) :: ictxt,iam,np\n+    iam = 0\n+    np = 1\n+  end subroutine foo_info\n+\n+  subroutine  foo_cdall(ictxt,map,info,nl)\n+    integer(foo_ipk_) :: ictxt, info\n+    type(foo_desc_type) :: map\n+    integer(foo_ipk_), optional  :: nl\n+\n+    if (present(nl)) then\n+      map%nl = nl\n+    else\n+      map%nl = 1\n+    end if\n+  end subroutine foo_cdall\n+\n+  subroutine  foo_cdasb(map,info)\n+    integer(foo_ipk_) :: info\n+    type(foo_desc_type) :: map\n+    if (map%nl < 0) map%nl=1\n+  end subroutine foo_cdasb\n+\n+\n+  subroutine d_base_allocate(this,n)\n+    class(foo_d_base_vect_type), intent(out) :: this\n+\n+    allocate(this%v(max(1,n)))\n+\n+  end subroutine d_base_allocate\n+\n+  subroutine d_base_free(this)\n+    class(foo_d_base_vect_type), intent(inout) :: this\n+    if (allocated(this%v)) &\n+         & deallocate(this%v)\n+  end subroutine d_base_free\n+\n+  function d_base_get_vect(this) result(res)\n+    class(foo_d_base_vect_type), intent(inout) :: this\n+    real(foo_dpk_), allocatable :: res(:)\n+\n+    if (allocated(this%v)) then\n+      res = this%v\n+    else\n+      allocate(res(1))\n+    end if\n+  end function d_base_get_vect\n+\n+  subroutine d_vect_free(this)\n+    class(foo_d_vect_type) :: this\n+    if (allocated(this%v)) then\n+      call this%v%free()\n+      deallocate(this%v)\n+    end if\n+  end subroutine d_vect_free\n+\n+  function d_vect_get_vect(this) result(res)\n+    class(foo_d_vect_type) :: this\n+    real(foo_dpk_), allocatable :: res(:)\n+\n+    if (allocated(this%v)) then\n+      res = this%v%get_vect()\n+    else\n+      allocate(res(1))\n+    end if\n+  end function d_vect_get_vect\n+\n+  subroutine foo_geall(v,map,info)\n+    type(foo_d_vect_type), intent(out) :: v\n+    type(foo_Desc_type) :: map\n+    integer(foo_ipk_) :: info\n+\n+    allocate(foo_d_base_vect_type :: v%v,stat=info)\n+    if (info == 0) call v%v%allocate(map%nl)\n+  end subroutine foo_geall\n+\n+end module foo_base_mod\n+\n+\n+module foo_scalar_field_mod\n+  use foo_base_mod\n+  implicit none\n+\n+  type scalar_field\n+    type(foo_d_vect_type)        :: f\n+    type(foo_desc_type), pointer :: map => null()\n+  contains\n+    procedure :: free\n+  end type\n+\n+  integer(foo_ipk_), parameter :: nx=4,ny=nx, nz=nx\n+  type(foo_desc_type), allocatable, save, target :: map\n+  integer(foo_ipk_) ,save :: NumMy_xy_planes\n+  integer(foo_ipk_) ,parameter :: NumGlobalElements = nx*ny*nz\n+  integer(foo_ipk_) ,parameter :: NumGlobal_xy_planes = nz, Num_xy_points_per_plane = nx*ny\n+\n+contains\n+  subroutine initialize_map(ictxt,NumMyElements,info)\n+    integer(foo_ipk_) :: ictxt, NumMyElements, info\n+    info = 0\n+    if (allocated(map)) deallocate(map,stat=info)\n+    if (info == 0) allocate(map,stat=info)\n+    if (info == 0) call foo_cdall(ictxt,map,info,nl=NumMyElements)\n+    if (info == 0) call foo_cdasb(map,info)\n+  end subroutine initialize_map\n+\n+  function new_scalar_field(comm) result(this)\n+    type(scalar_field)                          :: this\n+    integer(foo_ipk_)              ,intent(in) :: comm\n+    real(foo_dpk_) ,allocatable   :: f_v(:)\n+    integer(foo_ipk_) :: i,j,k,NumMyElements, iam, np, info,ip\n+    integer(foo_ipk_), allocatable :: idxs(:)\n+    call foo_info(comm,iam,np)\n+    NumMy_xy_planes = NumGlobal_xy_planes/np\n+    NumMyElements = NumMy_xy_planes*Num_xy_points_per_plane\n+    if (.not. allocated(map)) call initialize_map(comm,NumMyElements,info)\n+    this%map => map\n+    call foo_geall(this%f,this%map,info)\n+  end function\n+\n+  subroutine free(this)\n+    class(scalar_field), intent(inout) :: this\n+    integer(foo_ipk_) ::info\n+    write(0,*) 'Freeing scalar_this%f'\n+    call this%f%free()\n+  end subroutine free\n+\n+end module foo_scalar_field_mod\n+\n+module foo_vector_field_mod\n+  use foo_base_mod\n+  use foo_scalar_field_mod, only : scalar_field,new_scalar_field\n+  implicit none\n+  type vector_field\n+    type(scalar_field) :: u(1)\n+  contains\n+    procedure :: free\n+  end type\n+contains\n+  function new_vector_field(comm_in) result(this)\n+    type(vector_field) :: this\n+    integer(foo_ipk_), intent(in) :: comm_in\n+    this%u = [new_scalar_field(comm_in)] ! Removing this line eliminates the memory leak\n+  end function\n+\n+  subroutine free(this)\n+    class(vector_field), intent(inout) :: this\n+    integer :: i\n+    associate(vf=>this%u)\n+      do i=1, size(vf)\n+        write(0,*) 'Freeing vector_this%u(',i,')'\n+        call vf(i)%free()\n+      end do\n+    end associate\n+  end subroutine free\n+\n+end module foo_vector_field_mod\n+\n+program main\n+  use foo_base_mod\n+  use foo_vector_field_mod,only: vector_field,new_vector_field\n+  use foo_scalar_field_mod,only: map\n+  implicit none\n+  type(vector_field) :: u\n+  type(foo_d_vect_type) :: v\n+  real(foo_dpk_), allocatable :: av(:)\n+  integer(foo_ipk_) :: ictxt, iam, np, i,info\n+  call foo_init(ictxt)\n+  call foo_info(ictxt,iam,np)\n+  u = new_vector_field(ictxt)\n+  call u%free()\n+  do i=1,10\n+    u = new_vector_field(ictxt)\n+    call u%free()\n+  end do\n+  call u%free()\n+  call foo_exit(ictxt)\n+end program"}, {"sha": "36c1245ccdd8ea495a1ba5657ead04d8928b51d0", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_14.f03", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4236ceb1020bcb8af45f2497672435d75c2c84/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03?ref=6a4236ceb1020bcb8af45f2497672435d75c2c84", "patch": "@@ -0,0 +1,214 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Tests the fix for PR61830.\n+!\n+! Contributed by Salvatore Filippone  <sfilippone@uniroma2.it>\n+!\n+module foo_base_mod\n+  integer, parameter :: foo_dpk_ = kind(1.d0)\n+  type foo_d_base_vect_type\n+    real(foo_dpk_), allocatable :: v(:)\n+  contains\n+    procedure :: free     => d_base_free\n+    procedure :: get_vect => d_base_get_vect\n+    procedure :: allocate => d_base_allocate\n+  end type foo_d_base_vect_type\n+\n+\n+  type foo_d_vect_type\n+    class(foo_d_base_vect_type), allocatable :: v\n+  contains\n+    procedure :: free     => d_vect_free\n+    procedure :: get_vect => d_vect_get_vect\n+  end type foo_d_vect_type\n+\n+  type foo_desc_type\n+    integer :: nl=-1\n+  end type foo_desc_type\n+\n+contains\n+\n+  subroutine  foo_cdall(map,nl)\n+    type(foo_desc_type) :: map\n+    integer, optional  :: nl\n+\n+    if (present(nl)) then\n+      map%nl = nl\n+    else\n+      map%nl = 1\n+    end if\n+  end subroutine foo_cdall\n+\n+\n+  subroutine  foo_cdasb(map,info)\n+    integer :: info\n+    type(foo_desc_type) :: map\n+    if (map%nl < 0) map%nl=1\n+  end subroutine foo_cdasb\n+\n+\n+\n+  subroutine d_base_allocate(this,n)\n+    class(foo_d_base_vect_type), intent(out) :: this\n+\n+    allocate(this%v(max(1,n)))\n+\n+  end subroutine d_base_allocate\n+\n+  subroutine d_base_free(this)\n+    class(foo_d_base_vect_type), intent(inout) :: this\n+    if (allocated(this%v))  then\n+      write(0,*) 'Scalar deallocation'\n+      deallocate(this%v)\n+    end if\n+  end subroutine d_base_free\n+\n+  function d_base_get_vect(this) result(res)\n+    class(foo_d_base_vect_type), intent(inout) :: this\n+    real(foo_dpk_), allocatable :: res(:)\n+\n+    if (allocated(this%v)) then\n+      res = this%v\n+    else\n+      allocate(res(1))\n+    end if\n+  end function d_base_get_vect\n+\n+  subroutine d_vect_free(this)\n+    class(foo_d_vect_type) :: this\n+    if (allocated(this%v)) then\n+      call this%v%free()\n+      write(0,*) 'Deallocate class() component'\n+      deallocate(this%v)\n+    end if\n+  end subroutine d_vect_free\n+\n+  function d_vect_get_vect(this) result(res)\n+    class(foo_d_vect_type) :: this\n+    real(foo_dpk_), allocatable :: res(:)\n+\n+    if (allocated(this%v)) then\n+      res = this%v%get_vect()\n+    else\n+      allocate(res(1))\n+    end if\n+  end function d_vect_get_vect\n+\n+  subroutine foo_geall(v,map,info)\n+    type(foo_d_vect_type), intent(out) :: v\n+    type(foo_Desc_type) :: map\n+    integer :: info\n+\n+    allocate(foo_d_base_vect_type :: v%v,stat=info)\n+    if (info == 0) call v%v%allocate(map%nl)\n+  end subroutine foo_geall\n+\n+end module foo_base_mod\n+\n+\n+module foo_scalar_field_mod\n+  use foo_base_mod\n+  implicit none\n+\n+  type scalar_field\n+    type(foo_d_vect_type)        :: f\n+    type(foo_desc_type), pointer :: map => null()\n+  contains\n+    procedure :: free\n+  end type\n+\n+  integer, parameter :: nx=4,ny=nx, nz=nx\n+  type(foo_desc_type), allocatable, save, target :: map\n+  integer ,save :: NumMy_xy_planes\n+  integer ,parameter :: NumGlobalElements = nx*ny*nz\n+  integer ,parameter :: NumGlobal_xy_planes = nz, &\n+       & Num_xy_points_per_plane = nx*ny\n+\n+contains\n+  subroutine initialize_map(NumMyElements)\n+    integer :: NumMyElements, info\n+    info = 0\n+    if (allocated(map)) deallocate(map,stat=info)\n+    if (info == 0) allocate(map,stat=info)\n+    if (info == 0) call foo_cdall(map,nl=NumMyElements)\n+    if (info == 0) call foo_cdasb(map,info)\n+  end subroutine initialize_map\n+\n+  function new_scalar_field() result(this)\n+    type(scalar_field)                          :: this\n+    real(foo_dpk_) ,allocatable   :: f_v(:)\n+    integer :: i,j,k,NumMyElements, iam, np, info,ip\n+    integer, allocatable :: idxs(:)\n+\n+    NumMy_xy_planes = NumGlobal_xy_planes\n+    NumMyElements = NumMy_xy_planes*Num_xy_points_per_plane\n+    if (.not. allocated(map)) call initialize_map(NumMyElements)\n+    this%map => map\n+    call foo_geall(this%f,this%map,info)\n+  end function\n+\n+  subroutine free(this)\n+    class(scalar_field), intent(inout) :: this\n+    integer ::info\n+    call this%f%free()\n+  end subroutine free\n+\n+end module foo_scalar_field_mod\n+\n+module foo_vector_field_mod\n+  use foo_base_mod\n+  use foo_scalar_field_mod\n+  implicit none\n+  type vector_field\n+    type(scalar_field) :: u(1)\n+  end type vector_field\n+contains\n+  function new_vector_field() result(this)\n+    type(vector_field) :: this\n+    integer :: i\n+    do i=1, size(this%u)\n+      associate(sf=>this%u(i))\n+        sf = new_scalar_field()\n+      end associate\n+    end do\n+  end function\n+\n+  subroutine free_v_field(this)\n+    class(vector_field), intent(inout) :: this\n+    integer :: i\n+    associate(vf=>this%u)\n+      do i=1, size(vf)\n+        call vf(i)%free()\n+      end do\n+    end associate\n+  end subroutine free_v_field\n+\n+end module foo_vector_field_mod\n+\n+program main\n+  use foo_base_mod\n+  use foo_vector_field_mod\n+  use foo_scalar_field_mod\n+  implicit none\n+  type(vector_field) :: u\n+  type(foo_d_vect_type) :: v\n+  real(foo_dpk_), allocatable :: av(:)\n+  integer  :: iam, np, i,info\n+\n+  u = new_vector_field()\n+  call foo_geall(v,map,info)\n+  call free_v_field(u)\n+  do i=1,10\n+    u = new_vector_field()\n+    call free_v_field(u)\n+    av = v%get_vect()\n+  end do\n+! This gets rid of the \"memory leak\"\n+  if (associated (u%u(1)%map)) deallocate (u%u(1)%map)\n+  call free_v_field(u)\n+  call v%free()\n+  deallocate(av)\n+end program\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 23 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 29 \"original\" } }"}]}