{"sha": "7b28fa2c6b956d08b2ef909026f42b5df60ae990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IyOGZhMmM2Yjk1NmQwOGIyZWY5MDkwMjZmNDJiNWRmNjBhZTk5MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-20T18:04:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-20T18:04:55Z"}, "message": "reflect: allocate correct type in assignTo and cvtT2I\n\nBackport https://codereview.appspot.com/155450044 from the\nmaster Go library.  Original description:\n\nI came across this while debugging a GC problem in gccgo.\nThere is code in assignTo and cvtT2I that handles assignment\nto all interface values.  It allocates an empty interface even\nif the real type is a non-empty interface.  The fields are\nthen set for a non-empty interface, but the memory is recorded\nas holding an empty interface.  This means that the GC has\nincorrect information.\n\nThis is extremely unlikely to fail, because the code in the GC\nthat handles empty interfaces looks like this:\n\nobj = nil;\ntyp = eface->type;\nif(typ != nil) {\n        if(!(typ->kind&KindDirectIface) || !(typ->kind&KindNoPointers))\n                obj = eface->data;\n\nIn the current runtime the condition is always true--if\nKindDirectIface is set, then KindNoPointers is clear--and we\nalways want to set obj = eface->data.  So the question is what\nhappens when we incorrectly store a non-empty interface value\nin memory marked as an empty interface.  In that case\neface->type will not be a *rtype as we expect, but will\ninstead be a pointer to an Itab.  We are going to use this\npointer to look at a *rtype kind field.  The *rtype struct\nstarts out like this:\n\ntype rtype struct {\n        size          uintptr\n        hash          uint32            // hash of type; avoids computation in hash tables\n        _             uint8             // unused/padding\n        align         uint8             // alignment of variable with this type\n        fieldAlign    uint8             // alignment of struct field with this type\n        kind          uint8             // enumeration for C\n\nAn Itab always has at least two pointers, so on a\nlittle-endian 64-bit system the kind field will be the high\nbyte of the second pointer.  This will normally be zero, so\nthe test of typ->kind will succeed, which is what we want.\n\nOn a 32-bit system it might be possible to construct a failing\ncase by somehow getting the Itab for an interface with one\nmethod to be immediately followed by a word that is all ones.\nThe effect would be that the test would sometimes fail and the\nGC would not mark obj, leading to an invalid dangling\npointer.  I have not tried to construct this test.\n\nI noticed this in gccgo, where this error is much more likely\nto cause trouble for a rather random reason: gccgo uses a\ndifferent layout of rtype, and in gccgo the kind field happens\nto be the low byte of a pointer, not the high byte.\n\nFrom-SVN: r216489", "tree": {"sha": "1a334ba4cf1443ef4c305ebb6150b207a84172c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a334ba4cf1443ef4c305ebb6150b207a84172c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b28fa2c6b956d08b2ef909026f42b5df60ae990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b28fa2c6b956d08b2ef909026f42b5df60ae990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b28fa2c6b956d08b2ef909026f42b5df60ae990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b28fa2c6b956d08b2ef909026f42b5df60ae990/comments", "author": null, "committer": null, "parents": [{"sha": "2bf492a1a4526f143064e41001f34fc1874feea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf492a1a4526f143064e41001f34fc1874feea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf492a1a4526f143064e41001f34fc1874feea7"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "c36e9954427b24f99a5b52a993bbc957c8a36fcd", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b28fa2c6b956d08b2ef909026f42b5df60ae990/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b28fa2c6b956d08b2ef909026f42b5df60ae990/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=7b28fa2c6b956d08b2ef909026f42b5df60ae990", "patch": "@@ -1405,9 +1405,9 @@ func (v Value) send(x Value, nb bool) (selected bool) {\n func (v Value) Set(x Value) {\n \tv.mustBeAssignable()\n \tx.mustBeExported() // do not let unexported x leak\n-\tvar target *interface{}\n+\tvar target unsafe.Pointer\n \tif v.kind() == Interface {\n-\t\ttarget = (*interface{})(v.ptr)\n+\t\ttarget = v.ptr\n \t}\n \tx = x.assignTo(\"reflect.Set\", v.typ, target)\n \tif x.flag&flagIndir != 0 {\n@@ -2230,7 +2230,7 @@ func NewAt(typ Type, p unsafe.Pointer) Value {\n // assignTo returns a value v that can be assigned directly to typ.\n // It panics if v is not assignable to typ.\n // For a conversion to an interface type, target is a suggested scratch space to use.\n-func (v Value) assignTo(context string, dst *rtype, target *interface{}) Value {\n+func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value {\n \tif v.flag&flagMethod != 0 {\n \t\tv = makeMethodValue(context, v)\n \t}\n@@ -2246,15 +2246,15 @@ func (v Value) assignTo(context string, dst *rtype, target *interface{}) Value {\n \n \tcase implements(dst, v.typ):\n \t\tif target == nil {\n-\t\t\ttarget = new(interface{})\n+\t\t\ttarget = unsafe_New(dst)\n \t\t}\n \t\tx := valueInterface(v, false)\n \t\tif dst.NumMethod() == 0 {\n-\t\t\t*target = x\n+\t\t\t*(*interface{})(target) = x\n \t\t} else {\n-\t\t\tifaceE2I(dst, x, unsafe.Pointer(target))\n+\t\t\tifaceE2I(dst, x, target)\n \t\t}\n-\t\treturn Value{dst, unsafe.Pointer(target) /* 0, */, flagIndir | flag(Interface)<<flagKindShift}\n+\t\treturn Value{dst, target /* 0, */, flagIndir | flag(Interface)<<flagKindShift}\n \t}\n \n \t// Failed.\n@@ -2537,14 +2537,14 @@ func cvtDirect(v Value, typ Type) Value {\n \n // convertOp: concrete -> interface\n func cvtT2I(v Value, typ Type) Value {\n-\ttarget := new(interface{})\n+\ttarget := unsafe_New(typ.common())\n \tx := valueInterface(v, false)\n \tif typ.NumMethod() == 0 {\n-\t\t*target = x\n+\t\t*(*interface{})(target) = x\n \t} else {\n-\t\tifaceE2I(typ.(*rtype), x, unsafe.Pointer(target))\n+\t\tifaceE2I(typ.(*rtype), x, target)\n \t}\n-\treturn Value{typ.common(), unsafe.Pointer(target) /* 0, */, v.flag&flagRO | flagIndir | flag(Interface)<<flagKindShift}\n+\treturn Value{typ.common(), target /* 0, */, v.flag&flagRO | flagIndir | flag(Interface)<<flagKindShift}\n }\n \n // convertOp: interface -> interface"}]}