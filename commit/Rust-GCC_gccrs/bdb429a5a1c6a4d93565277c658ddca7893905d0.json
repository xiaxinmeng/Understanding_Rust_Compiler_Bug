{"sha": "bdb429a5a1c6a4d93565277c658ddca7893905d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiNDI5YTVhMWM2YTRkOTM1NjUyNzdjNjU4ZGRjYTc4OTM5MDVkMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-30T13:46:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-30T13:46:05Z"}, "message": "calls.c (expand_call): Pass bit alignment to mark_reg_pointer.\n\n\t* calls.c (expand_call): Pass bit alignment to mark_reg_pointer.\n\t* explow.c (memory_address, allocate_dynamic_stack_space): Likewise.\n\t* function.c (assign_parms): Likewise.\n\t* integrate.c (expand_inline_function): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t(copy_rtx_and_substitute): Likewise.\n\t* expr.c (expand_expr, expand_expr_unaligned): Likewise.\n \t(clear_by_pieces): Fix error in last change.\n\t* emit-rtl.c (init_emit): Set known registers alignment in bits.\n\t* function.h (regno_pointer_align): Now unsigned.\n\t* config/arm/arm.c (alignable_memory_operand): REGNO_POINTER_ALIGN\n\tis in bits.\n\t* config/i386/i386.c (aligned_operand): Likewise.\n\t* config/sparc/sparc.c (mem_min_alignment): Likewise.\n\t* config/alpha/alpha.c (aligned_memory_operand): Likewise.\n\t(unaligned_memory_operand): Likewise.\n\t(alpha_expand_block_move, alpha_expand_block_clear): Likewise.\n\tAlso make alignments and sizes unsigned and some whitespace cleanup.\n\t(alpha_va_start): Do nothing if VALIST's type is error_mark_node.\n\nFrom-SVN: r32829", "tree": {"sha": "4604157a949437de045f5e4819a744fa071efad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4604157a949437de045f5e4819a744fa071efad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb429a5a1c6a4d93565277c658ddca7893905d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb429a5a1c6a4d93565277c658ddca7893905d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb429a5a1c6a4d93565277c658ddca7893905d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb429a5a1c6a4d93565277c658ddca7893905d0/comments", "author": null, "committer": null, "parents": [{"sha": "068feaa95538472dfdb0244ef4899a86e73db86e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068feaa95538472dfdb0244ef4899a86e73db86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068feaa95538472dfdb0244ef4899a86e73db86e"}], "stats": {"total": 327, "additions": 167, "deletions": 160}, "files": [{"sha": "fcd042bbfc5d63f968e7fef1deb77b8dd6cdb617", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -1,5 +1,25 @@\n Thu Mar 30 06:32:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* calls.c (expand_call): Pass bit alignment to mark_reg_pointer.\n+\t* explow.c (memory_address, allocate_dynamic_stack_space): Likewise.\n+\t* function.c (assign_parms): Likewise.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t(copy_rtx_and_substitute): Likewise.\n+\t* expr.c (expand_expr, expand_expr_unaligned): Likewise.\n+ \t(clear_by_pieces): Fix error in last change.\n+\t* emit-rtl.c (init_emit): Set known registers alignment in bits.\n+\t* function.h (regno_pointer_align): Now unsigned.\n+\t* config/arm/arm.c (alignable_memory_operand): REGNO_POINTER_ALIGN\n+\tis in bits.\n+\t* config/i386/i386.c (aligned_operand): Likewise.\n+\t* config/sparc/sparc.c (mem_min_alignment): Likewise.\n+\t* config/alpha/alpha.c (aligned_memory_operand): Likewise.\n+\t(unaligned_memory_operand): Likewise.\n+\t(alpha_expand_block_move, alpha_expand_block_clear): Likewise.\n+\tAlso make alignments and sizes unsigned and some whitespace cleanup.\n+\t(alpha_va_start): Do nothing if VALIST's type is error_mark_node.\n+\n \t* builtins.c (get_pointer_alignment): Use host_integerp & tree_low_cst.\n \t(expand_builtin_apply): Pass alignment to emit_block_move in bits.\n \t(expand_builtin_memcpy, expand_builtin_va_copy): Likewise.\n@@ -26,7 +46,7 @@ Thu Mar 30 06:32:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* expr.h (emit_cmp_insn, emit_cmp_and_jump_insns): Alignment unsigned.\n \t* function.c (purge_addressof_1): Pass bit align to store_bit_field.\n \t(assign_parms): Likewise to emit_group_store.\n-\t* optbas.c (prepare_cmp_insn): Alignment is in bits.\n+\t* optabs.c (prepare_cmp_insn): Alignment is in bits.\n \t(emit_cmp_and_jump_insns, emit_cmp_insn): Likewise, and also unsigned.\n \t* stmt.c (expand_value_return): Pass align in bits to emit_group_load.\n \t(expand_return): Likewise to {extract,store}_bit_field."}, {"sha": "0148391a6c07e2843c734beafd74a5887cd6ef7c", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -2758,10 +2758,7 @@ expand_call (exp, target, ignore)\n \n \t  /* Mark the return value as a pointer if needed.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n-\t    {\n-\t      tree pointed_to = TREE_TYPE (TREE_TYPE (exp));\n-\t      mark_reg_pointer (temp, TYPE_ALIGN (pointed_to) / BITS_PER_UNIT);\n-\t    }\n+\t    mark_reg_pointer (temp, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))));\n \n \t  /* Construct an \"equal form\" for the value which mentions all the\n \t     arguments in order as well as the function name.  */\n@@ -2795,7 +2792,7 @@ expand_call (exp, target, ignore)\n \n \t  /* The return value from a malloc-like function is a pointer. */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n-\t    mark_reg_pointer (temp, BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n+\t    mark_reg_pointer (temp, BIGGEST_ALIGNMENT);\n \n \t  emit_move_insn (temp, valreg);\n "}, {"sha": "a547a9292ac68c7b1dee08883672ff8c0dcd049c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 111, "deletions": 113, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -828,8 +828,7 @@ aligned_memory_operand (op, mode)\n       base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n     }\n \n-  return (GET_CODE (base) == REG\n-\t  && REGNO_POINTER_ALIGN (REGNO (base)) >= 4);\n+  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);\n }\n \n /* Similar, but return 1 if OP is a MEM which is not alignable.  */\n@@ -873,8 +872,7 @@ unaligned_memory_operand (op, mode)\n       base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n     }\n \n-  return (GET_CODE (base) == REG\n-\t  && REGNO_POINTER_ALIGN (REGNO (base)) < 4);\n+  return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) < 32);\n }\n \n /* Return 1 if OP is either a register or an unaligned memory location.  */\n@@ -2501,77 +2499,69 @@ alpha_expand_block_move (operands)\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n   HOST_WIDE_INT orig_bytes = INTVAL (bytes_rtx);\n-  HOST_WIDE_INT bytes = orig_bytes;\n-  HOST_WIDE_INT src_align = INTVAL (align_rtx);\n-  HOST_WIDE_INT dst_align = src_align;\n-  rtx orig_src\t= operands[1];\n-  rtx orig_dst\t= operands[0];\n-  rtx data_regs[2*MAX_MOVE_WORDS+16];\n+  unsigned HOST_WIDE_INT bytes = orig_bytes;\n+  unsigned HOST_WIDE_INT src_align = INTVAL (align_rtx) * BITS_PER_UNIT;\n+  unsigned HOST_WIDE_INT dst_align = src_align;\n+  rtx orig_src = operands[1];\n+  rtx orig_dst = operands[0];\n+  rtx data_regs[2 * MAX_MOVE_WORDS + 16];\n   rtx tmp;\n-  int i, words, ofs, nregs = 0;\n+  unsigned int i, words, ofs, nregs = 0;\n   \n-  if (bytes <= 0)\n+  if (orig_bytes <= 0)\n     return 1;\n-  if (bytes > MAX_MOVE_WORDS*8)\n+  else if (bytes > MAX_MOVE_WORDS * BITS_PER_UNIT)\n     return 0;\n \n   /* Look for additional alignment information from recorded register info.  */\n \n   tmp = XEXP (orig_src, 0);\n   if (GET_CODE (tmp) == REG)\n-    {\n-      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > src_align)\n-\tsrc_align = REGNO_POINTER_ALIGN (REGNO (tmp));\n-    }\n+    src_align = MAX (src_align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n \t   && GET_CODE (XEXP (tmp, 0)) == REG\n \t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n     {\n-      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n-      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+      unsigned HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      unsigned int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n \n       if (a > src_align)\n \t{\n-          if (a >= 8 && c % 8 == 0)\n-\t    src_align = 8;\n-          else if (a >= 4 && c % 4 == 0)\n-\t    src_align = 4;\n-          else if (a >= 2 && c % 2 == 0)\n-\t    src_align = 2;\n+          if (a >= 64 && c % 8 == 0)\n+\t    src_align = 64;\n+          else if (a >= 32 && c % 4 == 0)\n+\t    src_align = 32;\n+          else if (a >= 16 && c % 2 == 0)\n+\t    src_align = 16;\n \t}\n     }\n \t\n   tmp = XEXP (orig_dst, 0);\n   if (GET_CODE (tmp) == REG)\n-    {\n-      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > dst_align)\n-\tdst_align = REGNO_POINTER_ALIGN (REGNO (tmp));\n-    }\n+    dst_align = MAX (dst_align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n \t   && GET_CODE (XEXP (tmp, 0)) == REG\n \t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n     {\n-      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n-      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+      unsigned HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      unsigned int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n \n       if (a > dst_align)\n \t{\n-          if (a >= 8 && c % 8 == 0)\n-\t    dst_align = 8;\n-          else if (a >= 4 && c % 4 == 0)\n-\t    dst_align = 4;\n-          else if (a >= 2 && c % 2 == 0)\n-\t    dst_align = 2;\n+          if (a >= 64 && c % 8 == 0)\n+\t    dst_align = 64;\n+          else if (a >= 32 && c % 4 == 0)\n+\t    dst_align = 32;\n+          else if (a >= 16 && c % 2 == 0)\n+\t    dst_align = 16;\n \t}\n     }\n \n-  /*\n-   * Load the entire block into registers.\n-   */\n-\n+  /* Load the entire block into registers.  */\n   if (GET_CODE (XEXP (orig_src, 0)) == ADDRESSOF)\n     {\n       enum machine_mode mode;\n+\n       tmp = XEXP (XEXP (orig_src, 0), 0);\n \n       /* Don't use the existing register if we're reading more than\n@@ -2589,6 +2579,7 @@ alpha_expand_block_move (operands)\n \t    }\n \t  else\n \t    data_regs[nregs++] = gen_lowpart (mode, tmp);\n+\n \t  goto src_done;\n \t}\n \n@@ -2598,50 +2589,48 @@ alpha_expand_block_move (operands)\n     }\n \n   ofs = 0;\n-  if (src_align >= 8 && bytes >= 8)\n+  if (src_align >= 64 && bytes >= 8)\n     {\n       words = bytes / 8;\n \n       for (i = 0; i < words; ++i)\n-\tdata_regs[nregs+i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx(DImode);\n \n       for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (data_regs[nregs+i],\n-\t\t\t  change_address (orig_src, DImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t\t ofs + i*8)));\n-\t}\n+\temit_move_insn (data_regs[nregs + i],\n+\t\t\tchange_address (orig_src, DImode,\n+\t\t\t\t\tplus_constant (XEXP (orig_src, 0), \n+\t\t\t\t\t\t       ofs + i * 8)));\n \n       nregs += words;\n       bytes -= words * 8;\n       ofs += words * 8;\n     }\n-  if (src_align >= 4 && bytes >= 4)\n+\n+  if (src_align >= 32 && bytes >= 4)\n     {\n       words = bytes / 4;\n \n       for (i = 0; i < words; ++i)\n-\tdata_regs[nregs+i] = gen_reg_rtx(SImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx(SImode);\n \n       for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (data_regs[nregs+i],\n-\t\t\t  change_address (orig_src, SImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t\t ofs + i*4)));\n-\t}\n+\temit_move_insn (data_regs[nregs + i],\n+\t\t\tchange_address (orig_src, SImode,\n+\t\t\t\t\tplus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t       ofs + i * 4)));\n \n       nregs += words;\n       bytes -= words * 4;\n       ofs += words * 4;\n     }\n+\n   if (bytes >= 16)\n     {\n       words = bytes / 8;\n \n       for (i = 0; i < words+1; ++i)\n-\tdata_regs[nregs+i] = gen_reg_rtx(DImode);\n+\tdata_regs[nregs + i] = gen_reg_rtx(DImode);\n \n       alpha_expand_unaligned_load_words (data_regs + nregs, orig_src,\n \t\t\t\t\t words, ofs);\n@@ -2650,23 +2639,26 @@ alpha_expand_block_move (operands)\n       bytes -= words * 8;\n       ofs += words * 8;\n     }\n-  if (!TARGET_BWX && bytes >= 8)\n+\n+  if (! TARGET_BWX && bytes >= 8)\n     {\n       data_regs[nregs++] = tmp = gen_reg_rtx (DImode);\n       alpha_expand_unaligned_load (tmp, orig_src, 8, ofs, 0);\n       bytes -= 8;\n       ofs += 8;\n     }\n-  if (!TARGET_BWX && bytes >= 4)\n+\n+  if (! TARGET_BWX && bytes >= 4)\n     {\n       data_regs[nregs++] = tmp = gen_reg_rtx (SImode);\n       alpha_expand_unaligned_load (tmp, orig_src, 4, ofs, 0);\n       bytes -= 4;\n       ofs += 4;\n     }\n+\n   if (bytes >= 2)\n     {\n-      if (src_align >= 2)\n+      if (src_align >= 16)\n \t{\n \t  do {\n \t    data_regs[nregs++] = tmp = gen_reg_rtx (HImode);\n@@ -2678,14 +2670,16 @@ alpha_expand_block_move (operands)\n \t    ofs += 2;\n \t  } while (bytes >= 2);\n \t}\n-      else if (!TARGET_BWX)\n+\n+      else if (! TARGET_BWX)\n \t{\n \t  data_regs[nregs++] = tmp = gen_reg_rtx (HImode);\n \t  alpha_expand_unaligned_load (tmp, orig_src, 2, ofs, 0);\n \t  bytes -= 2;\n \t  ofs += 2;\n \t}\n     }\n+\n   while (bytes > 0)\n     {\n       data_regs[nregs++] = tmp = gen_reg_rtx (QImode);\n@@ -2696,14 +2690,13 @@ alpha_expand_block_move (operands)\n       bytes -= 1;\n       ofs += 1;\n     }\n+\n  src_done:\n \n-  if (nregs > (int)(sizeof(data_regs)/sizeof(*data_regs)))\n-    abort();\n+  if (nregs > sizeof data_regs / sizeof *data_regs)\n+    abort ();\n \n-  /*\n-   * Now save it back out again.\n-   */\n+  /* Now save it back out again.  */\n \n   i = 0, ofs = 0;\n \n@@ -2721,15 +2714,14 @@ alpha_expand_block_move (operands)\n \t      i = 1;\n \t      goto dst_done;\n \t    }\n+\n \t  else if (nregs == 2 && mode == TImode)\n \t    {\n \t      /* Undo the subregging done above when copying between\n \t\t two TImode registers.  */\n \t      if (GET_CODE (data_regs[0]) == SUBREG\n \t\t  && GET_MODE (SUBREG_REG (data_regs[0])) == TImode)\n-\t\t{\n-\t\t  emit_move_insn (tmp, SUBREG_REG (data_regs[0]));\n-\t\t}\n+\t\temit_move_insn (tmp, SUBREG_REG (data_regs[0]));\n \t      else\n \t\t{\n \t\t  rtx seq;\n@@ -2760,7 +2752,7 @@ alpha_expand_block_move (operands)\n     }\n \n   /* Write out the data in whatever chunks reading the source allowed.  */\n-  if (dst_align >= 8)\n+  if (dst_align >= 64)\n     {\n       while (i < nregs && GET_MODE (data_regs[i]) == DImode)\n \t{\n@@ -2772,7 +2764,8 @@ alpha_expand_block_move (operands)\n \t  i++;\n \t}\n     }\n-  if (dst_align >= 4)\n+\n+  if (dst_align >= 32)\n     {\n       /* If the source has remaining DImode regs, write them out in\n \t two pieces.  */\n@@ -2787,7 +2780,7 @@ alpha_expand_block_move (operands)\n \t\t\t  gen_lowpart (SImode, data_regs[i]));\n \t  emit_move_insn (change_address (orig_dst, SImode,\n \t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t ofs+4)),\n+\t\t\t\t\t\t\t ofs + 4)),\n \t\t\t  gen_lowpart (SImode, tmp));\n \t  ofs += 8;\n \t  i++;\n@@ -2803,18 +2796,20 @@ alpha_expand_block_move (operands)\n \t  i++;\n \t}\n     }\n+\n   if (i < nregs && GET_MODE (data_regs[i]) == DImode)\n     {\n       /* Write out a remaining block of words using unaligned methods.  */\n \n-      for (words = 1; i+words < nregs ; ++words)\n-\tif (GET_MODE (data_regs[i+words]) != DImode)\n+      for (words = 1; i + words < nregs; words++)\n+\tif (GET_MODE (data_regs[i + words]) != DImode)\n \t  break;\n \n       if (words == 1)\n \talpha_expand_unaligned_store (orig_dst, data_regs[i], 8, ofs);\n       else\n-        alpha_expand_unaligned_store_words (data_regs+i, orig_dst, words, ofs);\n+        alpha_expand_unaligned_store_words (data_regs + i, orig_dst,\n+\t\t\t\t\t    words, ofs);\n      \n       i += words;\n       ofs += words * 8;\n@@ -2830,7 +2825,7 @@ alpha_expand_block_move (operands)\n       i++;\n     }\n \n-  if (dst_align >= 2)\n+  if (dst_align >= 16)\n     while (i < nregs && GET_MODE (data_regs[i]) == HImode)\n       {\n \temit_move_insn (change_address (orig_dst, HImode,\n@@ -2847,6 +2842,7 @@ alpha_expand_block_move (operands)\n \ti++;\n \tofs += 2;\n       }\n+\n   while (i < nregs && GET_MODE (data_regs[i]) == QImode)\n     {\n       emit_move_insn (change_address (orig_dst, QImode,\n@@ -2856,10 +2852,11 @@ alpha_expand_block_move (operands)\n       i++;\n       ofs += 1;\n     }\n+\n  dst_done:\n \n   if (i != nregs)\n-    abort();\n+    abort ();\n \n   return 1;\n }\n@@ -2870,42 +2867,40 @@ alpha_expand_block_clear (operands)\n {\n   rtx bytes_rtx\t= operands[1];\n   rtx align_rtx = operands[2];\n-  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n-  HOST_WIDE_INT align = INTVAL (align_rtx);\n-  rtx orig_dst\t= operands[0];\n+  HOST_WIDE_INT orig_bytes = INTVAL (bytes_rtx);\n+  unsigned HOST_WIDE_INT bytes = orig_bytes;\n+  unsigned HOST_WIDE_INT align = INTVAL (align_rtx);\n+  rtx orig_dst = operands[0];\n   rtx tmp;\n-  HOST_WIDE_INT i, words, ofs = 0;\n+  unsigned HOST_WIDE_INT i, words, ofs = 0;\n   \n-  if (bytes <= 0)\n+  if (orig_bytes <= 0)\n     return 1;\n   if (bytes > MAX_MOVE_WORDS*8)\n     return 0;\n \n   /* Look for stricter alignment.  */\n-\n   tmp = XEXP (orig_dst, 0);\n   if (GET_CODE (tmp) == REG)\n-    {\n-      if (REGNO_POINTER_ALIGN (REGNO (tmp)) > align)\n-\talign = REGNO_POINTER_ALIGN (REGNO (tmp));\n-    }\n+    align = MAX (align, REGNO_POINTER_ALIGN (REGNO (tmp)));\n   else if (GET_CODE (tmp) == PLUS\n \t   && GET_CODE (XEXP (tmp, 0)) == REG\n \t   && GET_CODE (XEXP (tmp, 1)) == CONST_INT)\n     {\n-      HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n-      int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n+      unsigned HOST_WIDE_INT c = INTVAL (XEXP (tmp, 1));\n+      unsigned int a = REGNO_POINTER_ALIGN (REGNO (XEXP (tmp, 0)));\n \n       if (a > align)\n \t{\n-          if (a >= 8 && c % 8 == 0)\n-\t    align = 8;\n-          else if (a >= 4 && c % 4 == 0)\n-\t    align = 4;\n-          else if (a >= 2 && c % 2 == 0)\n-\t    align = 2;\n+          if (a >= 64 && c % 8 == 0)\n+\t    align = 64;\n+          else if (a >= 32 && c % 4 == 0)\n+\t    align = 32;\n+          else if (a >= 16 && c % 2 == 0)\n+\t    align = 16;\n \t}\n     }\n+\n   else if (GET_CODE (tmp) == ADDRESSOF)\n     {\n       enum machine_mode mode;\n@@ -2925,36 +2920,34 @@ alpha_expand_block_clear (operands)\n \n   /* Handle a block of contiguous words first.  */\n \n-  if (align >= 8 && bytes >= 8)\n+  if (align >= 64 && bytes >= 8)\n     {\n       words = bytes / 8;\n \n       for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (change_address(orig_dst, DImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs + i*8)),\n+\temit_move_insn (change_address(orig_dst, DImode,\n+\t\t\t\t       plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t      ofs + i * 8)),\n \t\t\t  const0_rtx);\n-\t}\n \n       bytes -= words * 8;\n       ofs += words * 8;\n     }\n-  if (align >= 4 && bytes >= 4)\n+\n+  if (align >= 16 && bytes >= 4)\n     {\n       words = bytes / 4;\n \n       for (i = 0; i < words; ++i)\n-\t{\n-\t  emit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t ofs + i*4)),\n-\t\t\t  const0_rtx);\n-\t}\n+\temit_move_insn (change_address (orig_dst, SImode,\n+\t\t\t\t\tplus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t       ofs + i * 4)),\n+\t\t\tconst0_rtx);\n \n       bytes -= words * 4;\n       ofs += words * 4;\n     }\n+\n   if (bytes >= 16)\n     {\n       words = bytes / 8;\n@@ -2968,21 +2961,23 @@ alpha_expand_block_clear (operands)\n   /* Next clean up any trailing pieces.  We know from the contiguous\n      block move that there are no aligned SImode or DImode hunks left.  */\n \n-  if (!TARGET_BWX && bytes >= 8)\n+  if (! TARGET_BWX && bytes >= 8)\n     {\n       alpha_expand_unaligned_store (orig_dst, const0_rtx, 8, ofs);\n       bytes -= 8;\n       ofs += 8;\n     }\n+\n   if (!TARGET_BWX && bytes >= 4)\n     {\n       alpha_expand_unaligned_store (orig_dst, const0_rtx, 4, ofs);\n       bytes -= 4;\n       ofs += 4;\n     }\n+\n   if (bytes >= 2)\n     {\n-      if (align >= 2)\n+      if (align >= 16)\n \t{\n \t  do {\n \t    emit_move_insn (change_address (orig_dst, HImode,\n@@ -2993,13 +2988,14 @@ alpha_expand_block_clear (operands)\n \t    ofs += 2;\n \t  } while (bytes >= 2);\n \t}\n-      else if (!TARGET_BWX)\n+      else if (! TARGET_BWX)\n \t{\n \t  alpha_expand_unaligned_store (orig_dst, const0_rtx, 2, ofs);\n \t  bytes -= 2;\n \t  ofs += 2;\n \t}\n     }\n+\n   while (bytes > 0)\n     {\n       emit_move_insn (change_address (orig_dst, QImode,\n@@ -3012,7 +3008,6 @@ alpha_expand_block_clear (operands)\n \n   return 1;\n }\n-\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n@@ -3756,6 +3751,9 @@ alpha_va_start (stdarg_p, valist, nextarg)\n   HOST_WIDE_INT offset;\n   tree t, offset_field, base_field;\n \n+  if (TREE_CODE (TREE_TYPE (valist)) == ERROR_MARK)\n+    return;\n+\n   if (TARGET_OPEN_VMS)\n     std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n "}, {"sha": "7bf05363b7797491370048d296cf46928d34be33", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -2487,7 +2487,7 @@ alignable_memory_operand (op, mode)\n \t       && (GET_CODE (reg = XEXP (op, 0)) == REG\n \t\t   || (GET_CODE (XEXP (op, 0)) == SUBREG\n \t\t       && GET_CODE (reg = SUBREG_REG (XEXP (op, 0))) == REG))))\n-\t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 4);\n+\t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 32);\n }\n \n /* Similar to s_register_operand, but does not allow hard integer "}, {"sha": "c739bf62390fbaf07509a1e9fc0d342d518fe0f6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -1449,12 +1449,12 @@ aligned_operand (op, mode)\n   if (parts.index)\n     {\n       if (parts.scale < 4\n-\t  && REGNO_POINTER_ALIGN (REGNO (parts.index)) < 4)\n+\t  && REGNO_POINTER_ALIGN (REGNO (parts.index)) < 32)\n \treturn 0;\n     }\n   if (parts.base)\n     {\n-      if (REGNO_POINTER_ALIGN (REGNO (parts.base)) < 4)\n+      if (REGNO_POINTER_ALIGN (REGNO (parts.base)) < 32)\n \treturn 0;\n     }\n   if (parts.disp)"}, {"sha": "7c27bbc48d1cfdd121065cac77127bbb105cc006", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -2938,9 +2938,10 @@ mem_min_alignment (mem, desired)\n \t     completed, we already matched with proper alignments.\n \t     If not running global_alloc, reload might give us\n \t     unaligned pointer to local stack though.  */\n-\t  if (((cfun != 0 && REGNO_POINTER_ALIGN (regno) >= desired)\n+\t  if (((cfun != 0\n+\t\t&& REGNO_POINTER_ALIGN (regno) >= desired * BITS_PER_UNIT)\n \t       || (optimize && reload_completed))\n-\t      && ((INTVAL (offset) & (desired - 1)) == 0))\n+\t      && (INTVAL (offset) & (desired - 1)) == 0)\n \t    return 1;\n \t}\n       else"}, {"sha": "cf8f5232e6601aef46ecf0cea415fb7883196906", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -3839,21 +3839,16 @@ init_emit ()\n   REGNO_POINTER_FLAG (VIRTUAL_CFA_REGNUM) = 1;\n \n #ifdef STACK_BOUNDARY\n-  REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (FRAME_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM)\n-    = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n-\n-  REGNO_POINTER_ALIGN (VIRTUAL_INCOMING_ARGS_REGNUM)\n-    = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (VIRTUAL_STACK_VARS_REGNUM)\n-    = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM)\n-    = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (VIRTUAL_OUTGOING_ARGS_REGNUM)\n-    = STACK_BOUNDARY / BITS_PER_UNIT;\n-  REGNO_POINTER_ALIGN (VIRTUAL_CFA_REGNUM) = UNITS_PER_WORD;\n+  REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) = STACK_BOUNDARY;\n+\n+  REGNO_POINTER_ALIGN (VIRTUAL_INCOMING_ARGS_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (VIRTUAL_STACK_VARS_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (VIRTUAL_OUTGOING_ARGS_REGNUM) = STACK_BOUNDARY;\n+  REGNO_POINTER_ALIGN (VIRTUAL_CFA_REGNUM) = BITS_PER_WORD;\n #endif\n \n #ifdef INIT_EXPANDERS"}, {"sha": "5eec1d7c28ba3bfd74f3a53d368bdb496aa00fd3", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -583,11 +583,11 @@ memory_address (mode, x)\n   if (oldx == x)\n     return x;\n   else if (GET_CODE (x) == REG)\n-    mark_reg_pointer (x, 1);\n+    mark_reg_pointer (x, BITS_PER_UNIT);\n   else if (GET_CODE (x) == PLUS\n \t   && GET_CODE (XEXP (x, 0)) == REG\n \t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    mark_reg_pointer (XEXP (x, 0), 1);\n+    mark_reg_pointer (XEXP (x, 0), BITS_PER_UNIT);\n \n   /* OLDX may have been the address on a temporary.  Update the address\n      to indicate that X is now used.  */\n@@ -1305,7 +1305,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n       || REGNO (target) < FIRST_PSEUDO_REGISTER)\n     target = gen_reg_rtx (Pmode);\n \n-  mark_reg_pointer (target, known_align / BITS_PER_UNIT);\n+  mark_reg_pointer (target, known_align);\n \n   /* Perform the required allocation from the stack.  Some systems do\n      this differently than simply incrementing/decrementing from the"}, {"sha": "21daef7c5e0787a836d181ab38fc613a605937a9", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -2291,7 +2291,7 @@ clear_by_pieces (to, len, align)\n \n   if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX * BITS_PER_UNIT || align >= BIGGEST_ALIGNMENT)\n-    align = MOVE_MAX;\n+    align = MOVE_MAX * BITS_PER_UNIT;\n \n   /* First move what we can in the largest integer mode, then go to\n      successively smaller modes.  */\n@@ -5973,8 +5973,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (temp != 0)\n \t{\n \t  if (GET_CODE (temp) == MEM && GET_CODE (XEXP (temp, 0)) == REG)\n-\t    mark_reg_pointer (XEXP (temp, 0),\n-\t\t\t      DECL_ALIGN (exp) / BITS_PER_UNIT);\n+\t    mark_reg_pointer (XEXP (temp, 0), DECL_ALIGN (exp));\n \n \t  return temp;\n \t}\n@@ -6801,7 +6800,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    op0 = validize_mem (op0);\n \n \t    if (GET_CODE (op0) == MEM && GET_CODE (XEXP (op0, 0)) == REG)\n-\t      mark_reg_pointer (XEXP (op0, 0), alignment / BITS_PER_UNIT);\n+\t      mark_reg_pointer (XEXP (op0, 0), alignment);\n \n \t    op0 = extract_bit_field (op0, bitsize, bitpos,\n \t\t\t\t     unsignedp, target, ext_mode, ext_mode,\n@@ -6852,7 +6851,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  MEM_ALIAS_SET (op0) = get_alias_set (exp);\n  \n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n-\t  mark_reg_pointer (XEXP (op0, 0), alignment / BITS_PER_UNIT);\n+\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n \n \tMEM_SET_IN_STRUCT_P (op0, 1);\n \tMEM_VOLATILE_P (op0) |= volatilep;\n@@ -8278,7 +8277,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       if (GET_CODE (op0) == REG\n \t  && ! REG_USERVAR_P (op0))\n-\tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)) / BITS_PER_UNIT);\n+\tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)));\n \n       /* If we might have had a temp slot, add an equivalent address\n \t for it.  */\n@@ -8758,7 +8757,7 @@ expand_expr_unaligned (exp, palign)\n \t  alignment >>= 1;\n \n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n-\t  mark_reg_pointer (XEXP (op0, 0), alignment / BITS_PER_UNIT);\n+\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n \n \tMEM_IN_STRUCT_P (op0) = 1;\n \tMEM_VOLATILE_P (op0) |= volatilep;"}, {"sha": "e74d8ba5b911419e8e91407d66d018822fa030c8", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -4763,8 +4763,8 @@ assign_parms (fndecl)\n \t  /* For pointer data type, suggest pointer register.  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n \t    mark_reg_pointer (parmreg,\n-\t\t\t      (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm)))\n-\t\t\t       / BITS_PER_UNIT));\n+\t\t\t      TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n+\n \t}\n       else\n \t{"}, {"sha": "884b98a3b734f464bb24c7184c316a960d9688ce", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -108,7 +108,7 @@ struct emit_status\n   /* Indexed by pseudo register number, if nonzero gives the known alignment\n      for that pseudo (if regno_pointer_flag is set).\n      Allocated in parallel with regno_pointer_flag.  */\n-  char *regno_pointer_align;\n+  unsigned char *regno_pointer_align;\n \n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n      Allocated in parallel with regno_pointer_flag.  */"}, {"sha": "38dca61528d2d38abb5259eb52d6495cde986610", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -756,8 +756,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       if (arg_vals[i] != 0 && GET_CODE (arg_vals[i]) == REG\n \t  && POINTER_TYPE_P (TREE_TYPE (formal)))\n \tmark_reg_pointer (arg_vals[i],\n-\t\t\t  (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (formal)))\n-\t\t\t   / BITS_PER_UNIT));\n+\t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (formal))));\n     }\n \t\n   /* Allocate the structures we use to remap things.  */\n@@ -1761,8 +1760,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n \n #ifdef STACK_BOUNDARY\n-\t      mark_reg_pointer (map->reg_map[regno],\n-\t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n+\t      mark_reg_pointer (map->reg_map[regno], STACK_BOUNDARY);\n #endif\n \n \t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n@@ -1795,8 +1793,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n \n #ifdef STACK_BOUNDARY\n-\t      mark_reg_pointer (map->reg_map[regno],\n-\t\t\t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n+\t      mark_reg_pointer (map->reg_map[regno], STACK_BOUNDARY);\n #endif\n \n \t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);"}, {"sha": "38fb857ac01dcde4efe9f6dcb8f49b3f3a256afa", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb429a5a1c6a4d93565277c658ddca7893905d0/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=bdb429a5a1c6a4d93565277c658ddca7893905d0", "patch": "@@ -3791,8 +3791,8 @@ expand_decl (decl)\n \n       if (POINTER_TYPE_P (type))\n \tmark_reg_pointer (DECL_RTL (decl),\n-\t\t\t  (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl)))\n-\t\t\t   / BITS_PER_UNIT));\n+\t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n+\t\t\t  \n     }\n \n   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST"}]}