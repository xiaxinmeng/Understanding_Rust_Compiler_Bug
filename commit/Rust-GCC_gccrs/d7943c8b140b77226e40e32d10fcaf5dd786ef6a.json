{"sha": "d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5NDNjOGIxNDBiNzcyMjZlNDBlMzJkMTBmY2FmNWRkNzg2ZWY2YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-14T03:31:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-14T03:31:23Z"}, "message": "Expand vector permutation with vec_perm and vec_perm_const.\n\nFrom-SVN: r179958", "tree": {"sha": "853fb9c2eda007bb7110b6aeb291f76f4011742d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/853fb9c2eda007bb7110b6aeb291f76f4011742d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/comments", "author": null, "committer": null, "parents": [{"sha": "5066ab2ee8ccdde331e871303cdfa7d44e461fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5066ab2ee8ccdde331e871303cdfa7d44e461fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5066ab2ee8ccdde331e871303cdfa7d44e461fcc"}], "stats": {"total": 248, "additions": 192, "deletions": 56}, "files": [{"sha": "db96937cb78efcfd5c5050f03c52ae75a48e4c55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -1,3 +1,14 @@\n+2011-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* doc/md.texi (vec_perm): Document fallback to byte permutation.\n+\t* genopinit.c (optabs): Add vec_perm_const.\n+\t* optabs.c (can_vec_perm_expr_p): Rename from expand_vec_perm_expr_p.\n+\tReject non-vector modes.  Allow fallback to byte permutation.\n+\t(expand_vec_perm_expr_1): Split out from ...\n+\t(expand_vec_perm_expr): ... here.  Allow fallback to byte permutation.\n+\t* optabs.h (DOI_vec_perm_const, vec_perm_const_optab): New.\n+\t* tree-vect-generic.c (lower_vec_perm): Update for name change.\n+\n 2011-10-13  Richard Henderson  <rth@redhat.com>\n \n \t* config/rs6000/altivec.md (vec_permv16qi): New pattern."}, {"sha": "68a55481f40659f7c5dbb41a22c8bf8f5d1c3cb1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -4041,6 +4041,12 @@ be computed modulo @math{2*@var{N}}.  Note that if\n @code{rtx_equal_p(operand1, operand2)}, this can be implemented\n with just operand 1 and selector elements modulo @var{N}.\n \n+In order to make things easy for a number of targets, if there is no\n+@samp{vec_perm} pattern for mode @var{m}, but there is for mode @var{q}\n+where @var{q} is a vector of @code{QImode} of the same width as @var{m},\n+the middle-end will lower the mode @var{m} @code{VEC_PERM_EXPR} to\n+mode @var{q}.\n+\n @cindex @code{vec_perm_const@var{m}} instruction pattern\n @item @samp{vec_perm_const@var{m}}\n Like @samp{vec_perm} except that the permutation is a compile-time"}, {"sha": "d40e4c4ec8633367e8a3172ca5c61c2f22f0df60", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -254,6 +254,7 @@ static const char * const optabs[] =\n   \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\",\n   \"set_optab_handler (vec_realign_load_optab, $A, CODE_FOR_$(vec_realign_load_$a$))\",\n   \"set_direct_optab_handler (vec_perm_optab, $A, CODE_FOR_$(vec_perm$a$))\",\n+  \"set_direct_optab_handler (vec_perm_const_optab, $A, CODE_FOR_$(vec_perm_const$a$))\",\n   \"set_convert_optab_handler (vcond_optab, $A, $B, CODE_FOR_$(vcond$a$b$))\",\n   \"set_convert_optab_handler (vcondu_optab, $A, $B, CODE_FOR_$(vcondu$a$b$))\",\n   \"set_optab_handler (ssum_widen_optab, $A, CODE_FOR_$(widen_ssum$I$a3$))\","}, {"sha": "e9a23f4b093a2fa6d6988d96d524ea13f5890804", "filename": "gcc/optabs.c", "status": "modified", "additions": 166, "deletions": 50, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -6687,87 +6687,203 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n \n /* Return true if VEC_PERM_EXPR can be expanded using SIMD extensions\n    of the CPU.  */\n+\n bool\n-expand_vec_perm_expr_p (enum machine_mode mode, tree v0, tree v1, tree mask)\n+can_vec_perm_expr_p (tree type, tree sel)\n {\n-  int v0_mode_s = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (v0))));\n-  int mask_mode_s = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (mask))));\n+  enum machine_mode mode, qimode;\n+  mode = TYPE_MODE (type);\n+\n+  /* If the target doesn't implement a vector mode for the vector type,\n+     then no operations are supported.  */\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  if (TREE_CODE (sel) == VECTOR_CST)\n+    {\n+      if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n+\t  && targetm.vectorize.builtin_vec_perm_ok (type, sel))\n+\treturn true;\n+    }\n \n-  if (TREE_CODE (mask) == VECTOR_CST\n-      && targetm.vectorize.builtin_vec_perm_ok (TREE_TYPE (v0), mask))\n+  if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n     return true;\n \n-  if (v0_mode_s != mask_mode_s\n-      || TYPE_VECTOR_SUBPARTS (TREE_TYPE (v0))\n-\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask))\n-      || TYPE_VECTOR_SUBPARTS (TREE_TYPE (v1))\n-\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask)))\n+  /* We allow fallback to a QI vector mode, and adjust the mask.  */\n+  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n+  if (!VECTOR_MODE_P (qimode))\n     return false;\n \n-  return direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing;\n+  /* ??? For completeness, we ought to check the QImode version of\n+      vec_perm_const_optab.  But all users of this implicit lowering\n+      feature implement the variable vec_perm_optab.  */\n+  if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n+    return false;\n+\n+  /* In order to support the lowering of non-constant permutations,\n+     we need to support shifts and adds.  */\n+  if (TREE_CODE (sel) != VECTOR_CST)\n+    {\n+      if (GET_MODE_UNIT_SIZE (mode) > 2\n+\t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n+\t  && optab_handler (vashl_optab, mode) == CODE_FOR_nothing)\n+\treturn false;\n+      if (optab_handler (add_optab, qimode) == CODE_FOR_nothing)\n+\treturn false;\n+    }\n+\n+  return true;\n }\n \n-/* Generate instructions for VEC_COND_EXPR given its type and three\n-   operands.  */\n-rtx\n-expand_vec_perm_expr (tree type, tree v0, tree v1, tree mask, rtx target)\n+/* A subroutine of expand_vec_perm_expr for expanding one vec_perm insn.  */\n+\n+static rtx\n+expand_vec_perm_expr_1 (enum insn_code icode, rtx target,\n+\t\t\trtx v0, rtx v1, rtx sel)\n {\n+  enum machine_mode tmode = GET_MODE (target);\n+  enum machine_mode smode = GET_MODE (sel);\n   struct expand_operand ops[4];\n-  enum insn_code icode;\n-  enum machine_mode mode = TYPE_MODE (type);\n \n-  gcc_checking_assert (expand_vec_perm_expr_p (mode, v0, v1, mask));\n+  create_output_operand (&ops[0], target, tmode);\n+  create_input_operand (&ops[3], sel, smode);\n \n-  if (TREE_CODE (mask) == VECTOR_CST)\n+  /* Make an effort to preserve v0 == v1.  The target expander is able to\n+     rely on this to determine if we're permuting a single input operand.  */\n+  if (rtx_equal_p (v0, v1))\n     {\n-      tree m_type, call;\n-      tree fn = targetm.vectorize.builtin_vec_perm (TREE_TYPE (v0), &m_type);\n+      if (!insn_operand_matches (icode, 1, v0))\n+        v0 = force_reg (tmode, v0);\n+      gcc_checking_assert (insn_operand_matches (icode, 1, v0));\n+      gcc_checking_assert (insn_operand_matches (icode, 2, v0));\n \n-      if (!fn)\n-\tgoto vec_perm;\n+      create_fixed_operand (&ops[1], v0);\n+      create_fixed_operand (&ops[2], v0);\n+    }\n+  else\n+    {\n+      create_input_operand (&ops[1], v0, tmode);\n+      create_input_operand (&ops[2], v1, tmode);\n+    }\n \n-      if (m_type != TREE_TYPE (TREE_TYPE (mask)))\n-\t{\n-\t  int units = TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask));\n-\t  tree cvt = build_vector_type (m_type, units);\n-\t  mask = fold_convert (cvt, mask);\n-\t}\n+  if (maybe_expand_insn (icode, 4, ops))\n+    return ops[0].value;\n+  return NULL_RTX;\n+}\n \n-      call = fold_build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-      call = build_call_nary (type, call, 3, v0, v1, mask);\n+/* Generate instructions for VEC_PERM_EXPR given its type and three\n+   operands.  */\n+rtx\n+expand_vec_perm_expr (tree type, tree v0, tree v1, tree sel, rtx target)\n+{\n+  enum insn_code icode;\n+  enum machine_mode mode = TYPE_MODE (type);\n+  enum machine_mode qimode;\n+  rtx v0_rtx, v1_rtx, sel_rtx, *vec, vt, tmp;\n+  unsigned int i, w, e, u;\n \n-      return expand_expr_real_1 (call, target, VOIDmode, EXPAND_NORMAL, NULL);\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+  v0_rtx = expand_normal (v0);\n+  if (operand_equal_p (v0, v1, 0))\n+    v1_rtx = v0_rtx;\n+  else\n+    v1_rtx = expand_normal (v1);\n+  sel_rtx = expand_normal (sel);\n+\n+  /* If the input is a constant, expand it specially.  */\n+  if (CONSTANT_P (sel_rtx))\n+    {\n+      icode = direct_optab_handler (vec_perm_const_optab, mode);\n+      if (icode != CODE_FOR_nothing\n+\t  && targetm.vectorize.builtin_vec_perm_ok (TREE_TYPE (v0), sel)\n+\t  && (tmp = expand_vec_perm_expr_1 (icode, target, v0_rtx,\n+\t\t\t\t\t    v1_rtx, sel_rtx)) != NULL)\n+\treturn tmp;\n     }\n \n- vec_perm:\n+  /* Otherwise fall back to a fully variable permuation.  */\n   icode = direct_optab_handler (vec_perm_optab, mode);\n+  if (icode != CODE_FOR_nothing\n+      && (tmp = expand_vec_perm_expr_1 (icode, target, v0_rtx,\n+\t\t\t\t\tv1_rtx, sel_rtx)) != NULL)\n+    return tmp;\n+\n+  /* As a special case to aid several targets, lower the element-based\n+     permutation to a byte-based permutation and try again.  */\n+  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n+  if (!VECTOR_MODE_P (qimode))\n+    return NULL_RTX;\n \n+  /* ??? For completeness, we ought to check the QImode version of\n+     vec_perm_const_optab.  But all users of this implicit lowering\n+     feature implement the variable vec_perm_optab.  */\n+  icode = direct_optab_handler (vec_perm_optab, qimode);\n   if (icode == CODE_FOR_nothing)\n-    return 0;\n+    return NULL_RTX;\n \n-  create_output_operand (&ops[0], target, mode);\n-  create_input_operand (&ops[3], expand_normal (mask),\n-\t\t\tTYPE_MODE (TREE_TYPE (mask)));\n+  w = GET_MODE_SIZE (mode);\n+  e = GET_MODE_NUNITS (mode);\n+  u = GET_MODE_UNIT_SIZE (mode);\n+  vec = XALLOCAVEC (rtx, w);\n \n-  if (operand_equal_p (v0, v1, 0))\n+  if (CONSTANT_P (sel_rtx))\n     {\n-      rtx rtx_v0 = expand_normal (v0);\n-      if (!insn_operand_matches (icode, 1, rtx_v0))\n-        rtx_v0 = force_reg (mode, rtx_v0);\n-\n-      gcc_checking_assert (insn_operand_matches (icode, 2, rtx_v0));\n+      unsigned int j;\n+      for (i = 0; i < e; ++i)\n+\t{\n+\t  unsigned int this_e = INTVAL (XVECEXP (sel_rtx, 0, i));\n+\t  this_e &= 2 * e - 1;\n+          this_e *= u;\n \n-      create_fixed_operand (&ops[1], rtx_v0);\n-      create_fixed_operand (&ops[2], rtx_v0);\n+\t  for (j = 0; j < u; ++j)\n+\t    vec[i * e + j] = GEN_INT (this_e + j);\n+\t}\n+      sel_rtx = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n     }\n   else\n     {\n-      create_input_operand (&ops[1], expand_normal (v0), mode);\n-      create_input_operand (&ops[2], expand_normal (v1), mode);\n-    }\n+      /* Multiply each element by its byte size.  */\n+      if (u == 2)\n+\tsel_rtx = expand_simple_binop (mode, PLUS, sel_rtx, sel_rtx,\n+\t\t\t\t       sel_rtx, 0, OPTAB_DIRECT);\n+      else\n+\tsel_rtx = expand_simple_binop (mode, ASHIFT, sel_rtx,\n+\t\t\t\t       GEN_INT (exact_log2 (u)),\n+\t\t\t\t       sel_rtx, 0, OPTAB_DIRECT);\n+      gcc_assert (sel_rtx);\n \n-  expand_insn (icode, 4, ops);\n-  return ops[0].value;\n+      /* Broadcast the low byte each element into each of its bytes.  */\n+      for (i = 0; i < w; ++i)\n+\t{\n+\t  int this_e = i / u * u;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    this_e += u - 1;\n+\t  vec[i] = GEN_INT (this_e);\n+\t}\n+      vt = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n+      sel_rtx = gen_lowpart (qimode, sel_rtx);\n+      sel_rtx = expand_vec_perm_expr_1 (icode, gen_reg_rtx (qimode),\n+\t\t\t\t\tsel_rtx, sel_rtx, vt);\n+      gcc_assert (sel_rtx != NULL);\n+\n+      /* Add the byte offset to each byte element.  */\n+      /* Note that the definition of the indicies here is memory ordering,\n+\t so there should be no difference between big and little endian.  */\n+      for (i = 0; i < w; ++i)\n+\tvec[i] = GEN_INT (i % u);\n+      vt = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n+      sel_rtx = expand_simple_binop (qimode, PLUS, sel_rtx, vt,\n+\t\t\t\t     NULL_RTX, 0, OPTAB_DIRECT);\n+      gcc_assert (sel_rtx);\n+    }\n+\n+  tmp = expand_vec_perm_expr_1 (icode, gen_lowpart (qimode, target),\n+\t\t\t        gen_lowpart (qimode, v0_rtx),\n+\t\t\t        gen_lowpart (qimode, v1_rtx), sel_rtx);\n+  gcc_assert (tmp != NULL);\n+\n+  return gen_lowpart (mode, tmp);\n }\n \n "}, {"sha": "926d21f09dc0d430c9dda031a9936ce100c85203", "filename": "gcc/optabs.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -638,9 +638,6 @@ enum direct_optab_index\n   DOI_reload_in,\n   DOI_reload_out,\n \n-  /* Vector shuffling.  */\n-  DOI_vec_perm,\n-\n   /* Block move operation.  */\n   DOI_movmem,\n \n@@ -688,6 +685,10 @@ enum direct_optab_index\n   /* Atomic clear with release semantics.  */\n   DOI_sync_lock_release,\n \n+  /* Vector permutation.  */\n+  DOI_vec_perm,\n+  DOI_vec_perm_const,\n+\n   DOI_MAX\n };\n \n@@ -704,7 +705,6 @@ typedef struct direct_optab_d *direct_optab;\n #endif\n #define reload_in_optab (&direct_optab_table[(int) DOI_reload_in])\n #define reload_out_optab (&direct_optab_table[(int) DOI_reload_out])\n-#define vec_perm_optab (&direct_optab_table[(int) DOI_vec_perm])\n #define movmem_optab (&direct_optab_table[(int) DOI_movmem])\n #define setmem_optab (&direct_optab_table[(int) DOI_setmem])\n #define cmpstr_optab (&direct_optab_table[(int) DOI_cmpstr])\n@@ -734,6 +734,8 @@ typedef struct direct_optab_d *direct_optab;\n   (&direct_optab_table[(int) DOI_sync_lock_test_and_set])\n #define sync_lock_release_optab \\\n   (&direct_optab_table[(int) DOI_sync_lock_release])\n+#define vec_perm_optab (&direct_optab_table[DOI_vec_perm])\n+#define vec_perm_const_optab (&direct_optab_table[(int) DOI_vec_perm_const])\n \f\n /* Target-dependent globals.  */\n struct target_optabs {\n@@ -889,7 +891,7 @@ extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n extern rtx expand_vec_shift_expr (sepops, rtx);\n \n /* Return tree if target supports vector operations for VEC_PERM_EXPR.  */\n-bool expand_vec_perm_expr_p (enum machine_mode, tree, tree, tree);\n+extern bool can_vec_perm_expr_p (tree, tree);\n \n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm_expr (tree, tree, tree, tree, rtx);"}, {"sha": "663ea00a72292b8ed10a1651a4c3eb596084e7c3", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7943c8b140b77226e40e32d10fcaf5dd786ef6a/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d7943c8b140b77226e40e32d10fcaf5dd786ef6a", "patch": "@@ -641,7 +641,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n   unsigned i;\n \n-  if (expand_vec_perm_expr_p (TYPE_MODE (vect_type), vec0, vec1, mask))\n+  if (can_vec_perm_expr_p (vect_type, mask))\n     return;\n   \n   warning_at (loc, OPT_Wvector_operation_performance,"}]}