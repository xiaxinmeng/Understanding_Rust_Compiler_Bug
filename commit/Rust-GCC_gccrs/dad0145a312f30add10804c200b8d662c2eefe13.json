{"sha": "dad0145a312f30add10804c200b8d662c2eefe13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFkMDE0NWEzMTJmMzBhZGQxMDgwNGMyMDBiOGQ2NjJjMmVlZmUxMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T23:00:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T23:00:15Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r924", "tree": {"sha": "1d2d4de05d4e71aeef4a5c504065508aece26848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d2d4de05d4e71aeef4a5c504065508aece26848"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dad0145a312f30add10804c200b8d662c2eefe13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0145a312f30add10804c200b8d662c2eefe13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad0145a312f30add10804c200b8d662c2eefe13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0145a312f30add10804c200b8d662c2eefe13/comments", "author": null, "committer": null, "parents": [{"sha": "95949d0ccc73f4bef55fe213c4b1d817cc25ca5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95949d0ccc73f4bef55fe213c4b1d817cc25ca5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95949d0ccc73f4bef55fe213c4b1d817cc25ca5b"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "c82eb00b305cdd2bc71c8c419c5dc993bb4b5c8b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0145a312f30add10804c200b8d662c2eefe13/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0145a312f30add10804c200b8d662c2eefe13/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=dad0145a312f30add10804c200b8d662c2eefe13", "patch": "@@ -853,7 +853,13 @@ dbxout_type (type, full, show_arg_types)\n     case TYPE_UNSEEN:\n       break;\n     case TYPE_XREF:\n-      if (! full)\n+      /* If we have already had a cross reference,\n+\t and either that's all we want or that's the best we could do,\n+\t don't repeat the cross reference.\n+\t Sun dbx crashes if we do.  */\n+      if (! full || TYPE_SIZE (type) == 0\n+\t  /* No way in DBX fmt to describe a variable size.  */\n+\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \treturn;\n       break;\n     case TYPE_DEFINED:\n@@ -1846,6 +1852,46 @@ dbxout_parms (parms)\n \t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n+\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n+\t\t && rtx_equal_p (XEXP (DECL_RTL (parms), 0),\n+\t\t\t\t DECL_INCOMING_RTL (parms)))\n+\t  {\n+\t    /* Parm was passed via invisible reference.\n+\t       That is, its address was passed in a register.\n+\t       Output it as if it lived in that register.\n+\t       The debugger will know from the type\n+\t       that it was actually passed by invisible reference.  */\n+\n+\t    char regparm_letter;\n+\t    /* Parm passed in registers and lives in registers or nowhere.  */\n+\n+\t    current_sym_code = DBX_REGPARM_STABS_CODE;\n+\t    regparm_letter = DBX_REGPARM_STABS_LETTER;\n+\n+\t    /* DECL_RTL looks like (MEM (REG...).  Get the register number.  */\n+\t    current_sym_value = REGNO (XEXP (DECL_RTL (parms), 0));\n+\t    current_sym_addr = 0;\n+\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\n+\t\tfprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n+\t\t\t DBX_REGPARM_STABS_LETTER);\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):%c\", ASM_STABS_OP,\n+\t\t\t DBX_REGPARM_STABS_LETTER);\n+\t      }\n+\n+\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n \t\t && XEXP (DECL_RTL (parms), 0) != const0_rtx)\n \t  {"}]}