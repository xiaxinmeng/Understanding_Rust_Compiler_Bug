{"sha": "00f07b86e7d7c80695fb655738b89d893b54fc9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmMDdiODZlN2Q3YzgwNjk1ZmI2NTU3MzhiODlkODkzYjU0ZmM5YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-07-10T08:25:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-07-10T08:25:20Z"}, "message": "Move vector highpart emulation to the optabs layer\n\n        * expmed.c (expmed_mult_highpart): Rename from expand_mult_highpart.\n        (expmed_mult_highpart_optab): Rename from expand_mult_highpart_optab.\n        * optabs.c (can_mult_highpart_p): New.\n        (expand_mult_highpart): New.\n        * expr.c (expand_expr_real_2) [MULT_HIGHPART_EXPR): Use it.\n        * tree-vect-generic.c (expand_vector_operations_1): Don't expand\n        by pieces if can_mult_highpart_p.\n        (expand_vector_divmod): Use can_mult_highpart_p and always\n        generate MULT_HIGHPART_EXPR.\n        * tree-vect-patterns.c (vect_recog_divmod_pattern): Likewise.\n        * tree-vect-stmts.c (vectorizable_operation): Likewise.\n\nFrom-SVN: r189407", "tree": {"sha": "92ca34cfac26d6253011a1acbd60501bca8cdf7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92ca34cfac26d6253011a1acbd60501bca8cdf7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f07b86e7d7c80695fb655738b89d893b54fc9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f07b86e7d7c80695fb655738b89d893b54fc9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f07b86e7d7c80695fb655738b89d893b54fc9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f07b86e7d7c80695fb655738b89d893b54fc9a/comments", "author": null, "committer": null, "parents": [{"sha": "9283726f7623410f58bf23da7d7589c7b261b449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9283726f7623410f58bf23da7d7589c7b261b449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9283726f7623410f58bf23da7d7589c7b261b449"}], "stats": {"total": 490, "additions": 204, "deletions": 286}, "files": [{"sha": "5ff4d81de5c73651e12ad906db0cc3ce413d19c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -1,5 +1,17 @@\n 2012-07-10  Richard Henderson  <rth@redhat.com>\n \n+\t* expmed.c (expmed_mult_highpart): Rename from expand_mult_highpart.\n+\t(expmed_mult_highpart_optab): Rename from expand_mult_highpart_optab.\n+\t* optabs.c (can_mult_highpart_p): New.\n+\t(expand_mult_highpart): New.\n+\t* expr.c (expand_expr_real_2) [MULT_HIGHPART_EXPR): Use it.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Don't expand\n+\tby pieces if can_mult_highpart_p.\n+\t(expand_vector_divmod): Use can_mult_highpart_p and always\n+\tgenerate MULT_HIGHPART_EXPR.\n+\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_operation): Likewise.\n+\n \t* config/spu/spu-builtins.md (spu_mpy): Move to spu.md.\n \t(spu_mpyu, spu_mpyhhu, spu_mpyhh): Likewise.\n \t* config/spu/spu.md (vec_widen_smult_odd_v8hi): Rename from spu_mpy."}, {"sha": "4101f613f82ea29bfc919f09d2831974da1fbb91", "filename": "gcc/expmed.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -2381,8 +2381,8 @@ static rtx expand_mult_const (enum machine_mode, rtx, HOST_WIDE_INT, rtx,\n \t\t\t      const struct algorithm *, enum mult_variant);\n static unsigned HOST_WIDE_INT invert_mod2n (unsigned HOST_WIDE_INT, int);\n static rtx extract_high_half (enum machine_mode, rtx);\n-static rtx expand_mult_highpart (enum machine_mode, rtx, rtx, rtx, int, int);\n-static rtx expand_mult_highpart_optab (enum machine_mode, rtx, rtx, rtx,\n+static rtx expmed_mult_highpart (enum machine_mode, rtx, rtx, rtx, int, int);\n+static rtx expmed_mult_highpart_optab (enum machine_mode, rtx, rtx, rtx,\n \t\t\t\t       int, int);\n /* Compute and return the best algorithm for multiplying by T.\n    The algorithm must cost less than cost_limit\n@@ -3477,7 +3477,7 @@ expand_mult_highpart_adjust (enum machine_mode mode, rtx adj_operand, rtx op0,\n   return target;\n }\n \n-/* Subroutine of expand_mult_highpart.  Return the MODE high part of OP.  */\n+/* Subroutine of expmed_mult_highpart.  Return the MODE high part of OP.  */\n \n static rtx\n extract_high_half (enum machine_mode mode, rtx op)\n@@ -3495,11 +3495,11 @@ extract_high_half (enum machine_mode mode, rtx op)\n   return convert_modes (mode, wider_mode, op, 0);\n }\n \n-/* Like expand_mult_highpart, but only consider using a multiplication\n+/* Like expmed_mult_highpart, but only consider using a multiplication\n    optab.  OP1 is an rtx for the constant operand.  */\n \n static rtx\n-expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n+expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \t\t\t    rtx target, int unsignedp, int max_cost)\n {\n   rtx narrow_op1 = gen_int_mode (INTVAL (op1), mode);\n@@ -3610,7 +3610,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n    MAX_COST is the total allowed cost for the expanded RTL.  */\n \n static rtx\n-expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n+expmed_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n \t\t      rtx target, int unsignedp, int max_cost)\n {\n   enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n@@ -3633,7 +3633,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n      mode == word_mode, however all the cost calculations in\n      synth_mult etc. assume single-word operations.  */\n   if (GET_MODE_BITSIZE (wider_mode) > BITS_PER_WORD)\n-    return expand_mult_highpart_optab (mode, op0, op1, target,\n+    return expmed_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t       unsignedp, max_cost);\n \n   extra_cost = shift_cost[speed][mode][GET_MODE_BITSIZE (mode) - 1];\n@@ -3651,7 +3651,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n     {\n       /* See whether the specialized multiplication optabs are\n \t cheaper than the shift/add version.  */\n-      tem = expand_mult_highpart_optab (mode, op0, op1, target, unsignedp,\n+      tem = expmed_mult_highpart_optab (mode, op0, op1, target, unsignedp,\n \t\t\t\t\talg.cost.cost + extra_cost);\n       if (tem)\n \treturn tem;\n@@ -3666,7 +3666,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n \n       return tem;\n     }\n-  return expand_mult_highpart_optab (mode, op0, op1, target,\n+  return expmed_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t     unsignedp, max_cost);\n }\n \n@@ -3940,7 +3940,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n      In all cases but EXACT_DIV_EXPR, this multiplication requires the upper\n      half of the product.  Different strategies for generating the product are\n-     implemented in expand_mult_highpart.\n+     implemented in expmed_mult_highpart.\n \n      If what we actually want is the remainder, we generate that by another\n      by-constant multiplication and a subtraction.  */\n@@ -3990,7 +3990,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n      mode for which we can do the operation with a library call.  */\n \n   /* We might want to refine this now that we have division-by-constant\n-     optimization.  Since expand_mult_highpart tries so many variants, it is\n+     optimization.  Since expmed_mult_highpart tries so many variants, it is\n      not straightforward to generalize this.  Maybe we should make an array\n      of possible modes in init_expmed?  Save this for GCC 2.7.  */\n \n@@ -4155,7 +4155,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      = (shift_cost[speed][compute_mode][post_shift - 1]\n \t\t\t\t + shift_cost[speed][compute_mode][1]\n \t\t\t\t + 2 * add_cost[speed][compute_mode]);\n-\t\t\t    t1 = expand_mult_highpart (compute_mode, op0,\n+\t\t\t    t1 = expmed_mult_highpart (compute_mode, op0,\n \t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -4187,7 +4187,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    extra_cost\n \t\t\t      = (shift_cost[speed][compute_mode][pre_shift]\n \t\t\t\t + shift_cost[speed][compute_mode][post_shift]);\n-\t\t\t    t2 = expand_mult_highpart (compute_mode, t1,\n+\t\t\t    t2 = expmed_mult_highpart (compute_mode, t1,\n \t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -4313,7 +4313,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n \t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n \t\t\t\t      + add_cost[speed][compute_mode]);\n-\t\t\tt1 = expand_mult_highpart (compute_mode, op0,\n+\t\t\tt1 = expmed_mult_highpart (compute_mode, op0,\n \t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n@@ -4348,7 +4348,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n \t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n \t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n-\t\t\tt1 = expand_mult_highpart (compute_mode, op0, mlr,\n+\t\t\tt1 = expmed_mult_highpart (compute_mode, op0, mlr,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n@@ -4436,7 +4436,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n \t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n \t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n-\t\t\tt3 = expand_mult_highpart (compute_mode, t2,\n+\t\t\tt3 = expmed_mult_highpart (compute_mode, t2,\n \t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 1,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t3 != 0)"}, {"sha": "916dee09fe4e401ad10bbf8db1489b10a290645b", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -8554,9 +8554,14 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n     case RDIV_EXPR:\n-    case MULT_HIGHPART_EXPR:\n       goto binop;\n \n+    case MULT_HIGHPART_EXPR:\n+      expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n+      temp = expand_mult_highpart (mode, op0, op1, target, unsignedp);\n+      gcc_assert (temp);\n+      return temp;\n+\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case CEIL_MOD_EXPR:"}, {"sha": "e1ecc657484a835fe0a34aa8f925d7011154bbda", "filename": "gcc/optabs.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -7162,6 +7162,132 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n   return ops[0].value;\n }\n \n+/* Return non-zero if a highpart multiply is supported of can be synthisized.\n+   For the benefit of expand_mult_highpart, the return value is 1 for direct,\n+   2 for even/odd widening, and 3 for hi/lo widening.  */\n+\n+int\n+can_mult_highpart_p (enum machine_mode mode, bool uns_p)\n+{\n+  optab op;\n+  unsigned char *sel;\n+  unsigned i, nunits;\n+\n+  op = uns_p ? umul_highpart_optab : smul_highpart_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    return 1;\n+\n+  /* If the mode is an integral vector, synth from widening operations.  */\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+    return 0;\n+\n+  nunits = GET_MODE_NUNITS (mode);\n+  sel = XALLOCAVEC (unsigned char, nunits);\n+\n+  op = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    {\n+      op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n+      if (optab_handler (op, mode) != CODE_FOR_nothing)\n+\t{\n+\t  for (i = 0; i < nunits; ++i)\n+\t    sel[i] = !BYTES_BIG_ENDIAN + (i & ~1) + ((i & 1) ? nunits : 0);\n+\t  if (can_vec_perm_p (mode, false, sel))\n+\t    return 2;\n+\t}\n+    }\n+\n+  op = uns_p ? vec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n+  if (optab_handler (op, mode) != CODE_FOR_nothing)\n+    {\n+      op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n+      if (optab_handler (op, mode) != CODE_FOR_nothing)\n+\t{\n+\t  for (i = 0; i < nunits; ++i)\n+\t    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n+\t  if (can_vec_perm_p (mode, false, sel))\n+\t    return 3;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Expand a highpart multiply.  */\n+\n+rtx\n+expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n+\t\t      rtx target, bool uns_p)\n+{\n+  struct expand_operand eops[3];\n+  enum insn_code icode;\n+  int method, i, nunits;\n+  enum machine_mode wmode;\n+  rtx m1, m2, perm;\n+  optab tab1, tab2;\n+  rtvec v;\n+\n+  method = can_mult_highpart_p (mode, uns_p);\n+  switch (method)\n+    {\n+    case 0:\n+      return NULL_RTX;\n+    case 1:\n+      tab1 = uns_p ? umul_highpart_optab : smul_highpart_optab;\n+      return expand_binop (mode, tab1, op0, op1, target, uns_p,\n+\t\t\t   OPTAB_LIB_WIDEN);\n+    case 2:\n+      tab1 = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n+      tab2 = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n+      break;\n+    case 3:\n+      tab1 = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n+      tab2 = uns_p ? vec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  optab t = tab1;\n+\t  tab1 = tab2;\n+\t  tab2 = t;\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  icode = optab_handler (tab1, mode);\n+  nunits = GET_MODE_NUNITS (mode);\n+  wmode = insn_data[icode].operand[0].mode;\n+  gcc_checking_assert (2 * GET_MODE_NUNITS (wmode) == nunits);\n+  gcc_checking_assert (GET_MODE_SIZE (wmode) == GET_MODE_SIZE (mode));\n+\n+  create_output_operand (&eops[0], gen_reg_rtx (wmode), wmode);\n+  create_input_operand (&eops[1], op0, mode);\n+  create_input_operand (&eops[2], op1, mode);\n+  expand_insn (icode, 3, eops);\n+  m1 = gen_lowpart (mode, eops[0].value);\n+\n+  create_output_operand (&eops[0], gen_reg_rtx (wmode), wmode);\n+  create_input_operand (&eops[1], op0, mode);\n+  create_input_operand (&eops[2], op1, mode);\n+  expand_insn (optab_handler (tab2, mode), 3, eops);\n+  m2 = gen_lowpart (mode, eops[0].value);\n+\n+  v = rtvec_alloc (nunits);\n+  if (method == 2)\n+    {\n+      for (i = 0; i < nunits; ++i)\n+\tRTVEC_ELT (v, i) = GEN_INT (!BYTES_BIG_ENDIAN + (i & ~1)\n+\t\t\t\t    + ((i & 1) ? nunits : 0));\n+    }\n+  else\n+    {\n+      for (i = 0; i < nunits; ++i)\n+\tRTVEC_ELT (v, i) = GEN_INT (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n+    }\n+  perm = gen_rtx_CONST_VECTOR (mode, v);\n+\n+  return expand_vec_perm (mode, m1, m2, perm, target);\n+}\n \f\n /* Return true if there is a compare_and_swap pattern.  */\n "}, {"sha": "8b04e17e7b319be88052431093111153677842ac", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -1014,6 +1014,12 @@ extern bool can_vec_perm_p (enum machine_mode, bool, const unsigned char *);\n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm (enum machine_mode, rtx, rtx, rtx, rtx);\n \n+/* Return non-zero if target supports a given highpart multiplication.  */\n+extern int can_mult_highpart_p (enum machine_mode, bool);\n+\n+/* Generate code for MULT_HIGHPART_EXPR.  */\n+extern rtx expand_mult_highpart (enum machine_mode, rtx, rtx, rtx, bool);\n+\n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n "}, {"sha": "b0f41d123d7559413e7eb34f798150a521d49329", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 16, "deletions": 97, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -454,10 +454,9 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n   int dummy_int;\n   unsigned int i, unsignedp = TYPE_UNSIGNED (TREE_TYPE (type));\n   unsigned HOST_WIDE_INT mask = GET_MODE_MASK (TYPE_MODE (TREE_TYPE (type)));\n-  optab op;\n   tree *vec;\n-  unsigned char *sel = NULL;\n-  tree cur_op, m1, m2, mulcst, perm_mask, wider_type, tem, decl_e, decl_o;\n+  tree cur_op, mulcst, tem;\n+  optab op;\n \n   if (prec > HOST_BITS_PER_WIDE_INT)\n     return NULL_TREE;\n@@ -745,54 +744,8 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n   if (mode == -2 || BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n     return NULL_TREE;\n \n-  op = optab_for_tree_code (MULT_HIGHPART_EXPR, type, optab_default);\n-  if (op != NULL && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n-    wider_type = decl_e = decl_o = NULL_TREE;\n-  else\n-    {\n-      wider_type = build_nonstandard_integer_type (prec * 2, unsignedp),\n-      wider_type = build_vector_type (wider_type, nunits / 2);\n-      if (GET_MODE_CLASS (TYPE_MODE (wider_type)) != MODE_VECTOR_INT\n-\t  || GET_MODE_BITSIZE (TYPE_MODE (wider_type))\n-\t     != GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\treturn NULL_TREE;\n-\n-      sel = XALLOCAVEC (unsigned char, nunits);\n-\n-      if (targetm.vectorize.builtin_mul_widen_even\n-\t  && targetm.vectorize.builtin_mul_widen_odd\n-\t  && (decl_e = targetm.vectorize.builtin_mul_widen_even (type))\n-\t  && (decl_o = targetm.vectorize.builtin_mul_widen_odd (type))\n-\t  && (TYPE_MODE (TREE_TYPE (TREE_TYPE (decl_e)))\n-\t      == TYPE_MODE (wider_type)))\n-\t{\n-\t  for (i = 0; i < nunits; i++)\n-\t    sel[i] = !BYTES_BIG_ENDIAN + (i & ~1) + ((i & 1) ? nunits : 0);\n-\t  if (!can_vec_perm_p (TYPE_MODE (type), false, sel))\n-\t    decl_e = decl_o = NULL_TREE;\n-\t}\n-      else\n-\tdecl_e = decl_o = NULL_TREE;\n-\n-      if (decl_e == NULL_TREE)\n-\t{\n-\t  op = optab_for_tree_code (VEC_WIDEN_MULT_LO_EXPR,\n-\t\t\t\t    type, optab_default);\n-\t  if (op == NULL\n-\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n-\t    return NULL_TREE;\n-\t  op = optab_for_tree_code (VEC_WIDEN_MULT_HI_EXPR,\n-\t\t\t\t    type, optab_default);\n-\t  if (op == NULL\n-\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n-\t    return NULL_TREE;\n-\n-\t  for (i = 0; i < nunits; i++)\n-\t    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n-\t  if (!can_vec_perm_p (TYPE_MODE (type), false, sel))\n-\t    return NULL_TREE;\n-\t}\n-    }\n+  if (!can_mult_highpart_p (TYPE_MODE (type), TYPE_UNSIGNED (type)))\n+    return NULL_TREE;\n \n   cur_op = op0;\n \n@@ -830,46 +783,8 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n   for (i = 0; i < nunits; i++)\n     vec[i] = build_int_cst (TREE_TYPE (type), mulc[i]);\n   mulcst = build_vector (type, vec);\n-  if (wider_type == NULL_TREE)\n-    cur_op = gimplify_build2 (gsi, MULT_HIGHPART_EXPR, type, cur_op, mulcst);\n-  else\n-    {\n-      for (i = 0; i < nunits; i++)\n-\tvec[i] = build_int_cst (TREE_TYPE (type), sel[i]);\n-      perm_mask = build_vector (type, vec);\n-\n-      if (decl_e != NULL_TREE)\n-\t{\n-\t  gimple call;\n-\n-\t  call = gimple_build_call (decl_e, 2, cur_op, mulcst);\n-\t  m1 = create_tmp_reg (wider_type, NULL);\n-\t  add_referenced_var (m1);\n-\t  m1 = make_ssa_name (m1, call);\n-\t  gimple_call_set_lhs (call, m1);\n-\t  gsi_insert_seq_before (gsi, call, GSI_SAME_STMT);\n-\n-\t  call = gimple_build_call (decl_o, 2, cur_op, mulcst);\n-\t  m2 = create_tmp_reg (wider_type, NULL);\n-\t  add_referenced_var (m2);\n-\t  m2 = make_ssa_name (m2, call);\n-\t  gimple_call_set_lhs (call, m2);\n-\t  gsi_insert_seq_before (gsi, call, GSI_SAME_STMT);\n-\t}\n-      else\n-\t{\n-\t  m1 = gimplify_build2 (gsi, BYTES_BIG_ENDIAN ? VEC_WIDEN_MULT_HI_EXPR\n-\t\t\t\t\t\t      : VEC_WIDEN_MULT_LO_EXPR,\n-\t\t\t\twider_type, cur_op, mulcst);\n-\t  m2 = gimplify_build2 (gsi, BYTES_BIG_ENDIAN ? VEC_WIDEN_MULT_LO_EXPR\n-\t\t\t\t\t\t      : VEC_WIDEN_MULT_HI_EXPR,\n-\t\t\t\twider_type, cur_op, mulcst);\n-\t}\n \n-      m1 = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, m1);\n-      m2 = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, m2);\n-      cur_op = gimplify_build3 (gsi, VEC_PERM_EXPR, type, m1, m2, perm_mask);\n-    }\n+  cur_op = gimplify_build2 (gsi, MULT_HIGHPART_EXPR, type, cur_op, mulcst);\n \n   switch (mode)\n     {\n@@ -1454,13 +1369,17 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   if (compute_type == type)\n     {\n       compute_mode = TYPE_MODE (compute_type);\n-      if (VECTOR_MODE_P (compute_mode)\n-          && op != NULL\n-\t  && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n-\treturn;\n-      else\n-\t/* There is no operation in hardware, so fall back to scalars.  */\n-\tcompute_type = TREE_TYPE (type);\n+      if (VECTOR_MODE_P (compute_mode))\n+\t{\n+          if (op && optab_handler (op, compute_mode) != CODE_FOR_nothing)\n+\t    return;\n+\t  if (code == MULT_HIGHPART_EXPR\n+\t      && can_mult_highpart_p (compute_mode,\n+\t\t\t\t      TYPE_UNSIGNED (compute_type)))\n+\t    return;\n+\t}\n+      /* There is no operation in hardware, so fall back to scalars.  */\n+      compute_type = TREE_TYPE (type);\n     }\n \n   gcc_assert (code != VEC_LSHIFT_EXPR && code != VEC_RSHIFT_EXPR);"}, {"sha": "ab9e927549d4c65d42933e4c2880fef898677e68", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -1642,10 +1642,8 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n   optab optab;\n-  tree dummy, q;\n-  enum tree_code dummy_code;\n+  tree q;\n   int dummy_int, prec;\n-  VEC (tree, heap) *dummy_vec;\n   stmt_vec_info def_stmt_vinfo;\n \n   if (!is_gimple_assign (last_stmt))\n@@ -1814,23 +1812,8 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n       || prec > HOST_BITS_PER_WIDE_INT)\n     return NULL;\n \n-  optab = optab_for_tree_code (MULT_HIGHPART_EXPR, vectype, optab_default);\n-  if (optab == NULL\n-      || optab_handler (optab, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n-    {\n-      tree witype = build_nonstandard_integer_type (prec * 2,\n-\t\t\t\t\t\t    TYPE_UNSIGNED (itype));\n-      tree vecwtype = get_vectype_for_scalar_type (witype);\n-\n-      if (vecwtype == NULL_TREE)\n-\treturn NULL;\n-      if (!supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n-\t\t\t\t\t   vecwtype, vectype,\n-\t\t\t\t\t   &dummy, &dummy, &dummy_code,\n-\t\t\t\t\t   &dummy_code, &dummy_int,\n-\t\t\t\t\t   &dummy_vec))\n-\treturn NULL;\n-    }\n+  if (!can_mult_highpart_p (TYPE_MODE (vectype), TYPE_UNSIGNED (itype)))\n+    return NULL;\n \n   STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n "}, {"sha": "9caf1c6728a9e89c730650d82ae2f63291ae139a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 19, "deletions": 152, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f07b86e7d7c80695fb655738b89d893b54fc9a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=00f07b86e7d7c80695fb655738b89d893b54fc9a", "patch": "@@ -3304,18 +3304,17 @@ static bool\n vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\tgimple *vec_stmt, slp_tree slp_node)\n {\n-  tree vec_dest, vec_dest2 = NULL_TREE;\n-  tree vec_dest3 = NULL_TREE, vec_dest4 = NULL_TREE;\n+  tree vec_dest;\n   tree scalar_dest;\n   tree op0, op1 = NULL_TREE, op2 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype, wide_vectype = NULL_TREE;\n+  tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code;\n   enum machine_mode vec_mode;\n   tree new_temp;\n   int op_type;\n-  optab optab, optab2 = NULL;\n+  optab optab;\n   int icode;\n   tree def;\n   gimple def_stmt;\n@@ -3332,8 +3331,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vop0, vop1, vop2;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n-  unsigned char *sel = NULL;\n-  tree decl1 = NULL_TREE, decl2 = NULL_TREE, perm_mask = NULL_TREE;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -3455,87 +3452,26 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       || code == RROTATE_EXPR)\n    return false;\n \n-  optab = optab_for_tree_code (code, vectype, optab_default);\n-\n   /* Supportable by target?  */\n-  if (!optab && code != MULT_HIGHPART_EXPR)\n+\n+  vec_mode = TYPE_MODE (vectype);\n+  if (code == MULT_HIGHPART_EXPR)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no optab.\");\n-      return false;\n+      if (can_mult_highpart_p (vec_mode, TYPE_UNSIGNED (vectype)))\n+\ticode = 0;\n+      else\n+\ticode = CODE_FOR_nothing;\n     }\n-  vec_mode = TYPE_MODE (vectype);\n-  icode = optab ? (int) optab_handler (optab, vec_mode) : CODE_FOR_nothing;\n-\n-  if (icode == CODE_FOR_nothing\n-      && code == MULT_HIGHPART_EXPR\n-      && VECTOR_MODE_P (vec_mode)\n-      && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN)\n-    {\n-      /* If MULT_HIGHPART_EXPR isn't supported by the backend, see\n-\t if we can emit VEC_WIDEN_MULT_{LO,HI}_EXPR followed by VEC_PERM_EXPR\n-\t or builtin_mul_widen_{even,odd} followed by VEC_PERM_EXPR.  */\n-      unsigned int prec = TYPE_PRECISION (TREE_TYPE (scalar_dest));\n-      unsigned int unsignedp = TYPE_UNSIGNED (TREE_TYPE (scalar_dest));\n-      tree wide_type\n-\t= build_nonstandard_integer_type (prec * 2, unsignedp);\n-      wide_vectype\n-        = get_same_sized_vectype (wide_type, vectype);\n-\n-      sel = XALLOCAVEC (unsigned char, nunits_in);\n-      if (VECTOR_MODE_P (TYPE_MODE (wide_vectype))\n-\t  && GET_MODE_SIZE (TYPE_MODE (wide_vectype))\n-\t     == GET_MODE_SIZE (vec_mode))\n-\t{\n-\t  if (targetm.vectorize.builtin_mul_widen_even\n-\t      && (decl1 = targetm.vectorize.builtin_mul_widen_even (vectype))\n-\t      && targetm.vectorize.builtin_mul_widen_odd\n-\t      && (decl2 = targetm.vectorize.builtin_mul_widen_odd (vectype))\n-\t      && TYPE_MODE (TREE_TYPE (TREE_TYPE (decl1)))\n-\t\t == TYPE_MODE (wide_vectype))\n-\t    {\n-\t      for (i = 0; i < nunits_in; i++)\n-\t\tsel[i] = !BYTES_BIG_ENDIAN + (i & ~1)\n-\t\t\t + ((i & 1) ? nunits_in : 0);\n-\t      if (can_vec_perm_p (vec_mode, false, sel))\n-\t\ticode = 0;\n-\t    }\n-\t  if (icode == CODE_FOR_nothing)\n-\t    {\n-\t      decl1 = NULL_TREE;\n-\t      decl2 = NULL_TREE;\n-\t      optab = optab_for_tree_code (VEC_WIDEN_MULT_LO_EXPR,\n-\t\t\t\t\t   vectype, optab_default);\n-\t      optab2 = optab_for_tree_code (VEC_WIDEN_MULT_HI_EXPR,\n-\t\t\t\t\t    vectype, optab_default);\n-\t      if (optab != NULL\n-\t\t  && optab2 != NULL\n-\t\t  && optab_handler (optab, vec_mode) != CODE_FOR_nothing\n-\t\t  && optab_handler (optab2, vec_mode) != CODE_FOR_nothing\n-\t\t  && insn_data[optab_handler (optab, vec_mode)].operand[0].mode\n-\t\t     == TYPE_MODE (wide_vectype)\n-\t\t  && insn_data[optab_handler (optab2,\n-\t\t\t\t\t      vec_mode)].operand[0].mode\n-\t\t     == TYPE_MODE (wide_vectype))\n-\t\t{\n-\t\t  for (i = 0; i < nunits_in; i++)\n-\t\t    sel[i] = !BYTES_BIG_ENDIAN + 2 * i;\n-\t\t  if (can_vec_perm_p (vec_mode, false, sel))\n-\t\t    icode = optab_handler (optab, vec_mode);\n-\t\t}\n-\t    }\n-\t}\n-      if (icode == CODE_FOR_nothing)\n+  else\n+    {\n+      optab = optab_for_tree_code (code, vectype, optab_default);\n+      if (!optab)\n \t{\n-\t  if (optab_for_tree_code (code, vectype, optab_default) == NULL)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"no optab.\");\n-\t      return false;\n-\t    }\n-\t  wide_vectype = NULL_TREE;\n-\t  optab2 = NULL;\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"no optab.\");\n+\t  return false;\n \t}\n+      icode = (int) optab_handler (optab, vec_mode);\n     }\n \n   if (icode == CODE_FOR_nothing)\n@@ -3575,16 +3511,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     fprintf (vect_dump, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n-  if (wide_vectype)\n-    {\n-      vec_dest = vect_create_destination_var (scalar_dest, wide_vectype);\n-      vec_dest2 = vect_create_destination_var (scalar_dest, wide_vectype);\n-      vec_dest3 = vect_create_destination_var (scalar_dest, vectype);\n-      vec_dest4 = vect_create_destination_var (scalar_dest, vectype);\n-      perm_mask = vect_gen_perm_mask (vectype, sel);\n-    }\n-  else\n-    vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n      created in the previous stages of the recursion, so no allocation is\n@@ -3693,66 +3620,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  ? VEC_index (tree, vec_oprnds1, i) : NULL_TREE);\n \t  vop2 = ((op_type == ternary_op)\n \t\t  ? VEC_index (tree, vec_oprnds2, i) : NULL_TREE);\n-\t  if (wide_vectype)\n-\t    {\n-\t      tree new_temp2, vce;\n-\n-\t      gcc_assert (code == MULT_HIGHPART_EXPR);\n-\t      if (decl1 != NULL_TREE)\n-\t\t{\n-\t\t  new_stmt = gimple_build_call (decl1, 2, vop0, vop1);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t\t  new_stmt = gimple_build_call (decl2, 2, vop0, vop1);\n-\t\t  new_temp2 = make_ssa_name (vec_dest2, new_stmt);\n-\t\t  gimple_call_set_lhs (new_stmt, new_temp2);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  new_temp = make_ssa_name (vec_dest, NULL);\n-\t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops (BYTES_BIG_ENDIAN\n-\t\t\t\t\t\t    ? VEC_WIDEN_MULT_HI_EXPR\n-\t\t\t\t\t\t    : VEC_WIDEN_MULT_LO_EXPR,\n-\t\t\t\t\t\t    new_temp, vop0, vop1);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t\t  new_temp2 = make_ssa_name (vec_dest2, NULL);\n-\t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops (BYTES_BIG_ENDIAN\n-\t\t\t\t\t\t    ? VEC_WIDEN_MULT_LO_EXPR\n-\t\t\t\t\t\t    : VEC_WIDEN_MULT_HI_EXPR,\n-\t\t\t\t\t\t    new_temp2, vop0, vop1);\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t}\n-\n-\t      vce = build1 (VIEW_CONVERT_EXPR, vectype, new_temp);\n-\t      new_stmt = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t       vec_dest3, vce,\n-\t\t\t\t\t\t       NULL_TREE);\n-\t      new_temp = make_ssa_name (vec_dest3, new_stmt);\n-\t      gimple_assign_set_lhs (new_stmt, new_temp);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t      vce = build1 (VIEW_CONVERT_EXPR, vectype, new_temp2);\n-\t      new_stmt = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t       vec_dest4, vce,\n-\t\t\t\t\t\t       NULL_TREE);\n-\t      new_temp2 = make_ssa_name (vec_dest4, new_stmt);\n-\t      gimple_assign_set_lhs (new_stmt, new_temp2);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t      new_temp = permute_vec_elements (new_temp, new_temp2,\n-\t\t\t\t\t       perm_mask, stmt, gsi);\n-\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n-\t      if (slp_node)\n-\t\tVEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node),\n-\t\t\t\tnew_stmt);\n-\t      continue;\n-\t    }\n \t  new_stmt = gimple_build_assign_with_ops3 (code, vec_dest,\n \t\t\t\t\t\t    vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);"}]}