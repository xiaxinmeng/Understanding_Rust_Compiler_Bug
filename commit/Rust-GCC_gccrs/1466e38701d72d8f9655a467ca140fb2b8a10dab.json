{"sha": "1466e38701d72d8f9655a467ca140fb2b8a10dab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ2NmUzODcwMWQ3MmQ4Zjk2NTVhNDY3Y2ExNDBmYjJiOGExMGRhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-01T18:13:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-01T18:13:31Z"}, "message": "re PR rtl-optimization/15289 (reload error with non-lowpart subregs)\n\n        PR rtl-opt/15289\n        * emit-rtl.c (gen_complex_constant_part): Remove.\n        (gen_realpart, gen_imagpart): Remove.\n        * rtl.h (gen_realpart, gen_imagpart): Remove.\n        * expmed.c (extract_bit_field): Remove CONCAT hack catering to\n        gen_realpart/gen_imagpart.\n        * expr.c (write_complex_part, read_complex_part): New.\n        (emit_move_via_alt_mode, emit_move_via_integer, emit_move_resolve_push,\n        emit_move_complex_push, emit_move_complex, emit_move_ccmode,\n        emit_move_multi_word): Split out from ...\n        (emit_move_insn_1): ... here.\n        (expand_expr_real_1) <COMPLEX_EXPR>: Use write_complex_part.\n        <REALPART_EXPR, IMAGPART_EXPR>: Use read_complex_part.\n        * function.c (assign_parm_setup_reg): Hard-code transformations\n        instead of using gen_realpart/gen_imagpart.\n\nFrom-SVN: r91571", "tree": {"sha": "0f615db96d2762fa43d9e464d0d9e93fff7ad6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f615db96d2762fa43d9e464d0d9e93fff7ad6a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1466e38701d72d8f9655a467ca140fb2b8a10dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1466e38701d72d8f9655a467ca140fb2b8a10dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1466e38701d72d8f9655a467ca140fb2b8a10dab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1466e38701d72d8f9655a467ca140fb2b8a10dab/comments", "author": null, "committer": null, "parents": [{"sha": "8c1cfd5aa4a3eb878b7591a688c79dd939684813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1cfd5aa4a3eb878b7591a688c79dd939684813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1cfd5aa4a3eb878b7591a688c79dd939684813"}], "stats": {"total": 884, "additions": 422, "deletions": 462}, "files": [{"sha": "7a2aa56a0e4c99571e7d975b6669fc9422550c93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -1,5 +1,21 @@\n 2004-12-01  Richard Henderson  <rth@redhat.com>\n \n+\tPR rtl-opt/15289\n+\t* emit-rtl.c (gen_complex_constant_part): Remove.\n+\t(gen_realpart, gen_imagpart): Remove.\n+\t* rtl.h (gen_realpart, gen_imagpart): Remove.\n+\t* expmed.c (extract_bit_field): Remove CONCAT hack catering to\n+\tgen_realpart/gen_imagpart.\n+\t* expr.c (write_complex_part, read_complex_part): New.\n+\t(emit_move_via_alt_mode, emit_move_via_integer, emit_move_resolve_push,\n+\temit_move_complex_push, emit_move_complex, emit_move_ccmode, \n+\temit_move_multi_word): Split out from ...\n+\t(emit_move_insn_1): ... here.\n+\t(expand_expr_real_1) <COMPLEX_EXPR>: Use write_complex_part.\n+\t<REALPART_EXPR, IMAGPART_EXPR>: Use read_complex_part.\n+\t* function.c (assign_parm_setup_reg): Hard-code transformations\n+\tinstead of using gen_realpart/gen_imagpart.\n+\n \t* expr.c (optimize_bitfield_assignment_op): Split out from ... \n \t(expand_assignment): ... here.  Use handled_component_p to gate\n \tget_inner_reference code.  Simplify MEM handling.  Special case"}, {"sha": "d722f90ad697ffbf8ba0560d4a1b3aed52edf0be", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -184,7 +184,6 @@ static int reg_attrs_htab_eq (const void *, const void *);\n static reg_attrs *get_reg_attrs (tree, int);\n static tree component_ref_for_mem_expr (tree);\n static rtx gen_const_vector (enum machine_mode, int);\n-static rtx gen_complex_constant_part (enum machine_mode, rtx, int);\n static void copy_rtx_if_shared_1 (rtx *orig);\n \n /* Probability of the conditional branch currently proceeded by try_split.\n@@ -1169,81 +1168,6 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n   return 0;\n }\n \f\n-/* Return the constant real or imaginary part (which has mode MODE)\n-   of a complex value X.  The IMAGPART_P argument determines whether\n-   the real or complex component should be returned.  This function\n-   returns NULL_RTX if the component isn't a constant.  */\n-\n-static rtx\n-gen_complex_constant_part (enum machine_mode mode, rtx x, int imagpart_p)\n-{\n-  tree decl, part;\n-\n-  if (MEM_P (x)\n-      && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n-    {\n-      decl = SYMBOL_REF_DECL (XEXP (x, 0));\n-      if (decl != NULL_TREE && TREE_CODE (decl) == COMPLEX_CST)\n-\t{\n-\t  part = imagpart_p ? TREE_IMAGPART (decl) : TREE_REALPART (decl);\n-\t  if (TREE_CODE (part) == REAL_CST\n-\t      || TREE_CODE (part) == INTEGER_CST)\n-\t    return expand_expr (part, NULL_RTX, mode, 0);\n-\t}\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Return the real part (which has mode MODE) of a complex value X.\n-   This always comes at the low address in memory.  */\n-\n-rtx\n-gen_realpart (enum machine_mode mode, rtx x)\n-{\n-  rtx part;\n-\n-  /* Handle complex constants.  */\n-  part = gen_complex_constant_part (mode, x, 0);\n-  if (part != NULL_RTX)\n-    return part;\n-\n-  if (WORDS_BIG_ENDIAN\n-      && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n-      && REG_P (x)\n-      && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    internal_error\n-      (\"can't access real part of complex value in hard register\");\n-  else if (WORDS_BIG_ENDIAN)\n-    return gen_highpart (mode, x);\n-  else\n-    return gen_lowpart (mode, x);\n-}\n-\n-/* Return the imaginary part (which has mode MODE) of a complex value X.\n-   This always comes at the high address in memory.  */\n-\n-rtx\n-gen_imagpart (enum machine_mode mode, rtx x)\n-{\n-  rtx part;\n-\n-  /* Handle complex constants.  */\n-  part = gen_complex_constant_part (mode, x, 1);\n-  if (part != NULL_RTX)\n-    return part;\n-\n-  if (WORDS_BIG_ENDIAN)\n-    return gen_lowpart (mode, x);\n-  else if (! WORDS_BIG_ENDIAN\n-\t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n-\t   && REG_P (x)\n-\t   && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    internal_error\n-      (\"can't access imaginary part of complex value in hard register\");\n-  else\n-    return gen_highpart (mode, x);\n-}\n-\f\n rtx\n gen_highpart (enum machine_mode mode, rtx x)\n {"}, {"sha": "c6c8058cc9ea755e7a9596cc10c4ad8cd46b753c", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -1611,28 +1611,6 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     return spec_target;\n   if (GET_MODE (target) != tmode && GET_MODE (target) != mode)\n     {\n-      /* If the target mode is complex, then extract the two scalar elements\n-\t from the value now.  Creating (subreg:SC (reg:DI) 0), as we would do\n-\t with the clause below, will cause gen_realpart or gen_imagpart to\n-\t fail, since those functions must return lvalues.  */\n-      if (COMPLEX_MODE_P (tmode))\n-\t{\n-\t  rtx realpart, imagpart;\n-\t  enum machine_mode itmode = GET_MODE_INNER (tmode);\n-\n-\t  target = convert_to_mode (mode_for_size (GET_MODE_BITSIZE (tmode),\n-\t\t\t\t\t\t   MODE_INT, 0),\n-\t\t\t\t    target, unsignedp);\n-\n-\t  realpart = extract_bit_field (target, GET_MODE_BITSIZE (itmode), 0,\n-\t\t\t\t\tunsignedp, NULL, itmode, itmode);\n-\t  imagpart = extract_bit_field (target, GET_MODE_BITSIZE (itmode),\n-\t\t\t\t\tGET_MODE_BITSIZE (itmode), unsignedp,\n-\t\t\t\t\tNULL, itmode, itmode);\n-\n-\t  return gen_rtx_CONCAT (tmode, realpart, imagpart);\n-\t}\n-\n       /* If the target mode is not a scalar integral, first convert to the\n \t integer mode of that size and then access it as a floating-point\n \t value via a SUBREG.  */"}, {"sha": "f02da24cd612516c02f9c0fbe560d9136a86ba08", "filename": "gcc/expr.c", "status": "modified", "additions": 401, "deletions": 358, "changes": 759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -2574,404 +2574,467 @@ clear_storage_libcall_fn (int for_call)\n   return block_clear_fn;\n }\n \f\n-/* Generate code to copy Y into X.\n-   Both Y and X must have the same mode, except that\n-   Y can be a constant with VOIDmode.\n-   This mode cannot be BLKmode; use emit_block_move for that.\n+/* Write to one of the components of the complex value CPLX.  Write VAL to\n+   the real part if IMAG_P is false, and the imaginary part if its true.  */\n \n-   Return the last instruction emitted.  */\n+static void\n+write_complex_part (rtx cplx, rtx val, bool imag_p)\n+{\n+  if (GET_CODE (cplx) == CONCAT)\n+    emit_move_insn (XEXP (cplx, imag_p), val);\n+  else\n+    {\n+      enum machine_mode cmode = GET_MODE (cplx);\n+      enum machine_mode imode = GET_MODE_INNER (cmode);\n+      unsigned ibitsize = GET_MODE_BITSIZE (imode);\n \n-rtx\n-emit_move_insn (rtx x, rtx y)\n+      store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, imode, val);\n+    }\n+}\n+\n+/* Extract one of the components of the complex value CPLX.  Extract the\n+   real part if IMAG_P is false, and the imaginary part if it's true.  */\n+\n+static rtx\n+read_complex_part (rtx cplx, bool imag_p)\n {\n-  enum machine_mode mode = GET_MODE (x);\n-  rtx y_cst = NULL_RTX;\n-  rtx last_insn, set;\n+  enum machine_mode cmode, imode;\n+  unsigned ibitsize;\n \n-  gcc_assert (mode != BLKmode\n-\t      && (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode));\n+  if (GET_CODE (cplx) == CONCAT)\n+    return XEXP (cplx, imag_p);\n \n-  if (CONSTANT_P (y))\n+  cmode = GET_MODE (cplx);\n+  imode = GET_MODE_INNER (cmode);\n+  ibitsize = GET_MODE_BITSIZE (imode);\n+\n+  /* Special case reads from complex constants that got spilled to memory.  */\n+  if (MEM_P (cplx) && GET_CODE (XEXP (cplx, 0)) == SYMBOL_REF)\n     {\n-      if (optimize\n-\t  && SCALAR_FLOAT_MODE_P (GET_MODE (x))\n-\t  && (last_insn = compress_float_constant (x, y)))\n-\treturn last_insn;\n+      tree decl = SYMBOL_REF_DECL (XEXP (cplx, 0));\n+      if (decl && TREE_CODE (decl) == COMPLEX_CST)\n+\t{\n+\t  tree part = imag_p ? TREE_IMAGPART (decl) : TREE_REALPART (decl);\n+\t  if (CONSTANT_CLASS_P (part))\n+\t    return expand_expr (part, NULL_RTX, imode, EXPAND_NORMAL);\n+\t}\n+    }\n \n-      y_cst = y;\n+  return extract_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0,\n+\t\t\t    true, NULL_RTX, imode, imode);\n+}\n+\f\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n+   ALT_MODE instead of the operand's natural mode, MODE.  CODE is the insn\n+   code for the move in ALT_MODE, and is known to be valid.  Returns the\n+   instruction emitted.  */\n \n-      if (!LEGITIMATE_CONSTANT_P (y))\n+static rtx\n+emit_move_via_alt_mode (enum machine_mode alt_mode, enum machine_mode mode,\n+\t\t\tenum insn_code code, rtx x, rtx y)\n+{\n+  /* Get X and Y in ALT_MODE.  We can't use gen_lowpart here because it\n+     may call change_address which is not appropriate if we were\n+     called when a reload was in progress.  We don't have to worry\n+     about changing the address since the size in bytes is supposed to\n+     be the same.  Copy the MEM to change the mode and move any\n+     substitutions from the old MEM to the new one.  */\n+\n+  if (reload_in_progress)\n+    {\n+      rtx x1 = x, y1 = y;\n+\n+      x = gen_lowpart_common (alt_mode, x1);\n+      if (x == 0 && MEM_P (x1))\n \t{\n-\t  y = force_const_mem (mode, y);\n+\t  x = adjust_address_nv (x1, alt_mode, 0);\n+\t  copy_replacements (x1, x);\n+\t}\n \n-\t  /* If the target's cannot_force_const_mem prevented the spill,\n-\t     assume that the target's move expanders will also take care\n-\t     of the non-legitimate constant.  */\n-\t  if (!y)\n-\t    y = y_cst;\n+      y = gen_lowpart_common (alt_mode, y1);\n+      if (y == 0 && MEM_P (y1))\n+\t{\n+\t  y = adjust_address_nv (y1, alt_mode, 0);\n+\t  copy_replacements (y1, y);\n \t}\n     }\n+  else\n+    {\n+      x = simplify_gen_subreg (alt_mode, x, mode, 0);\n+      y = simplify_gen_subreg (alt_mode, y, mode, 0);\n+    }\n \n-  /* If X or Y are memory references, verify that their addresses are valid\n-     for the machine.  */\n-  if (MEM_P (x)\n-      && ((! memory_address_p (GET_MODE (x), XEXP (x, 0))\n-\t   && ! push_operand (x, GET_MODE (x)))\n-\t  || (flag_force_addr\n-\t      && CONSTANT_ADDRESS_P (XEXP (x, 0)))))\n-    x = validize_mem (x);\n+  return emit_insn (GEN_FCN (code) (x, y));\n+}\n \n-  if (MEM_P (y)\n-      && (! memory_address_p (GET_MODE (y), XEXP (y, 0))\n-\t  || (flag_force_addr\n-\t      && CONSTANT_ADDRESS_P (XEXP (y, 0)))))\n-    y = validize_mem (y);\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n+   an integer mode of the same size as MODE.  Returns the instruction\n+   emitted, or NULL if such a move could not be generated.  */\n \n-  gcc_assert (mode != BLKmode);\n+static rtx\n+emit_move_via_integer (enum machine_mode mode, rtx x, rtx y)\n+{\n+  enum machine_mode imode;\n+  enum insn_code code;\n \n-  last_insn = emit_move_insn_1 (x, y);\n+  /* There must exist a mode of the exact size we require.  */\n+  imode = int_mode_for_mode (mode);\n+  if (imode == BLKmode)\n+    return NULL_RTX;\n \n-  if (y_cst && REG_P (x)\n-      && (set = single_set (last_insn)) != NULL_RTX\n-      && SET_DEST (set) == x\n-      && ! rtx_equal_p (y_cst, SET_SRC (set)))\n-    set_unique_reg_note (last_insn, REG_EQUAL, y_cst);\n+  /* The target must support moves in this mode.  */\n+  code = mov_optab->handlers[imode].insn_code;\n+  if (code == CODE_FOR_nothing)\n+    return NULL_RTX;\n \n-  return last_insn;\n+  return emit_move_via_alt_mode (imode, mode, code, x, y);\n }\n \n-/* Low level part of emit_move_insn.\n-   Called just like emit_move_insn, but assumes X and Y\n-   are basically valid.  */\n+/* A subroutine of emit_move_insn_1.  X is a push_operand in MODE.\n+   Return an equivalent MEM that does not use an auto-increment.  */\n \n-rtx\n-emit_move_insn_1 (rtx x, rtx y)\n+static rtx\n+emit_move_resolve_push (enum machine_mode mode, rtx x)\n {\n-  enum machine_mode mode = GET_MODE (x);\n-  enum machine_mode submode;\n+  enum rtx_code code = GET_CODE (XEXP (x, 0));\n+  HOST_WIDE_INT adjust;\n+  rtx temp;\n \n-  gcc_assert ((unsigned int) mode < (unsigned int) MAX_MACHINE_MODE);\n+  adjust = GET_MODE_SIZE (mode);\n+#ifdef PUSH_ROUNDING\n+  adjust = PUSH_ROUNDING (adjust);\n+#endif\n+  if (code == PRE_DEC || code == POST_DEC)\n+    adjust = -adjust;\n \n-  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-    return\n-      emit_insn (GEN_FCN (mov_optab->handlers[(int) mode].insn_code) (x, y));\n+  /* Do not use anti_adjust_stack, since we don't want to update\n+     stack_pointer_delta.  */\n+  temp = expand_simple_binop (Pmode, PLUS, stack_pointer_rtx,\n+\t\t\t      GEN_INT (adjust), stack_pointer_rtx,\n+\t\t\t      0, OPTAB_LIB_WIDEN);\n+  if (temp != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, temp);\n \n-  /* Expand complex moves by moving real part and imag part, if possible.  */\n-  else if (COMPLEX_MODE_P (mode)\n-\t   && BLKmode != (submode = GET_MODE_INNER (mode))\n-\t   && (mov_optab->handlers[(int) submode].insn_code\n-\t       != CODE_FOR_nothing))\n+  switch (code)\n     {\n-      unsigned int modesize = GET_MODE_SIZE (mode);\n-      unsigned int submodesize = GET_MODE_SIZE (submode);\n-\n-      /* Don't split destination if it is a stack push.  */\n-      int stack = push_operand (x, mode);\n+    case PRE_INC:\n+    case PRE_DEC:\n+      temp = stack_pointer_rtx;\n+      break;\n+    case POST_INC:\n+      temp = plus_constant (stack_pointer_rtx, -GET_MODE_SIZE (mode));\n+      break;\n+    case POST_DEC:\n+      temp = plus_constant (stack_pointer_rtx, GET_MODE_SIZE (mode));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-#ifdef PUSH_ROUNDING\n-      /* In case we output to the stack, but the size is smaller than the\n-\t machine can push exactly, we need to use move instructions.  */\n-      if (stack && PUSH_ROUNDING (submodesize) != submodesize)\n-\t{\n-\t  rtx temp;\n-\t  HOST_WIDE_INT offset1, offset2;\n+  return replace_equiv_address (x, temp);\n+}\n \n-\t  /* Do not use anti_adjust_stack, since we don't want to update\n-\t     stack_pointer_delta.  */\n-\t  temp = expand_binop (Pmode,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t\t       sub_optab,\n-#else\n-\t\t\t       add_optab,\n-#endif\n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT (PUSH_ROUNDING (modesize)),\n-\t\t\t       stack_pointer_rtx, 0, OPTAB_LIB_WIDEN);\n+/* A subroutine of emit_move_complex.  Generate a move from Y into X.\n+   X is known to satisfy push_operand, and MODE is known to be complex.\n+   Returns the last instruction emitted.  */\n \n-\t  if (temp != stack_pointer_rtx)\n-\t    emit_move_insn (stack_pointer_rtx, temp);\n+static rtx\n+emit_move_complex_push (enum machine_mode mode, rtx x, rtx y)\n+{\n+  enum machine_mode submode = GET_MODE_INNER (mode);\n+  bool imag_first;\n \n-#ifdef STACK_GROWS_DOWNWARD\n-\t  offset1 = 0;\n-\t  offset2 = submodesize;\n-#else\n-\t  offset1 = -PUSH_ROUNDING (modesize);\n-\t  offset2 = -PUSH_ROUNDING (modesize) + submodesize;\n-#endif\n+#ifdef PUSH_ROUNDING\n+  unsigned int submodesize = GET_MODE_SIZE (submode);\n \n-\t  emit_move_insn (change_address (x, submode,\n-\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t        stack_pointer_rtx,\n-\t\t\t\t\t\t\tGEN_INT (offset1))),\n-\t\t\t  gen_realpart (submode, y));\n-\t  emit_move_insn (change_address (x, submode,\n-\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t        stack_pointer_rtx,\n-\t\t\t\t\t\t\tGEN_INT (offset2))),\n-\t\t\t  gen_imagpart (submode, y));\n-\t}\n-      else\n+  /* In case we output to the stack, but the size is smaller than the\n+     machine can push exactly, we need to use move instructions.  */\n+  if (PUSH_ROUNDING (submodesize) != submodesize)\n+    {\n+      x = emit_move_resolve_push (mode, x);\n+      return emit_move_insn (x, y);\n+    }\n #endif\n-      /* If this is a stack, push the highpart first, so it\n-\t will be in the argument order.\n \n-\t In that case, change_address is used only to convert\n-\t the mode, not to change the address.  */\n-      if (stack)\n-\t{\n-\t  /* Note that the real part always precedes the imag part in memory\n-\t     regardless of machine's endianness.  */\n-#ifdef STACK_GROWS_DOWNWARD\n-\t  emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n-\t\t\t  gen_imagpart (submode, y));\n-\t  emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n-\t\t\t  gen_realpart (submode, y));\n-#else\n-\t  emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n-\t\t\t  gen_realpart (submode, y));\n-\t  emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n-\t\t\t  gen_imagpart (submode, y));\n-#endif\n-\t}\n-      else\n-\t{\n-\t  rtx realpart_x, realpart_y;\n-\t  rtx imagpart_x, imagpart_y;\n-\n-\t  /* If this is a complex value with each part being smaller than a\n-\t     word, the usual calling sequence will likely pack the pieces into\n-\t     a single register.  Unfortunately, SUBREG of hard registers only\n-\t     deals in terms of words, so we have a problem converting input\n-\t     arguments to the CONCAT of two registers that is used elsewhere\n-\t     for complex values.  If this is before reload, we can copy it into\n-\t     memory and reload.  FIXME, we should see about using extract and\n-\t     insert on integer registers, but complex short and complex char\n-\t     variables should be rarely used.  */\n-\t  if ((reload_in_progress | reload_completed) == 0\n-\t      && (!validate_subreg (submode, mode, NULL, submodesize)\n-\t\t  || !validate_subreg (submode, mode, NULL, 0)))\n-\t    {\n-\t      if (REG_P (x) || REG_P (y))\n-\t\t{\n-\t\t  rtx mem, cmem;\n-\t\t  enum machine_mode reg_mode\n-\t\t    = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 1);\n+  /* Note that the real part always precedes the imag part in memory\n+     regardless of machine's endianness.  */\n+  switch (GET_CODE (XEXP (x, 0)))\n+    {\n+    case PRE_DEC:\n+    case POST_DEC:\n+      imag_first = true;\n+      break;\n+    case PRE_INC:\n+    case POST_INC:\n+      imag_first = false;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-\t\t  gcc_assert (reg_mode != BLKmode);\n+  emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n+\t\t  read_complex_part (y, imag_first));\n+  return emit_move_insn (gen_rtx_MEM (submode, XEXP (x, 0)),\n+\t\t\t read_complex_part (y, !imag_first));\n+}\n \n-\t\t  mem = assign_stack_temp (reg_mode, modesize, 0);\n-\t\t  cmem = adjust_address (mem, mode, 0);\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n+   MODE is known to be complex.  Returns the last instruction emitted.  */\n \n-\t\t  if (REG_P (x))\n-\t\t    {\n-\t\t      rtx sreg = gen_rtx_SUBREG (reg_mode, x, 0);\n-\t\t      emit_move_insn_1 (cmem, y);\n-\t\t      return emit_move_insn_1 (sreg, mem);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      rtx sreg = gen_rtx_SUBREG (reg_mode, y, 0);\n-\t\t      emit_move_insn_1 (mem, sreg);\n-\t\t      return emit_move_insn_1 (x, cmem);\n-\t\t    }\n-\t\t}\n-\t    }\n+static rtx\n+emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n+{\n+  bool try_int;\n \n-\t  realpart_x = gen_realpart (submode, x);\n-\t  realpart_y = gen_realpart (submode, y);\n-\t  imagpart_x = gen_imagpart (submode, x);\n-\t  imagpart_y = gen_imagpart (submode, y);\n-\n-\t  /* Show the output dies here.  This is necessary for SUBREGs\n-\t     of pseudos since we cannot track their lifetimes correctly;\n-\t     hard regs shouldn't appear here except as return values.\n-\t     We never want to emit such a clobber after reload.  */\n-\t  if (x != y\n-\t      && ! (reload_in_progress || reload_completed)\n-\t      && (GET_CODE (realpart_x) == SUBREG\n-\t\t  || GET_CODE (imagpart_x) == SUBREG))\n-\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n-\n-\t  emit_move_insn (realpart_x, realpart_y);\n-\t  emit_move_insn (imagpart_x, imagpart_y);\n-\t}\n+  /* Need to take special care for pushes, to maintain proper ordering\n+     of the data, and possibly extra padding.  */\n+  if (push_operand (x, mode))\n+    return emit_move_complex_push (mode, x, y);\n \n+  /* For memory to memory moves, optimial behaviour can be had with the\n+     existing block move logic.  */\n+  if (MEM_P (x) && MEM_P (y))\n+    {\n+      emit_block_move (x, y, GEN_INT (GET_MODE_SIZE (mode)),\n+\t\t       BLOCK_OP_NO_LIBCALL);\n       return get_last_insn ();\n     }\n \n-  /* Handle MODE_CC modes:  If we don't have a special move insn for this mode,\n-     find a mode to do it in.  If we have a movcc, use it.  Otherwise,\n-     find the MODE_INT mode of the same width.  */\n-  else if (GET_MODE_CLASS (mode) == MODE_CC\n-\t   && mov_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+  /* See if we can coerce the target into moving both values at once.  */\n+\n+  /* Not possible if the values are inherently not adjacent.  */\n+  if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n+    try_int = false;\n+  /* Is possible if both are registers (or subregs of registers).  */\n+  else if (register_operand (x, mode) && register_operand (y, mode))\n+    try_int = true;\n+  /* If one of the operands is a memory, and alignment constraints\n+     are friendly enough, we may be able to do combined memory operations.\n+     We do not attempt this if Y is a constant because that combination is\n+     usually better with the by-parts thing below.  */\n+  else if ((MEM_P (x) ? !CONSTANT_P (y) : MEM_P (y))\n+\t   && (!STRICT_ALIGNMENT\n+\t       || get_mode_alignment (mode) == BIGGEST_ALIGNMENT))\n+    try_int = true;\n+  else\n+    try_int = false;\n+\n+  if (try_int)\n     {\n-      enum insn_code insn_code;\n-      enum machine_mode tmode = VOIDmode;\n-      rtx x1 = x, y1 = y;\n+      rtx ret = emit_move_via_integer (mode, x, y);\n+      if (ret)\n+\treturn ret;\n+    }\n \n-      if (mode != CCmode\n-\t  && mov_optab->handlers[(int) CCmode].insn_code != CODE_FOR_nothing)\n-\ttmode = CCmode;\n-      else\n-\tfor (tmode = QImode; tmode != VOIDmode;\n-\t     tmode = GET_MODE_WIDER_MODE (tmode))\n-\t  if (GET_MODE_SIZE (tmode) == GET_MODE_SIZE (mode))\n-\t    break;\n+  /* Show the output dies here.  This is necessary for SUBREGs\n+     of pseudos since we cannot track their lifetimes correctly;\n+     hard regs shouldn't appear here except as return values.  */\n+  if (!reload_completed && !reload_in_progress\n+      && REG_P (x) && !reg_overlap_mentioned_p (x, y))\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n \n-      gcc_assert (tmode != VOIDmode);\n+  write_complex_part (x, read_complex_part (y, false), false);\n+  write_complex_part (x, read_complex_part (y, true), true);\n+  return get_last_insn ();\n+}\n \n-      /* Get X and Y in TMODE.  We can't use gen_lowpart here because it\n-\t may call change_address which is not appropriate if we were\n-\t called when a reload was in progress.  We don't have to worry\n-\t about changing the address since the size in bytes is supposed to\n-\t be the same.  Copy the MEM to change the mode and move any\n-\t substitutions from the old MEM to the new one.  */\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n+   MODE is known to be MODE_CC.  Returns the last instruction emitted.  */\n \n-      if (reload_in_progress)\n-\t{\n-\t  x = gen_lowpart_common (tmode, x1);\n-\t  if (x == 0 && MEM_P (x1))\n-\t    {\n-\t      x = adjust_address_nv (x1, tmode, 0);\n-\t      copy_replacements (x1, x);\n-\t    }\n+static rtx\n+emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n+{\n+  rtx ret;\n \n-\t  y = gen_lowpart_common (tmode, y1);\n-\t  if (y == 0 && MEM_P (y1))\n-\t    {\n-\t      y = adjust_address_nv (y1, tmode, 0);\n-\t      copy_replacements (y1, y);\n-\t    }\n-\t}\n-      else\n+  /* Assume all MODE_CC modes are equivalent; if we have movcc, use it.  */\n+  if (mode != CCmode)\n+    {\n+      enum insn_code code = mov_optab->handlers[CCmode].insn_code;\n+      if (code != CODE_FOR_nothing)\n+\treturn emit_move_via_alt_mode (CCmode, mode, code, x, y);\n+    }\n+\n+  /* Otherwise, find the MODE_INT mode of the same width.  */\n+  ret = emit_move_via_integer (mode, x, y);\n+  gcc_assert (ret != NULL);\n+  return ret;\n+}\n+\n+/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n+   MODE is any multi-word or full-word mode that lacks a move_insn\n+   pattern.  Note that you will get better code if you define such\n+   patterns, even if they must turn into multiple assembler instructions.  */\n+\n+static rtx\n+emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n+{\n+  rtx last_insn = 0;\n+  rtx seq, inner;\n+  bool need_clobber;\n+  int i;\n+      \n+  gcc_assert (GET_MODE_SIZE (mode) >= UNITS_PER_WORD);\n+      \n+  /* If X is a push on the stack, do the push now and replace\n+     X with a reference to the stack pointer.  */\n+  if (push_operand (x, mode))\n+    x = emit_move_resolve_push (mode, x);\n+\n+  /* If we are in reload, see if either operand is a MEM whose address\n+     is scheduled for replacement.  */\n+  if (reload_in_progress && MEM_P (x)\n+      && (inner = find_replacement (&XEXP (x, 0))) != XEXP (x, 0))\n+    x = replace_equiv_address_nv (x, inner);\n+  if (reload_in_progress && MEM_P (y)\n+      && (inner = find_replacement (&XEXP (y, 0))) != XEXP (y, 0))\n+    y = replace_equiv_address_nv (y, inner);\n+\n+  start_sequence ();\n+\n+  need_clobber = false;\n+  for (i = 0;\n+       i < (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+       i++)\n+    {\n+      rtx xpart = operand_subword (x, i, 1, mode);\n+      rtx ypart = operand_subword (y, i, 1, mode);\n+\n+      /* If we can't get a part of Y, put Y into memory if it is a\n+\t constant.  Otherwise, force it into a register.  If we still\n+\t can't get a part of Y, abort.  */\n+      if (ypart == 0 && CONSTANT_P (y))\n \t{\n-\t  x = gen_lowpart (tmode, x);\n-\t  y = gen_lowpart (tmode, y);\n+\t  y = force_const_mem (mode, y);\n+\t  ypart = operand_subword (y, i, 1, mode);\n \t}\n+      else if (ypart == 0)\n+\typart = operand_subword_force (y, i, mode);\n+\n+      gcc_assert (xpart && ypart);\n+\n+      need_clobber |= (GET_CODE (xpart) == SUBREG);\n \n-      insn_code = mov_optab->handlers[(int) tmode].insn_code;\n-      return emit_insn (GEN_FCN (insn_code) (x, y));\n+      last_insn = emit_move_insn (xpart, ypart);\n     }\n \n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  /* Show the output dies here.  This is necessary for SUBREGs\n+     of pseudos since we cannot track their lifetimes correctly;\n+     hard regs shouldn't appear here except as return values.\n+     We never want to emit such a clobber after reload.  */\n+  if (x != y\n+      && ! (reload_in_progress || reload_completed)\n+      && need_clobber != 0)\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n+\n+  emit_insn (seq);\n+\n+  return last_insn;\n+}\n+\n+/* Low level part of emit_move_insn.\n+   Called just like emit_move_insn, but assumes X and Y\n+   are basically valid.  */\n+\n+rtx\n+emit_move_insn_1 (rtx x, rtx y)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  enum insn_code code;\n+\n+  gcc_assert ((unsigned int) mode < (unsigned int) MAX_MACHINE_MODE);\n+\n+  code = mov_optab->handlers[mode].insn_code;\n+  if (code != CODE_FOR_nothing)\n+    return emit_insn (GEN_FCN (code) (x, y));\n+\n+  /* Expand complex moves by moving real part and imag part.  */\n+  if (COMPLEX_MODE_P (mode))\n+    return emit_move_complex (mode, x, y);\n+\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n+    return emit_move_ccmode (mode, x, y);\n+\n   /* Try using a move pattern for the corresponding integer mode.  This is\n      only safe when simplify_subreg can convert MODE constants into integer\n      constants.  At present, it can only do this reliably if the value\n      fits within a HOST_WIDE_INT.  */\n-  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t   && (submode = int_mode_for_mode (mode)) != BLKmode\n-\t   && mov_optab->handlers[submode].insn_code != CODE_FOR_nothing)\n-    return emit_insn (GEN_FCN (mov_optab->handlers[submode].insn_code)\n-\t\t      (simplify_gen_subreg (submode, x, mode, 0),\n-\t\t       simplify_gen_subreg (submode, y, mode, 0)));\n-\n-  /* This will handle any multi-word or full-word mode that lacks a move_insn\n-     pattern.  However, you will get better code if you define such patterns,\n-     even if they must turn into multiple assembler instructions.  */\n-  else\n+  if (!CONSTANT_P (y) || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      rtx last_insn = 0;\n-      rtx seq, inner;\n-      int need_clobber;\n-      int i;\n-      \n-      gcc_assert (GET_MODE_SIZE (mode) >= UNITS_PER_WORD);\n-      \n-#ifdef PUSH_ROUNDING\n-\n-      /* If X is a push on the stack, do the push now and replace\n-\t X with a reference to the stack pointer.  */\n-      if (push_operand (x, GET_MODE (x)))\n-\t{\n-\t  rtx temp;\n-\t  enum rtx_code code;\n+      rtx ret = emit_move_via_integer (mode, x, y);\n+      if (ret)\n+\treturn ret;\n+    }\n \n-\t  /* Do not use anti_adjust_stack, since we don't want to update\n-\t     stack_pointer_delta.  */\n-\t  temp = expand_binop (Pmode,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t\t       sub_optab,\n-#else\n-\t\t\t       add_optab,\n-#endif\n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT\n-\t\t\t\t (PUSH_ROUNDING\n-\t\t\t\t  (GET_MODE_SIZE (GET_MODE (x)))),\n-\t\t\t       stack_pointer_rtx, 0, OPTAB_LIB_WIDEN);\n-\n-\t  if (temp != stack_pointer_rtx)\n-\t    emit_move_insn (stack_pointer_rtx, temp);\n-\n-\t  code = GET_CODE (XEXP (x, 0));\n-\n-\t  /* Just hope that small offsets off SP are OK.  */\n-\t  if (code == POST_INC)\n-\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (-((HOST_WIDE_INT)\n-\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (x)))));\n-\t  else if (code == POST_DEC)\n-\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (GET_MODE_SIZE (GET_MODE (x))));\n-\t  else\n-\t    temp = stack_pointer_rtx;\n+  return emit_move_multi_word (mode, x, y);\n+}\n \n-\t  x = change_address (x, VOIDmode, temp);\n-\t}\n-#endif\n+/* Generate code to copy Y into X.\n+   Both Y and X must have the same mode, except that\n+   Y can be a constant with VOIDmode.\n+   This mode cannot be BLKmode; use emit_block_move for that.\n \n-      /* If we are in reload, see if either operand is a MEM whose address\n-\t is scheduled for replacement.  */\n-      if (reload_in_progress && MEM_P (x)\n-\t  && (inner = find_replacement (&XEXP (x, 0))) != XEXP (x, 0))\n-\tx = replace_equiv_address_nv (x, inner);\n-      if (reload_in_progress && MEM_P (y)\n-\t  && (inner = find_replacement (&XEXP (y, 0))) != XEXP (y, 0))\n-\ty = replace_equiv_address_nv (y, inner);\n+   Return the last instruction emitted.  */\n \n-      start_sequence ();\n+rtx\n+emit_move_insn (rtx x, rtx y)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  rtx y_cst = NULL_RTX;\n+  rtx last_insn, set;\n \n-      need_clobber = 0;\n-      for (i = 0;\n-\t   i < (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n-\t   i++)\n-\t{\n-\t  rtx xpart = operand_subword (x, i, 1, mode);\n-\t  rtx ypart = operand_subword (y, i, 1, mode);\n+  gcc_assert (mode != BLKmode\n+\t      && (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode));\n \n-\t  /* If we can't get a part of Y, put Y into memory if it is a\n-\t     constant.  Otherwise, force it into a register.  If we still\n-\t     can't get a part of Y, abort.  */\n-\t  if (ypart == 0 && CONSTANT_P (y))\n-\t    {\n-\t      y = force_const_mem (mode, y);\n-\t      ypart = operand_subword (y, i, 1, mode);\n-\t    }\n-\t  else if (ypart == 0)\n-\t    ypart = operand_subword_force (y, i, mode);\n+  if (CONSTANT_P (y))\n+    {\n+      if (optimize\n+\t  && SCALAR_FLOAT_MODE_P (GET_MODE (x))\n+\t  && (last_insn = compress_float_constant (x, y)))\n+\treturn last_insn;\n \n-\t  gcc_assert (xpart && ypart);\n+      y_cst = y;\n \n-\t  need_clobber |= (GET_CODE (xpart) == SUBREG);\n+      if (!LEGITIMATE_CONSTANT_P (y))\n+\t{\n+\t  y = force_const_mem (mode, y);\n \n-\t  last_insn = emit_move_insn (xpart, ypart);\n+\t  /* If the target's cannot_force_const_mem prevented the spill,\n+\t     assume that the target's move expanders will also take care\n+\t     of the non-legitimate constant.  */\n+\t  if (!y)\n+\t    y = y_cst;\n \t}\n+    }\n \n-      seq = get_insns ();\n-      end_sequence ();\n+  /* If X or Y are memory references, verify that their addresses are valid\n+     for the machine.  */\n+  if (MEM_P (x)\n+      && ((! memory_address_p (GET_MODE (x), XEXP (x, 0))\n+\t   && ! push_operand (x, GET_MODE (x)))\n+\t  || (flag_force_addr\n+\t      && CONSTANT_ADDRESS_P (XEXP (x, 0)))))\n+    x = validize_mem (x);\n \n-      /* Show the output dies here.  This is necessary for SUBREGs\n-\t of pseudos since we cannot track their lifetimes correctly;\n-\t hard regs shouldn't appear here except as return values.\n-\t We never want to emit such a clobber after reload.  */\n-      if (x != y\n-\t  && ! (reload_in_progress || reload_completed)\n-\t  && need_clobber != 0)\n-\temit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n+  if (MEM_P (y)\n+      && (! memory_address_p (GET_MODE (y), XEXP (y, 0))\n+\t  || (flag_force_addr\n+\t      && CONSTANT_ADDRESS_P (XEXP (y, 0)))))\n+    y = validize_mem (y);\n \n-      emit_insn (seq);\n+  gcc_assert (mode != BLKmode);\n \n-      return last_insn;\n-    }\n+  last_insn = emit_move_insn_1 (x, y);\n+\n+  if (y_cst && REG_P (x)\n+      && (set = single_set (last_insn)) != NULL_RTX\n+      && SET_DEST (set) == x\n+      && ! rtx_equal_p (y_cst, SET_SRC (set)))\n+    set_unique_reg_note (last_insn, REG_EQUAL, y_cst);\n+\n+  return last_insn;\n }\n \n /* If Y is representable exactly in a narrower mode, and the target can\n@@ -8083,47 +8146,27 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case ADDR_EXPR:\n       return expand_expr_addr_expr (exp, target, tmode, modifier);\n \n-    /* COMPLEX type for Extended Pascal & Fortran  */\n     case COMPLEX_EXPR:\n-      {\n-\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n-\trtx insns;\n-\n-\t/* Get the rtx code of the operands.  */\n-\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-\top1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n-\n-\tif (! target)\n-\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-\n-\tstart_sequence ();\n-\n-\t/* Move the real (op0) and imaginary (op1) parts to their location.  */\n-\temit_move_insn (gen_realpart (mode, target), op0);\n-\temit_move_insn (gen_imagpart (mode, target), op1);\n+      /* Get the rtx code of the operands.  */\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n \n-\tinsns = get_insns ();\n-\tend_sequence ();\n+      if (!target)\n+\ttarget = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \n-\t/* Complex construction should appear as a single unit.  */\n-\t/* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS,\n-\t   each with a separate pseudo as destination.\n-\t   It's not correct for flow to treat them as a unit.  */\n-\tif (GET_CODE (target) != CONCAT)\n-\t  emit_no_conflict_block (insns, target, op0, op1, NULL_RTX);\n-\telse\n-\t  emit_insn (insns);\n+      /* Move the real (op0) and imaginary (op1) parts to their location.  */\n+      write_complex_part (target, op0, false);\n+      write_complex_part (target, op1, true);\n \n-\treturn target;\n-      }\n+      return target;\n \n     case REALPART_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-      return gen_realpart (mode, op0);\n+      return read_complex_part (op0, false);\n \n     case IMAGPART_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-      return gen_imagpart (mode, op0);\n+      return read_complex_part (op0, true);\n \n     case RESX_EXPR:\n       expand_resx_expr (exp);"}, {"sha": "046a4adda6d4fed71a3a7facc49162fc753a3f22", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -2869,10 +2869,11 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t{\n \t  enum machine_mode submode\n \t    = GET_MODE_INNER (GET_MODE (parmreg));\n-\t  int regnor = REGNO (gen_realpart (submode, parmreg));\n-\t  int regnoi = REGNO (gen_imagpart (submode, parmreg));\n-\t  rtx stackr = gen_realpart (submode, data->stack_parm);\n-\t  rtx stacki = gen_imagpart (submode, data->stack_parm);\n+\t  int regnor = REGNO (XEXP (parmreg, 0));\n+\t  int regnoi = REGNO (XEXP (parmreg, 1));\n+\t  rtx stackr = adjust_address_nv (data->stack_parm, submode, 0);\n+\t  rtx stacki = adjust_address_nv (data->stack_parm, submode,\n+\t\t\t\t\t  GET_MODE_SIZE (submode));\n \n \t  /* Scan backwards for the set of the real and\n \t     imaginary parts.  */"}, {"sha": "364c0a2bafba37b71be2b615205c6ad8a98760a1", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1466e38701d72d8f9655a467ca140fb2b8a10dab/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1466e38701d72d8f9655a467ca140fb2b8a10dab", "patch": "@@ -1383,8 +1383,6 @@ extern rtx gen_lowpart_if_possible (enum machine_mode, rtx);\n /* In emit-rtl.c */\n extern rtx gen_highpart (enum machine_mode, rtx);\n extern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);\n-extern rtx gen_realpart (enum machine_mode, rtx);\n-extern rtx gen_imagpart (enum machine_mode, rtx);\n extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);\n \n /* In emit-rtl.c */"}]}