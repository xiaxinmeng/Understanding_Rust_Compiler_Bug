{"sha": "cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FjOGNlOTVhMWU0YzdiMTBmNTg0N2QzNWIzNjUwZTZmYmE4ZDM4Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1998-10-05T22:03:25Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-10-05T22:03:25Z"}, "message": "unroll.c (loop_iteration_var, [...]): No longer static.\n\n        * unroll.c (loop_iteration_var, loop_initial_value, loop_increment\n        loop_final_value, loop_comparison_code): No longer static.\n        (unroll_loop): Delete loop_start_value update.\n        * loop.h (loop_iteration_var, loop_initial_value, loop_increment,\n        loop_final_value, loop_comparison_code): Extern.\n        (loop_start_value): Delete extern.\n        * loop.c (loop_can_insert_bct, loop_increment, loop_start_value,\n        loop_comparison_value, loop_comparison_code): Delete.\n        (loop_optimize): Remove initialization for deleted variables.\n        (strength_reduce): Delete analyze_loop_iterations call.  Only call\n        insert_bct if flag_branch_count_on_reg set.\n        (analyze_loop_iterations): Delete.\n        (insert_bct): Remove iteration count calculation.  Move checks for\n        viable BCT optimization to here.  Obtain iteration count from\n        loop_iterations and correct for unrolling.  Check for enough\n        iteration to be beneficial.  Comment out runtime iteration count\n        case.\n        (insert_bct): Print iteration count in dump file.  Remove\n        loop_var_mode and use word_mode directly.\n        * rs6000.h (processor_type): Add PROCESSOR_PPC604e.\n        * rs6000.c (rs6000_override_options): Use it.\n        (optimization_options): Enable use of flag_branch_on_count_reg.\n        * rs6000.md (define_function_unit): Describe 604e.\n\nFrom-SVN: r22852", "tree": {"sha": "73ad9f3c2b5d7897f532583b4fa7c64ee081961a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ad9f3c2b5d7897f532583b4fa7c64ee081961a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/comments", "author": null, "committer": null, "parents": [{"sha": "d64db93fbcb807f996f5b7204603c18893a7b0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64db93fbcb807f996f5b7204603c18893a7b0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64db93fbcb807f996f5b7204603c18893a7b0b9"}], "stats": {"total": 810, "additions": 269, "deletions": 541}, "files": [{"sha": "b3a90f2f60812ed3a6acef99cc43cc287bbd1b57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -1,3 +1,30 @@\n+Mon Oct  5 22:43:36 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* unroll.c (loop_iteration_var, loop_initial_value, loop_increment\n+\tloop_final_value, loop_comparison_code): No longer static.\n+\t(unroll_loop): Delete loop_start_value update.\n+\t* loop.h (loop_iteration_var, loop_initial_value, loop_increment,\n+\tloop_final_value, loop_comparison_code): Extern.\n+\t(loop_start_value): Delete extern.\n+\t* loop.c (loop_can_insert_bct, loop_increment, loop_start_value,\n+\tloop_comparison_value, loop_comparison_code): Delete.\n+\t(loop_optimize): Remove initialization for deleted variables.\n+\t(strength_reduce): Delete analyze_loop_iterations call.  Only call\n+\tinsert_bct if flag_branch_count_on_reg set.\n+\t(analyze_loop_iterations): Delete.\n+\t(insert_bct): Remove iteration count calculation.  Move checks for\n+\tviable BCT optimization to here.  Obtain iteration count from\n+\tloop_iterations and correct for unrolling.  Check for enough\n+\titeration to be beneficial.  Comment out runtime iteration count\n+\tcase.\n+\t(insert_bct): Print iteration count in dump file.  Remove\n+\tloop_var_mode and use word_mode directly.\n+\n+\t* rs6000.h (processor_type): Add PROCESSOR_PPC604e.\n+\t* rs6000.c (rs6000_override_options): Use it.\n+\t(optimization_options): Enable use of flag_branch_on_count_reg.\n+\t* rs6000.md (define_function_unit): Describe 604e.\n+\n 1998-10-05 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* loop.c (move_movables): Corrected threshold calculation for"}, {"sha": "b1b36fe423e07a219fbcb6c4e3a9d9ddf6e7ece9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -228,7 +228,7 @@ rs6000_override_options (default_cpu)\n \t {\"604\", PROCESSOR_PPC604,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n-\t {\"604e\", PROCESSOR_PPC604,\n+\t {\"604e\", PROCESSOR_PPC604e,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n \t {\"620\", PROCESSOR_PPC620,\n@@ -353,13 +353,11 @@ optimization_options (level, size)\n      int level;\n      int size ATTRIBUTE_UNUSED;\n {\n-#if 0\n #ifdef HAIFA\n   /* When optimizing, enable use of BCT instruction.  */\n   if (level >= 1)\n       flag_branch_on_count_reg = 1;\n #endif\n-#endif\n }\n \f\n /* Do anything needed at the start of the asm file.  */"}, {"sha": "bbdcebb73b72edb5d4be559bf5561c8b3bc27527", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -389,7 +389,7 @@ extern int target_flags;\n \n #define TARGET_DEFAULT (MASK_POWER | MASK_MULTIPLE | MASK_STRING)\n \n-/* Processor type.  */\n+/* Processor type.  Order must match cpu attribute in MD file.  */\n enum processor_type\n  {PROCESSOR_RIOS1,\n   PROCESSOR_RIOS2,\n@@ -398,6 +398,7 @@ enum processor_type\n   PROCESSOR_PPC601,\n   PROCESSOR_PPC603,\n   PROCESSOR_PPC604,\n+  PROCESSOR_PPC604e,\n   PROCESSOR_PPC620};\n \n extern enum processor_type rs6000_cpu;"}, {"sha": "7b7f989fddf24a5c0aed05bdb6a29b7017ef4c3b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -40,7 +40,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"\n+(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n ; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n@@ -50,12 +50,12 @@\n ; (POWER and 601 use Integer Unit)\n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620\"))\n   2 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"store,fpstore\")\n-       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620\"))\n   1 1)\n \n (define_function_unit \"lsu\" 1 0\n@@ -65,7 +65,7 @@\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   3 1)\n \n (define_function_unit \"iu\" 1 0\n@@ -181,22 +181,27 @@\n        (eq_attr \"cpu\" \"mpccore\"))\n   6 6)\n \n-; PPC604 has two units that perform integer operations\n+; PPC604{,e} has two units that perform integer operations\n ; and one unit for divide/multiply operations (and move\n ; from/to spr).\n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"integer\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   1 1)\n \n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n   4 2)\n \n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"ppc604e\"))\n+  2 1)\n+\n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   20 19)\n \n ; compare is done on integer unit, but feeds insns which\n@@ -213,7 +218,7 @@\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"compare,delayed_compare\")\n-       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n   3 1)\n \n (define_function_unit \"iu2\" 2 0   \n@@ -223,7 +228,7 @@\n \n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"compare,delayed_compare\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   1 1)\n \n ; fp compare uses fp unit\n@@ -250,7 +255,7 @@\n ; fp compare uses fp unit\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n   5 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -265,7 +270,7 @@\n \n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n-       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n   4 1)\n \n ; all jumps/branches are executing on the bpu, in 1 cycle, for all machines.\n@@ -295,7 +300,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n-       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc604,ppc604e,ppc620\"))\n   3 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -316,7 +321,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   3 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -336,7 +341,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"sdiv\")\n-       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc604,ppc604e,ppc620\"))\n   18 18)\n \n (define_function_unit \"fpu\" 1 0\n@@ -346,7 +351,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"ddiv\")\n-       (eq_attr \"cpu\" \"ppc601,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc604,ppc604e,ppc620\"))\n   31 31)\n \n (define_function_unit \"fpu\" 1 0"}, {"sha": "24f1b6d747986193e36bdcda209d972e3453f6db", "filename": "gcc/loop.c", "status": "modified", "additions": 205, "deletions": 504, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -82,26 +82,11 @@ static rtx *loop_number_loop_starts, *loop_number_loop_ends;\n \n int *loop_outer_loop;\n \n-#ifdef HAIFA\n-/* The main output of analyze_loop_iterations is placed here */\n-\n-int *loop_can_insert_bct;\n-\n-/* For each loop, determines whether some of its inner loops has used\n-   count register */\n+#ifdef HAVE_decrement_and_branch_on_count\n+/* Records whether resource in use by inner loop.  */\n \n int *loop_used_count_register;\n-\n-/* loop parameters for arithmetic loops. These loops have a loop variable\n-   which is initialized to loop_start_value, incremented in each iteration\n-   by \"loop_increment\".  At the end of the iteration the loop variable is\n-   compared to the loop_comparison_value (using loop_comparison_code).  */\n-\n-rtx *loop_increment;\n-rtx *loop_comparison_value;\n-rtx *loop_start_value;\n-enum rtx_code *loop_comparison_code;\n-#endif  /* HAIFA */\n+#endif  /* HAVE_decrement_and_branch_on_count */\n \n /* For each loop, keep track of its unrolling factor.\n    Potential values:\n@@ -372,20 +357,13 @@ typedef struct rtx_pair {\n    && INSN_LUID (INSN) >= INSN_LUID (START)\t\\\n    && INSN_LUID (INSN) <= INSN_LUID (END))\n \n-#ifdef HAIFA\n-/* This is extern from unroll.c */\n-extern void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n-\n-/* Two main functions for implementing bct:\n-   first - to be called before loop unrolling, and the second - after */\n #ifdef HAVE_decrement_and_branch_on_count\n-static void analyze_loop_iterations PROTO((rtx, rtx));\n+/* Test whether BCT applicable and safe.  */\n static void insert_bct PROTO((rtx, rtx));\n \n-/* Auxiliary function that inserts the bct pattern into the loop */\n+/* Auxiliary function that inserts the BCT pattern into the loop.  */\n static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n #endif /* HAVE_decrement_and_branch_on_count */\n-#endif  /* HAIFA */\n \n /* Indirect_jump_in_function is computed once per function.  */\n int indirect_jump_in_function = 0;\n@@ -500,25 +478,11 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   loop_unroll_factor = (int *) alloca (max_loop_num *sizeof (int));\n   bzero ((char *) loop_unroll_factor, max_loop_num * sizeof (int));\n \n-#ifdef HAIFA\n+#ifdef HAVE_decrement_and_branch_on_count\n   /* Allocate for BCT optimization */\n-  loop_can_insert_bct = (int *) alloca (max_loop_num * sizeof (int));\n-  bzero ((char *) loop_can_insert_bct, max_loop_num * sizeof (int));\n-\n   loop_used_count_register = (int *) alloca (max_loop_num * sizeof (int));\n   bzero ((char *) loop_used_count_register, max_loop_num * sizeof (int));\n-\n-  loop_increment = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_comparison_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_start_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  bzero ((char *) loop_increment, max_loop_num * sizeof (rtx));\n-  bzero ((char *) loop_comparison_value, max_loop_num * sizeof (rtx));\n-  bzero ((char *) loop_start_value, max_loop_num * sizeof (rtx));\n-\n-  loop_comparison_code \n-    = (enum rtx_code *) alloca (max_loop_num * sizeof (enum rtx_code));\n-  bzero ((char *) loop_comparison_code, max_loop_num * sizeof (enum rtx_code));\n-#endif  /* HAIFA */\n+#endif  /* HAVE_decrement_and_branch_on_count */\n \n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n@@ -2989,10 +2953,10 @@ mark_loop_jump (x, loop_num)\n \n       if (loop_num != -1)\n \t{\n-#ifdef HAIFA\n+#ifdef HAVE_decrement_and_branch_on_count\n \t  LABEL_OUTSIDE_LOOP_P (x) = 1;\n \t  LABEL_NEXTREF (x) = loop_number_exit_labels[loop_num];\n-#endif  /* HAIFA */\n+#endif  /* HAVE_decrement_and_branch_on_count */\n \n \t  loop_number_exit_labels[loop_num] = x;\n \n@@ -4109,16 +4073,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      so that \"decrement and branch until zero\" insn can be used.  */\n   check_dbra_loop (loop_end, insn_count, loop_start);\n \n-#ifdef HAIFA\n-  /* record loop-variables relevant for BCT optimization before unrolling\n-     the loop.  Unrolling may update part of this information, and the\n-     correct data will be used for generating the BCT.  */\n-#ifdef HAVE_decrement_and_branch_on_count\n-  if (HAVE_decrement_and_branch_on_count && bct_p)\n-    analyze_loop_iterations (loop_start, loop_end);\n-#endif\n-#endif  /* HAIFA */\n-\n   /* Create reg_map to hold substitutions for replaceable giv regs.  */\n   reg_map = (rtx *) alloca (max_reg_before_loop * sizeof (rtx));\n   bzero ((char *) reg_map, max_reg_before_loop * sizeof (rtx));\n@@ -4618,13 +4572,12 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   if (unroll_p)\n     unroll_loop (loop_end, insn_count, loop_start, end_insert_before, 1);\n \n-#ifdef HAIFA\n-  /* instrument the loop with bct insn */\n #ifdef HAVE_decrement_and_branch_on_count\n-  if (HAVE_decrement_and_branch_on_count && bct_p)\n+  /* Instrument the loop with BCT insn.  */\n+  if (HAVE_decrement_and_branch_on_count && bct_p\n+      && flag_branch_on_count_reg)\n     insert_bct (loop_start, loop_end);\n-#endif\n-#endif  /* HAIFA */\n+#endif  /* HAVE_decrement_and_branch_on_count */\n \n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n@@ -7985,530 +7938,280 @@ get_condition_for_loop (x)\n \t\t\t XEXP (comparison, 1), XEXP (comparison, 0));\n }\n \n-#ifdef HAIFA\n-/* Analyze a loop in order to instrument it with the use of count register.\n-   loop_start and loop_end are the first and last insns of the loop.\n-   This function works in cooperation with insert_bct ().\n-   loop_can_insert_bct[loop_num] is set according to whether the optimization\n-   is applicable to the loop.  When it is applicable, the following variables\n-   are also set:\n-    loop_start_value[loop_num]\n-    loop_comparison_value[loop_num]\n-    loop_increment[loop_num]\n-    loop_comparison_code[loop_num] */\n-\n #ifdef HAVE_decrement_and_branch_on_count\n+/* Instrument loop for insertion of bct instruction.  We distinguish between\n+   loops with compile-time bounds and those with run-time bounds. \n+   Information from loop_iterations() is used to compute compile-time bounds.\n+   Run-time bounds should use loop preconditioning, but currently ignored.\n+ */\n+\n static void\n-analyze_loop_iterations (loop_start, loop_end)\n-  rtx loop_start, loop_end;\n+insert_bct (loop_start, loop_end)\n+     rtx loop_start, loop_end;\n {\n-  rtx comparison, comparison_value;\n-  rtx iteration_var, initial_value, increment;\n-  enum rtx_code comparison_code;\n-\n-  rtx last_loop_insn;\n-  rtx insn;\n   int i;\n+  unsigned HOST_WIDE_INT n_iterations;\n+  rtx insn;\n \n-  /* loop_variable mode */\n-  enum machine_mode original_mode;\n-\n-  /* find the number of the loop */\n-  int loop_num = uid_loop_num [INSN_UID (loop_start)];\n-\n-  /* we change our mind only when we are sure that loop will be instrumented */\n-  loop_can_insert_bct[loop_num] = 0;\n-\n-  /* is the optimization suppressed.  */\n-  if ( !flag_branch_on_count_reg )\n-    return;\n-\n-  /* make sure that count-reg is not in use */\n-  if (loop_used_count_register[loop_num]){\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"analyze_loop_iterations %d: BCT instrumentation failed: count register already in use\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* make sure that the function has no indirect jumps.  */\n-  if (indirect_jump_in_function){\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-              \"analyze_loop_iterations %d: BCT instrumentation failed: indirect jump in function\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* make sure that the last loop insn is a conditional jump */\n-  last_loop_insn = PREV_INSN (loop_end);\n-  if (GET_CODE (last_loop_insn) != JUMP_INSN || !condjump_p (last_loop_insn)) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-              \"analyze_loop_iterations %d: BCT instrumentation failed: invalid jump at loop end\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* First find the iteration variable.  If the last insn is a conditional\n-     branch, and the insn preceding it tests a register value, make that\n-     register the iteration variable.  */\n-\n-  /* We used to use prev_nonnote_insn here, but that fails because it might\n-     accidentally get the branch for a contained loop if the branch for this\n-     loop was deleted.  We can only trust branches immediately before the\n-     loop_end.  */\n+  int increment_direction, compare_direction;\n \n-  comparison = get_condition_for_loop (last_loop_insn);\n-  /* ??? Get_condition may switch position of induction variable and\n-     invariant register when it canonicalizes the comparison.  */\n+  /* If the loop condition is <= or >=, the number of iteration\n+      is 1 more than the range of the bounds of the loop.  */\n+  int add_iteration = 0;\n \n-  if (comparison == 0) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"analyze_loop_iterations %d: BCT instrumentation failed: comparison not found\\n\",\n-\t      loop_num);\n-    return;\n-  }\n+  enum machine_mode loop_var_mode = word_mode;\n \n-  comparison_code = GET_CODE (comparison);\n-  iteration_var = XEXP (comparison, 0);\n-  comparison_value = XEXP (comparison, 1);\n+  int loop_num = uid_loop_num [INSN_UID (loop_start)];\n \n-  original_mode = GET_MODE (iteration_var);\n-  if (GET_MODE_CLASS (original_mode) != MODE_INT\n-      || GET_MODE_SIZE (original_mode) != UNITS_PER_WORD) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"analyze_loop_iterations %d: BCT Instrumentation failed: loop variable not integer\\n\",\n-\t      loop_num);\n+  /* It's impossible to instrument a competely unrolled loop.  */\n+  if (loop_unroll_factor [loop_num] == -1)\n     return;\n-  }\n-\n-  /* get info about loop bounds and increment */\n-  iteration_info (iteration_var, &initial_value, &increment,\n-\t\t  loop_start, loop_end);\n \n-  /* make sure that all required loop data were found */\n-  if (!(initial_value && increment && comparison_value\n-\t&& invariant_p (comparison_value) && invariant_p (increment)\n-\t&& ! indirect_jump_in_function))\n+  /* Make sure that the count register is not in use.  */\n+  if (loop_used_count_register [loop_num])\n     {\n-      if (loop_dump_stream) {\n+      if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-                \"analyze_loop_iterations %d: BCT instrumentation failed because of wrong loop: \", loop_num);\n-\tif (!(initial_value && increment && comparison_value)) {\n-\t  fprintf (loop_dump_stream, \"\\tbounds not available: \");\n-\t  if ( ! initial_value )\n-\t    fprintf (loop_dump_stream, \"initial \");\n-\t  if ( ! increment )\n-\t    fprintf (loop_dump_stream, \"increment \");\n-\t  if ( ! comparison_value )\n-\t    fprintf (loop_dump_stream, \"comparison \");\n-\t  fprintf (loop_dump_stream, \"\\n\");\n-\t}\n-\tif (!invariant_p (comparison_value) || !invariant_p (increment))\n-\t  fprintf (loop_dump_stream, \"\\tloop bounds not invariant\\n\");\n-      }\n+\t\t \"insert_bct %d: BCT instrumentation failed: count register already in use\\n\",\n+\t\t loop_num);\n       return;\n     }\n \n-  /* make sure that the increment is constant */\n-  if (GET_CODE (increment) != CONST_INT) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-              \"analyze_loop_iterations %d: instrumentation failed: not arithmetic loop\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* make sure that the loop contains neither function call, nor jump on table.\n-     (the count register might be altered by the called function, and might\n-     be used for a branch on table).  */\n-  for (insn = loop_start; insn && insn != loop_end; insn = NEXT_INSN (insn)) {\n-    if (GET_CODE (insn) == CALL_INSN){\n+  /* Make sure that the function has no indirect jumps.  */\n+  if (indirect_jump_in_function)\n+    {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-                \"analyze_loop_iterations %d: BCT instrumentation failed: function call in the loop\\n\",\n-\t\tloop_num);\n+\t\t \"insert_bct %d: BCT instrumentation failed: indirect jump in function\\n\",\n+\t\t loop_num);\n       return;\n     }\n \n-    if (GET_CODE (insn) == JUMP_INSN\n-       && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t   || GET_CODE (PATTERN (insn)) == ADDR_VEC)){\n+  /* Make sure that the last loop insn is a conditional jump.  */\n+  if (GET_CODE (PREV_INSN (loop_end)) != JUMP_INSN\n+      || ! condjump_p (PREV_INSN (loop_end))\n+      || simplejump_p (PREV_INSN (loop_end)))\n+    {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-                \"analyze_loop_iterations %d: BCT instrumentation failed: computed branch in the loop\\n\",\n-\t\tloop_num);\n+\t\t \"insert_bct %d: BCT instrumentation failed: invalid jump at loop end\\n\",\n+\t\t loop_num);\n       return;\n     }\n-  }\n-\n-  /* At this point, we are sure that the loop can be instrumented with BCT.\n-     Some of the loops, however, will not be instrumented - the final decision\n-     is taken by insert_bct () */\n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream,\n-            \"analyze_loop_iterations: loop (luid =%d) can be BCT instrumented.\\n\",\n-\t    loop_num);\n-\n-  /* mark all enclosing loops that they cannot use count register */\n-  /* ???: In fact, since insert_bct may decide not to instrument this loop,\n-     marking here may prevent instrumenting an enclosing loop that could\n-    actually be instrumented.  But since this is rare, it is safer to mark\n-    here in case the order of calling  (analyze/insert)_bct would be changed.  */\n-  for (i=loop_num; i != -1; i = loop_outer_loop[i])\n-    loop_used_count_register[i] = 1;\n-\n-  /* Set data structures which will be used by the instrumentation phase */\n-  loop_start_value[loop_num] = initial_value;\n-  loop_comparison_value[loop_num] = comparison_value;\n-  loop_increment[loop_num] = increment;\n-  loop_comparison_code[loop_num] = comparison_code;\n-  loop_can_insert_bct[loop_num] = 1;\n-}\n-\n-\n-/* instrument loop for insertion of bct instruction.  We distinguish between\n- loops with compile-time bounds, to those with run-time bounds.  The loop\n- behaviour is analized according to the following characteristics/variables:\n- ; Input variables:\n- ;   comparison-value: the value to which the iteration counter is compared.\n- ;   initial-value: iteration-counter initial value.\n- ;   increment: iteration-counter increment.\n- ; Computed variables:\n- ;   increment-direction: the sign of the increment.\n- ;   compare-direction: '1' for GT, GTE, '-1' for LT, LTE, '0' for NE.\n- ;   range-direction: sign (comparison-value - initial-value)\n- We give up on the following cases:\n- ; loop variable overflow.\n- ; run-time loop bounds with comparison code NE.\n- */\n-\n-static void\n-insert_bct (loop_start, loop_end)\n-     rtx loop_start, loop_end;\n-{\n-  rtx initial_value, comparison_value, increment;\n-  enum rtx_code comparison_code;\n-\n-  int increment_direction, compare_direction;\n-  int unsigned_p = 0;\n-\n-  /* if the loop condition is <= or >=, the number of iteration\n-      is 1 more than the range of the bounds of the loop */\n-  int add_iteration = 0;\n-\n-  /* the only machine mode we work with - is the integer of the size that the\n-     machine has */\n-  enum machine_mode loop_var_mode = word_mode;\n-\n-  int loop_num = uid_loop_num [INSN_UID (loop_start)];\n-\n-  /* get loop-variables. No need to check that these are valid - already\n-     checked in analyze_loop_iterations ().  */\n-  comparison_code = loop_comparison_code[loop_num];\n-  initial_value = loop_start_value[loop_num];\n-  comparison_value = loop_comparison_value[loop_num];\n-  increment = loop_increment[loop_num];\n-\n-  /* check analyze_loop_iterations decision for this loop.  */\n-  if (! loop_can_insert_bct[loop_num]){\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"insert_bct: [%d] - was decided not to instrument by analyze_loop_iterations ()\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* It's impossible to instrument a competely unrolled loop.  */\n-  if (loop_unroll_factor [loop_num] == -1)\n-    return;\n-\n-  /* make sure that the last loop insn is a conditional jump .\n-     This check is repeated from analyze_loop_iterations (),\n-     because unrolling might have changed that.  */\n-  if (GET_CODE (PREV_INSN (loop_end)) != JUMP_INSN\n-      || !condjump_p (PREV_INSN (loop_end))) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"insert_bct: not instrumenting BCT because of invalid branch\\n\");\n-    return;\n-  }\n-\n-  /* fix increment in case loop was unrolled.  */\n-  if (loop_unroll_factor [loop_num] > 1)\n-    increment = GEN_INT ( INTVAL (increment) * loop_unroll_factor [loop_num] );\n-\n-  /* determine properties and directions of the loop */\n-  increment_direction = (INTVAL (increment) > 0) ? 1:-1;\n-  switch ( comparison_code ) {\n-  case LEU:\n-    unsigned_p = 1;\n-    /* fallthrough */\n-  case LE:\n-    compare_direction = 1;\n-    add_iteration = 1;\n-    break;\n-  case GEU:\n-    unsigned_p = 1;\n-    /* fallthrough */\n-  case GE:\n-    compare_direction = -1;\n-    add_iteration = 1;\n-    break;\n-  case EQ:\n-    /* in this case we cannot know the number of iterations */\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-              \"insert_bct: %d: loop cannot be instrumented: == in condition\\n\",\n-\t      loop_num);\n-    return;\n-  case LTU:\n-    unsigned_p = 1;\n-    /* fallthrough */\n-  case LT:\n-    compare_direction = 1;\n-    break;\n-  case GTU:\n-    unsigned_p = 1;\n-    /* fallthrough */\n-  case GT:\n-    compare_direction = -1;\n-    break;\n-  case NE:\n-    compare_direction = 0;\n-    break;\n-  default:\n-    abort ();\n-  }\n-\n-\n-  /* make sure that the loop does not end by an overflow */\n-  if (compare_direction != increment_direction) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-              \"insert_bct: %d: loop cannot be instrumented: terminated by overflow\\n\",\n-\t      loop_num);\n-    return;\n-  }\n-\n-  /* try to instrument the loop.  */\n \n-  /* Handle the simpler case, where the bounds are known at compile time.  */\n-  if (GET_CODE (initial_value) == CONST_INT\n-      && GET_CODE (comparison_value) == CONST_INT)\n+  /* Make sure that the loop does not contain a function call\n+     (the count register might be altered by the called function).  */\n+  if (loop_has_call)\n     {\n-      int n_iterations;\n-      int increment_value_abs = INTVAL (increment) * increment_direction;\n-\n-      /* check the relation between compare-val and initial-val */\n-      int difference = INTVAL (comparison_value) - INTVAL (initial_value);\n-      int range_direction = (difference > 0) ? 1 : -1;\n-\n-      /* make sure the loop executes enough iterations to gain from BCT */\n-      if (difference > -3 && difference < 3) {\n-\tif (loop_dump_stream)\n-\t  fprintf (loop_dump_stream,\n-\t\t  \"insert_bct: loop %d not BCT instrumented: too small iteration count.\\n\",\n-\t\t  loop_num);\n-\treturn;\n-      }\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"insert_bct %d: BCT instrumentation failed: function call in loop\\n\",\n+\t\t loop_num);\n+      return;\n+    }\n \n-      /* make sure that the loop executes at least once */\n-      if ((range_direction ==  1 && compare_direction == -1)\n-\t  || (range_direction == -1 && compare_direction ==  1))\n+  /* Make sure that the loop does not jump via a table.\n+     (the count register might be used to perform the branch on table).  */\n+  for (insn = loop_start; insn && insn != loop_end; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t      || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n \t{\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n-\t\t    \"insert_bct: loop %d: does not iterate even once. Not instrumenting.\\n\",\n-\t\t    loop_num);\n+\t\t     \"insert_bct %d: BCT instrumentation failed: computed branch in the loop\\n\",\n+\t\t     loop_num);\n \t  return;\n \t}\n+    }\n \n-      /* make sure that the loop does not end by an overflow (in compile time\n-         bounds we must have an additional check for overflow, because here\n-         we also support the compare code of 'NE'.  */\n-      if (comparison_code == NE\n-\t  && increment_direction != range_direction) {\n-\tif (loop_dump_stream)\n-\t  fprintf (loop_dump_stream,\n-\t\t  \"insert_bct (compile time bounds): %d: loop not instrumented: terminated by overflow\\n\",\n-\t\t  loop_num);\n-\treturn;\n-      }\n+  /* Account for loop unrolling in instrumented iteration count.  */\n+  if (loop_unroll_factor [loop_num] > 1)\n+    n_iterations = loop_n_iterations / loop_unroll_factor [loop_num];\n+  else\n+    n_iterations = loop_n_iterations;\n \n-      /* Determine the number of iterations by:\n-\t ;\n-         ;                  compare-val - initial-val + (increment -1) + additional-iteration\n-         ; num_iterations = -----------------------------------------------------------------\n-         ;                                           increment\n-\t */\n-      difference = (range_direction > 0) ? difference : -difference;\n-#if 0\n-      fprintf (stderr, \"difference is: %d\\n\", difference); /* @*/\n-      fprintf (stderr, \"increment_value_abs is: %d\\n\", increment_value_abs); /* @*/\n-      fprintf (stderr, \"add_iteration is: %d\\n\", add_iteration); /* @*/\n-      fprintf (stderr, \"INTVAL (comparison_value) is: %d\\n\", INTVAL (comparison_value)); /* @*/\n-      fprintf (stderr, \"INTVAL (initial_value) is: %d\\n\", INTVAL (initial_value)); /* @*/\n-#endif\n+  if (n_iterations != 0 && n_iterations < 3)\n+    {\n+      /* Allow an enclosing outer loop to benefit if possible.  */\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"insert_bct %d: Too few iterations to benefit from BCT optimization\\n\",\n+\t\t loop_num);\n+      return;\n+    }\n \n-      if (increment_value_abs == 0) {\n-\tfprintf (stderr, \"insert_bct: error: increment == 0 !!!\\n\");\n-\tabort ();\n-      }\n-      n_iterations = (difference + increment_value_abs - 1 + add_iteration)\n-\t/ increment_value_abs;\n+  /* Try to instrument the loop.  */\n \n-#if 0\n-      fprintf (stderr, \"number of iterations is: %d\\n\", n_iterations); /* @*/\n-#endif\n+  /* Handle the simpler case, where the bounds are known at compile time.  */\n+  if (n_iterations > 0)\n+    {\n+      /* Mark all enclosing loops that they cannot use count register.  */\n+      for (i=loop_num; i != -1; i = loop_outer_loop[i])\n+\tloop_used_count_register[i] = 1;\n       instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));\n-\n-      /* Done with this loop.  */\n       return;\n     }\n \n-  /* Handle the more complex case, that the bounds are NOT known at compile time.  */\n-  /* In this case we generate run_time calculation of the number of iterations */\n+  /* Handle the more complex case, that the bounds are NOT known\n+     at compile time.  In this case we generate run_time calculation\n+     of the number of iterations.  */\n+\n+  if (GET_MODE_CLASS (GET_MODE (loop_iteration_var)) != MODE_INT\n+      || GET_MODE_SIZE (GET_MODE (loop_iteration_var)) != UNITS_PER_WORD)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"insert_bct %d: BCT Instrumentation failed: loop variable not integer\\n\",\n+\t\t loop_num);\n+      return;\n+    }\n \n   /* With runtime bounds, if the compare is of the form '!=' we give up */\n-  if (comparison_code == NE) {\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream,\n-\t      \"insert_bct: fail for loop %d: runtime bounds with != comparison\\n\",\n-\t      loop_num);\n-    return;\n-  }\n+  if (loop_comparison_code == NE)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"insert_bct %d: runtime bounds with != comparison\\n\",\n+\t\t loop_num);\n+      return;\n+    }\n+/* Use common loop preconditioning code instead.  */\n+#if 0\n+  else\n+    {\n+      /* We rely on the existence of run-time guard to ensure that the\n+\t loop executes at least once.  */\n+      rtx sequence;\n+      rtx iterations_num_reg;\n \n-  else {\n-    /* We rely on the existence of run-time guard to ensure that the\n-       loop executes at least once.  */\n-    rtx sequence;\n-    rtx iterations_num_reg;\n+      unsigned HOST_WIDE_INT increment_value_abs\n+\t= INTVAL (increment) * increment_direction;\n \n-    int increment_value_abs = INTVAL (increment) * increment_direction;\n+      /* make sure that the increment is a power of two, otherwise (an\n+\t expensive) divide is needed.  */\n+      if (exact_log2 (increment_value_abs) == -1)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"insert_bct: not instrumenting BCT because the increment is not power of 2\\n\");\n+\t  return;\n+\t}\n \n-    /* make sure that the increment is a power of two, otherwise (an\n-       expensive) divide is needed.  */\n-    if (exact_log2 (increment_value_abs) == -1)\n+      /* compute the number of iterations */\n+      start_sequence ();\n       {\n-\tif (loop_dump_stream)\n-\t  fprintf (loop_dump_stream,\n-\t\t  \"insert_bct: not instrumenting BCT because the increment is not power of 2\\n\");\n-\treturn;\n-      }\n+\trtx temp_reg;\n \n-    /* compute the number of iterations */\n-    start_sequence ();\n-    {\n-      rtx temp_reg;\n-\n-      /* Again, the number of iterations is calculated by:\n-\t ;\n-         ;                  compare-val - initial-val + (increment -1) + additional-iteration\n-         ; num_iterations = -----------------------------------------------------------------\n-         ;                                           increment\n+\t/* Again, the number of iterations is calculated by:\n+\t   ;\n+\t   ;                  compare-val - initial-val + (increment -1) + additional-iteration\n+\t   ; num_iterations = -----------------------------------------------------------------\n+\t   ;                                           increment\n \t */\n-      /* ??? Do we have to call copy_rtx here before passing rtx to\n-\t expand_binop?  */\n-      if (compare_direction > 0) {\n-\t/* <, <= :the loop variable is increasing */\n-\ttemp_reg = expand_binop (loop_var_mode, sub_optab, comparison_value,\n-\t\t\t\t initial_value, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-      }\n-      else {\n-\ttemp_reg = expand_binop (loop_var_mode, sub_optab, initial_value,\n-\t\t\t\t comparison_value, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-      }\n+\t/* ??? Do we have to call copy_rtx here before passing rtx to\n+\t   expand_binop?  */\n+\tif (compare_direction > 0)\n+\t  {\n+\t    /* <, <= :the loop variable is increasing */\n+\t    temp_reg = expand_binop (loop_var_mode, sub_optab,\n+\t\t\t\t     comparison_value, initial_value,\n+\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  }\n+\telse\n+\t  {\n+\t    temp_reg = expand_binop (loop_var_mode, sub_optab,\n+\t\t\t\t     initial_value, comparison_value,\n+\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  }\n \n-      if (increment_value_abs - 1 + add_iteration != 0)\n-\ttemp_reg = expand_binop (loop_var_mode, add_optab, temp_reg,\n-\t\t\t\t GEN_INT (increment_value_abs - 1 + add_iteration),\n-\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\tif (increment_value_abs - 1 + add_iteration != 0)\n+\t  temp_reg = expand_binop (loop_var_mode, add_optab, temp_reg,\n+\t\t\t\t   GEN_INT (increment_value_abs - 1\n+\t\t\t\t\t    + add_iteration),\n+\t\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n-      if (increment_value_abs != 1)\n-\t{\n-\t  /* ??? This will generate an expensive divide instruction for\n-\t     most targets.  The original authors apparently expected this\n-\t     to be a shift, since they test for power-of-2 divisors above,\n-\t     but just naively generating a divide instruction will not give \n-\t     a shift.  It happens to work for the PowerPC target because\n-\t     the rs6000.md file has a divide pattern that emits shifts.\n-\t     It will probably not work for any other target.  */\n-\t  iterations_num_reg = expand_binop (loop_var_mode, sdiv_optab,\n-\t\t\t\t\t     temp_reg,\n-\t\t\t\t\t     GEN_INT (increment_value_abs),\n-\t\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t}\n-      else\n-\titerations_num_reg = temp_reg;\n+\tif (increment_value_abs != 1)\n+\t  {\n+\t    /* ??? This will generate an expensive divide instruction for\n+\t       most targets.  The original authors apparently expected this\n+\t       to be a shift, since they test for power-of-2 divisors above,\n+\t       but just naively generating a divide instruction will not give \n+\t       a shift.  It happens to work for the PowerPC target because\n+\t       the rs6000.md file has a divide pattern that emits shifts.\n+\t       It will probably not work for any other target.  */\n+\t    iterations_num_reg = expand_binop (loop_var_mode, sdiv_optab,\n+\t\t\t\t\t       temp_reg,\n+\t\t\t\t\t       GEN_INT (increment_value_abs),\n+\t\t\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  }\n+\telse\n+\t  iterations_num_reg = temp_reg;\n+      }\n+      sequence = gen_sequence ();\n+      end_sequence ();\n+      emit_insn_before (sequence, loop_start);\n+      instrument_loop_bct (loop_start, loop_end, iterations_num_reg);\n     }\n-    sequence = gen_sequence ();\n-    end_sequence ();\n-    emit_insn_before (sequence, loop_start);\n-    instrument_loop_bct (loop_start, loop_end, iterations_num_reg);\n-  }\n+\n+  return;\n+#endif /* Complex case */\n }\n \n-/* instrument loop by inserting a bct in it. This is done in the following way:\n-   1. A new register is created and assigned the hard register number of the count\n-    register.\n-   2. In the head of the loop the new variable is initialized by the value passed in the\n-    loop_num_iterations parameter.\n+/* Instrument loop by inserting a bct in it as follows:\n+   1. A new counter register is created.\n+   2. In the head of the loop the new variable is initialized to the value\n+   passed in the loop_num_iterations parameter.\n    3. At the end of the loop, comparison of the register with 0 is generated.\n-    The created comparison follows the pattern defined for the\n-    decrement_and_branch_on_count insn, so this insn will be generated in assembly\n-    generation phase.\n-   4. The compare&branch on the old variable is deleted. So, if the loop-variable was\n-    not used elsewhere, it will be eliminated by data-flow analisys.  */\n+   The created comparison follows the pattern defined for the\n+   decrement_and_branch_on_count insn, so this insn will be generated.\n+   4. The branch on the old variable are deleted.  The compare must remain\n+   because it might be used elsewhere.  If the loop-variable or condition\n+   register are used elsewhere, they will be eliminated by flow.  */\n \n static void\n instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n      rtx loop_start, loop_end;\n      rtx loop_num_iterations;\n {\n-  rtx temp_reg1, temp_reg2;\n+  rtx counter_reg;\n   rtx start_label;\n-\n   rtx sequence;\n-  enum machine_mode loop_var_mode = word_mode;\n \n   if (HAVE_decrement_and_branch_on_count)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Loop: Inserting BCT\\n\");\n+\t{\n+\t  fputs (\"instrument_bct: Inserting BCT (\", loop_dump_stream);\n+\t  if (GET_CODE (loop_num_iterations) == CONST_INT)\n+\t    fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n+\t\t     INTVAL (loop_num_iterations));\n+\t  else\n+\t    fputs (\"runtime\", loop_dump_stream);\n+\t  fputs (\" iterations)\", loop_dump_stream);\n+\t}\n \n       /* Discard original jump to continue loop.  Original compare result\n \t may still be live, so it cannot be discarded explicitly.  */\n       delete_insn (PREV_INSN (loop_end));\n \n-      /* insert the label which will delimit the start of the loop */\n+      /* Insert the label which will delimit the start of the loop.  */\n       start_label = gen_label_rtx ();\n       emit_label_after (start_label, loop_start);\n \n-      /* insert initialization of the count register into the loop header */\n+      /* Insert initialization of the count register into the loop header.  */\n       start_sequence ();\n-      temp_reg1 = gen_reg_rtx (loop_var_mode);\n-      emit_insn (gen_move_insn (temp_reg1, loop_num_iterations));\n-\n-      /* this will be count register */\n-      temp_reg2 = gen_rtx_REG (loop_var_mode, COUNT_REGISTER_REGNUM);\n-      /* we have to move the value to the count register from an GPR\n-\t because rtx pointed to by loop_num_iterations could contain\n-\t expression which cannot be moved into count register */\n-      emit_insn (gen_move_insn (temp_reg2, temp_reg1));\n-\n+      counter_reg = gen_reg_rtx (word_mode);\n+      emit_insn (gen_move_insn (counter_reg, loop_num_iterations));\n       sequence = gen_sequence ();\n       end_sequence ();\n       emit_insn_before (sequence, loop_start);\n \n-      /* insert new comparison on the count register instead of the\n+      /* Insert new comparison on the count register instead of the\n \t old one, generating the needed BCT pattern (that will be\n \t later recognized by assembly generation phase).  */\n-      emit_jump_insn_before (gen_decrement_and_branch_on_count (temp_reg2,\n+      emit_jump_insn_before (gen_decrement_and_branch_on_count (counter_reg,\n \t\t\t\t\t\t\t\tstart_label),\n \t\t\t     loop_end);\n       LABEL_NUSES (start_label)++;\n@@ -8517,8 +8220,6 @@ instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n }\n #endif /* HAVE_decrement_and_branch_on_count */\n \n-#endif\t/* HAIFA */\n-\n /* Scan the function and determine whether it has indirect (computed) jumps.\n \n    This is taken mostly from flow.c; similar code exists elsewhere"}, {"sha": "d0ae25f4d45f0bb8c6fab52260694f6be2af916d", "filename": "gcc/loop.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -1,5 +1,5 @@\n /* Loop optimization definitions for GNU C-Compiler\n-   Copyright (C) 1991, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1995, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -184,9 +184,12 @@ void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n \n extern int *loop_unroll_factor;\n-#ifdef HAIFA\n-/* variables for interaction between unroll.c and loop.c, for\n-   the insertion of branch-on-count instruction. */\n-extern rtx *loop_start_value;\n-#endif  /* HAIFA */\n+\n+#ifdef HAVE_decrement_and_branch_on_count\n+extern rtx loop_iteration_var;\n+extern rtx loop_initial_value;\n+extern rtx loop_increment;\n+extern rtx loop_final_value;\n+extern enum rtx_code loop_comparison_code;\n+#endif  /* HAVE_decrement_and_branch_on_count */\n "}, {"sha": "3222e207890a22343b3e50788f4f1724effd8077", "filename": "gcc/unroll.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=cac8ce95a1e4c7b10f5847d35b3650e6fba8d38c", "patch": "@@ -189,11 +189,11 @@ static int *splittable_regs_updates;\n /* Values describing the current loop's iteration variable.  These are set up\n    by loop_iterations, and used by precondition_loop_p.  */\n \n-static rtx loop_iteration_var;\n-static rtx loop_initial_value;\n-static rtx loop_increment;\n-static rtx loop_final_value;\n-static enum rtx_code loop_comparison_code;\n+rtx loop_iteration_var;\n+rtx loop_initial_value;\n+rtx loop_increment;\n+rtx loop_final_value;\n+enum rtx_code loop_comparison_code;\n \n /* Forward declarations.  */\n \n@@ -1127,13 +1127,6 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Set unroll type to MODULO now.  */\n \t  unroll_type = UNROLL_MODULO;\n \t  loop_preconditioned = 1;\n-\n-#ifdef HAIFA\n-\t  /* Fix the initial value for the loop as needed.  */\n-\t  if (loop_n_iterations <= 0)\n-\t    loop_start_value [uid_loop_num [INSN_UID (loop_start)]]\n-\t      = initial_value;\n-#endif\n \t}\n     }\n "}]}