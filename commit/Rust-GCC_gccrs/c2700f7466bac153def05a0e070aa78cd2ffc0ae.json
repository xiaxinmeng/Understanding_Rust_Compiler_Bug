{"sha": "c2700f7466bac153def05a0e070aa78cd2ffc0ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3MDBmNzQ2NmJhYzE1M2RlZjA1YTBlMDcwYWE3OGNkMmZmYzBhZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:23Z"}, "message": "Allow the number of iterations to be smaller than VF\n\nFully-masked loops can be profitable even if the iteration\ncount is smaller than the vectorisation factor.  In this case\nwe're effectively doing a complete unroll followed by SLP.\n\nThe documentation for min-vect-loop-bound says that the\ndefault value was 0, but actually the default and minimum\nwere 1.  We need it to be 0 for this case since the parameter\ncounts a whole number of vector iterations.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (vect_fully_masked): Document.\n\t* params.def (PARAM_MIN_VECT_LOOP_BOUND): Change minimum and\n\tdefault value to 0.\n\t* tree-vect-loop.c (vect_analyze_loop_costing): New function,\n\tsplit out from...\n\t(vect_analyze_loop_2): ...here. Don't check the vectorization\n\tfactor against the number of loop iterations if the loop is\n\tfully-masked.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_fully_masked):\n\tNew proc.\n\t* gcc.dg/vect/slp-3.c: Expect all loops to be vectorized if\n\tvect_fully_masked.\n\t* gcc.target/aarch64/sve/loop_add_4.c: New test.\n\t* gcc.target/aarch64/sve/loop_add_4_run.c: Likewise.\n\t* gcc.target/aarch64/sve/loop_add_5.c: Likewise.\n\t* gcc.target/aarch64/sve/loop_add_5_run.c: Likewise.\n\t* gcc.target/aarch64/sve/miniloop_1.c: Likewise.\n\t* gcc.target/aarch64/sve/miniloop_2.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256629", "tree": {"sha": "50556d047879e76735dd263eb9a0712f9066545e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50556d047879e76735dd263eb9a0712f9066545e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2700f7466bac153def05a0e070aa78cd2ffc0ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2700f7466bac153def05a0e070aa78cd2ffc0ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2700f7466bac153def05a0e070aa78cd2ffc0ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2700f7466bac153def05a0e070aa78cd2ffc0ae/comments", "author": null, "committer": null, "parents": [{"sha": "8277ddf9eeae431d432855e41537df1c3a4fa323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8277ddf9eeae431d432855e41537df1c3a4fa323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8277ddf9eeae431d432855e41537df1c3a4fa323"}], "stats": {"total": 435, "additions": 361, "deletions": 74}, "files": [{"sha": "01fa70bfd37f0934936fc5f02d6ef113b771c635", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -1,3 +1,16 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/sourcebuild.texi (vect_fully_masked): Document.\n+\t* params.def (PARAM_MIN_VECT_LOOP_BOUND): Change minimum and\n+\tdefault value to 0.\n+\t* tree-vect-loop.c (vect_analyze_loop_costing): New function,\n+\tsplit out from...\n+\t(vect_analyze_loop_2): ...here. Don't check the vectorization\n+\tfactor against the number of loop iterations if the loop is\n+\tfully-masked.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "22458db0c41df72e4729a7e90e9aed29606e7c76", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -1414,6 +1414,10 @@ Target supports hardware vectors of @code{long}.\n @item vect_long_long\n Target supports hardware vectors of @code{long long}.\n \n+@item vect_fully_masked\n+Target supports fully-masked (also known as fully-predicated) loops,\n+so that vector loops can handle partial as well as full vectors.\n+\n @item vect_masked_store\n Target supports vector masked stores.\n "}, {"sha": "a0aa5765ff6214e7619910079de012abe9c5f48e", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -139,7 +139,7 @@ DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,\n DEFPARAM (PARAM_MIN_VECT_LOOP_BOUND,\n \t  \"min-vect-loop-bound\",\n \t  \"If -ftree-vectorize is used, the minimal loop bound of a loop to be considered for vectorization.\",\n-\t  1, 1, 0)\n+\t  0, 0, 0)\n \n /* The maximum number of instructions to consider when looking for an\n    instruction to fill a delay slot.  If more than this arbitrary"}, {"sha": "3c83b5d3fffce55b1e4dd706c0db8d99cf1a60d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -1,3 +1,18 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_fully_masked):\n+\tNew proc.\n+\t* gcc.dg/vect/slp-3.c: Expect all loops to be vectorized if\n+\tvect_fully_masked.\n+\t* gcc.target/aarch64/sve/loop_add_4.c: New test.\n+\t* gcc.target/aarch64/sve/loop_add_4_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/loop_add_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/loop_add_5_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/miniloop_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/miniloop_2.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "5e40499ff9637553983c1ba3a054c2ed257e2006", "filename": "gcc/testsuite/gcc.dg/vect/slp-3.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -141,6 +141,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { ! vect_fully_masked } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" { target vect_fully_masked } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { target { ! vect_fully_masked } } } }*/\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\" { target vect_fully_masked } } } */\n   "}, {"sha": "7f02497e8390c3aaff7e41bb51becbcca5437448", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_4.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define LOOP(TYPE, NAME, STEP)\t\t\t\t\t\\\n+  __attribute__((noinline, noclone))\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  test_##TYPE##_##NAME (TYPE *dst, TYPE base, int count)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < count; ++i, base += STEP)\t\t\\\n+      dst[i] += base;\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, TYPE) \\\n+  T (TYPE, m17, -17) \\\n+  T (TYPE, m16, -16) \\\n+  T (TYPE, m15, -15) \\\n+  T (TYPE, m1, -1) \\\n+  T (TYPE, 1, 1) \\\n+  T (TYPE, 15, 15) \\\n+  T (TYPE, 16, 16) \\\n+  T (TYPE, 17, 17)\n+\n+#define TEST_ALL(T) \\\n+  TEST_TYPE (T, int8_t) \\\n+  TEST_TYPE (T, int16_t) \\\n+  TEST_TYPE (T, int32_t) \\\n+  TEST_TYPE (T, int64_t)\n+\n+TEST_ALL (LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, w[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]+/z, \\[x[0-9]+, x[0-9]+\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7]+, \\[x[0-9]+, x[0-9]+\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tincb\\tx[0-9]+\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tdecb\\tz[0-9]+\\.b} } } */\n+/* We don't need to increment the vector IV for steps -16 and 16, since the\n+   increment is always a multiple of 256.  */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, w[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 1\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 1\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tincb\\tx[0-9]+\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tdech\\tz[0-9]+\\.h, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdech\\tz[0-9]+\\.h, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdech\\tz[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tinch\\tz[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tinch\\tz[0-9]+\\.h, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tinch\\tz[0-9]+\\.h, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 10 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, w[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 2\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tincw\\tx[0-9]+\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tdecw\\tz[0-9]+\\.s, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdecw\\tz[0-9]+\\.s, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdecw\\tz[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincw\\tz[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincw\\tz[0-9]+\\.s, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincw\\tz[0-9]+\\.s, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 10 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, x[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 3\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tincd\\tx[0-9]+\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tdecd\\tz[0-9]+\\.d, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdecd\\tz[0-9]+\\.d, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tdecd\\tz[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincd\\tz[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincd\\tz[0-9]+\\.d, all, mul #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tincd\\tz[0-9]+\\.d, all, mul #16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 10 } } */"}, {"sha": "00495a1477fa45902819ab556205d0fd921e3e35", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_4_run.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_4_run.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"loop_add_4.c\"\n+\n+#define N 131\n+#define BASE 41\n+\n+#define TEST_LOOP(TYPE, NAME, STEP)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N];\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * i + i % 5;\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    test_##TYPE##_##NAME (a, BASE, N);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE expected = i * i + i % 5 + BASE + i * STEP;\t\\\n+\tif (a[i] != expected)\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (TEST_LOOP)\n+}"}, {"sha": "cffacc06f3f78e2d9e5afb46e4876741d17c7f6f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_5.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256\" } */\n+\n+#include \"loop_add_4.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #-16\\n} 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #-15\\n} 1 { xfail *-*-* }  } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, #15\\n} 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.b, w[0-9]+, w[0-9]+\\n} 3 { xfail *-*-* }  } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]+/z, \\[x[0-9]+, x[0-9]+\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7]+, \\[x[0-9]+, x[0-9]+\\]} 8 } } */\n+\n+/* The induction vector is invariant for steps of -16 and 16.  */\n+/* { dg-final { scan-assembler-not {\\tsub\\tz[0-9]+\\.b, z[0-9]+\\.b, #} } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, z[0-9]+\\.b, #} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #-16\\n} 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #-15\\n} 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.h, w[0-9]+, w[0-9]+\\n} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 1\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 1\\]} 8 } } */\n+\n+/* The (-)17 * 16 is out of range.  */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.h, z[0-9]+\\.h, #} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, #} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 10 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.s, w[0-9]+, w[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 2\\]} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.s, z[0-9]+\\.s, #} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, #} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #-16\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #-15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, #15\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d, x[0-9]+, x[0-9]+\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 3\\]} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.d, z[0-9]+\\.d, #} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, z[0-9]+\\.d, #} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 8 } } */"}, {"sha": "6285ef5db30ffc5a63282eb38d3ce5fdf730a0d5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_5_run.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_5_run.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256\" { target aarch64_sve256_hw } } */\n+\n+#include \"loop_add_4_run.c\""}, {"sha": "09eb4146816cc51af5829f15b6c287aca086c382", "filename": "gcc/testsuite/gcc.target/aarch64/sve/miniloop_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_1.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+void loop (int * __restrict__ a, int * __restrict__ b, int * __restrict__ c,\n+\t   int * __restrict__ d, int * __restrict__ e, int * __restrict__ f,\n+\t   int * __restrict__ g, int * __restrict__ h)\n+{\n+  int i = 0;\n+  for (i = 0; i < 3; i++)\n+    {\n+      a[i] += i;\n+      b[i] += i;\n+      c[i] += i;\n+      d[i] += i;\n+      e[i] += i;\n+      f[i] += a[i] + 7;\n+      g[i] += b[i] - 3;\n+      h[i] += c[i] + 3;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, } 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, } 8 } } */"}, {"sha": "47ddc5415da9d8a54c84a0f6493f137b299f4381", "filename": "gcc/testsuite/gcc.target/aarch64/sve/miniloop_2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fminiloop_2.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps -msve-vector-bits=256\" } */\n+\n+#include \"miniloop_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, } 8 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, } 8 } } */"}, {"sha": "ea2b8faff884edb21f709a16506b57fe36411565", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -6494,6 +6494,12 @@ proc check_effective_target_vect_natural_alignment { } {\n     return $et_vect_natural_alignment\n }\n \n+# Return true if fully-masked loops are supported.\n+\n+proc check_effective_target_vect_fully_masked { } {\n+    return [check_effective_target_aarch64_sve]\n+}\n+\n # Return 1 if the target doesn't prefer any alignment beyond element\n # alignment during vectorization.\n "}, {"sha": "1666332fa8ae34ed59c38c6dff975ca76fc89489", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 103, "deletions": 71, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2700f7466bac153def05a0e070aa78cd2ffc0ae/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c2700f7466bac153def05a0e070aa78cd2ffc0ae", "patch": "@@ -1896,6 +1896,101 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Analyze the cost of the loop described by LOOP_VINFO.  Decide if it\n+   is worthwhile to vectorize.  Return 1 if definitely yes, 0 if\n+   definitely no, or -1 if it's worth retrying.  */\n+\n+static int\n+vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n+\n+  /* Only fully-masked loops can have iteration counts less than the\n+     vectorization factor.  */\n+  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n+      HOST_WIDE_INT max_niter;\n+\n+      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\tmax_niter = LOOP_VINFO_INT_NITERS (loop_vinfo);\n+      else\n+\tmax_niter = max_stmt_executions_int (loop);\n+\n+      if (max_niter != -1\n+\t  && (unsigned HOST_WIDE_INT) max_niter < assumed_vf)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: iteration count smaller than \"\n+\t\t\t     \"vectorization factor.\\n\");\n+\t  return 0;\n+\t}\n+    }\n+\n+  int min_profitable_iters, min_profitable_estimate;\n+  vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n+\t\t\t\t      &min_profitable_estimate);\n+\n+  if (min_profitable_iters < 0)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vector version will never be \"\n+\t\t\t \"profitable.\\n\");\n+      return -1;\n+    }\n+\n+  int min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t       * assumed_vf);\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+  unsigned int th = (unsigned) MAX (min_scalar_loop_bound,\n+\t\t\t\t    min_profitable_iters);\n+\n+  LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = th;\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) < th)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: iteration count smaller than user \"\n+\t\t\t \"specified loop bound parameter or minimum profitable \"\n+\t\t\t \"iterations (whichever is more conservative).\\n\");\n+      return 0;\n+    }\n+\n+  HOST_WIDE_INT estimated_niter = estimated_stmt_executions_int (loop);\n+  if (estimated_niter == -1)\n+    estimated_niter = likely_max_stmt_executions_int (loop);\n+  if (estimated_niter != -1\n+      && ((unsigned HOST_WIDE_INT) estimated_niter\n+\t  < MAX (th, (unsigned) min_profitable_estimate)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count too \"\n+\t\t\t \"small.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count smaller \"\n+\t\t\t \"than specified loop bound parameter or minimum \"\n+\t\t\t \"profitable iterations (whichever is more \"\n+\t\t\t \"conservative).\\n\");\n+      return -1;\n+    }\n+\n+  return 1;\n+}\n+\n \n /* Function vect_analyze_loop_2.\n \n@@ -1906,6 +2001,7 @@ static bool\n vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n {\n   bool ok;\n+  int res;\n   unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n   poly_uint64 min_vf = 2;\n   unsigned int n_stmts = 0;\n@@ -2063,9 +2159,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   vect_compute_single_scalar_iteration_cost (loop_vinfo);\n \n   poly_uint64 saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  HOST_WIDE_INT estimated_niter;\n   unsigned th;\n-  int min_scalar_loop_bound;\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n   ok = vect_analyze_slp (loop_vinfo, n_stmts);\n@@ -2095,7 +2189,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   /* Now the vectorization factor is final.  */\n   poly_uint64 vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   gcc_assert (known_ne (vectorization_factor, 0U));\n-  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n     {\n@@ -2108,17 +2201,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \n   HOST_WIDE_INT max_niter\n     = likely_max_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n-  if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-       && (LOOP_VINFO_INT_NITERS (loop_vinfo) < assumed_vf))\n-      || (max_niter != -1\n-\t  && (unsigned HOST_WIDE_INT) max_niter < assumed_vf))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: iteration count smaller than \"\n-\t\t\t \"vectorization factor.\\n\");\n-      return false;\n-    }\n \n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n@@ -2232,65 +2314,16 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t}\n     }\n \n-  /* Analyze cost.  Decide if worth while to vectorize.  */\n-  int min_profitable_estimate, min_profitable_iters;\n-  vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n-\t\t\t\t      &min_profitable_estimate);\n-\n-  if (min_profitable_iters < 0)\n+  /* Check the costings of the loop make vectorizing worthwhile.  */\n+  res = vect_analyze_loop_costing (loop_vinfo);\n+  if (res < 0)\n+    goto again;\n+  if (!res)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vector version will never be \"\n-\t\t\t \"profitable.\\n\");\n-      goto again;\n-    }\n-\n-  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t   * assumed_vf);\n-\n-  /* Use the cost model only if it is more conservative than user specified\n-     threshold.  */\n-  th = (unsigned) MAX (min_scalar_loop_bound, min_profitable_iters);\n-\n-  LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = th;\n-\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) < th)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"not vectorized: iteration count smaller than user \"\n-\t\t\t \"specified loop bound parameter or minimum profitable \"\n-\t\t\t \"iterations (whichever is more conservative).\\n\");\n-      goto again;\n-    }\n-\n-  estimated_niter\n-    = estimated_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n-  if (estimated_niter == -1)\n-    estimated_niter = max_niter;\n-  if (estimated_niter != -1\n-      && ((unsigned HOST_WIDE_INT) estimated_niter\n-          < MAX (th, (unsigned) min_profitable_estimate)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: estimated iteration count too \"\n-                         \"small.\\n\");\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"not vectorized: estimated iteration count smaller \"\n-                         \"than specified loop bound parameter or minimum \"\n-                         \"profitable iterations (whichever is more \"\n-                         \"conservative).\\n\");\n-      goto again;\n+\t\t\t \"Loop costings not worthwhile.\\n\");\n+      return false;\n     }\n \n   /* Decide whether we need to create an epilogue loop to handle\n@@ -3881,7 +3914,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t      * assumed_vf\n \t\t\t      - vec_inside_cost * peel_iters_prologue\n \t\t\t      - vec_inside_cost * peel_iters_epilogue);\n-\n       if (min_profitable_iters <= 0)\n         min_profitable_iters = 0;\n       else"}]}