{"sha": "7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2N2Q2OTI0ZThjZTEzY2JiNDAwM2NiNmZlMmE4MzcwMmY4YjBjYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "sidwell@codesourcery.com", "date": "2000-01-28T13:30:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-01-28T13:30:13Z"}, "message": "Compiler side new abi rtti (not enabled).\n\n\t* cp-tree.h (new_abi_rtti_p): New macro.\n\t(emit_support_tinfos): Prototype new function.\n\t(tinfo_decl_p): Likewise.\n\t(emit_tinfo_decl): Likwise.\n\t* rtti.c (TINFO_PSEUDO_TYPE, TINFO_VTABLE_DECL): New accessor\n\tmacros.\n\t(doing_runtime): New local static.\n\t(init_rtti_processing): Add new-abi initializer.\n\t(get_tinfo_decl): Add new-abi logic.\n\t(tinfo_from_decl): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t(qualifier_flags): New static function.\n\t(tinfo_base_init): Likewise.\n\t(generic_initializer): Likewise.\n\t(ptr_ref_initializer): Likewise.\n\t(ptmd_initializer): Likewise.\n\t(class_hint_flags): Likewise.\n\t(class_initializer): Likewise.\n\t(synthesize_tinfo_var): Likewise.\n\t(create_real_tinfo_var): Likewise.\n\t(create_pseudo_type_info): Likewise.\n\t(get_vmi_pseudo_type_info): Likewise.\n\t(create_tinfo_types): Likewise.\n\t(emit_support_tinfos): New global function.\n\t(tinfo_decl_p): New global predicate.\n\t(emit_tinfo_decl): New global function.\n\t* class.c (set_rtti_entry): Generalize for old and new rtti.\n\t(build_vtbl_initializer): Likewise.\n\t* decl2.c (finish_file): Likewise.\n\nFrom-SVN: r31668", "tree": {"sha": "319612614a1a38c46dc5ff15b2d46fd2af2763f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/319612614a1a38c46dc5ff15b2d46fd2af2763f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/comments", "author": null, "committer": null, "parents": [{"sha": "73565a7129b32a8b2e3e463c4e8595b499a75de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73565a7129b32a8b2e3e463c4e8595b499a75de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73565a7129b32a8b2e3e463c4e8595b499a75de5"}], "stats": {"total": 1015, "additions": 932, "deletions": 83}, "files": [{"sha": "a316529bddc66bd53d351ab3e71230a91b32e326", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "patch": "@@ -1,3 +1,36 @@\n+2000-01-28  Nathan Sidwell  <sidwell@codesourcery.com>\n+\n+\tCompiler side new abi rtti (not enabled).\n+\t* cp-tree.h (new_abi_rtti_p): New macro.\n+\t(emit_support_tinfos): Prototype new function.\n+\t(tinfo_decl_p): Likewise.\n+\t(emit_tinfo_decl): Likwise.\n+\t* rtti.c (TINFO_PSEUDO_TYPE, TINFO_VTABLE_DECL): New accessor\n+\tmacros.\n+\t(doing_runtime): New local static.\n+\t(init_rtti_processing): Add new-abi initializer.\n+\t(get_tinfo_decl): Add new-abi logic.\n+\t(tinfo_from_decl): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t(qualifier_flags): New static function.\n+\t(tinfo_base_init): Likewise.\n+\t(generic_initializer): Likewise.\n+\t(ptr_ref_initializer): Likewise.\n+\t(ptmd_initializer): Likewise.\n+\t(class_hint_flags): Likewise.\n+\t(class_initializer): Likewise.\n+\t(synthesize_tinfo_var): Likewise.\n+\t(create_real_tinfo_var): Likewise.\n+\t(create_pseudo_type_info): Likewise.\n+\t(get_vmi_pseudo_type_info): Likewise.\n+\t(create_tinfo_types): Likewise.\n+\t(emit_support_tinfos): New global function.\n+\t(tinfo_decl_p): New global predicate.\n+\t(emit_tinfo_decl): New global function.\n+\t* class.c (set_rtti_entry): Generalize for old and new rtti.\n+\t(build_vtbl_initializer): Likewise.\n+\t* decl2.c (finish_file): Likewise.\n+\n Thu Jan 27 20:53:36 2000  Jim Wilson  <wilson@cygnus.com>\n \n \t* cp/optimize.c (remap_decl): Add walk_tree calls for DECL_SIZE (t)"}, {"sha": "7872845d8c6603a5b13a4f2d15d22142e9c6951c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "patch": "@@ -963,34 +963,37 @@ static void\n set_rtti_entry (virtuals, offset, type)\n      tree virtuals, offset, type;\n {\n-  tree fn;\n+  tree decl;\n \n   if (CLASSTYPE_COM_INTERFACE (type))\n     return;\n \n   if (flag_rtti)\n-    fn = get_tinfo_decl (type);\n-  else\n+    decl = get_tinfo_decl (type);\n+  else if (!new_abi_rtti_p ())\n     /* If someone tries to get RTTI information for a type compiled\n        without RTTI, they're out of luck.  By calling __pure_virtual\n        in this case, we give a small clue as to what went wrong.  We\n        could consider having a __no_typeinfo function as well, for a\n        more specific hint.  */\n-    fn = abort_fndecl;\n+    decl = abort_fndecl;\n+  else\n+    /* For the new-abi, we just point to the type_info object.  */\n+    decl = NULL_TREE;\n \n   if (flag_vtable_thunks)\n     {\n       /* The first slot holds the offset.  */\n       TREE_PURPOSE (virtuals) = offset;\n \n-      /* The next node holds the function.  */\n+      /* The next node holds the decl.  */\n       virtuals = TREE_CHAIN (virtuals);\n       offset = integer_zero_node;\n     }\n \n-  /* This slot holds the function to call.  */\n+  /* This slot holds the decl.  */\n   TREE_PURPOSE (virtuals) = offset;\n-  TREE_VALUE (virtuals) = fn;\n+  TREE_VALUE (virtuals) = decl;\n }\n \n /* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,\n@@ -2615,9 +2618,26 @@ build_vtbl_initializer (binfo, t)\n       init = build_vtable_entry (integer_zero_node, init);\n       inits = tree_cons (NULL_TREE, init, inits);\n \n-      /* Even in this case, the second entry (the tdesc pointer) is\n-\t just an ordinary function.  */\n       v = TREE_CHAIN (v);\n+      \n+      if (new_abi_rtti_p ())\n+        {\n+          tree decl = TREE_VALUE (v);\n+          \n+          if (decl)\n+            decl = build_unary_op (ADDR_EXPR, decl, 0);\n+          else\n+            decl = integer_zero_node;\n+          decl = build1 (NOP_EXPR, vfunc_ptr_type_node, decl);\n+          TREE_CONSTANT (decl) = 1;\n+          decl = build_vtable_entry (integer_zero_node, decl);\n+          inits = tree_cons (NULL_TREE, decl, inits);\n+          \n+          v = TREE_CHAIN (v);\n+        }\n+      /* In the old abi the second entry (the tdesc pointer) is\n+\t just an ordinary function, so it can be dealt with like the\n+\t virtual functions.  */\n     }\n \n   /* Go through all the ordinary virtual functions, building up"}, {"sha": "299414a73253492094c5d3b2cb0f3ae2aab3056f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "patch": "@@ -238,6 +238,11 @@ extern int flag_rtti;\n    class).  */\n #define all_overridden_vfuns_in_vtables_p() (flag_new_abi)\n \n+/* Nonzero if we use access type_info objects directly, and use the\n+   cross-vendor layout for them. Zero if we use an accessor function\n+   to get the type_info object address.  */\n+#define new_abi_rtti_p() (0)\n+\n \f\n /* Language-dependent contents of an identifier.  */\n \n@@ -3988,13 +3993,16 @@ extern void init_repo\t\t\t\tPARAMS ((const char *));\n extern void finish_repo\t\t\t\tPARAMS ((void));\n \n /* in rtti.c */\n-extern void init_rtti_processing\t\tPARAMS ((void));\n-extern tree build_typeid\t\t\tPARAMS ((tree));\n-extern tree get_tinfo_decl                      PARAMS ((tree));\n-extern tree get_typeid\t\t\t\tPARAMS ((tree));\n-extern tree get_typeid_1\t\t\tPARAMS ((tree));\n-extern tree build_dynamic_cast\t\t\tPARAMS ((tree, tree));\n-extern void synthesize_tinfo_fn\t\t\tPARAMS ((tree));\n+extern void init_rtti_processing\t\tPARAMS((void));\n+extern tree build_typeid\t\t\tPARAMS((tree));\n+extern tree get_tinfo_decl                      PARAMS((tree));\n+extern tree get_typeid\t\t\t\tPARAMS((tree));\n+extern tree get_typeid_1\t\t\tPARAMS((tree));\n+extern tree build_dynamic_cast\t\t\tPARAMS((tree, tree));\n+extern void synthesize_tinfo_fn\t\t\tPARAMS((tree));\n+extern void emit_support_tinfos                 PARAMS((void));\n+extern int tinfo_decl_p                         PARAMS((tree, void *));\n+extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n \n /* in search.c */\n extern int types_overlap_p\t\t\tPARAMS ((tree, tree));"}, {"sha": "50a5d31cb4f2683f818003fef71736aa565c0d2f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "patch": "@@ -3434,6 +3434,9 @@ finish_file ()\n   varconst_time += this_time - start_time;\n   start_time = get_run_time ();\n \n+  if (new_abi_rtti_p ())\n+    emit_support_tinfos ();\n+  \n   do \n     {\n       reconsider = 0;\n@@ -3450,6 +3453,12 @@ finish_file ()\n \t\t\t/*data=*/0))\n \treconsider = 1;\n       \n+      /* Write out needed type info variables. Writing out one variable\n+         might cause others to be needed.  */\n+      if (new_abi_rtti_p ()\n+          && walk_globals (tinfo_decl_p, emit_tinfo_decl, /*data=*/0))\n+\treconsider = 1;\n+\n       /* The list of objects with static storage duration is built up\n \t in reverse order.  We clear STATIC_AGGREGATES so that any new\n \t aggregates added during the initialization of these will be"}, {"sha": "11b94ad307fd8ad85d9501d09a8f94827f817040", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 846, "deletions": 67, "changes": 913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=7267d6924e8ce13cbb4003cb6fe2a83702f8b0cc", "patch": "@@ -33,25 +33,48 @@ Boston, MA 02111-1307, USA.  */\n #define INT_TYPE_SIZE BITS_PER_WORD\n #endif\n \n+/* Accessors for the type_info objects. We need to remember several things\n+   about each of the type_info types. The global tree nodes such as\n+   bltn_desc_type_node are TREE_LISTs, and these macros are used to access\n+   the required information. */\n+/* The RECORD_TYPE of a type_info derived class. */\n+#define TINFO_PSEUDO_TYPE(NODE) TREE_TYPE (NODE)\n+/* The VAR_DECL of the vtable for the type_info derived class. */\n+#define TINFO_VTABLE_DECL(NODE) TREE_VALUE (NODE)\n+\n extern struct obstack permanent_obstack;\n \n-static tree build_runtime_decl PARAMS ((const char *, tree));\n-static tree build_headof_sub PARAMS ((tree));\n-static tree build_headof PARAMS ((tree));\n-static tree get_tinfo_var PARAMS ((tree));\n-static tree ifnonnull PARAMS ((tree, tree));\n-static tree tinfo_name PARAMS ((tree));\n-static tree get_base_offset PARAMS ((tree, tree));\n-static tree build_dynamic_cast_1 PARAMS ((tree, tree));\n-static void expand_si_desc PARAMS ((tree, tree));\n-static void expand_class_desc PARAMS ((tree, tree));\n-static void expand_attr_desc PARAMS ((tree, tree));\n-static void expand_ptr_desc PARAMS ((tree, tree));\n-static void expand_generic_desc PARAMS ((tree, tree, const char *));\n-static tree throw_bad_cast PARAMS ((void));\n-static tree throw_bad_typeid PARAMS ((void));\n-static tree get_tinfo_decl_dynamic PARAMS ((tree));\n-static tree tinfo_from_decl PARAMS ((tree));\n+static tree build_runtime_decl PARAMS((const char *, tree));\n+static tree build_headof_sub PARAMS((tree));\n+static tree build_headof PARAMS((tree));\n+static tree get_tinfo_var PARAMS((tree));\n+static tree ifnonnull PARAMS((tree, tree));\n+static tree tinfo_name PARAMS((tree));\n+static tree get_base_offset PARAMS((tree, tree));\n+static tree build_dynamic_cast_1 PARAMS((tree, tree));\n+static void expand_si_desc PARAMS((tree, tree));\n+static void expand_class_desc PARAMS((tree, tree));\n+static void expand_attr_desc PARAMS((tree, tree));\n+static void expand_ptr_desc PARAMS((tree, tree));\n+static void expand_generic_desc PARAMS((tree, tree, const char *));\n+static tree throw_bad_cast PARAMS((void));\n+static tree throw_bad_typeid PARAMS((void));\n+static tree get_tinfo_decl_dynamic PARAMS((tree));\n+static tree tinfo_from_decl PARAMS((tree));\n+static int qualifier_flags PARAMS((tree));\n+static tree tinfo_base_init PARAMS((tree, tree));\n+static tree generic_initializer PARAMS((tree, tree));\n+static tree ptr_ref_initializer PARAMS((tree, tree));\n+static tree ptmd_initializer PARAMS((tree, tree));\n+static int class_hint_flags PARAMS((tree));\n+static tree class_initializer PARAMS((tree, tree, tree));\n+static tree synthesize_tinfo_var PARAMS((tree, tree));\n+static tree create_real_tinfo_var PARAMS((tree, tree, tree));\n+static tree create_pseudo_type_info PARAMS((const char *, int, ...));\n+static tree get_vmi_pseudo_type_info PARAMS((int));\n+static void create_tinfo_types PARAMS((void));\n+\n+static int doing_runtime = 0;\n \f\n void\n init_rtti_processing ()\n@@ -62,13 +85,21 @@ init_rtti_processing ()\n     (class_type_node, get_identifier (\"type_info\"), 1);\n   if (flag_honor_std)\n     pop_namespace ();\n-\n-  tinfo_decl_id = get_identifier (\"__tf\");\n-  tinfo_decl_type = build_function_type\n+  if (!new_abi_rtti_p ())\n+    {\n+      tinfo_decl_id = get_identifier (\"__tf\");\n+      tinfo_decl_type = build_function_type\n         (build_reference_type\n           (build_qualified_type\n             (type_info_type_node, TYPE_QUAL_CONST)),\n          void_list_node);\n+    }\n+  else\n+    {\n+      tinfo_decl_id = get_identifier (\"__ti\");\n+      tinfo_decl_type = build_qualified_type\n+                          (type_info_type_node, TYPE_QUAL_CONST);\n+    }\n   tinfo_var_id = get_identifier (\"__ti\");\n }\n \n@@ -312,6 +343,7 @@ get_tinfo_var (type)\n   tree arrtype;\n   int size;\n \n+  my_friendly_assert (!new_abi_rtti_p (), 20000118);\n   if (IDENTIFIER_GLOBAL_VALUE (tname))\n     return IDENTIFIER_GLOBAL_VALUE (tname);\n     \n@@ -357,8 +389,8 @@ tinfo_name (type)\n }\n \n /* Returns a decl for a function or variable which can be used to obtain a\n-   type_info object for TYPE.  The old-abi uses functions, the new-abi will\n-   use the type_info object directly.  You can take the address of the\n+   type_info object for TYPE.  The old-abi uses functions, the new-abi\n+   uses the type_info object directly.  You can take the address of the\n    returned decl, to save the decl.  To use the decl call\n    tinfo_from_decl.  You must arrange that the decl is mark_used, if\n    actually use it --- decls in vtables are only used if the vtable is\n@@ -379,21 +411,47 @@ get_tinfo_decl (type)\n \n   name = build_overload_with_type (tinfo_decl_id, type);\n \n-  if (IDENTIFIER_GLOBAL_VALUE (name))\n-    return IDENTIFIER_GLOBAL_VALUE (name);\n+  d = IDENTIFIER_GLOBAL_VALUE (name);\n+  if (d)\n+    /* OK */;\n+  else if (!new_abi_rtti_p ())\n+    {\n+      /* The tinfo decl is a function returning a reference to the type_info\n+         object.  */\n+      d = build_lang_decl (FUNCTION_DECL, name, tinfo_decl_type);\n+      DECL_EXTERNAL (d) = 1;\n+      TREE_PUBLIC (d) = 1;\n+      DECL_ARTIFICIAL (d) = 1;\n+      DECL_NOT_REALLY_EXTERN (d) = 1;\n+      SET_DECL_TINFO_FN_P (d);\n+      TREE_TYPE (name) = type;\n \n-  d = build_lang_decl (FUNCTION_DECL, name, tinfo_decl_type);\n-  DECL_EXTERNAL (d) = 1;\n-  TREE_PUBLIC (d) = 1;\n-  DECL_ARTIFICIAL (d) = 1;\n-  DECL_NOT_REALLY_EXTERN (d) = 1;\n-  SET_DECL_TINFO_FN_P (d);\n-  TREE_TYPE (name) = type;\n+      pushdecl_top_level (d);\n+      make_function_rtl (d);\n+      mark_inline_for_output (d);\n+    }\n+  else\n+    {\n+      /* The tinfo decl is the type_info object itself.  We make all\n+         tinfo objects look as type_info, even though they will end up\n+         being a subclass of that when emitted.  This means the we'll\n+         erroneously think we know the dynamic type -- be careful in the\n+         runtime.  */\n+      d = build_lang_decl (VAR_DECL, name, tinfo_decl_type);\n+      \n+      DECL_ARTIFICIAL (d) = 1;\n+      DECL_ALIGN (d) = TYPE_ALIGN (ptr_type_node);\n+      TREE_READONLY (d) = 1;\n+      TREE_STATIC (d) = 1;\n+      DECL_EXTERNAL (d) = 1;\n+      TREE_PUBLIC (d) = 1;\n+      DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n+      cp_finish_decl (d, NULL_TREE, NULL_TREE, 0);\n \n-  pushdecl_top_level (d);\n-  make_function_rtl (d);\n-  mark_inline_for_output (d);\n-  \n+      pushdecl_top_level (d);\n+      /* Remember the type it is for.  */\n+      TREE_TYPE (name) = type;\n+    }\n   return d;\n }\n \n@@ -404,7 +462,14 @@ static tree\n tinfo_from_decl (expr)\n      tree expr;\n {\n-  tree t = build_call (expr, TREE_TYPE (tinfo_decl_type), NULL_TREE);\n+  tree t;\n+  \n+  if (!new_abi_rtti_p ())\n+    t = build_call (expr, TREE_TYPE (tinfo_decl_type), NULL_TREE);\n+  else if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+    t = build_indirect_ref (expr, NULL);\n+  else\n+    t = expr;\n   \n   return t;\n }\n@@ -631,7 +696,7 @@ build_dynamic_cast_1 (type, expr)\n       else\n \t{\n \t  tree retval;\n-          tree result, td1, td2, td3, elems, expr2;\n+          tree result, td2, td3, elems;\n           tree static_type, target_type, boff;\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n@@ -664,72 +729,112 @@ build_dynamic_cast_1 (type, expr)\n \t\t}\n \t    }\n \n+\t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n+\t  td2 = build_unary_op (ADDR_EXPR, get_tinfo_decl (target_type), 0);\n+\t  td3 = build_unary_op (ADDR_EXPR, get_tinfo_decl (static_type), 0);\n+\n+          /* Determine how T and V are related.  */\n+          boff = get_dynamic_cast_base_type (static_type, target_type);\n+          \n \t  /* Since expr is used twice below, save it.  */\n \t  expr = save_expr (expr);\n \n \t  expr1 = expr;\n \t  if (tc == REFERENCE_TYPE)\n \t    expr1 = build_unary_op (ADDR_EXPR, expr1, 0);\n \n-\t  /* Build run-time conversion.  */\n-\t  expr2 = build_headof (expr1);\n+          if (!new_abi_rtti_p ())\n+            {\n+\t      tree expr2 = build_headof (expr1);\n+\t      tree td1 = expr;\n \n-\t  if (ec == POINTER_TYPE)\n-\t    td1 = get_tinfo_decl_dynamic (build_indirect_ref (expr, NULL_PTR));\n-\t  else\n-\t    td1 = get_tinfo_decl_dynamic (expr);\n+\t      if (ec == POINTER_TYPE)\n+\t        td1 = build_indirect_ref (td1, NULL_PTR);\n+  \t      td1 = get_tinfo_decl_dynamic (td1);\n \t  \n-\t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-\t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n-\t  td2 = build_unary_op (ADDR_EXPR, get_tinfo_decl (target_type), 0);\n-\t  td3 = build_unary_op (ADDR_EXPR, get_tinfo_decl (static_type), 0);\n-\n-          /* Determine how T and V are related.  */\n-          boff = get_dynamic_cast_base_type (static_type, target_type);\n-\n-          elems = tree_cons\n-\t    (NULL_TREE, td1, tree_cons\n-\t     (NULL_TREE, td2, tree_cons\n-\t      (NULL_TREE, boff, tree_cons\n-\t       (NULL_TREE, expr2, tree_cons\n+              elems = tree_cons\n+\t        (NULL_TREE, td1, tree_cons\n+\t          (NULL_TREE, td2, tree_cons\n+\t            (NULL_TREE, boff, tree_cons\n+\t              (NULL_TREE, expr2, tree_cons\n+\t                (NULL_TREE, td3, tree_cons\n+\t\t          (NULL_TREE, expr1, NULL_TREE))))));\n+\t    }\n+\t  else\n+\t    elems = tree_cons\n+\t      (NULL_TREE, expr1, tree_cons\n \t        (NULL_TREE, td3, tree_cons\n-\t\t (NULL_TREE, expr1, NULL_TREE))))));\n+  \t          (NULL_TREE, td2, tree_cons\n+                    (NULL_TREE, boff, NULL_TREE))));\n \n \t  dcast_fn = dynamic_cast_node;\n \t  if (!dcast_fn)\n \t    {\n \t      tree tmp;\n-\t      tree tinfo_ptr = build_pointer_type (tinfo_decl_type);\n-  \t      \n-\t      tmp = tree_cons\n+\t      tree tinfo_ptr;\n+\t      tree ns = global_namespace;\n+\t      const char *name;\n+\t      \n+              push_nested_namespace (ns);\n+\t      if (!new_abi_rtti_p ())\n+\t        {\n+    \t          tinfo_ptr = build_pointer_type (tinfo_decl_type);\n+  \t          name = \"__dynamic_cast_2\";\n+\t          tmp = tree_cons\n \t\t    (NULL_TREE, tinfo_ptr, tree_cons\n \t\t      (NULL_TREE, tinfo_ptr, tree_cons\n \t                (NULL_TREE, integer_type_node, tree_cons\n \t\t          (NULL_TREE, ptr_type_node, tree_cons\n \t\t            (NULL_TREE, tinfo_ptr, tree_cons\n \t\t              (NULL_TREE, ptr_type_node, void_list_node))))));\n-\n+\t        }\n+\t      else\n+\t        {\n+\t          if (flag_honor_std)\n+\t            {\n+                      push_namespace (get_identifier (\"std\"));\n+                      ns = current_namespace;\n+\t            }\n+                  tinfo_ptr = xref_tag (class_type_node,\n+                                        get_identifier (\"__class_type_info\"),\n+                                        1);\n+                    \n+                  tinfo_ptr = build_pointer_type\n+                                (build_qualified_type\n+                                  (tinfo_ptr, TYPE_QUAL_CONST));\n+  \t          name = \"__dynamic_cast\";\n+  \t          tmp = tree_cons\n+\t            (NULL_TREE, const_ptr_type_node, tree_cons\n+\t              (NULL_TREE, tinfo_ptr, tree_cons\n+\t                (NULL_TREE, tinfo_ptr, tree_cons\n+\t                  (NULL_TREE, ptrdiff_type_node, void_list_node))));\n+\t        }\n \t      tmp = build_function_type (ptr_type_node, tmp);\n \t      dcast_fn = build_lang_decl (FUNCTION_DECL,\n-\t                                  get_identifier (\"__dynamic_cast_2\"),\n+\t                                  get_identifier (name),\n \t                                  tmp);\n \t      DECL_EXTERNAL (dcast_fn) = 1;\n \t      TREE_PUBLIC (dcast_fn) = 1;\n \t      DECL_ARTIFICIAL (dcast_fn) = 1;\n-\t      pushdecl_top_level (dcast_fn);\n+\t      pushdecl (dcast_fn);\n+\t      if (new_abi_rtti_p ())\n+\t        /* We want it's name mangling.  */\n+\t        set_mangled_name_for_decl (dcast_fn);\n \t      make_function_rtl (dcast_fn);\n-\t      \n-\t      dynamic_cast_node = dcast_fn;\n+              pop_nested_namespace (ns);\n+              dynamic_cast_node = dcast_fn;\n \t    }\n \t  mark_used (dcast_fn);\n           result = build_call\n \t    (dcast_fn, TREE_TYPE (TREE_TYPE (dcast_fn)), elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {\n-\t      expr1 = throw_bad_cast ();\n+\t      tree bad = throw_bad_cast ();\n+\t      \n \t      result = save_expr (result);\n-\t      return build (COND_EXPR, type, result, result, expr1);\n+\t      return build (COND_EXPR, type, result, result, bad);\n \t    }\n \n \t  /* Now back to the type we want from a void*.  */\n@@ -1128,6 +1233,7 @@ synthesize_tinfo_fn (fndecl)\n   tree if_stmt;\n   tree then_clause;\n \n+  my_friendly_assert (!new_abi_rtti_p (), 20000118);\n   if (at_eof)\n     {\n       import_export_decl (fndecl);\n@@ -1212,3 +1318,676 @@ synthesize_tinfo_fn (fndecl)\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n   expand_body (finish_function (lineno, 0));\n }\n+\n+/* Return the runtime bit mask encoding the qualifiers of TYPE.  */\n+\n+static int\n+qualifier_flags (type)\n+     tree type;\n+{\n+  int flags = 0;\n+  /* we want the qualifiers on this type, not any array core, it might have */\n+  int quals = TYPE_QUALS (type);\n+  \n+  if (quals & TYPE_QUAL_CONST)\n+    flags |= 1;\n+  if (quals & TYPE_QUAL_VOLATILE)\n+    flags |= 2;\n+  return flags;\n+}\n+\n+/* Return a CONSTRUCTOR for the common part of the type_info objects. This\n+   is the vtable pointer and NTBS name.  */\n+\n+static tree\n+tinfo_base_init (desc, target)\n+     tree desc;\n+     tree target;\n+{\n+  tree name_string = tinfo_name (target);\n+  tree init = NULL_TREE;\n+  \n+  if (TINFO_VTABLE_DECL (desc))\n+    {\n+      tree vtbl_ptr = build_unary_op (ADDR_EXPR, TINFO_VTABLE_DECL (desc), 0);\n+  \n+      init = tree_cons (NULL_TREE, vtbl_ptr, init);\n+    }\n+  \n+  init = tree_cons (NULL_TREE, decay_conversion (name_string), init);\n+  \n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse(init));\n+  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  init = tree_cons (NULL_TREE, init, NULL_TREE);\n+  \n+  return init;\n+}\n+\n+/* Return the CONSTRUCTOR expr for a type_info of TYPE. DESC provides the\n+   information about the particular type_info derivation, which adds no\n+   additional fields to the type_info base.  */\n+\n+static tree\n+generic_initializer (desc, target)\n+     tree desc;\n+     tree target;\n+{\n+  tree init = tinfo_base_init (desc, target);\n+  \n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, init);\n+  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  return init;\n+}\n+\n+/* Return the CONSTRUCTOR expr for a type_info of pointer or reference TYPE.\n+   DESC provides information about the particular type_info derivation,\n+   which adds target type and qualifier flags members to the type_info base.  */\n+\n+static tree\n+ptr_ref_initializer (desc, target)\n+     tree desc;\n+     tree target;\n+{\n+  tree init = tinfo_base_init (desc, target);\n+  tree to = TREE_TYPE (target);\n+  int flags = qualifier_flags (to);\n+  \n+  init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n+  init = tree_cons (NULL_TREE,\n+                    build_unary_op (ADDR_EXPR,\n+                                    get_tinfo_decl (TYPE_MAIN_VARIANT (to)), 0),\n+                    init);\n+  \n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n+  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  return init;\n+}\n+\n+/* Return the CONSTRUCTOR expr for a type_info of pointer or reference TYPE.\n+   DESC provides information about the particular type_info derivation,\n+   which adds target type and qualifier flags members to the type_info base.  */\n+\n+static tree\n+ptmd_initializer (desc, target)\n+     tree desc;\n+     tree target;\n+{\n+  tree init = tinfo_base_init (desc, target);\n+  tree to = TYPE_PTRMEM_POINTED_TO_TYPE (target);\n+  tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n+  int flags = qualifier_flags (to);\n+  \n+  init = tree_cons (NULL_TREE,\n+                    build_unary_op (ADDR_EXPR, get_tinfo_decl (klass), 0),\n+                    init);  \n+  init = tree_cons (NULL_TREE,\n+                    build_unary_op (ADDR_EXPR,\n+                                    get_tinfo_decl (TYPE_MAIN_VARIANT (to)), 0),\n+                    init);\n+  init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n+  \n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n+  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  return init;  \n+}\n+\n+/* Determine the hint flags describing the features of a class's heirarchy.\n+   FIXME: better set the hint_flags here!  For now set them\n+   to safe 'don't know' values.  The specification is under\n+   review.  Don't forget to check the runtime dynamic_cast and\n+   catch machinery if these change.  */\n+\n+static int\n+class_hint_flags (type)\n+     tree type;\n+{\n+  int hint_flags = 0;\n+  hint_flags |= 0x1;  /* contains multiply inherited sub object */\n+  hint_flags |= 0x4;  /* has virtual bases */\n+  hint_flags |= 0x8;  /* has private base */\n+  if (TYPE_POLYMORPHIC_P (type))\n+    hint_flags |= 0x2;\n+  \n+  return hint_flags;\n+}\n+        \n+/* Return the CONSTRUCTOR expr for a type_info of class TYPE.\n+   DESC provides information about the particular __class_type_info derivation,\n+   which adds hint flags and TRAIL initializers to the type_info base.  */\n+\n+static tree\n+class_initializer (desc, target, trail)\n+     tree desc;\n+     tree target;\n+     tree trail;\n+{\n+  tree init = tinfo_base_init (desc, target);\n+  int flags = class_hint_flags (target);\n+  \n+  trail = tree_cons (NULL_TREE, build_int_2 (flags, 0), trail);\n+  TREE_CHAIN (init) = trail;\n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, init);\n+  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  return init;  \n+}\n+\n+/* Generate a pseudo_type_info VAR_DECL suitable for the supplied\n+   TARGET_TYPE and given the REAL_NAME. This is the structure expected by\n+   the runtime, and therefore has additional fields.  If we need not emit a\n+   definition (because the runtime must contain it), return NULL_TREE,\n+   otherwise return the VAR_DECL.  */\n+\n+static tree\n+synthesize_tinfo_var (target_type, real_name)\n+     tree target_type;\n+     tree real_name;\n+{\n+  tree var_init = NULL_TREE;\n+  tree var_type = NULL_TREE;\n+  \n+  my_friendly_assert (new_abi_rtti_p (), 20000118);\n+\n+  switch (TREE_CODE (target_type))\n+    {\n+    case POINTER_TYPE:\n+      if (TYPE_PTRMEM_P (target_type))\n+        {\n+          var_type = ptmd_desc_type_node;\n+          var_init = ptmd_initializer (var_type, target_type);\n+        }\n+      else\n+        {\n+          int code = TREE_CODE (TREE_TYPE (target_type));\n+          \n+          if ((CP_TYPE_QUALS (TREE_TYPE (target_type)) | TYPE_QUAL_CONST)\n+              == TYPE_QUAL_CONST\n+              && (code == INTEGER_TYPE || code == BOOLEAN_TYPE\n+                  || code == CHAR_TYPE || code == REAL_TYPE\n+                  || code == VOID_TYPE)\n+              && !doing_runtime)\n+            /* These are in the runtime.  */\n+            return NULL_TREE;\n+          var_type = ptr_desc_type_node;\n+          var_init = ptr_ref_initializer (var_type, target_type);\n+        }\n+      break;\n+    case REFERENCE_TYPE:\n+      var_type = ref_desc_type_node;\n+      var_init = ptr_ref_initializer (var_type, target_type);\n+      break;\n+    case ENUMERAL_TYPE:\n+      var_type = enum_desc_type_node;\n+      var_init = generic_initializer (var_type, target_type);\n+      break;\n+    case FUNCTION_TYPE:\n+      var_type = func_desc_type_node;\n+      var_init = generic_initializer (var_type, target_type);\n+      break;\n+    case ARRAY_TYPE:\n+      var_type = ary_desc_type_node;\n+      var_init = generic_initializer (var_type, target_type);\n+      break;\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      if (!TYPE_SIZE (target_type))\n+        {\n+          /* FIXME: incomplete type. Awaiting specification.  */\n+          return NULL_TREE;\n+        }\n+      else if (!CLASSTYPE_N_BASECLASSES (target_type))\n+        {\n+          var_type = class_desc_type_node;\n+          var_init = class_initializer (var_type, target_type, NULL_TREE);\n+        }\n+      else\n+        {\n+          /* if this has a single public non-virtual base, it's easier */\n+          tree binfo = TYPE_BINFO (target_type);\n+          int nbases = BINFO_N_BASETYPES (binfo);\n+          tree base_binfos = BINFO_BASETYPES (binfo);\n+          tree base_inits = NULL_TREE;\n+          int is_simple = nbases == 1;\n+          int ix;\n+          \n+          /* Generate the base information initializer.  */\n+          for (ix = nbases; ix--;)\n+            {\n+              tree base_binfo = TREE_VEC_ELT (base_binfos, ix);\n+              tree base_init = NULL_TREE;\n+              int flags = 0;\n+              tree tinfo;\n+              tree offset;\n+              \n+              if (TREE_VIA_VIRTUAL (base_binfo))\n+                flags |= 1;\n+              if (TREE_PUBLIC (base_binfo))\n+                flags |= 2;\n+              tinfo = get_tinfo_decl (BINFO_TYPE (base_binfo));\n+              tinfo = build_unary_op (ADDR_EXPR, tinfo, 0);\n+              offset = get_base_offset (base_binfo, target_type);\n+              \n+              /* is it a single public inheritance? */\n+              if (is_simple && flags == 2 && integer_zerop (offset))\n+                {\n+                  base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n+                  break;\n+                }\n+              is_simple = 0;\n+              \n+              base_init = tree_cons\n+                  (NULL_TREE, build_int_2 (flags, 0), base_init);\n+              base_init = tree_cons (NULL_TREE, offset, base_init);\n+              base_init = tree_cons (NULL_TREE, tinfo, base_init);\n+              base_init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_init);\n+              base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n+            }\n+          \n+          if (is_simple)\n+            var_type = si_class_desc_type_node;\n+          else\n+            {\n+              /* Prepend the number of bases.  */\n+              base_inits = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_inits);\n+              base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n+              base_inits = tree_cons (NULL_TREE,\n+                                      build_int_2 (nbases, 0), base_inits);\n+          \n+              var_type = get_vmi_pseudo_type_info (nbases);\n+            }\n+          var_init = class_initializer (var_type, target_type, base_inits);\n+        }\n+      break;\n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+      if (!doing_runtime)\n+        /* These are guaranteed to be in the runtime.  */\n+        return NULL_TREE;\n+      var_type = bltn_desc_type_node;\n+      var_init = generic_initializer (var_type, target_type);\n+      break;\n+    default:\n+      my_friendly_abort (20000117);\n+    }\n+  \n+  return create_real_tinfo_var (real_name, TINFO_PSEUDO_TYPE (var_type), var_init);\n+}\n+\n+/* Create the real typeinfo variable.  */\n+\n+static tree\n+create_real_tinfo_var (name, type, init)\n+     tree name;\n+     tree type;\n+     tree init;\n+{\n+  tree decl;\n+  \n+  decl = build_lang_decl (VAR_DECL, name,\n+                          build_qualified_type (type, TYPE_QUAL_CONST));\n+  DECL_ARTIFICIAL (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_EXTERNAL (decl) = 0;\n+  \n+  comdat_linkage (decl);\n+  DECL_ASSEMBLER_NAME (decl) = name;\n+  DECL_INITIAL (decl) = init;\n+  cp_finish_decl (decl, init, NULL_TREE, 0);\n+  \n+  return decl;\n+}\n+\n+/* Generate the RECORD_TYPE containing the data layout of a type_info\n+   derivative as used by the runtime. This layout must be consistent with\n+   that defined in the runtime support. Also generate the VAR_DECL for the\n+   type's vtable. We explicitly manage the vtable member, and name it for\n+   real type as used in the runtime. The RECORD type has a different name,\n+   to avoid collisions.  Return a TREE_LIST who's TINFO_PSEUDO_TYPE\n+   is the generated type and TINFO_VTABLE_DECL is the vtable decl.\n+   \n+   REAL_NAME is the runtime's name of the type. Trailing arguments are\n+   additional FIELD_DECL's for the structure. The final argument must be\n+   NULL.  */\n+\n+static tree\n+create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char const *real_name;\n+  int ident;\n+#endif\n+  va_list ap;\n+  tree real_type, pseudo_type;\n+  char *pseudo_name;\n+  tree vtable_decl;\n+  int ix;\n+  tree fields[10];\n+  tree field_decl;\n+  tree result;\n+  \n+  VA_START (ap, ident);\n+#ifndef ANSI_PROTOTYPES\n+  real_name = va_arg (ap, char const *);\n+  ident = va_arg (app, int);\n+#endif\n+\n+  /* Generate the pseudo type name. */\n+  pseudo_name = (char *)alloca (strlen (real_name) + 30);\n+  strcpy (pseudo_name, real_name);\n+  strcat (pseudo_name, \"_pseudo\");\n+  if (ident)\n+    sprintf (pseudo_name + strlen (pseudo_name), \"%d\", ident);\n+  \n+  /* Get the vtable decl. */\n+  real_type = xref_tag (class_type_node, get_identifier (real_name), 1);\n+  vtable_decl = get_vtable_decl (real_type, /*complete=*/1);\n+  \n+  /* First field is the pseudo type_info base class. */\n+  fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n+  \n+  /* Now add the derived fields.  */\n+  for (ix = 0; (field_decl = va_arg (ap, tree));)\n+    fields[++ix] = field_decl;\n+  \n+  /* Create the pseudo type. */\n+  pseudo_type = make_aggr_type (RECORD_TYPE);\n+  finish_builtin_type (pseudo_type, pseudo_name, fields, ix, ptr_type_node);\n+  TYPE_HAS_CONSTRUCTOR (pseudo_type) = 1;\n+  va_end (ap);\n+  \n+  result = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+  TINFO_VTABLE_DECL (result) = vtable_decl;\n+  TINFO_PSEUDO_TYPE (result) = pseudo_type;\n+  \n+  return result;\n+}\n+\n+/* Return a descriptor for a vmi type with NUM_BASES bases.  */\n+\n+static tree\n+get_vmi_pseudo_type_info (num_bases)\n+     int num_bases;\n+{\n+  tree desc;\n+  tree array_domain, base_array;\n+  \n+  if (TREE_VEC_LENGTH (vmi_class_desc_type_node) <= num_bases)\n+    {\n+      int ix;\n+      tree extend = make_tree_vec (num_bases + 5);\n+      \n+      for (ix = TREE_VEC_LENGTH (vmi_class_desc_type_node); ix--;)\n+        TREE_VEC_ELT (extend, ix) = TREE_VEC_ELT (vmi_class_desc_type_node, ix);\n+      vmi_class_desc_type_node = extend;\n+    }\n+  desc = TREE_VEC_ELT (vmi_class_desc_type_node, num_bases);\n+  \n+  if (desc)\n+    return desc;\n+  \n+  /* Add number of bases and trailing array of base_class_type_info.  */\n+  array_domain = build_index_type (build_int_2 (num_bases, 0));\n+  base_array = build_array_type (base_desc_type_node, array_domain);\n+\n+  desc = create_pseudo_type_info\n+            (\"__vmi_class_type_info\", num_bases,\n+             build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+             build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+             build_lang_decl (FIELD_DECL, NULL_TREE, base_array),\n+             NULL);\n+  TREE_VEC_ELT (vmi_class_desc_type_node, num_bases) = desc;\n+  return desc;\n+}\n+\n+/* Make sure the required builtin types exist for generating the type_info\n+   varable definitions.  */\n+\n+static void\n+create_tinfo_types ()\n+{\n+  tree ptr_type_info;\n+  \n+  if (bltn_desc_type_node)\n+    return;\n+  if (flag_honor_std)\n+    push_namespace (get_identifier (\"std\"));\n+\n+  ptr_type_info = build_pointer_type\n+                    (build_qualified_type\n+                      (type_info_type_node, TYPE_QUAL_CONST));\n+  \n+  /* Create the internal type_info structure. This is used as a base for\n+     the other structures.  */\n+  {\n+    tree fields[2];\n+\n+    ti_desc_type_node = make_aggr_type (RECORD_TYPE);\n+    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n+    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n+    finish_builtin_type (ti_desc_type_node, \"__type_info_pseudo\",\n+                         fields, 1, ptr_type_node);\n+    TYPE_HAS_CONSTRUCTOR (ti_desc_type_node) = 1;\n+  }\n+  \n+  /* Fundamental type_info */\n+  bltn_desc_type_node = create_pseudo_type_info\n+      (\"__fundamental_type_info\", 0,\n+       NULL);\n+\n+  /* Pointer and reference type_info. These two fields, qualification mask\n+      and pointer to the pointed to (referenced) type.  */\n+  ptr_desc_type_node = create_pseudo_type_info\n+      (\"__pointer_type_info\", 0,\n+       build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+       build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+       NULL);\n+  ref_desc_type_node = create_pseudo_type_info\n+      (\"__reference_type_info\", 0,\n+       build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+       build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+       NULL);\n+\n+  /* Array, function and enum type_info. No additional fields. */\n+  ary_desc_type_node = create_pseudo_type_info\n+      (\"__array_type_info\", 0,\n+       NULL);\n+  func_desc_type_node = create_pseudo_type_info\n+       (\"__function_type_info\", 0,\n+        NULL);\n+  enum_desc_type_node = create_pseudo_type_info\n+       (\"__enum_type_info\", 0,\n+        NULL);\n+  \n+  /* Class type_info. Add a flags field.  */\n+  class_desc_type_node = create_pseudo_type_info\n+        (\"__class_type_info\", 0,\n+         build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+         NULL);\n+  \n+  /* Single public non-virtual base class. Add pointer to base class.  */\n+  si_class_desc_type_node = create_pseudo_type_info\n+           (\"__si_class_type_info\", 0,\n+            build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+            build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+            NULL);\n+  \n+  /* Base class internal helper. Pointer to base type, offset to base,\n+     flags. */\n+  {\n+    tree fields[3];\n+    \n+    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, ptrdiff_type_node),\n+    fields[2] = build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+    base_desc_type_node = make_aggr_type (RECORD_TYPE);\n+    finish_builtin_type (base_desc_type_node, \"__base_class_type_info_pseudo\",\n+                         fields, 2, ptr_type_node);\n+    TYPE_HAS_CONSTRUCTOR (base_desc_type_node) = 1;\n+  }\n+  \n+  /* General heirarchy is created as necessary in this vector. */\n+  vmi_class_desc_type_node = make_tree_vec (10);\n+  \n+  /* Pointer to member data type_info.  Add pointer to the class, pointer\n+     to the member's type info and qualifications flags.  */\n+  ptmd_desc_type_node = create_pseudo_type_info\n+       (\"__ptr_to_member_type_info\", 0,\n+        build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+        build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+        build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+        NULL);\n+\n+  if (flag_honor_std)\n+    pop_namespace ();\n+}\n+\n+/* Emit the type_info descriptors which are guaranteed to be in the runtime\n+   support.  Generating them here guarantees consistency with the other\n+   structures.  We use the following heuristic to determine when the runtime\n+   is being generated.  If std::__fundamental_type_info is defined, and it's\n+   destructor is defined, then the runtime is being built.  */\n+\n+void\n+emit_support_tinfos ()\n+{\n+  static tree *const fundamentals[] =\n+  {\n+    &void_type_node,\n+    &boolean_type_node,\n+    &wchar_type_node,\n+    #if 0\n+    &signed_wchar_type_node, &unsigned_wchar_type_node,\n+    #endif\n+    &char_type_node, &signed_char_type_node, &unsigned_char_type_node,\n+    &short_integer_type_node, &short_unsigned_type_node,\n+    &integer_type_node, &unsigned_type_node,\n+    &long_integer_type_node, &long_unsigned_type_node,\n+    &long_long_integer_type_node, &long_long_unsigned_type_node,\n+    &float_type_node, &double_type_node, &long_double_type_node,\n+\n+    /* GCC extension types */\n+    #if 0\n+    &complex_integer_type_node,\n+    &complex_float_type_node, &complex_double_type_node,\n+    &complex_long_double_type_node,\n+    #endif\n+    \n+    0\n+  };\n+  int ix;\n+  tree bltn_type, dtor;\n+  \n+  if (flag_honor_std)\n+    push_namespace (get_identifier (\"std\"));\n+  bltn_type = xref_tag (class_type_node,\n+                        get_identifier (\"__fundamental_type_info\"), 1);\n+  if (flag_honor_std)\n+    pop_namespace ();\n+  if (!TYPE_SIZE (bltn_type))\n+    return;\n+  dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (bltn_type), 1);\n+  if (DECL_EXTERNAL (dtor))\n+    return;\n+  doing_runtime = 1;\n+  for (ix = 0; fundamentals[ix]; ix++)\n+    {\n+      tree bltn = *fundamentals[ix];\n+      tree bltn_ptr = build_pointer_type (bltn);\n+      tree bltn_const_ptr = build_pointer_type\n+              (build_qualified_type (bltn, TYPE_QUAL_CONST));\n+      tree tinfo;\n+      \n+      tinfo = get_tinfo_decl (bltn);\n+      TREE_USED (tinfo) = 1;\n+      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n+      \n+      tinfo = get_tinfo_decl (bltn_ptr);\n+      TREE_USED (tinfo) = 1;\n+      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n+      \n+      tinfo = get_tinfo_decl (bltn_const_ptr);\n+      TREE_USED (tinfo) = 1;\n+      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n+    }\n+}\n+\n+/* Return non-zero, iff T is a type_info variable which has not had a\n+   definition emitted for it.  */\n+\n+int\n+tinfo_decl_p (t, data)\n+     tree t;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return TREE_CODE (t) == VAR_DECL\n+         && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (t)) == (t)\n+         && TREE_TYPE (t) == tinfo_decl_type\n+         && TREE_TYPE (DECL_NAME (t));\n+}\n+\n+/* Emit a suitable type_info definition for the type_info decl pointed to by\n+   DECL_PTR. We emit a completely new variable, of the correct type for the\n+   actual type this is describing. The DECL_ASSEMBLER_NAME of the generated\n+   definition is set to that of the supplied decl, so that they can be tied\n+   up. Mark the supplied decl as having been dealt with. Emitting one\n+   definitions might cause other declarations to be emitted.\n+   \n+   We need to do things this way, because we're trying to do something like\n+   \n+      struct B : A {\n+        ...\n+      };\n+   \n+      extern const A tinfo_var;\n+   \n+      const B tinfo_var = {...};\n+   \n+   which is not permitted. Also, we've not necessarily seen the definition of B.\n+   So we do something like the following,\n+   \n+      extern const A tinfo_var;\n+   \n+      struct pseudo_A {\n+        const void *vtable_ptr;\n+        const char *name;\n+      };\n+      struct pseudo_B {\n+        pseudo_A base;\n+        ...\n+      };\n+      \n+      const pseudo_B proxy_tinfo_var attribute((assembler_name=\"tinfo_var\")) =\n+      {\n+        {&B::vtable, \"...\"},\n+        ...\n+      };\n+   \n+   pseudo_A and pseudo_B must be layout equivalent to the real definitions in\n+   the runtime.  */\n+\n+int\n+emit_tinfo_decl (decl_ptr, data)\n+     tree *decl_ptr;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree tinfo_decl = *decl_ptr;\n+  tree tinfo_type, decl;\n+  \n+  my_friendly_assert (TREE_TYPE (tinfo_decl) == tinfo_decl_type, 20000121);\n+  tinfo_type = TREE_TYPE (DECL_NAME (tinfo_decl));\n+  my_friendly_assert (tinfo_type != NULL_TREE, 20000120);\n+  \n+  /* Say we've dealt with it.  */\n+  TREE_TYPE (DECL_NAME (tinfo_decl)) = NULL_TREE;\n+  \n+  if (!DECL_NEEDED_P (tinfo_decl))\n+    return 0;\n+  create_tinfo_types ();\n+  decl = synthesize_tinfo_var (tinfo_type, DECL_ASSEMBLER_NAME (tinfo_decl));\n+  \n+  return decl != 0;\n+}"}]}