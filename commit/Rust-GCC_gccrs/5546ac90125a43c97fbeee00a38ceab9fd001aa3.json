{"sha": "5546ac90125a43c97fbeee00a38ceab9fd001aa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU0NmFjOTAxMjVhNDNjOTdmYmVlZTAwYTM4Y2VhYjlmZDAwMWFhMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-02T23:28:53Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-02T23:28:53Z"}, "message": "sh.c (general_movsrc_operand, [...]): Move to ...\n\n\t* config/sh/sh.c (general_movsrc_operand,\n\tgeneral_movdst_operand, arith_reg_operand, arith_reg_dest,\n\tlogical_reg_operand, int_gpr_dest, fp_arith_reg_operand,\n\tfp_arith_reg_dest, arith_operand, arith_reg_or_0_operand,\n\txor_operand, cmp_operand, logical_operand, and_operand,\n\tfpscr_operand, fpul_operand, symbol_ref_operand,\n\tcommutative_float_operator, noncommutative_float_operator,\n\tunary_float_operator, binary_float_operator,\n\tbinary_logical_operator, equality_comparison_operator,\n\tgreater_comparison_operator, less_comparison_operator,\n\tshift_operator, logical_operator, target_reg_operand,\n\ttarget_operand, mextr_bit_offset, extend_reg_operand,\n\ttrunc_hi_operand, extend_reg_or_0_operand, minuend_operand,\n\tgeneral_extend_operand, ua_address_operand,\n\tcache_address_operand, inqhi_operand, sh_rep_vec, sh_1el_vec,\n\tsh_const_vec, ua_offset, sh_register_operand, cmpsi_operand,\n\tshift_count_reg_operand, shift_count_operand,\n\tunaligned_load_operand): Move to ...\n\t* config/sh/predicates.md: ... here.\n\t* config/sh/sh.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES):\n\tRemove.\n\nFrom-SVN: r100523", "tree": {"sha": "7028f796ed85523072d10b0e95820445ce669d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7028f796ed85523072d10b0e95820445ce669d29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5546ac90125a43c97fbeee00a38ceab9fd001aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5546ac90125a43c97fbeee00a38ceab9fd001aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5546ac90125a43c97fbeee00a38ceab9fd001aa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5546ac90125a43c97fbeee00a38ceab9fd001aa3/comments", "author": null, "committer": null, "parents": [{"sha": "e0d161cf091d0f309cdcaf1e42734263f5104f2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d161cf091d0f309cdcaf1e42734263f5104f2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d161cf091d0f309cdcaf1e42734263f5104f2f"}], "stats": {"total": 1735, "additions": 906, "deletions": 829}, "files": [{"sha": "fd459d339973f971f4b5fb7cf0dbcf13ee5b63b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5546ac90125a43c97fbeee00a38ceab9fd001aa3", "patch": "@@ -1,9 +1,33 @@\n-2005-06-03  Andrew Pinski  <pinskia@physics.uc.edu>\n+2005-06-02  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/sh/sh.c (general_movsrc_operand,\n+\tgeneral_movdst_operand, arith_reg_operand, arith_reg_dest,\n+\tlogical_reg_operand, int_gpr_dest, fp_arith_reg_operand,\n+\tfp_arith_reg_dest, arith_operand, arith_reg_or_0_operand,\n+\txor_operand, cmp_operand, logical_operand, and_operand,\n+\tfpscr_operand, fpul_operand, symbol_ref_operand,\n+\tcommutative_float_operator, noncommutative_float_operator,\n+\tunary_float_operator, binary_float_operator,\n+\tbinary_logical_operator, equality_comparison_operator,\n+\tgreater_comparison_operator, less_comparison_operator,\n+\tshift_operator, logical_operator, target_reg_operand,\n+\ttarget_operand, mextr_bit_offset, extend_reg_operand,\n+\ttrunc_hi_operand, extend_reg_or_0_operand, minuend_operand,\n+\tgeneral_extend_operand, ua_address_operand,\n+\tcache_address_operand, inqhi_operand, sh_rep_vec, sh_1el_vec,\n+\tsh_const_vec, ua_offset, sh_register_operand, cmpsi_operand,\n+\tshift_count_reg_operand, shift_count_operand,\n+\tunaligned_load_operand): Move to ...\n+\t* config/sh/predicates.md: ... here.\n+\t* config/sh/sh.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES):\n+\tRemove.\n+\n+2005-06-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* tree.c (build_common_builtin_nodes): Fix the return type on\n \t__builtin_memcmp.\n \n-2005-06-03  Richard Guenther  <rguenth@gcc.gnu.org>\n+2005-06-02  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* tree-ssa-loop-ivopts.c (build_addr_strip_iref): Remove.\n \t(find_interesting_uses_address): Use build_fold_addr_expr instead."}, {"sha": "324d30da802fd37de38210ff71bb64a5c7371188", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 880, "deletions": 0, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=5546ac90125a43c97fbeee00a38ceab9fd001aa3", "patch": "@@ -1,3 +1,25 @@\n+;; Predicate definitions for Renesas / SuperH SH.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; TODO: Add a comment here.\n+\n (define_predicate \"trapping_target_operand\"\n   (match_code \"if_then_else\")\n {\n@@ -36,3 +58,861 @@\n \t  && INTVAL (XEXP (and, 1)) == 3\n \t  && INTVAL (XEXP (cond, 1)) == 3);\n })\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"and_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (logical_operand (op, mode))\n+    return 1;\n+\n+  /* Check mshflo.l / mshflhi.l opportunities.  */\n+  if (TARGET_SHMEDIA\n+      && mode == DImode\n+      && GET_CODE (op) == CONST_INT\n+      && CONST_OK_FOR_J16 (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Like arith_reg_dest, but this predicate belongs to\n+;; SPECIAL_MODE_PREDICATES.\n+\n+(define_special_predicate \"any_arith_reg_dest\"\n+  (match_code \"subreg,reg\")\n+{\n+  return arith_reg_dest (op, mode);\n+})\n+\n+;; Like register_operand, but this predicate belongs to\n+;; SPECIAL_MODE_PREDICATES.\n+\n+(define_special_predicate \"any_register_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  return register_operand (op, mode);\n+})\n+\n+;; Returns 1 if OP is a valid source operand for an arithmetic insn.\n+\n+(define_predicate \"arith_operand\"\n+  (match_code \"subreg,reg,const_int,truncate\")\n+{\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (TARGET_SHMEDIA)\n+    {\n+      /* FIXME: We should be checking whether the CONST_INT fits in a\n+\t CONST_OK_FOR_I16 here, but this causes reload_cse to crash when\n+\t attempting to transform a sequence of two 64-bit sets of the\n+\t same register from literal constants into a set and an add,\n+\t when the difference is too wide for an add.  */\n+      if (GET_CODE (op) == CONST_INT\n+\t  || EXTRA_CONSTRAINT_C16 (op))\n+\treturn 1;\n+      else if (GET_CODE (op) == TRUNCATE\n+\t       && ! system_reg_operand (XEXP (op, 0), VOIDmode)\n+\t       && (mode == VOIDmode || mode == GET_MODE (op))\n+\t       && (GET_MODE_SIZE (GET_MODE (op))\n+\t\t   < GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n+\t       && (! FP_REGISTER_P (REGNO (XEXP (op, 0)))\n+\t\t   || GET_MODE_SIZE (GET_MODE (op)) == 4))\n+\treturn register_operand (XEXP (op, 0), VOIDmode);\n+      else\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Like above, but for DImode destinations: forbid paradoxical DImode\n+;; subregs, because this would lead to missing sign extensions when\n+;; truncating from DImode to SImode.\n+\n+(define_predicate \"arith_reg_dest\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (mode == DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n+      && TARGET_SHMEDIA)\n+    return 0;\n+  return arith_reg_operand (op, mode);\n+})\n+\n+;; Returns 1 if OP is a normal arithmetic register.\n+\n+(define_predicate \"arith_reg_operand\"\n+  (match_code \"subreg,reg,sign_extend\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (GET_CODE (op) == REG)\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 1;\n+\n+      return (regno != T_REG && regno != PR_REG\n+\t      && ! TARGET_REGISTER_P (regno)\n+\t      && (regno != FPUL_REG || TARGET_SH4)\n+\t      && regno != MACH_REG && regno != MACL_REG);\n+    }\n+  /* Allow a no-op sign extension - compare LOAD_EXTEND_OP.\n+     We allow SImode here, as not using an FP register is just a matter of\n+     proper register allocation.  */\n+  if (TARGET_SHMEDIA\n+      && GET_MODE (op) == DImode && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (XEXP (op, 0)) == SImode\n+      && GET_CODE (XEXP (op, 0)) != SUBREG)\n+    return register_operand (XEXP (op, 0), VOIDmode);\n+#if 0 /* Can't do this because of PROMOTE_MODE for unsigned vars.  */\n+  if (GET_MODE (op) == SImode && GET_CODE (op) == SIGN_EXTEND\n+      && GET_MODE (XEXP (op, 0)) == HImode\n+      && GET_CODE (XEXP (op, 0)) == REG\n+      && REGNO (XEXP (op, 0)) <= LAST_GENERAL_REG)\n+    return register_operand (XEXP (op, 0), VOIDmode);\n+#endif\n+  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_INT\n+      && GET_CODE (op) == SUBREG\n+      && GET_MODE (SUBREG_REG (op)) == DImode\n+      && GET_CODE (SUBREG_REG (op)) == SIGN_EXTEND\n+      && GET_MODE (XEXP (SUBREG_REG (op), 0)) == SImode\n+      && GET_CODE (XEXP (SUBREG_REG (op), 0)) != SUBREG)\n+    return register_operand (XEXP (SUBREG_REG (op), 0), VOIDmode);\n+  return 0;\n+})\n+\n+;; Returns 1 if OP is a valid source operand for a compare insn.\n+\n+(define_predicate \"arith_reg_or_0_operand\"\n+  (match_code \"subreg,reg,const_int,const_vector\")\n+{\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (EXTRA_CONSTRAINT_Z (op))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"binary_float_operator\"\n+  (match_code \"plus,minus,mult,div\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"binary_logical_operator\"\n+  (match_code \"and,ior,xor\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case IOR:\n+    case AND:\n+    case XOR:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"cache_address_operand\"\n+  (match_code \"plus,reg\")\n+{\n+  if (GET_CODE (op) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (op, 0)) != REG)\n+\treturn 0;\n+      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t  || (INTVAL (XEXP (op, 1)) & 31))\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) != REG)\n+    return 0;\n+  return address_operand (op, mode);\n+})\n+\n+;; Return 1 if OP is a valid source operand for shmedia cmpgt / cmpgtu.\n+\n+(define_predicate \"cmp_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n+    return 1;\n+  if (TARGET_SHMEDIA\n+      && mode != DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n+    return 0;\n+  return arith_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"cmpsi_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (GET_CODE (op) == REG && REGNO (op) == T_REG\n+      && GET_MODE (op) == SImode\n+      && TARGET_SH1)\n+    return 1;\n+  return arith_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"commutative_float_operator\"\n+  (match_code \"plus,mult\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MULT:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"equality_comparison_operator\"\n+  (match_code \"eq,ne\")\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"extend_reg_operand\"\n+  (match_code \"subreg,reg,truncate\")\n+{\n+  return (GET_CODE (op) == TRUNCATE\n+\t  ? arith_operand\n+\t  : arith_reg_operand) (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"extend_reg_or_0_operand\"\n+  (match_code \"subreg,reg,truncate,const_int\")\n+{\n+  return (GET_CODE (op) == TRUNCATE\n+\t  ? arith_operand\n+\t  : arith_reg_or_0_operand) (op, mode);\n+})\n+\n+;; Like arith_reg_operand, but this predicate does not accept SIGN_EXTEND.\n+\n+(define_predicate \"ext_dest_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  return arith_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fp_arith_reg_dest\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (mode == DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8)\n+    return 0;\n+  return fp_arith_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fp_arith_reg_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (GET_CODE (op) == REG)\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 1;\n+\n+      return (regno >= FIRST_PSEUDO_REGISTER\n+\t      || FP_REGISTER_P (regno));\n+    }\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fpscr_operand\"\n+  (match_code \"reg\")\n+{\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) == FPSCR_REG\n+\t      || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t\t  && !(reload_in_progress || reload_completed)))\n+\t  && GET_MODE (op) == PSImode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fpul_operand\"\n+  (match_code \"reg\")\n+{\n+  if (TARGET_SHMEDIA)\n+    return fp_arith_reg_operand (op, mode);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t  && GET_MODE (op) == mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"general_extend_operand\"\n+  (match_code \"subreg,reg,mem,truncate\")\n+{\n+  return (GET_CODE (op) == TRUNCATE\n+\t  ? arith_operand\n+\t  : nonimmediate_operand) (op, mode);\n+})\n+\n+;; Returns 1 if OP can be source of a simple move operation. Same as\n+;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as\n+;; are subregs of system registers.\n+\n+(define_predicate \"general_movsrc_operand\"\n+  (match_code \"subreg,reg,const_int,const_double,mem,symbol_ref,label_ref,const,const_vector\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (GET_CODE (inside) == CONST)\n+\tinside = XEXP (inside, 0);\n+\n+      if (GET_CODE (inside) == LABEL_REF)\n+\treturn 1;\n+\n+      if (GET_CODE (inside) == PLUS\n+\t  && GET_CODE (XEXP (inside, 0)) == LABEL_REF\n+\t  && GET_CODE (XEXP (inside, 1)) == CONST_INT)\n+\treturn 1;\n+\n+      /* Only post inc allowed.  */\n+      if (GET_CODE (inside) == PRE_DEC)\n+\treturn 0;\n+    }\n+\n+  if ((mode == QImode || mode == HImode)\n+      && (GET_CODE (op) == SUBREG\n+\t  && GET_CODE (XEXP (op, 0)) == REG\n+\t  && system_reg_operand (XEXP (op, 0), mode)))\n+    return 0;\n+\n+  if (TARGET_SHMEDIA\n+      && (GET_CODE (op) == PARALLEL || GET_CODE (op) == CONST_VECTOR)\n+      && sh_rep_vec (op, mode))\n+    return 1;\n+  if (TARGET_SHMEDIA && 1\n+      && GET_CODE (op) == SUBREG && GET_MODE (op) == mode\n+      && SUBREG_REG (op) == const0_rtx && subreg_lowpart_p (op))\n+    /* FIXME */ abort (); /* return 1; */\n+  return general_operand (op, mode);\n+})\n+\n+;; Returns 1 if OP can be a destination of a move. Same as\n+;; general_operand, but no preinc allowed.\n+\n+(define_predicate \"general_movdst_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  /* Only pre dec allowed.  */\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n+    return 0;\n+  if (mode == DImode && TARGET_SHMEDIA && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n+      && ! (high_life_started || reload_completed))\n+    return 0;\n+\n+  return general_operand (op, mode);\n+})\n+\n+;; Returns 1 if OP is a MEM that can be source of a simple move operation.\n+\n+(define_predicate \"unaligned_load_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx inside;\n+\n+  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n+    return 0;\n+\n+  inside = XEXP (op, 0);\n+\n+  if (GET_CODE (inside) == POST_INC)\n+    inside = XEXP (inside, 0);\n+\n+  if (GET_CODE (inside) == REG)\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"greater_comparison_operator\"\n+  (match_code \"gt,ge,gtu,geu\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case GT:\n+    case GE:\n+    case GTU:\n+    case GEU:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"inqhi_operand\"\n+  (match_code \"truncate\")\n+{\n+  if (GET_CODE (op) != TRUNCATE || mode != GET_MODE (op))\n+    return 0;\n+  op = XEXP (op, 0);\n+  /* Can't use true_regnum here because copy_cost wants to know about\n+     SECONDARY_INPUT_RELOAD_CLASS.  */\n+  return GET_CODE (op) == REG && FP_REGISTER_P (REGNO (op));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_special_predicate \"int_gpr_dest\"\n+  (match_code \"subreg,reg\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (GET_MODE_CLASS (op_mode) != MODE_INT\n+      || GET_MODE_SIZE (op_mode) >= UNITS_PER_WORD)\n+    return 0;\n+  if (! reload_completed)\n+    return 0;\n+  return true_regnum (op) <= LAST_GENERAL_REG;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"less_comparison_operator\"\n+  (match_code \"lt,le,ltu,leu\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case LT:\n+    case LE:\n+    case LTU:\n+    case LEU:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Returns 1 if OP is a valid source operand for a logical operation.\n+\n+(define_predicate \"logical_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (TARGET_SHMEDIA\n+      && mode != DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n+    return 0;\n+\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (TARGET_SHMEDIA)\n+    {\n+      if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I10 (INTVAL (op)))\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n+  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K08 (INTVAL (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"logical_operator\"\n+  (match_code \"and,ior,xor\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Like arith_reg_operand, but for register source operands of narrow\n+;; logical SHMEDIA operations: forbid subregs of DImode / TImode regs.\n+\n+(define_predicate \"logical_reg_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (TARGET_SHMEDIA\n+      && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4\n+      && mode != DImode)\n+    return 0;\n+  return arith_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"mextr_bit_offset\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT i;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  i = INTVAL (op);\n+  return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"minuend_operand\"\n+  (match_code \"subreg,reg,truncate,const_int\")\n+{\n+  return op == constm1_rtx || extend_reg_or_0_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"noncommutative_float_operator\"\n+  (match_code \"minus,div\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case MINUS:\n+    case DIV:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"sh_const_vec\"\n+  (match_code \"const_vector\")\n+{\n+  int i;\n+\n+  if (GET_CODE (op) != CONST_VECTOR\n+      || (GET_MODE (op) != mode && mode != VOIDmode))\n+    return 0;\n+  i = XVECLEN (op, 0) - 1;\n+  for (; i >= 0; i--)\n+    if (GET_CODE (XVECEXP (op, 0, i)) != CONST_INT)\n+      return 0;\n+  return 1;\n+})\n+\n+;; Determine if OP is a constant vector matching MODE with only one\n+;; element that is not a sign extension.  Two byte-sized elements\n+;; count as one.\n+\n+(define_predicate \"sh_1el_vec\"\n+  (match_code \"const_vector\")\n+{\n+  int unit_size;\n+  int i, last, least, sign_ix;\n+  rtx sign;\n+\n+  if (GET_CODE (op) != CONST_VECTOR\n+      || (GET_MODE (op) != mode && mode != VOIDmode))\n+    return 0;\n+  /* Determine numbers of last and of least significant elements.  */\n+  last = XVECLEN (op, 0) - 1;\n+  least = TARGET_LITTLE_ENDIAN ? 0 : last;\n+  if (GET_CODE (XVECEXP (op, 0, least)) != CONST_INT)\n+    return 0;\n+  sign_ix = least;\n+  if (GET_MODE_UNIT_SIZE (mode) == 1)\n+    sign_ix = TARGET_LITTLE_ENDIAN ? 1 : last - 1;\n+  if (GET_CODE (XVECEXP (op, 0, sign_ix)) != CONST_INT)\n+    return 0;\n+  unit_size = GET_MODE_UNIT_SIZE (GET_MODE (op));\n+  sign = (INTVAL (XVECEXP (op, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n+\t  ? constm1_rtx : const0_rtx);\n+  i = XVECLEN (op, 0) - 1;\n+  do\n+    if (i != least && i != sign_ix && XVECEXP (op, 0, i) != sign)\n+      return 0;\n+  while (--i);\n+  return 1;\n+})\n+\n+;; Like register_operand, but take into account that SHMEDIA can use\n+;; the constant zero like a general register.\n+\n+(define_predicate \"sh_register_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (op == CONST0_RTX (mode) && TARGET_SHMEDIA)\n+    return 1;\n+  return register_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"sh_rep_vec\"\n+  (match_code \"const_vector\")\n+{\n+  int i;\n+  rtx x, y;\n+\n+  if ((GET_CODE (op) != CONST_VECTOR && GET_CODE (op) != PARALLEL)\n+      || (GET_MODE (op) != mode && mode != VOIDmode))\n+    return 0;\n+  i = XVECLEN (op, 0) - 2;\n+  x = XVECEXP (op, 0, i + 1);\n+  if (GET_MODE_UNIT_SIZE (mode) == 1)\n+    {\n+      y = XVECEXP (op, 0, i);\n+      for (i -= 2; i >= 0; i -= 2)\n+\tif (! rtx_equal_p (XVECEXP (op, 0, i + 1), x)\n+\t    || ! rtx_equal_p (XVECEXP (op, 0, i), y))\n+\t  return 0;\n+    }\n+  else\n+    for (; i >= 0; i--)\n+      if (XVECEXP (op, 0, i) != x)\n+\treturn 0;\n+  return 1;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"shift_count_operand\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,zero_extend,sign_extend\")\n+{\n+  return (CONSTANT_P (op)\n+\t  ? (GET_CODE (op) == CONST_INT\n+\t     ? (unsigned) INTVAL (op) < GET_MODE_BITSIZE (mode)\n+\t     : nonmemory_operand (op, mode))\n+\t  : shift_count_reg_operand (op, mode));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"shift_count_reg_operand\"\n+  (match_code \"subreg,reg,zero_extend,sign_extend\")\n+{\n+  if ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n+       || (GET_CODE (op) == SUBREG && SUBREG_BYTE (op) == 0))\n+      && (mode == VOIDmode || mode == GET_MODE (op))\n+      && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n+      && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT)\n+    {\n+      mode = VOIDmode;\n+      do\n+\top = XEXP (op, 0);\n+      while ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n+\t      || GET_CODE (op) == TRUNCATE)\n+\t     && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n+\t     && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT);\n+\n+    }\n+  return arith_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"shift_operator\"\n+  (match_code \"ashift,ashiftrt,lshiftrt\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"symbol_ref_operand\"\n+  (match_code \"symbol_ref\")\n+{\n+  return (GET_CODE (op) == SYMBOL_REF);\n+})\n+\n+;; Same as target_reg_operand, except that label_refs and symbol_refs\n+;; are accepted before reload.\n+\n+(define_special_predicate \"target_operand\"\n+  (match_code \"subreg,reg,label_ref,symbol_ref,const,unspec\")\n+{\n+  if (mode != VOIDmode && mode != Pmode)\n+    return 0;\n+\n+  if ((GET_MODE (op) == Pmode || GET_MODE (op) == VOIDmode)\n+      && EXTRA_CONSTRAINT_Csy (op))\n+    return ! reload_completed;\n+\n+  return target_reg_operand (op, mode);\n+})\n+\n+;; Accept pseudos and branch target registers.\n+\n+(define_special_predicate \"target_reg_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (mode == VOIDmode\n+     ? GET_MODE (op) != Pmode && GET_MODE (op) != PDImode\n+     : mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != REG)\n+    return 0;\n+\n+  /* We must protect ourselves from matching pseudos that are virtual\n+     register, because they will eventually be replaced with hardware\n+     registers that aren't branch-target registers.  */\n+  if (REGNO (op) > LAST_VIRTUAL_REGISTER\n+      || TARGET_REGISTER_P (REGNO (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_special_predicate \"trunc_hi_operand\"\n+  (match_code \"subreg,reg,truncate\")\n+{\n+  enum machine_mode op_mode = GET_MODE (op);\n+\n+  if (op_mode != SImode && op_mode != DImode\n+      && op_mode != V4HImode && op_mode != V2SImode)\n+    return 0;\n+  return extend_reg_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"ua_address_operand\"\n+  (match_code \"subreg,reg,plus\")\n+{\n+  if (GET_CODE (op) == PLUS\n+      && (GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t  || ! CONST_OK_FOR_I06 (INTVAL (XEXP (op, 1)))))\n+    return 0;\n+  return address_operand (op, QImode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"ua_offset\"\n+  (match_code \"const_int\")\n+{\n+  return GET_CODE (op) == CONST_INT && CONST_OK_FOR_I06 (INTVAL (op));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"unary_float_operator\"\n+  (match_code \"abs,neg,sqrt\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case ABS:\n+    case NEG:\n+    case SQRT:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+})\n+\n+;; Return 1 if OP is a valid source operand for xor.\n+\n+(define_predicate \"xor_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return (TARGET_SHMEDIA\n+\t    ? (CONST_OK_FOR_I06 (INTVAL (op))\n+\t       || (no_new_pseudos && INTVAL (op) == 0xff))\n+\t    : CONST_OK_FOR_K08 (INTVAL (op)));\n+  if (TARGET_SHMEDIA\n+      && mode != DImode && GET_CODE (op) == SUBREG\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n+    return 0;\n+  return arith_reg_operand (op, mode);\n+})"}, {"sha": "91fa5e9ce5244b146bb580cdd2a26d56305012f2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 760, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5546ac90125a43c97fbeee00a38ceab9fd001aa3", "patch": "@@ -7550,301 +7550,6 @@ system_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Returns 1 if OP can be source of a simple move operation.\n-   Same as general_operand, but a LABEL_REF is valid, PRE_DEC is\n-   invalid as are subregs of system registers.  */\n-\n-int\n-general_movsrc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n-      if (GET_CODE (inside) == CONST)\n-\tinside = XEXP (inside, 0);\n-\n-      if (GET_CODE (inside) == LABEL_REF)\n-\treturn 1;\n-\n-      if (GET_CODE (inside) == PLUS\n-\t  && GET_CODE (XEXP (inside, 0)) == LABEL_REF\n-\t  && GET_CODE (XEXP (inside, 1)) == CONST_INT)\n-\treturn 1;\n-\n-      /* Only post inc allowed.  */\n-      if (GET_CODE (inside) == PRE_DEC)\n-\treturn 0;\n-    }\n-\n-  if ((mode == QImode || mode == HImode)\n-      && (GET_CODE (op) == SUBREG\n-\t  && GET_CODE (XEXP (op, 0)) == REG\n-\t  && system_reg_operand (XEXP (op, 0), mode)))\n-    return 0;\n-\n-  if (TARGET_SHMEDIA\n-      && (GET_CODE (op) == PARALLEL || GET_CODE (op) == CONST_VECTOR)\n-      && sh_rep_vec (op, mode))\n-    return 1;\n-  if (TARGET_SHMEDIA && 1\n-      && GET_CODE (op) == SUBREG && GET_MODE (op) == mode\n-      && SUBREG_REG (op) == const0_rtx && subreg_lowpart_p (op))\n-    /* FIXME */ abort (); /* return 1; */\n-  return general_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP can be a destination of a move.\n-   Same as general_operand, but no preinc allowed.  */\n-\n-int\n-general_movdst_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Only pre dec allowed.  */\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n-    return 0;\n-  if (mode == DImode && TARGET_SHMEDIA && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n-      && ! (high_life_started || reload_completed))\n-    return 0;\n-\n-  return general_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is a normal arithmetic register.  */\n-\n-int\n-arith_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    {\n-      int regno;\n-\n-      if (GET_CODE (op) == REG)\n-\tregno = REGNO (op);\n-      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n-\tregno = REGNO (SUBREG_REG (op));\n-      else\n-\treturn 1;\n-\n-      return (regno != T_REG && regno != PR_REG\n-\t      && ! TARGET_REGISTER_P (regno)\n-\t      && (regno != FPUL_REG || TARGET_SH4)\n-\t      && regno != MACH_REG && regno != MACL_REG);\n-    }\n-  /* Allow a no-op sign extension - compare LOAD_EXTEND_OP.\n-     We allow SImode here, as not using an FP register is just a matter of\n-     proper register allocation.  */\n-  if (TARGET_SHMEDIA\n-      && GET_MODE (op) == DImode && GET_CODE (op) == SIGN_EXTEND\n-      && GET_MODE (XEXP (op, 0)) == SImode\n-      && GET_CODE (XEXP (op, 0)) != SUBREG)\n-    return register_operand (XEXP (op, 0), VOIDmode);\n-#if 0 /* Can't do this because of PROMOTE_MODE for unsigned vars.  */\n-  if (GET_MODE (op) == SImode && GET_CODE (op) == SIGN_EXTEND\n-      && GET_MODE (XEXP (op, 0)) == HImode\n-      && GET_CODE (XEXP (op, 0)) == REG\n-      && REGNO (XEXP (op, 0)) <= LAST_GENERAL_REG)\n-    return register_operand (XEXP (op, 0), VOIDmode);\n-#endif\n-  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_INT\n-      && GET_CODE (op) == SUBREG\n-      && GET_MODE (SUBREG_REG (op)) == DImode\n-      && GET_CODE (SUBREG_REG (op)) == SIGN_EXTEND\n-      && GET_MODE (XEXP (SUBREG_REG (op), 0)) == SImode\n-      && GET_CODE (XEXP (SUBREG_REG (op), 0)) != SUBREG)\n-    return register_operand (XEXP (SUBREG_REG (op), 0), VOIDmode);\n-  return 0;\n-}\n-\n-/* Like above, but for DImode destinations: forbid paradoxical DImode subregs,\n-   because this would lead to missing sign extensions when truncating from\n-   DImode to SImode.  */\n-int\n-arith_reg_dest (rtx op, enum machine_mode mode)\n-{\n-  if (mode == DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n-      && TARGET_SHMEDIA)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-}\n-\n-/* Like arith_reg_operand, but for register source operands of narrow\n-  logical SHMEDIA operations: forbid subregs of DImode / TImode regs.  */\n-int\n-logical_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_SHMEDIA\n-      && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4\n-      && mode != DImode)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-}\n-\n-int\n-int_gpr_dest (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (GET_MODE_CLASS (op_mode) != MODE_INT\n-      || GET_MODE_SIZE (op_mode) >= UNITS_PER_WORD)\n-    return 0;\n-  if (! reload_completed)\n-    return 0;\n-  return true_regnum (op) <= LAST_GENERAL_REG;\n-}\n-\n-int\n-fp_arith_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    {\n-      int regno;\n-\n-      if (GET_CODE (op) == REG)\n-\tregno = REGNO (op);\n-      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n-\tregno = REGNO (SUBREG_REG (op));\n-      else\n-\treturn 1;\n-\n-      return (regno >= FIRST_PSEUDO_REGISTER\n-\t      || FP_REGISTER_P (regno));\n-    }\n-  return 0;\n-}\n-\n-int\n-fp_arith_reg_dest (rtx op, enum machine_mode mode)\n-{\n-  if (mode == DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8)\n-    return 0;\n-  return fp_arith_reg_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is a valid source operand for an arithmetic insn.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (TARGET_SHMEDIA)\n-    {\n-      /* FIXME: We should be checking whether the CONST_INT fits in a\n-\t CONST_OK_FOR_I16 here, but this causes reload_cse to crash when\n-\t attempting to transform a sequence of two 64-bit sets of the\n-\t same register from literal constants into a set and an add,\n-\t when the difference is too wide for an add.  */\n-      if (GET_CODE (op) == CONST_INT\n-\t  || EXTRA_CONSTRAINT_C16 (op))\n-\treturn 1;\n-      else if (GET_CODE (op) == TRUNCATE\n-\t       && ! system_reg_operand (XEXP (op, 0), VOIDmode)\n-\t       && (mode == VOIDmode || mode == GET_MODE (op))\n-\t       && (GET_MODE_SIZE (GET_MODE (op))\n-\t\t   < GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n-\t       && (! FP_REGISTER_P (REGNO (XEXP (op, 0)))\n-\t\t   || GET_MODE_SIZE (GET_MODE (op)) == 4))\n-\treturn register_operand (XEXP (op, 0), VOIDmode);\n-      else\n-\treturn 0;\n-    }\n-  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Returns 1 if OP is a valid source operand for a compare insn.  */\n-\n-int\n-arith_reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (EXTRA_CONSTRAINT_Z (op))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if OP is a valid source operand for xor.  */\n-\n-int\n-xor_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return (TARGET_SHMEDIA\n-\t    ? (CONST_OK_FOR_I06 (INTVAL (op))\n-\t       || (no_new_pseudos && INTVAL (op) == 0xff))\n-\t    : CONST_OK_FOR_K08 (INTVAL (op)));\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a valid source operand for shmedia cmpgt / cmpgtu.  */\n-int\n-cmp_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n-    return 1;\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-  return arith_reg_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is a valid source operand for a logical operation.  */\n-\n-int\n-logical_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_SHMEDIA\n-      && mode != DImode && GET_CODE (op) == SUBREG\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)\n-    return 0;\n-\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-\n-  if (TARGET_SHMEDIA)\n-    {\n-      if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I10 (INTVAL (op)))\n-\treturn 1;\n-      else\n-\treturn 0;\n-    }\n-  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K08 (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-int\n-and_operand (rtx op, enum machine_mode mode)\n-{\n-  if (logical_operand (op, mode))\n-    return 1;\n-\n-  /* Check mshflo.l / mshflhi.l opportunities.  */\n-  if (TARGET_SHMEDIA\n-      && mode == DImode\n-      && GET_CODE (op) == CONST_INT\n-      && CONST_OK_FOR_J16 (INTVAL (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Nonzero if OP is a floating point value with value 0.0.  */\n \n int\n@@ -7893,33 +7598,6 @@ tertiary_reload_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return code == MEM || (TARGET_SH4 && code == CONST_DOUBLE);\n }\n \n-int\n-fpscr_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) == FPSCR_REG\n-\t      || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t\t  && !(reload_in_progress || reload_completed)))\n-\t  && GET_MODE (op) == PSImode);\n-}\n-\n-int\n-fpul_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_SHMEDIA)\n-    return fp_arith_reg_operand (op, mode);\n-\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t  && GET_MODE (op) == mode);\n-}\n-\n-int\n-symbol_ref_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == SYMBOL_REF);\n-}\n-\n /* Return the TLS type for TLS symbols, 0 for otherwise.  */\n int\n tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -7928,366 +7606,6 @@ tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n     return 0;\n   return SYMBOL_REF_TLS_MODEL (op);\n }\n-\n-int\n-commutative_float_operator (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case PLUS:\n-    case MULT:\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-int\n-noncommutative_float_operator (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case MINUS:\n-    case DIV:\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-int\n-unary_float_operator (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case ABS:\n-    case NEG:\n-    case SQRT:\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-int\n-binary_float_operator (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case PLUS:\n-    case MINUS:\n-    case MULT:\n-    case DIV:\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-int\n-binary_logical_operator (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case IOR:\n-    case AND:\n-    case XOR:\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-int\n-equality_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));\n-}\n-\n-int\n-greater_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case GT:\n-    case GE:\n-    case GTU:\n-    case GEU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-int\n-less_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case LT:\n-    case LE:\n-    case LTU:\n-    case LEU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-int\n-shift_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-int\n-logical_operator (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Accept pseudos and branch target registers.  */\n-int\n-target_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode\n-     ? GET_MODE (op) != Pmode && GET_MODE (op) != PDImode\n-     : mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = XEXP (op, 0);\n-\n-  if (GET_CODE (op) != REG)\n-    return 0;\n-\n-  /* We must protect ourselves from matching pseudos that are virtual\n-     register, because they will eventually be replaced with hardware\n-     registers that aren't branch-target registers.  */\n-  if (REGNO (op) > LAST_VIRTUAL_REGISTER\n-      || TARGET_REGISTER_P (REGNO (op)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Same as target_reg_operand, except that label_refs and symbol_refs\n-   are accepted before reload.  */\n-int\n-target_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != Pmode)\n-    return 0;\n-\n-  if ((GET_MODE (op) == Pmode || GET_MODE (op) == VOIDmode)\n-      && EXTRA_CONSTRAINT_Csy (op))\n-    return ! reload_completed;\n-\n-  return target_reg_operand (op, mode);\n-}\n-\n-int\n-mextr_bit_offset (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT i;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  i = INTVAL (op);\n-  return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n-}\n-\n-int\n-extend_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == TRUNCATE\n-\t  ? arith_operand\n-\t  : arith_reg_operand) (op, mode);\n-}\n-\n-int\n-trunc_hi_operand (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (op_mode != SImode && op_mode != DImode\n-      && op_mode != V4HImode && op_mode != V2SImode)\n-    return 0;\n-  return extend_reg_operand (op, mode);\n-}\n-\n-int\n-extend_reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == TRUNCATE\n-\t  ? arith_operand\n-\t  : arith_reg_or_0_operand) (op, mode);\n-}\n-\n-int\n-minuend_operand (rtx op, enum machine_mode mode)\n-{\n-  return op == constm1_rtx || extend_reg_or_0_operand (op, mode);\n-}\n-\n-int\n-general_extend_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == TRUNCATE\n-\t  ? arith_operand\n-\t  : nonimmediate_operand) (op, mode);\n-}\n-\n-int\n-ua_address_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == PLUS\n-      && (GET_CODE (XEXP (op, 1)) != CONST_INT\n-\t  || ! CONST_OK_FOR_I06 (INTVAL (XEXP (op, 1)))))\n-    return 0;\n-  return address_operand (op, QImode);\n-}\n-\n-int\n-cache_address_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (op, 0)) != REG)\n-\treturn 0;\n-      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n-\t  || (INTVAL (XEXP (op, 1)) & 31))\n-\treturn 0;\n-    }\n-  else if (GET_CODE (op) != REG)\n-    return 0;\n-  return address_operand (op, mode);\n-}\n-\n-int\n-inqhi_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != TRUNCATE || mode != GET_MODE (op))\n-    return 0;\n-  op = XEXP (op, 0);\n-  /* Can't use true_regnum here because copy_cost wants to know about\n-     SECONDARY_INPUT_RELOAD_CLASS.  */\n-  return GET_CODE (op) == REG && FP_REGISTER_P (REGNO (op));\n-}\n-\n-int\n-sh_rep_vec (rtx v, enum machine_mode mode)\n-{\n-  int i;\n-  rtx x, y;\n-\n-  if ((GET_CODE (v) != CONST_VECTOR && GET_CODE (v) != PARALLEL)\n-      || (GET_MODE (v) != mode && mode != VOIDmode))\n-    return 0;\n-  i = XVECLEN (v, 0) - 2;\n-  x = XVECEXP (v, 0, i + 1);\n-  if (GET_MODE_UNIT_SIZE (mode) == 1)\n-    {\n-      y = XVECEXP (v, 0, i);\n-      for (i -= 2; i >= 0; i -= 2)\n-\tif (! rtx_equal_p (XVECEXP (v, 0, i + 1), x)\n-\t    || ! rtx_equal_p (XVECEXP (v, 0, i), y))\n-\t  return 0;\n-    }\n-  else\n-    for (; i >= 0; i--)\n-      if (XVECEXP (v, 0, i) != x)\n-\treturn 0;\n-  return 1;\n-}\n-\n-/* Determine if V is a constant vector matching MODE with only one element\n-   that is not a sign extension.  Two byte-sized elements count as one.  */\n-int\n-sh_1el_vec (rtx v, enum machine_mode mode)\n-{\n-  int unit_size;\n-  int i, last, least, sign_ix;\n-  rtx sign;\n-\n-  if (GET_CODE (v) != CONST_VECTOR\n-      || (GET_MODE (v) != mode && mode != VOIDmode))\n-    return 0;\n-  /* Determine numbers of last and of least significant elements.  */\n-  last = XVECLEN (v, 0) - 1;\n-  least = TARGET_LITTLE_ENDIAN ? 0 : last;\n-  if (GET_CODE (XVECEXP (v, 0, least)) != CONST_INT)\n-    return 0;\n-  sign_ix = least;\n-  if (GET_MODE_UNIT_SIZE (mode) == 1)\n-    sign_ix = TARGET_LITTLE_ENDIAN ? 1 : last - 1;\n-  if (GET_CODE (XVECEXP (v, 0, sign_ix)) != CONST_INT)\n-    return 0;\n-  unit_size = GET_MODE_UNIT_SIZE (GET_MODE (v));\n-  sign = (INTVAL (XVECEXP (v, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n-\t  ? constm1_rtx : const0_rtx);\n-  i = XVECLEN (v, 0) - 1;\n-  do\n-    if (i != least && i != sign_ix && XVECEXP (v, 0, i) != sign)\n-      return 0;\n-  while (--i);\n-  return 1;\n-}\n-\n-int\n-sh_const_vec (rtx v, enum machine_mode mode)\n-{\n-  int i;\n-\n-  if (GET_CODE (v) != CONST_VECTOR\n-      || (GET_MODE (v) != mode && mode != VOIDmode))\n-    return 0;\n-  i = XVECLEN (v, 0) - 1;\n-  for (; i >= 0; i--)\n-    if (GET_CODE (XVECEXP (v, 0, i)) != CONST_INT)\n-      return 0;\n-  return 1;\n-}\n \f\n /* Return the destination address of a branch.  */\n \n@@ -8799,12 +8117,6 @@ mark_constant_pool_use (rtx x)\n \n   return lab;\n }\n-\n-int\n-ua_offset (rtx c, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (c) == CONST_INT && CONST_OK_FOR_I06 (INTVAL (c));\n-}\n \f\n /* Return true if it's possible to redirect BRANCH1 to the destination\n    of an unconditional jump BRANCH2.  We only want to do this if the\n@@ -10088,57 +9400,6 @@ sh_register_move_cost (enum machine_mode mode,\n   return 2 * ((GET_MODE_SIZE (mode) + 3) / 4U);\n }\n \n-/* Like register_operand, but take into account that SHMEDIA can use\n-   the constant zero like a general register.  */\n-int\n-sh_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (op == CONST0_RTX (mode) && TARGET_SHMEDIA)\n-    return 1;\n-  return register_operand (op, mode);\n-}\n-\n-int\n-cmpsi_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG && REGNO (op) == T_REG\n-      && GET_MODE (op) == SImode\n-      && TARGET_SH1)\n-    return 1;\n-  return arith_operand (op, mode);\n-}\n-\n-int\n-shift_count_reg_operand (rtx op, enum machine_mode mode)\n-{\n-  if ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n-       || (GET_CODE (op) == SUBREG && SUBREG_BYTE (op) == 0))\n-      && (mode == VOIDmode || mode == GET_MODE (op))\n-      && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n-      && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT)\n-    {\n-      mode = VOIDmode;\n-      do\n-\top = XEXP (op, 0);\n-      while ((GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND\n-\t      || GET_CODE (op) == TRUNCATE)\n-\t     && GET_MODE_BITSIZE (GET_MODE (XEXP (op, 0))) >= 6\n-\t     && GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_INT);\n-\n-    }\n-  return arith_reg_operand (op, mode);\n-}\n-\n-int\n-shift_count_operand (rtx op, enum machine_mode mode)\n-{\n-  return (CONSTANT_P (op)\n-\t  ? (GET_CODE (op) == CONST_INT\n-\t     ? (unsigned) INTVAL (op) < GET_MODE_BITSIZE (mode)\n-\t     : nonmemory_operand (op, mode))\n-\t  : shift_count_reg_operand (op, mode));\n-}\n-\n static rtx emit_load_ptr (rtx, rtx);\n \n static rtx\n@@ -10541,27 +9802,6 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n   gcc_unreachable ();\n }\n \n-/* Returns 1 if OP is a MEM that can be source of a simple move operation.  */\n-\n-int\n-unaligned_load_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx inside;\n-\n-  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n-    return 0;\n-\n-  inside = XEXP (op, 0);\n-\n-  if (GET_CODE (inside) == POST_INC)\n-    inside = XEXP (inside, 0);\n-\n-  if (GET_CODE (inside) == REG)\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* This function returns a constant rtx that represents pi / 2**15 in\n    SFmode.  it's used to scale SFmode angles, in radians, to a\n    fixed-point signed 16.16-bit fraction of a full circle, i.e., 2*pi"}, {"sha": "e194759d388eab888bbef5844cc1df12abe3f0a7", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5546ac90125a43c97fbeee00a38ceab9fd001aa3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=5546ac90125a43c97fbeee00a38ceab9fd001aa3", "patch": "@@ -3246,73 +3246,6 @@ extern struct rtx_def *sp_switch;\n #define ADJUST_INSN_LENGTH(X, LENGTH)\t\t\t\t\\\n   (LENGTH) += sh_insn_length_adjustment (X);\n \f\n-/* Define the codes that are matched by predicates in sh.c.  */\n-#define PREDICATE_CODES \\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"any_arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"any_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"arith_reg_operand\", {SUBREG, REG, SIGN_EXTEND}},\t\t\t\\\n-  {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_VECTOR}},\t\\\n-  {\"binary_float_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n-  {\"binary_logical_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n-  {\"cache_address_operand\", {PLUS, REG}},\t\t\t\t\\\n-  {\"cmp_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"cmpsi_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n-  {\"equality_comparison_operator\", {EQ,NE}},\t\t\t\t\\\n-  {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\n-  {\"extend_reg_or_0_operand\", {SUBREG, REG, TRUNCATE, CONST_INT}},\t\\\n-  {\"ext_dest_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"fp_arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"fp_arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"fpscr_operand\", {REG}},\t\t\t\t\t\t\\\n-  {\"fpul_operand\", {REG}},\t\t\t\t\t\t\\\n-  {\"general_extend_operand\", {SUBREG, REG, MEM, TRUNCATE}},\t\t\\\n-  {\"general_movsrc_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM, CONST }}, \\\n-  {\"general_movdst_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"unaligned_load_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"greater_comparison_operator\", {GT,GE,GTU,GEU}},\t\t\t\\\n-  {\"inqhi_operand\", {TRUNCATE}},\t\t\t\t\t\\\n-  {\"int_gpr_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"less_comparison_operator\", {LT,LE,LTU,LEU}},\t\t\t\\\n-  {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"logical_operator\", {AND,IOR,XOR}},\t\t\t\t\t\\\n-  {\"logical_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"mextr_bit_offset\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"minuend_operand\", {SUBREG, REG, TRUNCATE, CONST_INT}},\t\t\\\n-  {\"noncommutative_float_operator\", {MINUS, DIV}},\t\t\t\\\n-  {\"sh_const_vec\", {CONST_VECTOR}},\t\t\t\t\t\\\n-  {\"sh_1el_vec\", {CONST_VECTOR}},\t\t\t\t\t\\\n-  {\"sh_register_operand\", {REG, SUBREG, CONST_INT}},\t\t\t\\\n-  {\"sh_rep_vec\", {CONST_VECTOR}},\t\t\t\t\t\\\n-  {\"shift_count_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, ZERO_EXTEND, SIGN_EXTEND}},\\\n-  {\"shift_count_reg_operand\", {SUBREG, REG, ZERO_EXTEND, SIGN_EXTEND}},\t\\\n-  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT}},\t\t\t\\\n-  {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-  {\"target_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF, CONST, UNSPEC}},\\\n-  {\"target_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"trunc_hi_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\n-  {\"ua_address_operand\", {SUBREG, REG, PLUS}},\t\t\t\t\\\n-  {\"ua_offset\", {CONST_INT}},\t\t\t\t\t\t\\\n-  {\"unary_float_operator\", {ABS, NEG, SQRT}},\t\t\t\t\\\n-  {\"xor_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-\n-#define SPECIAL_MODE_PREDICATES \\\n-  \"any_arith_reg_dest\", \\\n-  \"any_register_operand\", \\\n-  \"int_gpr_dest\", \\\n-  \"target_operand\", \\\n-  \"target_reg_operand\", \\\n-  \"trunc_hi_operand\", \\\n-  /* This line intentionally left blank.  */\n-\n-#define any_register_operand register_operand\n-#define any_arith_reg_dest arith_reg_dest\n-#define ext_dest_operand arith_reg_operand\n-\n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared"}]}