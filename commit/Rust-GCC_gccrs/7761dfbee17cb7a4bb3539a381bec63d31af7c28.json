{"sha": "7761dfbee17cb7a4bb3539a381bec63d31af7c28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2MWRmYmVlMTdjYjdhNGJiMzUzOWEzODFiZWM2M2QzMWFmN2MyOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-04-30T15:01:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-04-30T15:01:56Z"}, "message": "Use char_span for return type of location_get_source_line\n\nlocation_get_source_line returns a const char * that isn't 0-terminated,\nwriting back a length through an int * param.\n\nThis is error-prone, as all call-sites have to take into account the\nlack of 0-termination, and respect the length of the buffer.\n\nIt's cleaner to bundle together this pointer+length state into a class,\nso this patch does so, reusing the \"char_span\" class that I introduced\nin r250187 (as part of the fix for PR c/81405).\n\nThe patch also adds assertions to all access to the char_span.\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (get_corrected_substring): Update for\n\tlocation_get_source_line returning a char_span.  Use a char_span\n\twhen handling the prefix of the correction.\n\t* c-indentation.c (get_visual_column): Update for\n\tlocation_get_source_line returning a char_span.\n\t(get_first_nws_vis_column): Likewise.\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c (layout::layout): Update for\n\tlocation_get_source_line returning a char_span.\n\t(struct char_span): Move to input.h.\n\t(struct correction): Update for fields in char_span becoming\n\tprivate.\n\t(struct source_line): Update for location_get_source_line\n\treturning a char_span.\n\t(layout::print_line): Likewise.\n\t* edit-context.c (edited_file::print_content): Likewise.\n\t(edited_file::print_diff_hunk): Likewise.\n\t(edited_file::print_run_of_changed_lines): Likewise.\n\t(edited_file::get_num_lines): Likewise.\n\t(edited_line::edited_line): Likewise.\n\t* final.c (asm_show_source): Likewise.\n\t* input.c (location_get_source_line): Convert return type\n\tfrom const char * to char_span, losing the final \"line_len\"\n\tparam.\n\t(dump_location_info): Update for the above.\n\t(get_substring_ranges_for_loc): Likewise.  Use a char_span\n\twhen handling the literal within the line.\n\t(test_reading_source_line): Update for location_get_source_line\n\treturning a char_span.\n\t* input.h (class char_span): Move here from\n\tdiagnostic-show-locus.c, converting from a struct to a class.\n\tMake data members private.\n\t(char_span::operator bool): New.\n\t(char_span::length): New.\n\t(char_span::get_buffer): New.\n\t(char_span::operator[]): New.\n\t(char_span::subspan): Make const.\n\t(char_span::xstrdup): New.\n\t(location_get_source_line): Convert return type from const char *\n\tto char_span, losing the final \"line_size\" param.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n\t(test_show_locus): Update for location_get_source_line returning a\n\tchar_span.  Use char_span for handling words in the\n\t\"test_many_nested_locations\" fix-it example.\n\nFrom-SVN: r259768", "tree": {"sha": "e583063e82b23bf43e882069fe4de7790d5e078d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e583063e82b23bf43e882069fe4de7790d5e078d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7761dfbee17cb7a4bb3539a381bec63d31af7c28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7761dfbee17cb7a4bb3539a381bec63d31af7c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7761dfbee17cb7a4bb3539a381bec63d31af7c28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7761dfbee17cb7a4bb3539a381bec63d31af7c28/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e33d73d8aa1b7965d6b2bf08b5bbd673e63284"}], "stats": {"total": 299, "additions": 176, "deletions": 123}, "files": [{"sha": "74ac8b441f1ebbe2112684ae629ae06faf7ac0bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -1,3 +1,39 @@\n+2018-04-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c (layout::layout): Update for\n+\tlocation_get_source_line returning a char_span.\n+\t(struct char_span): Move to input.h.\n+\t(struct correction): Update for fields in char_span becoming\n+\tprivate.\n+\t(struct source_line): Update for location_get_source_line\n+\treturning a char_span.\n+\t(layout::print_line): Likewise.\n+\t* edit-context.c (edited_file::print_content): Likewise.\n+\t(edited_file::print_diff_hunk): Likewise.\n+\t(edited_file::print_run_of_changed_lines): Likewise.\n+\t(edited_file::get_num_lines): Likewise.\n+\t(edited_line::edited_line): Likewise.\n+\t* final.c (asm_show_source): Likewise.\n+\t* input.c (location_get_source_line): Convert return type\n+\tfrom const char * to char_span, losing the final \"line_len\"\n+\tparam.\n+\t(dump_location_info): Update for the above.\n+\t(get_substring_ranges_for_loc): Likewise.  Use a char_span\n+\twhen handling the literal within the line.\n+\t(test_reading_source_line): Update for location_get_source_line\n+\treturning a char_span.\n+\t* input.h (class char_span): Move here from\n+\tdiagnostic-show-locus.c, converting from a struct to a class.\n+\tMake data members private.\n+\t(char_span::operator bool): New.\n+\t(char_span::length): New.\n+\t(char_span::get_buffer): New.\n+\t(char_span::operator[]): New.\n+\t(char_span::subspan): Make const.\n+\t(char_span::xstrdup): New.\n+\t(location_get_source_line): Convert return type from const char *\n+\tto char_span, losing the final \"line_size\" param.\n+\n 2018-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-wrapper.c (ltrans_priorities): New static var."}, {"sha": "ab85a73bd1b5983242ba924125036263ed94979f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -1,3 +1,12 @@\n+2018-04-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (get_corrected_substring): Update for\n+\tlocation_get_source_line returning a char_span.  Use a char_span\n+\twhen handling the prefix of the correction.\n+\t* c-indentation.c (get_visual_column): Update for\n+\tlocation_get_source_line returning a char_span.\n+\t(get_first_nws_vis_column): Likewise.\n+\n 2018-03-29  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/84269"}, {"sha": "ee7c33d97f2291756b201bb286082d297ce3e67f", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -3499,10 +3499,8 @@ get_corrected_substring (const substring_loc &fmt_loc,\n   if (caret.column > finish.column)\n     return NULL;\n \n-  int line_width;\n-  const char *line = location_get_source_line (start.file, start.line,\n-\t\t\t\t\t       &line_width);\n-  if (line == NULL)\n+  char_span line = location_get_source_line (start.file, start.line);\n+  if (!line)\n     return NULL;\n \n   /* If we got this far, then we have the line containing the\n@@ -3511,9 +3509,9 @@ get_corrected_substring (const substring_loc &fmt_loc,\n      Generate a trimmed copy, containing the prefix part of the conversion\n      specification, up to the (but not including) the length modifier.\n      In the above example, this would be \"%-+*.*\".  */\n-  const char *current_content = line + start.column - 1;\n   int length_up_to_type = caret.column - start.column;\n-  char *prefix = xstrndup (current_content, length_up_to_type);\n+  char_span prefix_span = line.subspan (start.column - 1, length_up_to_type);\n+  char *prefix = prefix_span.xstrdup ();\n \n   /* Now attempt to generate a suggestion for the rest of the specification\n      (length modifier and conversion char), based on ARG_TYPE and"}, {"sha": "44b1e1e361f7336626e5c090cdb733bbf81db53f", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -70,9 +70,7 @@ get_visual_column (expanded_location exploc, location_t loc,\n       return false;\n     }\n \n-  int line_len;\n-  const char *line = location_get_source_line (exploc.file, exploc.line,\n-\t\t\t\t\t       &line_len);\n+  char_span line = location_get_source_line (exploc.file, exploc.line);\n   if (!line)\n     return false;\n   unsigned int vis_column = 0;\n@@ -112,12 +110,11 @@ get_first_nws_vis_column (const char *file, int line_num,\n {\n   gcc_assert (first_nws);\n \n-  int line_len;\n-  const char *line = location_get_source_line (file, line_num, &line_len);\n+  char_span line = location_get_source_line (file, line_num);\n   if (!line)\n     return false;\n   unsigned int vis_column = 0;\n-  for (int i = 1; i < line_len; i++)\n+  for (size_t i = 1; i < line.length (); i++)\n     {\n       unsigned char ch = line[i - 1];\n "}, {"sha": "f188ee9938b48b05d9d82215b3421f6bea745957", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -857,17 +857,15 @@ layout::layout (diagnostic_context * context,\n   /* Adjust m_x_offset.\n      Center the primary caret to fit in max_width; all columns\n      will be adjusted accordingly.  */\n-  int max_width = m_context->caret_max_width;\n-  int line_width;\n-  const char *line = location_get_source_line (m_exploc.file, m_exploc.line,\n-\t\t\t\t\t       &line_width);\n-  if (line && m_exploc.column <= line_width)\n+  size_t max_width = m_context->caret_max_width;\n+  char_span line = location_get_source_line (m_exploc.file, m_exploc.line);\n+  if (line && (size_t)m_exploc.column <= line.length ())\n     {\n-      int right_margin = CARET_LINE_MARGIN;\n-      int column = m_exploc.column;\n-      right_margin = MIN (line_width - column, right_margin);\n+      size_t right_margin = CARET_LINE_MARGIN;\n+      size_t column = m_exploc.column;\n+      right_margin = MIN (line.length () - column, right_margin);\n       right_margin = max_width - right_margin;\n-      if (line_width >= max_width && column > right_margin)\n+      if (line.length () >= max_width && column > right_margin)\n \tm_x_offset = column - right_margin;\n       gcc_assert (m_x_offset >= 0);\n     }\n@@ -1483,26 +1481,6 @@ get_printed_columns (const fixit_hint *hint)\n     }\n }\n \n-/* A struct capturing the bounds of a buffer, to allow for run-time\n-   bounds-checking in a checked build.  */\n-\n-struct char_span\n-{\n-  char_span (const char *ptr, size_t n_elts) : m_ptr (ptr), m_n_elts (n_elts) {}\n-\n-  char_span subspan (int offset, int n_elts)\n-  {\n-    gcc_assert (offset >= 0);\n-    gcc_assert (offset < (int)m_n_elts);\n-    gcc_assert (n_elts >= 0);\n-    gcc_assert (offset + n_elts <= (int)m_n_elts);\n-    return char_span (m_ptr + offset, n_elts);\n-  }\n-\n-  const char *m_ptr;\n-  size_t m_n_elts;\n-};\n-\n /* A correction on a particular line.\n    This describes a plan for how to print one or more fixit_hint\n    instances that affected the line, potentially consolidating hints\n@@ -1534,9 +1512,9 @@ struct correction\n   void overwrite (int dst_offset, const char_span &src_span)\n   {\n     gcc_assert (dst_offset >= 0);\n-    gcc_assert (dst_offset + src_span.m_n_elts < m_alloc_sz);\n-    memcpy (m_text + dst_offset, src_span.m_ptr,\n-\t    src_span.m_n_elts);\n+    gcc_assert (dst_offset + src_span.length () < m_alloc_sz);\n+    memcpy (m_text + dst_offset, src_span.get_buffer (),\n+\t    src_span.length ());\n   }\n \n   /* If insert, then start: the column before which the text\n@@ -1627,7 +1605,9 @@ struct source_line\n \n source_line::source_line (const char *filename, int line)\n {\n-  chars = location_get_source_line (filename, line, &width);\n+  char_span span = location_get_source_line (filename, line);\n+  chars = span.get_buffer ();\n+  width = span.length ();\n }\n \n /* Add HINT to the corrections for this line.\n@@ -1935,15 +1915,13 @@ layout::show_ruler (int max_column) const\n void\n layout::print_line (linenum_type row)\n {\n-  int line_width;\n-  const char *line = location_get_source_line (m_exploc.file, row,\n-\t\t\t\t\t       &line_width);\n+  char_span line = location_get_source_line (m_exploc.file, row);\n   if (!line)\n     return;\n \n   line_bounds lbounds;\n   print_leading_fixits (row);\n-  print_source_line (row, line, line_width, &lbounds);\n+  print_source_line (row, line.get_buffer (), line.length (), &lbounds);\n   if (should_print_annotation_line_p (row))\n     print_annotation_line (row, lbounds);\n   print_trailing_fixits (row);"}, {"sha": "3cdb88d565cebaf615929a1461e8e97a0e8cee23", "filename": "gcc/edit-context.c", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fedit-context.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Fedit-context.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -422,12 +422,10 @@ edited_file::print_content (pretty_printer *pp)\n \tel->print_content (pp);\n       else\n \t{\n-\t  int len;\n-\t  const char *line\n-\t    = location_get_source_line (m_filename, line_num, &len);\n+\t  char_span line = location_get_source_line (m_filename, line_num);\n \t  if (!line)\n \t    return false;\n-\t  for (int i = 0; i < len; i++)\n+\t  for (size_t i = 0; i < line.length (); i++)\n \t    pp_character (pp, line[i]);\n \t}\n       if (line_num < line_count)\n@@ -543,10 +541,8 @@ edited_file::print_diff_hunk (pretty_printer *pp, int old_start_of_hunk,\n       else\n \t{\n \t  /* Unchanged line.  */\n-\t  int line_len;\n-\t  const char *old_line\n-\t    = location_get_source_line (m_filename, line_num, &line_len);\n-\t  print_diff_line (pp, ' ', old_line, line_len);\n+\t  char_span old_line = location_get_source_line (m_filename, line_num);\n+\t  print_diff_line (pp, ' ', old_line.get_buffer (), old_line.length ());\n \t  line_num++;\n \t}\n     }\n@@ -574,10 +570,9 @@ edited_file::print_run_of_changed_lines (pretty_printer *pp,\n       gcc_assert (el_in_run);\n       if (el_in_run->actually_edited_p ())\n \t{\n-\t  int line_len;\n-\t  const char *old_line\n-\t    = location_get_source_line (m_filename, line_num, &line_len);\n-\t  print_diff_line (pp, '-', old_line, line_len);\n+\t  char_span old_line = location_get_source_line (m_filename, line_num);\n+\t  print_diff_line (pp, '-', old_line.get_buffer (),\n+\t\t\t   old_line.length ());\n \t}\n     }\n   pp_string (pp, colorize_stop (pp_show_color (pp)));\n@@ -671,10 +666,8 @@ edited_file::get_num_lines (bool *missing_trailing_newline)\n       m_num_lines = 0;\n       while (true)\n \t{\n-\t  int line_size;\n-\t  const char *line\n-\t    = location_get_source_line (m_filename, m_num_lines + 1,\n-\t\t\t\t\t&line_size);\n+\t  char_span line\n+\t    = location_get_source_line (m_filename, m_num_lines + 1);\n \t  if (line)\n \t    m_num_lines++;\n \t  else\n@@ -695,12 +688,12 @@ edited_line::edited_line (const char *filename, int line_num)\n   m_line_events (),\n   m_predecessors ()\n {\n-  const char *line = location_get_source_line (filename, line_num,\n-\t\t\t\t\t       &m_len);\n+  char_span line = location_get_source_line (filename, line_num);\n   if (!line)\n     return;\n+  m_len = line.length ();\n   ensure_capacity (m_len);\n-  memcpy (m_content, line, m_len);\n+  memcpy (m_content, line.get_buffer (), m_len);\n   ensure_terminated ();\n }\n "}, {"sha": "4c600f0edf2b533fa0a8697368bb37e3308f8508", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -2216,14 +2216,13 @@ asm_show_source (const char *filename, int linenum)\n   if (!filename)\n     return;\n \n-  int line_size;\n-  const char *line = location_get_source_line (filename, linenum, &line_size);\n+  char_span line = location_get_source_line (filename, linenum);\n   if (!line)\n     return;\n \n   fprintf (asm_out_file, \"%s %s:%i: \", ASM_COMMENT_START, filename, linenum);\n-  /* \"line\" is not 0-terminated, so we must use line_size.  */\n-  fwrite (line, 1, line_size, asm_out_file);\n+  /* \"line\" is not 0-terminated, so we must use its length.  */\n+  fwrite (line.get_buffer (), 1, line.length (), asm_out_file);\n   fputc ('\\n', asm_out_file);\n }\n "}, {"sha": "d65a82dc26eac4b087acb7fd9b8edff9060761f9", "filename": "gcc/input.c", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -741,29 +741,27 @@ read_line_num (fcache *c, size_t line_num,\n    The line is not nul-terminated.  The returned pointer is only\n    valid until the next call of location_get_source_line.\n    Note that the line can contain several null characters,\n-   so LINE_LEN, if non-null, points to the actual length of the line.\n-   If the function fails, NULL is returned.  */\n+   so the returned value's length has the actual length of the line.\n+   If the function fails, a NULL char_span is returned.  */\n \n-const char *\n-location_get_source_line (const char *file_path, int line,\n-\t\t\t  int *line_len)\n+char_span\n+location_get_source_line (const char *file_path, int line)\n {\n   char *buffer = NULL;\n   ssize_t len;\n \n   if (line == 0)\n-    return NULL;\n+    return char_span (NULL, 0);\n \n   fcache *c = lookup_or_add_file_to_cache_tab (file_path);\n   if (c == NULL)\n-    return NULL;\n+    return char_span (NULL, 0);\n \n   bool read = read_line_num (c, line, &buffer, &len);\n+  if (!read)\n+    return char_span (NULL, 0);\n \n-  if (read && line_len)\n-    *line_len = len;\n-\n-  return read ? buffer : NULL;\n+  return char_span (buffer, len);\n }\n \n /* Determine if FILE_PATH missing a trailing newline on its final line.\n@@ -1121,25 +1119,23 @@ dump_location_info (FILE *stream)\n \t    {\n \t      /* Beginning of a new source line: draw the line.  */\n \n-\t      int line_size;\n-\t      const char *line_text = location_get_source_line (exploc.file,\n-\t\t\t\t\t\t\t\texploc.line,\n-\t\t\t\t\t\t\t\t&line_size);\n+\t      char_span line_text = location_get_source_line (exploc.file,\n+\t\t\t\t\t\t\t      exploc.line);\n \t      if (!line_text)\n \t\tbreak;\n \t      fprintf (stream,\n \t\t       \"%s:%3i|loc:%5i|%.*s\\n\",\n \t\t       exploc.file, exploc.line,\n \t\t       loc,\n-\t\t       line_size, line_text);\n+\t\t       (int)line_text.length (), line_text.get_buffer ());\n \n \t      /* \"loc\" is at column 0, which means \"the whole line\".\n \t\t Render the locations *within* the line, by underlining\n \t\t it, showing the source_location numeric values\n \t\t at each column.  */\n-\t      int max_col = (1 << map->m_column_and_range_bits) - 1;\n-\t      if (max_col > line_size)\n-\t\tmax_col = line_size + 1;\n+\t      size_t max_col = (1 << map->m_column_and_range_bits) - 1;\n+\t      if (max_col > line_text.length ())\n+\t\tmax_col = line_text.length () + 1;\n \n \t      int indent = 14 + strlen (exploc.file);\n \n@@ -1426,28 +1422,27 @@ get_substring_ranges_for_loc (cpp_reader *pfile,\n       if (start.column > finish.column)\n \treturn \"range endpoints are reversed\";\n \n-      int line_width;\n-      const char *line = location_get_source_line (start.file, start.line,\n-\t\t\t\t\t\t   &line_width);\n-      if (line == NULL)\n+      char_span line = location_get_source_line (start.file, start.line);\n+      if (!line)\n \treturn \"unable to read source line\";\n \n       /* Determine the location of the literal (including quotes\n \t and leading prefix chars, such as the 'u' in a u\"\"\n \t token).  */\n-      const char *literal = line + start.column - 1;\n-      int literal_length = finish.column - start.column + 1;\n+      size_t literal_length = finish.column - start.column + 1;\n \n       /* Ensure that we don't crash if we got the wrong location.  */\n-      if (line_width < (start.column - 1 + literal_length))\n+      if (line.length () < (start.column - 1 + literal_length))\n \treturn \"line is not wide enough\";\n \n+      char_span literal = line.subspan (start.column - 1, literal_length);\n+\n       cpp_string from;\n       from.len = literal_length;\n       /* Make a copy of the literal, to avoid having to rely on\n \t the lifetime of the copy of the line within the cache.\n \t This will be released by the auto_cpp_string_vec dtor.  */\n-      from.text = XDUPVEC (unsigned char, literal, literal_length);\n+      from.text = (unsigned char *)literal.xstrdup ();\n       strs.safe_push (from);\n \n       /* For very long lines, a new linemap could have started\n@@ -1908,24 +1903,23 @@ test_reading_source_line ()\n \t\t\t\"This is the 3rd line\");\n \n   /* Read back a specific line from the tempfile.  */\n-  int line_size;\n-  const char *source_line = location_get_source_line (tmp.get_filename (),\n-\t\t\t\t\t\t      3, &line_size);\n-  ASSERT_TRUE (source_line != NULL);\n-  ASSERT_EQ (20, line_size);\n+  char_span source_line = location_get_source_line (tmp.get_filename (), 3);\n+  ASSERT_TRUE (source_line);\n+  ASSERT_TRUE (source_line.get_buffer () != NULL);\n+  ASSERT_EQ (20, source_line.length ());\n   ASSERT_TRUE (!strncmp (\"This is the 3rd line\",\n-\t\t\t source_line, line_size));\n+\t\t\t source_line.get_buffer (), source_line.length ()));\n \n-  source_line = location_get_source_line (tmp.get_filename (),\n-\t\t\t\t\t  2, &line_size);\n-  ASSERT_TRUE (source_line != NULL);\n-  ASSERT_EQ (21, line_size);\n+  source_line = location_get_source_line (tmp.get_filename (), 2);\n+  ASSERT_TRUE (source_line);\n+  ASSERT_TRUE (source_line.get_buffer () != NULL);\n+  ASSERT_EQ (21, source_line.length ());\n   ASSERT_TRUE (!strncmp (\"This is the test text\",\n-\t\t\t source_line, line_size));\n+\t\t\t source_line.get_buffer (), source_line.length ()));\n \n-  source_line = location_get_source_line (tmp.get_filename (),\n-\t\t\t\t\t  4, &line_size);\n-  ASSERT_TRUE (source_line == NULL);\n+  source_line = location_get_source_line (tmp.get_filename (), 4);\n+  ASSERT_FALSE (source_line);\n+  ASSERT_TRUE (source_line.get_buffer () == NULL);\n }\n \n /* Tests of lexing.  */"}, {"sha": "4619663519a46ebc93f0d1e407f8908104873534", "filename": "gcc/input.h", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -38,8 +38,52 @@ STATIC_ASSERT (BUILTINS_LOCATION < RESERVED_LOCATION_COUNT);\n \n extern bool is_location_from_builtin_token (source_location);\n extern expanded_location expand_location (source_location);\n-extern const char *location_get_source_line (const char *file_path, int line,\n-\t\t\t\t\t     int *line_size);\n+\n+/* A class capturing the bounds of a buffer, to allow for run-time\n+   bounds-checking in a checked build.  */\n+\n+class char_span\n+{\n+ public:\n+  char_span (const char *ptr, size_t n_elts) : m_ptr (ptr), m_n_elts (n_elts) {}\n+\n+  /* Test for a non-NULL pointer.  */\n+  operator bool() const { return m_ptr; }\n+\n+  /* Get length, not including any 0-terminator (which may not be,\n+     in fact, present).  */\n+  size_t length () const { return m_n_elts; }\n+\n+  const char *get_buffer () const { return m_ptr; }\n+\n+  char operator[] (int idx) const\n+  {\n+    gcc_assert (idx >= 0);\n+    gcc_assert ((size_t)idx < m_n_elts);\n+    return m_ptr[idx];\n+  }\n+\n+  char_span subspan (int offset, int n_elts) const\n+  {\n+    gcc_assert (offset >= 0);\n+    gcc_assert (offset < (int)m_n_elts);\n+    gcc_assert (n_elts >= 0);\n+    gcc_assert (offset + n_elts <= (int)m_n_elts);\n+    return char_span (m_ptr + offset, n_elts);\n+  }\n+\n+  char *xstrdup () const\n+  {\n+    return ::xstrndup (m_ptr, m_n_elts);\n+  }\n+\n+ private:\n+  const char *m_ptr;\n+  size_t m_n_elts;\n+};\n+\n+extern char_span location_get_source_line (const char *file_path, int line);\n+\n extern bool location_missing_trailing_newline (const char *file_path);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);"}, {"sha": "557ac8db20f0564dbdb5295a1edd42dfd0398ce8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -1,3 +1,10 @@\n+2018-04-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n+\t(test_show_locus): Update for location_get_source_line returning a\n+\tchar_span.  Use char_span for handling words in the\n+\t\"test_many_nested_locations\" fix-it example.\n+\n 2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* gcc.target/arc/interrupt-8.c: Update test."}, {"sha": "dabc0e421307d3a9a332f868725adba7ef8b1600", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7761dfbee17cb7a4bb3539a381bec63d31af7c28/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=7761dfbee17cb7a4bb3539a381bec63d31af7c28", "patch": "@@ -377,19 +377,17 @@ test_show_locus (function *fun)\n       rich_location richloc (line_table, loc);\n       for (int line = start_line; line <= finish_line; line++)\n \t{\n-\t  int line_size;\n-\t  const char *content = location_get_source_line (file, line,\n-\t\t\t\t\t\t\t  &line_size);\n+\t  char_span content = location_get_source_line (file, line);\n \t  gcc_assert (content);\n \t  /* Split line up into words.  */\n-\t  for (int idx = 0; idx < line_size; idx++)\n+\t  for (int idx = 0; idx < content.length (); idx++)\n \t    {\n \t      if (ISALPHA (content[idx]))\n \t\t{\n \t\t  int start_idx = idx;\n-\t\t  while (idx < line_size && ISALPHA (content[idx]))\n+\t\t  while (idx < content.length () && ISALPHA (content[idx]))\n \t\t    idx++;\n-\t\t  if (idx == line_size || !ISALPHA (content[idx]))\n+\t\t  if (idx == content.length () || !ISALPHA (content[idx]))\n \t\t    {\n \t\t      location_t start_of_word = get_loc (line, start_idx);\n \t\t      location_t end_of_word = get_loc (line, idx - 1);\n@@ -399,8 +397,8 @@ test_show_locus (function *fun)\n \t\t      richloc.add_range (word, true);\n \n \t\t      /* Add a fixit, converting to upper case.  */\n-\t\t      char *copy = xstrndup (content + start_idx,\n-\t\t\t\t\t     idx - start_idx);\n+\t\t      char_span word_span = content.subspan (start_idx, idx - start_idx);\n+\t\t      char *copy = word_span.xstrdup ();\n \t\t      for (char *ch = copy; *ch; ch++)\n \t\t\t*ch = TOUPPER (*ch);\n \t\t      richloc.add_fixit_replace (word, copy);"}]}