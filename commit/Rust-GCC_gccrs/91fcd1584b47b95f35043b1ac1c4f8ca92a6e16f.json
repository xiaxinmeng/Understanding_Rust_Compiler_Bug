{"sha": "91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmY2QxNTg0YjQ3Yjk1ZjM1MDQzYjFhYzFjNGY4Y2E5MmE2ZTE2Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-09T09:19:44Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-09T09:19:44Z"}, "message": "cpphash.h: ISvspace, is_vspace, is_nvspace: New.\n\n\t* cpphash.h: ISvspace, is_vspace, is_nvspace: New.\n\tIShspace, ISspace: Update.\n\n\t* cppinit.c: ISTABLE: Update.\n\tV: New.\n\n\t* cpplex.c (IS_HSPACE, S_NEWLINE): Remove.\n\t(IS_DIRECTIVE): Rename KNOWN_DIRECTIVE.\n\t(skip_block_comment, skip_line_comment,\tparse_string,\n\tlex_line): Use is_vspace rather than IS_NEWLINE.\n\t(skip_whitespace, lex_line): Clean up to use is_nvspace.\n\t(lex_line): Use KNOWN_DIRECTIVE.  Any kind of directive\n\tgets a BOL flag.\n\t(lex_next): Unconditionally stop if within a directive.\n\tTreat directives within macro invocations as directives\n\t(after parse_args emits error), not as the argument.\n\n\t* testsuite/gcc.dg/cpp/directiv.c: New tests.\n\t* testsuite/gcc.dg/cpp/undef1.c: Update.\n\nFrom-SVN: r34933", "tree": {"sha": "da206aace0d455cab3fa91f129af3841c667f84d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da206aace0d455cab3fa91f129af3841c667f84d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/comments", "author": null, "committer": null, "parents": [{"sha": "8514e31898f206915bbae2970285b1f35cd192ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8514e31898f206915bbae2970285b1f35cd192ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8514e31898f206915bbae2970285b1f35cd192ad"}], "stats": {"total": 224, "additions": 148, "deletions": 76}, "files": [{"sha": "db794f73679a13163e32d3b46ac1acebfac8dfea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -1,3 +1,22 @@\n+2000-07-09  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.h: ISvspace, is_vspace, is_nvspace: New.\n+\tIShspace, ISspace: Update.\n+\n+\t* cppinit.c: ISTABLE: Update.\n+\tV: New.\n+\n+\t* cpplex.c (IS_HSPACE, S_NEWLINE): Remove.\n+\t(IS_DIRECTIVE): Rename KNOWN_DIRECTIVE.\n+\t(skip_block_comment, skip_line_comment,\tparse_string,\n+\tlex_line): Use is_vspace rather than IS_NEWLINE.\n+\t(skip_whitespace, lex_line): Clean up to use is_nvspace.\n+\t(lex_line): Use KNOWN_DIRECTIVE.  Any kind of directive\n+\tgets a BOL flag.\n+\t(lex_next): Unconditionally stop if within a directive.\n+\tTreat directives within macro invocations as directives\n+\t(after parse_args emits error), not as the argument.\n+\n 2000-07-09  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* diagnostic.c (diagnostic_args): New macro."}, {"sha": "5cfd5a335f08fcb311878c917d4f1ae7155cfa92", "filename": "gcc/cpphash.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -141,12 +141,17 @@ struct spec_nodes\n \n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the\n-   definition of a pp-number in the C standard [section 6.4.8 of C99] */\n+   definition of a pp-number in the C standard [section 6.4.8 of C99].\n+\n+   In the unlikely event that characters other than \\r and \\n enter\n+   the set is_vspace, the macro handle_newline() in cpplex.c must be\n+   updated.  */\n #define ISidnum\t\t0x01\t/* a-zA-Z0-9_ */\n #define ISidstart\t0x02\t/* _a-zA-Z */\n #define ISnumstart\t0x04\t/* 0-9 */\n-#define IShspace\t0x08\t/* ' ' \\t \\f \\v */\n-#define ISspace\t\t0x10\t/* ' ' \\t \\f \\v \\n */\n+#define IShspace\t0x08\t/* ' ' \\t */\n+#define ISvspace\t0x10\t/* \\r \\n */\n+#define ISspace\t\t0x20\t/* ' ' \\t \\r \\n \\f \\v \\0 */\n \n #define _dollar_ok(x)\t((x) == '$' && CPP_OPTION (pfile, dollars_in_ident))\n \n@@ -155,6 +160,8 @@ struct spec_nodes\n #define is_numchar(x)\t(_cpp_IStable[x] & ISidnum)\n #define is_numstart(x)\t(_cpp_IStable[x] & ISnumstart)\n #define is_hspace(x)\t(_cpp_IStable[x] & IShspace)\n+#define is_vspace(x)\t(_cpp_IStable[x] & ISvspace)\n+#define is_nvspace(x)\t((_cpp_IStable[x] & (ISspace | ISvspace)) == ISspace)\n #define is_space(x)\t(_cpp_IStable[x] & ISspace)\n \n /* This table is constant if it can be initialized at compile time,"}, {"sha": "88a3e8ccaf87dbfdc6d073baaa1c213ecf81ed49", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -138,6 +138,7 @@ enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n #define A(x) s(x, ISidnum|ISidstart)\n #define N(x) s(x, ISidnum|ISnumstart)\n #define H(x) s(x, IShspace|ISspace)\n+#define V(x) s(x, ISvspace|ISspace)\n #define S(x) s(x, ISspace)\n \n ISTABLE\n@@ -153,14 +154,17 @@ ISTABLE\n \n   N('1') N('2') N('3') N('4') N('5') N('6') N('7') N('8') N('9') N('0')\n \n-  H('\\0') H(' ') H('\\t') H('\\v') H('\\f')\n+  H(' ') H('\\t')\n \n-  S('\\n')\n+  V('\\n') V('\\r')\n+\n+  S('\\0') S('\\v') S('\\f')\n END\n \n #undef A\n #undef N\n #undef H\n+#undef V\n #undef S\n #undef s\n #undef ISTABLE"}, {"sha": "951f633b2a421d09b1dc2dda664f652f5e86aeac", "filename": "gcc/cpplex.c", "status": "modified", "additions": 60, "deletions": 70, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -24,22 +24,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n Cleanups to do:-\n \n-o Fix ISTABLE to flag the parts we want for IS_HSPACE and IS_NEWLINE.\n o Get use of digraphs in sync with the standard reqd on the command line.\n o -dM and with _cpp_dump_list: too many \\n output.\n o Put a printer object in cpp_reader?\n o Check line numbers assigned to all errors.\n o Replace strncmp with memcmp almost everywhere.\n o lex_line's use of cur_token, flags and list->token_used is a bit opaque.\n-o Get rid of cpp_get_directive_token.\n o Convert do_ functions to return void.  Kaveh thinks its OK; and said he'll\n   give it a run when we've got some code.\n-o _cpp_parse_expr updated to new lexer.\n o Distinguish integers, floats, and 'other' pp-numbers.\n o Store ints and char constants as binary values.\n o New command-line assertion syntax.\n-o Merge hash table text pointer and token list text pointer for identifiers.\n-o Have _cpp_parse_expr use all the information the new lexer provides.\n o Work towards functions in cpperror.c taking a message level parameter.\n   If we do this, merge the common code of do_warning and do_error.\n o Comment all functions, and describe macro expansion algorithm.\n@@ -122,10 +117,6 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n    ((prevc) == 'e' || (prevc) == 'E' \\\n     || (((prevc) == 'p' || (prevc) == 'P') && !CPP_OPTION (pfile, c89))))\n \n-/* Maybe put these in the ISTABLE eventually.  */\n-#define IS_HSPACE(c) ((c) == ' ' || (c) == '\\t')\n-#define IS_NEWLINE(c) ((c) == '\\n' || (c) == '\\r')\n-\n /* Handle LF, CR, CR-LF and LF-CR style newlines.  Assumes next\n    character, if any, is in buffer.  */\n \n@@ -863,7 +854,7 @@ skip_block_comment (pfile)\n \t      cpp_warning (pfile, \"'/*' within comment\");\n \t    }\n \t}\n-      else if (IS_NEWLINE(c))\n+      else if (is_vspace (c))\n \t{\n \t  const unsigned char* bslash = backslash_start (pfile, cur - 2);\n \n@@ -897,7 +888,7 @@ skip_line_comment (pfile)\n     {\n       unsigned char c = *cur++;\n \n-      if (IS_NEWLINE (c))\n+      if (is_vspace (c))\n \t{\n \t  /* Check for a (trigaph?) backslash escaping the newline.  */\n \t  if (!backslash_start (pfile, cur - 2))\n@@ -922,37 +913,38 @@ skip_whitespace (pfile, in_directive)\n      int in_directive;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  register const unsigned char *cur = buffer->cur;\n-  unsigned short null_count = 0;\n+  unsigned short warned = 0;\n \n-  for (; cur < buffer->rlimit; )\n+  /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0. */\n+  while (buffer->cur < buffer->rlimit)\n     {\n-      unsigned char c = *cur++;\n+      unsigned char c = *buffer->cur;\n \n-      if (c == '\\t')\n+      if (!is_nvspace (c))\n+\tbreak;\n+\n+      buffer->cur++;\n+      /* Horizontal space always OK.  */\n+      if (c == ' ')\n+\tcontinue;\n+      else if (c == '\\t')\n+\tpfile->col_adjust += CPP_OPTION (pfile, tabstop) - 1\n+\t  - (CPP_BUF_COL (buffer) - 1) % CPP_OPTION(pfile, tabstop);\n+      /* Must be \\f \\v or \\0.  */\n+      else if (c == '\\0')\n \t{\n-\t  unsigned int col = CPP_BUF_COLUMN (buffer, cur - 1);\n-\t  pfile->col_adjust += (CPP_OPTION (pfile, tabstop) - 1\n-\t\t\t\t- col % CPP_OPTION(pfile, tabstop));\n+\t  if (!warned)\n+\t    cpp_warning_with_line (pfile, CPP_BUF_LINE (buffer),\n+\t\t\t\t   CPP_BUF_COL (buffer),\n+\t\t\t\t   \"embedded null character ignored\");\n+\t  warned = 1;\n \t}\n-      if (IS_HSPACE(c))\t\t/* FIXME: Fix ISTABLE.  */\n-\tcontinue;\n-      if (!is_space(c) || IS_NEWLINE (c)) /* Main loop handles newlines.  */\n-\tgoto out;\n-      if (c == '\\0')\n-\tnull_count++;\n-      /* Mut be '\\f' or '\\v' */\n       else if (in_directive && CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"%s in preprocessing directive\",\n-\t\t     c == '\\f' ? \"formfeed\" : \"vertical tab\");\n+\tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n+\t\t\t       CPP_BUF_COL (buffer),\n+\t\t\t       \"%s in preprocessing directive\",\n+\t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n     }\n-  cur++;\n-\n- out:\n-  buffer->cur = cur - 1;\n-  if (null_count)\n-    cpp_warning (pfile, null_count > 1 ? \"embedded null characters ignored\"\n-\t\t : \"embedded null character ignored\");\n }\n \n /* Parse (append) an identifier.  */\n@@ -1073,7 +1065,7 @@ parse_string (pfile, list, token, terminator)\n \n       if (c == '\\0')\n \tnull_count++;\n-      else if (c == terminator || IS_NEWLINE (c))\n+      else if (c == terminator || is_vspace (c))\n \t{\n \t  /* Needed for trigraph_replace and multiline string warning.  */\n \t  buffer->cur = cur;\n@@ -1090,7 +1082,7 @@ parse_string (pfile, list, token, terminator)\n \t    }\n \n \t  namebuf--;     /* Drop the newline / terminator from the name.  */\n-\t  if (IS_NEWLINE (c))\n+\t  if (is_vspace (c))\n \t    {\n \t      /* Drop a backslash newline, and continue. */\n \t      if (namebuf[-1] == '\\\\')\n@@ -1159,7 +1151,7 @@ parse_string (pfile, list, token, terminator)\n   /* We may not have trigraph-replaced the input for this code path,\n      but as the input is in error by being unterminated we don't\n      bother.  Prevent warnings about no newlines at EOF.  */\n-  if (IS_NEWLINE(cur[-1]))\n+  if (is_vspace (cur[-1]))\n     cur--;\n \n  unterminated:\n@@ -1240,7 +1232,7 @@ save_comment (list, token, from, len, type)\n  *  even when enabled.\n  */\n \n-#define IS_DIRECTIVE() (list->directive != 0)\n+#define KNOWN_DIRECTIVE() (list->directive != 0)\n #define MIGHT_BE_DIRECTIVE() \\\n (cur_token == &list->tokens[first_token + 1] && cur_token[-1].type == CPP_HASH)\n \n@@ -1273,21 +1265,22 @@ lex_line (pfile, list)\n     {\n       unsigned char c;\n \n-      /* Optimize whitespace skipping, as most tokens are probably\n-\t separated by whitespace. (' ' '\\t' '\\v' '\\f' '\\0').  */\n-      c = *cur++;\n-      if (is_hspace (c))\n+      /* Optimize non-vertical whitespace skipping; most tokens are\n+\t probably separated by whitespace. (' ' '\\t' '\\v' '\\f' '\\0').  */\n+      c = *cur;\n+      if (is_nvspace (c))\n \t{\n-\t  /* Step back to get the null warning and tab correction.  */\n-\t  buffer->cur = cur - 1;\n-\t  skip_whitespace (pfile, IS_DIRECTIVE ());\n+\t  buffer->cur = cur;\n+\t  skip_whitespace (pfile, (list->tokens[first_token].type == CPP_HASH\n+\t\t\t\t   && cur_token > &list->tokens[first_token]));\n \t  cur = buffer->cur;\n \n \t  flags = PREV_WHITE;\n \t  if (cur == buffer->rlimit)\n \t    break;\n-\t  c = *cur++;\n+\t  c = *cur;\n \t}\n+      cur++;\n \n       /* Initialize current token.  CPP_EOF will not be fixed up by\n \t expand_name_space.  */\n@@ -1428,7 +1421,7 @@ lex_line (pfile, list)\n \t\t      /* Back-up to first '-' or '/'.  */\n \t\t      cur_token--;\n \t\t      if (!CPP_OPTION (pfile, discard_comments)\n-\t\t\t  && (!IS_DIRECTIVE()\n+\t\t\t  && (!KNOWN_DIRECTIVE()\n \t\t\t      || (list->directive->flags & COMMENTS)))\n \t\t\tsave_comment (list, cur_token++, cur,\n \t\t\t\t      buffer->cur - cur, c);\n@@ -1466,7 +1459,7 @@ lex_line (pfile, list)\n \t\t  /* Back up to opening '/'.  */\n \t\t  cur_token--;\n \t\t  if (!CPP_OPTION (pfile, discard_comments)\n-\t\t      && (!IS_DIRECTIVE()\n+\t\t      && (!KNOWN_DIRECTIVE()\n \t\t\t  || (list->directive->flags & COMMENTS)))\n \t\t    save_comment (list, cur_token++, cur,\n \t\t\t\t  buffer->cur - cur, c);\n@@ -1647,7 +1640,7 @@ lex_line (pfile, list)\n \t      break;\n \t    }\n \t  /* Is this the beginning of a header name?  */\n-\t  if (IS_DIRECTIVE () && (list->directive->flags & INCL))\n+\t  if (KNOWN_DIRECTIVE () && (list->directive->flags & INCL))\n \t    {\n \t      c = '>';\t/* Terminator.  */\n \t      cur_token->type = CPP_HEADER_NAME;\n@@ -1755,7 +1748,7 @@ lex_line (pfile, list)\n   cur_token->flags = flags;\n   if (cur_token == &list->tokens[first_token] && pfile->done_initializing)\n     {\n-      if (cur > buffer->buf && !IS_NEWLINE (cur[-1]))\n+      if (cur > buffer->buf && !is_vspace (cur[-1]))\n \tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n \t\t\t       CPP_BUF_COLUMN (buffer, cur),\n \t\t\t       \"no newline at end of file\");\n@@ -1780,16 +1773,16 @@ lex_line (pfile, list)\n \tcpp_error (pfile, \"invalid preprocessing directive\");\n     }\n \n-  /* Put EOF at end of directives.  This covers \"directives do not\n-     extend beyond the end of the line (description 6.10 part 2)\".  */\n-  if (IS_DIRECTIVE () || !pfile->done_initializing)\n+  /* Put EOF at end of known directives.  This covers \"directives do\n+     not extend beyond the end of the line (description 6.10 part 2)\".  */\n+  if (KNOWN_DIRECTIVE () || !pfile->done_initializing)\n     {\n       pfile->first_directive_token = first;\n       cur_token++->type = CPP_EOF;\n     }\n \n-  if (first_token == 0 || IS_DIRECTIVE ())\n-    /* Set beginning of line flag.  */\n+  /* Directives, known or not, always start a new line.  */\n+  if (first_token == 0 || list->tokens[first_token].type == CPP_HASH)\n     first->flags |= BOL;\n   else\n     /* 6.10.3.10: Within the sequence of preprocessing tokens making\n@@ -2968,6 +2961,16 @@ lex_next (pfile, clear)\n   const cpp_token *old_list = list->tokens;\n   unsigned int old_used = list->tokens_used;\n \n+  /* If we are currently processing a directive, do not advance.  6.10\n+     paragraph 2: A new-line character ends the directive even if it\n+     occurs within what would otherwise be an invocation of a\n+     function-like macro.\n+\n+     It is possible that clear == 1 too; e.g. \"#if funlike_macro (\"\n+     since parse_args swallowed the directive's EOF.  */\n+  if (list->directive)\n+    return 1;\n+\n   if (clear)\n     {\n       /* Release all temporary tokens.  */\n@@ -2976,15 +2979,6 @@ lex_next (pfile, clear)\n       if (pfile->temp_used)\n \trelease_temp_tokens (pfile);\n     }\n-  else\n-    {\n-      /* If we are currently processing a directive, do not advance.\n-\t (6.10 paragraph 2: A new-line character ends the directive\n-\t even if it occurs within what would otherwise be an\n-\t invocation of a function-like macro.)  */\n-      if (list->directive)\n-\treturn 1;\n-    }\n      \n   lex_line (pfile, list);\n   pfile->contexts[0].count = list->tokens_used;\n@@ -3021,11 +3015,7 @@ lex_next (pfile, clear)\n \t\t\t       list->tokens[old_used].col,\n \t\t\t       \"#%s may not be used inside a macro argument\",\n \t\t\t       list->directive->name);\n-\t  /* Don't treat as a directive: clear list->directive,\n-\t     prune the final EOF from the list.  */\n-\t  list->directive = 0;\n-\t  list->tokens_used--;\n-\t  pfile->contexts[0].count--;\n+\t  return 1;\n \t}\n     }\n "}, {"sha": "63cac60285bd8ffe0af7277e84c32bc7d4210092", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -1,3 +1,8 @@\n+2000-07-09  Neil Booth  <NeilB@earthling.net>\n+\n+\t* testsuite/gcc.dg/cpp/directiv.c: New tests.\n+\t* testsuite/gcc.dg/cpp/undef1.c: Update.\n+\n 2000-07-08  Angela Marie Thomas <angela@cygnus.com>\n \n \t* lib/c-torture.exp: Make compiler_conditional_xfail_data global."}, {"sha": "8c27d0f76a7f2e7605a7e45008e08dc001ed50ce", "filename": "gcc/testsuite/gcc.dg/cpp/directiv.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -0,0 +1,47 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options -pedantic } */\n+\n+/* Tests general directive syntax, and directive error recovery.  */\n+\n+\n+/* Test directive name is not expanded.  */\n+#define foo define\n+#foo EMPTY\t\t\t/* { dg-error \"invalid\" } */\n+\n+/* Test # must be first on line.  */\n+EMPTY #define bar\n+#ifdef bar\n+#error bar is defined\n+#endif\n+\n+/* Test form feed and vertical tab warn pedantically, see 6.10\n+   paragraph 5.  Tab is OK.  */\n+#\fdefine something\t\t/* { dg-warning \"form feed\" } */\n+#define \u000bsomething_else\t/* { dg-warning \"vertical tab\" } */\n+\f#define some\tthing\t\t/* Tab OK, as is form feed before #.  */\n+\n+/* Our friend the null directive OK?  */\n+#\n+\n+/* Check that directives always start a line, even if in middle of\n+   macro expansion.  */\n+#define func(x) x\n+func (2\t\t\t\t/* { dg-error \"unterminated invocation\" }  */\n+#define foobar\t\t\t/* { dg-error \"may not be used inside\" } */\n+\n+/* For tidiness, I think the directive should still be processed\n+   above.  Certainly, continuing to try to find the closing ')' can\n+   lead to some really confusing error messages.  Hence this test.  */\n+#ifndef foobar\n+#error It is nice if the directive is processed!\n+#endif\n+\n+/* Check newlines end directives, even in function-like macro\n+   invocations.  6.10 paragraph 1.\n+\n+   Note that the #if is still treated as a conditional, so there\n+   should be no errors about #endif without #if.  */\n+#if func (\t\t\t/* { dg-error \"unterminated invocation\" } */\n+#endif"}, {"sha": "995d679b0ec7aa16ef13f2e2b27d4ca30c0e5205", "filename": "gcc/testsuite/gcc.dg/cpp/undef1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fundef1.c?ref=91fcd1584b47b95f35043b1ac1c4f8ca92a6e16f", "patch": "@@ -9,6 +9,6 @@\n \n #define foo(bar) bar\n \n-foo( blah\n+foo( blah\t\t\t/* { dg-error \"unterminated invocation\" }  */\n #undef foo\t/* { dg-error \"may not be used inside\" \"foo(#undef foo)\" } */\n      blah )"}]}