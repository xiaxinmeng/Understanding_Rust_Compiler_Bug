{"sha": "9f613f06b0da4b11cde815351df31ad74e22f449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2MTNmMDZiMGRhNGIxMWNkZTgxNTM1MWRmMzFhZDc0ZTIyZjQ0OQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2018-05-14T14:55:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2018-05-14T14:55:21Z"}, "message": "cp-tree.h (TYPE_REF_P): New.\n\n2018-05-14  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* cp-tree.h (TYPE_REF_P): New.\n\t(TYPE_OBJ_P, TYPE_REF_OBJ_P, TYPE_REFFN_P): Update.\n\t* call.c (build_list_conv, build_aggr_conv, standard_conversion,\n\tdirect_reference_binding, reference_binding, implicit_conversion,\n\tadd_builtin_candidate, build_user_type_conversion_1, build_op_call_1,\n\tbuild_new_op_1, build_x_va_arg, conv_binds_ref_to_prvalue,\n\tbuild_over_call, perform_implicit_conversion_flags,\n\textend_ref_init_temps, type_has_extended_temps): Use it.\n\t* class.c (one_inheriting_sig, check_field_decls,\n\tcheck_bases_and_members, find_flexarrays, finish_struct,\n\tfixed_type_or_null): Likewise.\n\t* constexpr.c (literal_type_p, cxx_bind_parameters_in_call,\n\tnon_const_var_error, cxx_eval_constant_expression,\n\tpotential_constant_expression_1): Likewise.\n\t* cp-gimplify.c (omp_var_to_track, omp_cxx_notice_variable,\n\tcp_genericize_r, cxx_omp_privatize_by_reference,\n\tcxx_omp_const_qual_no_mutable, cxx_omp_finish_clause,\n\tcp_fold_maybe_rvalue): Likewise.\n\t* cp-ubsan.c (cp_ubsan_maybe_instrument_downcast): Likewise.\n\t* cvt.c (build_up_reference, convert_to_reference,\n\tconvert_from_reference, convert_to_void, noexcept_conv_p,\n\tfnptr_conv_p): Likewise.\n\t* decl.c (poplevel, check_for_uninitialized_const_var,\n\tcheck_initializer, initialize_local_var, cp_finish_decl,\n\tget_tuple_decomp_init, cp_finish_decomp, grokdeclarator, copy_fn_p,\n\tmove_signature_fn_p, grok_op_properties, finish_function): Likewise.\n\t* decl2.c (grok_array_decl, cp_reconstruct_complex_type,\n\tdecl_maybe_constant_var_p): Likewise.\n\t* error.c (dump_type_prefix, dump_expr): Likewise.\n\t* except.c (initialize_handler_parm, complete_ptr_ref_or_void_ptr_p,\n\tis_admissible_throw_operand_or_catch_parameter): Likewise.\n\t* expr.c (mark_use): Likewise.\n\t* init.c (build_zero_init_1, build_value_init_noctor,\n\tperform_member_init, diagnose_uninitialized_cst_or_ref_member_1,\n\tbuild_new, build_delete): Likewise.\n\t* lambda.c (build_lambda_object): Likewise.\n\t* mangle.c (write_expression, write_template_arg): Likewise.\n\t* method.c (forward_parm, do_build_copy_constructor,\n\tdo_build_copy_assign, build_stub_object, constructible_expr,\n\twalk_field_subobs): Likewise.\n\t* parser.c (cp_parser_omp_for_loop_init,\n\tcp_parser_omp_declare_reduction_exprs,\n\tcp_parser_omp_declare_reduction): Likewise.\n\t* pt.c (convert_nontype_argument_function, convert_nontype_argument,\n\tconvert_template_argument, tsubst_pack_expansion,\n\ttsubst_function_decl, tsubst_decl, tsubst, tsubst_copy_and_build,\n\tmaybe_adjust_types_for_deduction, check_cv_quals_for_unify, unify,\n\tmore_specialized_fn, invalid_nontype_parm_type_p, dependent_type_p_r,\n\tvalue_dependent_expression_p, build_deduction_guide): Likewise.\n\t* semantics.c (finish_handler_parms, finish_non_static_data_member,\n\tfinish_compound_literal, omp_privatize_field,\n\thandle_omp_array_sections_1, handle_omp_array_sections,\n\tcp_check_omp_declare_reduction, finish_omp_reduction_clause,\n\tfinish_omp_declare_simd_methods, cp_finish_omp_clause_depend_sink,\n\tfinish_omp_clauses, finish_decltype_type, capture_decltype,\n\tfinish_builtin_launder): Likewise.\n\t* tree.c (lvalue_kind, cp_build_reference_type, move,\n\tcp_build_qualified_type_real, stabilize_expr, stabilize_init): Likewise.\n\t* typeck.c (cxx_safe_arg_type_equiv_p, build_class_member_access_expr,\n\tcp_build_indirect_ref_1, convert_arguments, warn_for_null_address,\n\tcp_build_addr_expr_1, maybe_warn_about_useless_cast,\n\tbuild_static_cast_1, build_static_cast, build_reinterpret_cast_1,\n\tbuild_const_cast_1, cp_build_c_cast, cp_build_modify_expr,\n\tconvert_for_initialization,\n\tmaybe_warn_about_returning_address_of_local, check_return_expr,\n\tcp_type_quals, casts_away_constness, non_reference): Likewise.\n\t* typeck2.c (cxx_readonly_error, store_init_value,\n\tprocess_init_constructor_record, build_x_arrow, build_functional_cast,\n\tadd_exception_specifier): Likewise.\n\nFrom-SVN: r260228", "tree": {"sha": "a9943bff782afde1064274c78c9428b0b7aebb43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9943bff782afde1064274c78c9428b0b7aebb43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f613f06b0da4b11cde815351df31ad74e22f449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f613f06b0da4b11cde815351df31ad74e22f449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f613f06b0da4b11cde815351df31ad74e22f449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f613f06b0da4b11cde815351df31ad74e22f449/comments", "author": null, "committer": null, "parents": [{"sha": "403962eac2c99fc7510fbd4164f0a56fb7a15d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403962eac2c99fc7510fbd4164f0a56fb7a15d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403962eac2c99fc7510fbd4164f0a56fb7a15d0c"}], "stats": {"total": 553, "additions": 312, "deletions": 241}, "files": [{"sha": "c4214716d021386170cbff1f86e2b22141748458", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -1,3 +1,75 @@\n+2018-05-14  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* cp-tree.h (TYPE_REF_P): New.\n+\t(TYPE_OBJ_P, TYPE_REF_OBJ_P, TYPE_REFFN_P): Update.\n+\t* call.c (build_list_conv, build_aggr_conv, standard_conversion,\n+\tdirect_reference_binding, reference_binding, implicit_conversion,\n+\tadd_builtin_candidate, build_user_type_conversion_1, build_op_call_1,\n+\tbuild_new_op_1, build_x_va_arg, conv_binds_ref_to_prvalue,\n+\tbuild_over_call, perform_implicit_conversion_flags,\n+\textend_ref_init_temps, type_has_extended_temps): Use it.\n+\t* class.c (one_inheriting_sig, check_field_decls,\n+\tcheck_bases_and_members, find_flexarrays, finish_struct,\n+\tfixed_type_or_null): Likewise.\n+\t* constexpr.c (literal_type_p, cxx_bind_parameters_in_call,\n+\tnon_const_var_error, cxx_eval_constant_expression,\n+\tpotential_constant_expression_1): Likewise.\n+\t* cp-gimplify.c (omp_var_to_track, omp_cxx_notice_variable,\n+\tcp_genericize_r, cxx_omp_privatize_by_reference,\n+\tcxx_omp_const_qual_no_mutable, cxx_omp_finish_clause,\n+\tcp_fold_maybe_rvalue): Likewise.\n+\t* cp-ubsan.c (cp_ubsan_maybe_instrument_downcast): Likewise.\n+\t* cvt.c (build_up_reference, convert_to_reference,\n+\tconvert_from_reference, convert_to_void, noexcept_conv_p,\n+\tfnptr_conv_p): Likewise.\n+\t* decl.c (poplevel, check_for_uninitialized_const_var,\n+\tcheck_initializer, initialize_local_var, cp_finish_decl,\n+\tget_tuple_decomp_init, cp_finish_decomp, grokdeclarator, copy_fn_p,\n+\tmove_signature_fn_p, grok_op_properties, finish_function): Likewise.\n+\t* decl2.c (grok_array_decl, cp_reconstruct_complex_type,\n+\tdecl_maybe_constant_var_p): Likewise.\n+\t* error.c (dump_type_prefix, dump_expr): Likewise.\n+\t* except.c (initialize_handler_parm, complete_ptr_ref_or_void_ptr_p,\n+\tis_admissible_throw_operand_or_catch_parameter): Likewise.\n+\t* expr.c (mark_use): Likewise.\n+\t* init.c (build_zero_init_1, build_value_init_noctor,\n+\tperform_member_init, diagnose_uninitialized_cst_or_ref_member_1,\n+\tbuild_new, build_delete): Likewise.\n+\t* lambda.c (build_lambda_object): Likewise.\n+\t* mangle.c (write_expression, write_template_arg): Likewise.\n+\t* method.c (forward_parm, do_build_copy_constructor,\n+\tdo_build_copy_assign, build_stub_object, constructible_expr,\n+\twalk_field_subobs): Likewise.\n+\t* parser.c (cp_parser_omp_for_loop_init,\n+\tcp_parser_omp_declare_reduction_exprs,\n+\tcp_parser_omp_declare_reduction): Likewise.\n+\t* pt.c (convert_nontype_argument_function, convert_nontype_argument,\n+\tconvert_template_argument, tsubst_pack_expansion,\n+\ttsubst_function_decl, tsubst_decl, tsubst, tsubst_copy_and_build,\n+\tmaybe_adjust_types_for_deduction, check_cv_quals_for_unify, unify,\n+\tmore_specialized_fn, invalid_nontype_parm_type_p, dependent_type_p_r,\n+\tvalue_dependent_expression_p, build_deduction_guide): Likewise.\n+\t* semantics.c (finish_handler_parms, finish_non_static_data_member,\n+\tfinish_compound_literal, omp_privatize_field,\n+\thandle_omp_array_sections_1, handle_omp_array_sections,\n+\tcp_check_omp_declare_reduction, finish_omp_reduction_clause,\n+\tfinish_omp_declare_simd_methods, cp_finish_omp_clause_depend_sink,\n+\tfinish_omp_clauses, finish_decltype_type, capture_decltype,\n+\tfinish_builtin_launder): Likewise.\n+\t* tree.c (lvalue_kind, cp_build_reference_type, move,\n+\tcp_build_qualified_type_real, stabilize_expr, stabilize_init): Likewise.\n+\t* typeck.c (cxx_safe_arg_type_equiv_p, build_class_member_access_expr,\n+\tcp_build_indirect_ref_1, convert_arguments, warn_for_null_address,\n+\tcp_build_addr_expr_1, maybe_warn_about_useless_cast,\n+\tbuild_static_cast_1, build_static_cast, build_reinterpret_cast_1,\n+\tbuild_const_cast_1, cp_build_c_cast, cp_build_modify_expr,\n+\tconvert_for_initialization,\n+\tmaybe_warn_about_returning_address_of_local, check_return_expr,\n+\tcp_type_quals, casts_away_constness, non_reference): Likewise.\n+\t* typeck2.c (cxx_readonly_error, store_init_value,\n+\tprocess_init_constructor_record, build_x_arrow, build_functional_cast,\n+\tadd_exception_specifier): Likewise.\n+\n 2018-05-14  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst) [ARRAY_TYPE]: Check valid_array_size_p."}, {"sha": "f620c0d86e854d216395c7f7f70d82138b81b5c4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -814,7 +814,7 @@ build_list_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n   flags |= LOOKUP_NO_NARROWING;\n \n   /* Can't make an array of these types.  */\n-  if (TREE_CODE (elttype) == REFERENCE_TYPE\n+  if (TYPE_REF_P (elttype)\n       || TREE_CODE (elttype) == FUNCTION_TYPE\n       || VOID_TYPE_P (elttype))\n     return NULL;\n@@ -915,7 +915,7 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n \tval = CONSTRUCTOR_ELT (ctor, i)->value;\n       else if (DECL_INITIAL (field))\n \tval = get_nsdmi (field, /*ctor*/false, complain);\n-      else if (TREE_CODE (ftype) == REFERENCE_TYPE)\n+      else if (TYPE_REF_P (ftype))\n \t/* Value-initialization of reference is ill-formed.  */\n \treturn NULL;\n       else\n@@ -1105,7 +1105,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   tree qualified_to;\n \n   to = non_reference (to);\n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (from))\n     {\n       fromref = true;\n       from = TREE_TYPE (from);\n@@ -1475,8 +1475,8 @@ direct_reference_binding (tree type, conversion *conv)\n {\n   tree t;\n \n-  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n-  gcc_assert (TREE_CODE (conv->type) != REFERENCE_TYPE);\n+  gcc_assert (TYPE_REF_P (type));\n+  gcc_assert (!TYPE_REF_P (conv->type));\n \n   t = TREE_TYPE (type);\n \n@@ -1567,7 +1567,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n     skip:;\n     }\n \n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (from))\n     {\n       from = TREE_TYPE (from);\n       if (!TYPE_REF_IS_RVALUE (rfrom)\n@@ -1633,7 +1633,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n       conv = build_identity_conv (tfrom, expr);\n       conv = direct_reference_binding (rto, conv);\n \n-      if (TREE_CODE (rfrom) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (rfrom))\n \t/* Handle rvalue reference to function properly.  */\n \tconv->rvaluedness_matches_p\n \t  = (TYPE_REF_IS_RVALUE (rto) == TYPE_REF_IS_RVALUE (rfrom));\n@@ -1835,7 +1835,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       from = TREE_TYPE (expr);\n     }\n \n-  if (TREE_CODE (to) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (to))\n     conv = reference_binding (to, from, expr, c_cast_p, flags, complain);\n   else\n     conv = standard_conversion (to, from, expr, c_cast_p, flags, complain);\n@@ -2845,7 +2845,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n      we need candidates for both of them.  */\n   if (type2 && !same_type_p (type1, type2)\n       && TREE_CODE (type1) == TREE_CODE (type2)\n-      && (TREE_CODE (type1) == REFERENCE_TYPE\n+      && (TYPE_REF_P (type1)\n \t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n \t  || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n \t  || TYPE_PTRMEMFUNC_P (type1)\n@@ -3007,11 +3007,11 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t      type = TREE_TYPE (convs);\n \n \t      if (i == 0 && ref1\n-\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n+\t\t  && (!TYPE_REF_P (type)\n \t\t      || CP_TYPE_CONST_P (TREE_TYPE (type))))\n \t\tcontinue;\n \n-\t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n+\t      if (code == COND_EXPR && TYPE_REF_P (type))\n \t\tvec_safe_push (types[i], type);\n \n \t      type = non_reference (type);\n@@ -3818,7 +3818,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n \n \t     We represent this in the conversion sequence with an\n \t     rvalue conversion, which means a constructor call.  */\n-\t  if (TREE_CODE (totype) != REFERENCE_TYPE\n+\t  if (!TYPE_REF_P (totype)\n \t      && !(convflags & LOOKUP_NO_TEMP_BIND))\n \t    cand->second_conv\n \t      = build_conv (ck_rvalue, totype, cand->second_conv);\n@@ -3842,7 +3842,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n \t find a direct binding, so don't even consider temporaries.  If\n \t we don't find a direct binding, the caller will try again to\n \t look for a temporary binding.  */\n-      if (TREE_CODE (totype) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (totype))\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n \n       old_candidates = candidates;\n@@ -4514,7 +4514,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \n       if (TYPE_PTRFN_P (totype)\n \t  || TYPE_REFFN_P (totype)\n-\t  || (TREE_CODE (totype) == REFERENCE_TYPE\n+\t  || (TYPE_REF_P (totype)\n \t      && TYPE_PTRFN_P (TREE_TYPE (totype))))\n \tfor (ovl_iterator iter (TREE_VALUE (convs)); iter; ++iter)\n \t  {\n@@ -5733,7 +5733,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t    {\n \t      parmtype = TREE_VALUE (parmlist);\n \n-\t      if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n+\t      if (TYPE_REF_P (parmtype))\n \t\tparmtype = TREE_TYPE (parmtype);\n \t      if (TREE_CODE (TREE_TYPE (args[i])) == ENUMERAL_TYPE\n \t\t  && (same_type_ignoring_top_level_qualifiers_p\n@@ -7246,7 +7246,7 @@ build_x_va_arg (source_location loc, tree expr, tree type)\n \n   expr = mark_lvalue_use (expr);\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       error (\"cannot receive reference type %qT through %<...%>\", type);\n       return error_mark_node;\n@@ -7618,7 +7618,7 @@ conv_binds_ref_to_prvalue (conversion *c)\n \n   if (c->kind == ck_rvalue)\n     return true;\n-  if (c->kind == ck_user && TREE_CODE (c->type) != REFERENCE_TYPE)\n+  if (c->kind == ck_user && !TYPE_REF_P (c->type))\n     return true;\n   if (c->kind == ck_identity && c->u.expr\n       && TREE_CODE (c->u.expr) == TARGET_EXPR)\n@@ -7862,7 +7862,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t     reference to the object\u2019s type (possibly cv-qualified)....\" */\n \t  gcc_assert (!(complain & tf_error));\n \t  tree ptype = convs[0]->type;\n-\t  if (TREE_CODE (ptype) != REFERENCE_TYPE\n+\t  if (!TYPE_REF_P (ptype)\n \t      || !TYPE_REF_IS_RVALUE (ptype)\n \t      || CONVERSION_RANK (convs[0]) > cr_exact)\n \t    return error_mark_node;\n@@ -8097,7 +8097,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  /* For -Wformat undo the implicit passing by hidden reference\n \t     done by convert_arg_to_ellipsis.  */\n \t  if (TREE_CODE (argarray[j]) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_TYPE (argarray[j])) == REFERENCE_TYPE)\n+\t      && TYPE_REF_P (TREE_TYPE (argarray[j])))\n \t    fargs[j] = TREE_OPERAND (argarray[j], 0);\n \t  else\n \t    fargs[j] = maybe_constant_value (argarray[j]);\n@@ -8153,12 +8153,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       targ = arg;\n       /* Strip the reference binding for the constructor parameter.  */\n       if (CONVERT_EXPR_P (targ)\n-\t  && TREE_CODE (TREE_TYPE (targ)) == REFERENCE_TYPE)\n+\t  && TYPE_REF_P (TREE_TYPE (targ)))\n \ttarg = TREE_OPERAND (targ, 0);\n       /* But don't strip any other reference bindings; binding a temporary to a\n \t reference prevents copy elision.  */\n       while ((CONVERT_EXPR_P (targ)\n-\t      && TREE_CODE (TREE_TYPE (targ)) != REFERENCE_TYPE)\n+\t      && !TYPE_REF_P (TREE_TYPE (targ)))\n \t     || TREE_CODE (targ) == NON_LVALUE_EXPR)\n \ttarg = TREE_OPERAND (targ, 0);\n       if (TREE_CODE (targ) == ADDR_EXPR)\n@@ -10672,7 +10672,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n   void *p;\n   location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     expr = mark_lvalue_use (expr);\n   else\n     expr = mark_rvalue_use (expr);\n@@ -11094,7 +11094,7 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)\n   tree type = TREE_TYPE (init);\n   if (processing_template_decl)\n     return init;\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     init = extend_ref_init_temps_1 (decl, init, cleanups);\n   else\n     {\n@@ -11136,7 +11136,7 @@ bool\n type_has_extended_temps (tree type)\n {\n   type = strip_array_types (type);\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     return true;\n   if (CLASS_TYPE_P (type))\n     {"}, {"sha": "e51946d3d83e5f5af2841bc93bc1f25acb34d1fb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -3054,7 +3054,7 @@ one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n   if (nparms == 0)\n     return;\n   if (nparms == 1\n-      && TREE_CODE (parms[0]) == REFERENCE_TYPE)\n+      && TYPE_REF_P (parms[0]))\n     {\n       tree parm = TYPE_MAIN_VARIANT (TREE_TYPE (parms[0]));\n       if (parm == t || parm == DECL_CONTEXT (ctor))\n@@ -3463,7 +3463,7 @@ check_field_decls (tree t, tree *access_decls,\n \t\t     \"a member of a union\", x);\n \t      continue;\n \t    }\n-\t  if (TREE_CODE (type) == REFERENCE_TYPE\n+\t  if (TYPE_REF_P (type)\n \t      && TREE_CODE (x) == FIELD_DECL)\n \t    {\n \t      error (\"non-static data member %q+D in a union may not \"\n@@ -3517,7 +3517,7 @@ check_field_decls (tree t, tree *access_decls,\n \tCLASSTYPE_NON_STD_LAYOUT (t) = 1;\n \n       /* If this is of reference type, check if it needs an init.  */\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (type))\n \t{\n \t  CLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n \t  CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n@@ -3595,7 +3595,7 @@ check_field_decls (tree t, tree *access_decls,\n \t\t     \"and %<mutable%>\", x);\n \t      continue;\n \t    }\n-\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (TYPE_REF_P (type))\n \t    {\n \t      error (\"member %q+D cannot be declared as a %<mutable%> \"\n \t\t     \"reference\", x);\n@@ -5594,7 +5594,7 @@ check_bases_and_members (tree t)\n \t    continue;\n \n \t  type = TREE_TYPE (field);\n-\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (TYPE_REF_P (type))\n \t    warning_at (DECL_SOURCE_LOCATION (field),\n \t\t\tOPT_Wuninitialized, \"non-static reference %q#D \"\n \t\t\t\"in class without a constructor\", field);\n@@ -6454,8 +6454,8 @@ find_flexarrays (tree t, flexmems_t *fmem, bool base_p,\n \t members if it hasn't been yet.  */\n       tree eltype = fldtype;\n       while (TREE_CODE (eltype) == ARRAY_TYPE\n-\t     || TREE_CODE (eltype) == POINTER_TYPE\n-\t     || TREE_CODE (eltype) == REFERENCE_TYPE)\n+\t     || TYPE_PTR_P (eltype)\n+\t     || TYPE_REF_P (eltype))\n \teltype = TREE_TYPE (eltype);\n \n       if (RECORD_OR_UNION_TYPE_P (eltype))\n@@ -7069,7 +7069,7 @@ finish_struct (tree t, tree attributes)\n       if (processing_template_decl)\n \t{\n \t  tree f = next_initializable_field (TYPE_FIELDS (t));\n-\t  if (f && TREE_CODE (TREE_TYPE (f)) == POINTER_TYPE)\n+\t  if (f && TYPE_PTR_P (TREE_TYPE (f)))\n \t    {\n \t      f = next_initializable_field (DECL_CHAIN (f));\n \t      if (f && same_type_p (TREE_TYPE (f), size_type_node))\n@@ -7214,7 +7214,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t      return TREE_TYPE (TREE_TYPE (instance));\n \t    }\n \t}\n-      else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n+      else if (TYPE_REF_P (TREE_TYPE (instance)))\n \t{\n \t  /* We only need one hash table because it is always left empty.  */\n \t  if (!fixed_type_or_null_ref_ht)"}, {"sha": "9ee37de88d3dcb3cfbdc44e7a8c4a6c53982cee1", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -60,7 +60,7 @@ literal_type_p (tree t)\n {\n   if (SCALAR_TYPE_P (t)\n       || VECTOR_TYPE_P (t)\n-      || TREE_CODE (t) == REFERENCE_TYPE\n+      || TYPE_REF_P (t)\n       || (VOID_TYPE_P (t) && cxx_dialect >= cxx14))\n     return true;\n   if (CLASS_TYPE_P (t))\n@@ -1328,7 +1328,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  arg = unshare_constructor (arg);\n \t  /* Make sure the binding has the same type as the parm.  But\n \t     only for constant args.  */\n-\t  if (TREE_CODE (type) != REFERENCE_TYPE)\n+\t  if (!TYPE_REF_P (type))\n \t    arg = adjust_temp_type (type, arg);\n \t  if (!TREE_CONSTANT (arg))\n \t    *non_constant_args = true;\n@@ -3394,7 +3394,7 @@ non_const_var_error (tree r)\n       else\n \tgcc_unreachable ();\n     }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (type))\n     inform (DECL_SOURCE_LOCATION (r),\n \t    \"%qD was not initialized with a constant \"\n \t    \"expression\", r);\n@@ -4104,7 +4104,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t}\n \n       if (TREE_CODE (t) == INTEGER_CST\n-\t  && TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n+\t  && TYPE_PTR_P (TREE_TYPE (t))\n \t  && !integer_zerop (t))\n \t{\n \t  if (!ctx->quiet)\n@@ -4185,13 +4185,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n \n     case PARM_DECL:\n-      if (lval && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+      if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n \t/* glvalue use.  */;\n       else if (tree *p = ctx->values->get (r))\n \tr = *p;\n       else if (lval)\n \t/* Defer in case this is only used for its type.  */;\n-      else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+      else if (TYPE_REF_P (TREE_TYPE (t)))\n \t/* Defer, there's no lvalue->rvalue conversion.  */;\n       else if (COMPLETE_TYPE_P (TREE_TYPE (t))\n \t       && is_really_empty_class (TREE_TYPE (t)))\n@@ -4619,15 +4619,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  {\n \t    if (integer_zerop (op))\n \t      {\n-\t\tif (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\tif (TYPE_REF_P (type))\n \t\t  {\n \t\t    if (!ctx->quiet)\n \t\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n \t\t\t\t\"dereferencing a null pointer\");\n \t\t    *non_constant_p = true;\n \t\t    return t;\n \t\t  }\n-\t\telse if (TREE_CODE (TREE_TYPE (op)) == POINTER_TYPE)\n+\t\telse if (TYPE_PTR_P (TREE_TYPE (op)))\n \t\t  {\n \t\t    tree from = TREE_TYPE (op);\n \n@@ -5807,7 +5807,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t}\n \n       return (RECUR (TREE_OPERAND (t, 0),\n-\t\t     TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE));\n+\t\t     !TYPE_REF_P (TREE_TYPE (t))));\n \n     case BIND_EXPR:\n       return RECUR (BIND_EXPR_BODY (t), want_rval);"}, {"sha": "eda5f05ea6a0be8fafcfd234ac9a12bb5d330aac", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -874,7 +874,7 @@ omp_var_to_track (tree decl)\n   tree type = TREE_TYPE (decl);\n   if (is_invisiref_parm (decl))\n     type = TREE_TYPE (type);\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (type))\n     type = TREE_TYPE (type);\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     type = TREE_TYPE (type);\n@@ -928,7 +928,7 @@ omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n \t      tree type = TREE_TYPE (decl);\n \t      if (is_invisiref_parm (decl))\n \t\ttype = TREE_TYPE (type);\n-\t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t      else if (TYPE_REF_P (type))\n \t\ttype = TREE_TYPE (type);\n \t      while (TREE_CODE (type) == ARRAY_TYPE)\n \t\ttype = TREE_TYPE (type);\n@@ -1091,7 +1091,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     }\n \n   if (TREE_CODE (stmt) == INTEGER_CST\n-      && TREE_CODE (TREE_TYPE (stmt)) == REFERENCE_TYPE\n+      && TYPE_REF_P (TREE_TYPE (stmt))\n       && (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n       && !wtd->no_sanitize_p)\n     {\n@@ -1486,7 +1486,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     case NOP_EXPR:\n       if (!wtd->no_sanitize_p\n \t  && sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT)\n-\t  && TREE_CODE (TREE_TYPE (stmt)) == REFERENCE_TYPE)\n+\t  && TYPE_REF_P (TREE_TYPE (stmt)))\n \tubsan_maybe_instrument_reference (stmt_p);\n       break;\n \n@@ -1513,8 +1513,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  else if (fn == NULL_TREE\n \t\t   && CALL_EXPR_IFN (stmt) == IFN_UBSAN_NULL\n \t\t   && TREE_CODE (CALL_EXPR_ARG (stmt, 0)) == INTEGER_CST\n-\t\t   && (TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (stmt, 0)))\n-\t\t       == REFERENCE_TYPE))\n+\t\t   && TYPE_REF_P (TREE_TYPE (CALL_EXPR_ARG (stmt, 0))))\n \t    *walk_subtrees = 0;\n \t}\n       /* Fall through.  */\n@@ -1907,7 +1906,7 @@ cxx_omp_clause_dtor (tree clause, tree decl)\n bool\n cxx_omp_privatize_by_reference (const_tree decl)\n {\n-  return (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+  return (TYPE_REF_P (TREE_TYPE (decl))\n \t  || is_invisiref_parm (decl));\n }\n \n@@ -1916,7 +1915,7 @@ bool\n cxx_omp_const_qual_no_mutable (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       if (!is_invisiref_parm (decl))\n \treturn false;\n@@ -2017,7 +2016,7 @@ cxx_omp_finish_clause (tree c, gimple_seq *)\n   inner_type = TREE_TYPE (decl);\n   if (decl == error_mark_node)\n     make_shared = true;\n-  else if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (TREE_TYPE (decl)))\n     inner_type = TREE_TYPE (inner_type);\n \n   /* We're interested in the base element, not arrays.  */\n@@ -2065,7 +2064,7 @@ cp_fold_maybe_rvalue (tree x, bool rval)\n     {\n       x = cp_fold (x);\n       if (rval && DECL_P (x)\n-\t  && TREE_CODE (TREE_TYPE (x)) != REFERENCE_TYPE)\n+\t  && !TYPE_REF_P (TREE_TYPE (x)))\n \t{\n \t  tree v = decl_constant_value (x);\n \t  if (v != x && v != error_mark_node)"}, {"sha": "4b4f88212fe9cd512175961d8227ab01b4322f85", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -3621,8 +3621,7 @@ struct GTY(()) lang_decl {\n #define REFERENCE_REF_P(NODE)\t\t\t\t\\\n   (INDIRECT_REF_P (NODE)\t\t\t\t\\\n    && TREE_TYPE (TREE_OPERAND (NODE, 0))\t\t\\\n-   && (TREE_CODE (TREE_TYPE (TREE_OPERAND ((NODE), 0)))\t\\\n-       == REFERENCE_TYPE))\n+   && TYPE_REF_P (TREE_TYPE (TREE_OPERAND ((NODE), 0))))\n \n /* True if NODE is a REFERENCE_TYPE which is OK to instantiate to be a\n    reference to VLA type, because it's used for VLA capture.  */\n@@ -4227,10 +4226,15 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* Returns true if NODE is a pointer-to-data-member.  */\n #define TYPE_PTRDATAMEM_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == OFFSET_TYPE)\n+\n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == POINTER_TYPE)\n \n+/* Returns true if NODE is a reference.  */\n+#define TYPE_REF_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == REFERENCE_TYPE)\n+\n /* Returns true if NODE is an object type:\n \n      [basic.types]\n@@ -4240,7 +4244,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n    Keep these checks in ascending order, for speed.  */\n #define TYPE_OBJ_P(NODE)\t\t\t\\\n-  (TREE_CODE (NODE) != REFERENCE_TYPE\t\t\\\n+  (!TYPE_REF_P (NODE)\t\t\t\t\\\n    && !VOID_TYPE_P (NODE)  \t\t        \\\n    && TREE_CODE (NODE) != FUNCTION_TYPE\t\t\\\n    && TREE_CODE (NODE) != METHOD_TYPE)\n@@ -4253,7 +4257,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* Returns true if NODE is a reference to an object.  Keep these checks\n    in ascending tree code order.  */\n #define TYPE_REF_OBJ_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == REFERENCE_TYPE && TYPE_OBJ_P (TREE_TYPE (NODE)))\n+  (TYPE_REF_P (NODE) && TYPE_OBJ_P (TREE_TYPE (NODE)))\n \n /* Returns true if NODE is a pointer to an object, or a pointer to\n    void.  Keep these checks in ascending tree code order.  */\n@@ -4269,7 +4273,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Returns true if NODE is a reference to function type.  */\n #define TYPE_REFFN_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == REFERENCE_TYPE\t\t\t\\\n+  (TYPE_REF_P (NODE)\t\t\t\t\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n \n /* Returns true if NODE is a pointer to member function type.  */"}, {"sha": "507433a55e17975c68015eb5fd3fd29d3687bfd8", "filename": "gcc/cp/cp-ubsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcp-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -265,7 +265,7 @@ cp_ubsan_maybe_instrument_downcast (location_t loc, tree type,\n     return NULL_TREE;\n \n   return cp_ubsan_maybe_instrument_vptr (loc, op, TREE_TYPE (type), true,\n-\t\t\t\t\t TREE_CODE (type) == POINTER_TYPE\n+\t\t\t\t\t TYPE_PTR_P (type)\n \t\t\t\t\t ? UBSAN_DOWNCAST_POINTER\n \t\t\t\t\t : UBSAN_DOWNCAST_REFERENCE);\n }"}, {"sha": "30b44b7d7eafdc55a6415cbf7cc5cb0253b2a2fc", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -322,7 +322,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl,\n   tree argtype = TREE_TYPE (arg);\n   tree target_type = TREE_TYPE (type);\n \n-  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+  gcc_assert (TYPE_REF_P (type));\n \n   if ((flags & DIRECT_BIND) && ! lvalue_p (arg))\n     {\n@@ -429,8 +429,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n   intype = TREE_TYPE (expr);\n \n-  gcc_assert (TREE_CODE (intype) != REFERENCE_TYPE);\n-  gcc_assert (TREE_CODE (reftype) == REFERENCE_TYPE);\n+  gcc_assert (!TYPE_REF_P (intype));\n+  gcc_assert (TYPE_REF_P (reftype));\n \n   intype = TYPE_MAIN_VARIANT (intype);\n \n@@ -533,7 +533,7 @@ tree\n convert_from_reference (tree val)\n {\n   if (TREE_TYPE (val)\n-      && TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n+      && TYPE_REF_P (TREE_TYPE (val)))\n     {\n       tree t = TREE_TYPE (TREE_TYPE (val));\n       tree ref = build1 (INDIRECT_REF, t, val);\n@@ -1163,8 +1163,7 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n     case INDIRECT_REF:\n       {\n \ttree type = TREE_TYPE (expr);\n-\tint is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\t\t\t   == REFERENCE_TYPE;\n+\tint is_reference = TYPE_REF_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n \tint is_volatile = TYPE_VOLATILE (type);\n \tint is_complete = COMPLETE_TYPE_P (complete_type (type));\n \n@@ -2011,8 +2010,8 @@ noexcept_conv_p (tree to, tree from)\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n       f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n     }\n-  if (TREE_CODE (t) == POINTER_TYPE\n-      && TREE_CODE (f) == POINTER_TYPE)\n+  if (TYPE_PTR_P (t)\n+      && TYPE_PTR_P (f))\n     {\n       t = TREE_TYPE (t);\n       f = TREE_TYPE (f);\n@@ -2042,8 +2041,8 @@ fnptr_conv_p (tree to, tree from)\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n       f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n     }\n-  if (TREE_CODE (t) == POINTER_TYPE\n-      && TREE_CODE (f) == POINTER_TYPE)\n+  if (TYPE_PTR_P (t)\n+      && TYPE_PTR_P (f))\n     {\n       t = TREE_TYPE (t);\n       f = TREE_TYPE (f);"}, {"sha": "59d6badf481e12b539e5ee429ffb58b00577fb6d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -674,7 +674,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t      }\n \t    else if (DECL_CONTEXT (decl) == current_function_decl\n \t\t     // For -Wunused-but-set-variable leave references alone.\n-\t\t     && TREE_CODE (TREE_TYPE (decl)) != REFERENCE_TYPE\n+\t\t     && !TYPE_REF_P (TREE_TYPE (decl))\n \t\t     && errorcount == unused_but_set_errorcount)\n \t      {\n \t\tif (!DECL_NAME (decl) && DECL_DECOMPOSITION_P (decl))\n@@ -5562,7 +5562,7 @@ check_for_uninitialized_const_var (tree decl, bool constexpr_context_p,\n      external linkage and must be initialized. ($8.4; $12.1)'' ARM\n      7.1.6 */\n   if (VAR_P (decl)\n-      && TREE_CODE (type) != REFERENCE_TYPE\n+      && !TYPE_REF_P (type)\n       && (constexpr_context_p\n \t  || CP_TYPE_CONST_P (type) || var_in_constexpr_fn (decl))\n       && !DECL_NONTRIVIALLY_INITIALIZED_P (decl))\n@@ -6265,7 +6265,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \n   if (TREE_CODE (decl) == CONST_DECL)\n     {\n-      gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n+      gcc_assert (!TYPE_REF_P (type));\n \n       DECL_INITIAL (decl) = init;\n \n@@ -6275,9 +6275,9 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n   else if (!init && DECL_REALLY_EXTERN (decl))\n     ;\n   else if (init || type_build_ctor_call (type)\n-\t   || TREE_CODE (type) == REFERENCE_TYPE)\n+\t   || TYPE_REF_P (type))\n     {\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (type))\n \t{\n \t  init = grok_reference_init (decl, type, init, flags);\n \t  flags |= LOOKUP_ALREADY_DIGESTED;\n@@ -6616,7 +6616,7 @@ initialize_local_var (tree decl, tree init)\n \t  gcc_assert (TREE_OPERAND (init, 0) == decl);\n \t  DECL_INITIAL (decl) = rinit;\n \n-\t  if (warn_init_self && TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (warn_init_self && TYPE_REF_P (type))\n \t    {\n \t      STRIP_NOPS (rinit);\n \t      if (rinit == decl)\n@@ -6889,7 +6889,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       /* If DECL is a reference, then we want to know whether init is a\n \t reference constant; init_const_expr_p as passed tells us whether\n \t it's an rvalue constant.  */\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (type))\n \tinit_const_expr_p = potential_constant_expression (init);\n       if (init_const_expr_p)\n \t{\n@@ -6898,7 +6898,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n \t  if (decl_maybe_constant_var_p (decl)\n \t      /* FIXME setting TREE_CONSTANT on refs breaks the back end.  */\n-\t      && TREE_CODE (type) != REFERENCE_TYPE)\n+\t      && !TYPE_REF_P (type))\n \t    TREE_CONSTANT (decl) = 1;\n \t}\n     }\n@@ -6935,7 +6935,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n       else if (init\n \t       && init_const_expr_p\n-\t       && TREE_CODE (type) != REFERENCE_TYPE\n+\t       && !TYPE_REF_P (type)\n \t       && decl_maybe_constant_var_p (decl)\n \t       && !(dep_init = value_dependent_init_p (init)))\n \t{\n@@ -7004,7 +7004,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   /* A reference will be modified here, as it is initialized.  */\n   if (! DECL_EXTERNAL (decl)\n       && TREE_READONLY (decl)\n-      && TREE_CODE (type) == REFERENCE_TYPE)\n+      && TYPE_REF_P (type))\n     {\n       was_readonly = 1;\n       TREE_READONLY (decl) = 0;\n@@ -7345,7 +7345,7 @@ get_tuple_decomp_init (tree decl, unsigned i)\n \n   /* [The id-expression] e is an lvalue if the type of the entity e is an\n      lvalue reference and an xvalue otherwise.  */\n-  if (TREE_CODE (etype) != REFERENCE_TYPE\n+  if (!TYPE_REF_P (etype)\n       || TYPE_REF_IS_RVALUE (etype))\n     e = move (e);\n \n@@ -7488,7 +7488,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n   tree type = TREE_TYPE (decl);\n   tree dexp = decl;\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       dexp = convert_from_reference (dexp);\n       type = complete_type (TREE_TYPE (type));\n@@ -11298,7 +11298,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  /* Filter out pointers-to-references and references-to-references.\n \t     We can get these if a TYPE_DECL is used.  */\n \n-\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (TYPE_REF_P (type))\n \t    {\n \t      if (declarator->kind != cdk_reference)\n \t\t{\n@@ -11404,7 +11404,7 @@ grokdeclarator (const cp_declarator *declarator,\n               */\n \t      if (VOID_TYPE_P (type))\n \t\t/* We already gave an error.  */;\n-\t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t      else if (TYPE_REF_P (type))\n \t\t{\n \t\t  if (declarator->u.reference.rvalue_ref)\n \t\t    /* Leave type alone.  */;\n@@ -11485,7 +11485,7 @@ grokdeclarator (const cp_declarator *declarator,\n       /* DR1688 says that a `constexpr' specifier in combination with\n \t `volatile' is valid.  */\n \n-      if (TREE_CODE (type) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (type))\n \t{\n \t  type_quals |= TYPE_QUAL_CONST;\n \t  type = cp_build_qualified_type (type, type_quals);\n@@ -11668,7 +11668,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  error (\"const %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n-      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+      else if (TYPE_REF_P (type))\n \t{\n \t  permerror (input_location, \"reference %qs cannot be declared \"\n \t             \"%<mutable%>\", name);\n@@ -12894,7 +12894,7 @@ copy_fn_p (const_tree d)\n       /* Pass by value copy assignment operator.  */\n       result = -1;\n     }\n-  else if (TREE_CODE (arg_type) == REFERENCE_TYPE\n+  else if (TYPE_REF_P (arg_type)\n \t   && !TYPE_REF_IS_RVALUE (arg_type)\n \t   && TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)) == DECL_CONTEXT (d))\n     {\n@@ -12962,7 +12962,7 @@ move_signature_fn_p (const_tree d)\n   if (arg_type == error_mark_node)\n     return 0;\n \n-  if (TREE_CODE (arg_type) == REFERENCE_TYPE\n+  if (TYPE_REF_P (arg_type)\n       && TYPE_REF_IS_RVALUE (arg_type)\n       && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)),\n                       DECL_CONTEXT (d)))\n@@ -13334,7 +13334,7 @@ grok_op_properties (tree decl, bool complain)\n       && warn_conversion)\n     {\n       tree t = TREE_TYPE (name);\n-      int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n+      int ref = TYPE_REF_P (t);\n \n       if (ref)\n \tt = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n@@ -13388,14 +13388,14 @@ grok_op_properties (tree decl, bool complain)\n     {\n       tree arg = TREE_VALUE (argtypes);\n       tree ret = TREE_TYPE (TREE_TYPE (decl));\n-      if (methodp || TREE_CODE (arg) == REFERENCE_TYPE)\n+      if (methodp || TYPE_REF_P (arg))\n \targ = TREE_TYPE (arg);\n       arg = TYPE_MAIN_VARIANT (arg);\n \n       if (operator_code == PREINCREMENT_EXPR\n \t  || operator_code == PREDECREMENT_EXPR)\n \t{\n-\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n+\t  if (!TYPE_REF_P (ret)\n \t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)), arg))\n \t    warning (OPT_Weffc__, \"prefix %qD should return %qT\", decl,\n \t\t     build_reference_type (arg));\n@@ -13414,7 +13414,7 @@ grok_op_properties (tree decl, bool complain)\n \t  || operator_code == TRUNC_DIV_EXPR\n \t  || operator_code == MULT_EXPR\n \t  || operator_code == TRUNC_MOD_EXPR)\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n+      && TYPE_REF_P (TREE_TYPE (TREE_TYPE (decl))))\n     warning (OPT_Weffc__, \"%qD should return by value\", decl);\n \n   return true;\n@@ -15822,7 +15822,7 @@ finish_function (bool inline_p)\n \t    && !TREE_NO_WARNING (decl)\n \t    && !DECL_IN_SYSTEM_HEADER (decl)\n \t    && TREE_TYPE (decl) != error_mark_node\n-\t    && TREE_CODE (TREE_TYPE (decl)) != REFERENCE_TYPE\n+\t    && !TYPE_REF_P (TREE_TYPE (decl))\n \t    && (!CLASS_TYPE_P (TREE_TYPE (decl))\n \t        || !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl))))\n \t  warning_at (DECL_SOURCE_LOCATION (decl),"}, {"sha": "0a6cf91a82d056aa48a44a6f2aa59a6a4230a71e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -462,7 +462,7 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n       if (array_expr == error_mark_node || index_exp == error_mark_node)\n \terror (\"ambiguous conversion for array subscript\");\n \n-      if (TREE_CODE (TREE_TYPE (array_expr)) == POINTER_TYPE)\n+      if (TYPE_PTR_P (TREE_TYPE (array_expr)))\n \tarray_expr = mark_rvalue_use (array_expr);\n       else\n \tarray_expr = mark_lvalue_use_nonread (array_expr);\n@@ -1345,7 +1345,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n       outer = build_pointer_type_for_mode (inner, TYPE_MODE (type),\n \t\t\t\t\t   TYPE_REF_CAN_ALIAS_ALL (type));\n     }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (type))\n     {\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_reference_type_for_mode (inner, TYPE_MODE (type),\n@@ -4275,7 +4275,7 @@ decl_maybe_constant_var_p (tree decl)\n   if (DECL_HAS_VALUE_EXPR_P (decl))\n     /* A proxy isn't constant.  */\n     return false;\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     /* References can be constant.  */;\n   else if (CP_TYPE_CONST_NON_VOLATILE_P (type)\n \t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))"}, {"sha": "374ab0dd804fe6843a3efd010eaebf3042c1c436", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -784,13 +784,13 @@ dump_type_prefix (cxx_pretty_printer *pp, tree t, int flags)\n \t  }\n \tif (TYPE_PTR_P (t))\n \t  pp_star (pp);\n-\telse if (TREE_CODE (t) == REFERENCE_TYPE)\n-\t{\n-\t  if (TYPE_REF_IS_RVALUE (t))\n-\t    pp_ampersand_ampersand (pp);\n-\t  else\n-\t    pp_ampersand (pp);\n-\t}\n+\telse if (TYPE_REF_P (t))\n+\t  {\n+\t    if (TYPE_REF_IS_RVALUE (t))\n+\t      pp_ampersand_ampersand (pp);\n+\t    else\n+\t      pp_ampersand (pp);\n+\t  }\n \tpp->padding = pp_before;\n \tpp_cxx_cv_qualifier_seq (pp, t);\n       }\n@@ -2271,7 +2271,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \t    if (!is_this_parameter (ob))\n \t      {\n \t\tdump_expr (pp, ob, flags | TFF_EXPR_IN_PARENS);\n-\t\tif (TREE_CODE (TREE_TYPE (ob)) == REFERENCE_TYPE)\n+\t\tif (TYPE_REF_P (TREE_TYPE (ob)))\n \t\t  pp_cxx_dot (pp);\n \t\telse\n \t\t  pp_cxx_arrow (pp);\n@@ -2305,7 +2305,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \t     shouldn't print the `&' doing so indicates to the user\n \t     that the expression has pointer type.  */\n \t  || (TREE_TYPE (t)\n-\t      && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE))\n+\t      && TYPE_REF_P (TREE_TYPE (t))))\n \tdump_expr (pp, TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       else if (TREE_CODE (TREE_OPERAND (t, 0)) == LABEL_DECL)\n \tdump_unary_op (pp, \"&&\", t, flags);\n@@ -2417,7 +2417,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n \t    && same_type_p (TREE_TYPE (optype),\n \t\t\t    TREE_TYPE (ttype)))\n \t  {\n-\t    if (TREE_CODE (ttype) == REFERENCE_TYPE)\n+\t    if (TYPE_REF_P (ttype))\n \t      {\n \t\tSTRIP_NOPS (op);\n \t\tif (TREE_CODE (op) == ADDR_EXPR)"}, {"sha": "45996191d582330e1b4fd72e2157c3269b39854a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -306,7 +306,7 @@ initialize_handler_parm (tree decl, tree exp)\n \n   /* Since pointers are passed by value, initialize a reference to\n      pointer catch parm with the address of the temporary.  */\n-  if (TREE_CODE (init_type) == REFERENCE_TYPE\n+  if (TYPE_REF_P (init_type)\n       && TYPE_PTR_P (TREE_TYPE (init_type)))\n     exp = cp_build_addr_expr (exp, tf_warning_or_error);\n \n@@ -802,7 +802,7 @@ complete_ptr_ref_or_void_ptr_p (tree type, tree from)\n \n   /* Or a pointer or ref to one, or cv void *.  */\n   is_ptr = TYPE_PTR_P (type);\n-  if (is_ptr || TREE_CODE (type) == REFERENCE_TYPE)\n+  if (is_ptr || TYPE_REF_P (type))\n     {\n       tree core = TREE_TYPE (type);\n \n@@ -846,7 +846,7 @@ is_admissible_throw_operand_or_catch_parameter (tree t, bool is_throw)\n   else if (abstract_virtuals_error (is_throw ? ACU_THROW : ACU_CATCH, type))\n     return false;\n   else if (!is_throw\n-\t   && TREE_CODE (type) == REFERENCE_TYPE\n+\t   && TYPE_REF_P (type)\n \t   && TYPE_REF_IS_RVALUE (type))\n     {\n       error (\"cannot declare catch parameter to be of rvalue \""}, {"sha": "0d0a10ec4a6388f5cf28e7aaca3faf1da2af6a1b", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -141,7 +141,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t    }\n \t  expr = process_outer_var_ref (expr, tf_warning_or_error, true);\n \t  if (!(TREE_TYPE (oexpr)\n-\t\t&& TREE_CODE (TREE_TYPE (oexpr)) == REFERENCE_TYPE))\n+\t\t&& TYPE_REF_P (TREE_TYPE (oexpr))))\n \t    expr = convert_from_reference (expr);\n \t}\n       break;\n@@ -166,7 +166,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t    {\n \t      /* Look through capture by reference.  */\n \t      tree cap = DECL_CAPTURED_VARIABLE (ref);\n-\t      if (TREE_CODE (TREE_TYPE (cap)) != REFERENCE_TYPE\n+\t      if (!TYPE_REF_P (TREE_TYPE (cap))\n \t\t  && decl_constant_var_p (cap))\n \t\t{\n \t\t  tree val = RECUR (cap);"}, {"sha": "d9fb0ea0086f0d3d5e71576846ceb3b5fad2a066", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -287,7 +287,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n     init = build_zero_cst (type);\n   else\n     {\n-      gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+      gcc_assert (TYPE_REF_P (type));\n       init = build_zero_cst (type);\n     }\n \n@@ -502,7 +502,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \terror (\"value-initialization of function type %qT\", type);\n       return error_mark_node;\n     }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (type))\n     {\n       if (complain & tf_error)\n \terror (\"value-initialization of reference type %qT\", type);\n@@ -751,7 +751,7 @@ perform_member_init (tree member, tree init)\n \t}\n     }\n   else if (init\n-\t   && (TREE_CODE (type) == REFERENCE_TYPE\n+\t   && (TYPE_REF_P (type)\n \t       /* Pre-digested NSDMI.  */\n \t       || (((TREE_CODE (init) == CONSTRUCTOR\n \t\t     && TREE_TYPE (init) == type)\n@@ -856,7 +856,7 @@ perform_member_init (tree member, tree init)\n \t{\n \t  tree core_type;\n \t  /* member traversal: note it leaves init NULL */\n-\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (TYPE_REF_P (type))\n \t    {\n \t      if (permerror (DECL_SOURCE_LOCATION (current_function_decl),\n \t\t\t     \"uninitialized reference member in %q#T\", type))\n@@ -2368,7 +2368,7 @@ diagnose_uninitialized_cst_or_ref_member_1 (tree type, tree origin,\n       if (type_has_user_provided_constructor (field_type))\n \tcontinue;\n \n-      if (TREE_CODE (field_type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (field_type))\n \t{\n \t  ++ error_count;\n \t  if (complain)\n@@ -3659,7 +3659,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n   /* ``A reference cannot be created by the new operator.  A reference\n      is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n      returned by new.'' ARM 5.3.3 */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       if (complain & tf_error)\n         error (\"new cannot be applied to a reference type\");\n@@ -4586,7 +4586,7 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (type) == POINTER_TYPE)\n+  if (TYPE_PTR_P (type))\n     type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \n   if (TREE_CODE (type) == ARRAY_TYPE)"}, {"sha": "cf7c38096ee757d92e6acde5f733f11fff012bf5", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -90,7 +90,7 @@ build_lambda_object (tree lambda_expr)\n \tval = build_array_copy (val);\n       else if (DECL_NORMAL_CAPTURE_P (field)\n \t       && !DECL_VLA_CAPTURE_P (field)\n-\t       && TREE_CODE (TREE_TYPE (field)) != REFERENCE_TYPE)\n+\t       && !TYPE_REF_P (TREE_TYPE (field)))\n \t{\n \t  /* \"the entities that are captured by copy are used to\n \t     direct-initialize each corresponding non-static data"}, {"sha": "58b33117415916461989c910da759e09971e9245", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -3071,7 +3071,7 @@ write_expression (tree expr)\n     }\n   else if (INDIRECT_REF_P (expr)\n \t   && TREE_TYPE (TREE_OPERAND (expr, 0))\n-\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == REFERENCE_TYPE)\n+\t   && TYPE_REF_P (TREE_TYPE (TREE_OPERAND (expr, 0))))\n     {\n       write_expression (TREE_OPERAND (expr, 0));\n     }\n@@ -3209,7 +3209,7 @@ write_expression (tree expr)\n \t don't actually want to output a mangling code for the `&'.  */\n       if (TREE_CODE (expr) == ADDR_EXPR\n \t  && TREE_TYPE (expr)\n-\t  && TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n+\t  && TYPE_REF_P (TREE_TYPE (expr)))\n \t{\n \t  expr = TREE_OPERAND (expr, 0);\n \t  if (DECL_P (expr))\n@@ -3473,7 +3473,7 @@ write_template_arg (tree node)\n   if (REFERENCE_REF_P (node))\n     node = TREE_OPERAND (node, 0);\n   if (TREE_CODE (node) == NOP_EXPR\n-      && TREE_CODE (TREE_TYPE (node)) == REFERENCE_TYPE)\n+      && TYPE_REF_P (TREE_TYPE (node)))\n     {\n       /* Template parameters can be of reference type. To maintain\n \t internal consistency, such arguments use a conversion from"}, {"sha": "e9add9addc41015cebe620f2c900b135c0a7df9d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -468,7 +468,7 @@ forward_parm (tree parm)\n   tree type = TREE_TYPE (parm);\n   if (DECL_PACK_P (parm))\n     type = PACK_EXPANSION_PATTERN (type);\n-  if (TREE_CODE (type) != REFERENCE_TYPE)\n+  if (!TYPE_REF_P (type))\n     type = cp_build_reference_type (type, /*rval=*/true);\n   warning_sentinel w (warn_useless_cast);\n   exp = build_static_cast (type, exp, tf_warning_or_error);\n@@ -731,7 +731,7 @@ do_build_copy_constructor (tree fndecl)\n \t     the field is \"T\", then the type will usually be \"const\n \t     T\".  (There are no cv-qualified variants of reference\n \t     types.)  */\n-\t  if (TREE_CODE (expr_type) != REFERENCE_TYPE)\n+\t  if (!TYPE_REF_P (expr_type))\n \t    {\n \t      int quals = cvquals;\n \n@@ -742,7 +742,7 @@ do_build_copy_constructor (tree fndecl)\n \t    }\n \n \t  init = build3 (COMPONENT_REF, expr_type, parm, field, NULL_TREE);\n-\t  if (move_p && TREE_CODE (expr_type) != REFERENCE_TYPE\n+\t  if (move_p && !TYPE_REF_P (expr_type)\n \t      /* 'move' breaks bit-fields, and has no effect for scalars.  */\n \t      && !scalarish_type_p (expr_type))\n \t    init = move (init);\n@@ -829,7 +829,7 @@ do_build_copy_assign (tree fndecl)\n \t\t     \"assignment operator\", field);\n \t      continue;\n \t    }\n-\t  else if (TREE_CODE (expr_type) == REFERENCE_TYPE)\n+\t  else if (TYPE_REF_P (expr_type))\n \t    {\n \t      error (\"non-static reference member %q#D, can%'t use \"\n \t\t     \"default assignment operator\", field);\n@@ -858,7 +858,7 @@ do_build_copy_assign (tree fndecl)\n \t  expr_type = cp_build_qualified_type (expr_type, quals);\n \n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n-\t  if (move_p && TREE_CODE (expr_type) != REFERENCE_TYPE\n+\t  if (move_p && !TYPE_REF_P (expr_type)\n \t      /* 'move' breaks bit-fields, and has no effect for scalars.  */\n \t      && !scalarish_type_p (expr_type))\n \t    init = move (init);\n@@ -970,7 +970,7 @@ build_stub_type (tree type, int quals, bool rvalue)\n static tree\n build_stub_object (tree reftype)\n {\n-  if (TREE_CODE (reftype) != REFERENCE_TYPE)\n+  if (!TYPE_REF_P (reftype))\n     reftype = cp_build_reference_type (reftype, /*rval*/true);\n   tree stub = build1 (CONVERT_EXPR, reftype, integer_one_node);\n   return convert_from_reference (stub);\n@@ -1149,7 +1149,7 @@ constructible_expr (tree to, tree from)\n       tree ctype = to;\n       vec<tree, va_gc> *args = NULL;\n       cp_unevaluated cp_uneval_guard;\n-      if (TREE_CODE (to) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (to))\n \tto = cp_build_reference_type (to, /*rval*/false);\n       tree ob = build_stub_object (to);\n       for (; from; from = TREE_CHAIN (from))\n@@ -1324,7 +1324,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\terror (\"non-static const member %q#D, can%'t use default \"\n \t\t       \"assignment operator\", field);\n \t    }\n-\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t  else if (TYPE_REF_P (mem_type))\n \t    {\n \t      if (diag)\n \t\terror (\"non-static reference member %q#D, can%'t use \"\n@@ -1372,7 +1372,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t}\n \t      bad = true;\n \t    }\n-\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t  else if (TYPE_REF_P (mem_type))\n \t    {\n \t      if (diag)\n \t\t{\n@@ -1403,7 +1403,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n       else if (sfk == sfk_copy_constructor)\n \t{\n \t  /* 12.8p11b5 */\n-\t  if (TREE_CODE (mem_type) == REFERENCE_TYPE\n+\t  if (TYPE_REF_P (mem_type)\n \t      && TYPE_REF_IS_RVALUE (mem_type))\n \t    {\n \t      if (diag)"}, {"sha": "a06516b645df81b853b2bac4be3a377e4c1590fd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -34954,7 +34954,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t      init = cp_parser_assignment_expression (parser);\n \n \t    non_class:\n-\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n+\t      if (TYPE_REF_P (TREE_TYPE (decl)))\n \t\tinit = error_mark_node;\n \t      else\n \t\tcp_finish_decl (decl, NULL_TREE,\n@@ -37417,7 +37417,7 @@ static bool\n cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n {\n   tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n-  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+  gcc_assert (TYPE_REF_P (type));\n   type = TREE_TYPE (type);\n   tree omp_out = build_lang_decl (VAR_DECL, get_identifier (\"omp_out\"), type);\n   DECL_ARTIFICIAL (omp_out) = 1;\n@@ -37656,7 +37656,7 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n \t       || TREE_CODE (type) == ARRAY_TYPE)\n \terror_at (loc, \"function or array type %qT in \"\n \t\t       \"%<#pragma omp declare reduction%>\", type);\n-      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+      else if (TYPE_REF_P (type))\n \terror_at (loc, \"reference type %qT in \"\n \t\t       \"%<#pragma omp declare reduction%>\", type);\n       else if (TYPE_QUALS_NO_ADDR_SPACE (type))"}, {"sha": "ddfda2e08ce1ed897844ac245f17a63c69a8183b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -6277,7 +6277,7 @@ convert_nontype_argument_function (tree type, tree expr,\n     }\n \n  accept:\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       if (REFERENCE_REF_P (fn))\n \tfn = TREE_OPERAND (fn, 0);\n@@ -6686,7 +6686,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t}\n     }\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     expr = mark_lvalue_use (expr);\n   else\n     expr = mark_rvalue_use (expr);\n@@ -6711,7 +6711,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t     could actually change the type to something more cv-qualified,\n \t     and this is not folded by convert_from_reference.  */\n \t  tree addr = TREE_OPERAND (probe, 0);\n-\t  if (TREE_CODE (probe_type) == REFERENCE_TYPE\n+\t  if (TYPE_REF_P (probe_type)\n \t      && TREE_CODE (addr) == ADDR_EXPR\n \t      && TYPE_PTR_P (TREE_TYPE (addr))\n \t      && (same_type_ignoring_top_level_qualifiers_p\n@@ -8019,7 +8019,7 @@ convert_template_argument (tree parm,\n           const_tree inner = TREE_OPERAND (val, 0);\n \t  const_tree innertype = TREE_TYPE (inner);\n \t  if (innertype\n-\t      && TREE_CODE (innertype) == REFERENCE_TYPE\n+\t      && TYPE_REF_P (innertype)\n \t      && TREE_CODE (TREE_TYPE (innertype)) == FUNCTION_TYPE\n \t      && TREE_OPERAND_LENGTH (inner) > 0\n               && reject_gcc_builtin (TREE_OPERAND (inner, 0)))\n@@ -12204,7 +12204,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       /* Also optimize expression pack expansions if we can tell that the\n \t elements won't have reference type.  */\n       tree type = TREE_TYPE (pattern);\n-      if (type && TREE_CODE (type) != REFERENCE_TYPE\n+      if (type && !TYPE_REF_P (type)\n \t  && !PACK_EXPANSION_P (type)\n \t  && !WILDCARD_TYPE_P (type))\n \treturn args;\n@@ -12941,7 +12941,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n       tree argtype\n \t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (t))));\n       argtype = tsubst (argtype, args, complain, in_decl);\n-      if (TREE_CODE (argtype) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (argtype))\n \terror_at (DECL_SOURCE_LOCATION (t),\n \t\t  \"reference type %qT in \"\n \t\t  \"%<#pragma omp declare reduction%>\", argtype);\n@@ -13723,7 +13723,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t\t\t  /*constant_expression_p=*/false);\n \t\tif (REFERENCE_REF_P (ve))\n \t\t  {\n-\t\t    gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+\t\t    gcc_assert (TYPE_REF_P (type));\n \t\t    ve = TREE_OPERAND (ve, 0);\n \t\t  }\n \t\tSET_DECL_VALUE_EXPR (r, ve);\n@@ -14620,7 +14620,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  Core issue 106 says that creating a reference to a reference\n \t  during instantiation is no longer a cause for failure. We\n \t  only enforce this check in strict C++98 mode.  */\n-\tif ((TREE_CODE (type) == REFERENCE_TYPE\n+\tif ((TYPE_REF_P (type)\n \t     && (((cxx_dialect == cxx98) && flag_iso) || code != REFERENCE_TYPE))\n \t    || (code == REFERENCE_TYPE && VOID_TYPE_P (type)))\n \t  {\n@@ -14664,7 +14664,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      r = build_ptrmemfunc_type (r);\n \t  }\n-\telse if (TREE_CODE (type) == REFERENCE_TYPE)\n+\telse if (TYPE_REF_P (type))\n \t  /* In C++0x, during template argument substitution, when there is an\n \t     attempt to create a reference to a reference type, reference\n \t     collapsing is applied as described in [14.3.1/4 temp.arg.type]:\n@@ -14704,7 +14704,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      error (\"creating pointer to member of non-class type %qT\", r);\n \t    return error_mark_node;\n \t  }\n-\tif (TREE_CODE (type) == REFERENCE_TYPE)\n+\tif (TYPE_REF_P (type))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"creating pointer to member reference type %qT\", type);\n@@ -14776,7 +14776,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    || TREE_CODE (type) == FUNCTION_TYPE\n \t    || (TREE_CODE (type) == ARRAY_TYPE\n \t\t&& TYPE_DOMAIN (type) == NULL_TREE)\n-\t    || TREE_CODE (type) == REFERENCE_TYPE)\n+\t    || TYPE_REF_P (type))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"creating array of %qT\", type);\n@@ -18862,7 +18862,7 @@ tsubst_copy_and_build (tree t,\n \telse if (outer_automatic_var_p (r))\n \t  r = process_outer_var_ref (r, complain);\n \n-\tif (TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+\tif (!TYPE_REF_P (TREE_TYPE (t)))\n \t  /* If the original type was a reference, we'll be wrapped in\n \t     the appropriate INDIRECT_REF.  */\n \t  r = convert_from_reference (r);\n@@ -19728,11 +19728,11 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       /* Core issue #873: Do the DR606 thing (see below) for these cases,\n \t too, but here handle it by stripping the reference from PARM\n \t rather than by adding it to ARG.  */\n-      if (TREE_CODE (*parm) == REFERENCE_TYPE\n+      if (TYPE_REF_P (*parm)\n \t  && TYPE_REF_IS_RVALUE (*parm)\n \t  && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n \t  && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED\n-\t  && TREE_CODE (*arg) == REFERENCE_TYPE\n+\t  && TYPE_REF_P (*arg)\n \t  && !TYPE_REF_IS_RVALUE (*arg))\n \t*parm = TREE_TYPE (*parm);\n       /* Nothing else to do in this case.  */\n@@ -19742,7 +19742,7 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       gcc_unreachable ();\n     }\n \n-  if (TREE_CODE (*parm) != REFERENCE_TYPE)\n+  if (!TYPE_REF_P (*parm))\n     {\n       /* [temp.deduct.call]\n \n@@ -19774,7 +19774,7 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n      deduction (13.3.1.8)). If P is a forwarding reference and the argument is\n      an lvalue, the type \"lvalue reference to A\" is used in place of A for type\n      deduction. */\n-  if (TREE_CODE (*parm) == REFERENCE_TYPE\n+  if (TYPE_REF_P (*parm)\n       && TYPE_REF_IS_RVALUE (*parm)\n       && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n       && !TEMPLATE_TYPE_PARM_FOR_CLASS (TREE_TYPE (*parm))\n@@ -19792,15 +19792,15 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n      reference type, the type referred to by P is used for\n      type deduction.  */\n   *parm = TYPE_MAIN_VARIANT (*parm);\n-  if (TREE_CODE (*parm) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (*parm))\n     {\n       *parm = TREE_TYPE (*parm);\n       result |= UNIFY_ALLOW_OUTER_MORE_CV_QUAL;\n     }\n \n   /* DR 322. For conversion deduction, remove a reference type on parm\n      too (which has been swapped into ARG).  */\n-  if (strict == DEDUCE_CONV && TREE_CODE (*arg) == REFERENCE_TYPE)\n+  if (strict == DEDUCE_CONV && TYPE_REF_P (*arg))\n     *arg = TREE_TYPE (*arg);\n \n   return result;\n@@ -20937,7 +20937,7 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n \t  types are not of the form \"cv-list T\" [14.8.2.5 temp.deduct.type].\n \t  It is ok when we're allowing additional CV qualifiers\n \t  at the outer level [14.8.2.1]/3,1st bullet.  */\n-      if ((TREE_CODE (arg) == REFERENCE_TYPE\n+      if ((TYPE_REF_P (arg)\n \t   || TREE_CODE (arg) == FUNCTION_TYPE\n \t   || TREE_CODE (arg) == METHOD_TYPE)\n \t  && (parm_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)))\n@@ -21744,7 +21744,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       }\n \n     case REFERENCE_TYPE:\n-      if (TREE_CODE (arg) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (arg))\n \treturn unify_type_mismatch (explain_p, parm, arg);\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n \t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL, explain_p);\n@@ -22308,14 +22308,14 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n \t  && !uses_deducible_template_parms (arg2))\n \tgoto next;\n \n-      if (TREE_CODE (arg1) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (arg1))\n \t{\n \t  ref1 = TYPE_REF_IS_RVALUE (arg1) + 1;\n \t  arg1 = TREE_TYPE (arg1);\n \t  quals1 = cp_type_quals (arg1);\n \t}\n \n-      if (TREE_CODE (arg2) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (arg2))\n \t{\n \t  ref2 = TYPE_REF_IS_RVALUE (arg2) + 1;\n \t  arg2 = TREE_TYPE (arg2);\n@@ -24400,7 +24400,7 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n     return false;\n   else if (TYPE_PTR_P (type))\n     return false;\n-  else if (TREE_CODE (type) == REFERENCE_TYPE\n+  else if (TYPE_REF_P (type)\n \t   && !TYPE_REF_IS_RVALUE (type))\n     return false;\n   else if (TYPE_PTRMEM_P (type))\n@@ -24470,7 +24470,7 @@ dependent_type_p_r (tree type)\n \t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE\n \t\t\t\t\t   (type)));\n   else if (TYPE_PTR_P (type)\n-\t   || TREE_CODE (type) == REFERENCE_TYPE)\n+\t   || TYPE_REF_P (type))\n     return dependent_type_p (TREE_TYPE (type));\n   else if (TREE_CODE (type) == FUNCTION_TYPE\n \t   || TREE_CODE (type) == METHOD_TYPE)\n@@ -24719,7 +24719,7 @@ value_dependent_expression_p (tree expression)\n \t  with an expression that is value-dependent.  */\n       if (DECL_DEPENDENT_INIT_P (expression)\n \t  /* FIXME cp_finish_decl doesn't fold reference initializers.  */\n-\t  || TREE_CODE (TREE_TYPE (expression)) == REFERENCE_TYPE)\n+\t  || TYPE_REF_P (TREE_TYPE (expression)))\n \treturn true;\n       if (DECL_HAS_VALUE_EXPR_P (expression))\n \t{\n@@ -26281,7 +26281,7 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n   if (TYPE_P (ctor))\n     {\n       type = ctor;\n-      bool copy_p = TREE_CODE (type) == REFERENCE_TYPE;\n+      bool copy_p = TYPE_REF_P (type);\n       if (copy_p)\n \t{\n \t  type = TREE_TYPE (type);"}, {"sha": "94e8f54254d527e3f80cc62f1ecb0bc616b5961c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -1334,7 +1334,7 @@ finish_handler_parms (tree decl, tree handler)\n       if (warn_catch_value\n \t  && type != NULL_TREE\n \t  && type != error_mark_node\n-\t  && TREE_CODE (TREE_TYPE (decl)) != REFERENCE_TYPE)\n+\t  && !TYPE_REF_P (TREE_TYPE (decl)))\n \t{\n \t  tree orig_type = TREE_TYPE (decl);\n \t  if (CLASS_TYPE_P (orig_type))\n@@ -1835,7 +1835,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n     {\n       tree type = TREE_TYPE (decl);\n \n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (type))\n \t/* Quals on the object don't matter.  */;\n       else if (PACK_EXPANSION_P (type))\n \t/* Don't bother trying to represent this.  */\n@@ -2729,7 +2729,7 @@ finish_compound_literal (tree type, tree compound_literal,\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       compound_literal\n \t= finish_compound_literal (TREE_TYPE (type), compound_literal,\n@@ -4465,7 +4465,7 @@ omp_privatize_field (tree t, bool shared)\n     return error_mark_node;\n   if (!omp_private_member_map && !shared)\n     omp_private_member_map = new hash_map<tree, tree>;\n-  if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (TREE_TYPE (t)))\n     {\n       gcc_assert (INDIRECT_REF_P (m));\n       m = TREE_OPERAND (m, 0);\n@@ -4783,7 +4783,7 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t    }\n \t}\n     }\n-  else if (TREE_CODE (type) == POINTER_TYPE)\n+  else if (TYPE_PTR_P (type))\n     {\n       if (length == NULL_TREE)\n \t{\n@@ -4997,7 +4997,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t\teltype = TREE_TYPE (eltype);\n \t      tree type = build_array_type (eltype, index_type);\n \t      tree ptype = build_pointer_type (eltype);\n-\t      if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t      if (TYPE_REF_P (TREE_TYPE (t))\n \t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n \t\tt = convert_from_reference (t);\n \t      else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n@@ -5084,7 +5084,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t  OMP_CLAUSE_CHAIN (c) = c2;\n \t  ptr = OMP_CLAUSE_DECL (c2);\n \t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t      && TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n+\t      && TYPE_REF_P (TREE_TYPE (ptr))\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n \t    {\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n@@ -5351,7 +5351,7 @@ void\n cp_check_omp_declare_reduction (tree udr)\n {\n   tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (udr)));\n-  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+  gcc_assert (TYPE_REF_P (type));\n   type = TREE_TYPE (type);\n   int i;\n   location_t loc = DECL_SOURCE_LOCATION (udr);\n@@ -5402,7 +5402,7 @@ cp_check_omp_declare_reduction (tree udr)\n \t\t     \"%<#pragma omp declare reduction%>\", type);\n       return;\n     }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (TYPE_REF_P (type))\n     {\n       error_at (loc, \"reference type %qT in %<#pragma omp declare reduction%>\",\n \t\ttype);\n@@ -5511,7 +5511,7 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n   tree type = TREE_TYPE (t);\n   if (TREE_CODE (t) == MEM_REF)\n     type = TREE_TYPE (type);\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     type = TREE_TYPE (type);\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -5651,8 +5651,7 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[0])))\n \t\tcxx_mark_addressable (placeholder);\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[1]))\n-\t\t  && TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n-\t\t     != REFERENCE_TYPE)\n+\t\t  && !TYPE_REF_P (TREE_TYPE (OMP_CLAUSE_DECL (c))))\n \t\tcxx_mark_addressable (decl_placeholder ? decl_placeholder\n \t\t\t\t      : OMP_CLAUSE_DECL (c));\n \t      tree omp_out = placeholder;\n@@ -5770,8 +5769,7 @@ finish_omp_declare_simd_methods (tree t)\n \tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n \t    && integer_zerop (OMP_CLAUSE_DECL (c))\n \t    && OMP_CLAUSE_LINEAR_STEP (c)\n-\t    && TREE_CODE (TREE_TYPE (OMP_CLAUSE_LINEAR_STEP (c)))\n-\t       == POINTER_TYPE)\n+\t    && TYPE_PTR_P (TREE_TYPE (OMP_CLAUSE_LINEAR_STEP (c))))\n \t  {\n \t    tree s = OMP_CLAUSE_LINEAR_STEP (c);\n \t    s = fold_convert_loc (OMP_CLAUSE_LOCATION (c), sizetype, s);\n@@ -5800,7 +5798,7 @@ cp_finish_omp_clause_depend_sink (tree sink_clause)\n   for (; t; t = TREE_CHAIN (t))\n     {\n       tree decl = TREE_VALUE (t);\n-      if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+      if (TYPE_PTR_P (TREE_TYPE (decl)))\n \t{\n \t  tree offset = TREE_PURPOSE (t);\n \t  bool neg = wi::neg_p (wi::to_wide (offset));\n@@ -5923,7 +5921,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      tree type = TREE_TYPE (t);\n \t      if ((OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF\n \t\t   || OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_UVAL)\n-\t\t  && TREE_CODE (type) != REFERENCE_TYPE)\n+\t\t  && !TYPE_REF_P (type))\n \t\t{\n \t\t  error (\"linear clause with %qs modifier applied to \"\n \t\t\t \"non-reference variable with %qT type\",\n@@ -5932,12 +5930,12 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t  break;\n \t\t}\n-\t      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t      if (TYPE_REF_P (type))\n \t\ttype = TREE_TYPE (type);\n \t      if (OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_REF)\n \t\t{\n \t\t  if (!INTEGRAL_TYPE_P (type)\n-\t\t      && TREE_CODE (type) != POINTER_TYPE)\n+\t\t      && !TYPE_PTR_P (type))\n \t\t    {\n \t\t      error (\"linear clause applied to non-integral non-pointer\"\n \t\t\t     \" variable with %qT type\", TREE_TYPE (t));\n@@ -5958,7 +5956,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t))\n \t\t   && (ort != C_ORT_OMP_DECLARE_SIMD\n \t\t       || TREE_CODE (t) != PARM_DECL\n-\t\t       || TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t       || !TYPE_REF_P (TREE_TYPE (t))\n \t\t       || !INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (t)))))\n \t    {\n \t      error (\"linear step expression must be integral\");\n@@ -5991,7 +5989,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t    }\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t  tree type = TREE_TYPE (OMP_CLAUSE_DECL (c));\n-\t\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\t  if (TYPE_REF_P (type))\n \t\t    type = TREE_TYPE (type);\n \t\t  if (OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF)\n \t\t    {\n@@ -6009,7 +6007,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n-\t\t  else if (TREE_CODE (type) == POINTER_TYPE\n+\t\t  else if (TYPE_PTR_P (type)\n \t\t\t   /* Can't multiply the step yet if *this\n \t\t\t      is still incomplete type.  */\n \t\t\t   && (ort != C_ORT_OMP_DECLARE_SIMD\n@@ -6533,9 +6531,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      remove = true;\n \t    }\n \t  else if (!type_dependent_expression_p (t)\n-\t\t   && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE\n+\t\t   && !TYPE_PTR_P (TREE_TYPE (t))\n \t\t   && TREE_CODE (TREE_TYPE (t)) != ARRAY_TYPE\n-\t\t   && (TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t   && (!TYPE_REF_P (TREE_TYPE (t))\n \t\t       || (!POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (t)))\n \t\t\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (t)))\n \t\t\t       != ARRAY_TYPE))))\n@@ -6765,7 +6763,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      break;\n \t    }\n \t  else if (!processing_template_decl\n-\t\t   && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t   && !TYPE_REF_P (TREE_TYPE (t))\n \t\t   && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n \t\t       || (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t   != GOMP_MAP_FIRSTPRIVATE_POINTER))\n@@ -6777,8 +6775,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t     == GOMP_MAP_FIRSTPRIVATE_POINTER)))\n \t\t   && t == OMP_CLAUSE_DECL (c)\n \t\t   && !type_dependent_expression_p (t)\n-\t\t   && !cp_omp_mappable_type ((TREE_CODE (TREE_TYPE (t))\n-\t\t\t\t\t      == REFERENCE_TYPE)\n+\t\t   && !cp_omp_mappable_type (TYPE_REF_P (TREE_TYPE (t))\n \t\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n \t\t\t\t\t     : TREE_TYPE (t)))\n \t    {\n@@ -6845,7 +6842,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  if (!remove\n \t      && !processing_template_decl\n \t      && (ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n-\t      && TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c))) == REFERENCE_TYPE)\n+\t      && TYPE_REF_P (TREE_TYPE (OMP_CLAUSE_DECL (c))))\n \t    {\n \t      t = OMP_CLAUSE_DECL (c);\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n@@ -7043,10 +7040,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  if (!type_dependent_expression_p (t))\n \t    {\n \t      tree type = TREE_TYPE (t);\n-\t      if (TREE_CODE (type) != POINTER_TYPE\n+\t      if (!TYPE_PTR_P (type)\n \t\t  && TREE_CODE (type) != ARRAY_TYPE\n-\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n-\t\t      || (TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+\t\t  && (!TYPE_REF_P (type)\n+\t\t      || (!TYPE_PTR_P (TREE_TYPE (type))\n \t\t\t  && TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE)))\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n@@ -7287,7 +7284,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  t = require_complete_type (t);\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t  else if (TYPE_REF_P (TREE_TYPE (t))\n \t\t   && !complete_type_or_else (TREE_TYPE (TREE_TYPE (t)), t))\n \t    remove = true;\n \t}\n@@ -7328,7 +7325,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n       if ((need_complete_type\n \t   || need_copy_assignment\n \t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n-\t  && TREE_CODE (inner_type) == REFERENCE_TYPE)\n+\t  && TYPE_REF_P (inner_type))\n \tinner_type = TREE_TYPE (inner_type);\n       while (TREE_CODE (inner_type) == ARRAY_TYPE)\n \tinner_type = TREE_TYPE (inner_type);\n@@ -8878,7 +8875,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n \t     decltype(e) is defined as T&; if an xvalue, T&&; otherwise, T. */\n \t  cp_lvalue_kind clk = lvalue_kind (expr);\n \t  type = unlowered_expr_type (expr);\n-\t  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n+\t  gcc_assert (!TYPE_REF_P (type));\n \n \t  /* For vector types, pick a non-opaque variant.  */\n \t  if (VECTOR_TYPE_P (type))\n@@ -9258,22 +9255,22 @@ capture_decltype (tree decl)\n \n       case CPLD_COPY:\n \ttype = TREE_TYPE (decl);\n-\tif (TREE_CODE (type) == REFERENCE_TYPE\n+\tif (TYPE_REF_P (type)\n \t    && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n \t  type = TREE_TYPE (type);\n \tbreak;\n \n       case CPLD_REFERENCE:\n \ttype = TREE_TYPE (decl);\n-\tif (TREE_CODE (type) != REFERENCE_TYPE)\n+\tif (!TYPE_REF_P (type))\n \t  type = build_reference_type (TREE_TYPE (decl));\n \tbreak;\n \n       default:\n \tgcc_unreachable ();\n       }\n \n-  if (TREE_CODE (type) != REFERENCE_TYPE)\n+  if (!TYPE_REF_P (type))\n     {\n       if (!LAMBDA_EXPR_MUTABLE_P (lam))\n \ttype = cp_build_qualified_type (type, (cp_type_quals (type)\n@@ -9363,7 +9360,7 @@ finish_builtin_launder (location_t loc, tree arg, tsubst_flags_t complain)\n   if (error_operand_p (arg))\n     return error_mark_node;\n   if (!type_dependent_expression_p (arg)\n-      && TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n+      && !TYPE_PTR_P (TREE_TYPE (arg)))\n     {\n       error_at (loc, \"non-pointer argument to %<__builtin_launder%>\");\n       return error_mark_node;"}, {"sha": "b2efab68a8c289f057aae6b49dc693050e06d717", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -65,7 +65,7 @@ lvalue_kind (const_tree ref)\n     return lvalue_kind (TREE_OPERAND (ref, 0));\n \n   if (TREE_TYPE (ref)\n-      && TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n+      && TYPE_REF_P (TREE_TYPE (ref)))\n     {\n       /* unnamed rvalue references are rvalues */\n       if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref))\n@@ -1100,7 +1100,7 @@ cp_build_reference_type (tree to_type, bool rval)\n   if (to_type == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (to_type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (to_type))\n     {\n       rval = rval && TYPE_REF_IS_RVALUE (to_type);\n       to_type = TREE_TYPE (to_type);\n@@ -1148,7 +1148,7 @@ tree\n move (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n-  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n+  gcc_assert (!TYPE_REF_P (type));\n   type = cp_build_reference_type (type, /*rval*/true);\n   return build_static_cast (type, expr, tf_warning_or_error);\n }\n@@ -1260,11 +1260,11 @@ cp_build_qualified_type_real (tree type,\n      [dcl.ref], [dcl.fct].  This used to be an error, but as of DR 295\n      (in CD1) we always ignore extra cv-quals on functions.  */\n   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n-      && (TREE_CODE (type) == REFERENCE_TYPE\n+      && (TYPE_REF_P (type)\n \t  || TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE))\n     {\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (type))\n \tbad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n       type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n     }\n@@ -5126,7 +5126,7 @@ stabilize_expr (tree exp, tree* initp)\n     }\n   /* There are no expressions with REFERENCE_TYPE, but there can be call\n      arguments with such a type; just treat it as a pointer.  */\n-  else if (TREE_CODE (TREE_TYPE (exp)) == REFERENCE_TYPE\n+  else if (TYPE_REF_P (TREE_TYPE (exp))\n \t   || SCALAR_TYPE_P (TREE_TYPE (exp))\n \t   || !glvalue_p (exp))\n     {\n@@ -5287,7 +5287,7 @@ stabilize_init (tree init, tree *initp)\n \t{\n \t  tree type = TREE_TYPE (ce->value);\n \t  tree subinit;\n-\t  if (TREE_CODE (type) == REFERENCE_TYPE\n+\t  if (TYPE_REF_P (type)\n \t      || SCALAR_TYPE_P (type))\n \t    ce->value = stabilize_expr (ce->value, &subinit);\n \t  else if (!stabilize_init (ce->value, &subinit))"}, {"sha": "e5eb35d75c6f496a4e3ef4cbe563710240f3a8b1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -1181,8 +1181,8 @@ cxx_safe_arg_type_equiv_p (tree t1, tree t2)\n   t1 = TYPE_MAIN_VARIANT (t1);\n   t2 = TYPE_MAIN_VARIANT (t2);\n \n-  if (TREE_CODE (t1) == POINTER_TYPE\n-      && TREE_CODE (t2) == POINTER_TYPE)\n+  if (TYPE_PTR_P (t1)\n+      && TYPE_PTR_P (t2))\n     return true;\n \n   /* The signedness of the parameter matters only when an integral\n@@ -2509,7 +2509,7 @@ build_class_member_access_expr (cp_expr object, tree member,\n       /* Compute the type of the field, as described in [expr.ref].  */\n       type_quals = TYPE_UNQUALIFIED;\n       member_type = TREE_TYPE (member);\n-      if (TREE_CODE (member_type) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (member_type))\n \t{\n \t  type_quals = (cp_type_quals (member_type)\n \t\t\t| cp_type_quals (object_type));\n@@ -3131,7 +3131,7 @@ cp_build_indirect_ref_1 (tree ptr, ref_operator errorstring,\n \t      (TREE_TYPE (ptr), TREE_TYPE (current_class_ptr)))))\n     return current_class_ref;\n \n-  pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n+  pointer = (TYPE_REF_P (TREE_TYPE (ptr))\n \t     ? ptr : decay_conversion (ptr, complain));\n   if (pointer == error_mark_node)\n     return error_mark_node;\n@@ -3901,10 +3901,10 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n \t Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */\n       if (TREE_CODE (val) == NOP_EXPR\n \t  && TREE_TYPE (val) == TREE_TYPE (TREE_OPERAND (val, 0))\n-\t  && (type == 0 || TREE_CODE (type) != REFERENCE_TYPE))\n+\t  && (type == 0 || !TYPE_REF_P (type)))\n \tval = TREE_OPERAND (val, 0);\n \n-      if (type == 0 || TREE_CODE (type) != REFERENCE_TYPE)\n+      if (type == 0 || !TYPE_REF_P (type))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n@@ -4176,7 +4176,7 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)\n \t\t\"be NULL\", TREE_OPERAND (cop, 0));\n \n   if (CONVERT_EXPR_P (op)\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (op, 0))) == REFERENCE_TYPE)\n+      && TYPE_REF_P (TREE_TYPE (TREE_OPERAND (op, 0))))\n     {\n       tree inner_op = op;\n       STRIP_NOPS (inner_op);\n@@ -5876,7 +5876,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \t}\n     }\n \n-  if (TREE_CODE (argtype) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (argtype))\n     {\n       tree type = build_pointer_type (TREE_TYPE (argtype));\n       arg = build1 (CONVERT_EXPR, type, arg);\n@@ -5898,7 +5898,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n   if (INDIRECT_REF_P (arg))\n     {\n       arg = TREE_OPERAND (arg, 0);\n-      if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (TREE_TYPE (arg)))\n \t{\n \t  tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n \t  arg = build1 (CONVERT_EXPR, type, arg);\n@@ -5943,7 +5943,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \tgcc_assert (PTRMEM_OK_P (arg));\n \n \tt = TREE_OPERAND (arg, 1);\n-\tif (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+\tif (TYPE_REF_P (TREE_TYPE (t)))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"cannot create pointer to reference member %qD\", t);\n@@ -6805,7 +6805,7 @@ maybe_warn_about_useless_cast (tree type, tree expr, tsubst_flags_t complain)\n   if (warn_useless_cast\n       && complain & tf_warning)\n     {\n-      if ((TREE_CODE (type) == REFERENCE_TYPE\n+      if ((TYPE_REF_P (type)\n \t   && (TYPE_REF_IS_RVALUE (type)\n \t       ? xvalue_p (expr) : lvalue_p (expr))\n \t   && same_type_p (TREE_TYPE (expr), TREE_TYPE (type)))\n@@ -6922,7 +6922,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n      we want to avoid constructing a new D.  The standard is not\n      completely clear about this issue, but our interpretation is\n      consistent with other compilers.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE\n+  if (TYPE_REF_P (type)\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (intype)\n       && (TYPE_REF_IS_RVALUE (type) || lvalue_p (expr))\n@@ -6991,7 +6991,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n   /* \"A glvalue of type cv1 T1 can be cast to type rvalue reference to\n      cv2 T2 if cv2 T2 is reference-compatible with cv1 T1 (8.5.3).\"  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE\n+  if (TYPE_REF_P (type)\n       && TYPE_REF_IS_RVALUE (type)\n       && (clk = real_lvalue_p (expr))\n       && reference_related_p (TREE_TYPE (type), intype)\n@@ -7055,7 +7055,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n \t If T is a reference type, the result is an lvalue; otherwise,\n \t the result is an rvalue.  */\n-      if (TREE_CODE (type) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (type))\n \t{\n \t  result = rvalue (result);\n \n@@ -7221,7 +7221,7 @@ build_static_cast (tree type, tree oexpr, tsubst_flags_t complain)\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-  if (TREE_CODE (type) != REFERENCE_TYPE\n+  if (!TYPE_REF_P (type)\n       && TREE_CODE (expr) == NOP_EXPR\n       && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n     expr = TREE_OPERAND (expr, 0);\n@@ -7330,7 +7330,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n      \"reference to T2\" if an expression of type \"pointer to T1\" can be\n      explicitly converted to the type \"pointer to T2\" using a\n      reinterpret_cast.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (type))\n     {\n       if (! lvalue_p (expr))\n \t{\n@@ -7582,7 +7582,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n \n   src_type = TREE_TYPE (expr);\n   /* Expressions do not really have reference types.  */\n-  if (TREE_CODE (src_type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (src_type))\n     src_type = TREE_TYPE (src_type);\n \n   /* [expr.const.cast]\n@@ -7600,7 +7600,7 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n      -- if T1 is a class type, a prvalue of type T1 can be explicitly\n      converted to an xvalue of type T2 using the cast const_cast<T2&&>.  */\n \n-  if (TREE_CODE (dst_type) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (dst_type))\n     {\n       reference_type = dst_type;\n       if (!TYPE_REF_IS_RVALUE (dst_type)\n@@ -7763,7 +7763,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-  if (TREE_CODE (type) != REFERENCE_TYPE\n+  if (!TYPE_REF_P (type)\n       && TREE_CODE (value) == NOP_EXPR\n       && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n     value = TREE_OPERAND (value, 0);\n@@ -7841,7 +7841,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n       if (!CLASS_TYPE_P (type))\n \ttype = TYPE_MAIN_VARIANT (type);\n       result_type = TREE_TYPE (result);\n-      if (!CLASS_TYPE_P (result_type) && TREE_CODE (type) != REFERENCE_TYPE)\n+      if (!CLASS_TYPE_P (result_type) && !TYPE_REF_P (type))\n \tresult_type = TYPE_MAIN_VARIANT (result_type);\n       /* If the type of RESULT does not match TYPE, perform a\n \t const_cast to make it match.  If the static_cast or\n@@ -8083,7 +8083,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t  /* A binary op has been requested.  Combine the old LHS\n \t     value with the RHS producing the value we should actually\n \t     store into the LHS.  */\n-\t  gcc_assert (!((TREE_CODE (lhstype) == REFERENCE_TYPE\n+\t  gcc_assert (!((TYPE_REF_P (lhstype)\n \t\t\t && MAYBE_CLASS_TYPE_P (TREE_TYPE (lhstype)))\n \t\t\t|| MAYBE_CLASS_TYPE_P (lhstype)));\n \n@@ -8122,8 +8122,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t\tgoto ret;\n \t    }\n \t}\n-      gcc_assert (TREE_CODE (lhstype) != REFERENCE_TYPE);\n-      gcc_assert (TREE_CODE (TREE_TYPE (newrhs)) != REFERENCE_TYPE);\n+      gcc_assert (!TYPE_REF_P (lhstype));\n+      gcc_assert (!TYPE_REF_P (TREE_TYPE (newrhs)));\n     }\n \n   /* The left-hand side must be an lvalue.  */\n@@ -8955,7 +8955,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n     ;\n   else if ((TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n \t    && TREE_CODE (type) != ARRAY_TYPE\n-\t    && (TREE_CODE (type) != REFERENCE_TYPE\n+\t    && (!TYPE_REF_P (type)\n \t\t|| TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE))\n \t   || (TREE_CODE (TREE_TYPE (rhs)) == FUNCTION_TYPE\n \t       && !TYPE_REFFN_P (type))\n@@ -9037,7 +9037,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t || TREE_CODE (whats_returned) == ARRAY_REF)\n     whats_returned = TREE_OPERAND (whats_returned, 0);\n \n-  if (TREE_CODE (valtype) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (valtype))\n     {\n       if (TREE_CODE (whats_returned) == AGGR_INIT_EXPR\n \t  || TREE_CODE (whats_returned) == TARGET_EXPR)\n@@ -9061,7 +9061,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n       && !(TREE_STATIC (whats_returned)\n \t   || TREE_PUBLIC (whats_returned)))\n     {\n-      if (TREE_CODE (valtype) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (valtype))\n \twarning_at (DECL_SOURCE_LOCATION (whats_returned),\n \t\t    OPT_Wreturn_local_addr,\n \t\t    \"reference to local variable %qD returned\",\n@@ -9263,7 +9263,7 @@ check_return_expr (tree retval, bool *no_warning)\n \n       /* The function return type must be a reference to the current\n \tclass.  */\n-      if (TREE_CODE (valtype) == REFERENCE_TYPE\n+      if (TYPE_REF_P (valtype)\n \t  && same_type_ignoring_top_level_qualifiers_p\n \t      (TREE_TYPE (valtype), TREE_TYPE (current_class_ref)))\n \t{\n@@ -9614,7 +9614,7 @@ cp_type_quals (const_tree type)\n   quals = TYPE_QUALS (type);\n   /* METHOD and REFERENCE_TYPEs should never have quals.  */\n   gcc_assert ((TREE_CODE (type) != METHOD_TYPE\n-\t       && TREE_CODE (type) != REFERENCE_TYPE)\n+\t       && !TYPE_REF_P (type))\n \t      || ((quals & (TYPE_QUAL_CONST|TYPE_QUAL_VOLATILE))\n \t\t  == TYPE_UNQUALIFIED));\n   return quals;\n@@ -9801,15 +9801,15 @@ casts_away_constness_r (tree *t1, tree *t2, tsubst_flags_t complain)\n static bool\n casts_away_constness (tree t1, tree t2, tsubst_flags_t complain)\n {\n-  if (TREE_CODE (t2) == REFERENCE_TYPE)\n+  if (TYPE_REF_P (t2))\n     {\n       /* [expr.const.cast]\n \n \t Casting from an lvalue of type T1 to an lvalue of type T2\n \t using a reference cast casts away constness if a cast from an\n \t rvalue of type \"pointer to T1\" to the type \"pointer to T2\"\n \t casts away constness.  */\n-      t1 = (TREE_CODE (t1) == REFERENCE_TYPE ? TREE_TYPE (t1) : t1);\n+      t1 = (TYPE_REF_P (t1) ? TREE_TYPE (t1) : t1);\n       return casts_away_constness (build_pointer_type (t1),\n \t\t\t\t   build_pointer_type (TREE_TYPE (t2)),\n \t\t\t\t   complain);\n@@ -9849,7 +9849,7 @@ casts_away_constness (tree t1, tree t2, tsubst_flags_t complain)\n tree\n non_reference (tree t)\n {\n-  if (t && TREE_CODE (t) == REFERENCE_TYPE)\n+  if (t && TYPE_REF_P (t))\n     t = TREE_TYPE (t);\n   return t;\n }"}, {"sha": "682303ad7af2ae867112044e78e973ffd39d67b4", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f613f06b0da4b11cde815351df31ad74e22f449/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9f613f06b0da4b11cde815351df31ad74e22f449", "patch": "@@ -111,7 +111,7 @@ cxx_readonly_error (tree arg, enum lvalue_use errstring)\n \t\t\t     \"constant field %qD\"),\n \t\t\t  arg);\n   else if (INDIRECT_REF_P (arg)\n-\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n+\t   && TYPE_REF_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n \t   && (VAR_P (TREE_OPERAND (arg, 0))\n \t       || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n     ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n@@ -845,7 +845,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t\t    || error_operand_p (value));\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = const_init;\n       /* FIXME setting TREE_CONSTANT on refs breaks the back end.  */\n-      if (TREE_CODE (type) != REFERENCE_TYPE)\n+      if (!TYPE_REF_P (type))\n \tTREE_CONSTANT (decl) = const_init && decl_maybe_constant_var_p (decl);\n     }\n   value = cp_fully_fold (value);\n@@ -1498,7 +1498,7 @@ process_init_constructor_record (tree type, tree init, int nested,\n       else\n \t{\n \t  const_tree fldtype = TREE_TYPE (field);\n-\t  if (TREE_CODE (fldtype) == REFERENCE_TYPE)\n+\t  if (TYPE_REF_P (fldtype))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"member %qD is uninitialized reference\", field);\n@@ -1823,7 +1823,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \n   if (processing_template_decl)\n     {\n-      if (type && TREE_CODE (type) == POINTER_TYPE\n+      if (type && TYPE_PTR_P (type)\n \t  && !dependent_scope_p (TREE_TYPE (type)))\n \t/* Pointer to current instantiation, don't treat as dependent.  */;\n       else if (type_dependent_expression_p (expr))\n@@ -1873,7 +1873,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \t  return error_mark_node;\n \t}\n \n-      if (TREE_CODE (TREE_TYPE (last_rval)) == REFERENCE_TYPE)\n+      if (TYPE_REF_P (TREE_TYPE (last_rval)))\n \tlast_rval = convert_from_reference (last_rval);\n     }\n   else\n@@ -2108,7 +2108,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       /* Diagnose this even in a template.  We could also try harder\n \t to give all the usual errors when the type and args are\n \t non-dependent...  */\n-      if (TREE_CODE (type) == REFERENCE_TYPE && !parms)\n+      if (TYPE_REF_P (type) && !parms)\n \t{\n \t  if (complain & tf_error)\n \t    error (\"invalid value-initialization of reference type\");\n@@ -2206,7 +2206,7 @@ add_exception_specifier (tree list, tree spec, int complain)\n      incomplete, or pointer or ref to incomplete other than pointer\n      to cv void.  */\n   is_ptr = TYPE_PTR_P (core);\n-  if (is_ptr || TREE_CODE (core) == REFERENCE_TYPE)\n+  if (is_ptr || TYPE_REF_P (core))\n     core = TREE_TYPE (core);\n   if (complain < 0)\n     ok = true;"}]}