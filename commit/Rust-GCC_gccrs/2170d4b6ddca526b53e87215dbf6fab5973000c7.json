{"sha": "2170d4b6ddca526b53e87215dbf6fab5973000c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE3MGQ0YjZkZGNhNTI2YjUzZTg3MjE1ZGJmNmZhYjU5NzMwMDBjNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-03-22T03:53:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-03-22T03:53:19Z"}, "message": "PR c++/81311 - wrong C++17 overload resolution.\n\n\t* call.c (build_user_type_conversion_1): Remove C++17 code.\n\t(conv_binds_ref_to_prvalue): New.\n\t(build_over_call): Handle C++17 copy elision.\n\t(build_special_member_call): Only do C++17 copy elision here if the\n\targument is already the right type.\n\nFrom-SVN: r258755", "tree": {"sha": "6b4bcfc8fdc60cb68fbaa3f0e74410d3c388fd6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b4bcfc8fdc60cb68fbaa3f0e74410d3c388fd6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2170d4b6ddca526b53e87215dbf6fab5973000c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2170d4b6ddca526b53e87215dbf6fab5973000c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2170d4b6ddca526b53e87215dbf6fab5973000c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2170d4b6ddca526b53e87215dbf6fab5973000c7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0e46153b65cf6e2f3b78e1647d9ed9dbcc8677f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e46153b65cf6e2f3b78e1647d9ed9dbcc8677f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e46153b65cf6e2f3b78e1647d9ed9dbcc8677f"}], "stats": {"total": 108, "additions": 80, "deletions": 28}, "files": [{"sha": "44de2fb5b37bd3cad5cdc544cc3a8baec971f108", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2170d4b6ddca526b53e87215dbf6fab5973000c7", "patch": "@@ -1,3 +1,12 @@\n+2018-03-21  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/81311 - wrong C++17 overload resolution.\n+\t* call.c (build_user_type_conversion_1): Remove C++17 code.\n+\t(conv_binds_ref_to_prvalue): New.\n+\t(build_over_call): Handle C++17 copy elision.\n+\t(build_special_member_call): Only do C++17 copy elision here if the\n+\targument is already the right type.\n+\n 2018-03-21  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/71965"}, {"sha": "9351918b23af81b10bd1aa0e03b7f57b38e56552", "filename": "gcc/cp/call.c", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2170d4b6ddca526b53e87215dbf6fab5973000c7", "patch": "@@ -3748,14 +3748,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n        creating a garbage BASELINK; constructors can't be inherited.  */\n     ctors = get_class_binding (totype, complete_ctor_identifier);\n \n-  /* FIXME P0135 doesn't say what to do in C++17 about list-initialization from\n-     a single element.  For now, let's handle constructors as before and also\n-     consider conversion operators from the element.  */\n-  if (cxx_dialect >= cxx17\n-      && BRACE_ENCLOSED_INITIALIZER_P (expr)\n-      && CONSTRUCTOR_NELTS (expr) == 1)\n-    fromtype = TREE_TYPE (CONSTRUCTOR_ELT (expr, 0)->value);\n-\n   if (MAYBE_CLASS_TYPE_P (fromtype))\n     {\n       tree to_nonref = non_reference (totype);\n@@ -3832,7 +3824,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   if (conv_fns)\n     {\n       if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n-\t/* FIXME see above about C++17.  */\n \tfirst_arg = CONSTRUCTOR_ELT (expr, 0)->value;\n       else\n \tfirst_arg = expr;\n@@ -7604,6 +7595,26 @@ unsafe_copy_elision_p (tree target, tree exp)\n \t  && !AGGR_INIT_VIA_CTOR_P (init));\n }\n \n+/* True iff C is a conversion that binds a reference to a prvalue.  */\n+\n+static bool\n+conv_binds_ref_to_prvalue (conversion *c)\n+{\n+  if (c->kind != ck_ref_bind)\n+    return false;\n+  if (c->need_temporary_p)\n+    return true;\n+\n+  c = next_conversion (c);\n+\n+  if (c->kind == ck_rvalue)\n+    return true;\n+  if (c->kind == ck_user && TREE_CODE (c->type) != REFERENCE_TYPE)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -7682,6 +7693,22 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \tjoust (cand, w->loser, 1, complain);\n     }\n \n+  /* Core issue 2327: P0135 doesn't say how to handle the case where the\n+     argument to the copy constructor ends up being a prvalue after\n+     conversion.  Let's do the normal processing, but pretend we aren't\n+     actually using the copy constructor.  */\n+  bool force_elide = false;\n+  if (cxx_dialect >= cxx17\n+      && cand->num_convs == 1\n+      && DECL_COMPLETE_CONSTRUCTOR_P (fn)\n+      && (DECL_COPY_CONSTRUCTOR_P (fn)\n+\t  || DECL_MOVE_CONSTRUCTOR_P (fn))\n+      && conv_binds_ref_to_prvalue (convs[0]))\n+    {\n+      force_elide = true;\n+      goto not_really_used;\n+    }\n+\n   /* OK, we're actually calling this inherited constructor; set its deletedness\n      appropriately.  We can get away with doing this here because calling is\n      the only way to refer to a constructor.  */\n@@ -7746,6 +7773,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* else continue to get conversion error.  */\n     }\n \n+ not_really_used:\n+\n   /* N3276 magic doesn't apply to nested calls.  */\n   tsubst_flags_t decltype_flag = (complain & tf_decltype);\n   complain &= ~tf_decltype;\n@@ -8066,15 +8095,15 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */\n \n-  if (! flag_elide_constructors)\n+  if (! flag_elide_constructors && !force_elide)\n     /* Do things the hard way.  */;\n   else if (cand->num_convs == 1 \n            && (DECL_COPY_CONSTRUCTOR_P (fn) \n                || DECL_MOVE_CONSTRUCTOR_P (fn))\n \t   /* It's unsafe to elide the constructor when handling\n \t      a noexcept-expression, it may evaluate to the wrong\n \t      value (c++/53025).  */\n-\t   && cp_noexcept_operand == 0)\n+\t   && (force_elide || cp_noexcept_operand == 0))\n     {\n       tree targ;\n       tree arg = argarray[num_artificial_parms_for (fn)];\n@@ -8112,6 +8141,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t subobject.  */\n       if (CHECKING_P && cxx_dialect >= cxx17)\n \tgcc_assert (TREE_CODE (arg) != TARGET_EXPR\n+\t\t    || force_elide\n \t\t    /* It's from binding the ref parm to a packed field. */\n \t\t    || convs[0]->need_temporary_p\n \t\t    || seen_error ()\n@@ -8120,7 +8150,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n-      if (!trivial)\n+      if (!trivial && !force_elide)\n \t{\n \t  if (!mark_used (fn, complain) && !(complain & tf_error))\n \t    return error_mark_node;\n@@ -8207,6 +8237,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n     }\n \n+  gcc_assert (!force_elide);\n+\n   if (!already_used\n       && !mark_used (fn, complain))\n     return error_mark_node;\n@@ -8873,23 +8905,11 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n     {\n       tree arg = (**args)[0];\n \n-      /* FIXME P0135 doesn't say how to handle direct initialization from a\n-\t type with a suitable conversion operator.  Let's handle it like\n-\t copy-initialization, but allowing explict conversions.  */\n-      tsubst_flags_t sub_complain = tf_warning;\n-      if (!is_dummy_object (instance))\n-\t/* If we're using this to initialize a non-temporary object, don't\n-\t   require the destructor to be accessible.  */\n-\tsub_complain |= tf_no_cleanup;\n       if (BRACE_ENCLOSED_INITIALIZER_P (arg)\n-\t  && !CONSTRUCTOR_IS_DIRECT_INIT (arg))\n-\t/* An init-list arg needs to convert to the parm type (83937), so fall\n-\t   through to normal processing.  */\n-\targ = error_mark_node;\n-      else if (!reference_related_p (class_type, TREE_TYPE (arg)))\n-\targ = perform_implicit_conversion_flags (class_type, arg,\n-\t\t\t\t\t\t sub_complain,\n-\t\t\t\t\t\t flags);\n+\t  && !TYPE_HAS_LIST_CTOR (class_type)\n+\t  && CONSTRUCTOR_NELTS (arg) == 1)\n+\targ = CONSTRUCTOR_ELT (arg, 0)->value;\n+\n       if ((TREE_CODE (arg) == TARGET_EXPR\n \t   || TREE_CODE (arg) == CONSTRUCTOR)\n \t  && (same_type_ignoring_top_level_qualifiers_p"}, {"sha": "e8e533b1dc5b4913c885ac1fc11afdd0771a96a0", "filename": "gcc/testsuite/g++.dg/overload/conv-op2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fconv-op2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2170d4b6ddca526b53e87215dbf6fab5973000c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fconv-op2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fconv-op2.C?ref=2170d4b6ddca526b53e87215dbf6fab5973000c7", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/81311\n+// { dg-do link }\n+\n+struct function\n+{\n+  template<class F> function(F) { }\n+};\n+\n+struct ref\n+{\n+  operator function&() const;\n+} r;\n+\n+struct val\n+{\n+  operator function() const;\n+} v;\n+\n+int main()\n+{\n+  function f1(r);\n+  function f2(v);\n+}"}]}