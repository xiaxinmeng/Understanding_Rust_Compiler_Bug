{"sha": "1c690164668bda556f308632eab4204f63a138d7", "node_id": "C_kwDOANBUbNoAKDFjNjkwMTY0NjY4YmRhNTU2ZjMwODYzMmVhYjQyMDRmNjNhMTM4ZDc", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-18T20:12:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-20T21:40:13Z"}, "message": "c++: tweak parsing of invalid types\n\ncp_parser_parse_and_diagnose_invalid_type_name is called during declaration\nparsing, so it should pass 'true' for the declarator_p argument.  But that\ncaused a diagnostic regression on template/pr84789.C due to undesired lookup\nin dependent scopes.  To fix that, cp_parser_nested_name_specifier_opt needs\nto respect the value of check_dependency_p.\n\nThis patch avoids a regression from Andrew Sharp's WIP patch for PR70417.\n\nIt would make more sense to test only check_dependency_p, not declarator_p,\nbut removing the declarator_p condition turns out to reveal complicated\ninteractions of cp_parser_constructor_declarator_p and caching of\nnested-name-specifiers and template-ids that I've already spent too much\ntime trying to sort out.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_parse_and_diagnose_invalid_type_name):\n\tPass true for declarator_p.\n\t(cp_parser_nested_name_specifier_opt): Only look through\n\tTYPENAME_TYPE if check_dependency_p is false.", "tree": {"sha": "55116db17696800765568f71ab396b90498378ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55116db17696800765568f71ab396b90498378ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c690164668bda556f308632eab4204f63a138d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c690164668bda556f308632eab4204f63a138d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c690164668bda556f308632eab4204f63a138d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c690164668bda556f308632eab4204f63a138d7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788483f77de04515b0b72d3c4c841c37b005f404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/788483f77de04515b0b72d3c4c841c37b005f404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/788483f77de04515b0b72d3c4c841c37b005f404"}], "stats": {"total": 8, "additions": 6, "deletions": 2}, "files": [{"sha": "49d951cfb193ce18079460eda1e9a4be045cf487", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c690164668bda556f308632eab4204f63a138d7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c690164668bda556f308632eab4204f63a138d7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1c690164668bda556f308632eab4204f63a138d7", "patch": "@@ -3693,7 +3693,7 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n \t\t\t\t/*template_keyword_p=*/false,\n \t\t\t\t/*check_dependency_p=*/true,\n \t\t\t\t/*template_p=*/NULL,\n-\t\t\t\t/*declarator_p=*/false,\n+\t\t\t\t/*declarator_p=*/true,\n \t\t\t\t/*optional_p=*/false);\n   /* If the next token is a (, this is a function with no explicit return\n      type, i.e. constructor, destructor or conversion op.  */\n@@ -6605,6 +6605,8 @@ check_template_keyword_in_nested_name_spec (tree name)\n    it unchanged if there is no nested-name-specifier.  Returns the new\n    scope iff there is a nested-name-specifier, or NULL_TREE otherwise.\n \n+   If CHECK_DEPENDENCY_P is FALSE, names are looked up in dependent scopes.\n+\n    If IS_DECLARATION is TRUE, the nested-name-specifier is known to be\n    part of a declaration and/or decl-specifier.  */\n \n@@ -6645,9 +6647,10 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t  /* Grab the nested-name-specifier and continue the loop.  */\n \t  cp_parser_pre_parsed_nested_name_specifier (parser);\n \t  /* If we originally encountered this nested-name-specifier\n-\t     with IS_DECLARATION set to false, we will not have\n+\t     with CHECK_DEPENDENCY_P set to true, we will not have\n \t     resolved TYPENAME_TYPEs, so we must do so here.  */\n \t  if (is_declaration\n+\t      && !check_dependency_p\n \t      && TREE_CODE (parser->scope) == TYPENAME_TYPE)\n \t    {\n \t      new_scope = resolve_typename_type (parser->scope,\n@@ -6729,6 +6732,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t a template.  So, if we have a typename at this point, we make\n \t an effort to look through it.  */\n       if (is_declaration\n+\t  && !check_dependency_p\n \t  && !typename_keyword_p\n \t  && parser->scope\n \t  && TREE_CODE (parser->scope) == TYPENAME_TYPE)"}]}