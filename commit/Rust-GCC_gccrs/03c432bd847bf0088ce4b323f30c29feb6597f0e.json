{"sha": "03c432bd847bf0088ce4b323f30c29feb6597f0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjNDMyYmQ4NDdiZjAwODhjZTRiMzIzZjMwYzI5ZmViNjU5N2YwZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-09-13T23:00:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-09-13T23:00:23Z"}, "message": "predicates.md (input_operand): Do not consider TImode constants as 1-instruction integer constants.\n\n\t* config/sparc/predicates.md (input_operand): Do not consider TImode\n\tconstants as 1-instruction integer constants.\n\tUse register_or_zero_operand instead of register_operand and tidy up.\n\t* config/sparc/sparc.md (movti): New expander.\n\t(movti_insn_sp64): New instruction.\n\t(movti_insn_sp64_hq): Likewise.\n\t(TImode splitters): New splitters.\n\t* config/sparc/sparc.c (sparc_expand_move) <TImode>: New case.\n\t(sparc_legitimate_address_p): Return 0 for REG+REG in TImode.\n\n\t* config/sparc/sparc-protos.h (arith_double_4096_operand): Delete.\n\t(arith_4096_operand): Likewise.\n\t(zero_operand): Likewise.\n\t(fp_zero_operand): Likewise.\n\t(reg_or_0_operand): Likewise.\n\nFrom-SVN: r191283", "tree": {"sha": "47b10f77dfce449ecb804ff4d663b85eb222ddab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47b10f77dfce449ecb804ff4d663b85eb222ddab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03c432bd847bf0088ce4b323f30c29feb6597f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c432bd847bf0088ce4b323f30c29feb6597f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c432bd847bf0088ce4b323f30c29feb6597f0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c432bd847bf0088ce4b323f30c29feb6597f0e/comments", "author": null, "committer": null, "parents": [{"sha": "12308bc61de47a985b260889194156021da3cc2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12308bc61de47a985b260889194156021da3cc2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12308bc61de47a985b260889194156021da3cc2e"}], "stats": {"total": 208, "additions": 197, "deletions": 11}, "files": [{"sha": "865369528b59b306bafa432852a7476c71f3f783", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03c432bd847bf0088ce4b323f30c29feb6597f0e", "patch": "@@ -1,3 +1,21 @@\n+2012-09-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/predicates.md (input_operand): Do not consider TImode\n+\tconstants as 1-instruction integer constants.\n+\tUse register_or_zero_operand instead of register_operand and tidy up.\n+\t* config/sparc/sparc.md (movti): New expander.\n+\t(movti_insn_sp64): New instruction.\n+\t(movti_insn_sp64_hq): Likewise.\n+\t(TImode splitters): New splitters.\n+\t* config/sparc/sparc.c (sparc_expand_move) <TImode>: New case.\n+\t(sparc_legitimate_address_p): Return 0 for REG+REG in TImode.\n+\n+\t* config/sparc/sparc-protos.h (arith_double_4096_operand): Delete.\n+\t(arith_4096_operand): Likewise.\n+\t(zero_operand): Likewise.\n+\t(fp_zero_operand): Likewise.\n+\t(reg_or_0_operand): Likewise.\n+\n 2012-09-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.ac (CXXFLAGS): Remove -O2 when not bootstrapping."}, {"sha": "326524b93740ac7bc611ce5fa2392d04355cebb9", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=03c432bd847bf0088ce4b323f30c29feb6597f0e", "patch": "@@ -357,7 +357,7 @@\n (define_predicate \"arith_add_operand\"\n   (ior (match_operand 0 \"arith_operand\")\n        (match_operand 0 \"const_4096_operand\")))\n-       \n+\n ;; Return true if OP is suitable as second double operand for add/sub.\n (define_predicate \"arith_double_add_operand\"\n   (match_code \"const_int,const_double,reg,subreg\")\n@@ -427,6 +427,7 @@\n \n   /* Allow any 1-instruction integer constant.  */\n   if (mclass == MODE_INT\n+      && mode != TImode\n       && (small_int_operand (op, mode) || const_high_operand (op, mode)))\n     return true;\n \n@@ -440,12 +441,10 @@\n   if (mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)\n     return true;\n \n-  if (mclass == MODE_VECTOR_INT && GET_CODE (op) == CONST_VECTOR\n-      && (const_zero_operand (op, mode)\n-          || const_all_ones_operand (op, mode)))\n+  if (mclass == MODE_VECTOR_INT && const_all_ones_operand (op, mode))\n     return true;\n \n-  if (register_operand (op, mode))\n+  if (register_or_zero_operand (op, mode))\n     return true;\n \n   /* If this is a SUBREG, look inside so that we handle paradoxical ones.  */"}, {"sha": "97f6233d392538bf2742866dd2232b8b93d261bb", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=03c432bd847bf0088ce4b323f30c29feb6597f0e", "patch": "@@ -82,11 +82,6 @@ extern const char *output_probe_stack_range (rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n extern void emit_conditional_branch_insn (rtx []);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n-extern int arith_double_4096_operand (rtx, enum machine_mode);\n-extern int arith_4096_operand (rtx, enum machine_mode);\n-extern int zero_operand (rtx, enum machine_mode);\n-extern int fp_zero_operand (rtx, enum machine_mode);\n-extern int reg_or_0_operand (rtx, enum machine_mode);\n extern int empty_delay_slot (rtx);\n extern int eligible_for_return_delay (rtx);\n extern int eligible_for_sibcall_delay (rtx);"}, {"sha": "ca234a23576bcbb2ece246776ce3c21da39d08ed", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=03c432bd847bf0088ce4b323f30c29feb6597f0e", "patch": "@@ -1465,6 +1465,18 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       sparc_emit_set_const64 (operands[0], operands[1]);\n       return true;\n \n+    case TImode:\n+      {\n+\trtx high, low;\n+\t/* TImode isn't available in 32-bit mode.  */\n+\tsplit_double (operands[1], &high, &low);\n+\temit_insn (gen_movdi (operand_subword (operands[0], 0, 0, TImode),\n+\t\t\t      high));\n+\temit_insn (gen_movdi (operand_subword (operands[0], 1, 0, TImode),\n+\t\t\t      low));\n+      }\n+      return true;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -3492,6 +3504,10 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n \t      && ! (TARGET_ARCH64 && TARGET_HARD_QUAD))\n \t    return 0;\n \n+\t  /* Likewise for TImode, but in all cases.  */\n+\t  if (mode == TImode)\n+\t    return 0;\n+\n \t  /* We prohibit REG + REG on ARCH32 if not optimizing for\n \t     DFmode/DImode because then mem_min_alignment is likely to be zero\n \t     after reload and the  forced split would lack a matching splitter"}, {"sha": "3e854616a0a258e80c41e630430d1f57147b378d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03c432bd847bf0088ce4b323f30c29feb6597f0e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=03c432bd847bf0088ce4b323f30c29feb6597f0e", "patch": "@@ -2034,6 +2034,164 @@\n   DONE;\n })\n \n+(define_expand \"movti\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"TARGET_ARCH64\"\n+{\n+  if (sparc_expand_move (TImode, operands))\n+    DONE;\n+})\n+\n+;; We need to prevent reload from splitting TImode moves, because it\n+;; might decide to overwrite a pointer with the value it points to.\n+;; In that case we have to do the loads in the appropriate order so\n+;; that the pointer is not destroyed too early.\n+\n+(define_insn \"*movti_insn_sp64\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r , o,?*e,?o,b\")\n+        (match_operand:TI 1 \"input_operand\"        \"roJ,rJ, eo, e,J\"))]\n+  \"TARGET_ARCH64\n+   && ! TARGET_HARD_QUAD\n+   && (register_operand (operands[0], TImode)\n+       || register_or_zero_operand (operands[1], TImode))\"\n+  \"#\"\n+  [(set_attr \"length\" \"2,2,2,2,2\")\n+   (set_attr \"cpu_feature\" \"*,*,fpu,fpu,vis\")])\n+\n+(define_insn \"*movti_insn_sp64_hq\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r , o,?*e,?*e,?m,b\")\n+        (match_operand:TI 1 \"input_operand\"        \"roJ,rJ,  e,  m, e,J\"))]\n+  \"TARGET_ARCH64\n+   && TARGET_HARD_QUAD\n+   && (register_operand (operands[0], TImode)\n+       || register_or_zero_operand (operands[1], TImode))\"\n+  \"@\n+  #\n+  #\n+  fmovq\\t%1, %0\n+  ldq\\t%1, %0\n+  stq\\t%1, %0\n+  #\"\n+  [(set_attr \"type\" \"*,*,fpmove,fpload,fpstore,*\")\n+   (set_attr \"length\" \"2,2,*,*,*,2\")])\n+\n+;; Now all the splits to handle multi-insn TI mode moves.\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+        (match_operand:TI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && ((TARGET_FPU\n+        && ! TARGET_HARD_QUAD)\n+       || (! fp_register_operand (operands[0], TImode)\n+           && ! fp_register_operand (operands[1], TImode)))\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx set_src = operands[1];\n+  rtx dest1, dest2;\n+  rtx src1, src2;\n+\n+  dest1 = gen_highpart (DImode, set_dest);\n+  dest2 = gen_lowpart (DImode, set_dest);\n+  src1 = gen_highpart (DImode, set_src);\n+  src2 = gen_lowpart (DImode, set_src);\n+\n+  /* Now emit using the real source and destination we found, swapping\n+     the order if we detect overlap.  */\n+  if (reg_overlap_mentioned_p (dest1, src2))\n+    {\n+      emit_insn (gen_movdi (dest2, src2));\n+      emit_insn (gen_movdi (dest1, src1));\n+    }\n+  else\n+    {\n+      emit_insn (gen_movdi (dest1, src1));\n+      emit_insn (gen_movdi (dest2, src2));\n+    }\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"const_zero_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_dest = operands[0];\n+  rtx dest1, dest2;\n+\n+  switch (GET_CODE (set_dest))\n+    {\n+    case REG:\n+      dest1 = gen_highpart (DImode, set_dest);\n+      dest2 = gen_lowpart (DImode, set_dest);\n+      break;\n+    case MEM:\n+      dest1 = adjust_address (set_dest, DImode, 0);\n+      dest2 = adjust_address (set_dest, DImode, 8);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (gen_movdi (dest1, const0_rtx));\n+  emit_insn (gen_movdi (dest2, const0_rtx));\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+        (match_operand:TI 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && offsettable_memref_p (operands[1])\n+   && (! TARGET_HARD_QUAD\n+       || ! fp_register_operand (operands[0], TImode))\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx word0 = adjust_address (operands[1], DImode, 0);\n+  rtx word1 = adjust_address (operands[1], DImode, 8);\n+  rtx set_dest, dest1, dest2;\n+\n+  set_dest = operands[0];\n+\n+  dest1 = gen_highpart (DImode, set_dest);\n+  dest2 = gen_lowpart (DImode, set_dest);\n+\n+  /* Now output, ordering such that we don't clobber any registers\n+     mentioned in the address.  */\n+  if (reg_overlap_mentioned_p (dest1, word1))\n+\n+    {\n+      emit_insn (gen_movdi (dest2, word1));\n+      emit_insn (gen_movdi (dest1, word0));\n+    }\n+  else\n+   {\n+      emit_insn (gen_movdi (dest1, word0));\n+      emit_insn (gen_movdi (dest2, word1));\n+   }\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"memory_operand\" \"\")\n+\t(match_operand:TI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && offsettable_memref_p (operands[0])\n+   && (! TARGET_HARD_QUAD\n+       || ! fp_register_operand (operands[1], TImode))\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx set_src = operands[1];\n+\n+  emit_insn (gen_movdi (adjust_address (operands[0], DImode, 0),\n+\t\t\tgen_highpart (DImode, set_src)));\n+  emit_insn (gen_movdi (adjust_address (operands[0], DImode, 8),\n+\t\t\tgen_lowpart (DImode, set_src)));\n+  DONE;\n+})\n+\n \n ;; Floating point move instructions\n \n@@ -2477,7 +2635,7 @@\n       dest2 = adjust_address (set_dest, DFmode, 8);\n       break;\n     default:\n-      gcc_unreachable ();      \n+      gcc_unreachable ();\n     }\n \n   emit_insn (gen_movdf (dest1, CONST0_RTX (DFmode)));"}]}