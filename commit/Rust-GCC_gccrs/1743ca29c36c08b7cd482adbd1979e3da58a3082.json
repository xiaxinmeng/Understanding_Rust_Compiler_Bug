{"sha": "1743ca29c36c08b7cd482adbd1979e3da58a3082", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0M2NhMjljMzZjMDhiN2NkNDgyYWRiZDE5NzllM2RhNThhMzA4Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:27:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:27:13Z"}, "message": "(build_conditional_expr): Use convert (boolean_type_node instead of truthvalue_conversion.\n\n(build_conditional_expr): Use convert (boolean_type_node instead of\ntruthvalue_conversion.\n(build_modify_expr): If the class lacks a constructor or assignment operator,\nreturn error_mark_node.\n(common_type): Use build_cplus_array_type.\n(commonparms): Don't abort if simple_cst_equal returns < 0.\n(build_c_cast): Don't tack on a NON_LVALUE_EXPR when casting to reference type.\n(build_indirect_ref): Fix check for *&.\n\nFrom-SVN: r10037", "tree": {"sha": "2df22bf7806fca3d7b5135736bdceaa9dd900e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2df22bf7806fca3d7b5135736bdceaa9dd900e33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1743ca29c36c08b7cd482adbd1979e3da58a3082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1743ca29c36c08b7cd482adbd1979e3da58a3082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1743ca29c36c08b7cd482adbd1979e3da58a3082", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1743ca29c36c08b7cd482adbd1979e3da58a3082/comments", "author": null, "committer": null, "parents": [{"sha": "dff6b454a21d43e2cb4c29d0418053239bf85620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff6b454a21d43e2cb4c29d0418053239bf85620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff6b454a21d43e2cb4c29d0418053239bf85620"}], "stats": {"total": 38, "additions": 23, "deletions": 15}, "files": [{"sha": "02ea5162c989426104c8efac12b6781871adb6f7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1743ca29c36c08b7cd482adbd1979e3da58a3082/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1743ca29c36c08b7cd482adbd1979e3da58a3082/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1743ca29c36c08b7cd482adbd1979e3da58a3082", "patch": "@@ -218,10 +218,7 @@ commonparms (p1, p2)\n \t}\n       else\n \t{\n-\t  int cmp = simple_cst_equal (TREE_PURPOSE (p1), TREE_PURPOSE (p2));\n-\t  if (cmp < 0)\n-\t    my_friendly_abort (111);\n-\t  if (cmp == 0)\n+\t  if (1 != simple_cst_equal (TREE_PURPOSE (p1), TREE_PURPOSE (p2)))\n \t    any_change = 1;\n \t  TREE_PURPOSE (n) = TREE_PURPOSE (p2);\n \t}\n@@ -419,7 +416,7 @@ common_type (t1, t2)\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2))\n \t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n-\tt1 = build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tt1 = build_cplus_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n \n@@ -1858,8 +1855,12 @@ build_indirect_ref (ptr, errorstring)\n   if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (TREE_CODE (pointer) == ADDR_EXPR\n-\t  && (TREE_TYPE (TREE_OPERAND (pointer, 0))\n-\t      == TREE_TYPE (type)))\n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (pointer, 0)))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+\t  && (TREE_READONLY (TREE_OPERAND (pointer, 0))\n+\t      == TYPE_READONLY (TREE_TYPE (type)))\n+\t  && (TREE_THIS_VOLATILE (TREE_OPERAND (pointer, 0))\n+\t      == TYPE_VOLATILE (TREE_TYPE (type))))\n \treturn TREE_OPERAND (pointer, 0);\n       else\n \t{\n@@ -4559,7 +4560,7 @@ build_conditional_expr (ifexp, op1, op2)\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n-  ifexp = truthvalue_conversion (ifexp);\n+  ifexp = convert (boolean_type_node, ifexp);\n \n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n@@ -5233,11 +5234,12 @@ build_c_cast (type, expr, allow_nonconverting)\n        so we can tell (for -pedantic) that the cast is no lvalue.\n        Also, pedantically, don't let (void *) (FOO *) 0 be a null\n        pointer constant.  */\n-  if (value == expr\n-      || (pedantic\n-\t  && TREE_CODE (value) == INTEGER_CST\n-\t  && TREE_CODE (expr) == INTEGER_CST\n-\t  && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE))\n+  if (TREE_CODE (type) != REFERENCE_TYPE\n+      && (value == expr\n+\t  || (pedantic\n+\t      && TREE_CODE (value) == INTEGER_CST\n+\t      && TREE_CODE (expr) == INTEGER_CST\n+\t      && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE)))\n     value = non_lvalue (value);\n \n   return value;\n@@ -5670,7 +5672,10 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n       else if (! TYPE_HAS_CONSTRUCTOR (lhstype))\n-\tcp_error (\"`%T' has no constructors\", lhstype);\n+\t{\n+\t  cp_error (\"`%T' has no constructors\", lhstype);\n+\t  return error_mark_node;\n+\t}\n       else if (TYPE_HAS_TRIVIAL_INIT_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t/* Do the default thing */;\n@@ -5691,7 +5696,10 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n       else if (! TYPE_HAS_ASSIGNMENT (lhstype))\n-\tcp_error (\"`%T' does not define operator=\", lhstype);\n+\t{\n+\t  cp_error (\"`%T' does not define operator=\", lhstype);\n+\t  return error_mark_node;\n+\t}\n       else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t{"}]}