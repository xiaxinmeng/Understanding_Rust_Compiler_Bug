{"sha": "3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "node_id": "C_kwDOANBUbNoAKDNhMGJjNDdjZGI2NzBjOGYxZTA5OTZlNjI1NWVlMTA4NGViN2ZlYmY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-17T20:18:08Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-17T20:18:08Z"}, "message": "c++: make manifestly_const_eval tri-state\n\nThis patch converts the constexpr machinery's manifestly_const_eval flag\ninto a tri-state enum to allow us to express wanting to fold\n__builtin_is_constant_evaluated to false via speculative constexpr\nevaluation.  For now, only the maybe_constant_value entry point is\nchanged to take this enum; the others continue to take bool.  The\nsubsequent patch will teach cp_fold (which uses maybe_constant_value) to\nfold the builtin to false when called from cp_fold_function and\ncp_fully_fold_init.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (constexpr_call::manifestly_const_eval): Give\n\tit type int instead of bool.\n\t(constexpr_ctx::manifestly_const_eval): Give it type mce_value\n\tinstead of bool.\n\t(cxx_eval_builtin_function_call): Adjust after making\n\tmanifestly_const_eval tri-state.\n\t(cxx_eval_call_expression): Likewise.\n\t(cxx_eval_binary_expression): Likewise.\n\t(cxx_eval_conditional_expression): Likewise.\n\t(cxx_eval_constant_expression): Likewise.\n\t(cxx_eval_outermost_constant_expr): Likewise.\n\t(cxx_constant_value): Likewise.\n\t(cxx_constant_dtor): Likewise.\n\t(maybe_constant_value): Give manifestly_const_eval parameter\n\ttype mce_value instead of bool and adjust accordingly.\n\t(fold_non_dependent_expr_template): Adjust call\n\tto cxx_eval_outermost_constant_expr.\n\t(fold_non_dependent_expr): Likewise.\n\t(maybe_constant_init_1): Likewise.\n\t* constraint.cc (satisfy_atom): Adjust call to\n\tmaybe_constant_value.\n\t* cp-tree.h (enum class mce_value): Define.\n\t(maybe_constant_value): Adjust manifestly_const_eval parameter\n\ttype and default argument.\n\t* decl.cc (compute_array_index_type_loc): Adjust call to\n\tmaybe_constant_value.\n\t* pt.cc (convert_nontype_argument): Likewise.", "tree": {"sha": "15b1a9aff4c04eaf0854d44d5f48b4327608a8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15b1a9aff4c04eaf0854d44d5f48b4327608a8aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/comments", "author": null, "committer": null, "parents": [{"sha": "6245441e124846d0c3551f312d2feef598fe251c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6245441e124846d0c3551f312d2feef598fe251c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6245441e124846d0c3551f312d2feef598fe251c"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "aa2c14355f827cf9a5f60eaad0b19023dffc5059", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "patch": "@@ -1119,8 +1119,8 @@ struct GTY((for_user)) constexpr_call {\n   /* The hash of this call; we remember it here to avoid having to\n      recalculate it when expanding the hash table.  */\n   hashval_t hash;\n-  /* Whether __builtin_is_constant_evaluated() should evaluate to true.  */\n-  bool manifestly_const_eval;\n+  /* The value of constexpr_ctx::manifestly_const_eval.  */\n+  enum mce_value manifestly_const_eval;\n };\n \n struct constexpr_call_hasher : ggc_ptr_hash<constexpr_call>\n@@ -1248,7 +1248,7 @@ struct constexpr_ctx {\n      trying harder to get a constant value.  */\n   bool strict;\n   /* Whether __builtin_is_constant_evaluated () should be true.  */\n-  bool manifestly_const_eval;\n+  mce_value manifestly_const_eval;\n };\n \n /* This internal flag controls whether we should avoid doing anything during\n@@ -1463,7 +1463,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   /* If we aren't requiring a constant expression, defer __builtin_constant_p\n      in a constexpr function until we have values for the parameters.  */\n   if (bi_const_p\n-      && !ctx->manifestly_const_eval\n+      && ctx->manifestly_const_eval != mce_true\n       && current_function_decl\n       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n     {\n@@ -1479,12 +1479,13 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   if (fndecl_built_in_p (fun, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n \t\t\t BUILT_IN_FRONTEND))\n     {\n-      if (!ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_unknown)\n \t{\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-      return boolean_true_node;\n+      return constant_boolean_node (ctx->manifestly_const_eval == mce_true,\n+\t\t\t\t    boolean_type_node);\n     }\n \n   if (fndecl_built_in_p (fun, CP_BUILT_IN_SOURCE_LOCATION, BUILT_IN_FRONTEND))\n@@ -1591,7 +1592,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n     }\n \n   bool save_ffbcp = force_folding_builtin_constant_p;\n-  force_folding_builtin_constant_p |= ctx->manifestly_const_eval;\n+  force_folding_builtin_constant_p |= ctx->manifestly_const_eval == mce_true;\n   tree save_cur_fn = current_function_decl;\n   /* Return name of ctx->call->fundef->decl for __builtin_FUNCTION ().  */\n   if (fndecl_built_in_p (fun, BUILT_IN_FUNCTION)\n@@ -2916,7 +2917,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       location_t save_loc = input_location;\n       input_location = loc;\n       ++function_depth;\n-      if (ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_true)\n \tFNDECL_MANIFESTLY_CONST_EVALUATED (fun) = true;\n       instantiate_decl (fun, /*defer_ok*/false, /*expl_inst*/false);\n       --function_depth;\n@@ -3676,7 +3677,7 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \n   if (r == NULL_TREE)\n     {\n-      if (ctx->manifestly_const_eval\n+      if (ctx->manifestly_const_eval == mce_true\n \t  && (flag_constexpr_fp_except\n \t      || TREE_CODE (type) != REAL_TYPE))\n \t{\n@@ -3741,13 +3742,13 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t without manifestly_const_eval even expressions or parts thereof which\n \t will later be manifestly const_eval evaluated), otherwise fold it to\n \t true.  */\n-      if (ctx->manifestly_const_eval)\n-\tval = boolean_true_node;\n-      else\n+      if (ctx->manifestly_const_eval == mce_unknown)\n \t{\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n+      val = constant_boolean_node (ctx->manifestly_const_eval == mce_true,\n+\t\t\t\t   boolean_type_node);\n     }\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n@@ -7051,7 +7052,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t      r = v;\n \t      break;\n \t    }\n-      if (ctx->manifestly_const_eval)\n+      if (ctx->manifestly_const_eval == mce_true)\n \tmaybe_warn_about_constant_value (loc, t);\n       if (COMPLETE_TYPE_P (TREE_TYPE (t))\n \t  && is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/false))\n@@ -7640,7 +7641,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif (TREE_CODE (t) == CONVERT_EXPR\n \t    && ARITHMETIC_TYPE_P (type)\n \t    && INDIRECT_TYPE_P (TREE_TYPE (op))\n-\t    && ctx->manifestly_const_eval)\n+\t    && ctx->manifestly_const_eval == mce_true)\n \t  {\n \t    if (!ctx->quiet)\n \t      error_at (loc,\n@@ -8178,7 +8179,7 @@ mark_non_constant (tree t)\n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t\t\t\t  bool strict = true,\n-\t\t\t\t  bool manifestly_const_eval = false,\n+\t\t\t\t  mce_value manifestly_const_eval = mce_unknown,\n \t\t\t\t  bool constexpr_dtor = false,\n \t\t\t\t  tree object = NULL_TREE)\n {\n@@ -8196,10 +8197,11 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   constexpr_global_ctx global_ctx;\n   constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n-\t\t\tmanifestly_const_eval || !allow_non_constant };\n+\t\t\t!allow_non_constant ? mce_true : manifestly_const_eval };\n \n   /* Turn off -frounding-math for manifestly constant evaluation.  */\n-  warning_sentinel rm (flag_rounding_math, ctx.manifestly_const_eval);\n+  warning_sentinel rm (flag_rounding_math,\n+\t\t       ctx.manifestly_const_eval == mce_true);\n   tree type = initialized_type (t);\n   tree r = t;\n   bool is_consteval = false;\n@@ -8288,7 +8290,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   auto_vec<tree, 16> cleanups;\n   global_ctx.cleanups = &cleanups;\n \n-  if (manifestly_const_eval)\n+  if (manifestly_const_eval == mce_true)\n     instantiate_constexpr_fns (r);\n   r = cxx_eval_constant_expression (&ctx, r, vc_prvalue,\n \t\t\t\t    &non_constant_p, &overflow_p);\n@@ -8427,7 +8429,7 @@ cxx_constant_value (tree t, tree decl /* = NULL_TREE */,\n \t\t    tsubst_flags_t complain /* = tf_error */)\n {\n   bool sfinae = !(complain & tf_error);\n-  tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, true, false, decl);\n+  tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, mce_true, false, decl);\n   if (sfinae && !TREE_CONSTANT (r))\n     r = error_mark_node;\n   return r;\n@@ -8439,7 +8441,7 @@ cxx_constant_value (tree t, tree decl /* = NULL_TREE */,\n void\n cxx_constant_dtor (tree t, tree decl)\n {\n-  cxx_eval_outermost_constant_expr (t, false, true, true, true, decl);\n+  cxx_eval_outermost_constant_expr (t, false, true, mce_true, true, decl);\n }\n \n /* Helper routine for fold_simple function.  Either return simplified\n@@ -8525,7 +8527,7 @@ static GTY((deletable)) hash_map<tree, tree> *cv_cache;\n \n tree\n maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n-\t\t      bool manifestly_const_eval /* = false */)\n+\t\t      mce_value manifestly_const_eval /* = mce_unknown */)\n {\n   tree r;\n \n@@ -8540,8 +8542,9 @@ maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n     /* No caching or evaluation needed.  */\n     return t;\n \n-  if (manifestly_const_eval)\n-    return cxx_eval_outermost_constant_expr (t, true, true, true, false, decl);\n+  if (manifestly_const_eval != mce_unknown)\n+    return cxx_eval_outermost_constant_expr (t, true, true,\n+\t\t\t\t\t     manifestly_const_eval, false, decl);\n \n   if (cv_cache == NULL)\n     cv_cache = hash_map<tree, tree>::create_ggc (101);\n@@ -8565,7 +8568,8 @@ maybe_constant_value (tree t, tree decl /* = NULL_TREE */,\n     return t;\n \n   uid_sensitive_constexpr_evaluation_checker c;\n-  r = cxx_eval_outermost_constant_expr (t, true, true, false, false, decl);\n+  r = cxx_eval_outermost_constant_expr (t, true, true,\n+\t\t\t\t\tmanifestly_const_eval, false, decl);\n   gcc_checking_assert (r == t\n \t\t       || CONVERT_EXPR_P (t)\n \t\t       || TREE_CODE (t) == VIEW_CONVERT_EXPR\n@@ -8631,7 +8635,7 @@ fold_non_dependent_expr_template (tree t, tsubst_flags_t complain,\n \treturn t;\n \n       tree r = cxx_eval_outermost_constant_expr (t, true, true,\n-\t\t\t\t\t\t manifestly_const_eval,\n+\t\t\t\t\t\t mce_value (manifestly_const_eval),\n \t\t\t\t\t\t false, object);\n       /* cp_tree_equal looks through NOPs, so allow them.  */\n       gcc_checking_assert (r == t\n@@ -8678,7 +8682,7 @@ fold_non_dependent_expr (tree t,\n     return fold_non_dependent_expr_template (t, complain,\n \t\t\t\t\t     manifestly_const_eval, object);\n \n-  return maybe_constant_value (t, object, manifestly_const_eval);\n+  return maybe_constant_value (t, object, mce_value (manifestly_const_eval));\n }\n \n /* Like fold_non_dependent_expr, but if EXPR couldn't be folded to a constant,\n@@ -8756,7 +8760,8 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n       bool is_static = (decl && DECL_P (decl)\n \t\t\t&& (TREE_STATIC (decl) || DECL_EXTERNAL (decl)));\n       t = cxx_eval_outermost_constant_expr (t, allow_non_constant, !is_static,\n-\t\t\t\t\t    manifestly_const_eval, false, decl);\n+\t\t\t\t\t    mce_value (manifestly_const_eval),\n+\t\t\t\t\t    false, decl);\n     }\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {"}, {"sha": "9374327008b2fe0dc95b98882383d8308d0344e6", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "patch": "@@ -3068,8 +3068,7 @@ satisfy_atom (tree t, tree args, sat_info info)\n     }\n   else\n     {\n-      result = maybe_constant_value (result, NULL_TREE,\n-\t\t\t\t     /*manifestly_const_eval=*/true);\n+      result = maybe_constant_value (result, NULL_TREE, mce_true);\n       if (!TREE_CONSTANT (result))\n \tresult = error_mark_node;\n     }"}, {"sha": "5595335bbf7bbef86c7682851e0dceaef5dc5893", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "patch": "@@ -8459,6 +8459,24 @@ struct GTY((for_user)) constexpr_fundef {\n   tree result;\n };\n \n+/* Whether the current context is manifestly constant-evaluated.\n+   Used by the constexpr machinery to control folding of\n+   __builtin_is_constant_evaluated.  */\n+\n+enum class mce_value\n+{\n+  /* Unknown, so treat __builtin_is_constant_evaluated as non-constant.  */\n+  mce_unknown = 0,\n+  /* Fold it to true.  */\n+  mce_true = 1,\n+  /* Fold it to false.  Primarily used during cp_fold_function and\n+     cp_fully_fold_init.  */\n+  mce_false = -1,\n+};\n+constexpr mce_value mce_unknown = mce_value::mce_unknown;\n+constexpr mce_value mce_true = mce_value::mce_true;\n+constexpr mce_value mce_false = mce_value::mce_false;\n+\n extern void fini_constexpr\t\t\t(void);\n extern bool literal_type_p                      (tree);\n extern void maybe_save_constexpr_fundef\t\t(tree);\n@@ -8487,7 +8505,7 @@ inline tree cxx_constant_value (tree t, tsubst_flags_t complain)\n { return cxx_constant_value (t, NULL_TREE, complain); }\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);\n+extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, mce_value = mce_unknown);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree,\n \t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error,"}, {"sha": "30c7470974d4b62ec6c03b2a7dd37f046983a247", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "patch": "@@ -11373,7 +11373,7 @@ compute_array_index_type_loc (location_t name_loc, tree name, tree size,\n \t\t\t\t    cp_convert (ssizetype, integer_one_node,\n \t\t\t\t\t\tcomplain),\n \t\t\t\t    complain);\n-\titype = maybe_constant_value (itype, NULL_TREE, true);\n+\titype = maybe_constant_value (itype, NULL_TREE, mce_true);\n       }\n \n       if (!TREE_CONSTANT (itype))"}, {"sha": "b1ac7d4beb4e0126766fac1eed8c1f6846889177", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "patch": "@@ -7390,16 +7390,14 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t      IMPLICIT_CONV_EXPR_NONTYPE_ARG (expr) = true;\n \t      return expr;\n \t    }\n-\t  expr = maybe_constant_value (expr, NULL_TREE,\n-\t\t\t\t       /*manifestly_const_eval=*/true);\n+\t  expr = maybe_constant_value (expr, NULL_TREE, mce_true);\n \t  expr = convert_from_reference (expr);\n \t  /* EXPR may have become value-dependent.  */\n \t  val_dep_p = value_dependent_expression_p (expr);\n \t}\n       else if (TYPE_PTR_OR_PTRMEM_P (type))\n \t{\n-\t  tree folded = maybe_constant_value (expr, NULL_TREE,\n-\t\t\t\t\t      /*manifestly_const_eval=*/true);\n+\t  tree folded = maybe_constant_value (expr, NULL_TREE, mce_true);\n \t  if (TYPE_PTR_P (type) ? integer_zerop (folded)\n \t      : null_member_pointer_value_p (folded))\n \t    expr = folded;"}]}