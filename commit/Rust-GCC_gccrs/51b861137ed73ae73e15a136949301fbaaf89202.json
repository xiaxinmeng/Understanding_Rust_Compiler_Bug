{"sha": "51b861137ed73ae73e15a136949301fbaaf89202", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiODYxMTM3ZWQ3M2FlNzNlMTVhMTM2OTQ5MzAxZmJhYWY4OTIwMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-01-05T19:32:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-01-05T19:32:09Z"}, "message": "Introduce RTL function reader\n\nThis is the combination of these patches:\n- [8a/9] Introduce class function_reader (v8)\n- Add ASSERT_RTX_PTR_EQ\n- [8b/9] Add target-independent selftests of RTL function reader (v2)\n- [8c/9] Add aarch64-specific selftests for RTL function reader (v2)\n- [8d/9] Add x86_64-specific selftests for RTL function reader (v2)\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add read-md.o, read-rtl.o,\n\tread-rtl-function.o, and selftest-rtl.o.\n\t* config/aarch64/aarch64.c: Include selftest.h and\n\tselftest-rtl.h.\n\t(selftest::aarch64_test_loading_full_dump): New function.\n\t(selftest::aarch64_run_selftests): New function.\n\t(TARGET_RUN_TARGET_SELFTESTS): Wire it up to\n\tselftest::aarch64_run_selftests.\n\t* config/i386/i386.c\n\t(selftest::ix86_test_loading_dump_fragment_1): New function.\n\t(selftest::ix86_test_loading_call_insn): New function.\n\t(selftest::ix86_test_loading_full_dump): New function.\n\t(selftest::ix86_test_loading_unspec): New function.\n\t(selftest::ix86_run_selftests): Call the new functions.\n\t* emit-rtl.c (maybe_set_max_label_num): New function.\n\t* emit-rtl.h (maybe_set_max_label_num): New decl.\n\t* function.c (instantiate_decls): Guard call to\n\tinstantiate_decls_1 with if (DECL_INITIAL (fndecl)).\n\t* function-tests.c (selftest::verify_three_block_rtl_cfg): Remove\n\t\"static\".\n\t* gensupport.c (gen_reader::gen_reader): Pass \"false\"\n\tfor new \"compact\" param of rtx_reader.\n\t* print-rtl.c (rtx_writer::print_rtx_operand): Print \"(nil)\"\n\trather than an empty string for NULL strings.\n\t* read-md.c: Potentially include config.h rather than bconfig.h.\n\tWrap include of errors.h with #ifdef GENERATOR_FILE.\n\t(have_error): New global, copied from errors.c.\n\t(md_reader::read_name): Rename to...\n\t(md_reader::read_name_1): ...this, adding \"out_loc\" param,\n\tand converting \"missing name or number\" to returning false, rather\n\tthan failing.\n\t(md_reader::read_name): Reimplement in terms of read_name_1.\n\t(md_reader::read_name_or_nil): New function.\n\t(md_reader::read_string): Handle \"(nil)\" by returning NULL.\n\t(md_reader::md_reader): Add new param \"compact\".\n\t(md_reader::read_md_files): Wrap with #ifdef GENERATOR_FILE.\n\t(md_reader::read_file): New method.\n\t* read-md.h (md_reader::md_reader): Add new param \"compact\".\n\t(md_reader::read_file): New method.\n\t(md_reader::is_compact): New accessor.\n\t(md_reader::read_name): Convert return type from void to\n\tfile_location.\n\t(md_reader::read_name_or_nil): New decl.\n\t(md_reader::read_name_1): New decl.\n\t(md_reader::m_compact): New field.\n\t(noop_reader::noop_reader): Pass \"false\" for new \"compact\" param\n\tof rtx_reader.\n\t(rtx_reader::rtx_reader): Add new \"compact\" param.\n\t(rtx_reader::read_rtx_operand): Make virtual and convert return\n\ttype from void to rtx.\n\t(rtx_reader::read_until): New decl.\n\t(rtx_reader::handle_any_trailing_information): New virtual\n\tfunction.\n\t(rtx_reader::postprocess): New virtual function.\n\t(rtx_reader::finalize_string): New virtual function.\n\t(rtx_reader::m_in_call_function_usage): New field.\n\t(rtx_reader::m_reuse_rtx_by_id): New field.\n\t* read-rtl-function.c: New file.\n\t* selftest-rtl.c (selftest::assert_rtx_ptr_eq_at): New function.\n\t* selftest-rtl.h (ASSERT_RTX_PTR_EQ): New macro.\n\t(selftest::verify_three_block_rtl_cfg): New decl.\n\t* read-rtl-function.h: New file.\n\t* read-rtl.c: Potentially include config.h rather than bconfig.h.\n\tFor host, include function.h, memmodel.h, and emit-rtl.h.\n\t(one_time_initialization): New function.\n\t(struct compact_insn_name): New struct.\n\t(compact_insn_names): New array.\n\t(find_code): Handle insn codes in compact dumps.\n\t(apply_subst_iterator): Wrap with #ifdef GENERATOR_FILE.\n\t(bind_subst_iter_and_attr): Likewise.\n\t(add_condition_to_string): Likewise.\n\t(add_condition_to_rtx): Likewise.\n\t(apply_attribute_uses): Likewise.\n\t(add_current_iterators): Likewise.\n\t(apply_iterators): Likewise.\n\t(initialize_iterators): Guard usage of apply_subst_iterator with\n\t#ifdef GENERATOR_FILE.\n\t(read_conditions): Wrap with #ifdef GENERATOR_FILE.\n\t(md_reader::read_mapping): Likewise.\n\t(add_define_attr_for_define_subst): Likewise.\n\t(add_define_subst_attr): Likewise.\n\t(read_subst_mapping): Likewise.\n\t(check_code_iterator): Likewise.\n\t(rtx_reader::read_rtx): Likewise.  Move one-time initialization\n\tlogic to...\n\t(one_time_initialization): New function.\n\t(rtx_reader::read_until): New method.\n\t(read_flags): New function.\n\t(parse_reg_note_name): New function.\n\t(rtx_reader::read_rtx_code): Initialize \"iterator\" to NULL.\n\tHandle reuse_rtx ids.\n\tWrap iterator lookup within #ifdef GENERATOR_FILE.\n\tAdd parsing support for RTL dumps, mirroring the special-cases in\n\tprint_rtx, by calling read_flags, reading REG_NOTE names, INSN_UID\n\tvalues, and calling handle_any_trailing_information.\n\t(rtx_reader::read_rtx_operand): Convert return type from void\n\tto rtx, returning return_rtx.  Handle case 'e'.  Call\n\tfinalize_string on XSTR and XTMPL fields.\n\t(rtx_reader::read_nested_rtx):  Handle dumps in which trailing\n\t \"(nil)\" values were omitted.  Call the postprocess vfunc on the\n\treturn_rtx.\n\t(rtx_reader::rtx_reader): Add new \"compact\" param and pass to base\n\tclass ctor.  Initialize m_in_call_function_usage.  Call\n\tone_time_initialization.\n\t* rtl-tests.c (selftest::test_uncond_jump): Call\n\tset_new_first_and_last_insn.\n\t* rtl.h (read_rtx): Wrap decl with #ifdef GENERATOR_FILE.\n\t* selftest-rtl.c: New file.\n\t* selftest-rtl.h (class selftest::rtl_dump_test): New class.\n\t(selftest::get_insn_by_uid): New decl.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tread_rtl_function_c_tests.\n\t* selftest.h  (selftest::read_rtl_function_c_tests): New decl.\n\t* tree-dfa.c (ssa_default_def): Return NULL_TREE for rtl function\n\tdumps.\n\ngcc/testsuite/ChangeLog:\n\t* selftests/asr_div1.rtl: New file.\n\t* selftests/aarch64: New subdirectory.\n\t* selftests/aarch64/times-two.rtl: New file.\n\t* selftests/bb-index.rtl: New file.\n\t* selftests/cfg-test.rtl: New file.\n\t* selftests/const-int.rtl: New file.\n\t* selftests/example-labels.rtl: New file.\n\t* selftests/insn-with-mode.rtl: New file.\n\t* selftests/jump-to-label-ref.rtl: New file.\n\t* selftests/jump-to-return.rtl: New file.\n\t* selftests/jump-to-simple-return.rtl: New file.\n\t* selftests/mem.rtl: New file.\n\t* selftests/note-insn-deleted.rtl: New file.\n\t* selftests/note_insn_basic_block.rtl: New file.\n\t* selftests/simple-cse.rtl: New file.\n\t* selftests/symbol-ref.rtl: New file.\n\t* selftests/x86_64: New subdirectory.\n\t* selftests/x86_64/call-insn.rtl: New file.\n\t* selftests/x86_64/copy-hard-reg-into-frame.rtl: New file.\n\t* selftests/x86_64/times-two.rtl: New file.\n\t* selftests/x86_64/unspec.rtl: New file.\n\nFrom-SVN: r244110", "tree": {"sha": "fd9bdb64e3920b3c35272969864ac5576f4fdad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd9bdb64e3920b3c35272969864ac5576f4fdad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b861137ed73ae73e15a136949301fbaaf89202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b861137ed73ae73e15a136949301fbaaf89202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b861137ed73ae73e15a136949301fbaaf89202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b861137ed73ae73e15a136949301fbaaf89202/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f86d7de6b80f68a47fc48f82af1a3ec9dbda21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f86d7de6b80f68a47fc48f82af1a3ec9dbda21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f86d7de6b80f68a47fc48f82af1a3ec9dbda21a"}], "stats": {"total": 3446, "additions": 3414, "deletions": 32}, "files": [{"sha": "1114d8a5f396752edb1fa724fac75c7790eadf88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -1,3 +1,121 @@\n+2017-01-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add read-md.o, read-rtl.o,\n+\tread-rtl-function.o, and selftest-rtl.o.\n+\t* config/aarch64/aarch64.c: Include selftest.h and\n+\tselftest-rtl.h.\n+\t(selftest::aarch64_test_loading_full_dump): New function.\n+\t(selftest::aarch64_run_selftests): New function.\n+\t(TARGET_RUN_TARGET_SELFTESTS): Wire it up to\n+\tselftest::aarch64_run_selftests.\n+\t* config/i386/i386.c\n+\t(selftest::ix86_test_loading_dump_fragment_1): New function.\n+\t(selftest::ix86_test_loading_call_insn): New function.\n+\t(selftest::ix86_test_loading_full_dump): New function.\n+\t(selftest::ix86_test_loading_unspec): New function.\n+\t(selftest::ix86_run_selftests): Call the new functions.\n+\t* emit-rtl.c (maybe_set_max_label_num): New function.\n+\t* emit-rtl.h (maybe_set_max_label_num): New decl.\n+\t* function.c (instantiate_decls): Guard call to\n+\tinstantiate_decls_1 with if (DECL_INITIAL (fndecl)).\n+\t* function-tests.c (selftest::verify_three_block_rtl_cfg): Remove\n+\t\"static\".\n+\t* gensupport.c (gen_reader::gen_reader): Pass \"false\"\n+\tfor new \"compact\" param of rtx_reader.\n+\t* print-rtl.c (rtx_writer::print_rtx_operand): Print \"(nil)\"\n+\trather than an empty string for NULL strings.\n+\t* read-md.c: Potentially include config.h rather than bconfig.h.\n+\tWrap include of errors.h with #ifdef GENERATOR_FILE.\n+\t(have_error): New global, copied from errors.c.\n+\t(md_reader::read_name): Rename to...\n+\t(md_reader::read_name_1): ...this, adding \"out_loc\" param,\n+\tand converting \"missing name or number\" to returning false, rather\n+\tthan failing.\n+\t(md_reader::read_name): Reimplement in terms of read_name_1.\n+\t(md_reader::read_name_or_nil): New function.\n+\t(md_reader::read_string): Handle \"(nil)\" by returning NULL.\n+\t(md_reader::md_reader): Add new param \"compact\".\n+\t(md_reader::read_md_files): Wrap with #ifdef GENERATOR_FILE.\n+\t(md_reader::read_file): New method.\n+\t* read-md.h (md_reader::md_reader): Add new param \"compact\".\n+\t(md_reader::read_file): New method.\n+\t(md_reader::is_compact): New accessor.\n+\t(md_reader::read_name): Convert return type from void to\n+\tfile_location.\n+\t(md_reader::read_name_or_nil): New decl.\n+\t(md_reader::read_name_1): New decl.\n+\t(md_reader::m_compact): New field.\n+\t(noop_reader::noop_reader): Pass \"false\" for new \"compact\" param\n+\tof rtx_reader.\n+\t(rtx_reader::rtx_reader): Add new \"compact\" param.\n+\t(rtx_reader::read_rtx_operand): Make virtual and convert return\n+\ttype from void to rtx.\n+\t(rtx_reader::read_until): New decl.\n+\t(rtx_reader::handle_any_trailing_information): New virtual\n+\tfunction.\n+\t(rtx_reader::postprocess): New virtual function.\n+\t(rtx_reader::finalize_string): New virtual function.\n+\t(rtx_reader::m_in_call_function_usage): New field.\n+\t(rtx_reader::m_reuse_rtx_by_id): New field.\n+\t* read-rtl-function.c: New file.\n+\t* selftest-rtl.c (selftest::assert_rtx_ptr_eq_at): New function.\n+\t* selftest-rtl.h (ASSERT_RTX_PTR_EQ): New macro.\n+\t(selftest::verify_three_block_rtl_cfg): New decl.\n+\t* read-rtl-function.h: New file.\n+\t* read-rtl.c: Potentially include config.h rather than bconfig.h.\n+\tFor host, include function.h, memmodel.h, and emit-rtl.h.\n+\t(one_time_initialization): New function.\n+\t(struct compact_insn_name): New struct.\n+\t(compact_insn_names): New array.\n+\t(find_code): Handle insn codes in compact dumps.\n+\t(apply_subst_iterator): Wrap with #ifdef GENERATOR_FILE.\n+\t(bind_subst_iter_and_attr): Likewise.\n+\t(add_condition_to_string): Likewise.\n+\t(add_condition_to_rtx): Likewise.\n+\t(apply_attribute_uses): Likewise.\n+\t(add_current_iterators): Likewise.\n+\t(apply_iterators): Likewise.\n+\t(initialize_iterators): Guard usage of apply_subst_iterator with\n+\t#ifdef GENERATOR_FILE.\n+\t(read_conditions): Wrap with #ifdef GENERATOR_FILE.\n+\t(md_reader::read_mapping): Likewise.\n+\t(add_define_attr_for_define_subst): Likewise.\n+\t(add_define_subst_attr): Likewise.\n+\t(read_subst_mapping): Likewise.\n+\t(check_code_iterator): Likewise.\n+\t(rtx_reader::read_rtx): Likewise.  Move one-time initialization\n+\tlogic to...\n+\t(one_time_initialization): New function.\n+\t(rtx_reader::read_until): New method.\n+\t(read_flags): New function.\n+\t(parse_reg_note_name): New function.\n+\t(rtx_reader::read_rtx_code): Initialize \"iterator\" to NULL.\n+\tHandle reuse_rtx ids.\n+\tWrap iterator lookup within #ifdef GENERATOR_FILE.\n+\tAdd parsing support for RTL dumps, mirroring the special-cases in\n+\tprint_rtx, by calling read_flags, reading REG_NOTE names, INSN_UID\n+\tvalues, and calling handle_any_trailing_information.\n+\t(rtx_reader::read_rtx_operand): Convert return type from void\n+\tto rtx, returning return_rtx.  Handle case 'e'.  Call\n+\tfinalize_string on XSTR and XTMPL fields.\n+\t(rtx_reader::read_nested_rtx):  Handle dumps in which trailing\n+\t \"(nil)\" values were omitted.  Call the postprocess vfunc on the\n+\treturn_rtx.\n+\t(rtx_reader::rtx_reader): Add new \"compact\" param and pass to base\n+\tclass ctor.  Initialize m_in_call_function_usage.  Call\n+\tone_time_initialization.\n+\t* rtl-tests.c (selftest::test_uncond_jump): Call\n+\tset_new_first_and_last_insn.\n+\t* rtl.h (read_rtx): Wrap decl with #ifdef GENERATOR_FILE.\n+\t* selftest-rtl.c: New file.\n+\t* selftest-rtl.h (class selftest::rtl_dump_test): New class.\n+\t(selftest::get_insn_by_uid): New decl.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tread_rtl_function_c_tests.\n+\t* selftest.h  (selftest::read_rtl_function_c_tests): New decl.\n+\t* tree-dfa.c (ssa_default_def): Return NULL_TREE for rtl function\n+\tdumps.\n+\n 2017-01-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*testqi_ext_3): No need to handle memory"}, {"sha": "c53c78a2f03f73ebe5ca4b96ed4f2254e9f5fcc7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -1420,6 +1420,9 @@ OBJS = \\\n \tprint-rtl-function.o \\\n \tprint-tree.o \\\n \tprofile.o \\\n+\tread-md.o \\\n+\tread-rtl.o \\\n+\tread-rtl-function.o \\\n \treal.o \\\n \trealmpfr.o \\\n \trecog.o \\\n@@ -1447,6 +1450,7 @@ OBJS = \\\n \tsel-sched-ir.o \\\n \tsel-sched-dump.o \\\n \tsel-sched.o \\\n+\tselftest-rtl.o \\\n \tselftest-run-tests.o \\\n \tsese.o \\\n \tshrink-wrap.o \\"}, {"sha": "4a3cf18162200f35a5f945000628c8947d0a991f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -64,6 +64,8 @@\n #include \"sched-int.h\"\n #include \"target-globals.h\"\n #include \"common/common-target.h\"\n+#include \"selftest.h\"\n+#include \"selftest-rtl.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -14605,6 +14607,52 @@ aarch64_excess_precision (enum excess_precision_type type)\n   return FLT_EVAL_METHOD_UNPREDICTABLE;\n }\n \n+/* Target-specific selftests.  */\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftest for the RTL loader.\n+   Verify that the RTL loader copes with a dump from\n+   print_rtx_function.  This is essentially just a test that class\n+   function_reader can handle a real dump, but it also verifies\n+   that lookup_reg_by_dump_name correctly handles hard regs.\n+   The presence of hard reg names in the dump means that the test is\n+   target-specific, hence it is in this file.  */\n+\n+static void\n+aarch64_test_loading_full_dump ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"aarch64/times-two.rtl\"));\n+\n+  ASSERT_STREQ (\"times_two\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+\n+  rtx_insn *insn_1 = get_insn_by_uid (1);\n+  ASSERT_EQ (NOTE, GET_CODE (insn_1));\n+\n+  rtx_insn *insn_15 = get_insn_by_uid (15);\n+  ASSERT_EQ (INSN, GET_CODE (insn_15));\n+  ASSERT_EQ (USE, GET_CODE (PATTERN (insn_15)));\n+\n+  /* Verify crtl->return_rtx.  */\n+  ASSERT_EQ (REG, GET_CODE (crtl->return_rtx));\n+  ASSERT_EQ (0, REGNO (crtl->return_rtx));\n+  ASSERT_EQ (SImode, GET_MODE (crtl->return_rtx));\n+}\n+\n+/* Run all target-specific selftests.  */\n+\n+static void\n+aarch64_run_selftests (void)\n+{\n+  aarch64_test_loading_full_dump ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */\n+\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST aarch64_address_cost\n \n@@ -14977,6 +15025,11 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_OMIT_STRUCT_RETURN_REG\n #define TARGET_OMIT_STRUCT_RETURN_REG true\n \n+#if CHECKING_P\n+#undef TARGET_RUN_TARGET_SELFTESTS\n+#define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests\n+#endif /* #if CHECKING_P */\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}, {"sha": "3ad021a607f9d2288ca117b52685fb9fe0265bcc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -51206,13 +51206,223 @@ ix86_test_dumping_memory_blockage ()\n        \"            ] UNSPEC_MEMORY_BLOCKAGE)))\\n\", pat, &r);\n }\n \n+/* Verify loading an RTL dump; specifically a dump of copying\n+   a param on x86_64 from a hard reg into the frame.\n+   This test is target-specific since the dump contains target-specific\n+   hard reg names.  */\n+\n+static void\n+ix86_test_loading_dump_fragment_1 ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION,\n+\t\t   locate_file (\"x86_64/copy-hard-reg-into-frame.rtl\"));\n+\n+  rtx_insn *insn = get_insn_by_uid (1);\n+\n+  /* The block structure and indentation here is purely for\n+     readability; it mirrors the structure of the rtx.  */\n+  tree mem_expr;\n+  {\n+    rtx pat = PATTERN (insn);\n+    ASSERT_EQ (SET, GET_CODE (pat));\n+    {\n+      rtx dest = SET_DEST (pat);\n+      ASSERT_EQ (MEM, GET_CODE (dest));\n+      /* Verify the \"/c\" was parsed.  */\n+      ASSERT_TRUE (RTX_FLAG (dest, call));\n+      ASSERT_EQ (SImode, GET_MODE (dest));\n+      {\n+\trtx addr = XEXP (dest, 0);\n+\tASSERT_EQ (PLUS, GET_CODE (addr));\n+\tASSERT_EQ (DImode, GET_MODE (addr));\n+\t{\n+\t  rtx lhs = XEXP (addr, 0);\n+\t  /* Verify that the \"frame\" REG was consolidated.  */\n+\t  ASSERT_RTX_PTR_EQ (frame_pointer_rtx, lhs);\n+\t}\n+\t{\n+\t  rtx rhs = XEXP (addr, 1);\n+\t  ASSERT_EQ (CONST_INT, GET_CODE (rhs));\n+\t  ASSERT_EQ (-4, INTVAL (rhs));\n+\t}\n+      }\n+      /* Verify the \"[1 i+0 S4 A32]\" was parsed.  */\n+      ASSERT_EQ (1, MEM_ALIAS_SET (dest));\n+      /* \"i\" should have been handled by synthesizing a global int\n+\t variable named \"i\".  */\n+      mem_expr = MEM_EXPR (dest);\n+      ASSERT_NE (mem_expr, NULL);\n+      ASSERT_EQ (VAR_DECL, TREE_CODE (mem_expr));\n+      ASSERT_EQ (integer_type_node, TREE_TYPE (mem_expr));\n+      ASSERT_EQ (IDENTIFIER_NODE, TREE_CODE (DECL_NAME (mem_expr)));\n+      ASSERT_STREQ (\"i\", IDENTIFIER_POINTER (DECL_NAME (mem_expr)));\n+      /* \"+0\".  */\n+      ASSERT_TRUE (MEM_OFFSET_KNOWN_P (dest));\n+      ASSERT_EQ (0, MEM_OFFSET (dest));\n+      /* \"S4\".  */\n+      ASSERT_EQ (4, MEM_SIZE (dest));\n+      /* \"A32.  */\n+      ASSERT_EQ (32, MEM_ALIGN (dest));\n+    }\n+    {\n+      rtx src = SET_SRC (pat);\n+      ASSERT_EQ (REG, GET_CODE (src));\n+      ASSERT_EQ (SImode, GET_MODE (src));\n+      ASSERT_EQ (5, REGNO (src));\n+      tree reg_expr = REG_EXPR (src);\n+      /* \"i\" here should point to the same var as for the MEM_EXPR.  */\n+      ASSERT_EQ (reg_expr, mem_expr);\n+    }\n+  }\n+}\n+\n+/* Verify that the RTL loader copes with a call_insn dump.\n+   This test is target-specific since the dump contains a target-specific\n+   hard reg name.  */\n+\n+static void\n+ix86_test_loading_call_insn ()\n+{\n+  /* The test dump includes register \"xmm0\", where requires TARGET_SSE\n+     to exist.  */\n+  if (!TARGET_SSE)\n+    return;\n+\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"x86_64/call-insn.rtl\"));\n+\n+  rtx_insn *insn = get_insns ();\n+  ASSERT_EQ (CALL_INSN, GET_CODE (insn));\n+\n+  /* \"/j\".  */\n+  ASSERT_TRUE (RTX_FLAG (insn, jump));\n+\n+  rtx pat = PATTERN (insn);\n+  ASSERT_EQ (CALL, GET_CODE (SET_SRC (pat)));\n+\n+  /* Verify REG_NOTES.  */\n+  {\n+    /* \"(expr_list:REG_CALL_DECL\".   */\n+    ASSERT_EQ (EXPR_LIST, GET_CODE (REG_NOTES (insn)));\n+    rtx_expr_list *note0 = as_a <rtx_expr_list *> (REG_NOTES (insn));\n+    ASSERT_EQ (REG_CALL_DECL, REG_NOTE_KIND (note0));\n+\n+    /* \"(expr_list:REG_EH_REGION (const_int 0 [0])\".  */\n+    rtx_expr_list *note1 = note0->next ();\n+    ASSERT_EQ (REG_EH_REGION, REG_NOTE_KIND (note1));\n+\n+    ASSERT_EQ (NULL, note1->next ());\n+  }\n+\n+  /* Verify CALL_INSN_FUNCTION_USAGE.  */\n+  {\n+    /* \"(expr_list:DF (use (reg:DF 21 xmm0))\".  */\n+    rtx_expr_list *usage\n+      = as_a <rtx_expr_list *> (CALL_INSN_FUNCTION_USAGE (insn));\n+    ASSERT_EQ (EXPR_LIST, GET_CODE (usage));\n+    ASSERT_EQ (DFmode, GET_MODE (usage));\n+    ASSERT_EQ (USE, GET_CODE (usage->element ()));\n+    ASSERT_EQ (NULL, usage->next ());\n+  }\n+}\n+\n+/* Verify that the RTL loader copes a dump from print_rtx_function.\n+   This test is target-specific since the dump contains target-specific\n+   hard reg names.  */\n+\n+static void\n+ix86_test_loading_full_dump ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"x86_64/times-two.rtl\"));\n+\n+  ASSERT_STREQ (\"times_two\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+\n+  rtx_insn *insn_1 = get_insn_by_uid (1);\n+  ASSERT_EQ (NOTE, GET_CODE (insn_1));\n+\n+  rtx_insn *insn_7 = get_insn_by_uid (7);\n+  ASSERT_EQ (INSN, GET_CODE (insn_7));\n+  ASSERT_EQ (PARALLEL, GET_CODE (PATTERN (insn_7)));\n+\n+  rtx_insn *insn_15 = get_insn_by_uid (15);\n+  ASSERT_EQ (INSN, GET_CODE (insn_15));\n+  ASSERT_EQ (USE, GET_CODE (PATTERN (insn_15)));\n+\n+  /* Verify crtl->return_rtx.  */\n+  ASSERT_EQ (REG, GET_CODE (crtl->return_rtx));\n+  ASSERT_EQ (0, REGNO (crtl->return_rtx));\n+  ASSERT_EQ (SImode, GET_MODE (crtl->return_rtx));\n+}\n+\n+/* Verify that the RTL loader copes with UNSPEC and UNSPEC_VOLATILE insns.\n+   In particular, verify that it correctly loads the 2nd operand.\n+   This test is target-specific since these are machine-specific\n+   operands (and enums).  */\n+\n+static void\n+ix86_test_loading_unspec ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"x86_64/unspec.rtl\"));\n+\n+  ASSERT_STREQ (\"test_unspec\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+\n+  ASSERT_TRUE (cfun);\n+\n+  /* Test of an UNSPEC.  */\n+   rtx_insn *insn = get_insns ();\n+  ASSERT_EQ (INSN, GET_CODE (insn));\n+  rtx set = single_set (insn);\n+  ASSERT_NE (NULL, set);\n+  rtx dst = SET_DEST (set);\n+  ASSERT_EQ (MEM, GET_CODE (dst));\n+  rtx src = SET_SRC (set);\n+  ASSERT_EQ (UNSPEC, GET_CODE (src));\n+  ASSERT_EQ (BLKmode, GET_MODE (src));\n+  ASSERT_EQ (UNSPEC_MEMORY_BLOCKAGE, XINT (src, 1));\n+\n+  rtx v0 = XVECEXP (src, 0, 0);\n+\n+  /* Verify that the two uses of the first SCRATCH have pointer\n+     equality.  */\n+  rtx scratch_a = XEXP (dst, 0);\n+  ASSERT_EQ (SCRATCH, GET_CODE (scratch_a));\n+\n+  rtx scratch_b = XEXP (v0, 0);\n+  ASSERT_EQ (SCRATCH, GET_CODE (scratch_b));\n+\n+  ASSERT_EQ (scratch_a, scratch_b);\n+\n+  /* Verify that the two mems are thus treated as equal.  */\n+  ASSERT_TRUE (rtx_equal_p (dst, v0));\n+\n+  /* Verify the the insn is recognized.  */\n+  ASSERT_NE(-1, recog_memoized (insn));\n+\n+  /* Test of an UNSPEC_VOLATILE, which has its own enum values.  */\n+  insn = NEXT_INSN (insn);\n+  ASSERT_EQ (INSN, GET_CODE (insn));\n+\n+  set = single_set (insn);\n+  ASSERT_NE (NULL, set);\n+\n+  src = SET_SRC (set);\n+  ASSERT_EQ (UNSPEC_VOLATILE, GET_CODE (src));\n+  ASSERT_EQ (UNSPECV_RDTSCP, XINT (src, 1));\n+}\n+\n /* Run all target-specific selftests.  */\n \n static void\n ix86_run_selftests (void)\n {\n   ix86_test_dumping_hard_regs ();\n   ix86_test_dumping_memory_blockage ();\n+\n+  /* Various tests of loading RTL dumps, here because they contain\n+     ix86-isms (e.g. names of hard regs).  */\n+  ix86_test_loading_dump_fragment_1 ();\n+  ix86_test_loading_call_insn ();\n+  ix86_test_loading_full_dump ();\n+  ix86_test_loading_unspec ();\n }\n \n } // namespace selftest"}, {"sha": "0b9552b3541e3b5c5336af5c61b642c66eb154ab", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -1374,6 +1374,19 @@ maybe_set_first_label_num (rtx_code_label *x)\n   if (CODE_LABEL_NUMBER (x) < first_label_num)\n     first_label_num = CODE_LABEL_NUMBER (x);\n }\n+\n+/* For use by the RTL function loader, when mingling with normal\n+   functions.\n+   Ensure that label_num is greater than the label num of X, to avoid\n+   duplicate labels in the generated assembler.  */\n+\n+void\n+maybe_set_max_label_num (rtx_code_label *x)\n+{\n+  if (CODE_LABEL_NUMBER (x) >= label_num)\n+    label_num = CODE_LABEL_NUMBER (x) + 1;\n+}\n+\n \f\n /* Return a value representing some low-order bits of X, where the number\n    of low-order bits is given by MODE.  Note that no conversion is done"}, {"sha": "da60a2d808c1742f65f0571c3422422292163906", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -510,4 +510,6 @@ extern int get_mem_align_offset (rtx, unsigned int);\n    MODE and adjusted by OFFSET.  */\n extern rtx widen_memory_access (rtx, machine_mode, HOST_WIDE_INT);\n \n+extern void maybe_set_max_label_num (rtx_code_label *x);\n+\n #endif /* GCC_EMIT_RTL_H */"}, {"sha": "ca30028143b262187b9d11cd0e65b26a2be81775", "filename": "gcc/function-tests.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ffunction-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ffunction-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -421,7 +421,7 @@ verify_three_block_gimple_cfg (function *fun)\n \n /* As above, but additionally verify the RTL insns are sane.  */\n \n-static void\n+void\n verify_three_block_rtl_cfg (function *fun)\n {\n   verify_three_block_cfg (fun);"}, {"sha": "7fde96adbe37470411e0136f29c9df101e18fa71", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -1909,7 +1909,8 @@ instantiate_decls (tree fndecl)\n     instantiate_decl_rtl (DECL_RTL (DECL_VALUE_EXPR (decl)));\n \n   /* Now process all variables defined in the function or its subblocks.  */\n-  instantiate_decls_1 (DECL_INITIAL (fndecl));\n+  if (DECL_INITIAL (fndecl))\n+    instantiate_decls_1 (DECL_INITIAL (fndecl));\n \n   FOR_EACH_LOCAL_DECL (cfun, ix, decl)\n     if (DECL_RTL_SET_P (decl))"}, {"sha": "cef0a0c83c8b0a7d434d6ce5586ab3eabee1eb69", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -2233,7 +2233,7 @@ process_define_subst (void)\n class gen_reader : public rtx_reader\n {\n  public:\n-  gen_reader () : rtx_reader () {}\n+  gen_reader () : rtx_reader (false) {}\n   void handle_unknown_directive (file_location, const char *);\n };\n "}, {"sha": "30fd7597450f99214dcf0f06b4436b4ef73bc5f3", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -577,7 +577,7 @@ rtx_writer::print_rtx_operand (const_rtx in_rtx, int idx)\n     string:\n \n       if (str == 0)\n-\tfputs (\" \\\"\\\"\", m_outfile);\n+\tfputs (\" (nil)\", m_outfile);\n       else\n \tfprintf (m_outfile, \" (\\\"%s\\\")\", str);\n       m_sawclose = 1;"}, {"sha": "ac28944d67150a8080c2950be346f8aa5dcda771", "filename": "gcc/read-md.c", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -17,14 +17,32 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* This file is compiled twice: once for the generator programs\n+   once for the compiler.  */\n+#ifdef GENERATOR_FILE\n #include \"bconfig.h\"\n+#else\n+#include \"config.h\"\n+#endif\n #include \"system.h\"\n #include \"coretypes.h\"\n+#ifdef GENERATOR_FILE\n #include \"errors.h\"\n+#endif /* #ifdef GENERATOR_FILE */\n #include \"statistics.h\"\n #include \"vec.h\"\n #include \"read-md.h\"\n \n+#ifndef GENERATOR_FILE\n+\n+/* Minimal reimplementation of errors.c for use by RTL frontend\n+   within cc1.  */\n+\n+int have_error = 0;\n+\n+#endif /* #ifndef GENERATOR_FILE */\n+\n+\n /* Associates PTR (which can be a string, etc.) with the file location\n    specified by FILENAME and LINENO.  */\n struct ptr_loc {\n@@ -424,15 +442,17 @@ md_reader::peek_char (void)\n /* Read an rtx code name into NAME.  It is terminated by any of the\n    punctuation chars of rtx printed syntax.  */\n \n-void\n-md_reader::read_name (struct md_name *name)\n+bool\n+md_reader::read_name_1 (struct md_name *name, file_location *out_loc)\n {\n   int c;\n   size_t i;\n   int angle_bracket_depth;\n \n   c = read_skip_spaces ();\n \n+  *out_loc = get_current_location ();\n+\n   i = 0;\n   angle_bracket_depth = 0;\n   while (1)\n@@ -464,7 +484,7 @@ md_reader::read_name (struct md_name *name)\n     }\n \n   if (i == 0)\n-    fatal_with_file_and_line (\"missing name or number\");\n+    return false;\n \n   name->buffer[i] = 0;\n   name->string = name->buffer;\n@@ -485,6 +505,36 @@ md_reader::read_name (struct md_name *name)\n \t}\n       while (def);\n     }\n+\n+  return true;\n+}\n+\n+/* Read an rtx code name into NAME.  It is terminated by any of the\n+   punctuation chars of rtx printed syntax.  */\n+\n+file_location\n+md_reader::read_name (struct md_name *name)\n+{\n+  file_location loc;\n+  if (!read_name_1 (name, &loc))\n+    fatal_with_file_and_line (\"missing name or number\");\n+  return loc;\n+}\n+\n+file_location\n+md_reader::read_name_or_nil (struct md_name *name)\n+{\n+  file_location loc;\n+  if (!read_name_1 (name, &loc))\n+    {\n+      file_location loc = get_current_location ();\n+      read_skip_construct (0, loc);\n+      /* Skip the ')'.  */\n+      read_char ();\n+      name->buffer[0] = 0;\n+      name->string = name->buffer;\n+    }\n+  return loc;\n }\n \n /* Subroutine of the string readers.  Handles backslash escapes.\n@@ -630,6 +680,14 @@ md_reader::read_string (int star_if_braced)\n \tobstack_1grow (&m_string_obstack, '*');\n       stringbuf = read_braced_string ();\n     }\n+  else if (saw_paren && c == 'n')\n+    {\n+      /* Handle (nil) by returning NULL.  */\n+      require_char ('i');\n+      require_char ('l');\n+      require_char_ws (')');\n+      return NULL;\n+    }\n   else\n     fatal_with_file_and_line (\"expected `\\\"' or `{', found `%c'\", c);\n \n@@ -924,8 +982,9 @@ md_reader::traverse_enum_types (htab_trav callback, void *info)\n \n /* Constructor for md_reader.  */\n \n-md_reader::md_reader ()\n-: m_toplevel_fname (NULL),\n+md_reader::md_reader (bool compact)\n+: m_compact (compact),\n+  m_toplevel_fname (NULL),\n   m_base_dir (NULL),\n   m_read_md_file (NULL),\n   m_read_md_filename (NULL),\n@@ -1129,6 +1188,8 @@ md_reader::add_include_path (const char *arg)\n   m_last_dir_md_include_ptr = &dirtmp->next;\n }\n \n+#ifdef GENERATOR_FILE\n+\n /* The main routine for reading .md files.  Try to process all the .md\n    files specified on the command line and return true if no error occurred.\n \n@@ -1235,6 +1296,24 @@ md_reader::read_md_files (int argc, const char **argv,\n   return !have_error;\n }\n \n+#endif /* #ifdef GENERATOR_FILE */\n+\n+/* Read FILENAME.  */\n+\n+bool\n+md_reader::read_file (const char *filename)\n+{\n+  m_read_md_filename = filename;\n+  m_read_md_file = fopen (m_read_md_filename, \"r\");\n+  if (m_read_md_file == 0)\n+    {\n+      perror (m_read_md_filename);\n+      return false;\n+    }\n+  handle_toplevel_file ();\n+  return !have_error;\n+}\n+\n /* class noop_reader : public md_reader */\n \n /* A dummy implementation which skips unknown directives.  */"}, {"sha": "4fcbcb4b4e74463faa590423e297a4a3a88d511e", "filename": "gcc/read-md.h", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -106,10 +106,11 @@ struct enum_type {\n class md_reader\n {\n  public:\n-  md_reader ();\n+  md_reader (bool compact);\n   virtual ~md_reader ();\n \n   bool read_md_files (int, const char **, bool (*) (const char *));\n+  bool read_file (const char *filename);\n \n   /* A hook that handles a single .md-file directive, up to but not\n      including the closing ')'.  It takes two arguments: the file position\n@@ -119,10 +120,13 @@ class md_reader\n \n   file_location get_current_location () const;\n \n+  bool is_compact () const { return m_compact; }\n+\n   /* Defined in read-md.c.  */\n   int read_char (void);\n   void unread_char (int ch);\n-  void read_name (struct md_name *name);\n+  file_location read_name (struct md_name *name);\n+  file_location read_name_or_nil (struct md_name *);\n   void read_escape ();\n   char *read_quoted_string ();\n   char *read_braced_string ();\n@@ -179,7 +183,12 @@ class md_reader\n   void handle_include (file_location loc);\n   void add_include_path (const char *arg);\n \n+  bool read_name_1 (struct md_name *name, file_location *out_loc);\n+\n  private:\n+  /* Are we reading a compact dump?  */\n+  bool m_compact;\n+\n   /* The name of the toplevel file that indirectly included\n      m_read_md_file.  */\n   const char *m_toplevel_fname;\n@@ -247,7 +256,7 @@ extern md_reader *md_reader_ptr;\n class noop_reader : public md_reader\n {\n  public:\n-  noop_reader () : md_reader () {}\n+  noop_reader () : md_reader (false) {}\n \n   /* A dummy implementation which skips unknown directives.  */\n   void handle_unknown_directive (file_location, const char *);\n@@ -261,14 +270,30 @@ class noop_reader : public md_reader\n class rtx_reader : public md_reader\n {\n  public:\n-  rtx_reader ();\n+  rtx_reader (bool compact);\n   ~rtx_reader ();\n \n   bool read_rtx (const char *rtx_name, vec<rtx> *rtxen);\n   rtx read_rtx_code (const char *code_name);\n-  void read_rtx_operand (rtx return_rtx, int idx);\n+  virtual rtx read_rtx_operand (rtx return_rtx, int idx);\n   rtx read_nested_rtx ();\n   rtx read_rtx_variadic (rtx form);\n+  char *read_until (const char *terminator_chars, bool consume_terminator);\n+\n+  virtual void handle_any_trailing_information (rtx) {}\n+  virtual rtx postprocess (rtx x) { return x; }\n+\n+  /* Hook to allow function_reader subclass to put STRINGBUF into gc-managed\n+     memory, rather than within an obstack.\n+     This base class implementation is a no-op.  */\n+  virtual const char *finalize_string (char *stringbuf) { return stringbuf; }\n+\n+ protected:\n+  /* Analogous to rtx_writer's m_in_call_function_usage.  */\n+  bool m_in_call_function_usage;\n+\n+  /* Support for \"reuse_rtx\" directives.  */\n+  auto_vec<rtx> m_reuse_rtx_by_id;\n };\n \n /* Global singleton; constrast with md_reader_ptr above.  */"}, {"sha": "c5cb3f7953f7cf587e14c148445d3474a7d70745", "filename": "gcc/read-rtl-function.c", "status": "added", "additions": 2123, "deletions": 0, "changes": 2123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,2123 @@\n+/* read-rtl-function.c - Reader for RTL function dumps\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"read-md.h\"\n+#include \"rtl.h\"\n+#include \"cfghooks.h\"\n+#include \"stringpool.h\"\n+#include \"function.h\"\n+#include \"tree-cfg.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"cfgrtl.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"toplev.h\"\n+#include \"varasm.h\"\n+#include \"read-rtl-function.h\"\n+#include \"selftest.h\"\n+#include \"selftest-rtl.h\"\n+\n+/* Forward decls.  */\n+class function_reader;\n+class fixup;\n+\n+/* Edges are recorded when parsing the \"insn-chain\" directive,\n+   and created at the end when all the blocks ought to exist.\n+   This struct records an \"edge-from\" or \"edge-to\" directive seen\n+   at LOC, which will be turned into an actual CFG edge once\n+   the \"insn-chain\" is fully parsed.  */\n+\n+struct deferred_edge\n+{\n+  deferred_edge (file_location loc, int src_bb_idx, int dest_bb_idx, int flags)\n+  : m_loc (loc), m_src_bb_idx (src_bb_idx), m_dest_bb_idx (dest_bb_idx),\n+    m_flags (flags)\n+  {}\n+\n+  file_location m_loc;\n+  int m_src_bb_idx;\n+  int m_dest_bb_idx;\n+  int m_flags;\n+};\n+\n+/* Subclass of rtx_reader for reading function dumps.  */\n+\n+class function_reader : public rtx_reader\n+{\n+ public:\n+  function_reader ();\n+  ~function_reader ();\n+\n+  /* Overridden vfuncs of class md_reader.  */\n+  void handle_unknown_directive (file_location, const char *) FINAL OVERRIDE;\n+\n+  /* Overridden vfuncs of class rtx_reader.  */\n+  rtx read_rtx_operand (rtx x, int idx) FINAL OVERRIDE;\n+  void handle_any_trailing_information (rtx x) FINAL OVERRIDE;\n+  rtx postprocess (rtx) FINAL OVERRIDE;\n+  const char *finalize_string (char *stringbuf) FINAL OVERRIDE;\n+\n+  rtx_insn **get_insn_by_uid (int uid);\n+  tree parse_mem_expr (const char *desc);\n+\n+ private:\n+  void parse_function ();\n+  void create_function ();\n+  void parse_param ();\n+  void parse_insn_chain ();\n+  void parse_block ();\n+  int parse_bb_idx ();\n+  void parse_edge (basic_block block, bool from);\n+  rtx_insn *parse_insn (file_location loc, const char *name);\n+  void parse_cfg (file_location loc);\n+  void parse_crtl (file_location loc);\n+  void create_edges ();\n+\n+  int parse_enum_value (int num_values, const char *const *strings);\n+\n+  void read_rtx_operand_u (rtx x, int idx);\n+  void read_rtx_operand_i_or_n (rtx x, int idx, char format_char);\n+  rtx read_rtx_operand_r (rtx x);\n+  void extra_parsing_for_operand_code_0 (rtx x, int idx);\n+\n+  void add_fixup_insn_uid (file_location loc, rtx insn, int operand_idx,\n+\t\t\t   int insn_uid);\n+\n+  void add_fixup_note_insn_basic_block (file_location loc, rtx insn,\n+\t\t\t\t\tint operand_idx, int bb_idx);\n+\n+  void add_fixup_source_location (file_location loc, rtx_insn *insn,\n+\t\t\t\t  const char *filename, int lineno);\n+\n+  void add_fixup_expr (file_location loc, rtx x,\n+\t\t       const char *desc);\n+\n+  rtx consolidate_singletons (rtx x);\n+  rtx parse_rtx ();\n+  void maybe_read_location (rtx_insn *insn);\n+\n+  void handle_insn_uids ();\n+  void apply_fixups ();\n+\n+ private:\n+  struct uid_hash : int_hash <int, -1, -2> {};\n+  hash_map<uid_hash, rtx_insn *> m_insns_by_uid;\n+  auto_vec<fixup *> m_fixups;\n+  rtx_insn *m_first_insn;\n+  auto_vec<tree> m_fake_scope;\n+  char *m_name;\n+  bool m_have_crtl_directive;\n+  basic_block m_bb_to_insert_after;\n+  auto_vec <deferred_edge> m_deferred_edges;\n+  int m_highest_bb_idx;\n+};\n+\n+/* Abstract base class for recording post-processing steps that must be\n+   done after reading a .rtl file.  */\n+\n+class fixup\n+{\n+ public:\n+  /* Constructor for a fixup at LOC affecting X.  */\n+  fixup (file_location loc, rtx x)\n+    : m_loc (loc), m_rtx (x)\n+  {}\n+  virtual ~fixup () {}\n+\n+  virtual void apply (function_reader *reader) const = 0;\n+\n+ protected:\n+  file_location m_loc;\n+  rtx m_rtx;\n+};\n+\n+/* An abstract subclass of fixup for post-processing steps that\n+   act on a specific operand of a specific instruction.  */\n+\n+class operand_fixup : public fixup\n+{\n+ public:\n+  /* Constructor for a fixup at LOC affecting INSN's operand\n+     with index OPERAND_IDX.  */\n+  operand_fixup (file_location loc, rtx insn, int operand_idx)\n+    : fixup (loc, insn), m_operand_idx (operand_idx)\n+  {}\n+\n+ protected:\n+  int m_operand_idx;\n+};\n+\n+/* A concrete subclass of operand_fixup: fixup an rtx_insn *\n+   field based on an integer UID.  */\n+\n+class fixup_insn_uid : public operand_fixup\n+{\n+ public:\n+  /* Constructor for a fixup at LOC affecting INSN's operand\n+     with index OPERAND_IDX.  Record INSN_UID as the uid.  */\n+  fixup_insn_uid (file_location loc, rtx insn, int operand_idx, int insn_uid)\n+    : operand_fixup (loc, insn, operand_idx),\n+      m_insn_uid (insn_uid)\n+  {}\n+\n+  void apply (function_reader *reader) const;\n+\n+ private:\n+  int m_insn_uid;\n+};\n+\n+/* A concrete subclass of operand_fixup: fix up a\n+   NOTE_INSN_BASIC_BLOCK based on an integer block ID.  */\n+\n+class fixup_note_insn_basic_block : public operand_fixup\n+{\n+ public:\n+  fixup_note_insn_basic_block (file_location loc, rtx insn, int operand_idx,\n+\t\t\t       int bb_idx)\n+    : operand_fixup (loc, insn, operand_idx),\n+      m_bb_idx (bb_idx)\n+  {}\n+\n+  void apply (function_reader *reader) const;\n+\n+ private:\n+  int m_bb_idx;\n+};\n+\n+/* A concrete subclass of fixup (not operand_fixup): fix up\n+   the expr of an rtx (REG or MEM) based on a textual dump.  */\n+\n+class fixup_expr : public fixup\n+{\n+ public:\n+  fixup_expr (file_location loc, rtx x, const char *desc)\n+    : fixup (loc, x),\n+      m_desc (xstrdup (desc))\n+  {}\n+\n+  ~fixup_expr () { free (m_desc); }\n+\n+  void apply (function_reader *reader) const;\n+\n+ private:\n+  char *m_desc;\n+};\n+\n+/* Return a textual description of the operand of INSN with\n+   index OPERAND_IDX.  */\n+\n+static const char *\n+get_operand_name (rtx insn, int operand_idx)\n+{\n+  gcc_assert (is_a <rtx_insn *> (insn));\n+  switch (operand_idx)\n+    {\n+    case 0:\n+      return \"PREV_INSN\";\n+    case 1:\n+      return \"NEXT_INSN\";\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+/* Fixup an rtx_insn * field based on an integer UID, as read by READER.  */\n+\n+void\n+fixup_insn_uid::apply (function_reader *reader) const\n+{\n+  rtx_insn **insn_from_uid = reader->get_insn_by_uid (m_insn_uid);\n+  if (insn_from_uid)\n+    XEXP (m_rtx, m_operand_idx) = *insn_from_uid;\n+  else\n+    {\n+      const char *op_name = get_operand_name (m_rtx, m_operand_idx);\n+      if (op_name)\n+\terror_at (m_loc,\n+\t\t  \"insn with UID %i not found for operand %i (`%s') of insn %i\",\n+\t\t  m_insn_uid, m_operand_idx, op_name, INSN_UID (m_rtx));\n+      else\n+\terror_at (m_loc,\n+\t\t  \"insn with UID %i not found for operand %i of insn %i\",\n+\t\t  m_insn_uid, m_operand_idx, INSN_UID (m_rtx));\n+    }\n+}\n+\n+/* Fix up a NOTE_INSN_BASIC_BLOCK based on an integer block ID.  */\n+\n+void\n+fixup_note_insn_basic_block::apply (function_reader *) const\n+{\n+  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, m_bb_idx);\n+  gcc_assert (bb);\n+  NOTE_BASIC_BLOCK (m_rtx) = bb;\n+}\n+\n+/* Fix up the expr of an rtx (REG or MEM) based on a textual dump\n+   read by READER.  */\n+\n+void\n+fixup_expr::apply (function_reader *reader) const\n+{\n+  tree expr = reader->parse_mem_expr (m_desc);\n+  switch (GET_CODE (m_rtx))\n+    {\n+    case REG:\n+      set_reg_attrs_for_decl_rtl (expr, m_rtx);\n+      break;\n+    case MEM:\n+      set_mem_expr (m_rtx, expr);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Strip trailing whitespace from DESC.  */\n+\n+static void\n+strip_trailing_whitespace (char *desc)\n+{\n+  char *terminator = desc + strlen (desc);\n+  while (desc < terminator)\n+    {\n+      terminator--;\n+      if (ISSPACE (*terminator))\n+\t*terminator = '\\0';\n+      else\n+\tbreak;\n+    }\n+}\n+\n+/* Return the numeric value n for GET_NOTE_INSN_NAME (n) for STRING,\n+   or fail if STRING isn't recognized.  */\n+\n+static int\n+parse_note_insn_name (const char *string)\n+{\n+  for (int i = 0; i < NOTE_INSN_MAX; i++)\n+    if (0 == strcmp (string, GET_NOTE_INSN_NAME (i)))\n+      return i;\n+  fatal_with_file_and_line (\"unrecognized NOTE_INSN name: `%s'\", string);\n+}\n+\n+/* Return the register number for NAME, or return -1 if it isn't\n+   recognized.  */\n+\n+static int\n+lookup_reg_by_dump_name (const char *name)\n+{\n+  for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (reg_names[i][0]\n+\t&& ! strcmp (name, reg_names[i]))\n+      return i;\n+\n+  /* Also lookup virtuals.  */\n+  if (!strcmp (name, \"virtual-incoming-args\"))\n+    return VIRTUAL_INCOMING_ARGS_REGNUM;\n+  if (!strcmp (name, \"virtual-stack-vars\"))\n+    return VIRTUAL_STACK_VARS_REGNUM;\n+  if (!strcmp (name, \"virtual-stack-dynamic\"))\n+    return VIRTUAL_STACK_DYNAMIC_REGNUM;\n+  if (!strcmp (name, \"virtual-outgoing-args\"))\n+    return VIRTUAL_OUTGOING_ARGS_REGNUM;\n+  if (!strcmp (name, \"virtual-cfa\"))\n+    return VIRTUAL_CFA_REGNUM;\n+  if (!strcmp (name, \"virtual-preferred-stack-boundary\"))\n+    return VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM;\n+  /* TODO: handle \"virtual-reg-%d\".  */\n+\n+  /* In compact mode, pseudos are printed with '< and '>' wrapping the regno,\n+     offseting it by (LAST_VIRTUAL_REGISTER + 1), so that the\n+     first non-virtual pseudo is dumped as \"<0>\".  */\n+  if (name[0] == '<' && name[strlen (name) - 1] == '>')\n+    {\n+      int dump_num = atoi (name + 1);\n+      return dump_num + LAST_VIRTUAL_REGISTER + 1;\n+    }\n+\n+  /* Not found.  */\n+  return -1;\n+}\n+\n+/* class function_reader : public rtx_reader */\n+\n+/* function_reader's constructor.  */\n+\n+function_reader::function_reader ()\n+: rtx_reader (true),\n+  m_first_insn (NULL),\n+  m_name (NULL),\n+  m_have_crtl_directive (false),\n+  m_bb_to_insert_after (NULL),\n+  m_highest_bb_idx (EXIT_BLOCK)\n+{\n+}\n+\n+/* function_reader's destructor.  */\n+\n+function_reader::~function_reader ()\n+{\n+  int i;\n+  fixup *f;\n+  FOR_EACH_VEC_ELT (m_fixups, i, f)\n+    delete f;\n+\n+  free (m_name);\n+}\n+\n+/* Implementation of rtx_reader::handle_unknown_directive,\n+   for parsing the remainder of a directive with name NAME\n+   seen at START_LOC.\n+\n+   Require a top-level \"function\" directive, as emitted by\n+   print_rtx_function, and parse it.  */\n+\n+void\n+function_reader::handle_unknown_directive (file_location start_loc,\n+\t\t\t\t\t   const char *name)\n+{\n+  if (strcmp (name, \"function\"))\n+    fatal_at (start_loc, \"expected 'function'\");\n+\n+  parse_function ();\n+}\n+\n+/* Parse the output of print_rtx_function (or hand-written data in the\n+   same format), having already parsed the \"(function\" heading, and\n+   finishing immediately before the final \")\".\n+\n+   The \"param\" and \"crtl\" clauses are optional.  */\n+\n+void\n+function_reader::parse_function ()\n+{\n+  m_name = xstrdup (read_string (0));\n+\n+  create_function ();\n+\n+  while (1)\n+    {\n+      int c = read_skip_spaces ();\n+      if (c == ')')\n+\t{\n+\t  unread_char (c);\n+\t  break;\n+\t}\n+      unread_char (c);\n+      require_char ('(');\n+      file_location loc = get_current_location ();\n+      struct md_name directive;\n+      read_name (&directive);\n+      if (strcmp (directive.string, \"param\") == 0)\n+\tparse_param ();\n+      else if (strcmp (directive.string, \"insn-chain\") == 0)\n+\tparse_insn_chain ();\n+      else if (strcmp (directive.string, \"crtl\") == 0)\n+\tparse_crtl (loc);\n+      else\n+\tfatal_with_file_and_line (\"unrecognized directive: %s\",\n+\t\t\t\t  directive.string);\n+    }\n+\n+  handle_insn_uids ();\n+\n+  apply_fixups ();\n+\n+  /* Rebuild the JUMP_LABEL field of any JUMP_INSNs in the chain, and the\n+     LABEL_NUSES of any CODE_LABELs.\n+\n+     This has to happen after apply_fixups, since only after then do\n+     LABEL_REFs have their label_ref_label set up.  */\n+  rebuild_jump_labels (get_insns ());\n+\n+  crtl->init_stack_alignment ();\n+}\n+\n+/* Set up state for the function *before* fixups are applied.\n+\n+   Create \"cfun\" and a decl for the function.\n+   By default, every function decl is hardcoded as\n+      int test_1 (int i, int j, int k);\n+   Set up various other state:\n+   - the cfg and basic blocks (edges are created later, *after* fixups\n+   are applied).\n+   - add the function to the callgraph.  */\n+\n+void\n+function_reader::create_function ()\n+{\n+  /* We start in cfgrtl mode, rather than cfglayout mode.  */\n+  rtl_register_cfg_hooks ();\n+\n+  /* Create cfun.  */\n+  tree fn_name = get_identifier (m_name ? m_name : \"test_1\");\n+  tree int_type = integer_type_node;\n+  tree return_type = int_type;\n+  tree arg_types[3] = {int_type, int_type, int_type};\n+  tree fn_type = build_function_type_array (return_type, 3, arg_types);\n+  tree fndecl = build_decl_stat (UNKNOWN_LOCATION, FUNCTION_DECL, fn_name,\n+\t\t\t\t fn_type);\n+  tree resdecl = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE,\n+\t\t\t     return_type);\n+  DECL_ARTIFICIAL (resdecl) = 1;\n+  DECL_IGNORED_P (resdecl) = 1;\n+  DECL_RESULT (fndecl) = resdecl;\n+  allocate_struct_function (fndecl, false);\n+  /* This sets cfun.  */\n+\n+  current_function_decl = fndecl;\n+\n+  cfun->curr_properties = (PROP_cfg | PROP_rtl);\n+\n+  /* Do we need this to force cgraphunit.c to output the function? */\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_PRESERVE_P (fndecl) = 1;\n+\n+  /* Add to cgraph.  */\n+  cgraph_node::finalize_function (fndecl, false);\n+\n+  /* Create bare-bones cfg.  This creates the entry and exit blocks.  */\n+  init_empty_tree_cfg_for_function (cfun);\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_RTL;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_RTL;\n+  init_rtl_bb_info (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  init_rtl_bb_info (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+  m_bb_to_insert_after = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+\n+}\n+\n+/* Look within the the params of FNDECL for a param named NAME.\n+   Return NULL_TREE if one isn't found.  */\n+\n+static tree\n+find_param_by_name (tree fndecl, const char *name)\n+{\n+  for (tree arg = DECL_ARGUMENTS (fndecl); arg; arg = TREE_CHAIN (arg))\n+    if (strcmp (name, IDENTIFIER_POINTER (DECL_NAME (arg))) == 0)\n+      return arg;\n+  return NULL_TREE;\n+}\n+\n+/* Parse the content of a \"param\" directive, having already parsed the\n+   \"(param\".  Consume the trailing ')'.  */\n+\n+void\n+function_reader::parse_param ()\n+{\n+  require_char_ws ('\"');\n+  file_location loc = get_current_location ();\n+  char *name = read_quoted_string ();\n+\n+  /* Lookup param by name.  */\n+  tree t_param = find_param_by_name (cfun->decl, name);\n+  if (!t_param)\n+    fatal_at (loc, \"param not found: %s\", name);\n+\n+  /* Parse DECL_RTL.  */\n+  require_char_ws ('(');\n+  require_word_ws (\"DECL_RTL\");\n+  DECL_WRTL_CHECK (t_param)->decl_with_rtl.rtl = parse_rtx ();\n+  require_char_ws (')');\n+\n+  /* Parse DECL_RTL_INCOMING.  */\n+  require_char_ws ('(');\n+  require_word_ws (\"DECL_RTL_INCOMING\");\n+  DECL_INCOMING_RTL (t_param) = parse_rtx ();\n+  require_char_ws (')');\n+\n+  require_char_ws (')');\n+}\n+\n+/* Parse zero or more child insn elements within an\n+   \"insn-chain\" element.  Consume the trailing ')'.  */\n+\n+void\n+function_reader::parse_insn_chain ()\n+{\n+  while (1)\n+    {\n+      int c = read_skip_spaces ();\n+      file_location loc = get_current_location ();\n+      if (c == ')')\n+\tbreak;\n+      else if (c == '(')\n+\t{\n+\t  struct md_name directive;\n+\t  read_name (&directive);\n+\t  if (strcmp (directive.string, \"block\") == 0)\n+\t    parse_block ();\n+\t  else\n+\t    parse_insn (loc, directive.string);\n+\t}\n+      else\n+\tfatal_at (loc, \"expected '(' or ')'\");\n+    }\n+\n+  create_edges ();\n+}\n+\n+/* Parse zero or more child directives (edges and insns) within a\n+   \"block\" directive, having already parsed the \"(block \" heading.\n+   Consume the trailing ')'.  */\n+\n+void\n+function_reader::parse_block ()\n+{\n+  /* Parse the index value from the dump.  This will be an integer;\n+     we don't support \"entry\" or \"exit\" here (unlike for edges).  */\n+  struct md_name name;\n+  read_name (&name);\n+  int bb_idx = atoi (name.string);\n+\n+  /* The term \"index\" has two meanings for basic blocks in a CFG:\n+     (a) the \"index\" field within struct basic_block_def.\n+     (b) the index of a basic_block within the cfg's x_basic_block_info\n+     vector, as accessed via BASIC_BLOCK_FOR_FN.\n+\n+     These can get out-of-sync when basic blocks are optimized away.\n+     They get back in sync by \"compact_blocks\".\n+     We reconstruct cfun->cfg->x_basic_block_info->m_vecdata with NULL\n+     values in it for any missing basic blocks, so that (a) == (b) for\n+     all of the blocks we create.  The doubly-linked list of basic\n+     blocks (next_bb/prev_bb) skips over these \"holes\".  */\n+\n+  if (m_highest_bb_idx < bb_idx)\n+    m_highest_bb_idx = bb_idx;\n+\n+  size_t new_size = m_highest_bb_idx + 1;\n+  if (basic_block_info_for_fn (cfun)->length () < new_size)\n+    vec_safe_grow_cleared (basic_block_info_for_fn (cfun), new_size);\n+\n+  last_basic_block_for_fn (cfun) = new_size;\n+\n+  /* Create the basic block.\n+\n+     We can't call create_basic_block and use the regular RTL block-creation\n+     hooks, since this creates NOTE_INSN_BASIC_BLOCK instances.  We don't\n+     want to do that; we want to use the notes we were provided with.  */\n+  basic_block bb = alloc_block ();\n+  init_rtl_bb_info (bb);\n+  bb->index = bb_idx;\n+  bb->flags = BB_NEW | BB_RTL;\n+  link_block (bb, m_bb_to_insert_after);\n+  m_bb_to_insert_after = bb;\n+\n+  n_basic_blocks_for_fn (cfun)++;\n+  SET_BASIC_BLOCK_FOR_FN (cfun, bb_idx, bb);\n+  BB_SET_PARTITION (bb, BB_UNPARTITIONED);\n+\n+  /* Handle insns, edge-from and edge-to directives.  */\n+  while (1)\n+    {\n+      int c = read_skip_spaces ();\n+      file_location loc = get_current_location ();\n+      if (c == ')')\n+\tbreak;\n+      else if (c == '(')\n+\t{\n+\t  struct md_name directive;\n+\t  read_name (&directive);\n+\t  if (strcmp (directive.string, \"edge-from\") == 0)\n+\t    parse_edge (bb, true);\n+\t  else if (strcmp (directive.string, \"edge-to\") == 0)\n+\t    parse_edge (bb, false);\n+\t  else\n+\t    {\n+\t      rtx_insn *insn = parse_insn (loc, directive.string);\n+\t      set_block_for_insn (insn, bb);\n+\t      if (!BB_HEAD (bb))\n+\t\tBB_HEAD (bb) = insn;\n+\t      BB_END (bb) = insn;\n+\t    }\n+\t}\n+      else\n+\tfatal_at (loc, \"expected '(' or ')'\");\n+    }\n+}\n+\n+/* Subroutine of function_reader::parse_edge.\n+   Parse a basic block index, handling \"entry\" and \"exit\".  */\n+\n+int\n+function_reader::parse_bb_idx ()\n+{\n+  struct md_name name;\n+  read_name (&name);\n+  if (strcmp (name.string, \"entry\") == 0)\n+    return ENTRY_BLOCK;\n+  if (strcmp (name.string, \"exit\") == 0)\n+    return EXIT_BLOCK;\n+  return atoi (name.string);\n+}\n+\n+/* Subroutine of parse_edge_flags.\n+   Parse TOK, a token such as \"FALLTHRU\", converting to the flag value.\n+   Issue an error if the token is unrecognized.  */\n+\n+static int\n+parse_edge_flag_token (const char *tok)\n+{\n+#define DEF_EDGE_FLAG(NAME,IDX)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (strcmp (tok, #NAME) == 0)\t\t\\\n+      return EDGE_##NAME; \\\n+  } while (0);\n+#include \"cfg-flags.def\"\n+#undef DEF_EDGE_FLAG\n+  error (\"unrecognized edge flag: '%s'\", tok);\n+  return 0;\n+}\n+\n+/* Subroutine of function_reader::parse_edge.\n+   Parse STR and convert to a flag value (or issue an error).\n+   The parser uses strtok and hence modifiers STR in-place.  */\n+\n+static int\n+parse_edge_flags (char *str)\n+{\n+  int result = 0;\n+\n+  char *tok = strtok (str, \"| \");\n+  while (tok)\n+    {\n+      result |= parse_edge_flag_token (tok);\n+      tok = strtok (NULL, \"| \");\n+    }\n+\n+  return result;\n+}\n+\n+/* Parse an \"edge-from\" or \"edge-to\" directive within the \"block\"\n+   directive for BLOCK, having already parsed the \"(edge\" heading.\n+   Consume the final \")\".  Record the edge within m_deferred_edges.\n+   FROM is true for an \"edge-from\" directive, false for an \"edge-to\"\n+   directive.  */\n+\n+void\n+function_reader::parse_edge (basic_block block, bool from)\n+{\n+  gcc_assert (block);\n+  int this_bb_idx = block->index;\n+  file_location loc = get_current_location ();\n+  int other_bb_idx = parse_bb_idx ();\n+\n+  /* \"(edge-from 2)\" means src = 2, dest = this_bb_idx, whereas\n+     \"(edge-to 3)\" means src = this_bb_idx, dest = 3.  */\n+  int src_idx = from ? other_bb_idx : this_bb_idx;\n+  int dest_idx = from ? this_bb_idx : other_bb_idx;\n+\n+  /* Optional \"(flags)\".  */\n+  int flags = 0;\n+  int c = read_skip_spaces ();\n+  if (c == '(')\n+    {\n+      require_word_ws (\"flags\");\n+      require_char_ws ('\"');\n+      char *str = read_quoted_string ();\n+      flags = parse_edge_flags (str);\n+      require_char_ws (')');\n+    }\n+  else\n+    unread_char (c);\n+\n+  require_char_ws (')');\n+\n+  /* This BB already exists, but the other BB might not yet.\n+     For now, save the edges, and create them at the end of insn-chain\n+     processing. */\n+  /* For now, only process the (edge-from) to this BB, and (edge-to)\n+     that go to the exit block.\n+     FIXME: we don't yet verify that the edge-from and edge-to directives\n+     are consistent.  */\n+  if (from || dest_idx == EXIT_BLOCK)\n+    m_deferred_edges.safe_push (deferred_edge (loc, src_idx, dest_idx, flags));\n+}\n+\n+/* Parse an rtx instruction, having parsed the opening and parenthesis, and\n+   name NAME, seen at START_LOC, by calling read_rtx_code, calling\n+   set_first_insn and set_last_insn as appropriate, and\n+   adding the insn to the insn chain.\n+   Consume the trailing ')'.  */\n+\n+rtx_insn *\n+function_reader::parse_insn (file_location start_loc, const char *name)\n+{\n+  rtx x = read_rtx_code (name);\n+  if (!x)\n+    fatal_at (start_loc, \"expected insn type; got '%s'\", name);\n+  rtx_insn *insn = dyn_cast <rtx_insn *> (x);\n+  if (!insn)\n+    fatal_at (start_loc, \"expected insn type; got '%s'\", name);\n+\n+  /* Consume the trailing ')'.  */\n+  require_char_ws (')');\n+\n+  rtx_insn *last_insn = get_last_insn ();\n+\n+  /* Add \"insn\" to the insn chain.  */\n+  if (last_insn)\n+    {\n+      gcc_assert (NEXT_INSN (last_insn) == NULL);\n+      SET_NEXT_INSN (last_insn) = insn;\n+    }\n+  SET_PREV_INSN (insn) = last_insn;\n+\n+  /* Add it to the sequence.  */\n+  set_last_insn (insn);\n+  if (!m_first_insn)\n+    {\n+      m_first_insn = insn;\n+      set_first_insn (insn);\n+    }\n+\n+  if (rtx_code_label *label = dyn_cast <rtx_code_label *> (insn))\n+    maybe_set_max_label_num (label);\n+\n+  return insn;\n+}\n+\n+/* Postprocessing subroutine for parse_insn_chain: all the basic blocks\n+   should have been created by now; create the edges that were seen.  */\n+\n+void\n+function_reader::create_edges ()\n+{\n+  int i;\n+  deferred_edge *de;\n+  FOR_EACH_VEC_ELT (m_deferred_edges, i, de)\n+    {\n+      /* The BBs should already have been created by parse_block.  */\n+      basic_block src = BASIC_BLOCK_FOR_FN (cfun, de->m_src_bb_idx);\n+      if (!src)\n+\tfatal_at (de->m_loc, \"error: block index %i not found\",\n+\t\t  de->m_src_bb_idx);\n+      basic_block dst = BASIC_BLOCK_FOR_FN (cfun, de->m_dest_bb_idx);\n+      if (!dst)\n+\tfatal_at (de->m_loc, \"error: block with index %i not found\",\n+\t\t  de->m_dest_bb_idx);\n+      unchecked_make_edge (src, dst, de->m_flags);\n+    }\n+}\n+\n+/* Parse a \"crtl\" directive, having already parsed the \"(crtl\" heading\n+   at location LOC.\n+   Consume the final \")\".  */\n+\n+void\n+function_reader::parse_crtl (file_location loc)\n+{\n+  if (m_have_crtl_directive)\n+    error_at (loc, \"more than one 'crtl' directive\");\n+  m_have_crtl_directive = true;\n+\n+  /* return_rtx.  */\n+  require_char_ws ('(');\n+  require_word_ws (\"return_rtx\");\n+  crtl->return_rtx = parse_rtx ();\n+  require_char_ws (')');\n+\n+  require_char_ws (')');\n+}\n+\n+/* Parse operand IDX of X, returning X, or an equivalent rtx\n+   expression (for consolidating singletons).\n+   This is an overridden implementation of rtx_reader::read_rtx_operand for\n+   function_reader, handling various extra data printed by print_rtx,\n+   and sometimes calling the base class implementation.  */\n+\n+rtx\n+function_reader::read_rtx_operand (rtx x, int idx)\n+{\n+  RTX_CODE code = GET_CODE (x);\n+  const char *format_ptr = GET_RTX_FORMAT (code);\n+  const char format_char = format_ptr[idx];\n+  struct md_name name;\n+\n+  /* Override the regular parser for some format codes.  */\n+  switch (format_char)\n+    {\n+    case 'e':\n+      if (idx == 7 && CALL_P (x))\n+\t{\n+\t  m_in_call_function_usage = true;\n+\t  return rtx_reader::read_rtx_operand (x, idx);\n+\t  m_in_call_function_usage = false;\n+\t}\n+      else\n+\treturn rtx_reader::read_rtx_operand (x, idx);\n+      break;\n+\n+    case 'u':\n+      read_rtx_operand_u (x, idx);\n+      /* Don't run regular parser for 'u'.  */\n+      return x;\n+\n+    case 'i':\n+    case 'n':\n+      read_rtx_operand_i_or_n (x, idx, format_char);\n+      /* Don't run regular parser for these codes.  */\n+      return x;\n+\n+    case 'B':\n+      gcc_assert (is_compact ());\n+      /* Compact mode doesn't store BBs.  */\n+      /* Don't run regular parser.  */\n+      return x;\n+\n+    case 'r':\n+      /* Don't run regular parser for 'r'.  */\n+      return read_rtx_operand_r (x);\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Call base class implementation.  */\n+  x = rtx_reader::read_rtx_operand (x, idx);\n+\n+  /* Handle any additional parsing needed to handle what the dump\n+     could contain.  */\n+  switch (format_char)\n+    {\n+    case '0':\n+      extra_parsing_for_operand_code_0 (x, idx);\n+      break;\n+\n+    case 'w':\n+      if (!is_compact ())\n+\t{\n+\t  /* Strip away the redundant hex dump of the value.  */\n+\t  require_char_ws ('[');\n+\t  read_name (&name);\n+\t  require_char_ws (']');\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return x;\n+}\n+\n+/* Parse operand IDX of X, of code 'u', when reading function dumps.\n+\n+   The RTL file recorded the ID of an insn (or 0 for NULL); we\n+   must store this as a pointer, but the insn might not have\n+   been loaded yet.  Store the ID away for now, via a fixup.  */\n+\n+void\n+function_reader::read_rtx_operand_u (rtx x, int idx)\n+{\n+  /* In compact mode, the PREV/NEXT insn uids are not dumped, so skip\n+     the \"uu\" when reading. */\n+  if (is_compact () && GET_CODE (x) != LABEL_REF)\n+    return;\n+\n+  struct md_name name;\n+  file_location loc = read_name (&name);\n+  int insn_id = atoi (name.string);\n+  if (insn_id)\n+    add_fixup_insn_uid (loc, x, idx, insn_id);\n+}\n+\n+/* Read a name, looking for a match against a string found in array\n+   STRINGS of size NUM_VALUES.\n+   Return the index of the the matched string, or emit an error.  */\n+\n+int\n+function_reader::parse_enum_value (int num_values, const char *const *strings)\n+{\n+  struct md_name name;\n+  read_name (&name);\n+  for (int i = 0; i < num_values; i++)\n+    {\n+      if (strcmp (name.string, strings[i]) == 0)\n+\treturn i;\n+    }\n+  error (\"unrecognized enum value: '%s'\", name.string);\n+  return 0;\n+}\n+\n+/* Parse operand IDX of X, of code 'i' or 'n' (as specified by FORMAT_CHAR).\n+   Special-cased handling of these, for reading function dumps.  */\n+\n+void\n+function_reader::read_rtx_operand_i_or_n (rtx x, int idx,\n+\t\t\t\t\t  char format_char)\n+{\n+  /* Handle some of the extra information that print_rtx\n+     can write out for these cases.  */\n+  /* print_rtx only writes out operand 5 for notes\n+     for NOTE_KIND values NOTE_INSN_DELETED_LABEL\n+     and NOTE_INSN_DELETED_DEBUG_LABEL.  */\n+  if (idx == 5 && NOTE_P (x))\n+    return;\n+\n+  if (idx == 4 && INSN_P (x))\n+    {\n+      maybe_read_location (as_a <rtx_insn *> (x));\n+      return;\n+    }\n+\n+  /* INSN_CODEs aren't printed in compact mode, so don't attempt to\n+     parse them.  */\n+  if (is_compact ()\n+      && INSN_P (x)\n+      && &INSN_CODE (x) == &XINT (x, idx))\n+    {\n+      INSN_CODE (x) = -1;\n+      return;\n+    }\n+\n+  /* Handle UNSPEC and UNSPEC_VOLATILE's operand 1.  */\n+#if !defined(GENERATOR_FILE) && NUM_UNSPECV_VALUES > 0\n+  if (idx == 1\n+      && GET_CODE (x) == UNSPEC_VOLATILE)\n+    {\n+      XINT (x, 1)\n+\t= parse_enum_value (NUM_UNSPECV_VALUES, unspecv_strings);\n+      return;\n+    }\n+#endif\n+#if !defined(GENERATOR_FILE) && NUM_UNSPEC_VALUES > 0\n+  if (idx == 1\n+      && (GET_CODE (x) == UNSPEC\n+\t  || GET_CODE (x) == UNSPEC_VOLATILE))\n+    {\n+      XINT (x, 1)\n+\t= parse_enum_value (NUM_UNSPEC_VALUES, unspec_strings);\n+      return;\n+    }\n+#endif\n+\n+  struct md_name name;\n+  read_name (&name);\n+  int value;\n+  if (format_char == 'n')\n+    value = parse_note_insn_name (name.string);\n+  else\n+    value = atoi (name.string);\n+  XINT (x, idx) = value;\n+}\n+\n+/* Parse the 'r' operand of X, returning X, or an equivalent rtx\n+   expression (for consolidating singletons).\n+   Special-cased handling of code 'r' for reading function dumps.  */\n+\n+rtx\n+function_reader::read_rtx_operand_r (rtx x)\n+{\n+  struct md_name name;\n+  file_location loc = read_name (&name);\n+  int regno = lookup_reg_by_dump_name (name.string);\n+  if (regno == -1)\n+    fatal_at (loc, \"unrecognized register: '%s'\", name.string);\n+\n+  set_regno_raw (x, regno, 1);\n+\n+  /* Consolidate singletons.  */\n+  x = consolidate_singletons (x);\n+\n+  ORIGINAL_REGNO (x) = regno;\n+\n+  /* Parse extra stuff at end of 'r'.\n+     We may have zero, one, or two sections marked by square\n+     brackets.  */\n+  int ch = read_skip_spaces ();\n+  bool expect_original_regno = false;\n+  if (ch == '[')\n+    {\n+      file_location loc = get_current_location ();\n+      char *desc = read_until (\"]\", true);\n+      strip_trailing_whitespace (desc);\n+      const char *desc_start = desc;\n+      /* If ORIGINAL_REGNO (rtx) != regno, we will have:\n+\t \"orig:%i\", ORIGINAL_REGNO (rtx).\n+\t Consume it, we don't set ORIGINAL_REGNO, since we can\n+\t get that from the 2nd copy later.  */\n+      if (0 == strncmp (desc, \"orig:\", 5))\n+\t{\n+\t  expect_original_regno = true;\n+\t  desc_start += 5;\n+\t  /* Skip to any whitespace following the integer.  */\n+\t  const char *space = strchr (desc_start, ' ');\n+\t  if (space)\n+\t    desc_start = space + 1;\n+\t}\n+      /* Any remaining text may be the REG_EXPR.  Alternatively we have\n+\t no REG_ATTRS, and instead we have ORIGINAL_REGNO.  */\n+      if (ISDIGIT (*desc_start))\n+\t{\n+\t  /* Assume we have ORIGINAL_REGNO.  */\n+\t  ORIGINAL_REGNO (x) = atoi (desc_start);\n+\t}\n+      else\n+\t{\n+\t  /* Assume we have REG_EXPR.  */\n+\t  add_fixup_expr (loc, x, desc_start);\n+\t}\n+      free (desc);\n+    }\n+  else\n+    unread_char (ch);\n+  if (expect_original_regno)\n+    {\n+      require_char_ws ('[');\n+      char *desc = read_until (\"]\", true);\n+      ORIGINAL_REGNO (x) = atoi (desc);\n+      free (desc);\n+    }\n+\n+  return x;\n+}\n+\n+/* Additional parsing for format code '0' in dumps, handling a variety\n+   of special-cases in print_rtx, when parsing operand IDX of X.  */\n+\n+void\n+function_reader::extra_parsing_for_operand_code_0 (rtx x, int idx)\n+{\n+  RTX_CODE code = GET_CODE (x);\n+  int c;\n+  struct md_name name;\n+\n+  if (idx == 1 && code == SYMBOL_REF)\n+    {\n+      /* Possibly wrote \" [flags %#x]\", SYMBOL_REF_FLAGS (in_rtx).  */\n+      c = read_skip_spaces ();\n+      if (c == '[')\n+\t{\n+\t  file_location loc = read_name (&name);\n+\t  if (strcmp (name.string, \"flags\"))\n+\t    error_at (loc, \"was expecting `%s'\", \"flags\");\n+\t  read_name (&name);\n+\t  SYMBOL_REF_FLAGS (x) = strtol (name.string, NULL, 16);\n+\n+\t  /* We can't reconstruct SYMBOL_REF_BLOCK; set it to NULL.  */\n+\t  if (SYMBOL_REF_HAS_BLOCK_INFO_P (x))\n+\t    SYMBOL_REF_BLOCK (x) = NULL;\n+\n+\t  require_char (']');\n+\t}\n+      else\n+\tunread_char (c);\n+\n+      /* If X had a non-NULL SYMBOL_REF_DECL,\n+\t rtx_writer::print_rtx_operand_code_0 would have dumped it\n+\t using print_node_brief.\n+\t Skip the content for now.  */\n+      c = read_skip_spaces ();\n+      if (c == '<')\n+\t{\n+\t  while (1)\n+\t    {\n+\t      char ch = read_char ();\n+\t      if (ch == '>')\n+\t\tbreak;\n+\t    }\n+\t}\n+      else\n+\tunread_char (c);\n+    }\n+  else if (idx == 3 && code == NOTE)\n+    {\n+      /* Note-specific data appears for operand 3, which annoyingly\n+\t is before the enum specifying which kind of note we have\n+\t (operand 4).  */\n+      c = read_skip_spaces ();\n+      if (c == '[')\n+\t{\n+\t  /* Possibly data for a NOTE_INSN_BASIC_BLOCK, of the form:\n+\t     [bb %d].  */\n+\t  file_location bb_loc = read_name (&name);\n+\t  if (strcmp (name.string, \"bb\"))\n+\t    error_at (bb_loc, \"was expecting `%s'\", \"bb\");\n+\t  read_name (&name);\n+\t  int bb_idx = atoi (name.string);\n+\t  add_fixup_note_insn_basic_block (bb_loc, x, idx,\n+\t\t\t\t\t   bb_idx);\n+\t  require_char_ws (']');\n+\t}\n+      else\n+\tunread_char (c);\n+    }\n+}\n+\n+/* Implementation of rtx_reader::handle_any_trailing_information.\n+   Handle the various additional information that print-rtl.c can\n+   write after the regular fields, when parsing X.  */\n+\n+void\n+function_reader::handle_any_trailing_information (rtx x)\n+{\n+  struct md_name name;\n+\n+  switch (GET_CODE (x))\n+    {\n+      case MEM:\n+\t{\n+\t  int ch;\n+\t  require_char_ws ('[');\n+\t  read_name (&name);\n+\t  set_mem_alias_set (x, atoi (name.string));\n+\t  /* We have either a MEM_EXPR, or a space.  */\n+\t  if (peek_char () != ' ')\n+\t    {\n+\t      file_location loc = get_current_location ();\n+\t      char *desc = read_until (\" +\", false);\n+\t      add_fixup_expr (loc, consolidate_singletons (x), desc);\n+\t      free (desc);\n+\t    }\n+\t  else\n+\t    read_char ();\n+\n+\t  /* We may optionally have '+' for MEM_OFFSET_KNOWN_P.  */\n+\t  ch = read_skip_spaces ();\n+\t  if (ch == '+')\n+\t    {\n+\t      read_name (&name);\n+\t      set_mem_offset (x, atoi (name.string));\n+\t    }\n+\t  else\n+\t    unread_char (ch);\n+\n+\t  /* Handle optional \" S\" for MEM_SIZE.  */\n+\t  ch = read_skip_spaces ();\n+\t  if (ch == 'S')\n+\t    {\n+\t      read_name (&name);\n+\t      set_mem_size (x, atoi (name.string));\n+\t    }\n+\t  else\n+\t    unread_char (ch);\n+\n+\t  /* Handle optional \" A\" for MEM_ALIGN.  */\n+\t  ch = read_skip_spaces ();\n+\t  if (ch == 'A' && peek_char () != 'S')\n+\t    {\n+\t      read_name (&name);\n+\t      set_mem_align (x, atoi (name.string));\n+\t    }\n+\t  else\n+\t    unread_char (ch);\n+\n+\t  /* Handle optional \" AS\" for MEM_ADDR_SPACE.  */\n+\t  ch = read_skip_spaces ();\n+\t  if (ch == 'A' && peek_char () == 'S')\n+\t    {\n+\t      read_char ();\n+\t      read_name (&name);\n+\t      set_mem_addr_space (x, atoi (name.string));\n+\t    }\n+\t  else\n+\t    unread_char (ch);\n+\n+\t  require_char (']');\n+\t}\n+\tbreak;\n+\n+      case CODE_LABEL:\n+\t/* Assume that LABEL_NUSES was not dumped.  */\n+\t/* TODO: parse LABEL_KIND.  */\n+\t/* For now, skip until closing ')'.  */\n+\tdo\n+\t  {\n+\t    char ch = read_char ();\n+\t    if (ch == ')')\n+\t      {\n+\t\tunread_char (ch);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\twhile (1);\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+    }\n+}\n+\n+/* Parse a tree dump for a MEM_EXPR in DESC and turn it back into a tree.\n+   We handle \"<retval>\" and param names within cfun, but for anything else\n+   we \"cheat\" by building a global VAR_DECL of type \"int\" with that name\n+   (returning the same global for a name if we see the same name more\n+   than once).  */\n+\n+tree\n+function_reader::parse_mem_expr (const char *desc)\n+{\n+  tree fndecl = cfun->decl;\n+\n+  if (0 == strcmp (desc, \"<retval>\"))\n+    return DECL_RESULT (fndecl);\n+\n+  tree param = find_param_by_name (fndecl, desc);\n+  if (param)\n+    return param;\n+\n+  /* Search within decls we already created.\n+     FIXME: use a hash rather than linear search.  */\n+  int i;\n+  tree t;\n+  FOR_EACH_VEC_ELT (m_fake_scope, i, t)\n+    if (strcmp (desc, IDENTIFIER_POINTER (DECL_NAME (t))) == 0)\n+      return t;\n+\n+  /* Not found?  Create it.\n+     This allows mimicking of real data but avoids having to specify\n+     e.g. names of locals, params etc.\n+     Though this way we don't know if we have a PARM_DECL vs a VAR_DECL,\n+     and we don't know the types.  Fake it by making everything be\n+     a VAR_DECL of \"int\" type.  */\n+  t = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t  get_identifier (desc),\n+\t\t  integer_type_node);\n+  m_fake_scope.safe_push (t);\n+  return t;\n+}\n+\n+/* Record that at LOC we saw an insn uid INSN_UID for the operand with index\n+   OPERAND_IDX within INSN, so that the pointer value can be fixed up in\n+   later post-processing.  */\n+\n+void\n+function_reader::add_fixup_insn_uid (file_location loc, rtx insn, int operand_idx,\n+\t\t\t\t     int insn_uid)\n+{\n+  m_fixups.safe_push (new fixup_insn_uid (loc, insn, operand_idx, insn_uid));\n+}\n+\n+/* Record that at LOC we saw an basic block index BB_IDX for the operand with index\n+   OPERAND_IDX within INSN, so that the pointer value can be fixed up in\n+   later post-processing.  */\n+\n+void\n+function_reader::add_fixup_note_insn_basic_block (file_location loc, rtx insn,\n+\t\t\t\t\t\t  int operand_idx, int bb_idx)\n+{\n+  m_fixups.safe_push (new fixup_note_insn_basic_block (loc, insn, operand_idx,\n+\t\t\t\t\t\t       bb_idx));\n+}\n+\n+/* Placeholder hook for recording source location information seen in a dump.\n+   This is empty for now.  */\n+\n+void\n+function_reader::add_fixup_source_location (file_location, rtx_insn *,\n+\t\t\t\t\t    const char *, int)\n+{\n+}\n+\n+/* Record that at LOC we saw textual description DESC of the MEM_EXPR or REG_EXPR\n+   of INSN, so that the fields can be fixed up in later post-processing.  */\n+\n+void\n+function_reader::add_fixup_expr (file_location loc, rtx insn,\n+\t\t\t\t const char *desc)\n+{\n+  gcc_assert (desc);\n+  /* Fail early if the RTL reader erroneously hands us an int.  */\n+  gcc_assert (!ISDIGIT (desc[0]));\n+\n+  m_fixups.safe_push (new fixup_expr (loc, insn, desc));\n+}\n+\n+/* Helper function for consolidate_reg.  Return the global rtx for\n+   the register with regno REGNO.  */\n+\n+static rtx\n+lookup_global_register (int regno)\n+{\n+  /* We can't use a switch here, as some of the REGNUMs might not be constants\n+     for some targets.  */\n+  if (regno == STACK_POINTER_REGNUM)\n+      return stack_pointer_rtx;\n+  else if (regno ==  FRAME_POINTER_REGNUM)\n+    return frame_pointer_rtx;\n+  else if (regno == HARD_FRAME_POINTER_REGNUM)\n+    return hard_frame_pointer_rtx;\n+  else if (regno == ARG_POINTER_REGNUM)\n+    return arg_pointer_rtx;\n+  else if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n+    return virtual_incoming_args_rtx;\n+  else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n+    return virtual_stack_vars_rtx;\n+  else if (regno == VIRTUAL_STACK_DYNAMIC_REGNUM)\n+    return virtual_stack_dynamic_rtx;\n+  else if (regno == VIRTUAL_OUTGOING_ARGS_REGNUM)\n+    return virtual_outgoing_args_rtx;\n+  else if (regno == VIRTUAL_CFA_REGNUM)\n+    return virtual_cfa_rtx;\n+  else if (regno == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n+    return virtual_preferred_stack_boundary_rtx;\n+#ifdef return_ADDRESS_POINTER_REGNUM\n+  else if (regno == RETURN_ADDRESS_POINTER_REGNUM)\n+    return return_address_pointer_rtx;\n+#endif\n+\n+  return NULL;\n+}\n+\n+/* Ensure that the backend can cope with a REG with regno REGNO.\n+   Normally REG instances are created by gen_reg_rtx which updates\n+   regno_reg_rtx, growing it as necessary.\n+   The REG instances created from the dumpfile weren't created this\n+   way, so we need to manually update regno_reg_rtx.  */\n+\n+static void\n+ensure_regno (int regno)\n+{\n+  if (reg_rtx_no < regno + 1)\n+    reg_rtx_no = regno + 1;\n+\n+  crtl->emit.ensure_regno_capacity ();\n+  gcc_assert (regno < crtl->emit.regno_pointer_align_length);\n+}\n+\n+/* Helper function for consolidate_singletons, for handling REG instances.\n+   Given REG instance X of some regno, return the singleton rtx for that\n+   regno, if it exists, or X.  */\n+\n+static rtx\n+consolidate_reg (rtx x)\n+{\n+  gcc_assert (GET_CODE (x) == REG);\n+\n+  unsigned int regno = REGNO (x);\n+\n+  ensure_regno (regno);\n+\n+  /* Some register numbers have their rtx created in init_emit_regs\n+     e.g. stack_pointer_rtx for STACK_POINTER_REGNUM.\n+     Consolidate on this.  */\n+  rtx global_reg = lookup_global_register (regno);\n+  if (global_reg)\n+    return global_reg;\n+\n+  /* Populate regno_reg_rtx if necessary.  */\n+  if (regno_reg_rtx[regno] == NULL)\n+    regno_reg_rtx[regno] = x;\n+  /* Use it.  */\n+  gcc_assert (GET_CODE (regno_reg_rtx[regno]) == REG);\n+  gcc_assert (REGNO (regno_reg_rtx[regno]) == regno);\n+  if (GET_MODE (x) == GET_MODE (regno_reg_rtx[regno]))\n+    return regno_reg_rtx[regno];\n+\n+  return x;\n+}\n+\n+/* When reading RTL function dumps, we must consolidate some\n+   rtx so that we use singletons where singletons are expected\n+   (e.g. we don't want multiple \"(const_int 0 [0])\" rtx, since\n+   these are tested via pointer equality against const0_rtx.\n+\n+   Return the equivalent singleton rtx for X, if any, otherwise X.  */\n+\n+rtx\n+function_reader::consolidate_singletons (rtx x)\n+{\n+  if (!x)\n+    return x;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PC: return pc_rtx;\n+    case RETURN: return ret_rtx;\n+    case SIMPLE_RETURN: return simple_return_rtx;\n+    case CC0: return cc0_rtx;\n+\n+    case REG:\n+      return consolidate_reg (x);\n+\n+    case CONST_INT:\n+      return gen_rtx_CONST_INT (GET_MODE (x), INTVAL (x));\n+\n+    default:\n+      break;\n+    }\n+\n+  return x;\n+}\n+\n+/* Parse an rtx directive, including both the opening/closing parentheses,\n+   and the name.  */\n+\n+rtx\n+function_reader::parse_rtx ()\n+{\n+  require_char_ws ('(');\n+  struct md_name directive;\n+  read_name (&directive);\n+  rtx result\n+    = consolidate_singletons (read_rtx_code (directive.string));\n+  require_char_ws (')');\n+\n+  return result;\n+}\n+\n+/* Implementation of rtx_reader::postprocess for reading function dumps.\n+   Return the equivalent singleton rtx for X, if any, otherwise X.  */\n+\n+rtx\n+function_reader::postprocess (rtx x)\n+{\n+  return consolidate_singletons (x);\n+}\n+\n+/* Implementation of rtx_reader::finalize_string for reading function dumps.\n+   Make a GC-managed copy of STRINGBUF.  */\n+\n+const char *\n+function_reader::finalize_string (char *stringbuf)\n+{\n+  return ggc_strdup (stringbuf);\n+}\n+\n+/* Attempt to parse optional location information for insn INSN, as\n+   potentially written out by rtx_writer::print_rtx_operand_code_i.\n+   We look for a quoted string followed by a colon.  */\n+\n+void\n+function_reader::maybe_read_location (rtx_insn *insn)\n+{\n+  file_location loc = get_current_location ();\n+\n+  /* Attempt to parse a quoted string.  */\n+  int ch = read_skip_spaces ();\n+  if (ch == '\"')\n+    {\n+      char *filename = read_quoted_string ();\n+      require_char (':');\n+      struct md_name line_num;\n+      read_name (&line_num);\n+      add_fixup_source_location (loc, insn, filename, atoi (line_num.string));\n+    }\n+  else\n+    unread_char (ch);\n+}\n+\n+/* Postprocessing subroutine of function_reader::parse_function.\n+   Populate m_insns_by_uid.  */\n+\n+void\n+function_reader::handle_insn_uids ()\n+{\n+  /* Locate the currently assigned INSN_UID values, storing\n+     them in m_insns_by_uid.  */\n+  int max_uid = 0;\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (m_insns_by_uid.get (INSN_UID (insn)))\n+\terror (\"duplicate insn UID: %i\", INSN_UID (insn));\n+      m_insns_by_uid.put (INSN_UID (insn), insn);\n+      if (INSN_UID (insn) > max_uid)\n+\tmax_uid = INSN_UID (insn);\n+    }\n+\n+  /* Ensure x_cur_insn_uid is 1 more than the biggest insn UID seen.\n+     This is normally updated by the various make_*insn_raw functions.  */\n+  crtl->emit.x_cur_insn_uid = max_uid + 1;\n+}\n+\n+/* Apply all of the recorded fixups.  */\n+\n+void\n+function_reader::apply_fixups ()\n+{\n+  int i;\n+  fixup *f;\n+  FOR_EACH_VEC_ELT (m_fixups, i, f)\n+    f->apply (this);\n+}\n+\n+/* Given a UID value, try to locate a pointer to the corresponding\n+   rtx_insn *, or NULL if if can't be found.  */\n+\n+rtx_insn **\n+function_reader::get_insn_by_uid (int uid)\n+{\n+  return m_insns_by_uid.get (uid);\n+}\n+\n+/* Run the RTL dump parser, parsing a dump located at PATH.\n+   Return true iff the file was successfully parsed.  */\n+\n+bool\n+read_rtl_function_body (const char *path)\n+{\n+  initialize_rtl ();\n+  init_emit ();\n+  init_varasm_status ();\n+\n+  function_reader reader;\n+  if (!reader.read_file (path))\n+    return false;\n+\n+  return true;\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that parse_edge_flags works.  */\n+\n+static void\n+test_edge_flags ()\n+{\n+  /* parse_edge_flags modifies its input (due to strtok), so we must make\n+     a copy of the literals.  */\n+#define ASSERT_PARSE_EDGE_FLAGS(EXPECTED, STR) \\\n+  do { \\\n+    char *str = xstrdup (STR); \\\n+    ASSERT_EQ (EXPECTED, parse_edge_flags (str)); \\\n+    free (str); \\\n+  } while (0)\n+\n+  ASSERT_PARSE_EDGE_FLAGS (0, \"\");\n+  ASSERT_PARSE_EDGE_FLAGS (EDGE_FALLTHRU, \"FALLTHRU\");\n+  ASSERT_PARSE_EDGE_FLAGS (EDGE_ABNORMAL_CALL, \"ABNORMAL_CALL\");\n+  ASSERT_PARSE_EDGE_FLAGS (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL,\n+\t\t\t   \"ABNORMAL | ABNORMAL_CALL\");\n+\n+#undef  ASSERT_PARSE_EDGE_FLAGS\n+}\n+\n+/* Verify that lookup_reg_by_dump_name works.  */\n+\n+static void\n+test_parsing_regnos ()\n+{\n+  ASSERT_EQ (-1, lookup_reg_by_dump_name (\"this is not a register\"));\n+\n+  /* Verify lookup of virtual registers.  */\n+  ASSERT_EQ (VIRTUAL_INCOMING_ARGS_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-incoming-args\"));\n+  ASSERT_EQ (VIRTUAL_STACK_VARS_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-stack-vars\"));\n+  ASSERT_EQ (VIRTUAL_STACK_DYNAMIC_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-stack-dynamic\"));\n+  ASSERT_EQ (VIRTUAL_OUTGOING_ARGS_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-outgoing-args\"));\n+  ASSERT_EQ (VIRTUAL_CFA_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-cfa\"));\n+  ASSERT_EQ (VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM,\n+    lookup_reg_by_dump_name (\"virtual-preferred-stack-boundary\"));\n+\n+  /* Verify lookup of non-virtual pseudos.  */\n+  ASSERT_EQ (LAST_VIRTUAL_REGISTER + 1, lookup_reg_by_dump_name (\"<0>\"));\n+  ASSERT_EQ (LAST_VIRTUAL_REGISTER + 2, lookup_reg_by_dump_name (\"<1>\"));\n+}\n+\n+/* Verify that edge E is as expected, with the src and dest basic blocks\n+   having indices EXPECTED_SRC_IDX and EXPECTED_DEST_IDX respectively, and\n+   the edge having flags equal to EXPECTED_FLAGS.\n+   Use LOC as the effective location when reporting failures.  */\n+\n+static void\n+assert_edge_at (const location &loc, edge e, int expected_src_idx,\n+\t\tint expected_dest_idx, int expected_flags)\n+{\n+  ASSERT_EQ_AT (loc, expected_src_idx, e->src->index);\n+  ASSERT_EQ_AT (loc, expected_dest_idx, e->dest->index);\n+  ASSERT_EQ_AT (loc, expected_flags, e->flags);\n+}\n+\n+/* Verify that edge EDGE is as expected, with the src and dest basic blocks\n+   having indices EXPECTED_SRC_IDX and EXPECTED_DEST_IDX respectively, and\n+   the edge having flags equal to EXPECTED_FLAGS.  */\n+\n+#define ASSERT_EDGE(EDGE, EXPECTED_SRC_IDX, EXPECTED_DEST_IDX,\t\t\\\n+\t\t    EXPECTED_FLAGS)\t\t\t\t\t\\\n+  assert_edge_at (SELFTEST_LOCATION, EDGE, EXPECTED_SRC_IDX, \\\n+\t\t  EXPECTED_DEST_IDX, EXPECTED_FLAGS)\n+\n+/* Verify that we can load RTL dumps.  */\n+\n+static void\n+test_loading_dump_fragment_1 ()\n+{\n+  // TODO: filter on target?\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"asr_div1.rtl\"));\n+\n+  /* Verify that the insns were loaded correctly.  */\n+  rtx_insn *insn_1 = get_insns ();\n+  ASSERT_TRUE (insn_1);\n+  ASSERT_EQ (1, INSN_UID (insn_1));\n+  ASSERT_EQ (INSN, GET_CODE (insn_1));\n+  ASSERT_EQ (SET, GET_CODE (PATTERN (insn_1)));\n+  ASSERT_EQ (NULL, PREV_INSN (insn_1));\n+\n+  rtx_insn *insn_2 = NEXT_INSN (insn_1);\n+  ASSERT_TRUE (insn_2);\n+  ASSERT_EQ (2, INSN_UID (insn_2));\n+  ASSERT_EQ (INSN, GET_CODE (insn_2));\n+  ASSERT_EQ (insn_1, PREV_INSN (insn_2));\n+  ASSERT_EQ (NULL, NEXT_INSN (insn_2));\n+\n+  /* Verify that registers were loaded correctly.  */\n+  rtx insn_1_dest = SET_DEST (PATTERN (insn_1));\n+  ASSERT_EQ (REG, GET_CODE (insn_1_dest));\n+  ASSERT_EQ ((LAST_VIRTUAL_REGISTER + 1) + 2, REGNO (insn_1_dest));\n+  rtx insn_1_src = SET_SRC (PATTERN (insn_1));\n+  ASSERT_EQ (LSHIFTRT, GET_CODE (insn_1_src));\n+  rtx reg = XEXP (insn_1_src, 0);\n+  ASSERT_EQ (REG, GET_CODE (reg));\n+  ASSERT_EQ (LAST_VIRTUAL_REGISTER + 1, REGNO (reg));\n+\n+  /* Verify that get_insn_by_uid works.  */\n+  ASSERT_EQ (insn_1, get_insn_by_uid (1));\n+  ASSERT_EQ (insn_2, get_insn_by_uid (2));\n+\n+  /* Verify that basic blocks were created.  */\n+  ASSERT_EQ (2, BLOCK_FOR_INSN (insn_1)->index);\n+  ASSERT_EQ (2, BLOCK_FOR_INSN (insn_2)->index);\n+\n+  /* Verify that the CFG was recreated.  */\n+  ASSERT_TRUE (cfun);\n+  verify_three_block_rtl_cfg (cfun);\n+  basic_block bb2 = BASIC_BLOCK_FOR_FN (cfun, 2);\n+  ASSERT_TRUE (bb2 != NULL);\n+  ASSERT_EQ (BB_RTL, bb2->flags & BB_RTL);\n+  ASSERT_EQ (2, bb2->index);\n+  ASSERT_EQ (insn_1, BB_HEAD (bb2));\n+  ASSERT_EQ (insn_2, BB_END (bb2));\n+}\n+\n+/* Verify loading another RTL dump.  */\n+\n+static void\n+test_loading_dump_fragment_2 ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"simple-cse.rtl\"));\n+\n+  rtx_insn *insn_1 = get_insn_by_uid (1);\n+  rtx_insn *insn_2 = get_insn_by_uid (2);\n+  rtx_insn *insn_3 = get_insn_by_uid (3);\n+\n+  rtx set1 = single_set (insn_1);\n+  ASSERT_NE (NULL, set1);\n+  rtx set2 = single_set (insn_2);\n+  ASSERT_NE (NULL, set2);\n+  rtx set3 = single_set (insn_3);\n+  ASSERT_NE (NULL, set3);\n+\n+  rtx src1 = SET_SRC (set1);\n+  ASSERT_EQ (PLUS, GET_CODE (src1));\n+\n+  rtx src2 = SET_SRC (set2);\n+  ASSERT_EQ (PLUS, GET_CODE (src2));\n+\n+  /* Both src1 and src2 refer to \"(reg:SI %0)\".\n+     Verify that we have pointer equality.  */\n+  rtx lhs1 = XEXP (src1, 0);\n+  rtx lhs2 = XEXP (src2, 0);\n+  ASSERT_EQ (lhs1, lhs2);\n+\n+  /* Verify that the CFG was recreated. */\n+  ASSERT_TRUE (cfun);\n+  verify_three_block_rtl_cfg (cfun);\n+}\n+\n+/* Verify that CODE_LABEL insns are loaded correctly.  */\n+\n+static void\n+test_loading_labels ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"example-labels.rtl\"));\n+\n+  rtx_insn *insn_100 = get_insn_by_uid (100);\n+  ASSERT_EQ (CODE_LABEL, GET_CODE (insn_100));\n+  ASSERT_EQ (100, INSN_UID (insn_100));\n+  ASSERT_EQ (NULL, LABEL_NAME (insn_100));\n+  ASSERT_EQ (0, LABEL_NUSES (insn_100));\n+  ASSERT_EQ (30, CODE_LABEL_NUMBER (insn_100));\n+\n+  rtx_insn *insn_200 = get_insn_by_uid (200);\n+  ASSERT_EQ (CODE_LABEL, GET_CODE (insn_200));\n+  ASSERT_EQ (200, INSN_UID (insn_200));\n+  ASSERT_STREQ (\"some_label_name\", LABEL_NAME (insn_200));\n+  ASSERT_EQ (0, LABEL_NUSES (insn_200));\n+  ASSERT_EQ (40, CODE_LABEL_NUMBER (insn_200));\n+\n+  /* Ensure that the presence of CODE_LABEL_NUMBER == 40\n+     means that the next label num to be handed out will be 41.  */\n+  ASSERT_EQ (41, max_label_num ());\n+\n+  /* Ensure that label names read from a dump are GC-managed\n+     and are found through the insn.  */\n+  forcibly_ggc_collect ();\n+  ASSERT_TRUE (ggc_marked_p (insn_200));\n+  ASSERT_TRUE (ggc_marked_p (LABEL_NAME (insn_200)));\n+}\n+\n+/* Verify that the loader copes with an insn with a mode.  */\n+\n+static void\n+test_loading_insn_with_mode ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"insn-with-mode.rtl\"));\n+  rtx_insn *insn = get_insns ();\n+  ASSERT_EQ (INSN, GET_CODE (insn));\n+\n+  /* Verify that the \"TI\" mode was set from \"insn:TI\".  */\n+  ASSERT_EQ (TImode, GET_MODE (insn));\n+}\n+\n+/* Verify that the loader copes with a jump_insn to a label_ref.  */\n+\n+static void\n+test_loading_jump_to_label_ref ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"jump-to-label-ref.rtl\"));\n+\n+  rtx_insn *jump_insn = get_insn_by_uid (1);\n+  ASSERT_EQ (JUMP_INSN, GET_CODE (jump_insn));\n+\n+  rtx_insn *barrier = get_insn_by_uid (2);\n+  ASSERT_EQ (BARRIER, GET_CODE (barrier));\n+\n+  rtx_insn *code_label = get_insn_by_uid (100);\n+  ASSERT_EQ (CODE_LABEL, GET_CODE (code_label));\n+\n+  /* Verify the jump_insn. */\n+  ASSERT_EQ (4, BLOCK_FOR_INSN (jump_insn)->index);\n+  ASSERT_EQ (SET, GET_CODE (PATTERN (jump_insn)));\n+  /* Ensure that the \"(pc)\" is using the global singleton.  */\n+  ASSERT_RTX_PTR_EQ (pc_rtx, SET_DEST (PATTERN (jump_insn)));\n+  rtx label_ref = SET_SRC (PATTERN (jump_insn));\n+  ASSERT_EQ (LABEL_REF, GET_CODE (label_ref));\n+  ASSERT_EQ (code_label, label_ref_label (label_ref));\n+  ASSERT_EQ (code_label, JUMP_LABEL (jump_insn));\n+\n+  /* Verify the code_label. */\n+  ASSERT_EQ (5, BLOCK_FOR_INSN (code_label)->index);\n+  ASSERT_EQ (NULL, LABEL_NAME (code_label));\n+  ASSERT_EQ (1, LABEL_NUSES (code_label));\n+\n+  /* Verify the generated CFG.  */\n+\n+  /* Locate blocks.  */\n+  basic_block entry = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  ASSERT_TRUE (entry != NULL);\n+  ASSERT_EQ (ENTRY_BLOCK, entry->index);\n+\n+  basic_block exit = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  ASSERT_TRUE (exit != NULL);\n+  ASSERT_EQ (EXIT_BLOCK, exit->index);\n+\n+  basic_block bb4 = (*cfun->cfg->x_basic_block_info)[4];\n+  basic_block bb5 = (*cfun->cfg->x_basic_block_info)[5];\n+  ASSERT_EQ (4, bb4->index);\n+  ASSERT_EQ (5, bb5->index);\n+\n+  /* Entry block.  */\n+  ASSERT_EQ (NULL, entry->preds);\n+  ASSERT_EQ (1, entry->succs->length ());\n+  ASSERT_EDGE ((*entry->succs)[0], 0, 4, EDGE_FALLTHRU);\n+\n+  /* bb4.  */\n+  ASSERT_EQ (1, bb4->preds->length ());\n+  ASSERT_EDGE ((*bb4->preds)[0], 0, 4, EDGE_FALLTHRU);\n+  ASSERT_EQ (1, bb4->succs->length ());\n+  ASSERT_EDGE ((*bb4->succs)[0], 4, 5, 0x0);\n+\n+  /* bb5.  */\n+  ASSERT_EQ (1, bb5->preds->length ());\n+  ASSERT_EDGE ((*bb5->preds)[0], 4, 5, 0x0);\n+  ASSERT_EQ (1, bb5->succs->length ());\n+  ASSERT_EDGE ((*bb5->succs)[0], 5, 1, EDGE_FALLTHRU);\n+\n+  /* Exit block.  */\n+  ASSERT_EQ (1, exit->preds->length ());\n+  ASSERT_EDGE ((*exit->preds)[0], 5, 1, EDGE_FALLTHRU);\n+  ASSERT_EQ (NULL, exit->succs);\n+}\n+\n+/* Verify that the loader copes with a jump_insn to a label_ref\n+   marked \"return\".  */\n+\n+static void\n+test_loading_jump_to_return ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"jump-to-return.rtl\"));\n+\n+  rtx_insn *jump_insn = get_insn_by_uid (1);\n+  ASSERT_EQ (JUMP_INSN, GET_CODE (jump_insn));\n+  ASSERT_RTX_PTR_EQ (ret_rtx, JUMP_LABEL (jump_insn));\n+}\n+\n+/* Verify that the loader copes with a jump_insn to a label_ref\n+   marked \"simple_return\".  */\n+\n+static void\n+test_loading_jump_to_simple_return ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION,\n+\t\t   locate_file (\"jump-to-simple-return.rtl\"));\n+\n+  rtx_insn *jump_insn = get_insn_by_uid (1);\n+  ASSERT_EQ (JUMP_INSN, GET_CODE (jump_insn));\n+  ASSERT_RTX_PTR_EQ (simple_return_rtx, JUMP_LABEL (jump_insn));\n+}\n+\n+/* Verify that the loader copes with a NOTE_INSN_BASIC_BLOCK.  */\n+\n+static void\n+test_loading_note_insn_basic_block ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION,\n+\t\t   locate_file (\"note_insn_basic_block.rtl\"));\n+\n+  rtx_insn *note = get_insn_by_uid (1);\n+  ASSERT_EQ (NOTE, GET_CODE (note));\n+  ASSERT_EQ (2, BLOCK_FOR_INSN (note)->index);\n+\n+  ASSERT_EQ (NOTE_INSN_BASIC_BLOCK, NOTE_KIND (note));\n+  ASSERT_EQ (2, NOTE_BASIC_BLOCK (note)->index);\n+  ASSERT_EQ (BASIC_BLOCK_FOR_FN (cfun, 2), NOTE_BASIC_BLOCK (note));\n+}\n+\n+/* Verify that the loader copes with a NOTE_INSN_DELETED.  */\n+\n+static void\n+test_loading_note_insn_deleted ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"note-insn-deleted.rtl\"));\n+\n+  rtx_insn *note = get_insn_by_uid (1);\n+  ASSERT_EQ (NOTE, GET_CODE (note));\n+  ASSERT_EQ (NOTE_INSN_DELETED, NOTE_KIND (note));\n+}\n+\n+/* Verify that the const_int values are consolidated, since\n+   pointer equality corresponds to value equality.\n+   TODO: do this for all in CASE_CONST_UNIQUE.  */\n+\n+static void\n+test_loading_const_int ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"const-int.rtl\"));\n+\n+  /* Verify that const_int values below MAX_SAVED_CONST_INT use\n+     the global values.  */\n+  ASSERT_EQ (const0_rtx, SET_SRC (PATTERN (get_insn_by_uid (1))));\n+  ASSERT_EQ (const1_rtx, SET_SRC (PATTERN (get_insn_by_uid (2))));\n+  ASSERT_EQ (constm1_rtx, SET_SRC (PATTERN (get_insn_by_uid (3))));\n+\n+  /* Verify that other const_int values are consolidated. */\n+  rtx int256 = gen_rtx_CONST_INT (SImode, 256);\n+  ASSERT_EQ (int256, SET_SRC (PATTERN (get_insn_by_uid (4))));\n+}\n+\n+/* Verify that the loader copes with a SYMBOL_REF.  */\n+\n+static void\n+test_loading_symbol_ref ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"symbol-ref.rtl\"));\n+\n+  rtx_insn *insn = get_insns ();\n+\n+  rtx high = SET_SRC (PATTERN (insn));\n+  ASSERT_EQ (HIGH, GET_CODE (high));\n+\n+  rtx symbol_ref = XEXP (high, 0);\n+  ASSERT_EQ (SYMBOL_REF, GET_CODE (symbol_ref));\n+\n+  /* Verify that \"[flags 0xc0]\" was parsed.  */\n+  ASSERT_EQ (0xc0, SYMBOL_REF_FLAGS (symbol_ref));\n+  /* TODO: we don't yet load SYMBOL_REF_DECL.  */\n+}\n+\n+/* Verify that the loader can rebuild a CFG.  */\n+\n+static void\n+test_loading_cfg ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"cfg-test.rtl\"));\n+\n+  ASSERT_STREQ (\"cfg_test\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+\n+  ASSERT_TRUE (cfun);\n+\n+  ASSERT_TRUE (cfun->cfg != NULL);\n+  ASSERT_EQ (6, n_basic_blocks_for_fn (cfun));\n+  ASSERT_EQ (6, n_edges_for_fn (cfun));\n+\n+  /* The \"fake\" basic blocks.  */\n+  basic_block entry = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  ASSERT_TRUE (entry != NULL);\n+  ASSERT_EQ (ENTRY_BLOCK, entry->index);\n+\n+  basic_block exit = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  ASSERT_TRUE (exit != NULL);\n+  ASSERT_EQ (EXIT_BLOCK, exit->index);\n+\n+  /* The \"real\" basic blocks.  */\n+  basic_block bb2 = (*cfun->cfg->x_basic_block_info)[2];\n+  basic_block bb3 = (*cfun->cfg->x_basic_block_info)[3];\n+  basic_block bb4 = (*cfun->cfg->x_basic_block_info)[4];\n+  basic_block bb5 = (*cfun->cfg->x_basic_block_info)[5];\n+\n+  ASSERT_EQ (2, bb2->index);\n+  ASSERT_EQ (3, bb3->index);\n+  ASSERT_EQ (4, bb4->index);\n+  ASSERT_EQ (5, bb5->index);\n+\n+  /* Verify connectivity.  */\n+\n+  /* Entry block.  */\n+  ASSERT_EQ (NULL, entry->preds);\n+  ASSERT_EQ (1, entry->succs->length ());\n+  ASSERT_EDGE ((*entry->succs)[0], 0, 2, EDGE_FALLTHRU);\n+\n+  /* bb2.  */\n+  ASSERT_EQ (1, bb2->preds->length ());\n+  ASSERT_EDGE ((*bb2->preds)[0], 0, 2, EDGE_FALLTHRU);\n+  ASSERT_EQ (2, bb2->succs->length ());\n+  ASSERT_EDGE ((*bb2->succs)[0], 2, 3, EDGE_TRUE_VALUE);\n+  ASSERT_EDGE ((*bb2->succs)[1], 2, 4, EDGE_FALSE_VALUE);\n+\n+  /* bb3.  */\n+  ASSERT_EQ (1, bb3->preds->length ());\n+  ASSERT_EDGE ((*bb3->preds)[0], 2, 3, EDGE_TRUE_VALUE);\n+  ASSERT_EQ (1, bb3->succs->length ());\n+  ASSERT_EDGE ((*bb3->succs)[0], 3, 5, EDGE_FALLTHRU);\n+\n+  /* bb4.  */\n+  ASSERT_EQ (1, bb4->preds->length ());\n+  ASSERT_EDGE ((*bb4->preds)[0], 2, 4, EDGE_FALSE_VALUE);\n+  ASSERT_EQ (1, bb4->succs->length ());\n+  ASSERT_EDGE ((*bb4->succs)[0], 4, 5, EDGE_FALLTHRU);\n+\n+  /* bb5.  */\n+  ASSERT_EQ (2, bb5->preds->length ());\n+  ASSERT_EDGE ((*bb5->preds)[0], 3, 5, EDGE_FALLTHRU);\n+  ASSERT_EDGE ((*bb5->preds)[1], 4, 5, EDGE_FALLTHRU);\n+  ASSERT_EQ (1, bb5->succs->length ());\n+  ASSERT_EDGE ((*bb5->succs)[0], 5, 1, EDGE_FALLTHRU);\n+\n+  /* Exit block.  */\n+  ASSERT_EQ (1, exit->preds->length ());\n+  ASSERT_EDGE ((*exit->preds)[0], 5, 1, EDGE_FALLTHRU);\n+  ASSERT_EQ (NULL, exit->succs);\n+}\n+\n+/* Verify that the loader copes with sparse block indices.\n+   This testcase loads a file with a \"(block 42)\".  */\n+\n+static void\n+test_loading_bb_index ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"bb-index.rtl\"));\n+\n+  ASSERT_STREQ (\"test_bb_index\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+\n+  ASSERT_TRUE (cfun);\n+\n+  ASSERT_TRUE (cfun->cfg != NULL);\n+  ASSERT_EQ (3, n_basic_blocks_for_fn (cfun));\n+  ASSERT_EQ (43, basic_block_info_for_fn (cfun)->length ());\n+  ASSERT_EQ (2, n_edges_for_fn (cfun));\n+\n+  ASSERT_EQ (NULL, (*cfun->cfg->x_basic_block_info)[41]);\n+  basic_block bb42 = (*cfun->cfg->x_basic_block_info)[42];\n+  ASSERT_NE (NULL, bb42);\n+  ASSERT_EQ (42, bb42->index);\n+}\n+\n+/* Verify that function_reader::handle_any_trailing_information correctly\n+   parses all the possible items emitted for a MEM.  */\n+\n+static void\n+test_loading_mem ()\n+{\n+  rtl_dump_test t (SELFTEST_LOCATION, locate_file (\"mem.rtl\"));\n+\n+  ASSERT_STREQ (\"test_mem\", IDENTIFIER_POINTER (DECL_NAME (cfun->decl)));\n+  ASSERT_TRUE (cfun);\n+\n+  /* Verify parsing of \"[42 i+17 S8 A128 AS5]\".  */\n+  rtx_insn *insn_1 = get_insn_by_uid (1);\n+  rtx set1 = single_set (insn_1);\n+  rtx mem1 = SET_DEST (set1);\n+  ASSERT_EQ (42, MEM_ALIAS_SET (mem1));\n+  /* \"+17\".  */\n+  ASSERT_TRUE (MEM_OFFSET_KNOWN_P (mem1));\n+  ASSERT_EQ (17, MEM_OFFSET (mem1));\n+  /* \"S8\".  */\n+  ASSERT_EQ (8, MEM_SIZE (mem1));\n+  /* \"A128.  */\n+  ASSERT_EQ (128, MEM_ALIGN (mem1));\n+  /* \"AS5.  */\n+  ASSERT_EQ (5, MEM_ADDR_SPACE (mem1));\n+\n+  /* Verify parsing of \"43 i+18 S9 AS6\"\n+     (an address space without an alignment).  */\n+  rtx_insn *insn_2 = get_insn_by_uid (2);\n+  rtx set2 = single_set (insn_2);\n+  rtx mem2 = SET_DEST (set2);\n+  ASSERT_EQ (43, MEM_ALIAS_SET (mem2));\n+  /* \"+18\".  */\n+  ASSERT_TRUE (MEM_OFFSET_KNOWN_P (mem2));\n+  ASSERT_EQ (18, MEM_OFFSET (mem2));\n+  /* \"S9\".  */\n+  ASSERT_EQ (9, MEM_SIZE (mem2));\n+  /* \"AS6.  */\n+  ASSERT_EQ (6, MEM_ADDR_SPACE (mem2));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+read_rtl_function_c_tests ()\n+{\n+  test_edge_flags ();\n+  test_parsing_regnos ();\n+  test_loading_dump_fragment_1 ();\n+  test_loading_dump_fragment_2 ();\n+  test_loading_labels ();\n+  test_loading_insn_with_mode ();\n+  test_loading_jump_to_label_ref ();\n+  test_loading_jump_to_return ();\n+  test_loading_jump_to_simple_return ();\n+  test_loading_note_insn_basic_block ();\n+  test_loading_note_insn_deleted ();\n+  test_loading_const_int ();\n+  test_loading_symbol_ref ();\n+  test_loading_cfg ();\n+  test_loading_bb_index ();\n+  test_loading_mem ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "45ada84de14c864f6955927e826473d42b8a0a38", "filename": "gcc/read-rtl-function.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,25 @@\n+/* read-rtl-function.h - Reader for RTL function dumps\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_READ_RTL_FUNCTION_H\n+#define GCC_READ_RTL_FUNCTION_H\n+\n+extern bool read_rtl_function_body (const char *path);\n+\n+#endif /* GCC_READ_RTL_FUNCTION_H */"}, {"sha": "e9c806828003968c2bb32df198cdb0ef00f35b5f", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 242, "deletions": 18, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -17,7 +17,13 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* This file is compiled twice: once for the generator programs\n+   once for the compiler.  */\n+#ifdef GENERATOR_FILE\n #include \"bconfig.h\"\n+#else\n+#include \"config.h\"\n+#endif\n \n /* Disable rtl checking; it conflicts with the iterator handling.  */\n #undef ENABLE_RTL_CHECKING\n@@ -30,6 +36,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"read-md.h\"\n #include \"gensupport.h\"\n \n+#ifndef GENERATOR_FILE\n+#include \"function.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#endif\n+\n /* One element in a singly-linked list of (integer, string) pairs.  */\n struct map_value {\n   struct map_value *next;\n@@ -106,6 +118,7 @@ htab_t subst_attr_to_iter_map = NULL;\n const char *current_iterator_name;\n \n static void validate_const_int (const char *);\n+static void one_time_initialization (void);\n \n /* Global singleton.  */\n rtx_reader *rtx_reader_ptr = NULL;\n@@ -142,6 +155,25 @@ apply_mode_iterator (void *loc, int mode)\n   PUT_MODE ((rtx) loc, (machine_mode) mode);\n }\n \n+/* In compact dumps, the code of insns is prefixed with \"c\", giving \"cinsn\",\n+   \"cnote\" etc, and CODE_LABEL is special-cased as \"clabel\".  */\n+\n+struct compact_insn_name {\n+  RTX_CODE code;\n+  const char *name;\n+};\n+\n+static const compact_insn_name compact_insn_names[] = {\n+  { DEBUG_INSN, \"cdebug_insn\" },\n+  { INSN, \"cinsn\" },\n+  { JUMP_INSN, \"cjump_insn\" },\n+  { CALL_INSN, \"ccall_insn\" },\n+  { JUMP_TABLE_DATA, \"cjump_table_data\" },\n+  { BARRIER, \"cbarrier\" },\n+  { CODE_LABEL, \"clabel\" },\n+  { NOTE, \"cnote\" }\n+};\n+\n /* Implementations of the iterator_group callbacks for codes.  */\n \n static int\n@@ -153,6 +185,10 @@ find_code (const char *name)\n     if (strcmp (GET_RTX_NAME (i), name) == 0)\n       return i;\n \n+  for (i = 0; i < (signed)ARRAY_SIZE (compact_insn_names); i++)\n+    if (strcmp (compact_insn_names[i].name, name) == 0)\n+      return compact_insn_names[i].code;\n+\n   fatal_with_file_and_line (\"unknown rtx code `%s'\", name);\n }\n \n@@ -181,6 +217,8 @@ apply_int_iterator (void *loc, int value)\n   *(int *)loc = value;\n }\n \n+#ifdef GENERATOR_FILE\n+\n /* This routine adds attribute or does nothing depending on VALUE.  When\n    VALUE is 1, it does nothing - the first duplicate of original\n    template is kept untouched when it's subjected to a define_subst.\n@@ -252,6 +290,8 @@ bind_subst_iter_and_attr (const char *iter, const char *attr)\n   *slot = value;\n }\n \n+#endif /* #ifdef GENERATOR_FILE */\n+\n /* Return name of a subst-iterator, corresponding to subst-attribute ATTR.  */\n \n static char*\n@@ -418,6 +458,8 @@ md_reader::copy_rtx_for_iterators (rtx original)\n   return x;\n }\n \n+#ifdef GENERATOR_FILE\n+\n /* Return a condition that must satisfy both ORIGINAL and EXTRA.  If ORIGINAL\n    has the form \"&& ...\" (as used in define_insn_and_splits), assume that\n    EXTRA is already satisfied.  Empty strings are treated like \"true\".  */\n@@ -581,6 +623,7 @@ apply_iterators (rtx original, vec<rtx> *queue)\n \t}\n     }\n }\n+#endif /* #ifdef GENERATOR_FILE */\n \n /* Add a new \"mapping\" structure to hashtable TABLE.  NAME is the name\n    of the mapping and GROUP is the group to which it belongs.  */\n@@ -655,7 +698,9 @@ initialize_iterators (void)\n   substs.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n   substs.find_builtin = find_int; /* We don't use it, anyway.  */\n+#ifdef GENERATOR_FILE\n   substs.apply_iterator = apply_subst_iterator;\n+#endif\n \n   lower = add_mapping (&modes, modes.attrs, \"mode\");\n   upper = add_mapping (&modes, modes.attrs, \"MODE\");\n@@ -724,6 +769,8 @@ atoll (const char *p)\n }\n #endif\n \f\n+\n+#ifdef GENERATOR_FILE\n /* Process a define_conditions directive, starting with the optional\n    space after the \"define_conditions\".  The directive looks like this:\n \n@@ -765,6 +812,7 @@ md_reader::read_conditions ()\n       add_c_test (expr, value);\n     }\n }\n+#endif /* #ifdef GENERATOR_FILE */\n \n static void\n validate_const_int (const char *string)\n@@ -861,6 +909,8 @@ md_reader::record_potential_iterator_use (struct iterator_group *group,\n     }\n }\n \n+#ifdef GENERATOR_FILE\n+\n /* Finish reading a declaration of the form:\n \n        (define... <name> [<value1> ... <valuen>])\n@@ -1020,15 +1070,6 @@ check_code_iterator (struct mapping *iterator)\n bool\n rtx_reader::read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n {\n-  static bool initialized = false;\n-\n-  /* Do one-time initialization.  */\n-  if (!initialized)\n-    {\n-      initialize_iterators ();\n-      initialized = true;\n-    }\n-\n   /* Handle various rtx-related declarations that aren't themselves\n      encoded as rtxes.  */\n   if (strcmp (rtx_name, \"define_conditions\") == 0)\n@@ -1082,6 +1123,103 @@ rtx_reader::read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n   return true;\n }\n \n+#endif /* #ifdef GENERATOR_FILE */\n+\n+/* Do one-time initialization.  */\n+\n+static void\n+one_time_initialization (void)\n+{\n+  static bool initialized = false;\n+\n+  if (!initialized)\n+    {\n+      initialize_iterators ();\n+      initialized = true;\n+    }\n+}\n+\n+/* Consume characters until encountering a character in TERMINATOR_CHARS,\n+   consuming the terminator character if CONSUME_TERMINATOR is true.\n+   Return all characters before the terminator as an allocated buffer.  */\n+\n+char *\n+rtx_reader::read_until (const char *terminator_chars, bool consume_terminator)\n+{\n+  int ch = read_skip_spaces ();\n+  unread_char (ch);\n+  auto_vec<char> buf;\n+  while (1)\n+    {\n+      ch = read_char ();\n+      if (strchr (terminator_chars, ch))\n+\t{\n+\t  if (!consume_terminator)\n+\t    unread_char (ch);\n+\t  break;\n+\t}\n+      buf.safe_push (ch);\n+    }\n+  buf.safe_push ('\\0');\n+  return xstrdup (buf.address ());\n+}\n+\n+/* Subroutine of read_rtx_code, for parsing zero or more flags.  */\n+\n+static void\n+read_flags (rtx return_rtx)\n+{\n+  while (1)\n+    {\n+      int ch = read_char ();\n+      if (ch != '/')\n+\t{\n+\t  unread_char (ch);\n+\t  break;\n+\t}\n+\n+      int flag_char = read_char ();\n+      switch (flag_char)\n+\t{\n+\t  case 's':\n+\t    RTX_FLAG (return_rtx, in_struct) = 1;\n+\t    break;\n+\t  case 'v':\n+\t    RTX_FLAG (return_rtx, volatil) = 1;\n+\t    break;\n+\t  case 'u':\n+\t    RTX_FLAG (return_rtx, unchanging) = 1;\n+\t    break;\n+\t  case 'f':\n+\t    RTX_FLAG (return_rtx, frame_related) = 1;\n+\t    break;\n+\t  case 'j':\n+\t    RTX_FLAG (return_rtx, jump) = 1;\n+\t    break;\n+\t  case 'c':\n+\t    RTX_FLAG (return_rtx, call) = 1;\n+\t    break;\n+\t  case 'i':\n+\t    RTX_FLAG (return_rtx, return_val) = 1;\n+\t    break;\n+\t  default:\n+\t    fatal_with_file_and_line (\"unrecognized flag: `%c'\", flag_char);\n+\t}\n+    }\n+}\n+\n+/* Return the numeric value n for GET_REG_NOTE_NAME (n) for STRING,\n+   or fail if STRING isn't recognized.  */\n+\n+static int\n+parse_reg_note_name (const char *string)\n+{\n+  for (int i = 0; i < REG_NOTE_MAX; i++)\n+    if (0 == strcmp (string, GET_REG_NOTE_NAME (i)))\n+      return i;\n+  fatal_with_file_and_line (\"unrecognized REG_NOTE name: `%s'\", string);\n+}\n+\n /* Subroutine of read_rtx and read_nested_rtx.  CODE_NAME is the name of\n    either an rtx code or a code iterator.  Parse the rest of the rtx and\n    return it.  */\n@@ -1090,11 +1228,12 @@ rtx\n rtx_reader::read_rtx_code (const char *code_name)\n {\n   RTX_CODE code;\n-  struct mapping *iterator;\n+  struct mapping *iterator = NULL;\n   const char *format_ptr;\n   struct md_name name;\n   rtx return_rtx;\n   int c;\n+  long reuse_id = -1;\n \n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n@@ -1103,23 +1242,74 @@ rtx_reader::read_rtx_code (const char *code_name)\n       rtx value;\t\t/* Value of this node.  */\n     };\n \n+  /* Handle reuse_rtx ids e.g. \"(0|scratch:DI)\".  */\n+  if (ISDIGIT (code_name[0]))\n+    {\n+      reuse_id = atoi (code_name);\n+      while (char ch = *code_name++)\n+\tif (ch == '|')\n+\t  break;\n+    }\n+\n+  /* Handle \"reuse_rtx\".  */\n+  if (strcmp (code_name, \"reuse_rtx\") == 0)\n+    {\n+      read_name (&name);\n+      long idx = atoi (name.string);\n+      /* Look it up by ID.  */\n+      gcc_assert (idx < m_reuse_rtx_by_id.length ());\n+      return_rtx = m_reuse_rtx_by_id[idx];\n+      return return_rtx;\n+    }\n+\n   /* If this code is an iterator, build the rtx using the iterator's\n      first value.  */\n+#ifdef GENERATOR_FILE\n   iterator = (struct mapping *) htab_find (codes.iterators, &code_name);\n   if (iterator != 0)\n     code = (enum rtx_code) iterator->values->number;\n   else\n     code = (enum rtx_code) codes.find_builtin (code_name);\n+#else\n+    code = (enum rtx_code) codes.find_builtin (code_name);\n+#endif\n \n   /* If we end up with an insn expression then we free this space below.  */\n   return_rtx = rtx_alloc (code);\n   format_ptr = GET_RTX_FORMAT (code);\n   memset (return_rtx, 0, RTX_CODE_SIZE (code));\n   PUT_CODE (return_rtx, code);\n \n+  if (reuse_id != -1)\n+    {\n+      /* Store away for later reuse.  */\n+      m_reuse_rtx_by_id.safe_grow_cleared (reuse_id + 1);\n+      m_reuse_rtx_by_id[reuse_id] = return_rtx;\n+    }\n+\n   if (iterator)\n     record_iterator_use (iterator, return_rtx);\n \n+  /* Check for flags. */\n+  read_flags (return_rtx);\n+\n+  /* Read REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n+  if ((GET_CODE (return_rtx) == EXPR_LIST\n+       || GET_CODE (return_rtx) == INSN_LIST\n+       || GET_CODE (return_rtx) == INT_LIST)\n+      && !m_in_call_function_usage)\n+    {\n+      char ch = read_char ();\n+      if (ch == ':')\n+\t{\n+\t  read_name (&name);\n+\t  PUT_MODE_RAW (return_rtx,\n+\t\t\t(machine_mode)parse_reg_note_name (name.string));\n+\t}\n+      else\n+\tunread_char (ch);\n+    }\n+\n   /* If what follows is `: mode ', read it and\n      store the mode in the rtx.  */\n \n@@ -1132,8 +1322,19 @@ rtx_reader::read_rtx_code (const char *code_name)\n   else\n     unread_char (c);\n \n+  if (INSN_CHAIN_CODE_P (code))\n+    {\n+      read_name (&name);\n+      INSN_UID (return_rtx) = atoi (name.string);\n+    }\n+\n+  /* Use the format_ptr to parse the various operands of this rtx.  */\n   for (int idx = 0; format_ptr[idx] != 0; idx++)\n-    read_rtx_operand (return_rtx, idx);\n+    return_rtx = read_rtx_operand (return_rtx, idx);\n+\n+  /* Handle any additional information that after the regular fields\n+     (e.g. when parsing function dumps).  */\n+  handle_any_trailing_information (return_rtx);\n \n   if (CONST_WIDE_INT_P (return_rtx))\n     {\n@@ -1197,9 +1398,11 @@ rtx_reader::read_rtx_code (const char *code_name)\n \n /* Subroutine of read_rtx_code.  Parse operand IDX within RETURN_RTX,\n    based on the corresponding format character within GET_RTX_FORMAT\n-   for the GET_CODE (RETURN_RTX).  */\n+   for the GET_CODE (RETURN_RTX), and return RETURN_RTX.\n+   This is a virtual function, so that function_reader can override\n+   some parsing, and potentially return a different rtx.  */\n \n-void\n+rtx\n rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n {\n   RTX_CODE code = GET_CODE (return_rtx);\n@@ -1217,6 +1420,9 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n       break;\n \n     case 'e':\n+      XEXP (return_rtx, idx) = read_nested_rtx ();\n+      break;\n+\n     case 'u':\n       XEXP (return_rtx, idx) = read_nested_rtx ();\n       break;\n@@ -1273,7 +1479,6 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n       {\n \tchar *stringbuf;\n \tint star_if_braced;\n-\tstruct obstack *string_obstack = get_string_obstack ();\n \n \tc = read_skip_spaces ();\n \tunread_char (c);\n@@ -1293,7 +1498,10 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \tstar_if_braced = (format_ptr[idx] == 'T');\n \n \tstringbuf = read_string (star_if_braced);\n+\tif (!stringbuf)\n+\t  break;\n \n+#ifdef GENERATOR_FILE\n \t/* For insn patterns, we want to provide a default name\n \t   based on the file and line, like \"*foo.md:12\", if the\n \t   given name is blank.  These are only for define_insn and\n@@ -1303,6 +1511,7 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \t    && (GET_CODE (return_rtx) == DEFINE_INSN\n \t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n \t  {\n+\t    struct obstack *string_obstack = get_string_obstack ();\n \t    char line_name[20];\n \t    const char *read_md_filename = get_filename ();\n \t    const char *fn = (read_md_filename ? read_md_filename : \"rtx\");\n@@ -1348,11 +1557,14 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \t    if (m != 0)\n \t      record_iterator_use (m, return_rtx);\n \t  }\n+#endif /* #ifdef GENERATOR_FILE */\n+\n+\tconst char *string_ptr = finalize_string (stringbuf);\n \n \tif (star_if_braced)\n-\t  XTMPL (return_rtx, idx) = stringbuf;\n+\t  XTMPL (return_rtx, idx) = string_ptr;\n \telse\n-\t  XSTR (return_rtx, idx) = stringbuf;\n+\t  XSTR (return_rtx, idx) = string_ptr;\n       }\n       break;\n \n@@ -1398,6 +1610,8 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n     default:\n       gcc_unreachable ();\n     }\n+\n+  return return_rtx;\n }\n \n /* Read a nested rtx construct from the MD file and return it.  */\n@@ -1408,6 +1622,11 @@ rtx_reader::read_nested_rtx ()\n   struct md_name name;\n   rtx return_rtx;\n \n+  /* In compact dumps, trailing \"(nil)\" values can be omitted.\n+     Handle such dumps.  */\n+  if (peek_char () == ')')\n+    return NULL_RTX;\n+\n   require_char_ws ('(');\n \n   read_name (&name);\n@@ -1418,6 +1637,8 @@ rtx_reader::read_nested_rtx ()\n \n   require_char_ws (')');\n \n+  return_rtx = postprocess (return_rtx);\n+\n   return return_rtx;\n }\n \n@@ -1454,11 +1675,14 @@ rtx_reader::read_rtx_variadic (rtx form)\n \n /* Constructor for class rtx_reader.  */\n \n-rtx_reader::rtx_reader ()\n-: md_reader ()\n+rtx_reader::rtx_reader (bool compact)\n+: md_reader (compact),\n+  m_in_call_function_usage (false)\n {\n   /* Set the global singleton pointer.  */\n   rtx_reader_ptr = this;\n+\n+  one_time_initialization ();\n }\n \n /* Destructor for class rtx_reader.  */"}, {"sha": "705434012d6be41b4877f150a6aceb06046afe75", "filename": "gcc/rtl-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Frtl-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Frtl-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-tests.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -200,6 +200,7 @@ test_single_set ()\n static void\n test_uncond_jump ()\n {\n+  set_new_first_and_last_insn (NULL, NULL);\n   rtx_insn *label = gen_label_rtx ();\n   rtx jump_pat = gen_rtx_SET (pc_rtx,\n \t\t\t      gen_rtx_LABEL_REF (VOIDmode,"}, {"sha": "638dfc8b1cb665f78919deaac486e433fb115d09", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -3712,7 +3712,9 @@ extern void init_varasm_once (void);\n extern rtx make_debug_expr_from_rtl (const_rtx);\n \n /* In read-rtl.c */\n+#ifdef GENERATOR_FILE\n extern bool read_rtx (const char *, vec<rtx> *);\n+#endif\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);"}, {"sha": "bfb1ab733a890f6f2a7e23a0f5d9987130a15615", "filename": "gcc/selftest-rtl.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-rtl.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,100 @@\n+/* Selftest support for RTL.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"selftest.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"read-rtl-function.h\"\n+#include \"read-md.h\"\n+#include \"tree-core.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"selftest-rtl.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Compare rtx EXPECTED and ACTUAL by pointer equality, calling\n+   ::selftest::pass if they are equal, aborting if they are non-equal.\n+   LOC is the effective location of the assertion, MSG describes it.  */\n+\n+void\n+assert_rtx_ptr_eq_at (const location &loc, const char *msg,\n+\t\t      rtx expected, rtx actual)\n+{\n+  if (expected == actual)\n+    ::selftest::pass (loc, msg);\n+  else\n+    {\n+      fprintf (stderr, \"%s:%i: %s: FAIL: %s\\n\", loc.m_file, loc.m_line,\n+\t       loc.m_function, msg);\n+      fprintf (stderr, \"  expected (at %p): \", (void *)expected);\n+      print_rtl (stderr, expected);\n+      fprintf (stderr, \"\\n  actual (at %p): \", (void *)actual);\n+      print_rtl (stderr, actual);\n+      fprintf (stderr, \"\\n\");\n+      abort ();\n+    }\n+}\n+\n+/* Constructor for selftest::rtl_dump_test.\n+   Read a dumped RTL function from PATH.\n+   Takes ownership of PATH, freeing in dtor.\n+   Use LOC as the effective location when reporting failures.  */\n+\n+rtl_dump_test::rtl_dump_test (const location &loc, char *path)\n+  : m_path (path)\n+{\n+  bool read_ok = read_rtl_function_body (path);\n+  ASSERT_TRUE_AT (loc, read_ok);\n+}\n+\n+/* Destructor for selftest::rtl_dump_test.\n+   Cleanup global state relating to the function, and free the path.  */\n+\n+selftest::rtl_dump_test::~rtl_dump_test ()\n+{\n+  /* Cleanups.  */\n+  current_function_decl = NULL;\n+  free_after_compilation (cfun);\n+  set_cfun (NULL);\n+  free (m_path);\n+}\n+\n+/* Get the insn with the given uid, or NULL if not found.  */\n+\n+rtx_insn *\n+get_insn_by_uid (int uid)\n+{\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_UID (insn) == uid)\n+      return insn;\n+\n+  /* Not found.  */\n+  return NULL;\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "2218f9c528022dd14d5c2b2dc2b8632b5e9534e0", "filename": "gcc/selftest-rtl.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-rtl.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -47,6 +47,43 @@ assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x,\n   assert_rtl_dump_eq (SELFTEST_LOCATION, (EXPECTED_DUMP), (RTX), \\\n \t\t      (REUSE_MANAGER))\n \n+/* Evaluate rtx EXPECTED and ACTUAL and compare them with ==\n+   (i.e. pointer equality), calling ::selftest::pass if they are\n+   equal, aborting if they are non-equal.  */\n+\n+#define ASSERT_RTX_PTR_EQ(EXPECTED, ACTUAL) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_RTX_PTR_EQ (\" #EXPECTED \", \" #ACTUAL \")\";  \\\n+  ::selftest::assert_rtx_ptr_eq_at (SELFTEST_LOCATION, desc, (EXPECTED), \\\n+\t\t\t\t    (ACTUAL));\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Compare rtx EXPECTED and ACTUAL by pointer equality, calling\n+   ::selftest::pass if they are equal, aborting if they are non-equal.\n+   LOC is the effective location of the assertion, MSG describes it.  */\n+\n+extern void assert_rtx_ptr_eq_at (const location &loc, const char *msg,\n+\t\t\t\t  rtx expected, rtx actual);\n+\n+/* A class for testing RTL function dumps.  */\n+\n+class rtl_dump_test\n+{\n+ public:\n+  /* Takes ownership of PATH.  */\n+  rtl_dump_test (const location &loc, char *path);\n+  ~rtl_dump_test ();\n+\n+ private:\n+  char *m_path;\n+};\n+\n+/* Get the insn with the given uid, or NULL if not found.  */\n+\n+extern rtx_insn *get_insn_by_uid (int uid);\n+\n+extern void verify_three_block_rtl_cfg (function *fun);\n+\n } /* end of namespace selftest.  */\n \n #endif /* #if CHECKING_P */"}, {"sha": "f62bc72b07207cf5e4cacb1b3831604c0e69b8b8", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -72,6 +72,7 @@ selftest::run_tests ()\n   tree_c_tests ();\n   gimple_c_tests ();\n   rtl_tests_c_tests ();\n+  read_rtl_function_c_tests ();\n \n   /* Higher-level tests, or for components that other selftests don't\n      rely on.  */"}, {"sha": "dad53e9fe09f2258efabb04f85b03ffd1bb5b097", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -184,6 +184,7 @@ extern void hash_map_tests_c_tests ();\n extern void hash_set_tests_c_tests ();\n extern void input_c_tests ();\n extern void pretty_print_c_tests ();\n+extern void read_rtl_function_c_tests ();\n extern void rtl_tests_c_tests ();\n extern void selftest_c_tests ();\n extern void spellcheck_c_tests ();"}, {"sha": "7b11cf5b60ee35bc5962d8fb74c956aa2b3e9791", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -1,3 +1,27 @@\n+2017-01-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* selftests/asr_div1.rtl: New file.\n+\t* selftests/aarch64: New subdirectory.\n+\t* selftests/aarch64/times-two.rtl: New file.\n+\t* selftests/bb-index.rtl: New file.\n+\t* selftests/cfg-test.rtl: New file.\n+\t* selftests/const-int.rtl: New file.\n+\t* selftests/example-labels.rtl: New file.\n+\t* selftests/insn-with-mode.rtl: New file.\n+\t* selftests/jump-to-label-ref.rtl: New file.\n+\t* selftests/jump-to-return.rtl: New file.\n+\t* selftests/jump-to-simple-return.rtl: New file.\n+\t* selftests/mem.rtl: New file.\n+\t* selftests/note-insn-deleted.rtl: New file.\n+\t* selftests/note_insn_basic_block.rtl: New file.\n+\t* selftests/simple-cse.rtl: New file.\n+\t* selftests/symbol-ref.rtl: New file.\n+\t* selftests/x86_64: New subdirectory.\n+\t* selftests/x86_64/call-insn.rtl: New file.\n+\t* selftests/x86_64/copy-hard-reg-into-frame.rtl: New file.\n+\t* selftests/x86_64/times-two.rtl: New file.\n+\t* selftests/x86_64/unspec.rtl: New file.\n+\n 2017-01-05  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/78765"}, {"sha": "05e2bdbf460c4df3f4e178323fbf8b4f8959b392", "filename": "gcc/testsuite/selftests/aarch64/times-two.rtl", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Faarch64%2Ftimes-two.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Faarch64%2Ftimes-two.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Faarch64%2Ftimes-two.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,36 @@\n+(function \"times_two\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 4 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 2 (set (mem/c:SI (plus:DI (reg/f:DI virtual-stack-vars)\n+                            (const_int -4)) [1 i+0 S4 A32])\n+                    (reg:SI x0 [ i ])) \"../../src/times-two.c\":2\n+                 (nil))\n+      (cnote 3 NOTE_INSN_FUNCTION_BEG)\n+      (cinsn 6 (set (reg:SI <2>)\n+                    (mem/c:SI (plus:DI (reg/f:DI virtual-stack-vars)\n+                            (const_int -4)) [1 i+0 S4 A32])) \"../../src/times-two.c\":3\n+                 (nil))\n+      (cinsn 7 (set (reg:SI <0> [ _2 ])\n+                    (ashift:SI (reg:SI <2>)\n+                        (const_int 1))) \"../../src/times-two.c\":3\n+                 (nil))\n+      (cinsn 10 (set (reg:SI <1> [ <retval> ])\n+                    (reg:SI <0> [ _2 ])) \"../../src/times-two.c\":3\n+                 (nil))\n+      (cinsn 14 (set (reg/i:SI x0)\n+                    (reg:SI <1> [ <retval> ])) \"../../src/times-two.c\":4\n+                 (nil))\n+      (cinsn 15 (use (reg/i:SI x0)) \"../../src/times-two.c\":4\n+                 (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx \n+      (reg/i:SI x0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"times_two\""}, {"sha": "2b03b3836225f6feaa5ed3639d50b1602c1834c4", "filename": "gcc/testsuite/selftests/asr_div1.rtl", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fasr_div1.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fasr_div1.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fasr_div1.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,24 @@\n+;; Taken from\n+;;    gcc/testsuite/gcc.dg/asr_div1.c -O2 -fdump-rtl-all -mtune=cortex-a53\n+;; for aarch64, hand editing to the new format.\n+\n+(function \"f1\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1 (set (reg:DI <2>)\n+        (lshiftrt:DI (reg:DI <0>)\n+            (const_int 32)))\n+        \"../../src/gcc/testsuite/gcc.dg/asr_div1.c\":14\n+        (expr_list:REG_DEAD (reg:DI <0>)\n+          (nil)))\n+      (cinsn 2 (set (reg:SI <1>)\n+        (ashiftrt:SI (subreg:SI (reg:DI <2>) 0)\n+            (const_int 3)))\n+        \"../../src/gcc/testsuite/gcc.dg/asr_div1.c\":14\n+        (expr_list:REG_DEAD (reg:DI <2>)\n+          (nil)))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "7c66f226b823e5691f96234aa84a443eabfaf3fb", "filename": "gcc/testsuite/selftests/bb-index.rtl", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fbb-index.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fbb-index.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fbb-index.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,8 @@\n+(function \"test_bb_index\"\n+  (insn-chain\n+    (block 42\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 42\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "08a0e226caeeb73292d301d854a18dbfba6a5d5d", "filename": "gcc/testsuite/selftests/cfg-test.rtl", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fcfg-test.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fcfg-test.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fcfg-test.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,37 @@\n+/* Example of a loading a CFG like this:\n+       0  (entry)\n+       |\n+       2\n+      / \\\n+     3   4\n+      \\ /\n+       5\n+       |\n+       1  (exit).  */\n+\n+(function \"cfg_test\"\n+  (insn-chain\n+     (block 2\n+       (edge-from entry (flags \"FALLTHRU\"))\n+       (cnote 1 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+       (edge-to 3 (flags \"TRUE_VALUE\"))\n+       (edge-to 4 (flags \"FALSE_VALUE\"))\n+     ) ;; block 2\n+     (block 3\n+       (edge-from 2 (flags \"TRUE_VALUE\"))\n+       (cnote 2 [bb 3] NOTE_INSN_BASIC_BLOCK)\n+       (edge-to 5 (flags \"FALLTHRU\"))\n+     ) ;; block 3\n+     (block 4\n+       (edge-from 2 (flags \"FALSE_VALUE\"))\n+       (cnote 3 [bb 4] NOTE_INSN_BASIC_BLOCK)\n+       (edge-to 5 (flags \"FALLTHRU\"))\n+     ) ;; block 4\n+     (block 5\n+       (edge-from 3 (flags \"FALLTHRU\"))\n+       (edge-from 4 (flags \"FALLTHRU\"))\n+       (cnote 4 [bb 5] NOTE_INSN_BASIC_BLOCK)\n+       (edge-to exit (flags \"FALLTHRU\"))\n+     ) ;; block 5\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "477f156c6632ad2c1719515c803be5369333c539", "filename": "gcc/testsuite/selftests/const-int.rtl", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fconst-int.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fconst-int.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fconst-int.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,20 @@\n+(function \"const_int_examples\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1\n+        (set (reg:SI <0>) (const_int 0))\n+        \"test.c\":2 (nil))\n+      (cinsn 2\n+        (set (reg:SI <1>) (const_int 1))\n+        \"test.c\":2 (nil))\n+      (cinsn 3\n+        (set (reg:SI <2>) (const_int -1))\n+        \"test.c\":2 (nil))\n+      (cinsn 4\n+        (set (reg:SI <3>) (const_int 256))\n+        \"test.c\":2 (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "ec33bfd7e5ab5aa141e13af018ae0c84dcc2607d", "filename": "gcc/testsuite/selftests/example-labels.rtl", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fexample-labels.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fexample-labels.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fexample-labels.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,8 @@\n+(function \"example_labels\"\n+  (insn-chain\n+    (block 6\n+      (clabel 100 30 (nil))\n+      (clabel 200 40 (\"some_label_name\"))\n+    ) ;; block 6\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "7e8f2a8803ab5e452acaa7562bcf90902cce80f0", "filename": "gcc/testsuite/selftests/insn-with-mode.rtl", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Finsn-with-mode.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Finsn-with-mode.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Finsn-with-mode.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,7 @@\n+(function \"insn_with_mode\"\n+  (insn-chain\n+    (block 2\n+      (insn:TI 1 (set (reg:SI <0>) (reg:SI <1>)) (nil))\n+    ) ;; block\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "29184bfb4b96fa2768edddb9cce9a6dbfc0d294e", "filename": "gcc/testsuite/selftests/jump-to-label-ref.rtl", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-label-ref.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-label-ref.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fjump-to-label-ref.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,17 @@\n+(function \"jump_to_label_ref\"\n+  (insn-chain\n+    (block 4\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cjump_insn 1 (set (pc) (label_ref 100))\n+        \"../../src/gcc/testsuite/rtl.dg/test.c\":4)\n+      (edge-to 5)\n+    ) ;; block 4\n+    (cbarrier 2)\n+    (block 5   \n+      (edge-from 4)\n+      (clabel 100 2 (nil) [1 uses])\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 5\n+  ) ;; insn-chain\n+) ;; function\n+"}, {"sha": "9da89ef42dfb48a80454efe2ca73702f9411ec5b", "filename": "gcc/testsuite/selftests/jump-to-return.rtl", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-return.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-return.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fjump-to-return.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,11 @@\n+(function \"jump_to_return\"\n+  (insn-chain\n+    (block 4\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cjump_insn 1 (return)\n+        \"../../src/gcc/testsuite/rtl.dg/test.c\":4\n+        (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 4\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "5a9c1d57dbc937117dd4e19f8c1da2953e73ba69", "filename": "gcc/testsuite/selftests/jump-to-simple-return.rtl", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-simple-return.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fjump-to-simple-return.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fjump-to-simple-return.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,11 @@\n+(function \"jump_to_simple_return\"\n+  (insn-chain\n+    (block 4\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cjump_insn 1 (simple_return)\n+        \"../../src/gcc/testsuite/rtl.dg/test.c\":4\n+        (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 4\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "219a4aa8072c364d0d15a51ae7ac40d42efa3d8e", "filename": "gcc/testsuite/selftests/mem.rtl", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fmem.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fmem.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fmem.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,9 @@\n+(function \"test_mem\"\n+  (insn-chain\n+    (block 2\n+      ;; Various nonsensical values, to exercise the parser:\n+      (cinsn 1 (set (mem:SI (reg:SI <10>) [42 i+17 S8 A128 AS5]) (reg:SI <1>)))\n+      (cinsn 2 (set (mem:SI (reg:SI <11>) [43 i+18 S9 AS6]) (reg:SI <2>)))\n+    ) ;; block 6\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "a388acde39685c7708fec4c5502199a7c0de61fb", "filename": "gcc/testsuite/selftests/note-insn-deleted.rtl", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fnote-insn-deleted.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fnote-insn-deleted.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fnote-insn-deleted.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,5 @@\n+(function \"example_note\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "e792d983165436736a4c38a912f16e717a3fdf4a", "filename": "gcc/testsuite/selftests/note_insn_basic_block.rtl", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fnote_insn_basic_block.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fnote_insn_basic_block.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fnote_insn_basic_block.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,9 @@\n+(function \"example_of_note\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 1 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "2dae4ae7433c5c071ae88c2b56a3b3c4e3113c72", "filename": "gcc/testsuite/selftests/simple-cse.rtl", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fsimple-cse.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fsimple-cse.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fsimple-cse.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,16 @@\n+(function \"test\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1 (set (reg:SI <1>)\n+                    (plus:SI (reg:SI <0>)\n+                             (const_int 1))) (nil))\n+      (cinsn 2 (set (reg:SI <2>)\n+                    (plus:SI (reg:SI <0>)\n+                             (const_int 1))) (nil))\n+      (cinsn 3 (set (mem:SI (reg:SI <3>) [1 i+0 S4 A32])\n+                    (mult:SI (reg:SI <1>) (reg:SI <2>))) (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "98b583ef75d8ce4cb8f006983705090633c7ce78", "filename": "gcc/testsuite/selftests/symbol-ref.rtl", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fsymbol-ref.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fsymbol-ref.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fsymbol-ref.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,13 @@\n+(function \"example_of_symbol_ref\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1\n+        (set (reg:SI <0>)\n+             (high:SI (symbol_ref:SI (\"isl_obj_map_vtable\") [flags 0xc0] <var_decl 0x7fa0363ea240 isl_obj_map_vtable>)))\n+        \"y.c\":12702\n+        (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "8f3a78126879d8feb1d59d3f9bf44c37a662a890", "filename": "gcc/testsuite/selftests/x86_64/call-insn.rtl", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcall-insn.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcall-insn.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcall-insn.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,17 @@\n+(function \"test\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (ccall_insn/j 1\n+        (set (reg:DF xmm0)\n+             (call (mem:QI (symbol_ref:DI (\"sqrt\") [flags 0x41]  <function_decl 0x7f82b1429d00 sqrt>) [0 __builtin_sqrt S1 A8])\n+                    (const_int 0))) \"test.c\":19\n+        (expr_list:REG_CALL_DECL (symbol_ref:DI (\"sqrt\") [flags 0x41]  <function_decl 0x7f82b1429d00 sqrt>)\n+           (expr_list:REG_EH_REGION (const_int 0)\n+              (nil)))\n+        (expr_list:DF (use (reg:DF xmm0))\n+           (nil)))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function \"test\""}, {"sha": "4598a1c9bfe91f3d0f16bdc7bc755360e5579e40", "filename": "gcc/testsuite/selftests/x86_64/copy-hard-reg-into-frame.rtl", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcopy-hard-reg-into-frame.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcopy-hard-reg-into-frame.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Fcopy-hard-reg-into-frame.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,15 @@\n+(function \"copy_hard_reg_into_frame\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1 (set (mem/c:SI\n+                      (plus:DI\n+                        (reg/f:DI frame)\n+                        (const_int -4))\n+                      [1 i+0 S4 A32])\n+               (reg:SI di [ i ])) \"test.c\":2\n+               (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "8cec47acd9adcac02cb998b7f96f297964455787", "filename": "gcc/testsuite/selftests/x86_64/times-two.rtl", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Ftimes-two.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Ftimes-two.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Ftimes-two.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,51 @@\n+;; Dump of this C function:\n+;;\n+;; int times_two (int i)\n+;; {\n+;;   return i * 2;\n+;; }\n+;;\n+;; after expand for target==x86_64\n+\n+(function \"times_two\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 4 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 2 (set (mem/c:SI (plus:DI (reg/f:DI virtual-stack-vars)\n+                            (const_int -4)) [1 i+0 S4 A32])\n+                    (reg:SI di [ i ])) \"../../src/times-two.c\":2\n+                 (nil))\n+      (cnote 3 NOTE_INSN_FUNCTION_BEG)\n+      (cinsn 6 (set (reg:SI <2>)\n+                    (mem/c:SI (plus:DI (reg/f:DI virtual-stack-vars)\n+                            (const_int -4)) [1 i+0 S4 A32])) \"../../src/times-two.c\":3\n+                 (nil))\n+      (cinsn 7 (parallel [\n+                        (set (reg:SI <0> [ _2 ])\n+                            (ashift:SI (reg:SI <2>)\n+                                (const_int 1)))\n+                        (clobber (reg:CC flags))\n+                    ]) \"../../src/times-two.c\":3\n+                 (expr_list:REG_EQUAL (ashift:SI (mem/c:SI (plus:DI (reg/f:DI virtual-stack-vars)\n+                                (const_int -4)) [1 i+0 S4 A32])\n+                        (const_int 1))\n+                    (nil)))\n+      (cinsn 10 (set (reg:SI <1> [ <retval> ])\n+                    (reg:SI <0> [ _2 ])) \"../../src/times-two.c\":3\n+                 (nil))\n+      (cinsn 14 (set (reg/i:SI ax)\n+                    (reg:SI <1> [ <retval> ])) \"../../src/times-two.c\":4\n+                 (nil))\n+      (cinsn 15 (use (reg/i:SI ax)) \"../../src/times-two.c\":4\n+                 (nil))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx \n+      (reg/i:SI ax)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"times_two\""}, {"sha": "ac822ac243ecc4588d0480aa713db6b5c101135c", "filename": "gcc/testsuite/selftests/x86_64/unspec.rtl", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Funspec.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Funspec.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fselftests%2Fx86_64%2Funspec.rtl?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -0,0 +1,20 @@\n+(function \"test_unspec\"\n+  (insn-chain\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cinsn 1 (set (mem/v:BLK (0|scratch:DI) [0  A8])\n+                    (unspec:BLK [\n+                            (mem/v:BLK (reuse_rtx 0) [0  A8])\n+                        ] UNSPEC_MEMORY_BLOCKAGE)) \"../../src/gcc/testsuite/gcc.dg/rtl/test.c\":2\n+                 (nil))\n+\n+      (cinsn 2 (set (mem/v:BLK (1|scratch:DI) [0  A8])\n+                    (unspec_volatile:BLK [\n+                            (mem/v:BLK (reuse_rtx 1) [0  A8])\n+                        ] UNSPECV_RDTSCP)) \"../../src/gcc/testsuite/gcc.dg/rtl/test.c\":2\n+                 (nil))\n+\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+) ;; function"}, {"sha": "4e47be1dc05ee7f9cbf3bc4f8b81e70d57842c91", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b861137ed73ae73e15a136949301fbaaf89202/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=51b861137ed73ae73e15a136949301fbaaf89202", "patch": "@@ -305,6 +305,11 @@ ssa_default_def (struct function *fn, tree var)\n   gcc_assert (VAR_P (var)\n \t      || TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL);\n+\n+  /* Always NULL_TREE for rtl function dumps.  */\n+  if (!fn->gimple_df)\n+    return NULL_TREE;\n+\n   in.var = (tree)&ind;\n   ind.uid = DECL_UID (var);\n   return DEFAULT_DEFS (fn)->find_with_hash ((tree)&in, DECL_UID (var));"}]}