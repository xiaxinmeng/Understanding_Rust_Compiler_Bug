{"sha": "269c14e111ebc7745eda1a98585078ccd622fb82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5YzE0ZTExMWViYzc3NDVlZGExYTk4NTg1MDc4Y2NkNjIyZmI4Mg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-03-11T21:05:49Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-03-11T21:05:49Z"}, "message": "h8300.h (SP_AND_G_REGS): Renamed from SP_AND_G_REG.\n\n\t* h8300/h8300.h (SP_AND_G_REGS): Renamed from SP_AND_G_REG.\n\t(CC_DONE_CBIT): Delete.\n\t(CC_OVERFLOW_0,CC_OVERFLOW_UNUSABLE,CC_NO_CARRY): Define.\n\t* h8300/h8300.c (cond_string): Delete CC_DONE_CBIT handling.\n\t(notice_update_cc): Delete CC_CBIT, CC_WHOOPS.  Add CC_SET_ZN_C0.\n\t(restore_compare_p): New function.\n\t(shift_one): Use shll instead of shal so overflow bit is usable.\n\tSet cc_valid bits to cc_status.flags values.\n\t(emit_a_shift): Set cc_status.flags.\n\t* h8300/h8300.md (attr cc): Delete whoops,cbit.  Add set_zn_c0.\n\t(all patterns) Update cc attr setting.\n\t(tstqi,tsthi,tstsi): Delete CC_DONE_CBIT handling.\n\t(addhi3,subhi3): Change define_expand to define_insn.\n\t(branch_true,branch_false): Check if compare needs to be restored.\n\nFrom-SVN: r11514", "tree": {"sha": "0a6168f0637dbceaa64e84f383b2c20ef4e55b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a6168f0637dbceaa64e84f383b2c20ef4e55b19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/269c14e111ebc7745eda1a98585078ccd622fb82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269c14e111ebc7745eda1a98585078ccd622fb82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269c14e111ebc7745eda1a98585078ccd622fb82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269c14e111ebc7745eda1a98585078ccd622fb82/comments", "author": null, "committer": null, "parents": [{"sha": "4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e74d8ec4b55e5a28738f5d3a2cb99335c0098f4"}], "stats": {"total": 313, "additions": 171, "deletions": 142}, "files": [{"sha": "cadff01496144249a3410c09153e323b9da81ab8", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 79, "deletions": 38, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=269c14e111ebc7745eda1a98585078ccd622fb82", "patch": "@@ -757,12 +757,8 @@ cond_string (code)\n   switch (code)\n     {\n     case NE:\n-      if (cc_prev_status.flags & CC_DONE_CBIT)\n-\treturn \"cs\";\n       return \"ne\";\n     case EQ:\n-      if (cc_prev_status.flags & CC_DONE_CBIT)\n-\treturn \"cc\";\n       return \"eq\";\n     case GE:\n       return \"ge\";\n@@ -800,8 +796,7 @@ print_operand (file, x, code)\n   /* This is used for communication between the 'P' and 'U' codes.  */\n   static char *last_p;\n \n-  /* This is used for communication between the 'Z' and 'Y' codes.  */\n-  /* ??? 'V' and 'W' use it too.  */\n+  /* This is used for communication between codes V,W,Z and Y.  */\n   static int bitint;\n \n   switch (code)\n@@ -1081,7 +1076,7 @@ print_operand (file, x, code)\n \t  switch (GET_MODE (x))\n \t    {\n \t    case QImode:\n-#if 0\t\t\t\t/* Is it asm (\"mov.b %0,r2l\", ...) */\n+#if 0 /* Is it asm (\"mov.b %0,r2l\", ...) */\n \t      fprintf (file, \"%s\", byte_reg (x, 0));\n #else /* ... or is it asm (\"mov.b %0l,r2l\", ...) */\n \t      fprintf (file, \"%s\", names_big[REGNO (x)]);\n@@ -1271,49 +1266,89 @@ notice_update_cc (body, insn)\n   switch (get_attr_cc (insn))\n     {\n     case CC_NONE:\n-      /* Insn does not affect the CC at all */\n+      /* Insn does not affect CC at all.  */\n       break;\n \n     case CC_NONE_0HIT:\n-      /* Insn does not change the CC, but the 0't operand has been changed.  */\n-\n+      /* Insn does not change CC, but the 0'th operand has been changed.  */\n       if (cc_status.value1 != 0\n \t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n-\n+      /* ??? Is value2 ever set?.  */\n       if (cc_status.value2 != 0\n \t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n \tcc_status.value2 = 0;\n-\n       break;\n \n     case CC_SET:\n-      /* Insn sets CC to recog_operand[0], but overflow is impossible.  */\n+      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+\t V is always set to 0.  C may or may not be set to 0 but that's ok\n+\t because alter_cond will change tests to use EQ/NE.  */\n       CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_OVERFLOW;\n+      cc_status.flags |= CC_OVERFLOW_0 | CC_NO_CARRY;\n       cc_status.value1 = recog_operand[0];\n       break;\n \n-    case CC_COMPARE:\n-      /* The insn is a compare instruction */\n+    case CC_SET_ZN_C0:\n+      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+\t The V flag is unusable.  The C flag may or may not be known but\n+\t that's ok because alter_cond will change tests to use EQ/NE.  */\n       CC_STATUS_INIT;\n-      cc_status.value1 = SET_SRC (body);\n+      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n+      cc_status.value1 = recog_operand[0];\n       break;\n \n-    case CC_CBIT:\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction.  */\n       CC_STATUS_INIT;\n-      cc_status.flags |= CC_DONE_CBIT;\n-      cc_status.value1 = 0;\n+      cc_status.value1 = SET_SRC (body);\n       break;\n \n-    case CC_WHOOPS:\n     case CC_CLOBBER:\n-      /* Insn clobbers CC. */\n+      /* Insn doesn't leave CC in a usable state.  */\n       CC_STATUS_INIT;\n       break;\n     }\n }\n \n+/* Return 1 if a previous compare needs to be re-issued.  This will happen\n+   if the compare was deleted because the previous insn set it, but the\n+   branch needs CC flags not set.\n+\n+   OP is the comparison being performed.  */\n+\n+int\n+restore_compare_p (op)\n+     rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+    case NE:\n+      break;\n+    case LT:\n+    case LE:\n+    case GT:\n+    case GE:\n+      if (cc_status.flags & CC_OVERFLOW_UNUSABLE)\n+\treturn 1;\n+      break;\n+    case LTU:\n+    case LEU:\n+    case GTU:\n+    case GEU:\n+      /* If the carry flag isn't usable, the test should have been changed\n+\t by alter_cond.  */\n+      if (cc_status.flags & CC_NO_CARRY)\n+\tabort ();\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  return 0;\n+}\n+\n /* Recognize valid operators for bit instructions */\n \n int\n@@ -1486,8 +1521,9 @@ enum shift_mode\n     QIshift, HIshift, SIshift\n   };\n \n-/* For single bit shift insns, record assembler and whether the condition code\n-   is valid afterwards.  */\n+/* For single bit shift insns, record assembler and what bits of the\n+   condition code are valid afterwards (represented as various CC_FOO\n+   bits, 0 means CC isn't left in a usable state).  */\n \n struct shift_insn\n {\n@@ -1507,19 +1543,19 @@ static const struct shift_insn shift_one[2][3][3] =\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shal %X0\", 1 },\n-      { \"add.w %T0,%T0\\t; shal.w\", 1 },\n+      { \"shll %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"add.w %T0,%T0\\t; shal.w\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n       { \"add.w %f0,%f0\\t; shal.l\\n\\taddx %y0,%y0\\n\\taddx %z0,%z0\\t; end shal.l\", 0 }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr %X0\", 1 },\n+      { \"shlr %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n       { \"shlr %t0\\t; shlr.w\\n\\trotxr %s0\\t; end shlr.w\", 0 },\n       { \"shlr %z0\\t; shlr.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shlr.l\", 0 }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar %X0\", 1 },\n+      { \"shar %X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n       { \"shar %t0\\t; shar.w\\n\\trotxr %s0\\t; end shar.w\", 0 },\n       { \"shar %z0\\t; shar.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shar.l\", 0 }\n     }\n@@ -1528,21 +1564,21 @@ static const struct shift_insn shift_one[2][3][3] =\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shal.b %X0\", 1 },\n-      { \"shal.w %T0\", 1 },\n-      { \"shal.l %S0\", 1 }\n+      { \"shll.b %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.w %T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.l %S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr.b %X0\", 1 },\n-      { \"shlr.w %T0\", 1 },\n-      { \"shlr.l %S0\", 1 }\n+      { \"shlr.b %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.w %T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.l %S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar.b %X0\", 1 },\n-      { \"shar.w %T0\", 1 },\n-      { \"shar.l %S0\", 1 }\n+      { \"shar.b %X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.w %T0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.l %S0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY }\n     }\n   }\n };\n@@ -1911,7 +1947,10 @@ emit_a_shift (insn, operands)\n \t  while (--n >= 0)\n \t    output_asm_insn (assembler, operands);\n \t  if (cc_valid)\n-\t    cc_status.value1 = operands[0];\n+\t    {\n+\t      cc_status.value1 = operands[0];\n+\t      cc_status.flags |= cc_valid;\n+\t    }\n \t  return \"\";\n \tcase SHIFT_ROT_AND:\n \t  {\n@@ -1934,6 +1973,7 @@ emit_a_shift (insn, operands)\n \t\t    sprintf (insn_buf, \"and #%d,%%X0\\t; end shift %d via rotate+and\",\n \t\t\t     mask, n);\n \t\t    cc_status.value1 = operands[0];\n+\t\t    cc_status.flags |= CC_OVERFLOW_0 | CC_NO_CARRY;\n \t\t    break;\n \t\t  case HImode:\n \t\t    sprintf (insn_buf, \"and #%d,%%s0\\n\\tand #%d,%%t0\\t; end shift %d via rotate+and\",\n@@ -1949,6 +1989,7 @@ emit_a_shift (insn, operands)\n \t\t\t \"bwl\"[shift_mode], mask,\n \t\t\t mode == QImode ? 'X' : mode == HImode ? 'T' : 'S');\n \t\tcc_status.value1 = operands[0];\n+\t\tcc_status.flags |= CC_OVERFLOW_0 | CC_NO_CARRY;\n \t      }\n \t    output_asm_insn (insn_buf, operands);\n \t    return \"\";"}, {"sha": "0babf4ac74a28f50226d5998cf8342bdcfb119aa", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=269c14e111ebc7745eda1a98585078ccd622fb82", "patch": "@@ -322,14 +322,18 @@ do {\t\t\t\t\\\n /* The h8 has only one kind of register, but we mustn't do byte by\n    byte operations on the sp, so we keep it as a different class */\n \n-enum reg_class { NO_REGS,  LONG_REGS, GENERAL_REGS, SP_REG, SP_AND_G_REG, ALL_REGS, LIM_REG_CLASSES };\n+enum reg_class {\n+  NO_REGS, LONG_REGS, GENERAL_REGS, SP_REG, SP_AND_G_REGS,\n+  ALL_REGS, LIM_REG_CLASSES\n+};\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n- {\"NO_REGS\",  \"LONG_REGS\",  \"GENERAL_REGS\", \"SP_REG\", \"SP_AND_G_REG\", \"ALL_REGS\", \"LIM_REGS\" }\n+{ \"NO_REGS\", \"LONG_REGS\", \"GENERAL_REGS\", \"SP_REG\", \"SP_AND_G_REGS\", \\\n+  \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -340,7 +344,7 @@ enum reg_class { NO_REGS,  LONG_REGS, GENERAL_REGS, SP_REG, SP_AND_G_REG, ALL_RE\n    0x07f,               /* LONG_REGS    */      \\\n    0x07f,\t\t/* GENERAL_REGS */\t\\\n    0x080,\t\t/* SP_REG       */     \t\\\n-   0x0ff,\t\t/* SP_AND_G_REG */     \t\\\n+   0x0ff,\t\t/* SP_AND_G_REGS */    \t\\\n    0x1ff,\t\t/* ALL_REGS \t*/\t\\\n }\n \n@@ -971,14 +975,18 @@ extern int current_function_anonymous_args;\n    Do not alter them if the instruction would not alter the cc's.  */\n \n #define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n-#define CC_DONE_CBIT 0400\n \n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \\\n-{\t\t\t\t\t\\\n-  if (cc_status.flags & CC_NO_OVERFLOW)\t\\\n-    return NO_OV;\t\t\t\\\n-  return NORMAL;\t\t\t\\\n-}\n+/* The mov,and,or,xor insns always set V to 0.  */\n+#define CC_OVERFLOW_0 0400\n+/* The add insns don't set overflow in a usable way.  */\n+#define CC_OVERFLOW_UNUSABLE 01000\n+/* The mov,and,or,xor insns don't set carry.  That's ok though as the\n+   Z bit is all we need when doing unsigned comparisons on the result of\n+   these insns (since they're always with 0).  However, conditions.h has\n+   CC_NO_OVERFLOW defined for this purpose.  Rename it to something more\n+   understandable.  */\n+#define CC_NO_CARRY CC_NO_OVERFLOW\n+/* ??? Use CC_Z_IN_NOT_C for bld insns?  */\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "a68d54cf7150f337a01cb8cac293d1050db5e548", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 74, "deletions": 94, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269c14e111ebc7745eda1a98585078ccd622fb82/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=269c14e111ebc7745eda1a98585078ccd622fb82", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for Hitachi H8/300\n-;; Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+;; Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n \n ;;   Contributed by Steve Chamberlain (sac@cygnus.com),\n ;;   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -21,7 +21,6 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n-\n ;; The original PO technology requires these to be ordered by speed,\n ;; so that assigner will pick the fastest.\n \n@@ -58,9 +57,20 @@\n \t (eq_attr \"type\" \"call\")\t(const_int 4)]\n \t(const_int 200)))\n \n-(define_attr \"cc\" \"none,clobber,none_0hit,set,compare,whoops,cbit\" \n-  (const_string \"whoops\"))\n-\n+;; Condition code settings.\n+;; none - insn does not affect cc\n+;; none_0hit - insn does not affect cc but it does modify operand 0\n+;;\tThis attribute is used to keep track of when operand 0 changes.\n+;; \tSee the description of NOTICE_UPDATE_CC for more info.\n+;; set - insn sets flags z,n.  v,c are set to 0.\n+;;\t(c may not really be set to 0 but that's ok, we don't need it anyway).\n+;; set_zn_c0 - insn sets z,n to usable values.  v is unknown.  c may or may not\n+;;\tbe known (if it isn't that's ok, we don't need it anyway).\n+;; compare - compare instruction\n+;; clobber - value of cc is unknown\n+(define_attr \"cc\" \"none,none_0hit,set,set_zn_c0,compare,clobber\"\n+  (const_string \"clobber\"))\n+\f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -82,10 +92,12 @@\n    (set (attr \"length\") (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4)))\n    (set_attr \"cc\" \"set\")])\n \n+;; ??? Use of the `c' constraint doesn't seem right.\n (define_insn \"movqi_internal\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n \t(match_operand:QI 1 \"general_operand_src\" \"I,r>,io,r,r,c\"))]\n-  \"register_operand (operands[0],QImode) || register_operand (operands[1], QImode)\"\n+  \"register_operand (operands[0],QImode)\n+   || register_operand (operands[1], QImode)\"\n   \"@\n    sub.b\t%X0,%X0\n    mov.b\t%X1,%X0\n@@ -100,7 +112,7 @@\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))\n       (const_int 4)])\n-   (set_attr \"cc\" \"set,set,set,set,set,none\")])\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set,clobber\")])\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"\")\n@@ -132,7 +144,7 @@\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set\")])\n    \n ;; movhi\n \n@@ -167,7 +179,7 @@\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"\")\n@@ -199,7 +211,7 @@\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set\")])\n \n ;; movsi\n \n@@ -380,7 +392,7 @@\n    mov.l\t%S1,%S0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"2,2,8,8,4,4\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set,set\")])\n \n (define_insn \"movsf_h8300h\"\n   [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n@@ -397,55 +409,34 @@\n    mov.l\t%S1,%S0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"2,2,8,8,4,4\")\n-   (set_attr \"cc\" \"set\")])\n-\n+   (set_attr \"cc\" \"set_zn_c0,set,set,set,set,set\")])\n+\f\n ;; ----------------------------------------------------------------------\n ;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"tstqi\"\n   [(set (cc0) (match_operand:QI 0 \"register_operand\" \"ra\"))]\n   \"\"\n-  \"*\n-{\n-  /* ??? I don't think this is right.  --Jim */\n-  if (cc_prev_status.flags & CC_DONE_CBIT)\n-    return \\\"btst\t#0,%X0\\\";\n-  else\n-    return \\\"cmp.b\t#0,%X0\\\";\n-}\"\n+  \"cmp.b\t#0,%X0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n+   (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"tsthi\"\n   [(set (cc0) (match_operand:HI 0 \"general_operand\" \"ra\"))]\n   \"\"\n-  \"*\n-{\n-  /* ??? I don't think this is right.  --Jim */\n-  if (cc_prev_status.flags & CC_DONE_CBIT)\n-    return \\\"btst\t#0,%0l\\\";\n-  else\n-    return \\\"mov.w\t%T0,%T0\\\";\n-}\"\n+  \"mov.w\t%T0,%T0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n+   (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"tstsi\"\n   [(set (cc0) (match_operand:SI 0 \"general_operand\" \"ra\"))]\n   \"TARGET_H8300H\"\n-  \"*\n-{\n-  /* ??? I don't think this is right.  --Jim */\n-  if (cc_prev_status.flags & CC_DONE_CBIT)\n-    return \\\"btst\t#0,%0l\\\";\n-  else\n-    return \\\"mov.l\t%S0,%S0\\\";\n-}\"\n+  \"mov.l\t%S0,%S0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"4\")\n+   (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"cmpqi\"\n@@ -481,7 +472,7 @@\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n-\n+\f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -494,13 +485,13 @@\n   \"add.b\t%X2,%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n-;; ??? adds operates on the 32bit register.  We can use it because we don't\n+;; h8300h: adds operates on the 32bit register.  We can use it because we don't\n ;; use the e0-7 registers.\n ;; ??? 4 can be handled in one insn on the 300h.\n \n-(define_insn \"addhi3_internal\"\n+(define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n \t\t (match_operand:HI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n@@ -514,15 +505,7 @@\n    add.w\t%T2,%T0\"\n   [(set_attr \"type\" \"arith,multi,arith,multi,multi,arith\")\n    (set_attr \"length\" \"2,4,2,4,4,2\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,set\")])\n-\n-;; ??? Why is this here?\n-(define_expand \"addhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,set_zn_c0\")])\n \n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -562,7 +545,7 @@\n    add.l\t%S2,%S0\"\n   [(set_attr \"type\" \"multi,multi,multi,multi,arith,arith\")\n    (set_attr \"length\" \"2,4,2,4,6,2\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,clobber\")])\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,set_zn_c0,set_zn_c0\")])\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n@@ -578,15 +561,15 @@\n    add.b\t%G2,%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n-;; ??? subs operates on the 32bit register.  We can use it because we don't\n+;; h8300h: subs operates on the 32bit register.  We can use it because we don't\n ;; use the e0-7 registers.\n ;; ??? 4 can be handled in one insn on the 300h.\n ;; ??? The fourth alternative can use sub.w on the 300h.\n ;; ??? Should the 'n' constraint be an 'i' here?\n \n-(define_insn \"subhi3_internal\"\n+(define_insn \"subhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n \t\t  (match_operand:HI 2 \"nonmemory_operand\" \"K,M,ra,n\")))]\n@@ -598,15 +581,7 @@\n    add.b\t%E2,%s0\\;addx\t%F2,%t0 ; -%0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2,4,2,4\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,set,clobber\")])\n-\n-;; ??? Why is this here?\n-(define_expand \"subhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,set_zn_c0,clobber\")])\n \n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -639,8 +614,8 @@\n    sub.l\t%S2,%S0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2,4,2,6\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,set,set\")])\n-\n+   (set_attr \"cc\" \"none_0hit,none_0hit,set_zn_c0,set_zn_c0\")])\n+\f\n ;; ----------------------------------------------------------------------\n ;; MULTIPLY INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -655,7 +630,7 @@\n   \"mulxs.b\t%X2,%T0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n (define_insn \"mulhisi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -665,7 +640,7 @@\n   \"mulxs.w\t%T2,%S0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n (define_insn \"umulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -776,7 +751,7 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"clobber\")])\n-\n+\f\n ;; ----------------------------------------------------------------------\n ;; AND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -805,6 +780,7 @@\n }\")\n \n ;; ??? Should have a bclr case here also.\n+;; ??? This should be symmetric with iorhi3.\n \n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -840,7 +816,7 @@\n    and\t%S2,%S0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"4,6\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"set\")])\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n@@ -870,6 +846,7 @@\n }\")\n \n ;; ??? Should have a bset case here also.\n+;; ??? This should be symmetric with andhi3.\n \n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n@@ -960,6 +937,8 @@\n     DONE;\n }\")\n \n+;; ??? This should be symmetric with andhi3.\n+\n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n@@ -988,8 +967,8 @@\n    xor\t%S2,%S0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"4,6\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n+   (set_attr \"cc\" \"set\")])\n+\f\n ;; ----------------------------------------------------------------------\n ;; NEGATION INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -1001,7 +980,7 @@\n   \"neg\t%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n (define_expand \"neghi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -1032,7 +1011,7 @@\n   \"neg\t%T0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n (define_expand \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1063,7 +1042,7 @@\n   \"neg\t%S0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS\n@@ -1108,7 +1087,7 @@\n ;; ??? length is wrong for 300h\n    (set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n-\n+\f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -1214,6 +1193,11 @@\n   \"\"\n   \"*\n {\n+  /* If we erroneously deleted a compare insn (which can happen if we need\n+     CC bits set that aren't), emit the compare.  */\n+  if (restore_compare_p (operands[1]))\n+    return 0;\n+\n   if (get_attr_length (insn) == 2) \n     return \\\"b%j1\t%l0\\\";\n   else if (get_attr_length (insn) == 4) \n@@ -1234,6 +1218,11 @@\n ;; ??? We don't take advantage of 16 bit relative jumps in the 300h.\n   \"*\n {\n+  /* If we erroneously deleted a compare insn (which can happen if we need\n+     CC bits set that aren't), emit the compare.  */\n+  if (restore_compare_p (operands[1]))\n+    return 0;\n+\n   if (get_attr_length (insn) == 2) \n     return \\\"b%k1\t%l0\\\";\n   else if (get_attr_length (insn) == 4) \n@@ -1290,14 +1279,6 @@\n \n ;; This is a define expand, because pointers may be either 16 or 32 bits.\n \n-;(define_insn \"indirect_jump\"\n-;  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n-;  \"\"\n-;  \"jmp\t@%0\"\n-;  [(set_attr \"type\" \"branch\")\n-;   (set_attr \"cc\" \"none\")\n-;   (set_attr \"length\" \"2\")])\n-\n (define_expand \"indirect_jump\"\n   [(set (pc) (match_operand 0 \"jump_address_operand\" \"Vr\"))]\n   \"\"\n@@ -1358,7 +1339,7 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n-\n+\f\n ;; ----------------------------------------------------------------------\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -1481,7 +1462,7 @@\n }\"\n   [(set_attr \"length\" \"10\")\n    (set_attr \"cc\" \"clobber\")])\n-\n+\f\n ;; ----------------------------------------------------------------------\n ;; SHIFTS\n ;; ----------------------------------------------------------------------\n@@ -1626,12 +1607,12 @@\n ;; However, for cases that loop or are done in pieces, cc does not contain\n ;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n-\n+\f\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------\n ;; The H8/300 has given 1/8th of its opcode space to bitfield\n-;; instructions so let's use them as well as we can\n+;; instructions so let's use them as well as we can.\n \n ;; BCC and BCS patterns.\n \n@@ -1912,7 +1893,7 @@\n       operands[1] = mem;\n     }\n }\")\n-\n+\f\n ;; -----------------------------------------------------------------\n ;; STACK POINTER MANIPULATIONS\n ;; -----------------------------------------------------------------\n@@ -1931,7 +1912,7 @@\n   \"mov.w\t%T1,%T0\\;add.w\t%T2,%T0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"set_zn_c0\")])\n \n \n ;; -------------------------------------------\n@@ -1981,7 +1962,7 @@\n \n \tDONE;\t\n }\")\n-\n+\f\n ;; ----------------------------------------------\n ;; Peepholes go at the end.\n ;; ----------------------------------------------\n@@ -2086,7 +2067,6 @@\n   \"\"\n   \"mov.b\t%X2,%X0\\;bset\t%X1,%X0\")\t\n \n-\n (define_insn \"fancybclr4\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=Ur,Ur\")\n \t(and:QI "}]}