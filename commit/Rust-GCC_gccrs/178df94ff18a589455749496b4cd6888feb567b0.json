{"sha": "178df94ff18a589455749496b4cd6888feb567b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc4ZGY5NGZmMThhNTg5NDU1NzQ5NDk2YjRjZDY4ODhmZWI1NjdiMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-08-03T13:34:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-08-03T13:34:49Z"}, "message": "cfgloop.h (DLTHE_FLAG_COMPLETTE_PEEL): New flag.\n\n\n\t* cfgloop.h (DLTHE_FLAG_COMPLETTE_PEEL): New flag.\n\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Special case\n\tprofile updating for complette unrolling.\n\t* loop-unroll.c (peel_loop_completely): Use it.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n\t(tree_unroll_loops_completely): Disable code growing unrolling of cold\n\tloops.\n\n\t* update-conroll.c: New testcase.\n\t* update-conroll-2.c: New testcase.\n\nFrom-SVN: r102687", "tree": {"sha": "1a926b9bc202452ffb1c89f9db59da5c72ea357e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a926b9bc202452ffb1c89f9db59da5c72ea357e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/178df94ff18a589455749496b4cd6888feb567b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178df94ff18a589455749496b4cd6888feb567b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/178df94ff18a589455749496b4cd6888feb567b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178df94ff18a589455749496b4cd6888feb567b0/comments", "author": null, "committer": null, "parents": [{"sha": "4164b2fb1628493c3b529b1e9ee045a504f44a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4164b2fb1628493c3b529b1e9ee045a504f44a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4164b2fb1628493c3b529b1e9ee045a504f44a0e"}], "stats": {"total": 100, "additions": 96, "deletions": 4}, "files": [{"sha": "21d87f21c64ba0fc19a2c7c4e30138b9a0c9a567", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -1,3 +1,13 @@\n+2005-08-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgloop.h (DLTHE_FLAG_COMPLETTE_PEEL): New flag.\n+\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Special case\n+\tprofile updating for complette unrolling.\n+\t* loop-unroll.c (peel_loop_completely): Use it.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n+\t(tree_unroll_loops_completely): Disable code growing unrolling of cold\n+\tloops.\n+\n 2005-08-03  Paul Brook  <paul@codesourcery.com>\n \n \t* combine.c (can_change_dest_mode): New function."}, {"sha": "0bfb8d87a9ead64c079c7a5e75b8befbd180c924", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -298,6 +298,8 @@ extern bool can_duplicate_loop_p (struct loop *loop);\n \t\t\t\t\t   duplicate_loop_to_header_edge.  */\n #define DLTHE_RECORD_COPY_NUMBER 2\t/* Record copy number in the aux\n \t\t\t\t\t   field of newly create BB.  */\n+#define DLTHE_FLAG_COMPLETTE_PEEL 4\t/* Update frequencies expecting\n+\t\t\t\t\t   a complette peeling. */\n \n extern struct loop * duplicate_loop (struct loops *, struct loop *,\n \t\t\t\t     struct loop *);"}, {"sha": "1e364279403f5af27fd3fa00dfd7f8373a678ad5", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -913,7 +913,28 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t\t\t\t? prob_pass_wont_exit\n \t\t\t\t: prob_pass_thru;\n \n-      if (is_latch)\n+      /* Complette peeling is special as the probability of exit in last\n+         copy becomes 1.  */\n+      if (flags & DLTHE_FLAG_COMPLETTE_PEEL)\n+\t{\n+\t  int wanted_freq = EDGE_FREQUENCY (e);\n+\n+\t  if (wanted_freq > freq_in)\n+\t    wanted_freq = freq_in;\n+\n+\t  gcc_assert (!is_latch);\n+\t  /* First copy has frequency of incomming edge.  Each subseqeuent\n+\t     frequency should be reduced by prob_pass_wont_exit.  Caller\n+\t     should've managed the flags so all except for original loop\n+\t     has won't exist set.  */\n+\t  scale_act = RDIV (wanted_freq * REG_BR_PROB_BASE, freq_in);\n+\t  /* Now simulate the duplication adjustments and compute header\n+\t     frequency of the last copy.  */\n+\t  for (i = 0; i < ndupl; i++)\n+            wanted_freq = RDIV (wanted_freq * scale_step[i], REG_BR_PROB_BASE);\n+\t  scale_main = RDIV (wanted_freq * REG_BR_PROB_BASE, freq_in);\n+\t}\n+      else if (is_latch)\n \t{\n \t  prob_pass_main = TEST_BIT (wont_exit, 0)\n \t\t\t\t? prob_pass_wont_exit"}, {"sha": "8293448f5cff7ed77be9c19ed5dc8db1ed7bb1ce", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -520,6 +520,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \t\t\t\t\t  wont_exit, desc->out_edge,\n \t\t\t\t\t  remove_edges, &n_remove_edges,\n \t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ\n+\t\t\t\t\t  | DLTHE_FLAG_COMPLETTE_PEEL\n \t\t\t\t\t  | (opt_info\n \t\t\t\t\t     ? DLTHE_RECORD_COPY_NUMBER : 0));\n       gcc_assert (ok);"}, {"sha": "e571c94ecab10a0111d70ba4c20b282e3e4158c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -1,3 +1,8 @@\n+2005-08-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* update-conroll.c: New testcase.\n+\t* update-conroll-2.c: New testcase.\n+\n 2005-08-02  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gfortran.dg/constant_substring.f: New test."}, {"sha": "d559b924535e2cd9830c1a5bc2738eccc4c0dda2", "filename": "gcc/testsuite/gcc.dg/tree-prof/update-cunroll-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-cunroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-cunroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-cunroll-2.c?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -0,0 +1,21 @@\n+\n+/* { dg-options \"-O2 -fdump-tree-optimized-blocks\" } */\n+int a[8];\n+__attribute__ ((noinline))\n+int t()\n+{\n+\tint i;\n+\tfor (i = 0; i < 3; i++)\n+\t\tif (a[i])\n+\t\t\tbreak;\n+\treturn i;\n+}\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1000; i++)\n+    t ();\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7a114ea3a9c0d92826d0a72149ed116d27c35465", "filename": "gcc/testsuite/gcc.dg/tree-ssa/update-cunroll.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-cunroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-cunroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-cunroll.c?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int a[8];\n+int t()\n+{\n+\tint i;\n+\tfor (i = 0; i < 3; i++)\n+\t\tif (a[i])\n+\t\t\tbreak;\n+\treturn i;\n+}\n+/* { dg-final { scan-tree-dump-times \".optimized\" 0 \"Invalid sum\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "4ac20039f4c5ef1258ec7529eaff1b17ee90053c", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178df94ff18a589455749496b4cd6888feb567b0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=178df94ff18a589455749496b4cd6888feb567b0", "patch": "@@ -223,20 +223,35 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n     \n   if (n_unroll)\n     {\n+      sbitmap wont_exit;\n+      edge *edges_to_remove = xmalloc (sizeof (edge *) * n_unroll);\n+      unsigned int n_to_remove = 0;\n+\n       old_cond = COND_EXPR_COND (cond);\n       COND_EXPR_COND (cond) = dont_exit;\n       update_stmt (cond);\n       initialize_original_copy_tables ();\n \n+      wont_exit = sbitmap_alloc (n_unroll + 1);\n+      sbitmap_ones (wont_exit);\n+      RESET_BIT (wont_exit, 0);\n+\n       if (!tree_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t       loops, n_unroll, NULL,\n-\t\t\t\t\t       NULL, NULL, NULL, 0))\n+\t\t\t\t\t       loops, n_unroll, wont_exit,\n+\t\t\t\t\t       exit, edges_to_remove,\n+\t\t\t\t\t       &n_to_remove,\n+\t\t\t\t\t       DLTHE_FLAG_UPDATE_FREQ\n+\t\t\t\t\t       | DLTHE_FLAG_COMPLETTE_PEEL))\n \t{\n \t  COND_EXPR_COND (cond) = old_cond;\n \t  update_stmt (cond);\n           free_original_copy_tables ();\n+\t  free (wont_exit);\n+\t  free (edges_to_remove);\n \t  return false;\n \t}\n+      free (wont_exit);\n+      free (edges_to_remove);\n       free_original_copy_tables ();\n     }\n   \n@@ -350,7 +365,7 @@ tree_unroll_loops_completely (struct loops *loops, bool may_increase_size)\n   unsigned i;\n   struct loop *loop;\n   bool changed = false;\n-  enum unroll_level ul = may_increase_size ? UL_ALL : UL_NO_GROWTH;\n+  enum unroll_level ul;\n \n   for (i = 1; i < loops->num; i++)\n     {\n@@ -359,6 +374,10 @@ tree_unroll_loops_completely (struct loops *loops, bool may_increase_size)\n       if (!loop)\n \tcontinue;\n \n+      if (may_increase_size && maybe_hot_bb_p (loop->header))\n+\tul = UL_ALL;\n+      else\n+\tul = UL_NO_GROWTH;\n       changed |= canonicalize_loop_induction_variables (loops, loop,\n \t\t\t\t\t\t\tfalse, ul,\n \t\t\t\t\t\t\t!flag_tree_loop_ivcanon);"}]}