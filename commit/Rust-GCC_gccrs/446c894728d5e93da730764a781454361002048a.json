{"sha": "446c894728d5e93da730764a781454361002048a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ2Yzg5NDcyOGQ1ZTkzZGE3MzA3NjRhNzgxNDU0MzYxMDAyMDQ4YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T22:48:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T22:48:01Z"}, "message": "(FLO_union_type): Remove bitfields to set sign...\n\n(FLO_union_type): Remove bitfields to set sign, exponent, and\nmantissa, and add value_raw field, which is an integer of the\nappropriate type.  If _DEBUG_BITFLOAT is defined, provide little and\nbig endian bitfields.\n(pack_d, unpack_d): Switch to use value_raw and explicit shifts and\nmasks so that we don't have to worry about whether the target is big\nor little endian.  If single precision floating point, rename to\npack_f and unpack_f, so there is no confusion in the debugger.\n\nFrom-SVN: r10312", "tree": {"sha": "74c6739938092fc938b782a4ca8a61f13b76ea16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74c6739938092fc938b782a4ca8a61f13b76ea16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/446c894728d5e93da730764a781454361002048a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446c894728d5e93da730764a781454361002048a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/446c894728d5e93da730764a781454361002048a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446c894728d5e93da730764a781454361002048a/comments", "author": null, "committer": null, "parents": [{"sha": "692ce0fd55f4b1c5294371884ad1db1843069a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692ce0fd55f4b1c5294371884ad1db1843069a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692ce0fd55f4b1c5294371884ad1db1843069a26"}], "stats": {"total": 81, "additions": 49, "deletions": 32}, "files": [{"sha": "3c17f402e232186cafa3bdb38ba78ac257e6e867", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/446c894728d5e93da730764a781454361002048a/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/446c894728d5e93da730764a781454361002048a/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=446c894728d5e93da730764a781454361002048a", "patch": "@@ -2,7 +2,7 @@\n    the floating point routines in libgcc1.c for targets without hardware\n    floating point.  */\n \n-/* Copyright (C) 1994 Free Software Foundation, Inc.\n+/* Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -99,6 +99,8 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\tdefine FRAC_NBITS 32\n #\tdefine FRACHIGH  0x80000000L\n #\tdefine FRACHIGH2 0xc0000000L\n+#\tdefine pack_d pack_f\n+#\tdefine unpack_d unpack_f\n \ttypedef USItype fractype;\n \ttypedef UHItype halffractype;\n \ttypedef SFtype FLO_type;\n@@ -239,22 +241,27 @@ typedef struct\n typedef union\n {\n   FLO_type value;\n+  fractype value_raw;\n+\n #ifdef _DEBUG_BITFLOAT\n-  int l[2];\n-#endif\n+  halffractype l[2];\n+\n   struct\n     {\n-#ifndef FLOAT_BIT_ORDER_MISMATCH\n       unsigned int sign:1 __attribute__ ((packed));\n       unsigned int exp:EXPBITS __attribute__ ((packed));\n       fractype fraction:FRACBITS __attribute__ ((packed));\n-#else\n+    }\n+  bits_big_endian;\n+\n+  struct\n+    {\n       fractype fraction:FRACBITS __attribute__ ((packed));\n       unsigned int exp:EXPBITS __attribute__ ((packed));\n       unsigned int sign:1 __attribute__ ((packed));\n-#endif\n     }\n-  bits;\n+  bits_little_endian;\n+#endif\n }\n FLO_union_type;\n \n@@ -314,31 +321,31 @@ pack_d ( fp_number_type *  src)\n {\n   FLO_union_type dst;\n   fractype fraction = src->fraction.ll;\t/* wasn't unsigned before? */\n-\n-  dst.bits.sign = src->sign;\n+  int sign = src->sign;\n+  int exp = 0;\n \n   if (isnan (src))\n     {\n-      dst.bits.exp = EXPMAX;\n-      dst.bits.fraction = src->fraction.ll;\n+      exp = EXPMAX;\n       if (src->class == CLASS_QNAN || 1)\n \t{\n-\t  dst.bits.fraction |= QUIET_NAN;\n+\t  fraction |= QUIET_NAN;\n \t}\n     }\n   else if (isinf (src))\n     {\n-      dst.bits.exp = EXPMAX;\n-      dst.bits.fraction = 0;\n+      exp = EXPMAX;\n+      fraction = 0;\n     }\n   else if (iszero (src))\n     {\n-      dst.bits.exp = 0;\n-      dst.bits.fraction = 0;\n+      exp = 0;\n+      fraction = 0;\n     }\n   else if (fraction == 0)\n     {\n-      dst.value = 0;\n+      exp = 0;\n+      sign = 0;\n     }\n   else\n     {\n@@ -350,7 +357,7 @@ pack_d ( fp_number_type *  src)\n \n \t  int shift = NORMAL_EXPMIN - src->normal_exp;\n \n-\t  dst.bits.exp = 0;\n+\t  exp = 0;\n \n \t  if (shift > FRAC_NBITS - NGARDS)\n \t    {\n@@ -363,16 +370,15 @@ pack_d ( fp_number_type *  src)\n \t      fraction >>= shift;\n \t    }\n \t  fraction >>= NGARDS;\n-\t  dst.bits.fraction = fraction;\n \t}\n       else if (src->normal_exp > EXPBIAS)\n \t{\n-\t  dst.bits.exp = EXPMAX;\n-\t  dst.bits.fraction = 0;\n+\t  exp = EXPMAX;\n+\t  fraction = 0;\n \t}\n       else\n \t{\n-\t  dst.bits.exp = src->normal_exp + EXPBIAS;\n+\t  exp = src->normal_exp + EXPBIAS;\n \t  /* IF the gard bits are the all zero, but the first, then we're\n \t     half way between two numbers, choose the one which makes the\n \t     lsb of the answer 0.  */\n@@ -389,22 +395,33 @@ pack_d ( fp_number_type *  src)\n \t  if (fraction >= IMPLICIT_2)\n \t    {\n \t      fraction >>= 1;\n-\t      dst.bits.exp += 1;\n+\t      exp += 1;\n \t    }\n \t  fraction >>= NGARDS;\n-\t  dst.bits.fraction = fraction;\n \t}\n     }\n+\n+  /* We previously used bitfields to store the number, but this doesn't\n+     handle little/big endian systems conviently, so use shifts and\n+     masks */\n+  dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);\n+  dst.value_raw |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << FRACBITS;\n+  dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);\n   return dst.value;\n }\n \n static void\n unpack_d (FLO_union_type * src, fp_number_type * dst)\n {\n-  fractype fraction = src->bits.fraction;\n-\n-  dst->sign = src->bits.sign;\n-  if (src->bits.exp == 0)\n+  /* We previously used bitfields to store the number, but this doesn't\n+     handle little/big endian systems conviently, so use shifts and\n+     masks */\n+  fractype fraction = src->value_raw & ((((fractype)1) << FRACBITS) - (fractype)1);\n+  int exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);\n+  int sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;\n+\n+  dst->sign = sign;\n+  if (exp == 0)\n     {\n       /* Hmm.  Looks like 0 */\n       if (fraction == 0)\n@@ -417,7 +434,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t  /* Zero exponent with non zero fraction - it's denormalized,\n \t     so there isn't a leading implicit one - we'll shift it so\n \t     it gets one.  */\n-\t  dst->normal_exp = src->bits.exp - EXPBIAS + 1;\n+\t  dst->normal_exp = exp - EXPBIAS + 1;\n \t  fraction <<= NGARDS;\n \n \t  dst->class = CLASS_NUMBER;\n@@ -431,7 +448,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t  dst->fraction.ll = fraction;\n \t}\n     }\n-  else if (src->bits.exp == EXPMAX)\n+  else if (exp == EXPMAX)\n     {\n       /* Huge exponent*/\n       if (fraction == 0)\n@@ -442,7 +459,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n       else\n \t{\n \t  /* Non zero fraction, means nan */\n-\t  if (dst->sign)\n+\t  if (sign)\n \t    {\n \t      dst->class = CLASS_SNAN;\n \t    }\n@@ -457,7 +474,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n   else\n     {\n       /* Nothing strange about this number */\n-      dst->normal_exp = src->bits.exp - EXPBIAS;\n+      dst->normal_exp = exp - EXPBIAS;\n       dst->class = CLASS_NUMBER;\n       dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;\n     }"}]}