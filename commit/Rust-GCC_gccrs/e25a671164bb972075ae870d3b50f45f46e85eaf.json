{"sha": "e25a671164bb972075ae870d3b50f45f46e85eaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1YTY3MTE2NGJiOTcyMDc1YWU4NzBkM2I1MGY0NWY0NmU4NWVhZg==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-01-03T00:56:35Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-01-03T00:56:35Z"}, "message": "dumpfile.c (dump_loc): Print filename with location.\n\n2013-01-02  Teresa Johnson  <tejohnson@google.com>\n\n\t* dumpfile.c (dump_loc): Print filename with location.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Use\n        new location_t parameter to emit complete unroll message with\n        new dump framework.\n\t(canonicalize_loop_induction_variables): Compute loops location\n        and pass to try_unroll_loop_completely.\n\t* loop-unroll.c (report_unroll_peel): New function.\n\t(peel_loops_completely): Use new dump format with location\n        for main dumpfile message, and invoke report_unroll_peel on success.\n\t(decide_unrolling_and_peeling): Ditto.\n\t(decide_peel_once_rolling): Remove old dumpfile message subsumed\n        by report_unroll_peel.\n\t(decide_peel_completely): Ditto.\n\t(decide_unroll_constant_iterations): Ditto.\n\t(decide_unroll_runtime_iterations): Ditto.\n\t(decide_peel_simple): Ditto.\n\t(decide_unroll_stupid): Ditto.\n\t* cfgloop.c (get_loop_location): New function.\n\t* cfgloop.h (get_loop_location): Declare.\n\n        testsuite/\n\t* gcc.dg/tree-ssa/loop-1.c: Update expected dump message.\n\t* gcc.dg/tree-ssa/loop-23.c: Ditto.\n\t* gcc.dg/tree-ssa/cunroll-1.c: Ditto.\n\t* gcc.dg/tree-ssa/cunroll-2.c: Ditto.\n\t* gcc.dg/tree-ssa/cunroll-3.c: Ditto.\n\t* gcc.dg/tree-ssa/cunroll-4.c: Ditto.\n\t* gcc.dg/tree-ssa/cunroll-5.c: Ditto.\n\t* gcc.dg/unroll_1.c: Ditto.\n\t* gcc.dg/unroll_2.c: Ditto.\n\t* gcc.dg/unroll_3.c: Ditto.\n\t* gcc.dg/unroll_4.c: Ditto.\n\nFrom-SVN: r194829", "tree": {"sha": "30f5b42d2bf373055b9ccc82406aaf7132d801d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30f5b42d2bf373055b9ccc82406aaf7132d801d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e25a671164bb972075ae870d3b50f45f46e85eaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25a671164bb972075ae870d3b50f45f46e85eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25a671164bb972075ae870d3b50f45f46e85eaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25a671164bb972075ae870d3b50f45f46e85eaf/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "778786217358981221cea14a4c543eaa5fba2221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/778786217358981221cea14a4c543eaa5fba2221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/778786217358981221cea14a4c543eaa5fba2221"}], "stats": {"total": 252, "additions": 202, "deletions": 50}, "files": [{"sha": "a6c85b730cb1577d8177039400b8a0ce8e00dc30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -1,3 +1,38 @@\n+2013-01-02  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* dumpfile.c (dump_loc): Print filename with location.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Use\n+\tnew location_t parameter to emit complete unroll message with\n+\tnew dump framework.\n+\t(canonicalize_loop_induction_variables): Compute loops location\n+\tand pass to try_unroll_loop_completely.\n+\t* loop-unroll.c (report_unroll_peel): New function.\n+\t(peel_loops_completely): Use new dump format with location\n+\tfor main dumpfile message, and invoke report_unroll_peel on success.\n+\t(decide_unrolling_and_peeling): Ditto.\n+\t(decide_peel_once_rolling): Remove old dumpfile message subsumed\n+\tby report_unroll_peel.\n+\t(decide_peel_completely): Ditto.\n+\t(decide_unroll_constant_iterations): Ditto.\n+\t(decide_unroll_runtime_iterations): Ditto.\n+\t(decide_peel_simple): Ditto.\n+\t(decide_unroll_stupid): Ditto.\n+\t* cfgloop.c (get_loop_location): New function.\n+\t* cfgloop.h (get_loop_location): Declare.\n+\n+\ttestsuite/\n+\t* gcc.dg/tree-ssa/loop-1.c: Update expected dump message.\n+\t* gcc.dg/tree-ssa/loop-23.c: Ditto.\n+\t* gcc.dg/tree-ssa/cunroll-1.c: Ditto.\n+\t* gcc.dg/tree-ssa/cunroll-2.c: Ditto.\n+\t* gcc.dg/tree-ssa/cunroll-3.c: Ditto.\n+\t* gcc.dg/tree-ssa/cunroll-4.c: Ditto.\n+\t* gcc.dg/tree-ssa/cunroll-5.c: Ditto.\n+\t* gcc.dg/unroll_1.c: Ditto.\n+\t* gcc.dg/unroll_2.c: Ditto.\n+\t* gcc.dg/unroll_3.c: Ditto.\n+\t* gcc.dg/unroll_4.c: Ditto.\n+\n 2013-01-02  Sriraman Tallam  <tmsriram@google.com>\n \n \t* config/i386/i386.c (fold_builtin_cpu): Remove unnecessary checks for"}, {"sha": "c15e64945f4c78178cf9bb60df5cecb9334b0221", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -1666,3 +1666,55 @@ loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n \n   return false;\n }\n+\n+/* Return location corresponding to the loop control condition if possible.  */\n+\n+location_t\n+get_loop_location (struct loop *loop)\n+{\n+  rtx insn = NULL;\n+  struct niter_desc *desc = NULL;\n+  edge exit;\n+\n+  /* For a for or while loop, we would like to return the location\n+     of the for or while statement, if possible.  To do this, look\n+     for the branch guarding the loop back-edge.  */\n+\n+  /* If this is a simple loop with an in_edge, then the loop control\n+     branch is typically at the end of its source.  */\n+  desc = get_simple_loop_desc (loop);\n+  if (desc->in_edge)\n+    {\n+      FOR_BB_INSNS_REVERSE (desc->in_edge->src, insn)\n+        {\n+          if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n+            return INSN_LOCATION (insn);\n+        }\n+    }\n+  /* If loop has a single exit, then the loop control branch\n+     must be at the end of its source.  */\n+  if ((exit = single_exit (loop)))\n+    {\n+      FOR_BB_INSNS_REVERSE (exit->src, insn)\n+        {\n+          if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n+            return INSN_LOCATION (insn);\n+        }\n+    }\n+  /* Next check the latch, to see if it is non-empty.  */\n+  FOR_BB_INSNS_REVERSE (loop->latch, insn)\n+    {\n+      if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n+        return INSN_LOCATION (insn);\n+    }\n+  /* Finally, if none of the above identifies the loop control branch,\n+     return the first location in the loop header.  */\n+  FOR_BB_INSNS (loop->header, insn)\n+    {\n+      if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n+        return INSN_LOCATION (insn);\n+    }\n+  /* If all else fails, simply return the current function location.  */\n+  return DECL_SOURCE_LOCATION (current_function_decl);\n+}\n+"}, {"sha": "81e70d859c4ceb4cb0e1dd310b01a308ea51fc10", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -239,6 +239,7 @@ extern bool loop_exit_edge_p (const struct loop *, const_edge);\n extern bool loop_exits_to_bb_p (struct loop *, basic_block);\n extern bool loop_exits_from_bb_p (struct loop *, basic_block);\n extern void mark_loop_exit_edges (void);\n+extern location_t get_loop_location (struct loop *loop);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);"}, {"sha": "7e1d6d7c5995917334ad3158cbe4c90f062a943d", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -265,7 +265,9 @@ dump_loc (int dump_kind, FILE *dfile, source_location loc)\n                  DECL_SOURCE_FILE (current_function_decl),\n                  DECL_SOURCE_LINE (current_function_decl));\n      else\n-        fprintf (dfile, \"\\n%d: \", LOCATION_LINE (loc));\n+        fprintf (dfile, \"\\n%s:%d: note: \",\n+                 LOCATION_FILE (loc),\n+                 LOCATION_LINE (loc));\n     }\n }\n "}, {"sha": "39a7b80bdb353d83f46c5de8dc96434eac0b9c89", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -148,6 +148,61 @@ static void combine_var_copies_in_loop_exit (struct var_to_expand *,\n \t\t\t\t\t     basic_block);\n static rtx get_expansion (struct var_to_expand *);\n \n+/* Emit a message summarizing the unroll or peel that will be\n+   performed for LOOP, along with the loop's location LOCUS, if\n+   appropriate given the dump or -fopt-info settings.  */\n+\n+static void\n+report_unroll_peel (struct loop *loop, location_t locus)\n+{\n+  struct niter_desc *desc;\n+  int niters = 0;\n+  int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;\n+\n+  if (!dump_enabled_p ())\n+    return;\n+\n+  /* In the special case where the loop never iterated, emit\n+     a different message so that we don't report an unroll by 0.\n+     This matches the equivalent message emitted during tree unrolling.  */\n+  if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY\n+      && !loop->lpt_decision.times)\n+    {\n+      dump_printf_loc (report_flags, locus,\n+                       \"Turned loop into non-loop; it never loops.\\n\");\n+      return;\n+    }\n+\n+  desc = get_simple_loop_desc (loop);\n+\n+  if (desc->const_iter)\n+    niters = desc->niter;\n+  else if (loop->header->count)\n+    niters = expected_loop_iterations (loop);\n+\n+  dump_printf_loc (report_flags, locus,\n+                   \"%s loop %d times\",\n+                   (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY\n+                    ?  \"Completely unroll\"\n+                    : (loop->lpt_decision.decision == LPT_PEEL_SIMPLE\n+                       ? \"Peel\" : \"Unroll\")),\n+                   loop->lpt_decision.times);\n+  if (profile_info)\n+    dump_printf (report_flags,\n+                 \" (header execution count %d\",\n+                 (int)loop->header->count);\n+  if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n+    dump_printf (report_flags,\n+                 \"%s%s iterations %d)\",\n+                 profile_info ? \", \" : \" (\",\n+                 desc->const_iter ? \"const\" : \"average\",\n+                 niters);\n+  else if (profile_info)\n+    dump_printf (report_flags, \")\");\n+\n+  dump_printf (report_flags, \"\\n\");\n+}\n+\n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n void\n unroll_and_peel_loops (int flags)\n@@ -234,11 +289,13 @@ peel_loops_completely (int flags)\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       loop->lpt_decision.decision = LPT_NONE;\n+      location_t locus = get_loop_location (loop);\n \n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"\\n;; *** Considering loop %d for complete peeling ***\\n\",\n-\t\t loop->num);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (TDF_RTL, locus,\n+                         \";; *** Considering loop %d at BB %d for \"\n+                         \"complete peeling ***\\n\",\n+                         loop->num, loop->header->index);\n \n       loop->ninsns = num_loop_insns (loop);\n \n@@ -248,6 +305,7 @@ peel_loops_completely (int flags)\n \n       if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n \t{\n+\t  report_unroll_peel (loop, locus);\n \t  peel_loop_completely (loop);\n #ifdef ENABLE_CHECKING\n \t  verify_loop_structure ();\n@@ -267,9 +325,13 @@ decide_unrolling_and_peeling (int flags)\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       loop->lpt_decision.decision = LPT_NONE;\n+      location_t locus = get_loop_location (loop);\n \n-      if (dump_file)\n-\tfprintf (dump_file, \"\\n;; *** Considering loop %d ***\\n\", loop->num);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (TDF_RTL, locus,\n+                         \";; *** Considering loop %d at BB %d for \"\n+                         \"unrolling and peeling ***\\n\",\n+                         loop->num, loop->header->index);\n \n       /* Do not peel cold areas.  */\n       if (optimize_loop_for_size_p (loop))\n@@ -309,6 +371,8 @@ decide_unrolling_and_peeling (int flags)\n \tdecide_unroll_stupid (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n \tdecide_peel_simple (loop, flags);\n+\n+      report_unroll_peel (loop, locus);\n     }\n }\n \n@@ -348,8 +412,6 @@ decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n     }\n \n   /* Success.  */\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to peel exactly once rolling loop\\n\");\n   loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n }\n \n@@ -429,8 +491,6 @@ decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n     }\n \n   /* Success.  */\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to peel loop completely\\n\");\n   loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n }\n \n@@ -608,10 +668,6 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n \n   loop->lpt_decision.decision = LPT_UNROLL_CONSTANT;\n   loop->lpt_decision.times = best_unroll;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to unroll the loop %d times (%d copies).\\n\",\n-\t     loop->lpt_decision.times, best_copies);\n }\n \n /* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES times.\n@@ -893,10 +949,6 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n \n   loop->lpt_decision.decision = LPT_UNROLL_RUNTIME;\n   loop->lpt_decision.times = i - 1;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to unroll the loop %d times.\\n\",\n-\t     loop->lpt_decision.times);\n }\n \n /* Splits edge E and inserts the sequence of instructions INSNS on it, and\n@@ -1305,10 +1357,6 @@ decide_peel_simple (struct loop *loop, int flags)\n   /* Success.  */\n   loop->lpt_decision.decision = LPT_PEEL_SIMPLE;\n   loop->lpt_decision.times = npeel;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to simply peel the loop %d times.\\n\",\n-\t     loop->lpt_decision.times);\n }\n \n /* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation does this:\n@@ -1460,10 +1508,6 @@ decide_unroll_stupid (struct loop *loop, int flags)\n \n   loop->lpt_decision.decision = LPT_UNROLL_STUPID;\n   loop->lpt_decision.times = i - 1;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Decided to unroll the loop stupidly %d times.\\n\",\n-\t     loop->lpt_decision.times);\n }\n \n /* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation does this:"}, {"sha": "6220640459d1a6c9865ba2ff59c599c53a7bae70", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -8,6 +8,6 @@ test(int c)\n     a[i]=5;\n }\n /* Array bounds says the loop will not roll much.  */\n-/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 2 times..\" \"cunrolli\"} } */\n+/* { dg-final { scan-tree-dump \"Completely unroll loop 2 times\" \"cunrolli\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"cunrolli\"} } */\n /* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "10f6645cf2527d82ce1e8316a2547fdeb824cbb8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-2.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -12,5 +12,5 @@ test(int c)\n     }\n }\n /* We are not able to get rid of the final conditional because the loop has two exits.  */\n-/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 1 times..\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"Completely unroll loop 1 times\" \"cunroll\"} } */\n /* { dg-final { cleanup-tree-dump \"cunroll\" } } */"}, {"sha": "44de9606e9ce62d52122503843a78936bd82b9a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-3.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -11,5 +11,5 @@ test(int c)\n }\n /* If we start duplicating headers prior curoll, this loop will have 0 iterations.  */\n \n-/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 1 times..\" \"cunrolli\"} } */\n+/* { dg-final { scan-tree-dump \"Completely unroll loop 1 times\" \"cunrolli\"} } */\n /* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "9b70e95949f01fc44338965da4199763d4a588b0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-4.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -16,6 +16,6 @@ test(int c)\n \n /* We should do this as part of cunrolli, but our cost model do not take into account early exit\n    from the last iteration.  */\n-/* { dg-final { scan-tree-dump \"Turned loop 1 to non-loop; it never loops.\" \"ivcanon\"} } */\n+/* { dg-final { scan-tree-dump \"Turned loop into non-loop; it never loops.\" \"ivcanon\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"ivcanon\"} } */\n /* { dg-final { cleanup-tree-dump \"ivcanon\" } } */"}, {"sha": "f74e6b5093b53c6eb80e1e46cf51dab4eccdda5d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-5.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -8,7 +8,7 @@ test(int c)\n     a[i]=5;\n }\n /* Basic testcase for complette unrolling.  */\n-/* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 5 times..\" \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump \"Completely unroll loop 5 times\" \"cunroll\"} } */\n /* { dg-final { scan-tree-dump \"Exit condition of peeled iterations was eliminated.\" \"cunroll\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"cunroll\"} } */\n /* { dg-final { cleanup-tree-dump \"cunroll\" } } */"}, {"sha": "81178ae4c6eb66039cd21ee3e3c6aa9b9ad7d6f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -33,7 +33,7 @@ int xxx(void)\n \n /* { dg-final { scan-tree-dump-times \"Added canonical iv to loop 1, 4 iterations\" 1 \"ivcanon\"} } */\n /* { dg-final { cleanup-tree-dump \"ivcanon\" } } */\n-/* { dg-final { scan-tree-dump-times \"Unrolled loop 1 completely\" 1 \"cunroll\"} } */\n+/* { dg-final { scan-tree-dump-times \"Completely unroll loop 4 times\" 1 \"cunroll\"} } */\n /* { dg-final { cleanup-tree-dump \"cunroll\" } } */\n /* { dg-final { scan-tree-dump-times \"foo\" 5 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "4f42491dad22f13556c5cba1a838005c730f82bc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -24,6 +24,6 @@ int foo(void)\n   return sum;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Unrolled loop 1 completely\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Completely unroll loop 3 times\" 1 \"cunroll\" } } */\n \n /* { dg-final { cleanup-tree-dump \"cunroll\" } } */"}, {"sha": "5818635cea90a7f693499c22b09b60fd1e3d4508", "filename": "gcc/testsuite/gcc.dg/unroll_1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -28,5 +28,5 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"Decided to peel loop completely\" 2 \"loop2_unroll\" } } */\n+/* { dg-final { scan-rtl-dump-times \"Turned loop into non-loop; it never loops\" 2 \"loop2_unroll\" } } */\n /* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */"}, {"sha": "9333bf97b1ba229b658ccfd4bd7197c90ab7925d", "filename": "gcc/testsuite/gcc.dg/unroll_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -28,6 +28,6 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"Decided to peel loop completely\" 1 \"loop2_unroll\" } } */\n+/* { dg-final { scan-rtl-dump-times \"Turned loop into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n /* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n /* { dg-excess-errors \"extra notes\" } */"}, {"sha": "673069f3f3366d7817681846a2fb3f05c56bf2e8", "filename": "gcc/testsuite/gcc.dg/unroll_3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -28,6 +28,6 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"Decided to peel loop completely\" 1 \"loop2_unroll\" } } */\n+/* { dg-final { scan-rtl-dump-times \"Turned loop into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n /* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n /* { dg-excess-errors \"extra notes\" } */"}, {"sha": "d3fedd0de5ce368c54bae99a0951a38d71048d5a", "filename": "gcc/testsuite/gcc.dg/unroll_4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -28,6 +28,6 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"Decided to peel loop completely\" 1 \"loop2_unroll\" } } */\n+/* { dg-final { scan-rtl-dump-times \"Turned loop into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n /* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n /* { dg-excess-errors \"extra notes\" } */"}, {"sha": "1a872a32cc43e8a2d939d94cdc03e109c1bdce6f", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25a671164bb972075ae870d3b50f45f46e85eaf/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=e25a671164bb972075ae870d3b50f45f46e85eaf", "patch": "@@ -639,22 +639,24 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n \n /* Tries to unroll LOOP completely, i.e. NITER times.\n    UL determines which loops we are allowed to unroll.\n-   EXIT is the exit of the loop that should be eliminated.  \n+   EXIT is the exit of the loop that should be eliminated.\n    MAXITER specfy bound on number of iterations, -1 if it is\n-   not known or too large for HOST_WIDE_INT.  */\n+   not known or too large for HOST_WIDE_INT.  The location\n+   LOCUS corresponding to the loop is used when emitting\n+   a summary of the unroll to the dump file.  */\n \n static bool\n try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter,\n \t\t\t    enum unroll_level ul,\n-\t\t\t    HOST_WIDE_INT maxiter)\n+\t\t\t    HOST_WIDE_INT maxiter,\n+\t\t\t    location_t locus)\n {\n   unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   gimple cond;\n   struct loop_size size;\n   bool n_unroll_found = false;\n   edge edge_to_cancel = NULL;\n-  int num = loop->num;\n \n   /* See if we proved number of iterations to be low constant.\n \n@@ -862,14 +864,25 @@ try_unroll_loop_completely (struct loop *loop,\n   loops_to_unloop.safe_push (loop);\n   loops_to_unloop_nunroll.safe_push (n_unroll);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (dump_enabled_p ())\n     {\n       if (!n_unroll)\n-        fprintf (dump_file, \"Turned loop %d to non-loop; it never loops.\\n\",\n-\t\t num);\n+        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, locus,\n+                         \"Turned loop into non-loop; it never loops.\\n\");\n       else\n-        fprintf (dump_file, \"Unrolled loop %d completely \"\n-\t\t \"(duplicated %i times).\\n\", num, (int)n_unroll);\n+        {\n+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, locus,\n+                           \"Completely unroll loop %d times\", (int)n_unroll);\n+          if (profile_info)\n+            dump_printf (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS,\n+                         \" (header execution count %d)\",\n+                         (int)loop->header->count);\n+          dump_printf (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, \"\\n\");\n+        }\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n       if (exit)\n         fprintf (dump_file, \"Exit condition of peeled iterations was \"\n \t\t \"eliminated.\\n\");\n@@ -898,15 +911,17 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   tree niter;\n   HOST_WIDE_INT maxiter;\n   bool modified = false;\n+  location_t locus = UNKNOWN_LOCATION;\n \n   niter = number_of_latch_executions (loop);\n+  exit = single_exit (loop);\n   if (TREE_CODE (niter) == INTEGER_CST)\n-    exit = single_exit (loop);\n+    locus = gimple_location (last_stmt (exit->src));\n   else\n     {\n       /* If the loop has more than one exit, try checking all of them\n \t for # of iterations determinable through scev.  */\n-      if (!single_exit (loop))\n+      if (!exit)\n \tniter = find_loop_niter (loop, &exit);\n \n       /* Finally if everything else fails, try brute force evaluation.  */\n@@ -915,6 +930,9 @@ canonicalize_loop_induction_variables (struct loop *loop,\n \t      || TREE_CODE (niter) != INTEGER_CST))\n \tniter = find_loop_niter_by_eval (loop, &exit);\n \n+      if (exit)\n+        locus = gimple_location (last_stmt (exit->src));\n+\n       if (TREE_CODE (niter) != INTEGER_CST)\n \texit = NULL;\n     }\n@@ -949,7 +967,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n      populates the loop bounds.  */\n   modified |= remove_redundant_iv_tests (loop);\n \n-  if (try_unroll_loop_completely (loop, exit, niter, ul, maxiter))\n+  if (try_unroll_loop_completely (loop, exit, niter, ul, maxiter, locus))\n     return true;\n \n   if (create_iv"}]}