{"sha": "5b2ff385d530365adf4fab64266ac30bfe5d0311", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyZmYzODVkNTMwMzY1YWRmNGZhYjY0MjY2YWMzMGJmZTVkMDMxMQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-07-15T21:54:06Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-07-15T21:54:06Z"}, "message": "valarray_array.h (__valarray_get_memory, [...]): New functions.\n\n2000-07-15  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* std/valarray_array.h (__valarray_get_memory,\n\t__valarray_get_storage, __valarray_release_storage): New\n\tfunctions.\n\t(_Array_default_ctor, _Array_init_ctor, _Array_copy_ctor,\n\t_Array_copier): New traits classes.\n\t(__valarray_default_construct): New function.  Implements valarray\n\tdefault construction.\n\t(__valarray_fill_construct): New function. Implements valarray\n\tconstruction with initializer.\n\t(__valarray_copy_construct): New function.  Implements valarray\n\tcopy construction.\n\t(__valarray_destroy_elements): New function.\n\t(__valarray_copy, __valarray_fill): Tweak.\n\t(__valarray_sum, __valarray_product): New helper functions.\n\t(_Array<>::free_data): Remove.\n\t(_Array<>::_Array): Tweak.\n\n\t* std/std_valarray.h (valarray<>::product): Remove.\n\t(valarray<>::valarray): Use __valarray_get_storage.\n\t(valarray<>::shift, valarray<>::cshift, valarray<>::resize):\n\tTweak.\n\n\t* std/cpp_type_traits.h: New file.\n\n\t* valarray.cc (multiplies<>, accumulate, valarray<>::product):\n\tRemove explicit instantiation.\n\t(__valarray_product): New function.\n\t(_Indexer::_Indexer): Use.\n\nFrom-SVN: r35055", "tree": {"sha": "28f1071fe4a2fca22e80626e6a13abf0e98fd826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28f1071fe4a2fca22e80626e6a13abf0e98fd826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b2ff385d530365adf4fab64266ac30bfe5d0311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2ff385d530365adf4fab64266ac30bfe5d0311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b2ff385d530365adf4fab64266ac30bfe5d0311", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2ff385d530365adf4fab64266ac30bfe5d0311/comments", "author": null, "committer": null, "parents": [{"sha": "557b9df5297395e5c17af73c4d360e525793d75e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b9df5297395e5c17af73c4d360e525793d75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557b9df5297395e5c17af73c4d360e525793d75e"}], "stats": {"total": 724, "additions": 632, "deletions": 92}, "files": [{"sha": "04eac45b2337a24ca7e0237aa4375e90b7c337f1", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=5b2ff385d530365adf4fab64266ac30bfe5d0311", "patch": "@@ -1,3 +1,34 @@\n+2000-07-15  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* std/valarray_array.h (__valarray_get_memory,\n+\t__valarray_get_storage, __valarray_release_storage): New\n+\tfunctions.\n+\t(_Array_default_ctor, _Array_init_ctor, _Array_copy_ctor,\n+\t_Array_copier): New traits classes.\n+\t(__valarray_default_construct): New function.  Implements valarray\n+\tdefault construction.\n+\t(__valarray_fill_construct): New function. Implements valarray\n+\tconstruction with initializer.\n+\t(__valarray_copy_construct): New function.  Implements valarray\n+\tcopy construction.\n+\t(__valarray_destroy_elements): New function. \n+\t(__valarray_copy, __valarray_fill): Tweak.\n+\t(__valarray_sum, __valarray_product): New helper functions.\n+\t(_Array<>::free_data): Remove.\n+\t(_Array<>::_Array): Tweak.\n+\n+\t* std/std_valarray.h (valarray<>::product): Remove.\n+\t(valarray<>::valarray): Use __valarray_get_storage.\n+\t(valarray<>::shift, valarray<>::cshift, valarray<>::resize):\n+\tTweak. \n+\n+\t* std/cpp_type_traits.h: New file.\n+\n+\t* valarray.cc (multiplies<>, accumulate, valarray<>::product):\n+\tRemove explicit instantiation. \n+\t(__valarray_product): New function.\n+\t(_Indexer::_Indexer): Use.\n+\n 2000-07-14  Jean-Francois Panisset <panisset@discreet.com>\n \t\n \t* std/bastring.h (basic_string<>::clear): Add function."}, {"sha": "1a065b4efa8127a892558100abe06af04404d312", "filename": "libstdc++/std/cpp_type_traits.h", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fcpp_type_traits.h?ref=5b2ff385d530365adf4fab64266ac30bfe5d0311", "patch": "@@ -0,0 +1,299 @@\n+// The  -*- C++ -*- type traits classes for internal use in libstdc++\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n+\n+#ifndef _CPP_BITS_CPP_TYPE_TRAITS_H\n+#define _CPP_BITS_CPP_TYPE_TRAITS_H 1\n+\n+//\n+// This file provides some compile-time information about various types.\n+// These informations were designed, on purpose, to be constant-expressions\n+// and not types as found in <stl/bits/type_traits.h>.  In particular, they\n+// can be used in control structures and the optimizer, hopefully, will do\n+// the obvious thing.\n+//\n+// Why integral expressions, and not functions nor types?\n+// Firstly, these compile-time information entities are used as\n+// template-arguments so function return values won't work.  We\n+// need compile-time entities.  We're left with types and iintegral constant\n+// expressions.\n+// Secondly, from the point of view of ease of use, type-based compile-time\n+// information is -not- *that* convenient.  One has to write lots of\n+// overloaded functions and to hope that the compiler will select the right\n+// one. As a net effect, the overall structure isn't very clear at first\n+// glance.\n+// Thirdly, partial ordering and overload resolution (of template functions)\n+// is very costly in terms of compiler-resource.  It is a Good Thing to\n+// keep these resource consumption as least as possible.  Please, direct\n+// any comment to <dosreis@cmla.ens-cachan.fr>.\n+//\n+// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.\n+//\n+\n+extern \"C++\" {\n+  template<typename _Tp>\n+  struct __is_void\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_void<void>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  //\n+  // Integer types\n+  //\n+  template<typename _Tp>\n+  struct __is_integer\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+  \n+  // Thirteen specializations (yes there are eleven standard integer\n+  // types; 'long long' and 'unsigned long long' are supported as\n+  // extensions)\n+  template<>\n+  struct __is_integer<bool>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<char>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<signed char>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<unsigned char>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+# if 0\n+  template<>\n+  struct __is_integer<wchar_t>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+\n+  template<>\n+  struct __is_integer<short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<unsigned short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<unsigned int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<unsigned long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+# if 0\n+  template<>\n+  struct __is_integer<long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_integer<unsigned long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+\n+  //\n+  // Floating point types\n+  //\n+  template<typename _Tp>\n+  struct __is_floating\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+  \n+  // three specializations (float, double and 'long double')\n+  template<>\n+  struct __is_floating<float>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_floating<double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  template<>\n+  struct __is_floating<long double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+  \n+  //\n+  // An arithmetic type is an integer type or a floating point type\n+  //\n+  template<typename _Tp>\n+  struct __is_arithmetic\n+  {\n+    enum\n+    {\n+      _M_type = __is_integer<_Tp>::_M_type || __is_floating<_Tp>::_M_type\n+    };\n+  };\n+  \n+  //\n+  // A fundamental type is `void' or and arithmetic type\n+  //\n+  template<typename _Tp>\n+  struct __is_fundamental\n+  {\n+    enum\n+    {\n+      _M_type = __is_void<_Tp>::_M_type || __is_arithmetic<_Tp>::_M_type\n+    };\n+  };\n+  \n+  //\n+  // For the immediate use, the following is a good approximation\n+  //\n+  template<typename _Tp>\n+  struct __is_pod\n+  {\n+    enum\n+    {\n+      _M_type = __is_fundamental<_Tp>::_M_type\n+    };\n+  };\n+} // extern \"C++\"\n+\n+#endif //_CPP_BITS_CPP_TYPE_TRAITS_H\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "d32412ce877af7034f70c5be82d5ac60d9d2282a", "filename": "libstdc++/std/std_valarray.h", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fstd_valarray.h?ref=5b2ff385d530365adf4fab64266ac30bfe5d0311", "patch": "@@ -212,10 +212,7 @@ template<class _Tp> class valarray\n     _Tp    sum() const;\t\n     _Tp    min() const;\t\n     _Tp    max() const;\t\n-    \n-    // FIXME: Extension\n-    _Tp    product () const;\n-\n+  \n     valarray<_Tp> shift (int) const;\n     valarray<_Tp> cshift(int) const;\n     _Expr<_ValFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(_Tp)) const;\n@@ -285,54 +282,69 @@ inline valarray<_Tp>::valarray () : _M_size (0), _M_data (0) {}\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (size_t __n) \n-        : _M_size (__n), _M_data (new _Tp[__n]) {}\n+  : _M_size (__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+{ __valarray_default_construct(_M_data, _M_data + __n); }\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const _Tp& __t, size_t __n)\n-        : _M_size (__n), _M_data (new _Tp[__n])\n-{ __valarray_fill (_M_data, _M_size, __t); }\n+  : _M_size (__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+{ __valarray_fill_construct(_M_data, _M_data + __n, __t); }\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const _Tp* __restrict__ __pT, size_t __n)\n-        : _M_size (__n), _M_data (new _Tp[__n])\n-{ __valarray_copy (__pT, __n, _M_data); }\n+        : _M_size (__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+{ __valarray_copy_construct(__pT, __pT + __n, _M_data); }\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const valarray<_Tp>& __v)\n-        : _M_size (__v._M_size), _M_data (new _Tp[__v._M_size])\n-{ __valarray_copy (__v._M_data, _M_size, _M_data); }\n+  : _M_size (__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n+{ __valarray_copy_construct (__v._M_data, __v._M_data + _M_size, _M_data); }\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const slice_array<_Tp>& __sa)\n-        : _M_size (__sa._M_sz), _M_data (new _Tp[__sa._M_sz])\n-{ __valarray_copy (__sa._M_array, __sa._M_sz, __sa._M_stride,\n-                   _Array<_Tp>(_M_data)); }\n+  : _M_size (__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n+{\n+  __valarray_copy_construct\n+    (__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));\n+}\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const gslice_array<_Tp>& __ga)\n-        : _M_size (__ga._M_index.size()), _M_data (new _Tp[_M_size])\n-{ __valarray_copy (__ga._M_array, _Array<size_t>(__ga._M_index), \n-                   _Array<_Tp>(_M_data), _M_size); }\n+  : _M_size (__ga._M_index.size()),\n+    _M_data(__valarray_get_storage<_Tp>(_M_size))\n+{\n+  __valarray_copy_construct\n+    (__ga._M_array, _Array<size_t>(__ga._M_index),\n+     _Array<_Tp>(_M_data), _M_size);\n+}\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const mask_array<_Tp>& __ma)\n-        : _M_size (__ma._M_sz), _M_data (new _Tp[__ma._M_sz])\n-{ __valarray_copy (__ma._M_array, __ma._M_mask,\n-                   _Array<_Tp>(_M_data), _M_size); }\n+  : _M_size (__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n+{\n+  __valarray_copy_construct\n+    (__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);\n+}\n \n template<typename _Tp>\n inline valarray<_Tp>::valarray (const indirect_array<_Tp>& __ia)\n-        : _M_size (__ia._M_sz), _M_data (new _Tp[__ia._M_sz])\n-{ __valarray_copy (__ia._M_array, __ia._M_index, \n-                   _Array<_Tp>(_M_data), _M_size); }\n+  : _M_size (__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_size))\n+{\n+  __valarray_copy_construct\n+    (__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);\n+}\n \n template<typename _Tp> template<class _Dom>\n inline valarray<_Tp>::valarray (const _Expr<_Dom, _Tp>& __e)\n-        : _M_size (__e.size ()), _M_data (new _Tp[_M_size])\n-{ __valarray_copy (__e, _M_size, _Array<_Tp>(_M_data)); }\n+  : _M_size (__e.size ()), _M_data (__valarray_get_storage<_Tp>(_M_size))\n+{ __valarray_copy_construct (__e, _M_size, _Array<_Tp>(_M_data)); }\n \n template<typename _Tp>\n-inline valarray<_Tp>::~valarray () { delete[] _M_data; }\n+inline valarray<_Tp>::~valarray ()\n+{\n+  __valarray_destroy_elements(_M_data, _M_data + _M_size);\n+  __valarray_release_storage(_M_data);\n+}\n \n template<typename _Tp>\n inline valarray<_Tp>&\n@@ -472,14 +484,7 @@ template<class _Tp>\n inline _Tp\n valarray<_Tp>::sum () const\n {\n-    return accumulate (_M_data, _M_data + _M_size, _Tp ());\n-}\n-\n-template<typename _Tp>\n-inline _Tp\n-valarray<_Tp>::product () const\n-{\n-    return accumulate (_M_data, _M_data+_M_size, _Tp(1), multiplies<_Tp> ());\n+  return __valarray_sum(_M_data, _M_data + _M_size);\n }\n \n template <class _Tp>\n@@ -488,18 +493,18 @@ valarray<_Tp>::shift (int __n) const\n {\n     _Tp* const __a = static_cast<_Tp*> (alloca (sizeof(_Tp) * _M_size));\n     if (! __n)                          // __n == 0: no shift\n-        __valarray_copy (_M_data, _M_size, __a);\n+        __valarray_copy_construct (_M_data, _M_size, __a);\n     else if (__n > 0) {                  // __n > 0: shift left\n         if (__n > _M_size)\n-            __valarray_fill(__a, __n, _Tp());\n+            __valarray_default_construct(__a, __a + __n);\n         else {\n-            __valarray_copy (_M_data+__n, _M_size-__n, __a);\n-            __valarray_fill (__a+_M_size-__n, __n, _Tp());\n+            __valarray_copy_construct (_M_data+__n, _M_size-__n, __a);\n+            __valarray_default_construct (__a+_M_size-__n, __a + _M_size);\n         }\n     }\n     else {                             // __n < 0: shift right\n-        __valarray_copy (_M_data, _M_size+__n, __a-__n);\n-        __valarray_fill(__a, -__n, _Tp());\n+      __valarray_copy_construct (_M_data, _M_data+_M_size+__n, __a-__n);\n+        __valarray_default_construct(__a, __a-__n);\n     }\n     return valarray<_Tp> (__a, _M_size);\n }\n@@ -509,15 +514,17 @@ inline valarray<_Tp>\n valarray<_Tp>::cshift (int __n) const\n {\n     _Tp* const __a = static_cast<_Tp*> (alloca (sizeof(_Tp) * _M_size));\n-    if (! __n)                          // __n == 0: no cshift\n-        __valarray_copy(_M_data, _M_size, __a);\n+    if (__n == 0)                          // __n == 0: no cshift\n+      __valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n     else if (__n > 0) {                 // __n > 0: cshift left\n-        __valarray_copy (_M_data, __n, __a + _M_size-__n);\n-        __valarray_copy (_M_data + __n, _M_size-__n, __a);\n+      __valarray_copy_construct (_M_data, _M_data + __n, __a + _M_size-__n);\n+      __valarray_copy_construct (_M_data + __n, _M_data + _M_size, __a);\n     }\n     else {                            // __n < 0: cshift right\n-        __valarray_copy (_M_data + _M_size + __n, -__n, __a);\n-        __valarray_copy (_M_data, _M_size + __n, __a - __n);\n+      __valarray_copy_construct\n+        (_M_data + _M_size + __n, _M_data + _M_size, __a);\n+        __valarray_copy_construct\n+          (_M_data, _M_data + _M_size + __n, __a - __n);\n     }\n     return valarray<_Tp> (__a, _M_size);\n }\n@@ -526,12 +533,15 @@ template <class _Tp>\n inline void\n valarray<_Tp>::resize (size_t __n, _Tp __c)\n {\n-    if (_M_size != __n) {\n-        delete[] _M_data;\n-        _M_size = __n;\n-        _M_data = new _Tp[_M_size];\n-    }\n-    __valarray_fill (_M_data, _M_size, __c);\n+  // this is so to make valarray<valarray<T> > work\n+  // even though it is not required by the standard.\n+  __valarray_destroy_elements(_M_data, _M_data + _M_size);\n+  if (_M_size != __n) {\n+    __valarray_release_storage(_M_data);\n+    _M_size = __n;\n+    _M_data = __valarray_get_storage<_Tp>(__n);\n+  }\n+  __valarray_fill_construct (_M_data, _M_data + _M_size, __c);\n }\n \n template<typename _Tp>"}, {"sha": "eb66463708e3f5a437f1cd2d62a38edc7b8492b5", "filename": "libstdc++/std/valarray_array.h", "status": "modified", "additions": 226, "deletions": 34, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fstd%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fvalarray_array.h?ref=5b2ff385d530365adf4fab64266ac30bfe5d0311", "patch": "@@ -34,39 +34,205 @@\n \n #include <cstdlib>\n #include <cstring>\n+#include <std/cpp_type_traits.h>\n \n extern \"C++\" {\n \n //\n // Helper functions on raw pointers\n //\n-\n-// fill plain array __a[<__n>] with __t\n-template<typename _Tp>\n-inline void\n-__valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n-{ while (__n--) *__a++ = __t; }\n-\n-// fill strided array __a[<__n-1 : __s>] with __t\n-template<typename _Tp>\n-inline void\n-__valarray_fill (_Tp* __restrict__ __a, size_t __n,\n-                 size_t __s, const _Tp& __t)\n-{ for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n-\n-// fill indirect array __a[__i[<__n>]] with __i\n-template<typename _Tp>\n-inline void\n-__valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n-                size_t __n, const _Tp& __t)\n-{ for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n-\n-// copy plain array __a[<__n>] in __b[<__n>]\n-template<typename _Tp>\n-inline void\n-__valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n-                 _Tp* __restrict__ __b)\n-{ memcpy (__b, __a, __n * sizeof(_Tp)); }\n+  \n+  inline void*\n+  __valarray_get_memory(size_t __n)\n+  { return operator new(__n); }\n+\n+  template<typename _Tp>\n+  inline _Tp*__restrict__\n+  __valarray_get_storage(size_t __n)\n+  {\n+    return static_cast<_Tp*__restrict__>\n+      (__valarray_get_memory(__n * sizeof(_Tp)));\n+  }\n+  \n+  // Return memory to the system\n+  inline void\n+  __valarray_release_storage(void* __p)\n+  { operator delete(__p); }\n+\n+  // Turn a raw-memory into an array of _Tp filled with _Tp()\n+  // This is required in 'valarray<T> v(n);'\n+  template<typename _Tp, bool>\n+  struct _Array_default_ctor\n+  {\n+    // Please note that this isn't exception safe.  But\n+    // valarrays aren't required to be exception safe.\n+    inline static void\n+    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+    { while (__b != __e) new(__b++) _Tp(); }\n+  };\n+\n+  template<typename _Tp>\n+  struct _Array_default_ctor<_Tp, true>\n+  {\n+    // For fundamental types, it suffices to say 'memset()'\n+    inline static void\n+    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+    { memset(__b, 0, (__e - __b)*sizeof(_Tp)); }\n+  };\n+\n+  template<typename _Tp>\n+  inline void\n+  __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+  {\n+    _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _S_do_it(__b, __e);\n+  }\n+    \n+  // Turn a raw-memory into an array of _Tp filled with __t\n+  // This is the required in valarray<T> v(n, t).  Also\n+  // used in valarray<>::resize().\n+  template<typename _Tp, bool>\n+  struct _Array_init_ctor\n+  {\n+    // Please note that this isn't exception safe.  But\n+    // valarrays aren't required to be exception safe.\n+    inline static void\n+    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n+    { while (__b != __e) new(__b++) _Tp(__t); }\n+  };\n+\n+  template<typename _Tp>\n+  struct _Array_init_ctor<_Tp, true>\n+  {\n+    inline static void\n+    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n+    { while (__b != __e) *__b++ = __t; }\n+  };\n+\n+  template<typename _Tp>\n+  inline void\n+  __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n+                            const _Tp __t)\n+  {\n+    _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _S_do_it(__b, __e, __t);\n+  }\n+\n+  //\n+  // copy-construct raw array [__o, *) from plain array [__b, __e)\n+  // We can't just say 'memcpy()'\n+  //\n+  template<typename _Tp, bool>\n+  struct _Array_copy_ctor\n+  {\n+    // Please note that this isn't exception safe.  But\n+    // valarrays aren't required to be exception safe.\n+    inline static void\n+    _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+             _Tp* __restrict__ __o)\n+    { while (__b != __e) new(__o++) _Tp(*__b++); }\n+  };\n+\n+  template<typename _Tp>\n+  struct _Array_copy_ctor<_Tp, true>\n+  {\n+    inline static void\n+    _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+             _Tp* __restrict__ __o)\n+    { memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }\n+  };\n+\n+  template<typename _Tp>\n+  inline void\n+  __valarray_copy_construct(const _Tp* __restrict__ __b,\n+                            const _Tp* __restrict__ __e,\n+                            _Tp* __restrict__ __o)\n+  {\n+    _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _S_do_it(__b, __e, __o);\n+  }\n+\n+  // copy-construct raw array [__o, *) from strided array __a[<__n : __s>]\n+  template<typename _Tp>\n+  inline void\n+  __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n+                             size_t __s, _Tp* __restrict__ __o)\n+  {\n+    if (__is_fundamental<_Tp>::_M_type)\n+      while (__n--) { *__o++ = *__a; __a += __s; }\n+    else\n+      while (__n--) { new(__o++) _Tp(*__a);  __a += __s; }\n+  }\n+\n+  // copy-construct raw array [__o, *) from indexed array __a[__i[<__n>]]\n+  template<typename _Tp>\n+  inline void\n+  __valarray_copy_construct (const _Tp* __restrict__ __a,\n+                             const size_t* __restrict__ __i,\n+                             _Tp* __restrict__ __o, size_t __n)\n+  {\n+    if (__is_fundamental<_Tp>::_M_type)\n+      while (__n--) *__o++ = __a[*__i++];\n+    else\n+      while (__n--) new (__o++) _Tp(__a[*__i++]);\n+  }\n+\n+  // Do the necessary cleanup when we're done with arrays.\n+  template<typename _Tp>\n+  inline void\n+  __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+  {\n+    if (!__is_fundamental<_Tp>::_M_type)\n+      while (__b != __e) { __b->~_Tp(); ++__b; }\n+  }\n+\n+  \n+  // fill plain array __a[<__n>] with __t\n+  template<typename _Tp>\n+  inline void\n+  __valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n+  { while (__n--) *__a++ = __t; }\n+  \n+  // fill strided array __a[<__n-1 : __s>] with __t\n+  template<typename _Tp>\n+  inline void\n+  __valarray_fill (_Tp* __restrict__ __a, size_t __n,\n+                   size_t __s, const _Tp& __t)\n+  { for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n+  \n+  // fill indirect array __a[__i[<__n>]] with __i\n+  template<typename _Tp>\n+  inline void\n+  __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n+                  size_t __n, const _Tp& __t)\n+  { for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n+  \n+  // copy plain array __a[<__n>] in __b[<__n>]\n+  // For non-fundamental types, it is wrong to say 'memcpy()'\n+  template<typename _Tp, bool>\n+  struct _Array_copier\n+  {\n+    inline static void\n+    _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+    { while (__n--) *__b++ = *__a++; }      \n+  };\n+  \n+  template<typename _Tp>\n+  struct _Array_copier<_Tp, true>\n+  {\n+    inline static void\n+    _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+    { memcpy (__b, __a, __n * sizeof (_Tp)); }\n+  };\n+\n+  template<typename _Tp>\n+  inline void\n+  __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n+                   _Tp* __restrict__ __b)\n+  {\n+    _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n+      _S_do_it(__a, __n, __b);\n+  }\n \n // copy strided array __a[<__n : __s>] in plain __b[<__n>]\n template<typename _Tp>\n@@ -97,6 +263,34 @@ __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n                  _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n { for (size_t __j=0; __j<__n; ++__j, ++__a, ++__i) __b[*__i] = *__a; }\n \n+  //\n+  // Compute the sum of elements in range [__f, __l)\n+  // This is a naive algorithm.  It suffers from cancelling.\n+  // In the future try to specialize\n+  // for _Tp = float, double, long double using a more accurate\n+  // algorithm.\n+  //\n+  template<typename _Tp>\n+  inline _Tp\n+  __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n+  {\n+    _Tp __r = _Tp();\n+    while (__f != __l) __r = __r + *__f++;\n+    return __r;\n+  }\n+\n+  // Compute the product of all elements in range [__f, __l)\n+  template<typename _Tp>\n+  _Tp\n+  __valarray_product(const _Tp* __restrict__ __f,\n+                     const _Tp* __restrict__ __l)\n+  {\n+    _Tp __r = _Tp(1);\n+    while (__f != __l) __r = __r * *__f++;\n+    return __r;\n+  }\n+  \n+\n //\n // Helper class _Array, first layer of valarray abstraction.\n // All operations on valarray should be forwarded to this class\n@@ -110,7 +304,6 @@ template<typename _Tp> struct _Array {\n     explicit _Array (const valarray<_Tp>&);\n     _Array (const _Tp* __restrict__, size_t);\n     \n-    void free_data() const;\n     _Tp* begin () const;\n     \n     _Tp* const __restrict__ _M_data;\n@@ -161,7 +354,9 @@ __valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,\n \n template<typename _Tp>\n inline\n-_Array<_Tp>::_Array (size_t __n) : _M_data (new _Tp[__n]) {}\n+_Array<_Tp>::_Array (size_t __n)\n+  : _M_data (__valarray_get_storage<_Tp>(__n))\n+{ __valarray_default_construct(_M_data, _M_data + __n); }\n \n template<typename _Tp>\n inline\n@@ -174,11 +369,8 @@ inline _Array<_Tp>::_Array (const valarray<_Tp>& __v)\n template<typename _Tp>\n inline\n _Array<_Tp>::_Array (const _Tp* __restrict__ __b, size_t __s) \n-        : _M_data (new _Tp[__s]) { __valarray_copy (__b, __s, _M_data); }\n-\n-template<typename _Tp>\n-inline void\n-_Array<_Tp>::free_data() const { delete[] _M_data; }\n+  : _M_data (__valarray_get_storage<_Tp>(__s ))\n+{ __valarray_copy_construct(__b, __s, _M_data); }\n \n template<typename _Tp>\n inline _Tp*"}, {"sha": "5de4e9299821a9a2a4432afb49e1373e814a7184", "filename": "libstdc++/valarray.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fvalarray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ff385d530365adf4fab64266ac30bfe5d0311/libstdc%2B%2B%2Fvalarray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fvalarray.cc?ref=5b2ff385d530365adf4fab64266ac30bfe5d0311", "patch": "@@ -1,9 +1,5 @@\n #include <std/std_valarray.h>\n \n-// Some Explicit Instanciations.\n-template class multiplies<size_t>;\n-template size_t accumulate(size_t*, size_t*, size_t, multiplies<size_t>);\n-\n template void\n    __valarray_fill(size_t* __restrict__, size_t, const size_t&);\n \n@@ -15,7 +11,19 @@ template valarray<size_t>::~valarray();\n template valarray<size_t>::valarray(const valarray<size_t>&);\n template size_t valarray<size_t>::size() const;\n template size_t& valarray<size_t>::operator[](size_t);\n-template size_t valarray<size_t>::product() const;\n+\n+\n+inline size_t\n+__valarray_product(const valarray<size_t>& __a)\n+{\n+  // XXX: This ugly cast is necessary because\n+  //      valarray::operator[]() const returns a VALUE!\n+  //      Try to get the committee to correct that gross error.\n+  typedef const size_t* __restrict__ _Tp;\n+  const size_t __n = __a.size();\n+  valarray<size_t>& __t = const_cast<valarray<size_t>&>(__a);\n+  return __valarray_product(&__t[0], &__t[0] + __n);\n+}\n \n \n void __gslice_to_index(size_t __o, const valarray<size_t>& __l,\n@@ -43,7 +51,7 @@ void __gslice_to_index(size_t __o, const valarray<size_t>& __l,\n _Indexer::_Indexer(size_t __o, const valarray<size_t>& __l,\n                    const valarray<size_t>& __s)\n         : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n-          _M_index(__l.size() ? __l.product() : 0)\n+          _M_index(__l.size() ? __valarray_product(__l) : 0)\n { __gslice_to_index(__o, __l, __s, _M_index); }\n \n "}]}