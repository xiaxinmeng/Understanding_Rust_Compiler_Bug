{"sha": "bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiNjBhMTBhYzg3NmJkMWQ2OGFiN2IwYjBmZjJhY2M2OWUwYzIxNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-10-29T18:04:50Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-10-29T18:04:50Z"}, "message": "rs6000.h (ALTIVEC_VECTOR_MODE): Add IEEE 128-bit floating point modes that can go in vector registers.\n\n2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.h (ALTIVEC_VECTOR_MODE): Add IEEE 128-bit\n\tfloating point modes that can go in vector registers.\n\t(MODES_TIEABLE_P): Move tests for vector modes before tests for\n\tscalar floating point, so that IEEE 128-bit floating point that\n\tcan go in vector registers bind with vectors and not FP.\n\t(struct rs6000_args): Add libcall field.\n\n\t* config/rs6000/rs6000.opt (-mfloat128-*): Delete -mfloat128-none\n\tand -mfloat128-software switches.  Replace them with a binary\n\t-mfloat128 switch.\n\t(-mfloat128): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Allow\n\t128-bit floating point types in GPRs, even if the appropriate\n\toption enabling the type was not used.\n\t(rs6000_debug_reg_global): Remove -mfloat128-{software,none}\n\tdebugging.\n\t(rs6000_setup_reg_addr_masks): Do not allow pre-increment and\n\tpre-decrement on IEEE 128-bit floating point values.\n\t(rs6000_init_hard_regno_mode_ok): Change test for whether TFmode\n\tis IEEE 128-bit floating point.\n\t(rs6000_init_hard_regno_mode_ok): Add reload handlers for IEEE\n\t128-bit floating point types that can go in vector registers.\n\t(rs6000_option_override_internal): Change -mfloat128-none and\n\t-mfloat128-software to -mfloat128, and move code to be near other\n\tVSX option handling.\n\t(rs6000_option_override_internal): Disable -mfloat128 if we don't\n\thave the Altivec ABI.\n\t(rs6000_init_builtins): Don't make TFmode use either IFmode or\n\tKFmode floating point nodes. Instead, have three separate nodes.\n\t(rs6000_scalar_mode_supported_p): Add support for IFmode to allow\n\teventually moving the long double default to IEEE 128-bit floating\n\tpoint.\n\t(rs6000_opt_masks): Add -mfloat128.\n\t(struct rs6000_opt_var): Fix typo in comment.\n\t(init_cumulative_args): Initialize libcall field in\n\tCUMULATIVE_ARGS.\n\t(rs6000_function_arg): Treat library functions as if they had\n\tprototypes to prevent IEEE 128-bit support functions from passing\n\targuments in both GPRs and vector registers.\n\t(rs6000_arg_partial_bytes): Likewise.\n\n\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add -mfloat128 as\n\tan option that can be turned on via -mcpu=<xxx>.\n\n\t* config/rs6000/rs6000-opts.h (enum float128_type_t): Delete, no\n\tlonger used.\n\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n\t__FLOAT128__ if -mfloat128. Define __LONG_DOUBLE_IEEE128__ if long\n\tdouble is IEEE 128-bit. Define __LONG_DOUBLE_IBM128__ if long\n\tdouble is IBM extended double.\n\n\t* config/rs6000/predicates.md (reg_or_indexed_operand): Allow\n\tSUBREGs.\n\nFrom-SVN: r229545", "tree": {"sha": "58aea4d20118e524b653effebfd831aea52ca28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58aea4d20118e524b653effebfd831aea52ca28b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/comments", "author": null, "committer": null, "parents": [{"sha": "721be0f47c5c0bb994af6df6f2e2793f9bd13ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721be0f47c5c0bb994af6df6f2e2793f9bd13ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/721be0f47c5c0bb994af6df6f2e2793f9bd13ee3"}], "stats": {"total": 259, "additions": 166, "deletions": 93}, "files": [{"sha": "ddc9108300c2525c7b6dc2aa2dc7b64201eaedb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -1,3 +1,61 @@\n+2015-10-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (ALTIVEC_VECTOR_MODE): Add IEEE 128-bit\n+\tfloating point modes that can go in vector registers.\n+\t(MODES_TIEABLE_P): Move tests for vector modes before tests for\n+\tscalar floating point, so that IEEE 128-bit floating point that\n+\tcan go in vector registers bind with vectors and not FP.\n+\t(struct rs6000_args): Add libcall field.\n+\n+\t* config/rs6000/rs6000.opt (-mfloat128-*): Delete -mfloat128-none\n+\tand -mfloat128-software switches.  Replace them with a binary\n+\t-mfloat128 switch.\n+\t(-mfloat128): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Allow\n+\t128-bit floating point types in GPRs, even if the appropriate\n+\toption enabling the type was not used.\n+\t(rs6000_debug_reg_global): Remove -mfloat128-{software,none}\n+\tdebugging.\n+\t(rs6000_setup_reg_addr_masks): Do not allow pre-increment and\n+\tpre-decrement on IEEE 128-bit floating point values.\n+\t(rs6000_init_hard_regno_mode_ok): Change test for whether TFmode\n+\tis IEEE 128-bit floating point.\n+\t(rs6000_init_hard_regno_mode_ok): Add reload handlers for IEEE\n+\t128-bit floating point types that can go in vector registers.\n+\t(rs6000_option_override_internal): Change -mfloat128-none and\n+\t-mfloat128-software to -mfloat128, and move code to be near other\n+\tVSX option handling.\n+\t(rs6000_option_override_internal): Disable -mfloat128 if we don't\n+\thave the Altivec ABI.\n+\t(rs6000_init_builtins): Don't make TFmode use either IFmode or\n+\tKFmode floating point nodes. Instead, have three separate nodes.\n+\t(rs6000_scalar_mode_supported_p): Add support for IFmode to allow\n+\teventually moving the long double default to IEEE 128-bit floating\n+\tpoint.\n+\t(rs6000_opt_masks): Add -mfloat128.\n+\t(struct rs6000_opt_var): Fix typo in comment.\n+\t(init_cumulative_args): Initialize libcall field in\n+\tCUMULATIVE_ARGS.\n+\t(rs6000_function_arg): Treat library functions as if they had\n+\tprototypes to prevent IEEE 128-bit support functions from passing\n+\targuments in both GPRs and vector registers.\n+\t(rs6000_arg_partial_bytes): Likewise.\n+\n+\t* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add -mfloat128 as\n+\tan option that can be turned on via -mcpu=<xxx>.\n+\n+\t* config/rs6000/rs6000-opts.h (enum float128_type_t): Delete, no\n+\tlonger used.\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n+\t__FLOAT128__ if -mfloat128. Define __LONG_DOUBLE_IEEE128__ if long\n+\tdouble is IEEE 128-bit. Define __LONG_DOUBLE_IBM128__ if long\n+\tdouble is IBM extended double.\n+\n+\t* config/rs6000/predicates.md (reg_or_indexed_operand): Allow\n+\tSUBREGs.\n+\n 2015-10-29  Mikhail Maltsev  <maltsevm@gmail.com>\n \n         * genautomata.c: Use CHECKING_P instead of ENABLE_CHECKING."}, {"sha": "1c99f7712f54f3803af7ac3b17fdd3a4cef73af9", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -684,7 +684,7 @@\n ;; Like indexed_or_indirect_operand, but also allow a GPR register if direct\n ;; moves are supported.\n (define_predicate \"reg_or_indexed_operand\"\n-  (match_code \"mem,reg\")\n+  (match_code \"mem,reg,subreg\")\n {\n   if (MEM_P (op))\n     return indexed_or_indirect_operand (op, mode);"}, {"sha": "8f02edd1a6361424036fd444f7fd13754a541c46", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -408,6 +408,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__RSQRTE__\");\n   if (TARGET_FRSQRTES)\n     builtin_define (\"__RSQRTEF__\");\n+  if (TARGET_FLOAT128)\n+    builtin_define (\"__FLOAT128__\");\n \n   if (TARGET_EXTRA_BUILTINS && cpp_get_options (pfile)->lang != CLK_ASM)\n     {\n@@ -481,6 +483,11 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     {\n       builtin_define (\"__LONG_DOUBLE_128__\");\n       builtin_define (\"__LONGDOUBLE128\");\n+\n+      if (TARGET_IEEEQUAD)\n+\tbuiltin_define (\"__LONG_DOUBLE_IEEE128__\");\n+      else\n+\tbuiltin_define (\"__LONG_DOUBLE_IBM128__\");\n     }\n \n   switch (TARGET_CMODEL)"}, {"sha": "c63506bdf827510bf077d1cd6b19c7ffd42ea68f", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -44,6 +44,7 @@\n #define ISA_2_6_MASKS_SERVER\t(ISA_2_5_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_ALTIVEC\t\t\t\\\n+\t\t\t\t | OPTION_MASK_FLOAT128\t\t\t\\\n \t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n \t\t\t\t | OPTION_MASK_UPPER_REGS_DF)\n \n@@ -80,6 +81,7 @@\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n \t\t\t\t | OPTION_MASK_DLMZB\t\t\t\\\n \t\t\t\t | OPTION_MASK_EFFICIENT_UNALIGNED_VSX\t\\\n+\t\t\t\t | OPTION_MASK_FLOAT128\t\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\"}, {"sha": "2a028eaae8f486f88cd68bfcfb6e2f48ac129471", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -80,14 +80,6 @@ enum fpu_type_t\n };\n \n \n-/* Float128 support.  */\n-enum float128_type_t\n-{\n-  FLOAT128_UNSET\t= -1,\t/* Initial value.  */\n-  FLOAT128_NONE,\t\t/* No __float128 support.  */\n-  FLOAT128_SW\t\t\t/* software __float128 support.  */\n-};\n-\n /* Types of costly dependences.  */\n enum rs6000_dependence_cost\n {"}, {"sha": "b08b5ea2dce652bc9000b2d005d80efdfcc711c3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 76, "deletions": 59, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -1772,16 +1772,6 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t    && IN_RANGE (last_regno, FIRST_GPR_REGNO, LAST_GPR_REGNO)\n \t    && ((regno & 1) == 0));\n \n-  /* If we don't allow 128-bit binary floating point, disallow the 128-bit\n-     types from going in any registers.  Similarly if __float128 is not\n-     supported, don't allow __float128/__ibm128 types.  */\n-  if (!TARGET_LONG_DOUBLE_128\n-      && (mode == TFmode || mode == KFmode || mode == IFmode))\n-    return false;\n-\n-  if (!TARGET_FLOAT128 && (mode == KFmode || mode == IFmode))\n-    return false;\n-\n   /* VSX registers that overlap the FPR registers are larger than for non-VSX\n      implementations.  Don't allow an item to be split between a FP register\n      and an Altivec register.  Allow TImode in all VSX registers if the user\n@@ -2055,7 +2045,6 @@ rs6000_debug_reg_global (void)\n   const char *trace_str;\n   const char *abi_str;\n   const char *cmodel_str;\n-  const char *float128_str;\n   struct cl_target_option cl_opts;\n \n   /* Modes we want tieable information on.  */\n@@ -2421,15 +2410,6 @@ rs6000_debug_reg_global (void)\n   fprintf (stderr, DEBUG_FMT_S, \"e500_double\",\n \t   (TARGET_E500_DOUBLE ? \"true\" : \"false\"));\n \n-  switch (TARGET_FLOAT128)\n-    {\n-    case FLOAT128_NONE:\tfloat128_str = \"none\";\t\tbreak;\n-    case FLOAT128_SW:\tfloat128_str = \"software\";\tbreak;\n-    default:\t\tfloat128_str = \"unknown\";\tbreak;\n-    }\n-\n-  fprintf (stderr, DEBUG_FMT_S, \"float128\", float128_str);\n-\n   if (TARGET_LINK_STACK)\n     fprintf (stderr, DEBUG_FMT_S, \"link_stack\", \"true\");\n \n@@ -2512,6 +2492,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)\n \t\t  && GET_MODE_SIZE (m2) <= 8\n \t\t  && !VECTOR_MODE_P (m2)\n+\t\t  && !FLOAT128_VECTOR_P (m2)\n \t\t  && !COMPLEX_MODE_P (m2)\n \t\t  && !indexed_only_p\n \t\t  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m2) == 8))\n@@ -2657,6 +2638,20 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       align32 = 128;\n     }\n \n+  /* KF mode (IEEE 128-bit in VSX registers).  We do not have arithmetic, so\n+     only set the memory modes.  Include TFmode if -mabi=ieeelongdouble.  */\n+  if (TARGET_FLOAT128)\n+    {\n+      rs6000_vector_mem[KFmode] = VECTOR_VSX;\n+      rs6000_vector_align[KFmode] = 128;\n+\n+      if (FLOAT128_IEEE_P (TFmode))\n+\t{\n+\t  rs6000_vector_mem[TFmode] = VECTOR_VSX;\n+\t  rs6000_vector_align[TFmode] = 128;\n+\t}\n+    }\n+\n   /* V2DF mode, VSX only.  */\n   if (TARGET_VSX)\n     {\n@@ -2850,7 +2845,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_FLOAT128)\n     {\n       rs6000_constraints[RS6000_CONSTRAINT_wq] = VSX_REGS;\t/* KFmode  */\n-      if (rs6000_ieeequad)\n+      if (FLOAT128_IEEE_P (TFmode))\n \trs6000_constraints[RS6000_CONSTRAINT_wp] = VSX_REGS;\t/* TFmode  */\n     }\n \n@@ -2873,13 +2868,21 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_di_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_di_store;\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;\n+\t  reg_addr[KFmode].reload_store    = CODE_FOR_reload_kf_di_store;\n+\t  reg_addr[KFmode].reload_load     = CODE_FOR_reload_kf_di_load;\n \t  reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_di_store;\n \t  reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_di_load;\n \t  reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_di_store;\n \t  reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_di_load;\n \t  reg_addr[SFmode].reload_store    = CODE_FOR_reload_sf_di_store;\n \t  reg_addr[SFmode].reload_load     = CODE_FOR_reload_sf_di_load;\n \n+\t  if (FLOAT128_IEEE_P (TFmode))\n+\t    {\n+\t      reg_addr[TFmode].reload_store = CODE_FOR_reload_tf_di_store;\n+\t      reg_addr[TFmode].reload_load  = CODE_FOR_reload_tf_di_load;\n+\t    }\n+\n \t  /* Only provide a reload handler for SDmode if lfiwzx/stfiwx are\n \t     available.  */\n \t  if (TARGET_NO_SDMODE_STACK)\n@@ -2933,13 +2936,21 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_si_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_si_store;\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;\n+\t  reg_addr[KFmode].reload_store    = CODE_FOR_reload_kf_si_store;\n+\t  reg_addr[KFmode].reload_load     = CODE_FOR_reload_kf_si_load;\n \t  reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_si_store;\n \t  reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_si_load;\n \t  reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_si_store;\n \t  reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_si_load;\n \t  reg_addr[SFmode].reload_store    = CODE_FOR_reload_sf_si_store;\n \t  reg_addr[SFmode].reload_load     = CODE_FOR_reload_sf_si_load;\n \n+\t  if (FLOAT128_IEEE_P (TFmode))\n+\t    {\n+\t      reg_addr[TFmode].reload_store = CODE_FOR_reload_tf_si_store;\n+\t      reg_addr[TFmode].reload_load  = CODE_FOR_reload_tf_si_load;\n+\t    }\n+\n \t  /* Only provide a reload handler for SDmode if lfiwzx/stfiwx are\n \t     available.  */\n \t  if (TARGET_NO_SDMODE_STACK)\n@@ -3695,13 +3706,6 @@ rs6000_option_override_internal (bool global_init_p)\n       && optimize >= 3)\n     rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;\n \n-  /* Set the appropriate IEEE 128-bit floating option.  Do not enable float128\n-     support by default until the libgcc support is added.  */\n-  if (TARGET_FLOAT128 == FLOAT128_UNSET)\n-    TARGET_FLOAT128 = FLOAT128_NONE;\n-  else if (TARGET_FLOAT128 == FLOAT128_SW && !TARGET_VSX)\n-    error (\"-mfloat128-software requires VSX support\");\n-\n   /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07\n      support. If we only have ISA 2.06 support, and the user did not specify\n      the switch, leave it set to -1 so the movmisalign patterns are enabled,\n@@ -3741,6 +3745,15 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n+  /* __float128 requires VSX support.  */\n+  if (TARGET_FLOAT128 && !TARGET_VSX)\n+    {\n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128) != 0)\n+\terror (\"-mfloat128 requires VSX support\");\n+\n+      rs6000_isa_flags &= ~OPTION_MASK_FLOAT128;\n+    }\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after defaults\", rs6000_isa_flags);\n \n@@ -3821,7 +3834,8 @@ rs6000_option_override_internal (bool global_init_p)\n      unless the altivec ABI was set.  This is set by default for 64-bit, but\n      not for 32-bit.  */\n   if (main_target_opt != NULL && !main_target_opt->x_rs6000_altivec_abi)\n-    rs6000_isa_flags &= ~((OPTION_MASK_VSX | OPTION_MASK_ALTIVEC)\n+    rs6000_isa_flags &= ~((OPTION_MASK_VSX | OPTION_MASK_ALTIVEC\n+\t\t\t   | OPTION_MASK_FLOAT128)\n \t\t\t  & ~rs6000_isa_flags_explicit);\n \n   /* Enable Altivec ABI for AIX -maltivec.  */\n@@ -9427,6 +9441,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      ? CALL_LIBCALL : CALL_NORMAL);\n   cum->sysv_gregno = GP_ARG_MIN_REG;\n   cum->stdarg = stdarg_p (fntype);\n+  cum->libcall = libcall;\n \n   cum->nargs_prototype = 0;\n   if (incoming || cum->prototype)\n@@ -10599,9 +10614,11 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n       rtx r, off;\n       int i, k = 0;\n \n-      /* Do we also need to pass this argument in the parameter\n-\t save area?  */\n-      if (TARGET_64BIT && ! cum->prototype)\n+      /* Do we also need to pass this argument in the parameter save area?\n+\t Library support functions for IEEE 128-bit are assumed to not need the\n+\t value passed both in GPRs and in vector registers.  */\n+      if (TARGET_64BIT && !cum->prototype\n+\t  && (!cum->libcall || !FLOAT128_VECTOR_P (elt_mode)))\n \t{\n \t  int align_words = ROUND_UP (cum->words, 2);\n \t  k = rs6000_psave_function_arg (mode, type, align_words, rvec);\n@@ -10832,11 +10849,14 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \n   if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, named))\n     {\n-      /* If we are passing this arg in the fixed parameter save area\n-         (gprs or memory) as well as VRs, we do not use the partial\n-\t bytes mechanism; instead, rs6000_function_arg will return a\n-\t PARALLEL including a memory element as necessary.  */\n-      if (TARGET_64BIT && ! cum->prototype)\n+      /* If we are passing this arg in the fixed parameter save area (gprs or\n+         memory) as well as VRs, we do not use the partial bytes mechanism;\n+         instead, rs6000_function_arg will return a PARALLEL including a memory\n+         element as necessary.  Library support functions for IEEE 128-bit are\n+         assumed to not need the value passed both in GPRs and in vector\n+         registers.  */\n+      if (TARGET_64BIT && !cum->prototype\n+\t  && (!cum->libcall || !FLOAT128_VECTOR_P (elt_mode)))\n \treturn 0;\n \n       /* Otherwise, we pass in VRs only.  Check for partial copies.  */\n@@ -14421,8 +14441,6 @@ rs6000_init_builtins (void)\n   tree tdecl;\n   tree ftype;\n   machine_mode mode;\n-  machine_mode ieee128_mode;\n-  machine_mode ibm128_mode;\n \n   if (TARGET_DEBUG_BUILTIN)\n     fprintf (stderr, \"rs6000_init_builtins%s%s%s%s\\n\",\n@@ -14495,26 +14513,24 @@ rs6000_init_builtins (void)\n      TFmode will be either IEEE 128-bit floating point or the IBM double-double\n      format that uses a pair of doubles, depending on the switches and\n      defaults.  */\n-  if (TARGET_IEEEQUAD)\n-    {\n-      ieee128_mode = TFmode;\n-      ibm128_mode = IFmode;\n-    }\n-  else\n+  if (TARGET_FLOAT128)\n     {\n-      ieee128_mode = KFmode;\n-      ibm128_mode = TFmode;\n-    }\n+      ibm128_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (ibm128_float_type_node) = 128;\n+      layout_type (ibm128_float_type_node);\n+      SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n+\n+      ieee128_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (ieee128_float_type_node) = 128;\n+      layout_type (ieee128_float_type_node);\n+      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n \n-  ieee128_float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (ieee128_float_type_node) = 128;\n-  layout_type (ieee128_float_type_node);\n-  SET_TYPE_MODE (ieee128_float_type_node, ieee128_mode);\n+      lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n+\t\t\t\t\t      \"__float128\");\n \n-  ibm128_float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (ibm128_float_type_node) = 128;\n-  layout_type (ibm128_float_type_node);\n-  SET_TYPE_MODE (ibm128_float_type_node, ibm128_mode);\n+      lang_hooks.types.register_builtin_type (ibm128_float_type_node,\n+\t\t\t\t\t      \"__ibm128\");\n+    }\n \n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n      tree type node.  */\n@@ -33093,8 +33109,8 @@ rs6000_scalar_mode_supported_p (machine_mode mode)\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return default_decimal_float_supported_p ();\n-  else if (mode == KFmode)\n-    return TARGET_FLOAT128;\n+  else if (TARGET_FLOAT128 && (mode == KFmode || mode == IFmode))\n+    return true;\n   else\n     return default_scalar_mode_supported_p (mode);\n }\n@@ -33205,6 +33221,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"efficient-unaligned-vsx\",\tOPTION_MASK_EFFICIENT_UNALIGNED_VSX,\n \t\t\t\t\t\t\t\tfalse, true  },\n+  { \"float128\",\t\t\tOPTION_MASK_FLOAT128,\t\tfalse, true  },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },\n   { \"htm\",\t\t\tOPTION_MASK_HTM,\t\tfalse, true  },\n@@ -33283,7 +33300,7 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n struct rs6000_opt_var {\n   const char *name;\t\t/* option name */\n   size_t global_offset;\t\t/* offset of the option in global_options.  */\n-  size_t target_offset;\t\t/* offset of the option in target optiosn.  */\n+  size_t target_offset;\t\t/* offset of the option in target options.  */\n };\n \n static struct rs6000_opt_var const rs6000_opt_vars[] ="}, {"sha": "cad1551a15cc97696699aadc81543c545e09914f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -1217,11 +1217,16 @@ enum data_align { align_abi, align_opt, align_both };\n \t ((MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V2DFmode)\t\\\n \n-#define ALTIVEC_VECTOR_MODE(MODE)\t\\\n-\t ((MODE) == V16QImode\t\t\\\n-\t  || (MODE) == V8HImode\t\t\\\n-\t  || (MODE) == V4SFmode\t\t\\\n-\t  || (MODE) == V4SImode)\n+/* Note KFmode and possibly TFmode (i.e. IEEE 128-bit floating point) are not\n+   really a vector, but we want to treat it as a vector for moves, and\n+   such.  */\n+\n+#define ALTIVEC_VECTOR_MODE(MODE)\t\t\t\t\t\\\n+  ((MODE) == V16QImode\t\t\t\t\t\t\t\\\n+   || (MODE) == V8HImode\t\t\t\t\t\t\\\n+   || (MODE) == V4SFmode\t\t\t\t\t\t\\\n+   || (MODE) == V4SImode\t\t\t\t\t\t\\\n+   || FLOAT128_VECTOR_P (MODE))\n \n #define ALTIVEC_OR_VSX_VECTOR_MODE(MODE)\t\t\t\t\\\n   (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)\t\t\t\\\n@@ -1248,12 +1253,19 @@ enum data_align { align_abi, align_opt, align_both };\n \n    PTImode cannot tie with other modes because PTImode is restricted to even\n    GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n-   57744).  */\n+   57744).\n+\n+   Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n+   128-bit floating point on VSX systems ties with other vectors.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n   ((MODE1) == PTImode\t\t\t\t\\\n    ? (MODE2) == PTImode\t\t\t\t\\\n    : (MODE2) == PTImode\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\\\n+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n+   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n    : SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n    ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n    : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n@@ -1266,10 +1278,6 @@ enum data_align { align_abi, align_opt, align_both };\n    ? SPE_VECTOR_MODE (MODE2)\t\t\t\\\n    : SPE_VECTOR_MODE (MODE2)\t\t\t\\\n    ? 0\t\t\t\t\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n-   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n    : 1)\n \n /* Post-reload, we can't use any new AltiVec registers, as we already\n@@ -1801,6 +1809,7 @@ typedef struct rs6000_args\n \t\t\t\t   GPR space (darwin64) */\n   int named;\t\t\t/* false for varargs params */\n   int escapes;\t\t\t/* if function visible outside tu */\n+  int libcall;\t\t\t/* If this is a compiler generated call.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "b9e4b7dfdb6cc10ee38bf868355efadeaf64e7fb", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=bdb60a10ac876bd1d68ab7b0b0ff2acc69e0c214", "patch": "@@ -601,18 +601,6 @@ moptimize-swaps\n Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save\n Analyze and remove doubleword swaps from VSX computations.\n \n-mfloat128-\n-Target RejectNegative Joined Enum(float128_type_t) Var(TARGET_FLOAT128) Init(FLOAT128_UNSET) Save\n--mfloat128-{software,none} - Specify how IEEE 128-bit floating point is used.\n-\n-Enum\n-Name(float128_type_t) Type(enum float128_type_t)\n-\n-EnumValue\n-Enum(float128_type_t) String(none) Value(FLOAT128_NONE)\n-\n-EnumValue\n-Enum(float128_type_t) String(software) Value(FLOAT128_SW)\n-\n-EnumValue\n-Enum(float128_type_t) String(sw) Value(FLOAT128_SW)\n+mfloat128\n+Target Report Mask(FLOAT128) Var(rs6000_isa_flags)\n+Enable/disable IEEE 128-bit floating point via the __float128 keyword."}]}