{"sha": "388092d5b419ad5573c6dcd1c6478691e8417087", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4MDkyZDViNDE5YWQ1NTczYzZkY2QxYzY0Nzg2OTFlODQxNzA4Nw==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@ispras.ru", "date": "2008-10-14T12:52:19Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2008-10-14T12:52:19Z"}, "message": "target.h (struct gcc_target): Update prototypes of needs_block_p and gen_spec_check.\n\n2008-10-14  Andrey Belevantsev  <abel@ispras.ru>\n\t    Dmitry Melnik  <dm@ispras.ru>\n\t    Dmitry Zhurikhin  <zhur@ispras.ru>\n\t    Alexander Monakov  <amonakov@ispras.ru>\n\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n\n\t* target.h (struct gcc_target): Update prototypes of needs_block_p\n\tand gen_spec_check.\n\t* haifa-sched.c (create_check_block_twin): Update calls to the above.\n\t* sel-sched.c (create_speculation_check): Likewise.\n\t* doc/tm.texi: Provide documentation for new target hooks.\n\t\t\n\t* config/ia64/ia64.c: Include sel-sched.h.  Rewrite speculation hooks.\n\t(ia64_gen_spec_insn): Removed.\n\t(get_spec_check_gen_function, insn_can_be_in_speculative_p,\n\tia64_gen_spec_check): New static functions.\n\t(ia64_alloc_sched_context, ia64_init_sched_context, \n\tia64_set_sched_context, ia64_clear_sched_context, \n\tia64_free_sched_context, ia64_get_insn_spec_ds, \n\tia64_get_insn_checked_ds, ia64_skip_rtx_p): Declare functions.\n\t(ia64_needs_block_p): Change prototype.\n\t(ia64_gen_check): Rename to ia64_gen_spec_check.\n\t(ia64_adjust_cost): Rename to ia64_adjust_cost_2.  Add new parameter \n\tinto declaration, add special memory dependencies handling.\n\t(TARGET_SCHED_ALLOC_SCHED_CONTEXT, TARGET_SCHED_INIT_SCHED_CONTEXT,\n\tTARGET_SCHED_SET_SCHED_CONTEXT, TARGET_SCHED_CLEAR_SCHED_CONTEXT,\n\tTARGET_SCHED_FREE_SCHED_CONTEXT, TARGET_SCHED_GET_INSN_SPEC_DS,\n\tTARGET_SCHED_GET_INSN_CHECKED_DS, TARGET_SCHED_SKIP_RTX_P): \n\tDefine new target hooks.\n\t(TARGET_SCHED_GEN_CHECK): Rename to TARGET_SCHED_GEN_SPEC_CHECK.\n\t(ia64_optimization_options): Turn on selective scheduling with -O3, \n\tdisable -fauto-inc-dec. Set mflag_sched_control_spec to true by default\n\twith selective scheduling.\n\t(ia64_override_options): Initialize align_loops and align_functions \n\tto 32 and 64, respectively.  Set global selective scheduling flags \n\taccording to target-dependent flags.\n\t(rtx_needs_barrier): Support UNSPEC_LDS_A.\n\t(group_barrier_needed): Use new mstop-bit-before-check flag. \n\tAdd heuristic.\n\t(dfa_state_size): Make global.\n\t(spec_check_no, max_uid): Remove.\n        (mem_ops_in_group, current_cycle): New variables.\n\t(ia64_sched_init): Disable checks for !SCHED_GROUP_P after reload.\n        Initialize new variables.\n        (is_load_p, record_memory_reference): New functions.\n        (ia64_dfa_sched_reorder): Lower priority of loads when limit is\n        reached.\n\t(ia64_variable_issue): Change use of current_sched_info to \n\tsched_deps_info.  Update comment.  Note if a load or a store is issued.\n        (ia64_first_cycle_multipass_dfa_lookahead_guard_spec): Require a cycle\n        advance if maximal number of loads or stores was issued on current \n        cycle.\n\t(scheduled_good_insn): New static helper function.\n        (ia64_dfa_new_cycle): Assert that last_scheduled_insn is set when \n        a group barrier is needed.  Fix vertical spacing.  Guard the code\n        doing state transition with last_scheduled_insn check.                \n        Mark that a stop bit should be before current insn if there was a \n        cycle advance.  Update current_cycle and mem_ops_in_group.\n\t(ia64_h_i_d_extended): Change use of current_sched_info to\n        sched_deps_info. Reallocate stops_p by larger chunks.\n\t(struct _ia64_sched_context): New structure.\n\t(ia64_sched_context_t): New typedef.\n\t(ia64_alloc_sched_context, ia64_init_sched_context, \n\tia64_set_sched_context, ia64_clear_sched_context,\n\tia64_free_sched_context): New static functions.\n\t(gen_func_t): New typedef.\n\t(get_spec_load_gen_function): New function.\n\t(SPEC_GEN_EXTEND_OFFSET): Declare.\t\n\t(ia64_set_sched_flags): Check common_sched_info instead of *flags.\n\t(get_mode_no_for_insn): Change the condition that prevents use of \n\tspecial hardware registers so it can now handle pseudos.\n\t(get_spec_unspec_code): New function.\n\t(ia64_skip_rtx_p, get_insn_spec_code, ia64_get_insn_spec_ds,\n\tia64_get_insn_checked_ds, ia64_gen_spec_load): New static functions.\n\t(ia64_speculate_insn, ia64_needs_block_p): Support branchy checks\n\tduring selective scheduling.\n\t(ia64_speculate_insn): Use ds_get_speculation_types when \n\tdetermining whether we need to change the pattern.\n\t(SPEC_GEN_LD_MAP, SPEC_GEN_CHECK_OFFSET): Declare.\n\t(ia64_spec_check_src_p): Support new speculation/check codes.\n\t(struct bundle_state): New field.\n\t(issue_nops_and_insn): Initialize it.\n\t(insert_bundle_state): Minimize mid-bundle stop bits.\n\t(important_for_bundling_p): New function.\n\t(get_next_important_insn): Use important_for_bundling_p.\n\t(bundling): When shifting TImode from unimportant insns, ignore \n\talso group barriers.  Assert that best state is found before \n\tthe backward bundling pass.  Print number of mid-bundle stop bits.  \n\tMinimize mid-bundle stop bits.  Check correct calculation of \n\tmid-bundle stop bits.\n\t(ia64_sched_finish, final_emit_insn_group_barriers): Fix formatting.\n\t(final_emit_insn_group_barriers): Emit stop bits before insns starting\n\ta new cycle.\n\t(sel2_run): New variable.\n\t(ia64_reorg): When flag_selective_scheduling2 is set, run the selective \n\tscheduling pass instead of schedule_ebbs.  \n\t\n\t* config/ia64/ia64.md (speculable1, speculable2): New attributes.\n\t(UNSPEC_LDS_A): New UNSPEC.\n\t(movqi_internal, movhi_internal, movsi_internal, movdi_internal, \n\tmovti_internal, movsf_internal, movdf_internal, \n\tmovxf_internal): Make visible.  Add speculable* attributes.\n\t(output_c_nc): New mode attribute.\n\t(mov<mode>_speculative_a, zero_extend<mode>di2_speculative_a,\n\tmov<mode>_nc, zero_extend<mode>di2_nc, \n\tadvanced_load_check_nc_<mode>): New insns.\n\t(zero_extend*): Add speculable* attributes.\n\n\t* config/ia64/ia64.opt (msched_fp_mem_deps_zero_cost): New option.\n\t(msched-stop-bits-after-every-cycle): Likewise.\n\t(msched-max-memory-insns,\n        msched-max-memory-insns-hard-limit): Likewise.\n\t(msched-spec-verbose): Remove.\n\t(msched-prefer-non-data-spec-insns,\n        msched-prefer-non-control-spec-insns, msched-count-spec-in-critical-path,\n\tmsel-sched-dont-check-control-spec): Use Target \n        Report Var instead of Common Report Var.\n\n\t* config/ia64/itanium2.md: Remove incorrect bypass.\n\t\n\t* config/ia64/t-ia64 (ia64.o): Add dependency on sel-sched.h.\n\nCo-Authored-By: Alexander Monakov <amonakov@ispras.ru>\nCo-Authored-By: Dmitry Melnik <dm@ispras.ru>\nCo-Authored-By: Dmitry Zhurikhin <zhur@ispras.ru>\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\n\nFrom-SVN: r141108", "tree": {"sha": "a119d58d157037691fbfb1607a5ac9c87bc3ca7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a119d58d157037691fbfb1607a5ac9c87bc3ca7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/388092d5b419ad5573c6dcd1c6478691e8417087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388092d5b419ad5573c6dcd1c6478691e8417087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/388092d5b419ad5573c6dcd1c6478691e8417087", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388092d5b419ad5573c6dcd1c6478691e8417087/comments", "author": {"login": "abonzo", "id": 20396542, "node_id": "MDQ6VXNlcjIwMzk2NTQy", "avatar_url": "https://avatars.githubusercontent.com/u/20396542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonzo", "html_url": "https://github.com/abonzo", "followers_url": "https://api.github.com/users/abonzo/followers", "following_url": "https://api.github.com/users/abonzo/following{/other_user}", "gists_url": "https://api.github.com/users/abonzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonzo/subscriptions", "organizations_url": "https://api.github.com/users/abonzo/orgs", "repos_url": "https://api.github.com/users/abonzo/repos", "events_url": "https://api.github.com/users/abonzo/events{/privacy}", "received_events_url": "https://api.github.com/users/abonzo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "847e63465e85f06389850301ba7632d4f0af6870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/847e63465e85f06389850301ba7632d4f0af6870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/847e63465e85f06389850301ba7632d4f0af6870"}], "stats": {"total": 1653, "additions": 1215, "deletions": 438}, "files": [{"sha": "1fa764086228b5df41d9025d7cf99fab02bfc741", "filename": "gcc/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -1,3 +1,125 @@\n+2008-10-14  Andrey Belevantsev  <abel@ispras.ru>\n+\t    Dmitry Melnik  <dm@ispras.ru>\n+\t    Dmitry Zhurikhin  <zhur@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n+\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* target.h (struct gcc_target): Update prototypes of needs_block_p\n+\tand gen_spec_check.\n+\t* haifa-sched.c (create_check_block_twin): Update calls to the above.\n+\t* sel-sched.c (create_speculation_check): Likewise.\n+\t* doc/tm.texi: Provide documentation for new target hooks.\n+\t\t\n+\t* config/ia64/ia64.c: Include sel-sched.h.  Rewrite speculation hooks.\n+\t(ia64_gen_spec_insn): Removed.\n+\t(get_spec_check_gen_function, insn_can_be_in_speculative_p,\n+\tia64_gen_spec_check): New static functions.\n+\t(ia64_alloc_sched_context, ia64_init_sched_context, \n+\tia64_set_sched_context, ia64_clear_sched_context, \n+\tia64_free_sched_context, ia64_get_insn_spec_ds, \n+\tia64_get_insn_checked_ds, ia64_skip_rtx_p): Declare functions.\n+\t(ia64_needs_block_p): Change prototype.\n+\t(ia64_gen_check): Rename to ia64_gen_spec_check.\n+\t(ia64_adjust_cost): Rename to ia64_adjust_cost_2.  Add new parameter \n+\tinto declaration, add special memory dependencies handling.\n+\t(TARGET_SCHED_ALLOC_SCHED_CONTEXT, TARGET_SCHED_INIT_SCHED_CONTEXT,\n+\tTARGET_SCHED_SET_SCHED_CONTEXT, TARGET_SCHED_CLEAR_SCHED_CONTEXT,\n+\tTARGET_SCHED_FREE_SCHED_CONTEXT, TARGET_SCHED_GET_INSN_SPEC_DS,\n+\tTARGET_SCHED_GET_INSN_CHECKED_DS, TARGET_SCHED_SKIP_RTX_P): \n+\tDefine new target hooks.\n+\t(TARGET_SCHED_GEN_CHECK): Rename to TARGET_SCHED_GEN_SPEC_CHECK.\n+\t(ia64_optimization_options): Turn on selective scheduling with -O3, \n+\tdisable -fauto-inc-dec. Set mflag_sched_control_spec to true by default\n+\twith selective scheduling.\n+\t(ia64_override_options): Initialize align_loops and align_functions \n+\tto 32 and 64, respectively.  Set global selective scheduling flags \n+\taccording to target-dependent flags.\n+\t(rtx_needs_barrier): Support UNSPEC_LDS_A.\n+\t(group_barrier_needed): Use new mstop-bit-before-check flag. \n+\tAdd heuristic.\n+\t(dfa_state_size): Make global.\n+\t(spec_check_no, max_uid): Remove.\n+        (mem_ops_in_group, current_cycle): New variables.\n+\t(ia64_sched_init): Disable checks for !SCHED_GROUP_P after reload.\n+        Initialize new variables.\n+        (is_load_p, record_memory_reference): New functions.\n+        (ia64_dfa_sched_reorder): Lower priority of loads when limit is\n+        reached.\n+\t(ia64_variable_issue): Change use of current_sched_info to \n+\tsched_deps_info.  Update comment.  Note if a load or a store is issued.\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard_spec): Require a cycle\n+        advance if maximal number of loads or stores was issued on current \n+        cycle.\n+\t(scheduled_good_insn): New static helper function.\n+        (ia64_dfa_new_cycle): Assert that last_scheduled_insn is set when \n+        a group barrier is needed.  Fix vertical spacing.  Guard the code\n+        doing state transition with last_scheduled_insn check.                \n+        Mark that a stop bit should be before current insn if there was a \n+        cycle advance.  Update current_cycle and mem_ops_in_group.\n+\t(ia64_h_i_d_extended): Change use of current_sched_info to\n+        sched_deps_info. Reallocate stops_p by larger chunks.\n+\t(struct _ia64_sched_context): New structure.\n+\t(ia64_sched_context_t): New typedef.\n+\t(ia64_alloc_sched_context, ia64_init_sched_context, \n+\tia64_set_sched_context, ia64_clear_sched_context,\n+\tia64_free_sched_context): New static functions.\n+\t(gen_func_t): New typedef.\n+\t(get_spec_load_gen_function): New function.\n+\t(SPEC_GEN_EXTEND_OFFSET): Declare.\t\n+\t(ia64_set_sched_flags): Check common_sched_info instead of *flags.\n+\t(get_mode_no_for_insn): Change the condition that prevents use of \n+\tspecial hardware registers so it can now handle pseudos.\n+\t(get_spec_unspec_code): New function.\n+\t(ia64_skip_rtx_p, get_insn_spec_code, ia64_get_insn_spec_ds,\n+\tia64_get_insn_checked_ds, ia64_gen_spec_load): New static functions.\n+\t(ia64_speculate_insn, ia64_needs_block_p): Support branchy checks\n+\tduring selective scheduling.\n+\t(ia64_speculate_insn): Use ds_get_speculation_types when \n+\tdetermining whether we need to change the pattern.\n+\t(SPEC_GEN_LD_MAP, SPEC_GEN_CHECK_OFFSET): Declare.\n+\t(ia64_spec_check_src_p): Support new speculation/check codes.\n+\t(struct bundle_state): New field.\n+\t(issue_nops_and_insn): Initialize it.\n+\t(insert_bundle_state): Minimize mid-bundle stop bits.\n+\t(important_for_bundling_p): New function.\n+\t(get_next_important_insn): Use important_for_bundling_p.\n+\t(bundling): When shifting TImode from unimportant insns, ignore \n+\talso group barriers.  Assert that best state is found before \n+\tthe backward bundling pass.  Print number of mid-bundle stop bits.  \n+\tMinimize mid-bundle stop bits.  Check correct calculation of \n+\tmid-bundle stop bits.\n+\t(ia64_sched_finish, final_emit_insn_group_barriers): Fix formatting.\n+\t(final_emit_insn_group_barriers): Emit stop bits before insns starting\n+\ta new cycle.\n+\t(sel2_run): New variable.\n+\t(ia64_reorg): When flag_selective_scheduling2 is set, run the selective \n+\tscheduling pass instead of schedule_ebbs.  \n+\t\n+\t* config/ia64/ia64.md (speculable1, speculable2): New attributes.\n+\t(UNSPEC_LDS_A): New UNSPEC.\n+\t(movqi_internal, movhi_internal, movsi_internal, movdi_internal, \n+\tmovti_internal, movsf_internal, movdf_internal, \n+\tmovxf_internal): Make visible.  Add speculable* attributes.\n+\t(output_c_nc): New mode attribute.\n+\t(mov<mode>_speculative_a, zero_extend<mode>di2_speculative_a,\n+\tmov<mode>_nc, zero_extend<mode>di2_nc, \n+\tadvanced_load_check_nc_<mode>): New insns.\n+\t(zero_extend*): Add speculable* attributes.\n+\n+\t* config/ia64/ia64.opt (msched_fp_mem_deps_zero_cost): New option.\n+\t(msched-stop-bits-after-every-cycle): Likewise.\n+\t(msched-max-memory-insns,\n+        msched-max-memory-insns-hard-limit): Likewise.\n+\t(msched-spec-verbose): Remove.\n+\t(msched-prefer-non-data-spec-insns,\n+        msched-prefer-non-control-spec-insns, msched-count-spec-in-critical-path,\n+\tmsel-sched-dont-check-control-spec): Use Target \n+        Report Var instead of Common Report Var.\n+\n+\t* config/ia64/itanium2.md: Remove incorrect bypass.\n+\t\n+\t* config/ia64/t-ia64 (ia64.o): Add dependency on sel-sched.h.\n+\n 2008-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/37805"}, {"sha": "34a37d200e7daa076c18176303ea51965f3a1e97", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 910, "deletions": 391, "changes": 1301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"dbgcnt.h\"\n #include \"tm-constrs.h\"\n+#include \"sel-sched.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -172,12 +173,19 @@ static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx);\n static bool ia64_first_cycle_multipass_dfa_lookahead_guard_spec (const_rtx);\n static int ia64_dfa_new_cycle (FILE *, int, rtx, int, int, int *);\n static void ia64_h_i_d_extended (void);\n+static void * ia64_alloc_sched_context (void);\n+static void ia64_init_sched_context (void *, bool);\n+static void ia64_set_sched_context (void *);\n+static void ia64_clear_sched_context (void *);\n+static void ia64_free_sched_context (void *);\n static int ia64_mode_to_int (enum machine_mode);\n static void ia64_set_sched_flags (spec_info_t);\n+static ds_t ia64_get_insn_spec_ds (rtx);\n+static ds_t ia64_get_insn_checked_ds (rtx);\n+static bool ia64_skip_rtx_p (const_rtx);\n static int ia64_speculate_insn (rtx, ds_t, rtx *);\n-static rtx ia64_gen_spec_insn (rtx, ds_t, int, bool, bool);\n-static bool ia64_needs_block_p (const_rtx);\n-static rtx ia64_gen_check (rtx, rtx, bool);\n+static bool ia64_needs_block_p (int);\n+static rtx ia64_gen_spec_check (rtx, rtx, ds_t);\n static int ia64_spec_check_p (rtx);\n static int ia64_spec_check_src_p (rtx);\n static rtx gen_tls_get_addr (void);\n@@ -222,7 +230,7 @@ static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void ia64_output_function_end_prologue (FILE *);\n \n static int ia64_issue_rate (void);\n-static int ia64_adjust_cost (rtx, rtx, rtx, int);\n+static int ia64_adjust_cost_2 (rtx, int, rtx, int, dw_t);\n static void ia64_sched_init (FILE *, int, int);\n static void ia64_sched_init_global (FILE *, int, int);\n static void ia64_sched_finish_global (FILE *, int);\n@@ -248,6 +256,7 @@ static int get_max_pos (state_t);\n static int get_template (state_t, int);\n \n static rtx get_next_important_insn (rtx, rtx);\n+static bool important_for_bundling_p (rtx);\n static void bundling (FILE *, int, rtx, rtx);\n \n static void ia64_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n@@ -333,8 +342,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P  ia64_in_small_data_p\n \n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST ia64_adjust_cost\n+#undef TARGET_SCHED_ADJUST_COST_2\n+#define TARGET_SCHED_ADJUST_COST_2 ia64_adjust_cost_2\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE ia64_issue_rate\n #undef TARGET_SCHED_VARIABLE_ISSUE\n@@ -373,22 +382,46 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCHED_H_I_D_EXTENDED\n #define TARGET_SCHED_H_I_D_EXTENDED ia64_h_i_d_extended\n \n+#undef TARGET_SCHED_ALLOC_SCHED_CONTEXT\n+#define TARGET_SCHED_ALLOC_SCHED_CONTEXT ia64_alloc_sched_context\n+\n+#undef TARGET_SCHED_INIT_SCHED_CONTEXT\n+#define TARGET_SCHED_INIT_SCHED_CONTEXT ia64_init_sched_context\n+\n+#undef TARGET_SCHED_SET_SCHED_CONTEXT\n+#define TARGET_SCHED_SET_SCHED_CONTEXT ia64_set_sched_context\n+\n+#undef TARGET_SCHED_CLEAR_SCHED_CONTEXT\n+#define TARGET_SCHED_CLEAR_SCHED_CONTEXT ia64_clear_sched_context\n+\n+#undef TARGET_SCHED_FREE_SCHED_CONTEXT\n+#define TARGET_SCHED_FREE_SCHED_CONTEXT ia64_free_sched_context\n+\n #undef TARGET_SCHED_SET_SCHED_FLAGS\n #define TARGET_SCHED_SET_SCHED_FLAGS ia64_set_sched_flags\n \n+#undef TARGET_SCHED_GET_INSN_SPEC_DS\n+#define TARGET_SCHED_GET_INSN_SPEC_DS ia64_get_insn_spec_ds\n+\n+#undef TARGET_SCHED_GET_INSN_CHECKED_DS\n+#define TARGET_SCHED_GET_INSN_CHECKED_DS ia64_get_insn_checked_ds\n+\n #undef TARGET_SCHED_SPECULATE_INSN\n #define TARGET_SCHED_SPECULATE_INSN ia64_speculate_insn\n \n #undef TARGET_SCHED_NEEDS_BLOCK_P\n #define TARGET_SCHED_NEEDS_BLOCK_P ia64_needs_block_p\n \n #undef TARGET_SCHED_GEN_SPEC_CHECK\n-#define TARGET_SCHED_GEN_SPEC_CHECK ia64_gen_check\n+#define TARGET_SCHED_GEN_SPEC_CHECK ia64_gen_spec_check\n \n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\\\n   ia64_first_cycle_multipass_dfa_lookahead_guard_spec\n \n+#undef TARGET_SCHED_SKIP_RTX_P\n+#define TARGET_SCHED_SKIP_RTX_P ia64_skip_rtx_p\n+\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n #undef TARGET_ARG_PARTIAL_BYTES\n@@ -5236,9 +5269,33 @@ ia64_override_options (void)\n   ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n   flag_schedule_insns_after_reload = 0;\n \n+  if (optimize >= 3\n+      && ! sel_sched_switch_set)\n+    {\n+      flag_selective_scheduling2 = 1;\n+      flag_sel_sched_pipelining = 1;\n+    }\n+  if (mflag_sched_control_spec == 2)\n+    {\n+      /* Control speculation is on by default for the selective scheduler,\n+         but not for the Haifa scheduler.  */\n+      mflag_sched_control_spec = flag_selective_scheduling2 ? 1 : 0;\n+    }\n+  if (flag_sel_sched_pipelining && flag_auto_inc_dec)\n+    {\n+      /* FIXME: remove this when we'd implement breaking autoinsns as\n+         a transformation.  */\n+      flag_auto_inc_dec = 0;\n+    }\n+\n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n   init_machine_status = ia64_init_machine_status;\n+\n+  if (align_functions <= 0)\n+    align_functions = 64;\n+  if (align_loops <= 0)\n+    align_loops = 32;\n }\n \n /* Initialize the record of emitted frame related registers.  */\n@@ -5893,6 +5950,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \tcase UNSPEC_FR_SQRT_RECIP_APPROX_RES:\n \tcase UNSPEC_LDA:\n \tcase UNSPEC_LDS:\n+\tcase UNSPEC_LDS_A:\n \tcase UNSPEC_LDSA:\n \tcase UNSPEC_CHKACLR:\n         case UNSPEC_CHKS:\n@@ -6098,6 +6156,7 @@ group_barrier_needed (rtx insn)\n \t asm.  */\n       if (! need_barrier)\n \tneed_barrier = rws_access_regno (REG_VOLATILE, flags, 0);\n+\n       break;\n \n     default:\n@@ -6296,14 +6355,6 @@ static state_t prev_cycle_state = NULL;\n \n static char *stops_p = NULL;\n \n-/* The following array element values are ZERO for non-speculative\n-   instructions and hold corresponding speculation check number for\n-   speculative instructions.  */\n-static int *spec_check_no = NULL;\n-\n-/* Size of spec_check_no array.  */\n-static int max_uid = 0;\n-\n /* The following variable is used to set up the mentioned above array.  */\n \n static int stop_before_p = 0;\n@@ -6327,6 +6378,12 @@ static int *add_cycles;\n /* The following variable value is number of data speculations in progress.  */\n static int pending_data_specs = 0;\n \n+/* Number of memory references on current and three future processor cycles.  */\n+static char mem_ops_in_group[4];\n+\n+/* Number of current processor cycle (from scheduler's point of view).  */\n+static int current_cycle;\n+\n static rtx ia64_single_set (rtx);\n static void ia64_emit_insn_before (rtx, rtx);\n \n@@ -6376,20 +6433,44 @@ ia64_single_set (rtx insn)\n   return ret;\n }\n \n-/* Adjust the cost of a scheduling dependency.  Return the new cost of\n-   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n-\n+/* Adjust the cost of a scheduling dependency.\n+   Return the new cost of a dependency of type DEP_TYPE or INSN on DEP_INSN.\n+   COST is the current cost, DW is dependency weakness.  */\n static int\n-ia64_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n+ia64_adjust_cost_2 (rtx insn, int dep_type1, rtx dep_insn, int cost, dw_t dw)\n {\n+  enum reg_note dep_type = (enum reg_note) dep_type1;\n   enum attr_itanium_class dep_class;\n   enum attr_itanium_class insn_class;\n \n-  if (REG_NOTE_KIND (link) != REG_DEP_OUTPUT)\n-    return cost;\n-\n   insn_class = ia64_safe_itanium_class (insn);\n   dep_class = ia64_safe_itanium_class (dep_insn);\n+\n+  /* Treat true memory dependencies separately.  Ignore apparent true\n+     dependence between store and call (call has a MEM inside a SYMBOL_REF).  */\n+  if (dep_type == REG_DEP_TRUE\n+      && (dep_class == ITANIUM_CLASS_ST || dep_class == ITANIUM_CLASS_STF)\n+      && (insn_class == ITANIUM_CLASS_BR || insn_class == ITANIUM_CLASS_SCALL))\n+    return 0;\n+\n+  if (dw == MIN_DEP_WEAK)\n+    /* Store and load are likely to alias, use higher cost to avoid stall.  */\n+    return PARAM_VALUE (PARAM_SCHED_MEM_TRUE_DEP_COST);\n+  else if (dw > MIN_DEP_WEAK)\n+    {\n+      /* Store and load are less likely to alias.  */\n+      if (mflag_sched_fp_mem_deps_zero_cost && dep_class == ITANIUM_CLASS_STF)\n+\t/* Assume there will be no cache conflict for floating-point data.\n+\t   For integer data, L1 conflict penalty is huge (17 cycles), so we\n+\t   never assume it will not cause a conflict.  */\n+\treturn 0;\n+      else\n+\treturn cost;\n+    }\n+\n+  if (dep_type != REG_DEP_OUTPUT)\n+    return cost;\n+\n   if (dep_class == ITANIUM_CLASS_ST || dep_class == ITANIUM_CLASS_STF\n       || insn_class == ITANIUM_CLASS_ST || insn_class == ITANIUM_CLASS_STF)\n     return 0;\n@@ -6474,14 +6555,17 @@ ia64_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n #ifdef ENABLE_CHECKING\n   rtx insn;\n \n-  if (reload_completed)\n+  if (!sel_sched_p () && reload_completed)\n     for (insn = NEXT_INSN (current_sched_info->prev_head);\n \t insn != current_sched_info->next_tail;\n \t insn = NEXT_INSN (insn))\n       gcc_assert (!SCHED_GROUP_P (insn));\n #endif\n   last_scheduled_insn = NULL_RTX;\n   init_insn_group_barriers ();\n+\n+  current_cycle = 0;\n+  memset (mem_ops_in_group, 0, sizeof (mem_ops_in_group));\n }\n \n /* We're beginning a scheduling pass.  Check assertion.  */\n@@ -6491,25 +6575,57 @@ ia64_sched_init_global (FILE *dump ATTRIBUTE_UNUSED,\n                         int sched_verbose ATTRIBUTE_UNUSED,\n                         int max_ready ATTRIBUTE_UNUSED)\n {  \n-  gcc_assert (!pending_data_specs);\n+  gcc_assert (pending_data_specs == 0);\n }\n \n /* Scheduling pass is now finished.  Free/reset static variable.  */\n static void\n ia64_sched_finish_global (FILE *dump ATTRIBUTE_UNUSED,\n \t\t\t  int sched_verbose ATTRIBUTE_UNUSED)\n {\n-  free (spec_check_no);\n-  spec_check_no = 0;\n-  max_uid = 0;\n+  gcc_assert (pending_data_specs == 0);\n+}\n+\n+/* Return TRUE if INSN is a load (either normal or speculative, but not a\n+   speculation check), FALSE otherwise.  */\n+static bool\n+is_load_p (rtx insn)\n+{\n+  enum attr_itanium_class insn_class = ia64_safe_itanium_class (insn);\n+\n+  return\n+   ((insn_class == ITANIUM_CLASS_LD || insn_class == ITANIUM_CLASS_FLD)\n+    && get_attr_check_load (insn) == CHECK_LOAD_NO);\n+}\n+\n+/* If INSN is a memory reference, memoize it in MEM_OPS_IN_GROUP global array\n+   (taking account for 3-cycle cache reference postponing for stores: Intel\n+   Itanium 2 Reference Manual for Software Development and Optimization,\n+   6.7.3.1).  */\n+static void\n+record_memory_reference (rtx insn)\n+{\n+  enum attr_itanium_class insn_class = ia64_safe_itanium_class (insn);\n+\n+  switch (insn_class) {\n+    case ITANIUM_CLASS_FLD:\n+    case ITANIUM_CLASS_LD:\n+      mem_ops_in_group[current_cycle % 4]++;\n+      break;\n+    case ITANIUM_CLASS_STF:\n+    case ITANIUM_CLASS_ST:\n+      mem_ops_in_group[(current_cycle + 3) % 4]++;\n+      break;\n+    default:;\n+  }\n }\n \n /* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n \n static int\n ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n-\t\t\tint *pn_ready, int clock_var ATTRIBUTE_UNUSED,\n+\t\t\tint *pn_ready, int clock_var,\n \t\t\tint reorder_type)\n {\n   int n_asms;\n@@ -6589,6 +6705,27 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n       ready += deleted;\n     }\n \n+  current_cycle = clock_var;\n+  if (reload_completed && mem_ops_in_group[clock_var % 4] >= ia64_max_memory_insns)\n+    {\n+      int moved = 0;\n+\n+      insnp = e_ready;\n+      /* Move down loads/stores, preserving relative order.  */\n+      while (insnp-- > ready + moved)\n+\twhile (insnp >= ready + moved)\n+\t  {\n+\t    rtx insn = *insnp;\n+\t    if (! is_load_p (insn))\n+\t      break;\n+\t    memmove (ready + 1, ready, (insnp - ready) * sizeof (rtx));\n+\t    *ready = insn;\n+\t    moved++;\n+\t  }\n+      n_ready -= moved;\n+      ready += moved;\n+    }\n+\n   return 1;\n }\n \n@@ -6626,9 +6763,9 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n \t\t     rtx insn ATTRIBUTE_UNUSED,\n \t\t     int can_issue_more ATTRIBUTE_UNUSED)\n {\n-  if (current_sched_info->flags & DO_SPECULATION)\n+  if (sched_deps_info->generate_spec_deps && !sel_sched_p ())\n     /* Modulo scheduling does not extend h_i_d when emitting\n-       new instructions.  Deal with it.  */\n+       new instructions.  Don't use h_i_d, if we don't have to.  */\n     {\n       if (DONE_SPEC (insn) & BEGIN_DATA)\n \tpending_data_specs++;\n@@ -6647,6 +6784,8 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n \tinit_insn_group_barriers ();\n       stops_p [INSN_UID (insn)] = stop_before_p;\n       stop_before_p = 0;\n+\n+      record_memory_reference (insn);\n     }\n   return 1;\n }\n@@ -6657,10 +6796,13 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n static int\n ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n {\n-  gcc_assert (insn  && INSN_P (insn));\n+  gcc_assert (insn && INSN_P (insn));\n   return ((!reload_completed\n \t   || !safe_group_barrier_needed (insn))\n-\t  && ia64_first_cycle_multipass_dfa_lookahead_guard_spec (insn));\n+\t  && ia64_first_cycle_multipass_dfa_lookahead_guard_spec (insn)\n+\t  && (!mflag_sched_mem_insns_hard_limit\n+\t      || !is_load_p (insn)\n+\t      || mem_ops_in_group[current_cycle % 4] < ia64_max_memory_insns));\n }\n \n /* We are choosing insn from the ready queue.  Return nonzero if INSN\n@@ -6682,6 +6824,26 @@ ia64_first_cycle_multipass_dfa_lookahead_guard_spec (const_rtx insn)\n \n static rtx dfa_pre_cycle_insn;\n \n+/* Returns 1 when a meaningful insn was scheduled between the last group\n+   barrier and LAST.  */\n+static int\n+scheduled_good_insn (rtx last)\n+{\n+  if (last && recog_memoized (last) >= 0)\n+    return 1;\n+\n+  for ( ;\n+       last != NULL && !NOTE_INSN_BASIC_BLOCK_P (last)\n+       && !stops_p[INSN_UID (last)];\n+       last = PREV_INSN (last))\n+    /* We could hit a NOTE_INSN_DELETED here which is actually outside\n+       the ebb we're scheduling.  */\n+    if (INSN_P (last) && recog_memoized (last) >= 0)\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* We are about to being issuing INSN.  Return nonzero if we cannot\n    issue it on given cycle CLOCK and return zero if we should not sort\n    the ready queue on the next clock start.  */\n@@ -6693,17 +6855,32 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n   int setup_clocks_p = FALSE;\n \n   gcc_assert (insn && INSN_P (insn));\n-  if ((reload_completed && safe_group_barrier_needed (insn))\n+  /* When a group barrier is needed for insn, last_scheduled_insn\n+     should be set.  */\n+  gcc_assert (!(reload_completed && safe_group_barrier_needed (insn))\n+              || last_scheduled_insn);\n+\n+  if ((reload_completed\n+       && (safe_group_barrier_needed (insn)\n+\t   || (mflag_sched_stop_bits_after_every_cycle\n+\t       && last_clock != clock\n+\t       && last_scheduled_insn\n+\t       && scheduled_good_insn (last_scheduled_insn))))\n       || (last_scheduled_insn\n \t  && (GET_CODE (last_scheduled_insn) == CALL_INSN\n \t      || GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT\n \t      || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)))\n     {\n       init_insn_group_barriers ();\n+\n       if (verbose && dump)\n \tfprintf (dump, \"//    Stop should be before %d%s\\n\", INSN_UID (insn),\n \t\t last_clock == clock ? \" + cycle advance\" : \"\");\n+\n       stop_before_p = 1;\n+      current_cycle = clock;\n+      mem_ops_in_group[current_cycle % 4] = 0;\n+\n       if (last_clock == clock)\n \t{\n \t  state_transition (curr_state, dfa_stop_insn);\n@@ -6716,19 +6893,24 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n \t}\n       else if (reload_completed)\n \tsetup_clocks_p = TRUE;\n-      if (GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT\n-\t  || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)\n-\tstate_reset (curr_state);\n-      else\n+\n+      if (last_scheduled_insn)\n \t{\n-\t  memcpy (curr_state, prev_cycle_state, dfa_state_size);\n-\t  state_transition (curr_state, dfa_stop_insn);\n-\t  state_transition (curr_state, dfa_pre_cycle_insn);\n-\t  state_transition (curr_state, NULL);\n+\t  if (GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT\n+\t      || asm_noperands (PATTERN (last_scheduled_insn)) >= 0)\n+\t    state_reset (curr_state);\n+\t  else\n+\t    {\n+\t      memcpy (curr_state, prev_cycle_state, dfa_state_size);\n+\t      state_transition (curr_state, dfa_stop_insn);\n+\t      state_transition (curr_state, dfa_pre_cycle_insn);\n+\t      state_transition (curr_state, NULL);\n+\t    }\n \t}\n     }\n   else if (reload_completed)\n     setup_clocks_p = TRUE;\n+\n   if (setup_clocks_p && ia64_tune == PROCESSOR_ITANIUM\n       && GET_CODE (PATTERN (insn)) != ASM_INPUT\n       && asm_noperands (PATTERN (insn)) < 0)\n@@ -6759,6 +6941,7 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n \t    add_cycles [INSN_UID (insn)] = 3 - d;\n \t}\n     }\n+\n   return 0;\n }\n \n@@ -6767,18 +6950,9 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n static void\n ia64_h_i_d_extended (void)\n {\n-  if (current_sched_info->flags & DO_SPECULATION)\n-    {\n-      int new_max_uid = get_max_uid () + 1;\n-\n-      spec_check_no = (int *) xrecalloc (spec_check_no, new_max_uid,\n-\t\t\t\t max_uid, sizeof (*spec_check_no));\n-      max_uid = new_max_uid;\n-    }\n-\n   if (stops_p != NULL) \n     {\n-      int new_clocks_length = get_max_uid () + 1;\n+      int new_clocks_length = get_max_uid () * 3 / 2;\n       \n       stops_p = (char *) xrecalloc (stops_p, new_clocks_length, clocks_length, 1);\n       \n@@ -6793,6 +6967,203 @@ ia64_h_i_d_extended (void)\n       clocks_length = new_clocks_length;\n     }\n }\n+\f\n+\n+/* This structure describes the data used by the backend to guide scheduling.\n+   When the current scheduling point is switched, this data should be saved\n+   and restored later, if the scheduler returns to this point.  */\n+struct _ia64_sched_context\n+{\n+  state_t prev_cycle_state;\n+  rtx last_scheduled_insn;\n+  struct reg_write_state rws_sum[NUM_REGS];\n+  struct reg_write_state rws_insn[NUM_REGS];\n+  int first_instruction;\n+  int pending_data_specs;\n+  int current_cycle;\n+  char mem_ops_in_group[4];\n+};\n+typedef struct _ia64_sched_context *ia64_sched_context_t;\n+\n+/* Allocates a scheduling context.  */\n+static void *\n+ia64_alloc_sched_context (void)\n+{\n+  return xmalloc (sizeof (struct _ia64_sched_context));\n+}\n+\n+/* Initializes the _SC context with clean data, if CLEAN_P, and from\n+   the global context otherwise.  */\n+static void\n+ia64_init_sched_context (void *_sc, bool clean_p)\n+{\n+  ia64_sched_context_t sc = (ia64_sched_context_t) _sc;\n+\n+  sc->prev_cycle_state = xmalloc (dfa_state_size);\n+  if (clean_p)\n+    {\n+      state_reset (sc->prev_cycle_state);\n+      sc->last_scheduled_insn = NULL_RTX;\n+      memset (sc->rws_sum, 0, sizeof (rws_sum));\n+      memset (sc->rws_insn, 0, sizeof (rws_insn));\n+      sc->first_instruction = 1;\n+      sc->pending_data_specs = 0;\n+      sc->current_cycle = 0;\n+      memset (sc->mem_ops_in_group, 0, sizeof (mem_ops_in_group));\n+    }\n+  else\n+    {\n+      memcpy (sc->prev_cycle_state, prev_cycle_state, dfa_state_size);\n+      sc->last_scheduled_insn = last_scheduled_insn;\n+      memcpy (sc->rws_sum, rws_sum, sizeof (rws_sum));\n+      memcpy (sc->rws_insn, rws_insn, sizeof (rws_insn));\n+      sc->first_instruction = first_instruction;\n+      sc->pending_data_specs = pending_data_specs;\n+      sc->current_cycle = current_cycle;\n+      memcpy (sc->mem_ops_in_group, mem_ops_in_group, sizeof (mem_ops_in_group));\n+    }\n+}\n+\n+/* Sets the global scheduling context to the one pointed to by _SC.  */\n+static void\n+ia64_set_sched_context (void *_sc)\n+{\n+  ia64_sched_context_t sc = (ia64_sched_context_t) _sc;\n+\n+  gcc_assert (sc != NULL);\n+\n+  memcpy (prev_cycle_state, sc->prev_cycle_state, dfa_state_size);\n+  last_scheduled_insn = sc->last_scheduled_insn;\n+  memcpy (rws_sum, sc->rws_sum, sizeof (rws_sum));\n+  memcpy (rws_insn, sc->rws_insn, sizeof (rws_insn));\n+  first_instruction = sc->first_instruction;\n+  pending_data_specs = sc->pending_data_specs;\n+  current_cycle = sc->current_cycle;\n+  memcpy (mem_ops_in_group, sc->mem_ops_in_group, sizeof (mem_ops_in_group));\n+}\n+\n+/* Clears the data in the _SC scheduling context.  */\n+static void\n+ia64_clear_sched_context (void *_sc)\n+{\n+  ia64_sched_context_t sc = (ia64_sched_context_t) _sc;\n+  \n+  free (sc->prev_cycle_state);\n+  sc->prev_cycle_state = NULL;\n+}\n+\n+/* Frees the _SC scheduling context.  */\n+static void\n+ia64_free_sched_context (void *_sc)\n+{\n+  gcc_assert (_sc != NULL);\n+\n+  free (_sc);\n+}\n+\n+typedef rtx (* gen_func_t) (rtx, rtx);\n+\n+/* Return a function that will generate a load of mode MODE_NO\n+   with speculation types TS.  */\n+static gen_func_t\n+get_spec_load_gen_function (ds_t ts, int mode_no)\n+{\n+  static gen_func_t gen_ld_[] = {\n+    gen_movbi,\n+    gen_movqi_internal,\n+    gen_movhi_internal,\n+    gen_movsi_internal,\n+    gen_movdi_internal,\n+    gen_movsf_internal,\n+    gen_movdf_internal,\n+    gen_movxf_internal,\n+    gen_movti_internal,\n+    gen_zero_extendqidi2,\n+    gen_zero_extendhidi2,\n+    gen_zero_extendsidi2,\n+  };\n+\n+  static gen_func_t gen_ld_a[] = {\n+    gen_movbi_advanced,\n+    gen_movqi_advanced,\n+    gen_movhi_advanced,\n+    gen_movsi_advanced,\n+    gen_movdi_advanced,\n+    gen_movsf_advanced,\n+    gen_movdf_advanced,\n+    gen_movxf_advanced,\n+    gen_movti_advanced,\n+    gen_zero_extendqidi2_advanced,\n+    gen_zero_extendhidi2_advanced,\n+    gen_zero_extendsidi2_advanced,\n+  };\n+  static gen_func_t gen_ld_s[] = {\n+    gen_movbi_speculative,\n+    gen_movqi_speculative,\n+    gen_movhi_speculative,\n+    gen_movsi_speculative,\n+    gen_movdi_speculative,\n+    gen_movsf_speculative,\n+    gen_movdf_speculative,\n+    gen_movxf_speculative,\n+    gen_movti_speculative,\n+    gen_zero_extendqidi2_speculative,\n+    gen_zero_extendhidi2_speculative,\n+    gen_zero_extendsidi2_speculative,\n+  };\n+  static gen_func_t gen_ld_sa[] = {\n+    gen_movbi_speculative_advanced,\n+    gen_movqi_speculative_advanced,\n+    gen_movhi_speculative_advanced,\n+    gen_movsi_speculative_advanced,\n+    gen_movdi_speculative_advanced,\n+    gen_movsf_speculative_advanced,\n+    gen_movdf_speculative_advanced,\n+    gen_movxf_speculative_advanced,\n+    gen_movti_speculative_advanced,\n+    gen_zero_extendqidi2_speculative_advanced,\n+    gen_zero_extendhidi2_speculative_advanced,\n+    gen_zero_extendsidi2_speculative_advanced,\n+  };\n+  static gen_func_t gen_ld_s_a[] = {\n+    gen_movbi_speculative_a,\n+    gen_movqi_speculative_a,\n+    gen_movhi_speculative_a,\n+    gen_movsi_speculative_a,\n+    gen_movdi_speculative_a,\n+    gen_movsf_speculative_a,\n+    gen_movdf_speculative_a,\n+    gen_movxf_speculative_a,\n+    gen_movti_speculative_a,\n+    gen_zero_extendqidi2_speculative_a,\n+    gen_zero_extendhidi2_speculative_a,\n+    gen_zero_extendsidi2_speculative_a,\n+  };\n+\n+  gen_func_t *gen_ld;\n+\n+  if (ts & BEGIN_DATA)\n+    {\n+      if (ts & BEGIN_CONTROL)\n+\tgen_ld = gen_ld_sa;\n+      else\n+\tgen_ld = gen_ld_a;\n+    }\n+  else if (ts & BEGIN_CONTROL)\n+    {\n+      if ((spec_info->flags & SEL_SCHED_SPEC_DONT_CHECK_CONTROL)\n+\t  || ia64_needs_block_p (ts))\n+\tgen_ld = gen_ld_s;\n+      else\n+\tgen_ld = gen_ld_s_a;\n+    }\n+  else if (ts == 0)\n+    gen_ld = gen_ld_;\n+  else\n+    gcc_unreachable ();\n+\n+  return gen_ld[mode_no];\n+}\n \n /* Constants that help mapping 'enum machine_mode' to int.  */\n enum SPEC_MODES\n@@ -6804,6 +7175,12 @@ enum SPEC_MODES\n     SPEC_MODE_LAST = 8\n   };\n \n+enum\n+  {\n+    /* Offset to reach ZERO_EXTEND patterns.  */\n+    SPEC_GEN_EXTEND_OFFSET = SPEC_MODE_LAST - SPEC_MODE_FOR_EXTEND_FIRST + 1\n+  };\n+\n /* Return index of the MODE.  */\n static int\n ia64_mode_to_int (enum machine_mode mode)\n@@ -6834,25 +7211,29 @@ ia64_set_sched_flags (spec_info_t spec_info)\n   unsigned int *flags = &(current_sched_info->flags);\n \n   if (*flags & SCHED_RGN\n-      || *flags & SCHED_EBB)  \n+      || *flags & SCHED_EBB\n+      || *flags & SEL_SCHED)\n     {\n       int mask = 0;\n \n       if ((mflag_sched_br_data_spec && !reload_completed && optimize > 0)\n-\t  || (mflag_sched_ar_data_spec && reload_completed))\n+          || (mflag_sched_ar_data_spec && reload_completed))\n \t{\n \t  mask |= BEGIN_DATA;\n-\t  \n-\t  if ((mflag_sched_br_in_data_spec && !reload_completed)\n-\t      || (mflag_sched_ar_in_data_spec && reload_completed))\n+\n+\t  if (!sel_sched_p ()\n+\t      && ((mflag_sched_br_in_data_spec && !reload_completed)\n+\t\t  || (mflag_sched_ar_in_data_spec && reload_completed)))\n \t    mask |= BE_IN_DATA;\n \t}\n       \n-      if (mflag_sched_control_spec)\n+      if (mflag_sched_control_spec\n+          && (!sel_sched_p ()\n+\t      || reload_completed))\n \t{\n \t  mask |= BEGIN_CONTROL;\n \t  \n-\t  if (mflag_sched_in_control_spec)\n+\t  if (!sel_sched_p () && mflag_sched_in_control_spec)\n \t    mask |= BE_IN_CONTROL;\n \t}\n \n@@ -6870,17 +7251,17 @@ ia64_set_sched_flags (spec_info_t spec_info)\n \t  if ((mask & DATA_SPEC) && mflag_sched_prefer_non_data_spec_insns)\n \t    spec_info->flags |= PREFER_NON_DATA_SPEC;\n \n-\t  if ((mask & CONTROL_SPEC)\n-\t      && mflag_sched_prefer_non_control_spec_insns)\n-\t    spec_info->flags |= PREFER_NON_CONTROL_SPEC;\n-\n-\t  if (mflag_sched_spec_verbose)\n+\t  if (mask & CONTROL_SPEC)\n \t    {\n-\t      if (sched_verbose >= 1)\n-\t\tspec_info->dump = sched_dump;\n-\t      else\n-\t\tspec_info->dump = stderr;\n+\t      if (mflag_sched_prefer_non_control_spec_insns)\n+\t\tspec_info->flags |= PREFER_NON_CONTROL_SPEC;\n+\n+\t      if (sel_sched_p () && mflag_sel_sched_dont_check_control_spec)\n+\t\tspec_info->flags |= SEL_SCHED_SPEC_DONT_CHECK_CONTROL;\n \t    }\n+\n+\t  if (sched_verbose >= 1)\n+\t    spec_info->dump = sched_dump;\n \t  else\n \t    spec_info->dump = 0;\n \t  \n@@ -6890,304 +7271,284 @@ ia64_set_sched_flags (spec_info_t spec_info)\n     }\n }\n \n-/* Implement targetm.sched.speculate_insn hook.\n-   Check if the INSN can be TS speculative.\n-   If 'no' - return -1.\n-   If 'yes' - generate speculative pattern in the NEW_PAT and return 1.\n-   If current pattern of the INSN already provides TS speculation, return 0.  */\n+/* If INSN is an appropriate load return its mode.\n+   Return -1 otherwise.  */\n static int\n-ia64_speculate_insn (rtx insn, ds_t ts, rtx *new_pat)\n-{  \n-  rtx pat, reg, mem, mem_reg;\n-  int mode_no, gen_p = 1;\n+get_mode_no_for_insn (rtx insn)\n+{\n+  rtx reg, mem, mode_rtx;\n+  int mode_no;\n   bool extend_p;\n-  \n-  gcc_assert (!(ts & ~BEGIN_SPEC) && ts);\n-           \n-  pat = PATTERN (insn);\n \n-  if (GET_CODE (pat) == COND_EXEC)\n-    pat = COND_EXEC_CODE (pat);\n+  extract_insn_cached (insn);\n \n-  /* This should be a SET ...  */\n-  if (GET_CODE (pat) != SET)\n-    return -1;\n+  /* We use WHICH_ALTERNATIVE only after reload.  This will\n+     guarantee that reload won't touch a speculative insn.  */\n \n-  reg = SET_DEST (pat);\n-  /* ... to the general/fp register ...  */\n-  if (!REG_P (reg) || !(GR_REGNO_P (REGNO (reg)) || FP_REGNO_P (REGNO (reg))))\n+  if (recog_data.n_operands != 2)\n     return -1;\n \n-  /* ... from the mem ...  */\n-  mem = SET_SRC (pat);\n+  reg = recog_data.operand[0];\n+  mem = recog_data.operand[1];\n \n-  /* ... that can, possibly, be a zero_extend ...  */\n-  if (GET_CODE (mem) == ZERO_EXTEND)\n+  /* We should use MEM's mode since REG's mode in presence of\n+     ZERO_EXTEND will always be DImode.  */\n+  if (get_attr_speculable1 (insn) == SPECULABLE1_YES)\n+    /* Process non-speculative ld.  */\n+    {\n+      if (!reload_completed)\n+\t{\n+\t  /* Do not speculate into regs like ar.lc.  */\n+\t  if (!REG_P (reg) || AR_REGNO_P (REGNO (reg)))\n+\t    return -1;\n+\n+\t  if (!MEM_P (mem))\n+\t    return -1;\n+\n+\t  {\n+\t    rtx mem_reg = XEXP (mem, 0);\n+\n+\t    if (!REG_P (mem_reg))\n+\t      return -1;\n+\t  }\n+\n+\t  mode_rtx = mem;\n+\t}\n+      else if (get_attr_speculable2 (insn) == SPECULABLE2_YES)\n+\t{\n+\t  gcc_assert (REG_P (reg) && MEM_P (mem));\n+\t  mode_rtx = mem;\n+\t}\n+      else\n+\treturn -1;\n+    }\n+  else if (get_attr_data_speculative (insn) == DATA_SPECULATIVE_YES\n+\t   || get_attr_control_speculative (insn) == CONTROL_SPECULATIVE_YES\n+\t   || get_attr_check_load (insn) == CHECK_LOAD_YES)\n+    /* Process speculative ld or ld.c.  */\n     {\n-      mem = XEXP (mem, 0);\n-      extend_p = true;      \n+      gcc_assert (REG_P (reg) && MEM_P (mem));\n+      mode_rtx = mem;\n     }\n   else\n-    extend_p = false;\n-\n-  /* ... or a speculative load.  */\n-  if (GET_CODE (mem) == UNSPEC)\n     {\n-      int code;\n-      \n-      code = XINT (mem, 1);\n-      if (code != UNSPEC_LDA && code != UNSPEC_LDS && code != UNSPEC_LDSA)\n-\treturn -1;\n-\n-      if ((code == UNSPEC_LDA && !(ts & BEGIN_CONTROL))\n-\t  || (code == UNSPEC_LDS && !(ts & BEGIN_DATA))\n-\t  || code == UNSPEC_LDSA)\n-\tgen_p = 0;\n+      enum attr_itanium_class attr_class = get_attr_itanium_class (insn);\n \n-      mem = XVECEXP (mem, 0, 0);\n-      gcc_assert (MEM_P (mem));\n+      if (attr_class == ITANIUM_CLASS_CHK_A\n+\t  || attr_class == ITANIUM_CLASS_CHK_S_I\n+\t  || attr_class == ITANIUM_CLASS_CHK_S_F)\n+\t/* Process chk.  */\n+\tmode_rtx = reg;\n+      else\n+\treturn -1;\n     }\n \n-  /* Source should be a mem ...  */\n-  if (!MEM_P (mem))\n-    return -1;\n+  mode_no = ia64_mode_to_int (GET_MODE (mode_rtx));\n \n-  /* ... addressed by a register.  */\n-  mem_reg = XEXP (mem, 0);\n-  if (!REG_P (mem_reg))\n-    return -1;\n-     \n-  /* We should use MEM's mode since REG's mode in presence of ZERO_EXTEND\n-     will always be DImode.  */\n-  mode_no = ia64_mode_to_int (GET_MODE (mem));\n-  \n-  if (mode_no == SPEC_MODE_INVALID\n-      || (extend_p\n-\t  && !(SPEC_MODE_FOR_EXTEND_FIRST <= mode_no\n-\t       && mode_no <= SPEC_MODE_FOR_EXTEND_LAST)))\n+  if (mode_no == SPEC_MODE_INVALID)\n     return -1;\n \n-  extract_insn_cached (insn);\n-  gcc_assert (reg == recog_data.operand[0] && mem == recog_data.operand[1]);\n+  extend_p = (GET_MODE (reg) != GET_MODE (mode_rtx));\n+\n+  if (extend_p)\n+    {\n+      if (!(SPEC_MODE_FOR_EXTEND_FIRST <= mode_no\n+\t    && mode_no <= SPEC_MODE_FOR_EXTEND_LAST))\n+\treturn -1;\n \n-  *new_pat = ia64_gen_spec_insn (insn, ts, mode_no, gen_p != 0, extend_p);\n+      mode_no += SPEC_GEN_EXTEND_OFFSET;\n+    }\n \n-  return gen_p;\n+  return mode_no;\n }\n \n-enum\n-  {\n-    /* Offset to reach ZERO_EXTEND patterns.  */\n-    SPEC_GEN_EXTEND_OFFSET = SPEC_MODE_LAST - SPEC_MODE_FOR_EXTEND_FIRST + 1,\n-    /* Number of patterns for each speculation mode.  */\n-    SPEC_N = (SPEC_MODE_LAST\n-              + SPEC_MODE_FOR_EXTEND_LAST - SPEC_MODE_FOR_EXTEND_FIRST + 2)\n-  };\n+/* If X is an unspec part of a speculative load, return its code.\n+   Return -1 otherwise.  */\n+static int\n+get_spec_unspec_code (const_rtx x)\n+{\n+  if (GET_CODE (x) != UNSPEC)\n+    return -1;\n \n-enum SPEC_GEN_LD_MAP\n   {\n-    /* Offset to ld.a patterns.  */\n-    SPEC_GEN_A = 0 * SPEC_N,\n-    /* Offset to ld.s patterns.  */\n-    SPEC_GEN_S = 1 * SPEC_N,\n-    /* Offset to ld.sa patterns.  */\n-    SPEC_GEN_SA = 2 * SPEC_N,\n-    /* Offset to ld.sa patterns.  For this patterns corresponding ld.c will\n-       mutate to chk.s.  */\n-    SPEC_GEN_SA_FOR_S = 3 * SPEC_N\n-  };\n+    int code;\n \n-/* These offsets are used to get (4 * SPEC_N).  */\n-enum SPEC_GEN_CHECK_OFFSET\n-  {\n-    SPEC_GEN_CHKA_FOR_A_OFFSET = 4 * SPEC_N - SPEC_GEN_A,\n-    SPEC_GEN_CHKA_FOR_SA_OFFSET = 4 * SPEC_N - SPEC_GEN_SA\n-  };\n+    code = XINT (x, 1);\n \n-/* If GEN_P is true, calculate the index of needed speculation check and return\n-   speculative pattern for INSN with speculative mode TS, machine mode\n-   MODE_NO and with ZERO_EXTEND (if EXTEND_P is true).\n-   If GEN_P is false, just calculate the index of needed speculation check.  */\n-static rtx\n-ia64_gen_spec_insn (rtx insn, ds_t ts, int mode_no, bool gen_p, bool extend_p)\n-{\n-  rtx pat, new_pat;\n-  int load_no;\n-  int shift = 0;\n+    switch (code)\n+      {\n+      case UNSPEC_LDA:\n+      case UNSPEC_LDS:\n+      case UNSPEC_LDS_A:\n+      case UNSPEC_LDSA:\n+\treturn code;\n \n-  static rtx (* const gen_load[]) (rtx, rtx) = {\n-    gen_movbi_advanced,\n-    gen_movqi_advanced,\n-    gen_movhi_advanced,\n-    gen_movsi_advanced,\n-    gen_movdi_advanced,\n-    gen_movsf_advanced,\n-    gen_movdf_advanced,\n-    gen_movxf_advanced,\n-    gen_movti_advanced,\n-    gen_zero_extendqidi2_advanced,\n-    gen_zero_extendhidi2_advanced,\n-    gen_zero_extendsidi2_advanced,\n+      default:\n+\treturn -1;\n+      }\n+  }\n+}\n \n-    gen_movbi_speculative,\n-    gen_movqi_speculative,\n-    gen_movhi_speculative,\n-    gen_movsi_speculative,\n-    gen_movdi_speculative,\n-    gen_movsf_speculative,\n-    gen_movdf_speculative,\n-    gen_movxf_speculative,\n-    gen_movti_speculative,\n-    gen_zero_extendqidi2_speculative,\n-    gen_zero_extendhidi2_speculative,\n-    gen_zero_extendsidi2_speculative,\n+/* Implement skip_rtx_p hook.  */\n+static bool\n+ia64_skip_rtx_p (const_rtx x)\n+{\n+  return get_spec_unspec_code (x) != -1;\n+}\n \n-    gen_movbi_speculative_advanced,\n-    gen_movqi_speculative_advanced,\n-    gen_movhi_speculative_advanced,\n-    gen_movsi_speculative_advanced,\n-    gen_movdi_speculative_advanced,\n-    gen_movsf_speculative_advanced,\n-    gen_movdf_speculative_advanced,\n-    gen_movxf_speculative_advanced,\n-    gen_movti_speculative_advanced,\n-    gen_zero_extendqidi2_speculative_advanced,\n-    gen_zero_extendhidi2_speculative_advanced,\n-    gen_zero_extendsidi2_speculative_advanced,\n+/* If INSN is a speculative load, return its UNSPEC code.\n+   Return -1 otherwise.  */\n+static int\n+get_insn_spec_code (const_rtx insn)\n+{\n+  rtx pat, reg, mem;\n \n-    gen_movbi_speculative_advanced,\n-    gen_movqi_speculative_advanced,\n-    gen_movhi_speculative_advanced,\n-    gen_movsi_speculative_advanced,\n-    gen_movdi_speculative_advanced,\n-    gen_movsf_speculative_advanced,\n-    gen_movdf_speculative_advanced,\n-    gen_movxf_speculative_advanced,\n-    gen_movti_speculative_advanced,\n-    gen_zero_extendqidi2_speculative_advanced,\n-    gen_zero_extendhidi2_speculative_advanced,\n-    gen_zero_extendsidi2_speculative_advanced\n-  };\n+  pat = PATTERN (insn);\n \n-  load_no = extend_p ? mode_no + SPEC_GEN_EXTEND_OFFSET : mode_no;\n+  if (GET_CODE (pat) == COND_EXEC)\n+    pat = COND_EXEC_CODE (pat);\n \n-  if (ts & BEGIN_DATA)\n+  if (GET_CODE (pat) != SET)\n+    return -1;\n+\n+  reg = SET_DEST (pat);\n+  if (!REG_P (reg))\n+    return -1;\n+\n+  mem = SET_SRC (pat);\n+  if (GET_CODE (mem) == ZERO_EXTEND)\n+    mem = XEXP (mem, 0);\n+\n+  return get_spec_unspec_code (mem);\n+}\n+\n+/* If INSN is a speculative load, return a ds with the speculation types.\n+   Otherwise [if INSN is a normal instruction] return 0.  */\n+static ds_t\n+ia64_get_insn_spec_ds (rtx insn)\n+{\n+  int code = get_insn_spec_code (insn);\n+\n+  switch (code)\n     {\n-      /* We don't need recovery because even if this is ld.sa\n-\t ALAT entry will be allocated only if NAT bit is set to zero. \n-\t So it is enough to use ld.c here.  */\t  \n+    case UNSPEC_LDA:\n+      return BEGIN_DATA;\n \n-      if (ts & BEGIN_CONTROL)\n-\t{\t      \n-\t  load_no += SPEC_GEN_SA;\n+    case UNSPEC_LDS:\n+    case UNSPEC_LDS_A:\n+      return BEGIN_CONTROL;\n \n-\t  if (!mflag_sched_ldc)\n-\t    shift = SPEC_GEN_CHKA_FOR_SA_OFFSET;\n-\t}\n-      else\n-\t{\n-\t  load_no += SPEC_GEN_A;\n+    case UNSPEC_LDSA:\n+      return BEGIN_DATA | BEGIN_CONTROL;\n \n-\t  if (!mflag_sched_ldc)\t\t\n-\t    shift = SPEC_GEN_CHKA_FOR_A_OFFSET;\n-\t}\n+    default:\n+      return 0;\n     }\n-  else if (ts & BEGIN_CONTROL)\n+}\n+\n+/* If INSN is a speculative load return a ds with the speculation types that\n+   will be checked.\n+   Otherwise [if INSN is a normal instruction] return 0.  */\n+static ds_t\n+ia64_get_insn_checked_ds (rtx insn)\n+{\n+  int code = get_insn_spec_code (insn);\n+\n+  switch (code)\n     {\n-      /* ld.sa can be used instead of ld.s to avoid basic block splitting.  */\n-      if (!mflag_control_ldc)\n-\tload_no += SPEC_GEN_S;\n-      else\n-\t{\n-\t  gcc_assert (mflag_sched_ldc);\n-\t  load_no += SPEC_GEN_SA_FOR_S;\n-\t}\n+    case UNSPEC_LDA:\n+      return BEGIN_DATA | BEGIN_CONTROL;\n+\n+    case UNSPEC_LDS:\n+      return BEGIN_CONTROL;\n+\n+    case UNSPEC_LDS_A:\n+    case UNSPEC_LDSA:\n+      return BEGIN_DATA | BEGIN_CONTROL;\n+\n+    default:\n+      return 0;\n     }\n-  else\n-    gcc_unreachable ();\n+}\n \n-  /* Set the desired check index.  We add '1', because zero element in this\n-     array means, that instruction with such uid is non-speculative.  */\n-  spec_check_no[INSN_UID (insn)] = load_no + shift + 1;\n+/* If GEN_P is true, calculate the index of needed speculation check and return\n+   speculative pattern for INSN with speculative mode TS, machine mode\n+   MODE_NO and with ZERO_EXTEND (if EXTEND_P is true).\n+   If GEN_P is false, just calculate the index of needed speculation check.  */\n+static rtx\n+ia64_gen_spec_load (rtx insn, ds_t ts, int mode_no)\n+{\n+  rtx pat, new_pat;\n+  gen_func_t gen_load;\n \n-  if (!gen_p)\n-    return 0;\n+  gen_load = get_spec_load_gen_function (ts, mode_no);\n \n-  new_pat = gen_load[load_no] (copy_rtx (recog_data.operand[0]),\n-\t\t\t       copy_rtx (recog_data.operand[1]));\n+  new_pat = gen_load (copy_rtx (recog_data.operand[0]),\n+\t\t      copy_rtx (recog_data.operand[1]));\n \n   pat = PATTERN (insn);\n   if (GET_CODE (pat) == COND_EXEC)\n-    new_pat = gen_rtx_COND_EXEC (VOIDmode, copy_rtx \n-\t\t\t\t (COND_EXEC_TEST (pat)), new_pat);\n+    new_pat = gen_rtx_COND_EXEC (VOIDmode, copy_rtx (COND_EXEC_TEST (pat)),\n+\t\t\t\t new_pat);\n \n   return new_pat;\n }\n \n-/* Offset to branchy checks.  */\n-enum { SPEC_GEN_CHECK_MUTATION_OFFSET = 5 * SPEC_N };\n-\n-/* Return nonzero, if INSN needs branchy recovery check.  */\n static bool\n-ia64_needs_block_p (const_rtx insn)\n+insn_can_be_in_speculative_p (rtx insn ATTRIBUTE_UNUSED,\n+\t\t\t      ds_t ds ATTRIBUTE_UNUSED)\n {\n-  int check_no;\n+  return false;\n+}\n \n-  check_no = spec_check_no[INSN_UID(insn)] - 1;\n-  gcc_assert (0 <= check_no && check_no < SPEC_GEN_CHECK_MUTATION_OFFSET);\n+/* Implement targetm.sched.speculate_insn hook.\n+   Check if the INSN can be TS speculative.\n+   If 'no' - return -1.\n+   If 'yes' - generate speculative pattern in the NEW_PAT and return 1.\n+   If current pattern of the INSN already provides TS speculation,\n+   return 0.  */\n+static int\n+ia64_speculate_insn (rtx insn, ds_t ts, rtx *new_pat)\n+{  \n+  int mode_no;\n+  int res;\n+  \n+  gcc_assert (!(ts & ~SPECULATIVE));\n \n-  return ((SPEC_GEN_S <= check_no && check_no < SPEC_GEN_S + SPEC_N)\n-\t  || (4 * SPEC_N <= check_no && check_no < 4 * SPEC_N + SPEC_N));\n-}\n+  if (ia64_spec_check_p (insn))\n+    return -1;\n \n-/* Generate (or regenerate, if (MUTATE_P)) recovery check for INSN.\n-   If (LABEL != 0 || MUTATE_P), generate branchy recovery check.\n-   Otherwise, generate a simple check.  */\n-static rtx\n-ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n-{\n-  rtx op1, pat, check_pat;\n+  if ((ts & BE_IN_SPEC)\n+      && !insn_can_be_in_speculative_p (insn, ts))\n+    return -1;\n \n-  static rtx (* const gen_check[]) (rtx, rtx) = {\n-    gen_movbi_clr,\n-    gen_movqi_clr,\n-    gen_movhi_clr,\n-    gen_movsi_clr,\n-    gen_movdi_clr,\n-    gen_movsf_clr,\n-    gen_movdf_clr,\n-    gen_movxf_clr,\n-    gen_movti_clr,\n-    gen_zero_extendqidi2_clr,\n-    gen_zero_extendhidi2_clr,\n-    gen_zero_extendsidi2_clr,\n+  mode_no = get_mode_no_for_insn (insn);\n \n-    gen_speculation_check_bi,\n-    gen_speculation_check_qi,\n-    gen_speculation_check_hi,\n-    gen_speculation_check_si,\n-    gen_speculation_check_di,\n-    gen_speculation_check_sf,\n-    gen_speculation_check_df,\n-    gen_speculation_check_xf,\n-    gen_speculation_check_ti,\n-    gen_speculation_check_di,\n-    gen_speculation_check_di,\n-    gen_speculation_check_di,\n+  if (mode_no != SPEC_MODE_INVALID)\n+    {\n+      if (ia64_get_insn_spec_ds (insn) == ds_get_speculation_types (ts))\n+\tres = 0;\n+      else\n+\t{\n+\t  res = 1;\n+\t  *new_pat = ia64_gen_spec_load (insn, ts, mode_no);\n+\t}\n+    }\n+  else\n+    res = -1;\n \n-    gen_movbi_clr,\n-    gen_movqi_clr,\n-    gen_movhi_clr,\n-    gen_movsi_clr,\n-    gen_movdi_clr,\n-    gen_movsf_clr,\n-    gen_movdf_clr,\n-    gen_movxf_clr,\n-    gen_movti_clr,\n-    gen_zero_extendqidi2_clr,\n-    gen_zero_extendhidi2_clr,\n-    gen_zero_extendsidi2_clr,\n+  return res;\n+}\n \n+/* Return a function that will generate a check for speculation TS with mode\n+   MODE_NO.\n+   If simple check is needed, pass true for SIMPLE_CHECK_P.\n+   If clearing check is needed, pass true for CLEARING_CHECK_P.  */\n+static gen_func_t\n+get_spec_check_gen_function (ds_t ts, int mode_no,\n+\t\t\t     bool simple_check_p, bool clearing_check_p)\n+{\n+  static gen_func_t gen_ld_c_clr[] = {\n     gen_movbi_clr,\n     gen_movqi_clr,\n     gen_movhi_clr,\n@@ -7200,36 +7561,22 @@ ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n     gen_zero_extendqidi2_clr,\n     gen_zero_extendhidi2_clr,\n     gen_zero_extendsidi2_clr,\n-\n-    gen_advanced_load_check_clr_bi,\n-    gen_advanced_load_check_clr_qi,\n-    gen_advanced_load_check_clr_hi,\n-    gen_advanced_load_check_clr_si,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_sf,\n-    gen_advanced_load_check_clr_df,\n-    gen_advanced_load_check_clr_xf,\n-    gen_advanced_load_check_clr_ti,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_di,\n-\n-    /* Following checks are generated during mutation.  */\n-    gen_advanced_load_check_clr_bi,\n-    gen_advanced_load_check_clr_qi,\n-    gen_advanced_load_check_clr_hi,\n-    gen_advanced_load_check_clr_si,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_sf,\n-    gen_advanced_load_check_clr_df,\n-    gen_advanced_load_check_clr_xf,\n-    gen_advanced_load_check_clr_ti,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_di,\n-    gen_advanced_load_check_clr_di,\n-\n-    0,0,0,0,0,0,0,0,0,0,0,0,\n-\n+  };\n+  static gen_func_t gen_ld_c_nc[] = {\n+    gen_movbi_nc,\n+    gen_movqi_nc,\n+    gen_movhi_nc,\n+    gen_movsi_nc,\n+    gen_movdi_nc,\n+    gen_movsf_nc,\n+    gen_movdf_nc,\n+    gen_movxf_nc,\n+    gen_movti_nc,\n+    gen_zero_extendqidi2_nc,\n+    gen_zero_extendhidi2_nc,\n+    gen_zero_extendsidi2_nc,\n+  };\n+  static gen_func_t gen_chk_a_clr[] = {\n     gen_advanced_load_check_clr_bi,\n     gen_advanced_load_check_clr_qi,\n     gen_advanced_load_check_clr_hi,\n@@ -7242,7 +7589,22 @@ ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n     gen_advanced_load_check_clr_di,\n     gen_advanced_load_check_clr_di,\n     gen_advanced_load_check_clr_di,\n-\n+  };\n+  static gen_func_t gen_chk_a_nc[] = {\n+    gen_advanced_load_check_nc_bi,\n+    gen_advanced_load_check_nc_qi,\n+    gen_advanced_load_check_nc_hi,\n+    gen_advanced_load_check_nc_si,\n+    gen_advanced_load_check_nc_di,\n+    gen_advanced_load_check_nc_sf,\n+    gen_advanced_load_check_nc_df,\n+    gen_advanced_load_check_nc_xf,\n+    gen_advanced_load_check_nc_ti,\n+    gen_advanced_load_check_nc_di,\n+    gen_advanced_load_check_nc_di,\n+    gen_advanced_load_check_nc_di,\n+  };\n+  static gen_func_t gen_chk_s[] = {\n     gen_speculation_check_bi,\n     gen_speculation_check_qi,\n     gen_speculation_check_hi,\n@@ -7254,49 +7616,96 @@ ia64_gen_check (rtx insn, rtx label, bool mutate_p)\n     gen_speculation_check_ti,\n     gen_speculation_check_di,\n     gen_speculation_check_di,\n-    gen_speculation_check_di\n+    gen_speculation_check_di,\n   };\n \n-  extract_insn_cached (insn);\n+  gen_func_t *gen_check;\n \n-  if (label)\n-    {\n-      gcc_assert (mutate_p || ia64_needs_block_p (insn));\n-      op1 = label;\n-    }\n-  else\n+  if (ts & BEGIN_DATA)\n     {\n-      gcc_assert (!mutate_p && !ia64_needs_block_p (insn));\n-      op1 = copy_rtx (recog_data.operand[1]);\n+      /* We don't need recovery because even if this is ld.sa\n+\t ALAT entry will be allocated only if NAT bit is set to zero.\n+\t So it is enough to use ld.c here.  */\n+\n+      if (simple_check_p)\n+\t{\n+\t  gcc_assert (mflag_sched_spec_ldc);\n+\n+\t  if (clearing_check_p)\n+\t    gen_check = gen_ld_c_clr;\n+\t  else\n+\t    gen_check = gen_ld_c_nc;\n+\t}\n+      else\n+\t{\n+\t  if (clearing_check_p)\n+\t    gen_check = gen_chk_a_clr;\n+\t  else\n+\t    gen_check = gen_chk_a_nc;\n+\t}\n     }\n-      \n-  if (mutate_p)\n-    /* INSN is ld.c.\n-       Find the speculation check number by searching for original\n-       speculative load in the RESOLVED_DEPS list of INSN.\n-       As long as patterns are unique for each instruction, this can be\n-       accomplished by matching ORIG_PAT fields.  */\n+  else if (ts & BEGIN_CONTROL)\n     {\n-      sd_iterator_def sd_it;\n-      dep_t dep;\n-      int check_no = 0;\n-      rtx orig_pat = ORIG_PAT (insn);\n-\n-      FOR_EACH_DEP (insn, SD_LIST_RES_BACK, sd_it, dep)\n+      if (simple_check_p)\n+\t/* We might want to use ld.sa -> ld.c instead of\n+\t   ld.s -> chk.s.  */\n \t{\n-\t  rtx x = DEP_PRO (dep);\n+\t  gcc_assert (!ia64_needs_block_p (ts));\n \n-\t  if (ORIG_PAT (x) == orig_pat)\n-\t    check_no = spec_check_no[INSN_UID (x)];\n+\t  if (clearing_check_p)\n+\t    gen_check = gen_ld_c_clr;\n+\t  else\n+\t    gen_check = gen_ld_c_nc;\n+\t}\n+      else\n+\t{\n+\t  gen_check = gen_chk_s;\n \t}\n-      gcc_assert (check_no);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  gcc_assert (mode_no >= 0);\n+  return gen_check[mode_no];\n+}\n+\n+/* Return nonzero, if INSN needs branchy recovery check.  */\n+static bool\n+ia64_needs_block_p (ds_t ts)\n+{\n+  if (ts & BEGIN_DATA)\n+    return !mflag_sched_spec_ldc;\n+\n+  gcc_assert ((ts & BEGIN_CONTROL) != 0);\n \n-      spec_check_no[INSN_UID (insn)] = (check_no\n-\t\t\t\t\t+ SPEC_GEN_CHECK_MUTATION_OFFSET);\n+  return !(mflag_sched_spec_control_ldc && mflag_sched_spec_ldc);\n+}\n+\n+/* Generate (or regenerate, if (MUTATE_P)) recovery check for INSN.\n+   If (LABEL != 0 || MUTATE_P), generate branchy recovery check.\n+   Otherwise, generate a simple check.  */\n+static rtx\n+ia64_gen_spec_check (rtx insn, rtx label, ds_t ds)\n+{\n+  rtx op1, pat, check_pat;\n+  gen_func_t gen_check;\n+  int mode_no;\n+\n+  mode_no = get_mode_no_for_insn (insn);\n+  gcc_assert (mode_no >= 0);\n+\n+  if (label)\n+    op1 = label;\n+  else\n+    {\n+      gcc_assert (!ia64_needs_block_p (ds));\n+      op1 = copy_rtx (recog_data.operand[1]);\n     }\n+      \n+  gen_check = get_spec_check_gen_function (ds, mode_no, label == NULL_RTX,\n+\t\t\t\t\t   true);\n \n-  check_pat = (gen_check[spec_check_no[INSN_UID (insn)] - 1]\n-\t       (copy_rtx (recog_data.operand[0]), op1));\n+  check_pat = gen_check (copy_rtx (recog_data.operand[0]), op1);\n     \n   pat = PATTERN (insn);\n   if (GET_CODE (pat) == COND_EXEC)\n@@ -7337,9 +7746,11 @@ ia64_spec_check_src_p (rtx src)\n \t      \n \t      code = XINT (t, 1);\n \t     \n-\t      if (code == UNSPEC_CHKACLR\n-\t\t  || code == UNSPEC_CHKS\n-\t\t  || code == UNSPEC_LDCCLR)\n+\t      if (code == UNSPEC_LDCCLR\n+\t\t  || code == UNSPEC_LDCNC\n+\t\t  || code == UNSPEC_CHKACLR\n+\t\t  || code == UNSPEC_CHKANC\n+\t\t  || code == UNSPEC_CHKS)\n \t\t{\n \t\t  gcc_assert (code != 0);\n \t\t  return code;\n@@ -7370,6 +7781,7 @@ struct bundle_state\n   int accumulated_insns_num; /* number of all previous insns including\n \t\t\t\tnops.  L is considered as 2 insns */\n   int branch_deviation; /* deviation of previous branches from 3rd slots  */\n+  int middle_bundle_stops; /* number of stop bits in the middle of bundles */\n   struct bundle_state *next;  /* next state with the same insn_num  */\n   struct bundle_state *originator; /* originator (previous insn state)  */\n   /* All bundle states are in the following chain.  */\n@@ -7515,9 +7927,15 @@ insert_bundle_state (struct bundle_state *bundle_state)\n \t\t   || (((struct bundle_state *)\n \t\t\t*entry_ptr)->accumulated_insns_num\n \t\t       == bundle_state->accumulated_insns_num\n-\t\t       && ((struct bundle_state *)\n-\t\t\t   *entry_ptr)->branch_deviation\n-\t\t       > bundle_state->branch_deviation))))\n+\t\t       && (((struct bundle_state *)\n+\t\t\t    *entry_ptr)->branch_deviation\n+\t\t\t   > bundle_state->branch_deviation\n+\t\t\t   || (((struct bundle_state *)\n+\t\t\t\t*entry_ptr)->branch_deviation\n+\t\t\t       == bundle_state->branch_deviation\n+\t\t\t       && ((struct bundle_state *)\n+\t\t\t\t   *entry_ptr)->middle_bundle_stops\n+\t\t\t       > bundle_state->middle_bundle_stops))))))\n \n     {\n       struct bundle_state temp;\n@@ -7611,6 +8029,7 @@ issue_nops_and_insn (struct bundle_state *originator, int before_nops_num,\n   curr_state->accumulated_insns_num\n     = originator->accumulated_insns_num + before_nops_num;\n   curr_state->branch_deviation = originator->branch_deviation;\n+  curr_state->middle_bundle_stops = originator->middle_bundle_stops;\n   gcc_assert (insn);\n   if (INSN_CODE (insn) == CODE_FOR_insn_group_barrier)\n     {\n@@ -7620,6 +8039,8 @@ issue_nops_and_insn (struct bundle_state *originator, int before_nops_num,\n       if (!try_issue_insn (curr_state, insn))\n \treturn;\n       memcpy (temp_dfa_state, curr_state->dfa_state, dfa_state_size);\n+      if (curr_state->accumulated_insns_num % 3 != 0)\n+\tcurr_state->middle_bundle_stops++;\n       if (state_transition (temp_dfa_state, dfa_pre_cycle_insn) >= 0\n \t  && curr_state->accumulated_insns_num % 3 != 0)\n \t{\n@@ -7795,17 +8216,24 @@ get_template (state_t state, int pos)\n     }\n }\n \n+/* True when INSN is important for bundling.  */\n+static bool\n+important_for_bundling_p (rtx insn)\n+{\n+  return (INSN_P (insn)\n+\t  && ia64_safe_itanium_class (insn) != ITANIUM_CLASS_IGNORE\n+\t  && GET_CODE (PATTERN (insn)) != USE\n+\t  && GET_CODE (PATTERN (insn)) != CLOBBER);\n+}\n+\n /* The following function returns an insn important for insn bundling\n    followed by INSN and before TAIL.  */\n \n static rtx\n get_next_important_insn (rtx insn, rtx tail)\n {\n   for (; insn && insn != tail; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& ia64_safe_itanium_class (insn) != ITANIUM_CLASS_IGNORE\n-\t&& GET_CODE (PATTERN (insn)) != USE\n-\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n+    if (important_for_bundling_p (insn))\n       return insn;\n   return NULL_RTX;\n }\n@@ -7930,6 +8358,7 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n   curr_state->cost = 0;\n   curr_state->accumulated_insns_num = 0;\n   curr_state->branch_deviation = 0;\n+  curr_state->middle_bundle_stops = 0;\n   curr_state->next = NULL;\n   curr_state->originator = NULL;\n   state_reset (curr_state->dfa_state);\n@@ -7952,7 +8381,8 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t  if (INSN_P (next_insn)\n \t      && ia64_safe_itanium_class (next_insn) != ITANIUM_CLASS_IGNORE\n \t      && GET_CODE (PATTERN (next_insn)) != USE\n-\t      && GET_CODE (PATTERN (next_insn)) != CLOBBER)\n+\t      && GET_CODE (PATTERN (next_insn)) != CLOBBER\n+\t      && INSN_CODE (next_insn) != CODE_FOR_insn_group_barrier)\n \t    {\n \t      PUT_MODE (next_insn, TImode);\n \t      break;\n@@ -8026,13 +8456,14 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \n \t    fprintf\n \t      (dump,\n-\t       \"//    Bundle state %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\\n\",\n+\t       \"//    Bundle state %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, mid.stops %d state %d) for %d\\n\",\n \t       curr_state->unique_num,\n \t       (curr_state->originator == NULL\n \t\t? -1 : curr_state->originator->unique_num),\n \t       curr_state->cost,\n \t       curr_state->before_nops_num, curr_state->after_nops_num,\n \t       curr_state->accumulated_insns_num, curr_state->branch_deviation,\n+\t       curr_state->middle_bundle_stops,\n \t       (ia64_tune == PROCESSOR_ITANIUM\n \t\t? ((struct DFA_chip *) curr_state->dfa_state)->oneb_automaton_state\n \t\t: ((struct DFA_chip *) curr_state->dfa_state)->twob_automaton_state),\n@@ -8059,10 +8490,15 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t\t    < best_state->accumulated_insns_num\n \t\t    || (curr_state->accumulated_insns_num\n \t\t\t== best_state->accumulated_insns_num\n-\t\t\t&& curr_state->branch_deviation\n-\t\t\t< best_state->branch_deviation)))))\n+\t\t\t&& (curr_state->branch_deviation\n+\t\t\t    < best_state->branch_deviation\n+\t\t\t    || (curr_state->branch_deviation\n+\t\t\t\t== best_state->branch_deviation\n+\t\t\t\t&& curr_state->middle_bundle_stops\n+\t\t\t\t< best_state->middle_bundle_stops)))))))\n       best_state = curr_state;\n   /* Second (backward) pass: adding nops and templates.  */\n+  gcc_assert (best_state);\n   insn_num = best_state->before_nops_num;\n   template0 = template1 = -1;\n   for (curr_state = best_state;\n@@ -8085,13 +8521,14 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \n \t  fprintf\n \t    (dump,\n-\t     \"//    Best %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\\n\",\n+\t     \"//    Best %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, mid.stops %d, state %d) for %d\\n\",\n \t     curr_state->unique_num,\n \t     (curr_state->originator == NULL\n \t      ? -1 : curr_state->originator->unique_num),\n \t     curr_state->cost,\n \t     curr_state->before_nops_num, curr_state->after_nops_num,\n \t     curr_state->accumulated_insns_num, curr_state->branch_deviation,\n+\t     curr_state->middle_bundle_stops,\n \t     (ia64_tune == PROCESSOR_ITANIUM\n \t      ? ((struct DFA_chip *) curr_state->dfa_state)->oneb_automaton_state\n \t      : ((struct DFA_chip *) curr_state->dfa_state)->twob_automaton_state),\n@@ -8290,6 +8727,57 @@ bundling (FILE *dump, int verbose, rtx prev_head_insn, rtx tail)\n \t\t\t\t     insn);\n \t  }\n       }\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    /* Assert right calculation of middle_bundle_stops.  */\n+    int num = best_state->middle_bundle_stops;\n+    bool start_bundle = true, end_bundle = false;\n+\n+    for (insn = NEXT_INSN (prev_head_insn);\n+\t insn && insn != tail;\n+\t insn = NEXT_INSN (insn))\n+      {\n+\tif (!INSN_P (insn))\n+\t  continue;\n+\tif (recog_memoized (insn) == CODE_FOR_bundle_selector)\n+\t  start_bundle = true;\n+\telse\n+\t  {\n+\t    rtx next_insn;\n+\n+\t    for (next_insn = NEXT_INSN (insn);\n+\t\t next_insn && next_insn != tail;\n+\t\t next_insn = NEXT_INSN (next_insn))\n+\t      if (INSN_P (next_insn)\n+\t\t  && (ia64_safe_itanium_class (next_insn)\n+\t\t      != ITANIUM_CLASS_IGNORE\n+\t\t      || recog_memoized (next_insn)\n+\t\t      == CODE_FOR_bundle_selector)\n+\t\t  && GET_CODE (PATTERN (next_insn)) != USE\n+\t\t  && GET_CODE (PATTERN (next_insn)) != CLOBBER)\n+\t\tbreak;\n+\n+\t    end_bundle = next_insn == NULL_RTX\n+\t     || next_insn == tail\n+\t     || (INSN_P (next_insn)\n+\t\t && recog_memoized (next_insn)\n+\t\t == CODE_FOR_bundle_selector);\n+\t    if (recog_memoized (insn) == CODE_FOR_insn_group_barrier\n+\t\t&& !start_bundle && !end_bundle\n+\t\t&& next_insn\n+\t\t&& GET_CODE (PATTERN (next_insn)) != ASM_INPUT\n+\t\t&& asm_noperands (PATTERN (next_insn)) < 0)\n+\t      num--;\n+\n+\t    start_bundle = false;\n+\t  }\n+      }\n+\n+    gcc_assert (num == 0);\n+  }\n+#endif\n+\n   free (index_to_bundle_states);\n   finish_bundle_state_table ();\n   bundling_p = 0;\n@@ -8327,6 +8815,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n {\n   rtx insn;\n   int need_barrier_p = 0;\n+  int seen_good_insn = 0;\n   rtx prev_insn = NULL_RTX;\n \n   init_insn_group_barriers ();\n@@ -8348,6 +8837,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t    emit_insn_after (gen_insn_group_barrier (GEN_INT (3)), last);\n \n \t  init_insn_group_barriers ();\n+\t  seen_good_insn = 0;\n \t  need_barrier_p = 0;\n \t  prev_insn = NULL_RTX;\n \t}\n@@ -8356,10 +8846,14 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t  if (recog_memoized (insn) == CODE_FOR_insn_group_barrier)\n \t    {\n \t      init_insn_group_barriers ();\n+\t      seen_good_insn = 0;\n \t      need_barrier_p = 0;\n \t      prev_insn = NULL_RTX;\n \t    }\n-\t  else if (need_barrier_p || group_barrier_needed (insn))\n+\t  else if (need_barrier_p || group_barrier_needed (insn)\n+\t\t   || (mflag_sched_stop_bits_after_every_cycle\n+\t\t       && GET_MODE (insn) == TImode\n+\t\t       && seen_good_insn))\n \t    {\n \t      if (TARGET_EARLY_STOP_BITS)\n \t\t{\n@@ -8383,19 +8877,32 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t\t       last != insn;\n \t\t       last = NEXT_INSN (last))\n \t\t    if (INSN_P (last))\n-\t\t      group_barrier_needed (last);\n+\t\t      {\n+\t\t\tgroup_barrier_needed (last);\n+\t\t\tif (recog_memoized (last) >= 0\n+\t\t\t    && important_for_bundling_p (last))\n+\t\t\t  seen_good_insn = 1;\n+\t\t      }\n \t\t}\n \t      else\n \t\t{\n \t\t  emit_insn_before (gen_insn_group_barrier (GEN_INT (3)),\n \t\t\t\t    insn);\n \t\t  init_insn_group_barriers ();\n+\t\t  seen_good_insn = 0;\n \t\t}\n \t      group_barrier_needed (insn);\n+\t      if (recog_memoized (insn) >= 0\n+\t\t  && important_for_bundling_p (insn))\n+\t\tseen_good_insn = 1;\n \t      prev_insn = NULL_RTX;\n \t    }\n-\t  else if (recog_memoized (insn) >= 0)\n-\t    prev_insn = insn;\n+\t  else if (recog_memoized (insn) >= 0\n+\t\t   && important_for_bundling_p (insn))\n+\t    {\n+\t      prev_insn = insn;\n+\t      seen_good_insn = 1;\n+\t    }\n \t  need_barrier_p = (GET_CODE (insn) == CALL_INSN\n \t\t\t    || GET_CODE (PATTERN (insn)) == ASM_INPUT\n \t\t\t    || asm_noperands (PATTERN (insn)) >= 0);\n@@ -8504,7 +9011,8 @@ ia64_ld_address_bypass_p (rtx producer, rtx consumer)\n     {\n       int c = XINT (mem, 1);\n \n-      gcc_assert (c == UNSPEC_LDA || c == UNSPEC_LDS || c == UNSPEC_LDSA);\n+      gcc_assert (c == UNSPEC_LDA || c == UNSPEC_LDS || c == UNSPEC_LDS_A\n+\t\t  || c == UNSPEC_LDSA);\n       mem = XVECEXP (mem, 0, 0);\n     }\n \n@@ -8601,7 +9109,8 @@ ia64_reorg (void)\n   if (optimize == 0)\n     split_all_insns ();\n \n-  if (optimize && ia64_flag_schedule_insns2 && dbg_cnt (ia64_sched2))\n+  if (optimize && ia64_flag_schedule_insns2\n+      && dbg_cnt (ia64_sched2))\n     {\n       timevar_push (TV_SCHED2);\n       ia64_final_schedule = 1;\n@@ -8675,7 +9184,16 @@ ia64_reorg (void)\n \t  _1mfb_ = get_cpu_unit_code (\"1b_1mfb.\");\n \t  _1mlx_ = get_cpu_unit_code (\"1b_1mlx.\");\n \t}\n-      schedule_ebbs ();\n+\n+      if (flag_selective_scheduling2\n+\t  && !maybe_skip_selective_scheduling ())\n+        run_selective_scheduling ();\n+      else\n+\tschedule_ebbs ();\n+\n+      /* Redo alignment computation, as it might gone wrong.  */\n+      compute_alignments ();\n+\n       /* We cannot reuse this one because it has been corrupted by the\n \t evil glat.  */\n       finish_bundle_states ();\n@@ -9932,6 +10450,7 @@ ia64_optimization_options (int level ATTRIBUTE_UNUSED,\n   set_param_value (\"simultaneous-prefetches\", 6);\n   set_param_value (\"l1-cache-line-size\", 32);\n \n+  set_param_value(\"sched-mem-true-dep-cost\", 4);\n }\n \n /* HP-UX version_id attribute."}, {"sha": "b03032dd020f79e8077e9c9a8df6d8a11e141b5c", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 124, "deletions": 26, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -82,12 +82,15 @@\n    (UNSPEC_VECT_EXTR\t\t31)\n    (UNSPEC_LDA                  40)\n    (UNSPEC_LDS                  41)\n-   (UNSPEC_LDSA                 42)\n-   (UNSPEC_LDCCLR               43)\n-   (UNSPEC_CHKACLR              45)\n-   (UNSPEC_CHKS                 47)\t\n-   (UNSPEC_FR_RECIP_APPROX_RES  48)\n-   (UNSPEC_FR_SQRT_RECIP_APPROX_RES 49)\n+   (UNSPEC_LDS_A                42)\n+   (UNSPEC_LDSA                 43)\n+   (UNSPEC_LDCCLR               44)\n+   (UNSPEC_LDCNC                45)\n+   (UNSPEC_CHKACLR              46)\n+   (UNSPEC_CHKANC               47)\n+   (UNSPEC_CHKS                 48)\n+   (UNSPEC_FR_RECIP_APPROX_RES  49)\n+   (UNSPEC_FR_SQRT_RECIP_APPROX_RES 50)\n   ])\n \n (define_constants\n@@ -185,6 +188,10 @@\n (define_attr \"control_speculative\" \"no,yes\" (const_string \"no\"))\n \n (define_attr \"check_load\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"speculable1\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"speculable2\" \"no,yes\" (const_string \"no\"))\n \f\n ;; DFA descriptions of ia64 processors used for insn scheduling and\n ;; bundling.\n@@ -234,7 +241,9 @@\n    ld1%O1 %0 = %1%P1\n    st1%Q0 %0 = %1%P0\n    mov %0 = %1\"\n-  [(set_attr \"itanium_class\" \"icmp,icmp,unknown,unknown,tbit,ialu,ld,st,ialu\")])\n+  [(set_attr \"itanium_class\" \"icmp,icmp,unknown,unknown,tbit,ialu,ld,st,ialu\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,  no,  no,     no,     no,  no, yes,no,no\")])\n \n (define_split\n   [(set (match_operand:BI 0 \"register_operand\" \"\")\n@@ -273,7 +282,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movqi_internal\"\n+(define_insn \"movqi_internal\"\n   [(set (match_operand:QI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n \t(match_operand:QI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -285,7 +294,9 @@\n    getf.sig %0 = %1\n    setf.sig %0 = %r1\n    mov %0 = %1\"\n-  [(set_attr \"itanium_class\" \"ialu,ialu,ld,st,frfr,tofr,fmisc\")])\n+  [(set_attr \"itanium_class\" \"ialu,ialu,ld,st,frfr,tofr,fmisc\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,  no, yes,no,no,  no,  no\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -298,7 +309,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movhi_internal\"\n+(define_insn \"movhi_internal\"\n   [(set (match_operand:HI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n \t(match_operand:HI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -310,7 +321,9 @@\n    getf.sig %0 = %1\n    setf.sig %0 = %r1\n    mov %0 = %1\"\n-  [(set_attr \"itanium_class\" \"ialu,ialu,ld,st,frfr,tofr,fmisc\")])\n+  [(set_attr \"itanium_class\" \"ialu,ialu,ld,st,frfr,tofr,fmisc\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,  no, yes,no,no,  no,  no\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n@@ -323,7 +336,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movsi_internal\"\n+(define_insn \"movsi_internal\"\n   [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r,r, m, r,*f,*f, r,*d\")\n \t(match_operand:SI 1 \"move_operand\"        \"rO,J,j,i,m,rO,*f,rO,*f,*d,rK\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -340,7 +353,9 @@\n   mov %0 = %1\n   mov %0 = %r1\"\n   ;; frar_m, toar_m ??? why not frar_i and toar_i\n-  [(set_attr \"itanium_class\" \"ialu,ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,frar_m,toar_m\")])\n+  [(set_attr \"itanium_class\" \"ialu,ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,frar_m,toar_m\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,  no,  no,  no,   yes,no,no,  no,  no,   no,    no\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -353,7 +368,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movdi_internal\"\n+(define_insn \"movdi_internal\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n \t\t    \"=r,r,r,r,r, m, r,*f,*f,*f, Q, r,*b, r,*e, r,*d, r,*c\")\n \t(match_operand:DI 1 \"move_operand\"\n@@ -387,7 +402,9 @@\n \n   return alt[which_alternative];\n }\n-  [(set_attr \"itanium_class\" \"ialu,ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")])\n+  [(set_attr \"itanium_class\" \"ialu,ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,  no,  no,  no,   yes,no,no,  no,  no,   yes,no, no,  no,  no,    no,    no,    no,    no,  no\")])\n \n (define_mode_iterator MODE [BI QI HI SI DI SF DF XF TI])\n (define_mode_iterator MODE_FOR_EXTEND [QI HI SI])\n@@ -472,6 +489,26 @@\n   (XF \"ldfe.c.clr %0 = %1%P1\")\n   (TI \"ldfp8.c.clr %X0 = %1%P1\")])\n \n+(define_mode_attr output_c_nc [\n+  (BI \"ld1.c.nc%O1 %0 = %1%P1\")\n+  (QI \"ld1.c.nc%O1 %0 = %1%P1\")\n+  (HI \"ld2.c.nc%O1 %0 = %1%P1\")\n+  (SI \"ld4.c.nc%O1 %0 = %1%P1\")\n+  (DI\n+   \"@\n+    ld8.c.nc%O1 %0 = %1%P1\n+    ldf8.c.nc %0 = %1%P1\")\n+  (SF\n+   \"@\n+    ldfs.c.nc %0 = %1%P1\n+    ld4.c.nc%O1 %0 = %1%P1\")\n+  (DF\n+   \"@\n+    ldfd.c.nc %0 = %1%P1\n+    ld8.c.nc%O1 %0 = %1%P1\")\n+  (XF \"ldfe.c.nc %0 = %1%P1\")\n+  (TI \"ldfp8.c.nc %X0 = %1%P1\")])\n+\n (define_mode_attr ld_reg_constr [(BI \"=*r\") (QI \"=r\") (HI \"=r\") (SI \"=r\") (DI \"=r,*f\") (SF \"=f,*r\") (DF \"=f,*r\") (XF \"=f\") (TI \"=*x\")])\n (define_mode_attr ldc_reg_constr [(BI \"+*r\") (QI \"+r\") (HI \"+r\") (SI \"+r\") (DI \"+r,*f\") (SF \"+f,*r\") (DF \"+f,*r\") (XF \"+f\") (TI \"+*x\")])\n (define_mode_attr chk_reg_constr [(BI \"*r\") (QI \"r\") (HI \"r\") (SI \"r\") (DI \"r,*f\") (SF \"f,*r\") (DF \"f,*r\") (XF \"f\") (TI \"*x\")])\n@@ -530,6 +567,15 @@\n    (set_attr \"data_speculative\" \"<attr_yes>\")\n    (set_attr \"control_speculative\" \"<attr_yes>\")])\n \n+(define_insn \"mov<mode>_speculative_a\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ld_reg_constr>\")\n+\t(unspec:MODE [(match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDS_A))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_sa>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n (define_insn \"zero_extend<mode>di2_speculative_advanced\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n \t(zero_extend:DI (unspec:MODE_FOR_EXTEND [(match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDSA)))]\n@@ -539,6 +585,15 @@\n    (set_attr \"data_speculative\" \"<attr_yes>\")\n    (set_attr \"control_speculative\" \"<attr_yes>\")])\n \n+(define_insn \"zero_extend<mode>di2_speculative_a\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI (unspec:MODE_FOR_EXTEND [(match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\")] UNSPEC_LDS_A)))]\n+  \"\"\n+  \"<output_sa>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"data_speculative\" \"<attr_yes>\")\n+   (set_attr \"control_speculative\" \"<attr_yes>\")])\n+\n (define_insn \"mov<mode>_clr\"\n   [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ldc_reg_constr>\")\n \t(if_then_else:MODE (ne (unspec [(match_dup 0)] UNSPEC_LDCCLR) (const_int 0))\n@@ -549,6 +604,16 @@\n   [(set_attr \"itanium_class\" \"<ld_class>\")\n    (set_attr \"check_load\" \"<attr_yes>\")])\n \n+(define_insn \"mov<mode>_nc\"\n+  [(set (match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<ldc_reg_constr>\")\n+\t(if_then_else:MODE (ne (unspec [(match_dup 0)] UNSPEC_LDCNC) (const_int 0))\n+\t\t\t   (match_operand:MODE 1 \"memory_operand\" \"<mem_constr>\")\n+\t\t\t   (match_dup 0)))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"<output_c_nc>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"check_load\" \"<attr_yes>\")])\n+\n (define_insn \"zero_extend<mode>di2_clr\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"+r\")\n \t(if_then_else:DI (ne (unspec [(match_dup 0)] UNSPEC_LDCCLR) (const_int 0))\n@@ -559,6 +624,16 @@\n   [(set_attr \"itanium_class\" \"<ld_class>\")\n    (set_attr \"check_load\" \"<attr_yes>\")])\n \n+(define_insn \"zero_extend<mode>di2_nc\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"+r\")\n+\t(if_then_else:DI (ne (unspec [(match_dup 0)] UNSPEC_LDCNC) (const_int 0))\n+\t\t\t (zero_extend:DI (match_operand:MODE_FOR_EXTEND 1 \"memory_operand\" \"<mem_constr>\"))\n+\t\t\t (match_dup 0)))]\n+  \"\"\n+  \"<output_c_nc>\"\n+  [(set_attr \"itanium_class\" \"<ld_class>\")\n+   (set_attr \"check_load\" \"<attr_yes>\")])\n+\n (define_insn \"advanced_load_check_clr_<mode>\"\n   [(set (pc)\n         (if_then_else (ne (unspec [(match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<chk_reg_constr>\")] UNSPEC_CHKACLR) (const_int 0))\n@@ -568,6 +643,15 @@\n   \"chk.a.clr %0, %l1\"\n   [(set_attr \"itanium_class\" \"<chka_class>\")])\n \n+(define_insn \"advanced_load_check_nc_<mode>\"\n+  [(set (pc)\n+        (if_then_else (ne (unspec [(match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<chk_reg_constr>\")] UNSPEC_CHKANC) (const_int 0))\n+                      (pc)\n+                      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"chk.a.clr %0, %l1\"\n+  [(set_attr \"itanium_class\" \"<chka_class>\")])\n+\n (define_insn \"speculation_check_<mode>\"\n   [(set (pc) \n         (if_then_else (ne (unspec [(match_operand:MODE 0 \"<reg_pred_prefix>_register_operand\" \"<chk_reg_constr>\")] UNSPEC_CHKS) (const_int 0))\n@@ -863,7 +947,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn_and_split \"*movti_internal\"\n+(define_insn_and_split \"movti_internal\"\n   [(set (match_operand:TI 0 \"destination_operand\" \"=r,   *fm,*x,*f,  Q\")\n \t(match_operand:TI 1 \"general_operand\"     \"r*fim,r,  Q, *fOQ,*f\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -879,7 +963,9 @@\n   ia64_split_tmode_move (operands);\n   DONE;\n }\n-  [(set_attr \"itanium_class\" \"unknown,unknown,fldp,unknown,unknown\")])\n+  [(set_attr \"itanium_class\" \"unknown,unknown,fldp,unknown,unknown\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,     no,     yes, no,     no\")])\n \n ;; Floating Point Moves\n ;;\n@@ -897,7 +983,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movsf_internal\"\n+(define_insn \"movsf_internal\"\n   [(set (match_operand:SF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:SF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -910,7 +996,9 @@\n    mov %0 = %1\n    ld4%O1 %0 = %1%P1\n    st4%Q0 %0 = %1%P0\"\n-  [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")])\n+  [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,   yes,no, no,  no,  no, yes,no\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -923,7 +1011,7 @@\n   operands[1] = op1;\n })\n \n-(define_insn \"*movdf_internal\"\n+(define_insn \"movdf_internal\"\n   [(set (match_operand:DF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:DF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n@@ -936,7 +1024,9 @@\n    mov %0 = %1\n    ld8%O1 %0 = %1%P1\n    st8%Q0 %0 = %1%P0\"\n-  [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")])\n+  [(set_attr \"itanium_class\" \"fmisc,fld,stf,frfr,tofr,ialu,ld,st\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,   yes,no, no,  no,  no, yes,no\")])\n \n ;; With no offsettable memory references, we've got to have a scratch\n ;; around to play with the second word if the variable winds up in GRs.\n@@ -951,15 +1041,17 @@\n \n ;; ??? There's no easy way to mind volatile acquire/release semantics.\n \n-(define_insn \"*movxf_internal\"\n+(define_insn \"movxf_internal\"\n   [(set (match_operand:XF 0 \"destination_operand\" \"=f,f, m\")\n \t(match_operand:XF 1 \"general_operand\"     \"fG,m,fG\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %F1\n    ldfe %0 = %1%P1\n    stfe %0 = %F1%P0\"\n-  [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n+  [(set_attr \"itanium_class\" \"fmisc,fld,stf\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no,   yes,no\")])\n \n ;; Same as for movxf, but for RFmode.\n (define_expand \"movrf\"\n@@ -1049,7 +1141,9 @@\n   \"@\n    zxt1 %0 = %1\n    ld1%O1 %0 = %1%P1\"\n-  [(set_attr \"itanium_class\" \"xtd,ld\")])\n+  [(set_attr \"itanium_class\" \"xtd,ld\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no, yes\")])\n \n (define_insn \"zero_extendhidi2\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r,r\")\n@@ -1058,7 +1152,9 @@\n   \"@\n    zxt2 %0 = %1\n    ld2%O1 %0 = %1%P1\"\n-  [(set_attr \"itanium_class\" \"xtd,ld\")])\n+  [(set_attr \"itanium_class\" \"xtd,ld\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no, yes\")])\n \n (define_insn \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"grfr_register_operand\" \"=r,r,?f\")\n@@ -1069,7 +1165,9 @@\n    addp4 %0 = %1, r0\n    ld4%O1 %0 = %1%P1\n    fmix.r %0 = f0, %1\"\n-  [(set_attr \"itanium_class\" \"ialu,ld,fmisc\")])\n+  [(set_attr \"itanium_class\" \"ialu,ld,fmisc\")\n+   (set_attr \"speculable1\"   \"yes\")\n+   (set_attr \"speculable2\"   \"no, yes,no\")])\n \n ;; Convert between floating point types of different sizes.\n "}, {"sha": "f1da7f309dfb2631d3760b896f4448587536ed98", "filename": "gcc/config/ia64/ia64.opt", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fia64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.opt?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -105,7 +105,7 @@ Target Report Var(mflag_sched_ar_data_spec) Init(1)\n Use data speculation after reload\n \n msched-control-spec\n-Target Report Var(mflag_sched_control_spec) Init(0)\n+Target Report Var(mflag_sched_control_spec) Init(2)\n Use control speculation\n \n msched-br-in-data-spec\n@@ -120,28 +120,44 @@ msched-in-control-spec\n Target Report Var(mflag_sched_in_control_spec) Init(1)\n Use in block control speculation\n \n-msched-ldc\n-Target Report Var(mflag_sched_ldc) Init(1)\n+msched-spec-ldc\n+Target Report Var(mflag_sched_spec_ldc) Init(1)\n Use simple data speculation check\n \n-msched-control-ldc\n-Target Report Var(mflag_control_ldc) Init(0)\n+msched-spec-control-ldc\n+Target Report Var(mflag_sched_spec_control_ldc) Init(0)\n Use simple data speculation check for control speculation\n \n-msched-spec-verbose\n-Common Report Var(mflag_sched_spec_verbose) Init(0)\n-Print information about speculative motions.\n-\n msched-prefer-non-data-spec-insns\n-Common Report Var(mflag_sched_prefer_non_data_spec_insns) Init(0)\n+Target Report Var(mflag_sched_prefer_non_data_spec_insns) Init(0)\n If set, data speculative instructions will be chosen for schedule only if there are no other choices at the moment \n \n msched-prefer-non-control-spec-insns\n-Common Report Var(mflag_sched_prefer_non_control_spec_insns) Init(0)\n+Target Report Var(mflag_sched_prefer_non_control_spec_insns) Init(0)\n If set, control speculative instructions will be chosen for schedule only if there are no other choices at the moment \n \n msched-count-spec-in-critical-path\n-Common Report Var(mflag_sched_count_spec_in_critical_path) Init(0)\n+Target Report Var(mflag_sched_count_spec_in_critical_path) Init(0)\n Count speculative dependencies while calculating priority of instructions\n \n+msched-stop-bits-after-every-cycle\n+Target Report Var(mflag_sched_stop_bits_after_every_cycle) Init(1)\n+Place a stop bit after every cycle when scheduling\n+\n+msched-fp-mem-deps-zero-cost\n+Target Report Var(mflag_sched_fp_mem_deps_zero_cost) Init(0)\n+Assume that floating-point stores and loads are not likely to cause conflict when placed into one instruction group\n+\n+msched-max-memory-insns=\n+Target RejectNegative Joined UInteger Var(ia64_max_memory_insns) Init(1)\n+Soft limit on number of memory insns per instruction group, giving lower priority to subsequent memory insns attempting to schedule in the same insn group. Frequently useful to prevent cache bank conflicts.  Default value is 1\n+\n+msched-max-memory-insns-hard-limit\n+Target Report Var(mflag_sched_mem_insns_hard_limit) Init(0)\n+Disallow more than `msched-max-memory-insns' in instruction group. Otherwise, limit is `soft' (prefer non-memory operations when limit is reached)\n+\n+msel-sched-dont-check-control-spec\n+Target Report Var(mflag_sel_sched_dont_check_control_spec) Init(0)\n+Don't generate checks for control speculation in selective scheduling\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "26dbb50c0dfc7d958dc5b41f74b6176c65623a8a", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -1072,14 +1072,13 @@\n (define_bypass  3 \"2_ialu\" \"2_mmalua,2_mmmul,2_mmshf\")\n (define_bypass  3 \"2_mmalua,2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld,2_ldc\")\n (define_bypass  6 \"2_tofr\"  \"2_frfr,2_stf\")\n-(define_bypass  7 \"2_fmac\"  \"2_frfr,2_stf\")\n \n ;; We don't use here fcmp because scall may be predicated.\n (define_bypass  0 \"2_fcvtfx,2_fld,2_flda,2_fldc,2_fmac,2_fmisc,2_frar_i,2_frar_m,\\\n                    2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_ldc,2_long_i,\\\n-                   2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,\\\n+                   2_mmalua,2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tobr,2_tofr,\\\n \t\t   2_xmpy,2_xtd\"\n-                  \"2_scall\")\n+                  \"2_br,2_scall\")\n \n (define_bypass  0 \"2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,2_flda,2_fldc,\\\n                    2_fmac,2_fmisc,2_frar_i,2_frar_m,2_frbr,2_frfr,2_frpr,\\"}, {"sha": "43f3d8e23bfe900b68680f2fb36df4befcb0f541", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -33,4 +33,4 @@ ia64-c.o: $(srcdir)/config/ia64/ia64-c.c $(CONFIG_H) $(SYSTEM_H) \\\n # genattrtab generates very long string literals.\n insn-attrtab.o-warn = -Wno-error\n \n-ia64.o: debug.h $(PARAMS_H)\n+ia64.o: debug.h $(PARAMS_H) sel-sched.h"}, {"sha": "eae7d4f424b95ad28c579ed47aacbfa1eeb26c6b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -6390,6 +6390,29 @@ Deallocate internal data in target scheduling context pointed to by @var{tc}.\n Deallocate a store for target scheduling context pointed to by @var{tc}.\n @end deftypefn\n \n+@deftypefn {Target Hook} void * TARGET_SCHED_ALLOC_SCHED_CONTEXT (void)\n+Return a pointer to a store large enough to hold target scheduling context.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_INIT_SCHED_CONTEXT (void *@var{tc}, bool @var{clean_p})\n+Initialize store pointed to by @var{tc} to hold target scheduling context.\n+It @var{clean_p} is true then initialize @var{tc} as if scheduler is at the\n+beginning of the block.  Overwise, make a copy of the current context in\n+@var{tc}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_CONTEXT (void *@var{tc})\n+Copy target scheduling context pointer to by @var{tc} to the current context.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_CLEAR_SCHED_CONTEXT (void *@var{tc})\n+Deallocate internal data in target scheduling context pointed to by @var{tc}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FREE_SCHED_CONTEXT (void *@var{tc})\n+Deallocate a store for target scheduling context pointed to by @var{tc}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, int @var{request}, rtx *@var{new_pat})\n This hook is called by the insn scheduler when @var{insn} has only\n speculative dependencies and therefore can be scheduled speculatively."}, {"sha": "09dc233c2537536cee00d0da41e442ac2c20e02b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -3949,7 +3949,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n   todo_spec &= SPECULATIVE;\n \n   /* Create recovery block.  */\n-  if (mutate_p || targetm.sched.needs_block_p (insn))\n+  if (mutate_p || targetm.sched.needs_block_p (todo_spec))\n     {\n       rec = sched_create_recovery_block (NULL);\n       label = BB_HEAD (rec);\n@@ -3961,7 +3961,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     }\n \n   /* Emit CHECK.  */\n-  check = targetm.sched.gen_spec_check (insn, label, mutate_p);\n+  check = targetm.sched.gen_spec_check (insn, label, todo_spec);\n \n   if (rec != EXIT_BLOCK_PTR)\n     {"}, {"sha": "9736e34155be375901739203db9e01e16a4244af", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -1817,7 +1817,7 @@ create_speculation_check (expr_t c_expr, ds_t check_ds, insn_t orig_insn)\n \n   /* Create a recovery block if target is going to emit branchy check, or if\n      ORIG_INSN was speculative already.  */\n-  if (targetm.sched.needs_block_p (EXPR_INSN_RTX (c_expr))\n+  if (targetm.sched.needs_block_p (check_ds)\n       || EXPR_SPEC_DONE_DS (INSN_EXPR (orig_insn)) != 0)\n     {\n       recovery_block = sel_create_recovery_block (orig_insn);"}, {"sha": "21c46adbbe2c674a19477117092ad586c324f746", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388092d5b419ad5573c6dcd1c6478691e8417087/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=388092d5b419ad5573c6dcd1c6478691e8417087", "patch": "@@ -397,7 +397,7 @@ struct gcc_target\n     /* The following member value is a pointer to a function called\n        by the insn scheduler.  It should return true if the check instruction\n        passed as the parameter needs a recovery block.  */\n-    bool (* needs_block_p) (const_rtx);\n+    bool (* needs_block_p) (int);\n \n     /* The following member value is a pointer to a function called\n        by the insn scheduler.  It should return a pattern for the check\n@@ -407,7 +407,7 @@ struct gcc_target\n        simple check).  If the mutation of the check is requested (e.g. from\n        ld.c to chk.a), the third parameter is true - in this case the first\n        parameter is the previous check.  */\n-    rtx (* gen_spec_check) (rtx, rtx, bool);\n+    rtx (* gen_spec_check) (rtx, rtx, int);\n \n     /* The following member value is a pointer to a function controlling\n        what insns from the ready insn queue will be considered for the"}]}