{"sha": "ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ5MTk4MTIxMmUxZjljZjBjOWI1N2E5M2Y4NWUwYTVjZjFlMDk2Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-28T17:20:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-28T17:20:25Z"}, "message": "i386-protos.h (ix86_setup_incoming_varargs, [...]): Declare.\n\n\t* i386-protos.h (ix86_setup_incoming_varargs, ix86_va_arg,\n\tix86_va_start, ix86_build_va_list): Declare.\n\t* i386.c (ix86_setup_incoming_varargs, ix86_va_arg,\n\tix86_va_start, ix86_build_va_list): New global functions.\n\t* i386.md (sse_prologue_save_insn): New insn.\n\t(sse_prologue_save): New expander.\n\t* i386.h (EXPAND_BUILTIN_VA_ARG, EXPAND_BUILTIN_VA_START,\n\tBUILD_VA_LIST_TYPE, SETUP_INCOMING_VARARGS): New macros.\n\nFrom-SVN: r45862", "tree": {"sha": "12467869da5fe7bf490f2d11def08e5c06292f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12467869da5fe7bf490f2d11def08e5c06292f0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/comments", "author": null, "committer": null, "parents": [{"sha": "576fb787822fe6c80db9228fe52bec206c6be163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576fb787822fe6c80db9228fe52bec206c6be163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576fb787822fe6c80db9228fe52bec206c6be163"}], "stats": {"total": 568, "additions": 566, "deletions": 2}, "files": [{"sha": "cfedd181d9412937a28eea4db928f1d130c25c74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -1,3 +1,14 @@\n+Fri Sep 28 19:18:40 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-protos.h (ix86_setup_incoming_varargs, ix86_va_arg,\n+\tix86_va_start, ix86_build_va_list): Declare.\n+\t* i386.c (ix86_setup_incoming_varargs, ix86_va_arg,\n+\tix86_va_start, ix86_build_va_list): New global functions.\n+\t* i386.md (sse_prologue_save_insn): New insn.\n+\t(sse_prologue_save): New expander.\n+\t* i386.h (EXPAND_BUILTIN_VA_ARG, EXPAND_BUILTIN_VA_START,\n+\tBUILD_VA_LIST_TYPE, SETUP_INCOMING_VARARGS): New macros.\n+\n 2001-09-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cpplex.c (new_buff, _cpp_get_buff, _cpp_extend_buff):"}, {"sha": "410b84e8de62c2ba8e97bbc0e381e45f4215b684", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -140,6 +140,11 @@ extern bool ix86_function_value_regno_p PARAMS ((int));\n extern bool ix86_function_arg_regno_p PARAMS ((int));\n extern int ix86_function_arg_boundary PARAMS ((enum machine_mode, tree));\n extern int ix86_return_in_memory PARAMS ((tree));\n+extern void ix86_va_start PARAMS ((int, tree, rtx));\n+extern rtx ix86_va_arg PARAMS ((tree, tree));\n+extern void ix86_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int *, int));\n \n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n@@ -175,6 +180,7 @@ extern rtx ix86_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int))\n \n #ifdef TREE_CODE\n extern int ix86_return_pops_args PARAMS ((tree, tree, int));\n+extern tree ix86_build_va_list PARAMS ((void));\n \n extern int ix86_data_alignment PARAMS ((tree, int));\n extern int ix86_local_alignment PARAMS ((tree, int));"}, {"sha": "889c428bc37cd93916c82d48738c2232c7ad4de3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 446, "deletions": 1, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -2061,10 +2061,455 @@ ix86_libcall_value (mode)\n   else\n    return gen_rtx_REG (mode, VALUE_REGNO (mode));\n }\n+\f\n+/* Create the va_list data type.  */\n \n+tree\n+ix86_build_va_list ()\n+{\n+  tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n-\f\n+  /* For i386 we use plain pointer to argument area.  */\n+  if (!TARGET_64BIT)\n+    return build_pointer_type (char_type_node);\n+\n+  record = make_lang_type (RECORD_TYPE);\n+  type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n+\n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gp_offset\"), \n+\t\t      unsigned_type_node);\n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fp_offset\"), \n+\t\t      unsigned_type_node);\n+  f_ovf = build_decl (FIELD_DECL, get_identifier (\"overflow_arg_area\"),\n+\t\t      ptr_type_node);\n+  f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n+\t\t      ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_gpr) = record;\n+  DECL_FIELD_CONTEXT (f_fpr) = record;\n+  DECL_FIELD_CONTEXT (f_ovf) = record;\n+  DECL_FIELD_CONTEXT (f_sav) = record;\n+\n+  TREE_CHAIN (record) = type_decl;\n+  TYPE_NAME (record) = type_decl;\n+  TYPE_FIELDS (record) = f_gpr;\n+  TREE_CHAIN (f_gpr) = f_fpr;\n+  TREE_CHAIN (f_fpr) = f_ovf;\n+  TREE_CHAIN (f_ovf) = f_sav;\n+\n+  layout_type (record);\n+\n+  /* The correct type is an array type of one element.  */\n+  return build_array_type (record, build_index_type (size_zero_node));\n+}\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+void\n+ix86_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int *pretend_size ATTRIBUTE_UNUSED;\n+     int no_rtl;\n+\n+{\n+  CUMULATIVE_ARGS next_cum;\n+  rtx save_area = NULL_RTX, mem;\n+  rtx label;\n+  rtx label_ref;\n+  rtx tmp_reg;\n+  rtx nsse_reg;\n+  int set;\n+  tree fntype;\n+  int stdarg_p;\n+  int i;\n+\n+  if (!TARGET_64BIT)\n+    return;\n+\n+  /* Indicate to allocate space on the stack for varargs save area.  */\n+  ix86_save_varrargs_registers = 1;\n+\n+  fntype = TREE_TYPE (current_function_decl);\n+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t  != void_type_node));\n+\n+  /* For varargs, we do not want to skip the dummy va_dcl argument.\n+     For stdargs, we do want to skip the last named argument.  */\n+  next_cum = *cum;\n+  if (stdarg_p)\n+    function_arg_advance (&next_cum, mode, type, 1);\n+\n+  if (!no_rtl)\n+    save_area = frame_pointer_rtx;\n+\n+  set = get_varargs_alias_set ();\n+\n+  for (i = next_cum.regno; i < ix86_regparm; i++)\n+    {\n+      mem = gen_rtx_MEM (Pmode,\n+\t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n+      MEM_ALIAS_SET (mem) = set;\n+      emit_move_insn (mem, gen_rtx_REG (Pmode,\n+\t\t\t\t\tx86_64_int_parameter_registers[i]));\n+    }\n+\n+  if (next_cum.sse_nregs)\n+    {\n+      /* Now emit code to save SSE registers.  The AX parameter contains number\n+\t of SSE parameter regsiters used to call this function.  We use\n+\t sse_prologue_save insn template that produces computed jump across\n+\t SSE saves.  We need some preparation work to get this working.  */\n+\n+      label = gen_label_rtx ();\n+      label_ref = gen_rtx_LABEL_REF (Pmode, label);\n+\n+      /* Compute address to jump to :\n+         label - 5*eax + nnamed_sse_arguments*5  */\n+      tmp_reg = gen_reg_rtx (Pmode);\n+      nsse_reg = gen_reg_rtx (Pmode);\n+      emit_insn (gen_zero_extendqidi2 (nsse_reg, gen_rtx_REG (QImode, 0)));\n+      emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n+\t\t\t      gen_rtx_MULT (VOIDmode, nsse_reg,\n+\t\t\t\t\t    GEN_INT (4))));\n+      if (next_cum.sse_regno)\n+\temit_move_insn\n+\t  (nsse_reg,\n+\t   gen_rtx_CONST (DImode,\n+\t\t\t  gen_rtx_PLUS (DImode,\n+\t\t\t\t\tlabel_ref,\n+\t\t\t\t\tGEN_INT (next_cum.sse_regno * 4))));\n+      else\n+\temit_move_insn (nsse_reg, label_ref);\n+      emit_insn (gen_subdi3 (nsse_reg, nsse_reg, tmp_reg));\n+\n+      /* Compute address of memory block we save into.  We always use pointer\n+\t pointing 127 bytes after first byte to store - this is needed to keep\n+\t instruction size limited by 4 bytes.  */\n+      tmp_reg = gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET(VOIDmode, tmp_reg,\n+\t\t\t     plus_constant (save_area, 8 * REGPARM_MAX + 127)));\n+      mem = gen_rtx_MEM (BLKmode, plus_constant (tmp_reg, -127));\n+      MEM_ALIAS_SET (mem) = set;\n+\n+      /* And finally do the dirty job!  */\n+      emit_insn (gen_sse_prologue_save (mem, nsse_reg, GEN_INT (next_cum.sse_regno),\n+\t\t label));\n+    }\n+\n+}\n+\n+/* Implement va_start.  */\n+\n+void\n+ix86_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n+{\n+  HOST_WIDE_INT words, n_gpr, n_fpr;\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, t;\n+\n+  /* Only 64bit target needs something special.  */\n+  if (!TARGET_64BIT)\n+    {\n+      std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n+      return;\n+    }\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  /* Count number of gp and fp argument registers used.  */\n+  words = current_function_args_info.words;\n+  n_gpr = current_function_args_info.regno;\n+  n_fpr = current_function_args_info.sse_regno;\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n+\t     words, n_gpr, n_fpr);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t     build_int_2 (n_gpr * 8, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t     build_int_2 (n_fpr * 16 + 8*REGPARM_MAX, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the overflow area.  */\n+  t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+  if (words != 0)\n+    t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n+\t       build_int_2 (words * UNITS_PER_WORD, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the register save area.\n+     Prologue of the function save it right above stack frame.  */\n+  t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n+  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Implement va_arg.  */\n+rtx\n+ix86_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  static int intreg[6] = { 0, 1, 2, 3, 4, 5 };\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, t;\n+  int indirect_p = 0, size, rsize;\n+  rtx lab_false, lab_over = NULL_RTX;\n+  rtx addr_rtx, r;\n+  rtx container;\n+\n+  /* Only 64bit target needs something special.  */\n+  if (!TARGET_64BIT)\n+    {\n+      return std_expand_builtin_va_arg (valist, type);\n+    }\n+\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  size = int_size_in_bytes (type);\n+  rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  container = construct_container (TYPE_MODE (type), type, 0,\n+\t\t\t\t   REGPARM_MAX, SSE_REGPARM_MAX, intreg, 0);\n+  /*\n+   * Pull the value out of the saved registers ...\n+   */\n \n+  addr_rtx = gen_reg_rtx (Pmode);\n+\n+  if (container)\n+    {\n+      rtx int_addr_rtx, sse_addr_rtx;\n+      int needed_intregs, needed_sseregs;\n+      int need_temp;\n+\n+      lab_over = gen_label_rtx ();\n+      lab_false = gen_label_rtx ();\n+\n+      examine_argument (TYPE_MODE (type), type, 0,\n+\t\t        &needed_intregs, &needed_sseregs);\n+\n+\n+      need_temp = ((needed_intregs && TYPE_ALIGN (type) > 64)\n+\t\t   || TYPE_ALIGN (type) > 128);\n+\n+      /* In case we are passing structure, verify that it is consetuctive block\n+         on the register save area.  If not we need to do moves.  */\n+      if (!need_temp && !REG_P (container))\n+\t{\n+\t  /* Verify that all registers are strictly consetuctive  */\n+\t  if (SSE_REGNO_P (REGNO (XEXP (XVECEXP (container, 0, 0), 0))))\n+\t    {\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n+\t\t{\n+\t\t  rtx slot = XVECEXP (container, 0, i);\n+\t\t  if (REGNO (XEXP (slot, 0)) != FIRST_SSE_REG + (unsigned int)i\n+\t\t      || INTVAL (XEXP (slot, 1)) != i * 16)\n+\t\t    need_temp = 1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (container, 0) && !need_temp; i++)\n+\t\t{\n+\t\t  rtx slot = XVECEXP (container, 0, i);\n+\t\t  if (REGNO (XEXP (slot, 0)) != (unsigned int)i\n+\t\t      || INTVAL (XEXP (slot, 1)) != i * 8)\n+\t\t    need_temp = 1;\n+\t\t}\n+\t    }\n+\t}\n+      if (!need_temp)\n+\t{\n+\t  int_addr_rtx = addr_rtx;\n+\t  sse_addr_rtx = addr_rtx;\n+\t}\n+      else\n+\t{\n+\t  int_addr_rtx = gen_reg_rtx (Pmode);\n+\t  sse_addr_rtx = gen_reg_rtx (Pmode);\n+\t}\n+      /* First ensure that we fit completely in registers.  */\n+      if (needed_intregs)\n+\t{\n+\t  emit_cmp_and_jump_insns (expand_expr\n+\t\t\t\t   (gpr, NULL_RTX, SImode, EXPAND_NORMAL),\n+\t\t\t\t   GEN_INT ((REGPARM_MAX - needed_intregs +\n+\t\t\t\t\t     1) * 8), GE, const1_rtx, SImode,\n+\t\t\t\t   1, 1, lab_false);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  emit_cmp_and_jump_insns (expand_expr\n+\t\t\t\t   (fpr, NULL_RTX, SImode, EXPAND_NORMAL),\n+\t\t\t\t   GEN_INT ((SSE_REGPARM_MAX -\n+\t\t\t\t\t     needed_sseregs + 1) * 16 +\n+\t\t\t\t\t    REGPARM_MAX * 8), GE, const1_rtx,\n+\t\t\t\t   SImode, 1, 1, lab_false);\n+\t}\n+\n+      /* Compute index to start of area used for integer regs.  */\n+      if (needed_intregs)\n+\t{\n+\t  t = build (PLUS_EXPR, ptr_type_node, sav, gpr);\n+\t  r = expand_expr (t, int_addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != int_addr_rtx)\n+\t    emit_move_insn (int_addr_rtx, r);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  t = build (PLUS_EXPR, ptr_type_node, sav, fpr);\n+\t  r = expand_expr (t, sse_addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != sse_addr_rtx)\n+\t    emit_move_insn (sse_addr_rtx, r);\n+\t}\n+      if (need_temp)\n+\t{\n+\t  int i;\n+\t  rtx mem;\n+\n+\t  mem = assign_temp (type, 0, 1, 0);\n+\t  MEM_ALIAS_SET (mem) = get_varargs_alias_set ();\n+\t  addr_rtx = XEXP (mem, 0);\n+\t  for (i = 0; i < XVECLEN (container, 0); i++)\n+\t    {\n+\t      rtx slot = XVECEXP (container, 0, i);\n+\t      rtx reg = XEXP (slot, 0);\n+\t      enum machine_mode mode = GET_MODE (reg);\n+\t      rtx src_addr;\n+\t      rtx src_mem;\n+\t      int src_offset;\n+\t      rtx dest_mem;\n+\n+\t      if (SSE_REGNO_P (REGNO (reg)))\n+\t\t{\n+\t\t  src_addr = sse_addr_rtx;\n+\t\t  src_offset = (REGNO (reg) - FIRST_SSE_REG) * 16;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  src_addr = int_addr_rtx;\n+\t\t  src_offset = REGNO (reg) * 8;\n+\t\t}\n+\t      src_mem = gen_rtx_MEM (mode, src_addr);\n+\t      MEM_ALIAS_SET (src_mem) = get_varargs_alias_set ();\n+\t      src_mem = adjust_address (src_mem, mode, src_offset);\n+\t      dest_mem = adjust_address (mem, mode, INTVAL (XEXP (slot, 1)));\n+\t      PUT_MODE (dest_mem, mode);\n+\t      /* ??? Break out TImode moves from integer registers?  */\n+\t      emit_move_insn (dest_mem, src_mem);\n+\t    }\n+\t}\n+\n+      if (needed_intregs)\n+\t{\n+\t  t =\n+\t    build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t   build_int_2 (needed_intregs * 8, 0));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t}\n+      if (needed_sseregs)\n+\t{\n+\t  t =\n+\t    build (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t   build_int_2 (needed_sseregs * 16, 0));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t}\n+\n+      emit_jump_insn (gen_jump (lab_over));\n+      emit_barrier ();\n+      emit_label (lab_false);\n+    }\n+\n+  /* ... otherwise out of the overflow area.  */\n+\n+  /* Care for on-stack alignment if needed.  */\n+  if (FUNCTION_ARG_BOUNDARY (VOIDmode, type) <= 64)\n+    t = ovf;\n+  else\n+    {\n+      HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n+      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+    }\n+  t = save_expr (t);\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+  t =\n+    build (PLUS_EXPR, TREE_TYPE (t), t,\n+\t   build_int_2 (rsize * UNITS_PER_WORD, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  if (container)\n+    emit_label (lab_over);\n+\n+  if (indirect_p)\n+    {\n+      abort ();\n+      r = gen_rtx_MEM (Pmode, addr_rtx);\n+      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+      emit_move_insn (addr_rtx, r);\n+    }\n+\n+  return addr_rtx;\n+}\n+\f\n /* Return nonzero if OP is general operand representable on x86_64.  */\n \n int"}, {"sha": "654d8fbdac0da6afadea979e12a6253c411086fa", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -1604,6 +1604,35 @@ typedef struct ix86_args {\n        || ! FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (TREE_TYPE (DECL)))) \\\n        || FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (TREE_TYPE (cfun->decl))))))\n \n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments.\n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n+  ix86_setup_incoming_varargs (&CUM, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = ix86_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  ix86_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  ix86_va_arg (valist, type)\n+\n /* This macro is invoked at the end of compilation.  It is used here to\n    output code for -fpic that will load the return address into %ebx.  */\n \n@@ -2775,6 +2804,7 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n #define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 2)\n \n+\n /* Select a format to encode pointers in exception handling data.  CODE\n    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n    true if the symbol may be affected by dynamic relocations."}, {"sha": "5119db6615b0db83b67c00ff0e876095fd1e8f4a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -19066,3 +19066,63 @@\n }\n   [(set_attr \"type\" \"sse\")])\n \n+(define_expand \"sse_prologue_save\"\n+  [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n+\t\t   (unspec:BLK [(reg:DI 21)\n+\t\t\t\t(reg:DI 22)\n+\t\t\t\t(reg:DI 23)\n+\t\t\t\t(reg:DI 24)\n+\t\t\t\t(reg:DI 25)\n+\t\t\t\t(reg:DI 26)\n+\t\t\t\t(reg:DI 27)\n+\t\t\t\t(reg:DI 28)] 13))\n+\t      (use (match_operand:DI 1 \"register_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))\n+\t      (use (label_ref:DI (match_operand 3 \"\" \"\")))])]\n+  \"TARGET_64BIT\"\n+  \"\")\n+\n+(define_insn \"*sse_prologue_save_insn\"\n+  [(set (mem:BLK (plus:DI (match_operand:DI 0 \"register_operand\" \"R\")\n+\t\t\t  (match_operand:DI 4 \"const_int_operand\" \"n\")))\n+\t(unspec:BLK [(reg:DI 21)\n+\t\t     (reg:DI 22)\n+\t\t     (reg:DI 23)\n+\t\t     (reg:DI 24)\n+\t\t     (reg:DI 25)\n+\t\t     (reg:DI 26)\n+\t\t     (reg:DI 27)\n+\t\t     (reg:DI 28)] 13))\n+   (use (match_operand:DI 1 \"register_operand\" \"r\"))\n+   (use (match_operand:DI 2 \"const_int_operand\" \"i\"))\n+   (use (label_ref:DI (match_operand 3 \"\" \"X\")))]\n+  \"TARGET_64BIT\n+   && INTVAL (operands[4]) + SSE_REGPARM_MAX * 16 - 16 < 128\n+   && INTVAL (operands[4]) + INTVAL (operands[2]) * 16 >= -128\"\n+  \"*\n+{\n+  int i;\n+  operands[0] = gen_rtx_MEM (Pmode,\n+\t\t\t     gen_rtx_PLUS (Pmode, operands[0], operands[4]));\n+  output_asm_insn (\\\"jmp\\\\t%A1\\\", operands);\n+  for (i = SSE_REGPARM_MAX - 1; i >= INTVAL (operands[2]); i--)\n+    {\n+      operands[4] = adjust_address (operands[0], DImode, i*16);\n+      operands[5] = gen_rtx_REG (TImode, SSE_REGNO (i));\n+      PUT_MODE (operands[4], TImode);\n+      if (GET_CODE (XEXP (operands[0], 0)) != PLUS)\n+        output_asm_insn (\\\"rex\\\", operands);\n+      output_asm_insn (\\\"movaps\\\\t{%5, %4|%4, %5}\\\", operands);\n+    }\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (operands[3]));\n+  RET;\n+}\n+  \"\n+  [(set_attr \"type\" \"other\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"length_address\" \"0\")\n+   (set_attr \"length\" \"135\")\n+   (set_attr \"memory\" \"store\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"mode\" \"DI\")])"}, {"sha": "58c4d0390bb10df009d33463e7f456eb20d1b875", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ad91981212e1f9cf0c9b57a93f85e0a5cf1e096b", "patch": "@@ -274,7 +274,7 @@ in the following sections.\n -fschedule-insns  -fschedule-insns2 @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -fthread-jumps  -ftrapv @gol\n--funroll-all-loops  -funroll-loops  @gol\n+-funroll-all-loops  -funroll-loops -fmessy-debugging @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -3414,6 +3414,18 @@ of optimizations to be performed is desired.\n Not all of the optimizations performed by GCC have @option{-f} options\n to control them.\n \n+@table @gcctabopt\n+@item -fmessy-debugging\n+@opindex fmessy-debugging\n+Some optimizations can be stronger if compiler give up ability to generate\n+at least approximately usefull debug information for optimized programs.\n+These transformation are not done when @option{-g} switch is not specified,\n+as politics is to get the code with @option{-g} and without equivalent,\n+except for debugging section.\n+\n+This optimization enables such transformations.  It is still compatible with\n+@option{-g}, but debugging resulting programs will be even higher challenge.\n+\n @table @gcctabopt\n @item -fstrength-reduce\n @opindex fstrength-reduce"}]}