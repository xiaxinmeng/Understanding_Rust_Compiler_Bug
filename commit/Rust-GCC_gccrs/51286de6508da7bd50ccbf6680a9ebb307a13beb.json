{"sha": "51286de6508da7bd50ccbf6680a9ebb307a13beb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyODZkZTY1MDhkYTdiZDUwY2NiZjY2ODBhOWViYjMwN2ExM2JlYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-12T17:09:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-12T17:09:24Z"}, "message": "expr.c (compress_float_constant): New.\n\n        * expr.c (compress_float_constant): New.\n        (emit_move_insn): Use it.\n        (float_extend_from_mem): New.\n        (init_expr_once): Initialize it.\n        * real.c (exact_real_truncate): New.\n\n        * config/i386/i386.h (CONST_COSTS): Assume CONST_DOUBLE gets\n        dropped into memory; penalize for size.\n        (RTX_COSTS): FLOAT_EXTEND is free.\n        * config/i386/i386.md (extendsfdf2, extendsfxf2, extendsftf2,\n        extenddfxf2, extenddftf2): Accept constants and drop them to memory.\n\nFrom-SVN: r53401", "tree": {"sha": "e7f07bf40bf4b1b2030898085fdd52bd0243b374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7f07bf40bf4b1b2030898085fdd52bd0243b374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51286de6508da7bd50ccbf6680a9ebb307a13beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51286de6508da7bd50ccbf6680a9ebb307a13beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51286de6508da7bd50ccbf6680a9ebb307a13beb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51286de6508da7bd50ccbf6680a9ebb307a13beb/comments", "author": null, "committer": null, "parents": [{"sha": "6412341ec950b23d76e52b89f052aab8efeee039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6412341ec950b23d76e52b89f052aab8efeee039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6412341ec950b23d76e52b89f052aab8efeee039"}], "stats": {"total": 187, "additions": 169, "deletions": 18}, "files": [{"sha": "235d652c0cc5997cf73b830b5e756ddbf54e9f91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51286de6508da7bd50ccbf6680a9ebb307a13beb", "patch": "@@ -1,3 +1,17 @@\n+2002-05-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (compress_float_constant): New.\n+\t(emit_move_insn): Use it.\n+\t(float_extend_from_mem): New.\n+\t(init_expr_once): Initialize it.\n+\t* real.c (exact_real_truncate): New.\n+\n+\t* config/i386/i386.h (CONST_COSTS): Assume CONST_DOUBLE gets\n+\tdropped into memory; penalize for size.\n+\t(RTX_COSTS): FLOAT_EXTEND is free.\n+\t* config/i386/i386.md (extendsfdf2, extendsfxf2, extendsftf2,\n+\textenddfxf2, extenddftf2): Accept constants and drop them to memory.\n+\n 2002-05-12  Richard Henderson  <rth@redhat.com>\n \n \t* profile.h (profile_info): Add missing extern to declaration."}, {"sha": "680605b9955df922c089174b67686b750e141fdd", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=51286de6508da7bd50ccbf6680a9ebb307a13beb", "patch": "@@ -2595,16 +2595,21 @@ do {\t\t\t\t\t\t\t\\\n     return flag_pic && SYMBOLIC_CONST (RTX) ? 1 : 0;\t\t\\\n \t\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int code;\t\t\t\t\t\t\t\\\n-      if (GET_MODE (RTX) == VOIDmode)\t\t\t\t\\\n-\treturn 0;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      code = standard_80387_constant_p (RTX);\t\t\t\\\n-      return code == 1 ? 1 :\t\t\t\t\t\\\n-\t     code == 2 ? 2 :\t\t\t\t\t\\\n-\t\t\t 3;\t\t\t\t\t\\\n-    }\n+    if (GET_MODE (RTX) == VOIDmode)\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    switch (standard_80387_constant_p (RTX))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+      case 1: /* 0.0 */\t\t\t\t\t\t\\\n+\treturn 1;\t\t\t\t\t\t\\\n+      case 2: /* 1.0 */\t\t\t\t\t\t\\\n+\treturn 2;\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\\\n+\t/* Start with (MEM (SYMBOL_REF)), since that's where\t\\\n+\t   it'll probably end up.  Add a penalty for size.  */\t\\\n+\treturn (COSTS_N_INSNS (1) + (flag_pic != 0)\t\t\\\n+\t\t+ (GET_MODE (RTX) == SFmode ? 0\t\t\t\\\n+\t\t   : GET_MODE (RTX) == DFmode ? 1 : 2));\t\\\n+      }\n \n /* Delete the definition here when TOPLEVEL_COSTS_N_INSNS gets added to cse.c */\n #define TOPLEVEL_COSTS_N_INSNS(N) \\\n@@ -2766,6 +2771,9 @@ do {\t\t\t\t\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2);\t\t\t\\\n     TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  case FLOAT_EXTEND:\t\t\t\t\t\t\t\\\n+    TOPLEVEL_COSTS_N_INSNS (0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   egress_rtx_costs:\t\t\t\t\t\t\t\\\n     break;\n "}, {"sha": "11ab6f421776a972a953ee6fda110d9debf20508", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=51286de6508da7bd50ccbf6680a9ebb307a13beb", "patch": "@@ -3367,9 +3367,13 @@\n \n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-        (float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+        (float_extend:DF (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387 || TARGET_SSE2\"\n {\n+  /* ??? Needed for compress_float_constant since all fp constants\n+     are LEGITIMATE_CONSTANT_P.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = validize_mem (force_const_mem (SFmode, operands[1]));\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[1] = force_reg (SFmode, operands[1]);\n })\n@@ -3418,9 +3422,13 @@\n \n (define_expand \"extendsfxf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-        (float_extend:XF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+        (float_extend:XF (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"!TARGET_64BIT && TARGET_80387\"\n {\n+  /* ??? Needed for compress_float_constant since all fp constants\n+     are LEGITIMATE_CONSTANT_P.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = validize_mem (force_const_mem (SFmode, operands[1]));\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[1] = force_reg (SFmode, operands[1]);\n })\n@@ -3459,9 +3467,13 @@\n \n (define_expand \"extendsftf2\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+        (float_extend:TF (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387\"\n {\n+  /* ??? Needed for compress_float_constant since all fp constants\n+     are LEGITIMATE_CONSTANT_P.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = validize_mem (force_const_mem (SFmode, operands[1]));\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[1] = force_reg (SFmode, operands[1]);\n })\n@@ -3500,9 +3512,13 @@\n \n (define_expand \"extenddfxf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-        (float_extend:XF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+        (float_extend:XF (match_operand:DF 1 \"general_operand\" \"\")))]\n   \"!TARGET_64BIT && TARGET_80387\"\n {\n+  /* ??? Needed for compress_float_constant since all fp constants\n+     are LEGITIMATE_CONSTANT_P.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = validize_mem (force_const_mem (SFmode, operands[1]));\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[1] = force_reg (DFmode, operands[1]);\n })\n@@ -3541,9 +3557,13 @@\n \n (define_expand \"extenddftf2\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+        (float_extend:TF (match_operand:DF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387\"\n {\n+  /* ??? Needed for compress_float_constant since all fp constants\n+     are LEGITIMATE_CONSTANT_P.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = validize_mem (force_const_mem (SFmode, operands[1]));\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     operands[1] = force_reg (DFmode, operands[1]);\n })"}, {"sha": "1a8d051832380487ebc2ccce7027d4aef9fcdac7", "filename": "gcc/expr.c", "status": "modified", "additions": 96, "deletions": 3, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=51286de6508da7bd50ccbf6680a9ebb307a13beb", "patch": "@@ -134,6 +134,7 @@ static void store_by_pieces_1\tPARAMS ((struct store_by_pieces *,\n static void store_by_pieces_2\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n \t\t\t\t\t struct store_by_pieces *));\n+static rtx compress_float_constant PARAMS ((rtx, rtx));\n static rtx get_subtarget\tPARAMS ((rtx));\n static int is_zeros_p\t\tPARAMS ((tree));\n static int mostly_zeros_p\tPARAMS ((tree));\n@@ -167,6 +168,10 @@ static void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n static char direct_load[NUM_MACHINE_MODES];\n static char direct_store[NUM_MACHINE_MODES];\n \n+/* Record for each mode whether we can float-extend from memory.  */\n+\n+static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n+\n /* If a memory-to-memory move would take MOVE_RATIO or more simple\n    move-instruction sequences, we will do a movstr or libcall instead.  */\n \n@@ -265,6 +270,28 @@ init_expr_once ()\n \t  }\n     }\n \n+  mem = gen_rtx_MEM (VOIDmode, gen_rtx_raw_REG (Pmode, 10000));\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      enum machine_mode srcmode;\n+      for (srcmode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); srcmode != mode;\n+           srcmode = GET_MODE_WIDER_MODE (srcmode))\n+\t{\n+\t  enum insn_code ic;\n+\n+\t  ic = can_extend_p (mode, srcmode, 0);\n+\t  if (ic == CODE_FOR_nothing)\n+\t    continue;\n+\n+\t  PUT_MODE (mem, srcmode);\n+\t  \n+\t  if ((*insn_data[ic].operand[1].predicate) (mem, srcmode))\n+\t    float_extend_from_mem[mode][srcmode] = true;\n+\t}\n+    }\n+\n   end_sequence ();\n }\n \n@@ -2771,10 +2798,18 @@ emit_move_insn (x, y)\n   /* Never force constant_p_rtx to memory.  */\n   if (GET_CODE (y) == CONSTANT_P_RTX)\n     ;\n-  else if (CONSTANT_P (y) && ! LEGITIMATE_CONSTANT_P (y))\n+  else if (CONSTANT_P (y))\n     {\n-      y_cst = y;\n-      y = force_const_mem (mode, y);\n+      if (optimize\n+\t  && FLOAT_MODE_P (GET_MODE (x))\n+\t  && (last_insn = compress_float_constant (x, y)))\n+\treturn last_insn;\n+\n+      if (!LEGITIMATE_CONSTANT_P (y))\n+\t{\n+\t  y_cst = y;\n+\t  y = force_const_mem (mode, y);\n+\t}\n     }\n \n   /* If X or Y are memory references, verify that their addresses are valid\n@@ -3100,6 +3135,64 @@ emit_move_insn_1 (x, y)\n   else\n     abort ();\n }\n+\n+/* If Y is representable exactly in a narrower mode, and the target can\n+   perform the extension directly from constant or memory, then emit the\n+   move as an extension.  */\n+\n+static rtx\n+compress_float_constant (x, y)\n+     rtx x, y;\n+{\n+  enum machine_mode dstmode = GET_MODE (x);\n+  enum machine_mode orig_srcmode = GET_MODE (y);\n+  enum machine_mode srcmode;\n+  REAL_VALUE_TYPE r;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, y);\n+\n+  for (srcmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_srcmode));\n+       srcmode != orig_srcmode;\n+       srcmode = GET_MODE_WIDER_MODE (srcmode))\n+    {\n+      enum insn_code ic;\n+      rtx trunc_y, last_insn;\n+\n+      /* Skip if the target can't extend this way.  */\n+      ic = can_extend_p (dstmode, srcmode, 0);\n+      if (ic == CODE_FOR_nothing)\n+\tcontinue;\n+\n+      /* Skip if the narrowed value isn't exact.  */\n+      if (! exact_real_truncate (srcmode, &r))\n+\tcontinue;\n+\n+      trunc_y = CONST_DOUBLE_FROM_REAL_VALUE (r, srcmode);\n+\n+      if (LEGITIMATE_CONSTANT_P (trunc_y))\n+\t{\n+\t  /* Skip if the target needs extra instructions to perform\n+\t     the extension.  */\n+\t  if (! (*insn_data[ic].operand[1].predicate) (trunc_y, srcmode))\n+\t    continue;\n+\t}\n+      else if (float_extend_from_mem[dstmode][srcmode])\n+\ttrunc_y = validize_mem (force_const_mem (srcmode, trunc_y));\n+      else\n+\tcontinue;\n+\n+      emit_unop_insn (ic, x, trunc_y, UNKNOWN);\n+      last_insn = get_last_insn ();\n+\n+      if (GET_CODE (x) == REG)\n+\tREG_NOTES (last_insn)\n+\t  = gen_rtx_EXPR_LIST (REG_EQUAL, y, REG_NOTES (last_insn));\n+\n+      return last_insn;\n+    }\n+\n+  return NULL_RTX;\n+}\n \f\n /* Pushing data onto the stack.  */\n "}, {"sha": "a4196981a1ba39df5f28783135e96e76aa2ad77a", "filename": "gcc/real.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51286de6508da7bd50ccbf6680a9ebb307a13beb/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=51286de6508da7bd50ccbf6680a9ebb307a13beb", "patch": "@@ -1066,6 +1066,22 @@ real_value_truncate (mode, arg)\n   return (r);\n }\n \n+/* Return true if ARG can be represented exactly in MODE.  */\n+\n+bool\n+exact_real_truncate (mode, arg)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE *arg;\n+{\n+  REAL_VALUE_TYPE trunc;\n+\n+  if (target_isnan (*arg))\n+    return false;\n+\n+  trunc = real_value_truncate (mode, *arg);\n+  return ereal_cmp (*arg, trunc) == 0;\n+}\n+\n /* Try to change R into its exact multiplicative inverse in machine mode\n    MODE.  Return nonzero function value if successful.  */\n "}]}