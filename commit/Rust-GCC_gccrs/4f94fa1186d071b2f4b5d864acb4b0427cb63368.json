{"sha": "4f94fa1186d071b2f4b5d864acb4b0427cb63368", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY5NGZhMTE4NmQwNzFiMmY0YjVkODY0YWNiNGIwNDI3Y2I2MzM2OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-19T11:55:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-19T11:55:21Z"}, "message": "[multiple changes]\n\n2017-01-19  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Remove side effects on\n\tactuals that are allocators with qualified expression since the\n\tinitialization of the object is performed by means of individual\n\tstatements (and hence it must be done before the call).\n\n2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Minor reformatting.\n\t(Build_Derived_Enumeration_Type): If the derived type inherits a\n\tdynamic predicate from its parent, the bounds of the type must\n\tfreeze because an explicit constraint is constructed for the\n\ttype and the corresponding range is elaborated now.\n\n2017-01-19  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_attr.ads: minor fix of inconsistent casing in comment\n\t* lib-writ.ads: minor align comments in columns\n\t* sem_ch3.adb: Minor reformatting.\n\t* spark_xrefs.ads: minor fix typo in SPARK-related comment\n\t* table.ads: minor style fix in comment\n\t* lib-xref-spark_specific.adb\n\t(Add_SPARK_Xrefs): simplify processing of SPARK cross-references.\n\t* sem_ch12.adb: minor whitespace fix\n\t* freeze.adb: Add comment.\n\t* sem_util.adb (Unique_Name): for instances of\n\tgeneric subprograms ignore the name of the wrapper package.\n\n2017-01-19  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Resolve_Record_Aggregate):\n\tFactorize code needed for aggregates of limited and unlimited\n\ttypes in a new routine.\n\t(Pass_Aggregate_To_Back_End): New subprogram.\n\n2017-01-19  Yannick Moy  <moy@adacore.com>\n\n\t* sinfo.adb (Pragma_Name): Only access up to Last_Pair of Pragma_Map.\n\nFrom-SVN: r244622", "tree": {"sha": "433636d571333cf3b1f941de0615bedd050305ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/433636d571333cf3b1f941de0615bedd050305ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f94fa1186d071b2f4b5d864acb4b0427cb63368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f94fa1186d071b2f4b5d864acb4b0427cb63368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f94fa1186d071b2f4b5d864acb4b0427cb63368", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f94fa1186d071b2f4b5d864acb4b0427cb63368/comments", "author": null, "committer": null, "parents": [{"sha": "4fcf700c916e89d5b1351200b2dd44a9fe8678d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fcf700c916e89d5b1351200b2dd44a9fe8678d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fcf700c916e89d5b1351200b2dd44a9fe8678d3"}], "stats": {"total": 538, "additions": 322, "deletions": 216}, "files": [{"sha": "4782ab7091041f121a40183c498be442da327b08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -1,3 +1,43 @@\n+2017-01-19  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Remove side effects on\n+\tactuals that are allocators with qualified expression since the\n+\tinitialization of the object is performed by means of individual\n+\tstatements (and hence it must be done before the call).\n+\n+2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Minor reformatting.\n+\t(Build_Derived_Enumeration_Type): If the derived type inherits a\n+\tdynamic predicate from its parent, the bounds of the type must\n+\tfreeze because an explicit constraint is constructed for the\n+\ttype and the corresponding range is elaborated now.\n+\n+2017-01-19  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_attr.ads: minor fix of inconsistent casing in comment\n+\t* lib-writ.ads: minor align comments in columns\n+\t* sem_ch3.adb: Minor reformatting.\n+\t* spark_xrefs.ads: minor fix typo in SPARK-related comment\n+\t* table.ads: minor style fix in comment\n+\t* lib-xref-spark_specific.adb\n+\t(Add_SPARK_Xrefs): simplify processing of SPARK cross-references.\n+\t* sem_ch12.adb: minor whitespace fix\n+\t* freeze.adb: Add comment.\n+\t* sem_util.adb (Unique_Name): for instances of\n+\tgeneric subprograms ignore the name of the wrapper package.\n+\n+2017-01-19  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Resolve_Record_Aggregate):\n+\tFactorize code needed for aggregates of limited and unlimited\n+\ttypes in a new routine.\n+\t(Pass_Aggregate_To_Back_End): New subprogram.\n+\n+2017-01-19  Yannick Moy  <moy@adacore.com>\n+\n+\t* sinfo.adb (Pragma_Name): Only access up to Last_Pair of Pragma_Map.\n+\n 2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch4.ads, sem_ch4.adb (Try_Object_Operation): Make subprogram"}, {"sha": "811340249935e69b37339c84d7087866415414e2", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 160, "deletions": 146, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -6545,6 +6545,9 @@ package body Exp_Aggr is\n       --  because it will not be set when type and its parent are in the\n       --  same scope, and the parent component needs expansion.\n \n+      procedure Pass_Aggregate_To_Back_End;\n+      --  Build a proper aggregate to be handled by the back-end\n+\n       function Top_Level_Aggregate (N : Node_Id) return Node_Id;\n       --  For nested aggregates return the ultimate enclosing aggregate; for\n       --  non-nested aggregates return N.\n@@ -6723,155 +6726,16 @@ package body Exp_Aggr is\n          end loop;\n       end Has_Visible_Private_Ancestor;\n \n-      -------------------------\n-      -- Top_Level_Aggregate --\n-      -------------------------\n+      --------------------------------\n+      -- Pass_Aggregate_To_Back_End --\n+      --------------------------------\n \n-      function Top_Level_Aggregate (N : Node_Id) return Node_Id is\n-         Aggr : Node_Id;\n+      procedure Pass_Aggregate_To_Back_End is\n+         Comp      : Entity_Id;\n+         New_Comp  : Node_Id;\n+         Tag_Value : Node_Id;\n \n       begin\n-         Aggr := N;\n-         while Present (Parent (Aggr))\n-           and then Nkind_In (Parent (Aggr), N_Component_Association,\n-                                             N_Aggregate)\n-         loop\n-            Aggr := Parent (Aggr);\n-         end loop;\n-\n-         return Aggr;\n-      end Top_Level_Aggregate;\n-\n-      --  Local variables\n-\n-      Top_Level_Aggr : constant Node_Id := Top_Level_Aggregate (N);\n-      Tag_Value      : Node_Id;\n-      Comp           : Entity_Id;\n-      New_Comp       : Node_Id;\n-\n-   --  Start of processing for Expand_Record_Aggregate\n-\n-   begin\n-      --  If the aggregate is to be assigned to an atomic/VFA variable, we have\n-      --  to prevent a piecemeal assignment even if the aggregate is to be\n-      --  expanded. We create a temporary for the aggregate, and assign the\n-      --  temporary instead, so that the back end can generate an atomic move\n-      --  for it.\n-\n-      if Is_Atomic_VFA_Aggregate (N) then\n-         return;\n-\n-      --  No special management required for aggregates used to initialize\n-      --  statically allocated dispatch tables\n-\n-      elsif Is_Static_Dispatch_Table_Aggregate (N) then\n-         return;\n-      end if;\n-\n-      --  Ada 2005 (AI-318-2): We need to convert to assignments if components\n-      --  are build-in-place function calls. The assignments will each turn\n-      --  into a build-in-place function call. If components are all static,\n-      --  we can pass the aggregate to the backend regardless of limitedness.\n-\n-      --  Extension aggregates, aggregates in extended return statements, and\n-      --  aggregates for C++ imported types must be expanded.\n-\n-      if Ada_Version >= Ada_2005 and then Is_Limited_View (Typ) then\n-         if not Nkind_In (Parent (N), N_Object_Declaration,\n-                                      N_Component_Association)\n-         then\n-            Convert_To_Assignments (N, Typ);\n-\n-         elsif Nkind (N) = N_Extension_Aggregate\n-           or else Convention (Typ) = Convention_CPP\n-         then\n-            Convert_To_Assignments (N, Typ);\n-\n-         elsif not Size_Known_At_Compile_Time (Typ)\n-           or else Component_Not_OK_For_Backend\n-           or else not Static_Components\n-         then\n-            Convert_To_Assignments (N, Typ);\n-\n-         else\n-            Set_Compile_Time_Known_Aggregate (N);\n-            Set_Expansion_Delayed (N, False);\n-         end if;\n-\n-      --  Gigi doesn't properly handle temporaries of variable size so we\n-      --  generate it in the front-end\n-\n-      elsif not Size_Known_At_Compile_Time (Typ)\n-        and then Tagged_Type_Expansion\n-      then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  An aggregate used to initialize a controlled object must be turned\n-      --  into component assignments as the components themselves may require\n-      --  finalization actions such as adjustment.\n-\n-      elsif Needs_Finalization (Typ) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  Ada 2005 (AI-287): In case of default initialized components we\n-      --  convert the aggregate into assignments.\n-\n-      elsif Has_Default_Init_Comps (N) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  Check components\n-\n-      elsif Component_Not_OK_For_Backend then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  If an ancestor is private, some components are not inherited and we\n-      --  cannot expand into a record aggregate.\n-\n-      elsif Has_Visible_Private_Ancestor (Typ) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  ??? The following was done to compile fxacc00.ads in the ACVCs. Gigi\n-      --  is not able to handle the aggregate for Late_Request.\n-\n-      elsif Is_Tagged_Type (Typ) and then Has_Discriminants (Typ) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  If the tagged types covers interface types we need to initialize all\n-      --  hidden components containing pointers to secondary dispatch tables.\n-\n-      elsif Is_Tagged_Type (Typ) and then Has_Interfaces (Typ) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  If some components are mutable, the size of the aggregate component\n-      --  may be distinct from the default size of the type component, so\n-      --  we need to expand to insure that the back-end copies the proper\n-      --  size of the data. However, if the aggregate is the initial value of\n-      --  a constant, the target is immutable and might be built statically\n-      --  if components are appropriate.\n-\n-      elsif Has_Mutable_Components (Typ)\n-        and then\n-          (Nkind (Parent (Top_Level_Aggr)) /= N_Object_Declaration\n-            or else not Constant_Present (Parent (Top_Level_Aggr))\n-            or else not Static_Components)\n-      then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  If the type involved has bit aligned components, then we are not sure\n-      --  that the back end can handle this case correctly.\n-\n-      elsif Type_May_Have_Bit_Aligned_Components (Typ) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  When generating C, only generate an aggregate when declaring objects\n-      --  since C does not support aggregates in e.g. assignment statements.\n-\n-      elsif Modify_Tree_For_C and then not In_Object_Declaration (N) then\n-         Convert_To_Assignments (N, Typ);\n-\n-      --  In all other cases, build a proper aggregate to be handled by gigi\n-\n-      else\n          if Nkind (N) = N_Aggregate then\n \n             --  If the aggregate is static and can be handled by the back-end,\n@@ -7164,8 +7028,158 @@ package body Exp_Aggr is\n                end;\n             end if;\n          end if;\n+      end Pass_Aggregate_To_Back_End;\n+\n+      -------------------------\n+      -- Top_Level_Aggregate --\n+      -------------------------\n+\n+      function Top_Level_Aggregate (N : Node_Id) return Node_Id is\n+         Aggr : Node_Id;\n+\n+      begin\n+         Aggr := N;\n+         while Present (Parent (Aggr))\n+           and then Nkind_In (Parent (Aggr), N_Component_Association,\n+                                             N_Aggregate)\n+         loop\n+            Aggr := Parent (Aggr);\n+         end loop;\n+\n+         return Aggr;\n+      end Top_Level_Aggregate;\n+\n+      --  Local variables\n+\n+      Top_Level_Aggr : constant Node_Id := Top_Level_Aggregate (N);\n+\n+   --  Start of processing for Expand_Record_Aggregate\n+\n+   begin\n+      --  If the aggregate is to be assigned to an atomic/VFA variable, we have\n+      --  to prevent a piecemeal assignment even if the aggregate is to be\n+      --  expanded. We create a temporary for the aggregate, and assign the\n+      --  temporary instead, so that the back end can generate an atomic move\n+      --  for it.\n+\n+      if Is_Atomic_VFA_Aggregate (N) then\n+         return;\n+\n+      --  No special management required for aggregates used to initialize\n+      --  statically allocated dispatch tables\n+\n+      elsif Is_Static_Dispatch_Table_Aggregate (N) then\n+         return;\n       end if;\n \n+      --  Ada 2005 (AI-318-2): We need to convert to assignments if components\n+      --  are build-in-place function calls. The assignments will each turn\n+      --  into a build-in-place function call. If components are all static,\n+      --  we can pass the aggregate to the backend regardless of limitedness.\n+\n+      --  Extension aggregates, aggregates in extended return statements, and\n+      --  aggregates for C++ imported types must be expanded.\n+\n+      if Ada_Version >= Ada_2005 and then Is_Limited_View (Typ) then\n+         if not Nkind_In (Parent (N), N_Object_Declaration,\n+                                      N_Component_Association)\n+         then\n+            Convert_To_Assignments (N, Typ);\n+\n+         elsif Nkind (N) = N_Extension_Aggregate\n+           or else Convention (Typ) = Convention_CPP\n+         then\n+            Convert_To_Assignments (N, Typ);\n+\n+         elsif not Size_Known_At_Compile_Time (Typ)\n+           or else Component_Not_OK_For_Backend\n+           or else not Static_Components\n+         then\n+            Convert_To_Assignments (N, Typ);\n+\n+         --  In all other cases, build a proper aggregate to be handled by\n+         --  the back-end\n+\n+         else\n+            Pass_Aggregate_To_Back_End;\n+         end if;\n+\n+      --  Gigi doesn't properly handle temporaries of variable size so we\n+      --  generate it in the front-end\n+\n+      elsif not Size_Known_At_Compile_Time (Typ)\n+        and then Tagged_Type_Expansion\n+      then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  An aggregate used to initialize a controlled object must be turned\n+      --  into component assignments as the components themselves may require\n+      --  finalization actions such as adjustment.\n+\n+      elsif Needs_Finalization (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  Ada 2005 (AI-287): In case of default initialized components we\n+      --  convert the aggregate into assignments.\n+\n+      elsif Has_Default_Init_Comps (N) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  Check components\n+\n+      elsif Component_Not_OK_For_Backend then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  If an ancestor is private, some components are not inherited and we\n+      --  cannot expand into a record aggregate.\n+\n+      elsif Has_Visible_Private_Ancestor (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  ??? The following was done to compile fxacc00.ads in the ACVCs. Gigi\n+      --  is not able to handle the aggregate for Late_Request.\n+\n+      elsif Is_Tagged_Type (Typ) and then Has_Discriminants (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  If the tagged types covers interface types we need to initialize all\n+      --  hidden components containing pointers to secondary dispatch tables.\n+\n+      elsif Is_Tagged_Type (Typ) and then Has_Interfaces (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  If some components are mutable, the size of the aggregate component\n+      --  may be distinct from the default size of the type component, so\n+      --  we need to expand to insure that the back-end copies the proper\n+      --  size of the data. However, if the aggregate is the initial value of\n+      --  a constant, the target is immutable and might be built statically\n+      --  if components are appropriate.\n+\n+      elsif Has_Mutable_Components (Typ)\n+        and then\n+          (Nkind (Parent (Top_Level_Aggr)) /= N_Object_Declaration\n+            or else not Constant_Present (Parent (Top_Level_Aggr))\n+            or else not Static_Components)\n+      then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  If the type involved has bit aligned components, then we are not sure\n+      --  that the back end can handle this case correctly.\n+\n+      elsif Type_May_Have_Bit_Aligned_Components (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  When generating C, only generate an aggregate when declaring objects\n+      --  since C does not support aggregates in e.g. assignment statements.\n+\n+      elsif Modify_Tree_For_C and then not In_Object_Declaration (N) then\n+         Convert_To_Assignments (N, Typ);\n+\n+      --  In all other cases, build a proper aggregate to be handled by gigi\n+\n+      else\n+         Pass_Aggregate_To_Back_End;\n+      end if;\n    end Expand_Record_Aggregate;\n \n    ----------------------------"}, {"sha": "fef399f4defa712510b904196035f0058173137b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -3315,6 +3315,17 @@ package body Exp_Ch6 is\n             Add_View_Conversion_Invariants (Formal, Actual);\n          end if;\n \n+         --  Generating C the initialization of an allocator is performed by\n+         --  means of individual statements, and hence it must be done before\n+         --  the call.\n+\n+         if Modify_Tree_For_C\n+           and then Nkind (Actual) = N_Allocator\n+           and then Nkind (Expression (Actual)) = N_Qualified_Expression\n+         then\n+            Remove_Side_Effects (Actual);\n+         end if;\n+\n          --  This label is required when skipping extra actual generation for\n          --  Unchecked_Union parameters.\n "}, {"sha": "2a453fe0020ee1ce2a73d7bad04549dca54edbb3", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -5305,6 +5305,9 @@ package body Freeze is\n          --  trigger the analysis of aspect expressions, so in this case we\n          --  want to continue the freezing process.\n \n+         --  Is_Generic_Unit (Scope (E)) is dubious here, do we want instead\n+         --  In_Generic_Scope (E)???\n+\n          if Present (Scope (E))\n            and then Is_Generic_Unit (Scope (E))\n            and then"}, {"sha": "f113b0a5993ba8f9a20aaae78deceda53d85d7ce", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -192,8 +192,8 @@ package Lib.Writ is\n    --              the units in this file, where x is the first character\n    --              (upper case) of the policy name (e.g. 'C' for Concurrent).\n \n-   --         FX  Units in this file use front-end exceptions, with explicit\n-   --             handlers to trigger AT-END actions on exception paths.\n+   --         FX   Units in this file use front-end exceptions, with explicit\n+   --              handlers to trigger AT-END actions on exception paths.\n \n    --         GP   Set if this compilation was done in GNATprove mode, either\n    --              from direct use of GNATprove, or from use of -gnatdF.\n@@ -240,12 +240,12 @@ package Lib.Writ is\n    --              (upper case) of the corresponding policy name (e.g. 'F'\n    --              for FIFO_Within_Priorities).\n \n-   --         UA  Unreserve_All_Interrupts pragma was processed in one or\n-   --             more units in this file\n+   --         UA   Unreserve_All_Interrupts pragma was processed in one or\n+   --              more units in this file\n \n-   --         ZX  Units in this file use zero-cost exceptions and have\n-   --             generated exception tables. If ZX is not present, the\n-   --             longjmp/setjmp exception scheme is in use.\n+   --         ZX   Units in this file use zero-cost exceptions and have\n+   --              generated exception tables. If ZX is not present, the\n+   --              longjmp/setjmp exception scheme is in use.\n \n    --      Note that language defined units never output policy (Lx, Tx, Qx)\n    --      parameters. Language defined units must correctly handle all\n@@ -570,22 +570,22 @@ package Lib.Writ is\n    --             code is required. Set if N_Compilation_Unit node has flag\n    --             Has_No_Elaboration_Code set.\n \n-   --         OL   The units in this file are compiled with a local pragma\n-   --              Optimize_Alignment, so no consistency requirement applies\n-   --              to these units. All internal units have this status since\n-   --              they have an automatic default of Optimize_Alignment (Off).\n+   --         OL  The units in this file are compiled with a local pragma\n+   --             Optimize_Alignment, so no consistency requirement applies\n+   --             to these units. All internal units have this status since\n+   --             they have an automatic default of Optimize_Alignment (Off).\n    --\n-   --         OO   Optimize_Alignment (Off) is the default setting for all\n-   --              units in this file. All files in the partition that specify\n-   --              a default must specify the same default.\n+   --         OO  Optimize_Alignment (Off) is the default setting for all\n+   --             units in this file. All files in the partition that specify\n+   --             a default must specify the same default.\n \n-   --         OS   Optimize_Alignment (Space) is the default setting for all\n-   --              units in this file. All files in the partition that specify\n-   --              a default must specify the same default.\n+   --         OS  Optimize_Alignment (Space) is the default setting for all\n+   --             units in this file. All files in the partition that specify\n+   --             a default must specify the same default.\n \n-   --         OT   Optimize_Alignment (Time) is the default setting for all\n-   --              units in this file. All files in the partition that specify\n-   --              a default must specify the same default.\n+   --         OT  Optimize_Alignment (Time) is the default setting for all\n+   --             units in this file. All files in the partition that specify\n+   --             a default must specify the same default.\n \n    --         PF  The unit has a library-level (package) finalizer\n "}, {"sha": "8cd50af281bac9720cdfbba7e15efd4c3757e40f", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -381,7 +381,7 @@ package body SPARK_Specific is\n       Rnums : array (0 .. Nrefs + Nrefs_Add) of Nat;\n       --  This array contains numbers of references in the Xrefs table. This\n       --  list is sorted in output order. The extra 0'th entry is convenient\n-      --  for the call to sort. When we sort the table, we move the entries in\n+      --  for the call to sort. When we sort the table, we move the indices in\n       --  Rnums around, but we do not move the original table entries.\n \n       ---------------------\n@@ -683,7 +683,7 @@ package body SPARK_Specific is\n       Col        : Nat;\n       From_Index : Xref_Index;\n       Line       : Nat;\n-      Loc        : Source_Ptr;\n+      Prev_Loc   : Source_Ptr;\n       Prev_Typ   : Character;\n       Ref_Count  : Nat;\n       Ref_Id     : Entity_Id;\n@@ -701,17 +701,9 @@ package body SPARK_Specific is\n          end;\n       end loop;\n \n-      --  Set up the pointer vector for the sort\n-\n-      for Index in 1 .. Nrefs loop\n-         Rnums (Index) := Index;\n-      end loop;\n-\n       for Index in Drefs.First .. Drefs.Last loop\n          Xrefs.Append (Drefs.Table (Index));\n-\n-         Nrefs         := Nrefs + 1;\n-         Rnums (Nrefs) := Xrefs.Last;\n+         Nrefs := Nrefs + 1;\n       end loop;\n \n       --  Capture the definition Sloc values. As in the case of normal cross\n@@ -730,7 +722,7 @@ package body SPARK_Specific is\n \n       for Index in 1 .. Ref_Count loop\n          declare\n-            Ref : Xref_Key renames Xrefs.Table (Rnums (Index)).Key;\n+            Ref : Xref_Key renames Xrefs.Table (Index).Key;\n \n          begin\n             if SPARK_Entities (Ekind (Ref.Ent))\n@@ -745,7 +737,7 @@ package body SPARK_Specific is\n               and then Get_Scope_Num (Ref.Ref_Scope) /= No_Scope\n             then\n                Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (Index);\n+               Rnums (Nrefs) := Index;\n             end if;\n          end;\n       end loop;\n@@ -778,18 +770,18 @@ package body SPARK_Specific is\n \n       Ref_Count := Nrefs;\n       Nrefs     := 0;\n-      Loc       := No_Location;\n+      Prev_Loc  := No_Location;\n       Prev_Typ  := 'm';\n \n       for Index in 1 .. Ref_Count loop\n          declare\n             Ref : Xref_Key renames Xrefs.Table (Rnums (Index)).Key;\n \n          begin\n-            if Ref.Loc /= Loc\n+            if Ref.Loc /= Prev_Loc\n               or else (Prev_Typ = 'm' and then Ref.Typ = 'r')\n             then\n-               Loc           := Ref.Loc;\n+               Prev_Loc      := Ref.Loc;\n                Prev_Typ      := Ref.Typ;\n                Nrefs         := Nrefs + 1;\n                Rnums (Nrefs) := Rnums (Index);"}, {"sha": "38463ff6df0068bbe8eb1d7d97091fbc6fa0365b", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -402,7 +402,7 @@ package Sem_Attr is\n       --  fixed-point types and discrete types. For fixed-point types and\n       --  discrete types, this attribute gives the size used for default\n       --  allocation of objects and components of the size. See section in\n-      --  Einfo (\"Handling of type'Size values\") for further details.\n+      --  Einfo (\"Handling of Type'Size values\") for further details.\n \n       -------------------------\n       -- Passed_By_Reference --"}, {"sha": "c43533603bec6fa36859942a3dbd6708feef12cd", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -6372,8 +6372,7 @@ package body Sem_Ch12 is\n \n             Set_Is_Generic_Actual_Type (E, True);\n             Set_Is_Hidden (E, False);\n-            Set_Is_Potentially_Use_Visible (E,\n-              In_Use (Instance));\n+            Set_Is_Potentially_Use_Visible (E, In_Use (Instance));\n \n             --  We constructed the generic actual type as a subtype of the\n             --  supplied type. This means that it normally would not inherit"}, {"sha": "77ab254558967cb5990876bcd5d241ff785eaec6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -2466,6 +2466,8 @@ package body Sem_Ch3 is\n                Freeze_All (First_Entity (Current_Scope), Decl);\n                Freeze_From := Last_Entity (Current_Scope);\n \n+            --  Current scope is a package specification\n+\n             elsif Scope (Current_Scope) /= Standard_Standard\n               and then not Is_Child_Unit (Current_Scope)\n               and then No (Generic_Parent (Parent (L)))\n@@ -2485,6 +2487,8 @@ package body Sem_Ch3 is\n             then\n                Adjust_Decl;\n \n+               --  End of a package declaration\n+\n                --  In compilation mode the expansion of freeze node takes care\n                --  of resolving expressions of all aspects in the list. In ASIS\n                --  mode this must be done explicitly.\n@@ -2495,6 +2499,9 @@ package body Sem_Ch3 is\n                   Resolve_Aspects;\n                end if;\n \n+               --  This is a freeze point because it is the end of a\n+               --  compilation unit.\n+\n                Freeze_All (First_Entity (Current_Scope), Decl);\n                Freeze_From := Last_Entity (Current_Scope);\n \n@@ -2561,6 +2568,12 @@ package body Sem_Ch3 is\n             end if;\n \n             Adjust_Decl;\n+\n+            --  The generated body of an expression function does not freeze,\n+            --  unless it is a completion, in which case only the expression\n+            --  itself freezes. THis is handled when the body itself is\n+            --  analyzed (see Freeze_Expr_Types, sem_ch6.adb).\n+\n             Freeze_All (Freeze_From, Decl);\n             Freeze_From := Last_Entity (Current_Scope);\n          end if;\n@@ -6740,8 +6753,12 @@ package body Sem_Ch3 is\n          --  If we constructed a default range for the case where no range\n          --  was given, then the expressions in the range must not freeze\n          --  since they do not correspond to expressions in the source.\n+         --  However, if the type inherits predicates the expressions will\n+         --  be elaborated earlier and must freeze.\n \n-         if Nkind (Indic) /= N_Subtype_Indication then\n+         if Nkind (Indic) /= N_Subtype_Indication\n+           and then not Has_Predicates (Derived_Type)\n+         then\n             Set_Must_Not_Freeze (Lo);\n             Set_Must_Not_Freeze (Hi);\n             Set_Must_Not_Freeze (Rang_Expr);"}, {"sha": "baf6f2c66fca0d09725716722bf839e96cfdeb9d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -20971,48 +20971,78 @@ package body Sem_Util is\n \n    function Unique_Name (E : Entity_Id) return String is\n \n-      --  Names of E_Subprogram_Body or E_Package_Body entities are not\n+      --  Names in E_Subprogram_Body or E_Package_Body entities are not\n       --  reliable, as they may not include the overloading suffix. Instead,\n       --  when looking for the name of E or one of its enclosing scope, we get\n       --  the name of the corresponding Unique_Entity.\n \n-      function Get_Scoped_Name (E : Entity_Id) return String;\n-      --  Return the name of E prefixed by all the names of the scopes to which\n-      --  E belongs, except for Standard.\n+      U : constant Entity_Id := Unique_Entity (E);\n \n-      ---------------------\n-      -- Get_Scoped_Name --\n-      ---------------------\n+      function This_Name return String;\n+\n+      ---------------\n+      -- This_Name --\n+      ---------------\n \n-      function Get_Scoped_Name (E : Entity_Id) return String is\n-         Name : constant String := Get_Name_String (Chars (E));\n+      function This_Name return String is\n       begin\n-         if Has_Fully_Qualified_Name (E)\n-           or else Scope (E) = Standard_Standard\n-         then\n-            return Name;\n-         else\n-            return Get_Scoped_Name (Unique_Entity (Scope (E))) & \"__\" & Name;\n-         end if;\n-      end Get_Scoped_Name;\n+         return Get_Name_String (Chars (U));\n+      end This_Name;\n \n    --  Start of processing for Unique_Name\n \n    begin\n-      if E = Standard_Standard then\n-         return Get_Name_String (Name_Standard);\n-\n-      elsif Scope (E) = Standard_Standard\n-        and then not (Ekind (E) = E_Package or else Is_Subprogram (E))\n+      if E = Standard_Standard\n+        or else Has_Fully_Qualified_Name (E)\n       then\n-         return Get_Name_String (Name_Standard) & \"__\" &\n-           Get_Name_String (Chars (E));\n+         return This_Name;\n \n       elsif Ekind (E) = E_Enumeration_Literal then\n-         return Unique_Name (Etype (E)) & \"__\" & Get_Name_String (Chars (E));\n+         return Unique_Name (Etype (E)) & \"__\" & This_Name;\n \n       else\n-         return Get_Scoped_Name (Unique_Entity (E));\n+         declare\n+            S : constant Entity_Id := Scope (U);\n+            pragma Assert (Present (S));\n+\n+         begin\n+            --  Prefix names of predefined types with standard__, but leave\n+            --  names of user-defined packages and subprograms without prefix\n+            --  (even if technically they are nested in the Standard package).\n+\n+            if S = Standard_Standard then\n+               if Ekind (U) = E_Package or else Is_Subprogram (U) then\n+                  return This_Name;\n+               else\n+                  return Unique_Name (S) & \"__\" & This_Name;\n+               end if;\n+\n+            --  For intances of generic subprograms use the name of the related\n+            --  instace and skip the scope of its wrapper package.\n+\n+            elsif Is_Wrapper_Package (S) then\n+               pragma Assert (Scope (S) = Scope (Related_Instance (S)));\n+               --  Wrapper package and the instantiation are in the same scope\n+\n+               declare\n+                  Enclosing_Name : constant String :=\n+                    Unique_Name (Scope (S)) & \"__\" &\n+                      Get_Name_String (Chars (Related_Instance (S)));\n+\n+               begin\n+                  if Is_Subprogram (U)\n+                    and then not Is_Generic_Actual_Subprogram (U)\n+                  then\n+                     return Enclosing_Name;\n+                  else\n+                     return Enclosing_Name & \"__\" & This_Name;\n+                  end if;\n+               end;\n+\n+            else\n+               return Unique_Name (S) & \"__\" & This_Name;\n+            end if;\n+         end;\n       end if;\n    end Unique_Name;\n "}, {"sha": "ef521167e3753c520dd38d0cf8c5ff7465775f88", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -6895,7 +6895,7 @@ package body Sinfo is\n    function Pragma_Name (N : Node_Id) return Name_Id is\n       Result : constant Name_Id := Pragma_Name_Unmapped (N);\n    begin\n-      for J in Pragma_Map'Range loop\n+      for J in Pragma_Map'First .. Last_Pair loop\n          if Result = Pragma_Map (J).Key then\n             return Pragma_Map (J).Value;\n          end if;"}, {"sha": "52c0ef69478196b4a73120e1d8c9a0d30a7fe8d3", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -137,7 +137,7 @@ package SPARK_Xrefs is\n    --      dependency-number and filename identify a file in FD lines\n \n    --      entity-number and entity identify a scope in FS lines\n-   --      for the file previously identified file.\n+   --      for the previously identified file.\n \n    --      (filename and entity are just a textual representations of\n    --       dependency-number and entity-number)"}, {"sha": "29b6fb009bfd74eb25315ae304210781a730bea0", "filename": "gcc/ada/table.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94fa1186d071b2f4b5d864acb4b0427cb63368/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=4f94fa1186d071b2f4b5d864acb4b0427cb63368", "patch": "@@ -221,8 +221,8 @@ package Table is\n       --  Writes out contents of table using Tree_IO\n \n       procedure Tree_Read;\n-      --  Initializes table by reading contents previously written\n-      --  with the Tree_Write call (also using Tree_IO)\n+      --  Initializes table by reading contents previously written with the\n+      --  Tree_Write call (also using Tree_IO).\n \n    private\n "}]}