{"sha": "561400f0d1743235c7ba86f4de045c9885c981bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxNDAwZjBkMTc0MzIzNWM3YmE4NmY0ZGUwNDVjOTg4NWM5ODFiZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-10-22T19:15:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-10-22T19:15:02Z"}, "message": "i386.h (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES_EPILOGUES): New tuning flag.\n\n\t* i386.h (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES_EPILOGUES): New tuning flag.\n\t* x86-tune.def (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES): Define it.\n\t* i386.c (expand_small_movmem_or_setmem): New function.\n\t(expand_set_or_movmem_prologue_epilogue_by_misaligned_moves): New function\n\t(alg_usable_p): Add support for value ranges; cleanup.\n\t(ix86_expand_set_or_movmem): Add support for misaligned moves.\n\nFrom-SVN: r203937", "tree": {"sha": "2ff07e1ea7e5a59d8fc9f84cffe3c295cb3b2841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ff07e1ea7e5a59d8fc9f84cffe3c295cb3b2841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561400f0d1743235c7ba86f4de045c9885c981bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561400f0d1743235c7ba86f4de045c9885c981bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561400f0d1743235c7ba86f4de045c9885c981bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561400f0d1743235c7ba86f4de045c9885c981bf/comments", "author": null, "committer": null, "parents": [{"sha": "7a1dd0fab3c8bf87e3c40bc5f281968010b5465f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1dd0fab3c8bf87e3c40bc5f281968010b5465f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1dd0fab3c8bf87e3c40bc5f281968010b5465f"}], "stats": {"total": 582, "additions": 512, "deletions": 70}, "files": [{"sha": "020231a067de89e9a6b8f92495ccddf75f2027be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561400f0d1743235c7ba86f4de045c9885c981bf", "patch": "@@ -1,3 +1,12 @@\n+2013-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES_EPILOGUES): New tuning flag.\n+\t* x86-tune.def (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES): Define it.\n+\t* i386.c (expand_small_movmem_or_setmem): New function.\n+\t(expand_set_or_movmem_prologue_epilogue_by_misaligned_moves): New function\n+\t(alg_usable_p): Add support for value ranges; cleanup.\n+\t(ix86_expand_set_or_movmem): Add support for misaligned moves.\n+\n 2013-10-22  Sterling Augustine  <saugustine@google.com>\n \n \t* doc/invoke.texi: Document -ggnu-pubnames."}, {"sha": "22341eeca6ceeca76797e8dc5e0909dec7198c0d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 492, "deletions": 70, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=561400f0d1743235c7ba86f4de045c9885c981bf", "patch": "@@ -22731,6 +22731,315 @@ expand_set_or_movmem_prologue (rtx destmem, rtx srcmem,\n   return destmem;\n }\n \n+/* Test if COUNT&SIZE is nonzero and if so, expand movme\n+   or setmem sequence that is valid for SIZE..2*SIZE-1 bytes\n+   and jump to DONE_LABEL.  */\n+static void\n+expand_small_movmem_or_setmem (rtx destmem, rtx srcmem,\n+\t\t\t       rtx destptr, rtx srcptr,\n+\t\t\t       rtx value, rtx vec_value,\n+\t\t\t       rtx count, int size,\n+\t\t\t       rtx done_label, bool issetmem)\n+{\n+  rtx label = ix86_expand_aligntest (count, size, false);\n+  enum machine_mode mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 1);\n+  rtx modesize;\n+  int n;\n+\n+  /* If we do not have vector value to copy, we must reduce size.  */\n+  if (issetmem)\n+    {\n+      if (!vec_value)\n+\t{\n+\t  if (GET_MODE (value) == VOIDmode && size > 8)\n+\t    mode = Pmode;\n+\t  else if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (value)))\n+\t    mode = GET_MODE (value);\n+\t}\n+      else\n+\tmode = GET_MODE (vec_value), value = vec_value;\n+    }\n+  else\n+    {\n+      /* Choose appropriate vector mode.  */\n+      if (size >= 32)\n+\tmode = TARGET_AVX ? V32QImode : TARGET_SSE ? V16QImode : DImode;\n+      else if (size >= 16)\n+\tmode = TARGET_SSE ? V16QImode : DImode;\n+      srcmem = change_address (srcmem, mode, srcptr);\n+    }\n+  destmem = change_address (destmem, mode, destptr);\n+  modesize = GEN_INT (GET_MODE_SIZE (mode));\n+  gcc_assert (GET_MODE_SIZE (mode) <= size);\n+  for (n = 0; n * GET_MODE_SIZE (mode) < size; n++)\n+    {\n+      if (issetmem)\n+\temit_move_insn (destmem, gen_lowpart (mode, value));\n+      else\n+\t{\n+          emit_move_insn (destmem, srcmem);\n+          srcmem = offset_address (srcmem, modesize, GET_MODE_SIZE (mode));\n+\t}\n+      destmem = offset_address (destmem, modesize, GET_MODE_SIZE (mode));\n+    }\n+\n+  destmem = offset_address (destmem, count, 1);\n+  destmem = offset_address (destmem, GEN_INT (-size - GET_MODE_SIZE (mode)),\n+\t\t\t    GET_MODE_SIZE (mode));\n+  if (issetmem)\n+    emit_move_insn (destmem, gen_lowpart (mode, value));\n+  else\n+    {\n+      srcmem = offset_address (srcmem, count, 1);\n+      srcmem = offset_address (srcmem, GEN_INT (-size - GET_MODE_SIZE (mode)),\n+\t\t\t       GET_MODE_SIZE (mode));\n+      emit_move_insn (destmem, srcmem);\n+    }\n+  emit_jump_insn (gen_jump (done_label));\n+  emit_barrier ();\n+\n+  emit_label (label);\n+  LABEL_NUSES (label) = 1;\n+}\n+\n+/* Handle small memcpy (up to SIZE that is supposed to be small power of 2.\n+   and get ready for the main memcpy loop by copying iniital DESIRED_ALIGN-ALIGN\n+   bytes and last SIZE bytes adjusitng DESTPTR/SRCPTR/COUNT in a way we can\n+   proceed with an loop copying SIZE bytes at once. Do moves in MODE.\n+   DONE_LABEL is a label after the whole copying sequence. The label is created\n+   on demand if *DONE_LABEL is NULL.\n+   MIN_SIZE is minimal size of block copied.  This value gets adjusted for new\n+   bounds after the initial copies. \n+\n+   DESTMEM/SRCMEM are memory expressions pointing to the copies block,\n+   DESTPTR/SRCPTR are pointers to the block. DYNAMIC_CHECK indicate whether\n+   we will dispatch to a library call for large blocks.\n+\n+   In pseudocode we do:\n+\n+   if (COUNT < SIZE)\n+     {\n+       Assume that SIZE is 4. Bigger sizes are handled analogously\n+       if (COUNT & 4)\n+\t {\n+\t    copy 4 bytes from SRCPTR to DESTPTR\n+\t    copy 4 bytes from SRCPTR + COUNT - 4 to DESTPTR + COUNT - 4\n+\t    goto done_label\n+\t }\n+       if (!COUNT)\n+\t goto done_label;\n+       copy 1 byte from SRCPTR to DESTPTR\n+       if (COUNT & 2)\n+\t {\n+\t    copy 2 bytes from SRCPTR to DESTPTR\n+\t    copy 2 bytes from SRCPTR + COUNT - 2 to DESTPTR + COUNT - 2\n+\t }\n+     }\n+   else\n+     {\n+       copy at least DESIRED_ALIGN-ALIGN bytes from SRCPTR to DESTPTR\n+       copy SIZE bytes from SRCPTR + COUNT - SIZE to DESTPTR + COUNT -SIZE\n+\n+       OLD_DESPTR = DESTPTR;\n+       Align DESTPTR up to DESIRED_ALIGN\n+       SRCPTR += DESTPTR - OLD_DESTPTR\n+       COUNT -= DEST_PTR - OLD_DESTPTR\n+       if (DYNAMIC_CHECK)\n+\t Round COUNT down to multiple of SIZE\n+       << optional caller supplied zero size guard is here >>\n+       << optional caller suppplied dynamic check is here >>\n+       << caller supplied main copy loop is here >>\n+     }\n+   done_label:\n+  */\n+static void\n+expand_set_or_movmem_prologue_epilogue_by_misaligned_moves (rtx destmem, rtx srcmem,\n+\t\t\t\t\t\t\t    rtx *destptr, rtx *srcptr,\n+\t\t\t\t\t\t\t    enum machine_mode mode,\n+\t\t\t\t\t\t\t    rtx value, rtx vec_value,\n+\t\t\t\t\t\t\t    rtx *count,\n+\t\t\t\t\t\t\t    rtx *done_label,\n+\t\t\t\t\t\t\t    int size,\n+\t\t\t\t\t\t\t    int desired_align,\n+\t\t\t\t\t\t\t    int align,\n+\t\t\t\t\t\t\t    unsigned HOST_WIDE_INT *min_size,\n+\t\t\t\t\t\t\t    bool dynamic_check,\n+\t\t\t\t\t\t\t    bool issetmem)\n+{\n+  rtx loop_label = NULL, label;\n+  int n;\n+  rtx modesize;\n+  int prolog_size = 0;\n+  rtx mode_value;\n+\n+  /* Chose proper value to copy.  */\n+  if (issetmem && VECTOR_MODE_P (mode))\n+    mode_value = vec_value;\n+  else\n+    mode_value = value;\n+  gcc_assert (GET_MODE_SIZE (mode) <= size);\n+\n+  /* See if block is big or small, handle small blocks.  */\n+  if (!CONST_INT_P (*count) && *min_size < (unsigned HOST_WIDE_INT)size)\n+    {\n+      int size2 = size;\n+      loop_label = gen_label_rtx ();\n+\n+      if (!*done_label)\n+\t*done_label = gen_label_rtx ();\n+\n+      emit_cmp_and_jump_insns (*count, GEN_INT (size2), GE, 0, GET_MODE (*count),\n+\t\t\t       1, loop_label);\n+      size2 >>= 1;\n+\n+      /* Handle sizes > 3.  */\n+      for (;size2 > 2; size2 >>= 1)\n+\texpand_small_movmem_or_setmem (destmem, srcmem,\n+\t\t\t\t       *destptr, *srcptr,\n+\t\t\t\t       value, vec_value,\n+\t\t\t\t       *count,\n+\t\t\t\t       size2, *done_label, issetmem);\n+      /* Nothing to copy?  Jump to DONE_LABEL if so */\n+      emit_cmp_and_jump_insns (*count, const0_rtx, EQ, 0, GET_MODE (*count),\n+\t\t\t       1, *done_label);\n+\n+      /* Do a byte copy.  */\n+      destmem = change_address (destmem, QImode, *destptr);\n+      if (issetmem)\n+\temit_move_insn (destmem, gen_lowpart (QImode, value));\n+      else\n+\t{\n+          srcmem = change_address (srcmem, QImode, *srcptr);\n+          emit_move_insn (destmem, srcmem);\n+\t}\n+\n+      /* Handle sizes 2 and 3.  */\n+      label = ix86_expand_aligntest (*count, 2, false);\n+      destmem = change_address (destmem, HImode, *destptr);\n+      destmem = offset_address (destmem, *count, 1);\n+      destmem = offset_address (destmem, GEN_INT (-2), 2);\n+      if (issetmem)\n+        emit_move_insn (destmem, gen_lowpart (HImode, value));\n+      else\n+\t{\n+\t  srcmem = change_address (srcmem, HImode, *srcptr);\n+\t  srcmem = offset_address (srcmem, *count, 1);\n+\t  srcmem = offset_address (srcmem, GEN_INT (-2), 2);\n+\t  emit_move_insn (destmem, srcmem);\n+\t}\n+\n+      emit_label (label);\n+      LABEL_NUSES (label) = 1;\n+      emit_jump_insn (gen_jump (*done_label));\n+      emit_barrier ();\n+    }\n+  else\n+    gcc_assert (*min_size >= (unsigned HOST_WIDE_INT)size\n+\t\t|| UINTVAL (*count) >= (unsigned HOST_WIDE_INT)size);\n+\n+  /* Start memcpy for COUNT >= SIZE.  */\n+  if (loop_label)\n+    {\n+       emit_label (loop_label);\n+       LABEL_NUSES (loop_label) = 1;\n+    }\n+\n+  /* Copy first desired_align bytes.  */\n+  if (!issetmem)\n+    srcmem = change_address (srcmem, mode, *srcptr);\n+  destmem = change_address (destmem, mode, *destptr);\n+  modesize = GEN_INT (GET_MODE_SIZE (mode));\n+  for (n = 0; prolog_size < desired_align - align; n++)\n+    {\n+      if (issetmem)\n+        emit_move_insn (destmem, mode_value);\n+      else\n+\t{\n+          emit_move_insn (destmem, srcmem);\n+          srcmem = offset_address (srcmem, modesize, GET_MODE_SIZE (mode));\n+\t}\n+      destmem = offset_address (destmem, modesize, GET_MODE_SIZE (mode));\n+      prolog_size += GET_MODE_SIZE (mode);\n+    }\n+\n+\n+  /* Copy last SIZE bytes.  */\n+  destmem = offset_address (destmem, *count, 1);\n+  destmem = offset_address (destmem,\n+\t\t\t    GEN_INT (-size - prolog_size),\n+\t\t\t    1);\n+  if (issetmem)\n+    emit_move_insn (destmem, mode_value);\n+  else\n+    {\n+      srcmem = offset_address (srcmem, *count, 1);\n+      srcmem = offset_address (srcmem,\n+\t\t\t       GEN_INT (-size - prolog_size),\n+\t\t\t       1);\n+      emit_move_insn (destmem, srcmem);\n+    }\n+  for (n = 1; n * GET_MODE_SIZE (mode) < size; n++)\n+    {\n+      destmem = offset_address (destmem, modesize, 1);\n+      if (issetmem)\n+\temit_move_insn (destmem, mode_value);\n+      else\n+\t{\n+          srcmem = offset_address (srcmem, modesize, 1);\n+          emit_move_insn (destmem, srcmem);\n+\t}\n+    }\n+\n+  /* Align destination.  */\n+  if (desired_align > 1 && desired_align > align)\n+    {\n+      rtx saveddest = *destptr;\n+\n+      gcc_assert (desired_align <= size);\n+      /* Align destptr up, place it to new register.  */\n+      *destptr = expand_simple_binop (GET_MODE (*destptr), PLUS, *destptr,\n+\t\t\t\t      GEN_INT (prolog_size),\n+\t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+      *destptr = expand_simple_binop (GET_MODE (*destptr), AND, *destptr,\n+\t\t\t\t      GEN_INT (-desired_align),\n+\t\t\t\t      *destptr, 1, OPTAB_DIRECT);\n+      /* See how many bytes we skipped.  */\n+      saveddest = expand_simple_binop (GET_MODE (*destptr), MINUS, saveddest,\n+\t\t\t\t       *destptr,\n+\t\t\t\t       saveddest, 1, OPTAB_DIRECT);\n+      /* Adjust srcptr and count.  */\n+      if (!issetmem)\n+\t*srcptr = expand_simple_binop (GET_MODE (*srcptr), MINUS, *srcptr, saveddest,\n+\t\t\t\t\t*srcptr, 1, OPTAB_DIRECT);\n+      *count = expand_simple_binop (GET_MODE (*count), PLUS, *count,\n+\t\t\t\t    saveddest, *count, 1, OPTAB_DIRECT);\n+      /* We copied at most size + prolog_size.  */\n+      if (*min_size > (unsigned HOST_WIDE_INT)(size + prolog_size))\n+\t*min_size = (*min_size - size) & ~(unsigned HOST_WIDE_INT)(size - 1);\n+      else\n+\t*min_size = 0;\n+\n+      /* Our loops always round down the bock size, but for dispatch to library\n+\t we need precise value.  */\n+      if (dynamic_check)\n+\t*count = expand_simple_binop (GET_MODE (*count), AND, *count,\n+\t\t\t\t      GEN_INT (-size), *count, 1, OPTAB_DIRECT);\n+    }\n+  else\n+    {\n+      gcc_assert (prolog_size == 0);\n+      /* Decrease count, so we won't end up copying last word twice.  */\n+      if (!CONST_INT_P (*count))\n+\t*count = expand_simple_binop (GET_MODE (*count), PLUS, *count,\n+\t\t\t\t      constm1_rtx, *count, 1, OPTAB_DIRECT);\n+      else\n+\t*count = GEN_INT ((UINTVAL (*count) - 1) & ~(unsigned HOST_WIDE_INT)(size - 1));\n+      if (*min_size)\n+\t*min_size = (*min_size - 1) & ~(unsigned HOST_WIDE_INT)(size - 1);\n+    }\n+}\n+\n+\n /* This function is like the previous one, except here we know how many bytes\n    need to be copied.  That allows us to update alignment not only of DST, which\n    is returned, but also of SRC, which is passed as a pointer for that\n@@ -22805,62 +23114,99 @@ expand_set_or_movmem_constant_prologue (rtx dst, rtx *srcp, rtx destreg,\n   return dst;\n }\n \n-/* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n-static enum stringop_alg\n-decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n-\t    int *dynamic_check, bool *noalign)\n+/* Return true if ALG can be used in current context.  \n+   Assume we expand memset if MEMSET is true.  */\n+static bool\n+alg_usable_p (enum stringop_alg alg, bool memset)\n {\n-  const struct stringop_algs * algs;\n-  bool optimize_for_speed;\n+  if (alg == no_stringop)\n+    return false;\n+  if (alg == vector_loop)\n+    return TARGET_SSE || TARGET_AVX;\n   /* Algorithms using the rep prefix want at least edi and ecx;\n      additionally, memset wants eax and memcpy wants esi.  Don't\n      consider such algorithms if the user has appropriated those\n      registers for their own purposes.\t*/\n-  bool rep_prefix_usable = !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n-                             || (memset\n-\t\t\t\t ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n-  *noalign = false;\n+  if (alg == rep_prefix_1_byte\n+      || alg == rep_prefix_4_byte\n+      || alg == rep_prefix_8_byte)\n+    return !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n+             || (memset ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n+  return true;\n+}\n \n-#define ALG_USABLE_P(alg) (rep_prefix_usable\t\t\t\\\n-\t\t\t   || (alg != rep_prefix_1_byte\t\t\\\n-\t\t\t       && alg != rep_prefix_4_byte      \\\n-\t\t\t       && alg != rep_prefix_8_byte))\n+/* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n+static enum stringop_alg\n+decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n+\t    unsigned HOST_WIDE_INT min_size, unsigned HOST_WIDE_INT max_size,\n+\t    bool memset, bool zero_memset, int *dynamic_check, bool *noalign)\n+{\n+  const struct stringop_algs * algs;\n+  bool optimize_for_speed;\n+  int max = -1;\n   const struct processor_costs *cost;\n+  int i;\n+  bool any_alg_usable_p = false;\n+\n+  *noalign = false;\n+  *dynamic_check = -1;\n \n   /* Even if the string operation call is cold, we still might spend a lot\n      of time processing large blocks.  */\n   if (optimize_function_for_size_p (cfun)\n       || (optimize_insn_for_size_p ()\n-          && expected_size != -1 && expected_size < 256))\n+ \t  && (max_size < 256\n+              || (expected_size != -1 && expected_size < 256))))\n     optimize_for_speed = false;\n   else\n     optimize_for_speed = true;\n \n   cost = optimize_for_speed ? ix86_cost : &ix86_size_cost;\n-\n-  *dynamic_check = -1;\n   if (memset)\n     algs = &cost->memset[TARGET_64BIT != 0];\n   else\n     algs = &cost->memcpy[TARGET_64BIT != 0];\n-  if (ix86_stringop_alg != no_stringop && ALG_USABLE_P (ix86_stringop_alg))\n+\n+  /* See maximal size for user defined algorithm.  */\n+  for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n+    {\n+      enum stringop_alg candidate = algs->size[i].alg;\n+      bool usable = alg_usable_p (candidate, memset);\n+      any_alg_usable_p |= usable;\n+\n+      if (candidate != libcall && candidate && usable)\n+\t  max = algs->size[i].max;\n+    }\n+\n+  /* If expected size is not known but max size is small enough\n+     so inline version is a win, set expected size into\n+     the range.  */\n+  if (max > 1 && (unsigned HOST_WIDE_INT)max >= max_size && expected_size == -1)\n+    expected_size = min_size / 2 + max_size / 2;\n+\n+  /* If user specified the algorithm, honnor it if possible.  */\n+  if (ix86_stringop_alg != no_stringop\n+      && alg_usable_p (ix86_stringop_alg, memset))\n     return ix86_stringop_alg;\n   /* rep; movq or rep; movl is the smallest variant.  */\n   else if (!optimize_for_speed)\n     {\n-      if (!count || (count & 3))\n-\treturn rep_prefix_usable ? rep_prefix_1_byte : loop_1_byte;\n+      *noalign = true;\n+      if (!count || (count & 3) || (memset && !zero_memset))\n+\treturn alg_usable_p (rep_prefix_1_byte, memset)\n+\t       ? rep_prefix_1_byte : loop_1_byte;\n       else\n-\treturn rep_prefix_usable ? rep_prefix_4_byte : loop;\n+\treturn alg_usable_p (rep_prefix_4_byte, memset)\n+\t       ? rep_prefix_4_byte : loop;\n     }\n-  /* Very tiny blocks are best handled via the loop, REP is expensive to setup.\n-   */\n+  /* Very tiny blocks are best handled via the loop, REP is expensive to\n+     setup.  */\n   else if (expected_size != -1 && expected_size < 4)\n     return loop_1_byte;\n   else if (expected_size != -1)\n     {\n-      unsigned int i;\n       enum stringop_alg alg = libcall;\n+      bool alg_noalign = false;\n       for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n \t{\n \t  /* We get here if the algorithms that were not libcall-based\n@@ -22873,8 +23219,11 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t    {\n \t      enum stringop_alg candidate = algs->size[i].alg;\n \n-\t      if (candidate != libcall && ALG_USABLE_P (candidate))\n-\t\talg = candidate;\n+\t      if (candidate != libcall && alg_usable_p (candidate, memset))\n+\t\t{\n+\t\t  alg = candidate;\n+\t\t  alg_noalign = algs->size[i].noalign;\n+\t\t}\n \t      /* Honor TARGET_INLINE_ALL_STRINGOPS by picking\n \t\t last non-libcall inline algorithm.  */\n \t      if (TARGET_INLINE_ALL_STRINGOPS)\n@@ -22883,17 +23232,19 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t\t     but we are still forced to inline, run the heuristic below\n \t\t     that will pick code for medium sized blocks.  */\n \t\t  if (alg != libcall)\n-\t\t    return alg;\n+\t\t    {\n+\t\t      *noalign = alg_noalign;\n+\t\t      return alg;\n+\t\t    }\n \t\t  break;\n \t\t}\n-\t      else if (ALG_USABLE_P (candidate))\n+\t      else if (alg_usable_p (candidate, memset))\n \t\t{\n \t\t  *noalign = algs->size[i].noalign;\n \t\t  return candidate;\n \t\t}\n \t    }\n \t}\n-      gcc_assert (TARGET_INLINE_ALL_STRINGOPS || !rep_prefix_usable);\n     }\n   /* When asked to inline the call anyway, try to pick meaningful choice.\n      We look for maximal size of block that is faster to copy by hand and\n@@ -22903,22 +23254,11 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n      If this turns out to be bad, we might simply specify the preferred\n      choice in ix86_costs.  */\n   if ((TARGET_INLINE_ALL_STRINGOPS || TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n-      && (algs->unknown_size == libcall || !ALG_USABLE_P (algs->unknown_size)))\n+      && (algs->unknown_size == libcall\n+\t  || !alg_usable_p (algs->unknown_size, memset)))\n     {\n-      int max = -1;\n       enum stringop_alg alg;\n-      int i;\n-      bool any_alg_usable_p = true;\n \n-      for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n-        {\n-          enum stringop_alg candidate = algs->size[i].alg;\n-          any_alg_usable_p = any_alg_usable_p && ALG_USABLE_P (candidate);\n-\n-          if (candidate != libcall && candidate\n-              && ALG_USABLE_P (candidate))\n-              max = algs->size[i].max;\n-        }\n       /* If there aren't any usable algorithms, then recursing on\n          smaller sizes isn't going to find anything.  Just return the\n          simple byte-at-a-time copy loop.  */\n@@ -22931,15 +23271,16 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n         }\n       if (max == -1)\n \tmax = 4096;\n-      alg = decide_alg (count, max / 2, memset, dynamic_check, noalign);\n+      alg = decide_alg (count, max / 2, min_size, max_size, memset,\n+\t\t\tzero_memset, dynamic_check, noalign);\n       gcc_assert (*dynamic_check == -1);\n       gcc_assert (alg != libcall);\n       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n \t*dynamic_check = max;\n       return alg;\n     }\n-  return ALG_USABLE_P (algs->unknown_size) ? algs->unknown_size : libcall;\n-#undef ALG_USABLE_P\n+  return (alg_usable_p (algs->unknown_size, memset)\n+\t  ? algs->unknown_size : libcall);\n }\n \n /* Decide on alignment.  We know that the operand is already aligned to ALIGN\n@@ -23073,27 +23414,46 @@ promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align,\n \n /* Expand string move (memcpy) ot store (memset) operation.  Use i386 string\n    operations when profitable.  The code depends upon architecture, block size\n-   and alignment, but always has the same overall structure:\n+   and alignment, but always has one of the following overall structures:\n+\n+   Aligned move sequence:\n+\n+     1) Prologue guard: Conditional that jumps up to epilogues for small\n+\tblocks that can be handled by epilogue alone.  This is faster\n+\tbut also needed for correctness, since prologue assume the block\n+\tis larger than the desired alignment.\n+\n+\tOptional dynamic check for size and libcall for large\n+\tblocks is emitted here too, with -minline-stringops-dynamically.\n+\n+     2) Prologue: copy first few bytes in order to get destination\n+\taligned to DESIRED_ALIGN.  It is emitted only when ALIGN is less\n+\tthan DESIRED_ALIGN and up to DESIRED_ALIGN - ALIGN bytes can be\n+\tcopied.  We emit either a jump tree on power of two sized\n+\tblocks, or a byte loop.\n+\n+     3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n+\twith specified algorithm.\n \n-   1) Prologue guard: Conditional that jumps up to epilogues for small\n-      blocks that can be handled by epilogue alone.  This is faster\n-      but also needed for correctness, since prologue assume the block\n-      is larger than the desired alignment.\n+     4) Epilogue: code copying tail of the block that is too small to be\n+\thandled by main body (or up to size guarded by prologue guard). \n \n-      Optional dynamic check for size and libcall for large\n-      blocks is emitted here too, with -minline-stringops-dynamically.\n+  Misaligned move sequence\n \n-   2) Prologue: copy/set first few bytes in order to get destination\n-      aligned to DESIRED_ALIGN.  It is emitted only when ALIGN is less\n-      than DESIRED_ALIGN and up to DESIRED_ALIGN - ALIGN bytes can be\n-      copied/set.  We emit either a jump tree on power of two sized\n-      blocks, or a byte loop.\n+     1) missaligned move prologue/epilogue containing:\n+        a) Prologue handling small memory blocks and jumping to done_label\n+\t   (skipped if blocks are known to be large enough)\n+\tb) Signle move copying first DESIRED_ALIGN-ALIGN bytes if alignment is\n+           needed by single possibly misaligned move\n+\t   (skipped if alignment is not needed)\n+        c) Copy of last SIZE_NEEDED bytes by possibly misaligned moves\n \n-   3) Main body: the copying/storing loop itself, copying/storing in SIZE_NEEDED\n-      chunks with specified algorithm.\n+     2) Zero size guard dispatching to done_label, if needed\n \n-   4) Epilogue: code copying/storing tail of the block that is too small to be\n-      handled by main body (or up to size guarded by prologue guard).  */\n+     3) dispatch to library call, if needed,\n+\n+     3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n+\twith specified algorithm.  */\n static bool\n ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t      rtx align_exp, rtx expected_align_exp,\n@@ -23118,6 +23478,10 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   bool noalign;\n   enum machine_mode move_mode = VOIDmode;\n   int unroll_factor = 1;\n+  /* TODO: Once vlaue ranges are available, fill in proper data.  */\n+  unsigned HOST_WIDE_INT min_size = 0;\n+  unsigned HOST_WIDE_INT max_size = -1;\n+  bool misaligned_prologue_used = false;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -23132,7 +23496,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n     align = MEM_ALIGN (dst) / BITS_PER_UNIT;\n \n   if (CONST_INT_P (count_exp))\n-    count = expected_size = INTVAL (count_exp);\n+    min_size = max_size = count = expected_size = INTVAL (count_exp);\n   if (CONST_INT_P (expected_size_exp) && count == 0)\n     expected_size = INTVAL (expected_size_exp);\n \n@@ -23142,7 +23506,9 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n-  alg = decide_alg (count, expected_size, issetmem, &dynamic_check, &noalign);\n+  alg = decide_alg (count, expected_size, min_size, max_size, issetmem,\n+\t\t    issetmem && val_exp == const0_rtx,\n+\t\t    &dynamic_check, &noalign);\n   if (alg == libcall)\n     return false;\n   gcc_assert (alg != no_stringop);\n@@ -23234,10 +23600,20 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n     }\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n+  /* Misaligned move sequences handles both prologues and epilogues at once.\n+     Default code generation results in smaller code for large alignments and\n+     also avoids redundant job when sizes are known precisely.  */\n+  misaligned_prologue_used = (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES\n+\t\t\t      && MAX (desired_align, epilogue_size_needed) <= 32\n+\t\t\t      && ((desired_align > align && !align_bytes)\n+\t\t\t\t  || (!count && epilogue_size_needed > 1)));\n+\n   /* Do the cheap promotion to allow better CSE across the\n      main loop and epilogue (ie one load of the big constant in the\n-     front of all code.  */\n-  if (issetmem && CONST_INT_P (val_exp))\n+     front of all code.  \n+     For now the misaligned move sequences do not have fast path\n+     without broadcasting.  */\n+  if (issetmem && ((CONST_INT_P (val_exp) || misaligned_prologue_used)))\n     {\n       if (alg == vector_loop)\n \t{\n@@ -23253,8 +23629,45 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t\t\t\t\t desired_align, align);\n \t}\n     }\n+  /* Misaligned move sequences handles both prologues and epilogues at once.\n+     Default code generation results in smaller code for large alignments and\n+     also avoids redundant job when sizes are known precisely.  */\n+  if (misaligned_prologue_used)\n+    {\n+      /* Misaligned move prologue handled small blocks by itself.  */\n+      misaligned_prologue_used = true;\n+      expand_set_or_movmem_prologue_epilogue_by_misaligned_moves\n+\t   (dst, src, &destreg, &srcreg,\n+\t    move_mode, promoted_val, vec_promoted_val,\n+\t    &count_exp,\n+\t    &jump_around_label,\n+            desired_align < align\n+\t    ? MAX (desired_align, epilogue_size_needed) : epilogue_size_needed,\n+\t    desired_align, align, &min_size, dynamic_check, issetmem);\n+      if (!issetmem)\n+        src = change_address (src, BLKmode, srcreg);\n+      dst = change_address (dst, BLKmode, destreg);\n+      set_mem_align (dst, desired_align * BITS_PER_UNIT);\n+      epilogue_size_needed = 0;\n+      if (need_zero_guard && !min_size)\n+\t{\n+\t  /* It is possible that we copied enough so the main loop will not\n+\t     execute.  */\n+\t  gcc_assert (size_needed > 1);\n+\t  if (jump_around_label == NULL_RTX)\n+\t    jump_around_label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (count_exp,\n+\t\t\t\t   GEN_INT (size_needed),\n+\t\t\t\t   LTU, 0, counter_mode (count_exp), 1, jump_around_label);\n+\t  if (expected_size == -1\n+\t      || expected_size < (desired_align - align) / 2 + size_needed)\n+\t    predict_jump (REG_BR_PROB_BASE * 20 / 100);\n+\t  else\n+\t    predict_jump (REG_BR_PROB_BASE * 60 / 100);\n+\t}\n+    }\n   /* Ensure that alignment prologue won't copy past end of block.  */\n-  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n+  else if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n     {\n       epilogue_size_needed = MAX (size_needed - 1, desired_align - align);\n       /* Epilogue always copies COUNT_EXP & EPILOGUE_SIZE_NEEDED bytes.\n@@ -23279,8 +23692,9 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\tgoto epilogue;\n \t    }\n \t}\n-      else\n+      else if (min_size < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n \t{\n+\t  gcc_assert (max_size >= (unsigned HOST_WIDE_INT)epilogue_size_needed);\n \t  label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (epilogue_size_needed),\n@@ -23327,11 +23741,11 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n     promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n \t\t\t\t\t\t   desired_align, align);\n \n-  if (desired_align > align)\n+  if (desired_align > align && !misaligned_prologue_used)\n     {\n       if (align_bytes == 0)\n \t{\n-\t  /* Except for the first move in epilogue, we no longer know\n+\t  /* Except for the first move in prologue, we no longer know\n \t     constant offset in aliasing info.  It don't seems to worth\n \t     the pain to maintain it for the first move, so throw away\n \t     the info early.  */\n@@ -23342,6 +23756,11 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t\t\t    promoted_val, vec_promoted_val,\n \t\t\t\t\t    count_exp, align, desired_align,\n \t\t\t\t\t    issetmem);\n+\t  /* At most desired_align - align bytes are copied.  */\n+\t  if (min_size < (unsigned)(desired_align - align))\n+\t    min_size = 0;\n+\t  else\n+\t    min_size -= desired_align - align;\n \t}\n       else\n \t{\n@@ -23358,8 +23777,11 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t  count_exp = plus_constant (counter_mode (count_exp),\n \t\t\t\t     count_exp, -align_bytes);\n \t  count -= align_bytes;\n+\t  min_size -= align_bytes;\n+\t  max_size -= align_bytes;\n \t}\n       if (need_zero_guard\n+\t  && !min_size\n \t  && (count < (unsigned HOST_WIDE_INT) size_needed\n \t      || (align_bytes == 0\n \t\t  && count < ((unsigned HOST_WIDE_INT) size_needed\n@@ -23389,7 +23811,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n       if (issetmem)\n \tpromoted_val = val_exp;\n     }\n-  else if (label == NULL_RTX)\n+  else if (label == NULL_RTX && !misaligned_prologue_used)\n     epilogue_size_needed = size_needed;\n \n   /* Step 3: Main loop.  */"}, {"sha": "5267042260633ee13705a088b7964626db260106", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=561400f0d1743235c7ba86f4de045c9885c981bf", "patch": "@@ -350,6 +350,8 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n #define TARGET_PROMOTE_QImode\tix86_tune_features[X86_TUNE_PROMOTE_QIMODE]\n #define TARGET_FAST_PREFIX\tix86_tune_features[X86_TUNE_FAST_PREFIX]\n #define TARGET_SINGLE_STRINGOP\tix86_tune_features[X86_TUNE_SINGLE_STRINGOP]\n+#define TARGET_MISALIGNED_MOVE_STRING_PROLOGUES_EPILOGUES \\\n+\tix86_tune_features[TARGET_MISALIGNED_MOVE_STRING_PROLOGUES]\n #define TARGET_QIMODE_MATH\tix86_tune_features[X86_TUNE_QIMODE_MATH]\n #define TARGET_HIMODE_MATH\tix86_tune_features[X86_TUNE_HIMODE_MATH]\n #define TARGET_PROMOTE_QI_REGS\tix86_tune_features[X86_TUNE_PROMOTE_QI_REGS]"}, {"sha": "6e5d2fe0affc155db51d31903c3bebc7b27f9f1a", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561400f0d1743235c7ba86f4de045c9885c981bf/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=561400f0d1743235c7ba86f4de045c9885c981bf", "patch": "@@ -239,6 +239,15 @@ DEF_TUNE (X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE, \"avoid_mem_opnd_for_cmove\",\n    as MOVS and STOS (without a REP prefix) to move/set sequences of bytes.  */\n DEF_TUNE (X86_TUNE_SINGLE_STRINGOP, \"single_stringop\", m_386 | m_P4_NOCONA)\n \n+/* TARGET_MISALIGNED_MOVE_STRING_PROLOGUES: Enable generation of compace\n+   prologues and epilogues by issuing a misaligned moves.  This require\n+   target to handle misaligned moves and partial memory stalls resonably\n+   well.  \n+   FIXME: This actualy may be a win on more targets than listed here.  */\n+DEF_TUNE (TARGET_MISALIGNED_MOVE_STRING_PROLOGUES,\n+\t  \"misaligned_move_string_prologues\",\n+\t  m_386 | m_486 | m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC)\n+\n /* X86_TUNE_USE_SAHF: Controls use of SAHF.  */\n DEF_TUNE (X86_TUNE_USE_SAHF, \"use_sahf\",\n           m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_K6_GEODE"}]}