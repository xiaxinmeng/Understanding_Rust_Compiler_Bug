{"sha": "8046c604274b3c68eadf882f30b5642ad3b86a3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0NmM2MDQyNzRiM2M2OGVhZGY4ODJmMzBiNTY0MmFkM2I4NmEzYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2012-07-23T19:03:48Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-07-23T19:03:48Z"}, "message": "i386-protos.c (ix86_lea_outperforms): Remove prototype.\n\n\t* config/i386/i386-protos.c (ix86_lea_outperforms): Remove prototype.\n\t* config/i386/i386.c (ix86_lea_outperforms): Make static.  Make\n\tsplit_cost argument signed.\n\t(ix86_avoid_lea_for_add): Cleanup.\n\t(ix86_use_lea_for_mov): Use INVALID_REGNUM instead of -1.\n\t(ix86_avoid_lea_for_addr): Ditto.  Make split_cost signed.\n\tUse gen_lowpart instead of gen_rtx_SUBREG.  Cleanup.\n\nFrom-SVN: r189792", "tree": {"sha": "5709a9db92f15c40adba12ff9c036fdb14f54bdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5709a9db92f15c40adba12ff9c036fdb14f54bdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8046c604274b3c68eadf882f30b5642ad3b86a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8046c604274b3c68eadf882f30b5642ad3b86a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8046c604274b3c68eadf882f30b5642ad3b86a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8046c604274b3c68eadf882f30b5642ad3b86a3c/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7839a79c96c4568ad8cb933b83a9176e4a7315fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7839a79c96c4568ad8cb933b83a9176e4a7315fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7839a79c96c4568ad8cb933b83a9176e4a7315fa"}], "stats": {"total": 79, "additions": 48, "deletions": 31}, "files": [{"sha": "20c0fcd91517c95ea95af92205fc1da09b8c8d2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8046c604274b3c68eadf882f30b5642ad3b86a3c", "patch": "@@ -1,3 +1,13 @@\n+2012-07-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-protos.c (ix86_lea_outperforms): Remove prototype.\n+\t* config/i386/i386.c (ix86_lea_outperforms): Make static.  Make\n+\tsplit_cost argument signed.\n+\t(ix86_avoid_lea_for_add): Cleanup.\n+\t(ix86_use_lea_for_mov): Use INVALID_REGNUM instead of -1.\n+\t(ix86_avoid_lea_for_addr): Ditto.  Make split_cost signed.\n+\tUse gen_lowpart instead of gen_rtx_SUBREG.  Cleanup.\n+\n 2012-07-23  Ulrich Weigand  <ulrich.weigand@linaro.org>\n \n \t* config/arm/arm.c (arm_reorg): Ensure all insns are split."}, {"sha": "a1daedafc6049ed824ac2baaf2371c9d6d131bda", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=8046c604274b3c68eadf882f30b5642ad3b86a3c", "patch": "@@ -92,8 +92,6 @@ extern void ix86_fixup_binary_operands_no_copy (enum rtx_code,\n extern void ix86_expand_binary_operator (enum rtx_code,\n \t\t\t\t\t enum machine_mode, rtx[]);\n extern bool ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n-extern bool ix86_lea_outperforms (rtx, unsigned int, unsigned int,\n-\t\t\t\t  unsigned int, unsigned int);\n extern bool ix86_avoid_lea_for_add (rtx, rtx[]);\n extern bool ix86_use_lea_for_mov (rtx, rtx[]);\n extern bool ix86_avoid_lea_for_addr (rtx, rtx[]);"}, {"sha": "eeb8c823c4bc5b9e4a930c417f881357a8f2e682", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8046c604274b3c68eadf882f30b5642ad3b86a3c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8046c604274b3c68eadf882f30b5642ad3b86a3c", "patch": "@@ -16805,9 +16805,9 @@ distance_agu_use (unsigned int regno0, rtx insn)\n    over a sequence of instructions.  Instructions sequence has\n    SPLIT_COST cycles higher latency than lea latency.  */\n \n-bool\n+static bool\n ix86_lea_outperforms (rtx insn, unsigned int regno0, unsigned int regno1,\n-\t\t      unsigned int regno2, unsigned int split_cost)\n+\t\t      unsigned int regno2, int split_cost)\n {\n   int dist_define, dist_use;\n \n@@ -16880,9 +16880,7 @@ ix86_ok_to_clobber_flags (rtx insn)\n bool\n ix86_avoid_lea_for_add (rtx insn, rtx operands[])\n {\n-  unsigned int regno0 = true_regnum (operands[0]);\n-  unsigned int regno1 = true_regnum (operands[1]);\n-  unsigned int regno2 = true_regnum (operands[2]);\n+  unsigned int regno0, regno1, regno2;\n \n   /* Check if we need to optimize.  */\n   if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n@@ -16892,6 +16890,10 @@ ix86_avoid_lea_for_add (rtx insn, rtx operands[])\n   if (!ix86_ok_to_clobber_flags(insn))\n     return false;\n \n+  regno0 = true_regnum (operands[0]);\n+  regno1 = true_regnum (operands[1]);\n+  regno2 = true_regnum (operands[2]);\n+\n   /* We need to split only adds with non destructive\n      destination operand.  */\n   if (regno0 == regno1 || regno0 == regno2)\n@@ -16906,8 +16908,7 @@ ix86_avoid_lea_for_add (rtx insn, rtx operands[])\n bool\n ix86_use_lea_for_mov (rtx insn, rtx operands[])\n {\n-  unsigned int regno0;\n-  unsigned int regno1;\n+  unsigned int regno0, regno1;\n \n   /* Check if we need to optimize.  */\n   if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n@@ -16920,7 +16921,7 @@ ix86_use_lea_for_mov (rtx insn, rtx operands[])\n   regno0 = true_regnum (operands[0]);\n   regno1 = true_regnum (operands[1]);\n \n-  return ix86_lea_outperforms (insn, regno0, regno1, -1, 0);\n+  return ix86_lea_outperforms (insn, regno0, regno1, INVALID_REGNUM, 0);\n }\n \n /* Return true if we need to split lea into a sequence of\n@@ -16929,10 +16930,8 @@ ix86_use_lea_for_mov (rtx insn, rtx operands[])\n bool\n ix86_avoid_lea_for_addr (rtx insn, rtx operands[])\n {\n-  unsigned int regno0 = true_regnum (operands[0]) ;\n-  unsigned int regno1 = -1;\n-  unsigned int regno2 = -1;\n-  unsigned int split_cost = 0;\n+  unsigned int regno0, regno1, regno2;\n+  int split_cost;\n   struct ix86_address parts;\n   int ok;\n \n@@ -16957,11 +16956,17 @@ ix86_avoid_lea_for_addr (rtx insn, rtx operands[])\n   if (parts.disp && flag_pic && !LEGITIMATE_PIC_OPERAND_P (parts.disp))\n     return false;\n \n+  regno0 = true_regnum (operands[0]) ;\n+  regno1 = INVALID_REGNUM;\n+  regno2 = INVALID_REGNUM;\n+\n   if (parts.base)\n     regno1 = true_regnum (parts.base);\n   if (parts.index)\n     regno2 = true_regnum (parts.index);\n \n+  split_cost = 0;\n+\n   /* Compute how many cycles we will add to execution time\n      if split lea into a sequence of instructions.  */\n   if (parts.base || parts.index)\n@@ -17021,27 +17026,31 @@ ix86_emit_binop (enum rtx_code code, enum machine_mode mode,\n extern void\n ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n {\n-  unsigned int regno0 = true_regnum (operands[0]) ;\n-  unsigned int regno1 = INVALID_REGNUM;\n-  unsigned int regno2 = INVALID_REGNUM;\n+  unsigned int regno0, regno1, regno2;\n   struct ix86_address parts;\n-  rtx tmp;\n+  rtx target, tmp;\n   int ok, adds;\n \n   ok = ix86_decompose_address (operands[1], &parts);\n   gcc_assert (ok);\n \n+  target = operands[0];\n+\n+  regno0 = true_regnum (target);\n+  regno1 = INVALID_REGNUM;\n+  regno2 = INVALID_REGNUM;\n+\n   if (parts.base)\n     {\n       if (GET_MODE (parts.base) != mode)\n-\tparts.base = gen_rtx_SUBREG (mode, parts.base, 0);\n+\tparts.base = gen_lowpart (mode, parts.base);\n       regno1 = true_regnum (parts.base);\n     }\n \n   if (parts.index)\n     {\n       if (GET_MODE (parts.index) != mode)\n-\tparts.index = gen_rtx_SUBREG (mode, parts.index, 0);\n+\tparts.index = gen_lowpart (mode, parts.index);\n       regno2 = true_regnum (parts.index);\n     }\n \n@@ -17057,41 +17066,41 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n \t  gcc_assert (regno2 != regno0);\n \n \t  for (adds = parts.scale; adds > 0; adds--)\n-\t    ix86_emit_binop (PLUS, mode, operands[0], parts.index);\n+\t    ix86_emit_binop (PLUS, mode, target, parts.index);\n \t}\n       else\n \t{\n \t  /* r1 = r2 + r3 * C case.  Need to move r3 into r1.  */\n \t  if (regno0 != regno2)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, target, parts.index));\n \n \t  /* Use shift for scaling.  */\n-\t  ix86_emit_binop (ASHIFT, mode, operands[0],\n+\t  ix86_emit_binop (ASHIFT, mode, target,\n \t\t\t   GEN_INT (exact_log2 (parts.scale)));\n \n \t  if (parts.base)\n-\t    ix86_emit_binop (PLUS, mode, operands[0], parts.base);\n+\t    ix86_emit_binop (PLUS, mode, target, parts.base);\n \n \t  if (parts.disp && parts.disp != const0_rtx)\n-\t    ix86_emit_binop (PLUS, mode, operands[0], parts.disp);\n+\t    ix86_emit_binop (PLUS, mode, target, parts.disp);\n \t}\n     }\n   else if (!parts.base && !parts.index)\n     {\n       gcc_assert(parts.disp);\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.disp));\n+      emit_insn (gen_rtx_SET (VOIDmode, target, parts.disp));\n     }\n   else\n     {\n       if (!parts.base)\n \t{\n \t  if (regno0 != regno2)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, target, parts.index));\n \t}\n       else if (!parts.index)\n \t{\n \t  if (regno0 != regno1)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, target, parts.base));\n \t}\n       else\n \t{\n@@ -17101,15 +17110,15 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n \t    tmp = parts.base;\n \t  else\n \t    {\n-\t      emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, target, parts.base));\n \t      tmp = parts.index;\n \t    }\n \n-\t  ix86_emit_binop (PLUS, mode, operands[0], tmp);\n+\t  ix86_emit_binop (PLUS, mode, target, tmp);\n \t}\n \n       if (parts.disp && parts.disp != const0_rtx)\n-\tix86_emit_binop (PLUS, mode, operands[0], parts.disp);\n+\tix86_emit_binop (PLUS, mode, target, parts.disp);\n     }\n }\n "}]}