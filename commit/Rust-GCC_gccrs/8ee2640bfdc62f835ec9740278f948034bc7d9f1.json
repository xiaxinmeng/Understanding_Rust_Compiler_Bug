{"sha": "8ee2640bfdc62f835ec9740278f948034bc7d9f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlMjY0MGJmZGM2MmY4MzVlYzk3NDAyNzhmOTQ4MDM0YmM3ZDlmMQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2020-06-21T04:23:02Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2020-06-21T05:26:13Z"}, "message": "rs6000: Add MMA built-in function definitions and test cases.\n\nAdd the Matrix-Multiply Assist (MMA) built-ins.  The MMA accumulators are\nINOUT operands for most MMA instructions, but they are also very expensive\nto move around.  For this reason, we have implemented a built-in API where\nthe accumulators are passed using pass-by-reference/pointers, so the user\nwon't use one accumulator as input and another as output, which wouldentail\na lot of copies.  However, using pointers gives us poor code generation\nwhen we expand the built-ins at normal expand time.  We therefore expand\nthe MMA built-ins early into gimple, converting the pass-by-reference calls\nto an internal built-in that uses pass-by-value calling convention, where\nwe can enforce the input and output accumulators are the same.  This gives\nus much better code generation.\n\n2020-06-20  Peter Bergner  <bergner@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/predicates.md (mma_assemble_input_operand): New.\n\t* config/rs6000/rs6000-builtin.def (BU_MMA_1, BU_MMA_V2, BU_MMA_3,\n\tBU_MMA_5, BU_MMA_6, BU_VSX_1): Add support macros for defining MMA\n\tbuilt-in functions.\n\t(ASSEMBLE_ACC, ASSEMBLE_PAIR, DISASSEMBLE_ACC, DISASSEMBLE_PAIR,\n\tPMXVBF16GER2, PMXVBF16GER2NN, PMXVBF16GER2NP, PMXVBF16GER2PN,\n\tPMXVBF16GER2PP, PMXVF16GER2, PMXVF16GER2NN, PMXVF16GER2NP,\n\tPMXVF16GER2PN, PMXVF16GER2PP, PMXVF32GER, PMXVF32GERNN,\n\tPMXVF32GERNP, PMXVF32GERPN, PMXVF32GERPP, PMXVF64GER, PMXVF64GERNN,\n\tPMXVF64GERNP, PMXVF64GERPN, PMXVF64GERPP, PMXVI16GER2, PMXVI16GER2PP,\n\tPMXVI16GER2S, PMXVI16GER2SPP, PMXVI4GER8, PMXVI4GER8PP, PMXVI8GER4,\n\tPMXVI8GER4PP, PMXVI8GER4SPP, XVBF16GER2, XVBF16GER2NN, XVBF16GER2NP,\n\tXVBF16GER2PN, XVBF16GER2PP, XVCVBF16SP, XVCVSPBF16, XVF16GER2,\n\tXVF16GER2NN, XVF16GER2NP, XVF16GER2PN, XVF16GER2PP, XVF32GER,\n\tXVF32GERNN, XVF32GERNP, XVF32GERPN, XVF32GERPP, XVF64GER, XVF64GERNN,\n\tXVF64GERNP, XVF64GERPN, XVF64GERPP, XVI16GER2, XVI16GER2PP, XVI16GER2S,\n\tXVI16GER2SPP, XVI4GER8, XVI4GER8PP, XVI8GER4, XVI8GER4PP, XVI8GER4SPP,\n\tXXMFACC, XXMTACC, XXSETACCZ): Add MMA built-ins.\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Use CONST_INT_P.\n\tAllow zero constants.\n\t(print_operand) <case 'A'>: New output modifier.\n\t(rs6000_split_multireg_move): Add support for inserting accumulator\n\tpriming and depriming instructions.  Add support for splitting an\n\tassemble accumulator pattern.\n\t* config/rs6000/rs6000-call.c (mma_init_builtins, mma_expand_builtin,\n\trs6000_gimple_fold_mma_builtin): New functions.\n\t(RS6000_BUILTIN_M): New macro.\n\t(def_builtin): Handle RS6000_BTC_QUAD and RS6000_BTC_PAIR attributes.\n\t(bdesc_mma): Add new MMA built-in support.\n\t(htm_expand_builtin): Use RS6000_BTC_OPND_MASK.\n\t(rs6000_invalid_builtin): Add handling of RS6000_BTM_FUTURE and\n\tRS6000_BTM_MMA.\n\t(rs6000_builtin_valid_without_lhs): Handle RS6000_BTC_VOID attribute.\n\t(rs6000_gimple_fold_builtin): Call rs6000_builtin_is_supported_p\n\tand rs6000_gimple_fold_mma_builtin.\n\t(rs6000_expand_builtin): Call mma_expand_builtin.\n\tUse RS6000_BTC_OPND_MASK.\n\t(rs6000_init_builtins): Adjust comment.  Call mma_init_builtins.\n\t(htm_init_builtins): Use RS6000_BTC_OPND_MASK.\n\t(builtin_function_type): Handle VSX_BUILTIN_XVCVSPBF16 and\n\tVSX_BUILTIN_XVCVBF16SP.\n\t* config/rs6000/rs6000.h (RS6000_BTC_QUINARY, RS6000_BTC_SENARY,\n\tRS6000_BTC_OPND_MASK, RS6000_BTC_QUAD, RS6000_BTC_PAIR,\n\tRS6000_BTC_QUADPAIR, RS6000_BTC_GIMPLE): New defines.\n\t(RS6000_BTC_PREDICATE, RS6000_BTC_ABS, RS6000_BTC_DST,\n\tRS6000_BTC_TYPE_MASK, RS6000_BTC_ATTR_MASK): Adjust values.\n\t* config/rs6000/mma.md (MAX_MMA_OPERANDS): New define_constant.\n\t(UNSPEC_MMA_ASSEMBLE_ACC, UNSPEC_MMA_PMXVBF16GER2,\n\tUNSPEC_MMA_PMXVBF16GER2NN, UNSPEC_MMA_PMXVBF16GER2NP,\n\tUNSPEC_MMA_PMXVBF16GER2PN, UNSPEC_MMA_PMXVBF16GER2PP,\n\tUNSPEC_MMA_PMXVF16GER2, UNSPEC_MMA_PMXVF16GER2NN,\n\tUNSPEC_MMA_PMXVF16GER2NP, UNSPEC_MMA_PMXVF16GER2PN,\n\tUNSPEC_MMA_PMXVF16GER2PP, UNSPEC_MMA_PMXVF32GER,\n\tUNSPEC_MMA_PMXVF32GERNN, UNSPEC_MMA_PMXVF32GERNP,\n\tUNSPEC_MMA_PMXVF32GERPN, UNSPEC_MMA_PMXVF32GERPP,\n\tUNSPEC_MMA_PMXVF64GER, UNSPEC_MMA_PMXVF64GERNN,\n\tUNSPEC_MMA_PMXVF64GERNP, UNSPEC_MMA_PMXVF64GERPN,\n\tUNSPEC_MMA_PMXVF64GERPP, UNSPEC_MMA_PMXVI16GER2,\n\tUNSPEC_MMA_PMXVI16GER2PP, UNSPEC_MMA_PMXVI16GER2S,\n\tUNSPEC_MMA_PMXVI16GER2SPP, UNSPEC_MMA_PMXVI4GER8,\n\tUNSPEC_MMA_PMXVI4GER8PP, UNSPEC_MMA_PMXVI8GER4,\n\tUNSPEC_MMA_PMXVI8GER4PP, UNSPEC_MMA_PMXVI8GER4SPP,\n\tUNSPEC_MMA_XVBF16GER2, UNSPEC_MMA_XVBF16GER2NN,\n\tUNSPEC_MMA_XVBF16GER2NP, UNSPEC_MMA_XVBF16GER2PN,\n\tUNSPEC_MMA_XVBF16GER2PP, UNSPEC_MMA_XVF16GER2, UNSPEC_MMA_XVF16GER2NN,\n\tUNSPEC_MMA_XVF16GER2NP, UNSPEC_MMA_XVF16GER2PN, UNSPEC_MMA_XVF16GER2PP,\n\tUNSPEC_MMA_XVF32GER, UNSPEC_MMA_XVF32GERNN, UNSPEC_MMA_XVF32GERNP,\n\tUNSPEC_MMA_XVF32GERPN, UNSPEC_MMA_XVF32GERPP, UNSPEC_MMA_XVF64GER,\n\tUNSPEC_MMA_XVF64GERNN, UNSPEC_MMA_XVF64GERNP, UNSPEC_MMA_XVF64GERPN,\n\tUNSPEC_MMA_XVF64GERPP, UNSPEC_MMA_XVI16GER2, UNSPEC_MMA_XVI16GER2PP,\n\tUNSPEC_MMA_XVI16GER2S, UNSPEC_MMA_XVI16GER2SPP, UNSPEC_MMA_XVI4GER8,\n\tUNSPEC_MMA_XVI4GER8PP, UNSPEC_MMA_XVI8GER4, UNSPEC_MMA_XVI8GER4PP,\n\tUNSPEC_MMA_XVI8GER4SPP, UNSPEC_MMA_XXMFACC, UNSPEC_MMA_XXMTACC): New.\n\t(MMA_ACC, MMA_VV, MMA_AVV, MMA_PV, MMA_APV, MMA_VVI4I4I8,\n\tMMA_AVVI4I4I8, MMA_VVI4I4I2, MMA_AVVI4I4I2, MMA_VVI4I4,\n\tMMA_AVVI4I4, MMA_PVI4I2, MMA_APVI4I2, MMA_VVI4I4I4,\n\tMMA_AVVI4I4I4): New define_int_iterator.\n\t(acc, vv, avv, pv, apv, vvi4i4i8, avvi4i4i8, vvi4i4i2,\n\tavvi4i4i2, vvi4i4, avvi4i4, pvi4i2, apvi4i2, vvi4i4i4,\n\tavvi4i4i4): New define_int_attr.\n\t(*movpxi): Add zero constant alternative.\n\t(mma_assemble_pair, mma_assemble_acc): New define_expand.\n\t(*mma_assemble_acc): New define_insn_and_split.\n\t(mma_<acc>, mma_xxsetaccz, mma_<vv>, mma_<avv>, mma_<pv>, mma_<apv>,\n\tmma_<vvi4i4i8>, mma_<avvi4i4i8>, mma_<vvi4i4i2>, mma_<avvi4i4i2>,\n\tmma_<vvi4i4>, mma_<avvi4i4>, mma_<pvi4i2>, mma_<apvi4i2>,\n\tmma_<vvi4i4i4>, mma_<avvi4i4i4>): New define_insn.\n\t* config/rs6000/rs6000.md (define_attr \"type\"): New type mma.\n\t* config/rs6000/vsx.md (UNSPEC_VSX_XVCVBF16SP): New.\n\t(UNSPEC_VSX_XVCVSPBF16): Likewise.\n\t(XVCVBF16): New define_int_iterator.\n\t(xvcvbf16): New define_int_attr.\n\t(vsx_<xvcvbf16>): New define_insn.\n\t* doc/extend.texi: Document the mma built-ins.", "tree": {"sha": "9375290dee7275b930336364140634ebd6a5fe08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9375290dee7275b930336364140634ebd6a5fe08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ee2640bfdc62f835ec9740278f948034bc7d9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee2640bfdc62f835ec9740278f948034bc7d9f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee2640bfdc62f835ec9740278f948034bc7d9f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee2640bfdc62f835ec9740278f948034bc7d9f1/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f002c046e37d0027513af5297d9259e1fad29c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f002c046e37d0027513af5297d9259e1fad29c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f002c046e37d0027513af5297d9259e1fad29c27"}], "stats": {"total": 1837, "additions": 1813, "deletions": 24}, "files": [{"sha": "15cacfb7fc10f6ee16d6f20ec2e5a7672ba42ae4", "filename": "gcc/config/rs6000/mma.md", "status": "modified", "additions": 484, "deletions": 6, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fmma.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fmma.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmma.md?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -31,6 +31,240 @@\n ;; therefore, we define the XImode and OImode move patterns, but we\n ;; disable their use with a \"false\" condition flag.\n \n+(define_constants [(MAX_MMA_OPERANDS 7)])\n+\n+;; Constants for creating unspecs\n+\n+(define_c_enum \"unspec\"\n+  [UNSPEC_MMA_ASSEMBLE_ACC\n+   UNSPEC_MMA_PMXVBF16GER2\n+   UNSPEC_MMA_PMXVBF16GER2NN\n+   UNSPEC_MMA_PMXVBF16GER2NP\n+   UNSPEC_MMA_PMXVBF16GER2PN\n+   UNSPEC_MMA_PMXVBF16GER2PP\n+   UNSPEC_MMA_PMXVF16GER2\n+   UNSPEC_MMA_PMXVF16GER2NN\n+   UNSPEC_MMA_PMXVF16GER2NP\n+   UNSPEC_MMA_PMXVF16GER2PN\n+   UNSPEC_MMA_PMXVF16GER2PP\n+   UNSPEC_MMA_PMXVF32GER\n+   UNSPEC_MMA_PMXVF32GERNN\n+   UNSPEC_MMA_PMXVF32GERNP\n+   UNSPEC_MMA_PMXVF32GERPN\n+   UNSPEC_MMA_PMXVF32GERPP\n+   UNSPEC_MMA_PMXVF64GER\n+   UNSPEC_MMA_PMXVF64GERNN\n+   UNSPEC_MMA_PMXVF64GERNP\n+   UNSPEC_MMA_PMXVF64GERPN\n+   UNSPEC_MMA_PMXVF64GERPP\n+   UNSPEC_MMA_PMXVI16GER2\n+   UNSPEC_MMA_PMXVI16GER2PP\n+   UNSPEC_MMA_PMXVI16GER2S\n+   UNSPEC_MMA_PMXVI16GER2SPP\n+   UNSPEC_MMA_PMXVI4GER8\n+   UNSPEC_MMA_PMXVI4GER8PP\n+   UNSPEC_MMA_PMXVI8GER4\n+   UNSPEC_MMA_PMXVI8GER4PP\n+   UNSPEC_MMA_PMXVI8GER4SPP\n+   UNSPEC_MMA_XVBF16GER2\n+   UNSPEC_MMA_XVBF16GER2NN\n+   UNSPEC_MMA_XVBF16GER2NP\n+   UNSPEC_MMA_XVBF16GER2PN\n+   UNSPEC_MMA_XVBF16GER2PP\n+   UNSPEC_MMA_XVF16GER2\n+   UNSPEC_MMA_XVF16GER2NN\n+   UNSPEC_MMA_XVF16GER2NP\n+   UNSPEC_MMA_XVF16GER2PN\n+   UNSPEC_MMA_XVF16GER2PP\n+   UNSPEC_MMA_XVF32GER\n+   UNSPEC_MMA_XVF32GERNN\n+   UNSPEC_MMA_XVF32GERNP\n+   UNSPEC_MMA_XVF32GERPN\n+   UNSPEC_MMA_XVF32GERPP\n+   UNSPEC_MMA_XVF64GER\n+   UNSPEC_MMA_XVF64GERNN\n+   UNSPEC_MMA_XVF64GERNP\n+   UNSPEC_MMA_XVF64GERPN\n+   UNSPEC_MMA_XVF64GERPP\n+   UNSPEC_MMA_XVI16GER2\n+   UNSPEC_MMA_XVI16GER2PP\n+   UNSPEC_MMA_XVI16GER2S\n+   UNSPEC_MMA_XVI16GER2SPP\n+   UNSPEC_MMA_XVI4GER8\n+   UNSPEC_MMA_XVI4GER8PP\n+   UNSPEC_MMA_XVI8GER4\n+   UNSPEC_MMA_XVI8GER4PP\n+   UNSPEC_MMA_XVI8GER4SPP\n+   UNSPEC_MMA_XXMFACC\n+   UNSPEC_MMA_XXMTACC\n+  ])\n+\n+;; MMA instructions with 1 accumulator argument\n+(define_int_iterator MMA_ACC\t\t[UNSPEC_MMA_XXMFACC\n+\t\t\t\t\t UNSPEC_MMA_XXMTACC])\n+\n+;; MMA instructions with 2 vector arguments\n+(define_int_iterator MMA_VV\t\t[UNSPEC_MMA_XVI4GER8\n+\t\t\t\t\t UNSPEC_MMA_XVI8GER4\n+\t\t\t\t\t UNSPEC_MMA_XVI16GER2\n+\t\t\t\t\t UNSPEC_MMA_XVI16GER2S\n+\t\t\t\t\t UNSPEC_MMA_XVF16GER2\n+\t\t\t\t\t UNSPEC_MMA_XVBF16GER2\n+\t\t\t\t\t UNSPEC_MMA_XVF32GER])\n+\n+;; MMA instructions with 1 accumulator and 2 vector arguments\n+(define_int_iterator MMA_AVV\t\t[UNSPEC_MMA_XVI4GER8PP\n+\t\t\t\t\t UNSPEC_MMA_XVI8GER4PP\n+\t\t\t\t\t UNSPEC_MMA_XVI8GER4SPP\n+\t\t\t\t\t UNSPEC_MMA_XVI16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_XVI16GER2SPP\n+\t\t\t\t\t UNSPEC_MMA_XVF16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_XVF16GER2PN\n+\t\t\t\t\t UNSPEC_MMA_XVF16GER2NP\n+\t\t\t\t\t UNSPEC_MMA_XVF16GER2NN\n+\t\t\t\t\t UNSPEC_MMA_XVBF16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_XVBF16GER2PN\n+\t\t\t\t\t UNSPEC_MMA_XVBF16GER2NP\n+\t\t\t\t\t UNSPEC_MMA_XVBF16GER2NN\n+\t\t\t\t\t UNSPEC_MMA_XVF32GERPP\n+\t\t\t\t\t UNSPEC_MMA_XVF32GERPN\n+\t\t\t\t\t UNSPEC_MMA_XVF32GERNP\n+\t\t\t\t\t UNSPEC_MMA_XVF32GERNN])\n+\n+;; MMA instructions with 1 vector pair and 1 vector arguments\n+(define_int_iterator MMA_PV\t\t[UNSPEC_MMA_XVF64GER])\n+\n+;; MMA instructions with 1 accumulator, 1 vector pair and 1 vector arguments\n+(define_int_iterator MMA_APV\t\t[UNSPEC_MMA_XVF64GERPP\n+\t\t\t\t\t UNSPEC_MMA_XVF64GERPN\n+\t\t\t\t\t UNSPEC_MMA_XVF64GERNP\n+\t\t\t\t\t UNSPEC_MMA_XVF64GERNN])\n+\n+;; MMA instructions with 2 vector, 2 4-bit and 1 8-bit arguments\n+(define_int_iterator MMA_VVI4I4I8\t[UNSPEC_MMA_PMXVI4GER8])\n+\n+;; MMA instructions with 1 accumulator, 2 vector, 2 4-bit and 1 8-bit arguments\n+(define_int_iterator MMA_AVVI4I4I8\t[UNSPEC_MMA_PMXVI4GER8PP])\n+\n+;; MMA instructions with 2 vector, 2 4-bit and 1 2-bit arguments\n+(define_int_iterator MMA_VVI4I4I2\t[UNSPEC_MMA_PMXVI16GER2\n+\t\t\t\t\t UNSPEC_MMA_PMXVI16GER2S\n+\t\t\t\t\t UNSPEC_MMA_PMXVF16GER2\n+\t\t\t\t\t UNSPEC_MMA_PMXVBF16GER2])\n+\n+;; MMA instructions with 1 accumulator, 2 vector, 2 4-bit and 1 2-bit arguments\n+(define_int_iterator MMA_AVVI4I4I2\t[UNSPEC_MMA_PMXVI16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_PMXVI16GER2SPP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF16GER2PN\n+\t\t\t\t\t UNSPEC_MMA_PMXVF16GER2NP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF16GER2NN\n+\t\t\t\t\t UNSPEC_MMA_PMXVBF16GER2PP\n+\t\t\t\t\t UNSPEC_MMA_PMXVBF16GER2PN\n+\t\t\t\t\t UNSPEC_MMA_PMXVBF16GER2NP\n+\t\t\t\t\t UNSPEC_MMA_PMXVBF16GER2NN])\n+\n+;; MMA instructions with 2 vector and 2 4-bit arguments\n+(define_int_iterator MMA_VVI4I4\t\t[UNSPEC_MMA_PMXVF32GER])\n+\n+;; MMA instructions with 1 accumulator, 2 vector and 2 4-bit arguments\n+(define_int_iterator MMA_AVVI4I4\t[UNSPEC_MMA_PMXVF32GERPP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF32GERPN\n+\t\t\t\t\t UNSPEC_MMA_PMXVF32GERNP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF32GERNN])\n+\n+;; MMA instructions with 2 vector, 1 4-bit and 1 2-bit arguments\n+(define_int_iterator MMA_PVI4I2\t\t[UNSPEC_MMA_PMXVF64GER])\n+\n+;; MMA instructions with 1 accumulator, 2 vector, 1 4-bit and 1 2-bit arguments\n+(define_int_iterator MMA_APVI4I2\t[UNSPEC_MMA_PMXVF64GERPP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF64GERPN\n+\t\t\t\t\t UNSPEC_MMA_PMXVF64GERNP\n+\t\t\t\t\t UNSPEC_MMA_PMXVF64GERNN])\n+\n+;; MMA instructions with 2 vector and 3 4-bit arguments\n+(define_int_iterator MMA_VVI4I4I4\t[UNSPEC_MMA_PMXVI8GER4])\n+\n+;; MMA instructions with 1 accumulator, 2 vector and 3 4-bit arguments\n+(define_int_iterator MMA_AVVI4I4I4\t[UNSPEC_MMA_PMXVI8GER4PP\n+\t\t\t\t\t UNSPEC_MMA_PMXVI8GER4SPP])\n+\n+(define_int_attr acc\t\t[(UNSPEC_MMA_XXMFACC\t\t\"xxmfacc\")\n+\t\t\t\t (UNSPEC_MMA_XXMTACC\t\t\"xxmtacc\")])\n+\n+(define_int_attr vv\t\t[(UNSPEC_MMA_XVI4GER8\t\t\"xvi4ger8\")\n+\t\t\t\t (UNSPEC_MMA_XVI8GER4\t\t\"xvi8ger4\")\n+\t\t\t\t (UNSPEC_MMA_XVI16GER2\t\t\"xvi16ger2\")\n+\t\t\t\t (UNSPEC_MMA_XVI16GER2S\t\t\"xvi16ger2s\")\n+\t\t\t\t (UNSPEC_MMA_XVF16GER2\t\t\"xvf16ger2\")\n+\t\t\t\t (UNSPEC_MMA_XVBF16GER2\t\t\"xvbf16ger2\")\n+\t\t\t\t (UNSPEC_MMA_XVF32GER\t\t\"xvf32ger\")])\n+\n+(define_int_attr avv\t\t[(UNSPEC_MMA_XVI4GER8PP\t\t\"xvi4ger8pp\")\n+\t\t\t\t (UNSPEC_MMA_XVI8GER4PP\t\t\"xvi8ger4pp\")\n+\t\t\t\t (UNSPEC_MMA_XVI8GER4SPP\t\"xvi8ger4spp\")\n+\t\t\t\t (UNSPEC_MMA_XVI16GER2PP\t\"xvi16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_XVI16GER2SPP\t\"xvi16ger2spp\")\n+\t\t\t\t (UNSPEC_MMA_XVF16GER2PP\t\"xvf16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_XVF16GER2PN\t\"xvf16ger2pn\")\n+\t\t\t\t (UNSPEC_MMA_XVF16GER2NP\t\"xvf16ger2np\")\n+\t\t\t\t (UNSPEC_MMA_XVF16GER2NN\t\"xvf16ger2nn\")\n+\t\t\t\t (UNSPEC_MMA_XVBF16GER2PP\t\"xvbf16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_XVBF16GER2PN\t\"xvbf16ger2pn\")\n+\t\t\t\t (UNSPEC_MMA_XVBF16GER2NP\t\"xvbf16ger2np\")\n+\t\t\t\t (UNSPEC_MMA_XVBF16GER2NN\t\"xvbf16ger2nn\")\n+\t\t\t\t (UNSPEC_MMA_XVF32GERPP\t\t\"xvf32gerpp\")\n+\t\t\t\t (UNSPEC_MMA_XVF32GERPN\t\t\"xvf32gerpn\")\n+\t\t\t\t (UNSPEC_MMA_XVF32GERNP\t\t\"xvf32gernp\")\n+\t\t\t\t (UNSPEC_MMA_XVF32GERNN\t\t\"xvf32gernn\")])\n+\n+(define_int_attr pv\t\t[(UNSPEC_MMA_XVF64GER\t\t\"xvf64ger\")])\n+\n+(define_int_attr apv\t\t[(UNSPEC_MMA_XVF64GERPP\t\t\"xvf64gerpp\")\n+\t\t\t\t (UNSPEC_MMA_XVF64GERPN\t\t\"xvf64gerpn\")\n+\t\t\t\t (UNSPEC_MMA_XVF64GERNP\t\t\"xvf64gernp\")\n+\t\t\t\t (UNSPEC_MMA_XVF64GERNN\t\t\"xvf64gernn\")])\n+\n+(define_int_attr vvi4i4i8\t[(UNSPEC_MMA_PMXVI4GER8\t\t\"pmxvi4ger8\")])\n+\n+(define_int_attr avvi4i4i8\t[(UNSPEC_MMA_PMXVI4GER8PP\t\"pmxvi4ger8pp\")])\n+\n+(define_int_attr vvi4i4i2\t[(UNSPEC_MMA_PMXVI16GER2\t\"pmxvi16ger2\")\n+\t\t\t\t (UNSPEC_MMA_PMXVI16GER2S\t\"pmxvi16ger2s\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF16GER2\t\"pmxvf16ger2\")\n+\t\t\t\t (UNSPEC_MMA_PMXVBF16GER2\t\"pmxvbf16ger2\")])\n+\n+(define_int_attr avvi4i4i2\t[(UNSPEC_MMA_PMXVI16GER2PP\t\"pmxvi16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVI16GER2SPP\t\"pmxvi16ger2spp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF16GER2PP\t\"pmxvf16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF16GER2PN\t\"pmxvf16ger2pn\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF16GER2NP\t\"pmxvf16ger2np\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF16GER2NN\t\"pmxvf16ger2nn\")\n+\t\t\t\t (UNSPEC_MMA_PMXVBF16GER2PP\t\"pmxvbf16ger2pp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVBF16GER2PN\t\"pmxvbf16ger2pn\")\n+\t\t\t\t (UNSPEC_MMA_PMXVBF16GER2NP\t\"pmxvbf16ger2np\")\n+\t\t\t\t (UNSPEC_MMA_PMXVBF16GER2NN\t\"pmxvbf16ger2nn\")])\n+\n+(define_int_attr vvi4i4\t\t[(UNSPEC_MMA_PMXVF32GER\t\t\"pmxvf32ger\")])\n+\n+(define_int_attr avvi4i4\t[(UNSPEC_MMA_PMXVF32GERPP\t\"pmxvf32gerpp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF32GERPN\t\"pmxvf32gerpn\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF32GERNP\t\"pmxvf32gernp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF32GERNN\t\"pmxvf32gernn\")])\n+\n+(define_int_attr pvi4i2\t\t[(UNSPEC_MMA_PMXVF64GER\t\t\"pmxvf64ger\")])\n+\n+(define_int_attr apvi4i2\t[(UNSPEC_MMA_PMXVF64GERPP\t\"pmxvf64gerpp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF64GERPN\t\"pmxvf64gerpn\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF64GERNP\t\"pmxvf64gernp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVF64GERNN\t\"pmxvf64gernn\")])\n+\n+(define_int_attr vvi4i4i4\t[(UNSPEC_MMA_PMXVI8GER4\t\t\"pmxvi8ger4\")])\n+\n+(define_int_attr avvi4i4i4\t[(UNSPEC_MMA_PMXVI8GER4PP\t\"pmxvi8ger4pp\")\n+\t\t\t\t (UNSPEC_MMA_PMXVI8GER4SPP\t\"pmxvi8ger4spp\")])\n+\n+\n ;; Define a disabled OImode move pattern, so we can use POImode.\n (define_expand \"movoi\"\n   [(set (match_operand:OI 0 \"nonimmediate_operand\")\n@@ -91,10 +325,11 @@\n })\n \n (define_insn_and_split \"*movpxi\"\n-  [(set (match_operand:PXI 0 \"nonimmediate_operand\" \"=d,m,d\")\n-\t(match_operand:PXI 1 \"input_operand\" \"m,d,d\"))]\n+  [(set (match_operand:PXI 0 \"nonimmediate_operand\" \"=d,m,d,d\")\n+\t(match_operand:PXI 1 \"input_operand\" \"m,d,d,O\"))]\n   \"TARGET_MMA\n-   && (gpc_reg_operand (operands[0], PXImode)\n+   && ((gpc_reg_operand (operands[0], PXImode)\n+\t&& !(CONST_INT_P (operands[1]) && INTVAL (operands[1]) == 0))\n        || gpc_reg_operand (operands[1], PXImode))\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -103,6 +338,249 @@\n   rs6000_split_multireg_move (operands[0], operands[1]);\n   DONE;\n }\n-  [(set_attr \"type\" \"vecload,vecstore,veclogical\")\n-   (set_attr \"length\" \"8,8,16\")\n-   (set_attr \"max_prefixed_insns\" \"2,2,*\")])\n+  [(set_attr \"type\" \"vecload,vecstore,veclogical,mma\")\n+   (set_attr \"length\" \"8,8,16,*\")\n+   (set_attr \"max_prefixed_insns\" \"2,2,*,*\")])\n+\n+(define_expand \"mma_assemble_pair\"\n+  [(match_operand:POI 0 \"vsx_register_operand\")\n+   (match_operand:V16QI 1 \"input_operand\")\n+   (match_operand:V16QI 2 \"input_operand\")]\n+  \"TARGET_MMA\"\n+{\n+  rtx dst;\n+\n+  /* Let the compiler know the code below fully defines our output value.  */\n+  emit_clobber (operands[0]);\n+\n+  dst = simplify_gen_subreg (V16QImode, operands[0], POImode, 0);\n+  emit_move_insn (dst, operands[1]);\n+  dst = simplify_gen_subreg (V16QImode, operands[0], POImode, 16);\n+  emit_move_insn (dst, operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"mma_assemble_acc\"\n+  [(match_operand:PXI 0 \"fpr_reg_operand\")\n+   (match_operand:V16QI 1 \"input_operand\")\n+   (match_operand:V16QI 2 \"input_operand\")\n+   (match_operand:V16QI 3 \"input_operand\")\n+   (match_operand:V16QI 4 \"input_operand\")]\n+  \"TARGET_MMA\"\n+{\n+  rtx src = gen_rtx_UNSPEC (PXImode,\n+\t\t\t    gen_rtvec (4, operands[1], operands[2],\n+\t\t\t\t       operands[3], operands[4]),\n+\t\t\t    UNSPEC_MMA_ASSEMBLE_ACC);\n+  emit_move_insn (operands[0], src);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*mma_assemble_acc\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t     (match_operand:V16QI 2 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t     (match_operand:V16QI 3 \"mma_assemble_input_operand\" \"mwa\")\n+\t\t     (match_operand:V16QI 4 \"mma_assemble_input_operand\" \"mwa\")]\n+\t\t     UNSPEC_MMA_ASSEMBLE_ACC))]\n+  \"TARGET_MMA\n+   && fpr_reg_operand (operands[0], PXImode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx src = gen_rtx_UNSPEC (PXImode,\n+\t\t\t    gen_rtvec (4, operands[1], operands[2],\n+\t\t\t\t       operands[3], operands[4]),\n+\t\t\t    UNSPEC_MMA_ASSEMBLE_ACC);\n+  rs6000_split_multireg_move (operands[0], src);\n+  DONE;\n+})\n+\n+;; MMA instructions that do not use their accumulators as an input, still\n+;; must not allow their vector operands to overlap the registers used by\n+;; the accumulator.  We enforce this by marking the output as early clobber.\n+\n+(define_insn \"mma_<acc>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")]\n+\t\t    MMA_ACC))]\n+  \"TARGET_MMA\"\n+  \"<acc> %A0\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_xxsetaccz\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=d\")\n+\t(const_int 0))]\n+  \"TARGET_MMA\"\n+  \"xxsetaccz %A0\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_<vv>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n+\t\t     MMA_VV))]\n+  \"TARGET_MMA\"\n+  \"<vv> %A0,%x1,%x2\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_<avv>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n+\t\t     MMA_AVV))]\n+  \"TARGET_MMA\"\n+  \"<avv> %A0,%x2,%x3\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_<pv>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:POI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")]\n+\t\t     MMA_PV))]\n+  \"TARGET_MMA\"\n+  \"<pv> %A0,%x1,%x2\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_<apv>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:POI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")]\n+\t\t     MMA_APV))]\n+  \"TARGET_MMA\"\n+  \"<apv> %A0,%x2,%x3\"\n+  [(set_attr \"type\" \"mma\")])\n+\n+(define_insn \"mma_<vvi4i4i8>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"u8bit_cint_operand\" \"n\")]\n+\t\t     MMA_VVI4I4I8))]\n+  \"TARGET_MMA\"\n+  \"<vvi4i4i8> %A0,%x1,%x2,%3,%4,%5\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<avvi4i4i8>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 6 \"u8bit_cint_operand\" \"n\")]\n+\t\t     MMA_AVVI4I4I8))]\n+  \"TARGET_MMA\"\n+  \"<avvi4i4i8> %A0,%x2,%x3,%4,%5,%6\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<vvi4i4i2>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n+\t\t     MMA_VVI4I4I2))]\n+  \"TARGET_MMA\"\n+  \"<vvi4i4i2> %A0,%x1,%x2,%3,%4,%5\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<avvi4i4i2>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 6 \"const_0_to_3_operand\" \"n\")]\n+\t\t     MMA_AVVI4I4I2))]\n+  \"TARGET_MMA\"\n+  \"<avvi4i4i2> %A0,%x2,%x3,%4,%5,%6\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<vvi4i4>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")]\n+\t\t     MMA_VVI4I4))]\n+  \"TARGET_MMA\"\n+  \"<vvi4i4> %A0,%x1,%x2,%3,%4\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<avvi4i4>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n+\t\t     MMA_AVVI4I4))]\n+  \"TARGET_MMA\"\n+  \"<avvi4i4> %A0,%x2,%x3,%4,%5\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<pvi4i2>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:POI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 4 \"const_0_to_3_operand\" \"n\")]\n+\t\t     MMA_PVI4I2))]\n+  \"TARGET_MMA\"\n+  \"<pvi4i2> %A0,%x1,%x2,%3,%4\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<apvi4i2>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:POI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_3_operand\" \"n\")]\n+\t\t     MMA_APVI4I2))]\n+  \"TARGET_MMA\"\n+  \"<apvi4i2> %A0,%x2,%x3,%4,%5\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<vvi4i4i4>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 3 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")]\n+\t\t     MMA_VVI4I4I4))]\n+  \"TARGET_MMA\"\n+  \"<vvi4i4i4> %A0,%x1,%x2,%3,%4,%5\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"mma_<avvi4i4i4>\"\n+  [(set (match_operand:PXI 0 \"fpr_reg_operand\" \"=&d\")\n+\t(unspec:PXI [(match_operand:PXI 1 \"fpr_reg_operand\" \"0\")\n+\t\t     (match_operand:V16QI 2 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:V16QI 3 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:SI 4 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 5 \"const_0_to_15_operand\" \"n\")\n+\t\t     (match_operand:SI 6 \"const_0_to_15_operand\" \"n\")]\n+\t\t     MMA_AVVI4I4I4))]\n+  \"TARGET_MMA\"\n+  \"<avvi4i4i4> %A0,%x2,%x3,%4,%5,%6\"\n+  [(set_attr \"type\" \"mma\")\n+   (set_attr \"length\" \"8\")])"}, {"sha": "9762855d76d701e2becdb6011832ac872232ec07", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -1119,6 +1119,11 @@\n   return gpc_reg_operand (op, mode);\n })\n \n+;; Return 1 if this operand is valid for a MMA assemble accumulator insn.\n+(define_special_predicate \"mma_assemble_input_operand\"\n+  (match_test \"(mode == V16QImode\n+\t\t&& (vsx_register_operand (op, mode) || MEM_P (op)))\"))\n+\n ;; Return true if operand is an operator used in rotate-and-mask instructions.\n (define_predicate \"rotate_mask_operator\"\n   (match_code \"rotate,ashift,lshiftrt\"))"}, {"sha": "968c46cc36ff100485a038d1b9e4607e9676660b", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -32,6 +32,7 @@\n    RS6000_BUILTIN_A -- ABS builtins\n    RS6000_BUILTIN_D -- DST builtins\n    RS6000_BUILTIN_H -- HTM builtins\n+   RS6000_BUILTIN_M -- MMA builtins\n    RS6000_BUILTIN_P -- Altivec, VSX, ISA 2.07 vector predicate builtins\n    RS6000_BUILTIN_X -- special builtins\n \n@@ -74,6 +75,10 @@\n   #error \"RS6000_BUILTIN_H is not defined.\"\n #endif\n \n+#ifndef RS6000_BUILTIN_M\n+  #error \"RS6000_BUILTIN_M is not defined.\"\n+#endif\n+\n #ifndef RS6000_BUILTIN_P\n   #error \"RS6000_BUILTIN_P is not defined.\"\n #endif\n@@ -329,6 +334,82 @@\n \t\t     | RS6000_BTC_SPECIAL),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+/* MMA convenience macros.  */\n+\n+#define BU_MMA_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM ## _INTERNAL,\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME \"_internal\",\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_MMA_V2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+#define BU_MMA_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM ## _INTERNAL,\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME \"_internal\",\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_MMA_5(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_QUINARY\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM ## _INTERNAL,\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME \"_internal\",\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_QUINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_MMA_6(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_SENARY\t\t\t\t\\\n+\t\t     | RS6000_BTC_VOID\t\t\t\t\t\\\n+\t\t     | RS6000_BTC_GIMPLE),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\t\\\n+  RS6000_BUILTIN_M (MMA_BUILTIN_ ## ENUM ## _INTERNAL,\t/* ENUM */\t\\\n+\t\t    \"__builtin_mma_\" NAME \"_internal\",\t/* NAME */\t\\\n+\t\t    RS6000_BTM_MMA,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_SENARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n /* ISA 2.05 (power6) convenience macros. */\n /* For functions that depend on the CMPB instruction */\n #define BU_P6_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n@@ -2785,3 +2866,77 @@ BU_SPECIAL_X (RS6000_BUILTIN_CPU_SUPPORTS, \"__builtin_cpu_supports\",\n /* Darwin CfString builtin.  */\n BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, \"__builtin_cfstring\", RS6000_BTM_ALWAYS,\n \t      RS6000_BTC_MISC)\n+\n+/* FUTURE MMA builtins.  */\n+BU_VSX_1 (XVCVBF16SP,\t    \"xvcvbf16sp\",\tMISC, vsx_xvcvbf16sp)\n+BU_VSX_1 (XVCVSPBF16,\t    \"xvcvspbf16\",\tMISC, vsx_xvcvspbf16)\n+\n+BU_MMA_1 (XXMFACC,\t    \"xxmfacc\",\t\tQUAD, mma_xxmfacc)\n+BU_MMA_1 (XXMTACC,\t    \"xxmtacc\",\t\tQUAD, mma_xxmtacc)\n+BU_MMA_1 (XXSETACCZ,\t    \"xxsetaccz\",\tMISC, mma_xxsetaccz)\n+\n+BU_MMA_V2 (DISASSEMBLE_ACC, \"disassemble_acc\",  QUAD, nothing)\n+BU_MMA_V2 (DISASSEMBLE_PAIR,\"disassemble_pair\", PAIR, nothing)\n+\n+BU_MMA_3 (ASSEMBLE_PAIR,    \"assemble_pair\",\tMISC, mma_assemble_pair)\n+BU_MMA_3 (XVBF16GER2,\t    \"xvbf16ger2\",\tMISC, mma_xvbf16ger2)\n+BU_MMA_3 (XVF16GER2,\t    \"xvf16ger2\",\tMISC, mma_xvf16ger2)\n+BU_MMA_3 (XVF32GER,\t    \"xvf32ger\",\t\tMISC, mma_xvf32ger)\n+BU_MMA_3 (XVF64GER,\t    \"xvf64ger\",\t\tPAIR, mma_xvf64ger)\n+BU_MMA_3 (XVI4GER8,\t    \"xvi4ger8\",\t\tMISC, mma_xvi4ger8)\n+BU_MMA_3 (XVI8GER4,\t    \"xvi8ger4\",\t\tMISC, mma_xvi8ger4)\n+BU_MMA_3 (XVI16GER2,\t    \"xvi16ger2\",\tMISC, mma_xvi16ger2)\n+BU_MMA_3 (XVI16GER2S,\t    \"xvi16ger2s\",\tMISC, mma_xvi16ger2s)\n+BU_MMA_3 (XVBF16GER2NN,\t    \"xvbf16ger2nn\",     QUAD, mma_xvbf16ger2nn)\n+BU_MMA_3 (XVBF16GER2NP,\t    \"xvbf16ger2np\",     QUAD, mma_xvbf16ger2np)\n+BU_MMA_3 (XVBF16GER2PN,\t    \"xvbf16ger2pn\",     QUAD, mma_xvbf16ger2pn)\n+BU_MMA_3 (XVBF16GER2PP,\t    \"xvbf16ger2pp\",     QUAD, mma_xvbf16ger2pp)\n+BU_MMA_3 (XVF16GER2NN,\t    \"xvf16ger2nn\",      QUAD, mma_xvf16ger2nn)\n+BU_MMA_3 (XVF16GER2NP,\t    \"xvf16ger2np\",      QUAD, mma_xvf16ger2np)\n+BU_MMA_3 (XVF16GER2PN,\t    \"xvf16ger2pn\",      QUAD, mma_xvf16ger2pn)\n+BU_MMA_3 (XVF16GER2PP,\t    \"xvf16ger2pp\",      QUAD, mma_xvf16ger2pp)\n+BU_MMA_3 (XVF32GERNN,\t    \"xvf32gernn\",       QUAD, mma_xvf32gernn)\n+BU_MMA_3 (XVF32GERNP,\t    \"xvf32gernp\",       QUAD, mma_xvf32gernp)\n+BU_MMA_3 (XVF32GERPN,\t    \"xvf32gerpn\",       QUAD, mma_xvf32gerpn)\n+BU_MMA_3 (XVF32GERPP,\t    \"xvf32gerpp\",       QUAD, mma_xvf32gerpp)\n+BU_MMA_3 (XVF64GERNN,\t    \"xvf64gernn\",       QUADPAIR, mma_xvf64gernn)\n+BU_MMA_3 (XVF64GERNP,\t    \"xvf64gernp\",       QUADPAIR, mma_xvf64gernp)\n+BU_MMA_3 (XVF64GERPN,\t    \"xvf64gerpn\",       QUADPAIR, mma_xvf64gerpn)\n+BU_MMA_3 (XVF64GERPP,\t    \"xvf64gerpp\",       QUADPAIR, mma_xvf64gerpp)\n+BU_MMA_3 (XVI4GER8PP,\t    \"xvi4ger8pp\",\tQUAD, mma_xvi4ger8pp)\n+BU_MMA_3 (XVI8GER4PP,\t    \"xvi8ger4pp\",       QUAD, mma_xvi8ger4pp)\n+BU_MMA_3 (XVI8GER4SPP,\t    \"xvi8ger4spp\",      QUAD, mma_xvi8ger4spp)\n+BU_MMA_3 (XVI16GER2PP,\t    \"xvi16ger2pp\",      QUAD, mma_xvi16ger2pp)\n+BU_MMA_3 (XVI16GER2SPP,\t    \"xvi16ger2spp\",     QUAD, mma_xvi16ger2spp)\n+\n+BU_MMA_5 (ASSEMBLE_ACC,     \"assemble_acc\",\tMISC, mma_assemble_acc)\n+BU_MMA_5 (PMXVF32GER,\t    \"pmxvf32ger\",       MISC, mma_pmxvf32ger)\n+BU_MMA_5 (PMXVF64GER,\t    \"pmxvf64ger\",       PAIR, mma_pmxvf64ger)\n+BU_MMA_5 (PMXVF32GERNN,\t    \"pmxvf32gernn\",     QUAD, mma_pmxvf32gernn)\n+BU_MMA_5 (PMXVF32GERNP,\t    \"pmxvf32gernp\",     QUAD, mma_pmxvf32gernp)\n+BU_MMA_5 (PMXVF32GERPN,\t    \"pmxvf32gerpn\",     QUAD, mma_pmxvf32gerpn)\n+BU_MMA_5 (PMXVF32GERPP,\t    \"pmxvf32gerpp\",     QUAD, mma_pmxvf32gerpp)\n+BU_MMA_5 (PMXVF64GERNN,\t    \"pmxvf64gernn\",     QUADPAIR, mma_pmxvf64gernn)\n+BU_MMA_5 (PMXVF64GERNP,\t    \"pmxvf64gernp\",     QUADPAIR, mma_pmxvf64gernp)\n+BU_MMA_5 (PMXVF64GERPN,\t    \"pmxvf64gerpn\",     QUADPAIR, mma_pmxvf64gerpn)\n+BU_MMA_5 (PMXVF64GERPP,\t    \"pmxvf64gerpp\",     QUADPAIR, mma_pmxvf64gerpp)\n+\n+BU_MMA_6 (PMXVBF16GER2,\t    \"pmxvbf16ger2\",     MISC, mma_pmxvbf16ger2)\n+BU_MMA_6 (PMXVF16GER2,\t    \"pmxvf16ger2\",      MISC, mma_pmxvf16ger2)\n+BU_MMA_6 (PMXVI4GER8,\t    \"pmxvi4ger8\",       MISC, mma_pmxvi4ger8)\n+BU_MMA_6 (PMXVI8GER4,\t    \"pmxvi8ger4\",\tMISC, mma_pmxvi8ger4)\n+BU_MMA_6 (PMXVI16GER2,\t    \"pmxvi16ger2\",      MISC, mma_pmxvi16ger2)\n+BU_MMA_6 (PMXVI16GER2S,\t    \"pmxvi16ger2s\",     MISC, mma_pmxvi16ger2s)\n+BU_MMA_6 (PMXVBF16GER2NN,   \"pmxvbf16ger2nn\",   QUAD, mma_pmxvbf16ger2nn)\n+BU_MMA_6 (PMXVBF16GER2NP,   \"pmxvbf16ger2np\",   QUAD, mma_pmxvbf16ger2np)\n+BU_MMA_6 (PMXVBF16GER2PN,   \"pmxvbf16ger2pn\",   QUAD, mma_pmxvbf16ger2pn)\n+BU_MMA_6 (PMXVBF16GER2PP,   \"pmxvbf16ger2pp\",   QUAD, mma_pmxvbf16ger2pp)\n+BU_MMA_6 (PMXVF16GER2NN,    \"pmxvf16ger2nn\",    QUAD, mma_pmxvf16ger2nn)\n+BU_MMA_6 (PMXVF16GER2NP,    \"pmxvf16ger2np\",    QUAD, mma_pmxvf16ger2np)\n+BU_MMA_6 (PMXVF16GER2PN,    \"pmxvf16ger2pn\",    QUAD, mma_pmxvf16ger2pn)\n+BU_MMA_6 (PMXVF16GER2PP,    \"pmxvf16ger2pp\",    QUAD, mma_pmxvf16ger2pp)\n+BU_MMA_6 (PMXVI4GER8PP,\t    \"pmxvi4ger8pp\",     QUAD, mma_pmxvi4ger8pp)\n+BU_MMA_6 (PMXVI8GER4PP,\t    \"pmxvi8ger4pp\",\tQUAD, mma_pmxvi8ger4pp)\n+BU_MMA_6 (PMXVI8GER4SPP,    \"pmxvi8ger4spp\",\tQUAD, mma_pmxvi8ger4spp)\n+BU_MMA_6 (PMXVI16GER2PP,    \"pmxvi16ger2pp\",    QUAD, mma_pmxvi16ger2pp)\n+BU_MMA_6 (PMXVI16GER2SPP,   \"pmxvi16ger2spp\",   QUAD, mma_pmxvi16ger2spp)"}, {"sha": "fdf136faf299acba3631cf2d243798878d2254f2", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 480, "deletions": 9, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -183,6 +183,7 @@ static tree builtin_function_type (machine_mode, machine_mode,\n \t\t\t\t   enum rs6000_builtins, const char *name);\n static void rs6000_common_init_builtins (void);\n static void htm_init_builtins (void);\n+static void mma_init_builtins (void);\n \n \n /* Hash table to keep track of the argument types for builtin functions.  */\n@@ -243,6 +244,7 @@ builtin_hasher::equal (builtin_hash_struct *p1, builtin_hash_struct *p2)\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -270,6 +272,9 @@ builtin_hasher::equal (builtin_hash_struct *p1, builtin_hash_struct *p2)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)  \\\n+  { NAME, ICODE, MASK, ATTR },\n+\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n@@ -296,6 +301,7 @@ static const struct rs6000_builtin_info_type rs6000_builtin_info[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8354,6 +8360,9 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n \t  attr_string = \", fp, const\";\n \t}\n     }\n+  else if ((classify & (RS6000_BTC_QUAD | RS6000_BTC_PAIR)) != 0)\n+    /* The function uses a register quad and/or pair.  Nothing to do.  */\n+    ;\n   else if ((classify & RS6000_BTC_ATTR_MASK) != 0)\n     gcc_unreachable ();\n \n@@ -8372,6 +8381,7 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8385,6 +8395,7 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8403,6 +8414,7 @@ static const struct builtin_description bdesc_3arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8416,6 +8428,7 @@ static const struct builtin_description bdesc_3arg[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8434,6 +8447,7 @@ static const struct builtin_description bdesc_4arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8447,6 +8461,7 @@ static const struct builtin_description bdesc_4arg[] =\n   { MASK, ICODE, NAME, ENUM },\n \n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8465,6 +8480,7 @@ static const struct builtin_description bdesc_dst[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8478,6 +8494,7 @@ static const struct builtin_description bdesc_dst[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8494,6 +8511,7 @@ static const struct builtin_description bdesc_2arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8505,6 +8523,7 @@ static const struct builtin_description bdesc_2arg[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n \n@@ -8527,6 +8546,7 @@ static const struct builtin_description bdesc_altivec_preds[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8540,6 +8560,7 @@ static const struct builtin_description bdesc_altivec_preds[] =\n \n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8559,6 +8580,7 @@ static const struct builtin_description bdesc_abs[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8572,6 +8594,7 @@ static const struct builtin_description bdesc_abs[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8590,6 +8613,7 @@ static const struct builtin_description bdesc_1arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8603,6 +8627,7 @@ static const struct builtin_description bdesc_1arg[] =\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8620,6 +8645,7 @@ static const struct builtin_description bdesc_0arg[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -8633,6 +8659,7 @@ static const struct builtin_description bdesc_0arg[] =\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n \n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n@@ -8641,6 +8668,7 @@ static const struct builtin_description bdesc_htm[] =\n #include \"rs6000-builtin.def\"\n };\n \n+/* MMA builtins.  */\n #undef RS6000_BUILTIN_0\n #undef RS6000_BUILTIN_1\n #undef RS6000_BUILTIN_2\n@@ -8649,7 +8677,40 @@ static const struct builtin_description bdesc_htm[] =\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n+#undef RS6000_BUILTIN_X\n+\n+#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE) \\\n+  { MASK, ICODE, NAME, ENUM },\n+\n+#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n+#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n+\n+static const struct builtin_description bdesc_mma[] =\n+{\n+#include \"rs6000-builtin.def\"\n+};\n+\n+#undef RS6000_BUILTIN_0\n+#undef RS6000_BUILTIN_1\n+#undef RS6000_BUILTIN_2\n+#undef RS6000_BUILTIN_3\n+#undef RS6000_BUILTIN_4\n+#undef RS6000_BUILTIN_A\n+#undef RS6000_BUILTIN_D\n+#undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n+#undef RS6000_BUILTIN_P\n+#undef RS6000_BUILTIN_X\n \n /* Return true if a builtin function is overloaded.  */\n bool\n@@ -9393,6 +9454,133 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n   return NULL_RTX;\n }\n \n+/* Expand the MMA built-in in EXP.\n+   Store true in *EXPANDEDP if we found a built-in to expand.  */\n+\n+static rtx\n+mma_expand_builtin (tree exp, rtx target, bool *expandedp)\n+{\n+  unsigned i;\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  enum rs6000_builtins fcode\n+    = (enum rs6000_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+  const struct builtin_description *d = bdesc_mma;\n+\n+  /* Expand the MMA built-in.  */\n+  for (i = 0; i < ARRAY_SIZE (bdesc_mma); i++, d++)\n+    if (d->code == fcode)\n+      break;\n+\n+  if (i >= ARRAY_SIZE (bdesc_mma))\n+    {\n+      *expandedp = false;\n+      return NULL_RTX;\n+    }\n+\n+  *expandedp = true;\n+\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+  enum insn_code icode = d->icode;\n+  const struct insn_operand_data *insn_op;\n+  rtx op[MAX_MMA_OPERANDS];\n+  unsigned nopnds = 0;\n+  unsigned attr = rs6000_builtin_info[fcode].attr;\n+  bool void_func = (attr & RS6000_BTC_VOID);\n+  machine_mode tmode = VOIDmode;\n+\n+  if (TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node)\n+    {\n+      tmode = insn_data[icode].operand[0].mode;\n+      if (!target\n+\t  || GET_MODE (target) != tmode\n+\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      op[nopnds++] = target;\n+    }\n+  else\n+    target = const0_rtx;\n+\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+    {\n+      if (arg == error_mark_node)\n+\treturn const0_rtx;\n+\n+      rtx opnd;\n+      insn_op = &insn_data[icode].operand[nopnds];\n+      if (TREE_CODE (arg) == ADDR_EXPR\n+\t  && MEM_P (DECL_RTL (TREE_OPERAND (arg, 0))))\n+\topnd = DECL_RTL (TREE_OPERAND (arg, 0));\n+      else\n+\topnd = expand_normal (arg);\n+\n+      if (!(*insn_op->predicate) (opnd, insn_op->mode))\n+\t{\n+\t  if (!strcmp (insn_op->constraint, \"n\"))\n+\t    {\n+\t      if (!CONST_INT_P (opnd))\n+\t\terror (\"argument %d must be an unsigned literal\", nopnds);\n+\t      else\n+\t\terror (\"argument %d is an unsigned literal that is \"\n+\t\t       \"out of range\", nopnds);\n+\t      return const0_rtx;\n+\t    }\n+\t  opnd = copy_to_mode_reg (insn_op->mode, opnd);\n+\t}\n+\n+      /* Some MMA instructions have INOUT accumulator operands, so force\n+\t their target register to be the same as their input register.  */\n+      if (!void_func\n+\t  && nopnds == 1\n+\t  && !strcmp (insn_op->constraint, \"0\")\n+\t  && insn_op->mode == tmode\n+\t  && REG_P (opnd)\n+\t  && (*insn_data[icode].operand[0].predicate) (opnd, tmode))\n+\ttarget = op[0] = opnd;\n+\n+      op[nopnds++] = opnd;\n+    }\n+\n+  unsigned attr_args = attr & RS6000_BTC_OPND_MASK;\n+  if (attr & RS6000_BTC_QUAD)\n+    attr_args++;\n+\n+  gcc_assert (nopnds == attr_args);\n+\n+  rtx pat;\n+  switch (nopnds)\n+    {\n+    case 1:\n+      pat = GEN_FCN (icode) (op[0]);\n+      break;\n+    case 2:\n+      pat = GEN_FCN (icode) (op[0], op[1]);\n+      break;\n+    case 3:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2]);\n+      break;\n+    case 4:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3]);\n+      break;\n+    case 5:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4]);\n+      break;\n+    case 6:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4], op[5]);\n+      break;\n+    case 7:\n+      pat = GEN_FCN (icode) (op[0], op[1], op[2], op[3], op[4], op[5], op[6]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\n /* Return the appropriate SPR number associated with the given builtin.  */\n static inline HOST_WIDE_INT\n htm_spr_num (enum rs6000_builtins code)\n@@ -9539,11 +9727,11 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)\n \tif (flag_checking)\n \t  {\n \t    int expected_nopnds = 0;\n-\t    if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_UNARY)\n+\t    if ((attr & RS6000_BTC_OPND_MASK) == RS6000_BTC_UNARY)\n \t      expected_nopnds = 1;\n-\t    else if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_BINARY)\n+\t    else if ((attr & RS6000_BTC_OPND_MASK) == RS6000_BTC_BINARY)\n \t      expected_nopnds = 2;\n-\t    else if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_TERNARY)\n+\t    else if ((attr & RS6000_BTC_OPND_MASK) == RS6000_BTC_TERNARY)\n \t      expected_nopnds = 3;\n \t    else if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_QUATERNARY)\n \t      expected_nopnds = 4;\n@@ -10647,6 +10835,10 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n \t   \"-m64\");\n   else if ((fnmask & RS6000_BTM_P9_MISC) == RS6000_BTM_P9_MISC)\n     error (\"%qs requires the %qs option\", name, \"-mcpu=power9\");\n+  else if ((fnmask & RS6000_BTM_FUTURE) != 0)\n+    error (\"%qs requires the %qs option\", name, \"-mcpu=future\");\n+  else if ((fnmask & RS6000_BTM_MMA) != 0)\n+    error (\"%qs requires the %qs option\", name, \"-mmma\");\n   else if ((fnmask & RS6000_BTM_LDBL128) == RS6000_BTM_LDBL128)\n     {\n       if (!TARGET_HARD_FLOAT)\n@@ -10690,6 +10882,10 @@ rs6000_fold_builtin (tree fndecl ATTRIBUTE_UNUSED,\n static bool\n rs6000_builtin_valid_without_lhs (enum rs6000_builtins fn_code)\n {\n+  /* Check for built-ins explicitly marked as a void function.  */\n+  if (rs6000_builtin_info[fn_code].attr & RS6000_BTC_VOID)\n+    return true;\n+\n   switch (fn_code)\n     {\n     case ALTIVEC_BUILTIN_STVX_V16QI:\n@@ -10836,6 +11032,156 @@ fold_mergeeo_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_odd)\n   gsi_replace (gsi, g, true);\n }\n \n+/* Expand the MMA built-ins early, so that we can convert the pass-by-reference\n+   __vector_quad arguments into pass-by-value arguments, leading to more\n+   efficient code generation.  */\n+\n+bool\n+rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  enum rs6000_builtins fncode\n+    = (enum rs6000_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+  unsigned attr = rs6000_builtin_info[fncode].attr;\n+\n+  if ((attr & RS6000_BTC_GIMPLE) == 0)\n+    return false;\n+\n+  unsigned nopnds = (attr & RS6000_BTC_OPND_MASK);\n+  gimple_seq new_seq = NULL;\n+  gimple *new_call;\n+  tree new_decl;\n+\n+  if (rs6000_builtin_info[fncode + 1].icode == CODE_FOR_nothing)\n+    {\n+      /* This is an MMA disassemble built-in function.  */\n+      gcc_assert (fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n+\t\t  || fncode == MMA_BUILTIN_DISASSEMBLE_PAIR);\n+\n+      push_gimplify_context (true);\n+      tree dst_ptr = gimple_call_arg (stmt, 0);\n+      tree src_ptr = gimple_call_arg (stmt, 1);\n+      tree src_type = TREE_TYPE (src_ptr);\n+      tree src = make_ssa_name (TREE_TYPE (src_type));\n+      gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);\n+\n+      /* If we are not disassembling an accumulator or our destination is\n+\t another accumulator, then just copy the entire thing as is.  */\n+      if (fncode != MMA_BUILTIN_DISASSEMBLE_ACC\n+\t  || TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_quad_type_node)\n+\t{\n+\t  tree dst = build_simple_mem_ref (build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t   src_type, dst_ptr));\n+\t  gimplify_assign (dst, src, &new_seq);\n+\t  pop_gimplify_context (NULL);\n+\t  gsi_replace_with_seq (gsi, new_seq, true);\n+\t  return true;\n+\t}\n+\n+      /* We're disassembling an accumulator into a different type, so we need\n+\t to emit a xxmfacc instruction now, since we cannot do it later.  */\n+      new_decl = rs6000_builtin_decls[MMA_BUILTIN_XXMFACC_INTERNAL];\n+      new_call = gimple_build_call (new_decl, 1, src);\n+      src = make_ssa_name (vector_quad_type_node);\n+      gimple_call_set_lhs (new_call, src);\n+      gimple_seq_add_stmt (&new_seq, new_call);\n+\n+      /* Copy the accumulator vector by vector.  */\n+      tree dst_type = build_pointer_type_for_mode (unsigned_V16QI_type_node,\n+\t\t\t\t\t\t   ptr_mode, true);\n+      tree dst_base = build1 (VIEW_CONVERT_EXPR, dst_type, dst_ptr);\n+      tree array_type = build_array_type_nelts (unsigned_V16QI_type_node, 4);\n+      tree src_array = build1 (VIEW_CONVERT_EXPR, array_type, src);\n+      for (unsigned i = 0; i < 4; i++)\n+\t{\n+\t  tree ref = build4 (ARRAY_REF, unsigned_V16QI_type_node, src_array,\n+\t\t\t     build_int_cst (size_type_node, i),\n+\t\t\t     NULL_TREE, NULL_TREE);\n+\t  tree dst = build2 (MEM_REF, unsigned_V16QI_type_node, dst_base,\n+\t\t\t     build_int_cst (dst_type, i * 16));\n+\t  gimplify_assign (dst, ref, &new_seq);\n+\t}\n+      pop_gimplify_context (NULL);\n+      gsi_replace_with_seq (gsi, new_seq, true);\n+      return true;\n+    }\n+\n+  /* Convert this built-in into an internal version that uses pass-by-value\n+     arguments.  The internal built-in follows immediately after this one.  */\n+  new_decl = rs6000_builtin_decls[fncode + 1];\n+  tree lhs, mem, op[MAX_MMA_OPERANDS];\n+  tree acc = gimple_call_arg (stmt, 0);\n+  if (TREE_CODE (acc) == PARM_DECL)\n+    mem = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (acc)), acc);\n+  else\n+    mem = build_simple_mem_ref (acc);\n+  push_gimplify_context (true);\n+\n+  if ((attr & RS6000_BTC_QUAD) != 0)\n+    {\n+      /* This built-in has a pass-by-reference accumulator input, so load it\n+\t into a temporary accumulator for use as a pass-by-value input.  */\n+      op[0] = make_ssa_name (vector_quad_type_node);\n+      for (unsigned i = 1; i < nopnds; i++)\n+\top[i] = gimple_call_arg (stmt, i);\n+      gimplify_assign (op[0], mem, &new_seq);\n+    }\n+  else\n+    {\n+      /* This built-in does not use its pass-by-reference accumulator argument\n+\t as an input argument, so remove it from the input list.  */\n+      nopnds--;\n+      for (unsigned i = 0; i < nopnds; i++)\n+\top[i] = gimple_call_arg (stmt, i + 1);\n+    }\n+\n+  switch (nopnds)\n+    {\n+    case 0:\n+      new_call = gimple_build_call (new_decl, 0);\n+      break;\n+    case 1:\n+      new_call = gimple_build_call (new_decl, 1, op[0]);\n+      break;\n+    case 2:\n+      new_call = gimple_build_call (new_decl, 2, op[0], op[1]);\n+      break;\n+    case 3:\n+      new_call = gimple_build_call (new_decl, 3, op[0], op[1], op[2]);\n+      break;\n+    case 4:\n+      new_call = gimple_build_call (new_decl, 4, op[0], op[1], op[2], op[3]);\n+      break;\n+    case 5:\n+      new_call = gimple_build_call (new_decl, 5, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4]);\n+      break;\n+    case 6:\n+      new_call = gimple_build_call (new_decl, 6, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4], op[5]);\n+      break;\n+    case 7:\n+      new_call = gimple_build_call (new_decl, 7, op[0], op[1], op[2], op[3],\n+\t\t\t\t    op[4], op[5], op[6]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (fncode == MMA_BUILTIN_ASSEMBLE_PAIR)\n+    lhs = make_ssa_name (vector_pair_type_node);\n+  else\n+    lhs = make_ssa_name (vector_quad_type_node);\n+  gimple_call_set_lhs (new_call, lhs);\n+  gimple_seq_add_stmt (&new_seq, new_call);\n+  gimplify_assign (mem, lhs, &new_seq);\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (gsi, new_seq, true);\n+\n+  return true;\n+}\n+\n /* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n    a constant, use rs6000_fold_builtin.)  */\n \n@@ -10871,11 +11217,12 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     return false;\n \n   /* Don't fold invalid builtins, let rs6000_expand_builtin diagnose it.  */\n-  HOST_WIDE_INT mask = rs6000_builtin_info[uns_fncode].mask;\n-  bool func_valid_p = (rs6000_builtin_mask & mask) == mask;\n-  if (!func_valid_p)\n+  if (!rs6000_builtin_is_supported_p (fn_code))\n     return false;\n \n+  if (rs6000_gimple_fold_mma_builtin (gsi))\n+    return true;\n+\n   switch (fn_code)\n     {\n     /* Flavors of vec_add.  We deliberately don't expand\n@@ -12010,6 +12357,13 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       break;\n     }\n \n+  if (TARGET_MMA)\n+    {\n+      ret = mma_expand_builtin (exp, target, &success);\n+\n+      if (success)\n+\treturn ret;\n+    }\n   if (TARGET_ALTIVEC)\n     {\n       ret = altivec_expand_builtin (exp, target, &success);\n@@ -12025,7 +12379,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \treturn ret;\n     }  \n \n-  unsigned attr = rs6000_builtin_info[uns_fcode].attr & RS6000_BTC_TYPE_MASK;\n+  unsigned attr = rs6000_builtin_info[uns_fcode].attr & RS6000_BTC_OPND_MASK;\n   /* RS6000_BTC_SPECIAL represents no-operand operators.  */\n   gcc_assert (attr == RS6000_BTC_UNARY\n \t      || attr == RS6000_BTC_BINARY\n@@ -12208,7 +12562,7 @@ rs6000_init_builtins (void)\n   else\n     ieee128_float_type_node = ibm128_float_type_node = long_double_type_node;\n \n-  /* Vector paired and vector quad support.  */\n+  /* Vector pair and vector quad support.  */\n   if (TARGET_MMA)\n     {\n       tree oi_uns_type = make_unsigned_type (256);\n@@ -12290,6 +12644,8 @@ rs6000_init_builtins (void)\n      the target attribute.  */\n   if (TARGET_EXTRA_BUILTINS)\n     altivec_init_builtins ();\n+  if (TARGET_MMA)\n+    mma_init_builtins ();\n   if (TARGET_HTM)\n     htm_init_builtins ();\n \n@@ -13015,6 +13371,119 @@ altivec_init_builtins (void)\n \n }\n \n+static void\n+mma_init_builtins (void)\n+{\n+  const struct builtin_description *d = bdesc_mma;\n+\n+  for (unsigned i = 0; i < ARRAY_SIZE (bdesc_mma); i++, d++)\n+    {\n+      tree op[MAX_MMA_OPERANDS], type;\n+      HOST_WIDE_INT mask = d->mask;\n+      unsigned icode = (unsigned) d->icode;\n+      unsigned attr = rs6000_builtin_info[d->code].attr;\n+      int attr_args = (attr & RS6000_BTC_OPND_MASK);\n+      bool gimple_func = (attr & RS6000_BTC_GIMPLE);\n+      unsigned nopnds = 0;\n+\n+      if ((mask & rs6000_builtin_mask) != mask)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"mma_builtin, skip binary %s\\n\", d->name);\n+\t  continue;\n+\t}\n+\n+      if (d->name == 0)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"mma_builtin, bdesc_mma[%ld] no name\\n\",\n+\t\t     (long unsigned) i);\n+\t  continue;\n+\t}\n+\n+      if (gimple_func)\n+\t{\n+\t  gcc_assert (icode == CODE_FOR_nothing);\n+\t  op[nopnds++] = void_type_node;\n+\t  /* Some MMA built-ins that are expanded into gimple are converted\n+\t     into internal MMA built-ins that are expanded into rtl.\n+\t     The internal built-in follows immediately after this built-in.  */\n+\t  icode = d[1].icode;\n+\t}\n+      else\n+\t{\n+\t  if ((attr & RS6000_BTC_QUAD) == 0)\n+\t    attr_args--;\n+\n+\t  /* Ensure we have the correct number and type of operands.  */\n+\t  gcc_assert (attr_args == insn_data[icode].n_operands - 1);\n+\t}\n+\n+      if (icode == CODE_FOR_nothing)\n+\t{\n+\t  /* This is a disassemble MMA built-in function.  */\n+\t  gcc_assert (attr_args == RS6000_BTC_BINARY\n+\t\t      && (d->code == MMA_BUILTIN_DISASSEMBLE_ACC\n+\t\t\t  || d->code == MMA_BUILTIN_DISASSEMBLE_PAIR));\n+\t  op[nopnds++] = build_pointer_type (void_type_node);\n+\t  if (attr & RS6000_BTC_QUAD)\n+\t    op[nopnds++] = build_pointer_type (vector_quad_type_node);\n+\t  else\n+\t    op[nopnds++] = build_pointer_type (vector_pair_type_node);\n+\t}\n+      else\n+\t{\n+\t  /* This is a normal MMA built-in function.  */\n+\t  unsigned j = (attr & RS6000_BTC_QUAD) ? 1 : 0;\n+\t  for (; j < insn_data[icode].n_operands; j++)\n+\t    {\n+\t      machine_mode mode = insn_data[icode].operand[j].mode;\n+\t      if (gimple_func && mode == PXImode)\n+\t\top[nopnds++] = build_pointer_type (vector_quad_type_node);\n+\t      else if (gimple_func && mode == POImode\n+\t\t       && d->code == MMA_BUILTIN_ASSEMBLE_PAIR)\n+\t\top[nopnds++] = build_pointer_type (vector_pair_type_node);\n+\t      else\n+\t\t/* MMA uses unsigned types.  */\n+\t\top[nopnds++] = builtin_mode_to_type[mode][1];\n+\t    }\n+\t}\n+\n+      switch (nopnds)\n+\t{\n+\tcase 1:\n+\t  type = build_function_type_list (op[0], NULL_TREE);\n+\t  break;\n+\tcase 2:\n+\t  type = build_function_type_list (op[0], op[1], NULL_TREE);\n+\t  break;\n+\tcase 3:\n+\t  type = build_function_type_list (op[0], op[1], op[2], NULL_TREE);\n+\t  break;\n+\tcase 4:\n+\t  type = build_function_type_list (op[0], op[1], op[2], op[3],\n+\t\t\t\t\t   NULL_TREE);\n+\t  break;\n+\tcase 5:\n+\t  type = build_function_type_list (op[0], op[1], op[2], op[3], op[4],\n+\t\t\t\t\t   NULL_TREE);\n+\t  break;\n+\tcase 6:\n+\t  type = build_function_type_list (op[0], op[1], op[2], op[3], op[4],\n+\t\t\t\t\t   op[5], NULL_TREE);\n+\t  break;\n+\tcase 7:\n+\t  type = build_function_type_list (op[0], op[1], op[2], op[3], op[4],\n+\t\t\t\t\t   op[5], op[6], NULL_TREE);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      def_builtin (d->name, type, d->code);\n+    }\n+}\n+\n static void\n htm_init_builtins (void)\n {\n@@ -13029,7 +13498,7 @@ htm_init_builtins (void)\n       HOST_WIDE_INT mask = d->mask;\n       unsigned attr = rs6000_builtin_info[d->code].attr;\n       bool void_func = (attr & RS6000_BTC_VOID);\n-      int attr_args = (attr & RS6000_BTC_TYPE_MASK);\n+      int attr_args = (attr & RS6000_BTC_OPND_MASK);\n       int nopnds = 0;\n       tree gpr_type_node;\n       tree rettype;\n@@ -13195,6 +13664,8 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n     case P8V_BUILTIN_VGBBD:\n     case MISC_BUILTIN_CDTBCD:\n     case MISC_BUILTIN_CBCDTD:\n+    case VSX_BUILTIN_XVCVSPBF16:\n+    case VSX_BUILTIN_XVCVBF16SP:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       break;"}, {"sha": "6bc070f9a3c8ea8fc87875830fe7a6de3a5f599e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -9941,7 +9941,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \n     case E_POImode:\n     case E_PXImode:\n-      if (CONSTANT_P (operands[1]))\n+      if (CONST_INT_P (operands[1]) && INTVAL (operands[1]) != 0)\n \terror (\"%qs is an opaque type, and you can't set it to other values.\",\n \t       (mode == POImode) ? \"__vector_pair\" : \"__vector_quad\");\n       break;\n@@ -12853,6 +12853,14 @@ print_operand (FILE *file, rtx x, int code)\n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n \t output_operand.  */\n \n+    case 'A':\n+      /* Write the MMA accumulator number associated with VSX register X.  */\n+      if (!REG_P (x) || !FP_REGNO_P (REGNO (x)) || (REGNO (x) % 4) != 0)\n+\toutput_operand_lossage (\"invalid %%A value\");\n+      else\n+\tfprintf (file, \"%d\", (REGNO (x) - FIRST_FPR_REGNO) / 4);\n+      return;\n+\n     case 'D':\n       /* Like 'J' but get to the GT bit only.  */\n       if (!REG_P (x) || !CR_REGNO_P (REGNO (x)))\n@@ -15963,6 +15971,12 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  unsigned offset = 0;\n \t  unsigned size = GET_MODE_SIZE (reg_mode);\n \n+\t  /* If we are reading an accumulator register, we have to\n+\t     deprime it before we can access it.  */\n+\t  if (TARGET_MMA\n+\t      && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\t    emit_insn (gen_mma_xxmfacc (src, src));\n+\n \t  for (int i = 0; i < nregs; i++)\n \t    {\n \t      unsigned subreg = (WORDS_BIG_ENDIAN)\n@@ -15991,6 +16005,32 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      emit_insn (gen_rtx_SET (dst2, src2));\n \t    }\n \n+\t  /* If we are writing an accumulator register, we have to\n+\t     prime it after we've written it.  */\n+\t  if (TARGET_MMA\n+\t      && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n+\n+\t  return;\n+\t}\n+\n+      if (GET_CODE (src) == UNSPEC)\n+\t{\n+\t  gcc_assert (REG_P (dst)\n+\t\t      && FP_REGNO_P (REGNO (dst))\n+\t\t      && XINT (src, 1) == UNSPEC_MMA_ASSEMBLE_ACC);\n+\n+\t  reg_mode = GET_MODE (XVECEXP (src, 0, 0));\n+\t  for (int i = 0; i < XVECLEN (src, 0); i++)\n+\t    {\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, reg + i);\n+\t      emit_insn (gen_rtx_SET (dst_i, XVECEXP (src, 0, i)));\n+\t    }\n+\n+\t  /* We are writing an accumulator register, so we have to\n+\t     prime it after we've written it.  */\n+\t  emit_insn (gen_mma_xxmtacc (dst, dst));\n+\n \t  return;\n \t}\n \n@@ -15999,6 +16039,12 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n   if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n     {\n+      /* If we are reading an accumulator register, we have to\n+\t deprime it before we can access it.  */\n+      if (TARGET_MMA\n+\t  && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\temit_insn (gen_mma_xxmfacc (src, src));\n+\n       /* Move register range backwards, if we might have destructive\n \t overlap.  */\n       int i;\n@@ -16007,6 +16053,12 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t\t\t\t     i * reg_mode_size),\n \t\t\t\tsimplify_gen_subreg (reg_mode, src, mode,\n \t\t\t\t\t\t     i * reg_mode_size)));\n+\n+      /* If we are writing an accumulator register, we have to\n+\t prime it after we've written it.  */\n+      if (TARGET_MMA\n+\t  && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\temit_insn (gen_mma_xxmtacc (dst, dst));\n     }\n   else\n     {\n@@ -16139,6 +16191,12 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));\n \t}\n \n+      /* If we are reading an accumulator register, we have to\n+\t deprime it before we can access it.  */\n+      if (TARGET_MMA && REG_P (src)\n+\t  && GET_MODE (src) == PXImode && FP_REGNO_P (REGNO (src)))\n+\temit_insn (gen_mma_xxmfacc (src, src));\n+\n       for (i = 0; i < nregs; i++)\n \t{\n \t  /* Calculate index to next subword.  */\n@@ -16156,6 +16214,13 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t\t  simplify_gen_subreg (reg_mode, src, mode,\n \t\t\t\t\t\t       j * reg_mode_size)));\n \t}\n+\n+      /* If we are writing an accumulator register, we have to\n+\t prime it after we've written it.  */\n+      if (TARGET_MMA && REG_P (dst)\n+\t  && GET_MODE (dst) == PXImode && FP_REGNO_P (REGNO (dst)))\n+\temit_insn (gen_mma_xxmtacc (dst, dst));\n+\n       if (restore_basereg != NULL_RTX)\n \temit_insn (restore_basereg);\n     }"}, {"sha": "eb22d5e4f016b463e2d1a90c355783da44409175", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -2251,20 +2251,24 @@ extern int frame_pointer_needed;\n    flags macros, but we've run out of bits, so we now map the options into new\n    settings used here.  */\n \n-/* Builtin attributes.  */\n-#define RS6000_BTC_SPECIAL\t0x00000000\t/* Special function.  */\n+/* Builtin operand count.  */\n #define RS6000_BTC_UNARY\t0x00000001\t/* normal unary function.  */\n #define RS6000_BTC_BINARY\t0x00000002\t/* normal binary function.  */\n #define RS6000_BTC_TERNARY\t0x00000003\t/* normal ternary function.  */\n #define RS6000_BTC_QUATERNARY\t0x00000004\t/* normal quaternary\n \t\t\t\t\t\t   function. */\n+#define RS6000_BTC_QUINARY\t0x00000005\t/* normal quinary function.  */\n+#define RS6000_BTC_SENARY\t0x00000006\t/* normal senary function.  */\n+#define RS6000_BTC_OPND_MASK\t0x00000007\t/* Mask to isolate operands. */\n \n-#define RS6000_BTC_PREDICATE\t0x00000005\t/* predicate function.  */\n-#define RS6000_BTC_ABS\t\t0x00000006\t/* Altivec/VSX ABS\n+/* Builtin attributes.  */\n+#define RS6000_BTC_SPECIAL\t0x00000000\t/* Special function.  */\n+#define RS6000_BTC_PREDICATE\t0x00000008\t/* predicate function.  */\n+#define RS6000_BTC_ABS\t\t0x00000010\t/* Altivec/VSX ABS\n \t\t\t\t\t\t   function.  */\n-#define RS6000_BTC_DST\t\t0x00000007\t/* Altivec DST function.  */\n+#define RS6000_BTC_DST\t\t0x00000020\t/* Altivec DST function.  */\n \n-#define RS6000_BTC_TYPE_MASK\t0x0000000f\t/* Mask to isolate types */\n+#define RS6000_BTC_TYPE_MASK\t0x0000003f\t/* Mask to isolate types */\n \n #define RS6000_BTC_MISC\t\t0x00000000\t/* No special attributes.  */\n #define RS6000_BTC_CONST\t0x00000100\t/* Neither uses, nor\n@@ -2273,13 +2277,18 @@ extern int frame_pointer_needed;\n \t\t\t\t\t\t   state/mem and does\n \t\t\t\t\t\t   not modify global state.  */\n #define RS6000_BTC_FP\t\t0x00000400\t/* depends on rounding mode.  */\n-#define RS6000_BTC_ATTR_MASK\t0x00000700\t/* Mask of the attributes.  */\n+#define RS6000_BTC_QUAD\t\t0x00000800\t/* Uses a register quad.  */\n+#define RS6000_BTC_PAIR\t\t0x00001000\t/* Uses a register pair.  */\n+#define RS6000_BTC_QUADPAIR\t0x00001800\t/* Uses a quad and a pair.  */\n+#define RS6000_BTC_ATTR_MASK\t0x00001f00\t/* Mask of the attributes.  */\n \n /* Miscellaneous information.  */\n #define RS6000_BTC_SPR\t\t0x01000000\t/* function references SPRs.  */\n #define RS6000_BTC_VOID\t\t0x02000000\t/* function has no return value.  */\n #define RS6000_BTC_CR\t\t0x04000000\t/* function references a CR.  */\n #define RS6000_BTC_OVERLOADED\t0x08000000\t/* function is overloaded.  */\n+#define RS6000_BTC_GIMPLE\t0x10000000\t/* function should be expanded\n+\t\t\t\t\t\t   into gimple.  */\n #define RS6000_BTC_MISC_MASK\t0x1f000000\t/* Mask of the misc info.  */\n \n /* Convenience macros to document the instruction type.  */\n@@ -2348,6 +2357,7 @@ extern int frame_pointer_needed;\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n \n@@ -2359,6 +2369,7 @@ extern int frame_pointer_needed;\n #define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n+#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n \n@@ -2377,6 +2388,7 @@ enum rs6000_builtins\n #undef RS6000_BUILTIN_A\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n+#undef RS6000_BUILTIN_M\n #undef RS6000_BUILTIN_P\n #undef RS6000_BUILTIN_X\n "}, {"sha": "67d7f38e5d0f58a93145a9aadad322531541b0d5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -203,7 +203,7 @@\n    vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,\n    vecfloat,vecfdiv,vecdouble,mffgpr,mftgpr,crypto,\n    veclogical,veccmpfx,vecexts,vecmove,\n-   htm,htmsimple,dfp\"\n+   htm,htmsimple,dfp,mma\"\n   (const_string \"integer\"))\n \n ;; What data size does this instruction work on?"}, {"sha": "342927abedabed033d010492ba68bca21b0e575d", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -296,6 +296,8 @@\n    UNSPEC_VSX_DIVUD\n    UNSPEC_VSX_MULSD\n    UNSPEC_VSX_SIGN_EXTEND\n+   UNSPEC_VSX_XVCVBF16SP\n+   UNSPEC_VSX_XVCVSPBF16\n    UNSPEC_VSX_XVCVSPSXDS\n    UNSPEC_VSX_VSLO\n    UNSPEC_VSX_EXTRACT\n@@ -346,6 +348,12 @@\n    UNSPEC_XXGENPCV\n   ])\n \n+(define_int_iterator XVCVBF16\t[UNSPEC_VSX_XVCVSPBF16\n+\t\t\t\t UNSPEC_VSX_XVCVBF16SP])\n+\n+(define_int_attr xvcvbf16       [(UNSPEC_VSX_XVCVSPBF16 \"xvcvspbf16\")\n+\t\t\t\t (UNSPEC_VSX_XVCVBF16SP \"xvcvbf16sp\")])\n+\n ;; VSX moves\n \n ;; The patterns for LE permuted loads and stores come before the general\n@@ -5676,3 +5684,10 @@\n   DONE;\n })\n \n+(define_insn \"vsx_<xvcvbf16>\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:V16QI [(match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")]\n+\t\t      XVCVBF16))]\n+  \"TARGET_FUTURE\"\n+  \"<xvcvbf16> %x0,%x1\"\n+  [(set_attr \"type\" \"vecfloat\")])"}, {"sha": "95f7192e41e46ccbaec68d09246d7a4473063bab", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -13858,6 +13858,7 @@ instructions, but allow the compiler to schedule those calls.\n * PowerPC AltiVec/VSX Built-in Functions::\n * PowerPC Hardware Transactional Memory Built-in Functions::\n * PowerPC Atomic Memory Operation Functions::\n+* PowerPC Matrix-Multiply Assist Built-in Functions::\n * RX Built-in Functions::\n * S/390 System z Built-in Functions::\n * SH Built-in Functions::\n@@ -21359,6 +21360,100 @@ void amo_stdat_smax (int64_t *, int64_t);\n void amo_stdat_smin (int64_t *, int64_t);\n @end smallexample\n \n+@node PowerPC Matrix-Multiply Assist Built-in Functions\n+@subsection PowerPC Matrix-Multiply Assist Built-in Functions\n+ISA 3.1 of the PowerPC added new Matrix-Multiply Assist (MMA) instructions.\n+GCC provides support for these instructions through the following built-in\n+functions which are enabled with the @code{-mmma} option.  The vec_t type\n+below is defined to be a normal vector unsigned char type.\u00a0 The uint2, uint4\n+and uint8 parameters are 2-bit, 4-bit and 8-bit unsigned integer constants\n+respectively.\u00a0 The compiler will verify that they are constants and that\n+their values are within range.\u00a0\n+\n+The built-in functions supported are:\n+\n+@smallexample\n+void __builtin_mma_xvi4ger8 (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi8ger4 (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi16ger2 (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi16ger2s (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf16ger2 (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvbf16ger2 (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf32ger (__vector_quad *, vec_t, vec_t);\n+\n+void __builtin_mma_xvi4ger8pp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi8ger4pp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi8ger4spp(__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi16ger2pp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvi16ger2spp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf16ger2pp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf16ger2pn (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf16ger2np (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf16ger2nn (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvbf16ger2pp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvbf16ger2pn (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvbf16ger2np (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvbf16ger2nn (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf32gerpp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf32gerpn (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf32gernp (__vector_quad *, vec_t, vec_t);\n+void __builtin_mma_xvf32gernn (__vector_quad *, vec_t, vec_t);\n+\n+void __builtin_mma_pmxvi4ger8 (__vector_quad *, vec_t, vec_t, uint4, uint4, uint8);\n+void __builtin_mma_pmxvi4ger8pp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint8);\n+\n+void __builtin_mma_pmxvi8ger4 (__vector_quad *, vec_t, vec_t, uint4, uint4, uint4);\n+void __builtin_mma_pmxvi8ger4pp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint4);\n+void __builtin_mma_pmxvi8ger4spp(__vector_quad *, vec_t, vec_t, uint4, uint4, uint4);\n+\n+void __builtin_mma_pmxvi16ger2 (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvi16ger2s (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvf16ger2 (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvbf16ger2 (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+\n+void __builtin_mma_pmxvi16ger2pp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvi16ger2spp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvf16ger2pp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvf16ger2pn (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvf16ger2np (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvf16ger2nn (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvbf16ger2pp (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvbf16ger2pn (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvbf16ger2np (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+void __builtin_mma_pmxvbf16ger2nn (__vector_quad *, vec_t, vec_t, uint4, uint4, uint2);\n+\n+void __builtin_mma_pmxvf32ger (__vector_quad *, vec_t, vec_t, uint4, uint4);\n+void __builtin_mma_pmxvf32gerpp (__vector_quad *, vec_t, vec_t, uint4, uint4);\n+void __builtin_mma_pmxvf32gerpn (__vector_quad *, vec_t, vec_t, uint4, uint4);\n+void __builtin_mma_pmxvf32gernp (__vector_quad *, vec_t, vec_t, uint4, uint4);\n+void __builtin_mma_pmxvf32gernn (__vector_quad *, vec_t, vec_t, uint4, uint4);\n+\n+void __builtin_mma_xvf64ger (__vector_quad *, __vector_pair, vec_t);\n+void __builtin_mma_xvf64gerpp (__vector_quad *, __vector_pair, vec_t);\n+void __builtin_mma_xvf64gerpn (__vector_quad *, __vector_pair, vec_t);\n+void __builtin_mma_xvf64gernp (__vector_quad *, __vector_pair, vec_t);\n+void __builtin_mma_xvf64gernn (__vector_quad *, __vector_pair, vec_t);\n+\n+void __builtin_mma_pmxvf64ger (__vector_quad *, __vector_pair, vec_t, uint4, uint2);\n+void __builtin_mma_pmxvf64gerpp (__vector_quad *, __vector_pair, vec_t, uint4, uint2);\n+void __builtin_mma_pmxvf64gerpn (__vector_quad *, __vector_pair, vec_t, uint4, uint2);\n+void __builtin_mma_pmxvf64gernp (__vector_quad *, __vector_pair, vec_t, uint4, uint2);\n+void __builtin_mma_pmxvf64gernn (__vector_quad *, __vector_pair, vec_t, uint4, uint2);\n+\n+void __builtin_mma_xxmtacc (__vector_quad *);\n+void __builtin_mma_xxmfacc (__vector_quad *);\n+void __builtin_mma_xxsetaccz (__vector_quad *);\n+\n+void __builtin_mma_assemble_acc (__vector_quad *, vec_t, vec_t, vec_t, vec_t);\n+void __builtin_mma_disassemble_acc (void *, __vector_quad *);\n+\n+void __builtin_mma_assemble_pair (__vector_pair *, vec_t, vec_t);\n+void __builtin_mma_disassemble_pair (void *, __vector_pair *);\n+\n+vec_t __builtin_vsx_xvcvspbf16 (vec_t);\n+vec_t __builtin_vsx_xvcvbf16sp (vec_t);\n+@end smallexample\n+\n @node RX Built-in Functions\n @subsection RX Built-in Functions\n GCC supports some of the RX instructions which cannot be expressed in"}, {"sha": "a971c869095acde79823e732d5635014fe3443ca", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-1.c", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-1.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,313 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+typedef unsigned char  vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo0 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvi4ger8 (&acc, vec0, vec1);\n+  __builtin_mma_xvi4ger8pp (&acc, vec0, vec1);\n+  dst[0] = acc;\n+}\n+\n+void\n+foo1 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvi8ger4 (&acc, vec0, vec1);\n+  __builtin_mma_xvi8ger4pp (&acc, vec0, vec1);\n+  __builtin_mma_xvi8ger4spp(&acc, vec0, vec1);\n+  dst[1] = acc;\n+}\n+\n+void\n+foo2 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvi16ger2 (&acc, vec0, vec1);\n+  __builtin_mma_xvi16ger2pp (&acc, vec0, vec1);\n+  dst[2] = acc;\n+}\n+\n+void\n+foo3 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvi16ger2s (&acc, vec0, vec1);\n+  __builtin_mma_xvi16ger2spp (&acc, vec0, vec1);\n+  dst[3] = acc;\n+}\n+\n+void\n+foo4 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvf16ger2 (&acc, vec0, vec1);\n+  __builtin_mma_xvf16ger2pp (&acc, vec0, vec1);\n+  __builtin_mma_xvf16ger2pn (&acc, vec0, vec1);\n+  dst[4] = acc;\n+}\n+\n+void\n+foo4b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_xvf16ger2np (&acc, vec0, vec1);\n+  __builtin_mma_xvf16ger2nn (&acc, vec0, vec1);\n+  dst[4] = acc;\n+}\n+\n+void\n+foo5 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvbf16ger2 (&acc, vec0, vec1);\n+  __builtin_mma_xvbf16ger2pp (&acc, vec0, vec1);\n+  __builtin_mma_xvbf16ger2pn (&acc, vec0, vec1);\n+  dst[5] = acc;\n+}\n+\n+void\n+foo5b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_xvbf16ger2np (&acc, vec0, vec1);\n+  __builtin_mma_xvbf16ger2nn (&acc, vec0, vec1);\n+  dst[5] = acc;\n+}\n+\n+void\n+foo6 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvf32ger (&acc, vec0, vec1);\n+  __builtin_mma_xvf32gerpp (&acc, vec0, vec1);\n+  __builtin_mma_xvf32gerpn (&acc, vec0, vec1);\n+  dst[6] = acc;\n+}\n+\n+void\n+foo6b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_xvf32gernp (&acc, vec0, vec1);\n+  __builtin_mma_xvf32gernn (&acc, vec0, vec1);\n+  dst[6] = acc;\n+}\n+\n+void\n+foo7 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvi4ger8 (&acc, vec0, vec1, 15, 15, 255);\n+  __builtin_mma_pmxvi4ger8pp (&acc, vec0, vec1, 15, 15, 255);\n+  dst[7] = acc;\n+}\n+\n+void\n+foo8 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvi8ger4 (&acc, vec0, vec1, 15, 15, 15);\n+  __builtin_mma_pmxvi8ger4pp (&acc, vec0, vec1, 15, 15, 15);\n+  __builtin_mma_pmxvi8ger4spp(&acc, vec0, vec1, 15, 15, 15);\n+  dst[8] = acc;\n+}\n+\n+void\n+foo9 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvi16ger2 (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvi16ger2pp (&acc, vec0, vec1, 15, 15, 3);\n+  dst[9] = acc;\n+}\n+\n+void\n+foo10 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvi16ger2s (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvi16ger2spp (&acc, vec0, vec1, 15, 15, 3);\n+  dst[10] = acc;\n+}\n+\n+void\n+foo11 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvf16ger2 (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvf16ger2pp (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvf16ger2pn (&acc, vec0, vec1, 15, 15, 3);\n+  dst[11] = acc;\n+}\n+\n+void\n+foo11b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_pmxvf16ger2np (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvf16ger2nn (&acc, vec0, vec1, 15, 15, 3);\n+  dst[11] = acc;\n+}\n+\n+void\n+foo12 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvbf16ger2 (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvbf16ger2pp (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvbf16ger2pn (&acc, vec0, vec1, 15, 15, 3);\n+  dst[12] = acc;\n+}\n+\n+void\n+foo12b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_pmxvbf16ger2np (&acc, vec0, vec1, 15, 15, 3);\n+  __builtin_mma_pmxvbf16ger2nn (&acc, vec0, vec1, 15, 15, 3);\n+  dst[12] = acc;\n+}\n+\n+void\n+foo13 (__vector_quad *dst, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_pmxvf32ger (&acc, vec0, vec1, 15, 15);\n+  __builtin_mma_pmxvf32gerpp (&acc, vec0, vec1, 15, 15);\n+  __builtin_mma_pmxvf32gerpn (&acc, vec0, vec1, 15, 15);\n+  dst[13] = acc;\n+}\n+\n+void\n+foo13b (__vector_quad *dst, __vector_quad *src, vec_t *vec)\n+{\n+  __vector_quad acc;\n+  vec_t vec0 = vec[0];\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_pmxvf32gernp (&acc, vec0, vec1, 15, 15);\n+  __builtin_mma_pmxvf32gernn (&acc, vec0, vec1, 15, 15);\n+  dst[13] = acc;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 40 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvp\\M} 12 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 40 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmfacc\\M} 20 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmtacc\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mxvbf16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvbf16ger2nn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvbf16ger2np\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvbf16ger2pn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvbf16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf16ger2nn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf16ger2np\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf16ger2pn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf32ger\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf32gernn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf32gernp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf32gerpn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf32gerpp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi16ger2s\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi16ger2spp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi4ger8\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi4ger8pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi8ger4\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi8ger4pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvi8ger4spp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvbf16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvbf16ger2nn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvbf16ger2np\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvbf16ger2pn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvbf16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf16ger2nn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf16ger2np\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf16ger2pn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf32ger\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf32gernn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf32gernp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf32gerpn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf32gerpp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi16ger2\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi16ger2pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi16ger2s\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi16ger2spp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi4ger8\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi4ger8pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi8ger4\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi8ger4pp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvi8ger4spp\\M} 1 } } */"}, {"sha": "cb8b30dd992d2db86f8c601c2111c21b2dc00092", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-2.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-2.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+typedef unsigned char  vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo0 (__vector_quad *dst, vec_t *vec, __vector_pair *pvecp)\n+{\n+  __vector_quad acc;\n+  __vector_pair vecp0 = *pvecp;\n+  vec_t vec1 = vec[1];\n+\n+  __builtin_mma_xvf64ger (&acc, vecp0, vec1);\n+  __builtin_mma_xvf64gerpp (&acc, vecp0, vec1);\n+  __builtin_mma_xvf64gerpn (&acc, vecp0, vec1);\n+  dst[0] = acc;\n+}\n+\n+void\n+foo1 (__vector_quad *dst, __vector_quad *src, vec_t *vec, __vector_pair *pvecp)\n+{\n+  __vector_quad acc;\n+  __vector_pair vecp0 = *pvecp;\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_xvf64gernp (&acc, vecp0, vec1);\n+  __builtin_mma_xvf64gernn (&acc, vecp0, vec1);\n+  dst[0] = acc;\n+}\n+\n+void\n+foo2 (__vector_quad *dst, vec_t *vec, __vector_pair *pvecp)\n+{\n+  __vector_quad acc;\n+  __vector_pair vecp0 = *pvecp;\n+  vec_t vec1 = vec[1];\n+  __builtin_mma_pmxvf64ger (&acc, vecp0, vec1, 15, 3);\n+  __builtin_mma_pmxvf64gerpp (&acc, vecp0, vec1, 15, 3);\n+  __builtin_mma_pmxvf64gerpn (&acc, vecp0, vec1, 15, 3);\n+  dst[1] = acc;\n+}\n+\n+void\n+foo3 (__vector_quad *dst, __vector_quad *src, vec_t *vec, __vector_pair *pvecp)\n+{\n+  __vector_quad acc;\n+  __vector_pair vecp0 = *pvecp;\n+  vec_t vec1 = vec[1];\n+\n+  acc = src[0];\n+  __builtin_mma_pmxvf64gernp (&acc, vecp0, vec1, 15, 3);\n+  __builtin_mma_pmxvf64gernn (&acc, vecp0, vec1, 15, 3);\n+  dst[1] = acc;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxmfacc\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmtacc\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvp\\M} 8 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 8 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf64ger\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf64gerpp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf64gerpn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf64gernp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvf64gernn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf64ger\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf64gerpp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf64gerpn\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf64gernp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mpmxvf64gernn\\M} 1 } } */"}, {"sha": "5406707061e55342c36d12bb1f97c776f4d45f4b", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-3.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+void\n+foo0 (void)\n+{\n+  __vector_quad acc;\n+  asm (\"#...\" : \"=d\" (acc));\n+  __builtin_mma_xxmtacc (&acc);\n+  __builtin_mma_xxmfacc (&acc);\n+  asm (\"#...\" :: \"d\" (acc));\n+}\n+\n+typedef unsigned char  vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo1 (vec_t *vec)\n+{\n+  vec[1] = __builtin_vsx_xvcvspbf16 (vec[0]);\n+  vec[3] = __builtin_vsx_xvcvbf16sp (vec[2]);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxmtacc\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmfacc\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M} 2 } } */\n+/* { dg-final { scan-assembler-not {\\mlxvp\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mstxvp\\M} } } */\n+/* { dg-final { scan-assembler-times {\\mxvcvspbf16\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxvcvbf16sp\\M} 1 } } */"}, {"sha": "138d1b46bc4f11a779b38aeebec4e2ac1c01f6a9", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-4.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+typedef unsigned char vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo (__vector_pair *dst, vec_t *src)\n+{\n+  __vector_pair pair;\n+  __builtin_mma_assemble_pair (&pair, src[0], src[4]);\n+  *dst = pair;\n+}\n+\n+void\n+bar (vec_t *dst, __vector_pair *src)\n+{\n+  vec_t res[2];\n+  __builtin_mma_disassemble_pair (res, src);\n+  dst[0] = res[0];\n+  dst[4] = res[1];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 1 } } */\n+"}, {"sha": "0ee45b6bdfd882b07b0e6e4c59a3179afabd4f8d", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-5.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+typedef unsigned char vec_t __attribute__((vector_size(16)));\n+\n+void\n+foo (__vector_quad *dst, vec_t *src)\n+{\n+  __vector_quad acc;\n+  __builtin_mma_assemble_acc (&acc, src[0], src[4], src[8], src[12]);\n+  *dst = acc;\n+}\n+\n+void\n+bar (vec_t *dst, __vector_quad *src)\n+{\n+  vec_t res[4];\n+  __builtin_mma_disassemble_acc (res, src);\n+  dst[0] = res[0];\n+  dst[4] = res[1];\n+  dst[8] = res[2];\n+  dst[12] = res[3];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmfacc\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmtacc\\M} 2 } } */"}, {"sha": "c0b5eedd3d173242f1db124e67cf2641b838b2b6", "filename": "gcc/testsuite/gcc.target/powerpc/mma-builtin-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee2640bfdc62f835ec9740278f948034bc7d9f1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-builtin-6.c?ref=8ee2640bfdc62f835ec9740278f948034bc7d9f1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_future_ok } */\n+/* { dg-options \"-Wno-psabi -mdejagnu-cpu=future -O2\" } */\n+\n+void\n+foo (__vector_quad *dst)\n+{\n+  __vector_quad acc;\n+  __builtin_mma_xxsetaccz (&acc);\n+  *dst = acc;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\mlxv\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mlxvp\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mxxmtacc\\M} } } */\n+/* { dg-final { scan-assembler-times {\\mxxsetaccz\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mxxmfacc\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvp\\M} 2 } } */"}]}