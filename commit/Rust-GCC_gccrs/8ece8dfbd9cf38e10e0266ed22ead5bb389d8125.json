{"sha": "8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjZThkZmJkOWNmMzhlMTBlMDI2NmVkMjJlYWQ1YmIzODlkODEyNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-11-20T01:26:00Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-11-20T01:26:00Z"}, "message": "C++ FE: offer suggestions for misspelled field names\n\ngcc/c/ChangeLog:\n\t* c-typeck.c (lookup_field_fuzzy): Move determination of closest\n\tcandidate into a new function, find_closest_identifier.\n\ngcc/cp/ChangeLog:\n\t* cp-tree.h (lookup_member_fuzzy): New decl.\n\t* search.c: Include spellcheck.h.\n\t(class lookup_field_fuzzy_info): New class.\n\t(lookup_field_fuzzy_info::fuzzy_lookup_fnfields): New.\n\t(lookup_field_fuzzy_info::fuzzy_lookup_field): New.\n\t(lookup_field_fuzzy_r): New.\n\t(lookup_member_fuzzy): New.\n\t* typeck.c (finish_class_member_access_expr): When issuing\n\ta \"has no member named\" error, call lookup_member_fuzzy, and\n\toffer any result as a suggestion.\n\ngcc/ChangeLog:\n\t* spellcheck-tree.c (find_closest_identifier): New function, taken\n\tfrom c/c-typeck.c:lookup_field_fuzzy, with NULL corrected to\n\tNULL_TREE in two places.\n\t* spellcheck.h (find_closest_identifier): New decl.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/spellcheck-fields.C: New file.\n\nFrom-SVN: r230638", "tree": {"sha": "3572616c35cc69549b3ff9761e6d1af8fb70780b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3572616c35cc69549b3ff9761e6d1af8fb70780b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32c912aad1f29233f15da6baf33c765e3b6213fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c912aad1f29233f15da6baf33c765e3b6213fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c912aad1f29233f15da6baf33c765e3b6213fd"}], "stats": {"total": 252, "additions": 222, "deletions": 30}, "files": [{"sha": "9399053a7f9f5375c4aa6ff7bd4ad42e1e09858b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -1,3 +1,8 @@\n+2015-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-typeck.c (lookup_field_fuzzy): Move determination of closest\n+\tcandidate into a new function, find_closest_identifier.\n+\n 2015-11-19  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/68412"}, {"sha": "9284bfcea66e464a679609792ffb59f348b76439", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -2274,33 +2274,7 @@ lookup_field_fuzzy (tree type, tree component)\n   lookup_field_fuzzy_find_candidates (type, component,\n \t\t\t\t      &candidates);\n \n-  /* Now determine which is closest.  */\n-  int i;\n-  tree identifier;\n-  tree best_identifier = NULL;\n-  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n-  FOR_EACH_VEC_ELT (candidates, i, identifier)\n-    {\n-      gcc_assert (TREE_CODE (identifier) == IDENTIFIER_NODE);\n-      edit_distance_t dist = levenshtein_distance (component, identifier);\n-      if (dist < best_distance)\n-\t{\n-\t  best_distance = dist;\n-\t  best_identifier = identifier;\n-\t}\n-    }\n-\n-  /* If more than half of the letters were misspelled, the suggestion is\n-     likely to be meaningless.  */\n-  if (best_identifier)\n-    {\n-      unsigned int cutoff = MAX (IDENTIFIER_LENGTH (component),\n-\t\t\t\t IDENTIFIER_LENGTH (best_identifier)) / 2;\n-      if (best_distance > cutoff)\n-\treturn NULL;\n-    }\n-\n-  return best_identifier;\n+  return find_closest_identifier (component, &candidates);\n }\n \n /* Make an expression to refer to the COMPONENT field of structure or"}, {"sha": "cf436d7d106bfe51c3e73cf66387c6638470e4ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -1,3 +1,16 @@\n+2015-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cp-tree.h (lookup_member_fuzzy): New decl.\n+\t* search.c: Include spellcheck.h.\n+\t(class lookup_field_fuzzy_info): New class.\n+\t(lookup_field_fuzzy_info::fuzzy_lookup_fnfields): New.\n+\t(lookup_field_fuzzy_info::fuzzy_lookup_field): New.\n+\t(lookup_field_fuzzy_r): New.\n+\t(lookup_member_fuzzy): New.\n+\t* typeck.c (finish_class_member_access_expr): When issuing\n+\ta \"has no member named\" error, call lookup_member_fuzzy, and\n+\toffer any result as a suggestion.\n+\n 2015-11-19  Torvald Riegel  <triegel@redhat.com>\n \n \t* except.c (do_free_exception): Use transactional wrapper."}, {"sha": "38bd7dd614ffb5f7735e20eb10c2d89fe35307c4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -6152,6 +6152,7 @@ extern int class_method_index_for_fn\t\t(tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree lookup_member_fuzzy\t\t(tree, tree, bool);\n extern int look_for_overrides\t\t\t(tree, tree);\n extern void get_pure_virtuals\t\t\t(tree);\n extern void maybe_suppress_debug_info\t\t(tree);"}, {"sha": "0c11a8318cb2388287aee78e8306deaff446b9ef", "filename": "gcc/cp/search.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"intl.h\"\n #include \"toplev.h\"\n+#include \"spellcheck.h\"\n \n static int is_subobject_of_p (tree, tree);\n static tree dfs_lookup_base (tree, void *);\n@@ -1352,6 +1353,144 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n   return rval;\n }\n \n+/* Helper class for lookup_member_fuzzy.  */\n+\n+class lookup_field_fuzzy_info\n+{\n+ public:\n+  lookup_field_fuzzy_info (bool want_type_p) :\n+    m_want_type_p (want_type_p), m_candidates () {}\n+\n+  void fuzzy_lookup_fnfields (tree type);\n+  void fuzzy_lookup_field (tree type);\n+\n+  /* If true, we are looking for types, not data members.  */\n+  bool m_want_type_p;\n+  /* The result: a vec of identifiers.  */\n+  auto_vec<tree> m_candidates;\n+};\n+\n+/* Locate all methods within TYPE, append them to m_candidates.  */\n+\n+void\n+lookup_field_fuzzy_info::fuzzy_lookup_fnfields (tree type)\n+{\n+  vec<tree, va_gc> *method_vec;\n+  tree fn;\n+  size_t i;\n+\n+  if (!CLASS_TYPE_P (type))\n+    return;\n+\n+  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  if (!method_vec)\n+    return;\n+\n+  for (i = 0; vec_safe_iterate (method_vec, i, &fn); ++i)\n+    if (fn)\n+      m_candidates.safe_push (DECL_NAME (OVL_CURRENT (fn)));\n+}\n+\n+/* Locate all fields within TYPE, append them to m_candidates.  */\n+\n+void\n+lookup_field_fuzzy_info::fuzzy_lookup_field (tree type)\n+{\n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n+      || TREE_CODE (type) == TYPENAME_TYPE)\n+    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and\n+       BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;\n+       instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.\n+       The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */\n+    return;\n+\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (!m_want_type_p || DECL_DECLARES_TYPE_P (field))\n+\tif (DECL_NAME (field))\n+\t  m_candidates.safe_push (DECL_NAME (field));\n+    }\n+}\n+\n+\n+/* Helper function for lookup_member_fuzzy, called via dfs_walk_all\n+   DATA is really a lookup_field_fuzzy_info.  Look for a field with\n+   the name indicated there in BINFO.  Gathers pertinent identifiers into\n+   m_candidates.  */\n+\n+static tree\n+lookup_field_fuzzy_r (tree binfo, void *data)\n+{\n+  lookup_field_fuzzy_info *lffi = (lookup_field_fuzzy_info *) data;\n+  tree type = BINFO_TYPE (binfo);\n+\n+  /* First, look for functions.  */\n+  if (!lffi->m_want_type_p)\n+    lffi->fuzzy_lookup_fnfields (type);\n+\n+  /* Look for data member and types.  */\n+  lffi->fuzzy_lookup_field (type);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Like lookup_member, but try to find the closest match for NAME,\n+   rather than an exact match, and return an identifier (or NULL_TREE).\n+   Do not complain.  */\n+\n+tree\n+lookup_member_fuzzy (tree xbasetype, tree name, bool want_type_p)\n+{\n+  tree type = NULL_TREE, basetype_path = NULL_TREE;\n+  struct lookup_field_fuzzy_info lffi (want_type_p);\n+\n+  /* rval_binfo is the binfo associated with the found member, note,\n+     this can be set with useful information, even when rval is not\n+     set, because it must deal with ALL members, not just non-function\n+     members.  It is used for ambiguity checking and the hidden\n+     checks.  Whereas rval is only set if a proper (not hidden)\n+     non-function member is found.  */\n+\n+  if (name == error_mark_node\n+      || xbasetype == NULL_TREE\n+      || xbasetype == error_mark_node)\n+    return NULL_TREE;\n+\n+  gcc_assert (identifier_p (name));\n+\n+  if (TREE_CODE (xbasetype) == TREE_BINFO)\n+    {\n+      type = BINFO_TYPE (xbasetype);\n+      basetype_path = xbasetype;\n+    }\n+  else\n+    {\n+      if (!RECORD_OR_UNION_CODE_P (TREE_CODE (xbasetype)))\n+\treturn NULL_TREE;\n+      type = xbasetype;\n+      xbasetype = NULL_TREE;\n+    }\n+\n+  type = complete_type (type);\n+\n+  /* Make sure we're looking for a member of the current instantiation in the\n+     right partial specialization.  */\n+  if (flag_concepts && dependent_type_p (type))\n+    type = currently_open_class (type);\n+\n+  if (!basetype_path)\n+    basetype_path = TYPE_BINFO (type);\n+\n+  if (!basetype_path)\n+    return NULL_TREE;\n+\n+  /* Populate lffi.m_candidates.  */\n+  dfs_walk_all (basetype_path, &lookup_field_fuzzy_r, NULL, &lffi);\n+\n+  return find_closest_identifier (name, &lffi.m_candidates);\n+}\n+\n /* Like lookup_member, except that if we find a function member we\n    return NULL_TREE.  */\n "}, {"sha": "95178905f9e5884fc4c32a13bad36afac0317d0a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -2792,9 +2792,18 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t  if (member == NULL_TREE)\n \t    {\n \t      if (complain & tf_error)\n-\t\terror (\"%q#T has no member named %qE\",\n-\t\t       TREE_CODE (access_path) == TREE_BINFO\n-\t\t       ? TREE_TYPE (access_path) : object_type, name);\n+\t\t{\n+\t\t  tree guessed_id = lookup_member_fuzzy (access_path, name,\n+\t\t\t\t\t\t\t /*want_type=*/false);\n+\t\t  if (guessed_id)\n+\t\t    error (\"%q#T has no member named %qE; did you mean %qE?\",\n+\t\t\t   TREE_CODE (access_path) == TREE_BINFO\n+\t\t\t   ? TREE_TYPE (access_path) : object_type, name, guessed_id);\n+\t\t  else\n+\t\t    error (\"%q#T has no member named %qE\",\n+\t\t\t   TREE_CODE (access_path) == TREE_BINFO\n+\t\t\t   ? TREE_TYPE (access_path) : object_type, name);\n+\t\t}\n \t      return error_mark_node;\n \t    }\n \t  if (member == error_mark_node)"}, {"sha": "f7fbcc0be32d7c767a1220de9a54460f71ba412f", "filename": "gcc/spellcheck-tree.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fspellcheck-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fspellcheck-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck-tree.c?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -37,3 +37,44 @@ levenshtein_distance (tree ident_s, tree ident_t)\n \t\t\t       IDENTIFIER_POINTER (ident_t),\n \t\t\t       IDENTIFIER_LENGTH (ident_t));\n }\n+\n+/* Given TARGET, an identifier, and CANDIDATES, a vec of identifiers,\n+   determine which element within CANDIDATES has the lowest edit\n+   distance to TARGET.  If there are multiple elements with the\n+   same minimal distance, the first in the vector wins.\n+\n+   If more than half of the letters were misspelled, the suggestion is\n+   likely to be meaningless, so return NULL_TREE for this case.  */\n+\n+tree\n+find_closest_identifier (tree target, const auto_vec<tree> *candidates)\n+{\n+  gcc_assert (TREE_CODE (target) == IDENTIFIER_NODE);\n+\n+  int i;\n+  tree identifier;\n+  tree best_identifier = NULL_TREE;\n+  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n+  FOR_EACH_VEC_ELT (*candidates, i, identifier)\n+    {\n+      gcc_assert (TREE_CODE (identifier) == IDENTIFIER_NODE);\n+      edit_distance_t dist = levenshtein_distance (target, identifier);\n+      if (dist < best_distance)\n+\t{\n+\t  best_distance = dist;\n+\t  best_identifier = identifier;\n+\t}\n+    }\n+\n+  /* If more than half of the letters were misspelled, the suggestion is\n+     likely to be meaningless.  */\n+  if (best_identifier)\n+    {\n+      unsigned int cutoff = MAX (IDENTIFIER_LENGTH (target),\n+\t\t\t\t IDENTIFIER_LENGTH (best_identifier)) / 2;\n+      if (best_distance > cutoff)\n+\treturn NULL_TREE;\n+    }\n+\n+  return best_identifier;\n+}"}, {"sha": "ad029985de2c780f810959d9fb36d43b175782da", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -23,14 +23,20 @@ along with GCC; see the file COPYING3.  If not see\n typedef unsigned int edit_distance_t;\n const edit_distance_t MAX_EDIT_DISTANCE = UINT_MAX;\n \n+/* spellcheck.c  */\n extern edit_distance_t\n levenshtein_distance (const char *s, int len_s,\n \t\t      const char *t, int len_t);\n \n extern edit_distance_t\n levenshtein_distance (const char *s, const char *t);\n \n+/* spellcheck-tree.c  */\n+\n extern edit_distance_t\n levenshtein_distance (tree ident_s, tree ident_t);\n \n+extern tree\n+find_closest_identifier (tree target, const auto_vec<tree> *candidates);\n+\n #endif  /* GCC_SPELLCHECK_H  */"}, {"sha": "face304aaaeecd73bfd18fbb2923a0932708a940", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ece8dfbd9cf38e10e0266ed22ead5bb389d8125/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ece8dfbd9cf38e10e0266ed22ead5bb389d8125", "patch": "@@ -1,3 +1,7 @@\n+2015-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/spellcheck-fields.C: New file.\n+\n 2015-11-19  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}]}