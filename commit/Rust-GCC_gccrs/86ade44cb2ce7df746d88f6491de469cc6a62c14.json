{"sha": "86ade44cb2ce7df746d88f6491de469cc6a62c14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhZGU0NGNiMmNlN2RmNzQ2ZDg4ZjY0OTFkZTQ2OWNjNmE2MmMxNA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-11-28T04:07:11Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-11-28T04:07:11Z"}, "message": "Numeric facets cleanup.\n\n\n2001-11-27  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tNumeric facets cleanup.\n\t* include/bits/locale_facets.h (__num_base::_S_atoms): Add, remove\n\t+ and - signs.\n\t(__num_base::_M_zero): Add\n\t(__num_base::_M_e): Add.\n\t(__num_base::_M_E): Add.\n\t* include/bits/locale_facets.tcc (num_get::_M_extract): Remove.\n\t(num_get::_M_extract_float): New.\n\t(num_get::_M_extract_int): New.\n\t* src/locale.cc (num_get::_M_extract): Remove.\n\n\t* include/bits/locale_facets.tcc (num_put::_M_insert_float):\n\tSimplify, use _M_insert.\n\t(num_put::do_put(bool)): Simplify, remove __pad.\n\t(__pad): Remove.\n\t(__pad_output): Change to __pad.\n\t* include/bits/ostream.tcc: And here.\n\t* src/locale-inst: Remove instantiations.\n\n\t* include/bits/locale_facets.h: Move helper functions in to class\n\tnum_put.\n\t(num_put::_M_insert_float): Same, for __output_integer.\n\t(num_put::_M_insert_int): Same, for __output_float.\n\t(num_put::_M_insert): New.\n\t(__num_base): Add.\n\t(__num_base::_S_format_float): Move\n\t__build_float_format into class __num_base.\n\t(__num_base::_S_format_int): Move __build_int_format into class\n\t__num_base.\n\t* include/bits/locale_facets.tcc (__group_digits): Change to\n\t(__add_grouping): This.\n\t* src/locale-inst.cc: And here. Tweak instantiations.\n\t* src/misc-inst.cc: Remove instantiations.\n\n\t* include/bits/ostream.tcc (__pad_char): Rename, adjust inserters\n\tfor new calling conventions, move to...\n\t* include/bits/locale_facets.tcc (__pad_output): Here. Adjust\n\tsignature to make it useful for both ostream and num_put.\n\t(__pad_numeric): Remove.\n\t* src/misc-inst.cc: Remove instantiations.\n\t* src/locale-inst.cc: Same.\n\n\t* include/bits/locale_facets.h (_Numeric_get): Remove.\n \t(_Numeric_put): Remove.\n\t(num_get::get(short)): Remove.\n\t(num_get::get(int)): Remove.\n\t(num_get::do_get(short)): Remove.\n\t(num_get::do_get(int)): Remove.\n\t* include/bits/istream.tcc (istream::operator>>(short)): Fix as\n\tper DR 118.\n\t(istream::operator>>(int)): Same.\n\n\t* include/bits/locale_facets.h (_Format_cache): Remove.\n\t* include/bits/locale_facets.tcc: Same.\n\t* src/locale.cc: Same.\n\t* src/locale-inst.cc: Same.\n\t* include/bits/ostream.tcc: Same.\n\t* src/ios.cc (ios_base::imbue): Remove here as well.\n\n\t* testsuite/22_locale/num_get.cc: New file.\n\t* testsuite/22_locale/num_get_members_char.cc: New file.\n\t* testsuite/22_locale/num_get_members_wchar_t.cc: New.\n\t* testsuite/22_locale/numpunct_members_wchar_t.cc: New file.\n\t* testsuite/22_locale/num_put.cc: New file.\n\t* testsuite/22_locale/num_put_members_char.cc: New file.\n\t* testsuite/22_locale/num_put_members_wchar_t.cc: New file.\n\t* testsuite/27_io/ostream_inserter_arith.cc: Fix.\n\t* testsuite/27_io/istream_extractor_arith.cc: Fix.\n\nFrom-SVN: r47397", "tree": {"sha": "380194f66bfb9788787766fc8976be2167e9d145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/380194f66bfb9788787766fc8976be2167e9d145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ade44cb2ce7df746d88f6491de469cc6a62c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ade44cb2ce7df746d88f6491de469cc6a62c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ade44cb2ce7df746d88f6491de469cc6a62c14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ade44cb2ce7df746d88f6491de469cc6a62c14/comments", "author": null, "committer": null, "parents": [{"sha": "59a64a46e0b90adb1dce2d19c42630edcd6374d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a64a46e0b90adb1dce2d19c42630edcd6374d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a64a46e0b90adb1dce2d19c42630edcd6374d1"}], "stats": {"total": 3305, "additions": 1892, "deletions": 1413}, "files": [{"sha": "b86bf98c08a16abfab0a8ea538861becf388df0e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -1,3 +1,74 @@\n+2001-11-27  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tNumeric facets cleanup.\n+\t* include/bits/locale_facets.h (__num_base::_S_atoms): Add, remove\n+\t+ and - signs.\n+\t(__num_base::_M_zero): Add\n+\t(__num_base::_M_e): Add.\n+\t(__num_base::_M_E): Add.\t\n+\t* include/bits/locale_facets.tcc (num_get::_M_extract): Remove.\n+\t(num_get::_M_extract_float): New.\n+\t(num_get::_M_extract_int): New.\n+\t* src/locale.cc (num_get::_M_extract): Remove.\n+\t\n+\t* include/bits/locale_facets.tcc (num_put::_M_insert_float):\n+\tSimplify, use _M_insert.\n+\t(num_put::do_put(bool)): Simplify, remove __pad. \n+\t(__pad): Remove.\n+\t(__pad_output): Change to __pad.\n+\t* include/bits/ostream.tcc: And here.\n+\t* src/locale-inst: Remove instantiations.\n+\n+\t* include/bits/locale_facets.h: Move helper functions in to class\n+\tnum_put.\n+\t(num_put::_M_insert_float): Same, for __output_integer.\n+\t(num_put::_M_insert_int): Same, for __output_float.\n+\t(num_put::_M_insert): New.\n+\t(__num_base): Add.\n+\t(__num_base::_S_format_float): Move\n+\t__build_float_format into class __num_base.\n+\t(__num_base::_S_format_int): Move __build_int_format into class\n+\t__num_base.\n+\t* include/bits/locale_facets.tcc (__group_digits): Change to\n+\t(__add_grouping): This.\n+\t* src/locale-inst.cc: And here. Tweak instantiations.\n+\t* src/misc-inst.cc: Remove instantiations.\n+\t\n+\t* include/bits/ostream.tcc (__pad_char): Rename, adjust inserters\n+\tfor new calling conventions, move to...\n+\t* include/bits/locale_facets.tcc (__pad_output): Here. Adjust\n+\tsignature to make it useful for both ostream and num_put.\n+\t(__pad_numeric): Remove.\n+\t* src/misc-inst.cc: Remove instantiations.\n+\t* src/locale-inst.cc: Same.\n+\n+\t* include/bits/locale_facets.h (_Numeric_get): Remove.\n+ \t(_Numeric_put): Remove.\n+\t(num_get::get(short)): Remove.\n+\t(num_get::get(int)): Remove.\t\n+\t(num_get::do_get(short)): Remove.\n+\t(num_get::do_get(int)): Remove.\t\n+\t* include/bits/istream.tcc (istream::operator>>(short)): Fix as\n+\tper DR 118.\n+\t(istream::operator>>(int)): Same.\n+\n+\t* include/bits/locale_facets.h (_Format_cache): Remove.\n+\t* include/bits/locale_facets.tcc: Same.\n+\t* src/locale.cc: Same.\n+\t* src/locale-inst.cc: Same.\n+\t* include/bits/ostream.tcc: Same.\n+\t* src/ios.cc (ios_base::imbue): Remove here as well.\n+\n+\t* testsuite/22_locale/num_get.cc: New file.\n+\t* testsuite/22_locale/num_get_members_char.cc: New file.\n+\t* testsuite/22_locale/num_get_members_wchar_t.cc: New.\n+\t* testsuite/22_locale/numpunct_members_wchar_t.cc: New file.\n+\t* testsuite/22_locale/num_put.cc: New file.\n+\t* testsuite/22_locale/num_put_members_char.cc: New file.\n+\t* testsuite/22_locale/num_put_members_wchar_t.cc: New file.\n+\t* testsuite/27_io/ostream_inserter_arith.cc: Fix.\n+\t* testsuite/27_io/istream_extractor_arith.cc: Fix.\n+\t\n 2001-11-27  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/explanations.html:  New section, empty for now."}, {"sha": "43ea6a5a37e32f59a10a9bd1e22179b2988e15cf", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -134,8 +134,18 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n+\t      long __l;\n \t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t\t_M_fnumget->get(*this, 0, *this, __err, __l);\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+\t      // 118. basic_istream uses nonexistent num_get member functions.\n+\t      if (!(__err & ios_base::failbit)\n+\t\t  && (numeric_limits<short>::min() <= __l \n+\t\t      && __l <= numeric_limits<short>::max()))\n+\t\t__n = __l;\n+\t      else\n+                __err |= ios_base::failbit;\n+#endif\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -188,8 +198,18 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n+\t      long __l;\n \t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t\t_M_fnumget->get(*this, 0, *this, __err, __l);\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+\t      // 118. basic_istream uses nonexistent num_get member functions.\n+\t      if (!(__err & ios_base::failbit)\n+\t\t  && (numeric_limits<int>::min() <= __l \n+\t\t      && __l <= numeric_limits<int>::max()))\n+\t\t__n = __l;\n+\t      else\n+                __err |= ios_base::failbit;\n+#endif\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -1252,4 +1272,3 @@ namespace std\n // Local Variables:\n // mode:C++\n // End:\n-"}, {"sha": "878f8b28cabc68a8d2796374e8bb84c5739c037c", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 195, "deletions": 343, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -415,162 +415,157 @@ namespace std\n   // 22.2.1.5  Template class codecvt\n   #include <bits/codecvt.h>\n \n-  template<typename _CharT, typename _InIter>\n-    class _Numeric_get;  // forward\n \n-  // _Format_cache holds the information extracted from the numpunct<>\n-  // and moneypunct<> facets in a form optimized for parsing and\n-  // formatting.  It is stored via a void* pointer in the pword()\n-  // array of an iosbase object passed to the _get and _put facets.\n-  // NB: contains no user-serviceable parts.\n+  class __num_base\n+  {\n+  public:\n+    // String literal of acceptable (narrow) input, for num_get.\n+    // \"0123456789eEabcdfxABCDFX\"\n+    static const char _S_atoms[];\n+\n+    enum \n+    {  \n+      _M_zero,\n+      _M_e = _M_zero + 10,\n+      _M_E = _M_zero + 11,\n+      _M_size = 23 + 1\n+    };\n+\n+    // Construct and return valid scanf format for floating point types.\n+    static bool\n+    _S_format_float(const ios_base& __io, char* __fptr, char __mod, \n+\t\t    streamsize __prec);\n+    \n+    // Construct and return valid scanf format for integer types.\n+    static void\n+    _S_format_int(const ios_base& __io, char* __fptr, char __mod, char __modl);\n+  };\n+\n   template<typename _CharT>\n-    class _Format_cache\n+    class numpunct : public locale::facet\n     {\n-    public: \n+    public:\n       // Types:\n-      typedef _CharT \t\t\t\tchar_type;\n-      typedef char_traits<_CharT> \t\ttraits_type;\n-      typedef basic_string<_CharT>\t\tstring_type;\n-      typedef typename string_type::size_type\tsize_type;\n-\n-      // Forward decls and Friends:\n-      friend class locale;\n-      template<typename _Char, typename _InIter>\n-        friend class _Numeric_get;\n-      friend class num_get<_CharT>;\n-      friend class num_put<_CharT>;\n-      friend class time_get<_CharT>;\n-      friend class money_get<_CharT>;\n-      friend class time_put<_CharT>;\n-      friend class money_put<_CharT>;\n+      typedef _CharT          \t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n \n-      // Data Members:\n+      static locale::id \t\tid;\n \n-      // ios_base::pword() reserved cell\n-      static int \t\t_S_pword_ix; \n-\n-      // True iff data members are consistent with the current locale,\n-      // ie imbue sets this to false.\n-      bool \t\t\t_M_valid;\n-\n-      // A list of valid numeric literals: for the standard \"C\" locale,\n-      // this would usually be: \"-+xX0123456789abcdef0123456789ABCDEF\"\n-      static const char \t_S_literals[];\n-\n-      // NB: Code depends on the order of definitions of the names\n-      // these are indices into _S_literals, above.\n-      // This string is formatted for putting, not getting. (output, not input)\n-      enum \n-      {  \n-\t_S_minus, \n-\t_S_plus, \n-\t_S_x, \n-\t_S_X, \n-\t_S_digits,\n-\t_S_digits_end = _S_digits + 16,\n-\t_S_udigits = _S_digits_end,  \n-\t_S_udigits_end = _S_udigits + 16,\n-\t_S_ee = _S_digits + 14, // For scientific notation, 'E'\n-\t_S_Ee = _S_udigits + 14 // For scientific notation, 'e'\n-      };\n-\n-      // The sign used to separate decimal values: for standard US\n-      // locales, this would usually be: \".\"\n-      // Abstracted from numpunct::decimal_point().\n-      char_type \t\t_M_decimal_point;\n-\n-      // The sign used to separate groups of digits into smaller\n-      // strings that the eye can parse with less difficulty: for\n-      // standard US locales, this would usually be: \",\"\n-      // Abstracted from numpunct::thousands_sep().\n-      char_type\t\t\t_M_thousands_sep;\n-\n-      // However the US's \"false\" and \"true\" are translated.\n-      // From numpunct::truename() and numpunct::falsename(), respectively.\n-      string_type \t\t_M_truename;\n-      string_type \t\t_M_falsename;\n-\n-      // If we are checking groupings. This should be equivalent to \n-      // numpunct::groupings().size() != 0\n-      bool \t\t\t_M_use_grouping;\n-\n-      // If we are using numpunct's groupings, this is the current\n-      // grouping string in effect (from numpunct::grouping()).\n-      string \t\t\t_M_grouping;\n-\n-      _Format_cache();\n-\n-      ~_Format_cache() throw() { }\n-\n-      // Given a member of the ios hierarchy as an argument, extract\n-      // out all the current formatting information into a\n-      // _Format_cache object and return a pointer to it.\n-      static _Format_cache<_CharT>* \n-      _S_get(ios_base& __ios);\n+    private:\n+      char_type \t\t\t_M_decimal_point;\n+      char_type \t\t\t_M_thousands_sep;\n+      string \t\t\t\t_M_grouping;\n+      string_type \t\t\t_M_truename;\n+      string_type \t\t\t_M_falsename;\n \n-      void \n-      _M_populate(ios_base&);\n+    public:\n+      explicit \n+      numpunct(size_t __refs = 0) : locale::facet(__refs) \n+      { _M_initialize_numpunct(); }\n+\n+      explicit \n+      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs) \n+      { _M_initialize_numpunct(__cloc); }\n+\n+      char_type    \n+      decimal_point() const\n+      { return this->do_decimal_point(); }\n+\n+      char_type    \n+      thousands_sep() const\n+      { return this->do_thousands_sep(); }\n+\n+      string       \n+      grouping() const\n+      { return this->do_grouping(); }\n+\n+      string_type  \n+      truename() const\n+      { return this->do_truename(); }\n+\n+      string_type  \n+      falsename() const\n+      { return this->do_falsename(); }\n+\n+    protected:\n+      virtual \n+      ~numpunct() { }\n+\n+      virtual char_type    \n+      do_decimal_point() const\n+      { return _M_decimal_point; }\n \n-      static void \n-      _S_callback(ios_base::event __event, ios_base& __ios, int __ix) throw();\n+      virtual char_type    \n+      do_thousands_sep() const\n+      { return _M_thousands_sep; }\n+\n+      virtual string\n+      do_grouping() const\n+      { return _M_grouping; }\n+\n+      virtual string_type  \n+      do_truename() const\n+      { return _M_truename; }\n+\n+      virtual string_type  \n+      do_falsename() const\n+      { return _M_falsename; }\n+\n+      // For use at construction time only.\n+      void \n+      _M_initialize_numpunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT>\n-    int _Format_cache<_CharT>::_S_pword_ix;\n+    locale::id numpunct<_CharT>::id;\n \n+  // NB: Cannot be made generic. \n   template<typename _CharT>\n-    const char _Format_cache<_CharT>::\n-    _S_literals[] = \"-+xX0123456789abcdef0123456789ABCDEF\";\n+    void\n+    numpunct<_CharT>::_M_initialize_numpunct(__c_locale)\n+    { }\n \n-   template<> _Format_cache<char>::_Format_cache();\n+  template<> \n+    void\n+    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n-   template<> _Format_cache<wchar_t>::_Format_cache();\n+  template<> \n+    void\n+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n #endif\n \n-  // _Numeric_get is used by num_get, money_get, and time_get to help\n-  // in parsing out numbers.\n-  template<typename _CharT, typename _InIter>\n-    class _Numeric_get\n+  template<typename _CharT>\n+    class numpunct_byname : public numpunct<_CharT>\n     {\n+      // Data Member.\n+      __c_locale\t\t\t_M_c_locale_numpunct;\n+\n     public:\n-      // Types:\n-      typedef _CharT     char_type;\n-      typedef _InIter    iter_type;\n-\n-      // Forward decls and Friends:\n-      template<typename _Char, typename _InIterT>\n-      friend class num_get;\n-      template<typename _Char, typename _InIterT>\n-      friend class time_get;\n-      template<typename _Char, typename _InIterT>\n-      friend class money_get;\n-      template<typename _Char, typename _InIterT>\n-      friend class num_put;\n-      template<typename _Char, typename _InIterT>\n-      friend class time_put;\n-      template<typename _Char, typename _InIterT>\n-      friend class money_put;\n+      typedef _CharT               \tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n \n-    private:\n       explicit \n-      _Numeric_get() { }\n+      numpunct_byname(const char* __s, size_t __refs = 0)\n+      : numpunct<_CharT>(__refs)\n+      {\n+\t_S_create_c_locale(_M_c_locale_numpunct, __s);\n+\t_M_initialize_numpunct(_M_c_locale_numpunct);\t\n+      }\n \n+    protected:\n       virtual \n-      ~_Numeric_get() { }\n-\n-      iter_type \n-      _M_get_digits(iter_type __in, iter_type __end) const;\n+      ~numpunct_byname() \n+      { _S_destroy_c_locale(_M_c_locale_numpunct); }\n     };\n \n   template<typename _CharT, typename _InIter>\n-    class num_get : public locale::facet\n+    class num_get : public locale::facet, public __num_base\n     {\n     public:\n       // Types:\n       typedef _CharT   \t\t\tchar_type;\n       typedef _InIter  \t\t\titer_type;\n-      typedef char_traits<_CharT> \t__traits_type;\n \n       static locale::id \t\tid;\n \n@@ -580,118 +575,99 @@ namespace std\n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, bool& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n-\n-#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n-      //XXX.  What number?\n-      iter_type \n-      get(iter_type __in, iter_type __end, ios_base& __io,\n-\t  ios_base::iostate& __err, short& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n-\n-      iter_type \n-      get(iter_type __in, iter_type __end, ios_base& __io,\n-\t  ios_base::iostate& __err, int& __v)   const\n-      { return do_get(__in, __end, __io, __err, __v); }\n-#endif\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io, \n \t  ios_base::iostate& __err, long& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n-\n-#ifdef _GLIBCPP_USE_LONG_LONG\n-      iter_type \n-      get(iter_type __in, iter_type __end, ios_base& __io,\n-\t  ios_base::iostate& __err, long long& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n-#endif\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned short& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned int& __v)   const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned long& __v)  const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, long long& __v) const\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n+\n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned long long& __v)  const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n #endif\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, float& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, double& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, long double& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }\n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, void*& __v) const\n-      { return do_get(__in, __end, __io, __err, __v); }      \n+      { return this->do_get(__in, __end, __io, __err, __v); }      \n \n     protected:\n       virtual ~num_get() { }\n \n-      // This consolidates the extraction, storage and\n-      // error-processing parts of the do_get(...) overloaded member\n-      // functions. \n-      // NB: This is specialized for char.\n       void \n-      _M_extract(iter_type __beg, iter_type __end, ios_base& __io, \n-\t\t ios_base::iostate& __err, char* __xtrc, \n-\t\t int& __base, bool __fp = true) const;\n+      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+\t\t       char* __xtrc) const;\n+\n+      void \n+      _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+\t\t     char* __xtrc, int& __base) const;\n \n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n \n-#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n-      //XXX.  What number?\n       virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, short&) const;\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n+\n       virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, int&) const;\n-#endif\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t      unsigned short&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     unsigned int&) const;\n+\n       virtual iter_type \n-      do_get (iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     unsigned long&) const;\n+\n #ifdef _GLIBCPP_USE_LONG_LONG \n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n \t     long long&) const;\n-#endif\n+\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n-\t      unsigned short&) const;\n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&,\n-\t      ios_base::iostate& __err, unsigned int&) const;\n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&,\n-\t      ios_base::iostate& __err, unsigned long&) const;\n-#ifdef _GLIBCPP_USE_LONG_LONG \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&,\n-\t     ios_base::iostate& __err, unsigned long long&) const;\n+\t     unsigned long long&) const;\n #endif\n+\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n \t     float&) const;\n@@ -701,8 +677,8 @@ namespace std\n \t     double&) const;\n \n       virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, \n-\t     ios_base::iostate& __err, long double&) const;\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     long double&) const;\n \n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n@@ -712,38 +688,13 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     locale::id num_get<_CharT, _InIter>::id;\n \n-  // Declare specialized extraction member function.\n-  template<>\n-    void\n-    num_get<char, istreambuf_iterator<char> >::    \n-    _M_extract(istreambuf_iterator<char> __beg, \n-\t       istreambuf_iterator<char> __end, ios_base& __io, \n-\t       ios_base::iostate& __err, char* __xtrc, \n-\t       int& __base, bool __fp) const;\n-\n-  // _Numeric_put is used by num_put, money_put, and time_put\n-  //   to help in formatting out numbers.\n   template<typename _CharT, typename _OutIter>\n-    class _Numeric_put\n-    {\n-    public:\n-      typedef _CharT      char_type;\n-      typedef _OutIter    iter_type;\n-    protected:\n-      explicit \n-      _Numeric_put() { }\n-\n-      virtual \n-      ~_Numeric_put() { }\n-    };\n-\n-  template<typename _CharT, typename _OutIter>\n-    class num_put : public locale::facet\n+    class num_put : public locale::facet, public __num_base\n     {\n     public:\n       // Types:\n-      typedef _CharT       char_type;\n-      typedef _OutIter     iter_type;\n+      typedef _CharT       \tchar_type;\n+      typedef _OutIter     \titer_type;\n \n       static locale::id\t\tid;\n \n@@ -752,43 +703,65 @@ namespace std\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, long __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  unsigned long __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  unsigned long long __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n #endif\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, double __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  long double __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  const void* __v) const\n-      { return do_put(__s, __f, __fill, __v); }\n+      { return this->do_put(__s, __f, __fill, __v); }\n \n     protected:\n+      template<typename _ValueT>\n+        iter_type\n+        _M_convert_float(iter_type, ios_base& __io, char_type __fill, \n+\t\t\t char __mod, _ValueT __v) const;\n+\n+      template<typename _ValueT>\n+        iter_type\n+        _M_convert_int(iter_type, ios_base& __io, char_type __fill, \n+\t\t       char __mod, char __modl, _ValueT __v) const;\n+\n+      iter_type\n+      _M_widen_float(iter_type, ios_base& __io, char_type __fill, char* __cs, \n+\t\t     int __len) const;\n+\n+      iter_type\n+      _M_widen_int(iter_type, ios_base& __io, char_type __fill, char* __cs, \n+\t\t   int __len) const;\n+\n+      iter_type\n+      _M_insert(iter_type, ios_base& __io, char_type __fill, \n+\t\tconst char_type* __ws, int __len) const;\n+\n       virtual \n       ~num_put() { };\n \n@@ -798,15 +771,13 @@ namespace std\n       virtual iter_type \n       do_put(iter_type, ios_base&, char_type __fill, long __v) const;\n \n-#ifdef _GLIBCPP_USE_LONG_LONG \n       virtual iter_type \n-      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;\n-#endif\n+      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;\n \n+#ifdef _GLIBCPP_USE_LONG_LONG \n       virtual iter_type \n-      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;\n+      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;\n \n-#ifdef _GLIBCPP_USE_LONG_LONG\n       virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;\n #endif\n@@ -825,126 +796,6 @@ namespace std\n     locale::id num_put<_CharT, _OutIter>::id;\n \n \n-  template<typename _CharT>\n-    class numpunct : public locale::facet\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT          \t\tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n-\n-      static locale::id \t\tid;\n-\n-    private:\n-      char_type \t\t\t_M_decimal_point;\n-      char_type \t\t\t_M_thousands_sep;\n-      string \t\t\t\t_M_grouping;\n-      string_type \t\t\t_M_truename;\n-      string_type \t\t\t_M_falsename;\n-\n-    public:\n-      explicit \n-      numpunct(size_t __refs = 0) : locale::facet(__refs) \n-      { _M_initialize_numpunct(); }\n-\n-      explicit \n-      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs) \n-      { _M_initialize_numpunct(__cloc); }\n-\n-      char_type    \n-      decimal_point() const\n-      { return this->do_decimal_point(); }\n-\n-      char_type    \n-      thousands_sep() const\n-      { return this->do_thousands_sep(); }\n-\n-      string       \n-      grouping() const\n-      { return this->do_grouping(); }\n-\n-      string_type  \n-      truename() const\n-      { return this->do_truename(); }\n-\n-      string_type  \n-      falsename() const\n-      { return this->do_falsename(); }\n-\n-    protected:\n-      virtual \n-      ~numpunct() { }\n-\n-      virtual char_type    \n-      do_decimal_point() const\n-      { return _M_decimal_point; }\n-\n-      virtual char_type    \n-      do_thousands_sep() const\n-      { return _M_thousands_sep; }\n-\n-      virtual string\n-      do_grouping() const\n-      { return _M_grouping; }\n-\n-      virtual string_type  \n-      do_truename() const\n-      { return _M_truename; }\n-\n-      virtual string_type  \n-      do_falsename() const\n-      { return _M_falsename; }\n-\n-      // For use at construction time only.\n-      void \n-      _M_initialize_numpunct(__c_locale __cloc = NULL);\n-    };\n-\n-  template<typename _CharT>\n-    locale::id numpunct<_CharT>::id;\n-\n-  // NB: Cannot be made generic. \n-  template<typename _CharT>\n-    void\n-    numpunct<_CharT>::_M_initialize_numpunct(__c_locale)\n-    { }\n-\n-  template<> \n-    void\n-    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<> \n-    void\n-    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n-#endif\n-\n-\n-  template<typename _CharT>\n-    class numpunct_byname : public numpunct<_CharT>\n-    {\n-      // Data Member.\n-      __c_locale\t\t\t_M_c_locale_numpunct;\n-\n-    public:\n-      typedef _CharT               \tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n-\n-      explicit \n-      numpunct_byname(const char* __s, size_t __refs = 0)\n-      : numpunct<_CharT>(__refs)\n-      {\n-\t_S_create_c_locale(_M_c_locale_numpunct, __s);\n-\t_M_initialize_numpunct(_M_c_locale_numpunct);\t\n-      }\n-\n-    protected:\n-      virtual \n-      ~numpunct_byname() \n-      { _S_destroy_c_locale(_M_c_locale_numpunct); }\n-    };\n-\n-\n   template<typename _CharT>\n     class collate : public locale::facet\n     {\n@@ -1466,8 +1317,9 @@ namespace std\n     };\n \n \n-  struct money_base\n+  class money_base\n   {\n+  public:\n     enum part { none, space, symbol, sign, value };\n     struct pattern { char field[4]; };\n "}, {"sha": "3b9148e565c5d2ecea1b9bdd65ccf2e4b8b3de12", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 544, "deletions": 530, "changes": 1074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -59,18 +59,17 @@ namespace std\n                        const basic_string<_CharT, _Traits, _Alloc>& __s2) const\n     {\n       typedef std::collate<_CharT> __collate_type;\n-      const __collate_type* __fcoll = &use_facet<__collate_type>(*this);\n-      return (__fcoll->compare(__s1.data(), __s1.data() + __s1.length(),\n-                               __s2.data(), __s2.data() + __s2.length()) < 0);\n+      const __collate_type& __collate = use_facet<__collate_type>(*this);\n+      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),\n+\t\t\t\t__s2.data(), __s2.data() + __s2.length()) < 0);\n     }\n \n   template<typename _Facet>\n     const _Facet&\n     use_facet(const locale& __loc)\n     {\n-      typedef locale::_Impl::__vec_facet        __vec_facet;\n       size_t __i = _Facet::id._M_index;\n-      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      locale::_Impl::__vec_facet* __facet = __loc._M_impl->_M_facets;\n       const locale::facet* __fp = (*__facet)[__i]; \n       if (__fp == 0 || __i >= __facet->size())\n         __throw_bad_cast();\n@@ -81,52 +80,262 @@ namespace std\n     bool\n     has_facet(const locale& __loc) throw()\n     {\n-      typedef locale::_Impl::__vec_facet        __vec_facet;\n       size_t __i = _Facet::id._M_index;\n-      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      locale::_Impl::__vec_facet* __facet = __loc._M_impl->_M_facets;\n       return (__i < __facet->size() && (*__facet)[__i] != 0);\n     }\n \n \n-  // This member function takes an (w)istreambuf_iterator object and\n-  // parses it into a generic char array suitable for parsing with\n-  // strto[l,ll,f,d]. The thought was to encapsulate the conversion\n-  // into this one function, and thus the num_get::do_get member\n-  // functions can just adjust for the type of the overloaded\n-  // argument and process the char array returned from _M_extract.\n-  // Other things were also considered, including a fused\n-  // multiply-add loop that would obviate the need for any call to\n-  // strto... at all: however, it would b e a bit of a pain, because\n-  // you'd have to be able to return either floating or integral\n-  // types, etc etc. The current approach seems to be smack dab in\n-  // the middle between an unoptimized approach using sscanf, and\n-  // some kind of hyper-optimized approach alluded to above.\n-\n-  // XXX\n-  // Need to do partial specialization to account for differences\n-  // between character sets. For char, this is pretty\n-  // straightforward, but for wchar_t, the conversion to a plain-jane\n-  // char type is a bit more involved.\n   template<typename _CharT, typename _InIter>\n     void\n     num_get<_CharT, _InIter>::\n-    _M_extract(_InIter /*__beg*/, _InIter /*__end*/, ios_base& /*__io*/,\n-               ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n-               int& /*__base*/, bool /*__fp*/) const\n+    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n+\t\t     ios_base::iostate& __err, char* __xtrc) const\n     {\n-      // XXX Not currently done: need to expand upon char version below.\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      int __pos = 0;\n+      char_type  __c = *__beg;\n+\n+      // Check first for sign.\n+      const char_type __plus = __ctype.widen('+');\n+      const char_type __minus = __ctype.widen('-');\n+      if ((__c == __plus || __c == __minus) && __beg != __end)\n+\t{\n+\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t  __c = *(++__beg);\n+\t}\n+\n+      // Next, strip leading zeros.\n+      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n+      bool __found_zero = false;\n+      while (__c == __zero && __beg != __end)\n+\t{\n+\t  __c = *(++__beg);\n+\t  __found_zero = true;\n+\t}\n+      if (__found_zero)\n+\t__xtrc[__pos++] = _S_atoms[_M_zero];\n+\n+      // Only need acceptable digits for floating point numbers.\n+      const size_t __len = _M_E - _M_zero + 1;\n+      char_type  __watoms[__len];\n+      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n+      bool __found_dec = false;\n+      bool __found_sci = false;\n+      const char_type __dec = __np.decimal_point();\n+\n+      string __found_grouping;\n+      const string __grouping = __np.grouping();\n+      bool __check_grouping = __grouping.size();\n+      int __sep_pos = 0;\n+      const char_type __sep = __np.thousands_sep();\n+\n+      while (__beg != __end)\n+        {\n+\t  // Only look in digits.\n+\t  typedef char_traits<_CharT> \t__traits_type;\n+          const char_type* __p = __traits_type::find(__watoms, 10,  __c);\n+\n+          // NB: strchr returns true for __c == 0x0\n+          if (__p && __c)\n+\t    {\n+\t      // Try first for acceptable digit; record it if found.\n+\t      __xtrc[__pos++] = _S_atoms[__p - __watoms];\n+\t      ++__sep_pos;\n+\t      __c = *(++__beg);\n+\t    }\n+          else if (__c == __sep && __check_grouping && !__found_dec)\n+\t    {\n+              // NB: Thousands separator at the beginning of a string\n+              // is a no-no, as is two consecutive thousands separators.\n+              if (__sep_pos)\n+                {\n+                  __found_grouping += static_cast<char>(__sep_pos);\n+                  __sep_pos = 0;\n+\t\t  __c = *(++__beg);\n+                }\n+              else\n+\t\t{\n+\t\t  __err |= ios_base::failbit;\n+\t\t  break;\n+\t\t}\n+            }\n+\t  else if (__c == __dec && !__found_dec)\n+\t    {\n+\t      __found_grouping += static_cast<char>(__sep_pos);\n+\t      __xtrc[__pos++] = '.';\n+\t      __c = *(++__beg);\n+\t      __found_dec = true;\n+\t    }\n+\t  else if ((__c == __watoms[_M_e] || __c == __watoms[_M_E]) \n+\t\t   && !__found_sci && __pos)\n+\t    {\n+\t      // Scientific notation.\n+\t      __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t      __c = *(++__beg);\n+\n+\t      // Remove optional plus or minus sign, if they exist.\n+\t      if (__c == __plus || __c == __minus)\n+\t\t{\n+\t\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t  __c = *(++__beg);\n+\t\t}\n+\t      __found_sci = true;\n+\t    }\n+\t  else\n+\t    // Not a valid input item.\n+\t    break;\n+        }\n+\n+      // Digit grouping is checked. If grouping and found_grouping don't\n+      // match, then get very very upset, and set failbit.\n+      if (__check_grouping && __found_grouping.size())\n+        {\n+          // Add the ending grouping if a decimal wasn't found.\n+\t  if (!__found_dec)\n+\t    __found_grouping += static_cast<char>(__sep_pos);\n+\n+          if (!__verify_grouping(__grouping, __found_grouping))\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+        }\n+\n+      // Finish up\n+      __xtrc[__pos] = char_type();\n+      if (__beg == __end)\n+        __err |= ios_base::eofbit;\n     }\n \n-  template<>\n+  template<typename _CharT, typename _InIter>\n     void\n-    num_get<char, istreambuf_iterator<char> >::\n-    _M_extract(istreambuf_iterator<char> __beg, \n-\t       istreambuf_iterator<char> __end, ios_base& __io, \n-\t       ios_base::iostate& __err, char* __xtrc, int& __base, \n-\t       bool __fp) const;\n+    num_get<_CharT, _InIter>::\n+    _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n+\t\t   ios_base::iostate& __err, char* __xtrc, int& __base) const\n+    {\n+      // Stage 1: determine a conversion specifier.\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      if (__basefield == ios_base::oct)\n+        __base = 8;\n+      else if (__basefield == ios_base::hex)\n+        __base = 16;\n+      else\n+\t__base = 10;\n+\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      int __pos = 0;\n+      char_type  __c = *__beg;\n+\n+      // Check first for sign.\n+      if ((__c == __ctype.widen('+') || __c == __ctype.widen('-'))\n+\t  && __beg != __end)\n+\t{\n+\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t  __c = *(++__beg);\n+\t}\n+\n+      // Next, strip leading zeros\n+      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n+      bool __found_zero = false;\n+      while (__base == 10 && __c == __zero && __beg != __end)\n+\t{\n+\t  __c = *(++__beg);\n+\t  __found_zero = true;\n+\t}\n+      if (__found_zero)\n+\t{\n+\t  __xtrc[__pos++] = _S_atoms[_M_zero];\n+\t  if (__basefield == 0)\n+\t    {\n+\t      // Depending on what is discovered, the base may change.\n+\t      if (__c == __ctype.widen('x') || __c == __ctype.widen('X'))\n+\t\t__base = 16;\n+\t      else\n+\t\t__base = 8;\n+\t    }\n+\t}\n+\n+      // At this point, base is determined. If not hex, only allow\n+      // base digits as valid input.\n+      size_t __len;\n+      if (__base == 16)\n+\t__len = _M_size;\n+      else\n+\t__len = __base;\n+\n+      char_type  __watoms[_M_size];\n+      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n+      string __found_grouping;\n+      const string __grouping = __np.grouping();\n+      bool __check_grouping = __grouping.size() && __base == 10;\n+      int __sep_pos = 0;\n+      const char_type __sep = __np.thousands_sep();\n+      while (__beg != __end)\n+        {\n+\t  typedef char_traits<_CharT> \t__traits_type;\n+          const char_type* __p = __traits_type::find(__watoms, __len,  __c);\n+\n+          // NB: strchr returns true for __c == 0x0\n+          if (__p && __c)\n+\t    {\n+\t      // Try first for acceptable digit; record it if found.\n+\t      __xtrc[__pos++] = _S_atoms[__p - __watoms];\n+\t      ++__sep_pos;\n+\t      __c = *(++__beg);\n+\t    }\n+          else if (__c == __sep && __check_grouping)\n+\t    {\n+              // NB: Thousands separator at the beginning of a string\n+              // is a no-no, as is two consecutive thousands separators.\n+              if (__sep_pos)\n+                {\n+                  __found_grouping += static_cast<char>(__sep_pos);\n+                  __sep_pos = 0;\n+\t\t  __c = *(++__beg);\n+                }\n+              else\n+\t\t{\n+\t\t  __err |= ios_base::failbit;\n+\t\t  break;\n+\t\t}\n+            }\n+\t  else\n+\t    // Not a valid input item.\n+\t    break;\n+        }\n+\n+      // Digit grouping is checked. If grouping and found_grouping don't\n+      // match, then get very very upset, and set failbit.\n+      if (__check_grouping && __found_grouping.size())\n+        {\n+          // Add the ending grouping\n+          __found_grouping += static_cast<char>(__sep_pos);\n+\n+          if (!__verify_grouping(__grouping, __found_grouping))\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+        }\n+\n+      // Finish up\n+      __xtrc[__pos] = char_type();\n+      if (__beg == __end)\n+        __err |= ios_base::eofbit;\n+    }\n \n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n-  // NB: This is an unresolved library defect #17\n   //17.  Bad bool parsing\n   template<typename _CharT, typename _InIter>\n     _InIter\n@@ -145,7 +354,7 @@ namespace std\n           // integral types.\n           char __xtrc[32] = {'\\0'};\n           int __base;\n-          _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+          _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n           // Stage 2: convert and store results.\n           char* __sanity;\n@@ -162,29 +371,30 @@ namespace std\n       // Parse bool values as alphanumeric\n       else\n         {\n-          typedef _Format_cache<char_type> __fcache_type;\n-          __fcache_type* __fmt = __fcache_type::_S_get(__io);\n-          const char_type* __true = __fmt->_M_truename.c_str();\n-          const char_type* __false = __fmt->_M_falsename.c_str();\n-          const size_t __truelen =  __traits_type::length(__true) - 1;\n-          const size_t __falselen =  __traits_type::length(__false) - 1;\n-\n-          for (size_t __pos = 0; __beg != __end; ++__pos)\n+          locale __loc = __io.getloc();\n+\t  const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__loc); \n+          const char_type* __true = __np.truename().c_str();\n+          const char_type* __false = __np.falsename().c_str();\n+\n+          const size_t __truen =  __np.truename().size() - 1;\n+          const size_t __falsen =  __np.falsename().size() - 1;\n+\n+          for (size_t __n = 0; __beg != __end; ++__n)\n             {\n               char_type __c = *__beg++;\n-              bool __testf = __c == __false[__pos];\n-              bool __testt = __c == __true[__pos];\n+              bool __testf = __n <= __falsen ? __c == __false[__n] : false;\n+              bool __testt = __n <= __truen ? __c == __true[__n] : false;\n               if (!(__testf || __testt))\n                 {\n                   __err |= ios_base::failbit;\n                   break;\n                 }\n-              else if (__testf && __pos == __falselen)\n+              else if (__testf && __n == __falsen)\n                 {\n                   __v = 0;\n                   break;\n                 }\n-              else if (__testt && __pos == __truelen)\n+              else if (__testt && __n == __truen)\n                 {\n                   __v = 1;\n                   break;\n@@ -198,63 +408,6 @@ namespace std\n     }\n #endif\n \n-#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n-  //XXX.  Which number?  Presumably same as in locale_facets.h...\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, short& __v) const\n-    {\n-      // Stage 1: extract and determine the conversion specifier.\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32]= {'\\0'};\n-      int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-\n-      // Stage 2: convert and store results.\n-      char* __sanity;\n-      errno = 0;\n-      long __l = strtol(__xtrc, &__sanity, __base);\n-      if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-          && __l >= SHRT_MIN && __l <= SHRT_MAX)\n-        __v = static_cast<short>(__l);\n-      else\n-        __err |= ios_base::failbit;\n-\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, int& __v) const\n-    {\n-      // Stage 1: extract and determine the conversion specifier.\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32] = {'\\0'};\n-      int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-\n-      // Stage 2: convert and store results.\n-      char* __sanity;\n-      errno = 0;\n-      long __l = strtol(__xtrc, &__sanity, __base);\n-      if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-          && __l >= INT_MIN && __l <= INT_MAX)\n-        __v = static_cast<int>(__l);\n-      else\n-        __err |= ios_base::failbit;\n-\n-      return __beg;\n-    }\n-#endif\n-\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n@@ -266,7 +419,7 @@ namespace std\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -281,55 +434,54 @@ namespace std\n       return __beg;\n     }\n \n-#ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, long long& __v) const\n+           ios_base::iostate& __err, unsigned short& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n-      long long __ll = strtoll(__xtrc, &__sanity, __base);\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-        __v = __ll;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __ul <= USHRT_MAX)\n+        __v = static_cast<unsigned short>(__ul);\n       else\n         __err |= ios_base::failbit;\n \n       return __beg;\n     }\n-#endif\n \n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, unsigned short& __v) const\n+           ios_base::iostate& __err, unsigned int& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n           && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-          && __ul <= USHRT_MAX)\n-        __v = static_cast<unsigned short>(__ul);\n+          && __ul <= UINT_MAX)\n+        __v = static_cast<unsigned int>(__ul);\n       else\n         __err |= ios_base::failbit;\n \n@@ -340,56 +492,55 @@ namespace std\n     _InIter\n     num_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, unsigned int& __v) const\n+           ios_base::iostate& __err, unsigned long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32]= {'\\0'};\n+      char __xtrc[32] = {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-          && __ul <= UINT_MAX)\n-        __v = static_cast<unsigned int>(__ul);\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ul;\n       else\n         __err |= ios_base::failbit;\n \n       return __beg;\n     }\n \n+#ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, unsigned long& __v) const\n+           ios_base::iostate& __err, long long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n-      char __xtrc[32] = {'\\0'};\n+      char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n-      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      long long __ll = strtoll(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n           && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-        __v = __ul;\n+        __v = __ll;\n       else\n         __err |= ios_base::failbit;\n \n       return __beg;\n     }\n \n-#ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n@@ -401,7 +552,7 @@ namespace std\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -420,15 +571,14 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n-           ios_base::iostate& __err, float& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+\t   ios_base::iostate& __err, float& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n-      int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -457,8 +607,7 @@ namespace std\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n-      int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -483,8 +632,7 @@ namespace std\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n-      int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+      _M_extract_float(__beg, __end, __io, __err, __xtrc);\n \n #if defined(_GLIBCPP_USE_C99) && !defined(__hpux)\n       // Stage 2: convert and store results.\n@@ -539,7 +687,7 @@ namespace std\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n-      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+      _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Stage 2: convert and store results.\n       char* __sanity;\n@@ -556,384 +704,235 @@ namespace std\n       return __beg;\n     }\n \n-  // __pad is specialized for ostreambuf_iterator, random access iterator.\n+\n+  // The following code uses sprintf() to convert floating point\n+  // values for insertion into a stream.  An optimization would be to\n+  // replace sprintf() with code that works directly on a wide buffer\n+  // and then use __pad to do the padding. It would be good\n+  // to replace sprintf() anyway to avoid accidental buffer overruns\n+  // and to gain back the efficiency that C++ provides by knowing up\n+  // front the type of the values to insert. This implementation\n+  // follows the C++ standard fairly directly as outlined in 22.2.2.2\n+  // [lib.locale.num.put]\n   template<typename _CharT, typename _OutIter>\n-    inline _OutIter\n-    __pad(_OutIter __s, _CharT __fill, int __padding);\n+    template<typename _ValueT>\n+      _OutIter\n+      num_put<_CharT, _OutIter>::\n+      _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n+\t\t       _ValueT __v) const\n+      {\n+\tconst streamsize __max_prec = numeric_limits<_ValueT>::digits10;\n+\tstreamsize __prec = __io.precision();\n+\t// Protect against sprintf() buffer overflows.\n+\tif (__prec > __max_prec)\n+\t  __prec = __max_prec;\n+\n+\t// Long enough for the max format spec.\n+\tchar __fbuf[16];\n+\tchar __cs[64];\n+\tint __len;\n+\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n+\tif (_S_format_float(__io, __fbuf, __mod, __prec))\n+\t  __len = sprintf(__cs, __fbuf, __prec, __v);\n+\telse\n+\t  __len = sprintf(__cs, __fbuf, __v);\n+\treturn _M_widen_float(__s, __io, __fill, __cs, __len);\n+      }\n \n-  template<typename _CharT, typename _RaIter>\n-    _RaIter\n-    __pad(_RaIter __s, _CharT __fill, int __padding, \n-\t  random_access_iterator_tag)\n-    {\n-      fill_n(__s, __fill);\n-      return __s + __padding;\n-    }\n+  template<typename _CharT, typename _OutIter>\n+    template<typename _ValueT>\n+      _OutIter\n+      num_put<_CharT, _OutIter>::\n+      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n+\t\t     char __modl, _ValueT __v) const\n+      {\n+\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n+\t// Leave room for \"+/-,\" \"0x,\" and commas. This size is\n+\t// arbitrary, but should work.\n+\tchar __cs[64];\n+\t// Long enough for the max format spec.\n+\tchar __fbuf[16];\n+\t_S_format_int(__io, __fbuf, __mod, __modl);\n+\tint __len = sprintf(__cs, __fbuf, __v);\n+\treturn _M_widen_int(__s, __io, __fill, __cs, __len);\n+      }\n \n-  template<typename _CharT, typename _OutIter, typename _Tag>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n-    __pad(_OutIter __s, _CharT __fill, int __padding, _Tag)\n+    num_put<_CharT, _OutIter>::\n+    _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs, \n+\t\t   int __len) const\n     {\n-      while (--__padding >= 0) { *__s = __fill; ++__s; }\n-      return __s;\n+      // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n+      // numpunct.decimal_point() values for '.' and adding grouping.\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * 64));\n+      __ctype.widen(__cs, __cs + __len, __ws);\n+      \n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      // Replace decimal point.\n+      const _CharT* __p;\n+      if (__p = char_traits<_CharT>::find(__ws, __len, __ctype.widen('.')))\n+\t__ws[__p - __ws] = __np.decimal_point();\n+      return _M_insert(__s, __io, __fill, __ws, __len);\n     }\n \n   template<typename _CharT, typename _OutIter>\n-    inline _OutIter\n-    __pad(_OutIter __s, _CharT __fill, int __padding)\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    _M_widen_int(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs, \n+\t\t int __len) const\n     {\n-      return __pad(__s, __fill, __padding, \n-\t\t   typename iterator_traits<_OutIter>::iterator_category());\n+      // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n+      // numpunct.decimal_point() values for '.' and adding grouping.\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * 64));\n+      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * 64));\n+      __ctype.widen(__cs, __cs + __len, __ws);\n+\n+      // Add grouping, if necessary.\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      string __grouping = __np.grouping();\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      bool __dec = __basefield != ios_base::oct \n+\t           && __basefield != ios_base::hex;\n+      if (__grouping.size() && __dec)\n+\t{\n+\t  _CharT* __p;\n+\t  __p = __add_grouping(__ws2, __np.thousands_sep(), __grouping.c_str(),\n+\t\t\t       __grouping.c_str() + __grouping.size(),\n+\t\t\t       __ws, __ws + __len);\n+\t  __len = __p - __ws2;\n+\t  // Switch strings.\n+\t  __ws = __ws2;\n+\t}\n+      return _M_insert(__s, __io, __fill, __ws, __len);\n     }\n \n+  // For use by integer and floating-point types after they have been\n+  // converted into a char_type string.\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n-    __pad_numeric(_OutIter __s, ios_base::fmtflags /*__flags*/,\n-\t\t  _CharT /*__fill*/, int /*__width*/, \n-\t\t  _CharT const* /*__first*/, _CharT const* /*__middle*/, \n-\t\t  _CharT const* /*__last*/)\n-  {\n-      // XXX Not currently done: non streambuf_iterator\n-      return __s;\n-    }\n-\n-  // Partial specialization for ostreambuf_iterator.\n-  template<typename _CharT>   \n-    ostreambuf_iterator<_CharT>\n-    __pad_numeric(ostreambuf_iterator<_CharT> __s, ios_base::fmtflags __flags,\n-\t\t  _CharT __fill, int __width, _CharT const* __first,\n-\t\t  _CharT const* __middle, _CharT const* __last)\n+    num_put<_CharT, _OutIter>::\n+    _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws, \n+\t      int __len) const\n     {\n-      typedef ostreambuf_iterator<_CharT> \t__out_iter;\n-      int __padding = __width - (__last - __first);\n-      if (__padding < 0)\n-        __padding = 0;\n-      ios_base::fmtflags __aflags = __flags & ios_base::adjustfield;\n-      bool __testfield = __padding == 0 || __aflags == ios_base::left\n-                         || __aflags == ios_base::internal;\n-\n-      // This was needlessly complicated.\n-      if (__first != __middle)\n-        {\n-          if (!__testfield)\n-            {\n-              __pad(__s, __fill, __padding);\n-              __padding = 0;\n-            }\n-          copy(__first, __middle, __s);\n-        }\n-      __out_iter __s2 = __s;\n+      // [22.2.2.2.2] Stage 3.\n+      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * 64));\n+      streamsize __w = __io.width();\n+      if (__w > static_cast<streamsize>(__len))\n+\t{\n+\t  __pad(__io, __fill, __ws2, __ws, __w, __len);\n+\t  __len = static_cast<int>(__w);\n+\t  // Switch strings.\n+\t  __ws = __ws2;\n+\t}\n+      __io.width(0);\n \n-      if (__padding && __aflags != ios_base::left)\n-        {\n-          __pad(__s2, __fill, __padding);\n-          __padding = 0;\n-        }\n-      __out_iter __s3 = copy(__middle, __last, __s2);\n-      if (__padding)\n-        __pad(__s3, __fill, __padding);\n-      return __s3;\n+      // [22.2.2.2.2] Stage 4.\n+      // Write resulting, fully-formatted string to output iterator.\n+      for (int __j = 0; __j < __len; ++__j, ++__s)\n+\t*__s = __ws[__j];\n+      return __s;\n     }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n     {\n-      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n       ios_base::fmtflags __flags = __io.flags();\n-\n       if ((__flags & ios_base::boolalpha) == 0)\n         {\n           unsigned long __uv = __v;\n-          return __output_integer(__s, __io, __fill, false, __uv);\n+          _M_convert_int(__s, __io, __fill, 'u', char_type(), __uv);\n         }\n       else\n         {\n-          const char_type* __first;\n-          const char_type* __last;\n+          locale __loc = __io.getloc();\n+\t  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc); \n+          const char_type* __ws;\n+          int __len;\n           if (__v)\n             {\n-              __first = __fmt->_M_truename.data();\n-              __last = __first + __fmt->_M_truename.size();\n+              __ws = __np.truename().c_str();\n+              __len = __np.truename().size();\n             }\n           else\n             {\n-              __first = __fmt->_M_falsename.data();\n-              __last = __first + __fmt->_M_falsename.size();\n+              __ws = __np.falsename().c_str();\n+              __len = __np.falsename().size();\n             }\n-        streamsize __width = __io.width(0);\n-        if (__last - __first >= __width)\n-          return copy(__first, __last, __s);\n-        else\n-          {\n-            int __padding = __width - (__last - __first);\n-            ios_base::fmtflags __aflags = __flags & ios_base::adjustfield;\n-            if (__aflags != ios_base::left)\n-              {\n-                __pad(__s, __fill, __padding);\n-                return copy(__first, __last, __s);\n-              }\n-            else\n-              {\n-                copy(__first, __last, __s);\n-                return __pad(__s, __fill, __padding);\n-              }\n-          }\n-      }\n-    }\n-\n-  template<typename _CharT, typename _OutIter, typename _ValueT>\n-    _OutIter\n-    __output_integer(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n-\t\t     _ValueT __v)\n-    {\n-      // Leave room for \"+/-,\" \"0x,\" and commas. This size is\n-      // arbitrary, but should work.\n-      const int __n = numeric_limits<_ValueT>::digits10 * 2 + 4;\n-      _CharT* __digits = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n-      _CharT* __digits_end = __digits + __n;\n-      ios_base::fmtflags __flags = __io.flags();\n-      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n-      char const* __table = __fmt->_S_literals + __fmt->_S_digits;\n-\n-      ios_base::fmtflags __basefield = (__flags & __io.basefield);\n-      _CharT* __sign_end = __digits_end;\n-      if (__basefield == ios_base::hex)\n-        {\n-          if (__flags & ios_base::uppercase)\n-            __table += 16;  // use ABCDEF\n-          do\n-            *--__digits_end = __table[__v & 15];\n-          while ((__v >>= 4) != 0);\n-          __sign_end = __digits_end;\n-          if (__flags & ios_base::showbase)\n-            {\n-              *--__digits_end = __fmt->_S_literals[__fmt->_S_x +\n-                       ((__flags & ios_base::uppercase) ? 1 : 0)];\n-              *--__digits_end = __table[0];\n-            }\n-        }\n-      else if (__basefield == ios_base::oct)\n-        {\n-          do\n-            *--__digits_end = __table[__v & 7];\n-          while ((__v >>= 3) != 0);\n-          if (__flags & ios_base::showbase\n-              && static_cast<char>(*__digits_end) != __table[0])\n-            *--__digits_end = __table[0];\n-          __sign_end = __digits_end;\n-        }\n-      else\n-        {\n-          // NB: This is _lots_ faster than using ldiv.\n-          do\n-            *--__digits_end = __table[__v % 10];\n-          while ((__v /= 10) != 0);\n-          __sign_end = __digits_end;\n-          // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n-          if (__neg || (__flags & ios_base::showpos))\n-            *--__digits_end = __fmt->_S_literals[__fmt->_S_plus - __neg];\n-        }\n-\n-      // XXX should specialize!\n-      if (!__fmt->_M_use_grouping && !__io.width())\n-        return copy(__digits_end, __digits + __n, __s);\n-\n-      if (!__fmt->_M_use_grouping)\n-        return __pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t     __digits_end, __sign_end, __digits + __n);\n-\n-      _CharT* __p = __digits;\n-      while (__digits_end < __sign_end)\n-        *__p++ = *__digits_end++;\n-      const char* __gbeg = __fmt->_M_grouping.data();\n-      const char* __gend = __gbeg + __fmt->_M_grouping.size();\n-      __digits_end = __group_digits(__p, __fmt->_M_thousands_sep, \n-\t\t\t\t    __gbeg, __gend,\n-\t\t\t\t    __sign_end, __digits + __n);\n-      return __pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t   __digits, __p, __digits_end);\n+\t  _M_insert(__s, __io, __fill, __ws, __len); \n+\t}\n+      return __s;\n     }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n-    {\n-      unsigned long __uv = __v;\n-      bool __neg = false;\n-      if (__v < 0)\n-        {\n-          __neg = true;\n-          __uv = -__uv;\n-        }\n-      return __output_integer(__s, __io, __fill, __neg, __uv);\n-    }\n+    { return _M_convert_int(__s, __io, __fill, 'd', char_type(), __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long __v) const\n-    { return __output_integer(__s, __io, __fill, false, __v); }\n+    { return _M_convert_int(__s, __io, __fill, 'u', char_type(), __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n-    {\n-      unsigned long long __uv = __v;\n-      bool __neg = false;\n-      if (__v < 0)\n-        {\n-          __neg = true;\n-          __uv = -__uv;\n-        }\n-      return __output_integer(__s, __b, __fill, __neg, __uv);\n-    }\n+    { return _M_convert_int(__s, __b, __fill, 'd', 'l', __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long long __v) const\n-    { return __output_integer(__s, __io, __fill, false, __v); }\n+    { return _M_convert_int(__s, __io, __fill, 'u', 'l', __v); }\n #endif\n \n-  // Generic helper function\n-  template<typename _CharT, typename _Traits, typename _OutIter>\n-    _OutIter\n-    __output_float(_OutIter __s, ios_base& __io, _CharT __fill,\n-                    const char* __sptr, size_t __slen)\n-    {\n-      // XXX Not currently done: non-streambuf_iterator\n-      return __s;\n-    }\n-\n-  // Partial specialization for ostreambuf_iterator.\n-  template<typename _CharT, typename _Traits>\n-    ostreambuf_iterator<_CharT, _Traits>\n-    __output_float(ostreambuf_iterator<_CharT, _Traits> __s, ios_base& __io, \n-\t\t   _CharT __fill, const char* __sptr, size_t __slen)\n-    {\n-      size_t __padding = __io.width() > streamsize(__slen) ?\n-                         __io.width() -__slen : 0;\n-      locale __loc = __io.getloc();\n-      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      ios_base::fmtflags __adjfield = __io.flags() & ios_base::adjustfield;\n-      const char* const __eptr = __sptr + __slen;\n-      // [22.2.2.2.2.19] Table 61\n-      if (__adjfield == ios_base::internal)\n-       {\n-         // [22.2.2.2.2.14]; widen()\n-         if (__sptr < __eptr && (*__sptr == '+' || *__sptr == '-'))\n-           {\n-             __s = __ctype.widen(*__sptr);\n-             ++__s;\n-             ++__sptr;\n-           }\n-         __s = __pad(__s, __fill, __padding);\n-         __padding = 0;\n-       }\n-      else if (__adjfield != ios_base::left)\n-        {\n-          __s = __pad(__s, __fill, __padding);\n-          __padding = 0;\n-        }\n-      // the \"C\" locale decimal character\n-      char __decimal_point = *(localeconv()->decimal_point);\n-      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n-      for (; __sptr != __eptr; ++__s, ++__sptr)\n-       {\n-         // [22.2.2.2.2.17]; decimal point conversion\n-         if (*__sptr == __decimal_point)\n-           __s = __fmt->_M_decimal_point;\n-         // [22.2.2.2.2.14]; widen()\n-         else\n-           __s = __ctype.widen(*__sptr);\n-       }\n-      // [22.2.2.2.2.19] Table 61\n-      if (__padding)\n-        __pad(__s, __fill, __padding);\n-      __io.width(0);\n-      return __s;\n-    }\n-\n-  bool\n-  __build_float_format(ios_base& __io, char* __fptr, char __modifier,\n-\t\t       streamsize __prec);\n-\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n-    {\n-      const streamsize __max_prec = numeric_limits<double>::digits10 + 3;\n-      streamsize __prec = __io.precision();\n-      // Protect against sprintf() buffer overflows.\n-      if (__prec > __max_prec)\n-        __prec = __max_prec;\n-      // The *2 provides for signs, exp, 'E', and pad.\n-      char __sbuf[__max_prec * 2];\n-      size_t __slen;\n-      // Long enough for the max format spec.\n-      char __fbuf[16];\n-      if (__build_float_format(__io, __fbuf, 0, __prec))\n-        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n-      else\n-        __slen = sprintf(__sbuf, __fbuf, __v);\n-      // [22.2.2.2.2] Stages 2-4.\n-      return __output_float(__s, __io, __fill, __sbuf, __slen);\n-    }\n+    { return _M_convert_float(__s, __io, __fill, char_type(), __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type __fill,\n-           long double __v) const\n-    {\n-      const streamsize __max_prec = numeric_limits<long double>::digits10 + 3;\n-      streamsize __prec = __io.precision();\n-      // Protect against sprintf() buffer overflows.\n-      if (__prec > __max_prec)\n-        __prec = __max_prec;\n-      // The *2 provides for signs, exp, 'E', and pad.\n-      char __sbuf[__max_prec * 2];\n-      size_t __slen;\n-      // Long enough for the max format spec.\n-      char __fbuf[16];\n-      // 'L' as per [22.2.2.2.2] Table 59\n-      if (__build_float_format(__io, __fbuf, 'L', __prec))\n-        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n-      else\n-        __slen = sprintf(__sbuf, __fbuf, __v);\n-      // [22.2.2.2.2] Stages 2-4\n-      return __output_float(__s, __io, __fill, __sbuf, __slen);\n-    }\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, \n+\t   long double __v) const\n+    { return _M_convert_float(__s, __io, __fill, 'L', __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            const void* __v) const\n     {\n-      typedef ios_base::fmtflags        fmtflags;\n-      fmtflags __fmt = __io.flags();\n-      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n-                             | ios_base::uppercase | ios_base::internal);\n-      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n-      try {\n-        _OutIter __s2 = __output_integer(__s, __io, __fill, false,\n-                                  reinterpret_cast<unsigned long>(__v));\n-        __io.flags(__fmt);\n-        return __s2;\n-      }\n-      catch (...) {\n-        __io.flags(__fmt);\n-        __throw_exception_again;\n-      }\n+      ios_base::fmtflags __flags = __io.flags();\n+      ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield\n+\t\t\t\t   | ios_base::uppercase | ios_base::internal);\n+      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n+      try \n+\t{\n+\t  _M_convert_int(__s, __io, __fill, 'u', char_type(),\n+\t\t\t reinterpret_cast<unsigned long>(__v));\n+\t  __io.flags(__flags);\n+\t}\n+      catch (...) \n+\t{\n+\t  __io.flags(__flags);\n+\t  __throw_exception_again;\n+\t}\n+      return __s;\n     }\n \n \n@@ -1253,13 +1252,13 @@ namespace std\n \t\t{\n \t\t  const char_type __sep = __intl ? __mpt.thousands_sep() \n \t\t    \t\t\t         : __mpf.thousands_sep();\n-\t\t  const char* __gbeg = __grouping.data();\n+\t\t  const char* __gbeg = __grouping.c_str();\n \t\t  const char* __gend = __gbeg + __grouping.size();\n \t\t  const int __n = numeric_limits<long double>::digits10 * 2;\n-\t\t  _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n-\t\t  _CharT* __s_end = __group_digits(__s, __sep, __gbeg, \n-\t\t\t\t\t\t   __gend, __beg, __end);\n-\t\t  __value.insert(0, __s, __s_end - __s);\n+\t\t  _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+\t\t  _CharT* __ws_end = __add_grouping(__ws2, __sep, __gbeg, \n+\t\t\t\t\t\t    __gend, __beg, __end);\n+\t\t  __value.insert(0, __ws2, __ws_end - __ws2);\n \t\t}\n \t      else\n \t\t__value.insert(0, string_type(__beg, __end));\n@@ -1921,6 +1920,100 @@ namespace std\n       return static_cast<long>(__val);\n     }\n \n+  // Construct correctly padded string, as per 22.2.2.2.2\n+  // Assumes \n+  // __newlen > __oldlen\n+  // __news is allocated for __newlen size\n+  // Used by both num_put and ostream inserters.\n+  template<typename _CharT, typename _Traits>\n+    void\n+    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,\n+\t  const streamsize __newlen, const streamsize __oldlen)\n+    {\n+      typedef _CharT\tchar_type;\n+      typedef _Traits\ttraits_type;\n+      typedef typename traits_type::int_type int_type;\n+      \n+      int_type __plen = static_cast<size_t>(__newlen - __oldlen); \n+      char_type* __pads = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __plen));\n+      traits_type::assign(__pads, __plen, __fill); \n+\n+      char_type* __beg;\n+      char_type* __end;\n+      size_t __mod = 0;\n+      size_t __beglen; //either __plen or __oldlen\n+      ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;\n+\n+      if (__adjust == ios_base::left)\n+\t{\n+\t  // Padding last.\n+\t  __beg = const_cast<char_type*>(__olds);\n+\t  __beglen = __oldlen;\n+\t  __end = __pads;\n+\t}\n+      else if (__adjust == ios_base::internal)\n+\t{\n+\t  // Pad after the sign, if there is one.\n+\t  // Pad after 0[xX], if there is one.\n+\t  // Who came up with these rules, anyway? Jeeze.\n+          locale __loc = __io.getloc();\n+\t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+\t  const char_type __minus = __ctype.widen('-');\n+\t  const char_type __plus = __ctype.widen('+');\n+\t  bool __testsign = __olds[0] == __minus || __olds[0] == __plus;\n+\t  bool __testhex = __ctype.widen('0') == __olds[0] \n+\t                   && (__ctype.widen('x') == __olds[1] \n+\t\t\t       || __ctype.widen('X') == __olds[1]);\n+\t  if (__testhex)\n+\t    {\n+\t      __news[0] = __olds[0]; \n+\t      __news[1] = __olds[1];\n+\t      __mod += 2;\n+\t      __news += 2;\n+\t      __beg = const_cast<char_type*>(__olds + __mod);\n+\t      __beglen = __oldlen - __mod;\n+\t      __end = __pads;\n+\t    }\n+\t  else if (__testsign)\n+\t    {\n+\t      __news[0] = __olds[0] == __plus ? __plus : __minus;\n+\t      ++__mod;\n+\t      ++__news;\n+\t      __beg = __pads;\n+\t      __beglen = __plen;\n+\t      __end = const_cast<char_type*>(__olds + __mod);\n+\t    }\n+\t  else\n+\t    {\n+\t      // Padding first.\n+\t      __beg = __pads;\n+\t      __beglen = __plen;\n+\t      __end = const_cast<char_type*>(__olds);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // Padding first.\n+\t  __beg = __pads;\n+\t  __beglen = __plen;\n+\t  __end = const_cast<char_type*>(__olds);\n+\t}\n+      traits_type::copy(__news, __beg, __beglen);\n+      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n+    }\n+\n+  // NB: Can't have default argument on non-member template, and\n+  // num_put doesn't have a _Traits template parameter, so this\n+  // forwarding template adds in the default template argument.\n+  template<typename _CharT>\n+    void\n+    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,\n+\t  const streamsize __newlen, const streamsize __oldlen)\n+    { \n+      return __pad<_CharT, char_traits<_CharT> >(__io, __fill, __news, \n+\t\t\t\t\t\t __olds, __newlen, __oldlen); \n+    }\n+\n   // Used by both numeric and monetary facets.\n   // Check to make sure that the __grouping_tmp string constructed in\n   // money_get or num_get matches the canonical grouping for a given\n@@ -1960,102 +2053,23 @@ namespace std\n   // only with __gbeg != __gend.\n   template<typename _CharT>\n     _CharT*\n-    __group_digits(_CharT* __s, _CharT __sep,  \n+    __add_grouping(_CharT* __s, _CharT __sep,  \n \t\t   const char* __gbeg, const char* __gend, \n \t\t   const _CharT* __first, const _CharT* __last)\n     {\n       if (__last - __first > *__gbeg)\n         {\n-          __s = __group_digits(__s,  __sep,\n+          __s = __add_grouping(__s,  __sep, \n \t\t\t       (__gbeg + 1 == __gend ? __gbeg : __gbeg + 1),\n \t\t\t       __gend, __first, __last - *__gbeg);\n           __first = __last - *__gbeg;\n           *__s++ = __sep;\n         }\n       do\n-        {\n-          *__s++ = *__first++;\n-        }\n+\t*__s++ = *__first++;\n       while (__first != __last);\n       return __s;\n     }\n-\n-  // XXX This stuff needs to be re-examined, heavily modified, or ditched.\n-  template<typename _CharT>\n-    _Format_cache<_CharT>::_Format_cache()\n-    : _M_valid(true), _M_use_grouping(false)\n-    { }\n-\n-  template<>\n-    _Format_cache<char>::_Format_cache();\n-\n-  template<>\n-    _Format_cache<wchar_t>::_Format_cache();\n-\n-  template<typename _CharT>\n-    void\n-    _Format_cache<_CharT>::_M_populate(ios_base& __io)\n-    {\n-      locale __loc = __io.getloc();\n-      numpunct<_CharT> const& __np = use_facet<numpunct<_CharT> >(__loc);\n-      _M_truename = __np.truename();\n-      _M_falsename = __np.falsename();\n-      _M_thousands_sep = __np.thousands_sep();\n-      _M_decimal_point = __np.decimal_point();\n-      _M_grouping = __np.grouping();\n-      _M_use_grouping = _M_grouping.size() != 0 && _M_grouping.data()[0] != 0;\n-      _M_valid = true;\n-    }\n-\n-  // This function is always called via a pointer installed in\n-  // an ios_base by ios_base::register_callback.\n-  template<typename _CharT>\n-    void\n-    _Format_cache<_CharT>::\n-    _S_callback(ios_base::event __ev, ios_base& __ios, int __ix) throw()\n-    {\n-      void*& __p = __ios.pword(__ix);\n-      switch (__ev)\n-        {\n-        case ios_base::erase_event:\n-          delete static_cast<_Format_cache<_CharT>*>(__p);\n-\t  __p = 0;\n-          break;\n-        case ios_base::copyfmt_event:\n-          // If just stored zero, the callback would get registered again.\n-          try \n-\t    { __p = new _Format_cache<_CharT>; }\n-          catch(...) \n-\t    { }\n-          break;\n-        case ios_base::imbue_event:\n-          static_cast<_Format_cache<_CharT>*>(__p)->_M_valid = false;\n-          break;\n-        }\n-    }\n-\n-  template<typename _CharT>\n-    _Format_cache<_CharT>*\n-    _Format_cache<_CharT>::_S_get(ios_base& __ios)\n-    {\n-      if (!_S_pword_ix)\n-        _S_pword_ix = ios_base::xalloc();  // XXX MT\n-      void*& __p = __ios.pword(_S_pword_ix);\n-\n-      // XXX What if pword fails? must check failbit, throw.\n-      if (__p == 0)  // XXX MT?  maybe sentry takes care of it\n-        {\n-          auto_ptr<_Format_cache<_CharT> > __ap(new _Format_cache<_CharT>);\n-          __ios.register_callback(&_Format_cache<_CharT>::_S_callback,\n-                                  _S_pword_ix);\n-          __p = __ap.release();\n-        }\n-      _Format_cache<_CharT>* __ncp = static_cast<_Format_cache<_CharT>*>(__p);\n-      if (!__ncp->_M_valid)\n-        __ncp->_M_populate(__ios);\n-\n-      return __ncp;\n-    }\n } // namespace std\n \n #endif"}, {"sha": "8ecd01998c2266ac2b44c7de378e1fcc2c71cf1d", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 6, "deletions": 93, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -465,93 +465,6 @@ namespace std\n     }\n \n   // 27.6.2.5.4 Character inserters\n-\n-  // Construct correctly padded string, as per 22.2.2.2.2\n-  // Similar in theory to __pad_numeric, from num_put, but it doesn't\n-  // use _S_fill: perhaps it should.\n-  // Assumes \n-  // __newlen > __oldlen\n-  // __news is allocated for __newlen size\n-  template<typename _CharT, typename _Traits>\n-    void\n-    __pad_char(basic_ios<_CharT, _Traits>& __ios, \n-\t       _CharT* __news, const _CharT* __olds,\n-\t       const streamsize __newlen, const streamsize __oldlen)\n-    {\n-      typedef _CharT\tchar_type;\n-      typedef _Traits\ttraits_type;\n-      typedef typename traits_type::int_type int_type;\n-      \n-      int_type __plen = static_cast<size_t>(__newlen - __oldlen); \n-      char_type* __pads = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __plen));\n-      traits_type::assign(__pads, __plen, __ios.fill()); \n-\n-      char_type* __beg;\n-      char_type* __end;\n-      size_t __mod = 0;\n-      size_t __beglen; //either __plen or __oldlen\n-      ios_base::fmtflags __adjust = __ios.flags() & ios_base::adjustfield;\n-\n-      if (__adjust == ios_base::left)\n-\t{\n-\t  // Padding last.\n-\t  __beg = const_cast<char_type*>(__olds);\n-\t  __beglen = __oldlen;\n-\t  __end = __pads;\n-\t}\n-      else if (__adjust == ios_base::internal)\n-\t{\n-\t  // Pad after the sign, if there is one.\n-\t  // Pad after 0[xX], if there is one.\n-\t  // Who came up with these rules, anyway? Jeeze.\n-\t  typedef _Format_cache<_CharT> __cache_type;\n-\t  __cache_type const* __fmt = __cache_type::_S_get(__ios);\n-\t  const char_type* __minus = traits_type::find(__olds, __oldlen, \n-\t\t\t\t\t\t       __fmt->_S_minus);\n-\t  const char_type* __plus = traits_type::find(__olds, __oldlen, \n-\t\t\t\t\t\t      __fmt->_S_plus);\n-\t  bool __testsign = __minus || __plus;\n-\t  bool __testhex = __olds[0] == '0' \n-\t    \t\t   && (__olds[1] == 'x' || __olds[1] == 'X');\n-\n-\t  if (__testhex)\n-\t    {\n-\t      __news[0] = __olds[0]; \n-\t      __news[1] = __olds[1];\n-\t      __mod += 2;\n-\t      __beg = const_cast<char_type*>(__olds + __mod);\n-\t      __beglen = __oldlen - __mod;\n-\t      __end = __pads;\n-\t    }\n-\t  else if (__testsign)\n-\t    {\n-\t      __mod += __plen;\n-\t      const char_type* __sign = __minus ? __minus + 1: __plus + 1;\n-\t      __beg = const_cast<char_type*>(__olds);\n-\t      __beglen = __sign - __olds;\n-\t      __end = const_cast<char_type*>(__sign + __plen);\n-\t      traits_type::copy(__news + __beglen, __pads, __plen);\n-\t    }\n-\t  else\n-\t    {\n-\t      // Padding first.\n-\t      __beg = __pads;\n-\t      __beglen = __plen;\n-\t      __end = const_cast<char_type*>(__olds);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  // Padding first.\n-\t  __beg = __pads;\n-\t  __beglen = __plen;\n-\t  __end = const_cast<char_type*>(__olds);\n-\t}\n-\n-      traits_type::copy(__news, __beg, __beglen);\n-      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n-    }\n-\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n@@ -568,7 +481,7 @@ namespace std\n \t      streamsize __len = 1;\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad_char(__out, __pads, &__c, __w, __len);\n+\t\t  __pad(__out, __out.fill(), __pads, &__c, __w, __len);\n \t\t  __len = __w;\n \t\t}\n \t      __out.write(__pads, __len);\n@@ -603,7 +516,7 @@ namespace std\n \t      streamsize __len = 1;\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad_char(__out, __pads, &__c, __w, __len);\n+\t\t  __pad(__out, __out.fill(), __pads, &__c, __w, __len);\n \t\t  __len = __w;\n \t\t}\n \t      __out.write(__pads, __len);\n@@ -636,7 +549,7 @@ namespace std\n \t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad_char(__out, __pads, __s, __w, __len);\n+\t\t  __pad(__out, __out.fill(), __pads, __s, __w, __len);\n \t\t  __s = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -682,7 +595,7 @@ namespace std\n \t      \n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad_char(__out, __pads, __ws, __w, __len);\n+\t\t  __pad(__out, __out.fill(), __pads, __ws, __w, __len);\n \t\t  __str = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -717,7 +630,7 @@ namespace std\n \t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad_char(__out, __pads, __s, __w, __len);\n+\t\t  __pad(__out, __out.fill(), __pads, __s, __w, __len);\n \t\t  __s = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -755,7 +668,7 @@ namespace std\n #endif\n \t  if (__w > __len)\n \t    {\n-\t      __pad_char(__out, __pads, __s, __w, __len);\n+\t      __pad(__out, __out.fill(), __pads, __s, __w, __len);\n \t      __s = __pads;\n \t      __len = __w;\n \t    }"}, {"sha": "4afbbc0528da726f19a0a0206f5c60b5d3a1fa69", "filename": "libstdc++-v3/include/bits/std_istream.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -159,21 +159,21 @@ namespace std\n \n       inline __istream_type& \n       get(char_type* __s, streamsize __n)\n-      { return get(__s, __n, this->widen('\\n')); }\n+      { return this->get(__s, __n, this->widen('\\n')); }\n \n       __istream_type&\n       get(__streambuf_type& __sb, char_type __delim);\n \n       inline __istream_type&\n       get(__streambuf_type& __sb)\n-      { return get(__sb, this->widen('\\n')); }\n+      { return this->get(__sb, this->widen('\\n')); }\n \n       __istream_type& \n       getline(char_type* __s, streamsize __n, char_type __delim);\n \n       inline __istream_type& \n       getline(char_type* __s, streamsize __n)\n-      { return getline(__s, __n, this->widen('\\n')); }\n+      { return this->getline(__s, __n, this->widen('\\n')); }\n \n       __istream_type& \n       ignore(streamsize __n = 1, int_type __delim = traits_type::eof());\n@@ -297,4 +297,3 @@ namespace std\n #endif\n \n #endif\t/* _CPP_ISTREAM */\n-"}, {"sha": "3061fcc4cc7be9a190bbee12de08a0a64660e165", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -171,8 +171,7 @@ namespace std\n       { \n \tint_type __eof = traits_type::eof();\n \tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_sbuf \n-\t  \t      || __b._M_sbuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n \n@@ -184,8 +183,7 @@ namespace std\n       {\n \tint_type __eof = traits_type::eof();\n \tbool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;\n-\tbool __beof = !__b._M_sbuf \n-\t  \t      || __b._M_sbuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n #endif"}, {"sha": "90379fb8845fc7c1ea4a1ef8efa801c6a0251b80", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -284,12 +284,6 @@ namespace std\n   {\n     locale __old = _M_ios_locale;\n     _M_ios_locale = __loc;\n-    // Make sure there's a callback for the format caches so they will be\n-    // marked dirty.\n-    _Format_cache<char>::_S_get(*this);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _Format_cache<wchar_t>::_S_get(*this);\n-#endif\n     _M_call_callbacks(imbue_event);\n     return __old;\n   }"}, {"sha": "5107a2963d4ea36e13de2105d5186837f3cac7f4", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 93, "deletions": 48, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -56,7 +56,6 @@ namespace std\n   template class moneypunct_byname<char, true>;\n   template class money_get<char, ibuf_iterator>;\n   template class money_put<char, obuf_iterator>;\n-  template class _Format_cache<char>;\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class moneypunct<wchar_t, false>;\n@@ -65,19 +64,91 @@ namespace std\n   template class moneypunct_byname<wchar_t, true>;\n   template class money_get<wchar_t, wibuf_iterator>;\n   template class money_put<wchar_t, wobuf_iterator>;\n-  template class _Format_cache<wchar_t>;\n #endif\n \n   // numpunct, numpunct_byname, num_get, and num_put\n   template class numpunct<char>;\n   template class numpunct_byname<char>;\n   template class num_get<char, ibuf_iterator>;\n-  template class num_put<char, obuf_iterator>;\n+  template class num_put<char, obuf_iterator>; \n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_int(obuf_iterator, ios_base&, char, char, char, long) const;\n+\n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_int(obuf_iterator, ios_base&, char, char, char, \n+\t\t   unsigned long) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_int(obuf_iterator, ios_base&, char, char, char, \n+\t\t   long long) const;\n+\n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_int(obuf_iterator, ios_base&, char, char, char,\n+\t\t   unsigned long long) const;\n+#endif\n+\n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_float(obuf_iterator, ios_base&, char, char, double) const;\n+\n+  template\n+    obuf_iterator\n+    num_put<char, obuf_iterator>::\n+    _M_convert_float(obuf_iterator, ios_base&, char, char, \n+\t\t    long double) const;\n+\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class numpunct<wchar_t>;\n   template class numpunct_byname<wchar_t>;\n   template class num_get<wchar_t, wibuf_iterator>;\n   template class num_put<wchar_t, wobuf_iterator>;\n+\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_int(wobuf_iterator, ios_base&, wchar_t, char, char, long) const;\n+\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_int(wobuf_iterator, ios_base&, wchar_t, char, char,\n+\t\t   unsigned long) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_int(wobuf_iterator, ios_base&, wchar_t, char, char,\n+\t\t   long long) const;\n+\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_int(wobuf_iterator, ios_base&, wchar_t, char, char,\n+\t\t   unsigned long long) const;\n+#endif\n+\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_float(wobuf_iterator, ios_base&, wchar_t, char, \n+\t\t     double) const;\n+\n+  template\n+    wobuf_iterator\n+    num_put<wchar_t, wobuf_iterator>::\n+    _M_convert_float(wobuf_iterator, ios_base&, wchar_t, char, \n+\t\t     long double) const;\n #endif\n \n   // time_get and time_put\n@@ -246,45 +317,32 @@ namespace std\n   typedef ostreambuf_iterator<char, char_traits<char> > ostreambuf_iter;\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n-  typedef istreambuf_iterator<wchar_t,char_traits<wchar_t> > wistreambuf_iter;\n-  typedef ostreambuf_iterator<wchar_t,char_traits<wchar_t> > wostreambuf_iter;\n+  typedef istreambuf_iterator<wchar_t, char_traits<wchar_t> > wistreambuf_iter;\n+  typedef ostreambuf_iterator<wchar_t, char_traits<wchar_t> > wostreambuf_iter;\n #endif\n \n   template \n     bool\n     locale::operator()(const string&, const string&) const;\n \n-  template\n-    ostreambuf_iter\n-    __pad<char, ostreambuf_iter, output_iterator_tag>\n-    (ostreambuf_iter, char, int, output_iterator_tag);\n-\n-  template \n-    ostreambuf_iter\n-    __pad_numeric<char, ostreambuf_iter>\n-    (ostreambuf_iter, ios_base::fmtflags, char, int, char const*, char const*, \n-     char const*);\n-\n   template\n     char*\n-    __group_digits<char>(char*, char, char const*, char const*, \n+    __add_grouping<char>(char*, char, char const*, char const*, \n \t\t\t char const*, char const*);\n \n   template\n     bool\n     __verify_grouping<char>(const basic_string<char>&, basic_string<char>&);\n \n-  template \n-    ostreambuf_iter\n-    __output_integer<char, ostreambuf_iter, unsigned long>\n-    (ostreambuf_iter, ios_base &, char, bool, unsigned long);\n+  template\n+    void \n+    __pad<char>(ios_base&, char, char*, const char *, streamsize, \n+\t\tstreamsize);\n \n-#ifdef _GLIBCPP_USE_LONG_LONG\n   template\n-    ostreambuf_iter\n-    __output_integer<char, ostreambuf_iter, unsigned long long>\n-    (ostreambuf_iter, ios_base &, char, bool, unsigned long long);\n-#endif\n+    void \n+    __pad<char, char_traits<char> >(ios_base&, char, char*, \n+\t\t\t\t    const char *, streamsize, streamsize);\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template \n@@ -293,37 +351,25 @@ namespace std\n \n   typedef ostreambuf_iterator<wchar_t> wostreambuf_iter;\n \n-  template\n-    wostreambuf_iter\n-    __pad<wchar_t, wostreambuf_iter, output_iterator_tag>\n-    (wostreambuf_iter, wchar_t, int, output_iterator_tag);\n-\n-  template \n-    wostreambuf_iter\n-    __pad_numeric<wchar_t, wostreambuf_iter>\n-    (wostreambuf_iter, ios_base::fmtflags, wchar_t __fill, int, wchar_t const*,\n-     wchar_t const*, wchar_t const*);\n-\n   template\n     wchar_t*\n-    __group_digits<wchar_t>(wchar_t*, wchar_t, char const*, char const*, \n+    __add_grouping<wchar_t>(wchar_t*, wchar_t, char const*, char const*, \n \t\t\t    wchar_t const*, wchar_t const*);\n   template\n     bool\n     __verify_grouping<wchar_t>(const basic_string<wchar_t>&, \n \t\t\t       basic_string<wchar_t>&);\n \n-  template \n-    wostreambuf_iter\n-    __output_integer<wchar_t, wostreambuf_iter, unsigned long>\n-    (wostreambuf_iter, ios_base &, wchar_t, bool, unsigned long);\n+  template\n+    void \n+    __pad<wchar_t>(ios_base&, wchar_t, wchar_t*, const wchar_t*, \n+\t\t   streamsize, streamsize);\n \n-#ifdef _GLIBCPP_USE_LONG_LONG\n   template\n-    wostreambuf_iter\n-    __output_integer<wchar_t, wostreambuf_iter, unsigned long long>\n-    (wostreambuf_iter, ios_base &, wchar_t, bool, unsigned long long);\n-#endif\n+    void \n+    __pad<wchar_t, char_traits<wchar_t> >(ios_base&, wchar_t, wchar_t*, \n+\t\t\t\t\t  const wchar_t*, \n+\t\t\t\t\t  streamsize, streamsize);\n #endif // _GLIBCPP_USE_WCHAR_T\n \n   template \n@@ -342,4 +388,3 @@ namespace std\n          __normal_iterator<locale::facet**, vector<locale::facet*> >,\n          locale::facet* const&);\n } // namespace std\n-"}, {"sha": "c3572c40b1593674c614e60b5b4c7c711c68bf16", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 43, "deletions": 331, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -74,6 +74,8 @@ namespace std\n   // Definitions for static const data members of locale::id\n   size_t locale::id::_S_highwater;  // init'd to 0 by linker\n \n+  const char __num_base::_S_atoms[] = \"0123456789eEabcdfxABCDFX\";\n+\n   // Definitions for static const data members of locale::_Impl\n   const locale::id* const\n   locale::_Impl::_S_id_ctype[] =\n@@ -353,7 +355,7 @@ namespace std\n   void  \n   locale::facet::\n   _M_add_reference() throw()\n-  { ++_M_references; }                     // XXX MT\n+  { ++_M_references; }  // XXX MT\n \n   void  \n   locale::facet::\n@@ -457,22 +459,6 @@ namespace std\n   const money_base::pattern \n   money_base::_S_default_pattern =  {{symbol, sign, none, value}};\n \n-  template<>\n-    _Format_cache<char>::_Format_cache()\n-    : _M_valid(true),\n-    _M_decimal_point('.'), _M_thousands_sep(','),\n-    _M_truename(\"true\"), _M_falsename(\"false\"), _M_use_grouping(false)\n-    { }\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    _Format_cache<wchar_t>::_Format_cache()\n-    : _M_valid(true),\n-    _M_decimal_point(L'.'), _M_thousands_sep(L','),\n-    _M_truename(L\"true\"), _M_falsename(L\"false\"), _M_use_grouping(false)\n-    { }\n-#endif\n-\n   template<>\n     const ctype<char>&\n     use_facet<ctype<char> >(const locale& __loc)\n@@ -493,310 +479,9 @@ namespace std\n     }\n #endif\n \n-  template<>\n-    void\n-    num_get<char, istreambuf_iterator<char> >::\n-    _M_extract(istreambuf_iterator<char> __beg, \n-\t       istreambuf_iterator<char> __end, ios_base& __io, \n-\t       ios_base::iostate& __err, char* __xtrc, int& __base, \n-\t       bool __fp) const\n-    {\n-      typedef _Format_cache<char> __cache_type;\t\n-\n-      // Prepare for possible failure\n-      __xtrc[0] = '\\0';\n-\n-      // Stage 1: determine a conversion specifier.\n-      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n-      if (__basefield == ios_base::dec)\n-        __base = 10;\n-      else if (__basefield == ios_base::oct)\n-        __base = 8;\n-      else if (__basefield == ios_base::hex)\n-        __base = 16;\n-      else\n-        __base = 0;\n-      // As far as I can tell, bases other than 10 are not available for\n-      // floating point types\n-      if (__fp)\n-        __base = 10;\n-\n-      // Stage 2: extract characters.\n-      __cache_type const* __fmt = __cache_type::_S_get(__io);\n-\n-      // Fail quickly if !__valid\n-      if (__beg == __end)\n-        {\n-          __err |= (ios_base::eofbit | ios_base::failbit);\n-          return;\n-        }\n-\n-      // Acceptable formats for numbers here are based on 22.2.3.1\n-      string __grp;\n-      int __sep_pos = 0;\n-      int __pos = 0;\n-      const char* __lits = __fmt->_S_literals;\n-      char __c = *__beg;\n-\n-      // Check first for sign\n-      bool __testsign = false;\n-      if ((__c == __lits[__cache_type::_S_minus])\n-\t  || (__c == __lits[__cache_type::_S_plus]))\n-        {\n-          __testsign = true;\n-          __xtrc[__pos++] = __c;\n-          ++__beg;\n-\t  __c = * __beg;\n-\n-          // Whitespace may follow a sign\n-          while ((__beg != __end) && (isspace(__c)))\n-\t    {\n-\t      ++__beg;\n-\t      __c = *__beg;\n-\t    }\n-\n-          // There had better be more to come...\n-          if (__beg == __end)\n-            {\n-              __xtrc[__pos] = '\\0';\n-              __err |= (ios_base::eofbit | ios_base::failbit);\n-              return;\n-            }\n-        }\n-\n-      // Now check if first character is a zero.\n-      bool __testzero = false;    \n-      if (__c == __lits[__cache_type::_S_digits])\n-        {\n-           __testzero = true;\n-           ++__beg;\n-\t   __c = *__beg;\n-\n-           // We have to check for __beg == __end here. If so,\n-           // a plain '0' (possibly with a sign) can be got rid of now\n-           if (__beg == __end)\n-             {\n-               __xtrc[__pos++] = __lits[__cache_type::_S_digits];\n-               __xtrc[__pos] = '\\0';\n-               __err |= ios_base::eofbit;\n-               return;\n-             }\n-\n-          // Figure out base for integer types only\n-          // Based on Table 55 of 22.2.2.1.2\n-          if (!__fp && __base != 10 && __base != 8)\n-            {\n-              // Here, __base == 0 or 16\n-              if ((__c == __lits[__cache_type::_S_x])\n-                 || (__c == __lits[__cache_type::_S_X]))\n-                {\n-                  ++__beg;\n-\t\t  __c = *__beg;\n-                  __base = 16;\n-                  __testzero = false; // \"0x\" is not a leading zero\n-                }\n-              else if (__base == 0)\n-                __base = 8;\n-            }\n-\n-          // Remove any more leading zeros\n-          while (__beg != __end)\n-            {\n-              if (__c == __lits[__cache_type::_S_digits])\n-                {\n-                  ++__beg;\n-\t\t  __c = *__beg;\n-                  __testzero = true;\n-                }\n-              else\n-                break;\n-            }\n-        }\n-      else if (__base == 0) // 1st character is not zero\n-        __base = 10;\n-\n-      // We now seek \"units\", i.e. digits and thousands separators.\n-      // We may need to know if anything is found here. A leading zero\n-      // (removed by now) would count.\n-      bool __testunits = __testzero;\n-      while (__beg != __end)\n-        {\n-          const char* __p = strchr(__lits, __c);\n-\n-          // NB: strchr returns true for __c == 0x0\n-          if (__p && __c\n-\t      &&((__p >= &__lits[__cache_type::_S_digits]\n-\t\t  && __p < &__lits[__cache_type::_S_digits + __base])\n-\t\t || (__p >= &__lits[__cache_type::_S_udigits]\n-\t\t     && __p < &__lits[__cache_type::_S_udigits + __base])))\n-\t    {\n-\t      // Try first for acceptable digit; record it if found.\n-\t      __xtrc[__pos++] = __c;\n-\t      ++__sep_pos;\n-\t      __testunits = true;\n-\t      ++__beg;\n-\t      __c = *__beg;\n-\t    }\n-          else if (__c == __fmt->_M_thousands_sep && __fmt->_M_use_grouping)\n-\t    {\n-              // NB: Thousands separator at the beginning of a string\n-              // is a no-no, as is two consecutive thousands\n-              // separators.\n-              if (__sep_pos)\n-                {\n-                  __grp += static_cast<char>(__sep_pos);\n-                  __sep_pos = 0;\n-\t\t  ++__beg;\n-\t\t  __c = *__beg;\n-                }\n-              else\n-\t\t{\n-\t\t  __err |= ios_base::failbit;\n-\t\t  break;\n-\t\t}\n-            }\n-\t  else\n-\t    // Not a valid input item.\n-\t    break;\n-        }\n-\n-      // Digit grouping is checked. If _M_groupings() doesn't\n-      // match, then get very very upset, and set failbit.\n-      if (__fmt->_M_use_grouping && !__grp.empty())\n-        {\n-          // Add the ending grouping\n-          __grp += static_cast<char>(__sep_pos);\n-\n-          if (!__verify_grouping(__fmt->_M_grouping, __grp))\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n-        }\n-\n-      // If there was nothing but zeros, put one in the output string\n-      if (__testzero && (__pos == 0 || (__pos == 1 && __testsign)))\n-        __xtrc[__pos++] = __lits[__cache_type::_S_digits];\n-\n-      // That's it for integer types. Remaining code is for floating point\n-      if (__fp && __beg != __end)\n-        {\n-          // Check first for decimal point. There MUST be one if\n-          // __testunits is false.\n-          bool __testdec = false;    // Is there a decimal point\n-                                     // with digits following it?\n-          if (__c == __fmt->_M_decimal_point)\n-            {\n-              __xtrc[__pos++] = '.';\n-              ++__beg;\n-\t      __c = *__beg;\n-\n-              // Now we get any digits after the decimal point\n-              // There MUST be some if __testunits is false.\n-              while (__beg != __end)\n-                {\n-                  const char* __p = strchr(__lits, __c);\n-                  if ((__p >= &__lits[__cache_type::_S_digits]\n-                        && __p < &__lits[__cache_type::_S_digits + __base])\n-                       || (__p >= &__lits[__cache_type::_S_udigits]\n-                           && __p < &__lits[__cache_type::_S_udigits + __base]))\n-                    {\n-                      __xtrc[__pos++] = __c;\n-                      ++__beg;\n-\t\t      __c = *__beg;\n-                      __testdec = true;\n-                    }\n-                  else\n-                    break;\n-                }\n-            }\n-          if (!__testunits && !__testdec) // Ill formed\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n-\n-          // Now we may find an exponent\n-          if (__beg != __end)\n-            {\n-              if ((__c == __lits[__cache_type::_S_ee])\n-                   || (__c == __lits[__cache_type::_S_Ee]))\n-                {\n-                  __xtrc[__pos++] = __c;\n-                  ++__beg;\n-\t\t  __c = *__beg;\n-\n-                  // Now there may be a sign\n-                  if (__beg != __end)\n-                    {\n-                      if ((__c == __lits[__cache_type::_S_minus])\n-                          || (__c == __lits[__cache_type::_S_plus]))\n-                        {\n-                          __xtrc[__pos++] = __c;\n-                          ++__beg;\n-\t\t\t  __c = *__beg;\n-                          // whitespace may follow a sign\n-                          while ((__beg != __end) && (isspace(__c)))\n-\t\t\t    {\n-\t\t\t      ++__beg;\n-\t\t\t      __c = *__beg;\n-\t\t\t    }\n-                        }\n-                    }\n-                  // And now there must be some digits\n-                  if (__beg == __end)\n-                    {\n-                      __xtrc[__pos] = '\\0';\n-                      __err |= (ios_base::eofbit | ios_base::failbit);\n-                      return;\n-                    }\n-                  while (__beg != __end)\n-                    {\n-                      const char* __p = strchr(__lits, __c);\n-                      if ((__p >= &__lits[__cache_type::_S_digits]\n-                            && __p < &__lits[__cache_type::_S_digits + __base])\n-                           || (__p >= &__lits[__cache_type::_S_udigits]\n-                               && __p < &__lits[__cache_type::_S_udigits + __base]))\n-                        {\n-                          __xtrc[__pos++] = __c;\n-                          ++__beg;\n-\t\t\t  __c = *__beg;\n-                        }\n-                      else\n-                        break;\n-                    }\n-                }\n-            }\n-          // Finally, that's it for floating point\n-        }\n-\n-      // Finish up\n-      __xtrc[__pos] = '\\0';\n-      if (__beg == __end)\n-        __err |= ios_base::eofbit;\n-    }\n-\n-  // The following code uses sprintf() to convert floating point\n-  // values for insertion into a stream. The current implementation\n-  // replicates the code in _S_pad_numeric() (in _S_output_float()) in\n-  // order to prevent having to create a \"wide\" buffer in addition to\n-  // the \"narrow\" buffer passed to sprintf(). An optimization would be\n-  // to replace sprintf() with code that works directly on a wide\n-  // buffer and then use _S_pad_numeric() to do the padding. It would\n-  // be good to replace sprintf() anyway to avoid accidental buffer\n-  // overruns and to gain back the efficiency that C++ provides by\n-  // knowing up front the type of the values to insert. This\n-  // implementation follows the C++ standard fairly directly as\n-  // outlined in 22.2.2.2 [lib.locale.num.put]\n   bool\n-  __build_float_format(ios_base& __io, char* __fptr, char __modifier,\n-\t\t       streamsize __prec)\n+  __num_base::_S_format_float(const ios_base& __io, char* __fptr, char __mod,\n+\t\t\t      streamsize __prec)\n   {\n     bool __incl_prec = false;\n     ios_base::fmtflags __flags = __io.flags();\n@@ -809,12 +494,12 @@ namespace std\n     // As per [22.2.2.2.2.11]\n     if (__flags & ios_base::fixed || __prec > 0)\n       {\n-        *__fptr++ = '.';\n-        *__fptr++ = '*';\n-        __incl_prec = true;\n+\t*__fptr++ = '.';\n+\t*__fptr++ = '*';\n+\t__incl_prec = true;\n       }\n-    if (__modifier)\n-      *__fptr++ = __modifier;\n+    if (__mod)\n+      *__fptr++ = __mod;\n     ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n     // [22.2.2.2.2] Table 58\n     if (__fltfield == ios_base::fixed)\n@@ -826,16 +511,43 @@ namespace std\n     *__fptr = '\\0';\n     return __incl_prec;\n   }\n+  \n+  void\n+  __num_base::_S_format_int(const ios_base& __io, char* __fptr, char __mod, \n+\t\t\t    char __modl)\n+  {\n+    ios_base::fmtflags __flags = __io.flags();\n+    *__fptr++ = '%';\n+    // [22.2.2.2.2] Table 60\n+    if (__flags & ios_base::showpos)\n+      *__fptr++ = '+';\n+    if (__flags & ios_base::showbase)\n+      *__fptr++ = '#';\n+    *__fptr++ = 'l';\n+\n+    // For long long types.\n+    if (__modl)\n+      *__fptr++ = __modl;\n \n+    ios_base::fmtflags __bsefield = __flags & ios_base::basefield;\n+    if (__bsefield == ios_base::hex)\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'X' : 'x';\n+    else if (__bsefield == ios_base::oct)\n+      *__fptr++ = 'o';\n+    else\n+      *__fptr++ = __mod;\n+    *__fptr = '\\0';\n+  }\n+  \n   template<>\n-  moneypunct_byname<char, false>::moneypunct_byname(const char* /*__s*/, \n-\t\t\t\t\t\t    size_t __refs)\n-  : moneypunct<char, false>(__refs) { }\n+    moneypunct_byname<char, false>::moneypunct_byname(const char* /*__s*/, \n+\t\t\t\t\t\t      size_t __refs)\n+    : moneypunct<char, false>(__refs) { }\n   \n   template<>\n-  moneypunct_byname<char, true>::moneypunct_byname(const char* /*__s*/, \n-\t\t\t\t\t\t   size_t __refs)\n-  : moneypunct<char, true>(__refs) { }\n+    moneypunct_byname<char, true>::moneypunct_byname(const char* /*__s*/, \n+\t\t\t\t\t\t     size_t __refs)\n+    : moneypunct<char, true>(__refs) { }\n   \n #ifdef _GLIBCPP_USE_WCHAR_T  \n   ctype<wchar_t>::__wmask_type"}, {"sha": "484a551c44d01916e74098dcae6f54126737077b", "filename": "libstdc++-v3/src/misc-inst.cc", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -241,39 +241,6 @@ namespace std\n     (vector<string>::const_iterator, vector<string>::const_iterator, \n      string*, __false_type);\n \n-  template\n-    void \n-    __pad_char(basic_ios<char>&, char*, const char*,\n-\t\tconst streamsize, const streamsize);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template\n-    void \n-    __pad_char(basic_ios<wchar_t>&, wchar_t*, const wchar_t*,\n-\t\tconst streamsize, const streamsize);\n-#endif\n-\n-  template\n-    ostreambuf_iterator<char>\n-    __pad_numeric(ostreambuf_iterator<char>, _Ios_Fmtflags, char, int,\n-\t\t  const char*, const char*, const char*);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    __pad_numeric(ostreambuf_iterator<wchar_t>, _Ios_Fmtflags, wchar_t, int,\n-\t\t  const wchar_t*, const wchar_t*, const wchar_t*);\n-#endif\n-\n-  template\n-    ostreambuf_iterator<char>\n-    __output_float(ostreambuf_iterator<char>, ios_base&, char, \n-\t\t   const char*, size_t);\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template\n-    ostreambuf_iterator<wchar_t>\n-    __output_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n-\t\t   const char*, size_t);\n-#endif\n-\n   template\n     streamsize\n     __copy_streambufs(basic_ios<char>&, basic_streambuf<char>*,"}, {"sha": "fae184d6cdbd9abd6361aa572aed7718fc5afd45", "filename": "libstdc++-v3/testsuite/22_locale/num_get.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,52 @@\n+// 2001-11-21  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1  Template class num_get\n+\n+#include <locale>\n+\n+void test01()\n+{\n+  // Check for required base class.\n+  typedef std::num_get<char> test_type;\n+  typedef std::locale::facet base_type;\n+  const test_type& obj = std::use_facet<test_type>(std::locale()); \n+  const base_type* base = &obj;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type char_type;\n+  typedef test_type::iter_type iter_type;\n+}\n+\n+// Should be able to instantiate this for other types besides char, wchar_t\n+class gnu_num_get: public std::num_get<unsigned char> \n+{ };\n+\n+void test02()\n+{ \n+  gnu_num_get facet01;\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "3ab623645fcfff325825d0335b6facbd8eee9c50", "filename": "libstdc++-v3/testsuite/22_locale/num_get_members_char.cc", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get_members_char.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,246 @@\n+// 2001-11-21 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+\n+  bool test = true;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_hk(\"en_HK\");\n+  locale loc_fr(\"fr_FR@euro\");\n+  locale loc_de(\"de_DE\");\n+  VERIFY( loc_c != loc_de );\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the numpunct facets\n+  const numpunct<char>& numpunct_c = use_facet<numpunct<char> >(loc_c); \n+  const numpunct<char>& numpunct_de = use_facet<numpunct<char> >(loc_de); \n+  const numpunct<char>& numpunct_hk = use_facet<numpunct<char> >(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const string empty;\n+  char c;\n+\n+  bool b1 = true;\n+  bool b0 = false;\n+  long l1 = 2147483647;\n+  long l2 = -2147483647;\n+  long l;\n+  unsigned long ul1 = 1294967294;\n+  unsigned long ul2 = 0;\n+  unsigned long ul;\n+  double d1 =  1.02345e+308;\n+  double d2 = 3.15e-308;\n+  double d;\n+  long double ld1 = 6.630025e+4;\n+  long double ld2 = 0.0;\n+  long double ld;\n+  void* v;\n+  const void* cv = &ul2;\n+\n+  // cache the num_get facet\n+  istringstream iss;\n+  iss.imbue(loc_de);\n+  const num_get<char>& ng = use_facet<num_get<char> >(iss.getloc()); \n+  const ios_base::iostate goodbit = ios_base::goodbit;\n+  const ios_base::iostate eofbit = ios_base::eofbit;\n+  ios_base::iostate err = ios_base::goodbit;\n+\n+  // bool, simple\n+  iss.str(\"1\");\n+  iterator_type os_it00 = iss.rdbuf();\n+  iterator_type os_it01 = ng.get(os_it00, 0, iss, err, b1);\n+  VERIFY( b1 == true );\n+  VERIFY( err & ios_base::eofbit );\n+\n+  iss.str(\"0\");\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, b0);\n+  VERIFY( b0 == false );\n+  VERIFY( err & eofbit );\n+\n+  // bool, more twisted examples\n+  iss.imbue(loc_c);\n+  iss.str(\"true \");\n+  iss.clear();\n+  iss.setf(ios_base::boolalpha);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, b0);\n+  VERIFY( b0 == true );\n+  VERIFY( err == goodbit );\n+\n+  iss.str(\"false \");\n+  iss.clear();\n+  iss.setf(ios_base::boolalpha);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, b1);\n+  VERIFY( b1 == false );\n+  VERIFY( err == goodbit );\n+\n+  // long, in a locale that expects grouping\n+  iss.imbue(loc_hk);\n+  iss.str(\"2,147,483,647 \");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, l);\n+  VERIFY( l == l1 );\n+  VERIFY( err == goodbit );\n+\n+  iss.str(\"-2,147,483,647++++++\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, l);\n+  VERIFY( l == l2 );\n+  VERIFY( err == goodbit );\n+\n+  // unsigned long, in a locale that does not group\n+  iss.imbue(loc_c);\n+  iss.str(\"1294967294\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ul);\n+  VERIFY( ul == ul1);\n+  VERIFY( err == eofbit );\n+\n+  iss.str(\"0+++++++++++++++++++\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ul);\n+  VERIFY( ul == ul2);\n+  VERIFY( err == goodbit );\n+\n+  // ... and one that does\n+  iss.imbue(loc_de);\n+  iss.str(\"1.294.967.294+++++++\");\n+  iss.clear();\n+  iss.width(20);\n+  iss.setf(ios_base::left, ios_base::adjustfield);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ul);\n+  VERIFY( ul == ul1 );\n+  VERIFY( err == goodbit );\n+\n+  // double\n+  iss.imbue(loc_c);\n+  iss.str(\"1.02345e+308++++++++\");\n+  iss.clear();\n+  iss.width(20);\n+  iss.setf(ios_base::left, ios_base::adjustfield);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( d == d1 );\n+  VERIFY( err == goodbit );\n+\n+  iss.str(\"+3.15e-308\");\n+  iss.clear();\n+  iss.width(20);\n+  iss.setf(ios_base::right, ios_base::adjustfield);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( d == d2 );\n+  VERIFY( err == eofbit );\n+\n+  iss.imbue(loc_de);\n+  iss.str(\"+1,02345e+308\");\n+  iss.clear();\n+  iss.width(20);\n+  iss.setf(ios_base::right, ios_base::adjustfield);\n+  iss.setf(ios_base::scientific, ios_base::floatfield);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( d == d1 );\n+  VERIFY( err == eofbit );\n+\n+  iss.str(\"3,15E-308 \");\n+  iss.clear();\n+  iss.width(20);\n+  iss.precision(10);\n+  iss.setf(ios_base::right, ios_base::adjustfield);\n+  iss.setf(ios_base::scientific, ios_base::floatfield);\n+  iss.setf(ios_base::uppercase);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( d == d2 );\n+  VERIFY( err == goodbit );\n+\n+  // long double\n+  iss.str(\"6,630025e+4\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ld);\n+  VERIFY( ld == ld1 );\n+  VERIFY( err == eofbit );\n+\n+  iss.str(\"0 \");\n+  iss.clear();\n+  iss.precision(0);\n+  iss.setf(ios_base::fixed, ios_base::floatfield);\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ld);\n+  VERIFY( ld == 0 );\n+  VERIFY( err == goodbit );\n+\n+  // const void\n+  iss.str(\"0xbffff74c.\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, v);\n+  VERIFY( &v != &cv );\n+  VERIFY( err == goodbit );\n+\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  long long ll1 = 9223372036854775807;\n+  long long ll2 = -9223372036854775807;\n+  long long ll;\n+\n+  iss.str(\"9.223.372.036.854.775.807\");\n+  iss.clear();\n+  err = goodbit;\n+  ng.get(iss.rdbuf(), 0, iss, err, ll);\n+  VERIFY( ll == ll1 );\n+  VERIFY( err == eofbit );\n+#endif\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}\n+\n+\n+// Kathleen Hannah, humanitarian, woman, art-thief"}, {"sha": "1715231e99966c3d23db30e8a4b68fd84ebbfac2", "filename": "libstdc++-v3/testsuite/22_locale/num_put.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,52 @@\n+// 2001-11-19  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.2  Template class num_put\n+\n+#include <locale>\n+\n+void test01()\n+{\n+  // Check for required base class.\n+  typedef std::num_put<char> test_type;\n+  typedef std::locale::facet base_type;\n+  const test_type& obj = std::use_facet<test_type>(std::locale()); \n+  const base_type* base = &obj;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type char_type;\n+  typedef test_type::iter_type iter_type;\n+}\n+\n+// Should be able to instantiate this for other types besides char, wchar_t\n+class gnu_num_put: public std::num_put<unsigned char> \n+{ };\n+\n+void test02()\n+{ \n+  gnu_num_put facet01;\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "9bc5dce9d6eb21b76547d8531aec63913ff1ea45", "filename": "libstdc++-v3/testsuite/22_locale/num_put_members_char.cc", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_char.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,230 @@\n+// 2001-11-19 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.2.1  num_put members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef ostreambuf_iterator<char> iterator_type;\n+\n+  bool test = true;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_hk(\"en_HK\");\n+  locale loc_fr(\"fr_FR@euro\");\n+  locale loc_de(\"de_DE\");\n+  VERIFY( loc_c != loc_de );\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the numpunct facets\n+  const numpunct<char>& numpunct_c = use_facet<numpunct<char> >(loc_c); \n+  const numpunct<char>& numpunct_de = use_facet<numpunct<char> >(loc_de); \n+  const numpunct<char>& numpunct_hk = use_facet<numpunct<char> >(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const string empty;\n+  string result1;\n+  string result2;\n+  char c;\n+\n+  bool b1 = true;\n+  bool b0 = false;\n+  long l1 = 2147483647;\n+  long l2 = -2147483647;\n+  unsigned long ul1 = 1294967294;\n+  unsigned long ul2 = 0;\n+  double d1 =  1.7976931348623157e+308;\n+  double d2 = 2.2250738585072014e-308;\n+  long double ld1 = 1.7976931348623157e+308;\n+  long double ld2 = 2.2250738585072014e-308;\n+  const void* cv = &ld1;\n+\n+  // cache the num_put facet\n+  ostringstream oss;\n+  oss.imbue(loc_de);\n+  const num_put<char>& np = use_facet<num_put<char> >(oss.getloc()); \n+\n+  // bool, simple\n+  iterator_type os_it00 = oss.rdbuf();\n+  iterator_type os_it01 = np.put(os_it00, oss, '+', b1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"1\" );\n+  //  VERIFY( os_it00 != os_it01 );\n+\n+  oss.str(empty);\n+  np.put(oss.rdbuf(), oss, '+', b0);\n+  result2 = oss.str();\n+  VERIFY( result2 == \"0\" );\n+\n+  // bool, more twisted examples\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', b0);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"+++++++++++++++++++0\" );\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  oss.setf(ios_base::boolalpha);\n+  np.put(oss.rdbuf(), oss, '+', b1);\n+  result2 = oss.str();\n+  VERIFY( result2 == \"true++++++++++++++++\" );\n+\n+  // long, in a locale that expects grouping\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', l1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"2,147,483,647\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', l2);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"-2,147,483,647++++++\" );\n+\n+  // unsigned long, in a locale that does not group\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', ul1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"1294967294\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', ul2);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"0+++++++++++++++++++\" );\n+\n+  // ... and one that does\n+  oss.imbue(loc_de);\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', ul1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"1.294.967.294+++++++\" );\n+\n+  // double\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', d1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"1,79769e+308++++++++\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, '+', d2);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"++++++++2,22507e-308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  oss.setf(ios_base::scientific, ios_base::floatfield);\n+  np.put(oss.rdbuf(), oss, '+', d2);\n+  result2 = oss.str();\n+  VERIFY( result2 == \"+++++++2,225074e-308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.precision(10);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  oss.setf(ios_base::scientific, ios_base::floatfield);\n+  oss.setf(ios_base::uppercase);\n+  np.put(oss.rdbuf(), oss, '+', d2);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"+++2,2250738585E-308\" );\n+\n+  // long double\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', ld1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"1,7976931349E+308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.precision(0);\n+  oss.setf(ios_base::fixed, ios_base::floatfield);\n+  np.put(oss.rdbuf(), oss, '+', ld2);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"0\" );\n+\n+  // const void\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', cv);\n+  result1 = oss.str();\n+  // No grouping characters.\n+  VERIFY( !char_traits<char>::find(result1.c_str(), \n+\t\t\t\t   numpunct_de.decimal_point(), \n+\t\t\t\t   result1.size()) );\n+  // Should contain an 'x'.\n+  VERIFY( !char_traits<char>::find(result1.c_str(), 'x', result1.size()) );\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  long long ll1 = 9223372036854775807;\n+  long long ll2 = -9223372036854775807;\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', ll1);\n+  result1 = oss.str();\n+  VERIFY( result1 == \"9.223.372.036.854.775.807\" );\n+#endif\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "885df82d2464cf384f382476ce14955062fa9888", "filename": "libstdc++-v3/testsuite/22_locale/num_put_members_wchar_t.cc", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put_members_wchar_t.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,234 @@\n+// 2001-11-19 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.2.1  num_put members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+void test01()\n+{\n+  using namespace std;\n+  typedef ostreambuf_iterator<wchar_t> iterator_type;\n+\n+  bool test = true;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_hk(\"en_HK\");\n+  locale loc_fr(\"fr_FR@euro\");\n+  locale loc_de(\"de_DE\");\n+  VERIFY( loc_c != loc_de );\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the numpunct facets\n+  const numpunct<wchar_t>& numpunct_c = use_facet<numpunct<wchar_t> >(loc_c); \n+  const numpunct<wchar_t>& numpunct_de = use_facet<numpunct<wchar_t> >(loc_de); \n+  const numpunct<wchar_t>& numpunct_hk = use_facet<numpunct<wchar_t> >(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const wstring empty;\n+  wstring result1;\n+  wstring result2;\n+  wchar_t c;\n+\n+  bool b1 = true;\n+  bool b0 = false;\n+  long l1 = 2147483647;\n+  long l2 = -2147483647;\n+  unsigned long ul1 = 1294967294;\n+  unsigned long ul2 = 0;\n+  double d1 =  1.7976931348623157e+308;\n+  double d2 = 2.2250738585072014e-308;\n+  long double ld1 = 1.7976931348623157e+308;\n+  long double ld2 = 2.2250738585072014e-308;\n+  const void* cv = &ld1;\n+\n+  // cache the num_put facet\n+  wostringstream oss;\n+  oss.imbue(loc_de);\n+  const num_put<wchar_t>& np = use_facet<num_put<wchar_t> >(oss.getloc()); \n+\n+  // bool, simple\n+  iterator_type os_it00 = oss.rdbuf();\n+  iterator_type os_it01 = np.put(os_it00, oss, '+', b1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"1\" );\n+  //  VERIFY( os_it00 != os_it01 );\n+\n+  oss.str(empty);\n+  np.put(oss.rdbuf(), oss, L'+', b0);\n+  result2 = oss.str();\n+  VERIFY( result2 == L\"0\" );\n+\n+  // bool, more twisted examples\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', b0);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"+++++++++++++++++++0\" );\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  oss.setf(ios_base::boolalpha);\n+  np.put(oss.rdbuf(), oss, L'+', b1);\n+  result2 = oss.str();\n+  VERIFY( result2 == L\"true++++++++++++++++\" );\n+\n+  // long, in a locale that expects grouping\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'+', l1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"2,147,483,647\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', l2);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"-2,147,483,647++++++\" );\n+\n+  // unsigned long, in a locale that does not group\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'+', ul1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"1294967294\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', ul2);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"0+++++++++++++++++++\" );\n+\n+  // ... and one that does\n+  oss.imbue(loc_de);\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', ul1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"1.294.967.294+++++++\" );\n+\n+  // double\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::left, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', d1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"1,79769e+308++++++++\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  np.put(oss.rdbuf(), oss, L'+', d2);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"++++++++2,22507e-308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  oss.setf(ios_base::scientific, ios_base::floatfield);\n+  np.put(oss.rdbuf(), oss, L'+', d2);\n+  result2 = oss.str();\n+  VERIFY( result2 == L\"+++++++2,225074e-308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.width(20);\n+  oss.precision(10);\n+  oss.setf(ios_base::right, ios_base::adjustfield);\n+  oss.setf(ios_base::scientific, ios_base::floatfield);\n+  oss.setf(ios_base::uppercase);\n+  np.put(oss.rdbuf(), oss, L'+', d2);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"+++2,2250738585E-308\" );\n+\n+  // long double\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'+', ld1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"1,7976931349E+308\" );\n+\n+  oss.str(empty);\n+  oss.clear();\n+  oss.precision(0);\n+  oss.setf(ios_base::fixed, ios_base::floatfield);\n+  np.put(oss.rdbuf(), oss, L'+', ld2);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"0\" );\n+\n+  // const void\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, L'+', cv);\n+  result1 = oss.str();\n+  // No grouping characters.\n+  VERIFY( !char_traits<wchar_t>::find(result1.c_str(), \n+\t\t\t\t   numpunct_de.decimal_point(), \n+\t\t\t\t   result1.size()) );\n+  // Should contain an 'x'.\n+  VERIFY( !char_traits<wchar_t>::find(result1.c_str(), L'x', result1.size()) );\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  long long ll1 = 9223372036854775807;\n+  long long ll2 = -9223372036854775807;\n+\n+  oss.str(empty);\n+  oss.clear();\n+  np.put(oss.rdbuf(), oss, '+', ll1);\n+  result1 = oss.str();\n+  VERIFY( result1 == L\"9.223.372.036.854.775.807\" );\n+#endif\n+}\n+#endif\n+\n+int main()\n+{\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  test01();\n+#endif\n+  return 0;\n+}\n+\n+\n+// Diana D. Brooks, former chief executive of Sotheby's\n+// art-thief extraordinaire"}, {"sha": "901de4c1f616762b73408bc93bb5a973865cd34a", "filename": "libstdc++-v3/testsuite/22_locale/numpunct_members_char.cc", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_char.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -75,19 +75,12 @@ void test01()\n \n   VERIFY( dp2 != dp3 );\n   VERIFY( th2 != th3 );\n-#if 0\n-  // XXX isn't actually supported right now.\n-  VERIFY( t2 != t3 );\n-  VERIFY( f2 != f3 );\n-#endif\n \n   VERIFY( dp2 != dp4 );\n   VERIFY( th2 != th4 );\n-#if 0\n-  // XXX isn't actually supported right now.\n-  VERIFY( t2 != t3 );\n-  VERIFY( f2 != f3 );\n-#endif\n+  // XXX This isn't actually supported right now.\n+  // VERIFY( t2 != t3 );\n+  // VERIFY( f2 != f3 );\n }\n \n int main()"}, {"sha": "afb7eb9fbd0bc4b8839390801e1d022fcc86e0a4", "filename": "libstdc++-v3/testsuite/22_locale/numpunct_members_wchar_t.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -0,0 +1,88 @@\n+// 2001-11-20 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.3.1.1 nunpunct members\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+void test01()\n+{\n+  using namespace std;\n+  \n+  bool test = true;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  locale loc_us(\"en_US\");\n+  locale loc_fr(\"fr_FR\");\n+  locale loc_de(\"de_DE\");\n+  VERIFY( loc_c != loc_de );\n+  VERIFY( loc_us != loc_fr );\n+  VERIFY( loc_us != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the numpunct facets\n+  const numpunct<wchar_t>& nump_c = use_facet<numpunct<wchar_t> >(loc_c); \n+  const numpunct<wchar_t>& nump_us = use_facet<numpunct<wchar_t> >(loc_us); \n+  const numpunct<wchar_t>& nump_fr = use_facet<numpunct<wchar_t> >(loc_fr); \n+  const numpunct<wchar_t>& nump_de = use_facet<numpunct<wchar_t> >(loc_de); \n+\n+  // sanity check the data is correct.\n+  wchar_t dp1 = nump_c.decimal_point();\n+  wchar_t th1 = nump_c.thousands_sep();\n+  string g1 = nump_c.grouping();\n+  wstring t1 = nump_c.truename();\n+  wstring f1 = nump_c.falsename();\n+\n+  wchar_t dp2 = nump_us.decimal_point();\n+  wchar_t th2 = nump_us.thousands_sep();\n+  string g2 = nump_us.grouping();\n+  wstring t2 = nump_us.truename();\n+  wstring f2 = nump_us.falsename();\n+\n+  wchar_t dp3 = nump_fr.decimal_point();\n+  wchar_t th3 = nump_fr.thousands_sep();\n+  string g3 = nump_fr.grouping();\n+  wstring t3 = nump_fr.truename();\n+  wstring f3 = nump_fr.falsename();\n+\n+  wchar_t dp4 = nump_de.decimal_point();\n+  wchar_t th4 = nump_de.thousands_sep();\n+  string g4 = nump_de.grouping();\n+  wstring t4 = nump_de.truename();\n+  wstring f4 = nump_de.falsename();\n+\n+  VERIFY( dp2 != dp3 );\n+  VERIFY( th2 != th3 );\n+\n+  VERIFY( dp2 != dp4 );\n+  VERIFY( th2 != th4 );\n+}\n+\n+int main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}, {"sha": "0cb5ae0ed028374d0a43ca74efebe906b132dacd", "filename": "libstdc++-v3/testsuite/27_io/istream_extractor_arith.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -387,7 +387,7 @@ bool test09()\n }\n \n bool test10() {\n-  std::string str_01(\"0 00 000 +0 +  0 -   0\");\n+  std::string str_01(\"0 00 000 +0 +0 -0\");\n   std::stringbuf isbuf_01(str_01);\n   std::istream is_01(&isbuf_01);\n \n@@ -447,7 +447,7 @@ bool test10() {\n   VERIFY( n == 33 );\n   VERIFY( is_03.rdstate() == std::ios_base::eofbit );\n \n-  std::string str_04(\"3. 4.5E+  2a5E-3 .6E1\");\n+  std::string str_04(\"3. 4.5E+2a5E-3 .6E1\");\n   std::stringbuf isbuf_04(str_04);\n   std::istream is_04(&isbuf_04);\n "}, {"sha": "bd49ebf7f76e0d319f1de51c8f862ec8a2583a70", "filename": "libstdc++-v3/testsuite/27_io/ostream_inserter_arith.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream_inserter_arith.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ade44cb2ce7df746d88f6491de469cc6a62c14/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream_inserter_arith.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream_inserter_arith.cc?ref=86ade44cb2ce7df746d88f6491de469cc6a62c14", "patch": "@@ -63,13 +63,13 @@ static bool F=false;\n static _TestCase testcases[] =\n {\n #if _GLIBCPP_USE_WCHAR_T\n-  // standard output (no formatting applied)\n+  // standard output (no formatting applied) 1-4\n   { 1.2, 6,0,'.',' ', F,F,F,F,F,F,F,F, \"1.2\",L\"1.2\" },\n   { 54, 6,0,'.',' ', F,F,F,F,F,F,F,F, \"54\",L\"54\" },\n   { -.012, 6,0,'.',' ', F,F,F,F,F,F,F,F, \"-0.012\",L\"-0.012\" },\n   { -.00000012, 6,0,'.',' ', F,F,F,F,F,F,F,F, \"-1.2e-07\",L\"-1.2e-07\" },\n     \n-  // fixed formatting\n+  // fixed formatting 5-11\n   { 10.2345, 0,0,'.',' ', T,F,F,F,F,F,F,F, \"10\",L\"10\" },\n   { 10.2345, 0,0,'.',' ', T,F,F,T,F,F,F,F, \"10.\",L\"10.\" },\n   { 10.2345, 1,0,'.',' ', T,F,F,F,F,F,F,F, \"10.2\",L\"10.2\" },\n@@ -78,7 +78,7 @@ static _TestCase testcases[] =\n   { -10.2345, 6,0,'.',' ', T,F,F,F,F,F,F,F, \"-10.234500\",L\"-10.234500\" },\n   { -10.2345, 6,0,',',' ', T,F,F,F,F,F,F,F, \"-10,234500\",L\"-10,234500\" },\n \n-  // fixed formatting with width\n+  // fixed formatting with width 12-22\n   { 10.2345, 4,5,'.',' ', T,F,F,F,F,F,F,F, \"10.2345\",L\"10.2345\" },\n   { 10.2345, 4,6,'.',' ', T,F,F,F,F,F,F,F, \"10.2345\",L\"10.2345\" },\n   { 10.2345, 4,7,'.',' ', T,F,F,F,F,F,F,F, \"10.2345\",L\"10.2345\" },\n@@ -91,7 +91,7 @@ static _TestCase testcases[] =\n   { -10.2345, 4,10,'.','A', T,F,F,F,F,T,F,F, \"-AA10.2345\",L\"-AA10.2345\" },\n   { 10.2345, 4,10,'.','#', T,F,T,F,F,T,F,F, \"+##10.2345\",L\"+##10.2345\" },\n \n-  // scientific formatting\n+  // scientific formatting 23-29\n   { 1.23e+12, 1,0,'.',' ', F,T,F,F,F,F,F,F, \"1.2e+12\",L\"1.2e+12\" },\n   { 1.23e+12, 1,0,'.',' ', F,T,F,F,T,F,F,F, \"1.2E+12\",L\"1.2E+12\" },\n   { 1.23e+12, 2,0,'.',' ', F,T,F,F,F,F,F,F, \"1.23e+12\",L\"1.23e+12\" },\n@@ -207,7 +207,7 @@ test01()\n         apply_formatting(tc, os);\n         os << tc.val;\n #ifdef TEST_NUMPUT_VERBOSE\n-        cout << \"result: \" << os.str() << endl;\n+        cout << j << \"result 1: \" << os.str() << endl;\n #endif\n         VERIFY( os && os.str() == tc.result );\n       }\n@@ -220,7 +220,7 @@ test01()\n         apply_formatting(tc, os);\n         os << (long double)tc.val;\n #ifdef TEST_NUMPUT_VERBOSE\n-        cout << \"result: \" << os.str() << endl;\n+        cout << j << \"result 2: \" << os.str() << endl;\n #endif\n         VERIFY( os && os.str() == tc.result );\n       }"}]}