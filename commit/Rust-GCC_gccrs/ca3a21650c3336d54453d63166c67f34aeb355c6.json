{"sha": "ca3a21650c3336d54453d63166c67f34aeb355c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzYTIxNjUwYzMzMzZkNTQ0NTNkNjMxNjZjNjdmMzRhZWIzNTVjNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-05-31T09:48:21Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-05-31T09:48:21Z"}, "message": "i386.md (*fop_<mode>_comm_mixed): Macroize from *fop_sf_comm_mixed and *fop_df_comm_mixed insn patterns using...\n\n\t* config/i386/i386.md (*fop_<mode>_comm_mixed): Macroize from\n\t*fop_sf_comm_mixed and *fop_df_comm_mixed insn patterns using MODEF\n\tmode iterator.\n\t(*fop_<mode>_comm_sse): Macroize from *fop_sf_comm_sse and\n\t*fop_df_comm_sse insn patterns using MODEF mode iterator.\n\t(*fop_<mode>_comm_i387): Macroize from *fop_sf_comm_i387 and\n\t*fop_df_comm_i387 insn patterns using MODEF mode iterator.\n\t(*fop_<mode>_1_mixed): Macroize from *fop_sf_1_mixed and\n\t*fop_df_1_mixed insn patterns using MODEF mode iterator.\n\t(*fop_<mode>_1_sse): Macroize from *fop_sf_1_sse and\n\t*fop_df_1_sse insn patterns using MODEF mode iterator.\n\t(*fop_<mode>_1_i387): Macroize from *fop_sf_1_i387 and\n\t*fop_df_1_i387 insn patterns using MODEF mode iterator.\n\t(*fop_<MODEF:mode>_2_i387): Macroize from *fop_sf_2<mode>_i387 and\n\t*fop_df_2<mode>_i387 insn patterns using MODEF mode iterator.\n\t(*fop_<MODEF:mode>_3_i387): Macroize from *fop_sf_3<mode>_i387 and\n\t*fop_df_3<mode>_i387 insn patterns using MODEF mode iterator.\n\t(*fop_xf_2_i387): Rename from *fop_xf_2<mode>_i387.\n\t(*fop_xf_3_i387): Rename from *fop_xf_3<mode>_i387.\n\t(*fop_xf_4_i387): Use <MODE> for mode attribute.\n\t(*fop_xf_5_i387): Ditto.\n\t(*fop_xf_6_i387): Ditto.\n\nFrom-SVN: r136235", "tree": {"sha": "63943ac82a37cc040100a2032f03bc7d7aa398ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63943ac82a37cc040100a2032f03bc7d7aa398ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3a21650c3336d54453d63166c67f34aeb355c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3a21650c3336d54453d63166c67f34aeb355c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3a21650c3336d54453d63166c67f34aeb355c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3a21650c3336d54453d63166c67f34aeb355c6/comments", "author": null, "committer": null, "parents": [{"sha": "7841ba598b858a72aa3ea5b3cd1d706b012534b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7841ba598b858a72aa3ea5b3cd1d706b012534b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7841ba598b858a72aa3ea5b3cd1d706b012534b9"}], "stats": {"total": 408, "additions": 135, "deletions": 273}, "files": [{"sha": "6177e80e001fcea1bc5c54c61bcfa7c19d6564f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a21650c3336d54453d63166c67f34aeb355c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a21650c3336d54453d63166c67f34aeb355c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3a21650c3336d54453d63166c67f34aeb355c6", "patch": "@@ -1,3 +1,28 @@\n+2008-05-31  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*fop_<mode>_comm_mixed): Macroize from\n+\t*fop_sf_comm_mixed and *fop_df_comm_mixed insn patterns using MODEF\n+\tmode iterator.\n+\t(*fop_<mode>_comm_sse): Macroize from *fop_sf_comm_sse and\n+\t*fop_df_comm_sse insn patterns using MODEF mode iterator.\n+\t(*fop_<mode>_comm_i387): Macroize from *fop_sf_comm_i387 and\n+\t*fop_df_comm_i387 insn patterns using MODEF mode iterator.\n+\t(*fop_<mode>_1_mixed): Macroize from *fop_sf_1_mixed and\n+\t*fop_df_1_mixed insn patterns using MODEF mode iterator.\n+\t(*fop_<mode>_1_sse): Macroize from *fop_sf_1_sse and\n+\t*fop_df_1_sse insn patterns using MODEF mode iterator.\n+\t(*fop_<mode>_1_i387): Macroize from *fop_sf_1_i387 and\n+\t*fop_df_1_i387 insn patterns using MODEF mode iterator.\n+\t(*fop_<MODEF:mode>_2_i387): Macroize from *fop_sf_2<mode>_i387 and\n+\t*fop_df_2<mode>_i387 insn patterns using MODEF mode iterator.\n+\t(*fop_<MODEF:mode>_3_i387): Macroize from *fop_sf_3<mode>_i387 and\n+\t*fop_df_3<mode>_i387 insn patterns using MODEF mode iterator.\n+\t(*fop_xf_2_i387): Rename from *fop_xf_2<mode>_i387.\n+\t(*fop_xf_3_i387): Rename from *fop_xf_3<mode>_i387.\n+\t(*fop_xf_4_i387): Use <MODE> for mode attribute.\n+\t(*fop_xf_5_i387): Ditto.\n+\t(*fop_xf_6_i387): Ditto.\n+\n 2008-05-30  Richard Guenther  <rguenther@suse.de>\n \n \t* builtins.c (build_string_literal): Avoid generating\n@@ -32,8 +57,7 @@\n \t* incpath.c: Use HOST_LACKS_INODE_NUMBERS conditional\n \trather than OS names to choose INO_T_EQ definition.\n \t(DIRS_EQ) [!INO_T_EQ]: Don't worry about case in comparison.\n-\t(add_path) [!INO_T_EQ]: Use lrealpath to fill canonical_name\n-\tfield.\n+\t(add_path) [!INO_T_EQ]: Use lrealpath to fill canonical_name field.\n \n 2008-05-29  Daniel Franke  <franke.daniel@gmail.com>\n \n@@ -43,8 +67,7 @@\n \t* config.gcc: Defined new variable, fortran_target_objs.\n \t(*-*-darwin*): Set fortran_target_objs.\n \t* Makefile.in: Defined new variable FORTRAN_TARGET_OBJS.\n-\t* configure.ac: Substitute fortran_target_objs, set\n-\tFORTRAN_TARGET_OBJS.\n+\t* configure.ac: Substitute fortran_target_objs, set FORTRAN_TARGET_OBJS.\n \t* configure: Regenerated.\n \n 2008-05-29  H.J. Lu  <hongjiu.lu@intel.com>\n@@ -91,8 +114,8 @@\n \n \t* value-prof.c (tree_ic_transform): Print counts.\n \t* tree-profile.c (tree_gen_ic_func_profiler):\n-\tClear __gcov_indreict_call_callee variable\n-\tto avoid misattribution of the profile.\n+\tClear __gcov_indreict_call_callee variable to avoid misattribution\n+\tof the profile.\n \n 2008-05-28  Rafael Espindola  <espindola@google.com>\n \n@@ -125,8 +148,7 @@\n \t(s390_expand_insv): Use rotate and insert selected bits\n \tinstruction for insv when building for z10.\n \t(print_operand_address): Handle symbol ref addresses.\n-\t(print_operand): Output modifier 'c' added for signed byte\n-\tvalues.\n+\t(print_operand): Output modifier 'c' added for signed byte values.\n \t(s390_encode_section_info): Mark symbol refs with\n \tSYMBOL_FLAG_NOT_NATURALLY_ALIGNED if appropriate.\n \n@@ -173,8 +195,7 @@\n 2008-05-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.c (z10_cost): New cost function for z10.\n-\t(s390_handle_arch_option, override_options): Support\n-\t-march=z10 switch.\n+\t(s390_handle_arch_option, override_options): Support -march=z10 switch.\n \t(s390_issue_rate): Adjust issue rate for z10.\n \t* config/s390/s390.h (processor_type): Add PROCESSOR_2097_Z10.\n \t(processor_flags): Add PF_Z10.\n@@ -255,8 +276,7 @@\n 2008-05-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36245\n-\t* tree-ssa-address.c (add_to_parts): Deal with non-pointer\n-\tbases.\n+\t* tree-ssa-address.c (add_to_parts): Deal with non-pointer bases.\n \n 2008-05-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n@@ -284,8 +304,7 @@\n \talternatives according to the \"enabled\" attribute\n \t* recog.h (struct recog_data): New field alternative_enabled_p.\n \t(skip_alternative): New inline function.\n-\t* regclass.c: (record_operand_costs): Check the \"enabled\"\n-\tattribute.\n+\t* regclass.c: (record_operand_costs): Check the \"enabled\" attribute.\n \t(record_reg_classes): Skip alternative according to the\n \t\"enabled\" attribute.\n \n@@ -299,15 +318,12 @@\n \t* recog.c (asm_operand_ok, preprocess_constraints,\n \tconstrain_operands): Likewise.\n \t* regclass.c (record_reg_classes): Likewise.\n-\t* reload.c (find_reloads, alternative_allows_const_pool_ref):\n-\tLikewise.\n+\t* reload.c (find_reloads, alternative_allows_const_pool_ref): Likewise.\n \t* reload1.c (maybe_fix_stack_asms): Likewise.\n-\t* stmt.c (parse_output_constraint, parse_input_constraint):\n-\tLikewise.\n+\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n \t* recog.h: Adjust comment.\n \t* genpreds.c (generic_constraint_letters): Remove 'm' constraint.\n-\t* genoutput.c (note_constraint): Don't emit error for 'm'\n-\tconstraint.\n+\t* genoutput.c (note_constraint): Don't emit error for 'm' constraint.\n \t* doc/md.texi: Add a note to description of 'm' constraint.\n \t* doc/tm.texi: Document the new TARGET_MEM_CONSTRAINT macro.\n \n@@ -354,7 +370,7 @@\n \t(cgraph_decide_inlining_incrementally): Likewise.\n \n 2008-05-26  Tristan Gingold  <gingold@adacore.com>\n-            Anatoly Sokolov  <aesok@post.ru>\n+\t    Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/avr/avr.md (\"call_prologue_saves\"): Use hi8(gs())/lo8(gs())\n \tinstead of pm_lo8/pm_hi8 to makes this call working on avr6.\n@@ -369,29 +385,22 @@\n 2008-05-26  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (expr_has_constants): Declare.\n-\t(visit_reference_op_load): Initialize VN_INFO->has_constants\n-\tproperly.\n+\t(visit_reference_op_load): Initialize VN_INFO->has_constants properly.\n \n 2008-05-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/36253\n-\t* caller-save.c (insert_restore): Verify alignment of spill\n-\tspace.\n+\t* caller-save.c (insert_restore): Verify alignment of spill space.\n \t(insert_save): Likewise.\n-\n \t* cfgexpand.c (LOCAL_ALIGNMENT): Removed.\n-\n \t* defaults.h (LOCAL_ALIGNMENT): New. Provide default.\n \t(STACK_SLOT_ALIGNMENT): Likewise.\n-\n \t* function.c (LOCAL_ALIGNMENT): Removed.\n \t(get_stack_local_alignment): New.\n \t(assign_stack_local): Use it.  Set alignment on stack slot.\n \t(assign_stack_temp_for_type): Use get_stack_local_alignment.\n-\n \t* config/i386/i386.h (LOCAL_ALIGNMENT): Updated.\n \t(STACK_SLOT_ALIGNMENT): New.\n-\n \t* config/i386/i386.c (ix86_local_alignment): Handle caller-save\n \tstack slot in XFmode.\n \n@@ -421,7 +430,7 @@\n \n 2008-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t * tree-nested.c (convert_tramp_reference) <ADDR_EXPR>: Do not\n+\t* tree-nested.c (convert_tramp_reference) <ADDR_EXPR>: Do not\n \tbuild a trampoline if we don't want one.\n \t* varasm.c (initializer_constant_valid_p) <ADDR_EXPR>: Do not\n \treturn zero for nested functions if we don't want a trampoline.\n@@ -510,9 +519,8 @@\n \n 2008-05-24  Richard Guenther  <rguenther@suse.de>\n \n-\t* tree-dfa.c (refs_may_alias_p): Re-instantiate case that\n-\ta scalar variable can be only accessed through a pointer\n-\tor a union.\n+\t* tree-dfa.c (refs_may_alias_p): Re-instantiate case that a scalar\n+\tvariable can be only accessed through a pointer or a union.\n \n 2008-05-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -542,10 +550,8 @@\n \t* target.h (gcc_target): Add allocate_stack_slots_for_args.\n \t* function.c (use_register_for_decl): Use\n \ttargetm.calls.allocate_stack_slots_for_args.\n-\t* target-def.h (TARGET_CALLS): Add \n-\tTARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS.\n-\t* config/arm/arm.c (arm_allocate_stack_slots_for_args): \n-\tNew function.\n+\t* target-def.h (TARGET_CALLS): Add TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS.\n+\t* config/arm/arm.c (arm_allocate_stack_slots_for_args): New function.\n \t(TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS): Define.\n \n 2008-05-23  Eric Botcazou  <ebotcazou@adacore.com>\n@@ -560,8 +566,7 @@\n \n 2008-05-23  Richard Guenther  <rguenther@suse.de>\n \n-\t* tree-ssa-operands.c (mark_difference_for_renaming): Use\n-\tbitmap_xor.\n+\t* tree-ssa-operands.c (mark_difference_for_renaming): Use bitmap_xor.\n \n 2008-05-23  Uros Bizjak  <ubizjak@gmail.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n@@ -584,8 +589,8 @@\n \n \t* doc/install.texi (Options specification): Document --enable-cld.\n \t* doc/invoke.texi (Machine Dependent Options)\n-        [i386 and x86-64 Options]: Add -mcld option.\n-        (Intel 386 and AMD x86-64 Options): Document -mcld option.\n+\t[i386 and x86-64 Options]: Add -mcld option.\n+\t(Intel 386 and AMD x86-64 Options): Document -mcld option.\n \n 2008-05-23  Kai Tietz  <kai.tietz@onevison.com>\n \t* config/i386/i386.c (return_in_memory_32): Add ATTRIBUTE_UNUSED.\n@@ -824,16 +829,15 @@\n \tparameter.\n \t* config/mips/mips.h (MIPS_COMPARE_AND_SWAP_12): Add OPS parameter.\n \t(MIPS_COMPARE_AND_SWAP_12_0): Delete macro.\n-\t(MIPS_COMPARE_AND_SWAP_12_ZERO_OP,\n-\tMIPS_COMPARE_AND_SWAP_12_NONZERO_OP,\n+\t(MIPS_COMPARE_AND_SWAP_12_ZERO_OP, MIPS_COMPARE_AND_SWAP_12_NONZERO_OP,\n \tMIPS_SYNC_OP_12, MIPS_SYNC_OP_12_NOT_NOP,\n \tMIPS_SYNC_OP_12_NOT_NOT, MIPS_SYNC_OLD_OP_12,\n \tMIPS_SYNC_OLD_OP_12_NOT_NOP, MIPS_SYNC_OLD_OP_12_NOT_NOP_REG,\n \tMIPS_SYNC_OLD_OP_12_NOT_NOT, MIPS_SYNC_OLD_OP_12_NOT_NOT_REG,\n \tMIPS_SYNC_NEW_OP_12, MIPS_SYNC_NEW_OP_12_NOT_NOP,\n \tMIPS_SYNC_NEW_OP_12_NOT_NOT, MIPS_SYNC_EXCHANGE_12,\n-\tMIPS_SYNC_EXCHANGE_12_ZERO_OP,\n-\tMIPS_SYNC_EXCHANGE_12_NONZERO_OP): New macros.\n+\tMIPS_SYNC_EXCHANGE_12_ZERO_OP, MIPS_SYNC_EXCHANGE_12_NONZERO_OP):\n+\tNew macros.\n \n 2008-05-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n@@ -995,8 +999,8 @@\n \n \t* config/i386/i386.c (ix86_expand_vector_init_concat): New.\n \t(ix86_expand_vector_init_interleave): Likewise.\n-\t(ix86_expand_vector_init_general): Use them.  Assert word_mode\n-\t== SImode when n_words == 4.\n+\t(ix86_expand_vector_init_general): Use them.  Assert\n+\tword_mode == SImode when n_words == 4.\n \n 2008-05-19  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "c245a49fd3f4ee40bb09818e58f0ab310202ef59", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 83, "deletions": 225, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3a21650c3336d54453d63166c67f34aeb355c6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3a21650c3336d54453d63166c67f34aeb355c6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ca3a21650c3336d54453d63166c67f34aeb355c6", "patch": "@@ -15798,80 +15798,80 @@\n ;; Gcc is slightly more smart about handling normal two address instructions\n ;; so use special patterns for add and mull.\n \n-(define_insn \"*fop_sf_comm_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,x\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n-  \"TARGET_MIX_SSE_I387\n+(define_insn \"*fop_<mode>_comm_mixed\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,0\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n-\t   (if_then_else (match_operand:SF 3 \"mult_operator\" \"\")\n+\t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t      (const_string \"ssemul\")\n \t      (const_string \"sseadd\"))\n-\t   (if_then_else (match_operand:SF 3 \"mult_operator\" \"\")\n+\t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t      (const_string \"fmul\")\n \t      (const_string \"fop\"))))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_sf_comm_sse\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE_MATH\n+(define_insn \"*fop_<mode>_comm_sse\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (if_then_else (match_operand:SF 3 \"mult_operator\" \"\")\n+        (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t   (const_string \"ssemul\")\n \t   (const_string \"sseadd\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_sf_comm_i387\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")]))]\n+(define_insn \"*fop_<mode>_comm_i387\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm\")]))]\n   \"TARGET_80387\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-\t(if_then_else (match_operand:SF 3 \"mult_operator\" \"\")\n+\t(if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t   (const_string \"fmul\")\n \t   (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_sf_1_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,x\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm,0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n-  \"TARGET_MIX_SSE_I387\n+(define_insn \"*fop_<mode>_1_mixed\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm,0\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:SF 3 \"mult_operator\" \"\"))\n+\t            (match_operand:MODEF 3 \"mult_operator\" \"\"))\n                  (const_string \"ssemul\")\n \t       (and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:SF 3 \"div_operator\" \"\"))\n+\t            (match_operand:MODEF 3 \"div_operator\" \"\"))\n                  (const_string \"ssediv\")\n \t       (eq_attr \"alternative\" \"2\")\n                  (const_string \"sseadd\")\n-\t       (match_operand:SF 3 \"mult_operator\" \"\")\n+\t       (match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"fmul\")\n-               (match_operand:SF 3 \"div_operator\" \"\")\n+               (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*rcpsf2_sse\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n@@ -15882,219 +15882,75 @@\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"SF\")])\n \n-(define_insn \"*fop_sf_1_sse\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE_MATH\n+(define_insn \"*fop_<mode>_1_sse\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n+  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:SF 3 \"mult_operator\" \"\")\n+        (cond [(match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"ssemul\")\n-\t       (match_operand:SF 3 \"div_operator\" \"\")\n+\t       (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"ssediv\")\n               ]\n               (const_string \"sseadd\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; This pattern is not fully shadowed by the pattern above.\n-(define_insn \"*fop_sf_1_i387\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n+(define_insn \"*fop_<mode>_1_i387\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n   \"TARGET_80387 && !TARGET_SSE_MATH\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:SF 3 \"mult_operator\" \"\")\n+        (cond [(match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"fmul\")\n-               (match_operand:SF 3 \"div_operator\" \"\")\n+               (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n-\n-;; ??? Add SSE splitters for these!\n-(define_insn \"*fop_sf_2<mode>_i387\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t  [(float:SF (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n-\t   (match_operand:SF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP && !TARGET_SSE_MATH\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(match_operand:SF 3 \"mult_operator\" \"\")\n-                 (const_string \"fmul\")\n-               (match_operand:SF 3 \"div_operator\" \"\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n-   (set_attr \"fp_int_src\" \"true\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_sf_3<mode>_i387\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:SF 3 \"binary_fp_operator\"\n-\t  [(match_operand:SF 1 \"register_operand\" \"0,0\")\n-\t   (float:SF (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP && !TARGET_SSE_MATH\"\n-  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(match_operand:SF 3 \"mult_operator\" \"\")\n-                 (const_string \"fmul\")\n-               (match_operand:SF 3 \"div_operator\" \"\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n-   (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*fop_df_comm_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,x\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t   (match_operand:DF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n-  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n-   && COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-\t(if_then_else (eq_attr \"alternative\" \"1\")\n-\t   (if_then_else (match_operand:DF 3 \"mult_operator\" \"\")\n-\t      (const_string \"ssemul\")\n-\t      (const_string \"sseadd\"))\n-\t   (if_then_else (match_operand:DF 3 \"mult_operator\" \"\")\n-\t      (const_string \"fmul\")\n-\t      (const_string \"fop\"))))\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*fop_df_comm_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n-\t   (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (if_then_else (match_operand:DF 3 \"mult_operator\" \"\")\n-\t   (const_string \"ssemul\")\n-\t   (const_string \"sseadd\")))\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*fop_df_comm_i387\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")]))]\n-  \"TARGET_80387\n-   && COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-\t(if_then_else (match_operand:DF 3 \"mult_operator\" \"\")\n-\t   (const_string \"fmul\")\n-\t   (const_string \"fop\")))\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*fop_df_1_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,x\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm,0\")\n-\t   (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n-   && !COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:DF 3 \"mult_operator\" \"\"))\n-                 (const_string \"ssemul\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:DF 3 \"div_operator\" \"\"))\n-                 (const_string \"ssediv\")\n-\t       (eq_attr \"alternative\" \"2\")\n-                 (const_string \"sseadd\")\n-\t       (match_operand:DF 3 \"mult_operator\" \"\")\n-                 (const_string \"fmul\")\n-               (match_operand:DF 3 \"div_operator\" \"\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*fop_df_1_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t  [(match_operand:DF 1 \"register_operand\" \"0\")\n-\t   (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && !COMMUTATIVE_ARITH_P (operands[3])\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set_attr \"mode\" \"DF\")\n-   (set (attr \"type\")\n-        (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n-                 (const_string \"ssemul\")\n-\t       (match_operand:DF 3 \"div_operator\" \"\")\n-                 (const_string \"ssediv\")\n-              ]\n-              (const_string \"sseadd\")))])\n-\n-;; This pattern is not fully shadowed by the pattern above.\n-(define_insn \"*fop_df_1_i387\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm\")\n-\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n-  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\n-   && !COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n-                 (const_string \"fmul\")\n-               (match_operand:DF 3 \"div_operator\" \"\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n-   (set_attr \"mode\" \"DF\")])\n-\n ;; ??? Add SSE splitters for these!\n-(define_insn \"*fop_df_2<mode>_i387\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t   [(float:DF (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n-\t    (match_operand:DF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\n-   && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n+(define_insn \"*fop_<MODEF:mode>_2_i387\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(float:MODEF\n+\t     (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n+\t   (match_operand:MODEF 2 \"register_operand\" \"0,0\")]))]\n+  \"TARGET_80387 && !TARGET_SSE_MATH\n+   && TARGET_USE_<X87MODEI12:MODE>MODE_FIOP\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n+        (cond [(match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"fmul\")\n-               (match_operand:DF 3 \"div_operator\" \"\")\n+               (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*fop_df_3<mode>_i387\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(match_operator:DF 3 \"binary_fp_operator\"\n-\t   [(match_operand:DF 1 \"register_operand\" \"0,0\")\n-\t    (float:DF (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\n-   && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n+   (set_attr \"mode\" \"<X87MODEI12:MODE>\")])\n+\n+(define_insn \"*fop_<MODEF:mode>_3_i387\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:MODEF 3 \"binary_fp_operator\"\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,0\")\n+\t   (float:MODEF\n+\t     (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n+  \"TARGET_80387 && !TARGET_SSE_MATH\n+   && TARGET_USE_<X87MODEI12:MODE>MODE_FIOP\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n+        (cond [(match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"fmul\")\n-               (match_operand:DF 3 \"div_operator\" \"\")\n+               (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n@@ -16184,11 +16040,12 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"XF\")])\n \n-(define_insn \"*fop_xf_2<mode>_i387\"\n+(define_insn \"*fop_xf_2_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n-\t   [(float:XF (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n-\t    (match_operand:XF 2 \"register_operand\" \"0,0\")]))]\n+\t  [(float:XF\n+\t     (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n+\t   (match_operand:XF 2 \"register_operand\" \"0,0\")]))]\n   \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n@@ -16201,11 +16058,12 @@\n    (set_attr \"fp_int_src\" \"true\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_xf_3<mode>_i387\"\n+(define_insn \"*fop_xf_3_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n \t  [(match_operand:XF 1 \"register_operand\" \"0,0\")\n-\t   (float:XF (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n+\t   (float:XF\n+\t     (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n   \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n@@ -16233,7 +16091,7 @@\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_xf_5_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n@@ -16250,7 +16108,7 @@\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_xf_6_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n@@ -16268,7 +16126,7 @@\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")"}]}