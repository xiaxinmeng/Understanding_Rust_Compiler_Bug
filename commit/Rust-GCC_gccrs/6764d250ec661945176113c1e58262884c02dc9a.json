{"sha": "6764d250ec661945176113c1e58262884c02dc9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc2NGQyNTBlYzY2MTk0NTE3NjExM2MxZTU4MjYyODg0YzAyZGM5YQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-16T00:08:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-16T00:08:51Z"}, "message": "flow.c (life_analysis_1): Do not clobber regs_ever_live after reload.\n\n        * flow.c (life_analysis_1): Do not clobber regs_ever_live after\n        reload.  Never perform rescans of the insn chain after reload.\n        (propagate_block): Do not delete insn or create new autoinc addressing\n        modes after reload.\n        * jump.c (jump_optimize): Unconditionally use the code that was\n        previously conditional on PRESERVE_DEATH_INFO_REGNO_P.\n        * reload1.c (reload): When reloading is finished, delete all\n        REG_DEAD and REG_UNUSED notes.\n        (emit_reload_insns): Delete all code that was conditional on\n        PRESERVE_DEATH_INFO_REGNO_P.\n        (no_longer_dead_regs): Delete variable.\n        (reload_cse_delete_death_notes): Delete function.\n        (reload_cse_no_longer_dead): Delete function.\n        (reload_cse_regs_1): Delete all code to handle deletion of death\n        notes.\n        (reload_cse_noop_set_p): Likewise.\n        (reload_cse_simplify_set): Likewise.\n        (reload_cse_simplify_operands): Likewise.\n        (reload_cse_move2add): Likewise.\n        * reorg.c (used_spill_regs): Delete declaration.\n        (max_label_num_after_reload): Delete declaration.\n        (find_dead_or_set_registers): Don't assume that spill regs are\n        dead at a CODE_LABEL.\n        * rtlanal.c (dead_or_set_regno_p): Death notes are always accurate,\n        even after reload.\n        * sched.c (sched_analyze_insn): Likewise.\n        (update_flow_info): Likewise.\n        * haifa-sched.c (sched_analyze_insn): Likewise.\n        (update_flow_info): Likewise.\n        * tm.texi (PRESERVE_DEATH_INFO_REGNO_P): Delete documentation.\n        * toplev.c (max_label_num_after_reload): Delete variable.\n        (rest_of_compilation): Don't set max_label_num_after_reload.\n        Call life_analysis after reload_cse_regs if optimizing.\n        * config/gmicro/gmicro.h: Delete comment referring to\n        PRESERVE_DEATH_INFO_REGNO_P.\n        * config/i386/i386.h: Likewise.\n        * config/m88k/m88k.h: Likewise.\n        * config/m32r/m32r.h (PRESERVE_DEATH_INFO_REGNO_P): Delete definition.\n        * config/sh/sh.h: Likewise.\nAccurate REG_DEAD notes after reload.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r23120", "tree": {"sha": "35e9d178ac30fae30efb3a75fce6b7fa5ed815f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35e9d178ac30fae30efb3a75fce6b7fa5ed815f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6764d250ec661945176113c1e58262884c02dc9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6764d250ec661945176113c1e58262884c02dc9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6764d250ec661945176113c1e58262884c02dc9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6764d250ec661945176113c1e58262884c02dc9a/comments", "author": null, "committer": null, "parents": [{"sha": "913135dfc2dce8e152ff5864dce5fffaca4ce1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913135dfc2dce8e152ff5864dce5fffaca4ce1c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/913135dfc2dce8e152ff5864dce5fffaca4ce1c5"}], "stats": {"total": 591, "additions": 114, "deletions": 477}, "files": [{"sha": "55cc43ea5936a749f5f5fbefc2078636f80dc088", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -1,3 +1,47 @@\n+Thu Oct 15 23:53:29 1998 Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\t\t\t Jeffrey A Law  (law@cygnus.com)\n+\n+\t* flow.c (life_analysis_1): Do not clobber regs_ever_live after\n+\treload.  Never perform rescans of the insn chain after reload.\n+\t(propagate_block): Do not delete insn or create new autoinc addressing\n+\tmodes after reload.\n+\n+\t* jump.c (jump_optimize): Unconditionally use the code that was\n+\tpreviously conditional on PRESERVE_DEATH_INFO_REGNO_P.\n+\t* reload1.c (reload): When reloading is finished, delete all\n+\tREG_DEAD and REG_UNUSED notes.\n+\t(emit_reload_insns): Delete all code that was conditional on\n+\tPRESERVE_DEATH_INFO_REGNO_P.\n+\t(no_longer_dead_regs): Delete variable.\n+\t(reload_cse_delete_death_notes): Delete function.\n+\t(reload_cse_no_longer_dead): Delete function.\n+\t(reload_cse_regs_1): Delete all code to handle deletion of death\n+\tnotes.\n+\t(reload_cse_noop_set_p): Likewise.\n+\t(reload_cse_simplify_set): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t(reload_cse_move2add): Likewise.\n+\t* reorg.c (used_spill_regs): Delete declaration.\n+\t(max_label_num_after_reload): Delete declaration.\n+\t(find_dead_or_set_registers): Don't assume that spill regs are\n+\tdead at a CODE_LABEL.\n+\t* rtlanal.c (dead_or_set_regno_p): Death notes are always accurate,\n+\teven after reload.\n+\t* sched.c (sched_analyze_insn): Likewise.\n+\t(update_flow_info): Likewise.\n+\t* haifa-sched.c (sched_analyze_insn): Likewise.\n+\t(update_flow_info): Likewise.\n+\t* tm.texi (PRESERVE_DEATH_INFO_REGNO_P): Delete documentation.\n+\t* toplev.c (max_label_num_after_reload): Delete variable.\n+\t(rest_of_compilation): Don't set max_label_num_after_reload.\n+\tCall life_analysis after reload_cse_regs if optimizing.\n+\t* config/gmicro/gmicro.h: Delete comment referring to\n+\tPRESERVE_DEATH_INFO_REGNO_P.\n+\t* config/i386/i386.h: Likewise.\n+\t* config/m88k/m88k.h: Likewise.\n+\t* config/m32r/m32r.h (PRESERVE_DEATH_INFO_REGNO_P): Delete definition.\n+\t* config/sh/sh.h: Likewise.\n+\n Thu Oct 15 19:48:41 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n \n \t* loop.c (strength_reduce): Restore marking bct_p as"}, {"sha": "ebcab0ce6fa10f54e7b1ea358be5e416b3181f0d", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -241,7 +241,6 @@ extern int target_flags;\n /* #define OVERLAPPING_REGNO_P(REGNO) */\n \n /* #define INSN_CLOBBERS_REGNO_P(INSN,REGNO)  */\n-/* #define PRESERVE_DEATH_INFO_REGNO_P(REGNO)  */\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE."}, {"sha": "66b2de5ec4638c65b2f69ac693c40340db4ca5e1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -834,11 +834,6 @@ enum reg_class\n \n #define STACK_TOP_P(xop) (REG_P (xop) && REGNO (xop) == FIRST_STACK_REG)\n \n-/* Try to maintain the accuracy of the death notes for regs satisfying the\n-   following.  Important for stack like regs, to know when to pop. */\n-\n-/* #define PRESERVE_DEATH_INFO_REGNO_P(x) FP_REGNO_P(x) */\n-\n /* 1 if register REGNO can magically overlap other regs.\n    Note that nonzero values work only in very special circumstances. */\n "}, {"sha": "12a1a50eafa88c52534bd8922720a4fe50cea439", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -2077,9 +2077,6 @@ extern int  conditional_move_operand\t\tPROTO((Rtx, int));\n extern int  carry_compare_operand\t\tPROTO((Rtx, int));\n extern char *emit_cond_move\t\t\tPROTO((Rtx *, Rtx));\n \n-/* Needed by a peephole optimisation.  */\n-#define PRESERVE_DEATH_INFO_REGNO_P(regno) (regno < FIRST_PSEUDO_REGISTER)\n-\n extern char * m32r_output_block_move PROTO((Rtx, Rtx *));\n extern int    m32r_block_immediate_operand PROTO((Rtx, int));\n extern void   m32r_expand_block_move PROTO((Rtx *));"}, {"sha": "855b6bf46523b5a06dd685aad55521963468a009", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -648,7 +648,6 @@ extern char * reg_names[];\n /* These interfaces that don't apply to the m88000.  */\n /* OVERLAPPING_REGNO_P(REGNO) 0 */\n /* INSN_CLOBBERS_REGNO_P(INSN, REGNO) 0 */\n-/* PRESERVE_DEATH_INFO_REGNO_P(REGNO) 0 */\n \n /* True if register is an extended register.  */\n #define XRF_REGNO_P(N) ((N) < FIRST_PSEUDO_REGISTER && (N) >= FIRST_EXTENDED_REGISTER)"}, {"sha": "1798d3ffd13c20f3584d82d0f0c87c8382d65c3f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -158,8 +158,6 @@ extern int target_flags;\n \n #define TARGET_DEFAULT  (0)\n \n-#define PRESERVE_DEATH_INFO_REGNO_P(regno) (TARGET_RELAX || optimize)\n-\n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\t\t\t\\"}, {"sha": "b91882337ca7ca9fb3f5fad00db3ac84e2b7e1e8", "filename": "gcc/flow.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -1347,13 +1347,24 @@ life_analysis_1 (f, nregs)\n      possibly excluding those that are used after they are set.  */\n   regset *basic_block_significant;\n   register int i;\n+  char save_regs_ever_live[FIRST_PSEUDO_REGISTER];\n \n   struct obstack flow_obstack;\n \n   gcc_obstack_init (&flow_obstack);\n \n   max_regno = nregs;\n \n+  /* The post-reload life analysis have (on a global basis) the same registers\n+     live as was computed by reload itself.\n+\n+     Otherwise elimination offsets and such may be incorrect.\n+\n+     Reload will make some registers as live even though they do not appear\n+     in the rtl.  */\n+  if (reload_completed)\n+    bcopy (regs_ever_live, save_regs_ever_live, (sizeof (regs_ever_live)));\n+\n   bzero (regs_ever_live, sizeof regs_ever_live);\n \n   /* Allocate and zero out many data structures\n@@ -1436,7 +1447,8 @@ life_analysis_1 (f, nregs)\n \t\t basic_block_live_at_end[i], 0, j,\n \t\t {\n \t\t   consider = 1;\n-\t\t   if (REGNO_REG_SET_P (basic_block_significant[i], j))\n+\t\t   if (!reload_completed\n+\t\t       && REGNO_REG_SET_P (basic_block_significant[i], j))\n \t\t     {\n \t\t       must_rescan = 1;\n \t\t       goto done;\n@@ -1581,6 +1593,9 @@ life_analysis_1 (f, nregs)\n \t\t\t\t }\n \t\t\t     });\n \n+  /* Restore regs_ever_live that was provided by reload.  */\n+  if (reload_completed)\n+    bcopy (save_regs_ever_live, regs_ever_live, (sizeof (regs_ever_live)));\n \n   free_regset_vector (basic_block_live_at_end, n_basic_blocks);\n   free_regset_vector (basic_block_new_live_at_end, n_basic_blocks);\n@@ -1792,7 +1807,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t     \"delete\" it by turning it into a NOTE of type NOTE_INSN_DELETED.\n \t     We could really delete it with delete_insn, but that\n \t     can cause trouble for first or last insn in a basic block.  */\n-\t  if (final && insn_is_dead)\n+\t  if (!reload_completed && final && insn_is_dead)\n \t    {\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -1832,7 +1847,8 @@ propagate_block (old, first, last, final, significant, bnum)\n \t    register rtx x = single_set (insn);\n \n \t    /* Does this instruction increment or decrement a register?  */\n-\t    if (final && x != 0\n+\t    if (!reload_completed\n+\t\t&& final && x != 0\n \t\t&& GET_CODE (SET_DEST (x)) == REG\n \t\t&& (GET_CODE (SET_SRC (x)) == PLUS\n \t\t    || GET_CODE (SET_SRC (x)) == MINUS)"}, {"sha": "f529a958cd47a9ec0c411e14afd760a29212d43f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -3767,27 +3767,6 @@ sched_analyze_insn (x, insn, loop_notes)\n \n     }\n \n-  /* After reload, it is possible for an instruction to have a REG_DEAD note\n-     for a register that actually dies a few instructions earlier.  For\n-     example, this can happen with SECONDARY_MEMORY_NEEDED reloads.\n-     In this case, we must consider the insn to use the register mentioned\n-     in the REG_DEAD note.  Otherwise, we may accidentally move this insn\n-     after another insn that sets the register, thus getting obviously invalid\n-     rtl.  This confuses reorg which believes that REG_DEAD notes are still\n-     meaningful.\n-\n-     ??? We would get better code if we fixed reload to put the REG_DEAD\n-     notes in the right places, but that may not be worth the effort.  */\n-\n-  if (reload_completed)\n-    {\n-      rtx note;\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD)\n-\t  sched_analyze_2 (XEXP (note, 0), insn);\n-    }\n-\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n \t\t\t       /* reg_last_sets[r] is now a list of insns */\n@@ -8007,16 +7986,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t         register that was not needed by this instantiation of the\n \t         pattern, so we can safely ignore it.  */\n \t      if (insn == first)\n-\t\t{\n-\t\t  /* After reload, REG_DEAD notes come sometimes an\n-\t\t     instruction after the register actually dies.  */\n-\t\t  if (reload_completed && REG_NOTE_KIND (note) == REG_DEAD)\n-\t\t    {\n-\t\t      XEXP (note, 1) = REG_NOTES (insn);\n-\t\t      REG_NOTES (insn) = note;\n-\t\t      break;\n-\t\t    }\n-\t\t\t\n+\t\t{\t\t\t\n \t\t  if (REG_NOTE_KIND (note) != REG_UNUSED)\n \t\t    abort ();\n "}, {"sha": "6884270700802a69c77434e01eeb3e34dd6f6847", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -480,12 +480,9 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t\tremove_death (dreg, trial);\n \t\t\t\tbreak;\n \t\t\t      }\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\t\t\t/* Deleting insn could lose a death-note for SREG\n-\t\t\t   so don't do it if final needs accurate\n-\t\t\t   death-notes.  */\n-\t\t\tif (PRESERVE_DEATH_INFO_REGNO_P (sreg)\n-\t\t\t    && (trial = find_regno_note (insn, REG_DEAD, sreg)))\n+\n+\t\t\t/* Deleting insn could lose a death-note for SREG.  */\n+\t\t\tif ((trial = find_regno_note (insn, REG_DEAD, sreg)))\n \t\t\t  {\n \t\t\t    /* Change this into a USE so that we won't emit\n \t\t\t       code for it, but still can keep the note.  */\n@@ -497,7 +494,6 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t    XEXP (trial, 1) = NULL_RTX;\n \t\t\t  }\n \t\t\telse\n-#endif\n \t\t\t  delete_insn (insn);\n \t\t      }\n \t\t  }"}, {"sha": "06bc9ddbc5b0b995d09a7862983850e1a2fad7ce", "filename": "gcc/reload1.c", "status": "modified", "additions": 24, "deletions": 331, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -416,8 +416,6 @@ static int reload_cse_simplify_set\tPROTO((rtx, rtx));\n static int reload_cse_simplify_operands\tPROTO((rtx));\n static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n static void reload_cse_record_set\tPROTO((rtx, rtx));\n-static void reload_cse_delete_death_notes\tPROTO((rtx));\n-static void reload_cse_no_longer_dead\tPROTO((int, enum machine_mode));\n static void reload_combine PROTO((void));\n static void reload_combine_note_use PROTO((rtx *, rtx));\n static void reload_combine_note_store PROTO((rtx, rtx));\n@@ -1206,17 +1204,13 @@ reload (first, global, dumpfile)\n     }\n \n   /* Make a pass over all the insns and delete all USEs which we inserted\n-     only to tag a REG_EQUAL note on them; if PRESERVE_DEATH_INFO_REGNO_P\n-     is defined, also remove death notes for things that are no longer\n-     registers or no longer die in the insn (e.g., an input and output\n-     pseudo being tied).  */\n+     only to tag a REG_EQUAL note on them.  Also remove all REG_DEAD and\n+     REG_UNUSED notes.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\trtx note, next;\n-#endif\n+\trtx *pnote;\n \n \tif (GET_CODE (PATTERN (insn)) == USE\n \t    && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n@@ -1226,16 +1220,16 @@ reload (first, global, dumpfile)\n \t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t    continue;\n \t  }\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\tfor (note = REG_NOTES (insn); note; note = next)\n+\n+\tpnote = &REG_NOTES (insn);\n+\twhile (*pnote != 0)\n \t  {\n-\t    next = XEXP (note, 1);\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& (GET_CODE (XEXP (note, 0)) != REG\n-\t\t    || reg_set_p (XEXP (note, 0), PATTERN (insn))))\n-\t      remove_note (insn, note);\n+\t    if (REG_NOTE_KIND (*pnote) == REG_DEAD\n+\t\t|| REG_NOTE_KIND (*pnote) == REG_UNUSED)\n+\t      *pnote = XEXP (*pnote, 1);\n+\t    else\n+\t      pnote = &XEXP (*pnote, 1);\n \t  }\n-#endif\n       }\n \n   /* If we are doing stack checking, give a warning if this function's\n@@ -6902,28 +6896,6 @@ emit_reload_insns (chain)\n \t\tgen_reload (reloadreg, oldequiv, reload_opnum[j],\n \t\t\t    reload_when_needed[j]);\n \n-#if defined(SECONDARY_INPUT_RELOAD_CLASS) && defined(PRESERVE_DEATH_INFO_REGNO_P)\n-\t      /* We may have to make a REG_DEAD note for the secondary reload\n-\t\t register in the insns we just made.  Find the last insn that\n-\t\t mentioned the register.  */\n-\t      if (! special && second_reload_reg\n-\t\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (second_reload_reg)))\n-\t\t{\n-\t\t  rtx prev;\n-\n-\t\t  for (prev = get_last_insn (); prev;\n-\t\t       prev = PREV_INSN (prev))\n-\t\t    if (GET_RTX_CLASS (GET_CODE (prev) == 'i')\n-\t\t\t&& reg_overlap_mentioned_for_reload_p (second_reload_reg,\n-\t\t\t\t\t\t\t       PATTERN (prev)))\n-\t\t      {\n-\t\t\tREG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t\t      second_reload_reg,\n-\t\t\t\t\t\t\t      REG_NOTES (prev));\n-\t\t\tbreak;\n-\t\t      }\n-\t\t}\n-#endif\n \t    }\n \n \t  this_reload_insn = get_last_insn ();\n@@ -6945,118 +6917,6 @@ emit_reload_insns (chain)\n \t  reload_in[j]\n \t    = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n \t}\n-      /* Add a note saying the input reload reg\n-\t dies in this insn, if anyone cares.  */\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-      if (old != 0\n-\t  && reload_reg_rtx[j] != old\n-\t  && reload_reg_rtx[j] != 0\n-\t  && reload_out[j] == 0\n-\t  && ! reload_inherited[j]\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (reload_reg_rtx[j])))\n-\t{\n-\t  register rtx reloadreg = reload_reg_rtx[j];\n-\n-#if 0\n-\t  /* We can't abort here because we need to support this for sched.c.\n-\t     It's not terrible to miss a REG_DEAD note, but we should try\n-\t     to figure out how to do this correctly.  */\n-\t  /* The code below is incorrect for address-only reloads.  */\n-\t  if (reload_when_needed[j] != RELOAD_OTHER\n-\t      && reload_when_needed[j] != RELOAD_FOR_INPUT)\n-\t    abort ();\n-#endif\n-\n-\t  /* Add a death note to this insn, for an input reload.  */\n-\n-\t  if ((reload_when_needed[j] == RELOAD_OTHER\n-\t       || reload_when_needed[j] == RELOAD_FOR_INPUT)\n-\t      && ! dead_or_set_p (insn, reloadreg))\n-\t    REG_NOTES (insn)\n-\t      = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t   reloadreg, REG_NOTES (insn));\n-\t}\n-\n-      /* When we inherit a reload, the last marked death of the reload reg\n-\t may no longer really be a death.  */\n-      if (reload_reg_rtx[j] != 0\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (reload_reg_rtx[j]))\n-\t  && reload_inherited[j])\n-\t{\n-\t  /* Handle inheriting an output reload.\n-\t     Remove the death note from the output reload insn.  */\n-\t  if (reload_spill_index[j] >= 0\n-\t      && GET_CODE (reload_in[j]) == REG\n-\t      && spill_reg_store[reload_spill_index[j]] != 0\n-\t      && find_regno_note (spill_reg_store[reload_spill_index[j]],\n-\t\t\t\t  REG_DEAD, REGNO (reload_reg_rtx[j])))\n-\t    remove_death (REGNO (reload_reg_rtx[j]),\n-\t\t\t  spill_reg_store[reload_spill_index[j]]);\n-\t  /* Likewise for input reloads that were inherited.  */\n-\t  else if (reload_spill_index[j] >= 0\n-\t\t   && GET_CODE (reload_in[j]) == REG\n-\t\t   && spill_reg_store[reload_spill_index[j]] == 0\n-\t\t   && reload_inheritance_insn[j] != 0\n-\t\t   && find_regno_note (reload_inheritance_insn[j], REG_DEAD,\n-\t\t\t\t       REGNO (reload_reg_rtx[j])))\n-\t    remove_death (REGNO (reload_reg_rtx[j]),\n-\t\t\t  reload_inheritance_insn[j]);\n-\t  else\n-\t    {\n-\t      rtx prev;\n-\n-\t      /* We got this register from find_equiv_reg.\n-\t\t Search back for its last death note and get rid of it.\n-\t\t But don't search back too far.\n-\t\t Don't go past a place where this reg is set,\n-\t\t since a death note before that remains valid.  */\n-\t      for (prev = PREV_INSN (insn);\n-\t\t   prev && GET_CODE (prev) != CODE_LABEL;\n-\t\t   prev = PREV_INSN (prev))\n-\t\tif (GET_RTX_CLASS (GET_CODE (prev)) == 'i'\n-\t\t    && dead_or_set_p (prev, reload_reg_rtx[j]))\n-\t\t  {\n-\t\t    if (find_regno_note (prev, REG_DEAD,\n-\t\t\t\t\t REGNO (reload_reg_rtx[j])))\n-\t\t      remove_death (REGNO (reload_reg_rtx[j]), prev);\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-\n-      /* We might have used find_equiv_reg above to choose an alternate\n-\t place from which to reload.  If so, and it died, we need to remove\n-\t that death and move it to one of the insns we just made.  */\n-\n-      if (oldequiv_reg != 0\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (true_regnum (oldequiv_reg)))\n-\t{\n-\t  rtx prev, prev1;\n-\n-\t  for (prev = PREV_INSN (insn); prev && GET_CODE (prev) != CODE_LABEL;\n-\t       prev = PREV_INSN (prev))\n-\t    if (GET_RTX_CLASS (GET_CODE (prev)) == 'i'\n-\t\t&& dead_or_set_p (prev, oldequiv_reg))\n-\t      {\n-\t\tif (find_regno_note (prev, REG_DEAD, REGNO (oldequiv_reg)))\n-\t\t  {\n-\t\t    for (prev1 = this_reload_insn;\n-\t\t\t prev1; prev1 = PREV_INSN (prev1))\n-\t\t      if (GET_RTX_CLASS (GET_CODE (prev1) == 'i')\n-\t\t\t&& reg_overlap_mentioned_for_reload_p (oldequiv_reg,\n-\t\t\t\t\t\t\t       PATTERN (prev1)))\n-\t\t      {\n-\t\t\tREG_NOTES (prev1) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t\t       oldequiv_reg,\n-\t\t\t\t\t\t\t       REG_NOTES (prev1));\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    remove_death (REGNO (oldequiv_reg), prev);\n-\t\t  }\n-\t\tbreak;\n-\t      }\n-\t}\n-#endif\n \n       /* If we are reloading a register that was recently stored in with an\n \t output-reload, see if we can prove there was\n@@ -7262,30 +7122,6 @@ emit_reload_insns (chain)\n \t\t\t    reload_when_needed[j]);\n \t    }\n \n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\t  /* If final will look at death notes for this reg,\n-\t     put one on the last output-reload insn to use it.  Similarly\n-\t     for any secondary register.  */\n-\t  if (PRESERVE_DEATH_INFO_REGNO_P (REGNO (reloadreg)))\n-\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n-\t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_for_reload_p (reloadreg,\n-\t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t   reloadreg, REG_NOTES (p));\n-\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t  if (! special && second_reloadreg\n-\t      && PRESERVE_DEATH_INFO_REGNO_P (REGNO (second_reloadreg)))\n-\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n-\t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_for_reload_p (second_reloadreg,\n-\t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t   second_reloadreg,\n-\t\t\t\t\t\t   REG_NOTES (p));\n-#endif\n-#endif\n \t  /* Look at all insns we emitted, just to be safe.  */\n \t  for (p = get_insns (); p; p = NEXT_INSN (p))\n \t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n@@ -7410,50 +7246,6 @@ emit_reload_insns (chain)\n         basic_block_end[chain->block] = PREV_INSN (following_insn);\n     }\n \n-  /* Move death notes from INSN\n-     to output-operand-address and output reload insns.  */\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-  {\n-    rtx insn1;\n-    /* Loop over those insns, last ones first.  */\n-    for (insn1 = PREV_INSN (following_insn); insn1 != insn;\n-\t insn1 = PREV_INSN (insn1))\n-      if (GET_CODE (insn1) == INSN && GET_CODE (PATTERN (insn1)) == SET)\n-\t{\n-\t  rtx source = SET_SRC (PATTERN (insn1));\n-\t  rtx dest = SET_DEST (PATTERN (insn1));\n-\n-\t  /* The note we will examine next.  */\n-\t  rtx reg_notes = REG_NOTES (insn);\n-\t  /* The place that pointed to this note.  */\n-\t  rtx *prev_reg_note = &REG_NOTES (insn);\n-\n-\t  /* If the note is for something used in the source of this\n-\t     reload insn, or in the output address, move the note.  */\n-\t  while (reg_notes)\n-\t    {\n-\t      rtx next_reg_notes = XEXP (reg_notes, 1);\n-\t      if (REG_NOTE_KIND (reg_notes) == REG_DEAD\n-\t\t  && GET_CODE (XEXP (reg_notes, 0)) == REG\n-\t\t  && ((GET_CODE (dest) != REG\n-\t\t       && reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n-\t\t\t\t\t\t\t      dest))\n-\t\t      || reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n-\t\t\t\t\t\t\t     source)))\n-\t\t{\n-\t\t  *prev_reg_note = next_reg_notes;\n-\t\t  XEXP (reg_notes, 1) = REG_NOTES (insn1);\n-\t\t  REG_NOTES (insn1) = reg_notes;\n-\t\t}\n-\t      else\n-\t\tprev_reg_note = &XEXP (reg_notes, 1);\n-\n-\t      reg_notes = next_reg_notes;\n-\t    }\n-\t}\n-  }\n-#endif\n-\n   /* For all the spill regs newly reloaded in this instruction,\n      record what they were reloaded from, so subsequent instructions\n      can inherit the reloads.\n@@ -8183,13 +7975,6 @@ static rtx *reg_values;\n \n static rtx invalidate_regno_rtx;\n \n-/* This is a set of registers for which we must remove REG_DEAD notes in\n-   previous insns, because our modifications made them invalid.  That can\n-   happen if we introduced the register into the current insn, or we deleted\n-   the current insn which used to set the register.  */\n-\n-static HARD_REG_SET no_longer_dead_regs;\n-\n /* Invalidate any entries in reg_values which depend on REGNO,\n    including those for REGNO itself.  This is called if REGNO is\n    changing.  If CLOBBER is true, then always forget anything we\n@@ -8392,55 +8177,6 @@ reload_cse_invalidate_rtx (dest, ignore)\n     reload_cse_invalidate_mem (dest);\n }\n \n-/* Possibly delete death notes on the insns before INSN if modifying INSN\n-   extended the lifespan of the registers.  */\n-\n-static void\n-reload_cse_delete_death_notes (insn)\n-     rtx insn;\n-{\n-  int dreg;\n-\n-  for (dreg = 0; dreg < FIRST_PSEUDO_REGISTER; dreg++)\n-    {\n-      rtx trial;\n-\n-      if (! TEST_HARD_REG_BIT (no_longer_dead_regs, dreg))\n-\tcontinue;\n-\n-      for (trial = prev_nonnote_insn (insn);\n-\t   (trial\n-\t    && GET_CODE (trial) != CODE_LABEL\n-\t    && GET_CODE (trial) != BARRIER);\n-\t   trial = prev_nonnote_insn (trial))\n-\t{\n-\t  if (find_regno_note (trial, REG_DEAD, dreg))\n-\t    {\n-\t      remove_death (dreg, trial);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Record that the current insn uses hard reg REGNO in mode MODE.  This\n-   will be used in reload_cse_delete_death_notes to delete prior REG_DEAD\n-   notes for this register.  */\n-\n-static void\n-reload_cse_no_longer_dead (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  int nregs = HARD_REGNO_NREGS (regno, mode);\n-  while (nregs-- > 0)\n-    {\n-      SET_HARD_REG_BIT (no_longer_dead_regs, regno);\n-      regno++;\n-    }\n-}\n-\n-\n /* Do a very simple CSE pass over the hard registers.\n \n    This function detects no-op moves where we happened to assign two\n@@ -8513,8 +8249,6 @@ reload_cse_regs_1 (first)\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n \n-      CLEAR_HARD_REG_SET (no_longer_dead_regs);\n-\n       /* If this is a call instruction, forget anything stored in a\n \t call clobbered register, or, if this is not a const call, in\n \t memory.  */\n@@ -8555,20 +8289,18 @@ reload_cse_regs_1 (first)\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t}\n-\t      reload_cse_delete_death_notes (insn);\n \n \t      /* We're done with this insn.  */\n \t      continue;\n \t    }\n \n \t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \t  count += reload_cse_simplify_set (body, insn);\n \n-\t  if (count > 0 && apply_change_group ())\n-\t    reload_cse_delete_death_notes (insn);\n-\t  else if (reload_cse_simplify_operands (insn))\n-\t    reload_cse_delete_death_notes (insn);\n+\t  if (count > 0)\n+\t    apply_change_group ();\n+\t  else\n+\t    reload_cse_simplify_operands (insn);\n \t    \n \t  reload_cse_record_set (body, body);\n \t}\n@@ -8612,22 +8344,20 @@ reload_cse_regs_1 (first)\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t}\n-\t      reload_cse_delete_death_notes (insn);\n \n \t      /* We're done with this insn.  */\n \t      continue;\n \t    }\n \t  \n \t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    if (GET_CODE (XVECEXP (body, 0, i)) == SET)\n \t      count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n \n-\t  if (count > 0 && apply_change_group ())\n-\t    reload_cse_delete_death_notes (insn);\n-\t  else if (reload_cse_simplify_operands (insn))\n-\t    reload_cse_delete_death_notes (insn);\n+\t  if (count > 0)\n+\t    apply_change_group ();\n+\t  else\n+\t    reload_cse_simplify_operands (insn);\n \n \t  /* Look through the PARALLEL and record the values being\n              set, if possible.  Also handle any CLOBBERs.  */\n@@ -8806,14 +8536,6 @@ reload_cse_noop_set_p (set, insn)\n \tret = 1;\n     }\n \n-  /* If we can delete this SET, then we need to look for an earlier\n-     REG_DEAD note on DREG, and remove it if it exists.  */\n-  if (ret && dreg >= 0)\n-    {\n-      if (! find_regno_note (insn, REG_UNUSED, dreg))\n-\treload_cse_no_longer_dead (dreg, dest_mode);\n-    }\n-\n   return ret;\n }\n \n@@ -8873,11 +8595,8 @@ reload_cse_simplify_set (set, insn)\n              storage.  */\n \t  push_obstacks (&reload_obstack, &reload_obstack);\n \n-\t  if (validated && ! find_regno_note (insn, REG_UNUSED, i))\n-\t    {\n-\t      reload_cse_no_longer_dead (i, dest_mode);\n-\t      return 1;\n-\t    }\n+\t  if (validated)\n+\t    return 1;\n \t}\n     }\n   return 0;\n@@ -9082,7 +8801,6 @@ reload_cse_simplify_operands (insn)\n   /* Substitute the operands as determined by op_alt_regno for the best\n      alternative.  */\n   j = alternative_order[0];\n-  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \n   /* Pop back to the real obstacks while changing the insn.  */\n   pop_obstacks ();\n@@ -9093,7 +8811,6 @@ reload_cse_simplify_operands (insn)\n       if (op_alt_regno[i][j] == -1)\n \tcontinue;\n \n-      reload_cse_no_longer_dead (op_alt_regno[i][j], mode);\n       validate_change (insn, recog_operand_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n     }\n@@ -9106,7 +8823,6 @@ reload_cse_simplify_operands (insn)\n       if (op_alt_regno[op][j] == -1)\n \tcontinue;\n \n-      reload_cse_no_longer_dead (op_alt_regno[op][j], mode);\n       validate_change (insn, recog_dup_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n     }\n@@ -9693,8 +9409,7 @@ static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n /* move2add_luid is linearily increased while scanning the instructions\n    from first to last.  It is used to set reg_set_luid in\n-   reload_cse_move2add and move2add_note_store, and to set reg_death_luid\n-   (local variable of reload_cse_move2add) .  */\n+   reload_cse_move2add and move2add_note_store.  */\n static int move2add_luid;\n \n static void\n@@ -9704,16 +9419,10 @@ reload_cse_move2add (first)\n   int i;\n   rtx insn;\n   int last_label_luid;\n-  /* reg_death and reg_death_luid are solely used to remove stale REG_DEAD\n-     notes.  */\n-  int reg_death_luid[FIRST_PSEUDO_REGISTER];\n-  rtx reg_death[FIRST_PSEUDO_REGISTER];\n \n   for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n-    {\n-      reg_set_luid[i] = 0;\n-      reg_death_luid[i] = 0;\n-    }\n+    reg_set_luid[i] = 0;\n+\n   last_label_luid = 0;\n   move2add_luid = 1;\n   for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n@@ -9768,8 +9477,6 @@ reload_cse_move2add (first)\n \t\t\t   && have_add2_insn (GET_MODE (reg)))\n \t\t    success = validate_change (insn, &PATTERN (insn),\n \t\t\t\t\t       gen_add2_insn (reg, new_src), 0);\n-\t\t  if (success && reg_death_luid[regno] > reg_set_luid[regno])\n-\t\t    remove_death (regno, reg_death[regno]);\n \t\t  reg_set_luid[regno] = move2add_luid;\n \t\t  reg_mode[regno] = GET_MODE (reg);\n \t\t  reg_offset[regno] = src;\n@@ -9818,8 +9525,6 @@ reload_cse_move2add (first)\n \t\t\t\t\t     gen_add2_insn (reg, new_src), 0);\n \t\t      if (success)\n \t\t\t{\n-\t\t\t  if (reg_death_luid[regno] > reg_set_luid[regno])\n-\t\t\t    remove_death (regno, reg_death[regno]);\n \t\t\t  /* INSN might be the first insn in a basic block\n \t\t\t     if the preceding insn is a conditional jump\n \t\t\t     or a possible-throwing call.  */\n@@ -9851,18 +9556,6 @@ reload_cse_move2add (first)\n \t\t  reg_offset[regno] = note;\n \t\t}\n \t    }\n-\t  /* Remember any REG_DEAD notes so that we can remove them\n-\t     later if necessary.  */\n-\t  else if (REG_NOTE_KIND (note) == REG_DEAD\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n-\t    {\n-\t      int regno = REGNO (XEXP (note, 0));\n-\t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  reg_death[regno] = insn;\n-\t\t  reg_death_luid[regno] = move2add_luid;\n-\t\t}\n-\t    }\n \t}\n       note_stores (PATTERN (insn), move2add_note_store);\n       /* If this is a CALL_INSN, all call used registers are stored with"}, {"sha": "c93f49e4785eefe0e0c5bc5c5dbe392988fe9b0e", "filename": "gcc/reorg.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -131,12 +131,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"insn-attr.h\"\n \n-/* Import list of registers used as spill regs from reload.  */\n-extern HARD_REG_SET used_spill_regs;\n-\n-/* Import highest label used in function at end of reload.  */\n-extern int max_label_num_after_reload;\n-\n \n #ifdef DELAY_SLOTS\n \n@@ -2584,14 +2578,6 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t  AND_COMPL_HARD_REG_SET (res->regs, pending_dead_regs);\n \t  CLEAR_HARD_REG_SET (pending_dead_regs);\n \n-\t  if (CODE_LABEL_NUMBER (insn) < max_label_num_after_reload)\n-\t    {\n-\t      /* All spill registers are dead at a label, so kill all of the\n-\t\t ones that aren't needed also.  */\n-\t      COPY_HARD_REG_SET (scratch, used_spill_regs);\n-\t      AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n-\t      AND_COMPL_HARD_REG_SET (res->regs, scratch);\n-\t    }\n \t  continue;\n \n \tcase BARRIER:"}, {"sha": "031d103b34e3eff73b13222a7eabb78a1d52a2fe", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -1194,30 +1194,21 @@ dead_or_set_regno_p (insn, test_regno)\n   int regno, endregno;\n   rtx link;\n \n-  /* REG_READ notes are not normally maintained after reload, so we\n-     ignore them if the are invalid.  */\n-  if (! reload_completed\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-      || PRESERVE_DEATH_INFO_REGNO_P (test_regno)\n-#endif\n-      )\n+  /* See if there is a death note for something that includes\n+     TEST_REGNO.  */\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     {\n-      /* See if there is a death note for something that includes\n-         TEST_REGNO.  */\n-      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t{\n-\t  if (REG_NOTE_KIND (link) != REG_DEAD\n-\t      || GET_CODE (XEXP (link, 0)) != REG)\n-\t    continue;\n+      if (REG_NOTE_KIND (link) != REG_DEAD\n+\t  || GET_CODE (XEXP (link, 0)) != REG)\n+\tcontinue;\n \n-\t  regno = REGNO (XEXP (link, 0));\n-\t  endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n-\t\t      : regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t  GET_MODE (XEXP (link, 0))));\n+      regno = REGNO (XEXP (link, 0));\n+      endregno = (regno >= FIRST_PSEUDO_REGISTER ? regno + 1\n+\t\t  : regno + HARD_REGNO_NREGS (regno,\n+\t\t\t\t\t      GET_MODE (XEXP (link, 0))));\n \n-\t  if (test_regno >= regno && test_regno < endregno)\n-\t    return 1;\n-\t}\n+      if (test_regno >= regno && test_regno < endregno)\n+\treturn 1;\n     }\n \n   if (GET_CODE (insn) == CALL_INSN\n@@ -1231,7 +1222,7 @@ dead_or_set_regno_p (insn, test_regno)\n       /* A value is totally replaced if it is the destination or the\n \t destination is a SUBREG of REGNO that does not change the number of\n \t words in it.  */\n-     if (GET_CODE (dest) == SUBREG\n+      if (GET_CODE (dest) == SUBREG\n \t  && (((GET_MODE_SIZE (GET_MODE (dest))\n \t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))"}, {"sha": "1d81407c3f4298ea3d427e686d16a7edd8673c7d", "filename": "gcc/sched.c", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -1554,27 +1554,6 @@ sched_analyze_insn (x, insn, loop_notes)\n       REG_NOTES (insn) = loop_notes;\n     }\n \n-  /* After reload, it is possible for an instruction to have a REG_DEAD note\n-     for a register that actually dies a few instructions earlier.  For\n-     example, this can happen with SECONDARY_MEMORY_NEEDED reloads.\n-     In this case, we must consider the insn to use the register mentioned\n-     in the REG_DEAD note.  Otherwise, we may accidentally move this insn\n-     after another insn that sets the register, thus getting obviously invalid\n-     rtl.  This confuses reorg which believes that REG_DEAD notes are still\n-     meaningful.\n-\n-     ??? We would get better code if we fixed reload to put the REG_DEAD\n-     notes in the right places, but that may not be worth the effort.  */\n-\n-  if (reload_completed)\n-    {\n-      rtx note;\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD)\n-\t  sched_analyze_2 (XEXP (note, 0), insn);\n-    }\n-\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n \t\t\t       reg_last_sets[i] = insn;\n@@ -3849,16 +3828,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t\t register that was not needed by this instantiation of the\n \t\t pattern, so we can safely ignore it.  */\n \t      if (insn == first)\n-\t\t{\n-\t\t  /* After reload, REG_DEAD notes come sometimes an\n-\t\t     instruction after the register actually dies.  */\n-\t\t  if (reload_completed && REG_NOTE_KIND (note) == REG_DEAD)\n-\t\t    {\n-\t\t      XEXP (note, 1) = REG_NOTES (insn);\n-\t\t      REG_NOTES (insn) = note;\n-\t\t      break;\n-\t\t    }\n-\t\t\t\n+\t\t{\t\t\t\n \t\t  if (REG_NOTE_KIND (note) != REG_UNUSED)\n \t\t    abort ();\n "}, {"sha": "b8e496939261eaf1f90a47689bac3d21e55848a0", "filename": "gcc/tm.texi", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -1684,24 +1684,6 @@ If this macro is not defined, it means that no insn clobbers registers\n mysteriously.  This is the usual situation; all else being equal,\n it is best for the RTL expression to show all the activity.\n \n-@cindex death notes\n-@findex PRESERVE_DEATH_INFO_REGNO_P\n-@item PRESERVE_DEATH_INFO_REGNO_P (@var{regno})\n-If defined, this is a C expression whose value is nonzero if correct\n-@code{REG_DEAD} notes are needed for hard register number @var{regno}\n-after reload.\n-\n-You would arrange to preserve death info for a register when some of the\n-code in the machine description which is executed to write the assembler\n-code looks at the death notes.  This is necessary only when the actual\n-hardware feature which GNU CC thinks of as a register is not actually a\n-register of the usual sort.  (It might, for example, be a hardware\n-stack.)\n-\n-It is also useful for peepholes and linker relaxation.\n-\n-If this macro is not defined, it means that no death notes need to be\n-preserved, and some may even be incorrect.  This is the usual situation.\n @end table\n \n @node Register Classes"}, {"sha": "b329ccc5775f8b9584fce74096af098d45a1052e", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6764d250ec661945176113c1e58262884c02dc9a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6764d250ec661945176113c1e58262884c02dc9a", "patch": "@@ -355,10 +355,6 @@ lang_expand_expr_t lang_expand_expr = 0;\n \n void (*incomplete_decl_finalize_hook) PROTO((tree)) = 0;\n \n-/* Highest label number used at the end of reload.  */\n-\n-int max_label_num_after_reload;\n-\n /* Nonzero if generating code to do profiling.  */\n \n int profile_flag = 0;\n@@ -3756,10 +3752,6 @@ rest_of_compilation (decl)\n   if (global_reg_dump)\n     open_dump_file (\".greg\", decl_printable_name (decl, 2));\n \n-  /* Save the last label number used so far, so reorg can tell\n-     when it's safe to kill spill regs.  */\n-  max_label_num_after_reload = max_label_num ();\n-\n   /* Unless we did stupid register allocation,\n      allocate remaining pseudo-regs, then do the reload pass\n      fixing up any insns that are invalid.  */\n@@ -3782,6 +3774,15 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     reload_cse_regs (insns);\n \n+  /* Re-create the death notes which were deleted during reload.  */\n+  if (optimize)\n+    TIMEVAR\n+      (flow_time,\n+       {\n+\t find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t life_analysis (insns, max_reg_num (), rtl_dump_file);\n+       });\n+\n   /* On some machines, the prologue and epilogue code, or parts thereof,\n      can be represented as RTL.  Doing so lets us schedule insns between\n      it and the rest of the code and also allows delayed branch"}]}