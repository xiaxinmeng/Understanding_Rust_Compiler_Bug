{"sha": "98791e3a3f59c66a1699becef28b69888d319136", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg3OTFlM2EzZjU5YzY2YTE2OTliZWNlZjI4YjY5ODg4ZDMxOTEzNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-05T21:54:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-05T21:54:39Z"}, "message": "alpha.c (alpha_adjust_cost): Remove everything but memory latency adjustments.\n\n        * config/alpha/alpha.c (alpha_adjust_cost): Remove everything but\n        memory latency adjustments.\n        (alpha_variable_issue): Remove.\n        (alpha_use_dfa_pipeline_interface): New.\n        (alpha_multipass_dfa_lookahead): New.\n        * config/alpha/alpha.md: Remove define_function_unit scheduling;\n        include new dfa scheduling.\n        (attr type): Add none.\n        (blockage): Use it.\n        * config/alpha/ev4.md: New.\n        * config/alpha/ev5.md: New.\n        * config/alpha/ev6.md: New.\n\nFrom-SVN: r53196", "tree": {"sha": "c0d43b42da108207e8bf264d34b14e328d6008bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d43b42da108207e8bf264d34b14e328d6008bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98791e3a3f59c66a1699becef28b69888d319136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98791e3a3f59c66a1699becef28b69888d319136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98791e3a3f59c66a1699becef28b69888d319136", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98791e3a3f59c66a1699becef28b69888d319136/comments", "author": null, "committer": null, "parents": [{"sha": "309527ce46ad5d14b51c14742dd68825ee609430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309527ce46ad5d14b51c14742dd68825ee609430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309527ce46ad5d14b51c14742dd68825ee609430"}], "stats": {"total": 983, "additions": 547, "deletions": 436}, "files": [{"sha": "8dfaae729a12c279017fd40353af991d74a76505", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -1,3 +1,18 @@\n+2002-05-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_adjust_cost): Remove everything but\n+\tmemory latency adjustments.\n+\t(alpha_variable_issue): Remove.\n+\t(alpha_use_dfa_pipeline_interface): New.\n+\t(alpha_multipass_dfa_lookahead): New.\n+\t* config/alpha/alpha.md: Remove define_function_unit scheduling;\n+\tinclude new dfa scheduling.\n+\t(attr type): Add none.\n+\t(blockage): Use it.\n+\t* config/alpha/ev4.md: New.\n+\t* config/alpha/ev5.md: New.\n+\t* config/alpha/ev6.md: New.\n+\n 2002-05-05  David S. Miller  <davem@redhat.com>\n \n \t* recog.c (store_data_bypass_p): Handle CLOBBER inside PARALLEL."}, {"sha": "c40636a4bb13225ef869414a9166bafbac0b4085", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 29, "deletions": 127, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -157,8 +157,10 @@ static int alpha_adjust_cost\n   PARAMS ((rtx, rtx, rtx, int));\n static int alpha_issue_rate\n   PARAMS ((void));\n-static int alpha_variable_issue\n-  PARAMS ((FILE *, int, rtx, int));\n+static int alpha_use_dfa_pipeline_interface\n+  PARAMS ((void));\n+static int alpha_multipass_dfa_lookahead\n+  PARAMS ((void));\n \n #if TARGET_ABI_UNICOSMK\n static void alpha_init_machine_status\n@@ -231,8 +233,12 @@ static unsigned int unicosmk_section_type_flags PARAMS ((tree, const char *,\n #define TARGET_SCHED_ADJUST_COST alpha_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE alpha_issue_rate\n-#undef TARGET_SCHED_VARIABLE_ISSUE\n-#define TARGET_SCHED_VARIABLE_ISSUE alpha_variable_issue\n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n+  alpha_use_dfa_pipeline_interface\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n+  alpha_multipass_dfa_lookahead\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -4828,9 +4834,8 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   /* If the dependence is an anti-dependence, there is no cost.  For an\n      output dependence, there is sometimes a cost, but it doesn't seem\n      worth handling those few cases.  */\n-\n   if (REG_NOTE_KIND (link) != 0)\n-    return 0;\n+    return cost;\n \n   /* If we can't recognize the insns, we can't really do anything.  */\n   if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n@@ -4845,141 +4850,38 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n       || dep_insn_type == TYPE_LDSYM)\n     cost += alpha_memory_latency-1;\n \n-  switch (alpha_cpu)\n-    {\n-    case PROCESSOR_EV4:\n-      /* On EV4, if INSN is a store insn and DEP_INSN is setting the data\n-\t being stored, we can sometimes lower the cost.  */\n-\n-      if ((insn_type == TYPE_IST || insn_type == TYPE_FST)\n-\t  && (set = single_set (dep_insn)) != 0\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n-\t{\n-\t  switch (dep_insn_type)\n-\t    {\n-\t    case TYPE_ILD:\n-\t    case TYPE_FLD:\n-\t      /* No savings here.  */\n-\t      return cost;\n-\n-\t    case TYPE_IMUL:\n-\t      /* In these cases, we save one cycle.  */\n-\t      return cost - 1;\n-\n-\t    default:\n-\t      /* In all other cases, we save two cycles.  */\n-\t      return MAX (0, cost - 2);\n-\t    }\n-\t}\n+  /* Everything else handled in DFA bypasses now.  */\n \n-      /* Another case that needs adjustment is an arithmetic or logical\n-\t operation.  It's cost is usually one cycle, but we default it to\n-\t two in the MD file.  The only case that it is actually two is\n-\t for the address in loads, stores, and jumps.  */\n-\n-      if (dep_insn_type == TYPE_IADD || dep_insn_type == TYPE_ILOG)\n-\t{\n-\t  switch (insn_type)\n-\t    {\n-\t    case TYPE_ILD:\n-\t    case TYPE_IST:\n-\t    case TYPE_FLD:\n-\t    case TYPE_FST:\n-\t    case TYPE_JSR:\n-\t      return cost;\n-\t    default:\n-\t      return 1;\n-\t    }\n-\t}\n-\n-      /* The final case is when a compare feeds into an integer branch;\n-\t the cost is only one cycle in that case.  */\n-\n-      if (dep_insn_type == TYPE_ICMP && insn_type == TYPE_IBR)\n-\treturn 1;\n-      break;\n-\n-    case PROCESSOR_EV5:\n-      /* And the lord DEC saith:  \"A special bypass provides an effective\n-\t latency of 0 cycles for an ICMP or ILOG insn producing the test\n-\t operand of an IBR or ICMOV insn.\" */\n-\n-      if ((dep_insn_type == TYPE_ICMP || dep_insn_type == TYPE_ILOG)\n-\t  && (set = single_set (dep_insn)) != 0)\n-\t{\n-\t  /* A branch only has one input.  This must be it.  */\n-\t  if (insn_type == TYPE_IBR)\n-\t    return 0;\n-\t  /* A conditional move has three, make sure it is the test.  */\n-\t  if (insn_type == TYPE_ICMOV\n-\t      && GET_CODE (set_src = PATTERN (insn)) == SET\n-\t      && GET_CODE (set_src = SET_SRC (set_src)) == IF_THEN_ELSE\n-\t      && rtx_equal_p (SET_DEST (set), XEXP (set_src, 0)))\n-\t    return 0;\n-\t}\n-\n-      /* \"The multiplier is unable to receive data from IEU bypass paths.\n-\t The instruction issues at the expected time, but its latency is\n-\t increased by the time it takes for the input data to become\n-\t available to the multiplier\" -- which happens in pipeline stage\n-\t six, when results are comitted to the register file.  */\n-\n-      if (insn_type == TYPE_IMUL)\n-\t{\n-\t  switch (dep_insn_type)\n-\t    {\n-\t    /* These insns produce their results in pipeline stage five.  */\n-\t    case TYPE_ILD:\n-\t    case TYPE_ICMOV:\n-\t    case TYPE_IMUL:\n-\t    case TYPE_MVI:\n-\t      return cost + 1;\n-\n-\t    /* Other integer insns produce results in pipeline stage four.  */\n-\t    default:\n-\t      return cost + 2;\n-\t    }\n-\t}\n-      break;\n-\n-    case PROCESSOR_EV6:\n-      /* There is additional latency to move the result of (most) FP \n-         operations anywhere but the FP register file.  */\n-\n-      if ((insn_type == TYPE_FST || insn_type == TYPE_FTOI)\n-\t  && (dep_insn_type == TYPE_FADD ||\n-\t      dep_insn_type == TYPE_FMUL ||\n-\t      dep_insn_type == TYPE_FCMOV))\n-        return cost + 2;\n-\n-      break;\n-    }\n-\n-  /* Otherwise, return the default cost.  */\n   return cost;\n }\n \n-/* Function to initialize the issue rate used by the scheduler.  */\n+/* The number of instructions that can be issued per cycle.  */\n+\n static int\n alpha_issue_rate ()\n {\n   return (alpha_cpu == PROCESSOR_EV4 ? 2 : 4);\n }\n \n static int\n-alpha_variable_issue (dump, verbose, insn, cim)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int verbose ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     int cim;\n+alpha_use_dfa_pipeline_interface ()\n {\n-    if (recog_memoized (insn) < 0 || get_attr_type (insn) == TYPE_MULTI)\n-      return 0;\n-\n-    return cim - 1;\n+  return true;\n }\n \n+/* How many alternative schedules to try.  This should be as wide as the\n+   scheduling freedom in the DFA, but no wider.  Making this value too\n+   large results extra work for the scheduler.\n+\n+   For EV4, loads can be issued to either IB0 or IB1, thus we have 2\n+   alternative schedules.  For EV5, we can choose between E0/E1 and\n+   FA/FM.  For EV6, an arithmatic insn can be issued to U0/U1/L0/L1.  */\n+\n+static int\n+alpha_multipass_dfa_lookahead ()\n+{\n+  return (alpha_cpu == PROCESSOR_EV6 ? 4 : 2);\n+}\n \f\n /* Register global variables and machine-specific functions with the\n    garbage collector.  */"}, {"sha": "1df715ad0c27e78bc04422484cf4832e1aba30ad", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 8, "deletions": 309, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -78,7 +78,7 @@\n \n (define_attr \"type\"\n   \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,\\\n-fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n+fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   (const_string \"iadd\"))\n \n ;; Describe a user's asm statement.\n@@ -123,313 +123,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n (define_attr \"length\" \"\"\n   (const_int 4))\n \f\n-;; On EV4 there are two classes of resources to consider: resources needed\n-;; to issue, and resources needed to execute.  IBUS[01] are in the first\n-;; category.  ABOX, BBOX, EBOX, FBOX, IMUL & FDIV make up the second.\n-;; (There are a few other register-like resources, but ...)\n-\n-; First, describe all of the issue constraints with single cycle delays.\n-; All insns need a bus, but all except loads require one or the other.\n-(define_function_unit \"ev4_ibus0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fst,fbr,iadd,imul,ilog,shift,icmov,icmp\"))\n-  1 1)\n-\n-(define_function_unit \"ev4_ibus1\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"ist,ibr,jsr,fadd,fcmov,fcpys,fmul,fdiv,misc\"))\n-  1 1)\n-\n-; Memory delivers its result in three cycles.  Actually return one and\n-; take care of this in adjust_cost, since we want to handle user-defined\n-; memory latencies.\n-(define_function_unit \"ev4_abox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"ild,fld,ldsym,ist,fst\"))\n-  1 1)\n-\n-; Branches have no delay cost, but do tie up the unit for two cycles.\n-(define_function_unit \"ev4_bbox\" 1 1\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"ibr,fbr,jsr\"))\n-  2 2)\n-\n-; Arithmetic insns are normally have their results available after\n-; two cycles.  There are a number of exceptions.  They are encoded in\n-; ADJUST_COST.  Some of the other insns have similar exceptions.\n-(define_function_unit \"ev4_ebox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"iadd,ilog,shift,icmov,icmp,misc\"))\n-  2 1)\n-\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (and (eq_attr \"type\" \"imul\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  21 19)\n-\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (and (eq_attr \"type\" \"imul\")\n-\t    (eq_attr \"opsize\" \"!si\")))\n-  23 21)\n-\n-(define_function_unit \"ev4_fbox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fadd,fmul,fcpys,fcmov\"))\n-  6 1)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  34 30)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"di\")))\n-  63 59)\n-\f\n-;; EV5 scheduling.  EV5 can issue 4 insns per clock.\n-;;\n-;; EV5 has two asymetric integer units.  Model this with E0 & E1 along\n-;; with the combined resource EBOX.\n-\n-(define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"!fbr,fcmov,fadd,fmul,fcpys,fdiv\"))\n-  1 1)\n-\n-; Memory takes at least 2 clocks.  Return one from here and fix up with\n-; user-defined latencies in adjust_cost.\n-(define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ild,fld,ldsym\"))\n-  1 1)\n-\n-; Loads can dual issue with one another, but loads and stores do not mix.\n-(define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ild,fld,ldsym\"))\n-  1 1\n-  [(eq_attr \"type\" \"ist,fst\")])\n-\n-; Stores, shifts, multiplies can only issue to E0\n-(define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ist,fst,shift,imul\"))\n-  1 1)\n-\n-; Motion video insns also issue only to E0, and take two ticks.\n-(define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"mvi\"))\n-  2 1)\n-\n-; Conditional moves always take 2 ticks.\n-(define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"icmov\"))\n-  2 1)\n-\n-; Branches can only issue to E1\n-(define_function_unit \"ev5_e1\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ibr,jsr\"))\n-  1 1)\n-\n-; Multiplies also use the integer multiplier.\n-; ??? How to: \"No instruction can be issued to pipe E0 exactly two\n-; cycles before an integer multiplication completes.\"\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (and (eq_attr \"type\" \"imul\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  8 4)\n-\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (and (eq_attr \"type\" \"imul\")\n-\t    (eq_attr \"opsize\" \"di\")))\n-  12 8)\n-\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (and (eq_attr \"type\" \"imul\")\n-\t    (eq_attr \"opsize\" \"udi\")))\n-  14 8)\n-\n-;; Similarly for the FPU we have two asymetric units.  But fcpys can issue\n-;; on either so we have to play the game again.\n-\n-(define_function_unit \"ev5_fbox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fadd,fcmov,fmul,fcpys,fbr,fdiv\"))\n-  4 1)\n-\n-(define_function_unit \"ev5_fm\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fmul\"))\n-  4 1)\n-\n-; Add and cmov as you would expect; fbr never produces a result;\n-; fdiv issues through fa to the divider,\n-(define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fadd,fcmov,fbr,fdiv\"))\n-  4 1)\n-\n-; ??? How to: \"No instruction can be issued to pipe FA exactly five\n-; cycles before a floating point divide completes.\"\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  15 15)\t\t\t\t; 15 to 31 data dependent\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"di\")))\n-  22 22)\t\t\t\t; 22 to 60 data dependent\n-\f\n-;; EV6 scheduling.  EV6 can issue 4 insns per clock.\n-;;\n-;; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer units\n-;; (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n-\n-;; Conditional moves decompose into two independent primitives, each\n-;; taking one cycle.  Since ev6 is out-of-order, we can't see anything\n-;; but two cycles.\n-(define_function_unit \"ev6_ebox\" 4 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"icmov\"))\n-  2 1)\n-\n-(define_function_unit \"ev6_ebox\" 4 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"!fbr,fcmov,fadd,fmul,fcpys,fdiv,fsqrt\"))\n-  1 1)\n-\n-;; Integer loads take at least 3 clocks, and only issue to lower units.\n-;; Return one from here and fix up with user-defined latencies in adjust_cost.\n-(define_function_unit \"ev6_l\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"ild,ldsym,ist,fst\"))\n-  1 1)\n-\n-;; FP loads take at least 4 clocks.  Return two from here...\n-(define_function_unit \"ev6_l\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"fld\"))\n-  2 1)\n-\n-;; Motion video insns also issue only to U0, and take three ticks.\n-(define_function_unit \"ev6_u0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"mvi\"))\n-  3 1)\n-\n-(define_function_unit \"ev6_u\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"mvi\"))\n-  3 1)\n-\n-;; Shifts issue to either upper pipe.\n-(define_function_unit \"ev6_u\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"shift\"))\n-  1 1)\n-\n-;; Multiplies issue only to U1, and all take 7 ticks.\n-;; Rather than create a new function unit just for U1, reuse IMUL\n-(define_function_unit \"imul\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"imul\"))\n-  7 1)\n-\n-(define_function_unit \"ev6_u\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"imul\"))\n-  7 1)\n-\n-;; Branches issue to either upper pipe\n-(define_function_unit \"ev6_u\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"ibr\"))\n-  3 1)\n-\n-;; Calls only issue to L0.\n-(define_function_unit \"ev6_l0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"jsr\"))\n-  1 1)\n-\n-(define_function_unit \"ev6_l\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"jsr\"))\n-  1 1)\n-\n-;; Ftoi/itof only issue to lower pipes\n-(define_function_unit \"ev6_l\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"ftoi\"))\n-  3 1)\n-\n-(define_function_unit \"ev6_l\" 2 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"itof\"))\n-  4 1)\n-\n-;; For the FPU we are very similar to EV5, except there's no insn that\n-;; can issue to fm & fa, so we get to leave that out.\n-\n-(define_function_unit \"ev6_fm\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"fmul\"))\n-  4 1)\n-\n-(define_function_unit \"ev6_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"fadd,fcpys,fbr,fdiv,fsqrt\"))\n-  4 1)\n-\n-(define_function_unit \"ev6_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (eq_attr \"type\" \"fcmov\"))\n-  8 1)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  12 10)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (and (eq_attr \"type\" \"fdiv\")\n-\t    (eq_attr \"opsize\" \"di\")))\n-  15 13)\n-\n-(define_function_unit \"fsqrt\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (and (eq_attr \"type\" \"fsqrt\")\n-\t    (eq_attr \"opsize\" \"si\")))\n-  16 14)\n-\n-(define_function_unit \"fsqrt\" 1 0\n-  (and (eq_attr \"cpu\" \"ev6\")\n-       (and (eq_attr \"type\" \"fsqrt\")\n-\t    (eq_attr \"opsize\" \"di\")))\n-  32 30)\n-\n-; ??? The FPU communicates with memory and the integer register file\n-; via two fp store units.  We need a slot in the fst immediately, and\n-; a slot in LOW after the operand data is ready.  At which point the\n-; data may be moved either to the store queue or the integer register\n-; file and the insn retired.\n-\n+;; Include scheduling descriptions.\n+  \n+(include \"ev4.md\")\n+(include \"ev5.md\")\n+(include \"ev6.md\")\n \f\n ;; First define the arithmetic insns.  Note that the 32-bit forms also\n ;; sign-extend.\n@@ -5018,7 +4716,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n   \"\"\n   \"\"\n-  [(set_attr \"length\" \"0\")])\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"none\")])\n \n (define_insn \"jump\"\n   [(set (pc)"}, {"sha": "6816e44640ba6f1a9ed3ab5770bbcc81893db090", "filename": "gcc/config/alpha/ev4.md", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev4.md?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -0,0 +1,142 @@\n+;; Scheduling description for Alpha EV4.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+; On EV4 there are two classes of resources to consider: resources needed\n+; to issue, and resources needed to execute.  IBUS[01] are in the first\n+; category.  ABOX, BBOX, EBOX, FBOX, IMUL & FDIV make up the second.\n+; (There are a few other register-like resources, but ...)\n+\n+(define_automaton \"ev4_0,ev4_1,ev4_2\")\n+(define_cpu_unit \"ev4_ib0,ev4_ib1,ev4_abox,ev4_bbox\" \"ev4_0\")\n+(define_cpu_unit \"ev4_ebox,ev4_imul\" \"ev4_1\")\n+(define_cpu_unit \"ev4_fbox,ev4_fdiv\" \"ev4_2\")\n+(define_reservation \"ev4_ib01\" \"ev4_ib0|ev4_ib1\")\n+\n+; Assume type \"multi\" single issues.\n+(define_insn_reservation \"ev4_multi\" 1\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"multi\"))\n+  \"ev4_ib0+ev4_ib1\")\n+\n+; Loads from L0 completes in three cycles.  adjust_cost still factors\n+; in user-specified memory latency, so return 1 here.\n+(define_insn_reservation \"ev4_ld\" 1\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"ild,fld,ldsym\"))\n+  \"ev4_ib01+ev4_abox\")\n+\n+; Stores can issue before the data (but not address) is ready.\n+(define_insn_reservation \"ev4_ist\" 1\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"ist\"))\n+  \"ev4_ib1+ev4_abox\")\n+\n+(define_insn_reservation \"ev4_fst\" 1\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"fst\"))\n+  \"ev4_ib0+ev4_abox\")\n+\n+; Branches have no delay cost, but do tie up the unit for two cycles.\n+(define_insn_reservation \"ev4_ibr\" 2\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"ibr,jsr\"))\n+  \"ev4_ib1+ev4_bbox,ev4_bbox\")\n+\n+(define_insn_reservation \"ev4_fbr\" 2\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"fbr\"))\n+  \"ev4_ib0+ev4_bbox,ev4_bbox\")\n+\n+; Arithmetic insns are normally have their results available after\n+; two cycles.  There are a number of exceptions.\n+\n+(define_insn_reservation \"ev4_iaddlog\" 2\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"iadd,ilog\"))\n+  \"ev4_ib0+ev4_ebox\")\n+\n+(define_bypass 1\n+  \"ev4_iaddlog\"\n+  \"ev4_ibr,ev4_iaddlog,ev4_shiftcm,ev4_icmp,ev4_imulsi,ev4_imuldi\")\n+\n+(define_insn_reservation \"ev4_shiftcm\" 2\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"shift,icmov\"))\n+  \"ev4_ib0+ev4_ebox\")\n+\n+(define_insn_reservation \"ev4_icmp\" 2\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"icmp\"))\n+  \"ev4_ib0+ev4_ebox\")\n+\n+(define_bypass 1 \"ev4_icmp\" \"ev4_ibr\")\n+\n+(define_bypass 0\n+  \"ev4_iaddlog,ev4_shiftcm,ev4_icmp\"\n+  \"ev4_ist\"\n+  \"store_data_bypass_p\")\n+\n+; Multiplies use a non-piplined imul unit.  Also, \"no [ebox] insn can\n+; be issued exactly three cycles before an integer multiply completes\".\n+\n+(define_insn_reservation \"ev4_imulsi\" 21\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  \"ev4_ib0+ev4_imul,ev4_imul*18,ev4_ebox\")\n+\n+(define_bypass 20 \"ev4_imulsi\" \"ev4_ist\" \"store_data_bypass_p\")\n+\n+(define_insn_reservation \"ev4_imuldi\" 23\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"!si\")))\n+  \"ev4_ib0+ev4_imul,ev4_imul*20,ev4_ebox\")\n+\n+(define_bypass 22 \"ev4_imuldi\" \"ev4_ist\" \"store_data_bypass_p\")\n+\n+; Most FP insns have a 6 cycle latency, but with a 4 cycle bypass back in.\n+(define_insn_reservation \"ev4_fpop\" 6\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"fadd,fmul,fcpys,fcmov\"))\n+  \"ev4_ib1+ev4_fbox\")\n+\n+(define_bypass 4 \"ev4_fpop\" \"ev4_fpop\")\n+\n+; The floating point divider is not pipelined.  Also, \"no FPOP insn can be\n+; issued exactly five or exactly six cycles before an fdiv insn completes\".\n+\n+(define_insn_reservation \"ev4_fdivsf\" 34\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  \"ev4_ib1+ev4_fdiv,ev4_fdiv*28,ev4_fdiv+ev4_fbox,ev4_fbox\")\n+\n+(define_insn_reservation \"ev4_fdivdf\" 63\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  \"ev4_ib1+ev4_fdiv,ev4_fdiv*57,ev4_fdiv+ev4_fbox,ev4_fbox\")\n+\n+; Traps don't consume or produce data.\n+(define_insn_reservation \"ev4_misc\" 1\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"misc\"))\n+  \"ev4_ib1\")"}, {"sha": "f0dfbdf22e6fa1dcc4a4944388e91f9206407c8f", "filename": "gcc/config/alpha/ev5.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev5.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev5.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev5.md?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -0,0 +1,180 @@\n+;; Scheduling description for Alpha EV5.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; EV5 has two asymetric integer units, E0 and E1, plus separate\n+;; FP add and multiply units.\n+\n+(define_automaton \"ev5_0,ev5_1\")\n+(define_cpu_unit \"ev5_e0,ev5_e1,ev5_fa,ev5_fm\" \"ev5_0\")\n+(define_reservation \"ev5_e01\" \"ev5_e0|ev5_e1\")\n+(define_reservation \"ev5_fam\" \"ev5_fa|ev5_fm\")\n+(define_cpu_unit \"ev5_imul\" \"ev5_0\")\n+(define_cpu_unit \"ev5_fdiv\" \"ev5_1\")\n+\n+; Assume type \"multi\" single issues.\n+(define_insn_reservation \"ev5_multi\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"multi\"))\n+  \"ev5_e0+ev5_e1+ev5_fa+ev5_fm\")\n+\n+; Stores can only issue to E0, and may not issue with loads.\n+; Model this with some fake units.\n+\n+(define_cpu_unit \"ev5_l0,ev5_l1,ev5_st\" \"ev5_0\")\n+(define_reservation \"ev5_ld\" \"ev5_l0|ev5_l1\")\n+(exclusion_set \"ev5_l0,ev5_l1\" \"ev5_st\")\n+\n+(define_insn_reservation \"ev5_st\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"ist,fst\"))\n+  \"ev5_e0+ev5_st\")\n+\n+; Loads from L0 complete in two cycles.  adjust_cost still factors\n+; in user-specified memory latency, so return 1 here.\n+(define_insn_reservation \"ev5_ld\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"ild,fld,ldsym\"))\n+  \"ev5_e01+ev5_ld\")\n+\n+; Integer branches slot only to E1.\n+(define_insn_reservation \"ev5_ibr\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"ibr\"))\n+  \"ev5_e1\")\n+\n+(define_insn_reservation \"ev5_jsr\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"jsr\"))\n+  \"ev5_e1\")\n+\n+(define_insn_reservation \"ev5_shiftmvi\" 2\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"shift,mvi\"))\n+  \"ev5_e0\")\n+\n+(define_insn_reservation \"ev5_cmov\" 2\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"icmov\"))\n+  \"ev5_e01\")\n+\n+(define_insn_reservation \"ev5_iadd\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"iadd\"))\n+  \"ev5_e01\")\n+\n+(define_insn_reservation \"ev5_ilogcmp\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"ilog,icmp\"))\n+  \"ev5_e01\")\n+\n+; Conditional move and branch can issue the same cycle as the test.\n+(define_bypass 0 \"ev5_ilogcmp\" \"ev5_ibr,ev5_cmov\" \"if_test_bypass_p\")\n+\n+; Multiplies use a non-piplined imul unit.  Also, \"no insn can be issued\n+; to E0 exactly two cycles before an integer multiply completes\".\n+\n+(define_insn_reservation \"ev5_imull\" 8\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  \"ev5_e0+ev5_imul,ev5_imul*3,nothing,ev5_e0\")\n+\n+(define_insn_reservation \"ev5_imulq\" 12\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  \"ev5_e0+ev5_imul,ev5_imul*7,nothing,ev5_e0\")\n+\n+(define_insn_reservation \"ev5_imulh\" 14\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"udi\")))\n+  \"ev5_e0+ev5_imul,ev5_imul*7,nothing*3,ev5_e0\")\n+\n+; The multiplier is unable to receive data from Ebox bypass paths.  The\n+; instruction issues at the expected time, but its latency is increased\n+; by the time it takes for the input data to become available to the\n+; multiplier.  For example, an IMULL instruction issued one cycle later\n+; than an ADDL instruction, which produced one of its operands, has a\n+; latency of 10 (8 + 2).  If the IMULL instruction is issued two cycles\n+; later than the ADDL instruction, the latency is 9 (8 + 1).\n+;\n+; Model this instead with increased latency on the input instruction.\n+\n+(define_bypass 3\n+  \"ev5_ld,ev5_shiftmvi,ev5_cmov,ev5_iadd,ev5_ilogcmp\"\n+  \"ev5_imull,ev5_imulq,ev5_imulh\")\n+\n+(define_bypass  9 \"ev5_imull\" \"ev5_imull,ev5_imulq,ev5_imulh\")\n+(define_bypass 13 \"ev5_imulq\" \"ev5_imull,ev5_imulq,ev5_imulh\")\n+(define_bypass 15 \"ev5_imulh\" \"ev5_imull,ev5_imulq,ev5_imulh\")\n+\n+; Similarly for the FPU we have two asymetric units.\n+\n+(define_insn_reservation \"ev5_fadd\" 4\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"fadd,fcmov\"))\n+  \"ev5_fa\")\n+\n+(define_insn_reservation \"ev5_fbr\" 1\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"fbr\"))\n+  \"ev5_fa\")\n+\n+(define_insn_reservation \"ev5_fcpys\" 4\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"fcpys\"))\n+  \"ev5_fam\")\n+\n+(define_insn_reservation \"ev5_fmul\" 4\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"fmul\"))\n+  \"ev5_fm\")\n+\n+; The floating point divider is not pipelined.  Also, \"no insn can be issued\n+; to FA exactly five before an fdiv insn completes\".\n+;\n+; ??? Do not model this late reservation due to the enormously increased\n+; size of the resulting DFA.\n+;\n+; ??? Putting ev5_fa and ev5_fdiv alone into the same automata produces\n+; a DFA of acceptable size, but putting ev5_fm and ev5_fa into separate\n+; automata produces incorrect results for insns that can choose one or\n+; the other, i.e. ev5_fcpys.\n+\n+(define_insn_reservation \"ev5_fdivsf\" 15\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  ; \"ev5_fa+ev5_fdiv,ev5_fdiv*9,ev5_fa+ev5_fdiv,ev5_fdiv*4\"\n+  \"ev5_fa+ev5_fdiv,ev5_fdiv*14\")\n+\n+(define_insn_reservation \"ev5_fdivdf\" 22\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  ; \"ev5_fa+ev5_fdiv,ev5_fdiv*17,ev5_fa+ev5_fdiv,ev5_fdiv*4\"\n+  \"ev5_fa+ev5_fdiv,ev5_fdiv*21\")\n+\n+; Traps don't consume or produce data; rpcc is latency 2 if we ever add it.\n+(define_insn_reservation \"ev5_misc\" 2\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"misc\"))\n+  \"ev5_e0\")"}, {"sha": "78bb51f23f2df8eed14f6c967342310a6f3108c1", "filename": "gcc/config/alpha/ev6.md", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98791e3a3f59c66a1699becef28b69888d319136/gcc%2Fconfig%2Falpha%2Fev6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev6.md?ref=98791e3a3f59c66a1699becef28b69888d319136", "patch": "@@ -0,0 +1,173 @@\n+;; Scheduling description for Alpha EV6.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+; EV6 can issue 4 insns per clock.  It's out-of-order, so this isn't\n+; expected to help over-much, but a precise description can be important\n+; for software pipelining.\n+;\n+; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer\n+; units (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n+;\n+; ??? The clusters have independent register files that are re-synced\n+; every cycle.  Thus there is one additional cycle of latency between\n+; insns issued on different clusters.  Possibly model that by duplicating\n+; all EBOX insn_reservations that can issue to either cluster, increasing\n+; all latencies by one, and adding bypasses within the cluster.\n+;\n+; ??? In addition, instruction order affects cluster issue.\n+\n+(define_automaton \"ev6_0,ev6_1\")\n+(define_cpu_unit \"ev6_u0,ev6_u1,ev6_l0,ev6_l1\" \"ev6_0\")\n+(define_reservation \"ev6_u\" \"ev6_u0|ev6_u1\")\n+(define_reservation \"ev6_l\" \"ev6_l0|ev6_l1\")\n+(define_reservation \"ev6_ebox\" \"ev6_u|ev6_l\")\n+\n+(define_cpu_unit \"ev6_fa\" \"ev6_1\")\n+(define_cpu_unit \"ev6_fm,ev6_fst0,ev6_fst1\" \"ev6_0\")\n+(define_reservation \"ev6_fst\" \"ev6_fst0|ev6_fst1\")\n+\n+; Assume type \"multi\" single issues.\n+(define_insn_reservation \"ev6_multi\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"multi\"))\n+  \"ev6_u0+ev6_u1+ev6_l0+ev6_l1+ev6_fa+ev6_fm+ev6_fst0+ev6_fst1\")\n+\n+; Integer loads take at least 3 clocks, and only issue to lower units.\n+; adjust_cost still factors in user-specified memory latency, so return 1 here.\n+(define_insn_reservation \"ev6_ild\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ild,ldsym\"))\n+  \"ev6_l\")\n+\n+(define_insn_reservation \"ev6_ist\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ist\"))\n+  \"ev6_l\")\n+\n+; FP loads take at least 4 clocks.  adjust_cost still factors\n+; in user-specified memory latency, so return 2 here.\n+(define_insn_reservation \"ev6_fld\" 2\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fld\"))\n+  \"ev6_l\")\n+\n+; The FPU communicates with memory and the integer register file\n+; via two fp store units.  We need a slot in the fst immediately, and\n+; a slot in LOW after the operand data is ready.  At which point the\n+; data may be moved either to the store queue or the integer register\n+; file and the insn retired.\n+\n+(define_insn_reservation \"ev6_fst\" 3\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fst\"))\n+  \"ev6_fst,nothing,ev6_l\")\n+\n+; Arithmetic goes anywhere.\n+(define_insn_reservation \"ev6_arith\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"iadd,ilog,icmp\"))\n+  \"ev6_ebox\")\n+\n+; Motion video insns also issue only to U0, and take three ticks.\n+(define_insn_reservation \"ev6_mvi\" 3\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"mvi\"))\n+  \"ev6_u0\")\n+\n+; Shifts issue to upper units.\n+(define_insn_reservation \"ev6_shift\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"shift\"))\n+  \"ev6_u\")\n+\n+; Multiplies issue only to U1, and all take 7 ticks.\n+(define_insn_reservation \"ev6_imul\" 7\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"imul\"))\n+  \"ev6_u1\")\n+\n+; Conditional moves decompose into two independent primitives, each taking\n+; one cycle.  Since ev6 is out-of-order, we can't see anything but two cycles.\n+(define_insn_reservation \"ev6_icmov\" 2\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"icmov\"))\n+  \"ev6_ebox,ev6_ebox\")\n+\n+; Integer branches issue to upper units\n+(define_insn_reservation \"ev6_ibr\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ibr\"))\n+  \"ev6_u\")\n+\n+; Calls only issue to L0.\n+(define_insn_reservation \"ev6_jsr\" 1\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"jsr\"))\n+  \"ev6_l0\")\n+\n+; Ftoi/itof only issue to lower pipes.\n+(define_insn_reservation \"ev6_itof\" 3\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"itof\"))\n+  \"ev6_l\")\n+\n+(define_insn_reservation \"ev6_ftoi\" 3\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ftoi\"))\n+  \"ev6_fst,nothing,ev6_l\")\n+\n+(define_insn_reservation \"ev6_fmul\" 4\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fmul\"))\n+  \"ev6_fm\")\n+\n+(define_insn_reservation \"ev6_fadd\" 4\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fadd,fcpys,fbr\"))\n+  \"ev6_fa\")\n+\n+(define_insn_reservation \"ev6_fcmov\" 8\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fcmov\"))\n+  \"ev6_fa,nothing*3,ev6_fa\")\n+\n+(define_insn_reservation \"ev6_fdivsf\" 12\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  \"ev6_fa*9\")\n+\n+(define_insn_reservation \"ev6_fdivdf\" 15\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  \"ev6_fa*12\")\n+\n+(define_insn_reservation \"ev6_sqrtsf\" 18\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  \"ev6_fa*15\")\n+\n+(define_insn_reservation \"ev6_sqrtdf\" 33\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  \"ev6_fa*30\")"}]}