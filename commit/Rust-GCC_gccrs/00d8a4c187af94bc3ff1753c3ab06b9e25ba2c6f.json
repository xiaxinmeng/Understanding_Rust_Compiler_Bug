{"sha": "00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBkOGE0YzE4N2FmOTRiYzNmZjE3NTNjM2FiMDZiOWUyNWJhMmM2Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:47:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:47:00Z"}, "message": "(fixup_var_refs{,_insns}): Add new parms for promoted mode and signedness;\n\nall callers changed.\nInsert mode conversions when required.\n(fixup_var_refs_1): Add new parms for mode and signedness; handle SUBREGs\nfor promoted values.\n(assign_parms): Promote the mode of parameters when useful for the target\nmachine.\n\nFrom-SVN: r2175", "tree": {"sha": "cad4c9e09d4468d60da7e62e537033f91196f146", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cad4c9e09d4468d60da7e62e537033f91196f146"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f/comments", "author": null, "committer": null, "parents": [{"sha": "1499e0a89ff9d386d58c6b63ae2b40c5acb031f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1499e0a89ff9d386d58c6b63ae2b40c5acb031f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1499e0a89ff9d386d58c6b63ae2b40c5acb031f7"}], "stats": {"total": 159, "additions": 118, "deletions": 41}, "files": [{"sha": "9295cb1121c1ffc92a74755b4b4cebf67b3c303c", "filename": "gcc/function.c", "status": "modified", "additions": 118, "deletions": 41, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=00d8a4c187af94bc3ff1753c3ab06b9e25ba2c6f", "patch": "@@ -495,7 +495,7 @@ pop_function_context ()\n   {\n     struct var_refs_queue *queue = p->fixup_var_refs_queue;\n     for (; queue; queue = queue->next)\n-      fixup_var_refs (queue->modified);\n+      fixup_var_refs (queue->modified, queue->promoted_mode, queue->unsignedp);\n   }\n \n   free (p);\n@@ -812,11 +812,17 @@ put_var_into_stack (decl)\n {\n   register rtx reg;\n   register rtx new = 0;\n+  enum machine_mode promoted_mode, decl_mode;\n   struct function *function = 0;\n   tree context = decl_function_context (decl);\n \n-  /* Get the current rtl used for this object.  */\n+  /* Get the current rtl used for this object and it's original mode.  */\n   reg = TREE_CODE (decl) == SAVE_EXPR ? SAVE_EXPR_RTL (decl) : DECL_RTL (decl);\n+  promoted_mode = GET_MODE (reg);\n+\n+  /* Get the declared mode for this object.  */\n+  decl_mode = (TREE_CODE (decl) == SAVE_EXPR ? TYPE_MODE (TREE_TYPE (decl))\n+\t       : DECL_MODE (decl));\n \n   /* If this variable comes from an outer function,\n      find that function's saved context.  */\n@@ -847,7 +853,7 @@ put_var_into_stack (decl)\n \tnew = function->parm_reg_stack_loc[REGNO (reg)];\n       if (new == 0)\n \tnew = assign_outer_stack_local (GET_MODE (reg),\n-\t\t\t\t\tGET_MODE_SIZE (GET_MODE (reg)),\n+\t\t\t\t\tGET_MODE_SIZE (decl_mode),\n \t\t\t\t\t0, function);\n     }\n   else\n@@ -856,14 +862,14 @@ put_var_into_stack (decl)\n \tnew = parm_reg_stack_loc[REGNO (reg)];\n       if (new == 0)\n \tnew = assign_stack_local (GET_MODE (reg),\n-\t\t\t\t  GET_MODE_SIZE (GET_MODE (reg)),\n-\t\t\t\t  0);\n+\t\t\t\t  GET_MODE_SIZE (decl_mode), 0);\n     }\n \n   XEXP (reg, 0) = XEXP (new, 0);\n   /* `volatil' bit means one thing for MEMs, another entirely for REGs.  */\n   REG_USERVAR_P (reg) = 0;\n   PUT_CODE (reg, MEM);\n+  PUT_MODE (reg, decl_mode);\n \n   /* If this is a memory ref that contains aggregate components,\n      mark it as such for cse and loop optimize.  */\n@@ -884,32 +890,37 @@ put_var_into_stack (decl)\n       temp\n \t= (struct var_refs_queue *) oballoc (sizeof (struct var_refs_queue));\n       temp->modified = reg;\n+      temp->promoted_mode = promoted_mode;\n+      temp->unsignedp = TREE_UNSIGNED (TREE_TYPE (decl));\n       temp->next = function->fixup_var_refs_queue;\n       function->fixup_var_refs_queue = temp;\n       pop_obstacks ();\n     }\n   else\n     /* Variable is local; fix it up now.  */\n-    fixup_var_refs (reg);\n+    fixup_var_refs (reg, promoted_mode, TREE_UNSIGNED (TREE_TYPE (decl)));\n }\n \f\n static void\n-fixup_var_refs (var)\n+fixup_var_refs (var, promoted_mode, unsignedp)\n      rtx var;\n+     enum machine_mode promoted_mode;\n+     int unsignedp;\n {\n   tree pending;\n   rtx first_insn = get_insns ();\n   struct sequence_stack *stack = sequence_stack;\n   tree rtl_exps = rtl_expr_chain;\n \n   /* Must scan all insns for stack-refs that exceed the limit.  */\n-  fixup_var_refs_insns (var, first_insn, stack == 0);\n+  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn, stack == 0);\n \n   /* Scan all pending sequences too.  */\n   for (; stack; stack = stack->next)\n     {\n       push_to_sequence (stack->first);\n-      fixup_var_refs_insns (var, stack->first, stack->next != 0);\n+      fixup_var_refs_insns (var, promoted_mode, unsignedp,\n+\t\t\t    stack->first, stack->next != 0);\n       /* Update remembered end of sequence\n \t in case we added an insn at the end.  */\n       stack->last = get_last_insn ();\n@@ -923,7 +934,7 @@ fixup_var_refs (var)\n       if (seq != const0_rtx && seq != 0)\n \t{\n \t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (var, seq, 0);\n+\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0);\n \t  end_sequence ();\n \t}\n     }\n@@ -974,8 +985,10 @@ find_replacement (replacements, x)\n    main chain of insns for the current function.  */\n \n static void\n-fixup_var_refs_insns (var, insn, toplevel)\n+fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n      rtx var;\n+     enum machine_mode promoted_mode;\n+     int unsignedp;\n      rtx insn;\n      int toplevel;\n {\n@@ -1012,13 +1025,15 @@ fixup_var_refs_insns (var, insn, toplevel)\n \n \t      struct fixup_replacement *replacements = 0;\n \n-\t      fixup_var_refs_1 (var, &PATTERN (insn), insn, &replacements);\n+\t      fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n+\t\t\t\t&replacements);\n \n \t      while (replacements)\n \t\t{\n \t\t  if (GET_CODE (replacements->new) == REG)\n \t\t    {\n \t\t      rtx insert_before;\n+\t\t      rtx seq;\n \n \t\t      /* OLD might be a (subreg (mem)).  */\n \t\t      if (GET_CODE (replacements->old) == SUBREG)\n@@ -1042,9 +1057,24 @@ fixup_var_refs_insns (var, insn, toplevel)\n \t\t      else\n \t\t\tinsert_before = insn;\n \n-\t\t      emit_insn_before (gen_move_insn (replacements->new,\n-\t\t\t\t\t\t       replacements->old),\n-\t\t\t\t\tinsert_before);\n+\t\t      /* If we are changing the mode, do a conversion.\n+\t\t\t This might be wasteful, but combine.c will\n+\t\t\t eliminate much of the waste.  */\n+\n+\t\t      if (GET_MODE (replacements->new)\n+\t\t\t  != GET_MODE (replacements->old))\n+\t\t\t{\n+\t\t\t  start_sequence ();\n+\t\t\t  convert_move (replacements->new,\n+\t\t\t\t\treplacements->old, unsignedp);\n+\t\t\t  seq = gen_sequence ();\n+\t\t\t  end_sequence ();\n+\t\t\t}\n+\t\t      else\n+\t\t\tseq = gen_move_insn (replacements->new,\n+\t\t\t\t\t     replacements->old);\n+\n+\t\t      emit_insn_before (seq, insert_before);\n \t\t    }\n \n \t\t  replacements = replacements->next;\n@@ -1062,8 +1092,8 @@ fixup_var_refs_insns (var, insn, toplevel)\n     }\n }\n \f\n-/* VAR is a MEM that used to be a pseudo register.  See if the rtx expression\n-   at *LOC in INSN needs to be changed.\n+/* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.\n+   See if the rtx expression at *LOC in INSN needs to be changed.  \n \n    REPLACEMENTS is a pointer to a list head that starts out zero, but may\n    contain a list of original rtx's and replacements. If we find that we need\n@@ -1074,8 +1104,9 @@ fixup_var_refs_insns (var, insn, toplevel)\n    or the SUBREG, as appropriate, to the pseudo.  */\n \n static void\n-fixup_var_refs_1 (var, loc, insn, replacements)\n+fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n      register rtx var;\n+     enum machine_mode promoted_mode;\n      register rtx *loc;\n      rtx insn;\n      struct fixup_replacement **replacements;\n@@ -1104,14 +1135,15 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \n \t  *loc = replacement->new = x = fixup_stack_1 (x, insn);\n \n-\t  /* Unless we are forcing memory to register, we can leave things\n-\t     the way they are if the insn is valid.  */\n+\t  /* Unless we are forcing memory to register or we changed the mode,\n+\t     we can leave things the way they are if the insn is valid.  */\n \t     \n \t  INSN_CODE (insn) = -1;\n-\t  if (! flag_force_mem && recog_memoized (insn) >= 0)\n+\t  if (! flag_force_mem && GET_MODE (x) == promoted_mode\n+\t      && recog_memoized (insn) >= 0)\n \t    return;\n \n-\t  *loc = replacement->new = gen_reg_rtx (GET_MODE (x));\n+\t  *loc = replacement->new = gen_reg_rtx (promoted_mode);\n \t  return;\n \t}\n \n@@ -1230,6 +1262,18 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n     case SUBREG:\n       if (SUBREG_REG (x) == var)\n \t{\n+\t  /* If this is a special SUBREG made because VAR was promoted\n+\t     from a wider mode, replace it with VAR and call ourself\n+\t     recursively, this time saying that the object previously\n+\t     had its current mode (by virtue of the SUBREG).  */\n+\n+\t  if (SUBREG_PROMOTED_VAR_P (x))\n+\t    {\n+\t      *loc = var;\n+\t      fixup_var_refs_1 (var, GET_MODE (var), loc, insn, replacements);\n+\t      return;\n+\t    }\n+\n \t  /* If this SUBREG makes VAR wider, it has become a paradoxical\n \t     SUBREG with VAR in memory, but these aren't allowed at this \n \t     stage of the compilation.  So load VAR into a pseudo and take\n@@ -1314,9 +1358,12 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \t  {\n \t    /* Since this case will return, ensure we fixup all the\n \t       operands here.  */\n-\t    fixup_var_refs_1 (var, &XEXP (outerdest, 1), insn, replacements);\n-\t    fixup_var_refs_1 (var, &XEXP (outerdest, 2), insn, replacements);\n-\t    fixup_var_refs_1 (var, &SET_SRC (x), insn, replacements);\n+\t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 1),\n+\t\t\t      insn, replacements);\n+\t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 2),\n+\t\t\t      insn, replacements);\n+\t    fixup_var_refs_1 (var, promoted_mode, &SET_SRC (x),\n+\t\t\t      insn, replacements);\n \n \t    tem = XEXP (outerdest, 0);\n \n@@ -1439,24 +1486,37 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \n \t/* Otherwise, storing into VAR must be handled specially\n \t   by storing into a temporary and copying that into VAR\n-\t   with a new insn after this one.  */\n+\t   with a new insn after this one.  Note that this case\n+\t   will be used when storing into a promoted scalar since\n+\t   the insn will now have different modes on the input\n+\t   and output and hence will be invalid (except for the case\n+\t   of setting it to a constant, which does not need any\n+\t   change if it is valid).  We generate extra code in that case,\n+\t   but combine.c will eliminate it.  */\n \n \tif (dest == var)\n \t  {\n \t    rtx temp;\n-\t    rtx fixeddest;\n-\t    tem = SET_DEST (x);\n+\t    rtx fixeddest = SET_DEST (x);\n+\n \t    /* STRICT_LOW_PART can be discarded, around a MEM.  */\n-\t    if (GET_CODE (tem) == STRICT_LOW_PART)\n-\t      tem = XEXP (tem, 0);\n+\t    if (GET_CODE (fixeddest) == STRICT_LOW_PART)\n+\t      fixeddest = XEXP (fixeddest, 0);\n \t    /* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */\n-\t    if (GET_CODE (tem) == SUBREG)\n-\t      fixeddest = fixup_memory_subreg (tem, insn, 0);\n+\t    if (GET_CODE (fixeddest) == SUBREG)\n+\t      fixeddest = fixup_memory_subreg (fixeddest, insn, 0);\n \t    else\n-\t      fixeddest = fixup_stack_1 (tem, insn);\n+\t      fixeddest = fixup_stack_1 (fixeddest, insn);\n+\n+\t    temp = gen_reg_rtx (GET_MODE (SET_SRC (x)) == VOIDmode\n+\t\t\t\t? GET_MODE (fixeddest)\n+\t\t\t\t: GET_MODE (SET_SRC (x)));\n+\n+\t    emit_insn_after (gen_move_insn (fixeddest,\n+\t\t\t\t\t    gen_lowpart (GET_MODE (fixeddest),\n+\t\t\t\t\t\t\t temp)),\n+\t\t\t     insn);\n \n-\t    temp = gen_reg_rtx (GET_MODE (tem));\n-\t    emit_insn_after (gen_move_insn (fixeddest, temp), insn);\n \t    SET_DEST (x) = temp;\n \t  }\n       }\n@@ -1468,12 +1528,13 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tfixup_var_refs_1 (var, &XEXP (x, i), insn, replacements);\n+\tfixup_var_refs_1 (var, promoted_mode, &XEXP (x, i), insn, replacements);\n       if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    fixup_var_refs_1 (var, &XVECEXP (x, i, j), insn, replacements);\n+\t    fixup_var_refs_1 (var, promoted_mode, &XVECEXP (x, i, j),\n+\t\t\t      insn, replacements);\n \t}\n     }\n }\n@@ -2493,6 +2554,7 @@ assign_parms (fndecl, second_time)\n   register rtx stack_parm = 0;\n   CUMULATIVE_ARGS args_so_far;\n   enum machine_mode passed_mode, nominal_mode;\n+  int unsignedp;\n   /* Total space needed so far for args on the stack,\n      given as a constant and a tree-expression.  */\n   struct args_size stack_args_size;\n@@ -2889,9 +2951,24 @@ assign_parms (fndecl, second_time)\n \t\t  by invisible reference.  */\n \t       || passed_pointer || parm == function_result_decl)\n \t{\n-\t  /* Store the parm in a pseudoregister during the function.  */\n-\t  register rtx parmreg = gen_reg_rtx (nominal_mode);\n+\t  /* Store the parm in a pseudoregister during the function, but we\n+\t     may need to do it in a wider mode.  */\n+\n+\t  register rtx parmreg;\n+\n+\t  unsignedp = TREE_UNSIGNED (TREE_TYPE (parm));\n+\t  if (TREE_CODE (TREE_TYPE (parm)) == INTEGER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == ENUMERAL_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == BOOLEAN_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == CHAR_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (parm)) == OFFSET_TYPE)\n+\t    {\n+\t      PROMOTE_MODE (nominal_mode, unsignedp, TREE_TYPE (parm));\n+\t    }\n \n+\t  parmreg = gen_reg_rtx (nominal_mode);\n \t  REG_USERVAR_P (parmreg) = 1;\n \n \t  /* If this was an item that we received a pointer to, set DECL_RTL\n@@ -2917,9 +2994,9 @@ assign_parms (fndecl, second_time)\n \t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n \t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm),\n \t\t\t\t\t   GET_MODE (entry_parm)))\n-\t\tconvert_move (parmreg, copy_to_reg (entry_parm), 0);\n+\t\tconvert_move (parmreg, copy_to_reg (entry_parm), unsignedp);\n \t      else\n-\t\tconvert_move (parmreg, validize_mem (entry_parm), 0);\n+\t\tconvert_move (parmreg, validize_mem (entry_parm), unsignedp);\n \t    }\n \t  else\n \t    emit_move_insn (parmreg, validize_mem (entry_parm));"}]}