{"sha": "2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ1NmQ2YmE5YzJlYmNlYjg4NjVhNjVjMGZkMjY1Nzc3M2FiZjc2Yg==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-12-07T16:48:39Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-12-07T16:48:39Z"}, "message": "[AArch64][1/2] Implement TARGET_ESTIMATED_POLY_VALUE\n\nThe hook TARGET_ESTIMATED_POLY_VALUE allows a target to give an estimate for a poly_int run-time value.\nIt is used exclusively in tuning decisions, things like estimated loop iterations, probabilities etc.\nIt is not relied on for correctness.\n\nIf we know the SVE width implemented in hardware we can make more more\ninformed decisions in the implementation of TARGET_ESTIMATED_POLY_VALUE,\neven when compiling for VLA vectorisation.\n\nThis patch adds an sve_width field to our tuning structs and sets it for\nthe current CPU tunings.\n\nA new value is introduced to the aarch64_sve_vector_bits_enum enum that indicates\nthat SVE is not available: SVE_NOT_IMPLEMENTED. I set it to the same value as SVE_SCALABLE\nso that parts of the aarch64 backend that follow the pattern:\nif (vector_width == SVE_SCALABLE)\n  do_vla_friendly_action ()\nelse\n  assume_specific_width_for_correctness ()\n\ncontinue to work without change, but the CPU tuning structs can use a more\nappropriate moniker for indicating the absence of SVE.\n\nThis sets sve_width to SVE_NOT_IMPLEMENTED for all cores.\nI aim to add an -moverride switch in the next patch that allows a power user to experiment\nwith different values of it for investigations.\n\n\t* config/aarch64/aarch64-opts.h (aarch64_sve_vector_bits_enum):\n\tAdd SVE_NOT_IMPLEMENTED value.\n\t* config/aarch64/aarch64-protos.h (struct tune_params): Add sve_width\n\tfield.\n\t* config/aarch64/aarch64.c (generic_tunings,cortexa35_tunings,\n\tcortexa53_tunings, cortexa57_tunings, cortexa72_tunings,\n\tcortexa73_tunings, exynosm1_tunings, thunderx_tunings,\n\tthunderx_tunings, tsv110_tunings, xgene1_tunings, qdf24xx_tunings,\n\tsaphira_tunings, thunderx2t99_tunings, emag_tunings):\n\tSpecify sve_width.\n\t(aarch64_estimated_poly_value): Define.\n\t(TARGET_ESTIMATED_POLY_VALUE): Define.\n\nFrom-SVN: r266896", "tree": {"sha": "d9b45d8c597fa71df69c1c938ab7c80af938eaec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9b45d8c597fa71df69c1c938ab7c80af938eaec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11f1ae2aae248c8c67dcde52e2b958108352267a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f1ae2aae248c8c67dcde52e2b958108352267a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f1ae2aae248c8c67dcde52e2b958108352267a"}], "stats": {"total": 57, "additions": 57, "deletions": 0}, "files": [{"sha": "3f83c29dc36b9c472876dfcddd8e6986a16c8b91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "patch": "@@ -1,3 +1,18 @@\n+2018-12-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64-opts.h (aarch64_sve_vector_bits_enum):\n+\tAdd SVE_NOT_IMPLEMENTED value.\n+\t* config/aarch64/aarch64-protos.h (struct tune_params): Add sve_width\n+\tfield.\n+\t* config/aarch64/aarch64.c (generic_tunings,cortexa35_tunings,\n+\tcortexa53_tunings, cortexa57_tunings, cortexa72_tunings,\n+\tcortexa73_tunings, exynosm1_tunings, thunderx_tunings,\n+\tthunderx_tunings, tsv110_tunings, xgene1_tunings, qdf24xx_tunings,\n+\tsaphira_tunings, thunderx2t99_tunings, emag_tunings):\n+\tSpecify sve_width.\n+\t(aarch64_estimated_poly_value): Define.\n+\t(TARGET_ESTIMATED_POLY_VALUE): Define.\n+\n 2018-12-07  Paul A. Clarke  <pc@us.ibm.com>\n \n \tPR target/88408"}, {"sha": "1ac056b66dad21c51b740af82e77270074e87962", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "patch": "@@ -84,6 +84,7 @@ enum aarch64_function_type {\n /* SVE vector register sizes.  */\n enum aarch64_sve_vector_bits_enum {\n   SVE_SCALABLE,\n+  SVE_NOT_IMPLEMENTED = SVE_SCALABLE,\n   SVE_128 = 128,\n   SVE_256 = 256,\n   SVE_512 = 512,"}, {"sha": "4ed886bd20049df10906a660c85c2fd9686e24d7", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "patch": "@@ -252,6 +252,10 @@ struct tune_params\n   const struct cpu_vector_cost *vec_costs;\n   const struct cpu_branch_cost *branch_costs;\n   const struct cpu_approx_modes *approx_modes;\n+  /* Width of the SVE registers or SVE_NOT_IMPLEMENTED if not applicable.\n+     Only used for tuning decisions, does not disable VLA\n+     vectorization.  */\n+  enum aarch64_sve_vector_bits_enum sve_width;\n   int memmov_cost;\n   int issue_rate;\n   unsigned int fusible_ops;"}, {"sha": "ba9b5ad4efedf87c4ec247683e0435f14a7ef146", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d56d6ba9c2ebceb8865a65c0fd2657773abf76b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2d56d6ba9c2ebceb8865a65c0fd2657773abf76b", "patch": "@@ -681,6 +681,7 @@ static const struct tune_params generic_tunings =\n   &generic_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   2, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC), /* fusible_ops  */\n@@ -706,6 +707,7 @@ static const struct tune_params cortexa35_tunings =\n   &generic_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   1, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -732,6 +734,7 @@ static const struct tune_params cortexa53_tunings =\n   &generic_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   2, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -758,6 +761,7 @@ static const struct tune_params cortexa57_tunings =\n   &cortexa57_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -784,6 +788,7 @@ static const struct tune_params cortexa72_tunings =\n   &cortexa57_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   3, /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -810,6 +815,7 @@ static const struct tune_params cortexa73_tunings =\n   &cortexa57_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost.  */\n   2, /* issue_rate.  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -838,6 +844,7 @@ static const struct tune_params exynosm1_tunings =\n   &exynosm1_vector_cost,\n   &generic_branch_cost,\n   &exynosm1_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4,\t/* memmov_cost  */\n   3,\t/* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC), /* fusible_ops  */\n@@ -863,6 +870,7 @@ static const struct tune_params thunderxt88_tunings =\n   &thunderx_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   6, /* memmov_cost  */\n   2, /* issue_rate  */\n   AARCH64_FUSE_CMP_BRANCH, /* fusible_ops  */\n@@ -888,6 +896,7 @@ static const struct tune_params thunderx_tunings =\n   &thunderx_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   6, /* memmov_cost  */\n   2, /* issue_rate  */\n   AARCH64_FUSE_CMP_BRANCH, /* fusible_ops  */\n@@ -914,6 +923,7 @@ static const struct tune_params tsv110_tunings =\n   &tsv110_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4,    /* memmov_cost  */\n   4,    /* issue_rate  */\n   (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH\n@@ -940,6 +950,7 @@ static const struct tune_params xgene1_tunings =\n   &xgene1_vector_cost,\n   &generic_branch_cost,\n   &xgene1_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   6, /* memmov_cost  */\n   4, /* issue_rate  */\n   AARCH64_FUSE_NOTHING, /* fusible_ops  */\n@@ -965,6 +976,7 @@ static const struct tune_params emag_tunings =\n   &xgene1_vector_cost,\n   &generic_branch_cost,\n   &xgene1_approx_modes,\n+  SVE_NOT_IMPLEMENTED,\n   6, /* memmov_cost  */\n   4, /* issue_rate  */\n   AARCH64_FUSE_NOTHING, /* fusible_ops  */\n@@ -990,6 +1002,7 @@ static const struct tune_params qdf24xx_tunings =\n   &qdf24xx_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   4, /* issue_rate  */\n   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -1018,6 +1031,7 @@ static const struct tune_params saphira_tunings =\n   &generic_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost  */\n   4, /* issue_rate  */\n   (AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_ADRP_ADD\n@@ -1044,6 +1058,7 @@ static const struct tune_params thunderx2t99_tunings =\n   &thunderx2t99_vector_cost,\n   &generic_branch_cost,\n   &generic_approx_modes,\n+  SVE_NOT_IMPLEMENTED, /* sve_width  */\n   4, /* memmov_cost.  */\n   4, /* issue_rate.  */\n   (AARCH64_FUSE_CMP_BRANCH | AARCH64_FUSE_AES_AESMC\n@@ -17869,6 +17884,25 @@ aarch64_speculation_safe_value (machine_mode mode,\n   return result;\n }\n \n+/* Implement TARGET_ESTIMATED_POLY_VALUE.\n+   Look into the tuning structure for an estimate.\n+   VAL.coeffs[1] is multiplied by the number of VQ chunks over the initial\n+   Advanced SIMD 128 bits.  */\n+\n+static HOST_WIDE_INT\n+aarch64_estimated_poly_value (poly_int64 val)\n+{\n+  enum aarch64_sve_vector_bits_enum width_source\n+    = aarch64_tune_params.sve_width;\n+\n+  /* If we still don't have an estimate, use the default.  */\n+  if (width_source == SVE_SCALABLE)\n+    return default_estimated_poly_value (val);\n+\n+  HOST_WIDE_INT over_128 = width_source - 128;\n+  return val.coeffs[0] + val.coeffs[1] * over_128 / 128;\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P\n@@ -18348,6 +18382,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_SPECULATION_SAFE_VALUE\n #define TARGET_SPECULATION_SAFE_VALUE aarch64_speculation_safe_value\n \n+#undef TARGET_ESTIMATED_POLY_VALUE\n+#define TARGET_ESTIMATED_POLY_VALUE aarch64_estimated_poly_value\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}]}