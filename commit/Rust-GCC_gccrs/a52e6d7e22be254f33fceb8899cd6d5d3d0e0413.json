{"sha": "a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUyZTZkN2UyMmJlMjU0ZjMzZmNlYjg4OTljZDZkNWQzZDBlMDQxMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:26:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:26:54Z"}, "message": "[multiple changes]\n\n2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): An expression\n\tfunction declaration is not a subprogram declaration, and thus\n\tcannot appear in a protected definition.\n\n2013-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Insert_Actions): When new\n\tactions come from the expression of the expression with actions,\n\tthen they must be added to the list of existing actions.\n\n2013-01-29  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Subtype_Declaration) <Private_Kind>: For\n\tthe subtype of a constrained private type with discriminants\n\tthat has got a full view, show that the completion is a clone\n\tof the full view.\n\nFrom-SVN: r195543", "tree": {"sha": "5465d9757a399b697c772b89c8d4f1e89fe464a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5465d9757a399b697c772b89c8d4f1e89fe464a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/comments", "author": null, "committer": null, "parents": [{"sha": "78d087bc6ccc74c3ca8d1483d660fad535cad358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d087bc6ccc74c3ca8d1483d660fad535cad358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d087bc6ccc74c3ca8d1483d660fad535cad358"}], "stats": {"total": 88, "additions": 67, "deletions": 21}, "files": [{"sha": "076ae03f8336bf4bd1ec12eb7acb9e3f18afc164", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "patch": "@@ -1,3 +1,22 @@\n+2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): An expression\n+\tfunction declaration is not a subprogram declaration, and thus\n+\tcannot appear in a protected definition.\n+\n+2013-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Insert_Actions): When new\n+\tactions come from the expression of the expression with actions,\n+\tthen they must be added to the list of existing actions.\n+\n+2013-01-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration) <Private_Kind>: For\n+\tthe subtype of a constrained private type with discriminants\n+\tthat has got a full view, show that the completion is a clone\n+\tof the full view.\n+\n 2013-01-29  Javier Miranda  <miranda@adacore.com>\n \n \t* errout.ads, errout.adb (Get_Ignore_Errors): New subprogram."}, {"sha": "4e04ae859aa4914962eb5860df281a18194abcee", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3141,25 +3141,27 @@ package body Exp_Util is\n \n       --  N_Raise_xxx_Error is an annoying special case, it is a statement if\n       --  it has type Standard_Void_Type, and a subexpression otherwise.\n-      --  otherwise. Procedure attribute references are also statements.\n+      --  otherwise. Procedure calls, and similarly procedure attribute\n+      --  references, are also statements.\n \n       if Nkind (Assoc_Node) in N_Subexpr\n-        and then (Nkind (Assoc_Node) in N_Raise_xxx_Error\n+        and then (Nkind (Assoc_Node) not in N_Raise_xxx_Error\n                    or else Etype (Assoc_Node) /= Standard_Void_Type)\n+        and then Nkind (Assoc_Node) /= N_Procedure_Call_Statement\n         and then (Nkind (Assoc_Node) /= N_Attribute_Reference\n                    or else\n                      not Is_Procedure_Attribute_Name\n                            (Attribute_Name (Assoc_Node)))\n       then\n-         P := Assoc_Node;             -- ??? does not agree with above!\n-         N := Parent (Assoc_Node);\n+         N := Assoc_Node;\n+         P := Parent (Assoc_Node);\n \n       --  Non-subexpression case. Note that N is initially Empty in this case\n       --  (N is only guaranteed Non-Empty in the subexpr case).\n \n       else\n-         P := Assoc_Node;\n          N := Empty;\n+         P := Assoc_Node;\n       end if;\n \n       --  Capture root of the transient scope\n@@ -3171,6 +3173,13 @@ package body Exp_Util is\n       loop\n          pragma Assert (Present (P));\n \n+         --  Make sure that inserted actions stay in the transient scope\n+\n+         if Present (Wrapped_Node) and then N = Wrapped_Node then\n+            Store_Before_Actions_In_Scope (Ins_Actions);\n+            return;\n+         end if;\n+\n          case Nkind (P) is\n \n             --  Case of right operand of AND THEN or OR ELSE. Put the actions\n@@ -3282,14 +3291,17 @@ package body Exp_Util is\n \n                return;\n \n-            --  Case of appearing within an Expressions_With_Actions node. We\n-            --  append the actions to the list of actions already there, if\n-            --  the node has not been analyzed yet. Otherwise find insertion\n-            --  location further up the tree.\n+            --  Case of appearing within an Expressions_With_Actions node. When\n+            --  the new actions come from the expression of the expression with\n+            --  actions, they must be added to the existing actions. The other\n+            --  alternative is when the new actions are related to one of the\n+            --  existing actions of the expression with actions. In that case\n+            --  they must be inserted further up the tree.\n \n             when N_Expression_With_Actions =>\n-               if not Analyzed (P) then\n-                  Append_List (Ins_Actions, Actions (P));\n+               if N = Expression (P) then\n+                  Insert_List_After_And_Analyze\n+                    (Last (Actions (P)), Ins_Actions);\n                   return;\n                end if;\n \n@@ -3697,13 +3709,6 @@ package body Exp_Util is\n \n          end case;\n \n-         --  Make sure that inserted actions stay in the transient scope\n-\n-         if P = Wrapped_Node then\n-            Store_Before_Actions_In_Scope (Ins_Actions);\n-            return;\n-         end if;\n-\n          --  If we fall through above tests, keep climbing tree\n \n          N := P;"}, {"sha": "f5e0bec769f707e0615de619fa3a75f8adbfd338", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "patch": "@@ -4282,14 +4282,27 @@ package body Sem_Ch3 is\n                   Set_Stored_Constraint_From_Discriminant_Constraint (Id);\n \n                   --  This would seem semantically correct, but apparently\n-                  --  confuses the back-end. To be explained and checked with\n-                  --  current version ???\n+                  --  generates spurious errors about missing components ???\n \n                   --  Set_Has_Discriminants (Id);\n                end if;\n \n                Prepare_Private_Subtype_Completion (Id, N);\n \n+               --  If this is the subtype of a constrained private type with\n+               --  discriminants that has got a full view and we also have\n+               --  built a completion just above, show that the completion\n+               --  is a clone of the full view to the back-end.\n+\n+               if Has_Discriminants (T)\n+                  and then not Has_Unknown_Discriminants (T)\n+                  and then not Is_Empty_Elmt_List (Discriminant_Constraint (T))\n+                  and then Present (Full_View (T))\n+                  and then Present (Full_View (Id))\n+               then\n+                  Set_Cloned_Subtype (Full_View (Id), Full_View (T));\n+               end if;\n+\n             when Access_Kind =>\n                Set_Ekind             (Id, E_Access_Subtype);\n                Set_Is_Constrained    (Id, Is_Constrained        (T));"}, {"sha": "68eeea347d086e6cf991467e52158b4f5930941d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a52e6d7e22be254f33fceb8899cd6d5d3d0e0413/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a52e6d7e22be254f33fceb8899cd6d5d3d0e0413", "patch": "@@ -408,6 +408,15 @@ package body Sem_Ch6 is\n       --  that the expression can be inlined whenever possible.\n \n       else\n+         --  An expression function that is not a completion is not a\n+         --  subprogram declaration, and thus cannot appear in a protected\n+         --  definition.\n+\n+         if Nkind (Parent (N)) = N_Protected_Definition then\n+            Error_Msg_N\n+              (\"an expression function is not a legal protected operation\", N);\n+         end if;\n+\n          New_Decl :=\n            Make_Subprogram_Declaration (Loc, Specification => Spec);\n "}]}