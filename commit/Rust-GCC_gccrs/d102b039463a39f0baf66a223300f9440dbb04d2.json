{"sha": "d102b039463a39f0baf66a223300f9440dbb04d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwMmIwMzk0NjNhMzlmMGJhZjY2YTIyMzMwMGY5NDQwZGJiMDRkMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2019-10-10T18:54:50Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2019-10-10T18:54:50Z"}, "message": "Add check for prefixed addresses.\n\n2019-10-10  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (quad_address_p): Add check for prefixed\n\taddresses.\n\t(mem_operand_gpr): Add check for prefixed addresses.\n\t(mem_operand_ds_form): Add check for prefixed addresses.\n\t(rs6000_legitimate_offset_address_p): If we support prefixed\n\taddresses, check for a 34-bit offset instead of 16-bit.\n\t(rs6000_legitimate_address_p): Add check for prefixed addresses.\n\tDo not allow load/store with update if the address is prefixed.\n\t(rs6000_mode_dependent_address):  If we support prefixed\n\taddresses, check for a 34-bit offset instead of 16-bit.\n\nFrom-SVN: r276846", "tree": {"sha": "9695bca7d954d42ee9023176a6c39d0a8319715a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9695bca7d954d42ee9023176a6c39d0a8319715a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d102b039463a39f0baf66a223300f9440dbb04d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d102b039463a39f0baf66a223300f9440dbb04d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d102b039463a39f0baf66a223300f9440dbb04d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d102b039463a39f0baf66a223300f9440dbb04d2/comments", "author": null, "committer": null, "parents": [{"sha": "b4c7ca2ef3915a0b2292499dabcaabefdca04d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c7ca2ef3915a0b2292499dabcaabefdca04d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c7ca2ef3915a0b2292499dabcaabefdca04d89"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "fea008537025bf463e37a1f9355ddcf6a74e109a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d102b039463a39f0baf66a223300f9440dbb04d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d102b039463a39f0baf66a223300f9440dbb04d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d102b039463a39f0baf66a223300f9440dbb04d2", "patch": "@@ -1,3 +1,16 @@\n+2019-10-10  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (quad_address_p): Add check for prefixed\n+\taddresses.\n+\t(mem_operand_gpr): Add check for prefixed addresses.\n+\t(mem_operand_ds_form): Add check for prefixed addresses.\n+\t(rs6000_legitimate_offset_address_p): If we support prefixed\n+\taddresses, check for a 34-bit offset instead of 16-bit.\n+\t(rs6000_legitimate_address_p): Add check for prefixed addresses.\n+\tDo not allow load/store with update if the address is prefixed.\n+\t(rs6000_mode_dependent_address):  If we support prefixed\n+\taddresses, check for a 34-bit offset instead of 16-bit.\n+\n 2019-10-10  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/77918"}, {"sha": "3421faf813f357d69d467fd8c8debc957b15cfb8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d102b039463a39f0baf66a223300f9440dbb04d2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d102b039463a39f0baf66a223300f9440dbb04d2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d102b039463a39f0baf66a223300f9440dbb04d2", "patch": "@@ -7250,6 +7250,13 @@ quad_address_p (rtx addr, machine_mode mode, bool strict)\n   if (VECTOR_MODE_P (mode) && !mode_supports_dq_form (mode))\n     return false;\n \n+  /* Is this a valid prefixed address?  If the bottom four bits of the offset\n+     are non-zero, we could use a prefixed instruction (which does not have the\n+     DQ-form constraint that the traditional instruction had) instead of\n+     forcing the unaligned offset to a GPR.  */\n+  if (address_is_prefixed (addr, mode, NON_PREFIXED_DQ))\n+    return true;\n+\n   if (GET_CODE (addr) != PLUS)\n     return false;\n \n@@ -7351,6 +7358,13 @@ mem_operand_gpr (rtx op, machine_mode mode)\n       && legitimate_indirect_address_p (XEXP (addr, 0), false))\n     return true;\n \n+  /* Allow prefixed instructions if supported.  If the bottom two bits of the\n+     offset are non-zero, we could use a prefixed instruction (which does not\n+     have the DS-form constraint that the traditional instruction had) instead\n+     of forcing the unaligned offset to a GPR.  */\n+  if (address_is_prefixed (addr, mode, NON_PREFIXED_DS))\n+    return true;\n+\n   /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */\n   if (!rs6000_offsettable_memref_p (op, mode, false))\n     return false;\n@@ -7385,6 +7399,13 @@ mem_operand_ds_form (rtx op, machine_mode mode)\n   int extra;\n   rtx addr = XEXP (op, 0);\n \n+  /* Allow prefixed instructions if supported.  If the bottom two bits of the\n+     offset are non-zero, we could use a prefixed instruction (which does not\n+     have the DS-form constraint that the traditional instruction had) instead\n+     of forcing the unaligned offset to a GPR.  */\n+  if (address_is_prefixed (addr, mode, NON_PREFIXED_DS))\n+    return true;\n+\n   if (!offsettable_address_p (false, mode, addr))\n     return false;\n \n@@ -7754,7 +7775,10 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n       break;\n     }\n \n-  return SIGNED_16BIT_OFFSET_EXTRA_P (offset, extra);\n+  if (TARGET_PREFIXED_ADDR)\n+    return SIGNED_34BIT_OFFSET_EXTRA_P (offset, extra);\n+  else\n+    return SIGNED_16BIT_OFFSET_EXTRA_P (offset, extra);\n }\n \n bool\n@@ -8651,6 +8675,11 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n       && mode_supports_pre_incdec_p (mode)\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n+\n+  /* Handle prefixed addresses (PC-relative or 34-bit offset).  */\n+  if (address_is_prefixed (x, mode, NON_PREFIXED_DEFAULT))\n+    return 1;\n+\n   /* Handle restricted vector d-form offsets in ISA 3.0.  */\n   if (quad_offset_p)\n     {\n@@ -8709,7 +8738,11 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n \t  || (!avoiding_indexed_address_p (mode)\n \t      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)))\n       && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n-    return 1;\n+    {\n+      /* There is no prefixed version of the load/store with update.  */\n+      rtx addr = XEXP (x, 1);\n+      return !address_is_prefixed (addr, mode, NON_PREFIXED_DEFAULT);\n+    }\n   if (reg_offset_p && !quad_offset_p\n       && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n     return 1;\n@@ -8773,7 +8806,10 @@ rs6000_mode_dependent_address (const_rtx addr)\n \t{\n \t  HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));\n \t  HOST_WIDE_INT extra = TARGET_POWERPC64 ? 8 : 12;\n-\t  return !SIGNED_16BIT_OFFSET_EXTRA_P (val, extra);\n+\t  if (TARGET_PREFIXED_ADDR)\n+\t    return !SIGNED_34BIT_OFFSET_EXTRA_P (val, extra);\n+\t  else\n+\t    return !SIGNED_16BIT_OFFSET_EXTRA_P (val, extra);\n \t}\n       break;\n "}]}