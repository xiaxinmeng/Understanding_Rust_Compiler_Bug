{"sha": "30c4440c6ad1034e6e69fa7370659aaa9bb19912", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjNDQ0MGM2YWQxMDM0ZTZlNjlmYTczNzA2NTlhYWE5YmIxOTkxMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-18T13:34:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-18T13:34:00Z"}, "message": "2017-10-18  Richard Biener  <rguenther@suse.de>\n\n\t* graphite-isl-ast-to-gimple.c\n\t(translate_isl_ast_to_gimple::set_rename): Simplify.\n\t(translate_isl_ast_to_gimple::set_rename_for_each_def): Inline...\n\t(graphite_copy_stmts_from_block): ... here.\n\t(copy_bb_and_scalar_dependences): Simplify.\n\t(add_parameters_to_ivs_params): Canonicalize.\n\t(generate_entry_out_of_ssa_copies): Simplify.\n\t* graphite-sese-to-poly.c (extract_affine_name): Simplify\n\tby passing in ISL dimension.\n\t(parameter_index_in_region_1): Rename to ...\n\t(parameter_index_in_region): ... this.\n\t(extract_affine): Adjust assert, pass down parameter index.\n\t(add_param_constraints): Use range-info when available.\n\t(build_scop_context): Adjust.\n\t* sese.c (new_sese_info): Adjust.\n\t(free_sese_info): Likewise.\n\t* sese.h (bb_map_t, rename_map_t, phi_rename, init_back_edge_pair_t):\n\tRemove unused typedefs.\n\t(struct sese_info_t): Simplify rename_map, remove incomplete_phis.\n\nFrom-SVN: r253855", "tree": {"sha": "92f4127791c24ae4aaf493ce9c9b0ccf92a73dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92f4127791c24ae4aaf493ce9c9b0ccf92a73dcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c4440c6ad1034e6e69fa7370659aaa9bb19912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c4440c6ad1034e6e69fa7370659aaa9bb19912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c4440c6ad1034e6e69fa7370659aaa9bb19912", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c4440c6ad1034e6e69fa7370659aaa9bb19912/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28e2e23607381f057e694c373025433d414e2750", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e2e23607381f057e694c373025433d414e2750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e2e23607381f057e694c373025433d414e2750"}], "stats": {"total": 214, "additions": 85, "deletions": 129}, "files": [{"sha": "dcfa96f553ac633682d7dc7fa1725a7ad3fa069a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30c4440c6ad1034e6e69fa7370659aaa9bb19912", "patch": "@@ -1,3 +1,25 @@\n+2017-10-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* graphite-isl-ast-to-gimple.c\n+\t(translate_isl_ast_to_gimple::set_rename): Simplify.\n+\t(translate_isl_ast_to_gimple::set_rename_for_each_def): Inline...\n+\t(graphite_copy_stmts_from_block): ... here.\n+\t(copy_bb_and_scalar_dependences): Simplify.\n+\t(add_parameters_to_ivs_params): Canonicalize.\n+\t(generate_entry_out_of_ssa_copies): Simplify.\n+\t* graphite-sese-to-poly.c (extract_affine_name): Simplify\n+\tby passing in ISL dimension.\n+\t(parameter_index_in_region_1): Rename to ...\n+\t(parameter_index_in_region): ... this.\n+\t(extract_affine): Adjust assert, pass down parameter index.\n+\t(add_param_constraints): Use range-info when available.\n+\t(build_scop_context): Adjust.\n+\t* sese.c (new_sese_info): Adjust.\n+\t(free_sese_info): Likewise.\n+\t* sese.h (bb_map_t, rename_map_t, phi_rename, init_back_edge_pair_t):\n+\tRemove unused typedefs.\n+\t(struct sese_info_t): Simplify rename_map, remove incomplete_phis.\n+\n 2017-10-18  Martin Liska  <mliska@suse.cz>\n \n \t* combine.c (simplify_compare_const): Add gcc_fallthrough."}, {"sha": "dc5d56130bf42ebfe75f49da3a2d3e6468435410", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 23, "deletions": 51, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=30c4440c6ad1034e6e69fa7370659aaa9bb19912", "patch": "@@ -195,7 +195,6 @@ class translate_isl_ast_to_gimple\n   edge copy_bb_and_scalar_dependences (basic_block bb, edge next_e,\n \t\t\t\t       vec<tree> iv_map);\n   void set_rename (tree old_name, tree expr);\n-  void set_rename_for_each_def (gimple *stmt);\n   void gsi_insert_earliest (gimple_seq seq);\n   bool codegen_error_p () const { return codegen_error; }\n \n@@ -932,25 +931,12 @@ set_rename (tree old_name, tree expr)\n     {\n       fprintf (dump_file, \"[codegen] setting rename: old_name = \");\n       print_generic_expr (dump_file, old_name);\n-      fprintf (dump_file, \", new_name = \");\n+      fprintf (dump_file, \", new decl = \");\n       print_generic_expr (dump_file, expr);\n       fprintf (dump_file, \"\\n\");\n     }\n-\n-  if (old_name == expr)\n-    return;\n-\n-  vec <tree> *renames = region->rename_map->get (old_name);\n-\n-  if (renames)\n-    renames->safe_push (expr);\n-  else\n-    {\n-      vec<tree> r;\n-      r.create (2);\n-      r.safe_push (expr);\n-      region->rename_map->put (old_name, r);\n-    }\n+  bool res = region->rename_map->put (old_name, expr);\n+  gcc_assert (! res);\n }\n \n /* Return an iterator to the instructions comes last in the execution order.\n@@ -1132,21 +1118,6 @@ should_copy_to_new_region (gimple *stmt, sese_info_p region)\n   return true;\n }\n \n-/* Create new names for all the definitions created by COPY and add replacement\n-   mappings for each new name.  */\n-\n-void translate_isl_ast_to_gimple::\n-set_rename_for_each_def (gimple *stmt)\n-{\n-  def_operand_p def_p;\n-  ssa_op_iter op_iter;\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n-    {\n-      tree old_name = DEF_FROM_PTR (def_p);\n-      create_new_def_for (old_name, stmt, def_p);\n-    }\n-}\n-\n /* Duplicates the statements of basic block BB into basic block NEW_BB\n    and compute the new induction variables according to the IV_MAP.  */\n \n@@ -1192,7 +1163,13 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n       gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n \n       /* Crete new names for each def in the copied stmt.  */\n-      set_rename_for_each_def (copy);\n+      def_operand_p def_p;\n+      ssa_op_iter op_iter;\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_ALL_DEFS)\n+\t{\n+\t  tree old_name = DEF_FROM_PTR (def_p);\n+\t  create_new_def_for (old_name, copy, def_p);\n+\t}\n \n       if (codegen_error_p ())\n \treturn false;\n@@ -1244,17 +1221,14 @@ copy_bb_and_scalar_dependences (basic_block bb, edge next_e, vec<tree> iv_map)\n \tcontinue;\n \n       tree new_phi_def;\n-      vec <tree> *renames = region->rename_map->get (res);\n-      if (! renames || renames->is_empty ())\n+      tree *rename = region->rename_map->get (res);\n+      if (! rename)\n \t{\n \t  new_phi_def = create_tmp_reg (TREE_TYPE (res));\n \t  set_rename (res, new_phi_def);\n \t}\n       else\n-\t{\n-\t  gcc_assert (renames->length () == 1);\n-\t  new_phi_def = (*renames)[0];\n-\t}\n+\tnew_phi_def = *rename;\n \n       gassign *ass = gimple_build_assign (NULL_TREE, new_phi_def);\n       create_new_def_for (res, ass, NULL);\n@@ -1291,17 +1265,14 @@ copy_bb_and_scalar_dependences (basic_block bb, edge next_e, vec<tree> iv_map)\n \t\tcontinue;\n \n \t      tree new_phi_def;\n-\t      vec <tree> *renames = region->rename_map->get (res);\n-\t      if (! renames || renames->is_empty ())\n+\t      tree *rename = region->rename_map->get (res);\n+\t      if (! rename)\n \t\t{\n \t\t  new_phi_def = create_tmp_reg (TREE_TYPE (res));\n \t\t  set_rename (res, new_phi_def);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  gcc_assert (renames->length () == 1);\n-\t\t  new_phi_def = (*renames)[0];\n-\t\t}\n+\t\tnew_phi_def = *rename;\n \n \t      tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t      if (TREE_CODE (arg) == SSA_NAME\n@@ -1336,13 +1307,14 @@ add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n {\n   sese_info_p region = scop->scop_info;\n   unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n-  gcc_assert (nb_parameters == region->params.length ());\n+  gcc_assert (nb_parameters == sese_nb_params (region));\n   unsigned i;\n-  for (i = 0; i < nb_parameters; i++)\n+  tree param;\n+  FOR_EACH_VEC_ELT (region->params, i, param)\n     {\n       isl_id *tmp_id = isl_set_get_dim_id (scop->param_context,\n \t\t\t\t\t   isl_dim_param, i);\n-      ip[tmp_id] = region->params[i];\n+      ip[tmp_id] = param;\n     }\n }\n \n@@ -1417,10 +1389,10 @@ generate_entry_out_of_ssa_copies (edge false_entry,\n \tcontinue;\n       /* When there's no out-of-SSA var registered do not bother\n          to create one.  */\n-      vec <tree> *renames = region->rename_map->get (res);\n-      if (! renames || renames->is_empty ())\n+      tree *rename = region->rename_map->get (res);\n+      if (! rename)\n \tcontinue;\n-      tree new_phi_def = (*renames)[0];\n+      tree new_phi_def = *rename;\n       gassign *ass = gimple_build_assign (new_phi_def,\n \t\t\t\t\t  PHI_ARG_DEF_FROM_EDGE (phi,\n \t\t\t\t\t\t\t\t false_entry));"}, {"sha": "248c34a41c95aa11c06e1eac0c1173327acbd455", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=30c4440c6ad1034e6e69fa7370659aaa9bb19912", "patch": "@@ -142,11 +142,8 @@ isl_id_for_dr (scop_p s)\n /* Extract an affine expression from the ssa_name E.  */\n \n static isl_pw_aff *\n-extract_affine_name (scop_p s, tree e, __isl_take isl_space *space)\n+extract_affine_name (int dimension, __isl_take isl_space *space)\n {\n-  isl_id *id = isl_id_for_ssa_name (s, e);\n-  int dimension = isl_space_find_dim_by_id (space, isl_dim_param, id);\n-  isl_id_free (id);\n   isl_set *dom = isl_set_universe (isl_space_copy (space));\n   isl_aff *aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n   aff = isl_aff_add_coefficient_si (aff, isl_dim_param, dimension, 1);\n@@ -211,17 +208,13 @@ wrap (isl_pw_aff *pwaff, unsigned width)\n    Otherwise returns -1.  */\n \n static inline int\n-parameter_index_in_region_1 (tree name, sese_info_p region)\n+parameter_index_in_region (tree name, sese_info_p region)\n {\n   int i;\n   tree p;\n-\n-  gcc_assert (TREE_CODE (name) == SSA_NAME);\n-\n   FOR_EACH_VEC_ELT (region->params, i, p)\n     if (p == name)\n       return i;\n-\n   return -1;\n }\n \n@@ -288,10 +281,13 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n       break;\n \n     case SSA_NAME:\n-      gcc_assert (-1 != parameter_index_in_region_1 (e, s->scop_info)\n-\t\t  || defined_in_sese_p (e, s->scop_info->region));\n-      res = extract_affine_name (s, e, space);\n-      break;\n+      {\n+\tgcc_assert (! defined_in_sese_p (e, s->scop_info->region));\n+\tint dim = parameter_index_in_region (e, s->scop_info);\n+\tgcc_assert (dim != -1);\n+\tres = extract_affine_name (dim, space);\n+\tbreak;\n+      }\n \n     case INTEGER_CST:\n       res = extract_affine_int (e, space);\n@@ -431,54 +427,40 @@ add_conditions_to_domain (poly_bb_p pbb)\n    of P.  */\n \n static void\n-add_param_constraints (scop_p scop, graphite_dim_t p)\n+add_param_constraints (scop_p scop, graphite_dim_t p, tree parameter)\n {\n-  tree parameter = scop->scop_info->params[p];\n   tree type = TREE_TYPE (parameter);\n-  tree lb = NULL_TREE;\n-  tree ub = NULL_TREE;\n+  wide_int min, max;\n \n-  if (POINTER_TYPE_P (type) || !TYPE_MIN_VALUE (type))\n-    lb = lower_bound_in_type (type, type);\n-  else\n-    lb = TYPE_MIN_VALUE (type);\n+  gcc_assert (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type));\n \n-  if (POINTER_TYPE_P (type) || !TYPE_MAX_VALUE (type))\n-    ub = upper_bound_in_type (type, type);\n+  if (INTEGRAL_TYPE_P (type)\n+      && get_range_info (parameter, &min, &max) == VR_RANGE)\n+    ;\n   else\n-    ub = TYPE_MAX_VALUE (type);\n-\n-  if (lb)\n     {\n-      isl_space *space = isl_set_get_space (scop->param_context);\n-      isl_constraint *c;\n-      isl_val *v;\n-\n-      c = isl_inequality_alloc (isl_local_space_from_space (space));\n-      v = isl_val_int_from_wi (scop->isl_context, wi::to_widest (lb));\n-      v = isl_val_neg (v);\n-      c = isl_constraint_set_constant_val (c, v);\n-      c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, 1);\n-\n-      scop->param_context = isl_set_coalesce\n-\t(isl_set_add_constraint (scop->param_context, c));\n+      min = wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n     }\n \n-  if (ub)\n-    {\n-      isl_space *space = isl_set_get_space (scop->param_context);\n-      isl_constraint *c;\n-      isl_val *v;\n-\n-      c = isl_inequality_alloc (isl_local_space_from_space (space));\n-\n-      v = isl_val_int_from_wi (scop->isl_context, wi::to_widest (ub));\n-      c = isl_constraint_set_constant_val (c, v);\n-      c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, -1);\n-\n-      scop->param_context = isl_set_coalesce\n-\t(isl_set_add_constraint (scop->param_context, c));\n-    }\n+  isl_space *space = isl_set_get_space (scop->param_context);\n+  isl_constraint *c = isl_inequality_alloc (isl_local_space_from_space (space));\n+  isl_val *v = isl_val_int_from_wi (scop->isl_context,\n+\t\t\t\t    widest_int::from (min, TYPE_SIGN (type)));\n+  v = isl_val_neg (v);\n+  c = isl_constraint_set_constant_val (c, v);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, 1);\n+  scop->param_context = isl_set_coalesce\n+      (isl_set_add_constraint (scop->param_context, c));\n+\n+  space = isl_set_get_space (scop->param_context);\n+  c = isl_inequality_alloc (isl_local_space_from_space (space));\n+  v = isl_val_int_from_wi (scop->isl_context,\n+\t\t\t   widest_int::from (max, TYPE_SIGN (type)));\n+  c = isl_constraint_set_constant_val (c, v);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, -1);\n+  scop->param_context = isl_set_coalesce\n+      (isl_set_add_constraint (scop->param_context, c));\n }\n \n /* Add a constrain to the ACCESSES polyhedron for the alias set of\n@@ -930,9 +912,8 @@ build_scop_context (scop_p scop)\n \n   scop->param_context = isl_set_universe (space);\n \n-  graphite_dim_t p;\n-  for (p = 0; p < nbp; p++)\n-    add_param_constraints (scop, p);\n+  FOR_EACH_VEC_ELT (region->params, i, e)\n+    add_param_constraints (scop, i, e);\n }\n \n /* Return true when loop A is nested in loop B.  */"}, {"sha": "89cddf0ec974b73b1b247f39925d5bad978e8ee0", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=30c4440c6ad1034e6e69fa7370659aaa9bb19912", "patch": "@@ -156,10 +156,8 @@ new_sese_info (edge entry, edge exit)\n   region->liveout = NULL;\n   region->debug_liveout = NULL;\n   region->params.create (3);\n-  region->rename_map = new rename_map_t;\n+  region->rename_map = new hash_map <tree, tree>;\n   region->bbs.create (3);\n-  region->incomplete_phis.create (3);\n-\n \n   return region;\n }\n@@ -173,14 +171,9 @@ free_sese_info (sese_info_p region)\n   BITMAP_FREE (region->liveout);\n   BITMAP_FREE (region->debug_liveout);\n \n-  for (rename_map_t::iterator it = region->rename_map->begin ();\n-       it != region->rename_map->end (); ++it)\n-    (*it).second.release ();\n-\n   delete region->rename_map;\n   region->rename_map = NULL;\n   region->bbs.release ();\n-  region->incomplete_phis.release ();\n \n   XDELETE (region);\n }"}, {"sha": "cbc20ab10644ad1fa5306dad4f96bd9da87ba2eb", "filename": "gcc/sese.h", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c4440c6ad1034e6e69fa7370659aaa9bb19912/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=30c4440c6ad1034e6e69fa7370659aaa9bb19912", "patch": "@@ -22,13 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SESE_H\n #define GCC_SESE_H\n \n-typedef hash_map<basic_block, vec<basic_block> > bb_map_t;\n-typedef hash_map<tree, vec<tree> > rename_map_t;\n typedef struct ifsese_s *ifsese;\n-/* First phi is the new codegenerated phi second one is original phi.  */\n-typedef std::pair <gphi *, gphi *> phi_rename;\n-/* First edge is the init edge and second is the back edge w.r.t. a loop.  */\n-typedef std::pair<edge, edge> init_back_edge_pair_t;\n \n /* A Single Entry, Single Exit region is a part of the CFG delimited\n    by two edges.  */\n@@ -91,18 +85,12 @@ typedef struct sese_info_t\n   /* Parameters used within the SCOP.  */\n   vec<tree> params;\n \n-  /* Maps an old name to one or more new names.  When there are several new\n-     names, one has to select the definition corresponding to the immediate\n-     dominator.  */\n-  rename_map_t *rename_map;\n+  /* Maps an old name to a new decl.  */\n+  hash_map<tree, tree> *rename_map;\n \n   /* Basic blocks contained in this SESE.  */\n   vec<basic_block> bbs;\n \n-  /* A vector of phi nodes to be updated when all arguments are available.  The\n-     pair contains first the old_phi and second the new_phi.  */\n-  vec<phi_rename> incomplete_phis;\n-\n   /* The condition region generated for this sese.  */\n   ifsese if_region;\n "}]}