{"sha": "2097b5f2d342d2910e322a4140635c25bfef04ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5N2I1ZjJkMzQyZDI5MTBlMzIyYTQxNDA2MzVjMjViZmVmMDRlYw==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-02-05T16:48:54Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-02-05T16:48:54Z"}, "message": "re PR c++/14008 (Confusing diagnostic when omitting a template parameter)\n\n\tPR c++/14008\n\t* parser.c (cp_parser_diagnose_invalid_typename): Removed parsing\n\tcode, only emits the diagnostic now. Added lookup of the identifier\n\tand support for qualified ids.\n\t(cp_parser_parse_and_diagnose_invalid_type_name): New function.\n\tParse an (invalid) type name as id-expression within a declarator.\n\t(cp_parser_simple_declaration): Use it.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_make_typename_type): New function. Handle errors through\n\tcp_parser_diagnose_invalid_typename.\n\t(cp_parser_elaborated_type_specifier): Use it.\n\nFrom-SVN: r77323", "tree": {"sha": "605cacb4eca2bf2250ec9a4f597be3794b87fcff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605cacb4eca2bf2250ec9a4f597be3794b87fcff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2097b5f2d342d2910e322a4140635c25bfef04ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2097b5f2d342d2910e322a4140635c25bfef04ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2097b5f2d342d2910e322a4140635c25bfef04ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2097b5f2d342d2910e322a4140635c25bfef04ec/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ad136540ef6fae18e70f7745f2e962004bbc5cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad136540ef6fae18e70f7745f2e962004bbc5cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad136540ef6fae18e70f7745f2e962004bbc5cf"}], "stats": {"total": 158, "additions": 123, "deletions": 35}, "files": [{"sha": "8dfd5c1543e7e4857c8a82a1a73d1e32ab436847", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2097b5f2d342d2910e322a4140635c25bfef04ec/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2097b5f2d342d2910e322a4140635c25bfef04ec/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2097b5f2d342d2910e322a4140635c25bfef04ec", "patch": "@@ -1,3 +1,17 @@\n+2003-02-05  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/14008\n+\t* parser.c (cp_parser_diagnose_invalid_typename): Removed parsing \n+\tcode, only emits the diagnostic now. Added lookup of the identifier\n+\tand support for qualified ids.\n+\t(cp_parser_parse_and_diagnose_invalid_type_name): New function.\n+\tParse an (invalid) type name as id-expression within a declarator.\n+\t(cp_parser_simple_declaration): Use it.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_make_typename_type): New function. Handle errors through\n+\tcp_parser_diagnose_invalid_typename.\n+\t(cp_parser_elaborated_type_specifier): Use it.\n+\n 2004-02-04  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13932"}, {"sha": "f52106a6913be1393ccdd8f13fc974194d0d4d2b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 109, "deletions": 35, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2097b5f2d342d2910e322a4140635c25bfef04ec/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2097b5f2d342d2910e322a4140635c25bfef04ec/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2097b5f2d342d2910e322a4140635c25bfef04ec", "patch": "@@ -1721,7 +1721,9 @@ static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree);\n static tree cp_parser_non_integral_constant_expression\n   (const char *);\n-static bool cp_parser_diagnose_invalid_type_name\n+static void cp_parser_diagnose_invalid_type_name\n+  (cp_parser *, tree, tree);\n+static bool cp_parser_parse_and_diagnose_invalid_type_name\n   (cp_parser *);\n static int cp_parser_skip_to_closing_parenthesis\n   (cp_parser *, bool, bool, bool);\n@@ -1743,6 +1745,8 @@ static bool cp_parser_is_string_literal\n   (cp_token *);\n static bool cp_parser_is_keyword \n   (cp_token *, enum rid);\n+static tree cp_parser_make_typename_type\n+  (cp_parser *, tree, tree);\n \n /* Returns nonzero if we are parsing tentatively.  */\n \n@@ -1928,30 +1932,28 @@ cp_parser_non_integral_constant_expression (const char *thing)\n   return error_mark_node;\n }\n \n-/* Check for a common situation where a type-name should be present,\n-   but is not, and issue a sensible error message.  Returns true if an\n-   invalid type-name was detected.  */\n-\n-static bool\n-cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n-{\n-  /* If the next two tokens are both identifiers, the code is\n-     erroneous. The usual cause of this situation is code like:\n-\n-       T t;\n+/* Emit a diagnostic for an invalid type name. Consider also if it is\n+   qualified or not and the result of a lookup, to provide a better \n+   message.  */\n \n-     where \"T\" should name a type -- but does not.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n-      && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME)\n+static void\n+cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n+{\r\n+  tree decl, old_scope;\r\n+  /* Try to lookup the identifier.  */\n+  old_scope = parser->scope;\n+  parser->scope = scope;\n+  decl = cp_parser_lookup_name_simple (parser, id);\n+  parser->scope = old_scope;\n+  /* If the lookup found a template-name, it means that the user forgot\n+  to specify an argument list. Emit an useful error message.  */\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    error (\"invalid use of template-name `%E' without an argument list\",\r\n+      decl);\r\n+  else if (!parser->scope)\n     {\n-      tree name;\n-\n-      /* If parsing tentatively, we should commit; we really are\n-\t looking at a declaration.  */\n-      /* Consume the first identifier.  */\n-      name = cp_lexer_consume_token (parser->lexer)->value;\n       /* Issue an error message.  */\n-      error (\"`%s' does not name a type\", IDENTIFIER_POINTER (name));\n+      error (\"`%E' does not name a type\", id);\n       /* If we're in a template class, it's possible that the user was\n \t referring to a type from a base class.  For example:\n \n@@ -1980,25 +1982,78 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n \t\t       field;\n \t\t       field = TREE_CHAIN (field))\n \t\t    if (TREE_CODE (field) == TYPE_DECL\n-\t\t\t&& DECL_NAME (field) == name)\n+\t\t\t&& DECL_NAME (field) == id)\n \t\t      {\n-\t\t\terror (\"(perhaps `typename %T::%s' was intended)\",\n-\t\t\t       BINFO_TYPE (b), IDENTIFIER_POINTER (name));\n+\t\t\tinform (\"(perhaps `typename %T::%E' was intended)\",\n+\t\t\t        BINFO_TYPE (b), id);\n \t\t\tbreak;\n \t\t      }\n \t\t  if (field)\n \t\t    break;\n \t\t}\n \t    }\n \t}\n-      /* Skip to the end of the declaration; there's no point in\n-\t trying to process it.  */\n-      cp_parser_skip_to_end_of_statement (parser);\n-      \n-      return true;\n     }\n+  /* Here we diagnose qualified-ids where the scope is actually correct,\n+     but the identifier does not resolve to a valid type name.  */\n+  else \n+    {\n+      if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n+\terror (\"`%E' in namespace `%E' does not name a type\", \n+\t       id, parser->scope);\n+      else if (TYPE_P (parser->scope))\n+\terror (\"`%E' in class `%T' does not name a type\", \n+\t       id, parser->scope);\n+      else\n+\tabort();\n+    }\n+}\n+\n+/* Check for a common situation where a type-name should be present,\n+   but is not, and issue a sensible error message.  Returns true if an\n+   invalid type-name was detected.\n+   \n+   The situation handled by this function are variable declarations of the\n+   form `ID a', where `ID' is an id-expression and `a' is a plain identifier. \n+   Usually, `ID' should name a type, but if we got here it means that it \n+   does not. We try to emit the best possible error message depending on\n+   how exactly the id-expression looks like.\n+*/\n+\n+static bool\n+cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n+{\n+  tree id;\n+\n+  cp_parser_parse_tentatively (parser);\n+  id = cp_parser_id_expression (parser, \n+\t\t\t\t/*template_keyword_p=*/false,\n+\t\t\t\t/*check_dependency_p=*/true,\n+\t\t\t\t/*template_p=*/NULL,\n+\t\t\t\t/*declarator_p=*/true);\n+  /* After the id-expression, there should be a plain identifier,\n+     otherwise this is not a simple variable declaration. Also, if\n+     the scope is dependent, we cannot do much.  */\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+      || (parser->scope && TYPE_P (parser->scope) \n+\t  && dependent_type_p (parser->scope)))\n+    {\n+      cp_parser_abort_tentative_parse (parser);\n+      return false;\n+    }\n+  if (!cp_parser_parse_definitely (parser))\n+    return false;\n \n-  return false;\n+  /* If we got here, this cannot be a valid variable declaration, thus\n+     the cp_parser_id_expression must have resolved to a plain identifier\n+     node (not a TYPE_DECL or TEMPLATE_ID_EXPR).  */\n+  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 20030203);\n+  /* Emit a diagnostic for the invalid type.  */\n+  cp_parser_diagnose_invalid_type_name (parser, parser->scope, id);\n+  /* Skip to the end of the declaration; there's no point in\n+     trying to process it.  */\n+  cp_parser_skip_to_end_of_block_or_statement (parser);\n+  return true;\n }\n \n /* Consume tokens up to, and including, the next non-nested closing `)'. \n@@ -2210,6 +2265,25 @@ cp_parser_skip_to_closing_brace (cp_parser *parser)\n     }\n }\n \n+/* This is a simple wrapper around make_typename_type. When the id is\n+   an unresolved identifier node, we can provide a superior diagnostic\n+   using cp_parser_diagnose_invalid_type_name.  */\n+\n+static tree\n+cp_parser_make_typename_type (cp_parser *parser, tree scope, tree id)\n+{\r\n+  tree result;\r\n+  if (TREE_CODE (id) == IDENTIFIER_NODE)\r\n+    {\r\n+      result = make_typename_type (scope, id, /*complain=*/0);\r\n+      if (result == error_mark_node)\r\n+\tcp_parser_diagnose_invalid_type_name (parser, scope, id);\r\n+      return result;\r\n+    }\r\n+  return make_typename_type (scope, id, tf_error);\r\n+}\n+\n+\n /* Create a new C++ parser.  */\n \n static cp_parser *\n@@ -6440,7 +6514,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n        T t;\n \n      where \"T\" should name a type -- but does not.  */\n-  if (cp_parser_diagnose_invalid_type_name (parser))\n+  if (cp_parser_parse_and_diagnose_invalid_type_name (parser))\n     {\n       /* If parsing tentatively, we should commit; we really are\n \t looking at a declaration.  */\n@@ -9076,8 +9150,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n       /* For a `typename', we needn't call xref_tag.  */\n       if (tag_type == typename_type)\n-\treturn make_typename_type (parser->scope, identifier, \n-\t\t\t\t   /*complain=*/1);\n+\treturn cp_parser_make_typename_type (parser, parser->scope, \n+\t\t\t\t\t     identifier);\n       /* Look up a qualified name in the usual way.  */\n       if (parser->scope)\n \t{\n@@ -12290,7 +12364,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t    &prefix_attributes,\n \t\t\t\t    &declares_class_or_enum);\n   /* Check for an invalid type-name.  */\n-  if (cp_parser_diagnose_invalid_type_name (parser))\n+  if (cp_parser_parse_and_diagnose_invalid_type_name (parser))\n     return;\n   /* If there is no declarator, then the decl-specifier-seq should\n      specify a type.  */"}]}