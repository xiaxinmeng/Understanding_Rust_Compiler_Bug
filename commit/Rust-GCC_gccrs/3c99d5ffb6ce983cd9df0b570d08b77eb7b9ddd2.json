{"sha": "3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5OWQ1ZmZiNmNlOTgzY2Q5ZGYwYjU3MGQwOGI3N2ViN2I5ZGRkMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-10T21:10:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-10T21:10:20Z"}, "message": "(simplify_rtx, case SUBREG): Fix direction of test when calling operand_subword...\n\n(simplify_rtx, case SUBREG): Fix direction of test when calling\noperand_subword; use inline code intead of subreg_lowpart_p.\n\nFrom-SVN: r13698", "tree": {"sha": "282e942f870d17f29772bf53ba0fa2bf993cff0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/282e942f870d17f29772bf53ba0fa2bf993cff0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2/comments", "author": null, "committer": null, "parents": [{"sha": "a3a03040fb9ec55225cdb4e3a5cfbb2c5b5dda94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a03040fb9ec55225cdb4e3a5cfbb2c5b5dda94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a03040fb9ec55225cdb4e3a5cfbb2c5b5dda94"}], "stats": {"total": 14, "additions": 11, "deletions": 3}, "files": [{"sha": "89f6525b560e4da66648c3c3bd3f8499ed780614", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3c99d5ffb6ce983cd9df0b570d08b77eb7b9ddd2", "patch": "@@ -3383,7 +3383,7 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \n       if (CONSTANT_P (SUBREG_REG (x)) && op0_mode != VOIDmode\n \t  && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (op0_mode) < UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (op0_mode) > UNITS_PER_WORD\n \t  && GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n \t  temp = operand_subword (SUBREG_REG (x), SUBREG_WORD (x),\n@@ -3395,8 +3395,16 @@ simplify_rtx (x, op0_mode, last, in_dest)\n       /* If we want a subreg of a constant, at offset 0,\n \t take the low bits.  On a little-endian machine, that's\n \t always valid.  On a big-endian machine, it's valid\n-\t only if the constant's mode fits in one word.  */\n-      if (CONSTANT_P (SUBREG_REG (x)) && subreg_lowpart_p (x)\n+\t only if the constant's mode fits in one word.   Note that we\n+\t cannot use subreg_lowpart_p since we SUBREG_REG may be VOIDmode.  */\n+      if (CONSTANT_P (SUBREG_REG (x))\n+\t  && ((GET_MODE_SIZE (op0_mode) <= UNITS_PER_WORD\n+\t      || ! WORDS_BIG_ENDIAN)\n+\t      ? SUBREG_WORD (x) == 0\n+\t      : (SUBREG_WORD (x)\n+\t\t == ((GET_MODE_SIZE (op0_mode)\n+\t\t      - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n+\t\t     / UNITS_PER_WORD)))\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (op0_mode)\n \t  && (! WORDS_BIG_ENDIAN\n \t      || GET_MODE_BITSIZE (op0_mode) <= BITS_PER_WORD))"}]}