{"sha": "744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0YWE0MmZhYmE3ZWVkZjgyZWFhNmM3YTYzNmNhMWViMWQwYzI3Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-09T20:34:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-09T20:34:13Z"}, "message": "targhooks.c (default_builtin_vectorized_function): Change fn parameter to unsigned int.\n\n./:\t* targhooks.c (default_builtin_vectorized_function): Change fn\n\tparameter to unsigned int.\n\t(default_builtin_vectorized_conversion): Change code parameter to\n\tunsigned int.\n\t(default_builtin_reciprocal): Change fn parameter to unsigned int.\n\t* targhooks.h: Update declarations.\n\t* config/rs6000/rs6000.c (rs6000_builtin_conversion): Change code\n\tparameter to unsigned int.\n\n\t* c-typeck.c (comptypes_check_enum_int): New static function.\n\t(comptypes_internal): Add enum_and_int_p parameter.  Change all\n\tcallers.\n\t(comp_target_types): Add location parameter.  Change all callers.\n\t(tagged_types_tu_compatible_p): Add enum_and_int_p parameter.\n\tChange all callers.\n\t(function_types_compatible_p, type_lists_compatible_p): Likewise.\n\t(build_conditional_expr): Add colon_loc parameter.  Change all\n\tcallers.\n\t(convert_for_assignment): Add location parameter.  Change all\n\tcallers.\n\t* c-parser.c (c_parser_conditional_expression): Pass location of\n\tcolon to build_conditional_expr.\n\t* c-tree.h (build_conditional_expr): Update declaration.\nobjc/:\n\t* objc-act.c (objc_gimplify_expr): Change return type to int.\n\t* objc-act.h: Update declaration.\ntestsuite/:\n\t* gcc.dg/Wcxx-compat-12.c: New testcase.\n\nFrom-SVN: r148325", "tree": {"sha": "56175d390c11854aba3f0de6bda4ded498eb45a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56175d390c11854aba3f0de6bda4ded498eb45a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/comments", "author": null, "committer": null, "parents": [{"sha": "a3f2b833834ad00c2a209a7e07848ff0c94bd21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f2b833834ad00c2a209a7e07848ff0c94bd21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f2b833834ad00c2a209a7e07848ff0c94bd21b"}], "stats": {"total": 269, "additions": 184, "deletions": 85}, "files": [{"sha": "878d18ea0ac58f3999f8fd64eaad5ce2610d0471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -1,3 +1,29 @@\n+2009-06-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* targhooks.c (default_builtin_vectorized_function): Change fn\n+\tparameter to unsigned int.\n+\t(default_builtin_vectorized_conversion): Change code parameter to\n+\tunsigned int.\n+\t(default_builtin_reciprocal): Change fn parameter to unsigned int.\n+\t* targhooks.h: Update declarations.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_conversion): Change code\n+\tparameter to unsigned int.\n+\n+\t* c-typeck.c (comptypes_check_enum_int): New static function.\n+\t(comptypes_internal): Add enum_and_int_p parameter.  Change all\n+\tcallers.\n+\t(comp_target_types): Add location parameter.  Change all callers.\n+\t(tagged_types_tu_compatible_p): Add enum_and_int_p parameter.\n+\tChange all callers.\n+\t(function_types_compatible_p, type_lists_compatible_p): Likewise.\n+\t(build_conditional_expr): Add colon_loc parameter.  Change all\n+\tcallers.\n+\t(convert_for_assignment): Add location parameter.  Change all\n+\tcallers.\n+\t* c-parser.c (c_parser_conditional_expression): Pass location of\n+\tcolon to build_conditional_expr.\n+\t* c-tree.h (build_conditional_expr): Update declaration.\n+\n 2009-06-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite.c: Revert previous patch."}, {"sha": "284708656b556689422c9c42137cca640fe985ac", "filename": "gcc/c-parser.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -4503,7 +4503,7 @@ static struct c_expr\n c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n {\n   struct c_expr cond, exp1, exp2, ret;\n-  location_t cond_loc;\n+  location_t cond_loc, colon_loc;\n \n   gcc_assert (!after || c_dialect_objc ());\n \n@@ -4542,6 +4542,8 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       skip_evaluation += ((cond.value == truthvalue_true_node)\n \t\t\t  - (cond.value == truthvalue_false_node));\n     }\n+\n+  colon_loc = c_parser_peek_token (parser)->location;\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n     {\n       skip_evaluation -= cond.value == truthvalue_true_node;\n@@ -4553,7 +4555,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   exp2 = c_parser_conditional_expression (parser, NULL);\n   exp2 = default_function_array_conversion (exp2);\n   skip_evaluation -= cond.value == truthvalue_true_node;\n-  ret.value = build_conditional_expr (cond.value,\n+  ret.value = build_conditional_expr (colon_loc, cond.value,\n \t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n \t\t\t\t      exp1.value, exp2.value);\n   ret.original_code = ERROR_MARK;"}, {"sha": "880cc1b877a638876c9b40b05eba4b6d81972bbf", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -607,7 +607,7 @@ extern struct c_expr parser_build_unary_op (enum tree_code, struct c_expr,\n extern struct c_expr parser_build_binary_op (location_t, \n     \t\t\t\t\t     enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n-extern tree build_conditional_expr (tree, bool, tree, tree);\n+extern tree build_conditional_expr (location_t, tree, bool, tree, tree);\n extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (struct c_type_name *, tree, location_t);\n extern tree build_c_cast (tree, tree);"}, {"sha": "6c86b92de6dd99d4895ca75754af313355682909", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 121, "deletions": 70, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -82,16 +82,16 @@ static int require_constant_elements;\n \n static bool null_pointer_constant_p (const_tree);\n static tree qualify_type (tree, tree);\n-static int tagged_types_tu_compatible_p (const_tree, const_tree);\n-static int comp_target_types (tree, tree);\n-static int function_types_compatible_p (const_tree, const_tree);\n-static int type_lists_compatible_p (const_tree, const_tree);\n+static int tagged_types_tu_compatible_p (const_tree, const_tree, bool *);\n+static int comp_target_types (location_t, tree, tree);\n+static int function_types_compatible_p (const_tree, const_tree, bool *);\n+static int type_lists_compatible_p (const_tree, const_tree, bool *);\n static tree lookup_field (tree, tree);\n static int convert_arguments (tree, VEC(tree,gc) *, VEC(tree,gc) *, tree,\n \t\t\t      tree);\n static tree pointer_diff (tree, tree);\n-static tree convert_for_assignment (tree, tree, tree, enum impl_conv, bool,\n-\t\t\t\t    tree, tree, int);\n+static tree convert_for_assignment (location_t, tree, tree, tree,\n+\t\t\t\t    enum impl_conv, bool, tree, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n static void push_member_name (tree);\n@@ -111,7 +111,7 @@ static void readonly_error (tree, enum lvalue_use);\n static void readonly_warning (tree, enum lvalue_use);\n static int lvalue_or_else (const_tree, enum lvalue_use);\n static void record_maybe_used_decl (tree);\n-static int comptypes_internal (const_tree, const_tree);\n+static int comptypes_internal (const_tree, const_tree, bool *);\n \f\n /* Return true if EXP is a null pointer constant, false otherwise.  */\n \n@@ -919,19 +919,37 @@ comptypes (tree type1, tree type2)\n   const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n   int val;\n \n-  val = comptypes_internal (type1, type2);\n+  val = comptypes_internal (type1, type2, NULL);\n+  free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n+\n+  return val;\n+}\n+\n+/* Like comptypes, but if it returns non-zero because enum and int are\n+   compatible, it sets *ENUM_AND_INT_P to true.  */\n+\n+static int\n+comptypes_check_enum_int (tree type1, tree type2, bool *enum_and_int_p)\n+{\n+  const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n+  int val;\n+\n+  val = comptypes_internal (type1, type2, enum_and_int_p);\n   free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n \n   return val;\n }\n \f\n /* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n    or various other operations.  Return 2 if they are compatible\n-   but a warning may be needed if you use them together.  This\n-   differs from comptypes, in that we don't free the seen types.  */\n+   but a warning may be needed if you use them together.  If\n+   ENUM_AND_INT_P is not NULL, and one type is an enum and the other a\n+   compatible integer type, then this sets *ENUM_AND_INT_P to true;\n+   *ENUM_AND_INT_P is never set to false.  This differs from\n+   comptypes, in that we don't free the seen types.  */\n \n static int\n-comptypes_internal (const_tree type1, const_tree type2)\n+comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n {\n   const_tree t1 = type1;\n   const_tree t2 = type2;\n@@ -959,9 +977,17 @@ comptypes_internal (const_tree type1, const_tree type2)\n      are compatible with each other only if they are the same type.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE && TREE_CODE (t2) != ENUMERAL_TYPE)\n-    t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n+    {\n+      t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n+      if (enum_and_int_p != NULL && TREE_CODE (t2) != VOID_TYPE)\n+\t*enum_and_int_p = true;\n+    }\n   else if (TREE_CODE (t2) == ENUMERAL_TYPE && TREE_CODE (t1) != ENUMERAL_TYPE)\n-    t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n+    {\n+      t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n+      if (enum_and_int_p != NULL && TREE_CODE (t1) != VOID_TYPE)\n+\t*enum_and_int_p = true;\n+    }\n \n   if (t1 == t2)\n     return 1;\n@@ -999,11 +1025,12 @@ comptypes_internal (const_tree type1, const_tree type2)\n \t  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n \tbreak;\n       val = (TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t     ? 1 : comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2)));\n+\t     ? 1 : comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t       enum_and_int_p));\n       break;\n \n     case FUNCTION_TYPE:\n-      val = function_types_compatible_p (t1, t2);\n+      val = function_types_compatible_p (t1, t2, enum_and_int_p);\n       break;\n \n     case ARRAY_TYPE:\n@@ -1016,7 +1043,8 @@ comptypes_internal (const_tree type1, const_tree type2)\n \n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n-\t    && 0 == (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2))))\n+\t    && 0 == (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t       enum_and_int_p)))\n \t  return 0;\n \n \t/* Sizes must match unless one is missing or variable.  */\n@@ -1060,14 +1088,15 @@ comptypes_internal (const_tree type1, const_tree type2)\n \t    break;\n \n \t  if (attrval != 2)\n-\t    return tagged_types_tu_compatible_p (t1, t2);\n-\t  val = tagged_types_tu_compatible_p (t1, t2);\n+\t    return tagged_types_tu_compatible_p (t1, t2, enum_and_int_p);\n+\t  val = tagged_types_tu_compatible_p (t1, t2, enum_and_int_p);\n \t}\n       break;\n \n     case VECTOR_TYPE:\n-      val = TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n-\t    && comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2));\n+      val = (TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n+\t     && comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t    enum_and_int_p));\n       break;\n \n     default:\n@@ -1080,10 +1109,11 @@ comptypes_internal (const_tree type1, const_tree type2)\n    ignoring their qualifiers.  */\n \n static int\n-comp_target_types (tree ttl, tree ttr)\n+comp_target_types (location_t location, tree ttl, tree ttr)\n {\n   int val;\n   tree mvl, mvr;\n+  bool enum_and_int_p;\n \n   /* Do not lose qualifiers on element types of array types that are\n      pointer targets by taking their TYPE_MAIN_VARIANT.  */\n@@ -1093,10 +1123,16 @@ comp_target_types (tree ttl, tree ttr)\n     mvl = TYPE_MAIN_VARIANT (mvl);\n   if (TREE_CODE (mvr) != ARRAY_TYPE)\n     mvr = TYPE_MAIN_VARIANT (mvr);\n-  val = comptypes (mvl, mvr);\n+  enum_and_int_p = false;\n+  val = comptypes_check_enum_int (mvl, mvr, &enum_and_int_p);\n \n   if (val == 2)\n-    pedwarn (input_location, OPT_pedantic, \"types are not quite compatible\");\n+    pedwarn (location, OPT_pedantic, \"types are not quite compatible\");\n+\n+  if (val == 1 && enum_and_int_p && warn_cxx_compat)\n+    warning_at (location, OPT_Wc___compat,\n+\t\t\"pointer target types incompatible in C++\");\n+\n   return val;\n }\n \f\n@@ -1184,10 +1220,11 @@ free_all_tagged_tu_seen_up_to (const struct tagged_tu_seen_cache *tu_til)\n    compatible.  If the two types are not the same (which has been\n    checked earlier), this can only happen when multiple translation\n    units are being compiled.  See C99 6.2.7 paragraph 1 for the exact\n-   rules.  */\n+   rules.  ENUM_AND_INT_P is as in comptypes_internal.  */\n \n static int\n-tagged_types_tu_compatible_p (const_tree t1, const_tree t2)\n+tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n+\t\t\t      bool *enum_and_int_p)\n {\n   tree s1, s2;\n   bool needs_warning = false;\n@@ -1297,7 +1334,8 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2)\n \n \t    if (DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n-\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n+\t\t\t\t\t enum_and_int_p);\n \n \t    if (result != 1 && !DECL_NAME (s1))\n \t      break;\n@@ -1332,7 +1370,8 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2)\n \t\t{\n \t\t  int result;\n \n-\t\t  result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t\t  result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n+\t\t\t\t\t       enum_and_int_p);\n \n \t\t  if (result != 1 && !DECL_NAME (s1))\n \t\t    continue;\n@@ -1374,7 +1413,8 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2)\n \t    if (TREE_CODE (s1) != TREE_CODE (s2)\n \t\t|| DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n-\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n+\t\t\t\t\t enum_and_int_p);\n \t    if (result == 0)\n \t      break;\n \t    if (result == 2)\n@@ -1402,10 +1442,12 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2)\n    the other must specify a fixed number of self-promoting arg types.\n    Otherwise, if one type specifies only the number of arguments,\n    the other must specify that number of self-promoting arg types.\n-   Otherwise, the argument types must match.  */\n+   Otherwise, the argument types must match.\n+   ENUM_AND_INT_P is as in comptypes_internal.  */\n \n static int\n-function_types_compatible_p (const_tree f1, const_tree f2)\n+function_types_compatible_p (const_tree f1, const_tree f2,\n+\t\t\t     bool *enum_and_int_p)\n {\n   tree args1, args2;\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -1426,7 +1468,7 @@ function_types_compatible_p (const_tree f1, const_tree f2)\n   if (TYPE_VOLATILE (ret2))\n     ret2 = build_qualified_type (TYPE_MAIN_VARIANT (ret2),\n \t\t\t\t TYPE_QUALS (ret2) & ~TYPE_QUAL_VOLATILE);\n-  val = comptypes_internal (ret1, ret2);\n+  val = comptypes_internal (ret1, ret2, enum_and_int_p);\n   if (val == 0)\n     return 0;\n \n@@ -1444,7 +1486,8 @@ function_types_compatible_p (const_tree f1, const_tree f2)\n \t compare that with the other type's arglist.\n \t If they don't match, ask for a warning (but no error).  */\n       if (TYPE_ACTUAL_ARG_TYPES (f1)\n-\t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1)))\n+\t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1),\n+\t\t\t\t\t   enum_and_int_p))\n \tval = 2;\n       return val;\n     }\n@@ -1453,22 +1496,24 @@ function_types_compatible_p (const_tree f1, const_tree f2)\n       if (!self_promoting_args_p (args1))\n \treturn 0;\n       if (TYPE_ACTUAL_ARG_TYPES (f2)\n-\t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2)))\n+\t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2),\n+\t\t\t\t\t   enum_and_int_p))\n \tval = 2;\n       return val;\n     }\n \n   /* Both types have argument lists: compare them and propagate results.  */\n-  val1 = type_lists_compatible_p (args1, args2);\n+  val1 = type_lists_compatible_p (args1, args2, enum_and_int_p);\n   return val1 != 1 ? val1 : val;\n }\n \n-/* Check two lists of types for compatibility,\n-   returning 0 for incompatible, 1 for compatible,\n-   or 2 for compatible with warning.  */\n+/* Check two lists of types for compatibility, returning 0 for\n+   incompatible, 1 for compatible, or 2 for compatible with\n+   warning.  ENUM_AND_INT_P is as in comptypes_internal.  */\n \n static int\n-type_lists_compatible_p (const_tree args1, const_tree args2)\n+type_lists_compatible_p (const_tree args1, const_tree args2,\n+\t\t\t bool *enum_and_int_p)\n {\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   int val = 1;\n@@ -1507,7 +1552,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2)\n       else if (TREE_CODE (a1) == ERROR_MARK\n \t       || TREE_CODE (a2) == ERROR_MARK)\n \t;\n-      else if (!(newval = comptypes_internal (mv1, mv2)))\n+      else if (!(newval = comptypes_internal (mv1, mv2, enum_and_int_p)))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n@@ -1526,7 +1571,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2)\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes_internal (mv3, mv2))\n+\t\t  if (comptypes_internal (mv3, mv2, enum_and_int_p))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)\n@@ -1547,7 +1592,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2)\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes_internal (mv3, mv1))\n+\t\t  if (comptypes_internal (mv3, mv1, enum_and_int_p))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)\n@@ -2850,8 +2895,8 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t      origtype = (origtypes == NULL\n \t\t\t  ? NULL_TREE\n \t\t\t  : VEC_index (tree, origtypes, parmnum));\n-\t      parmval = convert_for_assignment (type, val, origtype,\n-\t\t\t\t\t\tic_argpass, npc,\n+\t      parmval = convert_for_assignment (input_location, type, val,\n+\t\t\t\t\t\torigtype, ic_argpass, npc,\n \t\t\t\t\t\tfundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n \n@@ -3713,7 +3758,8 @@ c_mark_addressable (tree exp)\n    expressions.  */\n \n tree\n-build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n+build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n+\t\t\ttree op1, tree op2)\n {\n   tree type1;\n   tree type2;\n@@ -3758,7 +3804,7 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n      In C99 they will be pointers by now.  */\n   if (code1 == ARRAY_TYPE || code2 == ARRAY_TYPE)\n     {\n-      error (\"non-lvalue array in conditional expression\");\n+      error_at (colon_loc, \"non-lvalue array in conditional expression\");\n       return error_mark_node;\n     }\n \n@@ -3847,7 +3893,9 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n \t\t\t      && tree_expr_nonnegative_warnv_p (op2, &ovf)))\n \t\t\t/* OK */;\n \t\t      else\n-\t\t\twarning (OPT_Wsign_compare, \"signed and unsigned type in conditional expression\");\n+\t\t\twarning_at (colon_loc, OPT_Wsign_compare,\n+\t\t\t\t    (\"signed and unsigned type in \"\n+\t\t\t\t     \"conditional expression\"));\n \t\t    }\n \t\t  if (!op1_maybe_const || TREE_CODE (op1) != INTEGER_CST)\n \t\t    {\n@@ -3868,13 +3916,13 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {\n       if (code1 != VOID_TYPE || code2 != VOID_TYPE)\n-\tpedwarn (input_location, OPT_pedantic, \n+\tpedwarn (colon_loc, OPT_pedantic,\n \t\t \"ISO C forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n-      if (comp_target_types (type1, type2))\n+      if (comp_target_types (colon_loc, type1, type2))\n \tresult_type = common_pointer_type (type1, type2);\n       else if (null_pointer_constant_p (orig_op1))\n \tresult_type = qualify_type (type2, type1);\n@@ -3883,7 +3931,7 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n-\t    pedwarn (input_location, OPT_pedantic, \n+\t    pedwarn (colon_loc, OPT_pedantic,\n \t\t     \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n@@ -3892,7 +3940,7 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n       else if (VOID_TYPE_P (TREE_TYPE (type2)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (input_location, OPT_pedantic, \n+\t    pedwarn (colon_loc, OPT_pedantic,\n \t\t     \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type2),\n@@ -3901,15 +3949,15 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n       else\n \t{\n \t  if (!objc_ok)\n-\t    pedwarn (input_location, 0, \n+\t    pedwarn (colon_loc, 0,\n \t\t     \"pointer type mismatch in conditional expression\");\n \t  result_type = build_pointer_type (void_type_node);\n \t}\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op2))\n-\tpedwarn (input_location, 0, \n+\tpedwarn (colon_loc, 0,\n \t\t \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n@@ -3920,7 +3968,7 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op1))\n-\tpedwarn (input_location, 0, \n+\tpedwarn (colon_loc, 0,\n \t\t \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n@@ -4501,8 +4549,8 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   newrhs = c_fully_fold (newrhs, false, NULL);\n   if (rhs_semantic_type)\n     newrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n-  newrhs = convert_for_assignment (lhstype, newrhs, rhs_origtype, ic_assign,\n-\t\t\t\t   npc, NULL_TREE, NULL_TREE, 0);\n+  newrhs = convert_for_assignment (location, lhstype, newrhs, rhs_origtype,\n+\t\t\t\t   ic_assign, npc, NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n \n@@ -4531,8 +4579,8 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (olhstype == TREE_TYPE (result))\n     return result;\n \n-  result = convert_for_assignment (olhstype, result, rhs_origtype, ic_assign,\n-\t\t\t\t   false, NULL_TREE, NULL_TREE, 0);\n+  result = convert_for_assignment (location, olhstype, result, rhs_origtype,\n+\t\t\t\t   ic_assign, false, NULL_TREE, NULL_TREE, 0);\n   protected_set_expr_location (result, location);\n   return result;\n }\n@@ -4552,9 +4600,10 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (tree type, tree rhs, tree origtype,\n-\t\t\tenum impl_conv errtype, bool null_pointer_constant,\n-\t\t\ttree fundecl, tree function, int parmnum)\n+convert_for_assignment (location_t location, tree type, tree rhs,\n+\t\t\ttree origtype, enum impl_conv errtype,\n+\t\t\tbool null_pointer_constant, tree fundecl,\n+\t\t\ttree function, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree orig_rhs = rhs;\n@@ -4764,7 +4813,7 @@ convert_for_assignment (tree type, tree rhs, tree origtype,\n \t\t Meanwhile, the lhs target must have all the qualifiers of\n \t\t the rhs.  */\n \t      if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t\t  || comp_target_types (memb_type, rhstype))\n+\t\t  || comp_target_types (location, memb_type, rhstype))\n \t\t{\n \t\t  /* If this type won't generate any warnings, use it.  */\n \t\t  if (TYPE_QUALS (ttl) == TYPE_QUALS (ttr)\n@@ -4912,7 +4961,7 @@ convert_for_assignment (tree type, tree rhs, tree origtype,\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n       if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t  || (target_cmp = comp_target_types (type, rhstype))\n+\t  || (target_cmp = comp_target_types (location, type, rhstype))\n \t  || is_opaque_pointer\n \t  || (c_common_unsigned_type (mvl)\n \t      == c_common_unsigned_type (mvr)))\n@@ -5596,7 +5645,8 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \n       /* Added to enable additional -Wmissing-format-attribute warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n-\tinside_init = convert_for_assignment (type, inside_init, origtype,\n+\tinside_init = convert_for_assignment (input_location, type,\n+\t\t\t\t\t      inside_init, origtype,\n \t\t\t\t\t      ic_init, null_pointer_constant,\n \t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n       return inside_init;\n@@ -5616,8 +5666,8 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \tinside_init = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n \t\t\t      inside_init);\n       inside_init\n-\t= convert_for_assignment (type, inside_init, origtype, ic_init,\n-\t\t\t\t  null_pointer_constant,\n+\t= convert_for_assignment (input_location, type, inside_init, origtype,\n+\t\t\t\t  ic_init, null_pointer_constant,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n       /* Check to see if we have already given an error message.  */\n@@ -7987,8 +8037,9 @@ c_finish_return (tree retval, tree origtype)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (valtype, retval, origtype, ic_return,\n-\t\t\t\t       npc, NULL_TREE, NULL_TREE, 0);\n+      tree t = convert_for_assignment (input_location, valtype, retval,\n+\t\t\t\t       origtype, ic_return, npc,\n+\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;\n \n@@ -8971,7 +9022,7 @@ build_binary_op (location_t location, enum tree_code code,\n       /* Subtraction of two similar pointers.\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n-\t  && comp_target_types (type0, type1))\n+\t  && comp_target_types (location, type0, type1))\n \t{\n \t  ret = pointer_diff (op0, op1);\n \t  goto return_build_binary_op;\n@@ -9199,7 +9250,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  /* Anything compares with void *.  void * compares with anything.\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n-\t  if (comp_target_types (type0, type1))\n+\t  if (comp_target_types (location, type0, type1))\n \t    result_type = common_pointer_type (type0, type1);\n \t  else if (VOID_TYPE_P (tt0))\n \t    {\n@@ -9268,7 +9319,7 @@ build_binary_op (location_t location, enum tree_code code,\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (comp_target_types (type0, type1))\n+\t  if (comp_target_types (location, type0, type1))\n \t    {\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))"}, {"sha": "064138bf9398299527c85b5d1d4dde904abf6bfc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -858,7 +858,7 @@ static tree rs6000_builtin_reciprocal (unsigned int, bool, bool);\n static tree rs6000_builtin_mask_for_load (void);\n static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n-static tree rs6000_builtin_conversion (enum tree_code, tree);\n+static tree rs6000_builtin_conversion (unsigned int, tree);\n static tree rs6000_builtin_vec_perm (tree, tree *);\n \n static void def_builtin (int, const char *, tree, int);\n@@ -2013,8 +2013,10 @@ rs6000_builtin_mask_for_load (void)\n    side of the conversion.\n    Return NULL_TREE if it is not available.  */\n static tree\n-rs6000_builtin_conversion (enum tree_code code, tree type)\n+rs6000_builtin_conversion (unsigned int tcode, tree type)\n {\n+  enum tree_code code = (enum tree_code) tcode;\n+\n   if (!TARGET_ALTIVEC)\n     return NULL_TREE;\n "}, {"sha": "110c1a075a462577fbcb263a150418d8f7c1f36a", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -1,3 +1,8 @@\n+2009-06-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_gimplify_expr): Change return type to int.\n+\t* objc-act.h: Update declaration.\n+\n 2009-06-08  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* objc-act.c (objc_init): Skip print_struct_values during"}, {"sha": "41ed41ee5ba08672e095ffc677f05a4342b8d89b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -9532,7 +9532,7 @@ objc_rewrite_function_call (tree function, tree first_param)\n    a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend or one\n    of its cousins).  */\n \n-enum gimplify_status\n+int\n objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   enum gimplify_status r0, r1;"}, {"sha": "fb929342b9993d5faf237a3a9ebd318ecbdcdf14", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for objc-act.c.\n-   Copyright (C) 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -31,7 +31,7 @@ bool objc_init (void);\n const char *objc_printable_name (tree, int);\n void objc_finish_file (void);\n tree objc_fold_obj_type_ref (tree, tree);\n-enum gimplify_status objc_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n+int objc_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n \n /* NB: The remaining public functions are prototyped in c-common.h, for the\n    benefit of stub-objc.c and objc-act.c.  */"}, {"sha": "91c29f0974b36b0fb7e930a9fc7369b1c48e34e6", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -398,7 +398,7 @@ default_invalid_within_doloop (const_rtx insn)\n /* Mapping of builtin functions to vectorized variants.  */\n \n tree\n-default_builtin_vectorized_function (enum built_in_function fn ATTRIBUTE_UNUSED,\n+default_builtin_vectorized_function (unsigned int fn ATTRIBUTE_UNUSED,\n \t\t\t\t     tree type_out ATTRIBUTE_UNUSED,\n \t\t\t\t     tree type_in ATTRIBUTE_UNUSED)\n {\n@@ -408,7 +408,7 @@ default_builtin_vectorized_function (enum built_in_function fn ATTRIBUTE_UNUSED,\n /* Vectorized conversion.  */\n \n tree\n-default_builtin_vectorized_conversion (enum tree_code code ATTRIBUTE_UNUSED,\n+default_builtin_vectorized_conversion (unsigned int code ATTRIBUTE_UNUSED,\n \t\t\t\t       tree type ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n@@ -417,7 +417,7 @@ default_builtin_vectorized_conversion (enum tree_code code ATTRIBUTE_UNUSED,\n /* Reciprocal.  */\n \n tree\n-default_builtin_reciprocal (enum built_in_function fn ATTRIBUTE_UNUSED,\n+default_builtin_reciprocal (unsigned int fn ATTRIBUTE_UNUSED,\n \t\t\t    bool md_fn ATTRIBUTE_UNUSED,\n \t\t\t    bool sqrt ATTRIBUTE_UNUSED)\n {"}, {"sha": "5d77ce5854b59cae0137ec969beaaa5cf21fbf29", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -66,12 +66,11 @@ extern bool default_fixed_point_supported_p (void);\n \n extern const char * default_invalid_within_doloop (const_rtx);\n \n-extern tree default_builtin_vectorized_function\n-  (enum built_in_function, tree, tree);\n+extern tree default_builtin_vectorized_function (unsigned int, tree, tree);\n \n-extern tree default_builtin_vectorized_conversion (enum tree_code, tree);\n+extern tree default_builtin_vectorized_conversion (unsigned int, tree);\n \n-extern tree default_builtin_reciprocal (enum built_in_function, bool, bool);\n+extern tree default_builtin_reciprocal (unsigned int, bool, bool);\n \n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);\n "}, {"sha": "7ac14c0badd3852bdd6a5236691eeeedf2041054", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -1,3 +1,7 @@\n+2009-06-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wcxx-compat-12.c: New testcase.\n+\n 2009-06-09  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/40334"}, {"sha": "a6094e183be73e52b9a23984afb17765c7141e0c", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-12.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744aa42faba7eedf82eaa6c7a636ca1eb1d0c272/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-12.c?ref=744aa42faba7eedf82eaa6c7a636ca1eb1d0c272", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+\n+enum E { A };\n+\n+enum E v;\n+unsigned int *p = &v;\t     /* { dg-warning \"incompatible in C\\[+\\]\\[+\\]\" } */\n+\n+void foo(unsigned int);\n+void (*pfn)(enum E) = &foo;  /* { dg-warning \"incompatible in C\\[+\\]\\[+\\]\" } */"}]}