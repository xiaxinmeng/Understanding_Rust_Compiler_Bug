{"sha": "d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "node_id": "C_kwDOANBUbNoAKGQyMjc4ZGExYzNjYjdiZjhiM2Q5NmM4NmRiZWYyOTgyYmY0Y2M1NGE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-20T14:19:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-21T09:06:57Z"}, "message": "[PR106967] frange: revamp relational operators for NANs.\n\nSince NANs can be inserted by other passes even for -ffinite-math-only,\nwe can't depend on the flag to determine if a NAN is a possiblity.\nInstead, we must explicitly check for them.\n\nIn the case of -ffinite-math-only, paths leading up to a NAN are\nundefined and can be considered unreachable.  I have audited all the\nrelational code and made sure we're handling the known NAN case before\nanything else, setting undefined when appropriate.\n\nIn the process, I revamped all the relational code handling NANs to\ncorrectly notice paths that are unreachable.\n\nThe basic structure for ordered relational operators (except != of\ncourse) is this:\n\n\tIf either operand is a known NAN, return FALSE.\n\n\tThe true side of a relop when one operand is a NAN is\n\tunreachable.\n\n\tOn the false side of a relop when one operand is a NAN, we\n\tknow nothing about the other operand.\n\nRegstrapped on x86-64 and ppc64le Linux.\nlapack testing on x86-64 with and without -ffinite-math-only.\n\n\tPR tree-optimization/106967\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (foperator_equal::fold_range): Adjust for NAN.\n\t(foperator_equal::op1_range): Same.\n\t(foperator_not_equal::fold_range): Same.\n\t(foperator_not_equal::op1_range): Same.\n\t(foperator_lt::fold_range): Same.\n\t(foperator_lt::op1_range): Same.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_le::fold_range): Same.\n\t(foperator_le::op1_range): Same.\n\t(foperator_le::op2_range): Same.\n\t(foperator_gt::fold_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\t(foperator_ge::fold_range): Same.\n\t(foperator_ge::op1_range): Same.\n\t(foperator_ge::op2_range): Same.\n\t(foperator_unordered::op1_range): Same.\n\t(foperator_ordered::fold_range): Same.\n\t(foperator_ordered::op1_range): Same.\n\t(build_le): Assert that we don't have a NAN.\n\t(build_lt): Same.\n\t(build_gt): Same.\n\t(build_ge): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr106967.c: New test.", "tree": {"sha": "bc0bd39f8caa2202ec73ca9e4bf8cd4655c2c4b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc0bd39f8caa2202ec73ca9e4bf8cd4655c2c4b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce8aed75a38b468490ecab4c318e3eb08d468608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce8aed75a38b468490ecab4c318e3eb08d468608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce8aed75a38b468490ecab4c318e3eb08d468608"}], "stats": {"total": 286, "additions": 193, "deletions": 93}, "files": [{"sha": "2bd3dc9253fa41e468e67cfa63a1f76be9aae70c", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 177, "deletions": 93, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "patch": "@@ -230,11 +230,8 @@ frange_add_zeros (frange &r, tree type)\n static bool\n build_le (frange &r, tree type, const frange &val)\n {\n-  if (val.known_isnan ())\n-    {\n-      r.set_undefined ();\n-      return false;\n-    }\n+  gcc_checking_assert (!val.known_isnan ());\n+\n   r.set (type, dconstninf, val.upper_bound ());\n \n   // Add both zeros if there's the possibility of zero equality.\n@@ -248,11 +245,8 @@ build_le (frange &r, tree type, const frange &val)\n static bool\n build_lt (frange &r, tree type, const frange &val)\n {\n-  if (val.known_isnan ())\n-    {\n-      r.set_undefined ();\n-      return false;\n-    }\n+  gcc_checking_assert (!val.known_isnan ());\n+\n   // < -INF is outside the range.\n   if (real_isinf (&val.upper_bound (), 1))\n     {\n@@ -272,11 +266,8 @@ build_lt (frange &r, tree type, const frange &val)\n static bool\n build_ge (frange &r, tree type, const frange &val)\n {\n-  if (val.known_isnan ())\n-    {\n-      r.set_undefined ();\n-      return false;\n-    }\n+  gcc_checking_assert (!val.known_isnan ());\n+\n   r.set (type, val.lower_bound (), dconstinf);\n \n   // Add both zeros if there's the possibility of zero equality.\n@@ -290,11 +281,8 @@ build_ge (frange &r, tree type, const frange &val)\n static bool\n build_gt (frange &r, tree type, const frange &val)\n {\n-  if (val.known_isnan ())\n-    {\n-      r.set_undefined ();\n-      return false;\n-    }\n+  gcc_checking_assert (!val.known_isnan ());\n+\n   // > +INF is outside the range.\n   if (real_isinf (&val.lower_bound (), 0))\n     {\n@@ -365,9 +353,11 @@ foperator_equal::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_EQ))\n     return true;\n \n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_false (type);\n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n-  if (op1.singleton_p () && op2.singleton_p ())\n+  else if (op1.singleton_p () && op2.singleton_p ())\n     {\n       if (op1 == op2)\n \tr = range_true (type);\n@@ -393,25 +383,33 @@ foperator_equal::fold_range (irange &r, tree type,\n bool\n foperator_equal::op1_range (frange &r, tree type,\n \t\t\t    const irange &lhs,\n-\t\t\t    const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t    const frange &op2,\n \t\t\t    relation_kind rel) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      // If it's true, the result is the same as OP2.\n-      r = op2;\n-      // Add both zeros if there's the possibility of zero equality.\n-      frange_add_zeros (r, type);\n-      // The TRUE side of op1 == op2 implies op1 is !NAN.\n-      r.clear_nan ();\n+      // The TRUE side of x == NAN is unreachable.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  // If it's true, the result is the same as OP2.\n+\t  r = op2;\n+\t  // Add both zeros if there's the possibility of zero equality.\n+\t  frange_add_zeros (r, type);\n+\t  // The TRUE side of op1 == op2 implies op1 is !NAN.\n+\t  r.clear_nan ();\n+\t}\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n       // The FALSE side of op1 == op1 implies op1 is a NAN.\n       if (rel == VREL_EQ)\n \tr.set_nan (type);\n+      // On the FALSE side of x == NAN, we know nothing about x.\n+      else if (op2.known_isnan ())\n+\tr.set_varying (type);\n       // If the result is false, the only time we know anything is\n       // if OP2 is a constant.\n       else if (op2.singleton_p ()\n@@ -420,6 +418,8 @@ foperator_equal::op1_range (frange &r, tree type,\n \t  REAL_VALUE_TYPE tmp = op2.lower_bound ();\n \t  r.set (type, tmp, tmp, VR_ANTI_RANGE);\n \t}\n+      else\n+\tr.set_varying (type);\n       break;\n \n     default:\n@@ -453,9 +453,12 @@ foperator_not_equal::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_NE))\n     return true;\n \n+  // x != NAN is always TRUE.\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_true (type);\n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n-  if (op1.singleton_p () && op2.singleton_p ())\n+  else if (op1.singleton_p () && op2.singleton_p ())\n     {\n       if (op1 != op2)\n \tr = range_true (type);\n@@ -481,7 +484,7 @@ foperator_not_equal::fold_range (irange &r, tree type,\n bool\n foperator_not_equal::op1_range (frange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\tconst frange &op2,\n \t\t\t\trelation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n@@ -502,12 +505,18 @@ foperator_not_equal::op1_range (frange &r, tree type,\n       break;\n \n     case BRS_FALSE:\n-      // If it's false, the result is the same as OP2.\n-      r = op2;\n-      // Add both zeros if there's the possibility of zero equality.\n-      frange_add_zeros (r, type);\n-      // The FALSE side of op1 != op2 implies op1 is !NAN.\n-      r.clear_nan ();\n+      // The FALSE side of x != NAN is impossible.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  // If it's false, the result is the same as OP2.\n+\t  r = op2;\n+\t  // Add both zeros if there's the possibility of zero equality.\n+\t  frange_add_zeros (r, type);\n+\t  // The FALSE side of op1 != op2 implies op1 is !NAN.\n+\t  r.clear_nan ();\n+\t}\n       break;\n \n     default:\n@@ -545,7 +554,9 @@ foperator_lt::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n     return true;\n \n-  if (finite_operands_p (op1, op2))\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_false (type);\n+  else if (finite_operands_p (op1, op2))\n     {\n       if (real_less (&op1.upper_bound (), &op2.lower_bound ()))\n \tr = range_true (type);\n@@ -555,8 +566,6 @@ foperator_lt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_isnan () || op2.known_isnan ())\n-    r = range_false (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -566,13 +575,16 @@ bool\n foperator_lt::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op2,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_lt (r, type, op2))\n+      // The TRUE side of x < NAN is unreachable.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_lt (r, type, op2))\n \t{\n \t  r.clear_nan ();\n \t  // x < y implies x is not +INF.\n@@ -581,7 +593,11 @@ foperator_lt::op1_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_ge (r, type, op2);\n+      // On the FALSE side of x < NAN, we know nothing about x.\n+      if (op2.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_ge (r, type, op2);\n       break;\n \n     default:\n@@ -594,13 +610,16 @@ bool\n foperator_lt::op2_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op1,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_gt (r, type, op1))\n+      // The TRUE side of NAN < x is unreachable.\n+      if (op1.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_gt (r, type, op1))\n \t{\n \t  r.clear_nan ();\n \t  // x < y implies y is not -INF.\n@@ -609,7 +628,11 @@ foperator_lt::op2_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_le (r, type, op1);\n+      // On the FALSE side of NAN < x, we know nothing about x.\n+      if (op1.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_le (r, type, op1);\n       break;\n \n     default:\n@@ -647,7 +670,9 @@ foperator_le::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n     return true;\n \n-  if (finite_operands_p (op1, op2))\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_false (type);\n+  else if (finite_operands_p (op1, op2))\n     {\n       if (real_compare (LE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n \tr = range_true (type);\n@@ -657,8 +682,6 @@ foperator_le::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_isnan () || op2.known_isnan ())\n-    r = range_false (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -674,12 +697,19 @@ foperator_le::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_le (r, type, op2))\n+      // The TRUE side of x <= NAN is unreachable.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_le (r, type, op2))\n \tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_gt (r, type, op2);\n+      // On the FALSE side of x <= NAN, we know nothing about x.\n+      if (op2.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_gt (r, type, op2);\n       break;\n \n     default:\n@@ -698,12 +728,19 @@ foperator_le::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_ge (r, type, op1))\n+      // The TRUE side of NAN <= x is unreachable.\n+      if (op1.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_ge (r, type, op1))\n \tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_lt (r, type, op1);\n+      // On the FALSE side of NAN <= x, we know nothing about x.\n+      if (op1.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_lt (r, type, op1);\n       break;\n \n     default:\n@@ -741,7 +778,9 @@ foperator_gt::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n     return true;\n \n-  if (finite_operands_p (op1, op2))\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_false (type);\n+  else if (finite_operands_p (op1, op2))\n     {\n       if (real_compare (GT_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n \tr = range_true (type);\n@@ -751,8 +790,6 @@ foperator_gt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_isnan () || op2.known_isnan ())\n-    r = range_false (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -762,13 +799,16 @@ bool\n foperator_gt::op1_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op2,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_gt (r, type, op2))\n+      // The TRUE side of x > NAN is unreachable.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_gt (r, type, op2))\n \t{\n \t  r.clear_nan ();\n \t  // x > y implies x is not -INF.\n@@ -777,7 +817,11 @@ foperator_gt::op1_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_le (r, type, op2);\n+      // On the FALSE side of x > NAN, we know nothing about x.\n+      if (op2.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_le (r, type, op2);\n       break;\n \n     default:\n@@ -790,13 +834,16 @@ bool\n foperator_gt::op2_range (frange &r,\n \t\t\t tree type,\n \t\t\t const irange &lhs,\n-\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t const frange &op1,\n \t\t\t relation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_lt (r, type, op1))\n+      // The TRUE side of NAN > x is unreachable.\n+      if (op1.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_lt (r, type, op1))\n \t{\n \t  r.clear_nan ();\n \t  // x > y implies y is not +INF.\n@@ -805,7 +852,11 @@ foperator_gt::op2_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_ge (r, type, op1);\n+      // On The FALSE side of NAN > x, we know nothing about x.\n+      if (op1.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_ge (r, type, op1);\n       break;\n \n     default:\n@@ -843,7 +894,9 @@ foperator_ge::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n     return true;\n \n-  if (finite_operands_p (op1, op2))\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    r = range_false (type);\n+  else if (finite_operands_p (op1, op2))\n     {\n       if (real_compare (GE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n \tr = range_true (type);\n@@ -853,8 +906,6 @@ foperator_ge::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_isnan () || op2.known_isnan ())\n-    r = range_false (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -870,12 +921,19 @@ foperator_ge::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_ge (r, type, op2);\n-      r.clear_nan ();\n+      // The TRUE side of x >= NAN is unreachable.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else if (build_ge (r, type, op2))\n+\tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_lt (r, type, op2);\n+      // On the FALSE side of x >= NAN, we know nothing about x.\n+      if (op2.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_lt (r, type, op2);\n       break;\n \n     default:\n@@ -892,13 +950,23 @@ foperator_ge::op2_range (frange &r, tree type,\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n-    case BRS_FALSE:\n-      build_gt (r, type, op1);\n+    case BRS_TRUE:\n+      // The TRUE side of NAN >= x is unreachable.\n+      if (op1.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  build_le (r, type, op1);\n+\t  r.clear_nan ();\n+\t}\n       break;\n \n-    case BRS_TRUE:\n-      build_le (r, type, op1);\n-      r.clear_nan ();\n+    case BRS_FALSE:\n+      // On the FALSE side of NAN >= x, we know nothing about x.\n+      if (op1.known_isnan ())\n+\tr.set_varying (type);\n+      else\n+\tbuild_gt (r, type, op1);\n       break;\n \n     default:\n@@ -949,23 +1017,30 @@ foperator_unordered::fold_range (irange &r, tree type,\n bool\n foperator_unordered::op1_range (frange &r, tree type,\n \t\t\t\tconst irange &lhs,\n-\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\tconst frange &op2,\n \t\t\t\trelation_kind) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n       if (!op2.maybe_isnan ())\n \tr.set_nan (type);\n+      else\n+\tr.set_varying (type);\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n-      // A false UNORDERED means both operands are !NAN.\n-      r.clear_nan ();\n+      // A false UNORDERED means both operands are !NAN, so it's\n+      // impossible for op2 to be a NAN.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  r.set_varying (type);\n+\t  r.clear_nan ();\n+\t}\n       break;\n \n     default:\n@@ -1002,10 +1077,10 @@ foperator_ordered::fold_range (irange &r, tree type,\n \t\t\t       const frange &op1, const frange &op2,\n \t\t\t       relation_kind) const\n {\n-  if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n-    r = range_true (type);\n-  else if (op1.known_isnan () || op2.known_isnan ())\n+  if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n+  else if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n+    r = range_true (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -1014,15 +1089,21 @@ foperator_ordered::fold_range (irange &r, tree type,\n bool\n foperator_ordered::op1_range (frange &r, tree type,\n \t\t\t      const irange &lhs,\n-\t\t\t      const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t      const frange &op2,\n \t\t\t      relation_kind rel) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      r.set_varying (type);\n-      // The TRUE side of op1 ORDERED op2 implies op1 is !NAN.\n-      r.clear_nan ();\n+      // The TRUE side of ORDERED means both operands are !NAN, so\n+      // it's impossible for op2 to be a NAN.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  r.set_varying (type);\n+\t  r.clear_nan ();\n+\t}\n       break;\n \n     case BRS_FALSE:\n@@ -1046,13 +1127,16 @@ class foperator_relop_unknown : public range_operator_float\n \n public:\n   bool fold_range (irange &r, tree type,\n-\t\t   const frange &, const frange &,\n+\t\t   const frange &op1, const frange &op2,\n \t\t   relation_kind) const final override\n   {\n-    r.set_varying (type);\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      r = range_true (type);\n+    else\n+      r.set_varying (type);\n     return true;\n   }\n-} fop_relop_unknown;\n+} fop_unordered_relop_unknown;\n \n \n // Instantiate a range_op_table for floating point operations.\n@@ -1077,11 +1161,11 @@ floating_op_table::floating_op_table ()\n   set (LE_EXPR, fop_le);\n   set (GT_EXPR, fop_gt);\n   set (GE_EXPR, fop_ge);\n-  set (UNLE_EXPR, fop_relop_unknown);\n-  set (UNLT_EXPR, fop_relop_unknown);\n-  set (UNGE_EXPR, fop_relop_unknown);\n-  set (UNGT_EXPR, fop_relop_unknown);\n-  set (UNEQ_EXPR, fop_relop_unknown);\n+  set (UNLE_EXPR, fop_unordered_relop_unknown);\n+  set (UNLT_EXPR, fop_unordered_relop_unknown);\n+  set (UNGE_EXPR, fop_unordered_relop_unknown);\n+  set (UNGT_EXPR, fop_unordered_relop_unknown);\n+  set (UNEQ_EXPR, fop_unordered_relop_unknown);\n   set (ORDERED_EXPR, fop_ordered);\n   set (UNORDERED_EXPR, fop_unordered);\n }"}, {"sha": "bff27956f606357f490525a4065eafdd3713456c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr106967.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr106967.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr106967.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr106967.c?ref=d2278da1c3cb7bf8b3d96c86dbef2982bf4cc54a", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -ffinite-math-only -fno-trapping-math -fno-tree-dominator-opts\" }\n+\n+void\n+foo (float x, int *y)\n+{\n+  int i;\n+  float sum2 = 0.0;\n+\n+  for (i = 0; i < *y; ++i)\n+    sum2 += x;\n+\n+  sum2 = 1.0 / sum2;\n+  if (sum2 * 0.0 < 5.E-5)\n+    *y = 0;\n+}"}]}