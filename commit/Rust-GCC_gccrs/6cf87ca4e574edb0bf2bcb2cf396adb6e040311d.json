{"sha": "6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmODdjYTRlNTc0ZWRiMGJmMmJjYjJjZjM5NmFkYjZlMDQwMzExZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-06-17T06:17:44Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-06-17T06:17:44Z"}, "message": "* cpplib.h, cpphash.h, cppcharset.c, cpperror.c, cppexp.c\n\t* cppfiles.c, cpphash.c, cppinit.c, cpplex.c, cpplib.c\n\t* cppmacro.c, cpppch.c, cpptrad.c, cppspec.c: Convert to\n\tISO C: new-style function declarations, no need for PARAMS,\n\tno special punctuation on indirect function calls, use string\n\tconstant concatenation where convenient.\n\nFrom-SVN: r68070", "tree": {"sha": "aba39e5edc2926935bd59dd4f66f9b3d59447d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba39e5edc2926935bd59dd4f66f9b3d59447d19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/comments", "author": null, "committer": null, "parents": [{"sha": "82620aaf0b59eead65b65bbaa3db5606df4027f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82620aaf0b59eead65b65bbaa3db5606df4027f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82620aaf0b59eead65b65bbaa3db5606df4027f9"}], "stats": {"total": 1866, "additions": 656, "deletions": 1210}, "files": [{"sha": "1bf43479c6b91c99943c4f1d07b6605d069d0a95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -1,3 +1,12 @@\n+2003-06-16  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cpplib.h, cpphash.h, cppcharset.c, cpperror.c, cppexp.c\n+\t* cppfiles.c, cpphash.c, cppinit.c, cpplex.c, cpplib.c\n+\t* cppmacro.c, cpppch.c, cpptrad.c, cppspec.c: Convert to\n+\tISO C: new-style function declarations, no need for PARAMS,\n+\tno special punctuation on indirect function calls, use string\n+\tconstant concatenation where convenient.\n+\n 2003-06-17  Andreas Jaeger  <aj@suse.de>\n \n \t* rtl.h: Remove declarations from coverage.h.\n@@ -16,11 +25,11 @@\n \t* config/sparc/aout.h, config/sparc/biarch64.h, config/sparc/elf.h,\n \tconfig/sparc/freebsd.h, config/sparc/linux.h, config/sparc/linux64.h,\n \tconfig/sparc/lite.h, config/sparc/litecoff.h, config/sparc/liteelf.h,\n-\tconfig/sparc/netbsd-elf.h, config/sparc/openbsd.h, \n+\tconfig/sparc/netbsd-elf.h, config/sparc/openbsd.h,\n \tconfig/sparc/rtemself.h, config/sparc/sol2-64.h,\n \tconfig/sparc/sol2-bi.h, config/sparc/sol2-gas-bi.h,\n \tconfig/sparc/sol2-gld-bi.h, config/sparc/sol2-gld.h,\n-\tconfig/sparc/sol2.h, config/sparc/sp64-aout.h, \n+\tconfig/sparc/sol2.h, config/sparc/sp64-aout.h,\n \tconfig/sparc/sp64-elf.h, config/sparc/sp86x-elf.h,\n \tconfig/sparc/sparc-protos.h, config/sparc/sysv4-only.h: Replace\n \t\"GNU compiler\", \"GNU CC\" with \"GCC\".\n@@ -82,7 +91,7 @@\n \t* builtin-attrs.def, builtin-attrs.def, builtins.c, cpplex.c,\n \tcpplib.c, gencheck.c, gengenrtl.c, machmode.def, protoize.c: Don't\n \tuse macros from \"symcat.h\", instead rely on ISO C.\n-\t\n+\n \t* system.h: Don't include \"symcat.h\".\n \t* configure.in (AC_C_STRINGIZE): Delete.\n \t* config.in, configure: Regenerate."}, {"sha": "f506ba2bc1bcb9347bae4a65bed2c43a8698694d", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -25,7 +25,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-static int ucn_valid_in_identifier PARAMS ((cpp_reader *, cppchar_t));\n+static int ucn_valid_in_identifier (cpp_reader *, cppchar_t);\n \n /* [lex.charset]: The character designated by the universal character\n    name \\UNNNNNNNN is that character whose character short name in\n@@ -52,10 +52,7 @@ static int ucn_valid_in_identifier PARAMS ((cpp_reader *, cppchar_t));\n */\n \n cppchar_t\n-_cpp_valid_ucn (pfile, pstr, identifier_pos)\n-     cpp_reader *pfile;\n-     const uchar **pstr;\n-     int identifier_pos;\n+_cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr, int identifier_pos)\n {\n   cppchar_t result, c;\n   unsigned int length;\n@@ -128,9 +125,7 @@ _cpp_valid_ucn (pfile, pstr, identifier_pos)\n    identifier.  We assume C has already gone through the checks of\n    _cpp_valid_ucn.  */\n static int\n-ucn_valid_in_identifier (pfile, c)\n-     cpp_reader *pfile;\n-     cppchar_t c;\n+ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c)\n {\n   /* None of the valid chars are outside the Basic Multilingual Plane (the\n      low 16 bits).  */"}, {"sha": "cb681f00f247fbd3a2b15a4e789067d723ff5e1e", "filename": "gcc/cpperror.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -31,16 +31,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_location PARAMS ((cpp_reader *, unsigned int, unsigned int));\n+static void print_location (cpp_reader *, unsigned int, unsigned int);\n \n /* Print the logical file location (LINE, COL) in preparation for a\n    diagnostic.  Outputs the #include chain if it has changed.  A line\n    of zero suppresses the include stack, and outputs the program name\n    instead.  */\n static void\n-print_location (pfile, line, col)\n-     cpp_reader *pfile;\n-     unsigned int line, col;\n+print_location (cpp_reader *pfile, unsigned int line, unsigned int col)\n {\n   if (!pfile->buffer || line == 0)\n     fprintf (stderr, \"%s: \", progname);\n@@ -72,10 +70,8 @@ print_location (pfile, line, col)\n    the correct place by default.  Returns 0 if the error has been\n    suppressed.  */\n int\n-_cpp_begin_message (pfile, code, line, column)\n-     cpp_reader *pfile;\n-     int code;\n-     unsigned int line, column;\n+_cpp_begin_message (cpp_reader *pfile, int code, unsigned int line,\n+\t\t    unsigned int column)\n {\n   int level = DL_EXTRACT (code);\n \n@@ -177,10 +173,7 @@ cpp_error_with_line (cpp_reader *pfile, int level,\n }\n \n void\n-cpp_errno (pfile, level, msgid)\n-     cpp_reader *pfile;\n-     int level;\n-     const char *msgid;\n+cpp_errno (cpp_reader *pfile, int level, const char *msgid)\n {\n   if (msgid[0] == '\\0')\n     msgid = _(\"stdout\");"}, {"sha": "16082efd5e224a56e1bd3ba9c59aa81e77af836e", "filename": "gcc/cppexp.c", "status": "modified", "additions": 58, "deletions": 115, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -40,34 +40,31 @@ struct op\n /* Some simple utility routines on double integers.  */\n #define num_zerop(num) ((num.low | num.high) == 0)\n #define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)\n-static bool num_positive PARAMS ((cpp_num, size_t));\n-static bool num_greater_eq PARAMS ((cpp_num, cpp_num, size_t));\n-static cpp_num num_trim PARAMS ((cpp_num, size_t));\n-static cpp_num num_part_mul PARAMS ((cpp_num_part, cpp_num_part));\n-\n-static cpp_num num_unary_op PARAMS ((cpp_reader *, cpp_num, enum cpp_ttype));\n-static cpp_num num_binary_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t      enum cpp_ttype));\n-static cpp_num num_negate PARAMS ((cpp_num, size_t));\n-static cpp_num num_bitwise_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t       enum cpp_ttype));\n-static cpp_num num_inequality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t\t  enum cpp_ttype));\n-static cpp_num num_equality_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t\tenum cpp_ttype));\n-static cpp_num num_mul PARAMS ((cpp_reader *, cpp_num, cpp_num));\n-static cpp_num num_div_op PARAMS ((cpp_reader *, cpp_num, cpp_num,\n-\t\t\t\t   enum cpp_ttype));\n-static cpp_num num_lshift PARAMS ((cpp_num, size_t, size_t));\n-static cpp_num num_rshift PARAMS ((cpp_num, size_t, size_t));\n-\n-static cpp_num append_digit PARAMS ((cpp_num, int, int, size_t));\n-static cpp_num parse_defined PARAMS ((cpp_reader *));\n-static cpp_num eval_token PARAMS ((cpp_reader *, const cpp_token *));\n-static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n-static unsigned int interpret_float_suffix PARAMS ((const uchar *, size_t));\n-static unsigned int interpret_int_suffix PARAMS ((const uchar *, size_t));\n-static void check_promotion PARAMS ((cpp_reader *, const struct op *));\n+static bool num_positive (cpp_num, size_t);\n+static bool num_greater_eq (cpp_num, cpp_num, size_t);\n+static cpp_num num_trim (cpp_num, size_t);\n+static cpp_num num_part_mul (cpp_num_part, cpp_num_part);\n+\n+static cpp_num num_unary_op (cpp_reader *, cpp_num, enum cpp_ttype);\n+static cpp_num num_binary_op (cpp_reader *, cpp_num, cpp_num, enum cpp_ttype);\n+static cpp_num num_negate (cpp_num, size_t);\n+static cpp_num num_bitwise_op (cpp_reader *, cpp_num, cpp_num, enum cpp_ttype);\n+static cpp_num num_inequality_op (cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\t  enum cpp_ttype);\n+static cpp_num num_equality_op (cpp_reader *, cpp_num, cpp_num,\n+\t\t\t\tenum cpp_ttype);\n+static cpp_num num_mul (cpp_reader *, cpp_num, cpp_num);\n+static cpp_num num_div_op (cpp_reader *, cpp_num, cpp_num, enum cpp_ttype);\n+static cpp_num num_lshift (cpp_num, size_t, size_t);\n+static cpp_num num_rshift (cpp_num, size_t, size_t);\n+\n+static cpp_num append_digit (cpp_num, int, int, size_t);\n+static cpp_num parse_defined (cpp_reader *);\n+static cpp_num eval_token (cpp_reader *, const cpp_token *);\n+static struct op *reduce (cpp_reader *, struct op *, enum cpp_ttype);\n+static unsigned int interpret_float_suffix (const uchar *, size_t);\n+static unsigned int interpret_int_suffix (const uchar *, size_t);\n+static void check_promotion (cpp_reader *, const struct op *);\n \n /* Token type abuse to create unary plus and minus operators.  */\n #define CPP_UPLUS (CPP_LAST_CPP_OP + 1)\n@@ -84,9 +81,7 @@ static void check_promotion PARAMS ((cpp_reader *, const struct op *));\n    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a\n    flag vector describing the suffix.  */\n static unsigned int\n-interpret_float_suffix (s, len)\n-     const uchar *s;\n-     size_t len;\n+interpret_float_suffix (const uchar *s, size_t len)\n {\n   size_t f = 0, l = 0, i = 0;\n \n@@ -113,9 +108,7 @@ interpret_float_suffix (s, len)\n    of length LEN, possibly zero. Returns 0 for an invalid suffix, or a\n    flag vector describing the suffix.  */\n static unsigned int\n-interpret_int_suffix (s, len)\n-     const uchar *s;\n-     size_t len;\n+interpret_int_suffix (const uchar *s, size_t len)\n {\n   size_t u, l, i;\n \n@@ -149,9 +142,7 @@ interpret_int_suffix (s, len)\n    floating point, or invalid), radix (decimal, octal, hexadecimal),\n    and type suffixes.  */\n unsigned int\n-cpp_classify_number (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n+cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n {\n   const uchar *str = token->val.str.text;\n   const uchar *limit;\n@@ -314,13 +305,11 @@ cpp_classify_number (pfile, token)\n    of precision options->precision.\n \n    We do not provide any interface for decimal->float conversion,\n-   because the preprocessor doesn't need it and the floating point\n-   handling in GCC proper is too ugly to speak of.  */\n+   because the preprocessor doesn't need it and we don't want to\n+   drag in GCC's floating point emulator.  */\n cpp_num\n-cpp_interpret_integer (pfile, token, type)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-     unsigned int type;\n+cpp_interpret_integer (cpp_reader *pfile, const cpp_token *token,\n+\t\t       unsigned int type)\n {\n   const uchar *p, *end;\n   cpp_num result;\n@@ -403,13 +392,9 @@ cpp_interpret_integer (pfile, token, type)\n   return result;\n }\n \n-/* Append DIGIT to NUM, a number of PRECISION bits being read in base\n-   BASE.  */\n+/* Append DIGIT to NUM, a number of PRECISION bits being read in base BASE.  */\n static cpp_num\n-append_digit (num, digit, base, precision)\n-     cpp_num num;\n-     int digit, base;\n-     size_t precision;\n+append_digit (cpp_num num, int digit, int base, size_t precision)\n {\n   cpp_num result;\n   unsigned int shift = 3 + (base == 16);\n@@ -458,8 +443,7 @@ append_digit (num, digit, base, precision)\n \n /* Handle meeting \"defined\" in a preprocessor expression.  */\n static cpp_num\n-parse_defined (pfile)\n-     cpp_reader *pfile;\n+parse_defined (cpp_reader *pfile)\n {\n   cpp_num result;\n   int paren = 0;\n@@ -529,9 +513,7 @@ parse_defined (pfile)\n    number or character constant, or the result of the \"defined\" or \"#\"\n    operators).  */\n static cpp_num\n-eval_token (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n+eval_token (cpp_reader *pfile, const cpp_token *token)\n {\n   cpp_num result;\n   unsigned int temp;\n@@ -695,8 +677,7 @@ static const struct operator\n    stored in the 'value' field of the stack element of the operator\n    that precedes it.  */\n bool\n-_cpp_parse_expr (pfile)\n-     cpp_reader *pfile;\n+_cpp_parse_expr (cpp_reader *pfile)\n {\n   struct op *top = pfile->op_stack;\n   unsigned int lex_count;\n@@ -838,10 +819,7 @@ _cpp_parse_expr (pfile)\n    pushing operator OP.  Returns NULL on error, otherwise the top of\n    the stack.  */\n static struct op *\n-reduce (pfile, top, op)\n-     cpp_reader *pfile;\n-     struct op *top;\n-     enum cpp_ttype op;\n+reduce (cpp_reader *pfile, struct op *top, enum cpp_ttype op)\n {\n   unsigned int prio;\n \n@@ -985,8 +963,7 @@ reduce (pfile, top, op)\n \n /* Returns the position of the old top of stack after expansion.  */\n struct op *\n-_cpp_expand_op_stack (pfile)\n-     cpp_reader *pfile;\n+_cpp_expand_op_stack (cpp_reader *pfile)\n {\n   size_t old_size = (size_t) (pfile->op_limit - pfile->op_stack);\n   size_t new_size = old_size * 2 + 20;\n@@ -1001,9 +978,7 @@ _cpp_expand_op_stack (pfile)\n /* Emits a warning if the effective sign of either operand of OP\n    changes because of integer promotions.  */\n static void\n-check_promotion (pfile, op)\n-     cpp_reader *pfile;\n-     const struct op *op;\n+check_promotion (cpp_reader *pfile, const struct op *op)\n {\n   if (op->value.unsignedp == op[-1].value.unsignedp)\n     return;\n@@ -1023,9 +998,7 @@ check_promotion (pfile, op)\n \n /* Clears the unused high order bits of the number pointed to by PNUM.  */\n static cpp_num\n-num_trim (num, precision)\n-     cpp_num num;\n-     size_t precision;\n+num_trim (cpp_num num, size_t precision)\n {\n   if (precision > PART_PRECISION)\n     {\n@@ -1045,9 +1018,7 @@ num_trim (num, precision)\n \n /* True iff A (presumed signed) >= 0.  */\n static bool\n-num_positive (num, precision)\n-     cpp_num num;\n-     size_t precision;\n+num_positive (cpp_num num, size_t precision)\n {\n   if (precision > PART_PRECISION)\n     {\n@@ -1061,9 +1032,7 @@ num_positive (num, precision)\n /* Sign extend a number, with PRECISION significant bits and all\n    others assumed clear, to fill out a cpp_num structure.  */\n cpp_num\n-cpp_num_sign_extend (num, precision)\n-     cpp_num num;\n-     size_t precision;\n+cpp_num_sign_extend (cpp_num num, size_t precision)\n {\n   if (!num.unsignedp)\n     {\n@@ -1087,9 +1056,7 @@ cpp_num_sign_extend (num, precision)\n \n /* Returns the negative of NUM.  */\n static cpp_num\n-num_negate (num, precision)\n-     cpp_num num;\n-     size_t precision;\n+num_negate (cpp_num num, size_t precision)\n {\n   cpp_num copy;\n \n@@ -1106,9 +1073,7 @@ num_negate (num, precision)\n \n /* Returns true if A >= B.  */\n static bool\n-num_greater_eq (pa, pb, precision)\n-     cpp_num pa, pb;\n-     size_t precision;\n+num_greater_eq (cpp_num pa, cpp_num pb, size_t precision)\n {\n   bool unsignedp;\n \n@@ -1131,10 +1096,8 @@ num_greater_eq (pa, pb, precision)\n \n /* Returns LHS OP RHS, where OP is a bit-wise operation.  */\n static cpp_num\n-num_bitwise_op (pfile, lhs, rhs, op)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_num lhs, rhs;\n-     enum cpp_ttype op;\n+num_bitwise_op (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\tcpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n {\n   lhs.overflow = false;\n   lhs.unsignedp = lhs.unsignedp || rhs.unsignedp;\n@@ -1162,10 +1125,8 @@ num_bitwise_op (pfile, lhs, rhs, op)\n \n /* Returns LHS OP RHS, where OP is an inequality.  */\n static cpp_num\n-num_inequality_op (pfile, lhs, rhs, op)\n-     cpp_reader *pfile;\n-     cpp_num lhs, rhs;\n-     enum cpp_ttype op;\n+num_inequality_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs,\n+\t\t   enum cpp_ttype op)\n {\n   bool gte = num_greater_eq (lhs, rhs, CPP_OPTION (pfile, precision));\n \n@@ -1186,10 +1147,8 @@ num_inequality_op (pfile, lhs, rhs, op)\n \n /* Returns LHS OP RHS, where OP is == or !=.  */\n static cpp_num\n-num_equality_op (pfile, lhs, rhs, op)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_num lhs, rhs;\n-     enum cpp_ttype op;\n+num_equality_op (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\t cpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n {\n   /* Work around a 3.0.4 bug; see PR 6950.  */\n   bool eq = num_eq (lhs, rhs);\n@@ -1204,9 +1163,7 @@ num_equality_op (pfile, lhs, rhs, op)\n \n /* Shift NUM, of width PRECISION, right by N bits.  */\n static cpp_num\n-num_rshift (num, precision, n)\n-     cpp_num num;\n-     size_t precision, n;\n+num_rshift (cpp_num num, size_t precision, size_t n)\n {\n   cpp_num_part sign_mask;\n \n@@ -1246,9 +1203,7 @@ num_rshift (num, precision, n)\n \n /* Shift NUM, of width PRECISION, left by N bits.  */\n static cpp_num\n-num_lshift (num, precision, n)\n-     cpp_num num;\n-     size_t precision, n;\n+num_lshift (cpp_num num, size_t precision, size_t n)\n {\n   if (n >= precision)\n     {\n@@ -1288,10 +1243,7 @@ num_lshift (num, precision, n)\n \n /* The four unary operators: +, -, ! and ~.  */\n static cpp_num\n-num_unary_op (pfile, num, op)\n-     cpp_reader *pfile;\n-     cpp_num num;\n-     enum cpp_ttype op;\n+num_unary_op (cpp_reader *pfile, cpp_num num, enum cpp_ttype op)\n {\n   switch (op)\n     {\n@@ -1326,10 +1278,7 @@ num_unary_op (pfile, num, op)\n \n /* The various binary operators.  */\n static cpp_num\n-num_binary_op (pfile, lhs, rhs, op)\n-     cpp_reader *pfile;\n-     cpp_num lhs, rhs;\n-     enum cpp_ttype op;\n+num_binary_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n {\n   cpp_num result;\n   size_t precision = CPP_OPTION (pfile, precision);\n@@ -1411,8 +1360,7 @@ num_binary_op (pfile, lhs, rhs, op)\n /* Multiplies two unsigned cpp_num_parts to give a cpp_num.  This\n    cannot overflow.  */\n static cpp_num\n-num_part_mul (lhs, rhs)\n-     cpp_num_part lhs, rhs;\n+num_part_mul (cpp_num_part lhs, cpp_num_part rhs)\n {\n   cpp_num result;\n   cpp_num_part middle[2], temp;\n@@ -1442,9 +1390,7 @@ num_part_mul (lhs, rhs)\n \n /* Multiply two preprocessing numbers.  */\n static cpp_num\n-num_mul (pfile, lhs, rhs)\n-     cpp_reader *pfile;\n-     cpp_num lhs, rhs;\n+num_mul (cpp_reader *pfile, cpp_num lhs, cpp_num rhs)\n {\n   cpp_num result, temp;\n   bool unsignedp = lhs.unsignedp || rhs.unsignedp;\n@@ -1494,10 +1440,7 @@ num_mul (pfile, lhs, rhs)\n /* Divide two preprocessing numbers, returning the answer or the\n    remainder depending upon OP.  */\n static cpp_num\n-num_div_op (pfile, lhs, rhs, op)\n-     cpp_reader *pfile;\n-     cpp_num lhs, rhs;\n-     enum cpp_ttype op;\n+num_div_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op)\n {\n   cpp_num result, sub;\n   cpp_num_part mask;"}, {"sha": "cd6fd6cfef640e940bcfb556f0df20d88546d4ff", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 55, "deletions": 120, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -86,31 +86,24 @@ struct include_file {\n #define NO_INCLUDE_PATH ((struct include_file *) -1)\n #define INCLUDE_PCH_P(F) (((F)->pch & 1) != 0)\n \n-static struct file_name_map *read_name_map\n-\t\t\t\tPARAMS ((cpp_reader *, const char *));\n-static char *read_filename_string PARAMS ((int, FILE *));\n-static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n-\t\t\t\t\t struct cpp_path *));\n-static struct cpp_path *search_from PARAMS ((cpp_reader *,\n-\t\t\t\t\t\tenum include_type));\n-static struct include_file *\n-\tfind_include_file PARAMS ((cpp_reader *, const char *, int,\n-\t\t\t\t   enum include_type));\n-static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n-static struct include_file *validate_pch PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t  const char *,\n-\t\t\t\t\t\t  const char *));\n-static struct include_file *open_file_pch PARAMS ((cpp_reader *, \n-\t\t\t\t\t\t   const char *));\n-static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n-static bool stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n-static void purge_cache \tPARAMS ((struct include_file *));\n-static void destroy_node\tPARAMS ((splay_tree_value));\n-static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n-static splay_tree_node find_or_create_entry PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t     const char *));\n-static void handle_missing_header PARAMS ((cpp_reader *, const char *, int));\n-static int remove_component_p PARAMS ((const char *));\n+static struct file_name_map *read_name_map (cpp_reader *, const char *);\n+static char *read_filename_string (int, FILE *);\n+static char *remap_filename (cpp_reader *, char *, struct cpp_path *);\n+static struct cpp_path *search_from (cpp_reader *, enum include_type);\n+static struct include_file *find_include_file (cpp_reader *, const char *,\n+\t\t\t\t\t       int, enum include_type);\n+static struct include_file *open_file (cpp_reader *, const char *);\n+static struct include_file *validate_pch (cpp_reader *, const char *,\n+\t\t\t\t\t  const char *);\n+static struct include_file *open_file_pch (cpp_reader *, const char *);\n+static int read_include_file (cpp_reader *, struct include_file *);\n+static bool stack_include_file (cpp_reader *, struct include_file *);\n+static void purge_cache (struct include_file *);\n+static void destroy_node (splay_tree_value);\n+static int report_missing_guard (splay_tree_node, void *);\n+static splay_tree_node find_or_create_entry (cpp_reader *, const char *);\n+static void handle_missing_header (cpp_reader *, const char *, int);\n+static int remove_component_p (const char *);\n \n /* Set up the splay tree we use to store information about all the\n    file names seen in this compilation.  We also have entries for each\n@@ -125,8 +118,7 @@ static int remove_component_p PARAMS ((const char *));\n    A node's value is a pointer to a struct include_file, and is never\n    NULL.  */\n void\n-_cpp_init_includes (pfile)\n-     cpp_reader *pfile;\n+_cpp_init_includes (cpp_reader *pfile)\n {\n   pfile->all_include_files\n     = splay_tree_new ((splay_tree_compare_fn) strcmp,\n@@ -136,16 +128,14 @@ _cpp_init_includes (pfile)\n \n /* Tear down the splay tree.  */\n void\n-_cpp_cleanup_includes (pfile)\n-     cpp_reader *pfile;\n+_cpp_cleanup_includes (cpp_reader *pfile)\n {\n   splay_tree_delete (pfile->all_include_files);\n }\n \n /* Free a node.  The path string is automatically freed.  */\n static void\n-destroy_node (v)\n-     splay_tree_value v;\n+destroy_node (splay_tree_value v)\n {\n   struct include_file *f = (struct include_file *) v;\n \n@@ -158,18 +148,15 @@ destroy_node (v)\n \n /* Mark a file to not be reread (e.g. #import, read failure).  */\n void\n-_cpp_never_reread (file)\n-     struct include_file *file;\n+_cpp_never_reread (struct include_file *file)\n {\n   file->cmacro = NEVER_REREAD;\n }\n \n /* Lookup a filename, which is simplified after making a copy, and\n    create an entry if none exists.  */\n static splay_tree_node\n-find_or_create_entry (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n+find_or_create_entry (cpp_reader *pfile, const char *fname)\n {\n   splay_tree_node node;\n   struct include_file *file;\n@@ -197,9 +184,7 @@ find_or_create_entry (pfile, fname)\n \n /* Enter a file name in the splay tree, for the sake of cpp_included.  */\n void\n-_cpp_fake_include (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n+_cpp_fake_include (cpp_reader *pfile, const char *fname)\n {\n   find_or_create_entry (pfile, fname);\n }\n@@ -214,9 +199,7 @@ _cpp_fake_include (pfile, fname)\n    Returns an include_file structure with an open file descriptor on\n    success, or NULL on failure.  */\n static struct include_file *\n-open_file (pfile, filename)\n-     cpp_reader *pfile;\n-     const char *filename;\n+open_file (cpp_reader *pfile, const char *filename)\n {\n   splay_tree_node nd = find_or_create_entry (pfile, filename);\n   struct include_file *file = (struct include_file *) nd->value;\n@@ -281,10 +264,7 @@ open_file (pfile, filename)\n }\n \n static struct include_file *\n-validate_pch (pfile, filename, pchname)\n-     cpp_reader *pfile;\n-     const char *filename;\n-     const char *pchname;\n+validate_pch (cpp_reader *pfile, const char *filename, const char *pchname)\n {\n   struct include_file * file;\n   \n@@ -316,9 +296,7 @@ validate_pch (pfile, filename, pchname)\n /* Like open_file, but also look for a precompiled header if (a) one exists\n    and (b) it is valid.  */\n static struct include_file *\n-open_file_pch (pfile, filename)\n-     cpp_reader *pfile;\n-     const char *filename;\n+open_file_pch (cpp_reader *pfile, const char *filename)\n {\n   if (filename[0] != '\\0'\n       && pfile->cb.valid_pch != NULL)\n@@ -377,9 +355,7 @@ open_file_pch (pfile, filename)\n    because of e.g. multiple-include guards.  Returns true if a buffer\n    is stacked.  */\n static bool\n-stack_include_file (pfile, inc)\n-     cpp_reader *pfile;\n-     struct include_file *inc;\n+stack_include_file (cpp_reader *pfile, struct include_file *inc)\n {\n   cpp_buffer *fp;\n   int sysp;\n@@ -462,9 +438,7 @@ stack_include_file (pfile, inc)\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n static int\n-read_include_file (pfile, inc)\n-     cpp_reader *pfile;\n-     struct include_file *inc;\n+read_include_file (cpp_reader *pfile, struct include_file *inc)\n {\n   ssize_t size, offset, count;\n   uchar *buf;\n@@ -555,8 +529,7 @@ read_include_file (pfile, inc)\n \n /* Drop INC's buffer from memory.  */\n static void\n-purge_cache (inc)\n-     struct include_file *inc;\n+purge_cache (struct include_file *inc)\n {\n   if (inc->buffer)\n     {\n@@ -568,9 +541,7 @@ purge_cache (inc)\n /* Return 1 if the file named by FNAME has been included before in\n    any context, 0 otherwise.  */\n int\n-cpp_included (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n+cpp_included (cpp_reader *pfile, const char *fname)\n {\n   struct cpp_path *path;\n   char *name, *n;\n@@ -608,11 +579,8 @@ cpp_included (pfile, fname)\n    otherwise an include_file structure.  If this request originates\n    from a directive of TYPE #include_next, set INCLUDE_NEXT to true.  */\n static struct include_file *\n-find_include_file (pfile, fname, angle_brackets, type)\n-     cpp_reader *pfile;\n-     const char *fname;\n-     int angle_brackets;\n-     enum include_type type;\n+find_include_file (cpp_reader *pfile, const char *fname, int angle_brackets,\n+\t\t   enum include_type type)\n {\n   struct cpp_path *path;\n   struct include_file *file;\n@@ -676,9 +644,7 @@ find_include_file (pfile, fname, angle_brackets, type)\n    see the details of a buffer.  This is an exported interface because\n    fix-header needs it.  */\n void\n-cpp_make_system_header (pfile, syshdr, externc)\n-     cpp_reader *pfile;\n-     int syshdr, externc;\n+cpp_make_system_header (cpp_reader *pfile, int syshdr, int externc)\n {\n   int flags = 0;\n \n@@ -693,29 +659,24 @@ cpp_make_system_header (pfile, syshdr, externc)\n    to achieve pseudo-file names like <built-in>.\n    If REASON is LC_LEAVE, then NEW_NAME must be NULL.  */\n void\n-cpp_change_file (pfile, reason, new_name)\n-     cpp_reader *pfile;\n-     enum lc_reason reason;\n-     const char *new_name;\n+cpp_change_file (cpp_reader *pfile, enum lc_reason reason,\n+\t\t const char *new_name)\n {\n   _cpp_do_file_change (pfile, reason, new_name, 1, 0);\n }\n \n /* Report on all files that might benefit from a multiple include guard.\n    Triggered by -H.  */\n void\n-_cpp_report_missing_guards (pfile)\n-     cpp_reader *pfile;\n+_cpp_report_missing_guards (cpp_reader *pfile)\n {\n   int banner = 0;\n   splay_tree_foreach (pfile->all_include_files, report_missing_guard, &banner);\n }\n \n /* Callback function for splay_tree_foreach().  */\n static int\n-report_missing_guard (n, b)\n-     splay_tree_node n;\n-     void *b;\n+report_missing_guard (splay_tree_node n, void *b)\n {\n   struct include_file *f = (struct include_file *) n->value;\n   int *bannerp = (int *) b;\n@@ -737,10 +698,8 @@ report_missing_guard (n, b)\n    appropriate.  ANGLE_BRACKETS is nonzero if the file was bracketed\n    like <..>.  */\n static void\n-handle_missing_header (pfile, fname, angle_brackets)\n-     cpp_reader *pfile;\n-     const char *fname;\n-     int angle_brackets;\n+handle_missing_header (cpp_reader *pfile, const char *fname,\n+\t\t       int angle_brackets)\n {\n   bool print_dep\n     = CPP_OPTION (pfile, deps.style) > (angle_brackets || pfile->map->sysp);\n@@ -761,11 +720,8 @@ handle_missing_header (pfile, fname, angle_brackets)\n    including HEADER, and the command line -imacros and -include.\n    Returns true if a buffer was stacked.  */\n bool\n-_cpp_execute_include (pfile, fname, angle_brackets, type)\n-     cpp_reader *pfile;\n-     const char *fname;\n-     int angle_brackets;\n-     enum include_type type;\n+_cpp_execute_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n+\t\t      enum include_type type)\n {\n   bool stacked = false;\n   struct include_file *inc;\n@@ -788,10 +744,8 @@ _cpp_execute_include (pfile, fname, angle_brackets, type)\n    file.  If it cannot be located or dated, return -1, if it is newer\n    newer, return 1, otherwise 0.  */\n int\n-_cpp_compare_file_date (pfile, fname, angle_brackets)\n-     cpp_reader *pfile;\n-     const char *fname;\n-     int angle_brackets;\n+_cpp_compare_file_date (cpp_reader *pfile, const char *fname,\n+\t\t\tint angle_brackets)\n {\n   struct include_file *inc;\n \n@@ -813,9 +767,7 @@ _cpp_compare_file_date (pfile, fname, angle_brackets)\n    FNAME is \"\", read standard input.  Return true if a buffer was\n    stacked.  */\n bool\n-_cpp_read_file (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n+_cpp_read_file (cpp_reader *pfile, const char *fname)\n {\n   /* This uses open_file, because we don't allow a PCH to be used as\n      the toplevel compilation (that would prevent re-compiling an\n@@ -834,9 +786,7 @@ _cpp_read_file (pfile, fname)\n /* Pushes the given file onto the buffer stack.  Returns nonzero if\n    successful.  */\n bool\n-cpp_push_include (pfile, filename)\n-     cpp_reader *pfile;\n-     const char *filename;\n+cpp_push_include (cpp_reader *pfile, const char *filename)\n {\n   /* Make the command line directive take up a line.  */\n   pfile->line++;\n@@ -846,9 +796,7 @@ cpp_push_include (pfile, filename)\n /* Do appropriate cleanup when a file INC's buffer is popped off the\n    input stack.  */\n void\n-_cpp_pop_file_buffer (pfile, inc)\n-     cpp_reader *pfile;\n-     struct include_file *inc;\n+_cpp_pop_file_buffer (cpp_reader *pfile, struct include_file *inc)\n {\n   /* Record the inclusion-preventing macro, which could be NULL\n      meaning no controlling macro.  */\n@@ -868,9 +816,7 @@ _cpp_pop_file_buffer (pfile, inc)\n    If we're handling -include or -imacros, use the \"\" chain, but with\n    the preprocessor's cwd prepended.  */\n static struct cpp_path *\n-search_from (pfile, type)\n-     cpp_reader *pfile;\n-     enum include_type type;\n+search_from (cpp_reader *pfile, enum include_type type)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned int dlen;\n@@ -933,9 +879,7 @@ struct file_name_map {\n /* Read a space delimited string of unlimited length from a stdio\n    file F.  */\n static char *\n-read_filename_string (ch, f)\n-     int ch;\n-     FILE *f;\n+read_filename_string (int ch, FILE *f)\n {\n   char *alloc, *set;\n   int len;\n@@ -970,9 +914,7 @@ struct file_name_map_list {\n \n /* Read the file name map file for DIRNAME.  */\n static struct file_name_map *\n-read_name_map (pfile, dirname)\n-     cpp_reader *pfile;\n-     const char *dirname;\n+read_name_map (cpp_reader *pfile, const char *dirname)\n {\n   struct file_name_map_list *map_list_ptr;\n   char *name;\n@@ -1048,10 +990,7 @@ read_name_map (pfile, dirname)\n /* Remap an unsimplified path NAME based on the file_name_map (if any)\n    for LOC.  */\n static char *\n-remap_filename (pfile, name, loc)\n-     cpp_reader *pfile;\n-     char *name;\n-     struct cpp_path *loc;\n+remap_filename (cpp_reader *pfile, char *name, struct cpp_path *loc)\n {\n   struct file_name_map *map;\n   const char *from, *p;\n@@ -1106,10 +1045,8 @@ remap_filename (pfile, name, loc)\n \n    If BRACKET does not lie in the QUOTE chain, it is set to QUOTE.  */\n void\n-cpp_set_include_chains (pfile, quote, bracket, quote_ignores_source_dir)\n-     cpp_reader *pfile;\n-     cpp_path *quote, *bracket;\n-     int quote_ignores_source_dir;\n+cpp_set_include_chains (cpp_reader *pfile, cpp_path *quote, cpp_path *bracket,\n+\t\t\tint quote_ignores_source_dir)\n {\n   pfile->quote_include = quote;\n   pfile->bracket_include = quote;\n@@ -1132,8 +1069,7 @@ cpp_set_include_chains (pfile, quote, bracket, quote_ignores_source_dir)\n    symlinks if we have it.  If not, we can still catch errors with\n    stat ().  */\n static int\n-remove_component_p (path)\n-     const char *path;\n+remove_component_p (const char *path)\n {\n   struct stat s;\n   int result;\n@@ -1168,8 +1104,7 @@ remove_component_p (path)\n    of the string.  Returns PATH.  errno is 0 if no error occurred;\n    nonzero if an error occurred when using stat () or lstat ().  */\n void\n-cpp_simplify_path (path)\n-     char *path ATTRIBUTE_UNUSED;\n+cpp_simplify_path (char *path ATTRIBUTE_UNUSED)\n {\n #ifndef VMS\n   char *from, *to;"}, {"sha": "01cd0a41f26317a956ef070399a4e9e639935829", "filename": "gcc/cpphash.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -30,13 +30,12 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-static cpp_hashnode *alloc_node PARAMS ((hash_table *));\n+static cpp_hashnode *alloc_node (hash_table *);\n \n /* Return an identifier node for hashtable.c.  Used by cpplib except\n    when integrated with the C front ends.  */\n static cpp_hashnode *\n-alloc_node (table)\n-     hash_table *table;\n+alloc_node (hash_table *table)\n {\n   cpp_hashnode *node;\n \n@@ -49,17 +48,15 @@ alloc_node (table)\n /* Set up the identifier hash table.  Use TABLE if non-null, otherwise\n    create our own.  */\n void\n-_cpp_init_hashtable (pfile, table)\n-     cpp_reader *pfile;\n-     hash_table *table;\n+_cpp_init_hashtable (cpp_reader *pfile, hash_table *table)\n {\n   struct spec_nodes *s;\n \n   if (table == NULL)\n     {\n       pfile->our_hashtable = 1;\n       table = ht_create (13);\t/* 8K (=2^13) entries.  */\n-      table->alloc_node = (hashnode (*) PARAMS ((hash_table *))) alloc_node;\n+      table->alloc_node = (hashnode (*) (hash_table *)) alloc_node;\n       gcc_obstack_init (&pfile->hash_ob);\n     }\n \n@@ -80,8 +77,7 @@ _cpp_init_hashtable (pfile, table)\n \n /* Tear down the identifier hash table.  */\n void\n-_cpp_destroy_hashtable (pfile)\n-     cpp_reader *pfile;\n+_cpp_destroy_hashtable (cpp_reader *pfile)\n {\n   if (pfile->our_hashtable)\n     {\n@@ -93,21 +89,15 @@ _cpp_destroy_hashtable (pfile)\n /* Returns the hash entry for the STR of length LEN, creating one\n    if necessary.  */\n cpp_hashnode *\n-cpp_lookup (pfile, str, len)\n-     cpp_reader *pfile;\n-     const unsigned char *str;\n-     unsigned int len;\n+cpp_lookup (cpp_reader *pfile, const unsigned char *str, unsigned int len)\n {\n   /* ht_lookup cannot return NULL.  */\n   return CPP_HASHNODE (ht_lookup (pfile->hash_table, str, len, HT_ALLOC));\n }\n \n /* Determine whether the str STR, of length LEN, is a defined macro.  */\n int\n-cpp_defined (pfile, str, len)\n-     cpp_reader *pfile;\n-     const unsigned char *str;\n-     int len;\n+cpp_defined (cpp_reader *pfile, const unsigned char *str, int len)\n {\n   cpp_hashnode *node;\n \n@@ -120,10 +110,7 @@ cpp_defined (pfile, str, len)\n /* For all nodes in the hashtable, callback CB with parameters PFILE,\n    the node, and V.  */\n void\n-cpp_forall_identifiers (pfile, cb, v)\n-     cpp_reader *pfile;\n-     cpp_cb cb;\n-     void *v;\n+cpp_forall_identifiers (cpp_reader *pfile, cpp_cb cb, void *v)\n {\n   /* We don't need a proxy since the hash table's identifier comes\n      first in cpp_hashnode.  */"}, {"sha": "388d5c874528d1dc05b45b4d478eeec6ead3d460", "filename": "gcc/cpphash.h", "status": "modified", "additions": 75, "deletions": 97, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -117,14 +117,13 @@ struct _cpp_buff\n   unsigned char *base, *cur, *limit;\n };\n \n-extern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, size_t));\n-extern void _cpp_release_buff PARAMS ((cpp_reader *, _cpp_buff *));\n-extern void _cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff **, size_t));\n-extern _cpp_buff *_cpp_append_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n-\t\t\t\t\t\t   size_t));\n-extern void _cpp_free_buff PARAMS ((_cpp_buff *));\n-extern unsigned char *_cpp_aligned_alloc PARAMS ((cpp_reader *, size_t));\n-extern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n+extern _cpp_buff *_cpp_get_buff (cpp_reader *, size_t);\n+extern void _cpp_release_buff (cpp_reader *, _cpp_buff *);\n+extern void _cpp_extend_buff (cpp_reader *, _cpp_buff **, size_t);\n+extern _cpp_buff *_cpp_append_extend_buff (cpp_reader *, _cpp_buff *, size_t);\n+extern void _cpp_free_buff (_cpp_buff *);\n+extern unsigned char *_cpp_aligned_alloc (cpp_reader *, size_t);\n+extern unsigned char *_cpp_unaligned_alloc (cpp_reader *, size_t);\n \n #define BUFF_ROOM(BUFF) (size_t) ((BUFF)->limit - (BUFF)->cur)\n #define BUFF_FRONT(BUFF) ((BUFF)->cur)\n@@ -468,90 +467,79 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n /* In cpperror.c  */\n-extern int _cpp_begin_message PARAMS ((cpp_reader *, int,\n-\t\t\t\t       unsigned int, unsigned int));\n+extern int _cpp_begin_message (cpp_reader *, int, unsigned int, unsigned int);\n \n /* In cppmacro.c */\n-extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n-extern bool _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_push_text_context\tPARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t\t const uchar *, size_t));\n-extern bool _cpp_save_parameter\t\tPARAMS ((cpp_reader *, cpp_macro *,\n-\t\t\t\t\t\t cpp_hashnode *));\n-extern bool _cpp_arguments_ok\t\tPARAMS ((cpp_reader *, cpp_macro *,\n-\t\t\t\t\t\t const cpp_hashnode *,\n-\t\t\t\t\t\t unsigned int));\n-extern const uchar *_cpp_builtin_macro_text PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t     cpp_hashnode *));\n-int _cpp_warn_if_unused_macro\t\tPARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t\t void *));\n+extern void _cpp_free_definition (cpp_hashnode *);\n+extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\n+extern void _cpp_pop_context (cpp_reader *);\n+extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t    const uchar *, size_t);\n+extern bool _cpp_save_parameter (cpp_reader *, cpp_macro *, cpp_hashnode *);\n+extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n+\t\t\t       unsigned int);\n+extern const uchar *_cpp_builtin_macro_text (cpp_reader *, cpp_hashnode *);\n+int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n /* In cpphash.c */\n-extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\n-extern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n+extern void _cpp_init_hashtable (cpp_reader *, hash_table *);\n+extern void _cpp_destroy_hashtable (cpp_reader *);\n \n /* In cppfiles.c */\n-extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n-extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n-extern bool _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern bool _cpp_execute_include\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\t int, enum include_type));\n-extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\t int));\n-extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n-extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n-extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct include_file *));\n+extern void _cpp_fake_include (cpp_reader *, const char *);\n+extern void _cpp_never_reread (struct include_file *);\n+extern bool _cpp_read_file (cpp_reader *, const char *);\n+extern bool _cpp_execute_include (cpp_reader *, const char *, int,\n+\t\t\t\t  enum include_type);\n+extern int _cpp_compare_file_date (cpp_reader *, const char *, int);\n+extern void _cpp_report_missing_guards (cpp_reader *);\n+extern void _cpp_init_includes (cpp_reader *);\n+extern void _cpp_cleanup_includes (cpp_reader *);\n+extern void _cpp_pop_file_buffer (cpp_reader *, struct include_file *);\n \n /* In cppexp.c */\n-extern bool _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n-extern struct op *_cpp_expand_op_stack\tPARAMS ((cpp_reader *));\n+extern bool _cpp_parse_expr (cpp_reader *);\n+extern struct op *_cpp_expand_op_stack (cpp_reader *);\n \n /* In cpplex.c */\n-extern void _cpp_process_line_notes\tPARAMS ((cpp_reader *, int));\n-extern void _cpp_clean_line\t\tPARAMS ((cpp_reader *));\n-extern bool _cpp_get_fresh_line\t\tPARAMS ((cpp_reader *));\n-extern bool _cpp_skip_block_comment\tPARAMS ((cpp_reader *));\n-extern cpp_token *_cpp_temp_token\tPARAMS ((cpp_reader *));\n-extern const cpp_token *_cpp_lex_token\tPARAMS ((cpp_reader *));\n-extern cpp_token *_cpp_lex_direct\tPARAMS ((cpp_reader *));\n-extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n-\t\t\t\t\t\t const cpp_token *));\n-extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n+extern void _cpp_process_line_notes (cpp_reader *, int);\n+extern void _cpp_clean_line (cpp_reader *);\n+extern bool _cpp_get_fresh_line (cpp_reader *);\n+extern bool _cpp_skip_block_comment (cpp_reader *);\n+extern cpp_token *_cpp_temp_token (cpp_reader *);\n+extern const cpp_token *_cpp_lex_token (cpp_reader *);\n+extern cpp_token *_cpp_lex_direct (cpp_reader *);\n+extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);\n+extern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n \n /* In cppinit.c.  */\n-extern void _cpp_maybe_push_include_file PARAMS ((cpp_reader *));\n+extern void _cpp_maybe_push_include_file (cpp_reader *);\n \n /* In cpplib.c */\n-extern int _cpp_test_assertion PARAMS ((cpp_reader *, unsigned int *));\n-extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n-extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n-extern char ** _cpp_save_pragma_names PARAMS ((cpp_reader *));\n-extern void _cpp_restore_pragma_names PARAMS ((cpp_reader *, char **));\n-extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n-extern void _cpp_init_directives PARAMS ((cpp_reader *));\n-extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n-extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n-\t\t\t\t\t const char *,\n-\t\t\t\t\t unsigned int, unsigned int));\n-extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n+extern int _cpp_test_assertion (cpp_reader *, unsigned int *);\n+extern int _cpp_handle_directive (cpp_reader *, int);\n+extern void _cpp_define_builtin (cpp_reader *, const char *);\n+extern char ** _cpp_save_pragma_names (cpp_reader *);\n+extern void _cpp_restore_pragma_names (cpp_reader *, char **);\n+extern void _cpp_do__Pragma (cpp_reader *);\n+extern void _cpp_init_directives (cpp_reader *);\n+extern void _cpp_init_internal_pragmas (cpp_reader *);\n+extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n+\t\t\t\t unsigned int, unsigned int);\n+extern void _cpp_pop_buffer (cpp_reader *);\n \n /* In cpptrad.c.  */\n-extern bool scan_out_logical_line PARAMS ((cpp_reader *, cpp_macro *));\n-extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n-extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n-\t\t\t\t\t size_t));\n-extern void _cpp_remove_overlay PARAMS ((cpp_reader *));\n-extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n-extern bool _cpp_expansions_different_trad PARAMS ((const cpp_macro *,\n-\t\t\t\t\t\t    const cpp_macro *));\n-extern uchar *_cpp_copy_replacement_text PARAMS ((const cpp_macro *, uchar *));\n-extern size_t _cpp_replacement_text_len PARAMS ((const cpp_macro *));\n+extern bool scan_out_logical_line (cpp_reader *, cpp_macro *);\n+extern bool _cpp_read_logical_line_trad (cpp_reader *);\n+extern void _cpp_overlay_buffer (cpp_reader *pfile, const uchar *, size_t);\n+extern void _cpp_remove_overlay (cpp_reader *);\n+extern bool _cpp_create_trad_definition (cpp_reader *, cpp_macro *);\n+extern bool _cpp_expansions_different_trad (const cpp_macro *,\n+\t\t\t\t\t    const cpp_macro *);\n+extern uchar *_cpp_copy_replacement_text (const cpp_macro *, uchar *);\n+extern size_t _cpp_replacement_text_len (const cpp_macro *);\n \n /* In cppcharset.c.  */\n-cppchar_t _cpp_valid_ucn PARAMS ((cpp_reader *, const uchar **,\n-\t\t\t\t  int identifer_p));\n+cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **, int identifer_p);\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1\n@@ -563,55 +551,45 @@ cppchar_t _cpp_valid_ucn PARAMS ((cpp_reader *, const uchar **,\n \n /* These are inline functions instead of macros so we can get type\n    checking.  */\n-static inline int ustrcmp\tPARAMS ((const uchar *, const uchar *));\n-static inline int ustrncmp\tPARAMS ((const uchar *, const uchar *,\n-\t\t\t\t\t size_t));\n-static inline size_t ustrlen\tPARAMS ((const uchar *));\n-static inline uchar *uxstrdup\tPARAMS ((const uchar *));\n-static inline uchar *ustrchr\tPARAMS ((const uchar *, int));\n-static inline int ufputs\tPARAMS ((const uchar *, FILE *));\n+static inline int ustrcmp (const uchar *, const uchar *);\n+static inline int ustrncmp (const uchar *, const uchar *, size_t);\n+static inline size_t ustrlen (const uchar *);\n+static inline uchar *uxstrdup (const uchar *);\n+static inline uchar *ustrchr (const uchar *, int);\n+static inline int ufputs (const uchar *, FILE *);\n \n static inline int\n-ustrcmp (s1, s2)\n-     const uchar *s1, *s2;\n+ustrcmp (const uchar *s1, const uchar *s2)\n {\n   return strcmp ((const char *)s1, (const char *)s2);\n }\n \n static inline int\n-ustrncmp (s1, s2, n)\n-     const uchar *s1, *s2;\n-     size_t n;\n+ustrncmp (const uchar *s1, const uchar *s2, size_t n)\n {\n   return strncmp ((const char *)s1, (const char *)s2, n);\n }\n \n static inline size_t\n-ustrlen (s1)\n-     const uchar *s1;\n+ustrlen (const uchar *s1)\n {\n   return strlen ((const char *)s1);\n }\n \n static inline uchar *\n-uxstrdup (s1)\n-     const uchar *s1;\n+uxstrdup (const uchar *s1)\n {\n   return (uchar *) xstrdup ((const char *)s1);\n }\n \n static inline uchar *\n-ustrchr (s1, c)\n-     const uchar *s1;\n-     int c;\n+ustrchr (const uchar *s1, int c)\n {\n   return (uchar *) strchr ((const char *)s1, c);\n }\n \n static inline int\n-ufputs (s, f)\n-     const uchar *s;\n-     FILE *f;\n+ufputs (const uchar *s, FILE *f)\n {\n   return fputs ((const char *)s, f);\n }"}, {"sha": "1792ddd8a078f0b0941ea2bf0f91ca6332e71010", "filename": "gcc/cppinit.c", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -27,10 +27,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpphash.h\"\n #include \"mkdeps.h\"\n \n-static void init_library\t\tPARAMS ((void));\n-static void mark_named_operators\tPARAMS ((cpp_reader *));\n-static void read_original_filename\tPARAMS ((cpp_reader *));\n-static void post_options\t\tPARAMS ((cpp_reader *));\n+static void init_library (void);\n+static void mark_named_operators (cpp_reader *);\n+static void read_original_filename (cpp_reader *);\n+static void post_options (cpp_reader *);\n \n /* If we have designated initializers (GCC >2.7) these tables can be\n    initialized, constant data.  Otherwise, they have to be filled in at\n@@ -47,7 +47,7 @@ __extension__ const uchar _cpp_trigraph_map[UCHAR_MAX + 1] = {\n #else\n \n #define TRIGRAPH_MAP uchar _cpp_trigraph_map[UCHAR_MAX + 1] = { 0 }; \\\n- static void init_trigraph_map PARAMS ((void)) { \\\n+ static void init_trigraph_map (void) { \\\n  unsigned char *x = _cpp_trigraph_map;\n \n #define END }\n@@ -91,9 +91,7 @@ static const struct lang_flags lang_defaults[] =\n \n /* Sets internal flags correctly for a given language.  */\n void\n-cpp_set_lang (pfile, lang)\n-     cpp_reader *pfile;\n-     enum c_lang lang;\n+cpp_set_lang (cpp_reader *pfile, enum c_lang lang)\n {\n   const struct lang_flags *l = &lang_defaults[(int) lang];\n \n@@ -110,7 +108,7 @@ cpp_set_lang (pfile, lang)\n \n /* Initialize library global state.  */\n static void\n-init_library ()\n+init_library (void)\n {\n   static int initialized = 0;\n \n@@ -127,9 +125,7 @@ init_library ()\n \n /* Initialize a cpp_reader structure.  */\n cpp_reader *\n-cpp_create_reader (lang, table)\n-     enum c_lang lang;\n-     hash_table *table;\n+cpp_create_reader (enum c_lang lang, hash_table *table)\n {\n   cpp_reader *pfile;\n \n@@ -205,8 +201,7 @@ cpp_create_reader (lang, table)\n /* Free resources used by PFILE.  Accessing PFILE after this function\n    returns leads to undefined behavior.  Returns the error count.  */\n void\n-cpp_destroy (pfile)\n-     cpp_reader *pfile;\n+cpp_destroy (cpp_reader *pfile)\n {\n   cpp_context *context, *contextn;\n   tokenrun *run, *runn;\n@@ -309,8 +304,7 @@ static const struct builtin operator_array[] =\n \n /* Mark the C++ named operators in the hash table.  */\n static void\n-mark_named_operators (pfile)\n-     cpp_reader *pfile;\n+mark_named_operators (cpp_reader *pfile)\n {\n   const struct builtin *b;\n \n@@ -329,9 +323,7 @@ mark_named_operators (pfile)\n    macros, into the hash table.  HOSTED is true if this is a hosted\n    environment.  */\n void\n-cpp_init_builtins (pfile, hosted)\n-     cpp_reader *pfile;\n-     int hosted;\n+cpp_init_builtins (cpp_reader *pfile, int hosted)\n {\n   const struct builtin *b;\n   size_t n = ARRAY_SIZE (builtin_array);\n@@ -368,9 +360,8 @@ cpp_init_builtins (pfile, hosted)\n /* Sanity-checks are dependent on command-line options, so it is\n    called as a subroutine of cpp_read_main_file ().  */\n #if ENABLE_CHECKING\n-static void sanity_checks PARAMS ((cpp_reader *));\n-static void sanity_checks (pfile)\n-     cpp_reader *pfile;\n+static void sanity_checks (cpp_reader *);\n+static void sanity_checks (cpp_reader *pfile)\n {\n   cppchar_t test = 0;\n   size_t max_precision = 2 * CHAR_BIT * sizeof (cpp_num_part);\n@@ -383,7 +374,8 @@ static void sanity_checks (pfile)\n \n   if (CPP_OPTION (pfile, precision) > max_precision)\n     cpp_error (pfile, DL_ICE,\n-\t       \"preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits\",\n+\t       \"preprocessor arithmetic has maximum precision of %lu bits;\"\n+\t       \" target requires %lu bits\",\n \t       (unsigned long) max_precision,\n \t       (unsigned long) CPP_OPTION (pfile, precision));\n \n@@ -408,7 +400,8 @@ static void sanity_checks (pfile)\n \n   if (CPP_OPTION (pfile, wchar_precision) > BITS_PER_CPPCHAR_T)\n     cpp_error (pfile, DL_ICE,\n-\t       \"CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits\",\n+\t       \"CPP on this host cannot handle wide character constants over\"\n+\t       \" %lu bits, but the target requires %lu bits\",\n \t       (unsigned long) BITS_PER_CPPCHAR_T,\n \t       (unsigned long) CPP_OPTION (pfile, wchar_precision));\n }\n@@ -420,10 +413,7 @@ static void sanity_checks (pfile)\n    cpp_read_main_file().  If no targets have been added before\n    cpp_read_main_file(), then the default target is used.  */\n void\n-cpp_add_dependency_target (pfile, target, quote)\n-     cpp_reader *pfile;\n-     const char *target;\n-     int quote;\n+cpp_add_dependency_target (cpp_reader *pfile, const char *target, int quote)\n {\n   if (!pfile->deps)\n     pfile->deps = deps_init ();\n@@ -436,9 +426,7 @@ cpp_add_dependency_target (pfile, target, quote)\n    or stdin if it is the empty string.  Return the original filename\n    on success (e.g. foo.i->foo.c), or NULL on failure.  */\n const char *\n-cpp_read_main_file (pfile, fname)\n-     cpp_reader *pfile;\n-     const char *fname;\n+cpp_read_main_file (cpp_reader *pfile, const char *fname)\n {\n   sanity_checks (pfile);\n \n@@ -480,8 +468,7 @@ cpp_read_main_file (pfile, fname)\n    generate file_change callbacks, which the front ends must handle\n    appropriately given their state of initialization.  */\n static void\n-read_original_filename (pfile)\n-     cpp_reader *pfile;\n+read_original_filename (cpp_reader *pfile)\n {\n   const cpp_token *token, *token1;\n \n@@ -512,9 +499,7 @@ read_original_filename (pfile)\n    Maybe it should also reset state, such that you could call\n    cpp_start_read with a new filename to restart processing.  */\n int\n-cpp_finish (pfile, deps_stream)\n-     cpp_reader *pfile;\n-     FILE *deps_stream;\n+cpp_finish (cpp_reader *pfile, FILE *deps_stream)\n {\n   /* Warn about unused macros before popping the final buffer.  */\n   if (CPP_OPTION (pfile, warn_unused_macros))\n@@ -546,8 +531,7 @@ cpp_finish (pfile, deps_stream)\n }\n \n static void\n-post_options (pfile)\n-     cpp_reader *pfile;\n+post_options (cpp_reader *pfile)\n {\n   /* -Wtraditional is not useful in C++ mode.  */\n   if (CPP_OPTION (pfile, cplusplus))"}, {"sha": "6933e75035bc11e6fed1d6c2407a553c620b76e8", "filename": "gcc/cpplex.c", "status": "modified", "additions": 70, "deletions": 144, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -52,34 +52,31 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n \n-static void add_line_note PARAMS ((cpp_buffer *, const uchar *, unsigned int));\n-static int skip_line_comment PARAMS ((cpp_reader *));\n-static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n-static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n-static void lex_number PARAMS ((cpp_reader *, cpp_string *));\n-static bool forms_identifier_p PARAMS ((cpp_reader *, int));\n-static void lex_string PARAMS ((cpp_reader *, cpp_token *, const uchar *));\n-static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n-\t\t\t\t  cppchar_t));\n-static void create_literal PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n-\t\t\t\t    unsigned int, enum cpp_ttype));\n-static bool warn_in_comment PARAMS ((cpp_reader *, _cpp_line_note *));\n-static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n-static cppchar_t maybe_read_ucn PARAMS ((cpp_reader *, const uchar **));\n-static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n-\n-static unsigned int hex_digit_value PARAMS ((unsigned int));\n-static _cpp_buff *new_buff PARAMS ((size_t));\n+static void add_line_note (cpp_buffer *, const uchar *, unsigned int);\n+static int skip_line_comment (cpp_reader *);\n+static void skip_whitespace (cpp_reader *, cppchar_t);\n+static cpp_hashnode *lex_identifier (cpp_reader *, const uchar *);\n+static void lex_number (cpp_reader *, cpp_string *);\n+static bool forms_identifier_p (cpp_reader *, int);\n+static void lex_string (cpp_reader *, cpp_token *, const uchar *);\n+static void save_comment (cpp_reader *, cpp_token *, const uchar *, cppchar_t);\n+static void create_literal (cpp_reader *, cpp_token *, const uchar *,\n+\t\t\t    unsigned int, enum cpp_ttype);\n+static bool warn_in_comment (cpp_reader *, _cpp_line_note *);\n+static int name_p (cpp_reader *, const cpp_string *);\n+static cppchar_t maybe_read_ucn (cpp_reader *, const uchar **);\n+static tokenrun *next_tokenrun (tokenrun *);\n+\n+static unsigned int hex_digit_value (unsigned int);\n+static _cpp_buff *new_buff (size_t);\n \n \n /* Utility routine:\n \n    Compares, the token TOKEN to the NUL-terminated string STRING.\n    TOKEN must be a CPP_NAME.  Returns 1 for equal, 0 for unequal.  */\n int\n-cpp_ideq (token, string)\n-     const cpp_token *token;\n-     const char *string;\n+cpp_ideq (const cpp_token *token, const char *string)\n {\n   if (token->type != CPP_NAME)\n     return 0;\n@@ -90,10 +87,7 @@ cpp_ideq (token, string)\n /* Record a note TYPE at byte POS into the current cleaned logical\n    line.  */\n static void\n-add_line_note (buffer, pos, type)\n-     cpp_buffer *buffer;\n-     const uchar *pos;\n-     unsigned int type;\n+add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)\n {\n   if (buffer->notes_used == buffer->notes_cap)\n     {\n@@ -110,8 +104,7 @@ add_line_note (buffer, pos, type)\n /* Returns with a logical line that contains no escaped newlines or\n    trigraphs.  This is a time-critical inner loop.  */\n void\n-_cpp_clean_line (pfile)\n-     cpp_reader *pfile;\n+_cpp_clean_line (cpp_reader *pfile)\n {\n   cpp_buffer *buffer;\n   const uchar *s;\n@@ -184,9 +177,7 @@ _cpp_clean_line (pfile)\n /* Return true if the trigraph indicated by NOTE should be warned\n    about in a comment.  */\n static bool\n-warn_in_comment (pfile, note)\n-     cpp_reader *pfile;\n-     _cpp_line_note *note;\n+warn_in_comment (cpp_reader *pfile, _cpp_line_note *note)\n {\n   const uchar *p;\n \n@@ -214,9 +205,7 @@ warn_in_comment (pfile, note)\n /* Process the notes created by add_line_note as far as the current\n    location.  */\n void\n-_cpp_process_line_notes (pfile, in_comment)\n-     cpp_reader *pfile;\n-     int in_comment;\n+_cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n@@ -275,8 +264,7 @@ _cpp_process_line_notes (pfile, in_comment)\n \n    Buffer->cur points to the initial asterisk of the comment.  */\n bool\n-_cpp_skip_block_comment (pfile)\n-     cpp_reader *pfile;\n+_cpp_skip_block_comment (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   cppchar_t c;\n@@ -324,8 +312,7 @@ _cpp_skip_block_comment (pfile)\n    terminating newline.  Handles escaped newlines.  Returns nonzero\n    if a multiline comment.  */\n static int\n-skip_line_comment (pfile)\n-     cpp_reader *pfile;\n+skip_line_comment (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned int orig_line = pfile->line;\n@@ -339,9 +326,7 @@ skip_line_comment (pfile)\n \n /* Skips whitespace, saving the next non-whitespace character.  */\n static void\n-skip_whitespace (pfile, c)\n-     cpp_reader *pfile;\n-     cppchar_t c;\n+skip_whitespace (cpp_reader *pfile, cppchar_t c)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   bool saw_NUL = false;\n@@ -374,9 +359,7 @@ skip_whitespace (pfile, c)\n /* See if the characters of a number token are valid in a name (no\n    '.', '+' or '-').  */\n static int\n-name_p (pfile, string)\n-     cpp_reader *pfile;\n-     const cpp_string *string;\n+name_p (cpp_reader *pfile, const cpp_string *string)\n {\n   unsigned int i;\n \n@@ -390,9 +373,7 @@ name_p (pfile, string)\n /* Returns TRUE if the sequence starting at buffer->cur is invalid in\n    an identifier.  FIRST is TRUE if this starts an identifier.  */\n static bool\n-forms_identifier_p (pfile, first)\n-     cpp_reader *pfile;\n-     int first;\n+forms_identifier_p (cpp_reader *pfile, int first)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n@@ -426,9 +407,7 @@ forms_identifier_p (pfile, first)\n \n /* Lex an identifier starting at BUFFER->CUR - 1.  */\n static cpp_hashnode *\n-lex_identifier (pfile, base)\n-     cpp_reader *pfile;\n-     const uchar *base;\n+lex_identifier (cpp_reader *pfile, const uchar *base)\n {\n   cpp_hashnode *result;\n   const uchar *cur;\n@@ -462,17 +441,16 @@ lex_identifier (pfile, base)\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n \tcpp_error (pfile, DL_PEDWARN,\n-\t\"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro\");\n+\t\t   \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t   \" of a C99 variadic macro\");\n     }\n \n   return result;\n }\n \n /* Lex a number to NUMBER starting at BUFFER->CUR - 1.  */\n static void\n-lex_number (pfile, number)\n-     cpp_reader *pfile;\n-     cpp_string *number;\n+lex_number (cpp_reader *pfile, cpp_string *number)\n {\n   const uchar *cur;\n   const uchar *base;\n@@ -500,12 +478,8 @@ lex_number (pfile, number)\n \n /* Create a token of type TYPE with a literal spelling.  */\n static void\n-create_literal (pfile, token, base, len, type)\n-     cpp_reader *pfile;\n-     cpp_token *token;\n-     const uchar *base;\n-     unsigned int len;\n-     enum cpp_ttype type;\n+create_literal (cpp_reader *pfile, cpp_token *token, const uchar *base,\n+\t\tunsigned int len, enum cpp_ttype type)\n {\n   uchar *dest = _cpp_unaligned_alloc (pfile, len + 1);\n \n@@ -524,10 +498,7 @@ create_literal (pfile, token, base, len, type)\n    The spelling is NUL-terminated, but it is not guaranteed that this\n    is the first NUL since embedded NULs are preserved.  */\n static void\n-lex_string (pfile, token, base)\n-     cpp_reader *pfile;\n-     cpp_token *token;\n-     const uchar *base;\n+lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n {\n   bool saw_NUL = false;\n   const uchar *cur;\n@@ -573,11 +544,8 @@ lex_string (pfile, token, base)\n \n /* The stored comment includes the comment start and any terminator.  */\n static void\n-save_comment (pfile, token, from, type)\n-     cpp_reader *pfile;\n-     cpp_token *token;\n-     const unsigned char *from;\n-     cppchar_t type;\n+save_comment (cpp_reader *pfile, cpp_token *token, const unsigned char *from,\n+\t      cppchar_t type)\n {\n   unsigned char *buffer;\n   unsigned int len, clen;\n@@ -617,9 +585,7 @@ save_comment (pfile, token, from, type)\n \n /* Allocate COUNT tokens for RUN.  */\n void\n-_cpp_init_tokenrun (run, count)\n-     tokenrun *run;\n-     unsigned int count;\n+_cpp_init_tokenrun (tokenrun *run, unsigned int count)\n {\n   run->base = xnewvec (cpp_token, count);\n   run->limit = run->base + count;\n@@ -628,8 +594,7 @@ _cpp_init_tokenrun (run, count)\n \n /* Returns the next tokenrun, or creates one if there is none.  */\n static tokenrun *\n-next_tokenrun (run)\n-     tokenrun *run;\n+next_tokenrun (tokenrun *run)\n {\n   if (run->next == NULL)\n     {\n@@ -646,8 +611,7 @@ next_tokenrun (run)\n    same as the last lexed token, so that diagnostics appear in the\n    right place.  */\n cpp_token *\n-_cpp_temp_token (pfile)\n-     cpp_reader *pfile;\n+_cpp_temp_token (cpp_reader *pfile)\n {\n   cpp_token *old, *result;\n \n@@ -668,8 +632,7 @@ _cpp_temp_token (pfile)\n    like directive handling, token lookahead, multiple include\n    optimization and skipping.  */\n const cpp_token *\n-_cpp_lex_token (pfile)\n-     cpp_reader *pfile;\n+_cpp_lex_token (cpp_reader *pfile)\n {\n   cpp_token *result;\n \n@@ -701,7 +664,7 @@ _cpp_lex_token (pfile)\n \t      && _cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n \t    continue;\n \t  if (pfile->cb.line_change && !pfile->state.skipping)\n-\t    (*pfile->cb.line_change)(pfile, result, pfile->state.parsing_args);\n+\t    pfile->cb.line_change (pfile, result, pfile->state.parsing_args);\n \t}\n \n       /* We don't skip tokens in directives.  */\n@@ -722,8 +685,7 @@ _cpp_lex_token (pfile)\n \n /* Returns true if a fresh line has been loaded.  */\n bool\n-_cpp_get_fresh_line (pfile)\n-     cpp_reader *pfile;\n+_cpp_get_fresh_line (cpp_reader *pfile)\n {\n   /* We can't get a new line until we leave the current directive.  */\n   if (pfile->state.in_directive)\n@@ -792,8 +754,7 @@ _cpp_get_fresh_line (pfile)\n    otherwise returns to the start of the token buffer if permissible.\n    Returns the location of the lexed token.  */\n cpp_token *\n-_cpp_lex_direct (pfile)\n-     cpp_reader *pfile;\n+_cpp_lex_direct (cpp_reader *pfile)\n {\n   cppchar_t c;\n   cpp_buffer *buffer;\n@@ -1128,8 +1089,7 @@ _cpp_lex_direct (pfile)\n /* An upper bound on the number of bytes needed to spell TOKEN.\n    Does not include preceding whitespace.  */\n unsigned int\n-cpp_token_len (token)\n-     const cpp_token *token;\n+cpp_token_len (const cpp_token *token)\n {\n   unsigned int len;\n \n@@ -1145,13 +1105,11 @@ cpp_token_len (token)\n \n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.\n-   Returns a pointer to the character after the last character\n-   written.  */\n+   Returns a pointer to the character after the last character written.\n+   FIXME: Would be nice if we didn't need the PFILE argument.  */\n unsigned char *\n-cpp_spell_token (pfile, token, buffer)\n-     cpp_reader *pfile;\t\t/* Would be nice to be rid of this...  */\n-     const cpp_token *token;\n-     unsigned char *buffer;\n+cpp_spell_token (cpp_reader *pfile, const cpp_token *token,\n+\t\t unsigned char *buffer)\n {\n   switch (TOKEN_SPELL (token))\n     {\n@@ -1195,9 +1153,7 @@ cpp_spell_token (pfile, token, buffer)\n /* Returns TOKEN spelt as a null-terminated string.  The string is\n    freed when the reader is destroyed.  Useful for diagnostics.  */\n unsigned char *\n-cpp_token_as_text (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n+cpp_token_as_text (cpp_reader *pfile, const cpp_token *token)\n { \n   unsigned int len = cpp_token_len (token) + 1;\n   unsigned char *start = _cpp_unaligned_alloc (pfile, len), *end;\n@@ -1211,8 +1167,7 @@ cpp_token_as_text (pfile, token)\n /* Used by C front ends, which really should move to using\n    cpp_token_as_text.  */\n const char *\n-cpp_type2name (type)\n-     enum cpp_ttype type;\n+cpp_type2name (enum cpp_ttype type)\n {\n   return (const char *) token_spellings[type].name;\n }\n@@ -1221,9 +1176,7 @@ cpp_type2name (type)\n    Separated from cpp_spell_token for efficiency - to avoid stdio\n    double-buffering.  */\n void\n-cpp_output_token (token, fp)\n-     const cpp_token *token;\n-     FILE *fp;\n+cpp_output_token (const cpp_token *token, FILE *fp)\n {\n   switch (TOKEN_SPELL (token))\n     {\n@@ -1264,8 +1217,7 @@ cpp_output_token (token, fp)\n \n /* Compare two tokens.  */\n int\n-_cpp_equiv_tokens (a, b)\n-     const cpp_token *a, *b;\n+_cpp_equiv_tokens (const cpp_token *a, const cpp_token *b)\n {\n   if (a->type == b->type && a->flags == b->flags)\n     switch (TOKEN_SPELL (a))\n@@ -1291,9 +1243,8 @@ _cpp_equiv_tokens (a, b)\n    conservative, and occasionally advises a space where one is not\n    needed, e.g. \".\" and \".2\".  */\n int\n-cpp_avoid_paste (pfile, token1, token2)\n-     cpp_reader *pfile;\n-     const cpp_token *token1, *token2;\n+cpp_avoid_paste (cpp_reader *pfile, const cpp_token *token1,\n+\t\t const cpp_token *token2)\n {\n   enum cpp_ttype a = token1->type, b = token2->type;\n   cppchar_t c;\n@@ -1349,9 +1300,7 @@ cpp_avoid_paste (pfile, token1, token2)\n    character, to FP.  Leading whitespace is removed.  If there are\n    macros, special token padding is not performed.  */\n void\n-cpp_output_line (pfile, fp)\n-     cpp_reader *pfile;\n-     FILE *fp;\n+cpp_output_line (cpp_reader *pfile, FILE *fp)\n {\n   const cpp_token *token;\n \n@@ -1369,8 +1318,7 @@ cpp_output_line (pfile, fp)\n \n /* Returns the value of a hexadecimal digit.  */\n static unsigned int\n-hex_digit_value (c)\n-     unsigned int c;\n+hex_digit_value (unsigned int c)\n {\n   if (hex_p (c))\n     return hex_value (c);\n@@ -1380,9 +1328,7 @@ hex_digit_value (c)\n \n /* Read a possible universal character name starting at *PSTR.  */\n static cppchar_t\n-maybe_read_ucn (pfile, pstr)\n-     cpp_reader *pfile;\n-     const uchar **pstr;\n+maybe_read_ucn (cpp_reader *pfile, const uchar **pstr)\n {\n   cppchar_t result, c = (*pstr)[-1];\n \n@@ -1411,11 +1357,8 @@ maybe_read_ucn (pfile, pstr)\n    if the escape sequence is part of a wide character constant or\n    string literal.  Handles all relevant diagnostics.  */\n cppchar_t\n-cpp_parse_escape (pfile, pstr, limit, wide)\n-     cpp_reader *pfile;\n-     const unsigned char **pstr;\n-     const unsigned char *limit;\n-     int wide;\n+cpp_parse_escape (cpp_reader *pfile, const unsigned char **pstr,\n+\t\t  const unsigned char *limit, int wide)\n {\n   /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n   static const uchar ascii[]  = {  7,  8, 27, 12, 10, 13,  9, 11 };\n@@ -1555,7 +1498,8 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n \n   if (c > mask)\n     {\n-      cpp_error (pfile, DL_PEDWARN, \"escape sequence out of range for its type\");\n+      cpp_error (pfile, DL_PEDWARN,\n+\t\t \"escape sequence out of range for its type\");\n       c &= mask;\n     }\n \n@@ -1569,11 +1513,8 @@ cpp_parse_escape (pfile, pstr, limit, wide)\n    characters seen, and UNSIGNEDP to a variable that indicates whether\n    the result has signed type.  */\n cppchar_t\n-cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-     unsigned int *pchars_seen;\n-     int *unsignedp;\n+cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n+\t\t\t unsigned int *pchars_seen, int *unsignedp)\n {\n   const unsigned char *str, *limit;\n   unsigned int chars_seen = 0;\n@@ -1678,8 +1619,7 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n /* Create a new allocation buffer.  Place the control block at the end\n    of the buffer, so that buffer overflows will cause immediate chaos.  */\n static _cpp_buff *\n-new_buff (len)\n-     size_t len;\n+new_buff (size_t len)\n {\n   _cpp_buff *result;\n   unsigned char *base;\n@@ -1699,9 +1639,7 @@ new_buff (len)\n \n /* Place a chain of unwanted allocation buffers on the free list.  */\n void\n-_cpp_release_buff (pfile, buff)\n-     cpp_reader *pfile;\n-     _cpp_buff *buff;\n+_cpp_release_buff (cpp_reader *pfile, _cpp_buff *buff)\n {\n   _cpp_buff *end = buff;\n \n@@ -1713,9 +1651,7 @@ _cpp_release_buff (pfile, buff)\n \n /* Return a free buffer of size at least MIN_SIZE.  */\n _cpp_buff *\n-_cpp_get_buff (pfile, min_size)\n-     cpp_reader *pfile;\n-     size_t min_size;\n+_cpp_get_buff (cpp_reader *pfile, size_t min_size)\n {\n   _cpp_buff *result, **p;\n \n@@ -1744,10 +1680,7 @@ _cpp_get_buff (pfile, min_size)\n    the excess bytes to the new buffer.  Chains the new buffer after\n    BUFF, and returns the new buffer.  */\n _cpp_buff *\n-_cpp_append_extend_buff (pfile, buff, min_extra)\n-     cpp_reader *pfile;\n-     _cpp_buff *buff;\n-     size_t min_extra;\n+_cpp_append_extend_buff (cpp_reader *pfile, _cpp_buff *buff, size_t min_extra)\n {\n   size_t size = EXTENDED_BUFF_SIZE (buff, min_extra);\n   _cpp_buff *new_buff = _cpp_get_buff (pfile, size);\n@@ -1763,10 +1696,7 @@ _cpp_append_extend_buff (pfile, buff, min_extra)\n    Chains the new buffer before the buffer pointed to by BUFF, and\n    updates the pointer to point to the new buffer.  */\n void\n-_cpp_extend_buff (pfile, pbuff, min_extra)\n-     cpp_reader *pfile;\n-     _cpp_buff **pbuff;\n-     size_t min_extra;\n+_cpp_extend_buff (cpp_reader *pfile, _cpp_buff **pbuff, size_t min_extra)\n {\n   _cpp_buff *new_buff, *old_buff = *pbuff;\n   size_t size = EXTENDED_BUFF_SIZE (old_buff, min_extra);\n@@ -1793,9 +1723,7 @@ _cpp_free_buff (buff)\n \n /* Allocate permanent, unaligned storage of length LEN.  */\n unsigned char *\n-_cpp_unaligned_alloc (pfile, len)\n-     cpp_reader *pfile;\n-     size_t len;\n+_cpp_unaligned_alloc (cpp_reader *pfile, size_t len)\n {\n   _cpp_buff *buff = pfile->u_buff;\n   unsigned char *result = buff->cur;\n@@ -1823,9 +1751,7 @@ _cpp_unaligned_alloc (pfile, len)\n    All existing other uses clearly fit this restriction: storing\n    registered pragmas during initialization.  */\n unsigned char *\n-_cpp_aligned_alloc (pfile, len)\n-     cpp_reader *pfile;\n-     size_t len;\n+_cpp_aligned_alloc (cpp_reader *pfile, size_t len)\n {\n   _cpp_buff *buff = pfile->a_buff;\n   unsigned char *result = buff->cur;"}, {"sha": "af32705856fb9f88bd212a1a899d081a743d5ca4", "filename": "gcc/cpplib.c", "status": "modified", "additions": 135, "deletions": 261, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -45,11 +45,11 @@ struct if_stack\n   const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n   bool skip_elses;\t\t/* Can future #else / #elif be skipped?  */\n   bool was_skipping;\t\t/* If were skipping on entry.  */\n-  int type;\t\t\t/* Most recent conditional, for diagnostics.  */\n+  int type;\t\t\t/* Most recent conditional for diagnostics.  */\n };\n \n /* Contains a registered pragma or pragma namespace.  */\n-typedef void (*pragma_cb) PARAMS ((cpp_reader *));\n+typedef void (*pragma_cb) (cpp_reader *);\n struct pragma_entry\n {\n   struct pragma_entry *next;\n@@ -82,7 +82,7 @@ struct pragma_entry\n #define EXPAND\t\t(1 << 4)\n \n /* Defines one #-directive, including how to handle it.  */\n-typedef void (*directive_handler) PARAMS ((cpp_reader *));\n+typedef void (*directive_handler) (cpp_reader *);\n typedef struct directive directive;\n struct directive\n {\n@@ -95,51 +95,44 @@ struct directive\n \n /* Forward declarations.  */\n \n-static void skip_rest_of_line\tPARAMS ((cpp_reader *));\n-static void check_eol\t\tPARAMS ((cpp_reader *));\n-static void start_directive\tPARAMS ((cpp_reader *));\n-static void prepare_directive_trad PARAMS ((cpp_reader *));\n-static void end_directive\tPARAMS ((cpp_reader *, int));\n-static void directive_diagnostics\n-\tPARAMS ((cpp_reader *, const directive *, int));\n-static void run_directive\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t const char *, size_t));\n-static char *glue_header_name\tPARAMS ((cpp_reader *));\n-static const char *parse_include PARAMS ((cpp_reader *, int *));\n-static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n-\t\t\t\t\t const cpp_hashnode *));\n-static unsigned int read_flag\tPARAMS ((cpp_reader *, unsigned int));\n-static uchar *dequote_string\tPARAMS ((cpp_reader *, const uchar *,\n-\t\t\t\t\t unsigned int));\n-static int  strtoul_for_line\tPARAMS ((const uchar *, unsigned int,\n-\t\t\t\t\t unsigned long *));\n-static void do_diagnostic\tPARAMS ((cpp_reader *, int, int));\n-static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n-static void do_include_common\tPARAMS ((cpp_reader *, enum include_type));\n-static struct pragma_entry *lookup_pragma_entry\n-  PARAMS ((struct pragma_entry *, const cpp_hashnode *pragma));\n-static struct pragma_entry *insert_pragma_entry\n-  PARAMS ((cpp_reader *, struct pragma_entry **, const cpp_hashnode *,\n-\t   pragma_cb));\n-static int count_registered_pragmas\tPARAMS ((struct pragma_entry *));\n-static char ** save_registered_pragmas \n-  PARAMS ((struct pragma_entry *, char **));\n-static char ** restore_registered_pragmas \n-  PARAMS ((cpp_reader *, struct pragma_entry *, char **));\n-static void do_pragma_once\tPARAMS ((cpp_reader *));\n-static void do_pragma_poison\tPARAMS ((cpp_reader *));\n-static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n-static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n-static void do_linemarker\t\tPARAMS ((cpp_reader *));\n-static const cpp_token *get_token_no_padding PARAMS ((cpp_reader *));\n-static const cpp_token *get__Pragma_string PARAMS ((cpp_reader *));\n-static void destringize_and_run PARAMS ((cpp_reader *, const cpp_string *));\n-static int parse_answer PARAMS ((cpp_reader *, struct answer **, int));\n-static cpp_hashnode *parse_assertion PARAMS ((cpp_reader *, struct answer **,\n-\t\t\t\t\t      int));\n-static struct answer ** find_answer PARAMS ((cpp_hashnode *,\n-\t\t\t\t\t     const struct answer *));\n-static void handle_assertion\tPARAMS ((cpp_reader *, const char *, int));\n+static void skip_rest_of_line (cpp_reader *);\n+static void check_eol (cpp_reader *);\n+static void start_directive (cpp_reader *);\n+static void prepare_directive_trad (cpp_reader *);\n+static void end_directive (cpp_reader *, int);\n+static void directive_diagnostics (cpp_reader *, const directive *, int);\n+static void run_directive (cpp_reader *, int, const char *, size_t);\n+static char *glue_header_name (cpp_reader *);\n+static const char *parse_include (cpp_reader *, int *);\n+static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);\n+static unsigned int read_flag (cpp_reader *, unsigned int);\n+static uchar *dequote_string (cpp_reader *, const uchar *, unsigned int);\n+static int strtoul_for_line (const uchar *, unsigned int, unsigned long *);\n+static void do_diagnostic (cpp_reader *, int, int);\n+static cpp_hashnode *lex_macro_node (cpp_reader *);\n+static void do_include_common (cpp_reader *, enum include_type);\n+static struct pragma_entry *lookup_pragma_entry (struct pragma_entry *,\n+                                                 const cpp_hashnode *);\n+static struct pragma_entry *insert_pragma_entry (cpp_reader *,\n+                                                 struct pragma_entry **,\n+                                                 const cpp_hashnode *,\n+                                                 pragma_cb);\n+static int count_registered_pragmas (struct pragma_entry *);\n+static char ** save_registered_pragmas (struct pragma_entry *, char **);\n+static char ** restore_registered_pragmas (cpp_reader *, struct pragma_entry *,\n+                                           char **);\n+static void do_pragma_once (cpp_reader *);\n+static void do_pragma_poison (cpp_reader *);\n+static void do_pragma_system_header (cpp_reader *);\n+static void do_pragma_dependency (cpp_reader *);\n+static void do_linemarker (cpp_reader *);\n+static const cpp_token *get_token_no_padding (cpp_reader *);\n+static const cpp_token *get__Pragma_string (cpp_reader *);\n+static void destringize_and_run (cpp_reader *, const cpp_string *);\n+static int parse_answer (cpp_reader *, struct answer **, int);\n+static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);\n+static struct answer ** find_answer (cpp_hashnode *, const struct answer *);\n+static void handle_assertion (cpp_reader *, const char *, int);\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -174,7 +167,7 @@ D(sccs,\t\tT_SCCS,\t\tEXTENSION, 0)\t\t   /* 0 SVR4? */\n /* Use the table to generate a series of prototypes, an enum for the\n    directive names, and an array of directive handlers.  */\n \n-#define D(name, t, o, f) static void do_##name PARAMS ((cpp_reader *));\n+#define D(name, t, o, f) static void do_##name (cpp_reader *);\n DIRECTIVE_TABLE\n #undef D\n \n@@ -208,8 +201,7 @@ static const directive linemarker_dir =\n \n /* Skip any remaining tokens in a directive.  */\n static void\n-skip_rest_of_line (pfile)\n-     cpp_reader *pfile;\n+skip_rest_of_line (cpp_reader *pfile)\n {\n   /* Discard all stacked contexts.  */\n   while (pfile->context->prev)\n@@ -223,8 +215,7 @@ skip_rest_of_line (pfile)\n \n /* Ensure there are no stray tokens at the end of a directive.  */\n static void\n-check_eol (pfile)\n-     cpp_reader *pfile;\n+check_eol (cpp_reader *pfile)\n {\n   if (! SEEN_EOL () && _cpp_lex_token (pfile)->type != CPP_EOF)\n     cpp_error (pfile, DL_PEDWARN, \"extra tokens at end of #%s directive\",\n@@ -233,8 +224,7 @@ check_eol (pfile)\n \n /* Called when entering a directive, _Pragma or command-line directive.  */\n static void\n-start_directive (pfile)\n-     cpp_reader *pfile;\n+start_directive (cpp_reader *pfile)\n {\n   /* Setup in-directive state.  */\n   pfile->state.in_directive = 1;\n@@ -246,9 +236,7 @@ start_directive (pfile)\n \n /* Called when leaving a directive, _Pragma or command-line directive.  */\n static void\n-end_directive (pfile, skip_line)\n-     cpp_reader *pfile;\n-     int skip_line;\n+end_directive (cpp_reader *pfile, int skip_line)\n {\n   if (CPP_OPTION (pfile, traditional))\n     {\n@@ -279,8 +267,7 @@ end_directive (pfile, skip_line)\n \n /* Prepare to handle the directive in pfile->directive.  */\n static void\n-prepare_directive_trad (pfile)\n-     cpp_reader *pfile;\n+prepare_directive_trad (cpp_reader *pfile)\n {\n   if (pfile->directive != &dtable[T_DEFINE])\n     {\n@@ -308,10 +295,7 @@ prepare_directive_trad (pfile)\n /* Output diagnostics for a directive DIR.  INDENTED is nonzero if\n    the '#' was indented.  */\n static void\n-directive_diagnostics (pfile, dir, indented)\n-     cpp_reader *pfile;\n-     const directive *dir;\n-     int indented;\n+directive_diagnostics (cpp_reader *pfile, const directive *dir, int indented)\n {\n   /* Issue -pedantic warnings for extensions.  */\n   if (CPP_PEDANTIC (pfile)\n@@ -347,9 +331,7 @@ directive_diagnostics (pfile, dir, indented)\n    nonzero if the line of tokens has been handled, zero if we should\n    continue processing the line.  */\n int\n-_cpp_handle_directive (pfile, indented)\n-     cpp_reader *pfile;\n-     int indented;\n+_cpp_handle_directive (cpp_reader *pfile, int indented)\n {\n   const directive *dir = 0;\n   const cpp_token *dname;\n@@ -439,7 +421,7 @@ _cpp_handle_directive (pfile, indented)\n     prepare_directive_trad (pfile);\n \n   if (dir)\n-    (*pfile->directive->handler) (pfile);\n+    pfile->directive->handler (pfile);\n   else if (skip == 0)\n     _cpp_backup_tokens (pfile, 1);\n \n@@ -456,11 +438,7 @@ _cpp_handle_directive (pfile, indented)\n /* Directive handler wrapper used by the command line option\n    processor.  BUF is \\n terminated.  */\n static void\n-run_directive (pfile, dir_no, buf, count)\n-     cpp_reader *pfile;\n-     int dir_no;\n-     const char *buf;\n-     size_t count;\n+run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n {\n   cpp_push_buffer (pfile, (const uchar *) buf, count,\n \t\t   /* from_stage3 */ true, 1);\n@@ -476,7 +454,7 @@ run_directive (pfile, dir_no, buf, count)\n   pfile->directive = &dtable[dir_no];\n   if (CPP_OPTION (pfile, traditional))\n     prepare_directive_trad (pfile);\n-  (void) (*pfile->directive->handler) (pfile);\n+  pfile->directive->handler (pfile);\n   end_directive (pfile, 1);\n   if (dir_no == T_PRAGMA)\n     pfile->buffer->inc = NULL;\n@@ -486,8 +464,7 @@ run_directive (pfile, dir_no, buf, count)\n /* Checks for validity the macro name in #define, #undef, #ifdef and\n    #ifndef directives.  */\n static cpp_hashnode *\n-lex_macro_node (pfile)\n-     cpp_reader *pfile;\n+lex_macro_node (cpp_reader *pfile)\n {\n   const cpp_token *token = _cpp_lex_token (pfile);\n \n@@ -523,8 +500,7 @@ lex_macro_node (pfile)\n \n /* Process a #define directive.  Most work is done in cppmacro.c.  */\n static void\n-do_define (pfile)\n-     cpp_reader *pfile;\n+do_define (cpp_reader *pfile)\n {\n   cpp_hashnode *node = lex_macro_node (pfile);\n \n@@ -537,14 +513,13 @@ do_define (pfile)\n \n       if (_cpp_create_definition (pfile, node))\n \tif (pfile->cb.define)\n-\t  (*pfile->cb.define) (pfile, pfile->directive_line, node);\n+\t  pfile->cb.define (pfile, pfile->directive_line, node);\n     }\n }\n \n /* Handle #undef.  Mark the identifier NT_VOID in the hash table.  */\n static void\n-do_undef (pfile)\n-     cpp_reader *pfile;\n+do_undef (cpp_reader *pfile)\n {\n   cpp_hashnode *node = lex_macro_node (pfile);\n \n@@ -553,7 +528,7 @@ do_undef (pfile)\n   if (node && node->type == NT_MACRO)\n     {\n       if (pfile->cb.undef)\n-\t(*pfile->cb.undef) (pfile, pfile->directive_line, node);\n+\tpfile->cb.undef (pfile, pfile->directive_line, node);\n \n       if (node->flags & NODE_WARN)\n \tcpp_error (pfile, DL_WARNING, \"undefining \\\"%s\\\"\", NODE_NAME (node));\n@@ -570,8 +545,7 @@ do_undef (pfile)\n    as an h-char-sequence (< ... >); we are looking at the first token\n    after the <.  Returns a malloced filename.  */\n static char *\n-glue_header_name (pfile)\n-     cpp_reader *pfile;\n+glue_header_name (cpp_reader *pfile)\n {\n   const cpp_token *token;\n   char *buffer;\n@@ -614,9 +588,7 @@ glue_header_name (pfile)\n    #pragma dependency.  The string is malloced and the caller should\n    free it.  Returns NULL on error.  */\n static const char *\n-parse_include (pfile, pangle_brackets)\n-     cpp_reader *pfile;\n-     int *pangle_brackets;\n+parse_include (cpp_reader *pfile, int *pangle_brackets)\n {\n   char *fname;\n   const cpp_token *header;\n@@ -655,9 +627,7 @@ parse_include (pfile, pangle_brackets)\n \n /* Handle #include, #include_next and #import.  */\n static void\n-do_include_common (pfile, type)\n-     cpp_reader *pfile;\n-     enum include_type type;\n+do_include_common (cpp_reader *pfile, enum include_type type)\n {\n   const char *fname;\n   int angle_brackets;\n@@ -675,8 +645,8 @@ do_include_common (pfile, type)\n       skip_rest_of_line (pfile);\n \n       if (pfile->cb.include)\n-\t(*pfile->cb.include) (pfile, pfile->directive_line,\n-\t\t\t      pfile->directive->name, fname, angle_brackets);\n+\tpfile->cb.include (pfile, pfile->directive_line,\n+\t\t\t   pfile->directive->name, fname, angle_brackets);\n \n       _cpp_execute_include (pfile, fname, angle_brackets, type);\n     }\n@@ -685,15 +655,13 @@ do_include_common (pfile, type)\n }\n \n static void\n-do_include (pfile)\n-     cpp_reader *pfile;\n+do_include (cpp_reader *pfile)\n {\n   do_include_common (pfile, IT_INCLUDE);\n }\n \n static void\n-do_import (pfile)\n-     cpp_reader *pfile;\n+do_import (cpp_reader *pfile)\n {\n   if (CPP_OPTION (pfile, warn_import))\n     {\n@@ -706,8 +674,7 @@ do_import (pfile)\n }\n \n static void\n-do_include_next (pfile)\n-     cpp_reader *pfile;\n+do_include_next (cpp_reader *pfile)\n {\n   enum include_type type = IT_INCLUDE_NEXT;\n \n@@ -727,9 +694,7 @@ do_include_next (pfile)\n    flag if it is valid, 0 at the end of the directive. Otherwise\n    complain.  */\n static unsigned int\n-read_flag (pfile, last)\n-     cpp_reader *pfile;\n-     unsigned int last;\n+read_flag (cpp_reader *pfile, unsigned int last)\n {\n   const cpp_token *token = _cpp_lex_token (pfile);\n \n@@ -753,10 +718,7 @@ read_flag (pfile, last)\n    which has a NUL terminator and all escape sequences converted to\n    their equivalents.  Temporary, hopefully.  */\n static uchar *\n-dequote_string (pfile, str, len)\n-     cpp_reader *pfile;\n-     const uchar *str;\n-     unsigned int len;\n+dequote_string (cpp_reader *pfile, const uchar *str, unsigned int len)\n {\n   uchar *result = _cpp_unaligned_alloc (pfile, len + 1);\n   uchar *dst = result;\n@@ -779,10 +741,7 @@ dequote_string (pfile, str, len)\n    of length LEN, to binary; store it in NUMP, and return 0 if the\n    number was well-formed, 1 if not.  Temporary, hopefully.  */\n static int\n-strtoul_for_line (str, len, nump)\n-     const uchar *str;\n-     unsigned int len;\n-     unsigned long *nump;\n+strtoul_for_line (const uchar *str, unsigned int len, long unsigned int *nump)\n {\n   unsigned long reg = 0;\n   uchar c;\n@@ -802,8 +761,7 @@ strtoul_for_line (str, len, nump)\n    Note that the filename string (if any) is a true string constant\n    (escapes are interpreted), unlike in #line.  */\n static void\n-do_line (pfile)\n-     cpp_reader *pfile;\n+do_line (cpp_reader *pfile)\n {\n   const cpp_token *token;\n   const char *new_file = pfile->map->to_file;\n@@ -850,8 +808,7 @@ do_line (pfile)\n    different syntax and semantics from #line:  Flags are allowed,\n    and we never complain about the line number being too big.  */\n static void\n-do_linemarker (pfile)\n-     cpp_reader *pfile;\n+do_linemarker (cpp_reader *pfile)\n {\n   const cpp_token *token;\n   const char *new_file = pfile->map->to_file;\n@@ -921,27 +878,21 @@ do_linemarker (pfile)\n    header, 2 for a system header that needs to be extern \"C\" protected,\n    and zero otherwise.  */\n void\n-_cpp_do_file_change (pfile, reason, to_file, file_line, sysp)\n-     cpp_reader *pfile;\n-     enum lc_reason reason;\n-     const char *to_file;\n-     unsigned int file_line;\n-     unsigned int sysp;\n+_cpp_do_file_change (cpp_reader *pfile, enum lc_reason reason,\n+\t\t     const char *to_file, unsigned int file_line,\n+\t\t     unsigned int sysp)\n {\n   pfile->map = add_line_map (&pfile->line_maps, reason, sysp,\n \t\t\t     pfile->line, to_file, file_line);\n \n   if (pfile->cb.file_change)\n-    (*pfile->cb.file_change) (pfile, pfile->map);\n+    pfile->cb.file_change (pfile, pfile->map);\n }\n \n /* Report a warning or error detected by the program we are\n    processing.  Use the directive's tokens in the error message.  */\n static void\n-do_diagnostic (pfile, code, print_dir)\n-     cpp_reader *pfile;\n-     int code;\n-     int print_dir;\n+do_diagnostic (cpp_reader *pfile, int code, int print_dir)\n {\n   if (_cpp_begin_message (pfile, code,\n \t\t\t  pfile->cur_token[-1].line,\n@@ -956,31 +907,28 @@ do_diagnostic (pfile, code, print_dir)\n }\n \n static void\n-do_error (pfile)\n-     cpp_reader *pfile;\n+do_error (cpp_reader *pfile)\n {\n   do_diagnostic (pfile, DL_ERROR, 1);\n }\n \n static void\n-do_warning (pfile)\n-     cpp_reader *pfile;\n+do_warning (cpp_reader *pfile)\n {\n   /* We want #warning diagnostics to be emitted in system headers too.  */\n   do_diagnostic (pfile, DL_WARNING_SYSHDR, 1);\n }\n \n /* Report program identification.  */\n static void\n-do_ident (pfile)\n-     cpp_reader *pfile;\n+do_ident (cpp_reader *pfile)\n {\n   const cpp_token *str = cpp_get_token (pfile);\n \n   if (str->type != CPP_STRING)\n     cpp_error (pfile, DL_ERROR, \"invalid #ident directive\");\n   else if (pfile->cb.ident)\n-    (*pfile->cb.ident) (pfile, pfile->directive_line, &str->val.str);\n+    pfile->cb.ident (pfile, pfile->directive_line, &str->val.str);\n \n   check_eol (pfile);\n }\n@@ -989,9 +937,7 @@ do_ident (pfile)\n    matching entry, or NULL if none is found.  The returned entry could\n    be the start of a namespace chain, or a pragma.  */\n static struct pragma_entry *\n-lookup_pragma_entry (chain, pragma)\n-     struct pragma_entry *chain;\n-     const cpp_hashnode *pragma;\n+lookup_pragma_entry (struct pragma_entry *chain, const cpp_hashnode *pragma)\n {\n   while (chain && chain->pragma != pragma)\n     chain = chain->next;\n@@ -1003,11 +949,8 @@ lookup_pragma_entry (chain, pragma)\n    singly-linked CHAIN.  If handler is NULL, it is a namespace,\n    otherwise it is a pragma and its handler.  */\n static struct pragma_entry *\n-insert_pragma_entry (pfile, chain, pragma, handler)\n-     cpp_reader *pfile;\n-     struct pragma_entry **chain;\n-     const cpp_hashnode *pragma;\n-     pragma_cb handler;\n+insert_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain,\n+\t\t     const cpp_hashnode *pragma, pragma_cb handler)\n {\n   struct pragma_entry *new;\n \n@@ -1034,11 +977,8 @@ insert_pragma_entry (pfile, chain, pragma, handler)\n    goes in the global namespace.  HANDLER is the handler it will call,\n    which must be non-NULL.  */\n void\n-cpp_register_pragma (pfile, space, name, handler)\n-     cpp_reader *pfile;\n-     const char *space;\n-     const char *name;\n-     pragma_cb handler;\n+cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n+\t\t     pragma_cb handler)\n {\n   struct pragma_entry **chain = &pfile->pragmas;\n   struct pragma_entry *entry;\n@@ -1080,8 +1020,7 @@ cpp_register_pragma (pfile, space, name, handler)\n \n /* Register the pragmas the preprocessor itself handles.  */\n void\n-_cpp_init_internal_pragmas (pfile)\n-     cpp_reader *pfile;\n+_cpp_init_internal_pragmas (cpp_reader *pfile)\n {\n   /* Pragmas in the global namespace.  */\n   cpp_register_pragma (pfile, 0, \"once\", do_pragma_once);\n@@ -1095,8 +1034,7 @@ _cpp_init_internal_pragmas (pfile)\n /* Return the number of registered pragmas in PE.  */\n \n static int\n-count_registered_pragmas (pe)\n-     struct pragma_entry *pe;\n+count_registered_pragmas (struct pragma_entry *pe)\n {\n   int ct = 0;\n   for (; pe != NULL; pe = pe->next)\n@@ -1112,9 +1050,7 @@ count_registered_pragmas (pe)\n    and return a pointer to the next free space in SD.  */\n \n static char **\n-save_registered_pragmas (pe, sd)\n-     struct pragma_entry *pe;\n-     char **sd;\n+save_registered_pragmas (struct pragma_entry *pe, char **sd)\n {\n   for (; pe != NULL; pe = pe->next)\n     {\n@@ -1131,8 +1067,7 @@ save_registered_pragmas (pe, sd)\n    registered pragmas.  */\n \n char **\n-_cpp_save_pragma_names (pfile)\n-     cpp_reader *pfile;\n+_cpp_save_pragma_names (cpp_reader *pfile)\n {\n   int ct = count_registered_pragmas (pfile->pragmas);\n   char **result = xnewvec (char *, ct);\n@@ -1144,10 +1079,8 @@ _cpp_save_pragma_names (pfile)\n    and return a pointer to the next unused name in SD.  */\n \n static char **\n-restore_registered_pragmas (pfile, pe, sd)\n-     cpp_reader *pfile;\n-     struct pragma_entry *pe;\n-     char **sd;\n+restore_registered_pragmas (cpp_reader *pfile, struct pragma_entry *pe,\n+\t\t\t    char **sd)\n {\n   for (; pe != NULL; pe = pe->next)\n     {\n@@ -1163,9 +1096,7 @@ restore_registered_pragmas (pfile, pe, sd)\n /* Restore the names of the registered pragmas from SAVED.  */\n \n void\n-_cpp_restore_pragma_names (pfile, saved)\n-     cpp_reader *pfile;\n-     char **saved;\n+_cpp_restore_pragma_names (cpp_reader *pfile, char **saved)\n {\n   (void) restore_registered_pragmas (pfile, pfile->pragmas, saved);\n   free (saved);\n@@ -1177,8 +1108,7 @@ _cpp_restore_pragma_names (pfile, saved)\n    expansion happens for other pragmas is implementation defined.\n    This implementation never macro-expands the text after #pragma.  */\n static void\n-do_pragma (pfile)\n-     cpp_reader *pfile;\n+do_pragma (cpp_reader *pfile)\n {\n   const struct pragma_entry *p = NULL;\n   const cpp_token *token;\n@@ -1207,23 +1137,22 @@ do_pragma (pfile)\n      themselves.  Stand-alone CPP must ignore us, otherwise it will\n      prefix the directive with spaces, hence the 1.  Ugh.  */\n   if (pfile->cb.line_change)\n-    (*pfile->cb.line_change)(pfile, token, 1);\n+    pfile->cb.line_change (pfile, token, 1);\n \n   if (p)\n-    (*p->u.handler) (pfile);\n+    p->u.handler (pfile);\n   else if (pfile->cb.def_pragma)\n     {\n       _cpp_backup_tokens (pfile, count);\n-      (*pfile->cb.def_pragma) (pfile, pfile->directive_line);\n+      pfile->cb.def_pragma (pfile, pfile->directive_line);\n     }\n \n   pfile->state.prevent_expansion--;\n }\n \n /* Handle #pragma once.  */\n static void\n-do_pragma_once (pfile)\n-     cpp_reader *pfile;\n+do_pragma_once (cpp_reader *pfile)\n {\n   if (CPP_OPTION (pfile, warn_deprecated))\n     cpp_error (pfile, DL_WARNING, \"#pragma once is obsolete\");\n@@ -1239,8 +1168,7 @@ do_pragma_once (pfile)\n /* Handle #pragma GCC poison, to poison one or more identifiers so\n    that the lexer produces a hard error for each subsequent usage.  */\n static void\n-do_pragma_poison (pfile)\n-     cpp_reader *pfile;\n+do_pragma_poison (cpp_reader *pfile)\n {\n   const cpp_token *tok;\n   cpp_hashnode *hp;\n@@ -1277,8 +1205,7 @@ do_pragma_poison (pfile)\n    system include directory.  To prevent abuse, it is rejected in the\n    primary source file.  */\n static void\n-do_pragma_system_header (pfile)\n-     cpp_reader *pfile;\n+do_pragma_system_header (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n@@ -1297,8 +1224,7 @@ do_pragma_system_header (pfile)\n    file. Issue a diagnostic, if the specified file is newer. We use this to\n    determine if a fixed header should be refixed.  */\n static void\n-do_pragma_dependency (pfile)\n-     cpp_reader *pfile;\n+do_pragma_dependency (cpp_reader *pfile)\n {\n   const char *fname;\n   int angle_brackets, ordering;\n@@ -1325,8 +1251,7 @@ do_pragma_dependency (pfile)\n \n /* Get a token but skip padding.  */\n static const cpp_token *\n-get_token_no_padding (pfile)\n-     cpp_reader *pfile;\n+get_token_no_padding (cpp_reader *pfile)\n {\n   for (;;)\n     {\n@@ -1339,8 +1264,7 @@ get_token_no_padding (pfile)\n /* Check syntax is \"(string-literal)\".  Returns the string on success,\n    or NULL on failure.  */\n static const cpp_token *\n-get__Pragma_string (pfile)\n-     cpp_reader *pfile;\n+get__Pragma_string (cpp_reader *pfile)\n {\n   const cpp_token *string;\n \n@@ -1360,9 +1284,7 @@ get__Pragma_string (pfile)\n /* Destringize IN into a temporary buffer, by removing the first \\ of\n    \\\" and \\\\ sequences, and process the result as a #pragma directive.  */\n static void\n-destringize_and_run (pfile, in)\n-     cpp_reader *pfile;\n-     const cpp_string *in;\n+destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n {\n   const unsigned char *src, *limit;\n   char *dest, *result;\n@@ -1417,13 +1339,12 @@ destringize_and_run (pfile, in)\n \n       Getting the line markers is a little tricky.  */\n   if (pfile->cb.line_change)\n-    (*pfile->cb.line_change) (pfile, pfile->cur_token, false);\n+    pfile->cb.line_change (pfile, pfile->cur_token, false);\n }\n \n /* Handle the _Pragma operator.  */\n void\n-_cpp_do__Pragma (pfile)\n-     cpp_reader *pfile;\n+_cpp_do__Pragma (cpp_reader *pfile)\n {\n   const cpp_token *string = get__Pragma_string (pfile);\n \n@@ -1434,17 +1355,15 @@ _cpp_do__Pragma (pfile)\n \t       \"_Pragma takes a parenthesized string literal\");\n }\n \n-/* Just ignore #sccs on all systems.  */\n+/* Ignore #sccs on all systems.  */\n static void\n-do_sccs (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+do_sccs (cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n }\n \n /* Handle #ifdef.  */\n static void\n-do_ifdef (pfile)\n-     cpp_reader *pfile;\n+do_ifdef (cpp_reader *pfile)\n {\n   int skip = 1;\n \n@@ -1465,8 +1384,7 @@ do_ifdef (pfile)\n \n /* Handle #ifndef.  */\n static void\n-do_ifndef (pfile)\n-     cpp_reader *pfile;\n+do_ifndef (cpp_reader *pfile)\n {\n   int skip = 1;\n   const cpp_hashnode *node = 0;\n@@ -1492,8 +1410,7 @@ do_ifndef (pfile)\n    cannot treat it as a controlling conditional, since the expansion\n    could change in the future.  That is handled by cpp_get_token.  */\n static void\n-do_if (pfile)\n-     cpp_reader *pfile;\n+do_if (cpp_reader *pfile)\n {\n   int skip = 1;\n \n@@ -1507,8 +1424,7 @@ do_if (pfile)\n    if_stack; this is so that the error message for missing #endif's\n    etc. will point to the original #if.  */\n static void\n-do_else (pfile)\n-     cpp_reader *pfile;\n+do_else (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   struct if_stack *ifs = buffer->if_stack;\n@@ -1541,8 +1457,7 @@ do_else (pfile)\n /* Handle a #elif directive by not changing if_stack either.  See the\n    comment above do_else.  */\n static void\n-do_elif (pfile)\n-     cpp_reader *pfile;\n+do_elif (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   struct if_stack *ifs = buffer->if_stack;\n@@ -1577,8 +1492,7 @@ do_elif (pfile)\n \n /* #endif pops the if stack and resets pfile->state.skipping.  */\n static void\n-do_endif (pfile)\n-     cpp_reader *pfile;\n+do_endif (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   struct if_stack *ifs = buffer->if_stack;\n@@ -1609,11 +1523,8 @@ do_endif (pfile)\n    is #if or #ifndef, CMACRO is a potentially controlling macro, and\n    we need to check here that we are at the top of the file.  */\n static void\n-push_conditional (pfile, skip, type, cmacro)\n-     cpp_reader *pfile;\n-     int skip;\n-     int type;\n-     const cpp_hashnode *cmacro;\n+push_conditional (cpp_reader *pfile, int skip, int type,\n+\t\t  const cpp_hashnode *cmacro)\n {\n   struct if_stack *ifs;\n   cpp_buffer *buffer = pfile->buffer;\n@@ -1639,10 +1550,7 @@ push_conditional (pfile, skip, type, cmacro)\n    storage, i.e. the #assert case.  Returns 0 on success, and sets\n    ANSWERP to point to the answer.  */\n static int\n-parse_answer (pfile, answerp, type)\n-     cpp_reader *pfile;\n-     struct answer **answerp;\n-     int type;\n+parse_answer (cpp_reader *pfile, struct answer **answerp, int type)\n {\n   const cpp_token *paren;\n   struct answer *answer;\n@@ -1718,10 +1626,7 @@ parse_answer (pfile, answerp, type)\n    the hash node of the predicate, or 0 on error.  If an answer was\n    supplied, it is placed in ANSWERP, otherwise it is set to 0.  */\n static cpp_hashnode *\n-parse_assertion (pfile, answerp, type)\n-     cpp_reader *pfile;\n-     struct answer **answerp;\n-     int type;\n+parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n {\n   cpp_hashnode *result = 0;\n   const cpp_token *predicate;\n@@ -1753,9 +1658,7 @@ parse_assertion (pfile, answerp, type)\n /* Returns a pointer to the pointer to CANDIDATE in the answer chain,\n    or a pointer to NULL if the answer is not in the chain.  */\n static struct answer **\n-find_answer (node, candidate)\n-     cpp_hashnode *node;\n-     const struct answer *candidate;\n+find_answer (cpp_hashnode *node, const struct answer *candidate)\n {\n   unsigned int i;\n   struct answer **result;\n@@ -1782,9 +1685,7 @@ find_answer (node, candidate)\n    nonzero on failure, zero on success.  On success, the result of\n    the test is written into VALUE, otherwise the value 0.  */\n int\n-_cpp_test_assertion (pfile, value)\n-     cpp_reader *pfile;\n-     unsigned int *value;\n+_cpp_test_assertion (cpp_reader *pfile, unsigned int *value)\n {\n   struct answer *answer;\n   cpp_hashnode *node;\n@@ -1807,8 +1708,7 @@ _cpp_test_assertion (pfile, value)\n \n /* Handle #assert.  */\n static void\n-do_assert (pfile)\n-     cpp_reader *pfile;\n+do_assert (cpp_reader *pfile)\n {\n   struct answer *new_answer;\n   cpp_hashnode *node;\n@@ -1841,8 +1741,7 @@ do_assert (pfile)\n \n /* Handle #unassert.  */\n static void\n-do_unassert (pfile)\n-     cpp_reader *pfile;\n+do_unassert (cpp_reader *pfile)\n {\n   cpp_hashnode *node;\n   struct answer *answer;\n@@ -1880,9 +1779,7 @@ do_unassert (pfile)\n    If STR has anything after the identifier, then it should\n    be identifier=definition.  */\n void\n-cpp_define (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n+cpp_define (cpp_reader *pfile, const char *str)\n {\n   char *buf, *p;\n   size_t count;\n@@ -1910,9 +1807,7 @@ cpp_define (pfile, str)\n \n /* Slight variant of the above for use by initialize_builtins.  */\n void\n-_cpp_define_builtin (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n+_cpp_define_builtin (cpp_reader *pfile, const char *str)\n {\n   size_t len = strlen (str);\n   char *buf = alloca (len + 1);\n@@ -1923,9 +1818,7 @@ _cpp_define_builtin (pfile, str)\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n void\n-cpp_undef (pfile, macro)\n-     cpp_reader *pfile;\n-     const char *macro;\n+cpp_undef (cpp_reader *pfile, const char *macro)\n {\n   size_t len = strlen (macro);\n   char *buf = alloca (len + 1);\n@@ -1936,28 +1829,21 @@ cpp_undef (pfile, macro)\n \n /* Process the string STR as if it appeared as the body of a #assert.  */\n void\n-cpp_assert (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n+cpp_assert (cpp_reader *pfile, const char *str)\n {\n   handle_assertion (pfile, str, T_ASSERT);\n }\n \n /* Process STR as if it appeared as the body of an #unassert.  */\n void\n-cpp_unassert (pfile, str)\n-     cpp_reader *pfile;\n-     const char *str;\n+cpp_unassert (cpp_reader *pfile, const char *str)\n {\n   handle_assertion (pfile, str, T_UNASSERT);\n }\n \n /* Common code for cpp_assert (-A) and cpp_unassert (-A-).  */\n static void\n-handle_assertion (pfile, str, type)\n-     cpp_reader *pfile;\n-     const char *str;\n-     int type;\n+handle_assertion (cpp_reader *pfile, const char *str, int type)\n {\n   size_t count = strlen (str);\n   const char *p = strchr (str, '=');\n@@ -1980,41 +1866,35 @@ handle_assertion (pfile, str, type)\n \n /* The number of errors for a given reader.  */\n unsigned int\n-cpp_errors (pfile)\n-     cpp_reader *pfile;\n+cpp_errors (cpp_reader *pfile)\n {\n   return pfile->errors;\n }\n \n /* The options structure.  */\n cpp_options *\n-cpp_get_options (pfile)\n-     cpp_reader *pfile;\n+cpp_get_options (cpp_reader *pfile)\n {\n   return &pfile->opts;\n }\n \n /* The callbacks structure.  */\n cpp_callbacks *\n-cpp_get_callbacks (pfile)\n-     cpp_reader *pfile;\n+cpp_get_callbacks (cpp_reader *pfile)\n {\n   return &pfile->cb;\n }\n \n /* The line map set.  */\n const struct line_maps *\n-cpp_get_line_maps (pfile)\n-     cpp_reader *pfile;\n+cpp_get_line_maps (cpp_reader *pfile)\n {\n   return &pfile->line_maps;\n }\n \n /* Copy the given callbacks structure to our own.  */\n void\n-cpp_set_callbacks (pfile, cb)\n-     cpp_reader *pfile;\n-     cpp_callbacks *cb;\n+cpp_set_callbacks (cpp_reader *pfile, cpp_callbacks *cb)\n {\n   pfile->cb = *cb;\n }\n@@ -2023,12 +1903,8 @@ cpp_set_callbacks (pfile, cb)\n    doesn't fail.  It does not generate a file change call back; that\n    is the responsibility of the caller.  */\n cpp_buffer *\n-cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n-     cpp_reader *pfile;\n-     const uchar *buffer;\n-     size_t len;\n-     int from_stage3;\n-     int return_at_eof;\n+cpp_push_buffer (cpp_reader *pfile, const uchar *buffer, size_t len,\n+\t\t int from_stage3, int return_at_eof)\n {\n   cpp_buffer *new = xobnew (&pfile->buffer_ob, cpp_buffer);\n \n@@ -2049,8 +1925,7 @@ cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n /* Pops a single buffer, with a file change call-back if appropriate.\n    Then pushes the next -include file, if any remain.  */\n void\n-_cpp_pop_buffer (pfile)\n-     cpp_reader *pfile;\n+_cpp_pop_buffer (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n   struct include_file *inc = buffer->inc;\n@@ -2086,8 +1961,7 @@ _cpp_pop_buffer (pfile)\n \n /* Enter all recognized directives in the hash table.  */\n void\n-_cpp_init_directives (pfile)\n-     cpp_reader *pfile;\n+_cpp_init_directives (cpp_reader *pfile)\n {\n   unsigned int i;\n   cpp_hashnode *node;"}, {"sha": "0d7400344f8516d9a69a33369a867df5d60aba40", "filename": "gcc/cpplib.h", "status": "modified", "additions": 79, "deletions": 95, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -375,16 +375,16 @@ struct cpp_options\n struct cpp_callbacks\n {\n   /* Called when a new line of preprocessed output is started.  */\n-  void (*line_change) PARAMS ((cpp_reader *, const cpp_token *, int));\n-  void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n-  void (*include) PARAMS ((cpp_reader *, unsigned int,\n-\t\t\t   const unsigned char *, const char *, int));\n-  void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-  void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-  void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n-  void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n-  int (*valid_pch) PARAMS ((cpp_reader *, const char *, int));\n-  void (*read_pch) PARAMS ((cpp_reader *, const char *, int, const char *));\n+  void (*line_change) (cpp_reader *, const cpp_token *, int);\n+  void (*file_change) (cpp_reader *, const struct line_map *);\n+  void (*include) (cpp_reader *, unsigned int, const unsigned char *,\n+\t\t   const char *, int);\n+  void (*define) (cpp_reader *, unsigned int, cpp_hashnode *);\n+  void (*undef) (cpp_reader *, unsigned int, cpp_hashnode *);\n+  void (*ident) (cpp_reader *, unsigned int, const cpp_string *);\n+  void (*def_pragma) (cpp_reader *, unsigned int);\n+  int (*valid_pch) (cpp_reader *, const char *, int);\n+  void (*read_pch) (cpp_reader *, const char *, int, const char *);\n };\n \n /* Chain of directories to look for include files in.  */\n@@ -494,91 +494,83 @@ struct cpp_hashnode GTY(())\n    pointer.  Otherwise you should pass in an initialized hash table\n    that cpplib will share; this technique is used by the C front\n    ends.  */\n-extern cpp_reader *cpp_create_reader PARAMS ((enum c_lang, struct ht *));\n+extern cpp_reader *cpp_create_reader (enum c_lang, struct ht *);\n \n /* Call this to change the selected language standard (e.g. because of\n    command line options).  */\n-extern void cpp_set_lang PARAMS ((cpp_reader *, enum c_lang));\n+extern void cpp_set_lang (cpp_reader *, enum c_lang);\n \n /* Add a dependency TARGET.  Quote it for \"make\" if QUOTE.  Can be\n    called any number of times before cpp_read_main_file().  If no\n    targets have been added before cpp_read_main_file(), then the\n    default target is used.  */\n-extern void cpp_add_dependency_target PARAMS ((cpp_reader *,\n-\t\t\t\t\t       const char * target,\n-\t\t\t\t\t       int quote));\n+extern void cpp_add_dependency_target (cpp_reader *, const char *, int);\n \n /* Set the include paths.  */\n-extern void cpp_set_include_chains PARAMS ((cpp_reader *, cpp_path *,\n-\t\t\t\t\t    cpp_path *, int));\n+extern void cpp_set_include_chains (cpp_reader *, cpp_path *, cpp_path *, int);\n \n /* Call these to get pointers to the options and callback structures\n    for a given reader.  These pointers are good until you call\n    cpp_finish on that reader.  You can either edit the callbacks\n    through the pointer returned from cpp_get_callbacks, or set them\n    with cpp_set_callbacks.  */\n-extern cpp_options *cpp_get_options PARAMS ((cpp_reader *));\n-extern const struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n-extern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\n-extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n+extern cpp_options *cpp_get_options (cpp_reader *);\n+extern const struct line_maps *cpp_get_line_maps (cpp_reader *);\n+extern cpp_callbacks *cpp_get_callbacks (cpp_reader *);\n+extern void cpp_set_callbacks (cpp_reader *, cpp_callbacks *);\n \n /* This function reads the file, but does not start preprocessing.  It\n    returns the name of the original file; this is the same as the\n    input file, except for preprocessed input.  This will generate at\n    least one file change callback, and possibly a line change callback\n    too.  If there was an error opening the file, it returns NULL.  */\n-extern const char *cpp_read_main_file PARAMS ((cpp_reader *, const char *));\n+extern const char *cpp_read_main_file (cpp_reader *, const char *);\n \n /* Set up built-ins like __FILE__.  */\n-extern void cpp_init_builtins PARAMS ((cpp_reader *, int));\n+extern void cpp_init_builtins (cpp_reader *, int);\n \n /* Call this to finish preprocessing.  If you requested dependency\n    generation, pass an open stream to write the information to,\n    otherwise NULL.  It is your responsibility to close the stream.\n \n    Returns cpp_errors (pfile).  */\n-extern int cpp_finish PARAMS ((cpp_reader *, FILE *deps_stream));\n+extern int cpp_finish (cpp_reader *, FILE *deps_stream);\n \n /* Call this to release the handle at the end of preprocessing.  Any\n    use of the handle after this function returns is invalid.  Returns\n    cpp_errors (pfile).  */\n-extern void cpp_destroy PARAMS ((cpp_reader *));\n+extern void cpp_destroy (cpp_reader *);\n \n /* Error count.  */\n-extern unsigned int cpp_errors PARAMS ((cpp_reader *));\n-\n-extern unsigned int cpp_token_len PARAMS ((const cpp_token *));\n-extern unsigned char *cpp_token_as_text PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_token *));\n-extern unsigned char *cpp_spell_token PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t       unsigned char *));\n-extern void cpp_register_pragma PARAMS ((cpp_reader *,\n-\t\t\t\t\t const char *, const char *,\n-\t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n-\n-extern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t    const cpp_token *));\n-extern const cpp_token *cpp_get_token PARAMS ((cpp_reader *));\n-extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t  const cpp_hashnode *));\n-extern void _cpp_backup_tokens PARAMS ((cpp_reader *, unsigned int));\n+extern unsigned int cpp_errors (cpp_reader *);\n+\n+extern unsigned int cpp_token_len (const cpp_token *);\n+extern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);\n+extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,\n+\t\t\t\t       unsigned char *);\n+extern void cpp_register_pragma (cpp_reader *, const char *, const char *,\n+\t\t\t\t void (*) (cpp_reader *));\n+extern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n+\t\t\t    const cpp_token *);\n+extern const cpp_token *cpp_get_token (cpp_reader *);\n+extern const unsigned char *cpp_macro_definition (cpp_reader *,\n+\t\t\t\t\t\t  const cpp_hashnode *);\n+extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n \n /* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n-extern cppchar_t\n-cpp_interpret_charconst PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t unsigned int *, int *));\n+extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n+\t\t\t\t\t  unsigned int *, int *);\n \n /* Used to register macros and assertions, perhaps from the command line.\n    The text is the same as the command line argument.  */\n-extern void cpp_define PARAMS ((cpp_reader *, const char *));\n-extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n-extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n-extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n+extern void cpp_define (cpp_reader *, const char *);\n+extern void cpp_assert (cpp_reader *, const char *);\n+extern void cpp_undef (cpp_reader *, const char *);\n+extern void cpp_unassert (cpp_reader *, const char *);\n \n-extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n-\t\t\t\t\t    const unsigned char *, size_t,\n-\t\t\t\t\t    int, int));\n-extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n+extern cpp_buffer *cpp_push_buffer (cpp_reader *, const unsigned char *,\n+\t\t\t\t    size_t, int, int);\n+extern int cpp_defined (cpp_reader *, const unsigned char *, int);\n \n /* A preprocessing number.  Code assumes that any unused high bits of\n    the double integer are set to zero.  */\n@@ -619,15 +611,15 @@ struct cpp_num\n \n /* Classify a CPP_NUMBER token.  The return value is a combination of\n    the flags from the above sets.  */\n-extern unsigned cpp_classify_number PARAMS ((cpp_reader *, const cpp_token *));\n+extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *);\n \n /* Evaluate a token classified as category CPP_N_INTEGER.  */\n-extern cpp_num cpp_interpret_integer PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t      unsigned int type));\n+extern cpp_num cpp_interpret_integer (cpp_reader *, const cpp_token *,\n+\t\t\t\t      unsigned int type);\n \n /* Sign extend a number, with PRECISION significant bits and all\n    others assumed clear, to fill out a cpp_num structure.  */\n-cpp_num cpp_num_sign_extend PARAMS ((cpp_num, size_t));\n+cpp_num cpp_num_sign_extend (cpp_num, size_t);\n \n /* Diagnostic levels.  To get a diagnostic without associating a\n    position in the translation unit with it, use cpp_error_with_line\n@@ -657,72 +649,64 @@ cpp_num cpp_num_sign_extend PARAMS ((cpp_num, size_t));\n    getting ridiculously oversized.  */\n \n /* Output a diagnostic of some kind.  */\n-extern void cpp_error PARAMS ((cpp_reader *, int, const char *msgid, ...))\n+extern void cpp_error (cpp_reader *, int, const char *msgid, ...)\n   ATTRIBUTE_PRINTF_3;\n \n-/* Output a diagnostic of severity LEVEL, with \"MSG: \" preceding the\n+/* Output a diagnostic with \"MSGID: \" preceding the\n    error string of errno.  No location is printed.  */\n-extern void cpp_errno PARAMS ((cpp_reader *, int level, const char *msg));\n+extern void cpp_errno (cpp_reader *, int, const char *msgid);\n \n /* Same as cpp_error, except additionally specifies a position as a\n    (translation unit) physical line and physical column.  If the line is\n    zero, then no location is printed.  */\n-extern void cpp_error_with_line PARAMS ((cpp_reader *, int, unsigned, unsigned, const char *msgid, ...))\n+extern void cpp_error_with_line (cpp_reader *, int, unsigned, unsigned, const char *msgid, ...)\n   ATTRIBUTE_PRINTF_5;\n \n /* In cpplex.c */\n-extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n-\t\t\t\t\t\t const char *));\n-extern void cpp_output_line\t\tPARAMS ((cpp_reader *, FILE *));\n-extern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\n-extern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\n+extern int cpp_ideq (const cpp_token *, const char *);\n+extern void cpp_output_line (cpp_reader *, FILE *);\n+extern void cpp_output_token (const cpp_token *, FILE *);\n+extern const char *cpp_type2name (enum cpp_ttype);\n /* Returns the value of an escape sequence, truncated to the correct\n    target precision.  PSTR points to the input pointer, which is just\n    after the backslash.  LIMIT is how much text we have.  WIDE is true\n    if the escape sequence is part of a wide character constant or\n    string literal.  Handles all relevant diagnostics.  */\n-extern cppchar_t cpp_parse_escape\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char ** pstr,\n-\t\t\t\t\t\t const unsigned char *limit,\n-\t\t\t\t\t\t int wide));\n+extern cppchar_t cpp_parse_escape (cpp_reader *, const unsigned char ** pstr,\n+\t\t\t\t   const unsigned char *limit, int wide);\n \n /* In cpphash.c */\n \n /* Lookup an identifier in the hashtable.  Puts the identifier in the\n    table if it is not already there.  */\n-extern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *,\n-\t\t\t\t\t\t unsigned int));\n+extern cpp_hashnode *cpp_lookup (cpp_reader *, const unsigned char *,\n+\t\t\t\t unsigned int);\n \n-typedef int (*cpp_cb) PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t cpp_cb, void *));\n+typedef int (*cpp_cb) (cpp_reader *, cpp_hashnode *, void *);\n+extern void cpp_forall_identifiers (cpp_reader *, cpp_cb, void *);\n \n /* In cppmacro.c */\n-extern void cpp_scan_nooutput\t\tPARAMS ((cpp_reader *));\n-extern int  cpp_sys_macro_p\t\tPARAMS ((cpp_reader *));\n-extern unsigned char *cpp_quote_string\tPARAMS ((unsigned char *,\n-\t\t\t\t\t\t const unsigned char *,\n-\t\t\t\t\t\t unsigned int));\n+extern void cpp_scan_nooutput (cpp_reader *);\n+extern int  cpp_sys_macro_p (cpp_reader *);\n+extern unsigned char *cpp_quote_string (unsigned char *, const unsigned char *,\n+\t\t\t\t\tunsigned int);\n \n /* In cppfiles.c */\n-extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n-extern void cpp_make_system_header PARAMS ((cpp_reader *, int, int));\n-extern void cpp_simplify_path PARAMS ((char *));\n-extern bool cpp_push_include PARAMS ((cpp_reader *, const char *));\n-extern void cpp_change_file PARAMS ((cpp_reader *, enum lc_reason,\n-\t\t\t\t     const char *));\n+extern int cpp_included (cpp_reader *, const char *);\n+extern void cpp_make_system_header (cpp_reader *, int, int);\n+extern void cpp_simplify_path (char *);\n+extern bool cpp_push_include (cpp_reader *, const char *);\n+extern void cpp_change_file (cpp_reader *, enum lc_reason, const char *);\n \n /* In cpppch.c */\n struct save_macro_data;\n-extern int cpp_save_state PARAMS ((cpp_reader *, FILE *));\n-extern int cpp_write_pch_deps PARAMS ((cpp_reader *, FILE *));\n-extern int cpp_write_pch_state PARAMS ((cpp_reader *, FILE *));\n-extern int cpp_valid_state PARAMS ((cpp_reader *, const char *, int));\n-extern void cpp_prepare_state PARAMS ((cpp_reader *, \n-\t\t\t\t       struct save_macro_data **));\n-extern int cpp_read_state PARAMS ((cpp_reader *, const char *, FILE *,\n-\t\t\t\t   struct save_macro_data *));\n+extern int cpp_save_state (cpp_reader *, FILE *);\n+extern int cpp_write_pch_deps (cpp_reader *, FILE *);\n+extern int cpp_write_pch_state (cpp_reader *, FILE *);\n+extern int cpp_valid_state (cpp_reader *, const char *, int);\n+extern void cpp_prepare_state (cpp_reader *, struct save_macro_data **);\n+extern int cpp_read_state (cpp_reader *, const char *, FILE *,\n+\t\t\t   struct save_macro_data *);\n \n #ifdef __cplusplus\n }"}, {"sha": "893dd215b619beb72f74dd49736ec9576e91bf5e", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 68, "deletions": 145, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -42,47 +42,40 @@ struct macro_arg\n \n /* Macro expansion.  */\n \n-static int enter_macro_context PARAMS ((cpp_reader *, cpp_hashnode *));\n-static int builtin_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n-static void push_token_context\n-  PARAMS ((cpp_reader *, cpp_hashnode *, const cpp_token *, unsigned int));\n-static void push_ptoken_context\n-  PARAMS ((cpp_reader *, cpp_hashnode *, _cpp_buff *,\n-\t   const cpp_token **, unsigned int));\n-static _cpp_buff *collect_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n-static cpp_context *next_context PARAMS ((cpp_reader *));\n-static const cpp_token *padding_token\n-  PARAMS ((cpp_reader *, const cpp_token *));\n-static void expand_arg PARAMS ((cpp_reader *, macro_arg *));\n-static const cpp_token *new_string_token PARAMS ((cpp_reader *, uchar *,\n-\t\t\t\t\t\t  unsigned int));\n-static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n-static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n-static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n-\t\t\t\t  const cpp_token *));\n-static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, cpp_macro *,\n-\t\t\t\t  macro_arg *));\n-static _cpp_buff *funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n-static bool create_iso_definition PARAMS ((cpp_reader *, cpp_macro *));\n+static int enter_macro_context (cpp_reader *, cpp_hashnode *);\n+static int builtin_macro (cpp_reader *, cpp_hashnode *);\n+static void push_token_context (cpp_reader *, cpp_hashnode *,\n+\t\t\t\tconst cpp_token *, unsigned int);\n+static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,\n+\t\t\t\t const cpp_token **, unsigned int);\n+static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *);\n+static cpp_context *next_context (cpp_reader *);\n+static const cpp_token *padding_token (cpp_reader *, const cpp_token *);\n+static void expand_arg (cpp_reader *, macro_arg *);\n+static const cpp_token *new_string_token (cpp_reader *, uchar *, unsigned int);\n+static const cpp_token *stringify_arg (cpp_reader *, macro_arg *);\n+static void paste_all_tokens (cpp_reader *, const cpp_token *);\n+static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);\n+static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,\n+\t\t\t  macro_arg *);\n+static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *);\n+static bool create_iso_definition (cpp_reader *, cpp_macro *);\n \n /* #define directive parsing and handling.  */\n \n-static cpp_token *alloc_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n-static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n-static bool warn_of_redefinition PARAMS ((cpp_reader *, const cpp_hashnode *,\n-\t\t\t\t\t  const cpp_macro *));\n-static bool parse_params PARAMS ((cpp_reader *, cpp_macro *));\n-static void check_trad_stringification PARAMS ((cpp_reader *,\n-\t\t\t\t\t\tconst cpp_macro *,\n-\t\t\t\t\t\tconst cpp_string *));\n+static cpp_token *alloc_expansion_token (cpp_reader *, cpp_macro *);\n+static cpp_token *lex_expansion_token (cpp_reader *, cpp_macro *);\n+static bool warn_of_redefinition (cpp_reader *, const cpp_hashnode *,\n+\t\t\t\t  const cpp_macro *);\n+static bool parse_params (cpp_reader *, cpp_macro *);\n+static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n+\t\t\t\t\tconst cpp_string *);\n \n /* Emits a warning if NODE is a macro defined in the main file that\n    has not been used.  */\n int\n-_cpp_warn_if_unused_macro (pfile, node, v)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-     void *v ATTRIBUTE_UNUSED;\n+_cpp_warn_if_unused_macro (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\t   void *v ATTRIBUTE_UNUSED)\n {\n   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {\n@@ -100,10 +93,7 @@ _cpp_warn_if_unused_macro (pfile, node, v)\n /* Allocates and returns a CPP_STRING token, containing TEXT of length\n    LEN, after null-terminating it.  TEXT must be in permanent storage.  */\n static const cpp_token *\n-new_string_token (pfile, text, len)\n-     cpp_reader *pfile;\n-     unsigned char *text;\n-     unsigned int len;\n+new_string_token (cpp_reader *pfile, unsigned char *text, unsigned int len)\n {\n   cpp_token *token = _cpp_temp_token (pfile);\n \n@@ -126,9 +116,7 @@ static const char * const monthnames[] =\n    is created.  Returns 1 if it generates a new token context, 0 to\n    return the token to the caller.  */\n const uchar *\n-_cpp_builtin_macro_text (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+_cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n {\n   const uchar *result = NULL;\n   unsigned int number = 1;\n@@ -221,7 +209,8 @@ _cpp_builtin_macro_text (pfile, node)\n \t      pfile->date = _cpp_unaligned_alloc (pfile,\n \t\t\t\t\t\t  sizeof (\"\\\"Oct 11 1347\\\"\"));\n \t      sprintf ((char *) pfile->date, \"\\\"%s %2d %4d\\\"\",\n-\t\t       monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n+\t\t       monthnames[tb->tm_mon], tb->tm_mday,\n+\t\t       tb->tm_year + 1900);\n \n \t      pfile->time = _cpp_unaligned_alloc (pfile,\n \t\t\t\t\t\t  sizeof (\"\\\"12:34:56\\\"\"));\n@@ -260,9 +249,7 @@ _cpp_builtin_macro_text (pfile, node)\n    created.  Returns 1 if it generates a new token context, 0 to\n    return the token to the caller.  */\n static int\n-builtin_macro (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n {\n   const uchar *buf;\n   size_t len;\n@@ -304,10 +291,7 @@ builtin_macro (pfile, node)\n    converted to octal.  DEST must be of sufficient size.  Returns\n    a pointer to the end of the string.  */\n uchar *\n-cpp_quote_string (dest, src, len)\n-     uchar *dest;\n-     const uchar *src;\n-     unsigned int len;\n+cpp_quote_string (uchar *dest, const uchar *src, unsigned int len)\n {\n   while (len--)\n     {\n@@ -336,9 +320,7 @@ cpp_quote_string (dest, src, len)\n /* Convert a token sequence ARG to a single string token according to\n    the rules of the ISO C #-operator.  */\n static const cpp_token *\n-stringify_arg (pfile, arg)\n-     cpp_reader *pfile;\n-     macro_arg *arg;\n+stringify_arg (cpp_reader *pfile, macro_arg *arg)\n {\n   unsigned char *dest;\n   unsigned int i, escape_it, backslash_count = 0;\n@@ -425,9 +407,7 @@ stringify_arg (pfile, arg)\n    case, PLHS is updated to point to the pasted token, which is\n    guaranteed to not have the PASTE_LEFT flag set.  */\n static bool\n-paste_tokens (pfile, plhs, rhs)\n-     cpp_reader *pfile;\n-     const cpp_token **plhs, *rhs;\n+paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n {\n   unsigned char *buf, *end;\n   const cpp_token *lhs;\n@@ -468,9 +448,7 @@ paste_tokens (pfile, plhs, rhs)\n    successful pastes, with the effect that the RHS appears in the\n    output stream after the pasted LHS normally.  */\n static void\n-paste_all_tokens (pfile, lhs)\n-     cpp_reader *pfile;\n-     const cpp_token *lhs;\n+paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n {\n   const cpp_token *rhs;\n   cpp_context *context = pfile->context;\n@@ -516,11 +494,7 @@ paste_all_tokens (pfile, lhs)\n    Note that MACRO cannot necessarily be deduced from NODE, in case\n    NODE was redefined whilst collecting arguments.  */\n bool\n-_cpp_arguments_ok (pfile, macro, node, argc)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n-     const cpp_hashnode *node;\n-     unsigned int argc;\n+_cpp_arguments_ok (cpp_reader *pfile, cpp_macro *macro, const cpp_hashnode *node, unsigned int argc)\n {\n   if (argc == macro->paramc)\n     return true;\n@@ -561,9 +535,7 @@ _cpp_arguments_ok (pfile, macro, node, argc)\n    NULL.  Each argument is terminated by a CPP_EOF token, for the\n    future benefit of expand_arg().  */\n static _cpp_buff *\n-collect_args (pfile, node)\n-     cpp_reader *pfile;\n-     const cpp_hashnode *node;\n+collect_args (cpp_reader *pfile, const cpp_hashnode *node)\n {\n   _cpp_buff *buff, *base_buff;\n   cpp_macro *macro;\n@@ -697,9 +669,7 @@ collect_args (pfile, node)\n    intervening padding tokens.  If we find the parenthesis, collect\n    the arguments and return the buffer containing them.  */\n static _cpp_buff *\n-funlike_invocation_p (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node)\n {\n   const cpp_token *token, *padding = NULL;\n \n@@ -739,9 +709,7 @@ funlike_invocation_p (pfile, node)\n    containing its yet-to-be-rescanned replacement list and return one.\n    Otherwise, we don't push a context and return zero.  */\n static int\n-enter_macro_context (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n {\n   /* The presence of a macro invalidates a file's controlling macro.  */\n   pfile->mi_valid = false;\n@@ -800,11 +768,7 @@ enter_macro_context (pfile, node)\n    Expand each argument before replacing, unless it is operated upon\n    by the # or ## operators.  */\n static void\n-replace_args (pfile, node, macro, args)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-     cpp_macro *macro;\n-     macro_arg *args;\n+replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro, macro_arg *args)\n {\n   unsigned int i, total;\n   const cpp_token *src, *limit;\n@@ -936,9 +900,7 @@ replace_args (pfile, node, macro, args)\n \n /* Return a special padding token, with padding inherited from SOURCE.  */\n static const cpp_token *\n-padding_token (pfile, source)\n-     cpp_reader *pfile;\n-     const cpp_token *source;\n+padding_token (cpp_reader *pfile, const cpp_token *source)\n {\n   cpp_token *result = _cpp_temp_token (pfile);\n \n@@ -951,8 +913,7 @@ padding_token (pfile, source)\n /* Get a new uninitialized context.  Create a new one if we cannot\n    re-use an old one.  */\n static cpp_context *\n-next_context (pfile)\n-     cpp_reader *pfile;\n+next_context (cpp_reader *pfile)\n {\n   cpp_context *result = pfile->context->next;\n \n@@ -970,12 +931,8 @@ next_context (pfile)\n \n /* Push a list of pointers to tokens.  */\n static void\n-push_ptoken_context (pfile, macro, buff, first, count)\n-     cpp_reader *pfile;\n-     cpp_hashnode *macro;\n-     _cpp_buff *buff;\n-     const cpp_token **first;\n-     unsigned int count;\n+push_ptoken_context (cpp_reader *pfile, cpp_hashnode *macro, _cpp_buff *buff,\n+\t\t     const cpp_token **first, unsigned int count)\n {\n   cpp_context *context = next_context (pfile);\n \n@@ -988,11 +945,8 @@ push_ptoken_context (pfile, macro, buff, first, count)\n \n /* Push a list of tokens.  */\n static void\n-push_token_context (pfile, macro, first, count)\n-     cpp_reader *pfile;\n-     cpp_hashnode *macro;\n-     const cpp_token *first;\n-     unsigned int count;\n+push_token_context (cpp_reader *pfile, cpp_hashnode *macro,\n+\t\t    const cpp_token *first, unsigned int count)\n {\n   cpp_context *context = next_context (pfile);\n \n@@ -1005,11 +959,8 @@ push_token_context (pfile, macro, first, count)\n \n /* Push a traditional macro's replacement text.  */\n void\n-_cpp_push_text_context (pfile, macro, start, len)\n-     cpp_reader *pfile;\n-     cpp_hashnode *macro;\n-     const uchar *start;\n-     size_t len;\n+_cpp_push_text_context (cpp_reader *pfile, cpp_hashnode *macro,\n+\t\t\tconst uchar *start, size_t len)\n {\n   cpp_context *context = next_context (pfile);\n \n@@ -1028,9 +979,7 @@ _cpp_push_text_context (pfile, macro, start, len)\n    has terminated the argument's tokens with a CPP_EOF so that we know\n    when we have fully expanded the argument.  */\n static void\n-expand_arg (pfile, arg)\n-     cpp_reader *pfile;\n-     macro_arg *arg;\n+expand_arg (cpp_reader *pfile, macro_arg *arg)\n {\n   unsigned int capacity;\n   bool saved_warn_trad;\n@@ -1076,8 +1025,7 @@ expand_arg (pfile, arg)\n    context represented a macro's replacement list.  The context\n    structure is not freed so that we can re-use it later.  */\n void\n-_cpp_pop_context (pfile)\n-     cpp_reader *pfile;\n+_cpp_pop_context (cpp_reader *pfile)\n {\n   cpp_context *context = pfile->context;\n \n@@ -1102,8 +1050,7 @@ _cpp_pop_context (pfile)\n    state.in_directive is still 1, and at the end of argument\n    pre-expansion.  */\n const cpp_token *\n-cpp_get_token (pfile)\n-     cpp_reader *pfile;\n+cpp_get_token (cpp_reader *pfile)\n {\n   const cpp_token *result;\n \n@@ -1180,8 +1127,7 @@ cpp_get_token (pfile)\n    defined in a system header.  Just checks the macro at the top of\n    the stack.  Used for diagnostic suppression.  */\n int\n-cpp_sys_macro_p (pfile)\n-     cpp_reader *pfile;\n+cpp_sys_macro_p (cpp_reader *pfile)\n {\n   cpp_hashnode *node = pfile->context->macro;\n \n@@ -1191,8 +1137,7 @@ cpp_sys_macro_p (pfile)\n /* Read each token in, until end of the current file.  Directives are\n    transparently processed.  */\n void\n-cpp_scan_nooutput (pfile)\n-     cpp_reader *pfile;\n+cpp_scan_nooutput (cpp_reader *pfile)\n {\n   /* Request a CPP_EOF token at the end of this file, rather than\n      transparently continuing with the including file.  */\n@@ -1209,9 +1154,7 @@ cpp_scan_nooutput (pfile)\n /* Step back one (or more) tokens.  Can only step mack more than 1 if\n    they are from the lexer, and not from macro expansion.  */\n void\n-_cpp_backup_tokens (pfile, count)\n-     cpp_reader *pfile;\n-     unsigned int count;\n+_cpp_backup_tokens (cpp_reader *pfile, unsigned int count)\n {\n   if (pfile->context->prev == NULL)\n     {\n@@ -1243,10 +1186,8 @@ _cpp_backup_tokens (pfile, count)\n \n /* Returns nonzero if a macro redefinition warning is required.  */\n static bool\n-warn_of_redefinition (pfile, node, macro2)\n-     cpp_reader *pfile;\n-     const cpp_hashnode *node;\n-     const cpp_macro *macro2;\n+warn_of_redefinition (cpp_reader *pfile, const cpp_hashnode *node,\n+\t\t      const cpp_macro *macro2)\n {\n   const cpp_macro *macro1;\n   unsigned int i;\n@@ -1287,8 +1228,7 @@ warn_of_redefinition (pfile, node, macro2)\n \n /* Free the definition of hashnode H.  */\n void\n-_cpp_free_definition (h)\n-     cpp_hashnode *h;\n+_cpp_free_definition (cpp_hashnode *h)\n {\n   /* Macros and assertions no longer have anything to free.  */\n   h->type = NT_VOID;\n@@ -1299,10 +1239,7 @@ _cpp_free_definition (h)\n /* Save parameter NODE to the parameter list of macro MACRO.  Returns\n    zero on success, nonzero if the parameter is a duplicate.  */\n bool\n-_cpp_save_parameter (pfile, macro, node)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n-     cpp_hashnode *node;\n+_cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n {\n   unsigned int len;\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n@@ -1335,9 +1272,7 @@ _cpp_save_parameter (pfile, macro, node)\n /* Check the syntax of the parameters in a MACRO definition.  Returns\n    false if an error occurs.  */\n static bool\n-parse_params (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+parse_params (cpp_reader *pfile, cpp_macro *macro)\n {\n   unsigned int prev_ident = 0;\n \n@@ -1416,9 +1351,7 @@ parse_params (pfile, macro)\n \n /* Allocate room for a token from a macro's replacement list.  */\n static cpp_token *\n-alloc_expansion_token (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+alloc_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n {\n   if (BUFF_ROOM (pfile->a_buff) < (macro->count + 1) * sizeof (cpp_token))\n     _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_token));\n@@ -1429,9 +1362,7 @@ alloc_expansion_token (pfile, macro)\n /* Lex a token from the expansion of MACRO, but mark parameters as we\n    find them and warn of traditional stringification.  */\n static cpp_token *\n-lex_expansion_token (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+lex_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n {\n   cpp_token *token;\n \n@@ -1453,9 +1384,7 @@ lex_expansion_token (pfile, macro)\n }\n \n static bool\n-create_iso_definition (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n {\n   cpp_token *token;\n   const cpp_token *ctoken;\n@@ -1524,7 +1453,7 @@ create_iso_definition (pfile, macro)\n \t  if (macro->count == 0 || token->type == CPP_EOF)\n \t    {\n \t      cpp_error (pfile, DL_ERROR,\n-\t\t\t \"'##' cannot appear at either end of a macro expansion\");\n+\t\t \"'##' cannot appear at either end of a macro expansion\");\n \t      return false;\n \t    }\n \n@@ -1551,9 +1480,7 @@ create_iso_definition (pfile, macro)\n \n /* Parse a macro and save its expansion.  Returns nonzero on success.  */\n bool\n-_cpp_create_definition (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+_cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n {\n   cpp_macro *macro;\n   unsigned int i;\n@@ -1634,10 +1561,8 @@ _cpp_create_definition (pfile, node)\n /* Warn if a token in STRING matches one of a function-like MACRO's\n    parameters.  */\n static void\n-check_trad_stringification (pfile, macro, string)\n-     cpp_reader *pfile;\n-     const cpp_macro *macro;\n-     const cpp_string *string;\n+check_trad_stringification (cpp_reader *pfile, const cpp_macro *macro,\n+\t\t\t    const cpp_string *string)\n {\n   unsigned int i, len;\n   const uchar *p, *q, *limit;\n@@ -1681,9 +1606,7 @@ check_trad_stringification (pfile, macro, string)\n    Caller is expected to generate the \"#define\" bit if needed.  The\n    returned text is temporary, and automatically freed later.  */\n const unsigned char *\n-cpp_macro_definition (pfile, node)\n-     cpp_reader *pfile;\n-     const cpp_hashnode *node;\n+cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n {\n   unsigned int i, len;\n   const cpp_macro *macro = node->value.macro;"}, {"sha": "e87abead4e8d38e6736b3e0dd496d3a3453477e6", "filename": "gcc/cpppch.c", "status": "modified", "additions": 28, "deletions": 66, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -24,16 +24,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"hashtab.h\"\n #include \"mkdeps.h\"\n \n-static int write_macdef PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-static int save_idents PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-static hashval_t hashmem PARAMS ((const void *, size_t));\n-static hashval_t cpp_string_hash PARAMS ((const void *));\n-static int cpp_string_eq PARAMS ((const void *, const void *));\n-static int count_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-static int comp_hashnodes PARAMS ((const void *, const void *));\n-static int collect_ht_nodes PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-static int write_defs PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-static int save_macros PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static int write_macdef (cpp_reader *, cpp_hashnode *, void *);\n+static int save_idents (cpp_reader *, cpp_hashnode *, void *);\n+static hashval_t hashmem (const void *, size_t);\n+static hashval_t cpp_string_hash (const void *);\n+static int cpp_string_eq (const void *, const void *);\n+static int count_defs (cpp_reader *, cpp_hashnode *, void *);\n+static int comp_hashnodes (const void *, const void *);\n+static int collect_ht_nodes (cpp_reader *, cpp_hashnode *, void *);\n+static int write_defs (cpp_reader *, cpp_hashnode *, void *);\n+static int save_macros (cpp_reader *, cpp_hashnode *, void *);\n \n /* This structure represents a macro definition on disk.  */\n struct macrodef_struct \n@@ -47,10 +47,7 @@ struct macrodef_struct\n    Suitable for being called by cpp_forall_identifiers.  */\n \n static int\n-write_macdef (pfile, hn, file_p)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hn;\n-     void *file_p;\n+write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n {\n   FILE *f = (FILE *) file_p;\n   switch (hn->type)\n@@ -123,10 +120,7 @@ struct cpp_savedstate\n    put the definition in 'definedstrs'.  */\n \n static int\n-save_idents (pfile, hn, ss_p)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_hashnode *hn;\n-     void *ss_p;\n+save_idents (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n   \n@@ -158,9 +152,7 @@ save_idents (pfile, hn, ss_p)\n /* Hash some memory in a generic way.  */\n \n static hashval_t\n-hashmem (p_p, sz)\n-     const void *p_p;\n-     size_t sz;\n+hashmem (const void *p_p, size_t sz)\n {\n   const unsigned char *p = (const unsigned char *)p_p;\n   size_t i;\n@@ -175,8 +167,7 @@ hashmem (p_p, sz)\n /* Hash a cpp string for the hashtable machinery.  */\n \n static hashval_t\n-cpp_string_hash (a_p)\n-     const void *a_p;\n+cpp_string_hash (const void *a_p)\n {\n   const struct cpp_string *a = (const struct cpp_string *) a_p;\n   return hashmem (a->text, a->len);\n@@ -185,9 +176,7 @@ cpp_string_hash (a_p)\n /* Compare two cpp strings for the hashtable machinery.  */\n \n static int\n-cpp_string_eq (a_p, b_p)\n-     const void *a_p;\n-     const void *b_p;\n+cpp_string_eq (const void *a_p, const void *b_p)\n {\n   const struct cpp_string *a = (const struct cpp_string *) a_p;\n   const struct cpp_string *b = (const struct cpp_string *) b_p;\n@@ -201,9 +190,7 @@ cpp_string_eq (a_p, b_p)\n    would be called when reading the precompiled header back in.  */\n \n int\n-cpp_save_state (r, f)\n-     cpp_reader *r;\n-     FILE *f;\n+cpp_save_state (cpp_reader *r, FILE *f)\n {\n   /* Save the list of non-void identifiers for the dependency checking.  */\n   r->savedstate = xmalloc (sizeof (struct cpp_savedstate));\n@@ -220,10 +207,7 @@ cpp_save_state (r, f)\n /* Calculate the 'hashsize' field of the saved state.  */\n \n static int\n-count_defs (pfile, hn, ss_p)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_hashnode *hn;\n-     void *ss_p;\n+count_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n   \n@@ -262,10 +246,7 @@ count_defs (pfile, hn, ss_p)\n \n /* Collect the identifiers into the state's string table. */\n static int\n-write_defs (pfile, hn, ss_p)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_hashnode *hn;\n-     void *ss_p;\n+write_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n   \n@@ -305,9 +286,7 @@ write_defs (pfile, hn, ss_p)\n /* Comparison function for qsort.  The arguments point to pointers of\n    type ht_hashnode *.  */\n static int\n-comp_hashnodes (px, py)\n-     const void *px;\n-     const void *py;\n+comp_hashnodes (const void *px, const void *py)\n {\n   cpp_hashnode *x = *(cpp_hashnode **) px;\n   cpp_hashnode *y = *(cpp_hashnode **) py;\n@@ -318,9 +297,7 @@ comp_hashnodes (px, py)\n    called after the PCH is ready to be saved.  */\n \n int\n-cpp_write_pch_deps (r, f)\n-     cpp_reader *r;\n-     FILE *f;\n+cpp_write_pch_deps (cpp_reader *r, FILE *f)\n {\n   struct macrodef_struct z;\n   struct cpp_savedstate *const ss = r->savedstate;\n@@ -367,9 +344,7 @@ cpp_write_pch_deps (r, f)\n    cpp_read_state.  */\n \n int\n-cpp_write_pch_state (r, f)\n-     cpp_reader *r;\n-     FILE *f;\n+cpp_write_pch_state (cpp_reader *r, FILE *f)\n {\n   struct macrodef_struct z;\n \n@@ -410,10 +385,8 @@ struct ht_node_list\n /* Callback for collecting identifiers from hash table */\n \n static int\n-collect_ht_nodes (pfile, hn, nl_p)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     cpp_hashnode *hn;\n-     void *nl_p;\n+collect_ht_nodes (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn,\n+\t\t  void *nl_p)\n {\n   struct ht_node_list *const nl = (struct ht_node_list *)nl_p;\n \n@@ -446,10 +419,7 @@ collect_ht_nodes (pfile, hn, nl_p)\n */\n \n int\n-cpp_valid_state (r, name, fd)\n-     cpp_reader *r;\n-     const char *name;\n-     int fd;\n+cpp_valid_state (cpp_reader *r, const char *name, int fd)\n {\n   struct macrodef_struct m;\n   size_t namebufsz = 256;\n@@ -583,10 +553,7 @@ struct save_macro_data\n    a PCH restore.  */\n \n static int \n-save_macros (r, h, data_p)\n-     cpp_reader *r ATTRIBUTE_UNUSED;\n-     cpp_hashnode *h;\n-     void *data_p;\n+save_macros (cpp_reader *r ATTRIBUTE_UNUSED, cpp_hashnode *h, void *data_p)\n {\n   struct save_macro_data *data = (struct save_macro_data *)data_p;\n   if (h->type != NT_VOID\n@@ -614,9 +581,7 @@ save_macros (r, h, data_p)\n    macros in 'data'.  */\n \n void\n-cpp_prepare_state (r, data)\n-     cpp_reader *r;\n-     struct save_macro_data **data;\n+cpp_prepare_state (cpp_reader *r, struct save_macro_data **data)\n {\n   struct save_macro_data *d = xmalloc (sizeof (struct save_macro_data));\n   \n@@ -632,11 +597,8 @@ cpp_prepare_state (r, data)\n    DEPNAME is passed to deps_restore.  */\n \n int\n-cpp_read_state (r, name, f, data)\n-     cpp_reader *r;\n-     const char *name;\n-     FILE *f;\n-     struct save_macro_data *data;\n+cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n+\t\tstruct save_macro_data *data)\n {\n   struct macrodef_struct m;\n   size_t defnlen = 256;"}, {"sha": "eb5205fa32390650a1f40943a2352c043a044540", "filename": "gcc/cppspec.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -51,10 +51,8 @@ static const char *const known_suffixes[] =\n \n /* Filter argc and argv before processing by the gcc driver proper.  */\n void\n-lang_specific_driver (in_argc, in_argv, in_added_libraries)\n-     int *in_argc;\n-     const char *const **in_argv;\n-     int *in_added_libraries ATTRIBUTE_UNUSED;\n+lang_specific_driver (int *in_argc, const char *const **in_argv,\n+\t\t      int *in_added_libraries ATTRIBUTE_UNUSED)\n {\n   int argc = *in_argc;\n   const char *const *argv = *in_argv;\n@@ -203,7 +201,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n }\n \n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n-int lang_specific_pre_link ()\n+int lang_specific_pre_link (void)\n {\n   return 0;  /* Not used for cpp.  */\n }"}, {"sha": "0e4b2314bb4077001e46aa9a223d7aa846877ae5", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 35, "deletions": 80, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "patch": "@@ -81,29 +81,24 @@ enum ls {ls_none = 0,\t\t/* Normal state.  */\n /* Lexing TODO: Maybe handle space in escaped newlines.  Stop cpplex.c\n    from recognizing comments and directives during its lexing pass.  */\n \n-static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *,\n-\t\t\t\t\t     int));\n-static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n-static const uchar *copy_comment PARAMS ((cpp_reader *, const uchar *, int));\n-static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n-static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n-static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n-static bool recursive_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n-static void save_replacement_text PARAMS ((cpp_reader *, cpp_macro *,\n-\t\t\t\t\t   unsigned int));\n-static void maybe_start_funlike PARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t const uchar *, struct fun_macro *));\n-static void save_argument PARAMS ((struct fun_macro *, size_t));\n-static void replace_args_and_push PARAMS ((cpp_reader *, struct fun_macro *));\n-static size_t canonicalize_text PARAMS ((uchar *, const uchar *, size_t,\n-\t\t\t\t\t uchar *));\n+static const uchar *skip_whitespace (cpp_reader *, const uchar *, int);\n+static cpp_hashnode *lex_identifier (cpp_reader *, const uchar *);\n+static const uchar *copy_comment (cpp_reader *, const uchar *, int);\n+static void check_output_buffer (cpp_reader *, size_t);\n+static void push_replacement_text (cpp_reader *, cpp_hashnode *);\n+static bool scan_parameters (cpp_reader *, cpp_macro *);\n+static bool recursive_macro (cpp_reader *, cpp_hashnode *);\n+static void save_replacement_text (cpp_reader *, cpp_macro *, unsigned int);\n+static void maybe_start_funlike (cpp_reader *, cpp_hashnode *, const uchar *,\n+\t\t\t\t struct fun_macro *);\n+static void save_argument (struct fun_macro *, size_t);\n+static void replace_args_and_push (cpp_reader *, struct fun_macro *);\n+static size_t canonicalize_text (uchar *, const uchar *, size_t, uchar *);\n \n /* Ensures we have N bytes' space in the output buffer, and\n    reallocates it if not.  */\n static void\n-check_output_buffer (pfile, n)\n-     cpp_reader *pfile;\n-     size_t n;\n+check_output_buffer (cpp_reader *pfile, size_t n)\n {\n   /* We might need two bytes to terminate an unterminated comment, and\n      one more to terminate the line with a NUL.  */\n@@ -134,10 +129,7 @@ check_output_buffer (pfile, n)\n    Returns a pointer to the first character after the comment in the\n    input buffer.  */\n static const uchar *\n-copy_comment (pfile, cur, in_define)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n-     int in_define;\n+copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n {\n   bool unterminated, copy = false;\n   unsigned int from_line = pfile->line;\n@@ -197,10 +189,7 @@ copy_comment (pfile, cur, in_define)\n    Returns a pointer to the first character after the whitespace in\n    the input buffer.  */\n static const uchar *\n-skip_whitespace (pfile, cur, skip_comments)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n-     int skip_comments;\n+skip_whitespace (cpp_reader *pfile, const uchar *cur, int skip_comments)\n {\n   uchar *out = pfile->out.cur;\n \n@@ -232,9 +221,7 @@ skip_whitespace (pfile, cur, skip_comments)\n    to point to a valid first character of an identifier.  Returns\n    the hashnode, and updates out.cur.  */\n static cpp_hashnode *\n-lex_identifier (pfile, cur)\n-     cpp_reader *pfile;\n-     const uchar *cur;\n+lex_identifier (cpp_reader *pfile, const uchar *cur)\n {\n   size_t len;\n   uchar *out = pfile->out.cur;\n@@ -256,10 +243,7 @@ lex_identifier (pfile, cur)\n    starting at START.  The true buffer is restored upon calling\n    restore_buff().  */\n void\n-_cpp_overlay_buffer (pfile, start, len)\n-     cpp_reader *pfile;\n-     const uchar *start;\n-     size_t len;\n+_cpp_overlay_buffer (cpp_reader *pfile, const uchar *start, size_t len)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n@@ -276,8 +260,7 @@ _cpp_overlay_buffer (pfile, start, len)\n \n /* Restores a buffer overlaid by _cpp_overlay_buffer().  */\n void\n-_cpp_remove_overlay (pfile)\n-     cpp_reader *pfile;\n+_cpp_remove_overlay (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->overlaid_buffer;\n \n@@ -292,8 +275,7 @@ _cpp_remove_overlay (pfile)\n /* Reads a logical line into the output buffer.  Returns TRUE if there\n    is more text left in the buffer.  */\n bool\n-_cpp_read_logical_line_trad (pfile)\n-     cpp_reader *pfile;\n+_cpp_read_logical_line_trad (cpp_reader *pfile)\n {\n   do\n     {\n@@ -308,11 +290,7 @@ _cpp_read_logical_line_trad (pfile)\n /* Set up state for finding the opening '(' of a function-like\n    macro.  */\n static void\n-maybe_start_funlike (pfile, node, start, macro)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-     const uchar *start;\n-     struct fun_macro *macro;\n+maybe_start_funlike (cpp_reader *pfile, cpp_hashnode *node, const uchar *start, struct fun_macro *macro)\n {\n   unsigned int n = node->value.macro->paramc + 1;\n \n@@ -327,9 +305,7 @@ maybe_start_funlike (pfile, node, start, macro)\n \n /* Save the OFFSET of the start of the next argument to MACRO.  */\n static void\n-save_argument (macro, offset)\n-     struct fun_macro *macro;\n-     size_t offset;\n+save_argument (struct fun_macro *macro, size_t offset)\n {\n   macro->argc++;\n   if (macro->argc <= macro->node->value.macro->paramc)\n@@ -344,9 +320,7 @@ save_argument (macro, offset)\n    MACRO, and we call save_replacement_text() every time we meet an\n    argument.  */\n bool\n-scan_out_logical_line (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n {\n   bool result = true;\n   cpp_context *context;\n@@ -683,9 +657,7 @@ scan_out_logical_line (pfile, macro)\n    the context stack.  NODE is either object-like, or a function-like\n    macro with no arguments.  */\n static void\n-push_replacement_text (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+push_replacement_text (cpp_reader *pfile, cpp_hashnode *node)\n {\n   size_t len;\n   const uchar *text;\n@@ -713,9 +685,7 @@ push_replacement_text (pfile, node)\n \n /* Returns TRUE if traditional macro recursion is detected.  */\n static bool\n-recursive_macro (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+recursive_macro (cpp_reader *pfile, cpp_hashnode *node)\n {\n   bool recursing = !!(node->flags & NODE_DISABLED);\n \n@@ -756,8 +726,7 @@ recursive_macro (pfile, node)\n /* Return the length of the replacement text of a function-like or\n    object-like non-builtin macro.  */\n size_t\n-_cpp_replacement_text_len (macro)\n-     const cpp_macro *macro;\n+_cpp_replacement_text_len (const cpp_macro *macro)\n {\n   size_t len;\n \n@@ -787,9 +756,7 @@ _cpp_replacement_text_len (macro)\n    sufficient size.  It is not NUL-terminated.  The next character is\n    returned.  */\n uchar *\n-_cpp_copy_replacement_text (macro, dest)\n-     const cpp_macro *macro;\n-     uchar *dest;\n+_cpp_copy_replacement_text (const cpp_macro *macro, uchar *dest)\n {\n   if (macro->fun_like && (macro->paramc != 0))\n     {\n@@ -823,9 +790,7 @@ _cpp_copy_replacement_text (macro, dest)\n    the context stack.  NODE is either object-like, or a function-like\n    macro with no arguments.  */\n static void\n-replace_args_and_push (pfile, fmacro)\n-     cpp_reader *pfile;\n-     struct fun_macro *fmacro;\n+replace_args_and_push (cpp_reader *pfile, struct fun_macro *fmacro)\n {\n   cpp_macro *macro = fmacro->node->value.macro;\n \n@@ -889,9 +854,7 @@ replace_args_and_push (pfile, fmacro)\n    duplicate parameter).  On success, CUR (pfile->context) is just\n    past the closing parenthesis.  */\n static bool\n-scan_parameters (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+scan_parameters (cpp_reader *pfile, cpp_macro *macro)\n {\n   const uchar *cur = CUR (pfile->context) + 1;\n   bool ok;\n@@ -930,10 +893,8 @@ scan_parameters (pfile, macro)\n    ARG_INDEX, with zero indicating the end of the replacement\n    text.  */\n static void\n-save_replacement_text (pfile, macro, arg_index)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n-     unsigned int arg_index;\n+save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n+\t\t       unsigned int arg_index)\n {\n   size_t len = pfile->out.cur - pfile->out.base;\n   uchar *exp;\n@@ -981,9 +942,7 @@ save_replacement_text (pfile, macro, arg_index)\n /* Analyze and save the replacement text of a macro.  Returns true on\n    success.  */\n bool\n-_cpp_create_trad_definition (pfile, macro)\n-     cpp_reader *pfile;\n-     cpp_macro *macro;\n+_cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n {\n   const uchar *cur;\n   uchar *limit;\n@@ -1040,11 +999,7 @@ _cpp_create_trad_definition (pfile, macro)\n    quote currently in effect is pointed to by PQUOTE, and is updated\n    by the function.  Returns the number of bytes copied.  */\n static size_t\n-canonicalize_text (dest, src, len, pquote)\n-     uchar *dest;\n-     const uchar *src;\n-     size_t len;\n-     uchar *pquote;\n+canonicalize_text (uchar *dest, const uchar *src, size_t len, uchar *pquote)\n {\n   uchar *orig_dest = dest;\n   uchar quote = *pquote;\n@@ -1078,8 +1033,8 @@ canonicalize_text (dest, src, len, pquote)\n /* Returns true if MACRO1 and MACRO2 have expansions different other\n    than in the form of their whitespace.  */\n bool\n-_cpp_expansions_different_trad (macro1, macro2)\n-     const cpp_macro *macro1, *macro2;\n+_cpp_expansions_different_trad (const cpp_macro *macro1,\n+\t\t\t\tconst cpp_macro *macro2)\n {\n   uchar *p1 = xmalloc (macro1->count + macro2->count);\n   uchar *p2 = p1 + macro1->count;"}]}