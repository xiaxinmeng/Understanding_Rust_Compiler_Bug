{"sha": "ca1f6b2991e1864c8db5c9f082c62804467b2a07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExZjZiMjk5MWUxODY0YzhkYjVjOWYwODJjNjI4MDQ0NjdiMmEwNw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-04-25T10:39:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:39:02Z"}, "message": "sem_prag.adb (No_Return): Give an error if the pragma applies to a body.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* sem_prag.adb (No_Return): Give an error if the pragma applies\n\tto a body. Specialize the error for the specless body case,\n\tas is done for (e.g.) pragma Convention.\n\t* debug.adb: Add switch -gnatd.J to disable the above legality\n\tchecks. This is mainly for use in our test suite, to avoid\n\trewriting a lot of illegal (but working) code.\tIt might also\n\tbe useful to customers. Under this switch, if a pragma No_Return\n\tapplies to a body, and the procedure raises an exception (as it\n\tshould), the pragma has no effect. If the procedure does return,\n\texecution is erroneous.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals): This is the\n\troot of the problem. It took N as an 'in out' parameter, and in\n\tsome cases, rewrote N, but then set N to Original_Node(N). So\n\tthe node returned in N had no Parent. The caller continued\n\tprocessing of this orphaned node. In some cases that caused a\n\tcrash (e.g. Remove_Side_Effects climbs up Parents in a loop,\n\tand trips over the Empty Parent). The solution is to make N an\n\t'in' parameter.  Instead of rewriting it, return the list of\n\tpost-call actions, so the caller can do the rewriting later,\n\tafter N has been fully processed.\n\t(Expand_Call_Helper): Move most of Expand_Call here. It has\n\ttoo many premature 'return' statements, and we want to do the\n\trewriting on return.\n\t(Insert_Post_Call_Actions): New procedure to insert the post-call\n\tactions in the appropriate place. In the problematic case,\n\tthat involves rewriting N as an Expression_With_Actions.\n\t(Expand_Call): Call the new procedures Expand_Call_Helper and\n\tInsert_Post_Call_Actions.\n\nFrom-SVN: r247178", "tree": {"sha": "92f49dea30cdd60ad3a79c1d0e99556ae64c1cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92f49dea30cdd60ad3a79c1d0e99556ae64c1cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca1f6b2991e1864c8db5c9f082c62804467b2a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1f6b2991e1864c8db5c9f082c62804467b2a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1f6b2991e1864c8db5c9f082c62804467b2a07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1f6b2991e1864c8db5c9f082c62804467b2a07/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36357cf398c9837313d3d62dbdc1e7b883f47135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36357cf398c9837313d3d62dbdc1e7b883f47135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36357cf398c9837313d3d62dbdc1e7b883f47135"}], "stats": {"total": 372, "additions": 227, "deletions": 145}, "files": [{"sha": "c6aec4824d804aaeea773d46da4eca439f6fe5df", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ca1f6b2991e1864c8db5c9f082c62804467b2a07", "patch": "@@ -1,3 +1,37 @@\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_prag.adb (No_Return): Give an error if the pragma applies\n+\tto a body. Specialize the error for the specless body case,\n+\tas is done for (e.g.) pragma Convention.\n+\t* debug.adb: Add switch -gnatd.J to disable the above legality\n+\tchecks. This is mainly for use in our test suite, to avoid\n+\trewriting a lot of illegal (but working) code.\tIt might also\n+\tbe useful to customers. Under this switch, if a pragma No_Return\n+\tapplies to a body, and the procedure raises an exception (as it\n+\tshould), the pragma has no effect. If the procedure does return,\n+\texecution is erroneous.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals): This is the\n+\troot of the problem. It took N as an 'in out' parameter, and in\n+\tsome cases, rewrote N, but then set N to Original_Node(N). So\n+\tthe node returned in N had no Parent. The caller continued\n+\tprocessing of this orphaned node. In some cases that caused a\n+\tcrash (e.g. Remove_Side_Effects climbs up Parents in a loop,\n+\tand trips over the Empty Parent). The solution is to make N an\n+\t'in' parameter.  Instead of rewriting it, return the list of\n+\tpost-call actions, so the caller can do the rewriting later,\n+\tafter N has been fully processed.\n+\t(Expand_Call_Helper): Move most of Expand_Call here. It has\n+\ttoo many premature 'return' statements, and we want to do the\n+\trewriting on return.\n+\t(Insert_Post_Call_Actions): New procedure to insert the post-call\n+\tactions in the appropriate place. In the problematic case,\n+\tthat involves rewriting N as an Expression_With_Actions.\n+\t(Expand_Call): Call the new procedures Expand_Call_Helper and\n+\tInsert_Post_Call_Actions.\n+\n 2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Inherits_Class_Wide_Pre): Cleanup code, handle"}, {"sha": "b404ac86c1d5e8f4ffc0a8ea27a4cd68580ffc06", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=ca1f6b2991e1864c8db5c9f082c62804467b2a07", "patch": "@@ -127,7 +127,7 @@ package body Debug is\n    --  d.G  Ignore calls through generic formal parameters for elaboration\n    --  d.H  GNSA mode for ASIS\n    --  d.I  Do not ignore enum representation clauses in CodePeer mode\n-   --  d.J\n+   --  d.J  Relaxed rules for pragma No_Return\n    --  d.K  Enable generation of contract-only procedures in CodePeer mode\n    --  d.L  Depend on back end for limited types in if and case expressions\n    --  d.M  Relaxed RM semantics\n@@ -645,6 +645,11 @@ package body Debug is\n    --       cases being able to change this default might be useful to remove\n    --       some false positives.\n \n+   --  d.J  Relaxed rules for pragma No_Return. A pragma No_Return is illegal\n+   --       if it applies to a body. This switch disables the legality check\n+   --       for that. If the procedure does in fact return normally, execution\n+   --       is erroneous, and therefore unpredictable.\n+\n    --  d.K  Enable generation of contract-only procedures in CodePeer mode and\n    --       report a warning on subprograms for which the contract-only body\n    --       cannot be built. Currently reported on subprograms defined in"}, {"sha": "c8e719b1321369a58fc6e8ec46024863a163bd7f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 158, "deletions": 138, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ca1f6b2991e1864c8db5c9f082c62804467b2a07", "patch": "@@ -158,7 +158,12 @@ package body Exp_Ch6 is\n    --  the values are not changed for the call, we know immediately that\n    --  we have an infinite recursion.\n \n-   procedure Expand_Actuals (N : in out Node_Id; Subp : Entity_Id);\n+   procedure Expand_Actuals\n+     (N : Node_Id; Subp : Entity_Id; Post_Call : out List_Id);\n+   --  Return in Post_Call a list of actions to take place after the call.\n+   --  The call will later be rewritten as an Expression_With_Actions,\n+   --  with the Post_Call actions inserted, and the call inside.\n+   --\n    --  For each actual of an in-out or out parameter which is a numeric\n    --  (view) conversion of the form T (A), where A denotes a variable,\n    --  we insert the declaration:\n@@ -190,11 +195,14 @@ package body Exp_Ch6 is\n    --\n    --  For OUT and IN OUT parameters, add predicate checks after the call\n    --  based on the predicates of the actual type.\n-   --\n-   --  The parameter N is IN OUT because in some cases, the expansion code\n-   --  rewrites the call as an expression actions with the call inside. In\n-   --  this case N is reset to point to the inside call so that the caller\n-   --  can continue processing of this call.\n+\n+   procedure Expand_Call_Helper (N : Node_Id; Post_Call : out List_Id);\n+   --  Does the main work of Expand_Call. Post_Call is as for Expand_Actuals\n+\n+   procedure Insert_Post_Call_Actions\n+     (N : Node_Id; Post_Call : List_Id);\n+   --  Insert the Post_Call list (previously produced by\n+   --  Expand_Actuals/Expand_Call_Helper) into the tree.\n \n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  N is a function call which returns a controlled object. Transform the\n@@ -1146,12 +1154,13 @@ package body Exp_Ch6 is\n    -- Expand_Actuals --\n    --------------------\n \n-   procedure Expand_Actuals (N : in out Node_Id; Subp : Entity_Id) is\n+   procedure Expand_Actuals\n+     (N : Node_Id; Subp : Entity_Id; Post_Call : out List_Id)\n+   is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Actual    : Node_Id;\n       Formal    : Entity_Id;\n       N_Node    : Node_Id;\n-      Post_Call : List_Id;\n       E_Actual  : Entity_Id;\n       E_Formal  : Entity_Id;\n \n@@ -2122,135 +2131,23 @@ package body Exp_Ch6 is\n          Next_Formal (Formal);\n          Next_Actual (Actual);\n       end loop;\n-\n-      --  Find right place to put post call stuff if it is present\n-\n-      if not Is_Empty_List (Post_Call) then\n-\n-         --  Cases where the call is not a member of a statement list.\n-         --  This includes the case where the call is an actual in another\n-         --  function call or indexing, i.e. an expression context as well.\n-\n-         if not Is_List_Member (N)\n-           or else Nkind_In (Parent (N), N_Function_Call, N_Indexed_Component)\n-         then\n-            --  In Ada 2012 the call may be a function call in an expression\n-            --  (since OUT and IN OUT parameters are now allowed for such\n-            --  calls). The write-back of (in)-out parameters is handled\n-            --  by the back-end, but the constraint checks generated when\n-            --  subtypes of formal and actual don't match must be inserted\n-            --  in the form of assignments.\n-\n-            if Ada_Version >= Ada_2012\n-              and then Nkind (N) = N_Function_Call\n-            then\n-               --  We used to just do handle this by climbing up parents to\n-               --  a non-statement/declaration and then simply making a call\n-               --  to Insert_Actions_After (P, Post_Call), but that doesn't\n-               --  work. If we are in the middle of an expression, e.g. the\n-               --  condition of an IF, this call would insert after the IF\n-               --  statement, which is much too late to be doing the write\n-               --  back. For example:\n-\n-               --     if Clobber (X) then\n-               --        Put_Line (X'Img);\n-               --     else\n-               --        goto Junk\n-               --     end if;\n-\n-               --  Now assume Clobber changes X, if we put the write back\n-               --  after the IF, the Put_Line gets the wrong value and the\n-               --  goto causes the write back to be skipped completely.\n-\n-               --  To deal with this, we replace the call by\n-\n-               --    do\n-               --       Tnnn : constant function-result-type := function-call;\n-               --       Post_Call actions\n-               --    in\n-               --       Tnnn;\n-               --    end;\n-\n-               declare\n-                  Tnnn  : constant Entity_Id := Make_Temporary (Loc, 'T');\n-                  FRTyp : constant Entity_Id := Etype (N);\n-                  Name  : constant Node_Id   := Relocate_Node (N);\n-\n-               begin\n-                  Prepend_To (Post_Call,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Tnnn,\n-                      Object_Definition   => New_Occurrence_Of (FRTyp, Loc),\n-                      Constant_Present    => True,\n-                      Expression          => Name));\n-\n-                  Rewrite (N,\n-                    Make_Expression_With_Actions (Loc,\n-                      Actions    => Post_Call,\n-                      Expression => New_Occurrence_Of (Tnnn, Loc)));\n-\n-                  --  We don't want to just blindly call Analyze_And_Resolve\n-                  --  because that would cause unwanted recursion on the call.\n-                  --  So for a moment set the call as analyzed to prevent that\n-                  --  recursion, and get the rest analyzed properly, then reset\n-                  --  the analyzed flag, so our caller can continue.\n-\n-                  Set_Analyzed (Name, True);\n-                  Analyze_And_Resolve (N, FRTyp);\n-                  Set_Analyzed (Name, False);\n-\n-                  --  Reset calling argument to point to function call inside\n-                  --  the expression with actions so the caller can continue\n-                  --  to process the call. In spite of the fact that it is\n-                  --  marked Analyzed above, it may be rewritten by Remove_\n-                  --  Side_Effects if validity checks are present, so go back\n-                  --  to original call.\n-\n-                  N := Original_Node (Name);\n-               end;\n-\n-            --  If not the special Ada 2012 case of a function call, then\n-            --  we must have the triggering statement of a triggering\n-            --  alternative or an entry call alternative, and we can add\n-            --  the post call stuff to the corresponding statement list.\n-\n-            else\n-               declare\n-                  P : Node_Id;\n-\n-               begin\n-                  P := Parent (N);\n-                  pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n-                                              N_Entry_Call_Alternative));\n-\n-                  if Is_Non_Empty_List (Statements (P)) then\n-                     Insert_List_Before_And_Analyze\n-                       (First (Statements (P)), Post_Call);\n-                  else\n-                     Set_Statements (P, Post_Call);\n-                  end if;\n-\n-                  return;\n-               end;\n-            end if;\n-\n-         --  Otherwise, normal case where N is in a statement sequence,\n-         --  just put the post-call stuff after the call statement.\n-\n-         else\n-            Insert_Actions_After (N, Post_Call);\n-            return;\n-         end if;\n-      end if;\n-\n-      --  The call node itself is re-analyzed in Expand_Call\n-\n    end Expand_Actuals;\n \n    -----------------\n    -- Expand_Call --\n    -----------------\n \n+   procedure Expand_Call (N : Node_Id) is\n+      Post_Call : List_Id;\n+   begin\n+      Expand_Call_Helper (N, Post_Call);\n+      Insert_Post_Call_Actions (N, Post_Call);\n+   end Expand_Call;\n+\n+   ------------------------\n+   -- Expand_Call_Helper --\n+   ------------------------\n+\n    --  This procedure handles expansion of function calls and procedure call\n    --  statements (i.e. it serves as the body for Expand_N_Function_Call and\n    --  Expand_N_Procedure_Call_Statement). Processing for calls includes:\n@@ -2267,7 +2164,7 @@ package body Exp_Ch6 is\n    --   for the 'Constrained attribute and for accessibility checks are added\n    --   at this point.\n \n-   procedure Expand_Call (N : Node_Id) is\n+   procedure Expand_Call_Helper (N : Node_Id; Post_Call : out List_Id) is\n       Loc           : constant Source_Ptr := Sloc (N);\n       Call_Node     : Node_Id := N;\n       Extra_Actuals : List_Id := No_List;\n@@ -2625,9 +2522,11 @@ package body Exp_Ch6 is\n \n       CW_Interface_Formals_Present : Boolean := False;\n \n-   --  Start of processing for Expand_Call\n+   --  Start of processing for Expand_Call_Helper\n \n    begin\n+      Post_Call := New_List;\n+\n       --  Expand the function or procedure call if the first actual has a\n       --  declared dimension aspect, and the subprogram is declared in one\n       --  of the dimension I/O packages.\n@@ -2817,7 +2716,8 @@ package body Exp_Ch6 is\n                Add_Actual_Parameter (Remove_Head (Extra_Actuals));\n             end loop;\n \n-            Expand_Actuals (Call_Node, Subp);\n+            Expand_Actuals (Call_Node, Subp, Post_Call);\n+            pragma Assert (Is_Empty_List (Post_Call));\n             return;\n          end;\n       end if;\n@@ -3666,7 +3566,7 @@ package body Exp_Ch6 is\n       --  At this point we have all the actuals, so this is the point at which\n       --  the various expansion activities for actuals is carried out.\n \n-      Expand_Actuals (Call_Node, Subp);\n+      Expand_Actuals (Call_Node, Subp, Post_Call);\n \n       --  Verify that the actuals do not share storage. This check must be done\n       --  on the caller side rather that inside the subprogram to avoid issues\n@@ -3941,11 +3841,12 @@ package body Exp_Ch6 is\n          --  replacing them with an unchecked conversion. Not only is this\n          --  efficient, but it also avoids order of elaboration problems when\n          --  address clauses are inlined (address expression elaborated at the\n-         --  at the wrong point).\n+         --  wrong point).\n \n          --  We perform this optimization regardless of whether we are in the\n          --  main unit or in a unit in the context of the main unit, to ensure\n-         --  that tree generated is the same in both cases, for CodePeer use.\n+         --  that the generated tree is the same in both cases, for CodePeer\n+         --  use.\n \n          if Is_RTE (Subp, RE_To_Address) then\n             Rewrite (Call_Node,\n@@ -4201,7 +4102,7 @@ package body Exp_Ch6 is\n             Establish_Transient_Scope (Call_Node, Sec_Stack => True);\n          end if;\n       end if;\n-   end Expand_Call;\n+   end Expand_Call_Helper;\n \n    -------------------------------\n    -- Expand_Ctrl_Function_Call --\n@@ -7315,6 +7216,125 @@ package body Exp_Ch6 is\n       end if;\n    end Freeze_Subprogram;\n \n+   ------------------------------\n+   -- Insert_Post_Call_Actions --\n+   ------------------------------\n+\n+   procedure Insert_Post_Call_Actions\n+     (N : Node_Id; Post_Call : List_Id)\n+   is\n+   begin\n+      if Is_Empty_List (Post_Call) then\n+         return;\n+      end if;\n+\n+      --  Cases where the call is not a member of a statement list.\n+      --  This includes the case where the call is an actual in another\n+      --  function call or indexing, i.e. an expression context as well.\n+\n+      if not Is_List_Member (N)\n+        or else Nkind_In (Parent (N), N_Function_Call, N_Indexed_Component)\n+      then\n+         --  In Ada 2012 the call may be a function call in an expression\n+         --  (since OUT and IN OUT parameters are now allowed for such\n+         --  calls). The write-back of (in)-out parameters is handled\n+         --  by the back-end, but the constraint checks generated when\n+         --  subtypes of formal and actual don't match must be inserted\n+         --  in the form of assignments.\n+\n+         if Nkind (Original_Node (N)) = N_Function_Call then\n+            pragma Assert (Ada_Version >= Ada_2012);\n+            --  Functions with '[in] out' parameters are only allowed in Ada\n+            --  2012.\n+\n+            --  We used to handle this by climbing up parents to a\n+            --  non-statement/declaration and then simply making a call to\n+            --  Insert_Actions_After (P, Post_Call), but that doesn't work\n+            --  for Ada 2012. If we are in the middle of an expression, e.g.\n+            --  the condition of an IF, this call would insert after the IF\n+            --  statement, which is much too late to be doing the write\n+            --  back. For example:\n+\n+            --     if Clobber (X) then\n+            --        Put_Line (X'Img);\n+            --     else\n+            --        goto Junk\n+            --     end if;\n+\n+            --  Now assume Clobber changes X, if we put the write back\n+            --  after the IF, the Put_Line gets the wrong value and the\n+            --  goto causes the write back to be skipped completely.\n+\n+            --  To deal with this, we replace the call by\n+\n+            --    do\n+            --       Tnnn : constant function-result-type := function-call;\n+            --       Post_Call actions\n+            --    in\n+            --       Tnnn;\n+            --    end;\n+\n+            declare\n+               Loc   : constant Source_Ptr := Sloc (N);\n+               Tnnn  : constant Entity_Id := Make_Temporary (Loc, 'T');\n+               FRTyp : constant Entity_Id := Etype (N);\n+               Name  : constant Node_Id   := Relocate_Node (N);\n+\n+            begin\n+               Prepend_To (Post_Call,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Tnnn,\n+                   Object_Definition   => New_Occurrence_Of (FRTyp, Loc),\n+                   Constant_Present    => True,\n+                   Expression          => Name));\n+\n+               Rewrite (N,\n+                 Make_Expression_With_Actions (Loc,\n+                   Actions    => Post_Call,\n+                   Expression => New_Occurrence_Of (Tnnn, Loc)));\n+\n+               --  We don't want to just blindly call Analyze_And_Resolve\n+               --  because that would cause unwanted recursion on the call.\n+               --  So for a moment set the call as analyzed to prevent that\n+               --  recursion, and get the rest analyzed properly, then reset\n+               --  the analyzed flag, so our caller can continue.\n+\n+               Set_Analyzed (Name, True);\n+               Analyze_And_Resolve (N, FRTyp);\n+               Set_Analyzed (Name, False);\n+            end;\n+\n+         --  If not the special Ada 2012 case of a function call, then\n+         --  we must have the triggering statement of a triggering\n+         --  alternative or an entry call alternative, and we can add\n+         --  the post call stuff to the corresponding statement list.\n+\n+         else\n+            declare\n+               P : Node_Id;\n+\n+            begin\n+               P := Parent (N);\n+               pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n+                                           N_Entry_Call_Alternative));\n+\n+               if Is_Non_Empty_List (Statements (P)) then\n+                  Insert_List_Before_And_Analyze\n+                    (First (Statements (P)), Post_Call);\n+               else\n+                  Set_Statements (P, Post_Call);\n+               end if;\n+            end;\n+         end if;\n+\n+      --  Otherwise, normal case where N is in a statement sequence,\n+      --  just put the post-call stuff after the call statement.\n+\n+      else\n+         Insert_Actions_After (N, Post_Call);\n+      end if;\n+   end Insert_Post_Call_Actions;\n+\n    -----------------------\n    -- Is_Null_Procedure --\n    -----------------------"}, {"sha": "2f65475199bac4479c5dc09e211245f10f3af180", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1f6b2991e1864c8db5c9f082c62804467b2a07/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ca1f6b2991e1864c8db5c9f082c62804467b2a07", "patch": "@@ -7621,7 +7621,7 @@ package body Sem_Prag is\n          end if;\n \n          --  Check that we are not applying this to a specless body. Relax this\n-         --  check if Relaxed_RM_Semantics to accomodate other Ada compilers.\n+         --  check if Relaxed_RM_Semantics to accommodate other Ada compilers.\n \n          if Is_Subprogram (E)\n            and then Nkind (Parent (Declaration_Node (E))) = N_Subprogram_Body\n@@ -8084,8 +8084,8 @@ package body Sem_Prag is\n                                                              N_Subprogram_Body\n                then\n                   Error_Pragma\n-                    (\"pragma% requires separate spec\"\n-                      & \" and must come before body\");\n+                    (\"pragma% requires separate spec\" &\n+                      \" and must come before body\");\n                end if;\n \n                --  Test result type if given, note that the result type\n@@ -18177,6 +18177,29 @@ package body Sem_Prag is\n                  and then Scope (E) = Current_Scope\n                loop\n                   if Ekind_In (E, E_Procedure, E_Generic_Procedure) then\n+                     --  Check that the pragma is not applied to a body.\n+                     --  First check the specless body case, to give a\n+                     --  different error message. These checks do not apply\n+                     --  if Relaxed_RM_Semantics, to accommodate other Ada\n+                     --  compilers. Disable these checks under -gnatd.J.\n+\n+                     if not Debug_Flag_Dot_JJ then\n+                        if Nkind (Parent (Declaration_Node (E))) =\n+                            N_Subprogram_Body\n+                          and then not Relaxed_RM_Semantics\n+                        then\n+                           Error_Pragma\n+                             (\"pragma% requires separate spec\" &\n+                                \" and must come before body\");\n+                        end if;\n+\n+                        --  Now the \"specful\" body case\n+\n+                        if Rep_Item_Too_Late (E, N) then\n+                           raise Pragma_Exit;\n+                        end if;\n+                     end if;\n+\n                      Set_No_Return (E);\n \n                      --  A pragma that applies to a Ghost entity becomes Ghost\n@@ -26125,7 +26148,7 @@ package body Sem_Prag is\n                raise Program_Error;\n             end if;\n \n-         --  To accomodate partial decoration of disabled SPARK features, this\n+         --  To accommodate partial decoration of disabled SPARK features, this\n          --  routine may be called with illegal input. If this is the case, do\n          --  not raise Program_Error.\n \n@@ -28031,7 +28054,7 @@ package body Sem_Prag is\n               (Item     => First (Choices (Clause)),\n                Is_Input => False);\n \n-         --  To accomodate partial decoration of disabled SPARK features, this\n+         --  To accommodate partial decoration of disabled SPARK features, this\n          --  routine may be called with illegal input. If this is the case, do\n          --  not raise Program_Error.\n \n@@ -28105,7 +28128,7 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-         --  To accomodate partial decoration of disabled SPARK features, this\n+         --  To accommodate partial decoration of disabled SPARK features, this\n          --  routine may be called with illegal input. If this is the case, do\n          --  not raise Program_Error.\n "}]}