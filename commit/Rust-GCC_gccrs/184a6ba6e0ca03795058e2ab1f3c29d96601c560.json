{"sha": "184a6ba6e0ca03795058e2ab1f3c29d96601c560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg0YTZiYTZlMGNhMDM3OTUwNThlMmFiMWYzYzI5ZDk2NjAxYzU2MA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-05-28T08:56:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-28T08:56:03Z"}, "message": "[Ada] Unnesting: check index expressions for uplevel references\n\n2018-05-28  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* exp_unst.adb (Visit_Node): For indexed components and attribute\n\treferences, examine index expressions or associated expressions as well\n\tto record uplevel references.\n\t(Vist_Node): For function and procedure calls, if a formal is an\n\tunconstrained array and the actual is constrained, check whether bounds\n\tof actual have uplevel references.\n\nFrom-SVN: r260841", "tree": {"sha": "e7f58fe48c4fe60010031db50c83bf0fe4997870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7f58fe48c4fe60010031db50c83bf0fe4997870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/184a6ba6e0ca03795058e2ab1f3c29d96601c560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184a6ba6e0ca03795058e2ab1f3c29d96601c560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184a6ba6e0ca03795058e2ab1f3c29d96601c560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184a6ba6e0ca03795058e2ab1f3c29d96601c560/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6af9261c73519a4c3e1a26376dc0b156ecd4aad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af9261c73519a4c3e1a26376dc0b156ecd4aad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6af9261c73519a4c3e1a26376dc0b156ecd4aad6"}], "stats": {"total": 89, "additions": 72, "deletions": 17}, "files": [{"sha": "c179b90a3bddbf4368ec31f3f1df4d3df2ee694a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184a6ba6e0ca03795058e2ab1f3c29d96601c560/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184a6ba6e0ca03795058e2ab1f3c29d96601c560/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=184a6ba6e0ca03795058e2ab1f3c29d96601c560", "patch": "@@ -1,3 +1,12 @@\n+2018-05-28  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_unst.adb (Visit_Node): For indexed components and attribute\n+\treferences, examine index expressions or associated expressions as well\n+\tto record uplevel references.\n+\t(Vist_Node): For function and procedure calls, if a formal is an\n+\tunconstrained array and the actual is constrained, check whether bounds\n+\tof actual have uplevel references.\n+\n 2018-05-28  Ed Schonberg  <schonberg@adacore.com>\n \n \t* einfo.ads, einfo.adb: Exceptions can be uplevel references, and thus"}, {"sha": "03f316a53ee9531100db64f8f4f3aae095332dde", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/184a6ba6e0ca03795058e2ab1f3c29d96601c560/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/184a6ba6e0ca03795058e2ab1f3c29d96601c560/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=184a6ba6e0ca03795058e2ab1f3c29d96601c560", "patch": "@@ -433,6 +433,21 @@ package body Exp_Unst is\n                   then\n                      Note_Uplevel_Bound (Prefix (N), Ref);\n \n+                     --  The indices of the indexed components, or the\n+                     --  associated expressions of an attribute reference,\n+                     --  may also involve uplevel references.\n+\n+                     declare\n+                        Expr : Node_Id;\n+\n+                     begin\n+                        Expr := First (Expressions (N));\n+                        while Present (Expr) loop\n+                           Note_Uplevel_Bound (Expr, Ref);\n+                           Next (Expr);\n+                        end loop;\n+                     end;\n+\n                   --  Conversion case\n \n                   elsif Nkind (N) = N_Type_Conversion then\n@@ -599,38 +614,69 @@ package body Exp_Unst is\n          begin\n             --  Record a call\n \n-            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call)\n+            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n \n               --  We are only interested in direct calls, not indirect calls\n               --  (where Name (N) is an explicit dereference) at least for now!\n \n-              and then Nkind (Name (N)) in N_Has_Entity\n-            then\n-               Ent := Entity (Name (N));\n+               if Nkind (Name (N)) in N_Has_Entity then\n+                  Ent := Entity (Name (N));\n \n-               --  We are only interested in calls to subprograms nested\n-               --  within Subp. Calls to Subp itself or to subprograms\n-               --  that are outside the nested structure do not affect us.\n+                  --  We are only interested in calls to subprograms nested\n+                  --  within Subp. Calls to Subp itself or to subprograms\n+                  --  that are outside the nested structure do not affect us.\n \n-               if Scope_Within (Ent, Subp) then\n+                  if Scope_Within (Ent, Subp) then\n \n-                  --  Ignore calls to imported routines\n+                     --  Ignore calls to imported routines\n \n-                  if Is_Imported (Ent) then\n-                     null;\n+                     if Is_Imported (Ent) then\n+                        null;\n \n-                  --  Here we have a call to keep and analyze\n+                     --  Here we have a call to keep and analyze\n \n-                  else\n-                     --  Both caller and callee must be subprograms\n+                     else\n+                        --  Both caller and callee must be subprograms\n \n-                     if Is_Subprogram (Ent) then\n-                        Append_Unique_Call ((N, Current_Subprogram, Ent));\n+                        if Is_Subprogram (Ent) then\n+                           Append_Unique_Call ((N, Current_Subprogram, Ent));\n+                        end if;\n                      end if;\n                   end if;\n                end if;\n \n-            --  Record a 'Access as a (potential) call\n+               --  for all calls where the formal is an unconstrained array\n+               --  and the actual is constrained we need to check the bounds.\n+\n+               declare\n+                  Subp   : Entity_Id;\n+                  Actual : Entity_Id;\n+                  Formal : Node_Id;\n+                  DT     : Boolean := False;\n+\n+               begin\n+                  if Nkind (Name (N)) = N_Explicit_Dereference then\n+                     Subp := Etype (Name (N));\n+                  else\n+                     Subp := Entity (Name (N));\n+                  end if;\n+\n+                  Actual := First_Actual (N);\n+                  Formal := First_Formal_With_Extras (Subp);\n+                  while Present (Actual) loop\n+                     if Is_Array_Type (Etype (Formal))\n+                       and then not Is_Constrained (Etype (Formal))\n+                       and then Is_Constrained (Etype (Actual))\n+                     then\n+                        Check_Static_Type (Etype (Actual), Empty, DT);\n+                     end if;\n+\n+                     Next_Actual (Actual);\n+                     Next_Formal_With_Extras (Formal);\n+                  end loop;\n+               end;\n+\n+            --  Handle a 'Access as a (potential) call\n \n             elsif Nkind (N) = N_Attribute_Reference then\n                declare"}]}