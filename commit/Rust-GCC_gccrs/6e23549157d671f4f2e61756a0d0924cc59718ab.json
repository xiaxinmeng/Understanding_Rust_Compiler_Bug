{"sha": "6e23549157d671f4f2e61756a0d0924cc59718ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyMzU0OTE1N2Q2NzFmNGYyZTYxNzU2YTBkMDkyNGNjNTk3MThhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-10-29T13:38:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-10-29T13:38:01Z"}, "message": "vect: Fix load costs for SLP permutes\n\nFor the following test case (compiled with load/store lanes\ndisabled locally):\n\n  void\n  f (uint32_t *restrict x, uint8_t *restrict y, int n)\n  {\n    for (int i = 0; i < n; ++i)\n      {\n\tx[i * 2] = x[i * 2] + y[i * 2];\n\tx[i * 2 + 1] = x[i * 2 + 1] + y[i * 2];\n      }\n  }\n\nwe have a redundant no-op permute on the x[] load node:\n\n   node 0x4472350 (max_nunits=8, refcnt=2)\n          stmt 0 _5 = *_4;\n          stmt 1 _13 = *_12;\n          load permutation { 0 1 }\n\nThen, when costing it, we pick a cost of 1, even though we need 4 copies\nof the x[] load to match a single y[] load:\n\n   ==> examining statement: _5 = *_4;\n   Vectorizing an unaligned access.\n   vect_model_load_cost: unaligned supported by hardware.\n   vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .\n\nThe problem is that the code only considers the permutation for\nthe first scalar iteration, rather than for all VF iterations.\n\nThis patch tries to fix that by making vect_transform_slp_perm_load\ncalculate the value instead.\n\ngcc/\n\t* tree-vectorizer.h (vect_transform_slp_perm_load): Take an\n\toptional extra parameter.\n\t* tree-vect-slp.c (vect_transform_slp_perm_load): Calculate\n\tthe number of loads as well as the number of permutes, taking\n\tthe counting loop from...\n\t* tree-vect-stmts.c (vect_model_load_cost): ...here.  Use the\n\tvalue computed by vect_transform_slp_perm_load for ncopies.", "tree": {"sha": "5b8e002bbfc48786bb13610aeaabfcb5e53c0db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b8e002bbfc48786bb13610aeaabfcb5e53c0db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e23549157d671f4f2e61756a0d0924cc59718ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e23549157d671f4f2e61756a0d0924cc59718ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e23549157d671f4f2e61756a0d0924cc59718ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e23549157d671f4f2e61756a0d0924cc59718ab/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "568de14d2e74cfdd600b8995ff6ac08c98ddef48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568de14d2e74cfdd600b8995ff6ac08c98ddef48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/568de14d2e74cfdd600b8995ff6ac08c98ddef48"}], "stats": {"total": 74, "additions": 43, "deletions": 31}, "files": [{"sha": "5d69a98c2a90be47ff852c90039b0ab2cd2e58ef", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6e23549157d671f4f2e61756a0d0924cc59718ab", "patch": "@@ -4830,13 +4830,16 @@ vect_get_slp_defs (vec_info *,\n \n /* Generate vector permute statements from a list of loads in DR_CHAIN.\n    If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n-   permute statements for the SLP node NODE.  */\n+   permute statements for the SLP node NODE.  Store the number of vector\n+   permute instructions in *N_PERMS and the number of vector load\n+   instructions in *N_LOADS.  */\n \n bool\n vect_transform_slp_perm_load (vec_info *vinfo,\n \t\t\t      slp_tree node, vec<tree> dr_chain,\n \t\t\t      gimple_stmt_iterator *gsi, poly_uint64 vf,\n-\t\t\t      bool analyze_only, unsigned *n_perms)\n+\t\t\t      bool analyze_only, unsigned *n_perms,\n+\t\t\t      unsigned int *n_loads)\n {\n   stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   int vec_index = 0;\n@@ -4888,6 +4891,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n   vec_perm_builder mask;\n   unsigned int nelts_to_build;\n   unsigned int nvectors_per_build;\n+  unsigned int in_nlanes;\n   bool repeating_p = (group_size == DR_GROUP_SIZE (stmt_info)\n \t\t      && multiple_p (nunits, group_size));\n   if (repeating_p)\n@@ -4898,6 +4902,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n       mask.new_vector (nunits, group_size, 3);\n       nelts_to_build = mask.encoded_nelts ();\n       nvectors_per_build = SLP_TREE_VEC_STMTS (node).length ();\n+      in_nlanes = DR_GROUP_SIZE (stmt_info) * 3;\n     }\n   else\n     {\n@@ -4909,7 +4914,10 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n       mask.new_vector (const_nunits, const_nunits, 1);\n       nelts_to_build = const_vf * group_size;\n       nvectors_per_build = 1;\n+      in_nlanes = const_vf * DR_GROUP_SIZE (stmt_info);\n     }\n+  auto_sbitmap used_in_lanes (in_nlanes);\n+  bitmap_clear (used_in_lanes);\n \n   unsigned int count = mask.encoded_nelts ();\n   mask.quick_grow (count);\n@@ -4921,6 +4929,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n       unsigned int stmt_num = j % group_size;\n       unsigned int i = (iter_num * DR_GROUP_SIZE (stmt_info)\n \t\t\t+ SLP_TREE_LOAD_PERMUTATION (node)[stmt_num]);\n+      bitmap_set_bit (used_in_lanes, i);\n       if (repeating_p)\n \t{\n \t  first_vec_index = 0;\n@@ -5034,6 +5043,32 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n \t}\n     }\n \n+  if (n_loads)\n+    {\n+      if (repeating_p)\n+\t*n_loads = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+      else\n+\t{\n+\t  /* Enforced above when !repeating_p.  */\n+\t  unsigned int const_nunits = nunits.to_constant ();\n+\t  *n_loads = 0;\n+\t  bool load_seen = false;\n+\t  for (unsigned i = 0; i < in_nlanes; ++i)\n+\t    {\n+\t      if (i % const_nunits == 0)\n+\t\t{\n+\t\t  if (load_seen)\n+\t\t    *n_loads += 1;\n+\t\t  load_seen = false;\n+\t\t}\n+\t      if (bitmap_bit_p (used_in_lanes, i))\n+\t\tload_seen = true;\n+\t    }\n+\t  if (load_seen)\n+\t    *n_loads += 1;\n+\t}\n+    }\n+\n   return true;\n }\n "}, {"sha": "1a0da0e84cc84b0219f7b8332e26ffaf67673df5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6e23549157d671f4f2e61756a0d0924cc59718ab", "patch": "@@ -1098,39 +1098,15 @@ vect_model_load_cost (vec_info *vinfo,\n \t the first group element not by the first scalar stmt DR.  */\n       stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       /* Record the cost for the permutation.  */\n-      unsigned n_perms;\n-      unsigned assumed_nunits\n-\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (first_stmt_info));\n+      unsigned n_perms, n_loads;\n       vect_transform_slp_perm_load (vinfo, slp_node, vNULL, NULL,\n-\t\t\t\t    vf, true, &n_perms);\n+\t\t\t\t    vf, true, &n_perms, &n_loads);\n       inside_cost += record_stmt_cost (cost_vec, n_perms, vec_perm,\n \t\t\t\t       first_stmt_info, 0, vect_body);\n+\n       /* And adjust the number of loads performed.  This handles\n \t redundancies as well as loads that are later dead.  */\n-      auto_sbitmap perm (DR_GROUP_SIZE (first_stmt_info));\n-      bitmap_clear (perm);\n-      for (unsigned i = 0;\n-\t   i < SLP_TREE_LOAD_PERMUTATION (slp_node).length (); ++i)\n-\tbitmap_set_bit (perm, SLP_TREE_LOAD_PERMUTATION (slp_node)[i]);\n-      ncopies = 0;\n-      bool load_seen = false;\n-      for (unsigned i = 0; i < DR_GROUP_SIZE (first_stmt_info); ++i)\n-\t{\n-\t  if (i % assumed_nunits == 0)\n-\t    {\n-\t      if (load_seen)\n-\t\tncopies++;\n-\t      load_seen = false;\n-\t    }\n-\t  if (bitmap_bit_p (perm, i))\n-\t    load_seen = true;\n-\t}\n-      if (load_seen)\n-\tncopies++;\n-      gcc_assert (ncopies\n-\t\t  <= (DR_GROUP_SIZE (first_stmt_info)\n-\t\t      - DR_GROUP_GAP (first_stmt_info)\n-\t\t      + assumed_nunits - 1) / assumed_nunits);\n+      ncopies = n_loads;\n     }\n \n   /* Grouped loads read all elements in the group at once,"}, {"sha": "fbf5291cf065f3944040937db92d3997acd45f23", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e23549157d671f4f2e61756a0d0924cc59718ab/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6e23549157d671f4f2e61756a0d0924cc59718ab", "patch": "@@ -1952,7 +1952,8 @@ extern tree cse_and_gimplify_to_preheader (loop_vec_info, tree);\n extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (vec_info *, slp_tree, vec<tree>,\n \t\t\t\t\t  gimple_stmt_iterator *, poly_uint64,\n-\t\t\t\t\t  bool, unsigned *);\n+\t\t\t\t\t  bool, unsigned *,\n+\t\t\t\t\t  unsigned * = nullptr);\n extern bool vect_slp_analyze_operations (vec_info *);\n extern void vect_schedule_slp (vec_info *, vec<slp_instance>);\n extern opt_result vect_analyze_slp (vec_info *, unsigned);"}]}