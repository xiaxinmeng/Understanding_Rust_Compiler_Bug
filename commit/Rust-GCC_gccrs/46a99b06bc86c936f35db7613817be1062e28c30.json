{"sha": "46a99b06bc86c936f35db7613817be1062e28c30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhOTliMDZiYzg2YzkzNmYzNWRiNzYxMzgxN2JlMTA2MmUyOGMzMA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-29T14:58:16Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-29T14:58:16Z"}, "message": "re PR target/26427 (with -fsection-anchors with zero sized structs)\n\n\n\tPR target/26427\n\tPR target/33120\n\tPR testsuite/35710\n\ngcc:\n\t* config/i386/darwin.h (ASM_OUTPUT_COMMON): Remove\n\t(ASM_OUTPUT_LOCAL): Likewise.\n\t* config/darwin-protos.h (darwin_asm_declare_object_name): New.\n\t(darwin_output_aligned_bss): Likewise.\n\t(darwin_asm_output_aligned_decl_local): Likewise.\n\t(darwin_asm_output_aligned_decl_common): Likewise.\n\t(darwin_use_anchors_for_symbol_p): Likewise.\n\t* config/rs6000/darwin.h (ASM_OUTPUT_COMMON): Remove.\n\t(TARGET_ASM_OUTPUT_ANCHOR): Define.\n\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): Define.\n\t(DARWIN_SECTION_ANCHORS): Set to 1.\n\t* config/darwin.c (emit_aligned_common): New var.\n\t(darwin_init_sections): Check that the Darwin private zero-size section\n\tmarker is in range.\n\t(darwin_text_section): Check for zero-sized objects.\n\t(darwin_mergeable_string_section): Likewise.\n\t(darwin_mergeable_constant_section): Likewise.\n\t(machopic_select_section): Adjust to check for zero-sized objects.\n\tAssert that OBJC meta data are non-zero sized.\n\t(darwin_asm_declare_object_name): New.\n\t(darwin_asm_declare_constant_name): Adjust for zero-sized\n\tobject sections.\n\t(BYTES_ZFILL): Define.\n\t(darwin_emit_weak_or_comdat): New.\n\t(darwin_emit_local_bss): New.\n\t(darwin_emit_common): New.\n\t(darwin_output_aligned_bss): New.\n\t(darwin_asm_output_aligned_decl_common): New.\n\t(darwin_asm_output_aligned_decl_local): New.\n\t(darwin_file_end): Disable subsections_via_symbols when section\n\tanchoring is active.\n\t(darwin_asm_output_anchor): Re-enable.\n\t(darwin_use_anchors_for_symbol_p): New.\n\t(darwin_override_options): Check for versions that can emit\n\taligned common.  Update usage of flags to current.\n\t* config/darwin-sections.def: Update comments and flags for\n\tnon-anchor sections.  zobj_const_section, zobj_data_section,\n\tzobj_bss_section, zobj_const_data_section: New.\n\t* config/darwin.h (ASM_DECLARE_OBJECT_NAME): Redefine.\n\t(ASM_OUTPUT_ALIGN): Make whitespace output consistent.\n\t(L2_MAX_OFILE_ALIGNMENT): Define.\n\t(ASM_OUTPUT_ALIGNED_BSS): Define.\n\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): Define.\n\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): Define.\n\t(SECTION_NO_ANCHOR): Define.\n\t(TARGET_ASM_OUTPUT_ANCHOR) Define with a default of NULL.\n\t(DARWIN_SECTION_ANCHORS): Define with a default of 0.\n\nboehm-gc:\n\t* dyn_load.c (GC_register_dynamic_libraries/DARWIN):  Add new writable\n\tdata section names.\n\t(GC_dyld_name_for_hdr): Adjust layout.\n\t(GC_dyld_image_add): Adjust layout, add new Darwin sections, adjust\n\tdebug to name the sections.\n\t(GC_dyld_image_remove): Adjust layout, remove new Darwin sections,\n\tadjust debug to name the sections.\n\t(GC_register_dynamic_libraries): Adjust layout.\n\t(GC_init_dyld): Likewise.\n\t(GC_register_main_static_data): Likewise.\n\ngcc/testsuite:\n\t* gcc.target/powerpc/darwin-abi-12.c: Adjust for new allocators.\n\t* gcc.dg/pr26427.c: Remove redundant warning for powerpc.\n\t* gcc.dg/darwin-comm.c: Adjust for new allocators.\n\t* gcc.dg/darwin-sections.c: New test.\n\t* g++.dg/ext/instantiate2.C: Adjust for new allocators.\n\n\nCo-Authored-By: Mike Stump <mrs@gcc.gnu.org>\n\nFrom-SVN: r167242", "tree": {"sha": "8c3109155c2d78bf97199aa9dbbef844a6a0e8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c3109155c2d78bf97199aa9dbbef844a6a0e8a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a99b06bc86c936f35db7613817be1062e28c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a99b06bc86c936f35db7613817be1062e28c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a99b06bc86c936f35db7613817be1062e28c30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a99b06bc86c936f35db7613817be1062e28c30/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71f3e391b3fdd791965321747ac078a61472fb87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f3e391b3fdd791965321747ac078a61472fb87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71f3e391b3fdd791965321747ac078a61472fb87"}], "stats": {"total": 1260, "additions": 1067, "deletions": 193}, "files": [{"sha": "8a1abca8ba8fb27729f1c05dc0d881d263dfacbf", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,3 +1,20 @@\n+2010-11-29  Iain Sandoe  <iains@gcc.gnu.org>\n+\t    Mike Stump  <mrs@gcc.gnu.org>\n+\n+\tPR target/26427\n+\tPR target/33120\n+\tPR testsuite/35710\n+\t* dyn_load.c (GC_register_dynamic_libraries/DARWIN):  Add new writable\n+\tdata section names.\n+\t(GC_dyld_name_for_hdr): Adjust layout.\n+\t(GC_dyld_image_add): Adjust layout, add new Darwin sections, adjust\n+\tdebug to name the sections.\n+\t(GC_dyld_image_remove): Adjust layout, remove new Darwin sections,\n+\tadjust debug to name the sections.\n+\t(GC_register_dynamic_libraries): Adjust layout.\n+\t(GC_init_dyld): Likewise.\n+\t(GC_register_main_static_data): Likewise.\n+\n 2010-10-29  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* configure: Regenerate."}, {"sha": "4bfa56cac2c3f47cf9922500696eb01c28b9dd76", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 157, "deletions": 58, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1157,72 +1157,167 @@ void GC_register_dynamic_libraries()\n \n /*#define DARWIN_DEBUG*/\n \n+/* Writeable sections generally available on Darwin.  */\n const static struct { \n         const char *seg;\n         const char *sect;\n } GC_dyld_sections[] = {\n         { SEG_DATA, SECT_DATA },\n+        /* Used by FSF GCC, but not by OSX system tools, so far.  */\n+        { SEG_DATA, \"__static_data\" }, \n         { SEG_DATA, SECT_BSS },\n-        { SEG_DATA, SECT_COMMON }\n+        { SEG_DATA, SECT_COMMON },\n+        /* FSF GCC - zero-sized object sections for targets supporting section\n+           anchors.  */\n+        { SEG_DATA, \"__zobj_data\" },\n+        { SEG_DATA, \"__zobj_bss\" }\n };\n-    \n+\n+/* Additional writeable sections:\n+\n+   GCC on Darwin constucts aligned sections \"on demand\", where the alignment\n+   size is embedded in the section name.  Furthermore, there are distintions\n+   between sections containing private vs. public symbols.\n+\n+   It also constructs sections specifically for zero-sized objects, when the\n+   target supports section anchors.  */\n+const char * GC_dyld_add_sect_fmts[] = \n+{\n+  \"__bss%u\",\n+  \"__pu_bss%u\",\n+  \"__zo_bss%u\",\n+  \"__zo_pu_bss%u\",\n+  NULL\n+} ;\n+\n+/* Currently, mach-o will allow up to a max of 2^15 alignment in an\n+   object file.  */\n+#define L2_MAX_OFILE_ALIGNMENT 15\n+\n+  \n #ifdef DARWIN_DEBUG\n-static const char *GC_dyld_name_for_hdr(const struct GC_MACH_HEADER *hdr) {\n-    unsigned long i,c;\n-    c = _dyld_image_count();\n-    for(i=0;i<c;i++) if(_dyld_get_image_header(i) == hdr)\n-        return _dyld_get_image_name(i);\n-    return NULL;\n+static const char *\n+GC_dyld_name_for_hdr (const struct GC_MACH_HEADER *hdr)\n+{\n+  unsigned long i,c;\n+  c = _dyld_image_count();\n+  for (i=0;i<c;i++) \n+    if(_dyld_get_image_header(i) == hdr)\n+      return _dyld_get_image_name(i);\n+  return NULL;\n }\n #endif\n-        \n+\n+\n /* This should never be called by a thread holding the lock */\n-static void GC_dyld_image_add(const struct GC_MACH_HEADER *hdr, intptr_t slide)\n+static void \n+GC_dyld_image_add (const struct GC_MACH_HEADER *hdr, intptr_t slide)\n {\n-    unsigned long start,end,i;\n-    const struct GC_MACH_SECTION *sec;\n-    if (GC_no_dls) return;\n-    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n+  char secnam[16];\n+  unsigned long start,end,i,j;\n+  const struct GC_MACH_SECTION *sec;\n+  const char *fmt;\n \n+  if (GC_no_dls)\n+    return;\n+\n+  for (i=0; i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]); i++)\n+    {\n       sec = GC_GETSECTBYNAME (hdr, GC_dyld_sections[i].seg,\n \t\t\t      GC_dyld_sections[i].sect);\n-        if(sec == NULL || sec->size == 0) continue;\n-        start = slide + sec->addr;\n-        end = start + sec->size;\n-#\tifdef DARWIN_DEBUG\n-            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n-                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n-#       endif\n-        GC_add_roots((char*)start,(char*)end);\n+      if(sec == NULL || sec->size == 0)\n+\tcontinue;\n+\n+      start = slide + sec->addr;\n+      end = start + sec->size;\n+\n+#     ifdef DARWIN_DEBUG\n+      GC_printf5(\"Adding section __DATA,%s at %p-%p (%lu bytes) from image %s\\n\",\n+                GC_dyld_sections[i].sect, start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#      endif\n+      GC_add_roots((char*)start,(char*)end);\n     }\n-#   ifdef DARWIN_DEBUG\n-        GC_print_static_roots();\n-#   endif\n+\n+  /* Sections constructed on demand.  */\n+  j=0;\n+  while ((fmt = GC_dyld_add_sect_fmts[j]) != NULL)\n+    {\n+      /* Add our manufactured aligned BSS sections.  */\n+      for (i=0; i<=L2_MAX_OFILE_ALIGNMENT; i++)\n+\t{\n+\t  snprintf (secnam, 16, fmt, (unsigned)i);\n+\t  sec = GC_GETSECTBYNAME (hdr, SEG_DATA, secnam);\n+\t  if (sec == NULL || sec->size == 0)\n+\t    continue;\n+\t  start = slide + sec->addr;\n+\t  end = start + sec->size;\n+#\t  ifdef DARWIN_DEBUG\n+\t  GC_printf5(\"Adding section __DATA,%s at %p-%p (%lu bytes) from image %s\\n\",\n+\t\t secnam, start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#\t  endif\n+\t  GC_add_roots((char*)start,(char*)end);\n+\t}\n+      j++;\n+    } \n+# ifdef DARWIN_DEBUG\n+  GC_print_static_roots();\n+# endif\n }\n \n /* This should never be called by a thread holding the lock */\n-static void GC_dyld_image_remove(const struct GC_MACH_HEADER *hdr,\n-\t\t\t\t intptr_t slide) {\n-    unsigned long start,end,i;\n-    const struct GC_MACH_SECTION *sec;\n-    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n+static void \n+GC_dyld_image_remove (const struct GC_MACH_HEADER *hdr, intptr_t slide)\n+{\n+  char secnam[16];\n+  unsigned long start,end,i,j;\n+  const struct GC_MACH_SECTION *sec;\n+  const char *fmt;\n+\n+  for (i=0; i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]); i++)\n+    {\n       sec = GC_GETSECTBYNAME (hdr, GC_dyld_sections[i].seg,\n \t\t\t      GC_dyld_sections[i].sect);\n-        if(sec == NULL || sec->size == 0) continue;\n-        start = slide + sec->addr;\n-        end = start + sec->size;\n-#\tifdef DARWIN_DEBUG\n-            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n-                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n-#\t\tendif\n-        GC_remove_roots((char*)start,(char*)end);\n+      if(sec == NULL || sec->size == 0)\n+\tcontinue;\n+\n+      start = slide + sec->addr;\n+      end = start + sec->size;\n+#     ifdef DARWIN_DEBUG\n+      GC_printf5(\"Removing section __DATA,%s at %p-%p (%lu bytes) from image %s\\n\",\n+                  GC_dyld_sections[i].sect, start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#      endif\n+      GC_remove_roots((char*)start,(char*)end);\n     }\n-#   ifdef DARWIN_DEBUG\n-        GC_print_static_roots();\n-#   endif\n+\n+  /* Remove our on-demand sections.  */\n+  j=0;\n+  while ((fmt = GC_dyld_add_sect_fmts[j]) != NULL)\n+    {\n+      for (i=0; i<=L2_MAX_OFILE_ALIGNMENT; i++)\n+\t{\n+\t  snprintf (secnam, 16, fmt, (unsigned)i);\n+\t  sec = GC_GETSECTBYNAME (hdr, SEG_DATA, secnam);\n+\t  if (sec == NULL || sec->size == 0)\n+\t    continue;\n+\t  start = slide + sec->addr;\n+\t  end = start + sec->size;\n+#\t  ifdef DARWIN_DEBUG\n+\t  GC_printf5(\"Removing section __DATA,%s at %p-%p (%lu bytes) from image %s\\n\",\n+\t\t      secnam, start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n+#\t  endif\n+\t  GC_remove_roots((char*)start,(char*)end);\n+\t}\n+      j++;\n+    }\n+\n+# ifdef DARWIN_DEBUG\n+  GC_print_static_roots();\n+# endif\n }\n \n-void GC_register_dynamic_libraries() {\n+void \n+GC_register_dynamic_libraries() \n+{\n     /* Currently does nothing. The callbacks are setup by GC_init_dyld() \n     The dyld library takes it from there. */\n }\n@@ -1233,15 +1328,18 @@ void GC_register_dynamic_libraries() {\n    This should be called BEFORE any thread in created and WITHOUT the\n    allocation lock held. */\n    \n-void GC_init_dyld() {\n+void \n+GC_init_dyld()\n+{\n   static GC_bool initialized = FALSE;\n   char *bind_fully_env = NULL;\n   \n-  if(initialized) return;\n+  if(initialized)\n+    return;\n   \n-#   ifdef DARWIN_DEBUG\n+# ifdef DARWIN_DEBUG\n   GC_printf0(\"Registering dyld callbacks...\\n\");\n-#   endif\n+# endif\n   \n   /* Apple's Documentation:\n      When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n@@ -1254,27 +1352,28 @@ void GC_init_dyld() {\n      linked in the future\n   */\n   \n-    _dyld_register_func_for_add_image(GC_dyld_image_add);\n-    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n+  _dyld_register_func_for_add_image(GC_dyld_image_add);\n+  _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n \n-    /* Set this early to avoid reentrancy issues. */\n-    initialized = TRUE;\n+  /* Set this early to avoid reentrancy issues. */\n+  initialized = TRUE;\n \n-    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n+  bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n     \n-    if (bind_fully_env == NULL) {\n-#   ifdef DARWIN_DEBUG\n+  if (bind_fully_env == NULL)\n+    {\n+#     ifdef DARWIN_DEBUG\n       GC_printf0(\"Forcing full bind of GC code...\\n\");\n-#   endif\n+#     endif\n       \n-      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n-        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n+      if (!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n+\tGC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n     }\n-\n }\n \n #define HAVE_REGISTER_MAIN_STATIC_DATA\n-GC_bool GC_register_main_static_data()\n+GC_bool \n+GC_register_main_static_data (void)\n {\n   /* Already done through dyld callbacks */\n   return FALSE;"}, {"sha": "27c9bf66b21b7a40ee02b98ebf1dd528bf3f7207", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,3 +1,57 @@\n+2010-11-29  Iain Sandoe  <iains@gcc.gnu.org>\n+\t    Mike Stump  <mrs@gcc.gnu.org>\n+\n+\tPR target/26427\n+\tPR target/33120\n+\tPR testsuite/35710\n+\t* config/i386/darwin.h (ASM_OUTPUT_COMMON): Remove\n+\t(ASM_OUTPUT_LOCAL): Likewise.\n+\t* config/darwin-protos.h (darwin_asm_declare_object_name): New.\n+\t(darwin_output_aligned_bss): Likewise.\n+\t(darwin_asm_output_aligned_decl_local): Likewise.\n+\t(darwin_asm_output_aligned_decl_common): Likewise.\n+\t(darwin_use_anchors_for_symbol_p): Likewise.\n+\t* config/rs6000/darwin.h (ASM_OUTPUT_COMMON): Remove.\n+\t(TARGET_ASM_OUTPUT_ANCHOR): Define.\n+\t(TARGET_USE_ANCHORS_FOR_SYMBOL_P): Define.\n+\t(DARWIN_SECTION_ANCHORS): Set to 1.\n+\t* config/darwin.c (emit_aligned_common): New var.\n+\t(darwin_init_sections): Check that the Darwin private zero-size section\n+\tmarker is in range.\n+\t(darwin_text_section): Check for zero-sized objects.\n+\t(darwin_mergeable_string_section): Likewise.\n+\t(darwin_mergeable_constant_section): Likewise.\n+\t(machopic_select_section): Adjust to check for zero-sized objects.\n+\tAssert that OBJC meta data are non-zero sized.\n+\t(darwin_asm_declare_object_name): New.\n+\t(darwin_asm_declare_constant_name): Adjust for zero-sized\n+\tobject sections.\n+\t(BYTES_ZFILL): Define.\n+\t(darwin_emit_weak_or_comdat): New.\n+\t(darwin_emit_local_bss): New.\n+\t(darwin_emit_common): New.\n+\t(darwin_output_aligned_bss): New.\n+\t(darwin_asm_output_aligned_decl_common): New.\n+\t(darwin_asm_output_aligned_decl_local): New.\n+\t(darwin_file_end): Disable subsections_via_symbols when section\n+\tanchoring is active.\n+\t(darwin_asm_output_anchor): Re-enable.\n+\t(darwin_use_anchors_for_symbol_p): New.\n+\t(darwin_override_options): Check for versions that can emit\n+\taligned common.  Update usage of flags to current.\n+\t* config/darwin-sections.def: Update comments and flags for\n+\tnon-anchor sections.  zobj_const_section, zobj_data_section,\n+\tzobj_bss_section, zobj_const_data_section: New.\n+\t* config/darwin.h (ASM_DECLARE_OBJECT_NAME): Redefine.\n+\t(ASM_OUTPUT_ALIGN): Make whitespace output consistent.\n+\t(L2_MAX_OFILE_ALIGNMENT): Define.\n+\t(ASM_OUTPUT_ALIGNED_BSS): Define.\n+\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): Define.\n+\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): Define.\n+\t(SECTION_NO_ANCHOR): Define.\n+\t(TARGET_ASM_OUTPUT_ANCHOR) Define with a default of NULL.\n+\t(DARWIN_SECTION_ANCHORS): Define with a default of 0.\n+\t\n 2010-11-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* system.h: Include \"safe-ctype.h\" instead of <safe-ctype.h>."}, {"sha": "fca8065e074dbb2d0b2f138825a65f31a52082d5", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -85,12 +85,26 @@ extern tree darwin_handle_weak_import_attribute (tree *node, tree name,\n extern void machopic_output_stub (FILE *, const char *, const char *);\n extern void darwin_globalize_label (FILE *, const char *);\n extern void darwin_assemble_visibility (tree, int);\n+\n extern void darwin_asm_output_dwarf_delta (FILE *, int, const char *,\n \t\t\t\t\t   const char *);\n extern void darwin_asm_output_dwarf_offset (FILE *, int, const char *,\n \t\t\t\t\t    section *);\n+\n+extern void darwin_asm_declare_object_name (FILE *, const char *, tree);\n extern void darwin_asm_declare_constant_name (FILE *, const char *,\n \t\t\t\t\t      const_tree, HOST_WIDE_INT);\n+\n+extern void darwin_output_aligned_bss (FILE *, tree, const char *,\n+\t\t\t\t       unsigned HOST_WIDE_INT, unsigned int);\n+\n+extern void darwin_asm_output_aligned_decl_local (FILE *, tree, const char *, \n+\t\t\t\t\t\t  unsigned HOST_WIDE_INT, \n+\t\t\t\t\t\t  unsigned int);\n+extern void darwin_asm_output_aligned_decl_common (FILE *, tree, const char *,\n+\t\t\t\t\t\t   unsigned HOST_WIDE_INT, \n+\t\t\t\t\t\t   unsigned int);\n+\n extern bool darwin_binds_local_p (const_tree);\n extern void darwin_cpp_builtins (struct cpp_reader *);\n \n@@ -104,6 +118,7 @@ extern tree darwin_build_constant_cfstring (tree);\n extern void darwin_enter_string_into_cfstring_table (tree);\n \n extern void darwin_asm_output_anchor (rtx symbol);\n+extern bool darwin_use_anchors_for_symbol_p (const_rtx symbol);\n extern bool darwin_kextabi_p (void);\n extern void darwin_override_options (void);\n extern void darwin_patch_builtins (void);"}, {"sha": "198fdcbb29ca839dc3f3e59a56ba64ac2f63ab41", "filename": "gcc/config/darwin-sections.def", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin-sections.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin-sections.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-sections.def?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -16,30 +16,70 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-DEF_SECTION (text_coal_section, SECTION_CODE,\n+/* Since Darwin's ld will not allow zero-sized objects, and gcc wants them,\n+   we emit one byte (in darwin.c) when such an object is encountered.\n+\n+   This messes up section anchoring because the emitted byte is not counted\n+   outside the port.  To cope with this, we set aside sections for zero-sized\n+   objects and disallow those sections from  participating in section anchors\n+   (\"zobj_\" sections, below).\n+   \n+   Items that might be coalesced by the linker are prevented from participating,\n+   (and those in mergeable sections are disallowed in varasm.c).  */\n+\n+/* .text handled in varasm.c  */\n+DEF_SECTION (text_coal_section, SECTION_CODE|SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__textcoal_nt,coalesced,pure_instructions\", 0)\n-DEF_SECTION (text_unlikely_coal_section, SECTION_CODE,\n+DEF_SECTION (text_unlikely_coal_section, SECTION_CODE|SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__text_unlikely_coal,\"\n \t     \"coalesced,pure_instructions\", 0)\n+\n+/* const */\n DEF_SECTION (const_section, 0, \".const\", 0)\n-DEF_SECTION (const_coal_section, 0,\n+DEF_SECTION (const_coal_section, SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__const_coal,coalesced\", 0)\n+/* Place to put zero-sized to avoid issues with section anchors.  */\n+DEF_SECTION (zobj_const_section, SECTION_NO_ANCHOR, \n+\t     \".section\\t__DATA,__zobj_const\", 0)\n+\n+/* Write-able data.  '.data'  handled in varasm.c  */\n+DEF_SECTION (static_data_section, SECTION_WRITE, \".static_data\", 0)\n+DEF_SECTION (data_coal_section, SECTION_WRITE|SECTION_NO_ANCHOR,\n+\t     \".section __DATA,__datacoal_nt,coalesced\", 0)\n+/* Place to put zero-sized to avoid issues with section anchors.  */\n+DEF_SECTION (zobj_data_section, SECTION_WRITE|SECTION_NO_ANCHOR, \n+\t     \".section\\t__DATA,__zobj_data\", 0)\n+\n+/* BSS - .lcomm / .zerofill __DATA,__bss sections cannot be switched to\n+   explicitly (will create an assembler error).  */\n+DEF_SECTION (zobj_bss_section, SECTION_WRITE|SECTION_BSS|SECTION_NO_ANCHOR, \n+\t     \".section\\t__DATA,__zobj_bss\", 0)\n+\n+/* const data */\n DEF_SECTION (const_data_section, 0, \".const_data\", 0)\n-DEF_SECTION (const_data_coal_section, 0,\n+DEF_SECTION (const_data_coal_section, SECTION_NO_ANCHOR,\n \t     \".section __DATA,__const_coal,coalesced\", 0)\n-DEF_SECTION (data_coal_section, SECTION_WRITE,\n-\t     \".section __DATA,__datacoal_nt,coalesced\", 0)\n+/* Place to put zero-sized to avoid issues with section anchors.  */\n+DEF_SECTION (zobj_const_data_section, SECTION_NO_ANCHOR, \n+\t     \".section\\t__DATA,__zobj_const_data\", 0)\n+\n+/* Strings and other literals.  */\n DEF_SECTION (cstring_section, SECTION_MERGE | SECTION_STRINGS, \".cstring\", 0)\n DEF_SECTION (literal4_section, SECTION_MERGE, \".literal4\", 0)\n DEF_SECTION (literal8_section, SECTION_MERGE, \".literal8\", 0)\n DEF_SECTION (literal16_section, SECTION_MERGE, \".literal16\", 0)\n-/* Unlike constant NSStrings, constant CFStrings do not live  in the __OBJC segment\n-  since they may also occur in pure C  or C++ programs.  */\n-DEF_SECTION (cfstring_constant_object_section, 0, \".section __DATA, __cfstring\", 0)\n-DEF_SECTION (constructor_section, 0, \".constructor\", 0)\n+/* Unlike constant NSStrings, constant CFStrings do not live  in the\n+   __OBJC segment since they may also occur in pure C  or C++ programs.  */\n+DEF_SECTION (cfstring_constant_object_section, 0, \n+\t     \".section __DATA, __cfstring\", 0)\n+\n+/* Module init, term, constructors & destructors.  */\n DEF_SECTION (mod_init_section, 0, \".mod_init_func\", 0)\n DEF_SECTION (mod_term_section, 0, \".mod_term_func\", 0)\n+DEF_SECTION (constructor_section, 0, \".constructor\", 0)\n DEF_SECTION (destructor_section, 0, \".destructor\", 0)\n+\n+/* Objective-C (V1) sections.  */\n DEF_SECTION (objc_class_section, 0, \".objc_class\", 1)\n DEF_SECTION (objc_meta_class_section, 0, \".objc_meta_class\", 1)\n DEF_SECTION (objc_category_section, 0, \".objc_category\", 1)\n@@ -66,32 +106,38 @@ DEF_SECTION (objc_class_names_section, 0, \".objc_class_names\", 1)\n DEF_SECTION (objc_meth_var_names_section, 0, \".objc_meth_var_names\", 1)\n DEF_SECTION (objc_meth_var_types_section, 0, \".objc_meth_var_types\", 1)\n DEF_SECTION (objc_cls_refs_section, SECTION_MERGE, \".objc_cls_refs\", 1)\n+\n+/* Stubs and symbol indirection sections.  */\n /* lazy symbol pointers.  */\n-DEF_SECTION (machopic_lazy_symbol_ptr_section, 0, \".lazy_symbol_pointer\", 0)\n-DEF_SECTION (machopic_lazy_symbol_ptr2_section,\t0,\n+DEF_SECTION (machopic_lazy_symbol_ptr_section, SECTION_NO_ANCHOR, \n+\t     \".lazy_symbol_pointer\", 0)\n+DEF_SECTION (machopic_lazy_symbol_ptr2_section,\tSECTION_NO_ANCHOR,\n \t     \".section __DATA, __la_sym_ptr2,lazy_symbol_pointers\", 0)\n-DEF_SECTION (machopic_lazy_symbol_ptr3_section, 0,\n+DEF_SECTION (machopic_lazy_symbol_ptr3_section, SECTION_NO_ANCHOR,\n \t     \".section __DATA, __la_sym_ptr3,lazy_symbol_pointers\", 0)\n /* non-lazy symbol pointers.  */\n-DEF_SECTION (machopic_nl_symbol_ptr_section, 0,\n+DEF_SECTION (machopic_nl_symbol_ptr_section, SECTION_NO_ANCHOR,\n \t     MACHOPIC_NL_SYMBOL_PTR_SECTION, 0)\n /* Symbol stubs.  */\n-DEF_SECTION (machopic_symbol_stub_section, 0, \".symbol_stub\", 0)\n-DEF_SECTION (machopic_symbol_stub1_section, 0,\n+DEF_SECTION (machopic_symbol_stub_section, SECTION_NO_ANCHOR, \n+\t     \".symbol_stub\", 0)\n+DEF_SECTION (machopic_symbol_stub1_section, SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__symbol_stub1,symbol_stubs,\"\n \t     \"pure_instructions,16\", 0)\n /* PIC symbol stubs.  */\n-DEF_SECTION (machopic_picsymbol_stub_section, 0, \".picsymbol_stub\", 0)\n-DEF_SECTION (machopic_picsymbol_stub1_section, 0,\n+DEF_SECTION (machopic_picsymbol_stub_section, SECTION_NO_ANCHOR, \n+\t     \".picsymbol_stub\", 0)\n+DEF_SECTION (machopic_picsymbol_stub1_section, SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__picsymbolstub1,symbol_stubs,\"\n \t     \"pure_instructions,32\", 0)\n-DEF_SECTION (machopic_picsymbol_stub2_section, 0,\n+DEF_SECTION (machopic_picsymbol_stub2_section, SECTION_NO_ANCHOR,\n \t     \".section __TEXT,__picsymbolstub2,symbol_stubs,pure_instructions,25\", 0)\n-DEF_SECTION (machopic_picsymbol_stub3_section, 0,\n+DEF_SECTION (machopic_picsymbol_stub3_section, SECTION_NO_ANCHOR,\n \t     \".section __IMPORT,__jump_table,symbol_stubs,self_modifying_code+pure_instructions,5\", 0)\n+\n /* Exception-related.  */\n-DEF_SECTION (darwin_exception_section, 0,\n+DEF_SECTION (darwin_exception_section, SECTION_NO_ANCHOR,\n \t     \".section __DATA,__gcc_except_tab\", 0)\n-DEF_SECTION (darwin_eh_frame_section, 0,\n+DEF_SECTION (darwin_eh_frame_section, SECTION_NO_ANCHOR,\n \t     \".section \" EH_FRAME_SECTION_NAME \",__eh_frame\"\n \t     EH_FRAME_SECTION_ATTR, 0)"}, {"sha": "596ed11501997fd1429d7920b90358d49d2aece3", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 621, "deletions": 28, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -105,6 +105,10 @@ section * darwin_sections[NUM_DARWIN_SECTIONS];\n /* True if we're setting __attribute__ ((ms_struct)).  */\n int darwin_ms_struct = false;\n \n+/* Earlier versions of Darwin as do not recognize an alignment field in \n+   .comm directives, this should be set for versions that allow it.  */\n+int emit_aligned_common = false;\n+\n /* A get_unnamed_section callback used to switch to an ObjC section.\n    DIRECTIVE is as for output_section_asm_op.  */\n \n@@ -172,6 +176,10 @@ darwin_init_sections (void)\n   readonly_data_section = darwin_sections[const_section];\n   exception_section = darwin_sections[darwin_exception_section];\n   eh_frame_section = darwin_sections[darwin_eh_frame_section];\n+\n+  /* Make sure that there is no conflict between the 'no anchor' section\n+     flag declared in darwin.h and the section flags declared in output.h.  */\n+  gcc_assert (SECTION_NO_ANCHOR > SECTION_MACH_DEP);\n }\n \n int\n@@ -1152,17 +1160,19 @@ darwin_text_section (int reloc, int weak)\n }\n \n static section *\n-darwin_rodata_section (int weak)\n+darwin_rodata_section (int weak, bool zsize)\n {\n   return (weak\n \t  ? darwin_sections[const_coal_section]\n-\t  : darwin_sections[const_section]);\n+\t  : (zsize ? darwin_sections[zobj_const_section]\n+\t\t   : darwin_sections[const_section]));\n }\n \n static section *\n darwin_mergeable_string_section (tree exp,\n \t\t\t\t unsigned HOST_WIDE_INT align)\n {\n+\n   if (flag_merge_constants\n       && TREE_CODE (exp) == STRING_CST\n       && TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n@@ -1173,6 +1183,11 @@ darwin_mergeable_string_section (tree exp,\n \t  == strlen (TREE_STRING_POINTER (exp)) + 1))\n     return darwin_sections[cstring_section];\n \n+  if (DARWIN_SECTION_ANCHORS && flag_section_anchors\n+      && TREE_CODE (exp) == STRING_CST\n+      && TREE_STRING_LENGTH (exp) == 0)\n+    return darwin_sections[zobj_const_section];\n+\n   return readonly_data_section;\n }\n \n@@ -1182,11 +1197,17 @@ darwin_mergeable_string_section (tree exp,\n \n static section *\n darwin_mergeable_constant_section (tree exp,\n-\t\t\t\t   unsigned HOST_WIDE_INT align)\n+\t\t\t\t   unsigned HOST_WIDE_INT align,\n+\t\t\t\t   bool zsize)\n {\n   enum machine_mode mode = DECL_MODE (exp);\n   unsigned int modesize = GET_MODE_BITSIZE (mode);\n \n+  if (DARWIN_SECTION_ANCHORS \n+      && flag_section_anchors \n+      && zsize)\n+    return darwin_sections[zobj_const_section];\n+\n   if (flag_merge_constants\n       && mode != VOIDmode\n       && mode != BLKmode\n@@ -1229,12 +1250,23 @@ machopic_select_section (tree decl,\n \t\t\t int reloc,\n \t\t\t unsigned HOST_WIDE_INT align)\n {\n-  bool weak = (DECL_P (decl)\n-\t       && DECL_WEAK (decl)\n-\t       && !lookup_attribute (\"weak_import\",\n-\t\t\t\t     DECL_ATTRIBUTES (decl)));\n+  bool zsize, one, weak, ro;\n   section *base_section = NULL;\n \n+  weak = (DECL_P (decl)\n+\t  && DECL_WEAK (decl)\n+\t  && !lookup_attribute (\"weak_import\", DECL_ATTRIBUTES (decl)));\n+\n+  zsize = (DECL_P (decl) \n+\t   && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL) \n+\t   && tree_low_cst (DECL_SIZE_UNIT (decl), 1) == 0);\n+\n+  one = DECL_P (decl) \n+\t&& TREE_CODE (decl) == VAR_DECL \n+\t&& DECL_ONE_ONLY (decl);\n+\n+  ro = TREE_READONLY (decl) || TREE_CONSTANT (decl) ;\n+\n   switch (categorize_decl_for_section (decl, reloc))\n     {\n     case SECCAT_TEXT:\n@@ -1253,7 +1285,7 @@ machopic_select_section (tree decl,\n \n     case SECCAT_RODATA:\n     case SECCAT_SRODATA:\n-      base_section = darwin_rodata_section (weak);\n+      base_section = darwin_rodata_section (weak, zsize);\n       break;\n \n     case SECCAT_RODATA_MERGE_STR:\n@@ -1265,7 +1297,7 @@ machopic_select_section (tree decl,\n       break;\n \n     case SECCAT_RODATA_MERGE_CONST:\n-      base_section =  darwin_mergeable_constant_section (decl, align);\n+      base_section =  darwin_mergeable_constant_section (decl, align, zsize);\n       break;\n \n     case SECCAT_DATA:\n@@ -1275,14 +1307,46 @@ machopic_select_section (tree decl,\n     case SECCAT_DATA_REL_RO_LOCAL:\n     case SECCAT_SDATA:\n     case SECCAT_TDATA:\n+      if (weak || one)\n+\t{\n+\t  if (ro)\n+\t    base_section = darwin_sections[const_data_coal_section];\n+\t  else \n+\t    base_section = darwin_sections[data_coal_section];\n+\t}\n+      else if (DARWIN_SECTION_ANCHORS \n+\t       && flag_section_anchors\n+\t       && zsize)\n+\t{\n+\t  /* If we're doing section anchors, then punt zero-sized objects into\n+\t     their own sections so that they don't interfere with offset\n+\t     computation for the remaining vars.  This does not need to be done\n+\t     for stuff in mergeable sections, since these are ineligible for \n+\t     anchors.  */\n+\t  if (ro)\n+\t    base_section = darwin_sections[zobj_const_data_section];\n+\t  else\n+\t    base_section = darwin_sections[zobj_data_section];\n+\t}\n+      else if (ro)\n+\tbase_section = darwin_sections[const_data_section];\n+      else\n+\tbase_section = data_section;\n+      break;\n     case SECCAT_BSS:\n     case SECCAT_SBSS:\n     case SECCAT_TBSS:\n-      if (TREE_READONLY (decl) || TREE_CONSTANT (decl))\n-\tbase_section = weak ? darwin_sections[const_data_coal_section]\n-\t\t\t    : darwin_sections[const_data_section];\n+      if (weak || one) \n+\tbase_section = darwin_sections[data_coal_section];\n       else\n-\tbase_section = weak ? darwin_sections[data_coal_section] : data_section;\n+\t{\n+\t  if (!TREE_PUBLIC (decl))\n+\t    base_section = lcomm_section;\n+\t  else if (bss_noswitch_section)\n+\t    base_section = bss_noswitch_section;\n+\t  else\n+\t    base_section = data_section;\n+\t}\n       break;\n \n     default:\n@@ -1319,13 +1383,16 @@ machopic_select_section (tree decl,\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n \n+      /* We shall assert that zero-sized objects are an error in ObjC \n+         meta-data.  */\n+      gcc_assert (tree_low_cst (DECL_SIZE_UNIT (decl), 1) != 0);\n       if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\n         return darwin_sections[objc_cls_meth_section];\n       else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\n         return darwin_sections[objc_inst_meth_section];\n-      else if (!strncmp (name, \"_OBJC_CATEGORY_CLASS_METHODS_\", 20))\n+      else if (!strncmp (name, \"_OBJC_CATEGORY_CLASS_METHODS_\", 29))\n         return darwin_sections[objc_cat_cls_meth_section];\n-      else if (!strncmp (name, \"_OBJC_CATEGORY_INSTANCE_METHODS_\", 23))\n+      else if (!strncmp (name, \"_OBJC_CATEGORY_INSTANCE_METHODS_\", 32))\n         return darwin_sections[objc_cat_inst_meth_section];\n       else if (!strncmp (name, \"_OBJC_CLASS_VARIABLES_\", 22))\n         return darwin_sections[objc_class_vars_section];\n@@ -1688,18 +1755,514 @@ darwin_non_lazy_pcrel (FILE *file, rtx addr)\n   fputs (\"-.\", file);\n }\n \n-/* The implementation of ASM_DECLARE_CONSTANT_NAME.  */\n+/* If this is uncommented, details of each allocation will be printed\n+   in the asm right before the actual code.  WARNING - this will cause some\n+   test-suite fails (since the printout will contain items that some tests\n+   are not expecting) -- so don't leave it on by default (it bloats the\n+   asm too).  */\n+/*#define DEBUG_DARWIN_MEM_ALLOCATORS*/\n+\n+/* The first two of these routines are ostensibly just intended to put\n+   names into the asm.  However, they are both hijacked in order to ensure\n+   that zero-sized items do not make their way into the output.  Consequently,\n+   we also need to make these participate in provisions for dealing with\n+   such items in section anchors.  */\n+\n+/* The implementation of ASM_DECLARE_OBJECT_NAME.  */\n+/* The RTTI data (e.g., __ti4name) is common and public (and static),\n+   but it does need to be referenced via indirect PIC data pointers.\n+   The machopic_define_symbol calls are telling the machopic subsystem\n+   that the name *is* defined in this module, so it doesn't need to\n+   make them indirect.  */\n+void \n+darwin_asm_declare_object_name (FILE *file, \n+\t\t\t\tconst char *nam, tree decl)\n+{\n+  const char *xname = nam;\n+  unsigned HOST_WIDE_INT size;\n+  bool local_def, weak;\n+\n+  weak = (DECL_P (decl)\n+\t  && DECL_WEAK (decl)\n+\t  && !lookup_attribute (\"weak_import\", \n+\t\t\t\t DECL_ATTRIBUTES (decl)));\n+\n+  local_def = DECL_INITIAL (decl) || (TREE_STATIC (decl) \n+\t\t\t\t      && (!DECL_COMMON (decl) \n+\t\t\t\t\t  || !TREE_PUBLIC (decl)));\n+\n+  if (GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n+    xname = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\n+  if (local_def)\n+    {\n+      (* targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n+      if (!weak)\n+\tmachopic_define_symbol (DECL_RTL (decl));\n+    }\n+\n+  size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+\n+#ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n+fprintf (file, \"# dadon: %s %s (%llu, %u) local %d weak %d\"\n+\t       \" stat %d com %d pub %d t-const %d t-ro %d init %lx\\n\",\n+\txname, (TREE_CODE (decl) == VAR_DECL?\"var\":\"const\"), \n+\t(unsigned long long)size, DECL_ALIGN (decl), local_def, \n+\tDECL_WEAK (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n+\tTREE_PUBLIC (decl), TREE_CONSTANT (decl), TREE_READONLY (decl),\n+\t(unsigned long)DECL_INITIAL (decl)); \n+#endif\n+\n+  /* Darwin needs help to support local zero-sized objects. \n+     They must be made at least one byte, and the section containing must be\n+     marked as unsuitable for section-anchors (see storage allocators below).\n+     \n+     For non-zero objects this output is handled by varasm.c.\n+  */\n+  if (!size)\n+    {\n+      unsigned int l2align = 0;\n \n+      /* The align must be honoured, even for zero-sized.  */\n+      if (DECL_ALIGN (decl))\n+\t{\n+\t  l2align = floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT);\n+\t  fprintf (file, \"\\t.align\\t%u\\n\", l2align);\n+\t}\n+\n+      ASM_OUTPUT_LABEL (file, xname);\n+      size = 1;\n+      fprintf (file, \"\\t.space\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+\n+      /* Check that we've correctly picked up the zero-sized item and placed it\n+         properly.  */\n+      gcc_assert ((!DARWIN_SECTION_ANCHORS || !flag_section_anchors)\n+\t\t  || (in_section \n+\t\t      && (in_section->common.flags & SECTION_NO_ANCHOR)));\n+    }\n+  else\n+    ASM_OUTPUT_LABEL (file, xname);\n+}\n+\n+/* The implementation of ASM_DECLARE_CONSTANT_NAME.  */\n void\n darwin_asm_declare_constant_name (FILE *file, const char *name,\n \t\t\t\t  const_tree exp ATTRIBUTE_UNUSED,\n \t\t\t\t  HOST_WIDE_INT size)\n {\n   assemble_label (file, name);\n+  /* As for other items, we need at least one byte.  */\n+  if (!size)\n+    {\n+      fputs (\"\\t.space\\t1\\n\", file);\n+      /* Check that we've correctly picked up the zero-sized item and placed it\n+         properly.  */\n+      gcc_assert ((!DARWIN_SECTION_ANCHORS || !flag_section_anchors)\n+\t\t  || (in_section \n+\t\t      && (in_section->common.flags & SECTION_NO_ANCHOR)));\n+    }\n+}\n+\n+/* Darwin storage allocators.\n+\n+   Zerofill sections are desirable for large blank data since, otherwise, these\n+   data bloat objects (PR33210).\n+\n+   However, section anchors don't work in .zerofill sections (one cannot switch\n+   to a zerofill section).  Ergo, for Darwin targets using section anchors we need\n+   to put (at least some) data into 'normal' switchable sections.\n+\n+   Here we set a relatively arbitrary value for the size of an object to trigger\n+   zerofill when section anchors are enabled (anything bigger than a page for\n+   current Darwin implementations).  FIXME: there ought to be some objective way\n+   to make this choice.\n+\n+   When section anchor are off this is ignored anyway.  */\n+\n+#define BYTES_ZFILL 4096\n+\n+/* Emit a chunk of data for items coalesced by the linker.  */\n+static void\n+darwin_emit_weak_or_comdat (FILE *fp, tree decl, const char *name,\n+\t\t\t\t  unsigned HOST_WIDE_INT size, \n+\t\t\t\t  unsigned int align)\n+{\n+  /* Since the sections used here are coalesed, they will not be eligible\n+     for section anchors, and therefore we don't need to break that out.  */\n+ if (TREE_READONLY (decl) || TREE_CONSTANT (decl))\n+    switch_to_section (darwin_sections[const_data_coal_section]);\n+  else\n+    switch_to_section (darwin_sections[data_coal_section]);\n+\n+  /* To be consistent, we'll allow darwin_asm_declare_object_name to assemble\n+     the align info for zero-sized items... but do it here otherwise.  */\n+  if (size && align)\n+    fprintf (fp, \"\\t.align\\t%d\\n\", floor_log2 (align / BITS_PER_UNIT));\n+\n+  if (TREE_PUBLIC (decl))\n+    darwin_globalize_label (fp, name);\n+\n+  /* ... and we let it deal with outputting one byte of zero for them too.  */ \n+  darwin_asm_declare_object_name (fp, name, decl);\n+  if (size)\n+    assemble_zeros (size);\n+}\n+\n+/* This routine emits 'local' storage:\n+\n+   When Section Anchors are off this routine emits .zerofill commands in \n+   sections named for their alignment.\n+\n+   When Section Anchors are on, smaller (non-zero-sized) items are placed in\n+   the .static_data section so that the section anchoring system can see them.\n+   Larger items are still placed in .zerofill sections, addressing PR33210.\n+   The routine has no checking - it is all assumed to be done by the caller.\n+*/\n+static void\n+darwin_emit_local_bss (FILE *fp, tree decl, const char *name, \n+\t\t\tunsigned HOST_WIDE_INT size, \n+\t\t\tunsigned int l2align)\n+{\n+   /* FIXME: We have a fudge to make this work with Java even when the target does\n+   not use sections anchors -- Java seems to need at least one small item in a\n+   non-zerofill segment.   */\n+   if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n+       || (size && size <= 2))\n+    {\n+      /* Put smaller objects in _static_data, where the section anchors system\n+\t can get them.\n+\t However, if they are zero-sized punt them to yet a different section\n+\t (that is not allowed to participate in anchoring).  */\n+      if (!size)\n+\t{\n+\t  fputs (\"\\t.section\\t__DATA,__zobj_bss\\n\", fp);\n+\t  in_section = darwin_sections[zobj_bss_section];\n+\t  size = 1;\n+\t}\n+      else\n+\t{\n+\t  fputs (\"\\t.static_data\\n\", fp);\n+\t  in_section = darwin_sections[static_data_section];\n+\t}\n+\n+      if (l2align)\n+\tfprintf (fp, \"\\t.align\\t%u\\n\", l2align);\n+\n+      assemble_name (fp, name);        \n+      fprintf (fp, \":\\n\\t.space\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+    }\n+  else \n+    {\n+      /* When we are on a non-section anchor target, we can get zero-sized\n+\t items here.  However, all we need to do is to bump them to one byte\n+\t and the section alignment will take care of the rest.  */\n+      char secnam[64];\n+      unsigned int flags ;\n+      snprintf (secnam, 64, \"__DATA,__%sbss%u\", ((size)?\"\":\"zo_\"), \n+\t\t\t\t\t\t(unsigned) l2align);\n+      /* We can't anchor (yet, if ever) in zerofill sections, because we can't\n+\t switch to them and emit a label.  */\n+      flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n+      in_section = get_section (secnam, flags, NULL);\n+      fprintf (fp, \"\\t.zerofill %s,\", secnam);\n+      assemble_name (fp, name);\n+      if (!size)\n+\tsize = 1;\n+\n+      if (l2align)\n+\tfprintf (fp, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\n+\t\t size, (unsigned) l2align);\n+      else\n+\tfprintf (fp, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+    }\n+\n+  (*targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n+  /* This is defined as a file-scope var, so we know to notify machopic.  */\n+  machopic_define_symbol (DECL_RTL (decl));\n+}\n+\n+/* Emit a chunk of common.  */\n+static void\n+darwin_emit_common (FILE *fp, const char *name,\n+\t\t    unsigned HOST_WIDE_INT size, unsigned int align) \n+{\n+  unsigned HOST_WIDE_INT rounded;\n+  unsigned int l2align;\n+\n+  /* Earlier systems complain if the alignment exceeds the page size. \n+     The magic number is 4096 * 8 - hard-coded for legacy systems.  */\n+  if (!emit_aligned_common && (align > 32768UL))\n+    align = 4096UL; /* In units.  */\n+  else\n+    align /= BITS_PER_UNIT;\n+\n+  /* Make sure we have a meaningful align.  */\n+  if (!align)\n+    align = 1;\n \n-  /* Darwin doesn't support zero-size objects, so give them a byte.  */\n-  if ((size) == 0)\n-    assemble_zeros (1);\n+  /* For earlier toolchains, we need to emit the var as a rounded size to \n+     tell ld the alignment.  */\n+  if (size < align) \n+    rounded = align;\n+  else\n+    rounded = (size + (align-1)) & ~(align-1);\n+\n+  l2align = floor_log2 (align);\n+  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);\n+\n+  in_section = comm_section;\n+  /* We mustn't allow multiple public symbols to share an address when using\n+     the normal OSX toolchain.  */\n+  if (!size)\n+    {\n+      /* Put at least one byte.  */\n+      size = 1;\n+      /* This section can no longer participate in section anchoring.  */\n+      comm_section->common.flags |= SECTION_NO_ANCHOR;\n+    }\n+\n+  fputs (\"\\t.comm\\t\", fp);\n+  assemble_name (fp, name);\n+  fprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED, \n+\t   emit_aligned_common?size:rounded);\n+  if (l2align && emit_aligned_common)\n+    fprintf (fp, \",%u\", l2align);\n+  fputs (\"\\n\", fp);\n+}\n+\n+/* Output a var which is all zero - into aligned BSS sections, common, lcomm\n+   or coalescable data sections (for weak or comdat) as appropriate.  */\n+\n+void\n+darwin_output_aligned_bss (FILE *fp, tree decl, const char *name,\n+\t\t\t  unsigned HOST_WIDE_INT size, unsigned int align)\n+{\n+  unsigned int l2align;\n+  bool one, pub, weak;\n+\n+  pub = TREE_PUBLIC (decl);\n+  one = DECL_ONE_ONLY (decl);\n+  weak = (DECL_P (decl)\n+\t  && DECL_WEAK (decl)\n+\t  && !lookup_attribute (\"weak_import\", \n+\t\t\t\t DECL_ATTRIBUTES (decl)));\n+\n+#ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n+fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n+\t     \" pub %d weak %d one %d init %lx\\n\",\n+\tname, (long long)size, (int)align, TREE_READONLY (decl), \n+\tTREE_CONSTANT (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n+\tpub, weak, one, (unsigned long)DECL_INITIAL (decl)); \n+#endif\n+\n+  /* Check that any initializer is valid.  */\n+  gcc_assert ((DECL_INITIAL (decl) == NULL) \n+\t       || (DECL_INITIAL (decl) == error_mark_node) \n+\t       || initializer_zerop (DECL_INITIAL (decl)));\n+\n+  gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n+  gcc_assert (!DECL_COMMON (decl));\n+\n+  /*  Pick up the correct alignment.  */\n+  if (!size || !align)\n+    align = DECL_ALIGN (decl);\n+\n+  l2align = floor_log2 (align / BITS_PER_UNIT);\n+  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);\n+  \n+  last_assemble_variable_decl = decl;\n+\n+  /* We would rather not have to check this here - but it seems that we might\n+     be passed a decl that should be in coalesced space.  */\n+  if (one || weak)\n+    {\n+      /* Weak or COMDAT objects are put in mergable sections.  */\n+      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+\t\t\t\t\tDECL_ALIGN (decl));\n+      return;\n+    } \n+\n+  /* If this is not public, then emit according to local rules.  */\n+  if (!pub)\n+    {\n+      darwin_emit_local_bss (fp, decl, name, size, l2align);\t\n+      return;\n+    }\n+\n+  /* So we have a public symbol (small item fudge for Java, see above).  */\n+  if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL) \n+       || (size && size <= 2))\n+    {\n+      /* Put smaller objects in data, where the section anchors system can get\n+\t them.  However, if they are zero-sized punt them to yet a different \n+\t section (that is not allowed to participate in anchoring).  */\n+      if (!size)\n+\t{\n+\t  fputs (\"\\t.section\\t__DATA,__zobj_data\\n\", fp);\n+\t  in_section = darwin_sections[zobj_data_section];\n+\t  size = 1;\n+\t}\n+      else\n+\t{\n+\t  fputs (\"\\t.data\\n\", fp);\n+\t  in_section = data_section;\n+\t}\n+\n+      if (l2align)\n+\tfprintf (fp, \"\\t.align\\t%u\\n\", l2align);\n+\n+      assemble_name (fp, name);\n+      fprintf (fp, \":\\n\\t.space\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+    }\n+  else \n+    {\n+      char secnam[64];\n+      unsigned int flags ;\n+      /* When we are on a non-section anchor target, we can get zero-sized\n+\t items here.  However, all we need to do is to bump them to one byte\n+\t and the section alignment will take care of the rest.  */\n+      snprintf (secnam, 64, \"__DATA,__%spu_bss%u\", ((size)?\"\":\"zo_\"), l2align);\n+\n+      /* We can't anchor in zerofill sections, because we can't switch\n+\t to them and emit a label.  */\n+      flags = SECTION_BSS|SECTION_WRITE|SECTION_NO_ANCHOR;\n+      in_section = get_section (secnam, flags, NULL);\n+      fprintf (fp, \"\\t.zerofill %s,\", secnam);\n+      assemble_name (fp, name);\n+      if (!size)\n+\tsize = 1;\n+\n+      if (l2align)\n+\tfprintf (fp, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\", size, l2align);\n+      else\n+\tfprintf (fp, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n+    }\n+  (* targetm.encode_section_info) (decl, DECL_RTL (decl), false);\n+}\n+\n+/* Output a chunk of common, with alignment specified (where the target\n+   supports this).  */\n+void\n+darwin_asm_output_aligned_decl_common (FILE *fp, tree decl, const char *name,\n+\t\t\t\t       unsigned HOST_WIDE_INT size, \n+\t\t\t\t       unsigned int align)\n+{\n+  unsigned int l2align;\n+  bool one, weak;\n+  /* No corresponding var.  */\n+  if (decl==NULL)\n+    {\n+#ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n+fprintf (fp, \"# adcom: %s (%d,%d) decl=0x0\\n\", name, (int)size, (int)align); \n+#endif\n+      darwin_emit_common (fp, name, size, align);\n+      return;\n+    }\n+\n+  one = DECL_ONE_ONLY (decl);\n+  weak = (DECL_P (decl)\n+\t  && DECL_WEAK (decl)\n+\t  && !lookup_attribute (\"weak_import\", \n+\t\t\t\t DECL_ATTRIBUTES (decl)));\n+\n+#ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n+fprintf (fp, \"# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d\"\n+\t     \" weak %d one %d init %lx\\n\",\n+\tname,  (long long)size, (int)align, TREE_READONLY (decl), \n+\tTREE_CONSTANT (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n+\tTREE_PUBLIC (decl), weak, one, (unsigned long)DECL_INITIAL (decl)); \n+#endif\n+\n+  /* We shouldn't be messing with this if the decl has a section name.  */\n+  gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n+\n+  /* We would rather not have to check this here - but it seems that we might\n+     be passed a decl that should be in coalesced space.  */\n+  if (one || weak)\n+    {\n+      /* Weak or COMDAT objects are put in mergable sections.  */\n+      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+\t\t\t\t\tDECL_ALIGN (decl));\n+      return;\n+    } \n+\n+  /* We should only get here for DECL_COMMON, with a zero init (and, in \n+     principle, only for public symbols too - although we deal with local\n+     ones below).  */\n+\n+  /* Check the initializer is OK.  */\n+  gcc_assert (DECL_COMMON (decl) \n+\t      && ((DECL_INITIAL (decl) == NULL) \n+\t       || (DECL_INITIAL (decl) == error_mark_node) \n+\t       || initializer_zerop (DECL_INITIAL (decl))));\n+\n+  last_assemble_variable_decl = decl;\n+\n+  if (!size || !align) \n+    align = DECL_ALIGN (decl);\n+\n+  l2align = floor_log2 (align / BITS_PER_UNIT);\n+  /* Check we aren't asking for more aligment than the platform allows.  */\n+  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);\n+\n+  if (TREE_PUBLIC (decl) != 0)\n+    darwin_emit_common (fp, name, size, align);\n+  else\n+    darwin_emit_local_bss (fp, decl, name, size, l2align);\t\n+}\n+\n+/* Output a chunk of BSS with alignment specfied.  */\n+void\n+darwin_asm_output_aligned_decl_local (FILE *fp, tree decl, const char *name, \n+\t\t\t\t      unsigned HOST_WIDE_INT size, \n+\t\t\t\t      unsigned int align)\n+{\n+  unsigned long l2align;\n+  bool one, weak;\n+\n+  one = DECL_ONE_ONLY (decl);\n+  weak = (DECL_P (decl)\n+\t  && DECL_WEAK (decl)\n+\t  && !lookup_attribute (\"weak_import\", \n+\t\t\t\t DECL_ATTRIBUTES (decl)));\n+\n+#ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n+fprintf (fp, \"# adloc: %s (%lld,%d) ro %d cst %d stat %d one %d pub %d\"\n+\t     \" weak %d init %lx\\n\",\n+\tname, (long long)size, (int)align, TREE_READONLY (decl), \n+\tTREE_CONSTANT (decl), TREE_STATIC (decl), one, TREE_PUBLIC (decl),\n+\tweak , (unsigned long)DECL_INITIAL (decl)); \n+#endif\n+\n+  /* We shouldn't be messing with this if the decl has a section name.  */\n+  gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n+\n+  /* We would rather not have to check this here - but it seems that we might\n+     be passed a decl that should be in coalesced space.  */\n+  if (one || weak)\n+    {\n+      /* Weak or COMDAT objects are put in mergable sections.  */\n+      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+\t\t\t\t\tDECL_ALIGN (decl));\n+      return;\n+    } \n+\n+  /* .. and it should be suitable for placement in local mem.  */\n+  gcc_assert(!TREE_PUBLIC (decl) && !DECL_COMMON (decl));\n+  /* .. and any initializer must be all-zero.  */\n+  gcc_assert ((DECL_INITIAL (decl) == NULL) \n+\t       || (DECL_INITIAL (decl) == error_mark_node) \n+\t       || initializer_zerop (DECL_INITIAL (decl)));\n+\n+  last_assemble_variable_decl = decl;\n+\n+  if (!size || !align)\n+    align = DECL_ALIGN (decl);\n+\n+  l2align = floor_log2 (align / BITS_PER_UNIT);\n+  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);\n+\n+  darwin_emit_local_bss (fp, decl, name, size, l2align);\n }\n \n /* Emit an assembler directive to set visibility for a symbol.  The\n@@ -1813,6 +2376,7 @@ darwin_asm_output_dwarf_delta (FILE *file, int size,\n     fprintf (file, \"\\t.set L$set$%d,\", darwin_dwarf_label_counter);\n   else\n     fprintf (file, \"\\t%s\\t\", directive);\n+\n   assemble_name_raw (file, lab1);\n   fprintf (file, \"-\");\n   assemble_name_raw (file, lab2);\n@@ -1916,7 +2480,10 @@ darwin_file_end (void)\n     }\n   obstack_free (&lto_section_names_obstack, NULL);\n \n-  fprintf (asm_out_file, \"\\t.subsections_via_symbols\\n\");\n+  /* If we have section anchors, then we must prevent the linker from\n+     re-arranging data.  */\n+  if (!DARWIN_SECTION_ANCHORS || !flag_section_anchors)\n+    fprintf (asm_out_file, \"\\t.subsections_via_symbols\\n\");\n }\n \n /* TODO: Add a language hook for identifying if a decl is a vtable.  */\n@@ -1932,12 +2499,9 @@ darwin_binds_local_p (const_tree decl)\n \t\t\t\t  TARGET_KEXTABI && DARWIN_VTABLE_P (decl));\n }\n \n-#if 0\n-/* See TARGET_ASM_OUTPUT_ANCHOR for why we can't do this yet.  */\n /* The Darwin's implementation of TARGET_ASM_OUTPUT_ANCHOR.  Define the\n    anchor relative to \".\", the current section position.  We cannot use\n    the default one because ASM_OUTPUT_DEF is wrong for Darwin.  */\n-\n void\n darwin_asm_output_anchor (rtx symbol)\n {\n@@ -1946,7 +2510,28 @@ darwin_asm_output_anchor (rtx symbol)\n   fprintf (asm_out_file, \", . + \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t   SYMBOL_REF_BLOCK_OFFSET (symbol));\n }\n-#endif\n+\n+/* Disable section anchoring on any section containing a zero-sized \n+   object.  */\n+bool\n+darwin_use_anchors_for_symbol_p (const_rtx symbol)\n+{\n+  if (DARWIN_SECTION_ANCHORS && flag_section_anchors) \n+    {\n+      section *sect;\n+      /* If the section contains a zero-sized object it's ineligible.  */\n+      sect = SYMBOL_REF_BLOCK (symbol)->sect;\n+      /* This should have the effect of disabling anchors for vars that follow\n+         any zero-sized one, in a given section.  */     \n+      if (sect->common.flags & SECTION_NO_ANCHOR)\n+\treturn false;\n+\n+        /* Also check the normal reasons for suppressing.  */\n+        return default_use_anchors_for_symbol_p (symbol);\n+    }\n+  else\n+    return false;\n+}\n \n /* Set the darwin specific attributes on TYPE.  */\n void\n@@ -1969,9 +2554,12 @@ darwin_kextabi_p (void) {\n void\n darwin_override_options (void)\n {\n+  bool darwin9plus = (darwin_macosx_version_min\n+\t\t      && strverscmp (darwin_macosx_version_min, \"10.5\") >= 0);\n+\n   /* Don't emit DWARF3/4 unless specifically selected.  This is a \n      workaround for tool bugs.  */\n-  if (dwarf_strict < 0) \n+  if (!global_options_set.x_dwarf_strict) \n     dwarf_strict = 1;\n \n   /* Disable -freorder-blocks-and-partition for darwin_emit_unwind_label.  */\n@@ -1997,11 +2585,15 @@ darwin_override_options (void)\n       flag_exceptions = 0;\n       /* No -fnon-call-exceptions data in kexts.  */\n       flag_non_call_exceptions = 0;\n+      /* so no tables either.. */\n+      flag_unwind_tables = 0;\n+      flag_asynchronous_unwind_tables = 0;\n       /* We still need to emit branch islands for kernel context.  */\n       darwin_emit_branch_islands = true;\n     }\n+\n   if (flag_var_tracking\n-      && strverscmp (darwin_macosx_version_min, \"10.5\") >= 0\n+      && darwin9plus\n       && debug_info_level >= DINFO_LEVEL_NORMAL\n       && debug_hooks->var_location != do_nothing_debug_hooks.var_location)\n     flag_var_tracking_uninit = 1;\n@@ -2019,9 +2611,10 @@ darwin_override_options (void)\n     }\n \n   /* It is assumed that branch island stubs are needed for earlier systems.  */\n-  if (darwin_macosx_version_min\n-      && strverscmp (darwin_macosx_version_min, \"10.5\") < 0)\n+  if (!darwin9plus)\n     darwin_emit_branch_islands = true;\n+  else\n+    emit_aligned_common = true; /* Later systems can support aligned common.  */\n \n   /* The c_dialect...() macros are not available to us here.  */\n   darwin_running_cxx = (strstr (lang_hooks.name, \"C++\") != 0);"}, {"sha": "eb1ff8984c15b2b263caecdce9240f0ad8e69f7a", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -529,34 +529,16 @@ extern GTY(()) int darwin_ms_struct;\n \t\t  (CLASS_NAME), (SEL_NAME));\t\t\t\t\\\n      } while (0)\n \n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL) \\\n+\tdarwin_asm_declare_object_name ((FILE), (NAME), (DECL))\n+\n /* The RTTI data (e.g., __ti4name) is common and public (and static),\n    but it does need to be referenced via indirect PIC data pointers.\n    The machopic_define_symbol calls are telling the machopic subsystem\n    that the name *is* defined in this module, so it doesn't need to\n    make them indirect.  */\n \n-#undef ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    const char *xname = NAME;\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)\t\t\\\n-      xname = IDENTIFIER_POINTER (DECL_NAME (DECL));\t\t\t\\\n-    if (! DECL_WEAK (DECL)\t\t\t\t\t\t\\\n-        && ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n-\t     && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n-            || DECL_INITIAL (DECL)))\t\t\t\t\t\\\n-        machopic_define_symbol (DECL_RTL (DECL));\t\t\t\\\n-    if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n-        || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n-      (* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n-    ASM_OUTPUT_LABEL (FILE, xname);\t\t\t\t\t\\\n-    /* Darwin doesn't support zero-size objects, so give them a\t\t\\\n-       byte.  */\t\t\t\t\t\t\t\\\n-    if (tree_low_cst (DECL_SIZE_UNIT (DECL), 1) == 0)\t\t\t\\\n-      assemble_zeros (1);\t\t\t\t\t\t\\\n-  } while (0)\n-\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     const char *xname = NAME;\t\t\t\t\t\t\\\n@@ -581,7 +563,6 @@ extern GTY(()) int darwin_ms_struct;\n    Make Objective-C internal symbols local and in doing this, we need \n    to accommodate the name mangling done by c++ on file scope locals.  */\n \n-\n int darwin_label_is_anonymous_local_objc_name (const char *name);\n \n #undef\tASM_OUTPUT_LABELREF\n@@ -633,37 +614,38 @@ int darwin_label_is_anonymous_local_objc_name (const char *name);\n #undef\tASM_OUTPUT_ALIGN\n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n   if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t%s %d\\n\", ALIGN_ASM_OP, (LOG))\n-\n-/* Ensure correct alignment of bss data.  */\n-\n-#undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\n-#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned HOST_WIDE_INT _new_size = SIZE;\t\t\t\t\\\n-    fputs (\"\\t.lcomm \", (FILE));\t\t\t\t\t\t\\\n-    assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-    if (_new_size == 0) _new_size = 1;\t\t\t\t\t\\\n-    fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\", _new_size,\t\\\n-\t     floor_log2 ((ALIGN) / BITS_PER_UNIT));\t\t\t\\\n-    if ((DECL) && ((TREE_STATIC (DECL)\t\t\t\t\t\\\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n-        || DECL_INITIAL (DECL)))\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n-\tmachopic_define_symbol (DECL_RTL (DECL));\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+    fprintf (FILE, \"\\t%s\\t%d\\n\", ALIGN_ASM_OP, (LOG))\n \n /* The maximum alignment which the object file format can support in\n    bits.  For Mach-O, this is 2^15 bytes.  */\n \n #undef\tMAX_OFILE_ALIGNMENT\n #define MAX_OFILE_ALIGNMENT (0x8000 * 8)\n \n+#define L2_MAX_OFILE_ALIGNMENT 15\n+\n+/*  These are the three variants that emit referenced blank space.  */\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n+\tdarwin_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n+\n+#undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+\tdarwin_asm_output_aligned_decl_local\t\t\t\t\\\n+\t\t\t\t  ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n+\n+#undef  ASM_OUTPUT_ALIGNED_DECL_COMMON\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+\tdarwin_asm_output_aligned_decl_common\t\t\t\t\\\n+\t\t\t\t   ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n+\n /* The generic version, archs should over-ride where required.  */\n #define MACHOPIC_NL_SYMBOL_PTR_SECTION \".non_lazy_symbol_pointer\"\n \n+/* Private flag applied to disable section-anchors in a particular section.\n+   This needs to be kept in sync with the flags used by varasm.c (defined in\n+   output.h).  */\n+#define SECTION_NO_ANCHOR 0x2000000\n+\n /* Declare the section variables.  */\n #ifndef USED_FOR_TARGET\n enum darwin_section_enum {\n@@ -911,17 +893,10 @@ void add_framework_path (char *);\n #undef GOMP_SELF_SPECS\n #define GOMP_SELF_SPECS \"\"\n \n-/* Darwin can't support anchors until we can cope with the adjustments\n-   to size that ASM_DECLARE_OBJECT_NAME and ASM_DECLARE_CONSTANT_NAME\n-   when outputting members of an anchor block and the linker can be\n-   taught to keep them together or we find some other suitable\n-   code-gen technique.  */\n-\n-#if 0\n-#define TARGET_ASM_OUTPUT_ANCHOR darwin_asm_output_anchor\n-#else\n+/* Darwin disables section anchors by default.  \n+   They should be enabled per arch where support exists in that arch.  */\n #define TARGET_ASM_OUTPUT_ANCHOR NULL\n-#endif\n+#define DARWIN_SECTION_ANCHORS 0\n \n /* Attempt to turn on execute permission for the stack.  This may be\n     used by TARGET_TRAMPOLINE_INIT if the target needs it (that is,"}, {"sha": "a9a2da4040e6688fb6d2470a528a3de864eab4e3", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -213,22 +213,6 @@ extern int darwin_emit_branch_islands;\n         }\t\t\t\t\\\n     } while (0)\n \n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n /* Darwin profiling -- call mcount.  */\n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\"}, {"sha": "bd4b19581313c906e6ddeea3251b08bc92d75e20", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -232,17 +232,6 @@ extern int darwin_emit_branch_islands;\n #define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)\t\\\n   fprintf (FILE, \"%s\", PREFIX)\n \n-/* This says how to output an assembler line to define a global common\n-   symbol.  */\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    unsigned HOST_WIDE_INT _new_size = SIZE;\t\t\t\t\\\n-    fputs (\"\\t.comm \", (FILE));\t\t\t\t\t\t\\\n-    RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\t\t\\\n-    if (_new_size == 0) _new_size = 1;\t\t\t\t\t\\\n-    fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", _new_size);\t\\\n-  } while (0)\n-\n /* Override the standard rs6000 definition.  */\n \n #undef ASM_COMMENT_START\n@@ -423,6 +412,22 @@ extern int darwin_emit_branch_islands;\n    default, as kernel code doesn't save/restore those registers.  */\n #define OS_MISSING_ALTIVEC (flag_mkernel || flag_apple_kext)\n \n+/* Darwin has support for section anchors on powerpc*.  \n+   It is disabled for any section containing a \"zero-sized item\" (because these\n+   are re-written as size=1 to be compatible with the OSX ld64).\n+   The re-writing would interfere with the computation of anchor offsets.\n+   Therefore, we place zero-sized items in their own sections and make such\n+   sections unavailable to section anchoring.  */\n+\n+#undef TARGET_ASM_OUTPUT_ANCHOR \n+#define TARGET_ASM_OUTPUT_ANCHOR darwin_asm_output_anchor\n+\n+#undef TARGET_USE_ANCHORS_FOR_SYMBOL_P\n+#define TARGET_USE_ANCHORS_FOR_SYMBOL_P darwin_use_anchors_for_symbol_p\n+\n+#undef DARWIN_SECTION_ANCHORS\n+#define DARWIN_SECTION_ANCHORS 1\n+\n /* PPC Darwin has to rename some of the long double builtins.  */\n #undef  SUBTARGET_INIT_BUILTINS\n #define SUBTARGET_INIT_BUILTINS\t\t\t\t\t\t\\"}, {"sha": "7e7ef57da946e48a76c52bd7eb5fb7c0430ab3da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,3 +1,15 @@\n+2010-11-29  Iain Sandoe  <iains@gcc.gnu.org>\n+\t    Mike Stump  <mrs@gcc.gnu.org>\n+\n+\tPR target/26427\n+\tPR target/33120\n+\tPR testsuite/35710\n+\t* gcc.target/powerpc/darwin-abi-12.c: Adjust for new allocators.\n+\t* gcc.dg/pr26427.c: Remove redundant warning for powerpc.\n+\t* gcc.dg/darwin-comm.c: Adjust for new allocators.\n+\t* gcc.dg/darwin-sections.c: New test.\n+\t* g++.dg/ext/instantiate2.C: Adjust for new allocators.\n+\n 2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/exceptions-1.m: New."}, {"sha": "a6292892b38309bd3d295cf0977bc74ce8989ff7", "filename": "gcc/testsuite/g++.dg/ext/instantiate2.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finstantiate2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finstantiate2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finstantiate2.C?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -8,7 +8,8 @@ template <class T> struct A {\n template <class T> T A<T>::t = 0;\n static template struct A<int>;\n \n-// { dg-final { scan-assembler \"\\n_?_ZN1AIiE1tE(:|\\n|\\t)\" } }\n+// { dg-final { scan-assembler \"\\n_?_ZN1AIiE1tE(:|\\n|\\t)\" { target { ! *-*-darwin* } } } }\n+// { dg-final { scan-assembler \".zerofill __DATA,__pu_bss2,__ZN1AIiE1tE\" { target *-*-darwin* } } } \n void test_int() { A<int>::t = 42; }\n \n // { dg-final { scan-assembler-not \"\\n_?_ZN1AIcE1tE(:|\\n|\\t)\" } }"}, {"sha": "a743fc6d4edb8f242b820e814368d0767d645ffd", "filename": "gcc/testsuite/gcc.dg/darwin-comm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-comm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-comm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-comm.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do compile { target *-*-darwin[912]* } } */\n-/* { dg-final { scan-assembler \".comm _foo,1,15\" } } */\n+/* { dg-final { scan-assembler \".comm\\[ \\t\\]_foo,1,15\" } } */\n \n char foo __attribute__ ((aligned(32768)));"}, {"sha": "79d48bd7da26c865603059ad2273b9bff42ea92a", "filename": "gcc/testsuite/gcc.dg/darwin-sections.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdarwin-sections.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile {target *-*-darwin* } } */\n+/* { dg-options \"-std=c99 -w\" } */\n+\n+/* This has been designed to give the same section usage for\n+   -m32 and -m64 - so don't put any ints or longs in it ... */\n+\n+/* A zero-sized object.  */\n+typedef struct _empty {} e_s;\n+\n+/* These should go in .comm */\n+char ub;\n+e_s ea;\n+/* { dg-final { scan-assembler \".comm\\[\\t \\]_ub,1\" } } */\n+/* { dg-final { scan-assembler \".comm\\[\\t \\]_ea,1\" } } */\n+\n+/* These should go into .data */\n+char a = 0;\n+short b = 0;\n+/* { dg-final { scan-assembler \".globl _a.*.data.*.space\\[\\t \\]1\" } } */\n+/* { dg-final { scan-assembler \".globl _b.*.data.*.space\\[\\t \\]2\" } } */\n+\n+/* These should go into __pu_bssN */\n+long long d = 0;\n+float e = 0;\n+double f = 0;\n+long double g = 0.L;\n+long long al_256 __attribute__((aligned (256))) = 0;\n+/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss3,_d,8,3\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss2,_e,4,2\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss3,_f,8,3\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss4,_g,16,4\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__pu_bss8,_al_256,8,8\" } } */\n+\n+/* This should go into __zo_bss0 */\n+static e_s sea;\n+/* { dg-final { scan-assembler \".zerofill __DATA,__zo_bss0,_sea,1\" } } */\n+\n+/* These should go into .static_data */\n+static char sa ;\n+static short sb ;\n+/* { dg-final { scan-assembler \".static_data.*_sa:.*.space\\[\\t \\]1\" } } */\n+/* { dg-final { scan-assembler \".static_data.*_sb:.*.space\\[\\t \\]2\" } } */\n+\n+/* These should go into _bssN */\n+static long long sd;\n+static float se ;\n+static double sf ;\n+static long double sg;\n+static long long sal_256 __attribute__((aligned (2048)));\n+/* { dg-final { scan-assembler \".zerofill __DATA,__bss3,_sd,8,3\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__bss2,_se,4,2\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__bss3,_sf,8,3\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__bss4,_sg,16,4\" } } */\n+/* { dg-final { scan-assembler \".zerofill __DATA,__bss11,_sal_256,8,11\" } } */\n+\n+long long foo (int x)\n+{\n+  e_s *s;\n+  a += x + sa;\n+  b += a + sb;\n+  d += b + sd;\n+  e += d + se;\n+  f += e + sf;\n+  g += f + sg;\n+ \n+  s = &ea;\n+  s = &sea;\n+  \n+  b += al_256;\n+  b += sal_256;\n+\n+  return (long long) sd + b;\n+}"}, {"sha": "add13ca209e74bfd71deab0555f579ce4acd2955", "filename": "gcc/testsuite/gcc.dg/pr26427.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26427.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26427.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26427.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-warning \"this target does not support\" } */\n+/* { dg-warning \"this target does not support\" \"\" {target *86*-*-darwin* } 0 } */\n /* { dg-do run { target { *-*-darwin* } } } */\n /* { dg-options { -fsection-anchors -O } } */\n /* PR target/26427 */"}, {"sha": "5f5764368c1ebe4ef5966e0a8d2b7ddd9b9c5b4e", "filename": "gcc/testsuite/gcc.target/powerpc/darwin-abi-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdarwin-abi-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a99b06bc86c936f35db7613817be1062e28c30/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdarwin-abi-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdarwin-abi-12.c?ref=46a99b06bc86c936f35db7613817be1062e28c30", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile { target powerpc*-*-darwin* } } */\n-/* { dg-final { scan-assembler \".comm _x,12,2\" } } */\n+/* { dg-final { scan-assembler \".comm\\[\\t \\]_x,12,2\" } } */\n /* { dg-final { scan-assembler-not \".space 7\" } } */\n /* PR 23071 */\n "}]}