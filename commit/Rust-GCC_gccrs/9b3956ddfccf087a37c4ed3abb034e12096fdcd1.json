{"sha": "9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIzOTU2ZGRmY2NmMDg3YTM3YzRlZDNhYmIwMzRlMTIwOTZmZGNkMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-05T15:36:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T15:36:47Z"}, "message": "a-cbmutr.adb: Minor reformatting\n\n2011-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cbmutr.adb: Minor reformatting\n\t(Allocate_Node): refactor node allocation algorithm\n\n2011-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.ads, opt.adb (Debug_Pragmas_Disabled): New switch.\n\t* sem_prag.adb (Analyze_Pragma, case Debug_Policy): Implement Disable\n\tmode.\n\t(Analyze_Pragma, case Check_Policy): Ditto.\n\t* sem_prag.ads (Check_Disabled): New function\n\t* snames.ads-tmpl: Add Name_Disable.\n\n2011-08-05  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document implementation-defined policy DISABLE for\n\tpragmas Assertion_Policy, Check_Policy, Debug_Policy.\n\nFrom-SVN: r177459", "tree": {"sha": "e0c8b07c07d3e9ee843137e6e4f27761d35a1df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0c8b07c07d3e9ee843137e6e4f27761d35a1df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/comments", "author": null, "committer": null, "parents": [{"sha": "79e705d601f94d3a4fd62a91bedc2d30c973c9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e705d601f94d3a4fd62a91bedc2d30c973c9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e705d601f94d3a4fd62a91bedc2d30c973c9a6"}], "stats": {"total": 345, "additions": 249, "deletions": 96}, "files": [{"sha": "68f44141ba2979aadc6d66516aa86fe8fb03f67e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -1,3 +1,22 @@\n+2011-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cbmutr.adb: Minor reformatting\n+\t(Allocate_Node): refactor node allocation algorithm\n+\n+2011-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.ads, opt.adb (Debug_Pragmas_Disabled): New switch.\n+\t* sem_prag.adb (Analyze_Pragma, case Debug_Policy): Implement Disable\n+\tmode.\n+\t(Analyze_Pragma, case Check_Policy): Ditto.\n+\t* sem_prag.ads (Check_Disabled): New function\n+\t* snames.ads-tmpl: Add Name_Disable.\n+\n+2011-08-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document implementation-defined policy DISABLE for\n+\tpragmas Assertion_Policy, Check_Policy, Debug_Policy.\n+\n 2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma, case Inline): reject an Inline pragma"}, {"sha": "b365d47479c8c521c767c0b474e5bdf5c674faaf", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 72, "deletions": 74, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    procedure Initialize_Node (Container : in out Tree; Index : Count_Type);\n    procedure Initialize_Root (Container : in out Tree);\n \n+   procedure Allocate_Node\n+     (Container          : in out Tree;\n+      Initialize_Element : not null access procedure (Index : Count_Type);\n+      New_Node           : out Count_Type);\n+\n    procedure Allocate_Node\n      (Container : in out Tree;\n       New_Item  : Element_Type;\n@@ -194,18 +199,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    -------------------\n \n    procedure Allocate_Node\n-     (Container : in out Tree;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type)\n+     (Container          : in out Tree;\n+      Initialize_Element : not null access procedure (Index : Count_Type);\n+      New_Node           : out Count_Type)\n    is\n    begin\n       if Container.Free >= 0 then\n          New_Node := Container.Free;\n+         pragma Assert (New_Node in Container.Elements'Range);\n \n          --  We always perform the assignment first, before we change container\n          --  state, in order to defend against exceptions duration assignment.\n \n-         Container.Elements (New_Node) := New_Item;\n+         Initialize_Element (New_Node);\n+\n          Container.Free := Container.Nodes (New_Node).Next;\n \n       else\n@@ -216,72 +223,62 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          --  the end of the array (Nodes'Last).\n \n          New_Node := abs Container.Free;\n+         pragma Assert (New_Node in Container.Elements'Range);\n \n          --  As above, we perform this assignment first, before modifying any\n          --  container state.\n \n-         Container.Elements (New_Node) := New_Item;\n+         Initialize_Element (New_Node);\n+\n          Container.Free := Container.Free - 1;\n+\n+         if abs Container.Free > Container.Capacity then\n+            Container.Free := 0;\n+         end if;\n       end if;\n \n       Initialize_Node (Container, New_Node);\n    end Allocate_Node;\n \n    procedure Allocate_Node\n      (Container : in out Tree;\n-      Stream    : not null access Root_Stream_Type'Class;\n+      New_Item  : Element_Type;\n       New_Node  : out Count_Type)\n    is\n-   begin\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-\n-         --  We always perform the assignment first, before we change container\n-         --  state, in order to defend against exceptions duration assignment.\n+      procedure Initialize_Element (Index : Count_Type);\n \n-         Element_Type'Read (Stream, Container.Elements (New_Node));\n-         Container.Free := Container.Nodes (New_Node).Next;\n-\n-      else\n-         --  A negative free store value means that the links of the nodes in\n-         --  the free store have not been initialized. In this case, the nodes\n-         --  are physically contiguous in the array, starting at the index that\n-         --  is the absolute value of the Container.Free, and continuing until\n-         --  the end of the array (Nodes'Last).\n+      procedure Initialize_Element (Index : Count_Type) is\n+      begin\n+         Container.Elements (Index) := New_Item;\n+      end Initialize_Element;\n \n-         New_Node := abs Container.Free;\n+   begin\n+      Allocate_Node (Container, Initialize_Element'Access, New_Node);\n+   end Allocate_Node;\n \n-         --  As above, we perform this assignment first, before modifying any\n-         --  container state.\n+   procedure Allocate_Node\n+     (Container : in out Tree;\n+      Stream    : not null access Root_Stream_Type'Class;\n+      New_Node  : out Count_Type)\n+   is\n+      procedure Initialize_Element (Index : Count_Type);\n \n-         Element_Type'Read (Stream, Container.Elements (New_Node));\n-         Container.Free := Container.Free - 1;\n-      end if;\n+      procedure Initialize_Element (Index : Count_Type) is\n+      begin\n+         Element_Type'Read (Stream, Container.Elements (Index));\n+      end Initialize_Element;\n \n-      Initialize_Node (Container, New_Node);\n+   begin\n+      Allocate_Node (Container, Initialize_Element'Access, New_Node);\n    end Allocate_Node;\n \n    procedure Allocate_Node\n      (Container : in out Tree;\n       New_Node  : out Count_Type)\n    is\n+      procedure Initialize_Element (Index : Count_Type) is null;\n    begin\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         Container.Free := Container.Nodes (New_Node).Next;\n-\n-      else\n-         --  A negative free store value means that the links of the nodes in\n-         --  the free store have not been initialized. In this case, the nodes\n-         --  are physically contiguous in the array, starting at the index that\n-         --  is the absolute value of the Container.Free, and continuing until\n-         --  the end of the array (Nodes'Last).\n-\n-         New_Node := abs Container.Free;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-\n-      Initialize_Node (Container, New_Node);\n+      Allocate_Node (Container, Initialize_Element'Access, New_Node);\n    end Allocate_Node;\n \n    -------------------\n@@ -405,7 +402,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            with \"Target capacity is less than Source count\";\n       end if;\n \n-      Target.Clear;  -- checks busy bit\n+      Target.Clear;  -- Checks busy bit\n \n       if Source.Count = 0 then\n          return;\n@@ -647,7 +644,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       if Parent.Container.Count = 0 then\n          pragma Assert (Is_Root (Parent));\n          pragma Assert (Child = Parent);\n-\n          return 0;\n       end if;\n \n@@ -823,8 +819,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  the \"normal\" way: Container.Free points to the head of the list of\n       --  free (inactive) nodes, and the value 0 means the free list is\n       --  empty. Each node on the free list has been initialized to point to\n-      --  the next free node (via its Next component), and the value -1 means\n-      --  that this is the last free node.\n+      --  the next free node (via its Next component), and the value 0 means\n+      --  that this is the last node of the free list.\n       --\n       --  If Container.Free is negative, then the links on the free store have\n       --  not been initialized. In this case the link values are implied: the\n@@ -833,11 +829,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  the array (Nodes'Last).\n       --\n       --  We prefer to lazy-init the free store (in fact, we would prefer to\n-      --  not initialize it at all). The time when we need to actually\n-      --  initialize the nodes in the free store is if the node that becomes\n-      --  inactive is not at the end of the active list. The free store would\n-      --  then be discontigous and so its nodes would need to be linked in the\n-      --  traditional way.\n+      --  not initialize it at all, because such initialization is an O(n)\n+      --  operation). The time when we need to actually initialize the nodes in\n+      --  the free store is when the node that becomes inactive is not at the\n+      --  end of the active list. The free store would then be discontigous and\n+      --  so its nodes would need to be linked in the traditional way.\n       --\n       --  It might be possible to perform an optimization here. Suppose that\n       --  the free store can be represented as having two parts: one comprising\n@@ -848,16 +844,17 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  nodes become inactive. ???\n \n       --  When an element is deleted from the list container, its node becomes\n-      --  inactive, and so we set its Prev component to a negative value, to\n-      --  indicate that it is now inactive. This provides a useful way to\n-      --  detect a dangling cursor reference.\n+      --  inactive, and so we set its Parent and Prev components to an\n+      --  impossible value (the index of the node itself), to indicate that it\n+      --  is now inactive. This provides a useful way to detect a dangling\n+      --  cursor reference.\n \n       N.Parent := X;  -- Node is deallocated (not on active list)\n       N.Prev := X;\n \n       if Container.Free >= 0 then\n-         --  The free store has previously been initialized. All we need to\n-         --  do here is link the newly-free'd node onto the free list.\n+         --  The free store has previously been initialized. All we need to do\n+         --  here is link the newly-free'd node onto the free list.\n \n          N.Next := Container.Free;\n          Container.Free := X;\n@@ -867,7 +864,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          --  inactive immediately precedes the start of the free store. All\n          --  we need to do is move the start of the free store back by one.\n \n-         N.Next := -1;  -- Not strictly necessary, but marginally safer\n+         N.Next := X;  -- Not strictly necessary, but marginally safer\n          Container.Free := Container.Free + 1;\n \n       else\n@@ -880,8 +877,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          --  See the comments above for an optimization opportunity. If the\n          --  next link for a node on the free store is negative, then this\n          --  means the remaining nodes on the free store are physically\n-         --  contiguous, starting as the absolute value of that index\n-         --  value. ???\n+         --  contiguous, starting at the absolute value of that index value.\n+         --  ???\n \n          Container.Free := abs Container.Free;\n \n@@ -893,7 +890,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n                NN (J).Next := J + 1;\n             end loop;\n \n-            NN (Container.Capacity).Next := -1;\n+            NN (Container.Capacity).Next := 0;\n          end if;\n \n          NN (X).Next := Container.Free;\n@@ -1558,8 +1555,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    begin\n       --  This is a simple utility operation to insert a list of nodes\n       --  (First..Last) as children of Parent. The Before node specifies where\n-      --  the new children should be inserted relative to the existing\n-      --  children.\n+      --  the new children should be inserted relative to existing children.\n \n       if First <= 0 then\n          pragma Assert (Last <= 0);\n@@ -2233,8 +2229,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       CC : Children_Type renames NN (N.Parent).Children;\n \n    begin\n-      --  This is a utility operation to remove a subtree\n-      --  node from its parent's list of children.\n+      --  This is a utility operation to remove a subtree node from its\n+      --  parent's list of children.\n \n       if CC.First = Subtree then\n          pragma Assert (N.Prev <= 0);\n@@ -2356,11 +2352,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    ---------------------\n \n    procedure Splice_Children\n-     (Target          : in out Tree;\n-      Target_Parent   : Cursor;\n-      Before          : Cursor;\n-      Source          : in out Tree;\n-      Source_Parent   : Cursor)\n+     (Target        : in out Tree;\n+      Target_Parent : Cursor;\n+      Before        : Cursor;\n+      Source        : in out Tree;\n+      Source_Parent : Cursor)\n    is\n    begin\n       if Target_Parent = No_Element then\n@@ -2567,14 +2563,14 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  Before we attempt the insertion, we must count the sources nodes in\n       --  order to determine whether the target have enough storage\n       --  available. Note that calculating this value is an O(n) operation.\n-      --\n+\n       --  Here is an optimization opportunity: iterate of each children the\n       --  source explicitly, and keep a running count of the total number of\n       --  nodes. Compare the running total to the capacity of the target each\n       --  pass through the loop. This is more efficient than summing the counts\n       --  of child subtree (which is what Subtree_Node_Count does) and then\n       --  comparing that total sum to the target's capacity.  ???\n-      --\n+\n       --  Here is another possibility. We currently treat the splice as an\n       --  all-or-nothing proposition: either we can insert all of children of\n       --  the source, or we raise exception with modifying the target. The\n@@ -2767,7 +2763,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       end if;\n \n       if Is_Root (Position) then\n+\n          --  Should this be PE instead?  Need ARG confirmation.  ???\n+\n          raise Constraint_Error with \"Position cursor designates root\";\n       end if;\n "}, {"sha": "a7f13a14122dd7e57ea9affd993acc67914fd795", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -104,6 +104,7 @@ Implementation Defined Pragmas\n * Pragma Ada_2012::\n * Pragma Annotate::\n * Pragma Assert::\n+* Pragma Assertion_Policy::\n * Pragma Assume_No_Invalid_Values::\n * Pragma Ast_Entry::\n * Pragma C_Pass_By_Copy::\n@@ -737,6 +738,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Ada_2012::\n * Pragma Annotate::\n * Pragma Assert::\n+* Pragma Assertion_Policy::\n * Pragma Assume_No_Invalid_Values::\n * Pragma Ast_Entry::\n * Pragma C_Pass_By_Copy::\n@@ -1075,6 +1077,43 @@ effect on the program.  However, the expressions are analyzed for\n semantic correctness whether or not assertions are enabled, so turning\n assertions on and off cannot affect the legality of a program.\n \n+Note that the implementation defined policy @code{DISABLE}, given in a\n+pragma Assertion_Policy, can be used to suppress this semantic analysis.\n+\n+Note: this is a standard language-defined pragma in versions\n+of Ada from 2005 on. In GNAT, it is implemented in all versions\n+of Ada, and the DISABLE policy is an implementation-defined\n+addition.\n+\n+\n+@node Pragma Assertion_Policy\n+@unnumberedsec Pragma Assertion_Policy\n+@findex Debug_Policy\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Assertion_Policy (CHECK | DISABLE | IGNORE);\n+@end smallexample\n+\n+@noindent\n+If the argument is @code{CHECK}, then pragma @code{Assert} is enabled.\n+If the argument is @code{IGNORE}, then pragma @code{Assert} is ignored.\n+This pragma overrides the effect of the @option{-gnata} switch on the\n+command line.\n+\n+The implementation defined policy @code{DISABLE} is like\n+@code{IGNORE} except that it completely disables semantic\n+checking of the argument to @code{pragma Assert}. This may\n+be useful when the pragma argument references subprograms\n+in a with'ed package which is replaced by a dummy package\n+for the final build.\n+\n+Note: this is a standard language-defined pragma in versions\n+of Ada from 2005 on. In GNAT, it is implemented in all versions\n+of Ada, and the DISABLE policy is an implementation-defined\n+addition.\n+\n @node Pragma Assume_No_Invalid_Values\n @unnumberedsec Pragma Assume_No_Invalid_Values\n @findex Assume_No_Invalid_Values\n@@ -1258,7 +1297,7 @@ pragma Check_Policy\n  ([Name   =>] Identifier,\n   [Policy =>] POLICY_IDENTIFIER);\n \n-POLICY_IDENTIFIER ::= On | Off | Check | Ignore\n+POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE\n @end smallexample\n \n @noindent\n@@ -1273,7 +1312,7 @@ The identifier given as the first argument corresponds to a name used in\n associated @code{Check} pragmas. For example, if the pragma:\n \n @smallexample @c ada\n-pragma Check_Policy (Critical_Error, Off);\n+pragma Check_Policy (Critical_Error, OFF);\n @end smallexample\n \n @noindent\n@@ -1291,15 +1330,22 @@ that @code{Precondition} checks are @code{Off} or @code{Ignored}. Similarly use\n of the name @code{Postcondition} controls whether @code{Postcondition} pragmas\n are recognized.\n \n-The check policy is @code{Off} to turn off corresponding checks, and @code{On}\n+The check policy is @code{OFF} to turn off corresponding checks, and @code{ON}\n to turn on corresponding checks. The default for a set of checks for which no\n-@code{Check_Policy} is given is @code{Off} unless the compiler switch\n+@code{Check_Policy} is given is @code{OFF} unless the compiler switch\n @option{-gnata} is given, which turns on all checks by default.\n \n-The check policy settings @code{Check} and @code{Ignore} are also recognized\n-as synonyms for @code{On} and @code{Off}. These synonyms are provided for\n+The check policy settings @code{CHECK} and @code{IGNORE} are also recognized\n+as synonyms for @code{ON} and @code{OFF}. These synonyms are provided for\n compatibility with the standard @code{Assertion_Policy} pragma.\n \n+The implementation defined policy @code{DISABLE} is like\n+@code{OFF} except that it completely disables semantic\n+checking of the argument to the corresponding class of\n+pragmas. This may be useful when the pragma arguments reference\n+subprograms in a with'ed package which is replaced by a dummy package\n+for the final build.\n+\n @node Pragma Comment\n @unnumberedsec Pragma Comment\n @findex Comment\n@@ -1719,7 +1765,7 @@ or by use of the configuration pragma @code{Debug_Policy}.\n Syntax:\n \n @smallexample @c ada\n-pragma Debug_Policy (CHECK | IGNORE);\n+pragma Debug_Policy (CHECK | DISABLE | IGNORE);\n @end smallexample\n \n @noindent\n@@ -1728,6 +1774,13 @@ If the argument is @code{IGNORE}, then pragma @code{DEBUG} is ignored.\n This pragma overrides the effect of the @option{-gnata} switch on the\n command line.\n \n+The implementation defined policy @code{DISABLE} is like\n+@code{IGNORE} except that it completely disables semantic\n+checking of the argument to @code{pragma Debug}. This may\n+be useful when the pragma argument references subprograms\n+in a with'ed package which is replaced by a dummy package\n+for the final build.\n+\n @node Pragma Detect_Blocking\n @unnumberedsec Pragma Detect_Blocking\n @findex Detect_Blocking"}, {"sha": "ed76923d5f04c68f3d93756d6499ff1bedbd53d8", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -49,6 +49,7 @@ package body Opt is\n       Assertions_Enabled_Config             := Assertions_Enabled;\n       Assume_No_Invalid_Values_Config       := Assume_No_Invalid_Values;\n       Check_Policy_List_Config              := Check_Policy_List;\n+      Debug_Pragmas_Disabled_Config         := Debug_Pragmas_Disabled;\n       Debug_Pragmas_Enabled_Config          := Debug_Pragmas_Enabled;\n       Default_Pool_Config                   := Default_Pool;\n       Dynamic_Elaboration_Checks_Config     := Dynamic_Elaboration_Checks;\n@@ -82,6 +83,7 @@ package body Opt is\n       Assertions_Enabled             := Save.Assertions_Enabled;\n       Assume_No_Invalid_Values       := Save.Assume_No_Invalid_Values;\n       Check_Policy_List              := Save.Check_Policy_List;\n+      Debug_Pragmas_Disabled         := Save.Debug_Pragmas_Disabled;\n       Debug_Pragmas_Enabled          := Save.Debug_Pragmas_Enabled;\n       Default_Pool                   := Save.Default_Pool;\n       Dynamic_Elaboration_Checks     := Save.Dynamic_Elaboration_Checks;\n@@ -117,6 +119,7 @@ package body Opt is\n       Save.Assertions_Enabled             := Assertions_Enabled;\n       Save.Assume_No_Invalid_Values       := Assume_No_Invalid_Values;\n       Save.Check_Policy_List              := Check_Policy_List;\n+      Save.Debug_Pragmas_Disabled         := Debug_Pragmas_Disabled;\n       Save.Debug_Pragmas_Enabled          := Debug_Pragmas_Enabled;\n       Save.Default_Pool                   := Default_Pool;\n       Save.Dynamic_Elaboration_Checks     := Dynamic_Elaboration_Checks;\n@@ -168,11 +171,13 @@ package body Opt is\n          if Main_Unit then\n             Assertions_Enabled       := Assertions_Enabled_Config;\n             Assume_No_Invalid_Values := Assume_No_Invalid_Values_Config;\n+            Debug_Pragmas_Disabled   := Debug_Pragmas_Disabled_Config;\n             Debug_Pragmas_Enabled    := Debug_Pragmas_Enabled_Config;\n             Check_Policy_List        := Check_Policy_List_Config;\n          else\n             Assertions_Enabled       := False;\n             Assume_No_Invalid_Values := False;\n+            Debug_Pragmas_Disabled   := False;\n             Debug_Pragmas_Enabled    := False;\n             Check_Policy_List        := Empty;\n          end if;\n@@ -185,6 +190,7 @@ package body Opt is\n          Assertions_Enabled          := Assertions_Enabled_Config;\n          Assume_No_Invalid_Values    := Assume_No_Invalid_Values_Config;\n          Check_Policy_List           := Check_Policy_List_Config;\n+         Debug_Pragmas_Disabled      := Debug_Pragmas_Disabled_Config;\n          Debug_Pragmas_Enabled       := Debug_Pragmas_Enabled_Config;\n          Dynamic_Elaboration_Checks  := Dynamic_Elaboration_Checks_Config;\n          Extensions_Allowed          := Extensions_Allowed_Config;\n@@ -241,6 +247,7 @@ package body Opt is\n       Tree_Read_Bool (All_Errors_Mode);\n       Tree_Read_Bool (Assertions_Enabled);\n       Tree_Read_Int  (Int (Check_Policy_List));\n+      Tree_Read_Bool (Debug_Pragmas_Disabled);\n       Tree_Read_Bool (Debug_Pragmas_Enabled);\n       Tree_Read_Int  (Int (Default_Pool));\n       Tree_Read_Bool (Enable_Overflow_Checks);\n@@ -307,6 +314,7 @@ package body Opt is\n       Tree_Write_Bool (All_Errors_Mode);\n       Tree_Write_Bool (Assertions_Enabled);\n       Tree_Write_Int  (Int (Check_Policy_List));\n+      Tree_Write_Bool (Debug_Pragmas_Disabled);\n       Tree_Write_Bool (Debug_Pragmas_Enabled);\n       Tree_Write_Int  (Int (Default_Pool));\n       Tree_Write_Bool (Enable_Overflow_Checks);"}, {"sha": "a9c2d9f75706620b46f0742229109d5c2fada13c", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -374,6 +374,10 @@ package Opt is\n    --  GNAT\n    --  Enable debug statements from pragma Debug\n \n+   Debug_Pragmas_Disabled : Boolean := False;\n+   --  GNAT\n+   --  Debug pragmas completely disabled (no semantic checking)\n+\n    subtype Debug_Level_Value is Nat range 0 .. 3;\n    Debugger_Level : Debug_Level_Value := 0;\n    --  GNATBIND\n@@ -1661,6 +1665,11 @@ package Opt is\n    --  terminated by Empty. The order is most recently processed first. This\n    --  list includes only those pragmas in configuration pragma files.\n \n+   Debug_Pragmas_Disabled_Config : Boolean;\n+   --  GNAT\n+   --  This is the value of the configuration switch for debug pragmas disabled\n+   --  mode, as possibly set by use of the configuration pragma Debug_Policy.\n+\n    Debug_Pragmas_Enabled_Config : Boolean;\n    --  GNAT\n    --  This is the value of the configuration switch for debug pragmas enabled\n@@ -1885,6 +1894,7 @@ private\n       Assertions_Enabled             : Boolean;\n       Assume_No_Invalid_Values       : Boolean;\n       Check_Policy_List              : Node_Id;\n+      Debug_Pragmas_Disabled         : Boolean;\n       Debug_Pragmas_Enabled          : Boolean;\n       Default_Pool                   : Node_Id;\n       Dynamic_Elaboration_Checks     : Boolean;"}, {"sha": "419f6cf962e184ecd13d768682f2062926ef0981", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 72, "deletions": 14, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -352,12 +352,18 @@ package body Sem_Prag is\n       --  Check the specified argument Arg to make sure that it is a valid\n       --  locking policy name. If not give error and raise Pragma_Exit.\n \n-      procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2 : Name_Id);\n-      procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2, N3 : Name_Id);\n-      procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2, N3, N4 : Name_Id);\n+      procedure Check_Arg_Is_One_Of\n+        (Arg                : Node_Id;\n+         N1, N2             : Name_Id);\n+      procedure Check_Arg_Is_One_Of\n+        (Arg                : Node_Id;\n+         N1, N2, N3         : Name_Id);\n+      procedure Check_Arg_Is_One_Of\n+        (Arg                : Node_Id;\n+         N1, N2, N3, N4, N5 : Name_Id);\n       --  Check the specified argument Arg to make sure that it is an\n-      --  identifier whose name matches either N1 or N2 (or N3 if present).\n-      --  If not then give error and raise Pragma_Exit.\n+      --  identifier whose name matches either N1 or N2 (or N3, N4, N5 if\n+      --  present). If not then give error and raise Pragma_Exit.\n \n       procedure Check_Arg_Is_Queuing_Policy (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is a valid\n@@ -1055,8 +1061,8 @@ package body Sem_Prag is\n       end Check_Arg_Is_One_Of;\n \n       procedure Check_Arg_Is_One_Of\n-        (Arg            : Node_Id;\n-         N1, N2, N3, N4 : Name_Id)\n+        (Arg                : Node_Id;\n+         N1, N2, N3, N4, N5 : Name_Id)\n       is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n \n@@ -1067,11 +1073,11 @@ package body Sem_Prag is\n            and then Chars (Argx) /= N2\n            and then Chars (Argx) /= N3\n            and then Chars (Argx) /= N4\n+           and then Chars (Argx) /= N5\n          then\n             Error_Pragma_Arg (\"invalid argument for pragma%\", Argx);\n          end if;\n       end Check_Arg_Is_One_Of;\n-\n       ---------------------------------\n       -- Check_Arg_Is_Queuing_Policy --\n       ---------------------------------\n@@ -6419,7 +6425,7 @@ package body Sem_Prag is\n \n             Rewrite (N,\n               Make_Pragma (Loc,\n-                Chars => Name_Check,\n+                Chars                        => Name_Check,\n                 Pragma_Argument_Associations => Newa));\n             Analyze (N);\n          end Assert;\n@@ -6428,7 +6434,7 @@ package body Sem_Prag is\n          -- Assertion_Policy --\n          ----------------------\n \n-         --  pragma Assertion_Policy (Check | Ignore)\n+         --  pragma Assertion_Policy (Check | Disable |Ignore)\n \n          when Pragma_Assertion_Policy => Assertion_Policy : declare\n             Policy : Node_Id;\n@@ -6438,7 +6444,7 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n-            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Ignore);\n+            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Disable, Name_Ignore);\n \n             --  We treat pragma Assertion_Policy as equivalent to:\n \n@@ -6863,6 +6869,14 @@ package body Sem_Prag is\n \n             Check_Arg_Is_Identifier (Arg1);\n \n+            --  Completely ignore if disabled\n+\n+            if Check_Disabled (Chars (Get_Pragma_Arg (Arg1))) then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+            end if;\n+\n             --  Indicate if pragma is enabled. The Original_Node reference here\n             --  is to deal with pragma Assert rewritten as a Check pragma.\n \n@@ -6948,7 +6962,7 @@ package body Sem_Prag is\n          --    [Name   =>] IDENTIFIER,\n          --    [Policy =>] POLICY_IDENTIFIER);\n \n-         --  POLICY_IDENTIFIER ::= ON | OFF | CHECK | IGNORE\n+         --  POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE\n \n          --  Note: this is a configuration pragma, but it is allowed to appear\n          --  anywhere else.\n@@ -6959,7 +6973,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Name);\n             Check_Optional_Identifier (Arg2, Name_Policy);\n             Check_Arg_Is_One_Of\n-              (Arg2, Name_On, Name_Off, Name_Check, Name_Ignore);\n+              (Arg2, Name_On, Name_Off, Name_Check, Name_Disable, Name_Ignore);\n \n             --  A Check_Policy pragma can appear either as a configuration\n             --  pragma, or in a declarative part or a package spec (see RM\n@@ -7608,6 +7622,14 @@ package body Sem_Prag is\n          begin\n             GNAT_Pragma;\n \n+            --  Skip analysis if disabled\n+\n+            if Debug_Pragmas_Disabled then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+            end if;\n+\n             Cond :=\n               New_Occurrence_Of\n                 (Boolean_Literals (Debug_Pragmas_Enabled and Expander_Active),\n@@ -7679,9 +7701,11 @@ package body Sem_Prag is\n          when Pragma_Debug_Policy =>\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n-            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Ignore);\n+            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Disable, Name_Ignore);\n             Debug_Pragmas_Enabled :=\n               Chars (Get_Pragma_Arg (Arg1)) = Name_Check;\n+            Debug_Pragmas_Disabled :=\n+              Chars (Get_Pragma_Arg (Arg1)) = Name_Disable;\n \n          ---------------------\n          -- Detect_Blocking --\n@@ -14181,6 +14205,40 @@ package body Sem_Prag is\n       End_Scope;\n    end Analyze_TC_In_Decl_Part;\n \n+   --------------------\n+   -- Check_Disabled --\n+   --------------------\n+\n+   function Check_Disabled (Nam : Name_Id) return Boolean is\n+      PP : Node_Id;\n+\n+   begin\n+      --  Loop through entries in check policy list\n+\n+      PP := Opt.Check_Policy_List;\n+      loop\n+         --  If there are no specific entries that matched, then nothing is\n+         --  disabled, so return False.\n+\n+         if No (PP) then\n+            return False;\n+\n+         --  Here we have an entry see if it matches\n+\n+         else\n+            declare\n+               PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+            begin\n+               if Nam = Chars (Get_Pragma_Arg (First (PPA))) then\n+                  return Chars (Get_Pragma_Arg (Last (PPA))) = Name_Disable;\n+               else\n+                  PP := Next_Pragma (PP);\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n+   end Check_Disabled;\n+\n    -------------------\n    -- Check_Enabled --\n    -------------------"}, {"sha": "18ffcc38a2460be100bb206b3e5fb2964c2472fb", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -54,9 +54,15 @@ package Sem_Prag is\n    --  pragma as \"spec expressions\" (see section in Sem \"Handling of Default\n    --  and Per-Object Expressions...\").\n \n+   function Check_Disabled (Nam : Name_Id) return Boolean;\n+   --  This function is used in connection with pragmas Assertion, Check,\n+   --  Precondition, and Postcondition, to determine if Check pragmas (or\n+   --  corresponding Assert, Precondition, or Postcondition pragmas) are\n+   --  currently disabled (as set by a Policy pragma with the Disabled\n+\n    function Check_Enabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,\n-   --  Precondition, and Postcondition to determine if Check pragmas (or\n+   --  Precondition, and Postcondition, to determine if Check pragmas (or\n    --  corresponding Assert, Precondition, or Postcondition pragmas) are\n    --  currently active, as determined by the presence of -gnata on the\n    --  command line (which sets the default), and the appearance of pragmas"}, {"sha": "252dbda4181772d769ce73cdc1221a6c30457d77", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3956ddfccf087a37c4ed3abb034e12096fdcd1/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "patch": "@@ -623,6 +623,7 @@ package Snames is\n    Name_Copy                           : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n    Name_Descriptor                     : constant Name_Id := N + $;\n+   Name_Disable                        : constant Name_Id := N + $;\n    Name_Dot_Replacement                : constant Name_Id := N + $;\n    Name_Dynamic                        : constant Name_Id := N + $;\n    Name_Ensures                        : constant Name_Id := N + $;"}]}