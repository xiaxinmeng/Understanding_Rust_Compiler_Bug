{"sha": "a8de832470f78a40a0e2c8de866a471bf74bf0ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThkZTgzMjQ3MGY3OGE0MGEwZTJjOGRlODY2YTQ3MWJmNzRiZjBhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-08-30T13:44:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-08-30T21:23:28Z"}, "message": "c++: fold function template args sooner [PR101460]\n\nAs discussed in the PR, we were giving a lot of unnecessary errors for this\ntestcase because we didn't try to do constant evaluation until\nconvert_nontype_argument, which happens for each of the candidates.  But\nwhen looking at a template-id as the function operand of a call, we can try\nto fold arguments before we get into overload resolution.\n\n\tPR c++/101460\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (cxx_constant_value_sfinae): Declare.\n\t* constexpr.c (cxx_constant_value_sfinae): New.\n\t* pt.c (fold_targs_r, maybe_fold_fn_template_args): New.\n\t(tsubst_copy_and_build) [CALL_EXPR]: Call\n\tmaybe_fold_fn_template_args.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/explicit-args6.C: New test.", "tree": {"sha": "b4c322aa99ae5649ec56af1b228c1304f2a2c68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4c322aa99ae5649ec56af1b228c1304f2a2c68d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8de832470f78a40a0e2c8de866a471bf74bf0ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8de832470f78a40a0e2c8de866a471bf74bf0ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8de832470f78a40a0e2c8de866a471bf74bf0ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8de832470f78a40a0e2c8de866a471bf74bf0ab/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7083b83e45852540a4a09ee11b74dc28d777399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7083b83e45852540a4a09ee11b74dc28d777399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7083b83e45852540a4a09ee11b74dc28d777399"}], "stats": {"total": 107, "additions": 107, "deletions": 0}, "files": [{"sha": "9606719bc73996af39a27966a17df6d07042fddc", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=a8de832470f78a40a0e2c8de866a471bf74bf0ab", "patch": "@@ -7458,6 +7458,18 @@ cxx_constant_value (tree t, tree decl)\n   return cxx_eval_outermost_constant_expr (t, false, true, true, false, decl);\n }\n \n+/* As above, but respect SFINAE.  */\n+\n+tree\n+cxx_constant_value_sfinae (tree t, tsubst_flags_t complain)\n+{\n+  bool sfinae = !(complain & tf_error);\n+  tree r = cxx_eval_outermost_constant_expr (t, sfinae, true, true);\n+  if (sfinae && !TREE_CONSTANT (r))\n+    r = error_mark_node;\n+  return r;\n+}\n+\n /* Like cxx_constant_value, but used for evaluation of constexpr destructors\n    of constexpr variables.  The actual initializer of DECL is not modified.  */\n "}, {"sha": "6a179375a56aed217aed94f37429b8f295b5f9ff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a8de832470f78a40a0e2c8de866a471bf74bf0ab", "patch": "@@ -8266,6 +8266,7 @@ extern bool require_constant_expression (tree);\n extern bool require_rvalue_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n+extern tree cxx_constant_value_sfinae\t\t(tree, tsubst_flags_t);\n extern void cxx_constant_dtor\t\t\t(tree, tree);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE, bool = false);"}, {"sha": "d7d0dce691caf7cc6823f204f8a28cd8f9dc29cc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a8de832470f78a40a0e2c8de866a471bf74bf0ab", "patch": "@@ -19465,6 +19465,63 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   return r;\n }\n \n+/* Subroutine of maybe_fold_fn_template_args.  */\n+\n+static bool\n+fold_targs_r (tree targs, tsubst_flags_t complain)\n+{\n+  int len = TREE_VEC_LENGTH (targs);\n+  for (int i = 0; i < len; ++i)\n+    {\n+      tree &elt = TREE_VEC_ELT (targs, i);\n+      if (!elt || TYPE_P (elt)\n+\t  || TREE_CODE (elt) == TEMPLATE_DECL)\n+\tcontinue;\n+      if (TREE_CODE (elt) == NONTYPE_ARGUMENT_PACK)\n+\t{\n+\t  if (!fold_targs_r (ARGUMENT_PACK_ARGS (elt), complain))\n+\t    return false;\n+\t}\n+      else if (/* We can only safely preevaluate scalar prvalues.  */\n+\t       SCALAR_TYPE_P (TREE_TYPE (elt))\n+\t       && !glvalue_p (elt)\n+\t       && !TREE_CONSTANT (elt))\n+\t{\n+\t  elt = cxx_constant_value_sfinae (elt, complain);\n+\t  if (elt == error_mark_node)\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Try to do constant evaluation of any explicit template arguments in FN\n+   before overload resolution, to get any errors only once.  Return true iff\n+   we didn't have any problems folding.  */\n+\n+static bool\n+maybe_fold_fn_template_args (tree fn, tsubst_flags_t complain)\n+{\n+  if (processing_template_decl || fn == NULL_TREE)\n+    return true;\n+  if (fn == error_mark_node)\n+    return false;\n+  if (TREE_CODE (fn) == OFFSET_REF\n+      || TREE_CODE (fn) == COMPONENT_REF)\n+    fn = TREE_OPERAND (fn, 1);\n+  if (BASELINK_P (fn))\n+    fn = BASELINK_FUNCTIONS (fn);\n+  if (TREE_CODE (fn) != TEMPLATE_ID_EXPR)\n+    return true;\n+  tree targs = TREE_OPERAND (fn, 1);\n+  if (targs == NULL_TREE)\n+    return true;\n+  if (targs == error_mark_node)\n+    return false;\n+  return fold_targs_r (targs, complain);\n+}\n+\n /* Like tsubst but deals with expressions and performs semantic\n    analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\" or\n    \"F<TARGS> (ARGS)\".  */\n@@ -20343,6 +20400,9 @@ tsubst_copy_and_build (tree t,\n \t    && !mark_used (function, complain) && !(complain & tf_error))\n \t  RETURN (error_mark_node);\n \n+\tif (!maybe_fold_fn_template_args (function, complain))\n+\t  return error_mark_node;\n+\n \t/* Put back tf_decltype for the actual call.  */\n \tcomplain |= decltype_flag;\n "}, {"sha": "d853564e3bea7c4a6118365388242352773769e7", "filename": "gcc/testsuite/g++.dg/template/explicit-args6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de832470f78a40a0e2c8de866a471bf74bf0ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexplicit-args6.C?ref=a8de832470f78a40a0e2c8de866a471bf74bf0ab", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/101460\n+// { dg-do compile { target c++11 } }\n+\n+template<bool> struct enable_if { };\n+template<> struct enable_if<true> { using type = void; };\n+\n+template<bool B>\n+using enable_if_t = typename enable_if<B>::type;\n+\n+struct tuple { };\n+struct pair { };\n+\n+template<unsigned N> enable_if_t<N == 1> get(tuple&) { }       // { dg-bogus \"candidate\" }\n+template<unsigned N> enable_if_t<N == 1> get(const tuple&) { } // { dg-bogus \"candidate\" }\n+template<unsigned N> enable_if_t<N == 1> get(pair&) { }\t       // { dg-bogus \"candidate\" }\n+template<unsigned N> enable_if_t<N == 1> get(const pair&) { }  // { dg-bogus \"candidate\" }\n+\n+template<int N>\n+constexpr unsigned\n+frob()\n+{\n+  static_assert(N == 1, \"user-friendly diagnostic\"); // { dg-error \"user-friendly\" }\n+  // narrowing check, reject negative values\n+  return unsigned{N};\t\t// { dg-prune-output \"narrowing\" }\n+} // { dg-prune-output \"flows off the end\" }\n+// { dg-prune-output \"not a return-statement\" }\n+\n+template<int N> void get_n(tuple& t) { get<frob<N>()>(t); } // { dg-error \"\" }\n+\n+int main()\n+{\n+  tuple t;\n+  get_n<-1>(t);\n+}"}]}