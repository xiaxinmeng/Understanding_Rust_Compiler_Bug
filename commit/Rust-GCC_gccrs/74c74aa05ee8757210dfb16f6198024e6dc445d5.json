{"sha": "74c74aa05ee8757210dfb16f6198024e6dc445d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRjNzRhYTA1ZWU4NzU3MjEwZGZiMTZmNjE5ODAyNGU2ZGM0NDVkNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:52:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:52:30Z"}, "message": "poly_int: DWARF locations\n\nThis patch adds support for DWARF location expressions\nthat involve polynomial offsets.  It adds a target hook that\nsays how the runtime invariants used in the offsets should be\nrepresented in DWARF.  SVE vectors have to be a multiple of\n128 bits in size, so the GCC port uses the number of 128-bit\nblocks minus one as the runtime invariant.  However, in DWARF,\nthe vector length is exposed via a pseudo \"VG\" register that\nholds the number of 64-bit elements in a vector.  Thus:\n\n  indeterminate 1 == (VG / 2) - 1\n\nThe hook needs to be general enough to express this.\nNote that in most cases the division and subtraction fold\naway into surrounding expressions.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (dwarf_poly_indeterminate_value): New hook.\n\t* targhooks.h (default_dwarf_poly_indeterminate_value): Declare.\n\t* targhooks.c (default_dwarf_poly_indeterminate_value): New function.\n\t* doc/tm.texi.in (TARGET_DWARF_POLY_INDETERMINATE_VALUE): Document.\n\t* doc/tm.texi: Regenerate.\n\t* dwarf2out.h (build_cfa_loc, build_cfa_aligned_loc): Take the\n\toffset as a poly_int64.\n\t* dwarf2out.c (new_reg_loc_descr): Move later in file.  Take the\n\toffset as a poly_int64.\n\t(loc_descr_plus_const, loc_list_plus_const, build_cfa_aligned_loc):\n\tTake the offset as a poly_int64.\n\t(build_cfa_loc): Likewise.  Use loc_descr_plus_const.\n\t(frame_pointer_fb_offset): Change to a poly_int64.\n\t(int_loc_descriptor): Take the offset as a poly_int64.  Use\n\ttargetm.dwarf_poly_indeterminate_value for polynomial offsets.\n\t(based_loc_descr): Take the offset as a poly_int64.\n\tUse strip_offset_and_add to handle (plus X (const)).\n\tUse new_reg_loc_descr instead of an open-coded version of the\n\tprevious implementation.\n\t(mem_loc_descriptor): Handle CONST_POLY_INT.\n\t(compute_frame_pointer_to_fb_displacement): Take the offset as a\n\tpoly_int64.  Use strip_offset_and_add to handle (plus X (const)).\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255868", "tree": {"sha": "3ad25363e816cea2e4024bcb3390bbfeab905eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ad25363e816cea2e4024bcb3390bbfeab905eca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74c74aa05ee8757210dfb16f6198024e6dc445d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c74aa05ee8757210dfb16f6198024e6dc445d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c74aa05ee8757210dfb16f6198024e6dc445d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c74aa05ee8757210dfb16f6198024e6dc445d5/comments", "author": null, "committer": null, "parents": [{"sha": "84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84bc717b510cc56f64120dd58c64e1f6ebfad5e3"}], "stats": {"total": 233, "additions": 182, "deletions": 51}, "files": [{"sha": "2ba9e08dfef433ab8c182c708fc5370ce6d722c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -1,3 +1,30 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (dwarf_poly_indeterminate_value): New hook.\n+\t* targhooks.h (default_dwarf_poly_indeterminate_value): Declare.\n+\t* targhooks.c (default_dwarf_poly_indeterminate_value): New function.\n+\t* doc/tm.texi.in (TARGET_DWARF_POLY_INDETERMINATE_VALUE): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* dwarf2out.h (build_cfa_loc, build_cfa_aligned_loc): Take the\n+\toffset as a poly_int64.\n+\t* dwarf2out.c (new_reg_loc_descr): Move later in file.  Take the\n+\toffset as a poly_int64.\n+\t(loc_descr_plus_const, loc_list_plus_const, build_cfa_aligned_loc):\n+\tTake the offset as a poly_int64.\n+\t(build_cfa_loc): Likewise.  Use loc_descr_plus_const.\n+\t(frame_pointer_fb_offset): Change to a poly_int64.\n+\t(int_loc_descriptor): Take the offset as a poly_int64.  Use\n+\ttargetm.dwarf_poly_indeterminate_value for polynomial offsets.\n+\t(based_loc_descr): Take the offset as a poly_int64.\n+\tUse strip_offset_and_add to handle (plus X (const)).\n+\tUse new_reg_loc_descr instead of an open-coded version of the\n+\tprevious implementation.\n+\t(mem_loc_descriptor): Handle CONST_POLY_INT.\n+\t(compute_frame_pointer_to_fb_displacement): Take the offset as a\n+\tpoly_int64.  Use strip_offset_and_add to handle (plus X (const)).\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n             Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "434c42a4ca944794bb63d8dd6a79f24215cfa9cb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -3130,6 +3130,19 @@ the CFI label attached to the insn, @var{pattern} is the pattern of\n the insn and @var{index} is @code{UNSPEC_INDEX} or @code{UNSPECV_INDEX}.\n @end deftypefn\n \n+@deftypefn {Target Hook} {unsigned int} TARGET_DWARF_POLY_INDETERMINATE_VALUE (unsigned int @var{i}, unsigned int *@var{factor}, int *@var{offset})\n+Express the value of @code{poly_int} indeterminate @var{i} as a DWARF\n+expression, with @var{i} counting from 1.  Return the number of a DWARF\n+register @var{R} and set @samp{*@var{factor}} and @samp{*@var{offset}} such\n+that the value of the indeterminate is:\n+@smallexample\n+value_of(@var{R}) / @var{factor} - @var{offset}\n+@end smallexample\n+\n+A target only needs to define this hook if it sets\n+@samp{NUM_POLY_INT_COEFFS} to a value greater than 1.\n+@end deftypefn\n+\n @defmac INCOMING_FRAME_SP_OFFSET\n A C expression whose value is an integer giving the offset, in bytes,\n from the value of the stack pointer register to the top of the stack"}, {"sha": "c1d2a8cdc1e032de0a80ed4d7e3215943fd63351", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -2544,6 +2544,8 @@ terminate the stack backtrace.  New ports should avoid this.\n \n @hook TARGET_DWARF_HANDLE_FRAME_UNSPEC\n \n+@hook TARGET_DWARF_POLY_INDETERMINATE_VALUE\n+\n @defmac INCOMING_FRAME_SP_OFFSET\n A C expression whose value is an integer giving the offset, in bytes,\n from the value of the stack pointer register to the top of the stack"}, {"sha": "6e94ad32a3361cbd57b5409a207582caf60dc555", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 111, "deletions": 49, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -1319,7 +1319,7 @@ typedef struct GTY(()) dw_loc_list_struct {\n   bool force;\n } dw_loc_list_node;\n \n-static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n+static dw_loc_descr_ref int_loc_descriptor (poly_int64);\n static dw_loc_descr_ref uint_loc_descriptor (unsigned HOST_WIDE_INT);\n \n /* Convert a DWARF stack opcode into its string name.  */\n@@ -1356,19 +1356,6 @@ new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,\n   return descr;\n }\n \n-/* Return a pointer to a newly allocated location description for\n-   REG and OFFSET.  */\n-\n-static inline dw_loc_descr_ref\n-new_reg_loc_descr (unsigned int reg,  unsigned HOST_WIDE_INT offset)\n-{\n-  if (reg <= 31)\n-    return new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + reg),\n-\t\t\t  offset, 0);\n-  else\n-    return new_loc_descr (DW_OP_bregx, reg, offset);\n-}\n-\n /* Add a location description term to a location description expression.  */\n \n static inline void\n@@ -1501,23 +1488,31 @@ loc_descr_equal_p (dw_loc_descr_ref a, dw_loc_descr_ref b)\n }\n \n \n-/* Add a constant OFFSET to a location expression.  */\n+/* Add a constant POLY_OFFSET to a location expression.  */\n \n static void\n-loc_descr_plus_const (dw_loc_descr_ref *list_head, HOST_WIDE_INT offset)\n+loc_descr_plus_const (dw_loc_descr_ref *list_head, poly_int64 poly_offset)\n {\n   dw_loc_descr_ref loc;\n   HOST_WIDE_INT *p;\n \n   gcc_assert (*list_head != NULL);\n \n-  if (!offset)\n+  if (known_eq (poly_offset, 0))\n     return;\n \n   /* Find the end of the chain.  */\n   for (loc = *list_head; loc->dw_loc_next != NULL; loc = loc->dw_loc_next)\n     ;\n \n+  HOST_WIDE_INT offset;\n+  if (!poly_offset.is_constant (&offset))\n+    {\n+      loc->dw_loc_next = int_loc_descriptor (poly_offset);\n+      add_loc_descr (&loc->dw_loc_next, new_loc_descr (DW_OP_plus, 0, 0));\n+      return;\n+    }\n+\n   p = NULL;\n   if (loc->dw_loc_opc == DW_OP_fbreg\n       || (loc->dw_loc_opc >= DW_OP_breg0 && loc->dw_loc_opc <= DW_OP_breg31))\n@@ -1543,10 +1538,33 @@ loc_descr_plus_const (dw_loc_descr_ref *list_head, HOST_WIDE_INT offset)\n     }\n }\n \n+/* Return a pointer to a newly allocated location description for\n+   REG and OFFSET.  */\n+\n+static inline dw_loc_descr_ref\n+new_reg_loc_descr (unsigned int reg, poly_int64 offset)\n+{\n+  HOST_WIDE_INT const_offset;\n+  if (offset.is_constant (&const_offset))\n+    {\n+      if (reg <= 31)\n+\treturn new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + reg),\n+\t\t\t      const_offset, 0);\n+      else\n+\treturn new_loc_descr (DW_OP_bregx, reg, const_offset);\n+    }\n+  else\n+    {\n+      dw_loc_descr_ref ret = new_reg_loc_descr (reg, 0);\n+      loc_descr_plus_const (&ret, offset);\n+      return ret;\n+    }\n+}\n+\n /* Add a constant OFFSET to a location list.  */\n \n static void\n-loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n+loc_list_plus_const (dw_loc_list_ref list_head, poly_int64 offset)\n {\n   dw_loc_list_ref d;\n   for (d = list_head; d != NULL; d = d->dw_loc_next)\n@@ -2626,7 +2644,7 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n    expression.  */\n \n struct dw_loc_descr_node *\n-build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n+build_cfa_loc (dw_cfa_location *cfa, poly_int64 offset)\n {\n   struct dw_loc_descr_node *head, *tmp;\n \n@@ -2639,11 +2657,7 @@ build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n       head->dw_loc_oprnd1.val_entry = NULL;\n       tmp = new_loc_descr (DW_OP_deref, 0, 0);\n       add_loc_descr (&head, tmp);\n-      if (offset != 0)\n-\t{\n-\t  tmp = new_loc_descr (DW_OP_plus_uconst, offset, 0);\n-\t  add_loc_descr (&head, tmp);\n-\t}\n+      loc_descr_plus_const (&head, offset);\n     }\n   else\n     head = new_reg_loc_descr (cfa->reg, offset);\n@@ -2657,7 +2671,7 @@ build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n \n struct dw_loc_descr_node *\n build_cfa_aligned_loc (dw_cfa_location *cfa,\n-\t\t       HOST_WIDE_INT offset, HOST_WIDE_INT alignment)\n+\t\t       poly_int64 offset, HOST_WIDE_INT alignment)\n {\n   struct dw_loc_descr_node *head;\n   unsigned int dwarf_fp\n@@ -3345,7 +3359,7 @@ static GTY(()) vec<tree, va_gc> *generic_type_instances;\n \n /* Offset from the \"steady-state frame pointer\" to the frame base,\n    within the current function.  */\n-static HOST_WIDE_INT frame_pointer_fb_offset;\n+static poly_int64 frame_pointer_fb_offset;\n static bool frame_pointer_fb_offset_valid;\n \n static vec<dw_die_ref> base_types;\n@@ -3519,7 +3533,7 @@ static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int,\n \t\t\t\t\t\tenum var_init_status);\n static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,\n \t\t\t\t\t\t     enum var_init_status);\n-static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n+static dw_loc_descr_ref based_loc_descr (rtx, poly_int64,\n \t\t\t\t\t enum var_init_status);\n static int is_based_loc (const_rtx);\n static bool resolve_one_addr (rtx *);\n@@ -13222,13 +13236,58 @@ int_shift_loc_descriptor (HOST_WIDE_INT i, int shift)\n   return ret;\n }\n \n-/* Return a location descriptor that designates a constant.  */\n+/* Return a location descriptor that designates constant POLY_I.  */\n \n static dw_loc_descr_ref\n-int_loc_descriptor (HOST_WIDE_INT i)\n+int_loc_descriptor (poly_int64 poly_i)\n {\n   enum dwarf_location_atom op;\n \n+  HOST_WIDE_INT i;\n+  if (!poly_i.is_constant (&i))\n+    {\n+      /* Create location descriptions for the non-constant part and\n+\t add any constant offset at the end.  */\n+      dw_loc_descr_ref ret = NULL;\n+      HOST_WIDE_INT constant = poly_i.coeffs[0];\n+      for (unsigned int j = 1; j < NUM_POLY_INT_COEFFS; ++j)\n+\t{\n+\t  HOST_WIDE_INT coeff = poly_i.coeffs[j];\n+\t  if (coeff != 0)\n+\t    {\n+\t      dw_loc_descr_ref start = ret;\n+\t      unsigned int factor;\n+\t      int bias;\n+\t      unsigned int regno = targetm.dwarf_poly_indeterminate_value\n+\t\t(j, &factor, &bias);\n+\n+\t      /* Add COEFF * ((REGNO / FACTOR) - BIAS) to the value:\n+\t\t add COEFF * (REGNO / FACTOR) now and subtract\n+\t\t COEFF * BIAS from the final constant part.  */\n+\t      constant -= coeff * bias;\n+\t      add_loc_descr (&ret, new_reg_loc_descr (regno, 0));\n+\t      if (coeff % factor == 0)\n+\t\tcoeff /= factor;\n+\t      else\n+\t\t{\n+\t\t  int amount = exact_log2 (factor);\n+\t\t  gcc_assert (amount >= 0);\n+\t\t  add_loc_descr (&ret, int_loc_descriptor (amount));\n+\t\t  add_loc_descr (&ret, new_loc_descr (DW_OP_shr, 0, 0));\n+\t\t}\n+\t      if (coeff != 1)\n+\t\t{\n+\t\t  add_loc_descr (&ret, int_loc_descriptor (coeff));\n+\t\t  add_loc_descr (&ret, new_loc_descr (DW_OP_mul, 0, 0));\n+\t\t}\n+\t      if (start)\n+\t\tadd_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n+\t    }\n+\t}\n+      loc_descr_plus_const (&ret, constant);\n+      return ret;\n+    }\n+\n   /* Pick the smallest representation of a constant, rather than just\n      defaulting to the LEB encoding.  */\n   if (i >= 0)\n@@ -13594,7 +13653,7 @@ address_of_int_loc_descriptor (int size, HOST_WIDE_INT i)\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n-based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n+based_loc_descr (rtx reg, poly_int64 offset,\n \t\t enum var_init_status initialized)\n {\n   unsigned int regno;\n@@ -13613,11 +13672,7 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n \n       if (elim != reg)\n \t{\n-\t  if (GET_CODE (elim) == PLUS)\n-\t    {\n-\t      offset += INTVAL (XEXP (elim, 1));\n-\t      elim = XEXP (elim, 0);\n-\t    }\n+\t  elim = strip_offset_and_add (elim, &offset);\n \t  gcc_assert ((SUPPORTS_STACK_ALIGNMENT\n \t\t       && (elim == hard_frame_pointer_rtx\n \t\t\t   || elim == stack_pointer_rtx))\n@@ -13641,7 +13696,15 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n \n \t  gcc_assert (frame_pointer_fb_offset_valid);\n \t  offset += frame_pointer_fb_offset;\n-\t  return new_loc_descr (DW_OP_fbreg, offset, 0);\n+\t  HOST_WIDE_INT const_offset;\n+\t  if (offset.is_constant (&const_offset))\n+\t    return new_loc_descr (DW_OP_fbreg, const_offset, 0);\n+\t  else\n+\t    {\n+\t      dw_loc_descr_ref ret = new_loc_descr (DW_OP_fbreg, 0, 0);\n+\t      loc_descr_plus_const (&ret, offset);\n+\t      return ret;\n+\t    }\n \t}\n     }\n \n@@ -13656,23 +13719,21 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n #endif\n   regno = DWARF_FRAME_REGNUM (regno);\n \n+  HOST_WIDE_INT const_offset;\n   if (!optimize && fde\n-      && (fde->drap_reg == regno || fde->vdrap_reg == regno))\n+      && (fde->drap_reg == regno || fde->vdrap_reg == regno)\n+      && offset.is_constant (&const_offset))\n     {\n       /* Use cfa+offset to represent the location of arguments passed\n \t on the stack when drap is used to align stack.\n \t Only do this when not optimizing, for optimized code var-tracking\n \t is supposed to track where the arguments live and the register\n \t used as vdrap or drap in some spot might be used for something\n \t else in other part of the routine.  */\n-      return new_loc_descr (DW_OP_fbreg, offset, 0);\n+      return new_loc_descr (DW_OP_fbreg, const_offset, 0);\n     }\n \n-  if (regno <= 31)\n-    result = new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + regno),\n-\t\t\t    offset, 0);\n-  else\n-    result = new_loc_descr (DW_OP_bregx, regno, offset);\n+  result = new_reg_loc_descr (regno, offset);\n \n   if (initialized == VAR_INIT_STATUS_UNINITIALIZED)\n     add_loc_descr (&result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n@@ -14680,6 +14741,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n   enum dwarf_location_atom op;\n   dw_loc_descr_ref op0, op1;\n   rtx inner = NULL_RTX;\n+  poly_int64 offset;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (rtl);\n@@ -15384,6 +15446,10 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t}\n       break;\n \n+    case CONST_POLY_INT:\n+      mem_loc_result = int_loc_descriptor (rtx_to_poly_int64 (rtl));\n+      break;\n+\n     case EQ:\n       mem_loc_result = scompare_loc_descriptor (DW_OP_eq, rtl, mem_mode);\n       break;\n@@ -19709,7 +19775,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n    before the latter is negated.  */\n \n static void\n-compute_frame_pointer_to_fb_displacement (HOST_WIDE_INT offset)\n+compute_frame_pointer_to_fb_displacement (poly_int64 offset)\n {\n   rtx reg, elim;\n \n@@ -19724,11 +19790,7 @@ compute_frame_pointer_to_fb_displacement (HOST_WIDE_INT offset)\n   elim = (ira_use_lra_p\n \t  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)\n \t  : eliminate_regs (reg, VOIDmode, NULL_RTX));\n-  if (GET_CODE (elim) == PLUS)\n-    {\n-      offset += INTVAL (XEXP (elim, 1));\n-      elim = XEXP (elim, 0);\n-    }\n+  elim = strip_offset_and_add (elim, &offset);\n \n   frame_pointer_fb_offset = -offset;\n "}, {"sha": "140724c8e8c48dc55f889059b85db44a22ad1ffc", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -267,9 +267,9 @@ struct GTY(()) dw_discr_list_node {\n \n /* Interface from dwarf2out.c to dwarf2cfi.c.  */\n extern struct dw_loc_descr_node *build_cfa_loc\n-  (dw_cfa_location *, HOST_WIDE_INT);\n+  (dw_cfa_location *, poly_int64);\n extern struct dw_loc_descr_node *build_cfa_aligned_loc\n-  (dw_cfa_location *, HOST_WIDE_INT offset, HOST_WIDE_INT alignment);\n+  (dw_cfa_location *, poly_int64, HOST_WIDE_INT);\n extern struct dw_loc_descr_node *mem_loc_descriptor\n   (rtx, machine_mode mode, machine_mode mem_mode,\n    enum var_init_status);"}, {"sha": "5296b25f25c507b4bbf36e6fd7d8cbb15280ec9a", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -4136,6 +4136,21 @@ the CFI label attached to the insn, @var{pattern} is the pattern of\\n\\\n the insn and @var{index} is @code{UNSPEC_INDEX} or @code{UNSPECV_INDEX}.\",\n  void, (const char *label, rtx pattern, int index), NULL)\n \n+DEFHOOK\n+(dwarf_poly_indeterminate_value,\n+ \"Express the value of @code{poly_int} indeterminate @var{i} as a DWARF\\n\\\n+expression, with @var{i} counting from 1.  Return the number of a DWARF\\n\\\n+register @var{R} and set @samp{*@var{factor}} and @samp{*@var{offset}} such\\n\\\n+that the value of the indeterminate is:\\n\\\n+@smallexample\\n\\\n+value_of(@var{R}) / @var{factor} - @var{offset}\\n\\\n+@end smallexample\\n\\\n+\\n\\\n+A target only needs to define this hook if it sets\\n\\\n+@samp{NUM_POLY_INT_COEFFS} to a value greater than 1.\",\n+ unsigned int, (unsigned int i, unsigned int *factor, int *offset),\n+ default_dwarf_poly_indeterminate_value)\n+\n /* ??? Documenting this hook requires a GFDL license grant.  */\n DEFHOOK_UNDOC\n (stdarg_optimize_hook,"}, {"sha": "d02fca9949793f17e2b542c274f9c1fd5cb6686e", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -1874,6 +1874,15 @@ default_debug_unwind_info (void)\n   return UI_NONE;\n }\n \n+/* Targets that set NUM_POLY_INT_COEFFS to something greater than 1\n+   must define this hook.  */\n+\n+unsigned int\n+default_dwarf_poly_indeterminate_value (unsigned int, unsigned int *, int *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Determine the correct mode for a Dwarf frame register that represents\n    register REGNO.  */\n "}, {"sha": "05635975ddaf1afe081b0ab649107cdc44751490", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c74aa05ee8757210dfb16f6198024e6dc445d5/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=74c74aa05ee8757210dfb16f6198024e6dc445d5", "patch": "@@ -238,6 +238,9 @@ extern int default_label_align_max_skip (rtx_insn *);\n extern int default_jump_align_max_skip (rtx_insn *);\n extern section * default_function_section(tree decl, enum node_frequency freq,\n \t\t\t\t\t  bool startup, bool exit);\n+extern unsigned int default_dwarf_poly_indeterminate_value (unsigned int,\n+\t\t\t\t\t\t\t    unsigned int *,\n+\t\t\t\t\t\t\t    int *);\n extern machine_mode default_dwarf_frame_reg_mode (int);\n extern fixed_size_mode default_get_reg_raw_mode (int);\n extern bool default_keep_leaf_when_profiled ();"}]}