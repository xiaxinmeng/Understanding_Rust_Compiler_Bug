{"sha": "e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM2YmYzM2EzYjRkOWJmMDcwNTFkMzJmMWUyZGRmMmI0YWEwZjZlYw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-09-03T05:32:20Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-09-03T05:32:20Z"}, "message": "objc-act.c (objc_tree_code_type, [...]): Constify.\n\n\t* objc/objc-act.c (objc_tree_code_type, objc_tree_code_length,\n\tobjc_tree_code_name, synth_id_with_class_suffix, warn_with_method,\n\terror_with_ivar, gen_declarator, create_builtin_decl,\n\tmy_build_string, generate_descriptor_table, generate_ivars_list,\n\tgenerate_dispatch_table, check_protocols, TAG_GETCLASS,\n\tTAG_GETMETACLASS, TAG_MSGSEND, TAG_MSGSENDSUPER, TAG_EXECCLASS,\n\tdump_base_name, lang_decode_option, build_encode_expr,\n\tstart_class, finish_class, encode_pointer, really_start_method,\n\tgen_declaration, dump_interface, handle_class_ref, handle_impent):\n\tConstify.\n\t(objc_demangle, objc_printable_name, generate_struct_by_value_array):\n\tAdd static prototypes.\n\t(build_objc_string_decl, build_selector_reference_decl,\n\tencode_bitfield, build_class_reference_decl): Remove unused\n\tparameter, all callers changed.\n\t(maybe_objc_method_name): Mark with ATTRIBUTE_UNUSED.\n\t(objc_printable_name): Likewise.  Change second parameter to type int.\n\t(init_objc): Use memcpy, not bcopy, to avoid casts.\n\nFrom-SVN: r29077", "tree": {"sha": "c197b2d5b359879084e6fb60b594332ca304036e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c197b2d5b359879084e6fb60b594332ca304036e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec/comments", "author": null, "committer": null, "parents": [{"sha": "8a34409df67594337075cf40e4a8f23f3102ab95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a34409df67594337075cf40e4a8f23f3102ab95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a34409df67594337075cf40e4a8f23f3102ab95"}], "stats": {"total": 191, "additions": 108, "deletions": 83}, "files": [{"sha": "43050d61962c04ca92b9c9802add54793ed64854", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "patch": "@@ -1,3 +1,24 @@\n+Fri Sep  3 01:28:33 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* objc/objc-act.c (objc_tree_code_type, objc_tree_code_length,\n+\tobjc_tree_code_name, synth_id_with_class_suffix, warn_with_method,\n+\terror_with_ivar, gen_declarator, create_builtin_decl,\n+\tmy_build_string, generate_descriptor_table, generate_ivars_list,\n+\tgenerate_dispatch_table, check_protocols, TAG_GETCLASS,\n+\tTAG_GETMETACLASS, TAG_MSGSEND, TAG_MSGSENDSUPER, TAG_EXECCLASS,\n+\tdump_base_name, lang_decode_option, build_encode_expr,\n+\tstart_class, finish_class, encode_pointer, really_start_method,\n+\tgen_declaration, dump_interface, handle_class_ref, handle_impent):\n+\tConstify.\n+\t(objc_demangle, objc_printable_name, generate_struct_by_value_array):\n+\tAdd static prototypes.\n+\t(build_objc_string_decl, build_selector_reference_decl,\n+\tencode_bitfield, build_class_reference_decl): Remove unused\n+\tparameter, all callers changed.\n+\t(maybe_objc_method_name): Mark with ATTRIBUTE_UNUSED.\n+\t(objc_printable_name): Likewise.  Change second parameter to type int.\n+\t(init_objc): Use memcpy, not bcopy, to avoid casts.\n+\n Thu Sep  2 21:49:52 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* reload1.c (eliminate_regs_in_insn): Avoid eliminating the"}, {"sha": "50dde955e16d2b4f19f9f1d606089e6e4b86e9f6", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e36bf33a3b4d9bf07051d32f1e2ddf2b4aa0f6ec", "patch": "@@ -92,7 +92,7 @@ extern cpp_options parse_options;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-char objc_tree_code_type[] = {\n+static const char objc_tree_code_type[] = {\n   'x',\n #include \"objc-tree.def\"\n };\n@@ -104,7 +104,7 @@ char objc_tree_code_type[] = {\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,\n \n-int objc_tree_code_length[] = {\n+static const int objc_tree_code_length[] = {\n   0,\n #include \"objc-tree.def\"\n };\n@@ -114,7 +114,7 @@ int objc_tree_code_length[] = {\n    Used for printing out the tree and error messages.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n \n-char *objc_tree_code_name[] = {\n+static const char * const objc_tree_code_name[] = {\n   \"@@dummy\",\n #include \"objc-tree.def\"\n };\n@@ -195,13 +195,15 @@ static void build_protocol_reference\t\tPROTO((tree));\n static tree init_selector\t\t\tPROTO((int));\n #endif\n static tree build_keyword_selector\t\tPROTO((tree));\n-static tree synth_id_with_class_suffix\t\tPROTO((char *, tree));\n+static tree synth_id_with_class_suffix\t\tPROTO((const char *, tree));\n \n static void generate_static_references\t\tPROTO((void));\n static int check_methods_accessible\t\tPROTO((tree, tree,\n \t\t\t\t\t\t       int));\n static void encode_aggregate_within\t\tPROTO((tree, int, int,\n \t\t\t\t\t               int, int));\n+static const char *objc_demangle\t\tPROTO((const char *));\n+static const char *objc_printable_name\t\tPROTO((tree, int));\n \n /* Misc. bookkeeping */\n \n@@ -241,9 +243,8 @@ static tree add_objc_string\t\t\tPROTO((tree,\n \t\t\t\t\t\t       enum string_section));\n static tree get_objc_string_decl\t\tPROTO((tree,\n \t\t\t\t\t\t       enum string_section));\n-static tree build_objc_string_decl\t\tPROTO((tree,\n-\t\t\t\t\t\t       enum string_section));\n-static tree build_selector_reference_decl\tPROTO((tree));\n+static tree build_objc_string_decl\t\tPROTO((enum string_section));\n+static tree build_selector_reference_decl\tPROTO((void));\n \n /* Protocol additions.  */\n \n@@ -257,7 +258,7 @@ static void encode_type_qualifiers\t\tPROTO((tree));\n static void encode_pointer\t\t\tPROTO((tree, int, int));\n static void encode_array\t\t\tPROTO((tree, int, int));\n static void encode_aggregate\t\t\tPROTO((tree, int, int));\n-static void encode_bitfield\t\t\tPROTO((int, int));\n+static void encode_bitfield\t\t\tPROTO((int));\n static void encode_type\t\t\t\tPROTO((tree, int, int));\n static void encode_field_decl\t\t\tPROTO((tree, int, int));\n \n@@ -269,11 +270,12 @@ static tree expr_last\t\t\t\tPROTO((tree));\n \n /* Utilities for debugging and error diagnostics.  */\n \n-static void warn_with_method\t\t\tPROTO((char *, int, tree));\n-static void error_with_ivar\t\t\tPROTO((char *, tree, tree));\n+static void warn_with_method\t\t\tPROTO((const char *, int, tree));\n+static void error_with_ivar\t\t\tPROTO((const char *, tree, tree));\n static char *gen_method_decl\t\t\tPROTO((tree, char *));\n static char *gen_declaration\t\t\tPROTO((tree, char *));\n-static char *gen_declarator\t\t\tPROTO((tree, char *, char *));\n+static char *gen_declarator\t\t\tPROTO((tree, char *,\n+\t\t\t\t\t\t       const char *));\n static int is_complex_decl\t\t\tPROTO((tree));\n static void adorn_decl\t\t\t\tPROTO((tree, char *));\n static void dump_interface\t\t\tPROTO((FILE *, tree));\n@@ -286,8 +288,8 @@ static tree define_decl\t\t\t\tPROTO((tree, tree));\n static tree lookup_method_in_protocol_list\tPROTO((tree, tree, int));\n static tree lookup_protocol_in_reflist\t\tPROTO((tree, tree));\n static tree create_builtin_decl\t\t\tPROTO((enum tree_code,\n-\t\t\t\t\t\t       tree, char *));\n-static tree my_build_string\t\t\tPROTO((int, char *));\n+\t\t\t\t\t\t       tree, const char *));\n+static tree my_build_string\t\t\tPROTO((int, const char *));\n static void build_objc_symtab_template\t\tPROTO((void));\n static tree init_def_list\t\t\tPROTO((tree));\n static tree init_objc_symtab\t\t\tPROTO((tree));\n@@ -299,7 +301,7 @@ static tree build_msg_pool_reference\t\tPROTO((int));\n #endif\n static tree build_typed_selector_reference     \tPROTO((tree, tree));\n static tree build_selector_reference\t\tPROTO((tree));\n-static tree build_class_reference_decl\t\tPROTO((tree));\n+static tree build_class_reference_decl\t\tPROTO((void));\n static void add_class_reference\t\t\tPROTO((tree));\n static tree objc_copy_list\t\t\tPROTO((tree, tree *));\n static tree build_protocol_template\t\tPROTO((void));\n@@ -308,7 +310,8 @@ static tree build_method_prototype_list_template PROTO((tree, int));\n static tree build_method_prototype_template\tPROTO((void));\n static int forwarding_offset\t\t\tPROTO((tree));\n static tree encode_method_prototype\t\tPROTO((tree, tree));\n-static tree generate_descriptor_table\t\tPROTO((tree, char *, int, tree, tree));\n+static tree generate_descriptor_table\t\tPROTO((tree, const char *,\n+\t\t\t\t\t\t       int, tree, tree));\n static void generate_method_descriptors\t\tPROTO((tree));\n static tree build_tmp_function_decl\t\tPROTO((void));\n static void hack_method_prototype\t\tPROTO((tree, tree));\n@@ -318,10 +321,10 @@ static void check_ivars\t\t\t\tPROTO((tree, tree));\n static tree build_ivar_list_template\t\tPROTO((tree, int));\n static tree build_method_list_template\t\tPROTO((tree, int));\n static tree build_ivar_list_initializer\t\tPROTO((tree, tree));\n-static tree generate_ivars_list\t\t\tPROTO((tree, char *,\n+static tree generate_ivars_list\t\t\tPROTO((tree, const char *,\n \t\t\t\t\t\t       int, tree));\n static tree build_dispatch_table_initializer\tPROTO((tree, tree));\n-static tree generate_dispatch_table\t\tPROTO((tree, char *,\n+static tree generate_dispatch_table\t\tPROTO((tree, const char *,\n \t\t\t\t\t\t       int, tree));\n static tree build_shared_structure_initializer\tPROTO((tree, tree, tree, tree,\n \t\t\t\t\t\t       tree, int, tree, tree,\n@@ -333,11 +336,14 @@ static tree check_duplicates\t\t\tPROTO((hash));\n static tree receiver_is_class_object\t\tPROTO((tree));\n static int check_methods\t\t\tPROTO((tree, tree, int));\n static int conforms_to_protocol\t\t\tPROTO((tree, tree));\n-static void check_protocols\t\t\tPROTO((tree, char *, char *));\n+static void check_protocols\t\t\tPROTO((tree, const char *,\n+\t\t\t\t\t\t       const char *));\n static tree encode_method_def\t\t\tPROTO((tree));\n static void gen_declspecs\t\t\tPROTO((tree, char *, int));\n static void generate_classref_translation_entry\tPROTO((tree));\n static void handle_class_ref\t\t\tPROTO((tree));\n+static void generate_struct_by_value_array\tPROTO((void))\n+     ATTRIBUTE_NORETURN;\n \n /*** Private Interface (data) ***/\n \n@@ -369,11 +375,11 @@ static void handle_class_ref\t\t\tPROTO((tree));\n #define STRING_OBJECT_CLASS_NAME \"NXConstantString\"\n #define PROTOCOL_OBJECT_CLASS_NAME \"Protocol\"\n \n-static char *TAG_GETCLASS;\n-static char *TAG_GETMETACLASS;\n-static char *TAG_MSGSEND;\n-static char *TAG_MSGSENDSUPER;\n-static char *TAG_EXECCLASS;\n+static const char *TAG_GETCLASS;\n+static const char *TAG_GETMETACLASS;\n+static const char *TAG_MSGSEND;\n+static const char *TAG_MSGSENDSUPER;\n+static const char *TAG_EXECCLASS;\n \n /* Set by `continue_class' and checked by `is_public'.  */\n \n@@ -482,7 +488,7 @@ extern enum debug_info_type write_symbols;\n \n /* Data imported from toplev.c.  */\n \n-extern char *dump_base_name;\n+extern const char *dump_base_name;\n \f\n /* Generate code for GNU or NeXT runtime environment.  */\n \n@@ -529,7 +535,7 @@ static int print_struct_values = 0;\n    an invisible pointer.  Determine at what size structure is the \n    transition point between the two possibilities. */\n \n-void\n+static void\n generate_struct_by_value_array ()\n {\n   tree type;\n@@ -690,7 +696,7 @@ lang_decode_option (argc, argv)\n      int argc;\n      char **argv;\n {\n-  char *p = argv[0];\n+  const char *p = argv[0];\n   if (!strcmp (p, \"-lang-objc\"))\n     doing_objc_thang = 1;\n   else if (!strcmp (p, \"-gen-decls\"))\n@@ -1133,7 +1139,7 @@ static tree\n create_builtin_decl (code, type, name)\n      enum tree_code code;\n      tree type;\n-     char *name;\n+     const char *name;\n {\n   tree decl = build_decl (code, get_identifier (name), type);\n \n@@ -1291,7 +1297,7 @@ synth_module_prologue ()\n static tree\n my_build_string (len, str)\n      int len;\n-     char *str;\n+     const char *str;\n {\n   int wide_flag = 0;\n   tree a_string = build_string (len, str);\n@@ -1998,8 +2004,7 @@ generate_strings ()\n }\n \n static tree\n-build_selector_reference_decl (name)\n-      tree name;\n+build_selector_reference_decl ()\n {\n   tree decl, ident;\n   char buf[256];\n@@ -2220,7 +2225,7 @@ build_selector_reference (ident)\n       chain = &TREE_CHAIN (*chain);\n     }\n \n-  expr = build_selector_reference_decl (ident);\n+  expr = build_selector_reference_decl ();\n \n   *chain = perm_tree_cons (expr, ident, NULL_TREE);\n \n@@ -2231,8 +2236,7 @@ build_selector_reference (ident)\n }\n \n static tree\n-build_class_reference_decl (name)\n-      tree name;\n+build_class_reference_decl ()\n {\n   tree decl, ident;\n   char buf[256];\n@@ -2306,12 +2310,12 @@ get_class_reference (ident)\n \tif (TREE_VALUE (*chain) == ident)\n \t  {\n \t    if (! TREE_PURPOSE (*chain))\n-\t      TREE_PURPOSE (*chain) = build_class_reference_decl (ident);\n+\t      TREE_PURPOSE (*chain) = build_class_reference_decl ();\n \n \t    return TREE_PURPOSE (*chain);\n \t  }\n \n-      decl = build_class_reference_decl (ident);\n+      decl = build_class_reference_decl ();\n       *chain = perm_tree_cons (decl, ident, NULL_TREE);\n       return decl;\n     }\n@@ -2363,16 +2367,15 @@ add_objc_string (ident, section)\n       chain = &TREE_CHAIN (*chain);\n     }\n \n-  decl = build_objc_string_decl (ident, section);\n+  decl = build_objc_string_decl (section);\n \n   *chain = perm_tree_cons (decl, ident, NULL_TREE);\n \n   return build_unary_op (ADDR_EXPR, decl, 1);\n }\n \n static tree\n-build_objc_string_decl (name, section)\n-     tree name;\n+build_objc_string_decl (section)\n      enum string_section section;\n {\n   tree decl, ident;\n@@ -2929,7 +2932,7 @@ encode_method_prototype (method_decl, func_decl)\n static tree\n generate_descriptor_table (type, name, size, list, proto)\n      tree type;\n-     char *name;\n+     const char *name;\n      int size;\n      tree list;\n      tree proto;\n@@ -3574,7 +3577,7 @@ synth_forward_declarations ()\n \n static void\n error_with_ivar (message, decl, rawdecl)\n-     char *message;\n+     const char *message;\n      tree decl;\n      tree rawdecl;\n {\n@@ -3885,7 +3888,7 @@ build_ivar_list_initializer (type, field_decl)\n static tree\n generate_ivars_list (type, name, size, list)\n      tree type;\n-     char *name;\n+     const char *name;\n      int size;\n      tree list;\n {\n@@ -4058,7 +4061,7 @@ build_method_template ()\n static tree\n generate_dispatch_table (type, name, size, list)\n      tree type;\n-     char *name;\n+     const char *name;\n      int size;\n      tree list;\n {\n@@ -4568,14 +4571,14 @@ generate_shared_structures ()\n \n static tree\n synth_id_with_class_suffix (preamble, ctxt)\n-     char *preamble;\n+     const char *preamble;\n      tree ctxt;\n {\n   char *string;\n   if (TREE_CODE (ctxt) == CLASS_IMPLEMENTATION_TYPE\n       || TREE_CODE (ctxt) == CLASS_INTERFACE_TYPE)\n     {\n-      char *class_name\n+      const char *class_name\n \t= IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n       string = (char *) alloca (strlen (preamble) + strlen (class_name) + 3);\n       sprintf (string, \"%s_%s\", preamble,\n@@ -4585,9 +4588,9 @@ synth_id_with_class_suffix (preamble, ctxt)\n \t   || TREE_CODE (ctxt) == CATEGORY_INTERFACE_TYPE)\n     {\n       /* We have a category.  */\n-      char *class_name\n+      const char *class_name\n \t= IDENTIFIER_POINTER (CLASS_NAME (implementation_context));\n-      char *class_super_name\n+      const char *class_super_name\n \t= IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context));\n       string = (char *) alloca (strlen (preamble)\n \t\t\t\t+ strlen (class_name)\n@@ -4597,7 +4600,7 @@ synth_id_with_class_suffix (preamble, ctxt)\n     }\n   else if (TREE_CODE (ctxt) == PROTOCOL_INTERFACE_TYPE)\n     {\n-      char *protocol_name = IDENTIFIER_POINTER (PROTOCOL_NAME (ctxt));\n+      const char *protocol_name = IDENTIFIER_POINTER (PROTOCOL_NAME (ctxt));\n       string\n \t= (char *) alloca (strlen (preamble) + strlen (protocol_name) + 3);\n       sprintf (string, \"%s_%s\", preamble, protocol_name);\n@@ -5401,7 +5404,7 @@ build_encode_expr (type)\n      tree type;\n {\n   tree result;\n-  char *string;\n+  const char *string;\n \n   if (!doing_objc_thang)\n     objc_fatal ();\n@@ -6076,8 +6079,8 @@ check_methods_accessible (chain, context, mtype)\n static void\n check_protocols (proto_list, type, name)\n      tree proto_list;\n-     char *type;\n-     char *name;\n+     const char *type;\n+     const char *name;\n {\n   for ( ; proto_list; proto_list = TREE_CHAIN (proto_list))\n     {\n@@ -6213,7 +6216,8 @@ start_class (code, class_name, super_name, protocol_list)\n \t  && (super_name != CLASS_SUPER_NAME (implementation_template)))\n         {\n \t  tree previous_name = CLASS_SUPER_NAME (implementation_template);\n-          char *name = previous_name ? IDENTIFIER_POINTER (previous_name) : \"\";\n+          const char *name =\n+\t    previous_name ? IDENTIFIER_POINTER (previous_name) : \"\";\n \t  error (\"conflicting super class name `%s'\",\n \t\t IDENTIFIER_POINTER (super_name));\n \t  error (\"previous declaration of `%s'\", name);\n@@ -6412,7 +6416,7 @@ finish_class (class)\n   else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)\n     {\n       tree decl_specs;\n-      char *class_name = IDENTIFIER_POINTER (CLASS_NAME (class));\n+      const char *class_name = IDENTIFIER_POINTER (CLASS_NAME (class));\n       char *string = (char *) alloca (strlen (class_name) + 3);\n \n       /* extern struct objc_object *_<my_name>; */\n@@ -6535,7 +6539,7 @@ encode_pointer (type, curtype, format)\n       if (TYPE_NAME (pointer_to)\n \t  && TREE_CODE (TYPE_NAME (pointer_to)) == IDENTIFIER_NODE)\n \t{\n-\t  char *name = IDENTIFIER_POINTER (TYPE_NAME (pointer_to));\n+\t  const char *name = IDENTIFIER_POINTER (TYPE_NAME (pointer_to));\n \n \t  if (strcmp (name, TAG_OBJECT) == 0) /* '@' */\n \t    {\n@@ -6770,9 +6774,8 @@ encode_aggregate (type, curtype, format)\n    hand generating this string (which is tedious).  */\n \n static void\n-encode_bitfield (width, format)\n+encode_bitfield (width)\n      int width;\n-     int format;\n {\n   char buffer[40];\n   sprintf (buffer, \"b%d\", width);\n@@ -6930,11 +6933,11 @@ encode_field_decl (field_decl, curtype, format)\n   if (flag_next_runtime)\n     {\n       if (DECL_BIT_FIELD (field_decl))\n-\tencode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n+\tencode_bitfield (DECL_FIELD_SIZE (field_decl));\n       else if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n \t       && DECL_FIELD_SIZE (field_decl)\n \t       && TYPE_MODE (type) > DECL_MODE (field_decl))\n-\tencode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n+\tencode_bitfield (DECL_FIELD_SIZE (field_decl));\n       else\n \tencode_type (TREE_TYPE (field_decl), curtype, format);\n     }\n@@ -6972,7 +6975,7 @@ expr_last (complex_expr)\n \n tree\n maybe_objc_method_name (decl)\n-      tree decl;\n+      tree decl ATTRIBUTE_UNUSED;\n {\n   if (method_context)\n     return METHOD_SEL_NAME (method_context);\n@@ -7076,7 +7079,7 @@ start_method_def (method)\n \n static void\n warn_with_method (message, mtype, method)\n-     char *message;\n+     const char *message;\n      int mtype;\n      tree method;\n {\n@@ -7159,7 +7162,8 @@ really_start_method (method, parmlist)\n {\n   tree sc_spec, ret_spec, ret_decl, decl_specs;\n   tree method_decl, method_id;\n-  char *buf, *sel_name, *class_name, *cat_name;\n+  const char *sel_name, *class_name, *cat_name;\n+  char *buf;\n \n   /* Synth the storage class & assemble the return type.  */\n   sc_spec = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n@@ -7575,7 +7579,7 @@ static char *\n gen_declarator (decl, buf, name)\n      tree decl;\n      char *buf;\n-     char *name;\n+     const char *name;\n {\n   if (decl)\n     {\n@@ -7977,9 +7981,9 @@ gen_declaration (atype_or_adecl, buf)\n \t  || TREE_CODE (atype_or_adecl) == PARM_DECL\n \t  || TREE_CODE (atype_or_adecl) == FUNCTION_DECL)\n \t{\n-\t  char *decl_name = (DECL_NAME (atype_or_adecl)\n-\t\t\t     ? IDENTIFIER_POINTER (DECL_NAME (atype_or_adecl))\n-\t\t\t     : \"\");\n+\t  const char *decl_name =\n+\t    (DECL_NAME (atype_or_adecl)\n+\t     ? IDENTIFIER_POINTER (DECL_NAME (atype_or_adecl)) : \"\");\n \n \t  if (declarator)\n \t    {\n@@ -8074,7 +8078,7 @@ dump_interface (fp, chain)\n      tree chain;\n {\n   char *buf = (char *)xmalloc (256);\n-  char *my_name = IDENTIFIER_POINTER (CLASS_NAME (chain));\n+  const char *my_name = IDENTIFIER_POINTER (CLASS_NAME (chain));\n   tree ivar_decls = CLASS_RAW_IVARS (chain);\n   tree nst_methods = CLASS_NST_METHODS (chain);\n   tree cls_methods = CLASS_CLS_METHODS (chain);\n@@ -8083,7 +8087,7 @@ dump_interface (fp, chain)\n \n   if (CLASS_SUPER_NAME (chain))\n     {\n-      char *super_name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));\n+      const char *super_name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));\n       fprintf (fp, \" : %s\\n\", super_name);\n     }\n   else\n@@ -8178,7 +8182,7 @@ objc_demangle (mangled)\n static const char *\n objc_printable_name (decl, kind)\n      tree decl;\n-     char **kind;\n+     int kind ATTRIBUTE_UNUSED;\n {\n   return objc_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)));\n }\n@@ -8193,17 +8197,15 @@ init_objc ()\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n \n-  bcopy (objc_tree_code_type,\n-\t tree_code_type + (int) LAST_CODE,\n-\t (int) LAST_OBJC_TREE_CODE - (int) LAST_CODE);\n-  bcopy ((char *) objc_tree_code_length,\n-\t (char *) (tree_code_length + (int) LAST_CODE),\n-\t (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE)\n-\t  * sizeof (int)));\n-  bcopy ((char *) objc_tree_code_name,\n-\t (char *) (tree_code_name + (int) LAST_CODE),\n-\t (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE)\n-\t  * sizeof (char *)));\n+  memcpy (tree_code_type + (int) LAST_CODE,\n+\t  objc_tree_code_type,\n+\t  (int) LAST_OBJC_TREE_CODE - (int) LAST_CODE);\n+  memcpy (tree_code_length + (int) LAST_CODE,\n+\t  objc_tree_code_length,\n+\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE) * sizeof (int)));\n+  memcpy (tree_code_name + (int) LAST_CODE,\n+\t  objc_tree_code_name,\n+\t  (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE) * sizeof (char *)));\n \n   errbuf = (char *)xmalloc (BUFSIZE);\n   hash_init ();\n@@ -8378,7 +8380,7 @@ static void\n handle_class_ref (chain)\n      tree chain;\n {\n-  char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));\n+  const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));\n   if (! flag_next_runtime)\n     {\n       tree decl;\n@@ -8430,7 +8432,8 @@ handle_impent (impent)\n \n   if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n     {\n-      char *class_name = IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+      const char *class_name =\n+\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n       char *string = (char *) alloca (strlen (class_name) + 30);\n \n       if (flag_next_runtime)\n@@ -8456,9 +8459,10 @@ handle_impent (impent)\n \n   else if (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n-      char *class_name = IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n-      char *class_super_name\n-\t= IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n+      const char *class_name =\n+\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+      const char *class_super_name =\n+\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n       char *string = (char *) alloca (strlen (class_name)\n \t\t\t\t      + strlen (class_super_name) + 30);\n "}]}