{"sha": "b38a4bd10249b5070ea1f4708a0fd228df268c26", "node_id": "C_kwDOANBUbNoAKGIzOGE0YmQxMDI0OWI1MDcwZWExZjQ3MDhhMGZkMjI4ZGYyNjhjMjY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-30T07:30:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-30T07:30:18Z"}, "message": "openmp: Add omp_aligned_{,c}alloc and omp_{c,re}alloc\n\nThis patch adds new OpenMP 5.1 allocator entrypoints and in addition to that\nfixes an omp_alloc bug which is hard to test for - if the first allocator\nfails but has a larger alignment trait and has a fallback allocator, either\nthe default behavior or a user fallback, then the extra alignment will be used\neven in the fallback allocation, rather than just starting with whatever\nalignment has been requested (in GOMP_alloc or the minimum one in omp_alloc).\n\nJonathan's comment on IRC this morning made me realize that I should add\nalloc_align attributes to 2 of the prototypes and I still need to add testsuite\ncoverage for omp_realloc, will do that in a follow-up.\n\n2021-09-30  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp.h.in (omp_aligned_alloc, omp_calloc, omp_aligned_calloc,\n\tomp_realloc): New prototypes.\n\t(omp_alloc): Move after omp_free prototype, add __malloc__ (omp_free)\n\tattribute.\n\t* allocator.c: Include string.h.\n\t(omp_aligned_alloc): No longer static, add ialias.  Add new_alignment\n\tvariable and use it instead of alignment so that when retrying the old\n\talignment is used again.  Don't retry if new alignment is the same\n\tas old alignment, unless allocator had pool size.\n\t(omp_alloc, GOMP_alloc, GOMP_free): Use ialias_call.\n\t(omp_aligned_calloc, omp_calloc, omp_realloc): New functions.\n\t* libgomp.map (OMP_5.0.2): Export omp_aligned_alloc, omp_calloc,\n\tomp_aligned_calloc and omp_realloc.\n\t* testsuite/libgomp.c-c++-common/alloc-4.c (main): Add\n\tomp_aligned_alloc, omp_calloc and omp_aligned_calloc tests.\n\t* testsuite/libgomp.c-c++-common/alloc-5.c: New test.\n\t* testsuite/libgomp.c-c++-common/alloc-6.c: New test.\n\t* testsuite/libgomp.c-c++-common/alloc-7.c: New test.\n\t* testsuite/libgomp.c-c++-common/alloc-8.c: New test.", "tree": {"sha": "432fb7276617f8c2caae8723fa38e2f8a2b44e06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/432fb7276617f8c2caae8723fa38e2f8a2b44e06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38a4bd10249b5070ea1f4708a0fd228df268c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38a4bd10249b5070ea1f4708a0fd228df268c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38a4bd10249b5070ea1f4708a0fd228df268c26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38a4bd10249b5070ea1f4708a0fd228df268c26/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "257fd0333fe9fe5b0b4f9fddde50a09afa82b2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257fd0333fe9fe5b0b4f9fddde50a09afa82b2ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257fd0333fe9fe5b0b4f9fddde50a09afa82b2ef"}], "stats": {"total": 1030, "additions": 1010, "deletions": 20}, "files": [{"sha": "dce600f5bd7442334b9ff0690594753babea4fff", "filename": "libgomp/allocator.c", "status": "modified", "additions": 382, "deletions": 16, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Fallocator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Fallocator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fallocator.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -30,6 +30,7 @@\n #define _GNU_SOURCE\n #include \"libgomp.h\"\n #include <stdlib.h>\n+#include <string.h>\n \n #define omp_max_predefined_alloc omp_thread_mem_alloc\n \n@@ -205,18 +206,19 @@ omp_destroy_allocator (omp_allocator_handle_t allocator)\n ialias (omp_init_allocator)\n ialias (omp_destroy_allocator)\n \n-static void *\n+void *\n omp_aligned_alloc (size_t alignment, size_t size,\n \t\t   omp_allocator_handle_t allocator)\n {\n   struct omp_allocator_data *allocator_data;\n-  size_t new_size;\n+  size_t new_size, new_alignment;\n   void *ptr, *ret;\n \n   if (__builtin_expect (size == 0, 0))\n     return NULL;\n \n retry:\n+  new_alignment = alignment;\n   if (allocator == omp_null_allocator)\n     {\n       struct gomp_thread *thr = gomp_thread ();\n@@ -228,19 +230,19 @@ omp_aligned_alloc (size_t alignment, size_t size,\n   if (allocator > omp_max_predefined_alloc)\n     {\n       allocator_data = (struct omp_allocator_data *) allocator;\n-      if (alignment < allocator_data->alignment)\n-\talignment = allocator_data->alignment;\n+      if (new_alignment < allocator_data->alignment)\n+\tnew_alignment = allocator_data->alignment;\n     }\n   else\n     {\n       allocator_data = NULL;\n-      if (alignment < sizeof (void *))\n-\talignment = sizeof (void *);\n+      if (new_alignment < sizeof (void *))\n+\tnew_alignment = sizeof (void *);\n     }\n \n   new_size = sizeof (struct omp_mem_header);\n-  if (alignment > sizeof (void *))\n-    new_size += alignment - sizeof (void *);\n+  if (new_alignment > sizeof (void *))\n+    new_size += new_alignment - sizeof (void *);\n   if (__builtin_add_overflow (size, new_size, &new_size))\n     goto fail;\n \n@@ -300,10 +302,11 @@ omp_aligned_alloc (size_t alignment, size_t size,\n \tgoto fail;\n     }\n \n-  if (alignment > sizeof (void *))\n+  if (new_alignment > sizeof (void *))\n     ret = (void *) (((uintptr_t) ptr\n \t\t     + sizeof (struct omp_mem_header)\n-\t\t     + alignment - sizeof (void *)) & ~(alignment - 1));\n+\t\t     + new_alignment - sizeof (void *))\n+\t\t    & ~(new_alignment - 1));\n   else\n     ret = (char *) ptr + sizeof (struct omp_mem_header);\n   ((struct omp_mem_header *) ret)[-1].ptr = ptr;\n@@ -317,7 +320,7 @@ omp_aligned_alloc (size_t alignment, size_t size,\n       switch (allocator_data->fallback)\n \t{\n \tcase omp_atv_default_mem_fb:\n-\t  if (alignment > sizeof (void *)\n+\t  if ((new_alignment > sizeof (void *) && new_alignment > alignment)\n \t      || (allocator_data\n \t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n \t    {\n@@ -326,7 +329,7 @@ omp_aligned_alloc (size_t alignment, size_t size,\n \t    }\n \t  /* Otherwise, we've already performed default mem allocation\n \t     and if that failed, it won't succeed again (unless it was\n-\t     intermitent.  Return NULL then, as that is the fallback.  */\n+\t     intermittent.  Return NULL then, as that is the fallback.  */\n \t  break;\n \tcase omp_atv_null_fb:\n \t  break;\n@@ -342,10 +345,12 @@ omp_aligned_alloc (size_t alignment, size_t size,\n   return NULL;\n }\n \n+ialias (omp_aligned_alloc)\n+\n void *\n omp_alloc (size_t size, omp_allocator_handle_t allocator)\n {\n-  return omp_aligned_alloc (1, size, allocator);\n+  return ialias_call (omp_aligned_alloc) (1, size, allocator);\n }\n \n /* Like omp_aligned_alloc, but apply on top of that:\n@@ -355,8 +360,9 @@ omp_alloc (size_t size, omp_allocator_handle_t allocator)\n void *\n GOMP_alloc (size_t alignment, size_t size, uintptr_t allocator)\n {\n-  void *ret = omp_aligned_alloc (alignment, size,\n-\t\t\t\t (omp_allocator_handle_t) allocator);\n+  void *ret\n+    = ialias_call (omp_aligned_alloc) (alignment, size,\n+\t\t\t\t       (omp_allocator_handle_t) allocator);\n   if (__builtin_expect (ret == NULL, 0) && size)\n     gomp_fatal (\"Out of memory allocating %lu bytes\",\n \t\t(unsigned long) size);\n@@ -396,5 +402,365 @@ ialias (omp_free)\n void\n GOMP_free (void *ptr, uintptr_t allocator)\n {\n-  return omp_free (ptr, (omp_allocator_handle_t) allocator);\n+  return ialias_call (omp_free) (ptr, (omp_allocator_handle_t) allocator);\n+}\n+\n+void *\n+omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n+\t\t    omp_allocator_handle_t allocator)\n+{\n+  struct omp_allocator_data *allocator_data;\n+  size_t new_size, size_temp, new_alignment;\n+  void *ptr, *ret;\n+\n+  if (__builtin_expect (size == 0 || nmemb == 0, 0))\n+    return NULL;\n+\n+retry:\n+  new_alignment = alignment;\n+  if (allocator == omp_null_allocator)\n+    {\n+      struct gomp_thread *thr = gomp_thread ();\n+      if (thr->ts.def_allocator == omp_null_allocator)\n+\tthr->ts.def_allocator = gomp_def_allocator;\n+      allocator = (omp_allocator_handle_t) thr->ts.def_allocator;\n+    }\n+\n+  if (allocator > omp_max_predefined_alloc)\n+    {\n+      allocator_data = (struct omp_allocator_data *) allocator;\n+      if (new_alignment < allocator_data->alignment)\n+\tnew_alignment = allocator_data->alignment;\n+    }\n+  else\n+    {\n+      allocator_data = NULL;\n+      if (new_alignment < sizeof (void *))\n+\tnew_alignment = sizeof (void *);\n+    }\n+\n+  new_size = sizeof (struct omp_mem_header);\n+  if (new_alignment > sizeof (void *))\n+    new_size += new_alignment - sizeof (void *);\n+  if (__builtin_mul_overflow (size, nmemb, &size_temp))\n+    goto fail;\n+  if (__builtin_add_overflow (size_temp, new_size, &new_size))\n+    goto fail;\n+\n+  if (__builtin_expect (allocator_data\n+\t\t\t&& allocator_data->pool_size < ~(uintptr_t) 0, 0))\n+    {\n+      uintptr_t used_pool_size;\n+      if (new_size > allocator_data->pool_size)\n+\tgoto fail;\n+#ifdef HAVE_SYNC_BUILTINS\n+      used_pool_size = __atomic_load_n (&allocator_data->used_pool_size,\n+\t\t\t\t\tMEMMODEL_RELAXED);\n+      do\n+\t{\n+\t  uintptr_t new_pool_size;\n+\t  if (__builtin_add_overflow (used_pool_size, new_size,\n+\t\t\t\t      &new_pool_size)\n+\t      || new_pool_size > allocator_data->pool_size)\n+\t    goto fail;\n+\t  if (__atomic_compare_exchange_n (&allocator_data->used_pool_size,\n+\t\t\t\t\t   &used_pool_size, new_pool_size,\n+\t\t\t\t\t   true, MEMMODEL_RELAXED,\n+\t\t\t\t\t   MEMMODEL_RELAXED))\n+\t    break;\n+\t}\n+      while (1);\n+#else\n+      gomp_mutex_lock (&allocator_data->lock);\n+      if (__builtin_add_overflow (allocator_data->used_pool_size, new_size,\n+\t\t\t\t  &used_pool_size)\n+\t  || used_pool_size > allocator_data->pool_size)\n+\t{\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+\t  goto fail;\n+\t}\n+      allocator_data->used_pool_size = used_pool_size;\n+      gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+      ptr = calloc (1, new_size);\n+      if (ptr == NULL)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  __atomic_add_fetch (&allocator_data->used_pool_size, -new_size,\n+\t\t\t      MEMMODEL_RELAXED);\n+#else\n+\t  gomp_mutex_lock (&allocator_data->lock);\n+\t  allocator_data->used_pool_size -= new_size;\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+\t  goto fail;\n+\t}\n+    }\n+  else\n+    {\n+      ptr = calloc (1, new_size);\n+      if (ptr == NULL)\n+\tgoto fail;\n+    }\n+\n+  if (new_alignment > sizeof (void *))\n+    ret = (void *) (((uintptr_t) ptr\n+\t\t     + sizeof (struct omp_mem_header)\n+\t\t     + new_alignment - sizeof (void *))\n+\t\t    & ~(new_alignment - 1));\n+  else\n+    ret = (char *) ptr + sizeof (struct omp_mem_header);\n+  ((struct omp_mem_header *) ret)[-1].ptr = ptr;\n+  ((struct omp_mem_header *) ret)[-1].size = new_size;\n+  ((struct omp_mem_header *) ret)[-1].allocator = allocator;\n+  return ret;\n+\n+fail:\n+  if (allocator_data)\n+    {\n+      switch (allocator_data->fallback)\n+\t{\n+\tcase omp_atv_default_mem_fb:\n+\t  if ((new_alignment > sizeof (void *) && new_alignment > alignment)\n+\t      || (allocator_data\n+\t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n+\t    {\n+\t      allocator = omp_default_mem_alloc;\n+\t      goto retry;\n+\t    }\n+\t  /* Otherwise, we've already performed default mem allocation\n+\t     and if that failed, it won't succeed again (unless it was\n+\t     intermittent.  Return NULL then, as that is the fallback.  */\n+\t  break;\n+\tcase omp_atv_null_fb:\n+\t  break;\n+\tdefault:\n+\tcase omp_atv_abort_fb:\n+\t  gomp_fatal (\"Out of memory allocating %lu bytes\",\n+\t\t      (unsigned long) (size * nmemb));\n+\tcase omp_atv_allocator_fb:\n+\t  allocator = allocator_data->fb_data;\n+\t  goto retry;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+ialias (omp_aligned_calloc)\n+\n+void *\n+omp_calloc (size_t nmemb, size_t size, omp_allocator_handle_t allocator)\n+{\n+  return ialias_call (omp_aligned_calloc) (1, nmemb, size, allocator);\n+}\n+\n+void *\n+omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n+\t     omp_allocator_handle_t free_allocator)\n+{\n+  struct omp_allocator_data *allocator_data, *free_allocator_data;\n+  size_t new_size, old_size, new_alignment, old_alignment;\n+  void *new_ptr, *ret;\n+  struct omp_mem_header *data;\n+\n+  if (__builtin_expect (ptr == NULL, 0))\n+    return ialias_call (omp_aligned_alloc) (1, size, allocator);\n+\n+  if (__builtin_expect (size == 0, 0))\n+    {\n+      ialias_call (omp_free) (ptr, free_allocator);\n+      return NULL;\n+    }\n+\n+  data = &((struct omp_mem_header *) ptr)[-1];\n+  free_allocator = data->allocator;\n+\n+retry:\n+  new_alignment = sizeof (void *);\n+  if (allocator == omp_null_allocator)\n+    allocator = free_allocator;\n+\n+  if (allocator > omp_max_predefined_alloc)\n+    {\n+      allocator_data = (struct omp_allocator_data *) allocator;\n+      if (new_alignment < allocator_data->alignment)\n+\tnew_alignment = allocator_data->alignment;\n+    }\n+  else\n+    allocator_data = NULL;\n+  if (free_allocator > omp_max_predefined_alloc)\n+    free_allocator_data = (struct omp_allocator_data *) free_allocator;\n+  else\n+    free_allocator_data = NULL;\n+  old_alignment = (uintptr_t) ptr - (uintptr_t) (data->ptr);\n+\n+  new_size = sizeof (struct omp_mem_header);\n+  if (new_alignment > sizeof (void *))\n+    new_size += new_alignment - sizeof (void *);\n+  if (__builtin_add_overflow (size, new_size, &new_size))\n+    goto fail;\n+  old_size = data->size;\n+\n+  if (__builtin_expect (allocator_data\n+\t\t\t&& allocator_data->pool_size < ~(uintptr_t) 0, 0))\n+    {\n+      uintptr_t used_pool_size;\n+      size_t prev_size = 0;\n+      /* Check if we can use realloc.  Don't use it if extra alignment\n+\t was used previously or newly, because realloc might return a pointer\n+\t with different alignment and then we'd need to memmove the data\n+\t again.  */\n+      if (free_allocator_data\n+\t  && free_allocator_data == allocator_data\n+\t  && new_alignment == sizeof (void *)\n+\t  && old_alignment == sizeof (struct omp_mem_header))\n+\tprev_size = old_size;\n+      if (new_size > prev_size\n+\t  && new_size - prev_size > allocator_data->pool_size)\n+\tgoto fail;\n+#ifdef HAVE_SYNC_BUILTINS\n+      used_pool_size = __atomic_load_n (&allocator_data->used_pool_size,\n+\t\t\t\t\tMEMMODEL_RELAXED);\n+      do\n+\t{\n+\t  uintptr_t new_pool_size;\n+\t  if (new_size > prev_size)\n+\t    {\n+\t      if (__builtin_add_overflow (used_pool_size, new_size - prev_size,\n+\t\t\t\t\t  &new_pool_size)\n+\t\t  || new_pool_size > allocator_data->pool_size)\n+\t\tgoto fail;\n+\t    }\n+\t  else\n+\t    new_pool_size = used_pool_size + new_size - prev_size;\n+\t  if (__atomic_compare_exchange_n (&allocator_data->used_pool_size,\n+\t\t\t\t\t   &used_pool_size, new_pool_size,\n+\t\t\t\t\t   true, MEMMODEL_RELAXED,\n+\t\t\t\t\t   MEMMODEL_RELAXED))\n+\t    break;\n+\t}\n+      while (1);\n+#else\n+      gomp_mutex_lock (&allocator_data->lock);\n+      if (new_size > prev_size)\n+\t{\n+\t  if (__builtin_add_overflow (allocator_data->used_pool_size,\n+\t\t\t\t      new_size - prev_size,\n+\t\t\t\t      &used_pool_size)\n+\t      || used_pool_size > allocator_data->pool_size)\n+\t    {\n+\t      gomp_mutex_unlock (&allocator_data->lock);\n+\t      goto fail;\n+\t    }\n+\t}\n+      else\n+\tused_pool_size = (allocator_data->used_pool_size\n+\t\t\t  + new_size - prev_size);\n+      allocator_data->used_pool_size = used_pool_size;\n+      gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+      if (prev_size)\n+\tnew_ptr = realloc (data->ptr, new_size);\n+      else\n+\tnew_ptr = malloc (new_size);\n+      if (new_ptr == NULL)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  __atomic_add_fetch (&allocator_data->used_pool_size,\n+\t\t\t      prev_size - new_size,\n+\t\t\t      MEMMODEL_RELAXED);\n+#else\n+\t  gomp_mutex_lock (&allocator_data->lock);\n+\t  allocator_data->used_pool_size -= new_size - prev_size;\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+\t  goto fail;\n+\t}\n+      else if (prev_size)\n+\t{\n+\t  ret = (char *) new_ptr + sizeof (struct omp_mem_header);\n+\t  ((struct omp_mem_header *) ret)[-1].ptr = new_ptr;\n+\t  ((struct omp_mem_header *) ret)[-1].size = new_size;\n+\t  ((struct omp_mem_header *) ret)[-1].allocator = allocator;\n+\t  return ret;\n+\t}\n+    }\n+  else if (new_alignment == sizeof (void *)\n+\t   && old_alignment == sizeof (struct omp_mem_header)\n+\t   && (free_allocator_data == NULL\n+\t       || free_allocator_data->pool_size == ~(uintptr_t) 0))\n+    {\n+      new_ptr = realloc (data->ptr, new_size);\n+      if (new_ptr == NULL)\n+\tgoto fail;\n+      ret = (char *) new_ptr + sizeof (struct omp_mem_header);\n+      ((struct omp_mem_header *) ret)[-1].ptr = new_ptr;\n+      ((struct omp_mem_header *) ret)[-1].size = new_size;\n+      ((struct omp_mem_header *) ret)[-1].allocator = allocator;\n+      return ret;\n+    }\n+  else\n+    {\n+      new_ptr = malloc (new_size);\n+      if (new_ptr == NULL)\n+\tgoto fail;\n+    }\n+\n+  if (new_alignment > sizeof (void *))\n+    ret = (void *) (((uintptr_t) new_ptr\n+\t\t     + sizeof (struct omp_mem_header)\n+\t\t     + new_alignment - sizeof (void *))\n+\t\t    & ~(new_alignment - 1));\n+  else\n+    ret = (char *) new_ptr + sizeof (struct omp_mem_header);\n+  ((struct omp_mem_header *) ret)[-1].ptr = new_ptr;\n+  ((struct omp_mem_header *) ret)[-1].size = new_size;\n+  ((struct omp_mem_header *) ret)[-1].allocator = allocator;\n+  if (old_size - old_alignment < size)\n+    size = old_size - old_alignment;\n+  memcpy (ret, ptr, size);\n+  if (__builtin_expect (free_allocator_data\n+\t\t\t&& free_allocator_data->pool_size < ~(uintptr_t) 0, 0))\n+    {\n+#ifdef HAVE_SYNC_BUILTINS\n+      __atomic_add_fetch (&free_allocator_data->used_pool_size, -data->size,\n+\t\t\t  MEMMODEL_RELAXED);\n+#else\n+      gomp_mutex_lock (&free_allocator_data->lock);\n+      free_allocator_data->used_pool_size -= data->size;\n+      gomp_mutex_unlock (&free_allocator_data->lock);\n+#endif\n+    }\n+  free (data->ptr);\n+  return ret;\n+\n+fail:\n+  if (allocator_data)\n+    {\n+      switch (allocator_data->fallback)\n+\t{\n+\tcase omp_atv_default_mem_fb:\n+\t  if (new_alignment > sizeof (void *)\n+\t      || (allocator_data\n+\t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n+\t    {\n+\t      allocator = omp_default_mem_alloc;\n+\t      goto retry;\n+\t    }\n+\t  /* Otherwise, we've already performed default mem allocation\n+\t     and if that failed, it won't succeed again (unless it was\n+\t     intermittent.  Return NULL then, as that is the fallback.  */\n+\t  break;\n+\tcase omp_atv_null_fb:\n+\t  break;\n+\tdefault:\n+\tcase omp_atv_abort_fb:\n+\t  gomp_fatal (\"Out of memory allocating %lu bytes\",\n+\t\t      (unsigned long) size);\n+\tcase omp_atv_allocator_fb:\n+\t  allocator = allocator_data->fb_data;\n+\t  goto retry;\n+\t}\n+    }\n+  return NULL;\n }"}, {"sha": "460a7a4a34bee53f6c9e140ab690c5de374de0e3", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -203,6 +203,10 @@ OMP_5.0.2 {\n   global:\n \tomp_get_device_num;\n \tomp_get_device_num_;\n+\tomp_aligned_alloc;\n+\tomp_calloc;\n+\tomp_aligned_calloc;\n+\tomp_realloc;\n } OMP_5.0.1;\n \n OMP_5.1 {"}, {"sha": "e39988e7cbd34cc715c9c042c24533a1c44ec9e2", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -295,12 +295,31 @@ extern omp_allocator_handle_t omp_init_allocator (omp_memspace_handle_t,\n extern void omp_destroy_allocator (omp_allocator_handle_t) __GOMP_NOTHROW;\n extern void omp_set_default_allocator (omp_allocator_handle_t) __GOMP_NOTHROW;\n extern omp_allocator_handle_t omp_get_default_allocator (void) __GOMP_NOTHROW;\n-extern void *omp_alloc (__SIZE_TYPE__,\n-\t\t\tomp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n-  __GOMP_NOTHROW __attribute__((__malloc__, __alloc_size__ (1)));\n extern void omp_free (void *,\n \t\t      omp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n   __GOMP_NOTHROW;\n+extern void *omp_alloc (__SIZE_TYPE__,\n+\t\t\tomp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n+  __GOMP_NOTHROW __attribute__((__malloc__, __malloc__ (omp_free),\n+\t\t\t\t__alloc_size__ (1)));\n+extern void *omp_aligned_alloc (__SIZE_TYPE__, __SIZE_TYPE__,\n+\t\t\t\tomp_allocator_handle_t\n+\t\t\t\t__GOMP_DEFAULT_NULL_ALLOCATOR)\n+  __GOMP_NOTHROW __attribute__((__malloc__, __malloc__ (omp_free),\n+\t\t\t\t__alloc_size__ (2)));\n+extern void *omp_calloc (__SIZE_TYPE__, __SIZE_TYPE__,\n+\t\t\t omp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n+  __GOMP_NOTHROW __attribute__((__malloc__, __malloc__ (omp_free),\n+\t\t\t\t__alloc_size__ (1, 2)));\n+extern void *omp_aligned_calloc (__SIZE_TYPE__, __SIZE_TYPE__, __SIZE_TYPE__,\n+\t\t\t\t omp_allocator_handle_t\n+\t\t\t\t __GOMP_DEFAULT_NULL_ALLOCATOR)\n+  __GOMP_NOTHROW __attribute__((__malloc__, __malloc__ (omp_free),\n+\t\t\t\t__alloc_size__ (2, 3)));\n+extern void *omp_realloc (void *, __SIZE_TYPE__,\n+\t\t\t  omp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR,\n+\t\t\t  omp_allocator_handle_t __GOMP_DEFAULT_NULL_ALLOCATOR)\n+  __GOMP_NOTHROW __attribute__((__malloc__ (omp_free), __alloc_size__ (2)));\n \n extern void omp_display_env (int) __GOMP_NOTHROW;\n "}, {"sha": "67ba1cda083969c01559689090df182905c61c05", "filename": "libgomp/testsuite/libgomp.c-c++-common/alloc-4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-4.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -12,12 +12,30 @@ main ()\n \n   if (omp_alloc (0, omp_null_allocator) != NULL)\n     abort ();\n+  if (omp_aligned_alloc (64, 0, omp_null_allocator) != NULL)\n+    abort ();\n+  if (omp_calloc (0, 0, omp_null_allocator) != NULL\n+      || omp_calloc (32, 0, omp_null_allocator) != NULL\n+      || omp_calloc (0, 64, omp_null_allocator) != NULL)\n+    abort ();\n+  if (omp_aligned_calloc (32, 0, 0, omp_null_allocator) != NULL\n+      || omp_aligned_calloc (64, 32, 0, omp_null_allocator) != NULL\n+      || omp_aligned_calloc (16, 0, 64, omp_null_allocator) != NULL)\n+    abort ();\n   a = omp_init_allocator (omp_default_mem_space, 2, traits);\n   if (a != omp_null_allocator)\n     {\n       if (omp_alloc (0, a) != NULL\n \t  || omp_alloc (0, a) != NULL\n-\t  || omp_alloc (0, a) != NULL)\n+\t  || omp_alloc (0, a) != NULL\n+\t  || omp_aligned_alloc (16, 0, a) != NULL\n+\t  || omp_aligned_alloc (128, 0, a) != NULL\n+\t  || omp_calloc (0, 0, a) != NULL\n+\t  || omp_calloc (32, 0, a) != NULL\n+\t  || omp_calloc (0, 64, a) != NULL\n+\t  || omp_aligned_calloc (32, 0, 0, a) != NULL\n+\t  || omp_aligned_calloc (64, 32, 0, a) != NULL\n+\t  || omp_aligned_calloc (16, 0, 64, a) != NULL)\n \tabort ();\n       omp_destroy_allocator (a);\n     }"}, {"sha": "8b4a489a92bdc469f479e55b495d499a3edd3962", "filename": "libgomp/testsuite/libgomp.c-c++-common/alloc-5.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-5.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -0,0 +1,159 @@\n+#include <omp.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+const omp_alloctrait_t traits2[]\n+= { { omp_atk_alignment, 16 },\n+    { omp_atk_sync_hint, omp_atv_default },\n+    { omp_atk_access, omp_atv_default },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_default_mem_fb },\n+    { omp_atk_partition, omp_atv_environment } };\n+omp_alloctrait_t traits3[]\n+= { { omp_atk_sync_hint, omp_atv_uncontended },\n+    { omp_atk_alignment, 32 },\n+    { omp_atk_access, omp_atv_all },\n+    { omp_atk_pool_size, 512 },\n+    { omp_atk_fallback, omp_atv_allocator_fb },\n+    { omp_atk_fb_data, 0 },\n+    { omp_atk_partition, omp_atv_default } };\n+const omp_alloctrait_t traits4[]\n+= { { omp_atk_alignment, 128 },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_null_fb } };\n+\n+int\n+main ()\n+{\n+  int *volatile p = (int *) omp_aligned_alloc (sizeof (int), 3 * sizeof (int), omp_default_mem_alloc);\n+  int *volatile q;\n+  int *volatile r;\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb },\n+\t{ omp_atk_pool_size, 4096 } };\n+  omp_allocator_handle_t a, a2;\n+\n+  if ((((uintptr_t) p) % __alignof (int)) != 0)\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  p[2] = 3;\n+  omp_free (p, omp_default_mem_alloc);\n+  p = (int *) omp_aligned_alloc (2 * sizeof (int), 2 * sizeof (int), omp_default_mem_alloc);\n+  if ((((uintptr_t) p) % (2 * sizeof (int))) != 0)\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  p = (int *) omp_aligned_alloc (1, sizeof (int), omp_null_allocator);\n+  if ((((uintptr_t) p) % __alignof (int)) != 0)\n+    abort ();\n+  p[0] = 3;\n+  omp_free (p, omp_get_default_allocator ());\n+\n+  a = omp_init_allocator (omp_default_mem_space, 3, traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_aligned_alloc (32, 3072, a);\n+  if ((((uintptr_t) p) % 64) != 0)\n+    abort ();\n+  p[0] = 1;\n+  p[3071 / sizeof (int)] = 2;\n+  if (omp_aligned_alloc (8, 3072, a) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  p = (int *) omp_aligned_alloc (128, 3072, a);\n+  if ((((uintptr_t) p) % 128) != 0)\n+    abort ();\n+  p[0] = 3;\n+  p[3071 / sizeof (int)] = 4;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (a);\n+  if (omp_get_default_allocator () != a)\n+    abort ();\n+  p = (int *) omp_aligned_alloc (64, 3072, omp_null_allocator);\n+  if (omp_aligned_alloc (8, 3072, omp_null_allocator) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits2) / sizeof (traits2[0]),\n+\t\t\t  traits2);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_aligned_alloc (4, 420, a2);\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_aligned_alloc (8, 768, a2);\n+  if ((((uintptr_t) q) % 16) != 0)\n+    abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  r = (int *) omp_aligned_alloc (8, 512, a2);\n+  if ((((uintptr_t) r) % 8) != 0)\n+    abort ();\n+  r[0] = 9;\n+  r[511 / sizeof (int)] = 10;\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, a2);\n+  omp_free (r, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits4) / sizeof (traits4[0]),\n+\t\t\t  traits4);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (a2);\n+#ifdef __cplusplus\n+  p = static_cast <int *> (omp_aligned_alloc (4, 420));\n+#else\n+  p = (int *) omp_aligned_alloc (4, 420, omp_null_allocator);\n+#endif\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_aligned_alloc (64, 768, omp_null_allocator);\n+  if ((((uintptr_t) q) % 128) != 0)\n+    abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  if (omp_aligned_alloc (8, 768, omp_null_allocator) != NULL)\n+    abort ();\n+#ifdef __cplusplus\n+  omp_free (p);\n+  omp_free (q);\n+  omp_free (NULL);\n+#else\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, omp_null_allocator);\n+  omp_free (NULL, omp_null_allocator);\n+#endif\n+  omp_free (NULL, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}, {"sha": "be571b7ecea6af8c863c95ca7ecd4ed94d45615e", "filename": "libgomp/testsuite/libgomp.c-c++-common/alloc-6.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-6.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -0,0 +1,58 @@\n+#include <omp.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+const omp_alloctrait_t traits[]\n+= { { omp_atk_alignment, 16 },\n+    { omp_atk_sync_hint, omp_atv_default },\n+    { omp_atk_access, omp_atv_default },\n+    { omp_atk_fallback, omp_atv_default_mem_fb },\n+    { omp_atk_partition, omp_atv_environment } };\n+\n+int\n+main ()\n+{\n+  omp_allocator_handle_t a;\n+  void *p, *q;\n+  volatile size_t large_sz;\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits) / sizeof (traits[0]),\n+\t\t\t  traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  p = omp_alloc (2048, a);\n+  if ((((uintptr_t) p) % 16) != 0)\n+    abort ();\n+  large_sz = ~(size_t) 1023;\n+  q = omp_alloc (large_sz, a);\n+  if (q != NULL)\n+    abort ();\n+  q = omp_aligned_alloc (32, large_sz, a);\n+  if (q != NULL)\n+    abort ();\n+  q = omp_calloc (large_sz / 4, 4, a);\n+  if (q != NULL)\n+    abort ();\n+  q = omp_aligned_calloc (1, 2, large_sz / 2, a);\n+  if (q != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  large_sz = ~(size_t) 0;\n+  large_sz >>= 1;\n+  large_sz += 1;\n+  if (omp_calloc (2, large_sz, a) != NULL)\n+    abort ();\n+  if (omp_calloc (large_sz, 1024, a) != NULL)\n+    abort ();\n+  if (omp_calloc (large_sz, large_sz, a) != NULL)\n+    abort ();\n+  if (omp_aligned_calloc (16, 2, large_sz, a) != NULL)\n+    abort ();\n+  if (omp_aligned_calloc (32, large_sz, 1024, a) != NULL)\n+    abort ();\n+  if (omp_aligned_calloc (64, large_sz, large_sz, a) != NULL)\n+    abort ();\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}, {"sha": "d66e25ac7d61cca225e22fca54594c1750921c9e", "filename": "libgomp/testsuite/libgomp.c-c++-common/alloc-7.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-7.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -0,0 +1,182 @@\n+#include <omp.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+const omp_alloctrait_t traits2[]\n+= { { omp_atk_alignment, 16 },\n+    { omp_atk_sync_hint, omp_atv_default },\n+    { omp_atk_access, omp_atv_default },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_default_mem_fb },\n+    { omp_atk_partition, omp_atv_environment } };\n+omp_alloctrait_t traits3[]\n+= { { omp_atk_sync_hint, omp_atv_uncontended },\n+    { omp_atk_alignment, 32 },\n+    { omp_atk_access, omp_atv_all },\n+    { omp_atk_pool_size, 512 },\n+    { omp_atk_fallback, omp_atv_allocator_fb },\n+    { omp_atk_fb_data, 0 },\n+    { omp_atk_partition, omp_atv_default } };\n+const omp_alloctrait_t traits4[]\n+= { { omp_atk_alignment, 128 },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_null_fb } };\n+\n+int\n+main ()\n+{\n+  int *volatile p = (int *) omp_calloc (3, sizeof (int), omp_default_mem_alloc);\n+  int *volatile q;\n+  int *volatile r;\n+  int i;\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb },\n+\t{ omp_atk_pool_size, 4096 } };\n+  omp_allocator_handle_t a, a2;\n+\n+  if ((((uintptr_t) p) % __alignof (int)) != 0 || p[0] || p[1] || p[2])\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  p[2] = 3;\n+  omp_free (p, omp_default_mem_alloc);\n+  p = (int *) omp_calloc (2, sizeof (int), omp_default_mem_alloc);\n+  if ((((uintptr_t) p) % __alignof (int)) != 0 || p[0] || p[1])\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  p = (int *) omp_calloc (1, sizeof (int), omp_null_allocator);\n+  if ((((uintptr_t) p) % __alignof (int)) != 0 || p[0])\n+    abort ();\n+  p[0] = 3;\n+  omp_free (p, omp_get_default_allocator ());\n+\n+  a = omp_init_allocator (omp_default_mem_space, 3, traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_calloc (3, 1024, a);\n+  if ((((uintptr_t) p) % 64) != 0)\n+    abort ();\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 1;\n+  p[3071 / sizeof (int)] = 2;\n+  if (omp_calloc (1024, 3, a) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  p = (int *) omp_calloc (512, 6, a);\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 3;\n+  p[3071 / sizeof (int)] = 4;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (a);\n+  if (omp_get_default_allocator () != a)\n+    abort ();\n+  p = (int *) omp_calloc (12, 256, omp_null_allocator);\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  if (omp_calloc (128, 24, omp_null_allocator) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits2) / sizeof (traits2[0]),\n+\t\t\t  traits2);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_calloc (10, 42, a2);\n+  for (i = 0; i < 420 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_calloc (24, 32, a2);\n+  if ((((uintptr_t) q) % 16) != 0)\n+    abort ();\n+  for (i = 0; i < 768 / sizeof (int); i++)\n+    if (q[i])\n+      abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  r = (int *) omp_calloc (128, 4, a2);\n+  if ((((uintptr_t) r) % __alignof (int)) != 0)\n+    abort ();\n+  for (i = 0; i < 512 / sizeof (int); i++)\n+    if (r[i])\n+      abort ();\n+  r[0] = 9;\n+  r[511 / sizeof (int)] = 10;\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, a2);\n+  omp_free (r, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits4) / sizeof (traits4[0]),\n+\t\t\t  traits4);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (a2);\n+#ifdef __cplusplus\n+  p = static_cast <int *> (omp_calloc (42, 10));\n+#else\n+  p = (int *) omp_calloc (42, 10, omp_null_allocator);\n+#endif\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  for (i = 0; i < 420 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_calloc (32, 24, omp_null_allocator);\n+  if ((((uintptr_t) q) % 128) != 0)\n+    abort ();\n+  for (i = 0; i < 768 / sizeof (int); i++)\n+    if (q[i])\n+      abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  if (omp_calloc (24, 32, omp_null_allocator) != NULL)\n+    abort ();\n+#ifdef __cplusplus\n+  omp_free (p);\n+  omp_free (q);\n+  omp_free (NULL);\n+#else\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, omp_null_allocator);\n+  omp_free (NULL, omp_null_allocator);\n+#endif\n+  omp_free (NULL, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}, {"sha": "bd4e08a6f9182a3116e1f59e3a5ca5fbbe625cc5", "filename": "libgomp/testsuite/libgomp.c-c++-common/alloc-8.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a4bd10249b5070ea1f4708a0fd228df268c26/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Falloc-8.c?ref=b38a4bd10249b5070ea1f4708a0fd228df268c26", "patch": "@@ -0,0 +1,184 @@\n+#include <omp.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+const omp_alloctrait_t traits2[]\n+= { { omp_atk_alignment, 16 },\n+    { omp_atk_sync_hint, omp_atv_default },\n+    { omp_atk_access, omp_atv_default },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_default_mem_fb },\n+    { omp_atk_partition, omp_atv_environment } };\n+omp_alloctrait_t traits3[]\n+= { { omp_atk_sync_hint, omp_atv_uncontended },\n+    { omp_atk_alignment, 32 },\n+    { omp_atk_access, omp_atv_all },\n+    { omp_atk_pool_size, 512 },\n+    { omp_atk_fallback, omp_atv_allocator_fb },\n+    { omp_atk_fb_data, 0 },\n+    { omp_atk_partition, omp_atv_default } };\n+const omp_alloctrait_t traits4[]\n+= { { omp_atk_alignment, 128 },\n+    { omp_atk_pool_size, 1024 },\n+    { omp_atk_fallback, omp_atv_null_fb } };\n+\n+int\n+main ()\n+{\n+  int *volatile p = (int *) omp_aligned_calloc (sizeof (int), 3, sizeof (int), omp_default_mem_alloc);\n+  int *volatile q;\n+  int *volatile r;\n+  int i;\n+  omp_alloctrait_t traits[3]\n+    = { { omp_atk_alignment, 64 },\n+\t{ omp_atk_fallback, omp_atv_null_fb },\n+\t{ omp_atk_pool_size, 4096 } };\n+  omp_allocator_handle_t a, a2;\n+\n+  if ((((uintptr_t) p) % __alignof (int)) != 0 || p[0] || p[1] || p[2])\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  p[2] = 3;\n+  omp_free (p, omp_default_mem_alloc);\n+  p = (int *) omp_aligned_calloc (2 * sizeof (int), 1, 2 * sizeof (int), omp_default_mem_alloc);\n+  if ((((uintptr_t) p) % (2 * sizeof (int))) != 0 || p[0] || p[1])\n+    abort ();\n+  p[0] = 1;\n+  p[1] = 2;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (omp_default_mem_alloc);\n+  p = (int *) omp_aligned_calloc (1, 1, sizeof (int), omp_null_allocator);\n+  if ((((uintptr_t) p) % __alignof (int)) != 0 || p[0])\n+    abort ();\n+  p[0] = 3;\n+  omp_free (p, omp_get_default_allocator ());\n+\n+  a = omp_init_allocator (omp_default_mem_space, 3, traits);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_aligned_calloc (32, 3, 1024, a);\n+  if ((((uintptr_t) p) % 64) != 0)\n+    abort ();\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 1;\n+  p[3071 / sizeof (int)] = 2;\n+  if (omp_aligned_calloc (8, 192, 16, a) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  p = (int *) omp_aligned_calloc (128, 6, 512, a);\n+  if ((((uintptr_t) p) % 128) != 0)\n+    abort ();\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 3;\n+  p[3071 / sizeof (int)] = 4;\n+  omp_free (p, omp_null_allocator);\n+  omp_set_default_allocator (a);\n+  if (omp_get_default_allocator () != a)\n+    abort ();\n+  p = (int *) omp_aligned_calloc (64, 12, 256, omp_null_allocator);\n+  for (i = 0; i < 3072 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  if (omp_aligned_calloc (8, 128, 24, omp_null_allocator) != NULL)\n+    abort ();\n+  omp_free (p, a);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits2) / sizeof (traits2[0]),\n+\t\t\t  traits2);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  p = (int *) omp_aligned_calloc (4, 5, 84, a2);\n+  for (i = 0; i < 420 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_aligned_calloc (8, 24, 32, a2);\n+  if ((((uintptr_t) q) % 16) != 0)\n+    abort ();\n+  for (i = 0; i < 768 / sizeof (int); i++)\n+    if (q[i])\n+      abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  r = (int *) omp_aligned_calloc (8, 64, 8, a2);\n+  if ((((uintptr_t) r) % 8) != 0)\n+    abort ();\n+  for (i = 0; i < 512 / sizeof (int); i++)\n+    if (r[i])\n+      abort ();\n+  r[0] = 9;\n+  r[511 / sizeof (int)] = 10;\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, a2);\n+  omp_free (r, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+\n+  a = omp_init_allocator (omp_default_mem_space,\n+\t\t\t  sizeof (traits4) / sizeof (traits4[0]),\n+\t\t\t  traits4);\n+  if (a == omp_null_allocator)\n+    abort ();\n+  if (traits3[5].key != omp_atk_fb_data)\n+    abort ();\n+  traits3[5].value = (uintptr_t) a;\n+  a2 = omp_init_allocator (omp_default_mem_space,\n+\t\t\t   sizeof (traits3) / sizeof (traits3[0]),\n+\t\t\t   traits3);\n+  if (a2 == omp_null_allocator)\n+    abort ();\n+  omp_set_default_allocator (a2);\n+#ifdef __cplusplus\n+  p = static_cast <int *> (omp_aligned_calloc (4, 21, 20));\n+#else\n+  p = (int *) omp_aligned_calloc (4, 21, 20, omp_null_allocator);\n+#endif\n+  if ((((uintptr_t) p) % 32) != 0)\n+    abort ();\n+  for (i = 0; i < 420 / sizeof (int); i++)\n+    if (p[i])\n+      abort ();\n+  p[0] = 5;\n+  p[419 / sizeof (int)] = 6;\n+  q = (int *) omp_aligned_calloc (64, 12, 64, omp_null_allocator);\n+  if ((((uintptr_t) q) % 128) != 0)\n+    abort ();\n+  for (i = 0; i < 768 / sizeof (int); i++)\n+    if (q[i])\n+      abort ();\n+  q[0] = 7;\n+  q[767 / sizeof (int)] = 8;\n+  if (omp_aligned_calloc (8, 24, 32, omp_null_allocator) != NULL)\n+    abort ();\n+#ifdef __cplusplus\n+  omp_free (p);\n+  omp_free (q);\n+  omp_free (NULL);\n+#else\n+  omp_free (p, omp_null_allocator);\n+  omp_free (q, omp_null_allocator);\n+  omp_free (NULL, omp_null_allocator);\n+#endif\n+  omp_free (NULL, omp_null_allocator);\n+  omp_destroy_allocator (a2);\n+  omp_destroy_allocator (a);\n+  return 0;\n+}"}]}