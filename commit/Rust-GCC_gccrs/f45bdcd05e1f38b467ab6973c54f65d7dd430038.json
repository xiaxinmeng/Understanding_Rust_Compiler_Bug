{"sha": "f45bdcd05e1f38b467ab6973c54f65d7dd430038", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1YmRjZDA1ZTFmMzhiNDY3YWI2OTczYzU0ZjY1ZDdkZDQzMDAzOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-20T03:35:14Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-20T03:35:14Z"}, "message": "expr.c (store_field): Remove two arguments value_mode and unsignedp.\n\n\t* expr.c (store_field): Remove two arguments value_mode and\n\tunsignedp.\n\t(expand_assignment, store_constructor_field,\n\texpand_expr_real_1): Adjust calls to store_field.\n\nFrom-SVN: r89317", "tree": {"sha": "5fef7080fa2d3ecaf66ce4582979157d116eaa20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fef7080fa2d3ecaf66ce4582979157d116eaa20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f45bdcd05e1f38b467ab6973c54f65d7dd430038", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45bdcd05e1f38b467ab6973c54f65d7dd430038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f45bdcd05e1f38b467ab6973c54f65d7dd430038", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45bdcd05e1f38b467ab6973c54f65d7dd430038/comments", "author": null, "committer": null, "parents": [{"sha": "4f8102dba53e66127cf93ca6bc209bb222d1afb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f8102dba53e66127cf93ca6bc209bb222d1afb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f8102dba53e66127cf93ca6bc209bb222d1afb6"}], "stats": {"total": 101, "additions": 28, "deletions": 73}, "files": [{"sha": "e3ec74bb5639fad21db056febed764479f4718bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45bdcd05e1f38b467ab6973c54f65d7dd430038/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45bdcd05e1f38b467ab6973c54f65d7dd430038/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f45bdcd05e1f38b467ab6973c54f65d7dd430038", "patch": "@@ -1,12 +1,19 @@\n-2004-10-18  Ramana Radhakrishnan  <ramana.radhakrishnan@codito.com>\r\n-\r\n-\t* config/arc/lib1funcs.asm (___umulsidi3): Correct usage of flags.\r\n-\r\n-\tPR target/17317\r\n-\t* config/arc/arc.h (REGNO_OK_FOR_BASE_P,REGNO_OK_FOR_INDEX_P,\r\n-\tREG_OK_FOR_BASE, REG_OK_FOR_INDEX): Consider blink(r31) as a valid\r\n-\tbase and index register for loads.\r\n-\r\n+2004-10-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expr.c (store_field): Remove two arguments value_mode and\n+\tunsignedp.\n+\t(expand_assignment, store_constructor_field,\n+\texpand_expr_real_1): Adjust calls to store_field.\n+\n+2004-10-18  Ramana Radhakrishnan  <ramana.radhakrishnan@codito.com>\n+\n+\t* config/arc/lib1funcs.asm (___umulsidi3): Correct usage of flags.\n+\n+\tPR target/17317\n+\t* config/arc/arc.h (REGNO_OK_FOR_BASE_P,REGNO_OK_FOR_INDEX_P,\n+\tREG_OK_FOR_BASE, REG_OK_FOR_INDEX): Consider blink(r31) as a valid\n+\tbase and index register for loads.\n+\n \t* config/arc/t-arc: Fix multilib handling.\n \n 2004-10-20  Hans-Peter Nilsson  <hp@bitrange.com>"}, {"sha": "8701c3d841fcfeaf04c8153d6476e51510c3ec6c", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 64, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45bdcd05e1f38b467ab6973c54f65d7dd430038/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45bdcd05e1f38b467ab6973c54f65d7dd430038/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f45bdcd05e1f38b467ab6973c54f65d7dd430038", "patch": "@@ -144,7 +144,7 @@ static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     tree, tree, int, int);\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n-\t\t\ttree, enum machine_mode, int, tree, int);\n+\t\t\ttree, tree, int);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (tree, tree);\n@@ -3620,8 +3620,7 @@ expand_assignment (tree to, tree from)\n \t}\n \n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n-\t\t\t    VOIDmode,\n-\t\t\t    unsignedp, TREE_TYPE (tem), get_alias_set (to));\n+\t\t\t    TREE_TYPE (tem), get_alias_set (to));\n \n       preserve_temp_slots (result);\n       free_temp_slots ();\n@@ -4329,8 +4328,7 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n-    store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n-\t\t alias_set);\n+    store_field (target, bitsize, bitpos, mode, exp, type, alias_set);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -5081,12 +5079,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n    BITSIZE bits, starting BITPOS bits from the start of TARGET.\n    If MODE is VOIDmode, it means that we are storing into a bit-field.\n \n-   If VALUE_MODE is VOIDmode, return nothing in particular.\n-   UNSIGNEDP is not used in this case.\n-\n-   Otherwise, return an rtx for the value stored.  This rtx\n-   has mode VALUE_MODE if that is convenient to do.\n-   In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.\n+   Always return const0_rtx unless we have something particular to\n+   return.\n \n    TYPE is the type of the underlying object,\n \n@@ -5096,8 +5090,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n-\t     enum machine_mode mode, tree exp, enum machine_mode value_mode,\n-\t     int unsignedp, tree type, int alias_set)\n+\t     enum machine_mode mode, tree exp, tree type, int alias_set)\n {\n   HOST_WIDE_INT width_mask = 0;\n \n@@ -5132,8 +5125,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n \temit_move_insn (object, target);\n \n-      store_field (blk_object, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n-\t\t   alias_set);\n+      store_field (blk_object, bitsize, bitpos, mode, exp, type, alias_set);\n \n       emit_move_insn (target, object);\n \n@@ -5146,7 +5138,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       /* We're storing into a struct containing a single __complex.  */\n \n       gcc_assert (!bitpos);\n-      return store_expr (exp, target, value_mode != VOIDmode);\n+      return store_expr (exp, target, 0);\n     }\n \n   /* If the structure is in a register or if the component\n@@ -5207,62 +5199,18 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t\t\t\t    / BITS_PER_UNIT),\n \t\t\t   BLOCK_OP_NORMAL);\n \n-\t  return value_mode == VOIDmode ? const0_rtx : target;\n+\t  return const0_rtx;\n \t}\n \n       /* Store the value in the bitfield.  */\n       store_bit_field (target, bitsize, bitpos, mode, temp);\n \n-      if (value_mode != VOIDmode)\n-\t{\n-\t  /* The caller wants an rtx for the value.\n-\t     If possible, avoid refetching from the bitfield itself.  */\n-\t  if (width_mask != 0\n-\t      && ! (MEM_P (target) && MEM_VOLATILE_P (target)))\n-\t    {\n-\t      tree count;\n-\t      enum machine_mode tmode;\n-\n-\t      tmode = GET_MODE (temp);\n-\t      if (tmode == VOIDmode)\n-\t\ttmode = value_mode;\n-\n-\t      if (unsignedp)\n-\t\treturn expand_and (tmode, temp,\n-\t\t\t\t   gen_int_mode (width_mask, tmode),\n-\t\t\t\t   NULL_RTX);\n-\n-\t      count = build_int_cst (NULL_TREE,\n-\t\t\t\t     GET_MODE_BITSIZE (tmode) - bitsize);\n-\t      temp = expand_shift (LSHIFT_EXPR, tmode, temp, count, 0, 0);\n-\t      return expand_shift (RSHIFT_EXPR, tmode, temp, count, 0, 0);\n-\t    }\n-\n-\t  return extract_bit_field (target, bitsize, bitpos, unsignedp,\n-\t\t\t\t    NULL_RTX, value_mode, VOIDmode);\n-\t}\n       return const0_rtx;\n     }\n   else\n     {\n-      rtx addr = XEXP (target, 0);\n-      rtx to_rtx = target;\n-\n-      /* If a value is wanted, it must be the lhs;\n-\t so make the address stable for multiple use.  */\n-\n-      if (value_mode != VOIDmode && !REG_P (addr)\n-\t  && ! CONSTANT_ADDRESS_P (addr)\n-\t  /* A frame-pointer reference is already stable.  */\n-\t  && ! (GET_CODE (addr) == PLUS\n-\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t&& (XEXP (addr, 0) == virtual_incoming_args_rtx\n-\t\t    || XEXP (addr, 0) == virtual_stack_vars_rtx)))\n-\tto_rtx = replace_equiv_address (to_rtx, copy_to_reg (addr));\n-\n       /* Now build a reference to just the desired component.  */\n-\n-      to_rtx = adjust_address (target, mode, bitpos / BITS_PER_UNIT);\n+      rtx to_rtx = adjust_address (target, mode, bitpos / BITS_PER_UNIT);\n \n       if (to_rtx == target)\n \tto_rtx = copy_rtx (to_rtx);\n@@ -5271,7 +5219,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (!MEM_KEEP_ALIAS_SET_P (to_rtx) && MEM_ALIAS_SET (to_rtx) != 0)\n \tset_mem_alias_set (to_rtx, alias_set);\n \n-      return store_expr (exp, to_rtx, value_mode != VOIDmode);\n+      return store_expr (exp, to_rtx, 0);\n     }\n }\n \f\n@@ -7274,7 +7222,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n \t\t\t   0, TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n-\t\t\t   VOIDmode, 0, type, 0);\n+\t\t\t   type, 0);\n \t    }\n \n \t  /* Return the entire union.  */"}]}