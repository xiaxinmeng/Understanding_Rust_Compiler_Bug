{"sha": "8c05d8cd4300f74bf2698f0a6b96464b5be571be", "node_id": "C_kwDOANBUbNoAKDhjMDVkOGNkNDMwMGY3NGJmMjY5OGYwYTZiOTY0NjRiNWJlNTcxYmU", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-11-19T09:36:27Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-11-19T09:36:27Z"}, "message": "libgomp/gcn: Prepare for reverse-offload callback handling\n\nlibgomp/ChangeLog:\n\n\t* config/gcn/libgomp-gcn.h: New file; contains\n\tstruct output, declared previously in plugin-gcn.c.\n\t* config/gcn/target.c: Include it.\n\t(GOMP_ADDITIONAL_ICVS): Declare as extern var.\n\t(GOMP_target_ext): Handle reverse offload.\n\t* plugin/plugin-gcn.c: Include libgomp-gcn.h.\n\t(struct kernargs): Replace struct def by the one\n\tfrom libgomp-gcn.h for output_data.\n\t(process_reverse_offload): New.\n\t(console_output): Call it.", "tree": {"sha": "0073b1875ad14dbadafb0c083eb34434c3ad0ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0073b1875ad14dbadafb0c083eb34434c3ad0ff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c05d8cd4300f74bf2698f0a6b96464b5be571be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c05d8cd4300f74bf2698f0a6b96464b5be571be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c05d8cd4300f74bf2698f0a6b96464b5be571be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c05d8cd4300f74bf2698f0a6b96464b5be571be/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1115dbfea4d6df51d608cece7416d658d2e2822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1115dbfea4d6df51d608cece7416d658d2e2822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1115dbfea4d6df51d608cece7416d658d2e2822"}], "stats": {"total": 139, "additions": 117, "deletions": 22}, "files": [{"sha": "91560be787f38e00169510d6ffda6e6ebd9bd8e7", "filename": "libgomp/config/gcn/libgomp-gcn.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fconfig%2Fgcn%2Flibgomp-gcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fconfig%2Fgcn%2Flibgomp-gcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Flibgomp-gcn.h?ref=8c05d8cd4300f74bf2698f0a6b96464b5be571be", "patch": "@@ -0,0 +1,61 @@\n+/* Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <tobias@codesourcery.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains defines and type definitions shared between the\n+   nvptx target's libgomp.a and the plugin-nvptx.c, but that is only\n+   needef for this target.  */\n+\n+#ifndef LIBGOMP_GCN_H\n+#define LIBGOMP_GCN_H 1\n+\n+/* This struct is also used in Newlib's libc/sys/amdgcn/write.c.  */\n+struct output\n+{\n+  int return_value;\n+  unsigned int next_output;\n+  struct printf_data {\n+    int written;\n+    union {\n+      char msg[128];\n+      uint64_t msg_u64[2];\n+    };\n+    int type;\n+    union {\n+      int64_t ivalue;\n+      double dvalue;\n+      char text[128];\n+      uint64_t value_u64[2];\n+    };\n+  } queue[1024];\n+  unsigned int consumed;\n+};\n+\n+#if (__SIZEOF_SHORT__ != 2 \\\n+     || __SIZEOF_SIZE_T__ != 8 \\\n+     || __SIZEOF_POINTER__ != 8)\n+#error \"Data-type conversion required for rev_offload\"\n+#endif\n+\n+#endif  /* LIBGOMP_GCN_H */"}, {"sha": "27854565d40d756e8f9e03cfefbfd0a8ac97c4fe", "filename": "libgomp/config/gcn/target.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fconfig%2Fgcn%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fconfig%2Fgcn%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ftarget.c?ref=8c05d8cd4300f74bf2698f0a6b96464b5be571be", "patch": "@@ -24,8 +24,11 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #include \"libgomp.h\"\n+#include \"libgomp-gcn.h\"\n #include <limits.h>\n \n+extern volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n+\n bool\n GOMP_teams4 (unsigned int num_teams_lower, unsigned int num_teams_upper,\n \t     unsigned int thread_limit, bool first)\n@@ -75,16 +78,43 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t void **hostaddrs, size_t *sizes, unsigned short *kinds,\n \t\t unsigned int flags, void **depend, void **args)\n {\n-  (void) device;\n-  (void) fn;\n-  (void) mapnum;\n-  (void) hostaddrs;\n-  (void) sizes;\n-  (void) kinds;\n   (void) flags;\n   (void) depend;\n   (void) args;\n-  __builtin_unreachable ();\n+\n+  if (device != GOMP_DEVICE_HOST_FALLBACK || fn == NULL)\n+    return;\n+\n+  /* The output data is at ((void*) kernargs)[2].  */\n+  register void **kernargs = (void**) __builtin_gcn_kernarg_ptr ();\n+  struct output *data = (struct output *) kernargs[2];\n+  /* Reserve one slot. */\n+  unsigned int index = __atomic_fetch_add (&data->next_output, 1,\n+\t\t\t\t\t   __ATOMIC_ACQUIRE);\n+\n+  if ((unsigned int) (index + 1) < data->consumed)\n+    abort ();  /* Overflow.  */\n+\n+  /* Spinlock while the host catches up.  */\n+  if (index >= 1024)\n+    while (__atomic_load_n (&data->consumed, __ATOMIC_ACQUIRE)\n+\t   <= (index - 1024))\n+      asm (\"s_sleep 64\");\n+\n+  unsigned int slot = index % 1024;\n+  uint64_t addrs_sizes_kind[3] = {(uint64_t) hostaddrs, (uint64_t) sizes,\n+\t\t\t\t  (uint64_t) kinds};\n+  data->queue[slot].msg_u64[0] = (uint64_t) fn;\n+  data->queue[slot].msg_u64[1] = (uint64_t) mapnum;\n+  data->queue[slot].value_u64[0] = (uint64_t) &addrs_sizes_kind[0];\n+  data->queue[slot].value_u64[1] = (uint64_t) GOMP_ADDITIONAL_ICVS.device_num;\n+\n+  data->queue[slot].type = 4; /* Reverse offload.  */\n+  __atomic_store_n (&data->queue[slot].written, 1, __ATOMIC_RELEASE);\n+\n+  /* Spinlock while the host catches up.  */\n+  while (__atomic_load_n (&data->queue[slot].written, __ATOMIC_ACQUIRE) != 0)\n+    asm (\"s_sleep 64\");\n }\n \n void"}, {"sha": "ffe5cf5af2c7e174e6febbf211f66e224928c931", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c05d8cd4300f74bf2698f0a6b96464b5be571be/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=8c05d8cd4300f74bf2698f0a6b96464b5be571be", "patch": "@@ -42,6 +42,7 @@\n #include <dlfcn.h>\n #include <signal.h>\n #include \"libgomp-plugin.h\"\n+#include \"config/gcn/libgomp-gcn.h\"  /* For struct output.  */\n #include \"gomp-constants.h\"\n #include <elf.h>\n #include \"oacc-plugin.h\"\n@@ -252,21 +253,7 @@ struct kernargs {\n   int64_t arena_ptr;\n \n   /* Output data.  */\n-  struct output {\n-    int return_value;\n-    unsigned int next_output;\n-    struct printf_data {\n-      int written;\n-      char msg[128];\n-      int type;\n-      union {\n-\tint64_t ivalue;\n-\tdouble dvalue;\n-\tchar text[128];\n-      };\n-    } queue[1024];\n-    unsigned int consumed;\n-  } output_data;\n+  struct output output_data;\n };\n \n /* A queue entry for a future asynchronous launch.  */\n@@ -1931,6 +1918,19 @@ create_kernel_dispatch (struct kernel_info *kernel, int num_teams)\n   return shadow;\n }\n \n+static void\n+process_reverse_offload (uint64_t fn, uint64_t mapnum, uint64_t rev_data,\n+\t\t\t uint64_t dev_num64)\n+{\n+  int dev_num = dev_num64;\n+  uint64_t addrs_sizes_kinds[3];\n+  GOMP_OFFLOAD_host2dev (dev_num, &addrs_sizes_kinds, (void *) rev_data,\n+\t\t\t sizeof (addrs_sizes_kinds));\n+  GOMP_PLUGIN_target_rev (fn, mapnum, addrs_sizes_kinds[0],\n+\t\t\t  addrs_sizes_kinds[1], addrs_sizes_kinds[2],\n+\t\t\t  dev_num, NULL, NULL, NULL);\n+}\n+\n /* Output any data written to console output from the kernel.  It is expected\n    that this function is polled during kernel execution.\n \n@@ -1975,6 +1975,10 @@ console_output (struct kernel_info *kernel, struct kernargs *kernargs,\n \tcase 1: printf (\"%.128s%f\\n\", data->msg, data->dvalue); break;\n \tcase 2: printf (\"%.128s%.128s\\n\", data->msg, data->text); break;\n \tcase 3: printf (\"%.128s%.128s\", data->msg, data->text); break;\n+\tcase 4:\n+\t  process_reverse_offload (data->msg_u64[0], data->msg_u64[1],\n+\t\t\t\t   data->value_u64[0],data->value_u64[1]);\n+\t  break;\n \tdefault: printf (\"GCN print buffer error!\\n\"); break;\n \t}\n       data->written = 0;"}]}