{"sha": "f63ab951732ba679174976e269fe8697742ebbcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYzYWI5NTE3MzJiYTY3OTE3NDk3NmUyNjlmZTg2OTc3NDJlYmJjZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-05-13T08:00:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-05-13T08:00:48Z"}, "message": "class.c (build_vtbl_ref_1): Use fixed_type_or_null.\n\n        * class.c (build_vtbl_ref_1): Use fixed_type_or_null.\n        (fixed_type_or_null): See through reference vars.\n        (build_base_path): Vtable contents are constant.\n        * typeck.c (get_member_function_from_ptrfunc): Likewise.\n\n        * rtti.c (emit_tinfo_decl): Call import_export_decl.\n        * decl2.c (import_export_decl): Set DECL_NOT_REALLY_EXTERN on\n        tinfo decls by default.  Don't mess with the builtins.\n\nFrom-SVN: r53416", "tree": {"sha": "8cecf23aef6e66bf41d420e5722b052aef5792fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cecf23aef6e66bf41d420e5722b052aef5792fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f63ab951732ba679174976e269fe8697742ebbcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63ab951732ba679174976e269fe8697742ebbcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63ab951732ba679174976e269fe8697742ebbcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63ab951732ba679174976e269fe8697742ebbcd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1cb2d640d085630bc7356b0b991c0c478b67a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1cb2d640d085630bc7356b0b991c0c478b67a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1cb2d640d085630bc7356b0b991c0c478b67a33"}], "stats": {"total": 113, "additions": 48, "deletions": 65}, "files": [{"sha": "da89625e155e7a24304885614e7d7f5273c03189", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f63ab951732ba679174976e269fe8697742ebbcd", "patch": "@@ -1,3 +1,14 @@\n+2002-05-13  Jason Merrill  <jason@redhat.com>\n+\n+\t* class.c (build_vtbl_ref_1): Use fixed_type_or_null.\n+\t(fixed_type_or_null): See through reference vars.\n+\t(build_base_path): Vtable contents are constant.\n+\t* typeck.c (get_member_function_from_ptrfunc): Likewise.\n+\n+\t* rtti.c (emit_tinfo_decl): Call import_export_decl.\n+\t* decl2.c (import_export_decl): Set DECL_NOT_REALLY_EXTERN on\n+\ttinfo decls by default.  Don't mess with the builtins.\n+\n 2002-05-12  Jason Merrill  <jason@redhat.com>\n \n \t* cp-lang.c (ok_to_generate_alias_set_for_type): Backend-created"}, {"sha": "98f32dccb14b6dadfd19597476e0d79f4b2f67af", "filename": "gcc/cp/class.c", "status": "modified", "additions": 28, "deletions": 60, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f63ab951732ba679174976e269fe8697742ebbcd", "patch": "@@ -316,7 +316,8 @@ build_base_path (code, expr, binfo, nonnull)\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n       v_offset = build_indirect_ref (v_offset, NULL);\n-      \n+      TREE_CONSTANT (v_offset) = 1;\n+\n       offset = cp_convert (ptrdiff_type_node,\n \t\t\t   size_diffop (offset, BINFO_OFFSET (v_binfo)));\n \n@@ -401,75 +402,36 @@ static tree\n build_vtbl_ref_1 (instance, idx)\n      tree instance, idx;\n {\n-  tree vtbl, aref;\n-  tree basetype = TREE_TYPE (instance);\n+  tree aref;\n+  tree vtbl = NULL_TREE;\n+\n+  /* Try to figure out what a reference refers to, and\n+     access its virtual function table directly.  */\n+\n+  int cdtorp = 0;\n+  tree fixed_type = fixed_type_or_null (instance, NULL, &cdtorp);\n \n+  tree basetype = TREE_TYPE (instance);\n   if (TREE_CODE (basetype) == REFERENCE_TYPE)\n     basetype = TREE_TYPE (basetype);\n \n-  if (instance == current_class_ref)\n-    vtbl = build_vfield_ref (instance, basetype);\n-  else\n+  if (fixed_type && !cdtorp)\n     {\n-      if (optimize)\n-\t{\n-\t  /* Try to figure out what a reference refers to, and\n-\t     access its virtual function table directly.  */\n-\t  tree ref = NULL_TREE;\n-\n-\t  if (TREE_CODE (instance) == INDIRECT_REF\n-\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (instance, 0))) == REFERENCE_TYPE)\n-\t    ref = TREE_OPERAND (instance, 0);\n-\t  else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n-\t    ref = instance;\n-\n-\t  if (ref && TREE_CODE (ref) == VAR_DECL\n-\t      && DECL_INITIAL (ref))\n-\t    {\n-\t      tree init = DECL_INITIAL (ref);\n-\n-\t      while (TREE_CODE (init) == NOP_EXPR\n-\t\t     || TREE_CODE (init) == NON_LVALUE_EXPR)\n-\t\tinit = TREE_OPERAND (init, 0);\n-\t      if (TREE_CODE (init) == ADDR_EXPR)\n-\t\t{\n-\t\t  init = TREE_OPERAND (init, 0);\n-\t\t  if (IS_AGGR_TYPE (TREE_TYPE (init))\n-\t\t      && (TREE_CODE (init) == PARM_DECL\n-\t\t\t  || TREE_CODE (init) == VAR_DECL))\n-\t\t    instance = init;\n-\t\t}\n-\t    }\n-\t}\n+      tree binfo = lookup_base (fixed_type, basetype,\n+\t\t\t\tba_ignore|ba_quiet, NULL);\n+      if (binfo)\n+\tvtbl = BINFO_VTABLE (binfo);\n+    }\n \n-      if (IS_AGGR_TYPE (TREE_TYPE (instance))\n-\t  && (TREE_CODE (instance) == RESULT_DECL\n-\t      || TREE_CODE (instance) == PARM_DECL\n-\t      || TREE_CODE (instance) == VAR_DECL))\n-\t{\n-\t  vtbl = TYPE_BINFO_VTABLE (basetype);\n-\t  /* Knowing the dynamic type of INSTANCE we can easily obtain\n-\t     the correct vtable entry.  We resolve this back to be in\n-\t     terms of the primary vtable.  */\n-\t  if (TREE_CODE (vtbl) == PLUS_EXPR)\n-\t    {\n-\t      idx = fold (build (PLUS_EXPR,\n-\t\t\t\t TREE_TYPE (idx),\n-\t\t\t\t idx,\n-\t\t\t\t build (EXACT_DIV_EXPR,\n-\t\t\t\t\tTREE_TYPE (idx),\n-\t\t\t\t\tTREE_OPERAND (vtbl, 1),\n-\t\t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type))));\n-\t      vtbl = get_vtbl_decl_for_binfo (TYPE_BINFO (basetype));\n-\t    }\n-\t}\n-      else\n-\tvtbl = build_vfield_ref (instance, basetype);\n+  if (!vtbl)\n+    {\n+      vtbl = build_vfield_ref (instance, basetype);\n     }\n \n   assemble_external (vtbl);\n \n   aref = build_array_ref (vtbl, idx);\n+  TREE_CONSTANT (aref) = 1;\n \n   return aref;\n }\n@@ -5396,7 +5358,7 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n \treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n       if (TREE_CODE (TREE_OPERAND (instance, 1)) == INTEGER_CST)\n \t/* Propagate nonnull.  */\n-\tfixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n+\treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n       return NULL_TREE;\n \n     case NOP_EXPR:\n@@ -5423,6 +5385,7 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n       /* fall through...  */\n     case TARGET_EXPR:\n     case PARM_DECL:\n+    case RESULT_DECL:\n       if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n \t{\n \t  if (nonnull)\n@@ -5449,6 +5412,11 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n           /* Reference variables should be references to objects.  */\n           if (nonnull)\n \t    *nonnull = 1;\n+\n+\t  if (TREE_CODE (instance) == VAR_DECL\n+\t      && DECL_INITIAL (instance))\n+\t    return fixed_type_or_null (DECL_INITIAL (instance),\n+\t\t\t\t       nonnull, cdtorp);\n \t}\n       return NULL_TREE;\n "}, {"sha": "2fd67ae8740ab380077773b3ce0d54b92f66fcbe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f63ab951732ba679174976e269fe8697742ebbcd", "patch": "@@ -2514,6 +2514,7 @@ import_export_decl (decl)\n       if (IS_AGGR_TYPE (ctype))\n \timport_export_class (ctype);\n \n+      DECL_NOT_REALLY_EXTERN (decl) = 1;\n       if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype)\n \t  && TYPE_POLYMORPHIC_P (ctype)\n \t  /* If -fno-rtti, we're not necessarily emitting this stuff with\n@@ -2537,9 +2538,9 @@ import_export_decl (decl)\n \t  if (flag_weak)\n \t    comdat_linkage (decl);\n \t}\n-      else if (TYPE_BUILT_IN (ctype) \n-\t       && same_type_p (ctype, TYPE_MAIN_VARIANT (ctype)))\n-\tDECL_NOT_REALLY_EXTERN (decl) = 0;\n+      /* We used to exclude the builtin types here, but that broke\n+\t emit_support_tinfos.  Let rtti.c choose whether or not to emit\n+\t them.  */\n       else\n \tcomdat_linkage (decl);\n     } "}, {"sha": "63ffcb7bef0f00b2bed1b4c6a30a140d0393ee32", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f63ab951732ba679174976e269fe8697742ebbcd", "patch": "@@ -1462,9 +1462,11 @@ emit_tinfo_decl (decl_ptr, data)\n   my_friendly_assert (TREE_TYPE (tinfo_decl) == tinfo_decl_type, 20000121);\n   tinfo_type = TREE_TYPE (DECL_NAME (tinfo_decl));\n   my_friendly_assert (tinfo_type != NULL_TREE, 20000120);\n-  \n-  if (!DECL_NEEDED_P (tinfo_decl))\n+\n+  import_export_decl (tinfo_decl);\n+  if (DECL_REALLY_EXTERN (tinfo_decl) || !DECL_NEEDED_P (tinfo_decl))\n     return 0;\n+\n   /* Say we've dealt with it.  */\n   TREE_TYPE (DECL_NAME (tinfo_decl)) = NULL_TREE;\n   "}, {"sha": "3b92a64ac830219b898226c9fef7b4e5dd60777d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63ab951732ba679174976e269fe8697742ebbcd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f63ab951732ba679174976e269fe8697742ebbcd", "patch": "@@ -2911,6 +2911,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold (build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx));\n       e2 = build_indirect_ref (e2, NULL);\n+      TREE_CONSTANT (e2) = 1;\n \n       /* When using function descriptors, the address of the\n \t vtable entry is treated as a function pointer.  */"}]}