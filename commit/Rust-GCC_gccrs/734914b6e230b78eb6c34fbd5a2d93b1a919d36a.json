{"sha": "734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM0OTE0YjZlMjMwYjc4ZWI2YzM0ZmJkNWEyZDkzYjFhOTE5ZDM2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2017-12-07T18:40:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:40:28Z"}, "message": "New VECTOR_CST layout\n\nThis patch uses a simple compression scheme to represent the contents\nof a VECTOR_CST using its leading elements.  There are three formats:\n\n1) a repeating sequence of N values.  This is encoded using the first\n   N elements.\n\n2) a \"foreground\" sequence of N values inserted at the beginning of\n   a \"background\" repeating sequence of N values, such as:\n   { 1, 2, 0, 0, 0, 0, ... }.  This is encoded using the first 2*N\n   elements.\n\n2) a \"foreground\" sequence of N values inserted at the beginning of\n   a \"background\" repeating sequence of N interleaved linear series,\n   such as: { 0, 0, 8, 10, 9, 11, 10, 12, ... }.  This is encoded\n   using the first 3*N elements.  In practice the foreground values\n   are often part of the same series as the background values,\n   such as: { 1, 11, 2, 12, 3, 13, ... }.\n\nThis reduces the amount of work involved in processing simple\nvector constants and means that the encoding extends naturally\nto variable-length vectors.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/generic.texi (VECTOR_CST): Describe new representation of\n\tvector constants.\n\t* vector-builder.h: New file.\n\t* tree-vector-builder.h: Likewise.\n\t* tree-vector-builder.c: Likewise.\n\t* Makefile.in (OBJS): Add tree-vector-builder.o.\n\t* tree.def (VECTOR_CST): Update comment to refer to generic.texi.\n\t* tree-core.h (tree_base): Add a vector_cst field to the u union.\n\t(tree_vector): Change the number of elements to\n\tvector_cst_encoded_nelts.\n\t* tree.h (VECTOR_CST_NELTS): Redefine using TYPE_VECTOR_SUBPARTS.\n\t(VECTOR_CST_ELTS): Delete.\n\t(VECTOR_CST_ELT): Redefine using vector_cst_elt.\n\t(VECTOR_CST_LOG2_NPATTERNS, VECTOR_CST_NPATTERNS): New macros.\n\t(VECTOR_CST_NELTS_PER_PATTERN, VECTOR_CST_DUPLICATE_P): Likewise.\n\t(VECTOR_CST_STEPPED_P, VECTOR_CST_ENCODED_ELTS): Likewise.\n\t(VECTOR_CST_ENCODED_ELT): Likewise.\n\t(vector_cst_encoded_nelts): New function.\n\t(make_vector): Take the values of VECTOR_CST_LOG2_NPATTERNS and\n\tVECTOR_CST_NELTS_PER_PATTERN as arguments.\n\t(vector_cst_int_elt, vector_cst_elt): Declare.\n\t* tree.c: Include tree-vector-builder.h.\n\t(tree_code_size): Abort if passed VECTOR_CST.\n\t(tree_size): Update for new VECTOR_CST layout.\n\t(make_vector): Take the values of VECTOR_CST_LOG2_NPATTERNS and\n\tVECTOR_CST_NELTS_PER_PATTERN as arguments.\n\t(build_vector): Use tree_vector_builder.\n\t(vector_cst_int_elt, vector_cst_elt): New functions.\n\t(drop_tree_overflow): For VECTOR_CST, drop the TREE_OVERFLOW from the\n\tencoded elements and then create the vector in the canonical form.\n\t(check_vector_cst, check_vector_cst_duplicate, check_vector_cst_fill)\n\t(check_vector_cst_stepped, test_vector_cst_patterns): New functions.\n\t(tree_c_tests): Call test_vector_cst_patterns.\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Handle the new\n\tVECTOR_CST fields.\n\t(hash_tree): Likewise.\n\t* tree-streamer-out.c (write_ts_vector_tree_pointers): Likewise.\n\t(streamer_write_tree_header): Likewise.\n\t* tree-streamer-in.c (lto_input_ts_vector_tree_pointers): Likewise.\n\t(streamer_alloc_tree): Likewise.  Update call to make_vector.\n\t* fold-const.c (fold_ternary_loc): Avoid using VECTOR_CST_ELTS.\n\ngcc/lto/\n\t* lto.c (compare_tree_sccs_1): Compare the new VECTOR_CST flags.\n\nFrom-SVN: r255474", "tree": {"sha": "464ddba276c629fcc0b513ee176e7938bd409fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/464ddba276c629fcc0b513ee176e7938bd409fc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0e7e36ebfe748057a6a6e105dbaa315eb0e46ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e7e36ebfe748057a6a6e105dbaa315eb0e46ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e7e36ebfe748057a6a6e105dbaa315eb0e46ac"}], "stats": {"total": 1085, "additions": 1015, "deletions": 70}, "files": [{"sha": "aa3bc51c342cbb7b472559ea934966e781ddc2f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1,3 +1,47 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/generic.texi (VECTOR_CST): Describe new representation of\n+\tvector constants.\n+\t* vector-builder.h: New file.\n+\t* tree-vector-builder.h: Likewise.\n+\t* tree-vector-builder.c: Likewise.\n+\t* Makefile.in (OBJS): Add tree-vector-builder.o.\n+\t* tree.def (VECTOR_CST): Update comment to refer to generic.texi.\n+\t* tree-core.h (tree_base): Add a vector_cst field to the u union.\n+\t(tree_vector): Change the number of elements to\n+\tvector_cst_encoded_nelts.\n+\t* tree.h (VECTOR_CST_NELTS): Redefine using TYPE_VECTOR_SUBPARTS.\n+\t(VECTOR_CST_ELTS): Delete.\n+\t(VECTOR_CST_ELT): Redefine using vector_cst_elt.\n+\t(VECTOR_CST_LOG2_NPATTERNS, VECTOR_CST_NPATTERNS): New macros.\n+\t(VECTOR_CST_NELTS_PER_PATTERN, VECTOR_CST_DUPLICATE_P): Likewise.\n+\t(VECTOR_CST_STEPPED_P, VECTOR_CST_ENCODED_ELTS): Likewise.\n+\t(VECTOR_CST_ENCODED_ELT): Likewise.\n+\t(vector_cst_encoded_nelts): New function.\n+\t(make_vector): Take the values of VECTOR_CST_LOG2_NPATTERNS and\n+\tVECTOR_CST_NELTS_PER_PATTERN as arguments.\n+\t(vector_cst_int_elt, vector_cst_elt): Declare.\n+\t* tree.c: Include tree-vector-builder.h.\n+\t(tree_code_size): Abort if passed VECTOR_CST.\n+\t(tree_size): Update for new VECTOR_CST layout.\n+\t(make_vector): Take the values of VECTOR_CST_LOG2_NPATTERNS and\n+\tVECTOR_CST_NELTS_PER_PATTERN as arguments.\n+\t(build_vector): Use tree_vector_builder.\n+\t(vector_cst_int_elt, vector_cst_elt): New functions.\n+\t(drop_tree_overflow): For VECTOR_CST, drop the TREE_OVERFLOW from the\n+\tencoded elements and then create the vector in the canonical form.\n+\t(check_vector_cst, check_vector_cst_duplicate, check_vector_cst_fill)\n+\t(check_vector_cst_stepped, test_vector_cst_patterns): New functions.\n+\t(tree_c_tests): Call test_vector_cst_patterns.\n+\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Handle the new\n+\tVECTOR_CST fields.\n+\t(hash_tree): Likewise.\n+\t* tree-streamer-out.c (write_ts_vector_tree_pointers): Likewise.\n+\t(streamer_write_tree_header): Likewise.\n+\t* tree-streamer-in.c (lto_input_ts_vector_tree_pointers): Likewise.\n+\t(streamer_alloc_tree): Likewise.  Update call to make_vector.\n+\t* fold-const.c (fold_ternary_loc): Avoid using VECTOR_CST_ELTS.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* selftest.h (ASSERT_TRUE_AT, ASSERT_FALSE_AT, ASSERT_EQ_AT)"}, {"sha": "f6e59cde8dfec3b03ca86dafee623d0f0d22728f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1574,6 +1574,7 @@ OBJS = \\\n \ttree-vect-loop-manip.o \\\n \ttree-vect-slp.o \\\n \ttree-vectorizer.o \\\n+\ttree-vector-builder.o \\\n \ttree-vrp.o \\\n \ttree.o \\\n \ttyped-splay-tree.o \\"}, {"sha": "75c448e7330ff8e0d4e073a8807441b07a575c50", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1084,10 +1084,77 @@ These nodes are used to represent complex number constants, that is a\n imaginary parts respectively.\n \n @item VECTOR_CST\n-These nodes are used to represent vector constants, whose parts are\n-constant nodes.  Each individual constant node is either an integer or a\n-double constant node.  The first operand is a @code{TREE_LIST} of the\n-constant nodes and is accessed through @code{TREE_VECTOR_CST_ELTS}.\n+These nodes are used to represent vector constants.  Each vector\n+constant @var{v} is treated as a specific instance of an arbitrary-length\n+sequence that itself contains @samp{VECTOR_CST_NPATTERNS (@var{v})}\n+interleaved patterns.  Each pattern has the form:\n+\n+@smallexample\n+@{ @var{base0}, @var{base1}, @var{base1} + @var{step}, @var{base1} + @var{step} * 2, @dots{} @}\n+@end smallexample\n+\n+The first three elements in each pattern are enough to determine the\n+values of the other elements.  However, if all @var{step}s are zero,\n+only the first two elements are needed.  If in addition each @var{base1}\n+is equal to the corresponding @var{base0}, only the first element in\n+each pattern is needed.  The number of encoded elements per pattern\n+is given by @samp{VECTOR_CST_NELTS_PER_PATTERN (@var{v})}.\n+\n+For example, the constant:\n+\n+@smallexample\n+@{ 0, 1, 2, 6, 3, 8, 4, 10, 5, 12, 6, 14, 7, 16, 8, 18 @}\n+@end smallexample\n+\n+is interpreted as an interleaving of the sequences:\n+\n+@smallexample\n+@{ 0, 2, 3, 4, 5, 6, 7, 8 @}\n+@{ 1, 6, 8, 10, 12, 14, 16, 18 @}\n+@end smallexample\n+\n+where the sequences are represented by the following patterns:\n+\n+@smallexample\n+@var{base0} == 0, @var{base1} == 2, @var{step} == 1\n+@var{base0} == 1, @var{base1} == 6, @var{step} == 2\n+@end smallexample\n+\n+In this case:\n+\n+@smallexample\n+VECTOR_CST_NPATTERNS (@var{v}) == 2\n+VECTOR_CST_NELTS_PER_PATTERN (@var{v}) == 3\n+@end smallexample\n+\n+The vector is therefore encoded using the first 6 elements\n+(@samp{@{ 0, 1, 2, 6, 3, 8 @}}), with the remaining 10 elements\n+being implicit extensions of them.\n+\n+Sometimes this scheme can create two possible encodings of the same\n+vector.  For example @{ 0, 1 @} could be seen as two patterns with\n+one element each or one pattern with two elements (@var{base0} and\n+@var{base1}).  The canonical encoding is always the one with the\n+fewest patterns or (if both encodings have the same number of\n+petterns) the one with the fewest encoded elements.\n+\n+@samp{vector_cst_encoding_nelts (@var{v})} gives the total number of\n+encoded elements in @var{v}, which is 6 in the example above.\n+@code{VECTOR_CST_ENCODED_ELTS (@var{v})} gives a pointer to the elements\n+encoded in @var{v} and @code{VECTOR_CST_ENCODED_ELT (@var{v}, @var{i})}\n+accesses the value of encoded element @var{i}.\n+\n+@samp{VECTOR_CST_DUPLICATE_P (@var{v})} is true if @var{v} simply contains\n+repeated instances of @samp{VECTOR_CST_NPATTERNS (@var{v})} values.  This is\n+a shorthand for testing @samp{VECTOR_CST_NELTS_PER_PATTERN (@var{v}) == 1}.\n+\n+@samp{VECTOR_CST_STEPPED_P (@var{v})} is true if at least one\n+pattern in @var{v} has a nonzero step.  This is a shorthand for\n+testing @samp{VECTOR_CST_NELTS_PER_PATTERN (@var{v}) == 3}.\n+\n+The utility function @code{vector_cst_elt} gives the value of an\n+arbitrary index as a @code{tree}.  @code{vector_cst_int_elt} gives\n+the same value as a @code{wide_int}.\n \n @item STRING_CST\n These nodes represent string-constants.  The @code{TREE_STRING_LENGTH}"}, {"sha": "2df78637f42d3c71fac0185c2b0c80de40437532", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -11610,9 +11610,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t  unsigned int nelts = VECTOR_CST_NELTS (arg0);\n \t\t  auto_vec<tree, 32> elts (nelts);\n \t\t  elts.quick_grow (nelts);\n-\t\t  memcpy (&elts[0], VECTOR_CST_ELTS (arg0),\n-\t\t\t  sizeof (tree) * nelts);\n-\t\t  elts[k] = arg1;\n+\t\t  for (unsigned int i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n+\t\t    elts[i] = (i == k ? arg1 : VECTOR_CST_ELT (arg0, i));\n \t\t  return build_vector (type, elts);\n \t\t}\n \t    }"}, {"sha": "4efa9c9c2fccfa1ba8c17eede0f2d0774fe9eb9a", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -747,8 +747,9 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     {\n-      for (unsigned i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\tDFS_follow_tree_edge (VECTOR_CST_ELT (expr, i));\n+      unsigned int count = vector_cst_encoded_nelts (expr);\n+      for (unsigned int i = 0; i < count; ++i)\n+\tDFS_follow_tree_edge (VECTOR_CST_ENCODED_ELT (expr, i));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n@@ -1195,8 +1196,11 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    for (unsigned i = 0; i < VECTOR_CST_NELTS (t); ++i)\n-      visit (VECTOR_CST_ELT (t, i));\n+    {\n+      unsigned int count = vector_cst_encoded_nelts (t);\n+      for (unsigned int i = 0; i < count; ++i)\n+\tvisit (VECTOR_CST_ENCODED_ELT (t, i));\n+    }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n     {"}, {"sha": "4823dc25f3e0da56fd531f2314b1db8806d937c2", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1,3 +1,7 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* lto.c (compare_tree_sccs_1): Compare the new VECTOR_CST flags.\n+\n 2017-12-07  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81544"}, {"sha": "e330644e2ef5d2a88d2b5009795888bb64bbfb91", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1065,6 +1065,12 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \t\t\tTREE_FIXED_CST_PTR (t1), TREE_FIXED_CST_PTR (t2)))\n       return false;\n \n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    {\n+      compare_values (VECTOR_CST_LOG2_NPATTERNS);\n+      compare_values (VECTOR_CST_NELTS_PER_PATTERN);\n+    }\n+\n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n     {\n       compare_values (DECL_MODE);\n@@ -1281,11 +1287,12 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     {\n-      unsigned i;\n       /* Note that the number of elements for EXPR has already been emitted\n \t in EXPR's header (see streamer_write_tree_header).  */\n-      for (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n-\tcompare_tree_edges (VECTOR_CST_ELT (t1, i), VECTOR_CST_ELT (t2, i));\n+      unsigned int count = vector_cst_encoded_nelts (t1);\n+      for (unsigned int i = 0; i < count; ++i)\n+\tcompare_tree_edges (VECTOR_CST_ENCODED_ELT (t1, i),\n+\t\t\t    VECTOR_CST_ENCODED_ELT (t2, i));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))"}, {"sha": "f225f999fc8c7dd5eb17de03bdcd0f2d49a18072", "filename": "gcc/tree-core.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -972,8 +972,17 @@ struct GTY(()) tree_base {\n     /* VEC length.  This field is only used with TREE_VEC.  */\n     int length;\n \n-    /* Number of elements.  This field is only used with VECTOR_CST.  */\n-    unsigned int nelts;\n+    /* This field is only used with VECTOR_CST.  */\n+    struct {\n+      /* The value of VECTOR_CST_LOG2_NPATTERNS.  */\n+      unsigned int log2_npatterns : 8;\n+\n+      /* The value of VECTOR_CST_NELTS_PER_PATTERN.  */\n+      unsigned int nelts_per_pattern : 8;\n+\n+      /* For future expansion.  */\n+      unsigned int unused : 16;\n+    } vector_cst;\n \n     /* SSA version number.  This field is only used with SSA_NAME.  */\n     unsigned int version;\n@@ -1325,7 +1334,7 @@ struct GTY(()) tree_complex {\n \n struct GTY(()) tree_vector {\n   struct tree_typed typed;\n-  tree GTY ((length (\"VECTOR_CST_NELTS ((tree) &%h)\"))) elts[1];\n+  tree GTY ((length (\"vector_cst_encoded_nelts ((tree) &%h)\"))) elts[1];\n };\n \n struct GTY(()) tree_identifier {"}, {"sha": "09201393cd3116688e77959aa56b14efba1fc9e3", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -592,8 +592,10 @@ streamer_alloc_tree (struct lto_input_block *ib, struct data_in *data_in,\n     }\n   else if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n     {\n-      HOST_WIDE_INT len = streamer_read_hwi (ib);\n-      result = make_vector (len);\n+      bitpack_d bp = streamer_read_bitpack (ib);\n+      unsigned int log2_npatterns = bp_unpack_value (&bp, 8);\n+      unsigned int nelts_per_pattern = bp_unpack_value (&bp, 8);\n+      result = make_vector (log2_npatterns, nelts_per_pattern);\n     }\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n     {\n@@ -650,9 +652,9 @@ static void\n lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t   struct data_in *data_in, tree expr)\n {\n-  unsigned i;\n-  for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-    VECTOR_CST_ELT (expr, i) = stream_read_tree (ib, data_in);\n+  unsigned int count = vector_cst_encoded_nelts (expr);\n+  for (unsigned int i = 0; i < count; ++i)\n+    VECTOR_CST_ENCODED_ELT (expr, i) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "921cb874dccdd7e5d68047f18b2fce9facaacdef", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -533,11 +533,11 @@ write_ts_common_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n static void\n write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n-  unsigned i;\n   /* Note that the number of elements for EXPR has already been emitted\n      in EXPR's header (see streamer_write_tree_header).  */\n-  for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-    stream_write_tree (ob, VECTOR_CST_ELT (expr, i), ref_p);\n+  unsigned int count = vector_cst_encoded_nelts (expr);\n+  for (unsigned int i = 0; i < count; ++i)\n+    stream_write_tree (ob, VECTOR_CST_ENCODED_ELT (expr, i), ref_p);\n }\n \n \n@@ -960,7 +960,12 @@ streamer_write_tree_header (struct output_block *ob, tree expr)\n   else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n     write_identifier (ob, ob->main_stream, expr);\n   else if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    streamer_write_hwi (ob, VECTOR_CST_NELTS (expr));\n+    {\n+      bitpack_d bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, VECTOR_CST_LOG2_NPATTERNS (expr), 8);\n+      bp_pack_value (&bp, VECTOR_CST_NELTS_PER_PATTERN (expr), 8);\n+      streamer_write_bitpack (&bp);\n+    }\n   else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n     streamer_write_hwi (ob, TREE_VEC_LENGTH (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))"}, {"sha": "708bf0e1a059aec7dd27df24497026666db5bd15", "filename": "gcc/tree-vector-builder.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -0,0 +1,64 @@\n+/* A class for building vector tree constants.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"tree-vector-builder.h\"\n+\n+/* Try to start building a new vector of type TYPE that holds the result of\n+   a unary operation on VECTOR_CST T.  ALLOW_STEPPED_P is true if the\n+   operation can handle stepped encodings directly, without having to\n+   expand the full sequence.\n+\n+   Return true if the operation is possible, which it always is when\n+   ALLOW_STEPPED_P is true.  Leave the builder unchanged otherwise.  */\n+\n+bool\n+tree_vector_builder::new_unary_operation (tree type, tree t,\n+\t\t\t\t\t  bool allow_stepped_p)\n+{\n+  unsigned int full_nelts = TYPE_VECTOR_SUBPARTS (type);\n+  gcc_assert (full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t)));\n+  unsigned int npatterns = VECTOR_CST_NPATTERNS (t);\n+  unsigned int nelts_per_pattern = VECTOR_CST_NELTS_PER_PATTERN (t);\n+  if (!allow_stepped_p && nelts_per_pattern > 2)\n+    {\n+      npatterns = full_nelts;\n+      nelts_per_pattern = 1;\n+    }\n+  new_vector (type, npatterns, nelts_per_pattern);\n+  return true;\n+}\n+\n+/* Return a VECTOR_CST for the current constant.  */\n+\n+tree\n+tree_vector_builder::build ()\n+{\n+  finalize ();\n+  gcc_assert (pow2p_hwi (npatterns ()));\n+  tree v = make_vector (exact_log2 (npatterns ()), nelts_per_pattern ());\n+  TREE_TYPE (v) = m_type;\n+  memcpy (VECTOR_CST_ENCODED_ELTS (v), address (),\n+\t  encoded_nelts () * sizeof (tree));\n+  return v;\n+}"}, {"sha": "b7b56259b8c70cfb61e6ad563caa70ad16aed8de", "filename": "gcc/tree-vector-builder.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.h?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -0,0 +1,135 @@\n+/* A class for building vector tree constants.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_VECTOR_BUILDER_H\n+#define GCC_TREE_VECTOR_BUILDER_H\n+\n+#include \"vector-builder.h\"\n+\n+/* This class is used to build VECTOR_CSTs from a sequence of elements.\n+   See vector_builder for more details.  */\n+class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n+{\n+  typedef vector_builder<tree, tree_vector_builder> parent;\n+  friend class vector_builder<tree, tree_vector_builder>;\n+\n+public:\n+  tree_vector_builder () : m_type (0) {}\n+  tree_vector_builder (tree, unsigned int, unsigned int);\n+  tree build ();\n+\n+  tree type () const { return m_type; }\n+\n+  void new_vector (tree, unsigned int, unsigned int);\n+  bool new_unary_operation (tree, tree, bool);\n+\n+private:\n+  bool equal_p (const_tree, const_tree) const;\n+  bool allow_steps_p () const;\n+  bool integral_p (const_tree) const;\n+  wide_int step (const_tree, const_tree) const;\n+  bool can_elide_p (const_tree) const;\n+  void note_representative (tree *, tree);\n+\n+  tree m_type;\n+};\n+\n+/* Create a new builder for a vector of type TYPE.  Initially encode the\n+   value as NPATTERNS interleaved patterns with NELTS_PER_PATTERN elements\n+   each.  */\n+\n+inline\n+tree_vector_builder::tree_vector_builder (tree type, unsigned int npatterns,\n+\t\t\t\t\t  unsigned int nelts_per_pattern)\n+{\n+  new_vector (type, npatterns, nelts_per_pattern);\n+}\n+\n+/* Start building a new vector of type TYPE.  Initially encode the value\n+   as NPATTERNS interleaved patterns with NELTS_PER_PATTERN elements each.  */\n+\n+inline void\n+tree_vector_builder::new_vector (tree type, unsigned int npatterns,\n+\t\t\t\t unsigned int nelts_per_pattern)\n+{\n+  m_type = type;\n+  parent::new_vector (TYPE_VECTOR_SUBPARTS (type), npatterns,\n+\t\t      nelts_per_pattern);\n+}\n+\n+/* Return true if elements I1 and I2 are equal.  */\n+\n+inline bool\n+tree_vector_builder::equal_p (const_tree elt1, const_tree elt2) const\n+{\n+  return operand_equal_p (elt1, elt2, 0);\n+}\n+\n+/* Return true if a stepped representation is OK.  We don't allow\n+   linear series for anything other than integers, to avoid problems\n+   with rounding.  */\n+\n+inline bool\n+tree_vector_builder::allow_steps_p () const\n+{\n+  return INTEGRAL_TYPE_P (TREE_TYPE (m_type));\n+}\n+\n+/* Return true if ELT can be interpreted as an integer.  */\n+\n+inline bool\n+tree_vector_builder::integral_p (const_tree elt) const\n+{\n+  return TREE_CODE (elt) == INTEGER_CST;\n+}\n+\n+/* Return the value of element ELT2 minus the value of element ELT1.\n+   Both elements are known to be INTEGER_CSTs.  */\n+\n+inline wide_int\n+tree_vector_builder::step (const_tree elt1, const_tree elt2) const\n+{\n+  return wi::to_wide (elt2) - wi::to_wide (elt1);\n+}\n+\n+/* Return true if we can drop element ELT, even if the retained elements\n+   are different.  Return false if this would mean losing overflow\n+   information.  */\n+\n+inline bool\n+tree_vector_builder::can_elide_p (const_tree elt) const\n+{\n+  return !CONSTANT_CLASS_P (elt) || !TREE_OVERFLOW (elt);\n+}\n+\n+/* Record that ELT2 is being elided, given that ELT1_PTR points to the last\n+   encoded element for the containing pattern.  */\n+\n+inline void\n+tree_vector_builder::note_representative (tree *elt1_ptr, tree elt2)\n+{\n+  if (CONSTANT_CLASS_P (elt2) && TREE_OVERFLOW (elt2))\n+    {\n+      gcc_assert (operand_equal_p (*elt1_ptr, elt2, 0));\n+      if (!TREE_OVERFLOW (elt2))\n+\t*elt1_ptr = elt2;\n+    }\n+}\n+\n+#endif"}, {"sha": "e3a60fb3e141640123a5396c1d0b65b387028271", "filename": "gcc/tree.c", "status": "modified", "additions": 223, "deletions": 38, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Tree code classes.  */\n \n@@ -837,7 +838,7 @@ tree_code_size (enum tree_code code)\n \tcase REAL_CST:\t\treturn sizeof (tree_real_cst);\n \tcase FIXED_CST:\t\treturn sizeof (tree_fixed_cst);\n \tcase COMPLEX_CST:\treturn sizeof (tree_complex);\n-\tcase VECTOR_CST:\treturn sizeof (tree_vector);\n+\tcase VECTOR_CST:\tgcc_unreachable ();\n \tcase STRING_CST:\tgcc_unreachable ();\n \tdefault:\n \t  gcc_checking_assert (code >= NUM_TREE_CODES);\n@@ -897,7 +898,7 @@ tree_size (const_tree node)\n \n     case VECTOR_CST:\n       return (sizeof (struct tree_vector)\n-\t      + (VECTOR_CST_NELTS (node) - 1) * sizeof (tree));\n+\t      + (vector_cst_encoded_nelts (node) - 1) * sizeof (tree));\n \n     case STRING_CST:\n       return TREE_STRING_LENGTH (node) + offsetof (struct tree_string, str) + 1;\n@@ -1708,21 +1709,28 @@ cst_and_fits_in_hwi (const_tree x)\n \t  && (tree_fits_shwi_p (x) || tree_fits_uhwi_p (x)));\n }\n \n-/* Build a newly constructed VECTOR_CST node of length LEN.  */\n+/* Build a newly constructed VECTOR_CST with the given values of\n+   (VECTOR_CST_)LOG2_NPATTERNS and (VECTOR_CST_)NELTS_PER_PATTERN.  */\n \n tree\n-make_vector (unsigned len MEM_STAT_DECL)\n+make_vector (unsigned log2_npatterns,\n+\t     unsigned int nelts_per_pattern MEM_STAT_DECL)\n {\n+  gcc_assert (IN_RANGE (nelts_per_pattern, 1, 3));\n   tree t;\n-  unsigned length = (len - 1) * sizeof (tree) + sizeof (struct tree_vector);\n+  unsigned npatterns = 1 << log2_npatterns;\n+  unsigned encoded_nelts = npatterns * nelts_per_pattern;\n+  unsigned length = (sizeof (struct tree_vector)\n+\t\t     + (encoded_nelts - 1) * sizeof (tree));\n \n   record_node_allocation_statistics (VECTOR_CST, length);\n \n   t = ggc_alloc_cleared_tree_node_stat (length PASS_MEM_STAT);\n \n   TREE_SET_CODE (t, VECTOR_CST);\n   TREE_CONSTANT (t) = 1;\n-  VECTOR_CST_NELTS (t) = len;\n+  VECTOR_CST_LOG2_NPATTERNS (t) = log2_npatterns;\n+  VECTOR_CST_NELTS_PER_PATTERN (t) = nelts_per_pattern;\n \n   return t;\n }\n@@ -1733,29 +1741,10 @@ make_vector (unsigned len MEM_STAT_DECL)\n tree\n build_vector (tree type, vec<tree> vals MEM_STAT_DECL)\n {\n-  unsigned int nelts = vals.length ();\n-  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n-  int over = 0;\n-  unsigned cnt = 0;\n-  tree v = make_vector (nelts);\n-  TREE_TYPE (v) = type;\n-\n-  /* Iterate through elements and check for overflow.  */\n-  for (cnt = 0; cnt < nelts; ++cnt)\n-    {\n-      tree value = vals[cnt];\n-\n-      VECTOR_CST_ELT (v, cnt) = value;\n-\n-      /* Don't crash if we get an address constant.  */\n-      if (!CONSTANT_CLASS_P (value))\n-\tcontinue;\n-\n-      over |= TREE_OVERFLOW (value);\n-    }\n-\n-  TREE_OVERFLOW (v) = over;\n-  return v;\n+  gcc_assert (vals.length () == TYPE_VECTOR_SUBPARTS (type));\n+  tree_vector_builder builder (type, vals.length (), 1);\n+  builder.splice (vals);\n+  return builder.build ();\n }\n \n /* Return a new VECTOR_CST node whose type is TYPE and whose values\n@@ -10370,6 +10359,59 @@ build_opaque_vector_type (tree innertype, int nunits)\n   return cand;\n }\n \n+/* Return the value of element I of VECTOR_CST T as a wide_int.  */\n+\n+wide_int\n+vector_cst_int_elt (const_tree t, unsigned int i)\n+{\n+  /* First handle elements that are directly encoded.  */\n+  unsigned int encoded_nelts = vector_cst_encoded_nelts (t);\n+  if (i < encoded_nelts)\n+    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, i));\n+\n+  /* Identify the pattern that contains element I and work out the index of\n+     the last encoded element for that pattern.  */\n+  unsigned int npatterns = VECTOR_CST_NPATTERNS (t);\n+  unsigned int pattern = i % npatterns;\n+  unsigned int count = i / npatterns;\n+  unsigned int final_i = encoded_nelts - npatterns + pattern;\n+\n+  /* If there are no steps, the final encoded value is the right one.  */\n+  if (!VECTOR_CST_STEPPED_P (t))\n+    return wi::to_wide (VECTOR_CST_ENCODED_ELT (t, final_i));\n+\n+  /* Otherwise work out the value from the last two encoded elements.  */\n+  tree v1 = VECTOR_CST_ENCODED_ELT (t, final_i - npatterns);\n+  tree v2 = VECTOR_CST_ENCODED_ELT (t, final_i);\n+  wide_int diff = wi::to_wide (v2) - wi::to_wide (v1);\n+  return wi::to_wide (v2) + (count - 2) * diff;\n+}\n+\n+/* Return the value of element I of VECTOR_CST T.  */\n+\n+tree\n+vector_cst_elt (const_tree t, unsigned int i)\n+{\n+  /* First handle elements that are directly encoded.  */\n+  unsigned int encoded_nelts = vector_cst_encoded_nelts (t);\n+  if (i < encoded_nelts)\n+    return VECTOR_CST_ENCODED_ELT (t, i);\n+\n+  /* If there are no steps, the final encoded value is the right one.  */\n+  if (!VECTOR_CST_STEPPED_P (t))\n+    {\n+      /* Identify the pattern that contains element I and work out the index of\n+\t the last encoded element for that pattern.  */\n+      unsigned int npatterns = VECTOR_CST_NPATTERNS (t);\n+      unsigned int pattern = i % npatterns;\n+      unsigned int final_i = encoded_nelts - npatterns + pattern;\n+      return VECTOR_CST_ENCODED_ELT (t, final_i);\n+    }\n+\n+  /* Otherwise work out the value from the last two encoded elements.  */\n+  return wide_int_to_tree (TREE_TYPE (TREE_TYPE (t)),\n+\t\t\t   vector_cst_int_elt (t, i));\n+}\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  */\n@@ -12451,6 +12493,23 @@ drop_tree_overflow (tree t)\n   if (TREE_CODE (t) == INTEGER_CST)\n     return wide_int_to_tree (TREE_TYPE (t), wi::to_wide (t));\n \n+  /* For VECTOR_CST, remove the overflow bits from the encoded elements\n+     and canonicalize the result.  */\n+  if (TREE_CODE (t) == VECTOR_CST)\n+    {\n+      tree_vector_builder builder;\n+      builder.new_unary_operation (TREE_TYPE (t), t, true);\n+      unsigned int count = builder.encoded_nelts ();\n+      for (unsigned int i = 0; i < count; ++i)\n+\t{\n+\t  tree elt = VECTOR_CST_ELT (t, i);\n+\t  if (TREE_OVERFLOW (elt))\n+\t    elt = drop_tree_overflow (elt);\n+\t  builder.quick_push (elt);\n+\t}\n+      return builder.build ();\n+    }\n+\n   /* Otherwise, as all tcc_constants are possibly shared, copy the node\n      and drop the flag.  */\n   t = copy_node (t);\n@@ -12465,15 +12524,7 @@ drop_tree_overflow (tree t)\n       if (TREE_OVERFLOW (TREE_IMAGPART (t)))\n \tTREE_IMAGPART (t) = drop_tree_overflow (TREE_IMAGPART (t));\n     }\n-  if (TREE_CODE (t) == VECTOR_CST)\n-    {\n-      for (unsigned i = 0; i < VECTOR_CST_NELTS (t); ++i)\n-\t{\n-\t  tree& elt = VECTOR_CST_ELT (t, i);\n-\t  if (TREE_OVERFLOW (elt))\n-\t    elt = drop_tree_overflow (elt);\n-\t}\n-    }\n+\n   return t;\n }\n \n@@ -14016,6 +14067,139 @@ test_labels ()\n   ASSERT_FALSE (FORCED_LABEL (label_decl));\n }\n \n+/* Check that VECTOR_CST ACTUAL contains the elements in EXPECTED.  */\n+\n+static void\n+check_vector_cst (vec<tree> expected, tree actual)\n+{\n+  ASSERT_EQ (expected.length (), TYPE_VECTOR_SUBPARTS (TREE_TYPE (actual)));\n+  for (unsigned int i = 0; i < expected.length (); ++i)\n+    ASSERT_EQ (wi::to_wide (expected[i]),\n+\t       wi::to_wide (vector_cst_elt (actual, i)));\n+}\n+\n+/* Check that VECTOR_CST ACTUAL contains NPATTERNS duplicated elements,\n+   and that its elements match EXPECTED.  */\n+\n+static void\n+check_vector_cst_duplicate (vec<tree> expected, tree actual,\n+\t\t\t    unsigned int npatterns)\n+{\n+  ASSERT_EQ (npatterns, VECTOR_CST_NPATTERNS (actual));\n+  ASSERT_EQ (1, VECTOR_CST_NELTS_PER_PATTERN (actual));\n+  ASSERT_EQ (npatterns, vector_cst_encoded_nelts (actual));\n+  ASSERT_TRUE (VECTOR_CST_DUPLICATE_P (actual));\n+  ASSERT_FALSE (VECTOR_CST_STEPPED_P (actual));\n+  check_vector_cst (expected, actual);\n+}\n+\n+/* Check that VECTOR_CST ACTUAL contains NPATTERNS foreground elements\n+   and NPATTERNS background elements, and that its elements match\n+   EXPECTED.  */\n+\n+static void\n+check_vector_cst_fill (vec<tree> expected, tree actual,\n+\t\t       unsigned int npatterns)\n+{\n+  ASSERT_EQ (npatterns, VECTOR_CST_NPATTERNS (actual));\n+  ASSERT_EQ (2, VECTOR_CST_NELTS_PER_PATTERN (actual));\n+  ASSERT_EQ (2 * npatterns, vector_cst_encoded_nelts (actual));\n+  ASSERT_FALSE (VECTOR_CST_DUPLICATE_P (actual));\n+  ASSERT_FALSE (VECTOR_CST_STEPPED_P (actual));\n+  check_vector_cst (expected, actual);\n+}\n+\n+/* Check that VECTOR_CST ACTUAL contains NPATTERNS stepped patterns,\n+   and that its elements match EXPECTED.  */\n+\n+static void\n+check_vector_cst_stepped (vec<tree> expected, tree actual,\n+\t\t\t  unsigned int npatterns)\n+{\n+  ASSERT_EQ (npatterns, VECTOR_CST_NPATTERNS (actual));\n+  ASSERT_EQ (3, VECTOR_CST_NELTS_PER_PATTERN (actual));\n+  ASSERT_EQ (3 * npatterns, vector_cst_encoded_nelts (actual));\n+  ASSERT_FALSE (VECTOR_CST_DUPLICATE_P (actual));\n+  ASSERT_TRUE (VECTOR_CST_STEPPED_P (actual));\n+  check_vector_cst (expected, actual);\n+}\n+\n+/* Test the creation of VECTOR_CSTs.  */\n+\n+static void\n+test_vector_cst_patterns ()\n+{\n+  auto_vec<tree, 8> elements (8);\n+  elements.quick_grow (8);\n+  tree element_type = build_nonstandard_integer_type (16, true);\n+  tree vector_type = build_vector_type (element_type, 8);\n+\n+  /* Test a simple linear series with a base of 0 and a step of 1:\n+     { 0, 1, 2, 3, 4, 5, 6, 7 }.  */\n+  for (unsigned int i = 0; i < 8; ++i)\n+    elements[i] = build_int_cst (element_type, i);\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+\n+  /* Try the same with the first element replaced by 100:\n+     { 100, 1, 2, 3, 4, 5, 6, 7 }.  */\n+  elements[0] = build_int_cst (element_type, 100);\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+\n+  /* Try a series that wraps around.\n+     { 100, 65531, 65532, 65533, 65534, 65535, 0, 1 }.  */\n+  for (unsigned int i = 1; i < 8; ++i)\n+    elements[i] = build_int_cst (element_type, (65530 + i) & 0xffff);\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+\n+  /* Try a downward series:\n+     { 100, 79, 78, 77, 76, 75, 75, 73 }.  */\n+  for (unsigned int i = 1; i < 8; ++i)\n+    elements[i] = build_int_cst (element_type, 80 - i);\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+\n+  /* Try two interleaved series with different bases and steps:\n+     { 100, 53, 66, 206, 62, 212, 58, 218 }.  */\n+  elements[1] = build_int_cst (element_type, 53);\n+  for (unsigned int i = 2; i < 8; i += 2)\n+    {\n+      elements[i] = build_int_cst (element_type, 70 - i * 2);\n+      elements[i + 1] = build_int_cst (element_type, 200 + i * 3);\n+    }\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 2);\n+\n+  /* Try a duplicated value:\n+     { 100, 100, 100, 100, 100, 100, 100, 100 }.  */\n+  for (unsigned int i = 1; i < 8; ++i)\n+    elements[i] = elements[0];\n+  check_vector_cst_duplicate (elements,\n+\t\t\t      build_vector (vector_type, elements), 1);\n+\n+  /* Try an interleaved duplicated value:\n+     { 100, 55, 100, 55, 100, 55, 100, 55 }.  */\n+  elements[1] = build_int_cst (element_type, 55);\n+  for (unsigned int i = 2; i < 8; ++i)\n+    elements[i] = elements[i - 2];\n+  check_vector_cst_duplicate (elements,\n+\t\t\t      build_vector (vector_type, elements), 2);\n+\n+  /* Try a duplicated value with 2 exceptions\n+     { 41, 97, 100, 55, 100, 55, 100, 55 }.  */\n+  elements[0] = build_int_cst (element_type, 41);\n+  elements[1] = build_int_cst (element_type, 97);\n+  check_vector_cst_fill (elements, build_vector (vector_type, elements), 2);\n+\n+  /* Try with and without a step\n+     { 41, 97, 100, 21, 100, 35, 100, 49 }.  */\n+  for (unsigned int i = 3; i < 8; i += 2)\n+    elements[i] = build_int_cst (element_type, i * 7);\n+  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 2);\n+\n+  /* Try a fully-general constant:\n+     { 41, 97, 100, 21, 100, 9990, 100, 49 }.  */\n+  elements[5] = build_int_cst (element_type, 9990);\n+  check_vector_cst_fill (elements, build_vector (vector_type, elements), 4);\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -14024,6 +14208,7 @@ tree_c_tests ()\n   test_integer_constants ();\n   test_identifiers ();\n   test_labels ();\n+  test_vector_cst_patterns ();\n }\n \n } // namespace selftest"}, {"sha": "edcb7effd50e491e5d04a406f5e29ef5c700093a", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -301,7 +301,7 @@ DEFTREECODE (FIXED_CST, \"fixed_cst\", tcc_constant, 0)\n    whose contents are other constant nodes.  */\n DEFTREECODE (COMPLEX_CST, \"complex_cst\", tcc_constant, 0)\n \n-/* Contents are in VECTOR_CST_ELTS field.  */\n+/* See generic.texi for details.  */\n DEFTREECODE (VECTOR_CST, \"vector_cst\", tcc_constant, 0)\n \n /* Contents are TREE_STRING_LENGTH and the actual contents of the string.  */"}, {"sha": "b3cf74779bac66629ec2a9322f13c624475b33f0", "filename": "gcc/tree.h", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -1008,10 +1008,24 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.real)\n #define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.imag)\n \n-/* In a VECTOR_CST node.  */\n-#define VECTOR_CST_NELTS(NODE) (VECTOR_CST_CHECK (NODE)->base.u.nelts)\n-#define VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elts)\n-#define VECTOR_CST_ELT(NODE,IDX) (VECTOR_CST_CHECK (NODE)->vector.elts[IDX])\n+/* In a VECTOR_CST node.  See generic.texi for details.  */\n+#define VECTOR_CST_NELTS(NODE) (TYPE_VECTOR_SUBPARTS (TREE_TYPE (NODE)))\n+#define VECTOR_CST_ELT(NODE,IDX) vector_cst_elt (NODE, IDX)\n+\n+#define VECTOR_CST_LOG2_NPATTERNS(NODE) \\\n+  (VECTOR_CST_CHECK (NODE)->base.u.vector_cst.log2_npatterns)\n+#define VECTOR_CST_NPATTERNS(NODE) \\\n+  (1U << VECTOR_CST_LOG2_NPATTERNS (NODE))\n+#define VECTOR_CST_NELTS_PER_PATTERN(NODE) \\\n+  (VECTOR_CST_CHECK (NODE)->base.u.vector_cst.nelts_per_pattern)\n+#define VECTOR_CST_DUPLICATE_P(NODE) \\\n+  (VECTOR_CST_NELTS_PER_PATTERN (NODE) == 1)\n+#define VECTOR_CST_STEPPED_P(NODE) \\\n+  (VECTOR_CST_NELTS_PER_PATTERN (NODE) == 3)\n+#define VECTOR_CST_ENCODED_ELTS(NODE) \\\n+  (VECTOR_CST_CHECK (NODE)->vector.elts)\n+#define VECTOR_CST_ENCODED_ELT(NODE, ELT) \\\n+  (VECTOR_CST_CHECK (NODE)->vector.elts[ELT])\n \n /* Define fields and accessors for some special-purpose tree nodes.  */\n \n@@ -3882,6 +3896,14 @@ id_equal (const char *str, const_tree id)\n   ((NODE) == error_mark_node\t\t\t\t\t\\\n    || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n \n+/* Return the number of elements encoded directly in a VECTOR_CST.  */\n+\n+inline unsigned int\n+vector_cst_encoded_nelts (const_tree t)\n+{\n+  return VECTOR_CST_NPATTERNS (t) * VECTOR_CST_NELTS_PER_PATTERN (t);\n+}\n+\n extern tree decl_assembler_name (tree);\n extern void overwrite_decl_assembler_name (tree decl, tree name);\n extern tree decl_comdat_group (const_tree);\n@@ -4021,7 +4043,7 @@ extern tree force_fit_type (tree, const wide_int_ref &, int, bool);\n extern tree build_int_cst (tree, HOST_WIDE_INT);\n extern tree build_int_cstu (tree type, unsigned HOST_WIDE_INT cst);\n extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n-extern tree make_vector (unsigned CXX_MEM_STAT_INFO);\n+extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);\n extern tree build_vector (tree, vec<tree> CXX_MEM_STAT_INFO);\n extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);\n extern tree build_vector_from_val (tree, tree);\n@@ -4268,6 +4290,9 @@ extern tree first_field (const_tree);\n \n extern bool initializer_zerop (const_tree);\n \n+extern wide_int vector_cst_int_elt (const_tree, unsigned int);\n+extern tree vector_cst_elt (const_tree, unsigned int);\n+\n /* Given a vector VEC, return its first element if all elements are\n    the same.  Otherwise return NULL_TREE.  */\n "}, {"sha": "ae30b3bba2f9cbe807e648809e3339302bf5e90c", "filename": "gcc/vector-builder.h", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/734914b6e230b78eb6c34fbd5a2d93b1a919d36a/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "patch": "@@ -0,0 +1,394 @@\n+/* A class for building vector constant patterns.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VECTOR_BUILDER_H\n+#define GCC_VECTOR_BUILDER_H\n+\n+/* This class is a wrapper around auto_vec<T> for building vectors of T.\n+   It aims to encode each vector as npatterns interleaved patterns,\n+   where each pattern represents a sequence:\n+\n+     { BASE0, BASE1, BASE1 + STEP, BASE1 + STEP*2, BASE1 + STEP*3, ... }\n+\n+   The first three elements in each pattern provide enough information\n+   to derive the other elements.  If all patterns have a STEP of zero,\n+   we only need to encode the first two elements in each pattern.\n+   If BASE1 is also equal to BASE0 for all patterns, we only need to\n+   encode the first element in each pattern.  The number of encoded\n+   elements per pattern is given by nelts_per_pattern.\n+\n+   The class can be used in two ways:\n+\n+   1. It can be used to build a full image of the vector, which is then\n+      canonicalized by finalize ().  In this case npatterns is initially\n+      the number of elements in the vector and nelts_per_pattern is\n+      initially 1.\n+\n+   2. It can be used to build a vector that already has a known encoding.\n+      This is preferred since it is more efficient and copes with\n+      variable-length vectors.  finalize () then canonicalizes the encoding\n+      to a simpler form if possible.\n+\n+   The derived class Derived provides this functionality for specific Ts.\n+   Derived needs to provide the following interface:\n+\n+      bool equal_p (T elt1, T elt2) const;\n+\n+\t  Return true if elements ELT1 and ELT2 are equal.\n+\n+      bool allow_steps_p () const;\n+\n+\t  Return true if a stepped representation is OK.  We don't allow\n+\t  linear series for anything other than integers, to avoid problems\n+\t  with rounding.\n+\n+      bool integral_p (T elt) const;\n+\n+\t  Return true if element ELT can be interpreted as an integer.\n+\n+      StepType step (T elt1, T elt2) const;\n+\n+\t  Return the value of element ELT2 minus the value of element ELT1,\n+\t  given integral_p (ELT1) && integral_p (ELT2).  There is no fixed\n+\t  choice of StepType.\n+\n+      bool can_elide_p (T elt) const;\n+\n+\t  Return true if we can drop element ELT, even if the retained\n+\t  elements are different.  This is provided for TREE_OVERFLOW\n+\t  handling.\n+\n+      void note_representative (T *elt1_ptr, T elt2);\n+\n+\t  Record that ELT2 is being elided, given that ELT1_PTR points to\n+\t  the last encoded element for the containing pattern.  This is\n+\t  again provided for TREE_OVERFLOW handling.  */\n+\n+template<typename T, typename Derived>\n+class vector_builder : public auto_vec<T, 32>\n+{\n+public:\n+  vector_builder ();\n+\n+  unsigned int full_nelts () const { return m_full_nelts; }\n+  unsigned int npatterns () const { return m_npatterns; }\n+  unsigned int nelts_per_pattern () const { return m_nelts_per_pattern; }\n+  unsigned int encoded_nelts () const;\n+  bool encoded_full_vector_p () const;\n+\n+  void finalize ();\n+\n+protected:\n+  void new_vector (unsigned int, unsigned int, unsigned int);\n+  void reshape (unsigned int, unsigned int);\n+  bool repeating_sequence_p (unsigned int, unsigned int, unsigned int);\n+  bool stepped_sequence_p (unsigned int, unsigned int, unsigned int);\n+  bool try_npatterns (unsigned int);\n+\n+private:\n+  vector_builder (const vector_builder &);\n+  vector_builder &operator= (const vector_builder &);\n+  Derived *derived () { return static_cast<Derived *> (this); }\n+  const Derived *derived () const;\n+\n+  unsigned int m_full_nelts;\n+  unsigned int m_npatterns;\n+  unsigned int m_nelts_per_pattern;\n+};\n+\n+template<typename T, typename Derived>\n+inline const Derived *\n+vector_builder<T, Derived>::derived () const\n+{\n+  return static_cast<const Derived *> (this);\n+}\n+\n+template<typename T, typename Derived>\n+inline\n+vector_builder<T, Derived>::vector_builder ()\n+  : m_full_nelts (0),\n+    m_npatterns (0),\n+    m_nelts_per_pattern (0)\n+{}\n+\n+/* Return the number of elements that are explicitly encoded.  The vec\n+   starts with these explicitly-encoded elements and may contain additional\n+   elided elements.  */\n+\n+template<typename T, typename Derived>\n+inline unsigned int\n+vector_builder<T, Derived>::encoded_nelts () const\n+{\n+  return m_npatterns * m_nelts_per_pattern;\n+}\n+\n+/* Return true if every element of the vector is explicitly encoded.  */\n+\n+template<typename T, typename Derived>\n+inline bool\n+vector_builder<T, Derived>::encoded_full_vector_p () const\n+{\n+  return m_npatterns * m_nelts_per_pattern == m_full_nelts;\n+}\n+\n+/* Start building a vector that has FULL_NELTS elements.  Initially\n+   encode it using NPATTERNS patterns with NELTS_PER_PATTERN each.  */\n+\n+template<typename T, typename Derived>\n+void\n+vector_builder<T, Derived>::new_vector (unsigned int full_nelts,\n+\t\t\t\t\tunsigned int npatterns,\n+\t\t\t\t\tunsigned int nelts_per_pattern)\n+{\n+  m_full_nelts = full_nelts;\n+  m_npatterns = npatterns;\n+  m_nelts_per_pattern = nelts_per_pattern;\n+  this->reserve (encoded_nelts ());\n+  this->truncate (0);\n+}\n+\n+/* Change the encoding to NPATTERNS patterns of NELTS_PER_PATTERN each,\n+   but without changing the underlying vector.  */\n+\n+template<typename T, typename Derived>\n+void\n+vector_builder<T, Derived>::reshape (unsigned int npatterns,\n+\t\t\t\t     unsigned int nelts_per_pattern)\n+{\n+  unsigned int old_encoded_nelts = encoded_nelts ();\n+  unsigned int new_encoded_nelts = npatterns * nelts_per_pattern;\n+  gcc_checking_assert (new_encoded_nelts <= old_encoded_nelts);\n+  unsigned int next = new_encoded_nelts - npatterns;\n+  for (unsigned int i = new_encoded_nelts; i < old_encoded_nelts; ++i)\n+    {\n+      derived ()->note_representative (&(*this)[next], (*this)[i]);\n+      next += 1;\n+      if (next == new_encoded_nelts)\n+\tnext -= npatterns;\n+    }\n+  m_npatterns = npatterns;\n+  m_nelts_per_pattern = nelts_per_pattern;\n+}\n+\n+/* Return true if elements [START, END) contain a repeating sequence of\n+   STEP elements.  */\n+\n+template<typename T, typename Derived>\n+bool\n+vector_builder<T, Derived>::repeating_sequence_p (unsigned int start,\n+\t\t\t\t\t\t  unsigned int end,\n+\t\t\t\t\t\t  unsigned int step)\n+{\n+  for (unsigned int i = start; i < end - step; ++i)\n+    if (!derived ()->equal_p ((*this)[i], (*this)[i + step]))\n+      return false;\n+  return true;\n+}\n+\n+/* Return true if elements [START, END) contain STEP interleaved linear\n+   series.  */\n+\n+template<typename T, typename Derived>\n+bool\n+vector_builder<T, Derived>::stepped_sequence_p (unsigned int start,\n+\t\t\t\t\t\tunsigned int end,\n+\t\t\t\t\t\tunsigned int step)\n+{\n+  if (!derived ()->allow_steps_p ())\n+    return false;\n+\n+  for (unsigned int i = start + step * 2; i < end; ++i)\n+    {\n+      T elt1 = (*this)[i - step * 2];\n+      T elt2 = (*this)[i - step];\n+      T elt3 = (*this)[i];\n+\n+      if (!derived ()->integral_p (elt1)\n+\t  || !derived ()->integral_p (elt2)\n+\t  || !derived ()->integral_p (elt3))\n+\treturn false;\n+\n+      if (derived ()->step (elt1, elt2) != derived ()->step (elt2, elt3))\n+\treturn false;\n+\n+      if (!derived ()->can_elide_p (elt3))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Try to change the number of encoded patterns to NPATTERNS, returning\n+   true on success.  */\n+\n+template<typename T, typename Derived>\n+bool\n+vector_builder<T, Derived>::try_npatterns (unsigned int npatterns)\n+{\n+  if (m_nelts_per_pattern == 1)\n+    {\n+      /* See whether NPATTERNS is valid with the current 1-element-per-pattern\n+\t encoding.  */\n+      if (repeating_sequence_p (0, encoded_nelts (), npatterns))\n+\t{\n+\t  reshape (npatterns, 1);\n+\t  return true;\n+\t}\n+\n+      /* We can only increase the number of elements per pattern if all\n+\t elements are still encoded explicitly.  */\n+      if (!encoded_full_vector_p ())\n+\treturn false;\n+    }\n+\n+  if (m_nelts_per_pattern <= 2)\n+    {\n+      /* See whether NPATTERNS is valid with a 2-element-per-pattern\n+\t encoding.  */\n+      if (repeating_sequence_p (npatterns, encoded_nelts (), npatterns))\n+\t{\n+\t  reshape (npatterns, 2);\n+\t  return true;\n+\t}\n+\n+      /* We can only increase the number of elements per pattern if all\n+\t elements are still encoded explicitly.  */\n+      if (!encoded_full_vector_p ())\n+\treturn false;\n+    }\n+\n+  if (m_nelts_per_pattern <= 3)\n+    {\n+      /* See whether we have NPATTERNS interleaved linear series,\n+\t giving a 3-element-per-pattern encoding.  */\n+      if (stepped_sequence_p (npatterns, encoded_nelts (), npatterns))\n+\t{\n+\t  reshape (npatterns, 3);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Replace the current encoding with the canonical form.  */\n+\n+template<typename T, typename Derived>\n+void\n+vector_builder<T, Derived>::finalize ()\n+{\n+  /* The encoding requires the same number of elements to come from each\n+     pattern.  */\n+  gcc_assert (m_full_nelts % m_npatterns == 0);\n+\n+  /* Allow the caller to build more elements than necessary.  For example,\n+     it's often convenient to build a stepped vector from the natural\n+     encoding of three elements even if the vector itself only has two.  */\n+  if (m_full_nelts <= encoded_nelts ())\n+    {\n+      m_npatterns = m_full_nelts;\n+      m_nelts_per_pattern = 1;\n+    }\n+\n+  /* Try to whittle down the number of elements per pattern.  That is:\n+\n+     1. If we have stepped patterns whose steps are all 0, reduce the\n+        number of elements per pattern from 3 to 2.\n+\n+     2. If we have background fill values that are the same as the\n+        foreground values, reduce the number of elements per pattern\n+        from 2 to 1.  */\n+  while (m_nelts_per_pattern > 1\n+\t && repeating_sequence_p (encoded_nelts () - m_npatterns * 2,\n+\t\t\t\t  encoded_nelts (), m_npatterns))\n+    /* The last two sequences of M_NPATTERNS elements are equal,\n+       so remove the last one.  */\n+    reshape (m_npatterns, m_nelts_per_pattern - 1);\n+\n+  if (pow2p_hwi (m_npatterns))\n+    {\n+      /* Try to halve the number of patterns while doing so gives a\n+\t valid pattern.  This approach is linear in the number of\n+\t elements, whereas searcing from 1 up would be O(n*log(n)).\n+\n+\t Each halving step tries to keep the number of elements per pattern\n+\t the same.  If that isn't possible, and if all elements are still\n+\t explicitly encoded, the halving step can instead increase the number\n+\t of elements per pattern.\n+\n+\t E.g. for:\n+\n+\t     { 0, 2, 3, 4, 5, 6, 7, 8 }  npatterns == 8  full_nelts == 8\n+\n+\t we first realize that the second half of the sequence is not\n+\t equal to the first, so we cannot maintain 1 element per pattern\n+\t for npatterns == 4.  Instead we halve the number of patterns\n+\t and double the number of elements per pattern, treating this\n+\t as a \"foreground\" { 0, 2, 3, 4 } against a \"background\" of\n+\t { 5, 6, 7, 8 | 5, 6, 7, 8 ... }:\n+\n+\t     { 0, 2, 3, 4 | 5, 6, 7, 8 }  npatterns == 4\n+\n+\t Next we realize that this is *not* a foreround of { 0, 2 }\n+\t against a background of { 3, 4 | 3, 4 ... }, so the only\n+\t remaining option for reducing the number of patterns is\n+\t to use a foreground of { 0, 2 } against a stepped background\n+\t of { 1, 2 | 3, 4 | 5, 6 ... }.  This is valid because we still\n+\t haven't elided any elements:\n+\n+\t     { 0, 2 | 3, 4 | 5, 6 }  npatterns == 2\n+\n+\t This in turn can be reduced to a foreground of { 0 } against a\n+\t stepped background of { 1 | 2 | 3 ... }:\n+\n+\t     { 0 | 2 | 3 }  npatterns == 1\n+\n+\t This last step would not have been possible for:\n+\n+\t     { 0, 0 | 3, 4 | 5, 6 }  npatterns == 2.  */\n+      while ((m_npatterns & 1) == 0 && try_npatterns (m_npatterns / 2))\n+\tcontinue;\n+\n+      /* Builders of arbitrary fixed-length vectors can use:\n+\n+\t     new_vector (x, x, 1)\n+\n+\t so that every element is specified explicitly.  Handle cases\n+\t that are actually wrapping series, like { 0, 1, 2, 3, 0, 1, 2, 3 }\n+\t would be for 2-bit elements.  We'll have treated them as\n+\t duplicates in the loop above.  */\n+      if (m_nelts_per_pattern == 1\n+\t  && this->length () >= m_full_nelts\n+\t  && (m_npatterns & 3) == 0\n+\t  && stepped_sequence_p (m_npatterns / 4, m_full_nelts,\n+\t\t\t\t m_npatterns / 4))\n+\t{\n+\t  reshape (m_npatterns / 4, 3);\n+\t  while ((m_npatterns & 1) == 0 && try_npatterns (m_npatterns / 2))\n+\t    continue;\n+\t}\n+    }\n+  else\n+    /* For the non-power-of-2 case, do a simple search up from 1.  */\n+    for (unsigned int i = 1; i <= m_npatterns / 2; ++i)\n+      if (m_npatterns % i == 0 && try_npatterns (i))\n+\tbreak;\n+}\n+\n+#endif"}]}