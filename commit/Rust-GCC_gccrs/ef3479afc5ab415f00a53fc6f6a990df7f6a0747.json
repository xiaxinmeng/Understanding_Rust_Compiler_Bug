{"sha": "ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzNDc5YWZjNWFiNDE1ZjAwYTUzZmM2ZjZhOTkwZGY3ZjZhMDc0Nw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-04-29T02:30:44Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-05-05T14:19:09Z"}, "message": "c++: Member template function lookup failure [PR94799]\n\nWhew, this took a while.  We fail to parse \"p->template A<T>::a()\"\n(where p is of type A<T> *) because since r249752 we treat the RHS of the ->\nas dependent and avoid a lookup in the enclosing context: since that rev\ncp_parser_template_name checks parser->context->object_type too, which\nhere is unknown_type_node, signalling a type-dependent object:\n\n 7756   if (dependent_p)\n 7757     /* Tell cp_parser_lookup_name that there was an object, even though it's\n 7758        type-dependent.  */\n 7759     parser->context->object_type = unknown_type_node;\n\nwith which cp_parser_template_name returns identifier 'A', cp_parser_class_name\nthen creates a TEMPLATE_ID_EXPR A<T>, but then\n\n23735       decl = make_typename_type (scope, decl, tag_type, tf_error);\n\nin cp_parser_class_name fails because scope is NULL.  Then we return\nerror_mark_node and parse errors ensue.\n\nI've tried various approaches, e.g. keeping TEMPLATE_ID_EXPR around\ninstead of calling make_typename_type, which didn't work, whereupon I\nrealized that since we don't want to perform name lookup if we've seen\nthe template keyword and the scope is dependent, we can adjust\nparser->context->object_type and use the type of the object expression\nas the scope, even if it's type-dependent.  This should be in line with\n[basic.lookup.classref]p4.  If the postfix expression doesn't have a type,\nuse typeof to carry its type.  This typeof will be processed in\ntsubst/TYPENAME_TYPE.\n\n\tPR c++/94799\n\t* parser.c (cp_parser_postfix_dot_deref_expression): If we have\n\ta type-dependent object of class type, stash it to\n\tparser->context->object_type.  If the postfix expression doesn't have\n\ta type, use typeof.\n\t(cp_parser_class_name): Consider object scope too.\n\t(cp_parser_lookup_name): Remove code dealing with the case when\n\tobject_type is unknown_type_node.\n\n\t* g++.dg/lookup/this1.C: Adjust dg-error.\n\t* g++.dg/template/lookup12.C: New test.\n\t* g++.dg/template/lookup13.C: New test.\n\t* g++.dg/template/lookup14.C: New test.\n\t* g++.dg/template/lookup15.C: New test.", "tree": {"sha": "ad74c7f5b8dac79c2b0797de6dfecd77b510e74f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad74c7f5b8dac79c2b0797de6dfecd77b510e74f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "811b7636cb8c10f1a550a76242b5666c7ae36da2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811b7636cb8c10f1a550a76242b5666c7ae36da2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/811b7636cb8c10f1a550a76242b5666c7ae36da2"}], "stats": {"total": 138, "additions": 128, "deletions": 10}, "files": [{"sha": "ef82d93bc071d28c3df015f9e0bce915cfdf6d5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -1,3 +1,15 @@\n+2020-05-05  Marek Polacek  <polacek@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/94799\n+\t* parser.c (cp_parser_postfix_dot_deref_expression): If we have\n+\ta type-dependent object of class type, stash it to\n+\tparser->context->object_type.  If the postfix expression doesn't have\n+\ta type, use typeof.\n+\t(cp_parser_class_name): Consider object scope too.\n+\t(cp_parser_lookup_name): Remove code dealing with the case when\n+\tobject_type is unknown_type_node.\n+\n 2020-05-04  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/94038"}, {"sha": "5832025443db9ccb761d71d6a028902a1e2a2630", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -7754,9 +7754,14 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n     }\n \n   if (dependent_p)\n-    /* Tell cp_parser_lookup_name that there was an object, even though it's\n-       type-dependent.  */\n-    parser->context->object_type = unknown_type_node;\n+    {\n+      tree type = TREE_TYPE (postfix_expression);\n+      /* If we don't have a (type-dependent) object of class type, use\n+\t typeof to figure out the type of the object.  */\n+      if (type == NULL_TREE)\n+\ttype = finish_typeof (postfix_expression);\n+      parser->context->object_type = type;\n+    }\n \n   /* Assume this expression is not a pseudo-destructor access.  */\n   pseudo_destructor_p = false;\n@@ -23625,8 +23630,15 @@ cp_parser_class_name (cp_parser *parser,\n     }\n \n   /* PARSER->SCOPE can be cleared when parsing the template-arguments\n-     to a template-id, so we save it here.  */\n-  scope = parser->scope;\n+     to a template-id, so we save it here.  Consider object scope too,\n+     so that make_typename_type below can use it (cp_parser_template_name\n+     considers object scope also).  This may happen with code like\n+\n+       p->template A<T>::a()\n+\n+      where we first want to look up A<T>::a in the class of the object\n+      expression, as per [basic.lookup.classref].  */\n+  scope = parser->scope ? parser->scope : parser->context->object_type;\n   if (scope == error_mark_node)\n     return error_mark_node;\n \n@@ -28340,10 +28352,6 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \tdecl = lookup_name_real (name, prefer_type_arg (tag_type, is_template),\n \t\t\t\t /*nonclass=*/0,\n \t\t\t\t /*block_p=*/true, is_namespace, 0);\n-      if (object_type == unknown_type_node)\n-\t/* The object is type-dependent, so we can't look anything up; we used\n-\t   this to get the DR 141 behavior.  */\n-\tobject_type = NULL_TREE;\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }"}, {"sha": "c23213a847aa6f871afecf508765d4b7e20272bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -1,3 +1,12 @@\n+2020-05-05  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/94799\n+\t* g++.dg/lookup/this1.C: Adjust dg-error.\n+\t* g++.dg/template/lookup12.C: New test.\n+\t* g++.dg/template/lookup13.C: New test.\n+\t* g++.dg/template/lookup14.C: New test.\n+\t* g++.dg/template/lookup15.C: New test.\n+\n 2020-05-05  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/spellcheck-options-22.c: New test."}, {"sha": "6b85cefcd37db9babb68658aecff150b801b8312", "filename": "gcc/testsuite/g++.dg/lookup/this1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fthis1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fthis1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fthis1.C?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -4,5 +4,5 @@\n struct A\n {\n     template<int> static void foo();\n-    static void bar() { this->A::foo<0>(); } // { dg-error \"unavailable\" }\n+    static void bar() { this->A::foo<0>(); } // { dg-error \"unavailable|not a class|expected\" }\n };"}, {"sha": "fc5939ab0f6b52d9de145e7775c279c4d154f26e", "filename": "gcc/testsuite/g++.dg/template/lookup12.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup12.C?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/94799 - member template function lookup fails.\n+\n+template<typename T> struct B {\n+  void foo ();\n+  int i;\n+};\n+\n+template<typename T>\n+struct D : public B<T> { };\n+\n+template<typename T>\n+void fn (D<T> d)\n+{\n+  d.template B<T>::foo ();\n+  d.template B<T>::i = 42;\n+  D<T>().template B<T>::foo ();\n+  d.template D<T>::template B<T>::foo ();\n+  d.template D<T>::template B<T>::i = 10;\n+}\n+\n+int\n+main ()\n+{\n+  D<int> d;\n+  fn(d);\n+}"}, {"sha": "a8c7e18a707779d865bdb655edaf9f47770c85b5", "filename": "gcc/testsuite/g++.dg/template/lookup13.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup13.C?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/94799 - member template function lookup fails.\n+\n+template <typename T>\n+struct A {\n+    int a() {\n+        return 42;\n+    }\n+\n+    template<typename> struct X { typedef int type; };\n+};\n+\n+template <typename T>\n+struct B {\n+    int b(A<T> *p) {\n+\tint i = 0;\n+        i += p->a();\n+        i += p->template A<T>::a();\n+        i += p->template A<T>::template A<T>::a();\n+\ti += A<T>().template A<T>::a();\n+\treturn i;\n+    }\n+};\n+\n+int main() {\n+    A<int> a;\n+    B<int> b;\n+    return b.b(&a);\n+}"}, {"sha": "e1c945a6dca7fe5be4c4b264a02c136c504beb6d", "filename": "gcc/testsuite/g++.dg/template/lookup14.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup14.C?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/94799 - member template function lookup fails.\n+\n+template<typename T>\n+struct A { };\n+\n+template<typename T>\n+void fn (A<T> a)\n+{\n+  // Don't perform name lookup of foo when parsing this template.\n+  a.template A<T>::foo ();\n+}"}, {"sha": "c7f3ba01576f8aa662a5403c6a81e5afb910235b", "filename": "gcc/testsuite/g++.dg/template/lookup15.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3479afc5ab415f00a53fc6f6a990df7f6a0747/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup15.C?ref=ef3479afc5ab415f00a53fc6f6a990df7f6a0747", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/94799 - member template function lookup fails.\n+\n+template<typename>\n+struct M { void fn() { } };\n+\n+M<int>* bar (int);\n+M<int> bar2 (int);\n+\n+template<typename T>\n+struct X : M<T> {\n+  void xfn ()\n+  {\n+    this->template M<T>::fn ();\n+    bar((T)1)->template M<T>::fn ();\n+    bar2((T)1).template M<T>::fn ();\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  X<int> x;\n+  x.xfn();\n+}"}]}