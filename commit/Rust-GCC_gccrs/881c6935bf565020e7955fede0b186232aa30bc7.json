{"sha": "881c6935bf565020e7955fede0b186232aa30bc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxYzY5MzViZjU2NTAyMGU3OTU1ZmVkZTBiMTg2MjMyYWEzMGJjNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-08-29T00:29:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-08-29T00:29:29Z"}, "message": "[multiple changes]\n\n2000-08-28  Daniel Berlin  <dberlin@redhat.com>\n\n        * dwarf2out.c (DIE_LABEL_PREFIX): Remove leading \"__\".\n        (print_die): If we don't know the offset of the\n        target die, try the symbol.  Add a trailing newline.\n        (reverse_all_dies): New fn.\n        (dwarf2out_finish): Call it.\n        (break_out_includes): Reorganize for clarity.\n        (add_sibling_attributes): Don't call reverse_die_lists.\n        (output_comp_unit): Rename from output_comdat_comp_unit.  Use for\n        primary CU, too.\n        * flags.h: Add flag_eliminate_dwarf2_dups.\n        * toplev.c (f_options): Support -feliminate-dwarf2-dups.\n\n2000-08-28  Jason Merrill  <jason@redhat.com>\n\n        * dwarf2.h (DW_TAG_GNU_BINCL, DW_TAG_GNU_EINCL): New tags.\n        * dwarf2out.c: #include \"md5.h\".\n        (DIE_LABEL_PREFIX): New macro.\n        (dw_val_struct): Add 'external' flag to val_die_ref.\n        (add_AT_die_ref, AT_ref): Adjust.\n        (AT_ref_external, set_AT_ref_external): New fns.\n        (build_abbrev_table): Call set_AT_ref_external.\n        (value_format): Call AT_ref_external.\n        (die_struct): Add die_symbol field.\n        (new_die): Clear it.\n        (dwarf_tag_name): Handle BINCL/EINCL.\n        (dwarf2out_start_source_file): Add BINCL DIE.\n        (dwarf2out_end_source_file): Add EINCL DIE.\n        (push_new_compile_unit, pop_compile_unit, clear_die_sizes): New fns.\n        (loc_checksum, attr_checksum, die_checksum): New fns.\n        (is_type_die, is_comdat_die, is_symbol_die): New fns.\n        (compute_section_prefix, assign_symbol_names): New fns.\n        (gen_internal_sym, output_die_symbol, output_symbolic_ref): New fns.\n        (output_die): Call output_die_symbol and AT_ref_external.\n        (output_comdat_comp_unit): New fn, split out from...\n        (dwarf2out_finish): ...here.  Also call add_sibling_attributes for\n        secondary CUs.\n        (output_pubnames, output_aranges): Abort if we see entries from\n        secondary CUs.\n        * toplev.h: Declare file_name_nondirectory.\n        * toplev.c (file_name_nondirectory): New fn, moved from C++ frontend.\n        (rest_of_type_compilation): Call dwarf2out_decl if at toplevel.\n        (debug_start_source_file): Call dwarf2out_start_source_file\n        regardless of debug verbosity.\n        (debug_end_source_file): Similarly.\n        * tree.h: Declare clean_symbol_name.\n        * tree.c (clean_symbol_name): Split out from...\n        (get_file_function_name_long): ...here.\n\n        * dwarf2out.c (new_loc_descr): Use calloc.\n        (splice_child_die): Remove the die from the right parent.\n        (gen_struct_or_union_die): Don't add AT_name to a specification DIE.\n\ngcc/cp:\n2000-08-28  Jason Merrill  <jason@redhat.com>\n\n        * lex.c (file_name_nondirectory): Move to toplev.c.\n\nlibiberty:\n2000-08-28  Jason Merrill  <jason@redhat.com>\n\n        * Makefile.in (REQUIRED_OFILES): Add md5.o.\n        (CFILES): Add md5.c.\n        * md5.c: New file.\n\ninclude:\n2000-08-28  Jason Merrill  <jason@redhat.com>\n\n        * md5.h: New file.\n\ngcc/cp:\n2000-08-28  Jason Merrill  <jason@redhat.com>\n\n        * cp-tree.h (LOCAL_CLASS_P): New macro.\n        * class.c (finish_struct_1): Use it.\n\nFrom-SVN: r36022", "tree": {"sha": "1c4a89e82f43c947c726d079f918ca55f88b843a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c4a89e82f43c947c726d079f918ca55f88b843a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/881c6935bf565020e7955fede0b186232aa30bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881c6935bf565020e7955fede0b186232aa30bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881c6935bf565020e7955fede0b186232aa30bc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881c6935bf565020e7955fede0b186232aa30bc7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5de0e8d4e02cf79e31e9845aa03814306e9161c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de0e8d4e02cf79e31e9845aa03814306e9161c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de0e8d4e02cf79e31e9845aa03814306e9161c8"}], "stats": {"total": 1294, "additions": 1227, "deletions": 67}, "files": [{"sha": "c9224cfdd7640a8fee55be71751449de5133102c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -1,3 +1,10 @@\n+2000-08-28  Jason Merrill  <jason@redhat.com>\n+\n+\t* lex.c (file_name_nondirectory): Move to toplev.c.\n+\n+\t* cp-tree.h (LOCAL_CLASS_P): New macro.\n+\t* class.c (finish_struct_1): Use it.\n+\n 2000-08-27  Alex Samuel  <samuel@codesourcery.com>\n \n \t* mangle.c (CLASSTYPE_TEMPLATE_ID_P): Remove unexplained voodoo."}, {"sha": "dfbdc94a78b89b441b56ae4996efed73c0f4aaed", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -5200,7 +5200,7 @@ finish_struct_1 (t)\n   maybe_suppress_debug_info (t);\n \n   /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (t, toplevel_bindings_p ());\n+  rest_of_type_compilation (t, ! LOCAL_CLASS_P (t));\n }\n \n /* When T was built up, the member declarations were added in reverse"}, {"sha": "cc5046921f967426caa4e0e64fea2b25f1f8c623", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -2224,6 +2224,11 @@ struct lang_decl\n   (DECL_CONTEXT (NODE) \\\n    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n \n+/* 1 iff NODE is function-local, but for types.  */\n+#define LOCAL_CLASS_P(NODE)\t\t\t\t\\\n+  (TYPE_CONTEXT (NODE)\t\t\t\t\t\\\n+   && TREE_CODE (TYPE_CONTEXT (NODE)) == FUNCTION_DECL)\n+\n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n    that is the common ancestor. */"}, {"sha": "94679b4c718f8d69e41ada2e2eda9e3ef5c26bce", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -96,21 +96,6 @@ static int is_extended_char PARAMS ((int));\n static int is_extended_char_1 PARAMS ((int));\n static void init_operators PARAMS ((void));\n \n-/* Given a file name X, return the nondirectory portion.\n-   Keep in mind that X can be computed more than once.  */\n-char *\n-file_name_nondirectory (x)\n-     const char *x;\n-{\n-  char *tmp = (char *) rindex (x, '/');\n-  if (DIR_SEPARATOR != '/' && ! tmp)\n-    tmp = (char *) rindex (x, DIR_SEPARATOR);\n-  if (tmp)\n-    return (char *) (tmp + 1);\n-  else\n-    return (char *) x;\n-}\n-\n /* This obstack is needed to hold text.  It is not safe to use\n    TOKEN_BUFFER because `check_newline' calls `yylex'.  */\n struct obstack inline_text_obstack;"}, {"sha": "5b6082845475221ce0c7fba7e24aa5a8819b8191", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -88,7 +88,9 @@ enum dwarf_tag\n     /* GNU extensions */\n     DW_TAG_format_label = 0x4101,\t/* for FORTRAN 77 and Fortran 90 */\n     DW_TAG_function_template = 0x4102,\t/* for C++ */\n-    DW_TAG_class_template = 0x4103\t/* for C++ */\n+    DW_TAG_class_template = 0x4103,\t/* for C++ */\n+    DW_TAG_GNU_BINCL = 0x4104,\n+    DW_TAG_GNU_EINCL = 0x4105\n   };\n \n #define DW_TAG_lo_user\t0x4080"}, {"sha": "69e03955704abad964cddbf216d599792845332c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 580, "deletions": 31, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -23,9 +23,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* TODO: Implement .debug_str handling, and share entries somehow.\n-\t Eliminate duplicates by putting common info in a separate section\n-\t   to be collected by the linker and referring to it with\n-\t   DW_FORM_ref_addr.\n \t Emit .debug_line header even when there are no functions, since\n \t   the file numbers are used by .debug_info.  Alternately, leave\n \t   out locations for types and decls.\n@@ -56,6 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n+#include \"md5.h\"\n #include \"tm_p.h\"\n \n /* Decide whether we want to emit frame unwind information for the current\n@@ -303,6 +301,7 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n #define FDE_AFTER_SIZE_LABEL\t\"LSFDE\"\n #define FDE_END_LABEL\t\t\"LEFDE\"\n #define FDE_LENGTH_LABEL\t\"LLFDE\"\n+#define DIE_LABEL_PREFIX\t\"DW\"\n \n /* Definitions of defaults for various types of primitive assembly language\n    output operations.  These may be overridden from within the tm.h file,\n@@ -2124,7 +2123,10 @@ typedef struct dw_val_struct\n       long unsigned val_unsigned;\n       dw_long_long_const val_long_long;\n       dw_float_const val_float;\n-      dw_die_ref val_die_ref;\n+      struct {\n+\tdw_die_ref die;\n+\tint external;\n+      } val_die_ref;\n       unsigned val_fde_index;\n       char *val_str;\n       char *val_lbl_id;\n@@ -2995,6 +2997,7 @@ dw_attr_node;\n typedef struct die_struct\n {\n   enum dwarf_tag die_tag;\n+  char *die_symbol;\n   dw_attr_ref die_attr;\n   dw_die_ref die_parent;\n   dw_die_ref die_child;\n@@ -3338,20 +3341,38 @@ static void equate_decl_number_to_die\tPARAMS ((tree, dw_die_ref));\n static void print_spaces\t\tPARAMS ((FILE *));\n static void print_die\t\t\tPARAMS ((dw_die_ref, FILE *));\n static void print_dwarf_line_table\tPARAMS ((FILE *));\n+static void reverse_die_lists\t\tPARAMS ((dw_die_ref));\n+static void reverse_all_dies\t\tPARAMS ((dw_die_ref));\n+static dw_die_ref push_new_compile_unit PARAMS ((dw_die_ref, dw_die_ref));\n+static dw_die_ref pop_compile_unit\tPARAMS ((dw_die_ref));\n+static void loc_checksum\t PARAMS ((dw_loc_descr_ref, struct md5_ctx *));\n+static void attr_checksum \t      PARAMS ((dw_attr_ref, struct md5_ctx *));\n+static void die_checksum\t       PARAMS ((dw_die_ref, struct md5_ctx *));\n+static void compute_section_prefix\tPARAMS ((dw_die_ref));\n+static int is_type_die\t\t\tPARAMS ((dw_die_ref));\n+static int is_comdat_die \t\tPARAMS ((dw_die_ref));\n+static int is_symbol_die \t\tPARAMS ((dw_die_ref));\n+static char *gen_internal_sym \t\tPARAMS ((void));\n+static void assign_symbol_names\t\tPARAMS ((dw_die_ref));\n+static void break_out_includes\t\tPARAMS ((dw_die_ref));\n static void add_sibling_attributes\tPARAMS ((dw_die_ref));\n static void build_abbrev_table\t\tPARAMS ((dw_die_ref));\n static unsigned long size_of_string\tPARAMS ((const char *));\n static int constant_size\t\tPARAMS ((long unsigned));\n static unsigned long size_of_die\tPARAMS ((dw_die_ref));\n static void calc_die_sizes\t\tPARAMS ((dw_die_ref));\n+static void clear_die_sizes\t\tPARAMS ((dw_die_ref));\n static unsigned long size_of_line_prolog PARAMS ((void));\n static unsigned long size_of_pubnames\tPARAMS ((void));\n static unsigned long size_of_aranges\tPARAMS ((void));\n static enum dwarf_form value_format\tPARAMS ((dw_attr_ref));\n static void output_value_format\t\tPARAMS ((dw_attr_ref));\n static void output_abbrev_section\tPARAMS ((void));\n+static void output_die_symbol\t\tPARAMS ((dw_die_ref));\n+static void output_symbolic_ref\t\tPARAMS ((dw_die_ref));\n static void output_die\t\t\tPARAMS ((dw_die_ref));\n static void output_compilation_unit_header PARAMS ((void));\n+static void output_comp_unit\t\tPARAMS ((dw_die_ref));\n static const char *dwarf2_name\t\tPARAMS ((tree, int));\n static void add_pubname\t\t\tPARAMS ((tree, dw_die_ref));\n static void output_pubnames\t\tPARAMS ((void));\n@@ -3441,7 +3462,6 @@ static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n static void gen_abstract_function\tPARAMS ((tree));\n static rtx save_rtx\t\t\tPARAMS ((rtx));\n static void splice_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n-static void reverse_die_lists\t\tPARAMS ((dw_die_ref));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -3728,6 +3748,10 @@ dwarf_tag_name (tag)\n       return \"DW_TAG_function_template\";\n     case DW_TAG_class_template:\n       return \"DW_TAG_class_template\";\n+    case DW_TAG_GNU_BINCL:\n+      return \"DW_TAG_GNU_BINCL\";\n+    case DW_TAG_GNU_EINCL:\n+      return \"DW_TAG_GNU_EINCL\";\n     default:\n       return \"DW_TAG_<unknown>\";\n     }\n@@ -4079,7 +4103,7 @@ decl_class_context (decl)\n }\n \f\n /* Add an attribute/value pair to a DIE.  We build the lists up in reverse\n-   addition order, and correct that in add_sibling_attributes.  */\n+   addition order, and correct that in reverse_all_dies.  */\n \n static inline void\n add_dwarf_attr (die, attr)\n@@ -4264,7 +4288,8 @@ add_AT_die_ref (die, attr_kind, targ_die)\n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n   attr->dw_attr_val.val_class = dw_val_class_die_ref;\n-  attr->dw_attr_val.v.val_die_ref = targ_die;\n+  attr->dw_attr_val.v.val_die_ref.die = targ_die;\n+  attr->dw_attr_val.v.val_die_ref.external = 0;\n   add_dwarf_attr (die, attr);\n }\n \n@@ -4274,11 +4299,34 @@ AT_ref (a)\n      register dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_die_ref)\n-    return a->dw_attr_val.v.val_die_ref;\n+    return a->dw_attr_val.v.val_die_ref.die;\n \n   abort ();\n }\n \n+static inline int AT_ref_external PARAMS ((dw_attr_ref));\n+static inline int\n+AT_ref_external (a)\n+     register dw_attr_ref a;\n+{\n+  if (a && AT_class (a) == dw_val_class_die_ref)\n+    return a->dw_attr_val.v.val_die_ref.external;\n+\n+  return 0;\n+}\n+\n+static inline void set_AT_ref_external PARAMS ((dw_attr_ref, int));\n+static inline void\n+set_AT_ref_external (a, i)\n+     register dw_attr_ref a;\n+     int i;\n+{\n+  if (a && AT_class (a) == dw_val_class_die_ref)\n+    a->dw_attr_val.v.val_die_ref.external = i;\n+  else\n+    abort ();\n+}\n+\n /* Add an FDE reference attribute value to a DIE.  */\n \n static inline void\n@@ -4611,7 +4659,7 @@ remove_children (die)\n }\n \n /* Add a child DIE below its parent.  We build the lists up in reverse\n-   addition order, and correct that in add_sibling_attributes.  */\n+   addition order, and correct that in reverse_all_dies.  */\n \n static inline void\n add_child_die (die, child_die)\n@@ -4677,6 +4725,7 @@ new_die (tag_value, parent_die)\n   die->die_parent = NULL;\n   die->die_sib = NULL;\n   die->die_attr = NULL;\n+  die->die_symbol = NULL;\n \n   if (parent_die != NULL)\n     add_child_die (parent_die, die);\n@@ -4822,7 +4871,12 @@ print_die (die, outfile)\n \t  break;\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref (a) != NULL)\n-\t    fprintf (outfile, \"die -> %lu\", AT_ref (a)->die_offset);\n+\t    {\n+\t      if (AT_ref (a)->die_offset == 0)\n+\t\tfprintf (outfile, \"die -> label: %s\", AT_ref (a)->die_symbol);\n+\t      else\n+\t\tfprintf (outfile, \"die -> %lu\", AT_ref (a)->die_offset);\n+\t    }\n \t  else\n \t    fprintf (outfile, \"die -> <null>\");\n \t  break;\n@@ -4851,6 +4905,8 @@ print_die (die, outfile)\n \n       print_indent -= 4;\n     }\n+  if (print_indent == 0)\n+    fprintf (outfile, \"\\n\");\n }\n \n /* Print the contents of the source code line number correspondence table.\n@@ -4925,20 +4981,379 @@ reverse_die_lists (die)\n   die->die_child = cp;\n }\n \n-/* Traverse the DIE, reverse its lists of attributes and children, and\n-   add a sibling attribute if it may have the effect of speeding up\n-   access to siblings.  To save some space, avoid generating sibling\n-   attributes for DIE's without children.  */\n+/* reverse_die_lists only reverses the single die you pass it. Since\n+   we used to reverse all dies in add_sibling_attributes, which runs\n+   through all the dies, it would reverse all the dies.  Now, however,\n+   since we don't call reverse_die_lists in add_sibling_attributes, we\n+   need a routine to recursively reverse all the dies. This is that\n+   routine.  */\n \n static void\n-add_sibling_attributes (die)\n+reverse_all_dies (die)\n      register dw_die_ref die;\n {\n   register dw_die_ref c;\n \n   reverse_die_lists (die);\n \n-  if (die != comp_unit_die && die->die_sib && die->die_child != NULL)\n+  for (c = die->die_child; c; c = c->die_sib)\n+    reverse_all_dies (c);\n+}\n+\n+/* Start a new compilation unit DIE for an include file.  OLD_UNIT is\n+   the CU for the enclosing include file, if any.  BINCL_DIE is the\n+   DW_TAG_GNU_BINCL DIE that marks the start of the DIEs for this\n+   include file.  */\n+\n+static dw_die_ref\n+push_new_compile_unit (old_unit, bincl_die)\n+     dw_die_ref old_unit, bincl_die;\n+{\n+  const char *filename = get_AT_string (bincl_die, DW_AT_name);\n+  dw_die_ref new_unit = gen_compile_unit_die (filename);\n+  new_unit->die_sib = old_unit;\n+  return new_unit;\n+}\n+\n+/* Close an include-file CU and reopen the enclosing one.  */\n+\n+static dw_die_ref\n+pop_compile_unit (old_unit)\n+     dw_die_ref old_unit;\n+{\n+  dw_die_ref new_unit = old_unit->die_sib;\n+  old_unit->die_sib = NULL;\n+  return new_unit;\n+}\n+\n+#define PROCESS(FOO) md5_process_bytes (&(FOO), sizeof (FOO), ctx)\n+#define PROCESS_STRING(FOO) md5_process_bytes ((FOO), strlen (FOO), ctx)\n+\n+/* Calculate the checksum of a location expression.  */\n+\n+static inline void\n+loc_checksum (loc, ctx)\n+     dw_loc_descr_ref loc;\n+     struct md5_ctx *ctx;\n+{\n+  PROCESS (loc->dw_loc_opc);\n+  PROCESS (loc->dw_loc_oprnd1);\n+  PROCESS (loc->dw_loc_oprnd2);\n+}\n+\n+/* Calculate the checksum of an attribute.  */\n+\n+static void\n+attr_checksum (at, ctx)\n+     dw_attr_ref at;\n+     struct md5_ctx *ctx;\n+{\n+  dw_loc_descr_ref loc;\n+  rtx r;\n+\n+  PROCESS (at->dw_attr);\n+\n+  /* We don't care about differences in file numbering.  */\n+  if (at->dw_attr == DW_AT_decl_file)\n+    return;\n+\n+  switch (AT_class (at))\n+    {\n+    case dw_val_class_const:\n+      PROCESS (at->dw_attr_val.v.val_int);\n+      break;\n+    case dw_val_class_unsigned_const:\n+      PROCESS (at->dw_attr_val.v.val_unsigned);\n+      break;\n+    case dw_val_class_long_long:\n+      PROCESS (at->dw_attr_val.v.val_long_long);\n+      break;\n+    case dw_val_class_float:\n+      PROCESS (at->dw_attr_val.v.val_float);\n+      break;\n+    case dw_val_class_flag:\n+      PROCESS (at->dw_attr_val.v.val_flag);\n+      break;\n+\n+    case dw_val_class_str:\n+      PROCESS_STRING (AT_string (at));\n+      break;\n+    case dw_val_class_addr:\n+      r = AT_addr (at);\n+      switch (GET_CODE (r))\n+\t{\n+\tcase SYMBOL_REF:\n+\t  PROCESS_STRING (XSTR (r, 0));\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case dw_val_class_loc:\n+      for (loc = AT_loc (at); loc; loc = loc->dw_loc_next)\n+\tloc_checksum (loc, ctx);\n+      break;\n+\n+    case dw_val_class_die_ref:\n+      if (AT_ref (at)->die_offset)\n+\tPROCESS (AT_ref (at)->die_offset);\n+      /* FIXME else use target die name or something.  */\n+\n+    case dw_val_class_fde_ref:\n+    case dw_val_class_lbl_id:\n+    case dw_val_class_lbl_offset:\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Calculate the checksum of a DIE.  */\n+\n+static void\n+die_checksum (die, ctx)\n+     dw_die_ref die;\n+     struct md5_ctx *ctx;\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+\n+  PROCESS (die->die_tag);\n+\n+  for (a = die->die_attr; a; a = a->dw_attr_next)\n+    attr_checksum (a, ctx);\n+\n+  for (c = die->die_child; c; c = c->die_sib)\n+    die_checksum (c, ctx);\n+}\n+\n+#undef PROCESS\n+#undef PROCESS_STRING\n+\n+/* The prefix to attach to symbols on DIEs in the current comdat debug\n+   info section.  */\n+static char *comdat_symbol_id;\n+\n+/* The index of the current symbol within the current comdat CU.  */\n+static unsigned int comdat_symbol_number;\n+\n+/* Calculate the MD5 checksum of the compilation unit DIE UNIT_DIE and its\n+   children, and set comdat_symbol_id accordingly.  */\n+\n+static void\n+compute_section_prefix (unit_die)\n+     dw_die_ref unit_die;\n+{\n+  char *p, *name;\n+  int i;\n+  unsigned char checksum[16];\n+  struct md5_ctx ctx;\n+\n+  md5_init_ctx (&ctx);\n+  die_checksum (unit_die, &ctx);\n+  md5_finish_ctx (&ctx, checksum);\n+\n+  p = file_name_nondirectory (get_AT_string (unit_die, DW_AT_name));\n+  name = (char *) alloca (strlen (p) + 64);\n+  sprintf (name, \"%s.\", p);\n+\n+  clean_symbol_name (name);\n+\n+  p = name + strlen (name);\n+  for (i = 0; i < 4; ++i)\n+    {\n+      sprintf (p, \"%.2x\", checksum[i]);\n+      p += 2;\n+    }\n+\n+  comdat_symbol_id = unit_die->die_symbol = xstrdup (name);\n+  comdat_symbol_number = 0;\n+}\n+\n+/* Returns nonzero iff DIE represents a type, in the sense of TYPE_P.  */\n+\n+static int\n+is_type_die (die)\n+     dw_die_ref die;\n+{\n+  switch (die->die_tag)\n+    {\n+    case DW_TAG_array_type:\n+    case DW_TAG_class_type:\n+    case DW_TAG_enumeration_type:\n+    case DW_TAG_pointer_type:\n+    case DW_TAG_reference_type:\n+    case DW_TAG_string_type:\n+    case DW_TAG_structure_type:\n+    case DW_TAG_subroutine_type:\n+    case DW_TAG_union_type:\n+    case DW_TAG_ptr_to_member_type:\n+    case DW_TAG_set_type:\n+    case DW_TAG_subrange_type:\n+    case DW_TAG_base_type:\n+    case DW_TAG_const_type:\n+    case DW_TAG_file_type:\n+    case DW_TAG_packed_type:\n+    case DW_TAG_volatile_type:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Returns 1 iff C is the sort of DIE that should go into a COMDAT CU.\n+   Basically, we want to choose the bits that are likely to be shared between\n+   compilations (types) and leave out the bits that are specific to individual\n+   compilations (functions).  */\n+\n+static int\n+is_comdat_die (c)\n+     dw_die_ref c;\n+{\n+#if 1\n+  /* I think we want to leave base types and __vtbl_ptr_type in the\n+     main CU, as we do for stabs.  The advantage is a greater\n+     likelihood of sharing between objects that don't include headers\n+     in the same order (and therefore would put the base types in a\n+     different comdat).  jason 8/28/00 */\n+  if (c->die_tag == DW_TAG_base_type)\n+    return 0;\n+\n+  if (c->die_tag == DW_TAG_pointer_type\n+      || c->die_tag == DW_TAG_reference_type\n+      || c->die_tag == DW_TAG_const_type\n+      || c->die_tag == DW_TAG_volatile_type)\n+    {\n+      dw_die_ref t = get_AT_ref (c, DW_AT_type);\n+      return t ? is_comdat_die (t) : 0;\n+    }\n+#endif\n+\n+  return is_type_die (c);\n+}\n+\n+/* Returns 1 iff C is the sort of DIE that might be referred to from another\n+   compilation unit.  */\n+\n+static int\n+is_symbol_die (c)\n+     dw_die_ref c;\n+{\n+  if (is_type_die (c))\n+    return 1;\n+  if (get_AT (c, DW_AT_declaration)\n+      && ! get_AT (c, DW_AT_specification))\n+    return 1;\n+  return 0;\n+}\n+\n+static char *\n+gen_internal_sym ()\n+{\n+  char buf[256];\n+  static int label_num;\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LDIE\", label_num++);\n+  return xstrdup (buf);\n+}\n+\n+/* Assign symbols to all worthy DIEs under DIE.  */\n+\n+static void\n+assign_symbol_names (die)\n+     register dw_die_ref die;\n+{\n+  register dw_die_ref c;\n+\n+  if (is_symbol_die (die))\n+    {\n+      if (comdat_symbol_id)\n+\t{\n+\t  char *p = alloca (strlen (comdat_symbol_id) + 64);\n+\t  sprintf (p, \"%s.%s.%x\", DIE_LABEL_PREFIX,\n+\t\t   comdat_symbol_id, comdat_symbol_number++);\n+\t  die->die_symbol = xstrdup (p);\n+\t}\n+      else\n+\tdie->die_symbol = gen_internal_sym ();\n+    }\n+\n+  for (c = die->die_child; c != NULL; c = c->die_sib)\n+    assign_symbol_names (c);\n+}\n+\n+/* Traverse the DIE (which is always comp_unit_die), and set up\n+   additional compilation units for each of the include files we see\n+   bracketed by BINCL/EINCL.  */\n+\n+static void\n+break_out_includes (die)\n+     register dw_die_ref die;\n+{\n+  dw_die_ref *ptr;\n+  register dw_die_ref unit = NULL;\n+  limbo_die_node *node;\n+\n+  for (ptr = &(die->die_child); *ptr; )\n+    {\n+      register dw_die_ref c = *ptr;\n+\n+      if (c->die_tag == DW_TAG_GNU_BINCL\n+\t  || c->die_tag == DW_TAG_GNU_EINCL\n+\t  || (unit && is_comdat_die (c)))\n+\t{\n+\t  /* This DIE is for a secondary CU; remove it from the main one.  */\n+\t  *ptr = c->die_sib;\n+\n+\t  if (c->die_tag == DW_TAG_GNU_BINCL)\n+\t    {\n+\t      unit = push_new_compile_unit (unit, c);\n+\t      free_die (c);\n+\t    }\n+\t  else if (c->die_tag == DW_TAG_GNU_EINCL)\n+\t    {\n+\t      unit = pop_compile_unit (unit);\n+\t      free_die (c);\n+\t    }\n+\t  else\n+\t    add_child_die (unit, c);\n+\t}\n+      else\n+\t{\n+\t  /* Leave this DIE in the main CU.  */\n+\t  ptr = &(c->die_sib);\n+\t  continue;\n+\t}\n+    }\n+\n+#if 0\n+  /* We can only use this in debugging, since the frontend doesn't check\n+     to make sure that we leave every include file we enter.  */     \n+  if (unit != NULL)\n+    abort ();\n+#endif\n+\n+  assign_symbol_names (die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    {\n+      compute_section_prefix (node->die);\n+      assign_symbol_names (node->die);\n+    }\n+}\n+\n+/* Traverse the DIE and add a sibling attribute if it may have the\n+   effect of speeding up access to siblings.  To save some space,\n+   avoid generating sibling attributes for DIE's without children.  */\n+\n+static void\n+add_sibling_attributes (die)\n+     register dw_die_ref die;\n+{\n+  register dw_die_ref c;\n+\n+  if (die->die_tag != DW_TAG_compile_unit\n+      && die->die_sib && die->die_child != NULL)\n     /* Add the sibling link to the front of the attribute list.  */\n     add_AT_die_ref (die, DW_AT_sibling, die->die_sib);\n \n@@ -4960,6 +5375,20 @@ build_abbrev_table (die)\n   register unsigned long n_alloc;\n   register dw_die_ref c;\n   register dw_attr_ref d_attr, a_attr;\n+\n+  /* Scan the DIE references, and mark as external any that refer to\n+     DIEs from other CUs (i.e. those with cleared die_offset).  */\n+  for (d_attr = die->die_attr; d_attr; d_attr = d_attr->dw_attr_next)\n+    {\n+      if (AT_class (d_attr) == dw_val_class_die_ref\n+\t  && AT_ref (d_attr)->die_offset == 0)\n+\t{\n+\t  if (AT_ref (d_attr)->die_symbol == 0)\n+\t    abort ();\n+\t  set_AT_ref_external (d_attr, 1);\n+\t}\n+    }\n+\n   for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n     {\n       register dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n@@ -5130,6 +5559,20 @@ calc_die_sizes (die)\n     next_die_offset += 1;\n }\n \n+/* Clear the offsets and sizes for a die and its children.  We do this so\n+   that we know whether or not a reference needs to use FORM_ref_addr; only\n+   DIEs in the same CU will have non-zero offsets available.  */\n+\n+static void\n+clear_die_sizes (die)\n+     dw_die_ref die;\n+{\n+  register dw_die_ref c;\n+  die->die_offset = 0;\n+  for (c = die->die_child; c; c = c->die_sib)\n+    clear_die_sizes (c);\n+}\n+\n /* Return the size of the line information prolog generated for the\n    compilation unit.  */\n \n@@ -5250,7 +5693,10 @@ value_format (a)\n     case dw_val_class_flag:\n       return DW_FORM_flag;\n     case dw_val_class_die_ref:\n-      return DW_FORM_ref;\n+      if (AT_ref_external (a))\n+\treturn DW_FORM_ref_addr;\n+      else\n+\treturn DW_FORM_ref;\n     case dw_val_class_fde_ref:\n       return DW_FORM_data;\n     case dw_val_class_lbl_id:\n@@ -5333,6 +5779,39 @@ output_abbrev_section ()\n   fprintf (asm_out_file, \"\\t%s\\t0\\n\", ASM_BYTE_OP);\n }\n \n+/* Output a symbol we can use to refer to this DIE from another CU.  */\n+\n+static inline void\n+output_die_symbol (die)\n+     register dw_die_ref die;\n+{\n+  char *sym = die->die_symbol;\n+\n+  if (sym == 0)\n+    return;\n+\n+  if (strncmp (sym, DIE_LABEL_PREFIX, sizeof (DIE_LABEL_PREFIX) - 1) == 0)\n+    /* We make these global, not weak; if the target doesn't support\n+       .linkonce, it doesn't support combining the sections, so debugging\n+       will break.  */\n+    ASM_GLOBALIZE_LABEL (asm_out_file, sym);\n+  ASM_OUTPUT_LABEL (asm_out_file, sym);\n+}\n+\n+/* Output a symbolic (i.e. FORM_ref_addr) reference to TARGET_DIE.  */\n+\n+static inline void\n+output_symbolic_ref (target_die)\n+     dw_die_ref target_die;\n+{\n+  char *sym = target_die->die_symbol;\n+\n+  if (sym == 0)\n+    abort ();\n+\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, sym);\n+}\n+\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -5344,6 +5823,11 @@ output_die (die)\n   register dw_die_ref c;\n   register unsigned long size;\n \n+  /* If someone in another CU might refer to us, set up a symbol for\n+     them to point to.  */\n+  if (die->die_symbol)\n+    output_die_symbol (die);\n+\n   output_uleb128 (die->die_abbrev);\n   if (flag_debug_asm)\n     fprintf (asm_out_file, \" (DIE (0x%lx) %s)\",\n@@ -5457,7 +5941,10 @@ output_die (die)\n \t  break;\n \n \tcase dw_val_class_die_ref:\n-\t  ASM_OUTPUT_DWARF_DATA (asm_out_file, AT_ref (a)->die_offset);\n+\t  if (AT_ref_external (a))\n+\t    output_symbolic_ref (AT_ref (a));\n+\t  else\n+\t    ASM_OUTPUT_DWARF_DATA (asm_out_file, AT_ref (a)->die_offset);\n \t  break;\n \n \tcase dw_val_class_fde_ref:\n@@ -5547,6 +6034,44 @@ output_compilation_unit_header ()\n   fputc ('\\n', asm_out_file);\n }\n \n+/* Output the compilation unit DIE and its children.  */\n+\n+static void\n+output_comp_unit (die)\n+     dw_die_ref die;\n+{\n+  char *secname;\n+\n+  if (die->die_child == 0)\n+    return;\n+\n+  /* Initialize the beginning DIE offset - and calculate sizes/offsets.   */\n+  next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n+  calc_die_sizes (die);\n+\n+  build_abbrev_table (die);\n+\n+  if (die->die_symbol)\n+    {\n+      secname = (char *) alloca (strlen (die->die_symbol) + 24);\n+      sprintf (secname, \".gnu.linkonce.wi.%s\", die->die_symbol);\n+      die->die_symbol = NULL;\n+    }\n+  else\n+    secname = (char *) DEBUG_INFO_SECTION;\n+\n+  /* Output debugging information.  */\n+  fputc ('\\n', asm_out_file);\n+  ASM_OUTPUT_SECTION (asm_out_file, secname);\n+  output_compilation_unit_header ();\n+  output_die (die);\n+\n+  /* Leave the sizes on the main CU, since we do it last and we use the\n+     sizes in output_pubnames.  */\n+  if (die->die_symbol)\n+    clear_die_sizes (die);\n+}\n+\n /* The DWARF2 pubname for a nested thingy looks like \"A::f\".  The output\n    of decl_printable_name for C++ looks like \"A::f(int)\".  Let's drop the\n    argument list, and maybe the scope.  */\n@@ -5622,6 +6147,10 @@ output_pubnames ()\n     {\n       register pubname_ref pub = &pubname_table[i];\n \n+      /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n+      if (pub->die->die_offset == 0)\n+\tabort ();\n+\n       ASM_OUTPUT_DWARF_DATA (asm_out_file, pub->die->die_offset);\n       if (flag_debug_asm)\n \tfprintf (asm_out_file, \"\\t%s DIE offset\", ASM_COMMENT_START);\n@@ -5735,6 +6264,10 @@ output_aranges ()\n     {\n       dw_die_ref die = arange_table[i];\n \n+      /* We shouldn't see aranges for DIEs outside of the main CU.  */\n+      if (die->die_offset == 0)\n+\tabort ();\n+\n       if (die->die_tag == DW_TAG_subprogram)\n \tASM_OUTPUT_DWARF_ADDR (asm_out_file, get_AT_low_pc (die));\n       else\n@@ -10134,6 +10667,12 @@ void\n dwarf2out_start_source_file (filename)\n      register const char *filename ATTRIBUTE_UNUSED;\n {\n+  if (flag_eliminate_dwarf2_dups)\n+    {\n+      /* Record the beginning of the file for break_out_includes.  */\n+      dw_die_ref bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die);\n+      add_AT_string (bincl_die, DW_AT_name, filename);\n+    }\n }\n \n /* Record the end of a source file, for later output\n@@ -10142,6 +10681,11 @@ dwarf2out_start_source_file (filename)\n void\n dwarf2out_end_source_file ()\n {\n+  if (flag_eliminate_dwarf2_dups)\n+    {\n+      /* Record the end of the file for break_out_includes.  */\n+      new_die (DW_TAG_GNU_EINCL, comp_unit_die);\n+    }      \n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter contains\n@@ -10291,9 +10835,19 @@ dwarf2out_finish ()\n      emit full debugging info for them.  */\n   retry_incomplete_types ();\n \n-  /* Traverse the DIE's, reverse their lists of attributes and children,\n-     and add add sibling attributes to those DIE's that have children.  */\n+  /* We need to reverse all the dies before break_out_includes, or\n+     we'll see the end of an include file before the beginning.  */\n+  reverse_all_dies (comp_unit_die);\n+\n+  /* Generate separate CUs for each of the include files we've seen.\n+     They will go into limbo_die_list.  */\n+  break_out_includes (comp_unit_die);\n+\n+  /* Traverse the DIE's and add add sibling attributes to those DIE's\n+     that have children.  */\n   add_sibling_attributes (comp_unit_die);\n+  for (node = limbo_die_list; node; node = node->next)\n+    add_sibling_attributes (node->die);\n \n   /* Output a terminator label for the .text section.  */\n   fputc ('\\n', asm_out_file);\n@@ -10339,22 +10893,17 @@ dwarf2out_finish ()\n     add_AT_unsigned (die, DW_AT_macro_info, 0);\n #endif\n \n+  /* Output all of the compilation units.  We put the main one last so that\n+     the offsets are available to output_pubnames.  */\n+  for (node = limbo_die_list; node; node = node->next)\n+    output_comp_unit (node->die);\n+  output_comp_unit (comp_unit_die);\n+\n   /* Output the abbreviation table.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);\n-  build_abbrev_table (comp_unit_die);\n   output_abbrev_section ();\n \n-  /* Initialize the beginning DIE offset - and calculate sizes/offsets.   */\n-  next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n-  calc_die_sizes (comp_unit_die);\n-\n-  /* Output debugging information.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, DEBUG_INFO_SECTION);\n-  output_compilation_unit_header ();\n-  output_die (comp_unit_die);\n-\n   if (pubname_table_in_use)\n     {\n       /* Output public names table.  */"}, {"sha": "a294c37de200f10fac6803503eff7b7c99884242", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -577,3 +577,7 @@ extern enum graph_dump_types graph_dump_format;\n    string identifying the compiler.  */\n \n extern int flag_no_ident;\n+\n+/* Nonzero means we should do dwarf2 duplicate elimination.  */\n+\n+extern int flag_eliminate_dwarf2_dups;"}, {"sha": "0d5d4f21ee78f7a0424837b8e673445df6dd0c4a", "filename": "gcc/toplev.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -422,6 +422,10 @@ tree (*lang_expand_constant) PARAMS ((tree)) = 0;\n \n void (*incomplete_decl_finalize_hook) PARAMS ((tree)) = 0;\n \n+/* Nonzero if doing dwarf2 duplicate elimination.  */\n+\n+int flag_eliminate_dwarf2_dups = 0;\n+\n /* Nonzero if generating code to do profiling.  */\n \n int profile_flag = 0;\n@@ -944,6 +948,8 @@ const char *user_label_prefix;\n \n lang_independent_options f_options[] =\n {\n+  {\"eliminate-dwarf2-dups\", &flag_eliminate_dwarf2_dups, 1, \n+   \"Perform DWARF2 duplicate elimination\"},\n   {\"float-store\", &flag_float_store, 1,\n    \"Do not store floats in registers\" },\n   {\"volatile\", &flag_volatile, 1,\n@@ -1656,6 +1662,21 @@ strip_off_ending (name, len)\n     }\n }\n \n+/* Given a file name X, return the nondirectory portion.  */\n+\n+char *\n+file_name_nondirectory (x)\n+     const char *x;\n+{\n+  char *tmp = (char *) rindex (x, '/');\n+  if (DIR_SEPARATOR != '/' && ! tmp)\n+    tmp = (char *) rindex (x, DIR_SEPARATOR);\n+  if (tmp)\n+    return (char *) (tmp + 1);\n+  else\n+    return (char *) x;\n+}\n+\n /* Output a quoted string.  */\n \n void\n@@ -2560,6 +2581,10 @@ rest_of_type_compilation (type, toplev)\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n     sdbout_symbol (TYPE_STUB_DECL (type), !toplev);\n+#endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG && toplev)\n+    dwarf2out_decl (TYPE_STUB_DECL (type));\n #endif\n   timevar_pop (TV_SYMOUT);\n }\n@@ -4973,8 +4998,7 @@ debug_start_source_file (filename)\n     dwarfout_start_new_source_file (filename);\n #endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n-  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-      && write_symbols == DWARF2_DEBUG)\n+  if (write_symbols == DWARF2_DEBUG)\n     dwarf2out_start_source_file (filename);\n #endif /* DWARF2_DEBUGGING_INFO  */\n #ifdef SDB_DEBUGGING_INFO\n@@ -5000,8 +5024,7 @@ debug_end_source_file (lineno)\n     dwarfout_resume_previous_source_file (lineno);\n #endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n-  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-      && write_symbols == DWARF2_DEBUG)\n+  if (write_symbols == DWARF2_DEBUG)\n     dwarf2out_end_source_file ();\n #endif /* DWARF2_DEBUGGING_INFO  */\n #ifdef SDB_DEBUGGING_INFO"}, {"sha": "fdfa6730b9396acf3d4fb413c4ab86b024293c2e", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -35,6 +35,7 @@ extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n \t\t\t\t\t\tconst int));\n extern int count_error\t\t\tPARAMS ((int));\n extern void strip_off_ending\t\tPARAMS ((char *, int));\n+extern char *file_name_nondirectory\tPARAMS ((const char *));\n extern void print_time\t\t\tPARAMS ((const char *, long));\n extern void debug_start_source_file\tPARAMS ((const char *));\n extern void debug_end_source_file\tPARAMS ((unsigned));"}, {"sha": "23612b356055f8de2ff41df9e81dd6201f197b3e", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -5386,6 +5386,26 @@ append_random_chars (template)\n   template[6] = '\\0';\n }\n \n+/* P is a string that will be used in a symbol.  Mask out any characters\n+   that are not valid in that context.  */\n+\n+void\n+clean_symbol_name (p)\n+     char *p;\n+{\n+  for (; *p; p++)\n+    if (! ( ISDIGIT(*p)\n+#ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n+\t    || *p == '$'\n+#endif\n+#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but...  */\n+\t    || *p == '.'\n+#endif\n+\t    || ISUPPER(*p)\n+\t    || ISLOWER(*p)))\n+      *p = '_';\n+}\n+  \n /* Generate a name for a function unique to this translation unit.\n    TYPE is some string to identify the purpose of this function to the\n    linker or collect2.  */\n@@ -5431,19 +5451,7 @@ get_file_function_name_long (type)\n \n   /* Don't need to pull weird characters out of global names.  */\n   if (p != first_global_object_name)\n-    {\n-      for (q = buf+11; *q; q++)\n-\tif (! ( ISDIGIT(*q)\n-#ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n-\t       || *q == '$'\n-#endif\n-#ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but...  */\n-\t       || *q == '.'\n-#endif\n-\t       || ISUPPER(*q)\n-\t       || ISLOWER(*q)))\n-\t  *q = '_';\n-    }\n+    clean_symbol_name (buf + 11);\n \n   return get_identifier (buf);\n }"}, {"sha": "80bb787b7c9a742ae503196435c0657a25065282", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -2435,6 +2435,7 @@ extern tree builtin_function\t\t\tPARAMS ((const char *, tree, int,\n \f\n /* In tree.c */\n extern char *perm_calloc\t\t\tPARAMS ((int, long));\n+extern void clean_symbol_name\t\t\tPARAMS ((char *));\n extern tree get_file_function_name\t\tPARAMS ((int));\n extern tree get_file_function_name_long \tPARAMS ((const char *));\n extern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));"}, {"sha": "6c68319a244386c640f6871e5322e370f9730952", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -1,3 +1,7 @@\n+2000-08-28  Jason Merrill  <jason@redhat.com>\n+\n+\t* md5.h: New file.\n+\n 2000-08-24  Greg McGary  <greg@mcgary.org>\n \n \t* libiberty.h (ARRAY_SIZE): New macro."}, {"sha": "ad97efc321355d02cf5de1e085a063dbf5eb4883", "filename": "include/md5.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/include%2Fmd5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/include%2Fmd5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fmd5.h?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -0,0 +1,146 @@\n+/* md5.h - Declaration of functions and data types used for MD5 sum\n+   computing library functions.\n+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   NOTE: The canonical source of this file is maintained with the GNU C\n+   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _MD5_H\n+#define _MD5_H 1\n+\n+#include <stdio.h>\n+\n+#if defined HAVE_LIMITS_H || _LIBC\n+# include <limits.h>\n+#endif\n+\n+/* The following contortions are an attempt to use the C preprocessor\n+   to determine an unsigned integral type that is 32 bits wide.  An\n+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but\n+   doing that would require that the configure script compile and *run*\n+   the resulting executable.  Locally running cross-compiled executables\n+   is usually not possible.  */\n+\n+#ifdef _LIBC\n+# include <sys/types.h>\n+typedef u_int32_t md5_uint32;\n+#else\n+# if defined __STDC__ && __STDC__\n+#  define UINT_MAX_32_BITS 4294967295U\n+# else\n+#  define UINT_MAX_32_BITS 0xFFFFFFFF\n+# endif\n+\n+/* If UINT_MAX isn't defined, assume it's a 32-bit type.\n+   This should be valid for all systems GNU cares about because\n+   that doesn't include 16-bit systems, and only modern systems\n+   (that certainly have <limits.h>) have 64+-bit integral types.  */\n+\n+# ifndef UINT_MAX\n+#  define UINT_MAX UINT_MAX_32_BITS\n+# endif\n+\n+# if UINT_MAX == UINT_MAX_32_BITS\n+   typedef unsigned int md5_uint32;\n+# else\n+#  if USHRT_MAX == UINT_MAX_32_BITS\n+    typedef unsigned short md5_uint32;\n+#  else\n+#   if ULONG_MAX == UINT_MAX_32_BITS\n+     typedef unsigned long md5_uint32;\n+#   else\n+     /* The following line is intended to evoke an error.\n+        Using #error is not portable enough.  */\n+     \"Cannot determine unsigned 32-bit data type.\"\n+#   endif\n+#  endif\n+# endif\n+#endif\n+\n+#undef __P\n+#if defined (__STDC__) && __STDC__\n+#define\t__P(x) x\n+#else\n+#define\t__P(x) ()\n+#endif\n+\n+/* Structure to save state of computation between the single steps.  */\n+struct md5_ctx\n+{\n+  md5_uint32 A;\n+  md5_uint32 B;\n+  md5_uint32 C;\n+  md5_uint32 D;\n+\n+  md5_uint32 total[2];\n+  md5_uint32 buflen;\n+  char buffer[128];\n+};\n+\n+/*\n+ * The following three functions are build up the low level used in\n+ * the functions `md5_stream' and `md5_buffer'.\n+ */\n+\n+/* Initialize structure containing state of computation.\n+   (RFC 1321, 3.3: Step 3)  */\n+extern void md5_init_ctx __P ((struct md5_ctx *ctx));\n+\n+/* Starting with the result of former calls of this function (or the\n+   initialization function update the context for the next LEN bytes\n+   starting at BUFFER.\n+   It is necessary that LEN is a multiple of 64!!! */\n+extern void md5_process_block __P ((const void *buffer, size_t len,\n+\t\t\t\t    struct md5_ctx *ctx));\n+\n+/* Starting with the result of former calls of this function (or the\n+   initialization function update the context for the next LEN bytes\n+   starting at BUFFER.\n+   It is NOT required that LEN is a multiple of 64.  */\n+extern void md5_process_bytes __P ((const void *buffer, size_t len,\n+\t\t\t\t    struct md5_ctx *ctx));\n+\n+/* Process the remaining bytes in the buffer and put result from CTX\n+   in first 16 bytes following RESBUF.  The result is always in little\n+   endian byte order, so that a byte-wise output yields to the wanted\n+   ASCII representation of the message digest.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32 bits value.  */\n+extern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));\n+\n+\n+/* Put result from CTX in first 16 bytes following RESBUF.  The result is\n+   always in little endian byte order, so that a byte-wise output yields\n+   to the wanted ASCII representation of the message digest.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32 bits value.  */\n+extern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));\n+\n+\n+/* Compute MD5 message digest for bytes read from STREAM.  The\n+   resulting message digest number will be written into the 16 bytes\n+   beginning at RESBLOCK.  */\n+extern int md5_stream __P ((FILE *stream, void *resblock));\n+\n+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The\n+   result is always in little endian byte order, so that a byte-wise\n+   output yields to the wanted ASCII representation of the message\n+   digest.  */\n+extern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));\n+\n+#endif"}, {"sha": "6849b0019e8aca14f69afc178d32c46bef5dbd2b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -1,3 +1,9 @@\n+2000-08-28  Jason Merrill  <jason@redhat.com>\n+\n+\t* Makefile.in (REQUIRED_OFILES): Add md5.o.\n+\t(CFILES): Add md5.c.\n+\t* md5.c: New file.\n+\n 2000-08-27  Alex Samuel  <samuel@codesourcery.com>\n \n \t* cp-demangle.c (demangle_name): Initialize template_p in local"}, {"sha": "c46d9dd1b56359763026a8d2db7f2791371eb90f", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -128,7 +128,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n \tbzero.c calloc.c choose-temp.c clock.c concat.c cplus-dem.c\t      \\\n         cp-demangle.c dyn-string.c fdmatch.c fnmatch.c getcwd.c\t\t      \\\n \tgetpwd.c getopt.c getopt1.c getpagesize.c getruntime.c\t\t      \\\n-\tfloatformat.c hashtab.c hex.c index.c insque.c memchr.c memcmp.c      \\\n+\tfloatformat.c hashtab.c hex.c index.c insque.c md5.c memchr.c memcmp.c\\\n \tmemcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c\t      \\\n \tpartition.c pexecute.c putenv.c random.c rename.c rindex.c setenv.c   \\\n \tsigsetmask.c sort.c spaces.c splay-tree.c strcasecmp.c strncasecmp.c  \\\n@@ -140,7 +140,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o cp-demangle.o \\\n \tdyn-string.o fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o\t  \\\n-\tgetruntime.o hashtab.o hex.o floatformat.o objalloc.o obstack.o\t  \\\n+\tgetruntime.o hashtab.o hex.o floatformat.o md5.o objalloc.o obstack.o \\\n \tpartition.o pexecute.o sort.o spaces.o splay-tree.o strerror.o\t  \\\n \tstrsignal.o xatexit.o xexit.o xmalloc.o xmemdup.o xstrdup.o\t  \\\n \txstrerror.o"}, {"sha": "d742c54f66514c4b16ec1d54862eeed9053ac693", "filename": "libiberty/md5.c", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2Fmd5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/881c6935bf565020e7955fede0b186232aa30bc7/libiberty%2Fmd5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmd5.c?ref=881c6935bf565020e7955fede0b186232aa30bc7", "patch": "@@ -0,0 +1,419 @@\n+/* md5.c - Functions to compute MD5 message digest of files or memory blocks\n+   according to the definition of MD5 in RFC 1321 from April 1992.\n+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   NOTE: The canonical source of this file is maintained with the GNU C\n+   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <sys/types.h>\n+\n+#if STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+# include <string.h>\n+#else\n+# ifndef HAVE_MEMCPY\n+#  define memcpy(d, s, n) bcopy ((s), (d), (n))\n+# endif\n+#endif\n+\n+#include \"md5.h\"\n+\n+#ifdef _LIBC\n+# include <endian.h>\n+# if __BYTE_ORDER == __BIG_ENDIAN\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#endif\n+\n+#ifdef WORDS_BIGENDIAN\n+# define SWAP(n)\t\t\t\t\t\t\t\\\n+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))\n+#else\n+# define SWAP(n) (n)\n+#endif\n+\n+\n+/* This array contains the bytes used to pad the buffer to the next\n+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */\n+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };\n+\n+\n+/* Initialize structure containing state of computation.\n+   (RFC 1321, 3.3: Step 3)  */\n+void\n+md5_init_ctx (ctx)\n+     struct md5_ctx *ctx;\n+{\n+  ctx->A = 0x67452301;\n+  ctx->B = 0xefcdab89;\n+  ctx->C = 0x98badcfe;\n+  ctx->D = 0x10325476;\n+\n+  ctx->total[0] = ctx->total[1] = 0;\n+  ctx->buflen = 0;\n+}\n+\n+/* Put result from CTX in first 16 bytes following RESBUF.  The result\n+   must be in little endian byte order.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32 bits value.  */\n+void *\n+md5_read_ctx (ctx, resbuf)\n+     const struct md5_ctx *ctx;\n+     void *resbuf;\n+{\n+  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);\n+  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);\n+  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);\n+  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);\n+\n+  return resbuf;\n+}\n+\n+/* Process the remaining bytes in the internal buffer and the usual\n+   prolog according to the standard and write the result to RESBUF.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32 bits value.  */\n+void *\n+md5_finish_ctx (ctx, resbuf)\n+     struct md5_ctx *ctx;\n+     void *resbuf;\n+{\n+  /* Take yet unprocessed bytes into account.  */\n+  md5_uint32 bytes = ctx->buflen;\n+  size_t pad;\n+\n+  /* Now count remaining bytes.  */\n+  ctx->total[0] += bytes;\n+  if (ctx->total[0] < bytes)\n+    ++ctx->total[1];\n+\n+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;\n+  memcpy (&ctx->buffer[bytes], fillbuf, pad);\n+\n+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n+  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP (ctx->total[0] << 3);\n+  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP ((ctx->total[1] << 3) |\n+\t\t\t\t\t\t\t(ctx->total[0] >> 29));\n+\n+  /* Process last bytes.  */\n+  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);\n+\n+  return md5_read_ctx (ctx, resbuf);\n+}\n+\n+/* Compute MD5 message digest for bytes read from STREAM.  The\n+   resulting message digest number will be written into the 16 bytes\n+   beginning at RESBLOCK.  */\n+int\n+md5_stream (stream, resblock)\n+     FILE *stream;\n+     void *resblock;\n+{\n+  /* Important: BLOCKSIZE must be a multiple of 64.  */\n+#define BLOCKSIZE 4096\n+  struct md5_ctx ctx;\n+  char buffer[BLOCKSIZE + 72];\n+  size_t sum;\n+\n+  /* Initialize the computation context.  */\n+  md5_init_ctx (&ctx);\n+\n+  /* Iterate over full file contents.  */\n+  while (1)\n+    {\n+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n+\t computation function processes the whole buffer so that with the\n+\t next round of the loop another block can be read.  */\n+      size_t n;\n+      sum = 0;\n+\n+      /* Read block.  Take care for partial reads.  */\n+      do\n+\t{\n+\t  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n+\n+\t  sum += n;\n+\t}\n+      while (sum < BLOCKSIZE && n != 0);\n+      if (n == 0 && ferror (stream))\n+        return 1;\n+\n+      /* If end of file is reached, end the loop.  */\n+      if (n == 0)\n+\tbreak;\n+\n+      /* Process buffer with BLOCKSIZE bytes.  Note that\n+\t\t\tBLOCKSIZE % 64 == 0\n+       */\n+      md5_process_block (buffer, BLOCKSIZE, &ctx);\n+    }\n+\n+  /* Add the last bytes if necessary.  */\n+  if (sum > 0)\n+    md5_process_bytes (buffer, sum, &ctx);\n+\n+  /* Construct result in desired memory.  */\n+  md5_finish_ctx (&ctx, resblock);\n+  return 0;\n+}\n+\n+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The\n+   result is always in little endian byte order, so that a byte-wise\n+   output yields to the wanted ASCII representation of the message\n+   digest.  */\n+void *\n+md5_buffer (buffer, len, resblock)\n+     const char *buffer;\n+     size_t len;\n+     void *resblock;\n+{\n+  struct md5_ctx ctx;\n+\n+  /* Initialize the computation context.  */\n+  md5_init_ctx (&ctx);\n+\n+  /* Process whole buffer but last len % 64 bytes.  */\n+  md5_process_bytes (buffer, len, &ctx);\n+\n+  /* Put result in desired memory area.  */\n+  return md5_finish_ctx (&ctx, resblock);\n+}\n+\n+\n+void\n+md5_process_bytes (buffer, len, ctx)\n+     const void *buffer;\n+     size_t len;\n+     struct md5_ctx *ctx;\n+{\n+  /* When we already have some bits in our internal buffer concatenate\n+     both inputs first.  */\n+  if (ctx->buflen != 0)\n+    {\n+      size_t left_over = ctx->buflen;\n+      size_t add = 128 - left_over > len ? len : 128 - left_over;\n+\n+      memcpy (&ctx->buffer[left_over], buffer, add);\n+      ctx->buflen += add;\n+\n+      if (left_over + add > 64)\n+\t{\n+\t  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);\n+\t  /* The regions in the following copy operation cannot overlap.  */\n+\t  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],\n+\t\t  (left_over + add) & 63);\n+\t  ctx->buflen = (left_over + add) & 63;\n+\t}\n+\n+      buffer = (const char *) buffer + add;\n+      len -= add;\n+    }\n+\n+  /* Process available complete blocks.  */\n+  if (len > 64)\n+    {\n+      md5_process_block (buffer, len & ~63, ctx);\n+      buffer = (const char *) buffer + (len & ~63);\n+      len &= 63;\n+    }\n+\n+  /* Move remaining bytes in internal buffer.  */\n+  if (len > 0)\n+    {\n+      memcpy (ctx->buffer, buffer, len);\n+      ctx->buflen = len;\n+    }\n+}\n+\n+\n+/* These are the four functions used in the four steps of the MD5 algorithm\n+   and defined in the RFC 1321.  The first function is a little bit optimized\n+   (as found in Colin Plumbs public domain implementation).  */\n+/* #define FF(b, c, d) ((b & c) | (~b & d)) */\n+#define FF(b, c, d) (d ^ (b & (c ^ d)))\n+#define FG(b, c, d) FF (d, b, c)\n+#define FH(b, c, d) (b ^ c ^ d)\n+#define FI(b, c, d) (c ^ (b | ~d))\n+\n+/* Process LEN bytes of BUFFER, accumulating context into CTX.\n+   It is assumed that LEN % 64 == 0.  */\n+\n+void\n+md5_process_block (buffer, len, ctx)\n+     const void *buffer;\n+     size_t len;\n+     struct md5_ctx *ctx;\n+{\n+  md5_uint32 correct_words[16];\n+  const md5_uint32 *words = buffer;\n+  size_t nwords = len / sizeof (md5_uint32);\n+  const md5_uint32 *endp = words + nwords;\n+  md5_uint32 A = ctx->A;\n+  md5_uint32 B = ctx->B;\n+  md5_uint32 C = ctx->C;\n+  md5_uint32 D = ctx->D;\n+\n+  /* First increment the byte count.  RFC 1321 specifies the possible\n+     length of the file up to 2^64 bits.  Here we only compute the\n+     number of bytes.  Do a double word increment.  */\n+  ctx->total[0] += len;\n+  if (ctx->total[0] < len)\n+    ++ctx->total[1];\n+\n+  /* Process all bytes in the buffer with 64 bytes in each round of\n+     the loop.  */\n+  while (words < endp)\n+    {\n+      md5_uint32 *cwp = correct_words;\n+      md5_uint32 A_save = A;\n+      md5_uint32 B_save = B;\n+      md5_uint32 C_save = C;\n+      md5_uint32 D_save = D;\n+\n+      /* First round: using the given function, the context and a constant\n+\t the next context is computed.  Because the algorithms processing\n+\t unit is a 32-bit word and it is determined to work on words in\n+\t little endian byte order we perhaps have to change the byte order\n+\t before the computation.  To reduce the work for the next steps\n+\t we store the swapped words in the array CORRECT_WORDS.  */\n+\n+#define OP(a, b, c, d, s, T)\t\t\t\t\t\t\\\n+      do\t\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;\t\t\\\n+\t  ++words;\t\t\t\t\t\t\t\\\n+\t  CYCLIC (a, s);\t\t\t\t\t\t\\\n+\t  a += b;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      while (0)\n+\n+      /* It is unfortunate that C does not provide an operator for\n+\t cyclic rotation.  Hope the C compiler is smart enough.  */\n+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n+\n+      /* Before we start, one word to the strange constants.\n+\t They are defined in RFC 1321 as\n+\n+\t T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\n+       */\n+\n+      /* Round 1.  */\n+      OP (A, B, C, D,  7, 0xd76aa478);\n+      OP (D, A, B, C, 12, 0xe8c7b756);\n+      OP (C, D, A, B, 17, 0x242070db);\n+      OP (B, C, D, A, 22, 0xc1bdceee);\n+      OP (A, B, C, D,  7, 0xf57c0faf);\n+      OP (D, A, B, C, 12, 0x4787c62a);\n+      OP (C, D, A, B, 17, 0xa8304613);\n+      OP (B, C, D, A, 22, 0xfd469501);\n+      OP (A, B, C, D,  7, 0x698098d8);\n+      OP (D, A, B, C, 12, 0x8b44f7af);\n+      OP (C, D, A, B, 17, 0xffff5bb1);\n+      OP (B, C, D, A, 22, 0x895cd7be);\n+      OP (A, B, C, D,  7, 0x6b901122);\n+      OP (D, A, B, C, 12, 0xfd987193);\n+      OP (C, D, A, B, 17, 0xa679438e);\n+      OP (B, C, D, A, 22, 0x49b40821);\n+\n+      /* For the second to fourth round we have the possibly swapped words\n+\t in CORRECT_WORDS.  Redefine the macro to take an additional first\n+\t argument specifying the function to use.  */\n+#undef OP\n+#define OP(f, a, b, c, d, k, s, T)\t\t\t\t\t\\\n+      do \t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  a += f (b, c, d) + correct_words[k] + T;\t\t\t\\\n+\t  CYCLIC (a, s);\t\t\t\t\t\t\\\n+\t  a += b;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      while (0)\n+\n+      /* Round 2.  */\n+      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);\n+      OP (FG, D, A, B, C,  6,  9, 0xc040b340);\n+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n+      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);\n+      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);\n+      OP (FG, D, A, B, C, 10,  9, 0x02441453);\n+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n+      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);\n+      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);\n+      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);\n+      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);\n+      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);\n+      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);\n+      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);\n+      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);\n+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n+\n+      /* Round 3.  */\n+      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);\n+      OP (FH, D, A, B, C,  8, 11, 0x8771f681);\n+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n+      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);\n+      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);\n+      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);\n+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n+      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);\n+      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);\n+      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);\n+      OP (FH, B, C, D, A,  6, 23, 0x04881d05);\n+      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);\n+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n+      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);\n+\n+      /* Round 4.  */\n+      OP (FI, A, B, C, D,  0,  6, 0xf4292244);\n+      OP (FI, D, A, B, C,  7, 10, 0x432aff97);\n+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n+      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);\n+      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);\n+      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);\n+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n+      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);\n+      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);\n+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n+      OP (FI, C, D, A, B,  6, 15, 0xa3014314);\n+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n+      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);\n+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n+      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);\n+      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);\n+\n+      /* Add the starting values of the context.  */\n+      A += A_save;\n+      B += B_save;\n+      C += C_save;\n+      D += D_save;\n+    }\n+\n+  /* Put checksum in context given as argument.  */\n+  ctx->A = A;\n+  ctx->B = B;\n+  ctx->C = C;\n+  ctx->D = D;\n+}"}]}