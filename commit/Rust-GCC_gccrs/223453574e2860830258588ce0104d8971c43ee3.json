{"sha": "223453574e2860830258588ce0104d8971c43ee3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIzNDUzNTc0ZTI4NjA4MzAyNTg1ODhjZTAxMDRkODk3MWM0M2VlMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-01-27T14:54:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-01-27T14:54:37Z"}, "message": "re PR tree-optimization/50444 (-ftree-sra ignores alignment)\n\n2012-01-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/50444\n\t* expr.c (mem_ref_refers_to_non_mem_p): New function.\n\t(expand_assignment): Use it.  Properly handle misaligned\n\tbases when expanding stores to component references.\n\t(expand_expr_real_1): Use mem_ref_refers_to_non_mem_p and\n\trefactor that case.\n\nFrom-SVN: r183629", "tree": {"sha": "dafa0ce7d5bb9bfc0cf46d5f2fb1426c73e95f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dafa0ce7d5bb9bfc0cf46d5f2fb1426c73e95f91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/223453574e2860830258588ce0104d8971c43ee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223453574e2860830258588ce0104d8971c43ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/223453574e2860830258588ce0104d8971c43ee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223453574e2860830258588ce0104d8971c43ee3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e08120b1ffde961adf63c2cc95f0416690a17bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08120b1ffde961adf63c2cc95f0416690a17bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08120b1ffde961adf63c2cc95f0416690a17bae"}], "stats": {"total": 169, "additions": 109, "deletions": 60}, "files": [{"sha": "844494742abafd477a484359189c875a63ebb0a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223453574e2860830258588ce0104d8971c43ee3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223453574e2860830258588ce0104d8971c43ee3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=223453574e2860830258588ce0104d8971c43ee3", "patch": "@@ -1,3 +1,12 @@\n+2012-01-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50444\n+\t* expr.c (mem_ref_refers_to_non_mem_p): New function.\n+\t(expand_assignment): Use it.  Properly handle misaligned\n+\tbases when expanding stores to component references.\n+\t(expand_expr_real_1): Use mem_ref_refers_to_non_mem_p and\n+\trefactor that case.\n+\n 2012-01-27  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR middle-end/51389"}, {"sha": "ff88fcd356f726cc0f02d9d4d2c40b9f4b502097", "filename": "gcc/expr.c", "status": "modified", "additions": 100, "deletions": 60, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223453574e2860830258588ce0104d8971c43ee3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223453574e2860830258588ce0104d8971c43ee3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=223453574e2860830258588ce0104d8971c43ee3", "patch": "@@ -4548,6 +4548,23 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n     }\n }\n \n+/* Returns true if the MEM_REF REF refers to an object that does not\n+   reside in memory and has non-BLKmode.  */\n+\n+static bool\n+mem_ref_refers_to_non_mem_p (tree ref)\n+{\n+  tree base = TREE_OPERAND (ref, 0);\n+  if (TREE_CODE (base) != ADDR_EXPR)\n+    return false;\n+  base = TREE_OPERAND (base, 0);\n+  return (DECL_P (base)\n+\t  && !TREE_ADDRESSABLE (base)\n+\t  && DECL_MODE (base) != BLKmode\n+\t  && DECL_RTL_SET_P (base)\n+\t  && !MEM_P (DECL_RTL (base)));\n+}\n+\n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n    is true, try generating a nontemporal store.  */\n \n@@ -4571,6 +4588,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if (operand_equal_p (to, from, 0))\n     return;\n \n+  /* Handle misaligned stores.  */\n   mode = TYPE_MODE (TREE_TYPE (to));\n   if ((TREE_CODE (to) == MEM_REF\n        || TREE_CODE (to) == TARGET_MEM_REF)\n@@ -4580,6 +4598,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       && ((icode = optab_handler (movmisalign_optab, mode))\n \t  != CODE_FOR_nothing))\n     {\n+      addr_space_t as\n+\t= TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n       struct expand_operand ops[2];\n       enum machine_mode address_mode;\n       rtx reg, op0, mem;\n@@ -4589,16 +4609,14 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       if (TREE_CODE (to) == MEM_REF)\n \t{\n-\t  addr_space_t as\n-\t    = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n \t  tree base = TREE_OPERAND (to, 0);\n \t  address_mode = targetm.addr_space.address_mode (as);\n \t  op0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \t  op0 = convert_memory_address_addr_space (address_mode, op0, as);\n \t  if (!integer_zerop (TREE_OPERAND (to, 1)))\n \t    {\n \t      rtx off\n-\t\t  = immed_double_int_const (mem_ref_offset (to), address_mode);\n+\t\t= immed_double_int_const (mem_ref_offset (to), address_mode);\n \t      op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n \t    }\n \t  op0 = memory_address_addr_space (mode, op0, as);\n@@ -4608,10 +4626,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t}\n       else if (TREE_CODE (to) == TARGET_MEM_REF)\n \t{\n-\t  addr_space_t as\n-\t    = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n \t  struct mem_address addr;\n-\n \t  get_address_description (to, &addr);\n \t  op0 = addr_for_mem_ref (&addr, as, true);\n \t  op0 = memory_address_addr_space (mode, op0, as);\n@@ -4627,7 +4642,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       create_fixed_operand (&ops[0], mem);\n       create_input_operand (&ops[1], reg, mode);\n       /* The movmisalign<mode> pattern cannot fail, else the assignment would\n-         silently be omitted.  */\n+\t silently be omitted.  */\n       expand_insn (icode, 2, ops);\n       return;\n     }\n@@ -4636,12 +4651,10 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      if the structure component's rtx is not simply a MEM.\n      Assignment of an array element at a constant index, and assignment of\n      an array element in an unaligned packed structure field, has the same\n-     problem.  */\n+     problem.  Same for (partially) storing into a non-memory object.  */\n   if (handled_component_p (to)\n-      /* ???  We only need to handle MEM_REF here if the access is not\n-         a full access of the base object.  */\n       || (TREE_CODE (to) == MEM_REF\n-\t  && TREE_CODE (TREE_OPERAND (to, 0)) == ADDR_EXPR)\n+\t  && mem_ref_refers_to_non_mem_p (to))\n       || TREE_CODE (TREE_TYPE (to)) == ARRAY_TYPE)\n     {\n       enum machine_mode mode1;\n@@ -4652,6 +4665,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       int unsignedp;\n       int volatilep = 0;\n       tree tem;\n+      bool misalignp;\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n@@ -4664,8 +4678,22 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */\n-\n-      to_rtx = expand_normal (tem);\n+      mode = TYPE_MODE (TREE_TYPE (tem));\n+      if (TREE_CODE (tem) == MEM_REF\n+\t  && mode != BLKmode\n+\t  && ((align = get_object_or_type_alignment (tem))\n+\t      < GET_MODE_ALIGNMENT (mode))\n+\t  && ((icode = optab_handler (movmisalign_optab, mode))\n+\t      != CODE_FOR_nothing))\n+\t{\n+\t  misalignp = true;\n+\t  to_rtx = gen_reg_rtx (mode);\n+\t}\n+      else\n+\t{\n+\t  misalignp = false;\n+\t  to_rtx = expand_normal (tem);\n+\t}\n \n       /* If the bitfield is volatile, we want to access it in the\n \t field's mode, not the computed mode.\n@@ -4811,6 +4839,37 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t\t  nontemporal);\n \t}\n \n+      if (misalignp)\n+\t{\n+\t  struct expand_operand ops[2];\n+\t  enum machine_mode address_mode;\n+\t  rtx op0, mem;\n+\t  addr_space_t as = TYPE_ADDR_SPACE\n+\t      (TREE_TYPE (TREE_TYPE (TREE_OPERAND (tem, 0))));\n+\t  tree base = TREE_OPERAND (tem, 0);\n+\t  address_mode = targetm.addr_space.address_mode (as);\n+\t  op0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\t  op0 = convert_memory_address_addr_space (address_mode, op0, as);\n+\t  if (!integer_zerop (TREE_OPERAND (tem, 1)))\n+\t    {\n+\t      rtx off = immed_double_int_const (mem_ref_offset (tem),\n+\t\t\t\t\t\taddress_mode);\n+\t      op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n+\t    }\n+\t  op0 = memory_address_addr_space (mode, op0, as);\n+\t  mem = gen_rtx_MEM (mode, op0);\n+\t  set_mem_attributes (mem, tem, 0);\n+\t  set_mem_addr_space (mem, as);\n+\t  if (TREE_THIS_VOLATILE (tem))\n+\t    MEM_VOLATILE_P (mem) = 1;\n+\n+\t  create_fixed_operand (&ops[0], mem);\n+\t  create_input_operand (&ops[1], to_rtx, mode);\n+\t  /* The movmisalign<mode> pattern cannot fail, else the assignment\n+\t     would silently be omitted.  */\n+\t  expand_insn (icode, 2, ops);\n+\t}\n+\n       if (result)\n \tpreserve_temp_slots (result);\n       free_temp_slots ();\n@@ -4866,11 +4925,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       return;\n     }\n \n-  /* Ordinary treatment.  Expand TO to get a REG or MEM rtx.\n-     Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n-\n-  if (to_rtx == 0)\n-    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  /* Ordinary treatment.  Expand TO to get a REG or MEM rtx.  */\n+  to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL\n@@ -9295,54 +9351,38 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tunsigned align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n-\tif (TREE_CODE (base) == ADDR_EXPR)\n+\tif (mem_ref_refers_to_non_mem_p (exp))\n \t  {\n \t    HOST_WIDE_INT offset = mem_ref_offset (exp).low;\n \t    tree bit_offset;\n+\t    tree bftype;\n \t    base = TREE_OPERAND (base, 0);\n-\t    if (!DECL_P (base))\n-\t      {\n-\t\tHOST_WIDE_INT off;\n-\t\tbase = get_addr_base_and_unit_offset (base, &off);\n-\t\tgcc_assert (base);\n-\t\toffset += off;\n-\t      }\n-\t    /* If we are expanding a MEM_REF of a non-BLKmode non-addressable\n-\t       decl we must use bitfield operations.  */\n-\t    if (DECL_P (base)\n-\t\t&& !TREE_ADDRESSABLE (base)\n-\t\t&& DECL_MODE (base) != BLKmode\n-\t\t&& DECL_RTL_SET_P (base)\n-\t\t&& !MEM_P (DECL_RTL (base)))\n+\t    if (offset == 0\n+\t\t&& host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t\t&& (GET_MODE_BITSIZE (DECL_MODE (base))\n+\t\t    == TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp)))))\n+\t      return expand_expr (build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t  TREE_TYPE (exp), base),\n+\t\t\t\t  target, tmode, modifier);\n+\t    bit_offset = bitsize_int (offset * BITS_PER_UNIT);\n+\t    bftype = TREE_TYPE (base);\n+\t    if (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n+\t      bftype = TREE_TYPE (exp);\n+\t    else\n \t      {\n-\t\ttree bftype;\n-\t\tif (offset == 0\n-\t\t    && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n-\t\t    && (GET_MODE_BITSIZE (DECL_MODE (base))\n-\t\t\t== TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp)))))\n-\t\t  return expand_expr (build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t      TREE_TYPE (exp), base),\n-\t\t\t\t      target, tmode, modifier);\n-\t\tbit_offset = bitsize_int (offset * BITS_PER_UNIT);\n-\t\tbftype = TREE_TYPE (base);\n-\t\tif (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n-\t\t  bftype = TREE_TYPE (exp);\n-\t\telse\n-\t\t  {\n-\t\t    temp = assign_stack_temp (DECL_MODE (base),\n-\t\t\t\t\t      GET_MODE_SIZE (DECL_MODE (base)),\n-\t\t\t\t\t      0);\n-\t\t    store_expr (base, temp, 0, false);\n-\t\t    temp = adjust_address (temp, BLKmode, offset);\n-\t\t    set_mem_size (temp, int_size_in_bytes (TREE_TYPE (exp)));\n-\t\t    return temp;\n-\t\t  }\n-\t\treturn expand_expr (build3 (BIT_FIELD_REF, bftype,\n-\t\t\t\t\t    base,\n-\t\t\t\t\t    TYPE_SIZE (TREE_TYPE (exp)),\n-\t\t\t\t\t    bit_offset),\n-\t\t\t\t    target, tmode, modifier);\n+\t\ttemp = assign_stack_temp (DECL_MODE (base),\n+\t\t\t\t\t  GET_MODE_SIZE (DECL_MODE (base)),\n+\t\t\t\t\t  0);\n+\t\tstore_expr (base, temp, 0, false);\n+\t\ttemp = adjust_address (temp, BLKmode, offset);\n+\t\tset_mem_size (temp, int_size_in_bytes (TREE_TYPE (exp)));\n+\t\treturn temp;\n \t      }\n+\t    return expand_expr (build3 (BIT_FIELD_REF, bftype,\n+\t\t\t\t\tbase,\n+\t\t\t\t\tTYPE_SIZE (TREE_TYPE (exp)),\n+\t\t\t\t\tbit_offset),\n+\t\t\t\ttarget, tmode, modifier);\n \t  }\n \taddress_mode = targetm.addr_space.address_mode (as);\n \tbase = TREE_OPERAND (exp, 0);"}]}