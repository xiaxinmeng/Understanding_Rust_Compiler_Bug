{"sha": "47b4c53f035502f1140ae6e286c4576faa57c7ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiNGM1M2YwMzU1MDJmMTE0MGFlNmUyODZjNDU3NmZhYTU3YzdlYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2018-12-14T05:40:07Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2018-12-14T05:40:07Z"}, "message": "auto-profile.c (AFDO_EINFO): New macro.\n\n\t* auto-profile.c (AFDO_EINFO): New macro.\n\t(class edge_info): New class.\n\t(is_edge_annotated, set_edge_annotated): Delete.\n\t(afdo_propagate_edge, afdo_propagate_circuit, afdo_propagate): Remove\n\tparameter.  Adjust edge count computation and annotation using class\n\tedge_info.\n\t(afdo_calculate_branch_prob, afdo_annotate_cfg): Likewise.\n\nFrom-SVN: r267119", "tree": {"sha": "9efe394f8e8344fae649f0f8aaeb36be2b0e7959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9efe394f8e8344fae649f0f8aaeb36be2b0e7959"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b4c53f035502f1140ae6e286c4576faa57c7ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b4c53f035502f1140ae6e286c4576faa57c7ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b4c53f035502f1140ae6e286c4576faa57c7ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b4c53f035502f1140ae6e286c4576faa57c7ea/comments", "author": null, "committer": null, "parents": [{"sha": "9ee465524042b1244ac20b3c1083d818c32d9bfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee465524042b1244ac20b3c1083d818c32d9bfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee465524042b1244ac20b3c1083d818c32d9bfc"}], "stats": {"total": 200, "additions": 107, "deletions": 93}, "files": [{"sha": "b59574863b3634826c15dceef859e58b7801a930", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b4c53f035502f1140ae6e286c4576faa57c7ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b4c53f035502f1140ae6e286c4576faa57c7ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47b4c53f035502f1140ae6e286c4576faa57c7ea", "patch": "@@ -1,3 +1,13 @@\n+2018-12-14  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* auto-profile.c (AFDO_EINFO): New macro.\n+\t(class edge_info): New class.\n+\t(is_edge_annotated, set_edge_annotated): Delete.\n+\t(afdo_propagate_edge, afdo_propagate_circuit, afdo_propagate): Remove\n+\tparameter.  Adjust edge count computation and annotation using class\n+\tedge_info.\n+\t(afdo_calculate_branch_prob, afdo_annotate_cfg): Likewise.\n+\n 2018-12-13  Michael Ploujnikov  <michael.ploujnikov@oracle.com>\n \n \t* ipa-cp.c (print_all_lattices): Skip cp clones."}, {"sha": "7e0020bc232756f4a04e709c64bbcd04838a8eb1", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 97, "deletions": 93, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b4c53f035502f1140ae6e286c4576faa57c7ea/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b4c53f035502f1140ae6e286c4576faa57c7ea/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=47b4c53f035502f1140ae6e286c4576faa57c7ea", "patch": "@@ -101,6 +101,23 @@ along with GCC; see the file COPYING3.  If not see\n namespace autofdo\n {\n \n+/* Intermediate edge info used when propagating AutoFDO profile information.\n+   We can't edge->count() directly since it's computed from edge's probability\n+   while probability is yet not decided during propagation.  */\n+#define AFDO_EINFO(e)                     ((struct edge_info *) e->aux)\n+class edge_info\n+{\n+public:\n+  edge_info () : count_ (profile_count::zero ().afdo ()), annotated_ (false) {}\n+  bool is_annotated () const { return annotated_; }\n+  void set_annotated () { annotated_ = true; }\n+  profile_count get_count () const { return count_; }\n+  void set_count (profile_count count) { count_ = count; }\n+private:\n+  profile_count count_;\n+  bool annotated_;\n+};\n+\n /* Represent a source location: (function_decl, lineno).  */\n typedef std::pair<tree, unsigned> decl_lineno;\n \n@@ -1067,18 +1084,6 @@ set_bb_annotated (basic_block bb, bb_set *annotated)\n   annotated->insert (bb);\n }\n \n-static bool\n-is_edge_annotated (const edge e, const edge_set &annotated)\n-{\n-  return annotated.find (e) != annotated.end ();\n-}\n-\n-static void\n-set_edge_annotated (edge e, edge_set *annotated)\n-{\n-  annotated->insert (e);\n-}\n-\n /* For a given BB, set its execution count. Attach value profile if a stmt\n    is not in PROMOTED, because we only want to promote an indirect call once.\n    Return TRUE if BB is annotated.  */\n@@ -1188,12 +1193,11 @@ afdo_find_equiv_class (bb_set *annotated_bb)\n    edges' counts are known, then the basic block's unknown count can also be\n    calculated.\n    IS_SUCC is true if out edges of a basic blocks are examined.\n-   Update ANNOTATED_BB and ANNOTATED_EDGE accordingly.\n+   Update ANNOTATED_BB accordingly.\n    Return TRUE if any basic block/edge count is changed.  */\n \n static bool\n-afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n-                     edge_set *annotated_edge)\n+afdo_propagate_edge (bool is_succ, bb_set *annotated_bb)\n {\n   basic_block bb;\n   bool changed = false;\n@@ -1206,30 +1210,30 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n     profile_count total_known_count = profile_count::zero ().afdo ();\n \n     FOR_EACH_EDGE (e, ei, is_succ ? bb->succs : bb->preds)\n-      if (!is_edge_annotated (e, *annotated_edge))\n-\tnum_unknown_edge++, unknown_edge = e;\n-      else\n-\ttotal_known_count += e->count ();\n+      {\n+\tgcc_assert (AFDO_EINFO (e) != NULL);\n+\tif (! AFDO_EINFO (e)->is_annotated ())\n+\t  num_unknown_edge++, unknown_edge = e;\n+\telse\n+\t  total_known_count += AFDO_EINFO (e)->get_count ();\n+      }\n \n-    if (num_unknown_edge == 0)\n+    /* Be careful not to annotate block with no successor in special cases.  */\n+    if (num_unknown_edge == 0 && total_known_count > bb->count)\n       {\n-        if (total_known_count > bb->count)\n-          {\n-            bb->count = total_known_count;\n-            changed = true;\n-          }\n-        if (!is_bb_annotated (bb, *annotated_bb))\n-          {\n-            set_bb_annotated (bb, annotated_bb);\n-            changed = true;\n-          }\n+\tbb->count = total_known_count;\n+\tif (!is_bb_annotated (bb, *annotated_bb))\n+\t  set_bb_annotated (bb, annotated_bb);\n+\tchanged = true;\n       }\n     else if (num_unknown_edge == 1 && is_bb_annotated (bb, *annotated_bb))\n       {\n-        unknown_edge->probability\n-\t  = total_known_count.probability_in (bb->count);\n-        set_edge_annotated (unknown_edge, annotated_edge);\n-        changed = true;\n+\tif (bb->count > total_known_count)\n+\t  AFDO_EINFO (unknown_edge)->set_count (bb->count - total_known_count);\n+\telse\n+\t  AFDO_EINFO (unknown_edge)->set_count (profile_count::zero().afdo ());\n+\tAFDO_EINFO (unknown_edge)->set_annotated ();\n+\tchanged = true;\n       }\n   }\n   return changed;\n@@ -1265,11 +1269,10 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n        goto BB3\n \n    In this case, we need to propagate through PHI to determine the edge\n-   count of BB1->BB.t1, BB.t1->BB.t2.\n-   Update ANNOTATED_EDGE accordingly.  */\n+   count of BB1->BB.t1, BB.t1->BB.t2.  */\n \n static void\n-afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n+afdo_propagate_circuit (const bb_set &annotated_bb)\n {\n   basic_block bb;\n   FOR_ALL_BB_FN (bb, cfun)\n@@ -1308,7 +1311,7 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n       bool check_value_one = (((integer_onep (cmp_rhs))\n                                ^ (gimple_cond_code (cmp_stmt) == EQ_EXPR))\n                               ^ ((e->flags & EDGE_TRUE_VALUE) != 0));\n-      if (!is_edge_annotated (e, *annotated_edge))\n+      if (! AFDO_EINFO (e)->is_annotated ())\n         continue;\n       for (i = 0; i < gimple_phi_num_args (phi_stmt); i++)\n         {\n@@ -1322,18 +1325,18 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n             continue;\n           total++;\n           only_one = ep;\n-          if (!e->probability.initialized_p ()\n-\t      && !is_edge_annotated (ep, *annotated_edge))\n-            {\n-              ep->probability = profile_probability::never ().afdo ();\n-              set_edge_annotated (ep, annotated_edge);\n-            }\n-        }\n-      if (total == 1 && !is_edge_annotated (only_one, *annotated_edge))\n-        {\n-          only_one->probability = e->probability;\n-          set_edge_annotated (only_one, annotated_edge);\n-        }\n+          if (! (AFDO_EINFO (e)->get_count ()).nonzero_p ()\n+\t      && ! AFDO_EINFO (ep)->is_annotated ())\n+\t    {\n+\t      AFDO_EINFO (ep)->set_count (profile_count::zero ().afdo ());\n+\t      AFDO_EINFO (ep)->set_annotated ();\n+\t    }\n+\t}\n+      if (total == 1 && ! AFDO_EINFO (only_one)->is_annotated ())\n+\t{\n+\t  AFDO_EINFO (only_one)->set_count (AFDO_EINFO (e)->get_count ());\n+\t  AFDO_EINFO (only_one)->set_annotated ();\n+\t}\n     }\n   }\n }\n@@ -1342,7 +1345,7 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n    graph. We do the propagation iteratively until stablize.  */\n \n static void\n-afdo_propagate (bb_set *annotated_bb, edge_set *annotated_edge)\n+afdo_propagate (bb_set *annotated_bb)\n {\n   basic_block bb;\n   bool changed = true;\n@@ -1359,64 +1362,71 @@ afdo_propagate (bb_set *annotated_bb, edge_set *annotated_edge)\n     {\n       changed = false;\n \n-      if (afdo_propagate_edge (true, annotated_bb, annotated_edge))\n+      if (afdo_propagate_edge (true, annotated_bb))\n         changed = true;\n-      if (afdo_propagate_edge (false, annotated_bb, annotated_edge))\n+      if (afdo_propagate_edge (false, annotated_bb))\n         changed = true;\n-      afdo_propagate_circuit (*annotated_bb, annotated_edge);\n+      afdo_propagate_circuit (*annotated_bb);\n     }\n }\n \n /* Propagate counts on control flow graph and calculate branch\n    probabilities.  */\n \n static void\n-afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n+afdo_calculate_branch_prob (bb_set *annotated_bb)\n {\n+  edge e;\n+  edge_iterator ei;\n   basic_block bb;\n-  bool has_sample = false;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-  {\n-    if (bb->count > profile_count::zero ())\n-      {\n-\thas_sample = true;\n-\tbreak;\n-      }\n-  }\n-\n-  if (!has_sample)\n-    return;\n \n   calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n   loop_optimizer_init (0);\n \n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      gcc_assert (bb->aux == NULL);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  gcc_assert (e->aux == NULL);\n+\t  e->aux = new edge_info ();\n+\t}\n+    }\n+\n   afdo_find_equiv_class (annotated_bb);\n-  afdo_propagate (annotated_bb, annotated_edge);\n+  afdo_propagate (annotated_bb);\n \n   FOR_EACH_BB_FN (bb, cfun)\n   {\n-    edge e;\n-    edge_iterator ei;\n     int num_unknown_succ = 0;\n     profile_count total_count = profile_count::zero ().afdo ();\n \n     FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      if (!is_edge_annotated (e, *annotated_edge))\n+      gcc_assert (AFDO_EINFO (e) != NULL);\n+      if (! AFDO_EINFO (e)->is_annotated ())\n         num_unknown_succ++;\n       else\n-        total_count += e->count ();\n+        total_count += AFDO_EINFO (e)->get_count ();\n     }\n     if (num_unknown_succ == 0 && total_count > profile_count::zero ())\n       {\n-        FOR_EACH_EDGE (e, ei, bb->succs)\n-          e->probability = e->count ().probability_in (total_count);\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  e->probability\n+\t    = AFDO_EINFO (e)->get_count ().probability_in (total_count);\n       }\n   }\n   FOR_ALL_BB_FN (bb, cfun)\n-    bb->aux = NULL;\n+    {\n+      bb->aux = NULL;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (AFDO_EINFO (e) != NULL)\n+\t  {\n+\t    delete AFDO_EINFO (e);\n+\t    e->aux = NULL;\n+\t  }\n+    }\n \n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n@@ -1496,7 +1506,6 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n {\n   basic_block bb;\n   bb_set annotated_bb;\n-  edge_set annotated_edge;\n   const function_instance *s\n       = afdo_source_profile->get_function_instance_by_decl (\n           current_function_decl);\n@@ -1511,21 +1520,15 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n   profile_count max_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   FOR_EACH_BB_FN (bb, cfun)\n-  {\n-    edge e;\n-    edge_iterator ei;\n-\n-    /* As autoFDO uses sampling approach, we have to assume that all\n-       counters are zero when not seen by autoFDO.  */\n-    bb->count = profile_count::zero ().afdo ();\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n-      e->probability = profile_probability::uninitialized ();\n-\n-    if (afdo_set_bb_count (bb, promoted_stmts))\n-      set_bb_annotated (bb, &annotated_bb);\n-    if (bb->count > max_count)\n-      max_count = bb->count;\n-  }\n+    {\n+      /* As autoFDO uses sampling approach, we have to assume that all\n+\t counters are zero when not seen by autoFDO.  */\n+      bb->count = profile_count::zero ().afdo ();\n+      if (afdo_set_bb_count (bb, promoted_stmts))\n+\tset_bb_annotated (bb, &annotated_bb);\n+      if (bb->count > max_count)\n+\tmax_count = bb->count;\n+    }\n   if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n       > ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->count)\n     {\n@@ -1546,7 +1549,8 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n   afdo_source_profile->mark_annotated (cfun->function_end_locus);\n   if (max_count > profile_count::zero ())\n     {\n-      afdo_calculate_branch_prob (&annotated_bb, &annotated_edge);\n+      /* Calculate, propagate count and probability information on CFG.  */\n+      afdo_calculate_branch_prob (&annotated_bb);\n       update_max_bb_count ();\n       profile_status_for_fn (cfun) = PROFILE_READ;\n     }"}]}