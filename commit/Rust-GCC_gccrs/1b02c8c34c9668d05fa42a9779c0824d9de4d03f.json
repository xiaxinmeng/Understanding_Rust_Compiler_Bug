{"sha": "1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwMmM4YzM0Yzk2NjhkMDVmYTQyYTk3NzljMDgyNGQ5ZGU0ZDAzZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-01-07T01:47:22Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-01-07T01:47:22Z"}, "message": "Refactor some code for a future change.\n\n2020-01-06  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (hard_reg_and_mode_to_addr_mask): New\n\thelper function to return the valid addressing formats for a given\n\thard register and mode.\n\t(rs6000_adjust_vec_address): Call hard_reg_and_mode_to_addr_mask.\n\nIndex: gcc/config/rs6000/rs6000.c\n===================================================================\n--- gcc/config/rs6000/rs6000.c\t(revision 279912)\n+++ gcc/config/rs6000/rs6000.c\t(working copy)\n@@ -6729,6 +6729,30 @@ rs6000_expand_vector_extract (rtx target\n     }\n }\n \n+/* Helper function to return an address mask based on a physical register.  */\n+\n+static addr_mask_type\n+hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n+{\n+  unsigned int r = reg_or_subregno (reg);\n+  addr_mask_type addr_mask;\n+\n+  gcc_assert (HARD_REGISTER_NUM_P (r));\n+  if (INT_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_GPR];\n+\n+  else if (FP_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_FPR];\n+\n+  else if (ALTIVEC_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_VMX];\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return addr_mask;\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -6865,21 +6889,8 @@ rs6000_adjust_vec_address (rtx scalar_re\n   if (GET_CODE (new_addr) == PLUS)\n     {\n       rtx op1 = XEXP (new_addr, 1);\n-      addr_mask_type addr_mask;\n-      unsigned int scalar_regno = reg_or_subregno (scalar_reg);\n-\n-      gcc_assert (HARD_REGISTER_NUM_P (scalar_regno));\n-      if (INT_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_GPR];\n-\n-      else if (FP_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_FPR];\n-\n-      else if (ALTIVEC_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_VMX];\n-\n-      else\n-\tgcc_unreachable ();\n+      addr_mask_type addr_mask\n+\t= hard_reg_and_mode_to_addr_mask (scalar_reg, scalar_mode);\n \n       if (REG_P (op1) || SUBREG_P (op1))\n \tvalid_addr_p = (addr_mask & RELOAD_REG_INDEXED) != 0;\n\nFrom-SVN: r279941", "tree": {"sha": "abe833ae80086115e0ce79d268d7657198f26fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abe833ae80086115e0ce79d268d7657198f26fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b02c8c34c9668d05fa42a9779c0824d9de4d03f/comments", "author": null, "committer": null, "parents": [{"sha": "0a4c673c8206a21d80c04489fb661813929dee3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4c673c8206a21d80c04489fb661813929dee3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a4c673c8206a21d80c04489fb661813929dee3e"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "513e14acaabc61f3a23cbc3683377a088210be2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b02c8c34c9668d05fa42a9779c0824d9de4d03f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b02c8c34c9668d05fa42a9779c0824d9de4d03f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "patch": "@@ -1,5 +1,10 @@\n 2020-01-06  Michael Meissner  <meissner@linux.ibm.com>\n \n+\t* config/rs6000/rs6000.c (hard_reg_and_mode_to_addr_mask): New\n+\thelper function to return the valid addressing formats for a given\n+\thard register and mode.\n+\t(rs6000_adjust_vec_address): Call hard_reg_and_mode_to_addr_mask.\n+\n \t* config/rs6000/constraints.md (Q constraint): Update\n \tdocumentation.\n \t* doc/md.texi (RS/6000 constraints): Update 'Q' cosntraint"}, {"sha": "127927d9583a418367f854e51a80ea5afc0150ec", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b02c8c34c9668d05fa42a9779c0824d9de4d03f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b02c8c34c9668d05fa42a9779c0824d9de4d03f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1b02c8c34c9668d05fa42a9779c0824d9de4d03f", "patch": "@@ -6729,6 +6729,30 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n     }\n }\n \n+/* Helper function to return an address mask based on a physical register.  */\n+\n+static addr_mask_type\n+hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n+{\n+  unsigned int r = reg_or_subregno (reg);\n+  addr_mask_type addr_mask;\n+\n+  gcc_assert (HARD_REGISTER_NUM_P (r));\n+  if (INT_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_GPR];\n+\n+  else if (FP_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_FPR];\n+\n+  else if (ALTIVEC_REGNO_P (r))\n+    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_VMX];\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return addr_mask;\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -6865,21 +6889,8 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n   if (GET_CODE (new_addr) == PLUS)\n     {\n       rtx op1 = XEXP (new_addr, 1);\n-      addr_mask_type addr_mask;\n-      unsigned int scalar_regno = reg_or_subregno (scalar_reg);\n-\n-      gcc_assert (HARD_REGISTER_NUM_P (scalar_regno));\n-      if (INT_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_GPR];\n-\n-      else if (FP_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_FPR];\n-\n-      else if (ALTIVEC_REGNO_P (scalar_regno))\n-\taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_VMX];\n-\n-      else\n-\tgcc_unreachable ();\n+      addr_mask_type addr_mask\n+\t= hard_reg_and_mode_to_addr_mask (scalar_reg, scalar_mode);\n \n       if (REG_P (op1) || SUBREG_P (op1))\n \tvalid_addr_p = (addr_mask & RELOAD_REG_INDEXED) != 0;"}]}