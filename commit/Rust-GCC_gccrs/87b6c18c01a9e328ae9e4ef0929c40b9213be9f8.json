{"sha": "87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdiNmMxOGMwMWE5ZTMyOGFlOWU0ZWYwOTI5YzQwYjkyMTNiZTlmOA==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-11-13T13:57:58Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:57:58Z"}, "message": "[PATCH 1/4] OpenMP 4.0 offloading to Intel MIC: mkoffload.\n\ngcc/\n\t* config.gcc (*-intelmic-* | *-intelmicemul-*): Add i386/t-intelmic to\n\ttmake_file.\n\t(i[34567]86-*-* | x86_64-*-*): Build mkoffload$(exeext) with the\n\taccelerator compiler.\n\t* config/i386/intelmic-mkoffload.c: New file.\n\t* config/i386/t-intelmic: Ditto.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\n\nFrom-SVN: r217495", "tree": {"sha": "629489cf37b1596d48e4683b49fd8d899574db50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/629489cf37b1596d48e4683b49fd8d899574db50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/comments", "author": null, "committer": null, "parents": [{"sha": "122d7303a0bdb99ebf4f1a178270295b93d8bed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122d7303a0bdb99ebf4f1a178270295b93d8bed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122d7303a0bdb99ebf4f1a178270295b93d8bed5"}], "stats": {"total": 575, "additions": 575, "deletions": 0}, "files": [{"sha": "9267d828c9cc81404903587052af4387827996b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "patch": "@@ -1,3 +1,13 @@\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\n+\t* config.gcc (*-intelmic-* | *-intelmicemul-*): Add i386/t-intelmic to\n+\ttmake_file.\n+\t(i[34567]86-*-* | x86_64-*-*): Build mkoffload$(exeext) with the\n+\taccelerator compiler.\n+\t* config/i386/intelmic-mkoffload.c: New file.\n+\t* config/i386/t-intelmic: Ditto.\n+\n 2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>"}, {"sha": "a6b37d8b8f5da734cb5103022bcad244db7ed6b4", "filename": "gcc/config.gcc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "patch": "@@ -2884,6 +2884,13 @@ powerpc*-*-* | rs6000-*-*)\n \ttm_file=\"${tm_file} rs6000/option-defaults.h\"\n esac\n \n+# Build mkoffload tool\n+case ${target} in\n+*-intelmic-* | *-intelmicemul-*)\n+\ttmake_file=\"${tmake_file} i386/t-intelmic\"\n+\t;;\n+esac\n+\n if [ \"$target_has_targetcm\" = \"no\" ]; then\n   c_target_objs=\"$c_target_objs default-c.o\"\n   cxx_target_objs=\"$cxx_target_objs default-c.o\"\n@@ -4279,3 +4286,11 @@ then\n \t\ttarget_cpu_default=$target_cpu_default2\n \tfi\n fi\n+\n+case ${target} in\n+i[34567]86-*-* | x86_64-*-*)\n+\tif test x$enable_as_accelerator = xyes; then\n+\t\textra_programs=\"mkoffload\\$(exeext)\"\n+\tfi\n+\t;;\n+esac"}, {"sha": "c972f56a50e4a85539d28026113bd6b492fa7bef", "filename": "gcc/config/i386/intelmic-mkoffload.c", "status": "added", "additions": 541, "deletions": 0, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c?ref=87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "patch": "@@ -0,0 +1,541 @@\n+/* Offload image generation tool for Intel MIC devices.\n+\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include <libgen.h>\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"obstack.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+#include \"collect-utils.h\"\n+#include <libgomp_target.h>\n+\n+const char tool_name[] = \"intelmic mkoffload\";\n+\n+const char image_section_name[] = \".gnu.offload_images\";\n+const char *symbols[3] = { \"__offload_image_intelmic_start\",\n+\t\t\t   \"__offload_image_intelmic_end\",\n+\t\t\t   \"__offload_image_intelmic_size\" };\n+const char *out_obj_filename = NULL;\n+\n+int num_temps = 0;\n+const int MAX_NUM_TEMPS = 10;\n+const char *temp_files[MAX_NUM_TEMPS];\n+\n+/* Shows if we should compile binaries for i386 instead of x86-64.  */\n+bool target_ilp32 = false;\n+\n+/* Delete tempfiles and exit function.  */\n+void\n+tool_cleanup (bool from_signal ATTRIBUTE_UNUSED)\n+{\n+  for (int i = 0; i < num_temps; i++)\n+    maybe_unlink (temp_files[i]);\n+}\n+\n+static void\n+mkoffload_atexit (void)\n+{\n+  tool_cleanup (false);\n+}\n+\n+/* Unlink FILE unless we are debugging.  */\n+void\n+maybe_unlink (const char *file)\n+{\n+  if (debug)\n+    notice (\"[Leaving %s]\\n\", file);\n+  else\n+    unlink_if_ordinary (file);\n+}\n+\n+/* Add or change the value of an environment variable, outputting the\n+   change to standard error if in verbose mode.  */\n+static void\n+xputenv (const char *string)\n+{\n+  if (verbose)\n+    fprintf (stderr, \"%s\\n\", string);\n+  putenv (CONST_CAST (char *, string));\n+}\n+\n+/* Parse STR, saving found tokens into PVALUES and return their number.\n+   Tokens are assumed to be delimited by ':'.  */\n+static unsigned\n+parse_env_var (const char *str, char ***pvalues)\n+{\n+  const char *curval, *nextval;\n+  char **values;\n+  unsigned num = 1, i;\n+\n+  curval = strchr (str, ':');\n+  while (curval)\n+    {\n+      num++;\n+      curval = strchr (curval + 1, ':');\n+    }\n+\n+  values = (char **) xmalloc (num * sizeof (char *));\n+  curval = str;\n+  nextval = strchr (curval, ':');\n+  if (nextval == NULL)\n+    nextval = strchr (curval, '\\0');\n+\n+  for (i = 0; i < num; i++)\n+    {\n+      int l = nextval - curval;\n+      values[i] = (char *) xmalloc (l + 1);\n+      memcpy (values[i], curval, l);\n+      values[i][l] = 0;\n+      curval = nextval + 1;\n+      nextval = strchr (curval, ':');\n+      if (nextval == NULL)\n+\tnextval = strchr (curval, '\\0');\n+    }\n+  *pvalues = values;\n+  return num;\n+}\n+\n+/* Auxiliary function that frees elements of PTR and PTR itself.\n+   N is number of elements to be freed.  If PTR is NULL, nothing is freed.\n+   If an element is NULL, subsequent elements are not freed.  */\n+static void\n+free_array_of_ptrs (void **ptr, unsigned n)\n+{\n+  unsigned i;\n+  if (!ptr)\n+    return;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (!ptr[i])\n+\tbreak;\n+      free (ptr[i]);\n+    }\n+  free (ptr);\n+  return;\n+}\n+\n+/* Check whether NAME can be accessed in MODE.  This is like access,\n+   except that it never considers directories to be executable.  */\n+static int\n+access_check (const char *name, int mode)\n+{\n+  if (mode == X_OK)\n+    {\n+      struct stat st;\n+\n+      if (stat (name, &st) < 0 || S_ISDIR (st.st_mode))\n+\treturn -1;\n+    }\n+\n+  return access (name, mode);\n+}\n+\n+/* Find target compiler using a path from COLLECT_GCC or COMPILER_PATH.  */\n+static char *\n+find_target_compiler (const char *name)\n+{\n+  bool found = false;\n+  char **paths = NULL;\n+  unsigned n_paths, i;\n+  const char *collect_path = dirname (ASTRDUP (getenv (\"COLLECT_GCC\")));\n+  size_t len = strlen (collect_path) + 1 + strlen (name) + 1;\n+  char *target_compiler = XNEWVEC (char, len);\n+  sprintf (target_compiler, \"%s/%s\", collect_path, name);\n+  if (access_check (target_compiler, X_OK) == 0)\n+    {\n+      found = true;\n+      goto out;\n+    }\n+\n+  n_paths = parse_env_var (getenv (\"COMPILER_PATH\"), &paths);\n+  for (i = 0; i < n_paths; i++)\n+    {\n+      len = strlen (paths[i]) + 1 + strlen (name) + 1;\n+      target_compiler = XRESIZEVEC (char, target_compiler, len);\n+      sprintf (target_compiler, \"%s/%s\", paths[i], name);\n+      if (access_check (target_compiler, X_OK) == 0)\n+\t{\n+\t  found = true;\n+\t  break;\n+\t}\n+    }\n+\n+out:\n+  free_array_of_ptrs ((void **) paths, n_paths);\n+  return found ? target_compiler : NULL;\n+}\n+\n+static void\n+compile_for_target (struct obstack *argv_obstack)\n+{\n+  if (target_ilp32)\n+    obstack_ptr_grow (argv_obstack, \"-m32\");\n+  obstack_ptr_grow (argv_obstack, NULL);\n+  char **argv = XOBFINISH (argv_obstack, char **);\n+\n+  /* Save environment variables.  */\n+  const char *epath = getenv (\"GCC_EXEC_PREFIX\");\n+  const char *cpath = getenv (\"COMPILER_PATH\");\n+  const char *lpath = getenv (\"LIBRARY_PATH\");\n+  const char *rpath = getenv (\"LD_RUN_PATH\");\n+  unsetenv (\"GCC_EXEC_PREFIX\");\n+  unsetenv (\"COMPILER_PATH\");\n+  unsetenv (\"LIBRARY_PATH\");\n+  unsetenv (\"LD_RUN_PATH\");\n+\n+  fork_execute (argv[0], argv, false);\n+  obstack_free (argv_obstack, NULL);\n+\n+  /* Restore environment variables.  */\n+  xputenv (concat (\"GCC_EXEC_PREFIX=\", epath, NULL));\n+  xputenv (concat (\"COMPILER_PATH=\", cpath, NULL));\n+  xputenv (concat (\"LIBRARY_PATH=\", lpath, NULL));\n+  xputenv (concat (\"LD_RUN_PATH=\", rpath, NULL));\n+}\n+\n+/* Generates object file with the descriptor for the target library.  */\n+static const char *\n+generate_target_descr_file (const char *target_compiler)\n+{\n+  const char *src_filename = make_temp_file (\"_target_descr.c\");\n+  const char *obj_filename = make_temp_file (\"_target_descr.o\");\n+  temp_files[num_temps++] = src_filename;\n+  temp_files[num_temps++] = obj_filename;\n+  FILE *src_file = fopen (src_filename, \"w\");\n+\n+  if (!src_file)\n+    fatal_error (\"cannot open '%s'\", src_filename);\n+\n+  fprintf (src_file,\n+\t   \"extern void *__offload_funcs_end[];\\n\"\n+\t   \"extern void *__offload_vars_end[];\\n\\n\"\n+\n+\t   \"void *__offload_func_table[0]\\n\"\n+\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n+\t   \"section (\\\".gnu.offload_funcs\\\"))) = { };\\n\\n\"\n+\n+\t   \"void *__offload_var_table[0]\\n\"\n+\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n+\t   \"section (\\\".gnu.offload_vars\\\"))) = { };\\n\\n\"\n+\n+\t   \"void *__OFFLOAD_TARGET_TABLE__[]\\n\"\n+\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"))) = {\\n\"\n+\t   \"  &__offload_func_table, &__offload_funcs_end,\\n\"\n+\t   \"  &__offload_var_table, &__offload_vars_end\\n\"\n+\t   \"};\\n\\n\");\n+\n+  fprintf (src_file,\n+\t   \"#ifdef __cplusplus\\n\"\n+\t   \"extern \\\"C\\\"\\n\"\n+\t   \"#endif\\n\"\n+\t   \"void target_register_lib (const void *);\\n\\n\"\n+\n+\t   \"__attribute__((constructor))\\n\"\n+\t   \"static void\\n\"\n+\t   \"init (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  target_register_lib (__OFFLOAD_TARGET_TABLE__);\\n\"\n+\t   \"}\\n\");\n+  fclose (src_file);\n+\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, target_compiler);\n+  obstack_ptr_grow (&argv_obstack, \"-c\");\n+  obstack_ptr_grow (&argv_obstack, \"-shared\");\n+  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n+  obstack_ptr_grow (&argv_obstack, src_filename);\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, obj_filename);\n+  compile_for_target (&argv_obstack);\n+\n+  return obj_filename;\n+}\n+\n+/* Generates object file with __offload_*_end symbols for the target\n+   library.  */\n+static const char *\n+generate_target_offloadend_file (const char *target_compiler)\n+{\n+  const char *src_filename = make_temp_file (\"_target_offloadend.c\");\n+  const char *obj_filename = make_temp_file (\"_target_offloadend.o\");\n+  temp_files[num_temps++] = src_filename;\n+  temp_files[num_temps++] = obj_filename;\n+  FILE *src_file = fopen (src_filename, \"w\");\n+\n+  if (!src_file)\n+    fatal_error (\"cannot open '%s'\", src_filename);\n+\n+  fprintf (src_file,\n+\t   \"void *__offload_funcs_end[0]\\n\"\n+\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n+\t   \"section (\\\".gnu.offload_funcs\\\"))) = { };\\n\\n\"\n+\n+\t   \"void *__offload_vars_end[0]\\n\"\n+\t   \"__attribute__ ((__used__, visibility (\\\"hidden\\\"),\\n\"\n+\t   \"section (\\\".gnu.offload_vars\\\"))) = { };\\n\");\n+  fclose (src_file);\n+\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, target_compiler);\n+  obstack_ptr_grow (&argv_obstack, \"-c\");\n+  obstack_ptr_grow (&argv_obstack, \"-shared\");\n+  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n+  obstack_ptr_grow (&argv_obstack, src_filename);\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, obj_filename);\n+  compile_for_target (&argv_obstack);\n+\n+  return obj_filename;\n+}\n+\n+/* Generates object file with the host side descriptor.  */\n+static const char *\n+generate_host_descr_file (const char *host_compiler)\n+{\n+  const char *src_filename = make_temp_file (\"_host_descr.c\");\n+  const char *obj_filename = make_temp_file (\"_host_descr.o\");\n+  temp_files[num_temps++] = src_filename;\n+  temp_files[num_temps++] = obj_filename;\n+  FILE *src_file = fopen (src_filename, \"w\");\n+\n+  if (!src_file)\n+    fatal_error (\"cannot open '%s'\", src_filename);\n+\n+  fprintf (src_file,\n+\t   \"extern void *__OFFLOAD_TABLE__;\\n\"\n+\t   \"extern void *__offload_image_intelmic_start;\\n\"\n+\t   \"extern void *__offload_image_intelmic_end;\\n\\n\"\n+\n+\t   \"static const void *__offload_target_data[] = {\\n\"\n+\t   \"  &__offload_image_intelmic_start, &__offload_image_intelmic_end\\n\"\n+\t   \"};\\n\\n\");\n+\n+  fprintf (src_file,\n+\t   \"#ifdef __cplusplus\\n\"\n+\t   \"extern \\\"C\\\"\\n\"\n+\t   \"#endif\\n\"\n+\t   \"void GOMP_offload_register (void *, int, void *);\\n\\n\"\n+\n+\t   \"__attribute__((constructor))\\n\"\n+\t   \"static void\\n\"\n+\t   \"init (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_register (&__OFFLOAD_TABLE__, %d, __offload_target_data);\\n\"\n+\t   \"}\\n\", OFFLOAD_TARGET_TYPE_INTEL_MIC);\n+  fclose (src_file);\n+\n+  unsigned new_argc = 0;\n+  const char *new_argv[9];\n+  new_argv[new_argc++] = host_compiler;\n+  new_argv[new_argc++] = \"-c\";\n+  new_argv[new_argc++] = \"-fPIC\";\n+  new_argv[new_argc++] = \"-shared\";\n+  if (target_ilp32)\n+    new_argv[new_argc++] = \"-m32\";\n+  new_argv[new_argc++] = src_filename;\n+  new_argv[new_argc++] = \"-o\";\n+  new_argv[new_argc++] = obj_filename;\n+  new_argv[new_argc++] = NULL;\n+\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), false);\n+\n+  return obj_filename;\n+}\n+\n+static const char *\n+prepare_target_image (const char *target_compiler, int argc, char **argv)\n+{\n+  const char *target_descr_filename\n+    = generate_target_descr_file (target_compiler);\n+  const char *target_offloadend_filename\n+    = generate_target_offloadend_file (target_compiler);\n+\n+  char *opt1\n+    = XALLOCAVEC (char, sizeof (\"-Wl,\") + strlen (target_descr_filename));\n+  char *opt2\n+    = XALLOCAVEC (char, sizeof (\"-Wl,\") + strlen (target_offloadend_filename));\n+  sprintf (opt1, \"-Wl,%s\", target_descr_filename);\n+  sprintf (opt2, \"-Wl,%s\", target_offloadend_filename);\n+\n+  const char *target_so_filename = make_temp_file (\"_offload_intelmic.so\");\n+  temp_files[num_temps++] = target_so_filename;\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, target_compiler);\n+  obstack_ptr_grow (&argv_obstack, \"-xlto\");\n+  obstack_ptr_grow (&argv_obstack, \"-fopenmp\");\n+  obstack_ptr_grow (&argv_obstack, \"-shared\");\n+  obstack_ptr_grow (&argv_obstack, \"-fPIC\");\n+  obstack_ptr_grow (&argv_obstack, opt1);\n+  for (int i = 1; i < argc; i++)\n+    {\n+      if (!strcmp (argv[i], \"-o\") && i + 1 != argc)\n+\tout_obj_filename = argv[++i];\n+      else\n+\tobstack_ptr_grow (&argv_obstack, argv[i]);\n+    }\n+  if (!out_obj_filename)\n+    fatal_error (\"output file not specified\");\n+  obstack_ptr_grow (&argv_obstack, opt2);\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, target_so_filename);\n+  compile_for_target (&argv_obstack);\n+\n+  /* Run objcopy.  */\n+  char *rename_section_opt\n+    = XALLOCAVEC (char, sizeof (\".data=\") + strlen (image_section_name));\n+  sprintf (rename_section_opt, \".data=%s\", image_section_name);\n+  const char *objcopy_argv[11];\n+  objcopy_argv[0] = \"objcopy\";\n+  objcopy_argv[1] = \"-B\";\n+  objcopy_argv[2] = \"i386\";\n+  objcopy_argv[3] = \"-I\";\n+  objcopy_argv[4] = \"binary\";\n+  objcopy_argv[5] = \"-O\";\n+  if (target_ilp32)\n+    objcopy_argv[6] = \"elf32-i386\";\n+  else\n+    objcopy_argv[6] = \"elf64-x86-64\";\n+  objcopy_argv[7] = target_so_filename;\n+  objcopy_argv[8] = \"--rename-section\";\n+  objcopy_argv[9] = rename_section_opt;\n+  objcopy_argv[10] = NULL;\n+  fork_execute (objcopy_argv[0], CONST_CAST (char **, objcopy_argv), false);\n+\n+  /* Objcopy has created symbols, containing the input file name with\n+     special characters replaced with '_'.  We are going to rename these\n+     new symbols.  */\n+  size_t symbol_name_len = strlen (target_so_filename);\n+  char *symbol_name = XALLOCAVEC (char, symbol_name_len + 1);\n+  for (size_t i = 0; i <= symbol_name_len; i++)\n+    {\n+      char c = target_so_filename[i];\n+      if ((c == '/') || (c == '.'))\n+\tc = '_';\n+      symbol_name[i] = c;\n+    }\n+\n+  char *opt_for_objcopy[3];\n+  opt_for_objcopy[0] = XALLOCAVEC (char, sizeof (\"_binary__start=\")\n+\t\t\t\t\t + symbol_name_len\n+\t\t\t\t\t + strlen (symbols[0]));\n+  opt_for_objcopy[1] = XALLOCAVEC (char, sizeof (\"_binary__end=\")\n+\t\t\t\t\t + symbol_name_len\n+\t\t\t\t\t + strlen (symbols[1]));\n+  opt_for_objcopy[2] = XALLOCAVEC (char, sizeof (\"_binary__size=\")\n+\t\t\t\t\t + symbol_name_len\n+\t\t\t\t\t + strlen (symbols[2]));\n+  sprintf (opt_for_objcopy[0], \"_binary_%s_start=%s\", symbol_name, symbols[0]);\n+  sprintf (opt_for_objcopy[1], \"_binary_%s_end=%s\", symbol_name, symbols[1]);\n+  sprintf (opt_for_objcopy[2], \"_binary_%s_size=%s\", symbol_name, symbols[2]);\n+\n+  objcopy_argv[0] = \"objcopy\";\n+  objcopy_argv[1] = target_so_filename;\n+  objcopy_argv[2] = \"--redefine-sym\";\n+  objcopy_argv[3] = opt_for_objcopy[0];\n+  objcopy_argv[4] = \"--redefine-sym\";\n+  objcopy_argv[5] = opt_for_objcopy[1];\n+  objcopy_argv[6] = \"--redefine-sym\";\n+  objcopy_argv[7] = opt_for_objcopy[2];\n+  objcopy_argv[8] = NULL;\n+  fork_execute (objcopy_argv[0], CONST_CAST (char **, objcopy_argv), false);\n+\n+  return target_so_filename;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  progname = \"mkoffload-intelmic\";\n+  gcc_init_libintl ();\n+  diagnostic_initialize (global_dc, 0);\n+\n+  if (atexit (mkoffload_atexit) != 0)\n+    fatal_error (\"atexit failed\");\n+\n+  const char *host_compiler = getenv (\"COLLECT_GCC\");\n+  if (!host_compiler)\n+    fatal_error (\"COLLECT_GCC must be set\");\n+\n+  const char *target_driver_name\n+    = DEFAULT_REAL_TARGET_MACHINE \"-accel-\" DEFAULT_TARGET_MACHINE \"-gcc\";\n+  char *target_compiler = find_target_compiler (target_driver_name);\n+  if (target_compiler == NULL)\n+    fatal_error (\"offload compiler %s not found\", target_driver_name);\n+\n+  /* We may be called with all the arguments stored in some file and\n+     passed with @file.  Expand them into argv before processing.  */\n+  expandargv (&argc, &argv);\n+\n+  /* Find out whether we should compile binaries for i386 or x86-64.  */\n+  for (int i = argc - 1; i > 0; i--)\n+    if (strncmp (argv[i], \"-foffload-abi=\", sizeof (\"-foffload-abi=\") - 1) == 0)\n+      {\n+\tif (strstr (argv[i], \"ilp32\"))\n+\t  target_ilp32 = true;\n+\telse if (!strstr (argv[i], \"lp64\"))\n+\t  fatal_error (\"unrecognizable argument of option -foffload-abi\");\n+\tbreak;\n+      }\n+\n+  const char *target_so_filename\n+    = prepare_target_image (target_compiler, argc, argv);\n+\n+  const char *host_descr_filename = generate_host_descr_file (host_compiler);\n+\n+  /* Perform partial linking for the target image and host side descriptor.\n+     As a result we'll get a finalized object file with all offload data.  */\n+  unsigned new_argc = 0;\n+  const char *new_argv[9];\n+  new_argv[new_argc++] = \"ld\";\n+  if (target_ilp32)\n+    {\n+      new_argv[new_argc++] = \"-m\";\n+      new_argv[new_argc++] = \"elf_i386\";\n+    }\n+  new_argv[new_argc++] = \"--relocatable\";\n+  new_argv[new_argc++] = host_descr_filename;\n+  new_argv[new_argc++] = target_so_filename;\n+  new_argv[new_argc++] = \"-o\";\n+  new_argv[new_argc++] = out_obj_filename;\n+  new_argv[new_argc++] = NULL;\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), false);\n+\n+  /* Run objcopy on the resultant object file to localize generated symbols\n+     to avoid conflicting between different DSO and an executable.  */\n+  new_argv[0] = \"objcopy\";\n+  new_argv[1] = \"-L\";\n+  new_argv[2] = symbols[0];\n+  new_argv[3] = \"-L\";\n+  new_argv[4] = symbols[1];\n+  new_argv[5] = \"-L\";\n+  new_argv[6] = symbols[2];\n+  new_argv[7] = out_obj_filename;\n+  new_argv[8] = NULL;\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), false);\n+\n+  return 0;\n+}"}, {"sha": "8b36e0d00a8af826e8e63dc4685a37a027b89dc2", "filename": "gcc/config/i386/t-intelmic", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig%2Fi386%2Ft-intelmic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b6c18c01a9e328ae9e4ef0929c40b9213be9f8/gcc%2Fconfig%2Fi386%2Ft-intelmic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-intelmic?ref=87b6c18c01a9e328ae9e4ef0929c40b9213be9f8", "patch": "@@ -0,0 +1,9 @@\n+mkoffload.o: $(srcdir)/config/i386/intelmic-mkoffload.c | insn-modes.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -I$(srcdir)/../libgomp \\\n+\t  -DDEFAULT_REAL_TARGET_MACHINE=\\\"$(real_target_noncanonical)\\\" \\\n+\t  -DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\" \\\n+\t  $< $(OUTPUT_OPTION)\n+\n+mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBDEPS)\n+\t$(COMPILER) -o $@ mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)"}]}