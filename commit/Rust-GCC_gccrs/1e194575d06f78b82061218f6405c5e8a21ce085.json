{"sha": "1e194575d06f78b82061218f6405c5e8a21ce085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxOTQ1NzVkMDZmNzhiODIwNjEyMThmNjQwNWM1ZThhMjFjZTA4NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T13:50:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T13:50:29Z"}, "message": "[multiple changes]\n\n2010-10-25  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added a-cobove (bounded vector container)\n\tto lists.\n\t* a-contai.ads: Added declaration of Capacity_Error exception.\n\t* a-cobove.ads, a-cobove.adb: New files.\n\n2010-10-25  Thomas Quinot  <quinot@adacore.com>\n\n\t* uname.adb: Revert previous change, no longer needed after change\n\tin par-ch10.adb.\n\n2010-10-25  Thomas Quinot  <quinot@adacore.com>\n\n\t* scos.ads: Minor comment fix.\n\n2010-10-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Assignment_Statement): Check dangerous order\n\tdependence.\n\t* sem_ch6.adb (Analyze_Procedure_Call_Statement): Ditto.\n\t* sem_res.adb (Analyze_Actuals): Add actual to list of actuals for\n\tcurrent construct, for subsequent order dependence checking.\n\t(Resolve): Check order dependence on expressions that are not\n\tsubexpressions.\n\t* sem_util.adb (Check_Order_Dependence): Code cleanup, to correspond\n\tto latest version of AI05-144-2.\n\t* sem_warn.adb (Warn_On_Overlapping_Actuals): Code cleanup.\n\n2010-10-25  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Build_Static_Predicate): Moved out of\n\tBuild_Predicate_Function.\n\t(Build_Static_Predicate): Complet rewrite for more general predicates\n\nFrom-SVN: r165917", "tree": {"sha": "b40bec5a75f1448c3dd1c6683682b9d8c1544311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b40bec5a75f1448c3dd1c6683682b9d8c1544311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e194575d06f78b82061218f6405c5e8a21ce085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e194575d06f78b82061218f6405c5e8a21ce085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e194575d06f78b82061218f6405c5e8a21ce085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e194575d06f78b82061218f6405c5e8a21ce085/comments", "author": null, "committer": null, "parents": [{"sha": "89ff4f167f64c73b46ebc30221119b76887c1b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ff4f167f64c73b46ebc30221119b76887c1b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ff4f167f64c73b46ebc30221119b76887c1b77"}], "stats": {"total": 4150, "additions": 3765, "deletions": 385}, "files": [{"sha": "8e07f6d20ee59d3517a08bf30e9677fa200c6037", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -1,3 +1,38 @@\n+2010-10-25  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added a-cobove (bounded vector container)\n+\tto lists.\n+\t* a-contai.ads: Added declaration of Capacity_Error exception.\n+\t* a-cobove.ads, a-cobove.adb: New files.\n+\n+2010-10-25  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* uname.adb: Revert previous change, no longer needed after change\n+\tin par-ch10.adb.\n+\n+2010-10-25  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* scos.ads: Minor comment fix.\n+\n+2010-10-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Assignment_Statement): Check dangerous order\n+\tdependence.\n+\t* sem_ch6.adb (Analyze_Procedure_Call_Statement): Ditto.\n+\t* sem_res.adb (Analyze_Actuals): Add actual to list of actuals for\n+\tcurrent construct, for subsequent order dependence checking.\n+\t(Resolve): Check order dependence on expressions that are not\n+\tsubexpressions.\n+\t* sem_util.adb (Check_Order_Dependence): Code cleanup, to correspond\n+\tto latest version of AI05-144-2.\n+\t* sem_warn.adb (Warn_On_Overlapping_Actuals): Code cleanup.\n+\n+2010-10-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Build_Static_Predicate): Moved out of\n+\tBuild_Predicate_Function.\n+\t(Build_Static_Predicate): Complet rewrite for more general predicates\n+\n 2010-10-25  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n             Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "a444b1770bf5b76ca6f1b5c250049f7b0f1bb39d", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -114,6 +114,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-comlin$(objext) \\\n   a-contai$(objext) \\\n   a-convec$(objext) \\\n+  a-cobove$(objext) \\\n   a-coorma$(objext) \\\n   a-coormu$(objext) \\\n   a-coorse$(objext) \\"}, {"sha": "8a71a0cd52b8bcee1e26edb439dab43c0c1c74b3", "filename": "gcc/ada/a-cobove.adb", "status": "added", "additions": 2439, "deletions": 0, "changes": 2439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -0,0 +1,2439 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       A D A . C O N T A I N E R S . B O U N D E D _ V E C T O R S        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Generic_Array_Sort;\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Bounded_Vectors is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base;\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\" (Left, Right : Vector) return Vector is\n+      LN   : constant Count_Type := Length (Left);\n+      RN   : constant Count_Type := Length (Right);\n+      N    : Count_Type'Base;  -- length of result\n+      J    : Count_Type'Base;  -- for computing intermediate index values\n+      Last : Index_Type'Base;  -- Last index of result\n+\n+   begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the vector parameters. We could decide to make it larger, but we\n+      --  have no basis for knowing how much larger, so we just allocate the\n+      --  minimum amount of storage.\n+\n+      --  Here we handle the easy cases first, when one of the vector\n+      --  parameters is empty. (We say \"easy\" because there's nothing to\n+      --  compute, that can potentially overflow.)\n+\n+      if LN = 0 then\n+         if RN = 0 then\n+            return Empty_Vector;\n+         end if;\n+\n+         return Vector'(Capacity => RN,\n+                        Elements => Right.Elements (1 .. RN),\n+                        Last     => Right.Last,\n+                        others   => <>);\n+      end if;\n+\n+      if RN = 0 then\n+         return Vector'(Capacity => LN,\n+                        Elements => Left.Elements (1 .. LN),\n+                        Last     => Left.Last,\n+                        others   => <>);\n+      end if;\n+\n+      --  Neither of the vector parameters is empty, so must compute the length\n+      --  of the result vector and its last index. (This is the harder case,\n+      --  because our computations must avoid overflow.)\n+\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the combined lengths. Note that we cannot\n+      --  simply add the lengths, because of the possibilty of overflow.\n+\n+      if LN > Count_Type'Last - RN then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      N := LN + RN;\n+\n+      --  The second constraint is that the new Last index value cannot\n+      --  exceed Index_Type'Last. We use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (N) < No_Index then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n+\n+         Last := No_Index + Index_Type'Base (N);\n+\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of length.\n+\n+         J := Count_Type'Base (No_Index) + N;  -- Last\n+\n+         if J > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (J);\n+\n+      else\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         J := Count_Type'Base (Index_Type'Last) - N;  -- No_Index\n+\n+         if J < Count_Type'Base (No_Index) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         --  We have determined that the result length would not create a Last\n+         --  index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + N);\n+      end if;\n+\n+      declare\n+         LE : Elements_Array renames Left.Elements (1 .. LN);\n+         RE : Elements_Array renames Right.Elements (1 .. RN);\n+\n+      begin\n+         return Vector'(Capacity => N,\n+                        Elements => LE & RE,\n+                        Last     => Last,\n+                        others   => <>);\n+      end;\n+   end \"&\";\n+\n+   function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n+      LN : constant Count_Type := Length (Left);\n+\n+   begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  We must compute the length of the result vector and its last index,\n+      --  but in such a way that overflow is avoided. We must satisfy two\n+      --  constraints: the new length cannot exceed Count_Type'Last, and the\n+      --  new Last index cannot exceed Index_Type'Last.\n+\n+      if LN = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      if Left.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      return Vector'(Capacity => LN + 1,\n+                     Elements => Left.Elements (1 .. LN) & Right,\n+                     Last     => Left.Last + 1,\n+                     others   => <>);\n+   end \"&\";\n+\n+   function \"&\" (Left : Element_Type; Right : Vector) return Vector is\n+      RN : constant Count_Type := Length (Right);\n+\n+   begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  We compute the length of the result vector and its last index, but in\n+      --  such a way that overflow is avoided. We must satisfy two constraints:\n+      --  the new length cannot exceed Count_Type'Last, and the new Last index\n+      --  cannot exceed Index_Type'Last.\n+\n+      if RN = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      if Right.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      return Vector'(Capacity => 1 + RN,\n+                     Elements => Left & Right.Elements (1 .. RN),\n+                     Last     => Right.Last + 1,\n+                     others   => <>);\n+   end \"&\";\n+\n+   function \"&\" (Left, Right : Element_Type) return Vector is\n+   begin\n+      --  We decide that the capacity of the result is the sum of the lengths\n+      --  of the parameters. We could decide to make it larger, but we have no\n+      --  basis for knowing how much larger, so we just allocate the minimum\n+      --  amount of storage.\n+\n+      --  We must compute the length of the result vector and its last index,\n+      --  but in such a way that overflow is avoided. We must satisfy two\n+      --  constraints: the new length cannot exceed Count_Type'Last (here, we\n+      --  know that that condition is satisfied), and the new Last index cannot\n+      --  exceed Index_Type'Last.\n+\n+      if Index_Type'First >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n+\n+      return Vector'(Capacity => 2,\n+                     Elements => (Left, Right),\n+                     Last     => Index_Type'First + 1,\n+                     others   => <>);\n+   end \"&\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   overriding function \"=\" (Left, Right : Vector) return Boolean is\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Last /= Right.Last then\n+         return False;\n+      end if;\n+\n+      for J in Count_Type range 1 .. Left.Length loop\n+         if Left.Elements (J) /= Right.Elements (J) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Vector; Source : Vector) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error  -- ???\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      Target.Clear;\n+\n+      Target.Elements (1 .. Source.Length) :=\n+        Source.Elements (1 .. Source.Length);\n+\n+      Target.Last := Source.Last;\n+   end Assign;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      if New_Item.Is_Empty then\n+         return;\n+      end if;\n+\n+      if Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Container.Insert (Container.Last + 1, New_Item);\n+   end Append;\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+      end if;\n+\n+      Container.Insert (Container.Last + 1, New_Item, Count);\n+   end Append;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Vector) return Count_Type is\n+   begin\n+      return Container.Elements'Length;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Vector) is\n+   begin\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is busy)\";\n+      end if;\n+\n+      Container.Last := No_Index;\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find_Index (Container, Item) /= No_Index;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Vector;\n+      Capacity : Count_Type := 0) return Vector\n+   is\n+      C : Count_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error\n+           with \"Requested capacity is less than Source length\";\n+      end if;\n+\n+      return Target : Vector (C) do\n+         Target.Elements (1 .. Source.Length) :=\n+            Source.Elements (1 .. Source.Length);\n+\n+         Target.Last := Source.Last;\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      Old_Last : constant Index_Type'Base := Container.Last;\n+      Old_Len  : constant Count_Type := Container.Length;\n+      New_Last : Index_Type'Base;\n+      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last\n+      Off      : Count_Type'Base;  -- Index expressed as offset from IT'First\n+\n+   begin\n+      --  Delete removes items from the vector, the number of which is the\n+      --  minimum of the specified Count and the items (if any) that exist from\n+      --  Index to Container.Last. There are no constraints on the specified\n+      --  value of Count (it can be larger than what's available at this\n+      --  position in the vector, for example), but there are constraints on\n+      --  the allowed values of the Index.\n+\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying which items\n+      --  should be deleted, so we must manually check. (That the user is\n+      --  allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Index < Index_Type'First then\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows the\n+      --  corner case of deleting no items from the back end of the vector to\n+      --  be treated as a no-op. (It is assumed that specifying an index value\n+      --  greater than Last + 1 indicates some deeper flaw in the caller's\n+      --  algorithm, so that case is treated as a proper error.)\n+\n+      if Index > Old_Last then\n+         if Index > Old_Last + 1 then\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  Here and elsewhere we treat deleting 0 items from the container as a\n+      --  no-op, even when the container is busy, so we simply return.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete checks the count to determine whether it is\n+      --  being called while the associated callback procedure is executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is busy)\";\n+      end if;\n+\n+      --  We first calculate what's available for deletion starting at\n+      --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n+      --  Count_Type'Base as the type for intermediate values. (See function\n+      --  Length for more information.)\n+\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n+\n+      else\n+         Count2 := Count_Type'Base (Old_Last - Index + 1);\n+      end if;\n+\n+      --  If more elements are requested (Count) for deletion than are\n+      --  available (Count2) for deletion beginning at Index, then everything\n+      --  from Index is deleted. There are no elements to slide down, and so\n+      --  all we need to do is set the value of Container.Last.\n+\n+      if Count >= Count2 then\n+         Container.Last := Index - 1;\n+         return;\n+      end if;\n+\n+      --  There are some elements aren't being deleted (the requested count was\n+      --  less than the available count), so we must slide them down to\n+      --  Index. We first calculate the index values of the respective array\n+      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n+      --  type for intermediate calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Off := Count_Type'Base (Index - Index_Type'First);\n+         New_Last := Old_Last - Index_Type'Base (Count);\n+\n+      else\n+         Off := Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n+         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n+      end if;\n+\n+      --  The array index values for each slice have already been determined,\n+      --  so we just slide down to Index the elements that weren't deleted.\n+\n+      declare\n+         EA  : Elements_Array renames Container.Elements;\n+         Idx : constant Count_Type := EA'First + Off;\n+\n+      begin\n+         EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n+         Container.Last := New_Last;\n+      end;\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      pragma Warnings (Off, Position);\n+\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Container.Last then\n+         raise Program_Error with \"Position index is out of range\";\n+      end if;\n+\n+      Delete (Container, Position.Index, Count);\n+      Position := No_Element;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Count >= Length (Container) then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      Delete (Container, Index_Type'First, Count);\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      --  It is not permitted to delete items while the container is busy (for\n+      --  example, we're in the middle of a passive iteration). However, we\n+      --  always treat deleting 0 items as a no-op, even when we're busy, so we\n+      --  simply return without checking.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete_Last checks the count to determine whether\n+      --  it is being called while the associated callback procedure is\n+      --  executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is busy)\";\n+      end if;\n+\n+      --  There is no restriction on how large Count can be when deleting\n+      --  items. If it is equal or greater than the current length, then this\n+      --  is equivalent to clearing the vector. (In particular, there's no need\n+      --  for us to actually calculate the new value for Last.)\n+\n+      --  If the requested count is less than the current length, then we must\n+      --  calculate the new value for Last. For the type we use the widest of\n+      --  Index_Type'Base and Count_Type'Base for the intermediate values of\n+      --  our calculation.  (See the comments in Length for more information.)\n+\n+      if Count >= Container.Length then\n+         Container.Last := No_Index;\n+\n+      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := Container.Last - Index_Type'Base (Count);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (Container.Last) - Count);\n+      end if;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      return Container.Elements (To_Array_Index (Index));\n+   end Element;\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Position.Container.Element (Position.Index);\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+   begin\n+      if Position.Container /= null then\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n+\n+         if Position.Index > Container.Last then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n+      end if;\n+\n+      for J in Position.Index .. Container.Last loop\n+         if Container.Elements (To_Array_Index (J)) = Item then\n+            return (Container'Unrestricted_Access, J);\n+         end if;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   ----------------\n+   -- Find_Index --\n+   ----------------\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   is\n+   begin\n+      for Indx in Index .. Container.Last loop\n+         if Container.Elements (To_Array_Index (Indx)) = Item then\n+            return Indx;\n+         end if;\n+      end loop;\n+\n+      return No_Index;\n+   end Find_Index;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (Container'Unrestricted_Access, Index_Type'First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Vector) return Element_Type is\n+   begin\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Container.Elements (To_Array_Index (Index_Type'First));\n+   end First_Element;\n+\n+   -----------------\n+   -- First_Index --\n+   -----------------\n+\n+   function First_Index (Container : Vector) return Index_Type is\n+      pragma Unreferenced (Container);\n+   begin\n+      return Index_Type'First;\n+   end First_Index;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : Vector) return Boolean is\n+      begin\n+         if Container.Last <= Index_Type'First then\n+            return True;\n+         end if;\n+\n+         declare\n+            EA : Elements_Array renames Container.Elements;\n+         begin\n+            for J in 1 .. Container.Length - 1 loop\n+               if EA (J + 1) < EA (J) then\n+                  return False;\n+               end if;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge (Target, Source : in out Vector) is\n+         I, J : Count_Type;\n+\n+      begin\n+         if Target.Is_Empty then\n+            Target.Assign (Source);\n+            return;\n+         end if;\n+\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Source.Is_Empty then\n+            return;\n+         end if;\n+\n+         if Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (vector is busy)\";\n+         end if;\n+\n+         I := Target.Length;\n+         Target.Set_Length (I + Source.Length);\n+\n+         declare\n+            TA : Elements_Array renames Target.Elements;\n+            SA : Elements_Array renames Source.Elements;\n+\n+         begin\n+            J := Target.Length;\n+            while not Source.Is_Empty loop\n+               pragma Assert (Source.Length <= 1\n+                                or else not (SA (Source.Length) <\n+                                             SA (Source.Length - 1)));\n+\n+               if I = 0 then\n+                  TA (1 .. J) := SA (1 .. Source.Length);\n+                  Source.Last := No_Index;\n+                  return;\n+               end if;\n+\n+               pragma Assert (I <= 1\n+                                or else not (TA (I) < TA (I - 1)));\n+\n+               if SA (Source.Length) < TA (I) then\n+                  TA (J) := TA (I);\n+                  I := I - 1;\n+\n+               else\n+                  TA (J) := SA (Source.Length);\n+                  Source.Last := Source.Last - 1;\n+               end if;\n+\n+               J := J - 1;\n+            end loop;\n+         end;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out Vector)\n+      is\n+         procedure Sort is\n+            new Generic_Array_Sort\n+             (Index_Type   => Count_Type,\n+              Element_Type => Element_Type,\n+              Array_Type   => Elements_Array,\n+              \"<\"          => \"<\");\n+\n+      begin\n+         if Container.Last <= Index_Type'First then\n+            return;\n+         end if;\n+\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (vector is locked)\";\n+         end if;\n+\n+         Sort (Container.Elements (1 .. Container.Length));\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      return Position.Index <= Position.Container.Last;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      EA         : Elements_Array renames Container.Elements;\n+      Old_Length : constant Count_Type := Container.Length;\n+\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      --  We treat inserting 0 items into the container as a no-op, even when\n+      --  the container is busy, so we simply return.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibilty of overflow.\n+\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n+\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+         end if;\n+\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n+\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is busy)\";\n+      end if;\n+\n+      if New_Length > Container.Capacity then\n+         raise Capacity_Error with \"New length is larger than capacity\";\n+      end if;\n+\n+      J := To_Array_Index (Before);\n+\n+      if Before > Container.Last then\n+         --  The new items are being appended to the vector, so no\n+         --  sliding of existing elements is required.\n+\n+         EA (J .. New_Length) := (others => New_Item);\n+\n+      else\n+         --  The new items are being inserted before some existing\n+         --  elements, so we must slide the existing elements up to their\n+         --  new home.\n+\n+         EA (J + Count .. New_Length) := EA (J .. Old_Length);\n+         EA (J .. J + Count - 1) := (others => New_Item);\n+      end if;\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector)\n+   is\n+      N : constant Count_Type := Length (New_Item);\n+      B : Count_Type;  -- index Before converted to Count_Type\n+\n+   begin\n+      --  Use Insert_Space to create the \"hole\" (the destination slice) into\n+      --  which we copy the source items.\n+\n+      Insert_Space (Container, Before, Count => N);\n+\n+      if N = 0 then\n+         --  There's nothing else to do here (vetting of parameters was\n+         --  performed already in Insert_Space), so we simply return.\n+\n+         return;\n+      end if;\n+\n+      B := To_Array_Index (Before);\n+\n+      if Container'Address /= New_Item'Address then\n+         --  This is the simple case.  New_Item denotes an object different\n+         --  from Container, so there's nothing special we need to do to copy\n+         --  the source items to their destination, because all of the source\n+         --  items are contiguous.\n+\n+         Container.Elements (B .. B + N - 1) := New_Item.Elements (1 .. N);\n+         return;\n+      end if;\n+\n+      --  We refer to array index value Before + N - 1 as J. This is the last\n+      --  index value of the destination slice.\n+\n+      --  New_Item denotes the same object as Container, so an insertion has\n+      --  potentially split the source items. The destination is always the\n+      --  range [Before, J], but the source is [Index_Type'First, Before) and\n+      --  (J, Container.Last]. We perform the copy in two steps, using each of\n+      --  the two slices of the source items.\n+\n+      declare\n+         subtype Src_Index_Subtype is Count_Type'Base range 1 .. B - 1;\n+\n+         Src : Elements_Array renames Container.Elements (Src_Index_Subtype);\n+\n+      begin\n+         --  We first copy the source items that precede the space we\n+         --  inserted. (If Before equals Index_Type'First, then this first\n+         --  source slice will be empty, which is harmless.)\n+\n+         Container.Elements (B .. B + Src'Length - 1) := Src;\n+      end;\n+\n+      declare\n+         subtype Src_Index_Subtype is Count_Type'Base range\n+           B + N .. Container.Length;\n+\n+         Src : Elements_Array renames Container.Elements (Src_Index_Subtype);\n+\n+      begin\n+         --  We next copy the source items that follow the space we inserted.\n+\n+         Container.Elements (B + N - Src'Length .. B + N - 1) := Src;\n+      end;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unchecked_Access\n+      then\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector;\n+      Position  : out Cursor)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unchecked_Access\n+      then\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n+      end if;\n+\n+      if Is_Empty (New_Item) then\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item);\n+\n+      Position := Cursor'(Container'Unchecked_Access, Index);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unchecked_Access\n+      then\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unchecked_Access\n+      then\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n+      end if;\n+\n+      if Count = 0 then\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert (Container, Index, New_Item, Count);\n+\n+      Position := Cursor'(Container'Unchecked_Access, Index);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   ------------------\n+   -- Insert_Space --\n+   ------------------\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      EA         : Elements_Array renames Container.Elements;\n+      Old_Length : constant Count_Type := Container.Length;\n+\n+      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n+      New_Length : Count_Type'Base;  -- sum of current length and Count\n+\n+      Index : Index_Type'Base;  -- scratch for intermediate values\n+      J     : Count_Type'Base;  -- scratch\n+\n+   begin\n+      --  As a precondition on the generic actual Index_Type, the base type\n+      --  must include Index_Type'Pred (Index_Type'First); this is the value\n+      --  that Container.Last assumes when the vector is empty. However, we do\n+      --  not allow that as the value for Index when specifying where the new\n+      --  items should be inserted, so we must manually check. (That the user\n+      --  is allowed to specify the value at all here is a consequence of the\n+      --  declaration of the Extended_Index subtype, which includes the values\n+      --  in the base range that immediately precede and immediately follow the\n+      --  values in the Index_Type.)\n+\n+      if Before < Index_Type'First then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n+      end if;\n+\n+      --  We do allow a value greater than Container.Last to be specified as\n+      --  the Index, but only if it's immediately greater. This allows for the\n+      --  case of appending items to the back end of the vector. (It is assumed\n+      --  that specifying an index value greater than Last + 1 indicates some\n+      --  deeper flaw in the caller's algorithm, so that case is treated as a\n+      --  proper error.)\n+\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n+      then\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n+      end if;\n+\n+      --  We treat inserting 0 items into the container as a no-op, even when\n+      --  the container is busy, so we simply return.\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      --  There are two constraints we need to satisfy. The first constraint is\n+      --  that a container cannot have more than Count_Type'Last elements, so\n+      --  we must check the sum of the current length and the insertion\n+      --  count. Note that we cannot simply add these values, because of the\n+      --  possibilty of overflow.\n+\n+      if Old_Length > Count_Type'Last - Count then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  It is now safe compute the length of the new vector, without fear of\n+      --  overflow.\n+\n+      New_Length := Old_Length + Count;\n+\n+      --  The second constraint is that the new Last index value cannot exceed\n+      --  Index_Type'Last. In each branch below, we calculate the maximum\n+      --  length (computed from the range of values in Index_Type), and then\n+      --  compare the new length to the maximum length. If the new length is\n+      --  acceptable, then we compute the new last index from that.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We have to handle the case when there might be more values in the\n+         --  range of Index_Type than in the range of Count_Type.\n+\n+         if Index_Type'First <= 0 then\n+            --  We know that No_Index (the same as Index_Type'First - 1) is\n+            --  less than 0, so it is safe to compute the following sum without\n+            --  fear of overflow.\n+\n+            Index := No_Index + Index_Type'Base (Count_Type'Last);\n+\n+            if Index <= Index_Type'Last then\n+               --  We have determined that range of Index_Type has at least as\n+               --  many values as in Count_Type, so Count_Type'Last is the\n+               --  maximum number of items that are allowed.\n+\n+               Max_Length := Count_Type'Last;\n+\n+            else\n+               --  The range of Index_Type has fewer values than in Count_Type,\n+               --  so the maximum number of items is computed from the range of\n+               --  the Index_Type.\n+\n+               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+            end if;\n+\n+         else\n+            --  No_Index is equal or greater than 0, so we can safely compute\n+            --  the difference without fear of overflow (which we would have to\n+            --  worry about if No_Index were less than 0, but that case is\n+            --  handled above).\n+\n+            Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  We know that No_Index (the same as Index_Type'First - 1) is less\n+         --  than 0, so it is safe to compute the following sum without fear of\n+         --  overflow.\n+\n+         J := Count_Type'Base (No_Index) + Count_Type'Last;\n+\n+         if J <= Count_Type'Base (Index_Type'Last) then\n+            --  We have determined that range of Index_Type has at least as\n+            --  many values as in Count_Type, so Count_Type'Last is the maximum\n+            --  number of items that are allowed.\n+\n+            Max_Length := Count_Type'Last;\n+\n+         else\n+            --  The range of Index_Type has fewer values than Count_Type does,\n+            --  so the maximum number of items is computed from the range of\n+            --  the Index_Type.\n+\n+            Max_Length :=\n+              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+         end if;\n+\n+      else\n+         --  No_Index is equal or greater than 0, so we can safely compute the\n+         --  difference without fear of overflow (which we would have to worry\n+         --  about if No_Index were less than 0, but that case is handled\n+         --  above).\n+\n+         Max_Length :=\n+           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n+      end if;\n+\n+      --  We have just computed the maximum length (number of items). We must\n+      --  now compare the requested length to the maximum length, as we do not\n+      --  allow a vector expand beyond the maximum (because that would create\n+      --  an internal array with a last index value greater than\n+      --  Index_Type'Last, with no way to index those elements).\n+\n+      if New_Length > Max_Length then\n+         raise Constraint_Error with \"Count is out of range\";\n+      end if;\n+\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is busy)\";\n+      end if;\n+\n+      --  An internal array has already been allocated, so we need to check\n+      --  whether there is enough unused storage for the new items.\n+\n+      if New_Length > Container.Capacity then\n+         raise Capacity_Error with \"New length is larger than capacity\";\n+      end if;\n+\n+      --  In this case, we're inserting space into a vector that has already\n+      --  allocated an internal array, and the existing array has enough\n+      --  unused storage for the new items.\n+\n+      if Before <= Container.Last then\n+         --  The space is being inserted before some existing elements,\n+         --  so we must slide the existing elements up to their new home.\n+\n+         J := To_Array_Index (Before);\n+         EA (J + Count .. New_Length) := EA (J .. Old_Length);\n+      end if;\n+\n+      --  New_Last is the last index value of the items in the container after\n+      --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n+      --  compute its value from the New_Length.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Container.Last := No_Index + Index_Type'Base (New_Length);\n+\n+      else\n+         Container.Last :=\n+           Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n+      end if;\n+   end Insert_Space;\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      Index : Index_Type'Base;\n+\n+   begin\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unchecked_Access\n+      then\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n+      end if;\n+\n+      if Count = 0 then\n+         if Before.Container = null\n+           or else Before.Index > Container.Last\n+         then\n+            Position := No_Element;\n+         else\n+            Position := (Container'Unchecked_Access, Before.Index);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if Before.Container = null\n+        or else Before.Index > Container.Last\n+      then\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n+      else\n+         Index := Before.Index;\n+      end if;\n+\n+      Insert_Space (Container, Index, Count => Count);\n+\n+      Position := Cursor'(Container'Unchecked_Access, Index);\n+   end Insert_Space;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Vector) return Boolean is\n+   begin\n+      return Container.Last < Index_Type'First;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         for Indx in Index_Type'First .. Container.Last loop\n+            Process (Cursor'(Container'Unrestricted_Access, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Vector) return Cursor is\n+   begin\n+      if Is_Empty (Container) then\n+         return No_Element;\n+      end if;\n+\n+      return (Container'Unrestricted_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Vector) return Element_Type is\n+   begin\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Container.Elements (Container.Length);\n+   end Last_Element;\n+\n+   ----------------\n+   -- Last_Index --\n+   ----------------\n+\n+   function Last_Index (Container : Vector) return Extended_Index is\n+   begin\n+      return Container.Last;\n+   end Last_Index;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Vector) return Count_Type is\n+      L : constant Index_Type'Base := Container.Last;\n+      F : constant Index_Type := Index_Type'First;\n+\n+   begin\n+      --  The base range of the index type (Index_Type'Base) might not include\n+      --  all values for length (Count_Type). Contrariwise, the index type\n+      --  might include values outside the range of length.  Hence we use\n+      --  whatever type is wider for intermediate values when calculating\n+      --  length. Note that no matter what the index type is, the maximum\n+      --  length to which a vector is allowed to grow is always the minimum\n+      --  of Count_Type'Last and (IT'Last - IT'First + 1).\n+\n+      --  For example, an Index_Type with range -127 .. 127 is only guaranteed\n+      --  to have a base range of -128 .. 127, but the corresponding vector\n+      --  would have lengths in the range 0 .. 255. In this case we would need\n+      --  to use Count_Type'Base for intermediate values.\n+\n+      --  Another case would be the index range -2**63 + 1 .. -2**63 + 10. The\n+      --  vector would have a maximum length of 10, but the index values lie\n+      --  outside the range of Count_Type (which is only 32 bits). In this\n+      --  case we would need to use Index_Type'Base for intermediate values.\n+\n+      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n+         return Count_Type'Base (L) - Count_Type'Base (F) + 1;\n+      else\n+         return Count_Type (L - F + 1);\n+      end if;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Vector;\n+      Source : in out Vector)\n+   is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error  -- ???\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (Target is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (Source is busy)\";\n+      end if;\n+\n+      --  Clear Target now, in case element assignment fails.\n+      Target.Last := No_Index;\n+\n+      Target.Elements (1 .. Source.Length) :=\n+        Source.Elements (1 .. Source.Length);\n+\n+      Target.Last := Source.Last;\n+      Source.Last := No_Index;\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index < Position.Container.Last then\n+         return (Position.Container, Position.Index + 1);\n+      end if;\n+\n+      return No_Element;\n+   end Next;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      if Position.Container = null then\n+         return;\n+      end if;\n+\n+      if Position.Index < Position.Container.Last then\n+         Position.Index := Position.Index + 1;\n+      else\n+         Position := No_Element;\n+      end if;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n+   begin\n+      Insert (Container, Index_Type'First, New_Item);\n+   end Prepend;\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container,\n+              Index_Type'First,\n+              New_Item,\n+              Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      if Position.Container = null then\n+         return;\n+      end if;\n+\n+      if Position.Index > Index_Type'First then\n+         Position.Index := Position.Index - 1;\n+      else\n+         Position := No_Element;\n+      end if;\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Index > Index_Type'First then\n+         return (Position.Container, Position.Index - 1);\n+      end if;\n+\n+      return No_Element;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : Element_Type))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+      L : Natural renames V.Lock;\n+\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (V.Elements (To_Array_Index (Index)));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n+   end Query_Element;\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      Query_Element (Position.Container.all, Position.Index, Process);\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Vector)\n+   is\n+      Length : Count_Type'Base;\n+      Last   : Index_Type'Base := No_Index;\n+\n+   begin\n+      Clear (Container);\n+\n+      Count_Type'Base'Read (Stream, Length);\n+\n+      Reserve_Capacity (Container, Capacity => Length);\n+\n+      for Idx in Count_Type range 1 .. Length loop\n+         Last := Last + 1;\n+         Element_Type'Read (Stream, Container.Elements (Idx));\n+         Container.Last := Last;\n+      end loop;\n+   end Read;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream vector cursor\";\n+   end Read;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is locked)\";\n+      end if;\n+\n+      Container.Elements (To_Array_Index (Index)) := New_Item;\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is locked)\";\n+      end if;\n+\n+      Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      if Capacity > Container.Capacity then\n+         raise Constraint_Error with \"Capacity is out of range\";\n+      end if;\n+   end Reserve_Capacity;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out Vector) is\n+      E        : Elements_Array renames Container.Elements;\n+      Idx, Jdx : Count_Type;\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is locked)\";\n+      end if;\n+\n+      Idx := 1;\n+      Jdx := Container.Length;\n+      while Idx < Jdx loop\n+         declare\n+            EI : constant Element_Type := E (Idx);\n+\n+         begin\n+            E (Idx) := E (Jdx);\n+            E (Jdx) := EI;\n+         end;\n+\n+         Idx := Idx + 1;\n+         Jdx := Jdx - 1;\n+      end loop;\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Last : Index_Type'Base;\n+\n+   begin\n+      if Position.Container /= null\n+        and then Position.Container /= Container'Unrestricted_Access\n+      then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      Last :=\n+        (if Position.Container = null or else Position.Index > Container.Last\n+         then Container.Last\n+         else Position.Index);\n+\n+      for Indx in reverse Index_Type'First .. Last loop\n+         if Container.Elements (To_Array_Index (Indx)) = Item then\n+            return (Container'Unrestricted_Access, Indx);\n+         end if;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ------------------------\n+   -- Reverse_Find_Index --\n+   ------------------------\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index\n+   is\n+      Last : constant Index_Type'Base :=\n+               Index_Type'Min (Container.Last, Index);\n+\n+   begin\n+      for Indx in reverse Index_Type'First .. Last loop\n+         if Container.Elements (To_Array_Index (Indx)) = Item then\n+            return Indx;\n+         end if;\n+      end loop;\n+\n+      return No_Index;\n+   end Reverse_Find_Index;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         for Indx in reverse Index_Type'First .. Container.Last loop\n+            Process (Cursor'(Container'Unrestricted_Access, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   ----------------\n+   -- Set_Length --\n+   ----------------\n+\n+   procedure Set_Length (Container : in out Vector; Length : Count_Type) is\n+      Count : constant Count_Type'Base := Container.Length - Length;\n+\n+   begin\n+      --  Set_Length allows the user to set the length explicitly, instead of\n+      --  implicitly as a side-effect of deletion or insertion. If the\n+      --  requested length is less then the current length, this is equivalent\n+      --  to deleting items from the back end of the vector. If the requested\n+      --  length is greater than the current length, then this is equivalent to\n+      --  inserting \"space\" (nonce items) at the end.\n+\n+      if Count >= 0 then\n+         Container.Delete_Last (Count);\n+\n+      elsif Container.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n+\n+      else\n+         Container.Insert_Space (Container.Last + 1, -Count);\n+      end if;\n+   end Set_Length;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n+      E : Elements_Array renames Container.Elements;\n+\n+   begin\n+      if I > Container.Last then\n+         raise Constraint_Error with \"I index is out of range\";\n+      end if;\n+\n+      if J > Container.Last then\n+         raise Constraint_Error with \"J index is out of range\";\n+      end if;\n+\n+      if I = J then\n+         return;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is locked)\";\n+      end if;\n+\n+      declare\n+         EI_Copy : constant Element_Type := E (To_Array_Index (I));\n+      begin\n+         E (To_Array_Index (I)) := E (To_Array_Index (J));\n+         E (To_Array_Index (J)) := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor) is\n+   begin\n+      if I.Container = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n+      end if;\n+\n+      if J.Container = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor denotes wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor denotes wrong container\";\n+      end if;\n+\n+      Swap (Container, I.Index, J.Index);\n+   end Swap;\n+\n+   --------------------\n+   -- To_Array_Index --\n+   --------------------\n+\n+   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base is\n+      Offset : Count_Type'Base;\n+\n+   begin\n+      --  We know that\n+      --    Index >= Index_Type'First\n+      --  hence we also know that\n+      --    Index - Index_Type'First >= 0\n+      --\n+      --  The issue is that even though 0 is guaranteed to be a value\n+      --  in the type Index_Type'Base, there's no guarantee that the\n+      --  difference is a value in that type. To prevent overflow we\n+      --  use the wider of Count_Type'Base and Index_Type'Base to\n+      --  perform intermediate calculations.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         Offset := Count_Type'Base (Index - Index_Type'First);\n+\n+      else\n+         Offset := Count_Type'Base (Index) -\n+                     Count_Type'Base (Index_Type'First);\n+      end if;\n+\n+      --  The array index subtype for all container element arrays\n+      --  always starts with 1.\n+\n+      return 1 + Offset;\n+   end To_Array_Index;\n+\n+   ---------------\n+   -- To_Cursor --\n+   ---------------\n+\n+   function To_Cursor\n+     (Container : Vector;\n+      Index     : Extended_Index) return Cursor\n+   is\n+   begin\n+      if Index not in Index_Type'First .. Container.Last then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Index);\n+   end To_Cursor;\n+\n+   --------------\n+   -- To_Index --\n+   --------------\n+\n+   function To_Index (Position : Cursor) return Extended_Index is\n+   begin\n+      if Position.Container = null then\n+         return No_Index;\n+      end if;\n+\n+      if Position.Index <= Position.Container.Last then\n+         return Position.Index;\n+      end if;\n+\n+      return No_Index;\n+   end To_Index;\n+\n+   ---------------\n+   -- To_Vector --\n+   ---------------\n+\n+   function To_Vector (Length : Count_Type) return Vector is\n+      Index : Count_Type'Base;\n+      Last  : Index_Type'Base;\n+\n+   begin\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length, but we do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index).  We must therefore check whether the specified Length would\n+      --  create a Last index value greater than Index_Type'Last.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n+\n+         Last := No_Index + Index_Type'Base (Length);\n+\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of Length.\n+\n+         Index := Count_Type'Base (No_Index) + Length;  -- Last\n+\n+         if Index > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (Index);\n+\n+      else\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n+\n+         if Index < Count_Type'Base (No_Index) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We have determined that the value of Length would not create a\n+         --  Last index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);\n+      end if;\n+\n+      return V : Vector (Capacity => Length) do\n+         V.Last := Last;\n+      end return;\n+   end To_Vector;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Count_Type) return Vector\n+   is\n+      Index : Count_Type'Base;\n+      Last  : Index_Type'Base;\n+\n+   begin\n+      if Length = 0 then\n+         return Empty_Vector;\n+      end if;\n+\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length, but we do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index). We must therefore check whether the specified Length would\n+      --  create a Last index value greater than Index_Type'Last.\n+\n+      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         --  We perform a two-part test. First we determine whether the\n+         --  computed Last value lies in the base range of the type, and then\n+         --  determine whether it lies in the range of the index (sub)type.\n+\n+         --  Last must satisfy this relation:\n+         --    First + Length - 1 <= Last\n+         --  We regroup terms:\n+         --    First - 1 <= Last - Length\n+         --  Which can rewrite as:\n+         --    No_Index <= Last - Length\n+\n+         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We now know that the computed value of Last is within the base\n+         --  range of the type, so it is safe to compute its value:\n+\n+         Last := No_Index + Index_Type'Base (Length);\n+\n+         --  Finally we test whether the value is within the range of the\n+         --  generic actual index subtype:\n+\n+         if Last > Index_Type'Last then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+      elsif Index_Type'First <= 0 then\n+         --  Here we can compute Last directly, in the normal way. We know that\n+         --  No_Index is less than 0, so there is no danger of overflow when\n+         --  adding the (positive) value of Length.\n+\n+         Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last\n+\n+         if Index > Count_Type'Base (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We know that the computed value (having type Count_Type) of Last\n+         --  is within the range of the generic actual index subtype, so it is\n+         --  safe to convert to Index_Type:\n+\n+         Last := Index_Type'Base (Index);\n+\n+      else\n+         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n+         --  must test the length indirectly (by working backwards from the\n+         --  largest possible value of Last), in order to prevent overflow.\n+\n+         Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n+\n+         if Index < Count_Type'Base (No_Index) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+         --  We have determined that the value of Length would not create a\n+         --  Last index value outside of the range of Index_Type, so we can now\n+         --  safely compute its value.\n+\n+         Last := Index_Type'Base (Count_Type'Base (No_Index) + Length);\n+      end if;\n+\n+      return V : Vector (Capacity => Length) do\n+         V.Elements := (others => New_Item);\n+         V.Last := Last;\n+      end return;\n+   end To_Vector;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+      B : Natural renames Container.Busy;\n+      L : Natural renames Container.Lock;\n+\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (Container.Elements (To_Array_Index (Index)));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n+   end Update_Element;\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Vector)\n+   is\n+      N : Count_Type;\n+\n+   begin\n+      N := Container.Length;\n+      Count_Type'Base'Write (Stream, N);\n+\n+      for J in 1 .. N loop\n+         Element_Type'Write (Stream, Container.Elements (J));\n+      end loop;\n+   end Write;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream vector cursor\";\n+   end Write;\n+\n+end Ada.Containers.Bounded_Vectors;"}, {"sha": "30dc9aabfba77ddf401a341abe00624f7793dd96", "filename": "gcc/ada/a-cobove.ads", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-cobove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-cobove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.ads?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -0,0 +1,369 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       A D A . C O N T A I N E R S . B O U N D E D _ V E C T O R S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Streams;\n+\n+generic\n+   type Index_Type is range <>;\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Vectors is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   subtype Extended_Index is Index_Type'Base\n+     range Index_Type'First - 1 ..\n+           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n+\n+   No_Index : constant Extended_Index := Extended_Index'First;\n+\n+   type Vector (Capacity : Count_Type) is tagged private;\n+   pragma Preelaborable_Initialization (Vector);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Vector : constant Vector;\n+\n+   No_Element : constant Cursor;\n+\n+   overriding function \"=\" (Left, Right : Vector) return Boolean;\n+\n+   function To_Vector (Length : Count_Type) return Vector;\n+\n+   function To_Vector\n+     (New_Item : Element_Type;\n+      Length   : Count_Type) return Vector;\n+\n+   function \"&\" (Left, Right : Vector) return Vector;\n+\n+   function \"&\" (Left : Vector; Right : Element_Type) return Vector;\n+\n+   function \"&\" (Left : Element_Type; Right : Vector) return Vector;\n+\n+   function \"&\" (Left, Right : Element_Type) return Vector;\n+\n+   function Capacity (Container : Vector) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Vector;\n+      Capacity  : Count_Type);\n+\n+   function Length (Container : Vector) return Count_Type;\n+\n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Count_Type);\n+\n+   function Is_Empty (Container : Vector) return Boolean;\n+\n+   procedure Clear (Container : in out Vector);\n+\n+   function To_Cursor\n+     (Container : Vector;\n+      Index     : Extended_Index) return Cursor;\n+\n+   function To_Index (Position : Cursor) return Extended_Index;\n+\n+   function Element\n+     (Container : Vector;\n+      Index     : Index_Type) return Element_Type;\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Container : Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : Element_Type));\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Assign (Target : in out Vector; Source : Vector);\n+\n+   function Copy (Source : Vector; Capacity : Count_Type := 0) return Vector;\n+\n+   procedure Move (Target : in out Vector; Source : in out Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Vector;\n+      Position  : out Cursor);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Prepend\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Vector);\n+\n+   procedure Append\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert_Space\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Index     : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out Vector;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out Vector;\n+      Count     : Count_Type := 1);\n+\n+   procedure Reverse_Elements (Container : in out Vector);\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type);\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor);\n+\n+   function First_Index (Container : Vector) return Index_Type;\n+\n+   function First (Container : Vector) return Cursor;\n+\n+   function First_Element (Container : Vector) return Element_Type;\n+\n+   function Last_Index (Container : Vector) return Extended_Index;\n+\n+   function Last (Container : Vector) return Cursor;\n+\n+   function Last_Element (Container : Vector) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index;\n+\n+   function Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find_Index\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index;\n+\n+   function Reverse_Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Contains\n+     (Container : Vector;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Vector;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector);\n+\n+   end Generic_Sorting;\n+\n+private\n+\n+   pragma Inline (First_Index);\n+   pragma Inline (Last_Index);\n+   pragma Inline (Element);\n+   pragma Inline (First_Element);\n+   pragma Inline (Last_Element);\n+   pragma Inline (Query_Element);\n+   pragma Inline (Update_Element);\n+   pragma Inline (Replace_Element);\n+   pragma Inline (Is_Empty);\n+   pragma Inline (Contains);\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Elements_Array is array (Count_Type range <>) of Element_Type;\n+   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n+\n+   type Vector (Capacity : Count_Type) is tagged record\n+      Elements : Elements_Array (1 .. Capacity);\n+      Last     : Extended_Index := No_Index;\n+      Busy     : Natural := 0;\n+      Lock     : Natural := 0;\n+   end record;\n+\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Vector);\n+\n+   for Vector'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Vector);\n+\n+   for Vector'Read use Read;\n+\n+   type Vector_Access is access all Vector;\n+   for Vector_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Vector_Access;\n+      Index     : Index_Type := Index_Type'First;\n+   end record;\n+\n+   procedure Write\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : not null access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   Empty_Vector : constant Vector := (Capacity => 0, others => <>);\n+\n+   No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n+\n+end Ada.Containers.Bounded_Vectors;"}, {"sha": "be8a808747bf67833f5347c39f3a3dc87eb93d2a", "filename": "gcc/ada/a-contai.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-contai.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fa-contai.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-contai.ads?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -19,4 +19,6 @@ package Ada.Containers is\n    type Hash_Type is mod 2**32;\n    type Count_Type is range 0 .. 2**31 - 1;\n \n+   Capacity_Error : exception;\n+\n end Ada.Containers;"}, {"sha": "005a246b93f160bece1921cb5593f64e5b044e8b", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -506,7 +506,8 @@ package body Impunit is\n \n    Non_Imp_File_Names_12 : constant File_List := (\n      \"s-multip\",    -- System.Multiprocessors\n-     \"s-mudido\");   -- System.Multiprocessors.Dispatching_Domains\n+     \"s-mudido\",    -- System.Multiprocessors.Dispatching_Domains\n+     \"a-cobove\");   -- Ada.Containers.Bounded_Vectors\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "ca5ffb4e6949b8ec18a7ab7ed265e2bb7298c702", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -240,7 +240,7 @@ package SCOs is\n    --      expression ::= |sloc term term  (if expr is OR or OR ELSE)\n    --      expression ::= !sloc term       (if expr is NOT)\n \n-   --      In the last four cases, sloc is the source location of the AND, OR,\n+   --      In the last three cases, sloc is the source location of the AND, OR,\n    --      or NOT token, respectively.\n \n    --      term ::= element"}, {"sha": "ed01ac8f387ba714e4e61998d06fdb0b384e0911", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 779, "deletions": 332, "changes": 1111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -77,10 +77,6 @@ package body Sem_Ch13 is\n    --  inherited from a derived type that is no longer appropriate for the\n    --  new Esize value. In this case, we reset the Alignment to unknown.\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n    procedure Build_Predicate_Function\n      (Typ   : Entity_Id;\n       FDecl : out Node_Id;\n@@ -94,6 +90,21 @@ package body Sem_Ch13 is\n    --  and setting Predicate_Procedure for Typ. In some error situations no\n    --  procedure is built, in which case PDecl/PBody are empty on return.\n \n+   procedure Build_Static_Predicate\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id;\n+      Nam  : Name_Id);\n+   --  Given a predicated type Typ, whose predicate expression is Expr, tests\n+   --  if Expr is a static predicate, and if so, builds the predicate range\n+   --  list. Nam is the name of the argument to the predicate function.\n+   --  Occurrences of the type name in the predicate expression have been\n+   --  replaced by identifer references to this name, which is unique, so any\n+   --  identifier with Chars matching Nam must be a reference to the type. If\n+   --  the predicate is non-static, this procedure returns doing nothing. If\n+   --  the predicate is static, then the corresponding predicate list is stored\n+   --  in Static_Predicate (Typ), and the Expr is rewritten as a canonicalized\n+   --  membership operation.\n+\n    function Get_Alignment_Value (Expr : Node_Id) return Uint;\n    --  Given the expression for an alignment value, returns the corresponding\n    --  Uint value. If the value is inappropriate, then error messages are\n@@ -3851,10 +3862,6 @@ package body Sem_Ch13 is\n       --  Inheritance of predicates for the parent type is done by calling the\n       --  Predicate_Function of the parent type, using Add_Call above.\n \n-      procedure Build_Static_Predicate;\n-      --  This function is called to process a static predicate, and put it in\n-      --  canonical form and store it in Static_Predicate (Typ).\n-\n       Object_Name : constant Name_Id := New_Internal_Name ('I');\n       --  Name for argument of Predicate procedure\n \n@@ -4001,455 +4008,895 @@ package body Sem_Ch13 is\n          end loop;\n       end Add_Predicates;\n \n-      ----------------------------\n-      -- Build_Static_Predicate --\n-      ----------------------------\n+   --  Start of processing for Build_Predicate_Function\n \n-      procedure Build_Static_Predicate is\n-         Exp : Node_Id;\n-         Alt : Node_Id;\n+   begin\n+      --  Initialize for construction of statement list\n+\n+      Expr  := Empty;\n+      FDecl := Empty;\n+      FBody := Empty;\n+\n+      --  Return if already built or if type does not have predicates\n+\n+      if not Has_Predicates (Typ)\n+        or else Present (Predicate_Function (Typ))\n+      then\n+         return;\n+      end if;\n+\n+      --  Add Predicates for the current type\n+\n+      Add_Predicates;\n+\n+      --  Add predicates for ancestor if present\n+\n+      declare\n+         Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n+      begin\n+         if Present (Atyp) then\n+            Add_Call (Atyp);\n+         end if;\n+      end;\n+\n+      --  If we have predicates, build the function\n+\n+      if Present (Expr) then\n+\n+         --  Deal with static predicate case\n+\n+         Build_Static_Predicate (Typ, Expr, Object_Name);\n+\n+         --  Build function declaration\n+\n+         pragma Assert (Has_Predicates (Typ));\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+         Set_Has_Predicates (SId);\n+         Set_Predicate_Function (Typ, SId);\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n+                 Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FDecl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Spec);\n+\n+         --  Build function body\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n \n-         Non_Static : Boolean := False;\n-         --  Set True if something non-static is found\n+         FBody :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression => Expr))));\n+      end if;\n+   end Build_Predicate_Function;\n \n-         Plist : List_Id := No_List;\n-         --  The entries in Plist are either static expressions which represent\n-         --  a possible value, or ranges of values. Subtype marks don't appear,\n-         --  since we expand them out.\n+   ----------------------------\n+   -- Build_Static_Predicate --\n+   ----------------------------\n+\n+   procedure Build_Static_Predicate\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id;\n+      Nam  : Name_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n \n+      Non_Static : exception;\n+      --  Raised if something non-static is found\n+\n+      TLo, THi : Uint;\n+      --  Low bound and high bound values of static subtype of Typ\n+\n+      type REnt is record\n          Lo, Hi : Uint;\n-         --  Low bound and high bound values of static subtype of Typ\n+      end record;\n+      --  One entry in a Rlist value, a single REnt (range entry) value\n+      --  denotes one range from Lo to Hi. To represent a single value\n+      --  range Lo = Hi = value.\n+\n+      type RList is array (Nat range <>) of REnt;\n+      --  A list of ranges. The ranges are sorted in increasing order,\n+      --  and are disjoint (there is a gap of at least one value between\n+      --  each range in the table).\n+\n+      Null_Range : constant RList := RList'(1 .. 0 => REnt'(No_Uint, No_Uint));\n+      True_Range : RList renames Null_Range;\n+      --  Constant representing null list of ranges, used to represent a\n+      --  predicate of True, since there are no ranges to be satisfied.\n+\n+      False_Range : constant RList := RList'(1 => REnt'(Uint_1, Uint_0));\n+      --  Range representing false\n+\n+      function \"and\" (Left, Right : RList) return RList;\n+      --  And's together two range lists, returning a range list. This is\n+      --  a set intersection operation.\n+\n+      function \"or\" (Left, Right : RList) return RList;\n+      --  Or's together two range lists, returning a range list. This is a\n+      --  set union operation.\n+\n+      function \"not\" (Right : RList) return RList;\n+      --  Returns complement of a given range list, i.e. a range list\n+      --  representing all the values in TLo .. THi that are not in the\n+      --  input operand Right.\n+\n+      function Build_Val (V : Uint) return Node_Id;\n+      --  Return an analyzed N_Identifier node referencing this value, suitable\n+      --  for use as an entry in the Static_Predicate list.\n+\n+      function Build_Range (Lo, Hi : Uint) return Node_Id;\n+      --  Return an analyzed N_Range node referencing this range, suitable\n+      --  for use as an entry in the Static_Predicate list.\n+\n+      function Get_RList (Exp : Node_Id) return RList;\n+      --  This is a recursive routine that converts the given expression into\n+      --  a list of ranges, suitable for use in building the static predicate.\n+\n+      function Is_Type_Ref (N : Node_Id) return Boolean;\n+      pragma Inline (Is_Type_Ref);\n+      --  Returns if True if N is a reference to the type for the predicate in\n+      --  the expression (i.e. if it is an identifier whose Chars field matches\n+      --  the Nam given in the call).\n+\n+      function Lo_Val (N : Node_Id) return Uint;\n+      --  Given static expression or static range from a Static_Predicate list,\n+      --  gets expression value or low bound of range.\n+\n+      function Hi_Val (N : Node_Id) return Uint;\n+      --  Given static expression or static range from a Static_Predicate list,\n+      --  gets expression value of high bound of range.\n+\n+      function Membership_Entry (N : Node_Id) return RList;\n+      --  Given a single membership entry (range, value, or subtype), returns\n+      --  the corresponding range list. Raises Static_Error if not static.\n+\n+      function Membership_Entries (N : Node_Id) return RList;\n+      --  Given an element on an alternatives list of a membership operation,\n+      --  returns the range list corresponding to this entry and all following\n+      --  entries (i.e. returns the \"or\" of this list of values).\n+\n+      function Stat_Pred (Typ : Entity_Id) return RList;\n+      --  Given a type, if it has a static predicate, then return the predicate\n+      --  as a range list, otherwise raise Non_Static.\n+\n+      -----------\n+      -- \"and\" --\n+      -----------\n+\n+      function \"and\" (Left, Right : RList) return RList is\n+         FEnt : REnt;\n+         --  First range of result\n+\n+         SLeft : Nat := Left'First;\n+         --  Start of rest of left entries\n+\n+         SRight : Nat := Right'First;\n+         --  Start of rest of right entries\n \n-         procedure Process_Entry (N : Node_Id);\n-         --  Process one entry (range or value or subtype mark)\n+      begin\n+         --  If either range is True, return the other\n \n-         -------------------\n-         -- Process_Entry --\n-         -------------------\n+         if Left = True_Range then\n+            return Right;\n+         elsif Right = True_Range then\n+            return Left;\n+         end if;\n \n-         procedure Process_Entry (N : Node_Id) is\n-            SLo, SHi : Uint;\n-            --  Low and high bounds of range in list\n+         --  If either range is False, return False\n \n-            P : Node_Id;\n+         if Left = False_Range or else Right = False_Range then\n+            return False_Range;\n+         end if;\n \n-            function Build_Val (V : Uint) return Node_Id;\n-            --  Return an analyzed N_Identifier node referencing this value\n+         --  If either range is empty, return False\n \n-            function Build_Range (Lo, Hi : Uint) return Node_Id;\n-            --  Return an analyzed N_Range node referencing this range\n+         if Left'Length = 0 or else Right'Length = 0 then\n+            return False_Range;\n+         end if;\n \n-            function Lo_Val (N : Node_Id) return Uint;\n-            --  Given static expression or static range, gets expression value\n-            --  or low bound of range.\n+         --  Loop to remove entries at start that are disjoint, and thus\n+         --  just get discarded from the result entirely.\n \n-            function Hi_Val (N : Node_Id) return Uint;\n-            --  Given static expression or static range, gets expression value\n-            --  of high bound of range.\n+         loop\n+            --  If no operands left in either operand, result is false\n \n-            -----------------\n-            -- Build_Range --\n-            -----------------\n+            if SLeft > Left'Last or else SRight > Right'Last then\n+               return False_Range;\n \n-            function Build_Range (Lo, Hi : Uint) return Node_Id is\n-               Result : Node_Id;\n-            begin\n-               if Lo = Hi then\n-                  return Build_Val (Hi);\n-               else\n-                  Result :=\n-                    Make_Range (Sloc (N),\n-                      Low_Bound  => Build_Val (Lo),\n-                      High_Bound => Build_Val (Hi));\n-                  Set_Etype (Result, Typ);\n-                  Set_Analyzed (Result);\n-                  return Result;\n-               end if;\n-            end Build_Range;\n+            --  Discard first left operand entry if disjoint with right\n \n-            ---------------\n-            -- Build_Val --\n-            ---------------\n+            elsif Left (SLeft).Hi < Right (SRight).Lo then\n+               SLeft := SLeft + 1;\n \n-            function Build_Val (V : Uint) return Node_Id is\n-               Result : Node_Id;\n+            --  Discard first right operand entry if disjoint with left\n \n-            begin\n-               if Is_Enumeration_Type (Typ) then\n-                  Result := Get_Enum_Lit_From_Pos (Typ, V, Sloc (N));\n-               else\n-                  Result := Make_Integer_Literal (Sloc (N), Intval => V);\n-               end if;\n+            elsif Right (SRight).Hi < Left (SLeft).Lo then\n+               SRight := SRight + 1;\n \n-               Set_Etype (Result, Typ);\n-               Set_Is_Static_Expression (Result);\n-               Set_Analyzed (Result);\n-               return Result;\n-            end Build_Val;\n+            --  Otherwise we have an overlapping entry\n \n-            ------------\n-            -- Hi_Val --\n-            ------------\n+            else\n+               exit;\n+            end if;\n+         end loop;\n \n-            function Hi_Val (N : Node_Id) return Uint is\n-            begin\n-               if Is_Static_Expression (N) then\n-                  return Expr_Value (N);\n-               else\n-                  pragma Assert (Nkind (N) = N_Range);\n-                  return Expr_Value (High_Bound (N));\n-               end if;\n-            end Hi_Val;\n+         --  Now we have two non-null operands, and first entries overlap.\n+         --  The first entry in the result will be the overlapping part of\n+         --  these two entries.\n \n-            ------------\n-            -- Lo_Val --\n-            ------------\n+         FEnt := REnt'(Lo => UI_Max (Left (SLeft).Lo, Right (SRight).Lo),\n+                       Hi => UI_Min (Left (SLeft).Hi, Right (SRight).Hi));\n \n-            function Lo_Val (N : Node_Id) return Uint is\n-            begin\n-               if Is_Static_Expression (N) then\n-                  return Expr_Value (N);\n-               else\n-                  pragma Assert (Nkind (N) = N_Range);\n-                  return Expr_Value (Low_Bound (N));\n-               end if;\n-            end Lo_Val;\n+         --  Now we can remove the entry that ended at a lower value, since\n+         --  its contribution is entirely contained in Fent.\n+\n+         if Left (SLeft).Hi <= Right (SRight).Hi then\n+            SLeft := SLeft + 1;\n+         else\n+            SRight := SRight + 1;\n+         end if;\n+\n+         --  If either operand is empty, that's the only entry\n+\n+         if SLeft > Left'Last or else SRight > Right'Last then\n+            return RList'(1 => FEnt);\n+\n+         --  Else compute and of remaining entries and concatenate\n+\n+         else\n+            return\n+              FEnt &\n+                (Left (SLeft .. Left'Last) and Right (SRight .. Right'Last));\n+         end if;\n+      end \"and\";\n+\n+      -----------\n+      -- \"not\" --\n+      -----------\n+\n+      function \"not\" (Right : RList) return RList is\n+      begin\n+         --  Return True if False range\n+\n+         if Right = False_Range then\n+            return True_Range;\n+         end if;\n+\n+         --  Return False if True range\n \n-         --  Start of processing for Process_Entry\n+         if Right'Length = 0 then\n+            return False_Range;\n+         end if;\n+\n+         --  Here if not trivial case\n+\n+         declare\n+            Result : RList (1 .. Right'Length + 1);\n+            --  May need one more entry for gap at beginning and end\n+\n+            Count : Nat := 0;\n+            --  Number of entries stored in Result\n \n          begin\n-            --  Range case\n+            --  Gap at start\n \n-            if Nkind (N) = N_Range then\n-               if not Is_Static_Expression (Low_Bound (N))\n-                    or else\n-                  not Is_Static_Expression (High_Bound (N))\n+            if Right (Right'First).Lo > TLo then\n+               Count := Count + 1;\n+               Result (Count) := REnt'(TLo, Right (Right'First).Lo - 1);\n+            end if;\n+\n+            --  Gaps between ranges\n+\n+            for J in Right'First .. Right'Last - 1 loop\n+               Count := Count + 1;\n+               Result (Count) :=\n+                 REnt'(Right (J).Hi + 1, Right (J + 1).Lo - 1);\n+            end loop;\n+\n+            --  Gap at end\n+\n+            if Right (Right'Last).Hi < THi then\n+               Count := Count + 1;\n+               Result (Count) := REnt'(Right (Right'Last).Hi + 1, THi);\n+            end if;\n+\n+            return Result (1 .. Count);\n+         end;\n+      end \"not\";\n+\n+      ----------\n+      -- \"or\" --\n+      ----------\n+\n+      function \"or\" (Left, Right : RList) return RList is\n+      begin\n+         --  If either range is True, return True\n+\n+         if Left = True_Range or else Right = True_Range then\n+            return True_Range;\n+         end if;\n+\n+         --  If either range is False, return the other\n+\n+         if Left = False_Range then\n+            return Right;\n+         elsif Right = False_Range then\n+            return Left;\n+         end if;\n+\n+         --  If either operand is null, return the other one\n+\n+         if Left'Length = 0 then\n+            return Right;\n+         elsif Right'Length = 0 then\n+            return Left;\n+         end if;\n+\n+         --  Now we have two non-null ranges\n+\n+         declare\n+            FEnt : REnt;\n+            --  First range of result\n+\n+            SLeft : Nat := Left'First;\n+            --  Start of rest of left entries\n+\n+            SRight : Nat := Right'First;\n+            --  Start of rest of right entries\n+\n+         begin\n+            --  Initialize result first entry from left or right operand\n+            --  depending on which starts with the lower range.\n+\n+            if Left (SLeft).Lo < Right (SRight).Lo then\n+               FEnt := Left (SLeft);\n+               SLeft := SLeft + 1;\n+            else\n+               FEnt := Right (SRight);\n+               SRight := SRight + 1;\n+            end if;\n+\n+            --  This loop eats ranges from left and right operands that\n+            --  are contiguous with the first range we are gathering.\n+\n+            loop\n+               --  Eat first entry in left operand if contiguous or\n+               --  overlapped by gathered first operand of result.\n+\n+               if SLeft <= Left'Last\n+                 and then Left (SLeft).Lo <= FEnt.Hi + 1\n                then\n-                  Non_Static := True;\n-                  return;\n+                  FEnt.Hi := UI_Max (FEnt.Hi, Left (SLeft).Hi);\n+                  SLeft := SLeft + 1;\n+\n+               --  Eat first entry in right operand if contiguous or\n+               --  overlapped by gathered right operand of result.\n+\n+               elsif SRight <= Right'Last\n+                 and then Right (SRight).Lo <= FEnt.Hi + 1\n+               then\n+                  FEnt.Hi := UI_Max (FEnt.Hi, Right (SRight).Hi);\n+                  SRight := SRight + 1;\n+\n+               --  All done if no more entries to eat!\n+\n                else\n-                  SLo := Lo_Val (N);\n-                  SHi := Hi_Val (N);\n+                  exit;\n                end if;\n+            end loop;\n \n-            --  Static expression case\n+            --  If left operand now empty, concatenate our new entry to right\n \n-            elsif Is_Static_Expression (N) then\n-               SLo := Lo_Val (N);\n-               SHi := Hi_Val (N);\n+            if SLeft > Left'Last then\n+               return FEnt & Right (SRight .. Right'Last);\n \n-            --  Identifier (other than static expression) case\n+            --  If right operand now empty, concatenate our new entry to left\n \n-            else pragma Assert (Nkind (N) = N_Identifier);\n+            elsif SRight > Right'Last then\n+               return FEnt & Left (SLeft .. Left'Last);\n \n-               --  Type case\n+            --  Otherwise, compute or of what is left and concatenate\n \n-               if Is_Type (Entity (N)) then\n+            else\n+               return\n+                 FEnt &\n+                  (Left (SLeft .. Left'Last) or Right (SRight .. Right'Last));\n+            end if;\n+         end;\n+      end \"or\";\n \n-                  --  If type has static predicates, process them recursively\n+      -----------------\n+      -- Build_Range --\n+      -----------------\n \n-                  if Present (Static_Predicate (Entity (N))) then\n-                     P := First (Static_Predicate (Entity (N)));\n-                     while Present (P) loop\n-                        Process_Entry (P);\n+      function Build_Range (Lo, Hi : Uint) return Node_Id is\n+         Result : Node_Id;\n+      begin\n+         if Lo = Hi then\n+            return Build_Val (Hi);\n+         else\n+            Result :=\n+              Make_Range (Loc,\n+                Low_Bound  => Build_Val (Lo),\n+                High_Bound => Build_Val (Hi));\n+            Set_Etype (Result, Typ);\n+            Set_Analyzed (Result);\n+            return Result;\n+         end if;\n+      end Build_Range;\n \n-                        if Non_Static then\n-                           return;\n-                        else\n-                           Next (P);\n-                        end if;\n-                     end loop;\n+      ---------------\n+      -- Build_Val --\n+      ---------------\n \n-                     return;\n+      function Build_Val (V : Uint) return Node_Id is\n+         Result : Node_Id;\n \n-                  --  For static subtype without predicates, get range\n+      begin\n+         if Is_Enumeration_Type (Typ) then\n+            Result := Get_Enum_Lit_From_Pos (Typ, V, Loc);\n+         else\n+            Result := Make_Integer_Literal (Loc, Intval => V);\n+         end if;\n \n-                  elsif Is_Static_Subtype (Entity (N))\n-                    and then not Has_Predicates (Entity (N))\n-                  then\n-                     SLo := Expr_Value (Type_Low_Bound  (Entity (N)));\n-                     SHi := Expr_Value (Type_High_Bound (Entity (N)));\n+         Set_Etype (Result, Typ);\n+         Set_Is_Static_Expression (Result);\n+         Set_Analyzed (Result);\n+         return Result;\n+      end Build_Val;\n \n-                  --  Any other type makes us non-static\n+      ---------------\n+      -- Get_RList --\n+      ---------------\n \n-                  else\n-                     Non_Static := True;\n-                     return;\n-                  end if;\n+      function Get_RList (Exp : Node_Id) return RList is\n+         Op  : Node_Kind;\n+         Val : Uint;\n+\n+      begin\n+         --  Static expression can only be true or false\n+\n+         if Is_OK_Static_Expression (Exp) then\n+\n+            --  For False, return impossible range, which will always fail\n+\n+            if Expr_Value (Exp) = 0 then\n+               return False_Range;\n+\n+            --  For True, null range\n+\n+            else\n+               return Null_Range;\n+            end if;\n+         end if;\n+\n+         --  Otherwise test node type\n+\n+         Op := Nkind (Exp);\n+\n+         case Op is\n+\n+            --  And\n+\n+            when N_Op_And | N_And_Then =>\n+               return Get_RList (Left_Opnd (Exp))\n+                        and\n+                      Get_RList (Right_Opnd (Exp));\n+\n+            --  Or\n+\n+            when N_Op_Or | N_Or_Else =>\n+               return Get_RList (Left_Opnd (Exp))\n+                        or\n+                      Get_RList (Right_Opnd (Exp));\n+\n+            --  Not\n+\n+            when N_Op_Not =>\n+               return not Get_RList (Right_Opnd (Exp));\n+\n+            --  Comparisons of type with static value\n+\n+            when N_Op_Compare =>\n+               --  Type is left operand\n+\n+               if Is_Type_Ref (Left_Opnd (Exp))\n+                 and then Is_OK_Static_Expression (Right_Opnd (Exp))\n+               then\n+                  Val := Expr_Value (Right_Opnd (Exp));\n \n-               --  Any other kind of identifier in predicate (e.g. a non-static\n-               --  expression value) means this is not a static predicate.\n+                  --  Typ is right operand\n+\n+               elsif Is_Type_Ref (Right_Opnd (Exp))\n+                 and then Is_OK_Static_Expression (Left_Opnd (Exp))\n+               then\n+                  Val := Expr_Value (Left_Opnd (Exp));\n+\n+                  --  Invert sense of comparison\n+\n+                  case Op is\n+                     when N_Op_Gt => Op := N_Op_Lt;\n+                     when N_Op_Lt => Op := N_Op_Gt;\n+                     when N_Op_Ge => Op := N_Op_Le;\n+                     when N_Op_Le => Op := N_Op_Ge;\n+                     when others  => null;\n+                  end case;\n+\n+                  --  Other cases are non-static\n \n                else\n-                  Non_Static := True;\n-                  return;\n+                  raise Non_Static;\n                end if;\n-            end if;\n \n-            --  Here with SLo and SHi set for (possibly single element) range\n-            --  of entry to insert in Plist. Non-static if out of range.\n+               --  Construct range according to comparison operation\n \n-            if SLo < Lo or else SHi > Hi then\n-               Non_Static := True;\n-               return;\n-            end if;\n+               case Op is\n+                  when N_Op_Eq =>\n+                     return RList'(1 => REnt'(Val, Val));\n \n-            --  If no Plist currently, create it\n+                  when N_Op_Ge =>\n+                     return RList'(1 => REnt'(Val, THi));\n \n-            if No (Plist) then\n-               Plist := New_List (Build_Range (SLo, SHi));\n-               return;\n+                  when N_Op_Gt =>\n+                     return RList'(1 => REnt'(Val + 1, THi));\n \n-            --  Otherwise search Plist for insertion point\n+                  when N_Op_Le =>\n+                     return RList'(1 => REnt'(TLo, Val));\n \n-            else\n-               P := First (Plist);\n-               loop\n-                  --  Case of inserting before current entry\n+                  when N_Op_Lt =>\n+                     return RList'(1 => REnt'(TLo, Val - 1));\n \n-                  if SHi < Lo_Val (P) - 1 then\n-                     Insert_Before (P, Build_Range (SLo, SHi));\n-                     exit;\n+                  when N_Op_Ne =>\n+                     return RList'(REnt'(TLo, Val - 1),\n+                                   REnt'(Val + 1, THi));\n \n-                  --  Case of belongs past current entry\n+                  when others  =>\n+                     raise Program_Error;\n+               end case;\n \n-                  elsif SLo > Hi_Val (P) + 1 then\n+            --  Membership (IN)\n \n-                     --  End of list case\n+            when N_In =>\n+               if not Is_Type_Ref (Left_Opnd (Exp)) then\n+                  raise Non_Static;\n+               end if;\n \n-                     if No (Next (P)) then\n-                        Append_To (Plist, Build_Range (SLo, SHi));\n-                        exit;\n+               if Present (Right_Opnd (Exp)) then\n+                  return Membership_Entry (Right_Opnd (Exp));\n+               else\n+                  return Membership_Entries (First (Alternatives (Exp)));\n+               end if;\n \n-                     --  Else just move to next item on list\n+            --  Negative membership (NOT IN)\n \n-                     else\n-                        Next (P);\n+            when N_Not_In =>\n+               if not Is_Type_Ref (Left_Opnd (Exp)) then\n+                  raise Non_Static;\n+               end if;\n+\n+               if Present (Right_Opnd (Exp)) then\n+                  return not Membership_Entry (Right_Opnd (Exp));\n+               else\n+                  return not Membership_Entries (First (Alternatives (Exp)));\n+               end if;\n+\n+            --  Function call, may be call to static predicate\n+\n+            when N_Function_Call =>\n+               if Is_Entity_Name (Name (Exp)) then\n+                  declare\n+                     Ent : constant Entity_Id := Entity (Name (Exp));\n+                  begin\n+                     if Has_Predicates (Ent) then\n+                        return Stat_Pred (Etype (First_Formal (Ent)));\n                      end if;\n+                  end;\n+               end if;\n \n-                  --  Case of extending current entyr, and in overlap cases\n-                  --  may also eat up entries past this one.\n+               --  Other function call cases are non-static\n \n-                  else\n-                     declare\n-                        New_Lo : constant Uint := UI_Min (Lo_Val (P), SLo);\n-                        New_Hi : Uint          := UI_Max (Hi_Val (P), SHi);\n+               raise Non_Static;\n \n-                     begin\n-                        --  See if there are entries past us that we eat up\n+            --  Qualified expression, dig out the expression\n \n-                        while Present (Next (P))\n-                          and then Lo_Val (Next (P)) <= New_Hi + 1\n-                        loop\n-                           New_Hi := Hi_Val (Next (P));\n-                           Remove (Next (P));\n-                        end loop;\n+            when N_Qualified_Expression =>\n+               return Get_RList (Expression (Exp));\n \n-                        --  We now need to replace the current node P with\n-                        --  a new entry New_Lo .. New_Hi.\n+            --  Any other node type is non-static\n \n-                        Insert_After (P, Build_Range (New_Lo, New_Hi));\n-                        Remove (P);\n-                        exit;\n-                     end;\n-                  end if;\n-               end loop;\n-            end if;\n-         end Process_Entry;\n+            when others =>\n+               raise Non_Static;\n+         end case;\n+      end Get_RList;\n \n-      --  Start of processing for Build_Static_Predicate\n+      ------------\n+      -- Hi_Val --\n+      ------------\n \n+      function Hi_Val (N : Node_Id) return Uint is\n       begin\n-         --  Immediately non-static if our subtype is non static, or we\n-         --  do not have an appropriate discrete subtype in the first place.\n-\n-         if not Ekind_In (Typ, E_Enumeration_Subtype,\n-                               E_Modular_Integer_Subtype,\n-                               E_Signed_Integer_Subtype)\n-           or else not Is_Static_Subtype (Typ)\n-         then\n-            return;\n+         if Is_Static_Expression (N) then\n+            return Expr_Value (N);\n+         else\n+            pragma Assert (Nkind (N) = N_Range);\n+            return Expr_Value (High_Bound (N));\n          end if;\n+      end Hi_Val;\n \n-         Lo := Expr_Value (Type_Low_Bound  (Typ));\n-         Hi := Expr_Value (Type_High_Bound (Typ));\n-\n-         --  Check if we have membership predicate\n+      -----------------\n+      -- Is_Type_Ref --\n+      -----------------\n \n-         if Nkind (Expr) = N_In then\n-            Exp := Expr;\n+      function Is_Type_Ref (N : Node_Id) return Boolean is\n+      begin\n+         return Nkind (N) = N_Identifier and then Chars (N) = Nam;\n+      end Is_Type_Ref;\n \n-         --  Allow qualified expression with membership predicate inside\n+      ------------\n+      -- Lo_Val --\n+      ------------\n \n-         elsif Nkind (Expr) = N_Qualified_Expression\n-           and then Nkind (Expression (Expr)) = N_In\n-         then\n-            Exp := Expression (Expr);\n+      function Lo_Val (N : Node_Id) return Uint is\n+      begin\n+         if Is_Static_Expression (N) then\n+            return Expr_Value (N);\n+         else\n+            pragma Assert (Nkind (N) = N_Range);\n+            return Expr_Value (Low_Bound (N));\n+         end if;\n+      end Lo_Val;\n \n-         --  Anything else cannot be a static predicate\n+      ------------------------\n+      -- Membership_Entries --\n+      ------------------------\n \n+      function Membership_Entries (N : Node_Id) return RList is\n+      begin\n+         if No (Next (N)) then\n+            return Membership_Entry (N);\n          else\n-            return;\n+            return Membership_Entry (N) or Membership_Entries (Next (N));\n          end if;\n+      end Membership_Entries;\n \n-         --  We have a membership operation, so we have a potentially static\n-         --  predicate, collect and canonicalize the entries in the list.\n+      ----------------------\n+      -- Membership_Entry --\n+      ----------------------\n \n-         if Present (Right_Opnd (Exp)) then\n-            Process_Entry (Right_Opnd (Exp));\n+      function Membership_Entry (N : Node_Id) return RList is\n+         Val : Uint;\n+         SLo : Uint;\n+         SHi : Uint;\n \n-            if Non_Static then\n-               return;\n+      begin\n+         --  Range case\n+\n+         if Nkind (N) = N_Range then\n+            if not Is_Static_Expression (Low_Bound (N))\n+                 or else\n+               not Is_Static_Expression (High_Bound (N))\n+            then\n+               raise Non_Static;\n+            else\n+               SLo := Expr_Value (Low_Bound  (N));\n+               SHi := Expr_Value (High_Bound (N));\n+               return RList'(1 => REnt'(SLo, SHi));\n             end if;\n \n-         else\n-            Alt := First (Alternatives (Exp));\n-            while Present (Alt) loop\n-               Process_Entry (Alt);\n+         --  Static expression case\n \n-               if Non_Static then\n-                  return;\n-               end if;\n+         elsif Is_Static_Expression (N) then\n+            Val := Expr_Value (N);\n+            return RList'(1 => REnt'(Val, Val));\n \n-               Next (Alt);\n-            end loop;\n-         end if;\n+         --  Identifier (other than static expression) case\n \n-         --  Processing was successful and all entries were static, so\n-         --  now we can store the result as the predicate list.\n+         else pragma Assert (Nkind (N) = N_Identifier);\n \n-         Set_Static_Predicate (Typ, Plist);\n+            --  Type case\n \n-         --  The processing for static predicates coalesced ranges and also\n-         --  eliminated duplicates. We might as well replace the alternatives\n-         --  list of the right operand of the membership test with the static\n-         --  predicate list, which will be more efficient.\n+            if Is_Type (Entity (N)) then\n \n-         declare\n-            New_Alts : constant List_Id := New_List;\n-            Old_Node : Node_Id;\n-            New_Node : Node_Id;\n+               --  If type has predicates, process them\n \n-         begin\n-            Old_Node := First (Plist);\n-            while Present (Old_Node) loop\n-               New_Node := New_Copy (Old_Node);\n+               if Has_Predicates (Entity (N)) then\n+                  return Stat_Pred (Entity (N));\n \n-               if Nkind (New_Node) = N_Range then\n-                  Set_Low_Bound  (New_Node, New_Copy (Low_Bound  (Old_Node)));\n-                  Set_High_Bound (New_Node, New_Copy (High_Bound (Old_Node)));\n-               end if;\n+               --  For static subtype without predicates, get range\n \n-               Append_To (New_Alts, New_Node);\n-               Next (Old_Node);\n-            end loop;\n+               elsif Is_Static_Subtype (Entity (N)) then\n+                  SLo := Expr_Value (Type_Low_Bound  (Entity (N)));\n+                  SHi := Expr_Value (Type_High_Bound (Entity (N)));\n+                  return RList'(1 => REnt'(SLo, SHi));\n+\n+               --  Any other type makes us non-static\n \n-            --  Now update the membership test node\n+               else\n+                  raise Non_Static;\n+               end if;\n \n-            pragma Assert (Nkind (Expr) = N_In);\n+            --  Any other kind of identifier in predicate (e.g. a non-static\n+            --  expression value) means this is not a static predicate.\n \n-            if List_Length (New_Alts) = 1 then\n-               Set_Right_Opnd   (Expr, First (New_Alts));\n-               Set_Alternatives (Expr, No_List);\n             else\n-               Set_Alternatives (Expr, New_Alts);\n-               Set_Right_Opnd   (Expr, Empty);\n+               raise Non_Static;\n             end if;\n-         end;\n-      end Build_Static_Predicate;\n+         end if;\n+      end Membership_Entry;\n \n-   --  Start of processing for Build_Predicate_Function\n+      ---------------\n+      -- Stat_Pred --\n+      ---------------\n \n-   begin\n-      --  Initialize for construction of statement list\n+      function Stat_Pred (Typ : Entity_Id) return RList is\n+      begin\n+         --  Not static if type does not have static predicates\n \n-      Expr  := Empty;\n-      FDecl := Empty;\n-      FBody := Empty;\n+         if not Has_Predicates (Typ)\n+           or else No (Static_Predicate (Typ))\n+         then\n+            raise Non_Static;\n+         end if;\n \n-      --  Return if already built or if type does not have predicates\n+         --  Otherwise we convert the predicate list to a range list\n \n-      if not Has_Predicates (Typ)\n-        or else Present (Predicate_Function (Typ))\n+         declare\n+            Result : RList (1 .. List_Length (Static_Predicate (Typ)));\n+            P      : Node_Id;\n+\n+         begin\n+            P := First (Static_Predicate (Typ));\n+            for J in Result'Range loop\n+               Result (J) := REnt'(Lo_Val (P), Hi_Val (P));\n+               Next (P);\n+            end loop;\n+\n+            return Result;\n+         end;\n+      end Stat_Pred;\n+\n+   --  Start of processing for Build_Static_Predicate\n+\n+   begin\n+      --  Immediately non-static if our subtype is non static, or we\n+      --  do not have an appropriate discrete subtype in the first place.\n+\n+      if not Ekind_In (Typ, E_Enumeration_Subtype,\n+                            E_Modular_Integer_Subtype,\n+                            E_Signed_Integer_Subtype)\n+        or else not Is_Static_Subtype (Typ)\n       then\n          return;\n       end if;\n \n-      --  Add Predicates for the current type\n+      --  Get bounds of the type\n \n-      Add_Predicates;\n+      TLo := Expr_Value (Type_Low_Bound  (Typ));\n+      THi := Expr_Value (Type_High_Bound (Typ));\n \n-      --  Add predicates for ancestor if present\n+      --  Now analyze the expression to see if it is a static predicate\n \n       declare\n-         Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n+         Ranges : constant RList := Get_RList (Expr);\n+         --  Range list from expression if it is static\n+\n+         Plist : List_Id;\n+\n       begin\n-         if Present (Atyp) then\n-            Add_Call (Atyp);\n-         end if;\n-      end;\n+         --  Convert range list into a form for the static predicate. In the\n+         --  Ranges array, we just have raw ranges, these must be converted\n+         --  to properly typed and analyzed static expressions or range nodes.\n \n-      --  If we have predicates, build the function\n+         Plist := New_List;\n \n-      if Present (Expr) then\n+         for J in Ranges'Range loop\n+            declare\n+               Lo : constant Uint := Ranges (J).Lo;\n+               Hi : constant Uint := Ranges (J).Hi;\n \n-         --  Deal with static predicate case\n+            begin\n+               if Lo = Hi then\n+                  Append_To (Plist, Build_Val (Lo));\n+               else\n+                  Append_To (Plist, Build_Range (Lo, Hi));\n+               end if;\n+            end;\n+         end loop;\n \n-         Build_Static_Predicate;\n+         --  Processing was successful and all entries were static, so now we\n+         --  can store the result as the predicate list.\n \n-         --  Build function declaration\n+         Set_Static_Predicate (Typ, Plist);\n \n-         pragma Assert (Has_Predicates (Typ));\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-         Set_Has_Predicates (SId);\n-         Set_Predicate_Function (Typ, SId);\n+         --  The processing for static predicates put the expression into\n+         --  canonical form as a series of ranges. It also eliminated\n+         --  duplicates and collapsed and combined ranges. We might as well\n+         --  replace the alternatives list of the right operand of the\n+         --  membership test with the static predicate list, which will\n+         --  usually be more efficient.\n \n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n-                 Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n+         declare\n+            New_Alts : constant List_Id := New_List;\n+            Old_Node : Node_Id;\n+            New_Node : Node_Id;\n \n-         FDecl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Spec);\n+         begin\n+            Old_Node := First (Plist);\n+            while Present (Old_Node) loop\n+               New_Node := New_Copy (Old_Node);\n \n-         --  Build function body\n+               if Nkind (New_Node) = N_Range then\n+                  Set_Low_Bound  (New_Node, New_Copy (Low_Bound  (Old_Node)));\n+                  Set_High_Bound (New_Node, New_Copy (High_Bound (Old_Node)));\n+               end if;\n \n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+               Append_To (New_Alts, New_Node);\n+               Next (Old_Node);\n+            end loop;\n \n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n-                 Parameter_Type =>\n-                   New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n+            --  If empty list, replace by True\n \n-         FBody :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Spec,\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression => Expr))));\n-      end if;\n-   end Build_Predicate_Function;\n+            if Is_Empty_List (New_Alts) then\n+               Rewrite (Expr, New_Occurrence_Of (Standard_True, Loc));\n+\n+            --  If singleton list, replace by simple membership test\n+\n+            elsif List_Length (New_Alts) = 1 then\n+               Rewrite (Expr,\n+                 Make_In (Loc,\n+                   Left_Opnd    => Make_Identifier (Loc, Nam),\n+                   Right_Opnd   => Relocate_Node (First (New_Alts)),\n+                   Alternatives => No_List));\n+\n+            --  If more than one range, replace by set membership test\n+\n+            else\n+               Rewrite (Expr,\n+                 Make_In (Loc,\n+                   Left_Opnd    => Make_Identifier (Loc, Nam),\n+                   Right_Opnd   => Empty,\n+                   Alternatives => New_Alts));\n+            end if;\n+         end;\n+      end;\n+\n+   --  If non-static, return doing nothing\n+\n+   exception\n+      when Non_Static =>\n+         return;\n+   end Build_Static_Predicate;\n \n    -----------------------------------\n    -- Check_Constant_Address_Clause --"}, {"sha": "b009852bc057d1410a384de6463eef96b7b8f18d", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -662,6 +662,7 @@ package body Sem_Ch5 is\n       --  checks have been applied.\n \n       Note_Possible_Modification (Lhs, Sure => True);\n+      Check_Order_Dependence;\n \n       --  ??? a real accessibility check is needed when ???\n "}, {"sha": "f6a0db97e385f7a0f5c38af67efdc95728d17422", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -811,9 +811,8 @@ package body Sem_Ch6 is\n          end if;\n \n          --  Apply checks suggested by AI05-0144 (dangerous order dependence)\n-         --  (Disabled for now)\n \n-         --  Check_Order_Dependence;\n+         Check_Order_Dependence;\n       end if;\n    end Analyze_Function_Return;\n \n@@ -1116,9 +1115,9 @@ package body Sem_Ch6 is\n             Analyze_Call (N);\n             Resolve (N, Standard_Void_Type);\n \n-            --  Apply checks suggested by AI05-0144 (Disabled for now)\n+            --  Apply checks suggested by AI05-0144\n \n-            --  Check_Order_Dependence;\n+            Check_Order_Dependence;\n \n          else\n             Analyze (N);"}, {"sha": "e92477ea30be5315cd95cb6049d1f07c9a45e9fd", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -2744,6 +2744,18 @@ package body Sem_Res is\n             return;\n          end if;\n \n+         --  AI05-144-2: Check dangerous order dependence within an expression\n+         --  that is not a subexpression. Exclude RHS of an assignment, because\n+         --  both sides may have side-effects and the check must be performed\n+         --  over the statement.\n+\n+         if Nkind (Parent (N)) not in N_Subexpr\n+           and then Nkind (Parent (N)) /= N_Assignment_Statement\n+           and then Nkind (Parent (N)) /= N_Procedure_Call_Statement\n+         then\n+            Check_Order_Dependence;\n+         end if;\n+\n          --  The expression is definitely NOT overloaded at this point, so\n          --  we reset the Is_Overloaded flag to avoid any confusion when\n          --  reanalyzing the node.\n@@ -3529,12 +3541,10 @@ package body Sem_Res is\n             A_Typ := Etype (A);\n             F_Typ := Etype (F);\n \n-            --  Save actual for subsequent check on order dependence,\n-            --  and indicate whether actual is modifiable. For AI05-0144\n+            --  Save actual for subsequent check on order dependence, and\n+            --  indicate whether actual is modifiable. For AI05-0144-2.\n \n-            --  Save_Actual (A,\n-            --    Ekind (F) /= E_In_Parameter or else Is_Access_Type (F_Typ));\n-            --  Why is this code commented out ???\n+            Save_Actual (A, Ekind (F) /= E_In_Parameter);\n \n             --  For mode IN, if actual is an entity, and the type of the formal\n             --  has warnings suppressed, then we reset Never_Set_In_Source for\n@@ -8228,11 +8238,8 @@ package body Sem_Res is\n       R     : constant Node_Id   := Right_Opnd (N);\n \n    begin\n-      --  Why are the calls to Check_Order_Dependence commented out ???\n       Resolve (L, B_Typ);\n-      --  Check_Order_Dependence;   --  For AI05-0144\n       Resolve (R, B_Typ);\n-      --  Check_Order_Dependence;   --  For AI05-0144\n \n       --  Check for issuing warning for always False assert/check, this happens\n       --  when assertions are turned off, in which case the pragma Assert/Check"}, {"sha": "7aca62590334a66c82a070ddd6aded3bdc51d487", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 100, "deletions": 31, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -101,12 +101,12 @@ package body Sem_Util is\n    --  whether the corresponding formal is OUT or IN OUT. Each top-level call\n    --  (procedure call, condition, assignment) examines all the actuals for a\n    --  possible order dependence. The table is reset after each such check.\n+   --  The actuals to be checked in a call to Check_Order_Dependence are at\n+   --  positions 1 .. Last.\n \n    type Actual_Name is record\n       Act         : Node_Id;\n       Is_Writable : Boolean;\n-      --  Comments needed???\n-\n    end record;\n \n    package Actuals_In_Call is new Table.Table (\n@@ -1222,17 +1222,25 @@ package body Sem_Util is\n       Act2 : Node_Id;\n \n    begin\n-      --  This could use comments ???\n+      if Ada_Version < Ada_2012 then\n+         return;\n+      end if;\n \n-      for J in 0 .. Actuals_In_Call.Last loop\n+      --  Ada2012 AI04-0144-2 : dangerous order dependence.\n+      --  Actuals in nested calls within a construct have been collected.\n+      --  If one of them is writeable and overlaps with another one, evaluation\n+      --  of the enclosing construct is non-deterministic.\n+      --  This is illegal in Ada2012, but is treated as a warning for now.\n+\n+      for J in 1 .. Actuals_In_Call.Last loop\n          if Actuals_In_Call.Table (J).Is_Writable then\n             Act1 := Actuals_In_Call.Table (J).Act;\n \n             if Nkind (Act1) = N_Attribute_Reference then\n                Act1 := Prefix (Act1);\n             end if;\n \n-            for K in 0 .. Actuals_In_Call.Last loop\n+            for K in 1 .. Actuals_In_Call.Last loop\n                if K /= J then\n                   Act2 := Actuals_In_Call.Table (K).Act;\n \n@@ -1248,15 +1256,19 @@ package body Sem_Util is\n                      null;\n \n                   elsif Denotes_Same_Object (Act1, Act2)\n-                    and then False\n+                    and then Parent (Act1) /= Parent (Act2)\n                   then\n-                     Error_Msg_N (\"?,mighty suspicious!!!\", Act1);\n+                     Error_Msg_N (\n+                       \"result may differ if evaluated \"\n+                        & \" after other actual in expression?\", Act1);\n                   end if;\n                end if;\n             end loop;\n          end if;\n       end loop;\n \n+      --  Remove checked actuals from table.\n+\n       Actuals_In_Call.Set_Last (0);\n    end Check_Order_Dependence;\n \n@@ -2350,49 +2362,105 @@ package body Sem_Util is\n    -------------------------\n \n    function Denotes_Same_Object (A1, A2 : Node_Id) return Boolean is\n+      Obj1 : Node_Id := A1;\n+      Obj2 : Node_Id := A2;\n+\n+      procedure Check_Renaming (Obj : in out Node_Id);\n+      --  If an object is a renaming, examine renamed object. If is is a\n+      --  dereference of a variable, or an indexed expression with non-\n+      --  constant indices, no overlap check can be reported.\n+\n+      procedure Check_Renaming (Obj : in out Node_Id) is\n+      begin\n+         if Is_Entity_Name (Obj)\n+           and then Present (Renamed_Entity (Entity (Obj)))\n+         then\n+            Obj := Renamed_Entity (Entity (Obj));\n+            if Nkind (Obj) = N_Explicit_Dereference\n+              and then Is_Variable (Prefix (Obj))\n+            then\n+               Obj := Empty;\n+\n+            elsif Nkind (Obj) = N_Indexed_Component then\n+               declare\n+                  Indx : Node_Id;\n+\n+               begin\n+                  Indx := First (Expressions (Obj));\n+                  while Present (Indx) loop\n+                     if not Is_OK_Static_Expression (Indx) then\n+                        Obj := Empty;\n+                        exit;\n+                     end if;\n+\n+                     Next_Index (Indx);\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+      end Check_Renaming;\n+\n    begin\n+      Check_Renaming (Obj1);\n+      Check_Renaming (Obj2);\n+\n+      if No (Obj1)\n+        or else No (Obj2)\n+      then\n+         return False;\n+      end if;\n+\n       --  If we have entity names, then must be same entity\n \n-      if Is_Entity_Name (A1) then\n-         if Is_Entity_Name (A2) then\n-            return Entity (A1) = Entity (A2);\n+      if Is_Entity_Name (Obj1) then\n+         if Is_Entity_Name (Obj2) then\n+            return Entity (Obj1) = Entity (Obj2);\n          else\n             return False;\n          end if;\n \n       --  No match if not same node kind\n \n-      elsif Nkind (A1) /= Nkind (A2) then\n+      elsif Nkind (Obj1) /= Nkind (Obj2) then\n          return False;\n \n       --  For selected components, must have same prefix and selector\n \n-      elsif Nkind (A1) = N_Selected_Component then\n-         return Denotes_Same_Object (Prefix (A1), Prefix (A2))\n+      elsif Nkind (Obj1) = N_Selected_Component then\n+         return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n            and then\n-         Entity (Selector_Name (A1)) = Entity (Selector_Name (A2));\n+         Entity (Selector_Name (Obj1)) = Entity (Selector_Name (Obj2));\n \n       --  For explicit dereferences, prefixes must be same\n \n-      elsif Nkind (A1) = N_Explicit_Dereference then\n-         return Denotes_Same_Object (Prefix (A1), Prefix (A2));\n+      elsif Nkind (Obj1) = N_Explicit_Dereference then\n+         return Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2));\n \n       --  For indexed components, prefixes and all subscripts must be the same\n \n-      elsif Nkind (A1) = N_Indexed_Component then\n-         if Denotes_Same_Object (Prefix (A1), Prefix (A2)) then\n+      elsif Nkind (Obj1) = N_Indexed_Component then\n+         if Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2)) then\n             declare\n                Indx1 : Node_Id;\n                Indx2 : Node_Id;\n \n             begin\n-               Indx1 := First (Expressions (A1));\n-               Indx2 := First (Expressions (A2));\n+               Indx1 := First (Expressions (Obj1));\n+               Indx2 := First (Expressions (Obj2));\n                while Present (Indx1) loop\n \n-                  --  Shouldn't we be checking that values are the same???\n+                  --  Indices must denote the same static value or the same\n+                  --  object.\n+\n+                  if Is_OK_Static_Expression (Indx1) then\n+                     if not Is_OK_Static_Expression (Indx2) then\n+                        return False;\n \n-                  if not Denotes_Same_Object (Indx1, Indx2) then\n+                     elsif Expr_Value (Indx1) /= Expr_Value (Indx2) then\n+                        return False;\n+                     end if;\n+\n+                  elsif not Denotes_Same_Object (Indx1, Indx2) then\n                      return False;\n                   end if;\n \n@@ -2408,30 +2476,28 @@ package body Sem_Util is\n \n       --  For slices, prefixes must match and bounds must match\n \n-      elsif Nkind (A1) = N_Slice\n-        and then Denotes_Same_Object (Prefix (A1), Prefix (A2))\n+      elsif Nkind (Obj1) = N_Slice\n+        and then Denotes_Same_Object (Prefix (Obj1), Prefix (Obj2))\n       then\n          declare\n             Lo1, Lo2, Hi1, Hi2 : Node_Id;\n \n          begin\n-            Get_Index_Bounds (Etype (A1), Lo1, Hi1);\n-            Get_Index_Bounds (Etype (A2), Lo2, Hi2);\n+            Get_Index_Bounds (Etype (Obj1), Lo1, Hi1);\n+            Get_Index_Bounds (Etype (Obj2), Lo2, Hi2);\n \n             --  Check whether bounds are statically identical. There is no\n             --  attempt to detect partial overlap of slices.\n \n-            --  What about an array and a slice of an array???\n-\n             return Denotes_Same_Object (Lo1, Lo2)\n               and then Denotes_Same_Object (Hi1, Hi2);\n          end;\n \n          --  Literals will appear as indexes. Isn't this where we should check\n          --  Known_At_Compile_Time at least if we are generating warnings ???\n \n-      elsif Nkind (A1) = N_Integer_Literal then\n-         return Intval (A1) = Intval (A2);\n+      elsif Nkind (Obj1) = N_Integer_Literal then\n+         return Intval (Obj1) = Intval (Obj2);\n \n       else\n          return False;\n@@ -10696,7 +10762,10 @@ package body Sem_Util is\n \n    procedure Save_Actual (N : Node_Id;  Writable : Boolean := False) is\n    begin\n-      if Is_Entity_Name (N)\n+      if Ada_Version < Ada_2012 then\n+         return;\n+\n+      elsif Is_Entity_Name (N)\n         or else\n           Nkind_In (N, N_Indexed_Component, N_Selected_Component, N_Slice)\n         or else"}, {"sha": "da24d8919dce5b28538dfad16059f67c5616179b", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -3708,7 +3708,7 @@ package body Sem_Warn is\n       Form1 := First_Formal (Subp);\n       Act1  := First_Actual (N);\n       while Present (Form1) and then Present (Act1) loop\n-         if Ekind (Form1) = E_In_Out_Parameter then\n+         if Ekind (Form1) /= E_In_Parameter then\n             Form2 := First_Formal (Subp);\n             Act2  := First_Actual (N);\n             while Present (Form2) and then Present (Act2) loop\n@@ -3739,11 +3739,11 @@ package body Sem_Warn is\n                   elsif Nkind (Act2) = N_Function_Call then\n                      null;\n \n-                  --  If either type is elementary the aliasing is harmless.\n+                  --  If type is not by-copy we can assume that  the aliasing\n+                  --  is intended.\n \n-                  elsif Is_Elementary_Type (Underlying_Type (Etype (Form1)))\n-                          or else\n-                        Is_Elementary_Type (Underlying_Type (Etype (Form2)))\n+                  elsif\n+                    Is_By_Reference_Type (Underlying_Type (Etype (Form1)))\n                   then\n                      null;\n \n@@ -3762,11 +3762,21 @@ package body Sem_Warn is\n                            Next_Actual (Act);\n                         end loop;\n \n+                        if Is_Elementary_Type (Etype (Act1))\n+                          and then Ekind (Form2) = E_In_Parameter\n+                        then\n+                           null;  --  no real aliasing.\n+\n+                        elsif Is_Elementary_Type (Etype (Act2))\n+                          and then Ekind (Form2) = E_In_Parameter\n+                        then\n+                           null;  --  ditto\n+\n                         --  If the call was written in prefix notation, and\n                         --  thus its prefix before rewriting was a selected\n                         --  component, count only visible actuals in the call.\n \n-                        if Is_Entity_Name (First_Actual (N))\n+                        elsif Is_Entity_Name (First_Actual (N))\n                           and then Nkind (Original_Node (N)) = Nkind (N)\n                           and then Nkind (Name (Original_Node (N))) =\n                                                          N_Selected_Component"}, {"sha": "9628867ae0ca58f60132b39601f268880ae8389c", "filename": "gcc/ada/uname.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Funame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e194575d06f78b82061218f6405c5e8a21ce085/gcc%2Fada%2Funame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.adb?ref=1e194575d06f78b82061218f6405c5e8a21ce085", "patch": "@@ -225,10 +225,10 @@ package body Uname is\n          Kind : constant Node_Kind := Nkind (Node);\n \n       begin\n-         --  Bail out on error node (guard against parse error)\n+         --  Just ignore an error node (someone else will give a message)\n \n          if Node = Error then\n-            raise Program_Error;\n+            return;\n \n          --  Otherwise see what kind of node we have\n "}]}