{"sha": "20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBmYjUyYWY5MzU5Y2RmNjZlMjQ1ZjE3NzliYmNkNmYxYTQxZGU4Yg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-06-19T18:32:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-06-19T18:32:20Z"}, "message": "tree-ssa-loop-niter.c (implies_ge_p): New function.\n\n\t* tree-ssa-loop-niter.c (implies_ge_p): New function.\n\t(derive_constant_upper_bound): Handle OP0 - CST in unsigned types\n\tcorrectly.\n\nFrom-SVN: r114782", "tree": {"sha": "a31ea250ca70dd8f95b546f2b0488936821de9da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a31ea250ca70dd8f95b546f2b0488936821de9da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20fb52af9359cdf66e245f1779bbcd6f1a41de8b/comments", "author": null, "committer": null, "parents": [{"sha": "dfa52cf9d1c5d14a6a8f905bcf84565ae7b0627c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa52cf9d1c5d14a6a8f905bcf84565ae7b0627c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa52cf9d1c5d14a6a8f905bcf84565ae7b0627c"}], "stats": {"total": 49, "additions": 47, "deletions": 2}, "files": [{"sha": "3cca1ab9c3c5591c7478bdd85dfbddac31aa3d6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fb52af9359cdf66e245f1779bbcd6f1a41de8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fb52af9359cdf66e245f1779bbcd6f1a41de8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "patch": "@@ -1,3 +1,9 @@\n+2006-06-19  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (implies_ge_p): New function.\n+\t(derive_constant_upper_bound): Handle OP0 - CST in unsigned types\n+\tcorrectly.\n+\n 2006-06-19  Denis Chertykov  <denisc@overta.ru>\n \n \t* config/avr/libgcc.S : Correct my wrong previous commit."}, {"sha": "a896d03274180f655c49abc7d352cea8d89fbd51", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fb52af9359cdf66e245f1779bbcd6f1a41de8b/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fb52af9359cdf66e245f1779bbcd6f1a41de8b/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=20fb52af9359cdf66e245f1779bbcd6f1a41de8b", "patch": "@@ -1491,6 +1491,24 @@ implies_nonnegative_p (tree cond, tree val)\n   return nonzero_p (compare);\n }\n \n+/* Returns true if we can prove that COND ==> A >= B.  */\n+\n+static bool\n+implies_ge_p (tree cond, tree a, tree b)\n+{\n+  tree compare = fold_build2 (GE_EXPR, boolean_type_node, a, b);\n+\n+  if (nonzero_p (compare))\n+    return true;\n+\n+  if (nonzero_p (cond))\n+    return false;\n+\n+  compare = tree_simplify_using_condition_1 (cond, compare);\n+\n+  return nonzero_p (compare);\n+}\n+\n /* Returns a constant upper bound on the value of expression VAL.  VAL\n    is considered to be unsigned.  If its type is signed, its value must\n    be nonnegative.\n@@ -1554,8 +1572,11 @@ derive_constant_upper_bound (tree val, tree additional)\n \t  || !implies_nonnegative_p (additional, op0))\n \treturn max;\n \n-      /* Canonicalize to OP0 - CST.  */\n+      /* Canonicalize to OP0 - CST.  Consider CST to be signed, in order to\n+\t choose the most logical way how to treat this constant regardless\n+\t of the signedness of the type.  */\n       cst = tree_to_double_int (op1);\n+      cst = double_int_sext (cst, TYPE_PRECISION (type));\n       if (TREE_CODE (val) == PLUS_EXPR)\n \tcst = double_int_neg (cst);\n \n@@ -1568,7 +1589,7 @@ derive_constant_upper_bound (tree val, tree additional)\n \t  if (double_int_negative_p (cst))\n \t    return max;;\n \n-\t  /* Case OP0 + CST.  We need to check that\n+\t  /* OP0 + CST.  We need to check that\n \t     BND <= MAX (type) - CST.  */\n \n \t  mmax = double_int_add (max, double_int_neg (cst));\n@@ -1579,9 +1600,27 @@ derive_constant_upper_bound (tree val, tree additional)\n \t}\n       else\n \t{\n+\t  /* OP0 - CST, where CST >= 0.\n+\n+\t     If TYPE is signed, we have already verified that OP0 >= 0, and we\n+\t     know that the result is nonnegative.  This implies that\n+\t     VAL <= BND - CST.\n+\n+\t     If TYPE is unsigned, we must additionally know that OP0 >= CST,\n+\t     otherwise the operation underflows.\n+\t   */\n+\n+\t  /* This should only happen if the type is unsigned; however, for\n+\t     programs that use overflowing signed arithmetics even with\n+\t     -fno-wrapv, this condition may also be true for signed values.  */\n \t  if (double_int_ucmp (bnd, cst) < 0)\n \t    return max;\n \n+\t  if (TYPE_UNSIGNED (type)\n+\t      && !implies_ge_p (additional,\n+\t\t\t\top0, double_int_to_tree (type, cst)))\n+\t    return max;\n+\n \t  bnd = double_int_add (bnd, double_int_neg (cst));\n \t}\n "}]}