{"sha": "7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjYzNlYjllNmM2MWEzZjE0MDhhNTVlMjJlZWZhNWZkM2QwOGU3OQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2014-01-23T09:13:08Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2014-01-23T09:13:08Z"}, "message": "PR preprocessor/58580 - preprocessor goes OOM with warning for zero literals\n\nIn this problem report, the compiler is fed a (bogus) translation unit\nin which some literals contain bytes whose value is zero.  The\npreprocessor detects that and proceeds to emit diagnostics for that\nking of bogus literals.  But then when the diagnostics machinery\nre-reads the input file again to display the bogus literals with a\ncaret, it attempts to calculate the length of each of the lines it got\nusing fgets.  The line length calculation is done using strlen.  But\nthat doesn't work well when the content of the line can have several\nzero bytes.  The result is that the read_line never sees the end of\nthe line because strlen repeatedly reports that the line ends before\nthe end-of-line character; so read_line thinks its buffer for reading\nthe line is too small; it thus increases the buffer, leading to a huge\nmemory consumption and disaster.\n\nHere is what this patch does.\n\nlocation_get_source_line is modified to return the length of a source\nline that can now contain bytes with zero value.\ndiagnostic_show_locus() is then modified to consider that a line can\nhave characters of value zero, and so just shows a white space when\ninstructed to display one of these characters.\n\nAdditionally location_get_source_line is modified to avoid re-reading\neach and every line from the beginning of the file until it reaches\nthe line number N that it is instructed to get; this was leading to\nannoying quadratic behaviour when reading adjacent lines near the end\nof (big) files.  So a cache is now associated to the file opened in\ntext mode.  When the content of the file is read, that content is\nstashed in the file cache.  That file cache is searched for line\ndelimiters.  A number of line positions are saved in the cache and a\nnumber of file caches are kept in memory.  That way when\nlocation_get_source_line is asked to read line N + 1, it just has to\nstart reading from line N that it has already read.\n\nlibcpp/ChangeLog:\n\n\t* include/line-map.h (linemap_get_file_highest_location): Declare\n\tnew function.\n\t* line-map.c (linemap_get_file_highest_location): Define it.\n\ngcc/ChangeLog:\n\n\t* input.h (location_get_source_line): Take an additional line_size\n\tparameter.\n\t(void diagnostics_file_cache_fini): Declare new function.\n\t* input.c (struct fcache): New type.\n\t(fcache_tab_size, fcache_buffer_size, fcache_line_record_size):\n\tNew static constants.\n\t(diagnostic_file_cache_init, total_lines_num)\n\t(lookup_file_in_cache_tab, evicted_cache_tab_entry)\n\t(add_file_to_cache_tab, lookup_or_add_file_to_cache_tab)\n\t(needs_read, needs_grow, maybe_grow, read_data, maybe_read_data)\n\t(get_next_line, read_next_line, goto_next_line, read_line_num):\n\tNew static function definitions.\n\t(diagnostic_file_cache_fini): New function.\n\t(location_get_source_line): Take an additional output line_len\n\tparameter.  Re-write using lookup_or_add_file_to_cache_tab and\n\tread_line_num.\n\t* diagnostic.c (diagnostic_finish): Call\n\tdiagnostic_file_cache_fini.\n\t(adjust_line): Take an additional input parameter for the length\n\tof the line, rather than calculating it with strlen.\n\t(diagnostic_show_locus): Adjust the use of\n\tlocation_get_source_line and adjust_line with respect to their new\n\tsignature.  While displaying a line now, do not stop at the first\n\tnull byte.  Rather, display the zero byte as a space and keep\n\tgoing until we reach the size of the line.\n\t* Makefile.in: Add vec.o to OBJS-libcommon\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/cpp/warning-zero-in-literals-1.c: New test file.\n\nSigned-off-by: Dodji Seketeli <dodji@seketeli.org>\n\nFrom-SVN: r206957", "tree": {"sha": "a52b9945d8fde28d7ed83dbdff9f6abfe49d325b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a52b9945d8fde28d7ed83dbdff9f6abfe49d325b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/comments", "author": null, "committer": null, "parents": [{"sha": "70473c6346babec51a0c488cb6e6d4e0a8194ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70473c6346babec51a0c488cb6e6d4e0a8194ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70473c6346babec51a0c488cb6e6d4e0a8194ac0"}], "stats": {"total": 751, "additions": 712, "deletions": 39}, "files": [{"sha": "7663546adec2846eae1fa81b8d7b7536ab4c2ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -1,3 +1,33 @@\n+2014-01-23  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/58580\n+\t* input.h (location_get_source_line): Take an additional line_size\n+\tparameter.\n+\t(void diagnostics_file_cache_fini): Declare new function.\n+\t* input.c (struct fcache): New type.\n+\t(fcache_tab_size, fcache_buffer_size, fcache_line_record_size):\n+\tNew static constants.\n+\t(diagnostic_file_cache_init, total_lines_num)\n+\t(lookup_file_in_cache_tab, evicted_cache_tab_entry)\n+\t(add_file_to_cache_tab, lookup_or_add_file_to_cache_tab)\n+\t(needs_read, needs_grow, maybe_grow, read_data, maybe_read_data)\n+\t(get_next_line, read_next_line, goto_next_line, read_line_num):\n+\tNew static function definitions.\n+\t(diagnostic_file_cache_fini): New function.\n+\t(location_get_source_line): Take an additional output line_len\n+\tparameter.  Re-write using lookup_or_add_file_to_cache_tab and\n+\tread_line_num.\n+\t* diagnostic.c (diagnostic_finish): Call\n+\tdiagnostic_file_cache_fini.\n+\t(adjust_line): Take an additional input parameter for the length\n+\tof the line, rather than calculating it with strlen.\n+\t(diagnostic_show_locus): Adjust the use of\n+\tlocation_get_source_line and adjust_line with respect to their new\n+\tsignature.  While displaying a line now, do not stop at the first\n+\tnull byte.  Rather, display the zero byte as a space and keep\n+\tgoing until we reach the size of the line.\n+\t* Makefile.in: Add vec.o to OBJS-libcommon\n+\n 2014-01-23  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/avx512fintrin.h (_mm512_loadu_si512): Rename."}, {"sha": "d491fcf8b215ce003ae13a03ce1832ecd42c2725", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -1471,7 +1471,8 @@ OBJS = \\\n \n # Objects in libcommon.a, potentially used by all host binaries and with\n # no target dependencies.\n-OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o input.o version.o\n+OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o \\\n+\tvec.o  input.o version.o\n \n # Objects in libcommon-target.a, used by drivers and by the core\n # compiler and containing target-dependent code."}, {"sha": "0cc75934da0dd801218a37351a9a303ef6dbf278", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -176,6 +176,8 @@ diagnostic_finish (diagnostic_context *context)\n \t\t     progname);\n       pp_newline_and_flush (context->printer);\n     }\n+\n+  diagnostic_file_cache_fini ();\n }\n \n /* Initialize DIAGNOSTIC, where the message MSG has already been\n@@ -259,12 +261,13 @@ diagnostic_build_prefix (diagnostic_context *context,\n    MAX_WIDTH by some margin, then adjust the start of the line such\n    that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n    margin is either 10 characters or the difference between the column\n-   and the length of the line, whatever is smaller.  */\n+   and the length of the line, whatever is smaller.  The length of\n+   LINE is given by LINE_WIDTH.  */\n static const char *\n-adjust_line (const char *line, int max_width, int *column_p)\n+adjust_line (const char *line, int line_width,\n+\t     int max_width, int *column_p)\n {\n   int right_margin = 10;\n-  int line_width = strlen (line);\n   int column = *column_p;\n \n   right_margin = MIN (line_width - column, right_margin);\n@@ -284,6 +287,7 @@ diagnostic_show_locus (diagnostic_context * context,\n \t\t       const diagnostic_info *diagnostic)\n {\n   const char *line;\n+  int line_width;\n   char *buffer;\n   expanded_location s;\n   int max_width;\n@@ -297,22 +301,25 @@ diagnostic_show_locus (diagnostic_context * context,\n \n   context->last_location = diagnostic->location;\n   s = expand_location_to_spelling_point (diagnostic->location);\n-  line = location_get_source_line (s);\n+  line = location_get_source_line (s, &line_width);\n   if (line == NULL)\n     return;\n \n   max_width = context->caret_max_width;\n-  line = adjust_line (line, max_width, &(s.column));\n+  line = adjust_line (line, line_width, max_width, &(s.column));\n \n   pp_newline (context->printer);\n   saved_prefix = pp_get_prefix (context->printer);\n   pp_set_prefix (context->printer, NULL);\n   pp_space (context->printer);\n-  while (max_width > 0 && *line != '\\0')\n+  while (max_width > 0 && line_width > 0)\n     {\n       char c = *line == '\\t' ? ' ' : *line;\n+      if (c == '\\0')\n+\tc = ' ';\n       pp_character (context->printer, c);\n       max_width--;\n+      line_width--;\n       line++;\n     }\n   pp_newline (context->printer);"}, {"sha": "6122938ea6f6fb63fb7a8fac9195cab7a8cf7fa0", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -291,6 +291,7 @@ void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n void diagnostic_set_caret_max_width (diagnostic_context *context, int value);\n \n+void diagnostic_file_cache_fini (void);\n \n /* Pure text formatting support functions.  */\n extern char *file_name_as_prefix (diagnostic_context *, const char *);"}, {"sha": "290680c1e5acf1ef48b78699d12ba3d9d3acae5c", "filename": "gcc/input.c", "status": "modified", "additions": 602, "deletions": 31, "changes": 633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -22,13 +22,98 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"intl.h\"\n #include \"input.h\"\n+#include \"vec.h\"\n+\n+/* This is a cache used by get_next_line to store the content of a\n+   file to be searched for file lines.  */\n+struct fcache\n+{\n+  /* These are information used to store a line boundary.  */\n+  struct line_info\n+  {\n+    /* The line number.  It starts from 1.  */\n+    size_t line_num;\n+\n+    /* The position (byte count) of the beginning of the line,\n+       relative to the file data pointer.  This starts at zero.  */\n+    size_t start_pos;\n+\n+    /* The position (byte count) of the last byte of the line.  This\n+       normally points to the '\\n' character, or to one byte after the\n+       last byte of the file, if the file doesn't contain a '\\n'\n+       character.  */\n+    size_t end_pos;\n+\n+    line_info (size_t l, size_t s, size_t e)\n+      : line_num (l), start_pos (s), end_pos (e)\n+    {}\n+\n+    line_info ()\n+      :line_num (0), start_pos (0), end_pos (0)\n+    {}\n+  };\n+\n+  /* The number of time this file has been accessed.  This is used\n+     to designate which file cache to evict from the cache\n+     array.  */\n+  unsigned use_count;\n+\n+  const char *file_path;\n+\n+  FILE *fp;\n+\n+  /* This points to the content of the file that we've read so\n+     far.  */\n+  char *data;\n+\n+  /*  The size of the DATA array above.*/\n+  size_t size;\n+\n+  /* The number of bytes read from the underlying file so far.  This\n+     must be less (or equal) than SIZE above.  */\n+  size_t nb_read;\n+\n+  /* The index of the beginning of the current line.  */\n+  size_t line_start_idx;\n+\n+  /* The number of the previous line read.  This starts at 1.  Zero\n+     means we've read no line so far.  */\n+  size_t line_num;\n+\n+  /* This is the total number of lines of the current file.  At the\n+     moment, we try to get this information from the line map\n+     subsystem.  Note that this is just a hint.  When using the C++\n+     front-end, this hint is correct because the input file is then\n+     completely tokenized before parsing starts; so the line map knows\n+     the number of lines before compilation really starts.  For e.g,\n+     the C front-end, it can happen that we start emitting diagnostics\n+     before the line map has seen the end of the file.  */\n+  size_t total_lines;\n+\n+  /* This is a record of the beginning and end of the lines we've seen\n+     while reading the file.  This is useful to avoid walking the data\n+     from the beginning when we are asked to read a line that is\n+     before LINE_START_IDX above.  Note that the maximum size of this\n+     record is fcache_line_record_size, so that the memory consumption\n+     doesn't explode.  We thus scale total_lines down to\n+     fcache_line_record_size.  */\n+  vec<line_info, va_heap> line_record;\n+\n+  fcache ();\n+  ~fcache ();\n+};\n \n /* Current position in real source file.  */\n \n location_t input_location;\n \n struct line_maps *line_table;\n \n+static fcache *fcache_tab;\n+static const size_t fcache_tab_size = 16;\n+static const size_t fcache_buffer_size = 4 * 1024;\n+static const size_t fcache_line_record_size = 100;\n+\n /* Expand the source location LOC into a human readable location.  If\n    LOC resolves to a builtin location, the file name of the readable\n    location is set to the string \"<built-in>\". If EXPANSION_POINT_P is\n@@ -87,56 +172,542 @@ expand_location_1 (source_location loc,\n   return xloc;\n }\n \n-/* Reads one line from file into a static buffer.  */\n-static const char *\n-read_line (FILE *file)\n+/* Initialize the set of cache used for files accessed by caret\n+   diagnostic.  */\n+\n+static void\n+diagnostic_file_cache_init (void)\n {\n-  static char *string;\n-  static size_t string_len;\n-  size_t pos = 0;\n-  char *ptr;\n+  if (fcache_tab == NULL)\n+    fcache_tab = new fcache[fcache_tab_size];\n+}\n \n-  if (!string_len)\n+/* Free the ressources used by the set of cache used for files accessed\n+   by caret diagnostic.  */\n+\n+void\n+diagnostic_file_cache_fini (void)\n+{\n+  if (fcache_tab)\n     {\n-      string_len = 200;\n-      string = XNEWVEC (char, string_len);\n+      delete [] (fcache_tab);\n+      fcache_tab = NULL;\n     }\n+}\n \n-  while ((ptr = fgets (string + pos, string_len - pos, file)))\n+/* Return the total lines number that have been read so far by the\n+   line map (in the preprocessor) so far.  For languages like C++ that\n+   entirely preprocess the input file before starting to parse, this\n+   equals the actual number of lines of the file.  */\n+\n+static size_t\n+total_lines_num (const char *file_path)\n+{\n+  size_t r = 0;\n+  source_location l = 0;\n+  if (linemap_get_file_highest_location (line_table, file_path, &l))\n     {\n-      size_t len = strlen (string + pos);\n+      gcc_assert (l >= RESERVED_LOCATION_COUNT);\n+      expanded_location xloc = expand_location (l);\n+      r = xloc.line;\n+    }\n+  return r;\n+}\n+\n+/* Lookup the cache used for the content of a given file accessed by\n+   caret diagnostic.  Return the found cached file, or NULL if no\n+   cached file was found.  */\n+\n+static fcache*\n+lookup_file_in_cache_tab (const char *file_path)\n+{\n+  if (file_path == NULL)\n+    return NULL;\n \n-      if (string[pos + len - 1] == '\\n')\n+  diagnostic_file_cache_init ();\n+\n+  /* This will contain the found cached file.  */\n+  fcache *r = NULL;\n+  for (unsigned i = 0; i < fcache_tab_size; ++i)\n+    {\n+      fcache *c = &fcache_tab[i];\n+      if (c->file_path && !strcmp (c->file_path, file_path))\n \t{\n-\t  string[pos + len - 1] = 0;\n-\t  return string;\n+\t  ++c->use_count;\n+\t  r = c;\n \t}\n-      pos += len;\n-      string = XRESIZEVEC (char, string, string_len * 2);\n-      string_len *= 2;\n     }\n-      \n-  return pos ? string : NULL;\n+\n+  if (r)\n+    ++r->use_count;\n+\n+  return r;\n+}\n+\n+/* Return the file cache that has been less used, recently, or the\n+   first empty one.  If HIGHEST_USE_COUNT is non-null,\n+   *HIGHEST_USE_COUNT is set to the highest use count of the entries\n+   in the cache table.  */\n+\n+static fcache*\n+evicted_cache_tab_entry (unsigned *highest_use_count)\n+{\n+  diagnostic_file_cache_init ();\n+\n+  fcache *to_evict = &fcache_tab[0];\n+  unsigned huc = to_evict->use_count;\n+  for (unsigned i = 1; i < fcache_tab_size; ++i)\n+    {\n+      fcache *c = &fcache_tab[i];\n+      bool c_is_empty = (c->file_path == NULL);\n+\n+      if (c->use_count < to_evict->use_count\n+\t  || (to_evict->file_path && c_is_empty))\n+\t/* We evict C because it's either an entry with a lower use\n+\t   count or one that is empty.  */\n+\tto_evict = c;\n+\n+      if (huc < c->use_count)\n+\thuc = c->use_count;\n+\n+      if (c_is_empty)\n+\t/* We've reached the end of the cache; subsequent elements are\n+\t   all empty.  */\n+\tbreak;\n+    }\n+\n+  if (highest_use_count)\n+    *highest_use_count = huc;\n+\n+  return to_evict;\n+}\n+\n+/* Create the cache used for the content of a given file to be\n+   accessed by caret diagnostic.  This cache is added to an array of\n+   cache and can be retrieved by lookup_file_in_cache_tab.  This\n+   function returns the created cache.  Note that only the last\n+   fcache_tab_size files are cached.  */\n+\n+static fcache*\n+add_file_to_cache_tab (const char *file_path)\n+{\n+\n+  FILE *fp = fopen (file_path, \"r\");\n+  if (ferror (fp))\n+    {\n+      fclose (fp);\n+      return NULL;\n+    }\n+\n+  unsigned highest_use_count = 0;\n+  fcache *r = evicted_cache_tab_entry (&highest_use_count);\n+  r->file_path = file_path;\n+  if (r->fp)\n+    fclose (r->fp);\n+  r->fp = fp;\n+  r->nb_read = 0;\n+  r->line_start_idx = 0;\n+  r->line_num = 0;\n+  r->line_record.truncate (0);\n+  /* Ensure that this cache entry doesn't get evicted next time\n+     add_file_to_cache_tab is called.  */\n+  r->use_count = ++highest_use_count;\n+  r->total_lines = total_lines_num (file_path);\n+\n+  return r;\n+}\n+\n+/* Lookup the cache used for the content of a given file accessed by\n+   caret diagnostic.  If no cached file was found, create a new cache\n+   for this file, add it to the array of cached file and return\n+   it.  */\n+\n+static fcache*\n+lookup_or_add_file_to_cache_tab (const char *file_path)\n+{\n+  fcache *r = lookup_file_in_cache_tab (file_path);\n+  if (r == NULL)\n+    r = add_file_to_cache_tab (file_path);\n+  return r;\n+}\n+\n+/* Default constructor for a cache of file used by caret\n+   diagnostic.  */\n+\n+fcache::fcache ()\n+: use_count (0), file_path (NULL), fp (NULL), data (0),\n+  size (0), nb_read (0), line_start_idx (0), line_num (0),\n+  total_lines (0)\n+{\n+  line_record.create (0);\n+}\n+\n+/* Destructor for a cache of file used by caret diagnostic.  */\n+\n+fcache::~fcache ()\n+{\n+  if (fp)\n+    {\n+      fclose (fp);\n+      fp = NULL;\n+    }\n+  if (data)\n+    {\n+      XDELETEVEC (data);\n+      data = 0;\n+    }\n+  line_record.release ();\n+}\n+\n+/* Returns TRUE iff the cache would need to be filled with data coming\n+   from the file.  That is, either the cache is empty or full or the\n+   current line is empty.  Note that if the cache is full, it would\n+   need to be extended and filled again.  */\n+\n+static bool\n+needs_read (fcache *c)\n+{\n+  return (c->nb_read == 0\n+\t  || c->nb_read == c->size\n+\t  || (c->line_start_idx >= c->nb_read - 1));\n+}\n+\n+/*  Return TRUE iff the cache is full and thus needs to be\n+    extended.  */\n+\n+static bool\n+needs_grow (fcache *c)\n+{\n+  return c->nb_read == c->size;\n+}\n+\n+/* Grow the cache if it needs to be extended.  */\n+\n+static void\n+maybe_grow (fcache *c)\n+{\n+  if (!needs_grow (c))\n+    return;\n+\n+  size_t size = c->size == 0 ? fcache_buffer_size : c->size * 2;\n+  c->data = XRESIZEVEC (char, c->data, size + 1);\n+  c->size = size;\n+}\n+\n+/*  Read more data into the cache.  Extends the cache if need be.\n+    Returns TRUE iff new data could be read.  */\n+\n+static bool\n+read_data (fcache *c)\n+{\n+  if (feof (c->fp) || ferror (c->fp))\n+    return false;\n+\n+  maybe_grow (c);\n+\n+  char * from = c->data + c->nb_read;\n+  size_t to_read = c->size - c->nb_read;\n+  size_t nb_read = fread (from, 1, to_read, c->fp);\n+\n+  if (ferror (c->fp))\n+    return false;\n+\n+  c->nb_read += nb_read;\n+  return !!nb_read;\n+}\n+\n+/* Read new data iff the cache needs to be filled with more data\n+   coming from the file FP.  Return TRUE iff the cache was filled with\n+   mode data.  */\n+\n+static bool\n+maybe_read_data (fcache *c)\n+{\n+  if (!needs_read (c))\n+    return false;\n+  return read_data (c);\n+}\n+\n+/* Read a new line from file FP, using C as a cache for the data\n+   coming from the file.  Upon successful completion, *LINE is set to\n+   the beginning of the line found.  Space for that line has been\n+   allocated in the cache thus *LINE has the same life time as C.\n+   *LINE_LEN is set to the length of the line.  Note that the line\n+   does not contain any terminal delimiter.  This function returns\n+   true if some data was read or process from the cache, false\n+   otherwise.  Note that subsequent calls to get_next_line return the\n+   next lines of the file and might overwrite the content of\n+   *LINE.  */\n+\n+static bool\n+get_next_line (fcache *c, char **line, ssize_t *line_len)\n+{\n+  /* Fill the cache with data to process.  */\n+  maybe_read_data (c);\n+\n+  size_t remaining_size = c->nb_read - c->line_start_idx;\n+  if (remaining_size == 0)\n+    /* There is no more data to process.  */\n+    return false;\n+\n+  char *line_start = c->data + c->line_start_idx;\n+\n+  char *next_line_start = NULL;\n+  size_t len = 0;\n+  char *line_end = (char *) memchr (line_start, '\\n', remaining_size);\n+  if (line_end == NULL)\n+    {\n+      /* We haven't found the end-of-line delimiter in the cache.\n+\t Fill the cache with more data from the file and look for the\n+\t '\\n'.  */\n+      while (maybe_read_data (c))\n+\t{\n+\t  line_start = c->data + c->line_start_idx;\n+\t  remaining_size = c->nb_read - c->line_start_idx;\n+\t  line_end = (char *) memchr (line_start, '\\n', remaining_size);\n+\t  if (line_end != NULL)\n+\t    {\n+\t      next_line_start = line_end + 1;\n+\t      break;\n+\t    }\n+\t}\n+      if (line_end == NULL)\n+\t/* We've loadded all the file into the cache and still no\n+\t   '\\n'.  Let's say the line ends up at one byte passed the\n+\t   end of the file.  This is to stay consistent with the case\n+\t   of when the line ends up with a '\\n' and line_end points to\n+\t   that terminal '\\n'.  That consistency is useful below in\n+\t   the len calculation.  */\n+\tline_end = c->data + c->nb_read ;\n+    }\n+  else\n+    next_line_start = line_end + 1;\n+\n+  if (ferror (c->fp))\n+    return -1;\n+\n+  /* At this point, we've found the end of the of line.  It either\n+     points to the '\\n' or to one byte after the last byte of the\n+     file.  */\n+  gcc_assert (line_end != NULL);\n+\n+  len = line_end - line_start;\n+\n+  if (c->line_start_idx < c->nb_read)\n+    *line = line_start;\n+\n+  ++c->line_num;\n+\n+  /* Before we update our line record, make sure the hint about the\n+     total number of lines of the file is correct.  If it's not, then\n+     we give up recording line boundaries from now on.  */\n+  bool update_line_record = true;\n+  if (c->line_num > c->total_lines)\n+    update_line_record = false;\n+\n+    /* Now update our line record so that re-reading lines from the\n+     before c->line_start_idx is faster.  */\n+  if (update_line_record\n+      && c->line_record.length () < fcache_line_record_size)\n+    {\n+      /* If the file lines fits in the line record, we just record all\n+\t its lines ...*/\n+      if (c->total_lines <= fcache_line_record_size\n+\t  && c->line_num > c->line_record.length ())\n+\tc->line_record.safe_push (fcache::line_info (c->line_num,\n+\t\t\t\t\t\t c->line_start_idx,\n+\t\t\t\t\t\t line_end - c->data));\n+      else if (c->total_lines > fcache_line_record_size)\n+\t{\n+\t  /* ... otherwise, we just scale total_lines down to\n+\t     (fcache_line_record_size lines.  */\n+\t  size_t n = (c->line_num * fcache_line_record_size) / c->total_lines;\n+\t  if (c->line_record.length () == 0\n+\t      || n >= c->line_record.length ())\n+\t    c->line_record.safe_push (fcache::line_info (c->line_num,\n+\t\t\t\t\t\t     c->line_start_idx,\n+\t\t\t\t\t\t     line_end - c->data));\n+\t}\n+    }\n+\n+  /* Update c->line_start_idx so that it points to the next line to be\n+     read.  */\n+  if (next_line_start)\n+    c->line_start_idx = next_line_start - c->data;\n+  else\n+    /* We didn't find any terminal '\\n'.  Let's consider that the end\n+       of line is the end of the data in the cache.  The next\n+       invocation of get_next_line will either read more data from the\n+       underlying file or return false early because we've reached the\n+       end of the file.  */\n+    c->line_start_idx = c->nb_read;\n+\n+  *line_len = len;\n+\n+  return true;\n+}\n+\n+/* Reads the next line from FILE into *LINE.  If *LINE is too small\n+   (or NULL) it is allocated (or extended) to have enough space to\n+   containe the line.  *LINE_LENGTH must contain the size of the\n+   initial*LINE buffer.  It's then updated by this function to the\n+   actual length of the returned line.  Note that the returned line\n+   can contain several zero bytes.  Also note that the returned string\n+   is allocated in static storage that is going to be re-used by\n+   subsequent invocations of read_line.  */\n+\n+static bool\n+read_next_line (fcache *cache, char ** line, ssize_t *line_len)\n+{\n+  char *l = NULL;\n+  ssize_t len = 0;\n+\n+  if (!get_next_line (cache, &l, &len))\n+    return false;\n+\n+  if (*line == NULL)\n+    *line = XNEWVEC (char, len);\n+  else\n+    if (*line_len < len)\n+\t*line = XRESIZEVEC (char, *line, len);\n+\n+  memcpy (*line, l, len);\n+  *line_len = len;\n+\n+  return true;\n+}\n+\n+/* Consume the next bytes coming from the cache (or from its\n+   underlying file if there are remaining unread bytes in the file)\n+   until we reach the next end-of-line (or end-of-file).  There is no\n+   copying from the cache involved.  Return TRUE upon successful\n+   completion.  */\n+\n+static bool\n+goto_next_line (fcache *cache)\n+{\n+  char *l;\n+  ssize_t len;\n+\n+  return get_next_line (cache, &l, &len);\n+}\n+\n+/* Read an arbitrary line number LINE_NUM from the file cached in C.\n+   The line is copied into *LINE.  *LINE_LEN must have been set to the\n+   length of *LINE.  If *LINE is too small (or NULL) it's extended (or\n+   allocated) and *LINE_LEN is adjusted accordingly.  *LINE ends up\n+   with a terminal zero byte and can contain additional zero bytes.\n+   This function returns bool if a line was read.  */\n+\n+static bool\n+read_line_num (fcache *c, size_t line_num,\n+\t       char ** line, ssize_t *line_len)\n+{\n+  gcc_assert (line_num > 0);\n+\n+  if (line_num <= c->line_num)\n+    {\n+      /* We've been asked to read lines that are before c->line_num.\n+\t So lets use our line record (if it's not empty) to try to\n+\t avoid re-reading the file from the beginning again.  */\n+\n+      if (c->line_record.is_empty ())\n+\t{\n+\t  c->line_start_idx = 0;\n+\t  c->line_num = 0;\n+\t}\n+      else\n+\t{\n+\t  fcache::line_info *i = NULL;\n+\t  if (c->total_lines <= fcache_line_record_size)\n+\t    {\n+\t      /* In languages where the input file is not totally\n+\t\t preprocessed up front, the c->total_lines hint\n+\t\t can be smaller than the number of lines of the\n+\t\t file.  In that case, only the first\n+\t\t c->total_lines have been recorded.\n+\n+\t\t Otherwise, the first c->total_lines we've read have\n+\t\t their start/end recorded here.  */\n+\t      i = (line_num <= c->total_lines)\n+\t\t? &c->line_record[line_num - 1]\n+\t\t: &c->line_record[c->total_lines - 1];\n+\t      gcc_assert (i->line_num <= line_num);\n+\t    }\n+\t  else\n+\t    {\n+\t      /*  So the file had more lines than our line record\n+\t\t  size.  Thus the number of lines we've recorded has\n+\t\t  been scaled down to fcache_line_reacord_size.  Let's\n+\t\t  pick the start/end of the recorded line that is\n+\t\t  closest to line_num.  */\n+\t      size_t n = (line_num <= c->total_lines)\n+\t\t? line_num * fcache_line_record_size / c->total_lines\n+\t\t: c ->line_record.length () - 1;\n+\t      if (n < c->line_record.length ())\n+\t\t{\n+\t\t  i = &c->line_record[n];\n+\t\t  gcc_assert (i->line_num <= line_num);\n+\t\t}\n+\t    }\n+\n+\t  if (i && i->line_num == line_num)\n+\t    {\n+\t      /* We have the start/end of the line.  Let's just copy\n+\t\t it again and we are done.  */\n+\t      ssize_t len = i->end_pos - i->start_pos + 1;\n+\t      if (*line_len < len)\n+\t\t*line = XRESIZEVEC (char, *line, len);\n+\t      memmove (*line, c->data + i->start_pos, len);\n+\t      (*line)[len - 1] = '\\0';\n+\t      *line_len = --len;\n+\t      return true;\n+\t    }\n+\n+\t  if (i)\n+\t    {\n+\t      c->line_start_idx = i->start_pos;\n+\t      c->line_num = i->line_num - 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      c->line_start_idx = 0;\n+\t      c->line_num = 0;\n+\t    }\n+\t}\n+    }\n+\n+  /*  Let's walk from line c->line_num up to line_num - 1, without\n+      copying any line.  */\n+  while (c->line_num < line_num - 1)\n+    if (!goto_next_line (c))\n+      return false;\n+\n+  /* The line we want is the next one.  Let's read and copy it back to\n+     the caller.  */\n+  return read_next_line (c, line, line_len);\n }\n \n /* Return the physical source line that corresponds to xloc in a\n    buffer that is statically allocated.  The newline is replaced by\n-   the null character.  */\n+   the null character.  Note that the line can contain several null\n+   characters, so LINE_LEN, if non-null, points to the actual length\n+   of the line.  */\n \n const char *\n-location_get_source_line (expanded_location xloc)\n+location_get_source_line (expanded_location xloc,\n+\t\t\t  int *line_len)\n {\n-  const char *buffer;\n-  int lines = 1;\n-  FILE *stream = xloc.file ? fopen (xloc.file, \"r\") : NULL;\n-  if (!stream)\n-    return NULL;\n+  static char *buffer;\n+  static ssize_t len;\n+\n+  fcache * c = lookup_or_add_file_to_cache_tab (xloc.file);\n+  bool read = read_line_num (c, xloc.line, &buffer, &len);\n \n-  while ((buffer = read_line (stream)) && lines < xloc.line)\n-    lines++;\n+  if (read && line_len)\n+    *line_len = len;\n \n-  fclose (stream);\n-  return buffer;\n+  return read ? buffer : NULL;\n }\n \n /* Expand the source location LOC into a human readable location.  If"}, {"sha": "d910bb88f9779fc95e0a073ff839d000b12401b6", "filename": "gcc/input.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -37,7 +37,8 @@ extern char builtins_location_check[(BUILTINS_LOCATION\n \t\t\t\t     < RESERVED_LOCATION_COUNT) ? 1 : -1];\n \n extern expanded_location expand_location (source_location);\n-extern const char *location_get_source_line (expanded_location xloc);\n+extern const char *location_get_source_line (expanded_location xloc,\n+\t\t\t\t\t     int *line_size);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);\n \n@@ -62,4 +63,6 @@ extern location_t input_location;\n \n void dump_line_table_statistics (void);\n \n+void diagnostics_file_cache_fini (void);\n+\n #endif"}, {"sha": "858d6f36b976f05a96fe91af3621a19476555a3b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -1,3 +1,8 @@\n+2014-01-23  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/58580\n+\t* c-c++-common/cpp/warning-zero-in-literals-1.c: New test file.\n+\n 2014-01-23  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n         * gcc.target/i386/avx512f-vmovdqu32-1.c: Fix intrinsic name."}, {"sha": "ff2ed962ac96e47ae05b0b040f4e10b8e09637e2", "filename": "gcc/testsuite/c-c++-common/cpp/warning-zero-in-literals-1.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79"}, {"sha": "90512820eb9e4a455764dca00a6718285ea452ba", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -1,3 +1,10 @@\n+2014-01-23  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR PR preprocessor/58580\n+\t* include/line-map.h (linemap_get_file_highest_location): Declare\n+\tnew function.\n+\t* line-map.c (linemap_get_file_highest_location): Define it.\n+\n 2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years"}, {"sha": "9886314b25a03bb4a06dd8e0d23db3b01c972552", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -756,6 +756,14 @@ struct linemap_stats\n   long duplicated_macro_maps_locations_size;\n };\n \n+/* Return the highest location emitted for a given file for which\n+   there is a line map in SET.  FILE_NAME is the file name to\n+   consider.  If the function returns TRUE, *LOC is set to the highest\n+   location emitted for that file.  */\n+bool linemap_get_file_highest_location (struct line_maps * set,\n+\t\t\t\t\tconst char *file_name,\n+\t\t\t\t\tsource_location *loc);\n+\n /* Compute and return statistics about the memory consumption of some\n    parts of the line table SET.  */\n void linemap_get_statistics (struct line_maps *, struct linemap_stats *);"}, {"sha": "7c7facbc760d5a666461611b3c17fcf863fc6b0a", "filename": "libcpp/line-map.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=7ecc3eb9e6c61a3f1408a55e22eefa5fd3d08e79", "patch": "@@ -1502,6 +1502,46 @@ linemap_dump_location (struct line_maps *set,\n \t   path, from, l, c, s, (void*)map, e, loc, location);\n }\n \n+/* Return the highest location emitted for a given file for which\n+   there is a line map in SET.  FILE_NAME is the file name to\n+   consider.  If the function returns TRUE, *LOC is set to the highest\n+   location emitted for that file.  */\n+\n+bool\n+linemap_get_file_highest_location (struct line_maps *set,\n+\t\t\t\t   const char *file_name,\n+\t\t\t\t   source_location *loc)\n+{\n+  /* If the set is empty or no ordinary map has been created then\n+     there is no file to look for ...  */\n+  if (set == NULL || set->info_ordinary.used == 0)\n+    return false;\n+\n+  /* Now look for the last ordinary map created for FILE_NAME.  */\n+  int i;\n+  for (i = set->info_ordinary.used - 1; i >= 0; --i)\n+    {\n+      const char *fname = set->info_ordinary.maps[i].d.ordinary.to_file;\n+      if (fname && !filename_cmp (fname, file_name))\n+\tbreak;\n+    }\n+\n+  if (i < 0)\n+    return false;\n+\n+  /* The highest location for a given map is either the starting\n+     location of the next map minus one, or -- if the map is the\n+     latest one -- the highest location of the set.  */\n+  source_location result;\n+  if (i == (int) set->info_ordinary.used - 1)\n+    result = set->highest_location;\n+  else\n+    result = set->info_ordinary.maps[i + 1].start_location - 1;\n+\n+  *loc = result;\n+  return true;\n+}\n+\n /* Compute and return statistics about the memory consumption of some\n    parts of the line table SET.  */\n "}]}