{"sha": "237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3YTk3OTVjYjhlZWUyMjk2ZDBlNzc3YmMyZGZmYTRjZGFmZWZhNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-22T01:49:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-22T01:49:19Z"}, "message": "loop.c (loop_unroll_factor): Move outside #ifdef HAIFA conditional.\n\n        * loop.c (loop_unroll_factor): Move outside #ifdef HAIFA\n        conditional.\n        (loop_unroll_iter): Remove unused variable and all references.\n        (loop_optimize): Always allocate and clear space for loop_unroll_factor.\n        (insert_bct): Fix minor formatting problems.\n        * loop.h (loop_unroll_factor): Move decl outside #ifdef HAIFA.\n        (loop_unroll_iter): Removed unused decl.\n        * unroll.c (unroll_loop): Remove code to set loop_unroll_iter.\n        Always record the unrolling factor.\nMore haifa cleanup\n\nFrom-SVN: r15621", "tree": {"sha": "90446704bc98bcf3a8a28c6f81912cdac9a90ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90446704bc98bcf3a8a28c6f81912cdac9a90ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/comments", "author": null, "committer": null, "parents": [{"sha": "813f674a97a75338b497442d3529b89fcd37b917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813f674a97a75338b497442d3529b89fcd37b917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/813f674a97a75338b497442d3529b89fcd37b917"}], "stats": {"total": 63, "additions": 26, "deletions": 37}, "files": [{"sha": "a72fdcbc427a7f83068ad984a544ccf93f136304", "filename": "gcc/loop.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "patch": "@@ -91,15 +91,6 @@ int *loop_can_insert_bct;\n \n int *loop_used_count_register;\n \n-/* For each loop, remember its unrolling factor (if at all).\n-   contents of the array:\n-   0/1: not unrolled.\n-   -1: completely unrolled - no further instrumentation is needed.\n-   >1: holds the exact amount of unrolling.  */\n-\n-int *loop_unroll_factor;\n-int *loop_unroll_iter;\n-\n /* loop parameters for arithmetic loops. These loops have a loop variable\n    which is initialized to loop_start_value, incremented in each iteration\n    by \"loop_increment\".  At the end of the iteration the loop variable is\n@@ -111,6 +102,13 @@ rtx *loop_start_value;\n enum rtx_code *loop_comparison_code;\n #endif  /* HAIFA */\n \n+/* For each loop, keep track of its unrolling factor.\n+   Potential values:\n+      0: unrolled\n+      1: not unrolled.\n+     -1: completely unrolled\n+     >0: holds the unroll exact factor.  */\n+int *loop_unroll_factor;\n \n /* Indexed by loop number, contains a nonzero value if the \"loop\" isn't\n    really a loop (an insn outside the loop branches into it).  */\n@@ -431,6 +429,12 @@ loop_optimize (f, dumpfile)\n   loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_number_exit_count = (int *) alloca (max_loop_num * sizeof (int));\n \n+  /* This is initialized by the unrolling code, so we go ahead\n+     and clear them just in case we are not performing loop\n+     unrolling.  */\n+  loop_unroll_factor = (int *) alloca (max_loop_num *sizeof (int));\n+  bzero ((char *) loop_unroll_factor, max_loop_num * sizeof (int));\n+\n #ifdef HAIFA\n   /* Allocate for BCT optimization */\n   loop_can_insert_bct = (int *) alloca (max_loop_num * sizeof (int));\n@@ -439,12 +443,6 @@ loop_optimize (f, dumpfile)\n   loop_used_count_register = (int *) alloca (max_loop_num * sizeof (int));\n   bzero ((char *) loop_used_count_register, max_loop_num * sizeof (int));\n \n-  loop_unroll_factor = (int *) alloca (max_loop_num *sizeof (int));\n-  bzero ((char *) loop_unroll_factor, max_loop_num * sizeof (int));\n-\n-  loop_unroll_iter = (int *) alloca (max_loop_num *sizeof (int));\n-  bzero ((char *) loop_unroll_iter, max_loop_num * sizeof (int));\n-\n   loop_increment = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_comparison_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_start_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n@@ -7277,12 +7275,9 @@ insert_bct (loop_start, loop_end)\n     return;\n   }\n \n-  /* make sure that the loop was not fully unrolled.  */\n-  if (loop_unroll_factor[loop_num] == -1){\n-    if (loop_dump_stream)\n-      fprintf (loop_dump_stream, \"insert_bct %d: was completely unrolled\\n\", loop_num);\n+  /* It's impossible to instrument a competely unrolled loop.  */\n+  if (loop_unroll_factor [loop_num] == -1)\n     return;\n-  }\n \n   /* make sure that the last loop insn is a conditional jump .\n      This check is repeated from analyze_loop_iterations (),\n@@ -7296,8 +7291,8 @@ insert_bct (loop_start, loop_end)\n   }\n \n   /* fix increment in case loop was unrolled.  */\n-  if (loop_unroll_factor[loop_num] > 1)\n-    increment = GEN_INT ( INTVAL (increment) * loop_unroll_factor[loop_num] );\n+  if (loop_unroll_factor [loop_num] > 1)\n+    increment = GEN_INT ( INTVAL (increment) * loop_unroll_factor [loop_num] );\n \n   /* determine properties and directions of the loop */\n   increment_direction = (INTVAL (increment) > 0) ? 1:-1;"}, {"sha": "44e150020282a757e5f7219af79434e28e2cd0ef", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "patch": "@@ -182,12 +182,11 @@ rtx final_giv_value PROTO((struct induction *, rtx, rtx));\n void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n \n+extern int *loop_unroll_factor;\n #ifdef HAIFA\n /* variables for interaction between unroll.c and loop.c, for\n    the insertion of branch-on-count instruction. */\n-extern int *loop_unroll_factor;\n extern rtx *loop_start_value;\n-extern int *loop_unroll_iter;\n extern int loop_number();\n #endif  /* HAIFA */\n "}, {"sha": "b9cbcfe6a48b144ffc7b67ac54b9056c238b6f26", "filename": "gcc/unroll.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/237a9795cb8eee2296d0e777bc2dffa4cdafefa6/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=237a9795cb8eee2296d0e777bc2dffa4cdafefa6", "patch": "@@ -1094,16 +1094,13 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Set unroll type to MODULO now.  */\n \t  unroll_type = UNROLL_MODULO;\n \t  loop_preconditioned = 1;\n+\n #ifdef HAIFA\n-\t  if (loop_n_iterations > 0)\n-\t    loop_unroll_iter[ loop_number(loop_start, loop_end) ]\n-\t      = (loop_n_iterations\n-\t\t  - loop_n_iterations % (abs_inc * unroll_number));\n-\t  else\n-\t    /* inform loop.c about the new initial value */\n-\t    loop_start_value[loop_number(loop_start, loop_end)] = initial_value;\n+\t  /* Fix the initial value for the loop as needed.  */\n+\t  if (loop_n_iterations <= 0)\n+\t    loop_start_value [loop_number (loop_start, loop_end)]\n+\t      = initial_value;\n #endif\n-\n \t}\n     }\n \n@@ -1118,13 +1115,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   /* At this point, we are guaranteed to unroll the loop.  */\n \n-#ifdef HAIFA\n-  /* inform loop.c about the factor of unrolling */\n+  /* Keep track of the unroll factor for each loop.  */\n   if (unroll_type == UNROLL_COMPLETELY)\n-    loop_unroll_factor[ loop_number(loop_start, loop_end) ] = -1;\n+    loop_unroll_factor [loop_number (loop_start, loop_end)] = -1;\n   else\n-    loop_unroll_factor[ loop_number(loop_start, loop_end) ] = unroll_number;\n-#endif  /* HAIFA */\n+    loop_unroll_factor [loop_number (loop_start, loop_end)] = unroll_number;\n \n \n   /* For each biv and giv, determine whether it can be safely split into"}]}