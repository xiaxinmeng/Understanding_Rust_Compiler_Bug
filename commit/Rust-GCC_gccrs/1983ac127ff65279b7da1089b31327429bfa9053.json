{"sha": "1983ac127ff65279b7da1089b31327429bfa9053", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk4M2FjMTI3ZmY2NTI3OWI3ZGExMDg5YjMxMzI3NDI5YmZhOTA1Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-11-19T22:55:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-11-19T22:55:55Z"}, "message": "tree-ssa-threadupdate.c: Replace REDIRECTION_DATA varray with a hash table.\n\n        * tree-ssa-threadupdate.c: Replace REDIRECTION_DATA varray with\n        a hash table.  Extensive modifications throughout to support\n        that change.\n        (struct el): New.\n        (struct local_info): New.\n        (struct redirection_data): Add new INCOMING_EDGES and DO_NOT_DUPLICATE\n        fields.\n        (redirection_data): Now a hashtable.\n        (redirection_data_hash, redirection_data_eq): New.\n        (lookup_redirection_data, create_duplicates): New.\n        (create_edge_and_update_destionation_phis): New.\n        (fixup_template_block, redirect_edges): New.\n        (thread_block): Use hash table traversals instead of loops over\n        varray entries or incoming edge vectors.\n\nFrom-SVN: r90941", "tree": {"sha": "528a60aee0ec3fb61490259d78dafcb6beee0337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528a60aee0ec3fb61490259d78dafcb6beee0337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1983ac127ff65279b7da1089b31327429bfa9053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1983ac127ff65279b7da1089b31327429bfa9053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1983ac127ff65279b7da1089b31327429bfa9053", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1983ac127ff65279b7da1089b31327429bfa9053/comments", "author": null, "committer": null, "parents": [{"sha": "4f7db7f7d7857726bdafc0f6f17808bf6352f97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7db7f7d7857726bdafc0f6f17808bf6352f97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7db7f7d7857726bdafc0f6f17808bf6352f97f"}], "stats": {"total": 494, "additions": 336, "deletions": 158}, "files": [{"sha": "91282c311e9e5d2458d4c692d19b706b05dfb08b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1983ac127ff65279b7da1089b31327429bfa9053/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1983ac127ff65279b7da1089b31327429bfa9053/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1983ac127ff65279b7da1089b31327429bfa9053", "patch": "@@ -137,6 +137,21 @@\n \n 2004-11-19  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-threadupdate.c: Replace REDIRECTION_DATA varray with\n+\ta hash table.  Extensive modifications throughout to support\n+\tthat change.\n+\t(struct el): New.\n+\t(struct local_info): New.\n+\t(struct redirection_data): Add new INCOMING_EDGES and DO_NOT_DUPLICATE\n+\tfields.\n+\t(redirection_data): Now a hashtable.\n+\t(redirection_data_hash, redirection_data_eq): New.\n+\t(lookup_redirection_data, create_duplicates): New.\n+\t(create_edge_and_update_destionation_phis): New.\n+\t(fixup_template_block, redirect_edges): New.\n+\t(thread_block): Use hash table traversals instead of loops over\n+\tvarray entries or incoming edge vectors.\n+\n \t* tree-ssa.c (verify_ssa): Remove redundant checking of PHI\n \targuments.\n "}, {"sha": "d252196b16699f7a087822cc5355a1f916504e98", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 321, "deletions": 158, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1983ac127ff65279b7da1089b31327429bfa9053/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1983ac127ff65279b7da1089b31327429bfa9053/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=1983ac127ff65279b7da1089b31327429bfa9053", "patch": "@@ -73,14 +73,41 @@ Boston, MA 02111-1307, USA.  */\n \n    Note that block duplication can be minimized by first collecting the\n    the set of unique destination blocks that the incoming edges should\n-   be threaded to.  Block duplication can be further minimized by using \n+   be threaded to.  Block duplication can be further minimized by using\n    B instead of creating B' for one destination if all edges into B are\n-   going to be threaded to a successor of B.  */\n+   going to be threaded to a successor of B.\n \n+   We further reduce the number of edges and statements we create by\n+   not copying all the outgoing edges and the control statement in\n+   step #1.  We instead create a template block without the outgoing\n+   edges and duplicate the template.  */\n+\n+\n+/* Steps #5 and #6 of the above algorithm are best implemented by walking\n+   all the incoming edges which thread to the same destination edge at\n+   the same time.  That avoids lots of table lookups to get information\n+   for the destination edge.\n+\n+   To realize that implementation we create a list of incoming edges\n+   which thread to the same outgoing edge.  Thus to implement steps\n+   #5 and #6 we traverse our hash table of outgoing edge information.\n+   For each entry we walk the list of incoming edges which thread to\n+   the current outgoing edge.  */\n+\n+struct el\n+{\n+  edge e;\n+  struct el *next;\n+};\n \n /* Main data structure recording information regarding B's duplicate\n    blocks.  */\n \n+/* We need to efficiently record the unique thread destinations of this\n+   block and specific information associated with those destinations.  We\n+   may have many incoming edges threaded to the same outgoing edge.  This\n+   can be naturaly implemented with a hash table.  */\n+\n struct redirection_data\n {\n   /* A duplicate of B with the trailing control statement removed and which\n@@ -90,10 +117,30 @@ struct redirection_data\n   /* An outgoing edge from B.  DUP_BLOCK will have OUTGOING_EDGE->dest as\n      its single successor.  */\n   edge outgoing_edge;\n+\n+  /* A list of incoming edges which we want to thread to\n+     OUTGOING_EDGE->dest.  */\n+  struct el *incoming_edges;\n+\n+  /* Flag indicating whether or not we should create a duplicate block\n+     for this thread destination.  This is only true if we are threading\n+     all incoming edges and thus are using BB itself as a duplicate block.  */\n+  bool do_not_duplicate;\n };\n \n /* Main data structure to hold information for duplicates of BB.  */\n-static varray_type redirection_data;\n+static htab_t redirection_data;\n+\n+/* Data structure of information to pass to hash table traversal routines.  */\n+struct local_info\n+{\n+  /* The current block we are working on.  */\n+  basic_block bb;\n+\n+  /* A template copy of BB with no outgoing edges or control statement that\n+     we use for creating copies.  */\n+  basic_block template_block;\n+};\n \n /* Remove the last statement in block BB if it is a control statement\n    Also remove all outgoing edges except the edge which reaches DEST_BB.\n@@ -151,11 +198,237 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n   remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n }\n \n+/* Hashing and equality routines for our hash table.  */\n+static hashval_t\n+redirection_data_hash (const void *p)\n+{\n+  edge e = ((struct redirection_data *)p)->outgoing_edge;\n+  return htab_hash_pointer (e);\n+}\n+\n+static int\n+redirection_data_eq (const void *p1, const void *p2)\n+{\n+  edge e1 = ((struct redirection_data *)p1)->outgoing_edge;\n+  edge e2 = ((struct redirection_data *)p2)->outgoing_edge;\n+\n+  return e1 == e2;\n+}\n+\n+/* Given an outgoing edge E lookup and return its entry in our hash table.\n+\n+   If INSERT is true, then we insert the entry into the hash table if\n+   it is not already present.  INCOMING_EDGE is added to the list of incoming\n+   edges associated with E in the hash table.  */\n+\n+static struct redirection_data *\n+lookup_redirection_data (edge e, edge incoming_edge, bool insert)\n+{\n+  void **slot;\n+  struct redirection_data *elt;\n+\n+ /* Build a hash table element so we can see if E is already\n+     in the table.  */\n+  elt = xmalloc (sizeof (struct redirection_data));\n+  elt->outgoing_edge = e;\n+  elt->dup_block = NULL;\n+  elt->do_not_duplicate = false;\n+  elt->incoming_edges = NULL;\n+\n+  slot = htab_find_slot (redirection_data, elt, insert);\n+\n+  /* This will only happen if INSERT is false and the entry is not\n+     in the hash table.  */\n+  if (slot == NULL)\n+    {\n+      free (elt);\n+      return NULL;\n+    }\n+\n+  /* This will only happen if E was not in the hash table and\n+     INSERT is true.  */\n+  if (*slot == NULL)\n+    {\n+      *slot = (void *)elt;\n+      elt->incoming_edges = xmalloc (sizeof (struct el));\n+      elt->incoming_edges->e = incoming_edge;\n+      elt->incoming_edges->next = NULL;\n+      return elt;\n+    }\n+  /* E was in the hash table.  */\n+  else\n+    {\n+      /* Free ELT as we do not need it anymore, we will extract the\n+\t relevant entry from the hash table itself.  */\n+      free (elt);\n+\n+      /* Get the entry stored in the hash table.  */\n+      elt = (struct redirection_data *) *slot;\n+\n+      /* If insertion was requested, then we need to add INCOMING_EDGE\n+\t to the list of incoming edges associated with E.  */\n+      if (insert)\n+\t{\n+          struct el *el = xmalloc (sizeof (struct el));\n+\t  el->next = elt->incoming_edges;\n+\t  el->e = incoming_edge;\n+\t  elt->incoming_edges = el;\n+\t}\n+\n+      return elt;\n+    }\n+}\n+\n+/* Given a duplicate block and its single destination (both stored\n+   in RD).  Create an edge between the duplicate and its single\n+   destination.\n+\n+   Add an additional argument to any PHI nodes at the single\n+   destination.  */\n+\n+static void\n+create_edge_and_update_destination_phis (struct redirection_data *rd)\n+{\n+  edge e = make_edge (rd->dup_block, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n+  tree phi;\n+\n+  /* If there are any PHI nodes at the destination of the outgoing edge\n+     from the duplicate block, then we will need to add a new argument\n+     to them.  The argument should have the same value as the argument\n+     associated with the outgoing edge stored in RD.  */\n+  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+    {\n+      int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n+      add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx), e);\n+    }\n+}\n+\n+/* Hash table traversal callback routine to create duplicate blocks.  */\n+\n+static int\n+create_duplicates (void **slot, void *data)\n+{\n+  struct redirection_data *rd = (struct redirection_data *) *slot;\n+  struct local_info *local_info = (struct local_info *)data;\n+\n+  /* If this entry should not have a duplicate created, then there's\n+     nothing to do.  */\n+  if (rd->do_not_duplicate)\n+    return 1;\n+\n+  /* Create a template block if we have not done so already.  Otherwise\n+     use the template to create a new block.  */\n+  if (local_info->template_block == NULL)\n+    {\n+      create_block_for_threading (local_info->bb, rd);\n+      local_info->template_block = rd->dup_block;\n+\n+      /* We do not create any outgoing edges for the template.  We will\n+\t take care of that in a later traversal.  That way we do not\n+\t create edges that are going to just be deleted.  */\n+    }\n+  else\n+    {\n+      create_block_for_threading (local_info->template_block, rd);\n+\n+      /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n+         block.  */\n+      create_edge_and_update_destination_phis (rd);\n+    }\n+\n+  /* Keep walking the hash table.  */\n+  return 1;\n+}\n+\n+/* We did not create any outgoing edges for the template block during\n+   block creation.  This hash table traversal callback creates the\n+   outgoing edge for the template block.  */\n+\n+static int\n+fixup_template_block (void **slot, void *data)\n+{\n+  struct redirection_data *rd = (struct redirection_data *) *slot;\n+  struct local_info *local_info = (struct local_info *)data;\n+\n+  /* If this is the template block, then create its outgoing edges\n+     and halt the hash table traversal.  */\n+  if (rd->dup_block && rd->dup_block == local_info->template_block)\n+    {\n+      create_edge_and_update_destination_phis (rd);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Hash table traversal callback to redirect each incoming edge\n+   associated with this hash table element to its new destination.  */\n+\n+static int\n+redirect_edges (void **slot, void *data)\n+{\n+  struct redirection_data *rd = (struct redirection_data *) *slot;\n+  struct local_info *local_info = (struct local_info *)data;\n+  struct el *next, *el;\n+\n+  /* Walk over all the incoming edges associated associated with this\n+     hash table entry.  */\n+  for (el = rd->incoming_edges; el; el = next)\n+    {\n+      edge e = el->e;\n+\n+      /* Go ahead and free this element from the list.  Doing this now\n+\t avoids the need for another list walk when we destroy the hash\n+\t table.  */\n+      next = el->next;\n+      free (el);\n+\n+      /* Go ahead and clear E->aux.  It's not needed anymore and failure\n+         to clear it will cause all kinds of unpleasant problems later.  */\n+      e->aux = NULL;\n+\n+      if (rd->dup_block)\n+\t{\n+\t  edge e2;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n+\t\t     e->src->index, e->dest->index, rd->dup_block->index);\n+\n+\t  /* Redirect the incoming edge to the appropriate duplicate\n+\t     block.  */\n+\t  e2 = redirect_edge_and_branch (e, rd->dup_block);\n+\t  flush_pending_stmts (e2);\n+\n+\t  if ((dump_file && (dump_flags & TDF_DETAILS))\n+\t      && e->src != e2->src)\n+\t    fprintf (dump_file, \"    basic block %d created\\n\", e2->src->index);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n+\t\t     e->src->index, e->dest->index, local_info->bb->index);\n+\n+\t  /* We are using BB as the duplicate.  Remove the unnecessary\n+\t     outgoing edges and statements from BB.  */\n+\t  remove_ctrl_stmt_and_useless_edges (local_info->bb,\n+\t\t\t\t\t      rd->outgoing_edge->dest);\n+\n+\t  /* And fixup the flags on the single remaining edge.  */\n+\t  EDGE_SUCC (local_info->bb, 0)->flags\n+\t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\t  EDGE_SUCC (local_info->bb, 0)->flags |= EDGE_FALLTHRU;\n+\t}\n+    }\n+  return 1;\n+}\n+\n /* BB is a block which ends with a COND_EXPR or SWITCH_EXPR and when BB\n    is reached via one or more specific incoming edges, we know which\n    outgoing edge from BB will be traversed.\n \n-   We want to redirect those incoming edges to the target of the \n+   We want to redirect those incoming edges to the target of the\n    appropriate outgoing edge.  Doing so avoids a conditional branch\n    and may expose new optimization opportunities.  Note that we have\n    to update dominator tree and SSA graph after such changes.\n@@ -187,19 +460,23 @@ thread_block (basic_block bb)\n      redirect to a duplicate of BB.  */\n   edge e;\n   edge_iterator ei;\n-  basic_block template_block;\n+  struct local_info local_info;\n \n   /* ALL indicates whether or not all incoming edges into BB should\n      be threaded to a duplicate of BB.  */\n   bool all = true;\n \n-  unsigned int i;\n-\n-  VARRAY_GENERIC_PTR_INIT (redirection_data, 2, \"redirection data\");\n-\n-  /* Look at each incoming edge into BB.  Record each unique outgoing\n-     edge that we want to thread an incoming edge to.  Also note if\n-     all incoming edges are threaded or not.  */\n+  /* To avoid scanning a linear array for the element we need we instead\n+     use a hash table.  For normal code there should be no noticable\n+     difference.  However, if we have a block with a large number of\n+     incoming and outgoing edges such linear searches can get expensive.  */\n+  redirection_data = htab_create (EDGE_COUNT (bb->succs),\n+\t\t\t\t  redirection_data_hash,\n+\t\t\t\t  redirection_data_eq,\n+\t\t\t\t  free);\n+\n+  /* Record each unique threaded destination into a hash table for\n+     efficient lookups.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (!e->aux)\n@@ -208,39 +485,25 @@ thread_block (basic_block bb)\n \t}\n       else\n \t{\n-\t  unsigned int i;\n-\n-\t  /* See if we can find an entry for the destination of this\n-\t     threaded edge that has already been recorded.  */\n-\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n-\t    {\n-\t      struct redirection_data *rd;\n-\t      edge e2;\n-\n-\t      rd = VARRAY_GENERIC_PTR (redirection_data, i);\n-\t      e2 = e->aux;\n-\n-\t      if (e2->dest == rd->outgoing_edge->dest)\n-\t\tbreak;\n-\t    }\n-\n-\t  /* If the loop did not terminate early, then we have a new\n-\t     destination for the incoming threaded edges.  Record it.  */\n-\t  if (i == VARRAY_ACTIVE_SIZE (redirection_data))\n-\t    {\n-\t      struct redirection_data *rd;\n-\n-\t      rd = ggc_alloc_cleared (sizeof (struct redirection_data));\n-\t      rd->outgoing_edge = e->aux;\n-\t      VARRAY_PUSH_GENERIC_PTR (redirection_data, rd);\n-\t    }\n+\t  edge e2 = e->aux;\n+\n+\t  /* Insert the outgoing edge into the hash table if it is not\n+\t     already in the hash table.  */\n+\t  lookup_redirection_data (e2, e, true);\n \t}\n     }\n \n-  /* Now create duplicates of BB.  Note that if all incoming edges are\n-     threaded, then BB is going to become unreachable.  In that case\n-     we use BB for one of the duplicates rather than wasting memory\n-     duplicating BB.  Thus the odd starting condition for the loop.\n+  /* If we are going to thread all incoming edges to an outgoing edge, then\n+     BB will become unreachable.  Rather than just throwing it away, use\n+     it for one of the duplicates.  Mark the first incoming edge with the\n+     DO_NOT_DUPLICATE attribute.  */\n+  if (all)\n+    {\n+      edge e = EDGE_PRED (bb, 0)->aux;\n+      lookup_redirection_data (e, NULL, false)->do_not_duplicate = true;\n+    }\n+\n+  /* Now create duplicates of BB.\n \n      Note that for a block with a high outgoing degree we can waste\n      a lot of time and memory creating and destroying useless edges.\n@@ -249,134 +512,34 @@ thread_block (basic_block bb)\n      tail of the duplicate as well as all outgoing edges from the\n      duplicate.  We then use that duplicate block as a template for\n      the rest of the duplicates.  */\n-  template_block = NULL;\n-  for (i = (all ? 1 : 0); i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n-    {\n-      struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+  local_info.template_block = NULL;\n+  local_info.bb = bb;\n+  htab_traverse (redirection_data, create_duplicates, &local_info);\n \n-      if (template_block == NULL)\n-\t{\n-\t  create_block_for_threading (bb, rd);\n-\t  template_block = rd->dup_block;\n-\t}\n-      else\n-\t{\n-\t  create_block_for_threading (template_block, rd);\n-\t}\n-    }\n-\n-  /* Now created up edges from the duplicate blocks to their new\n-     destinations.  Doing this as a separate loop after block creation\n-     allows us to avoid creating lots of useless edges.  */\n-  for (i = (all ? 1 : 0); i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n-    {\n-      struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n-      tree phi;\n-      edge e;\n+  /* The template does not have an outgoing edge.  Create that outgoing\n+     edge and update PHI nodes as the edge's target as necessary.\n \n-      e = make_edge (rd->dup_block, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n+     We do this after creating all the duplicates to avoid creating\n+     unnecessary edges.  */\n+  htab_traverse (redirection_data, fixup_template_block, &local_info);\n \n-      /* If there are any PHI nodes at the destination of the outgoing edge\n-\t from the duplicate block, then we will need to add a new argument\n-\t to them.  The argument should have the same value as the argument\n-\t associated with the outgoing edge stored in RD.  */\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n-\t  add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx), e);\n-\t}\n-    }\n-\n-  /* The loop above created the duplicate blocks (and the statements\n-     within the duplicate blocks).  This loop creates PHI nodes for the\n-     duplicated blocks and redirects the incoming edges into BB to reach\n-     the duplicates of BB.\n-\n-     Note that redirecting the edge will change e->pred_next, so we have\n-     to hold e->pred_next in a temporary. \n-\n-     If this turns out to be a performance problem, then we could create\n-     a list of incoming edges associated with each entry in \n-     REDIRECTION_DATA and walk over that list of edges instead.  */\n-  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n-    {\n-      edge new_dest = e->aux;\n-\n-      /* E was not threaded, then there is nothing to do.  */\n-      if (!new_dest)\n-\t{\n-\t  ei_next (&ei);\n-\t  continue;\n-\t}\n-\n-      /* Go ahead and clear E->aux.  It's not needed anymore and failure\n-         to clear it will cause all kinds of unpleasant problems later.  */\n-      e->aux = NULL;\n-\n-      /* We know E is an edge we want to thread.  Find the entry associated\n-         with E's new destination in the REDIRECTION_DATA array.  */\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n-\t{\n-\t  struct redirection_data *rd;\n-\n-\t  rd = VARRAY_GENERIC_PTR (redirection_data, i);\n-\n-\t  /* We have found the right entry if the outgoing edge in this\n-\t     entry matches E's new destination.  Note that if we have not\n-\t     created a duplicate block (rd->dup_block is NULL), then we\n-\t     are going to re-use BB as a duplicate and we do not need\n-\t     to create PHI nodes or redirect the edge.  */\n-\t  if (rd->outgoing_edge == new_dest && rd->dup_block)\n-\t    {\n-\t      edge e2;\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t\t e->src->index, e->dest->index, rd->dup_block->index);\n-\n-\t      e2 = redirect_edge_and_branch (e, rd->dup_block);\n-\t      flush_pending_stmts (e2);\n-\n-\t      if ((dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  && e->src != e2->src)\n-\t      fprintf (dump_file, \"    basic block %d created\\n\",\n-\t\t       e2->src->index);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* If all the incoming edges where threaded, then we used BB as one\n-     of the duplicate blocks.  We need to fixup BB in that case so that\n-     it no longer has a COND_EXPR or SWITCH_EXPR and reaches one destination\n-     unconditionally.  */\n-  if (all)\n-    {\n-      struct redirection_data *rd;\n-\n-      rd = VARRAY_GENERIC_PTR (redirection_data, 0);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t EDGE_PRED (bb, 0)->src->index, bb->index,\n-\t\t EDGE_SUCC (bb, 0)->dest->index);\n-\n-      remove_ctrl_stmt_and_useless_edges (bb, rd->outgoing_edge->dest);\n-      EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n-    }\n+  /* The hash table traversals above created the duplicate blocks (and the\n+     statements within the duplicate blocks).  This loop creates PHI nodes for\n+     the duplicated blocks and redirects the incoming edges into BB to reach\n+     the duplicates of BB.  */\n+  htab_traverse (redirection_data, redirect_edges, &local_info);\n \n   /* Done with this block.  Clear REDIRECTION_DATA.  */\n-  VARRAY_CLEAR (redirection_data);\n+  htab_delete (redirection_data);\n+  redirection_data = NULL;\n }\n \n-/* Walk through all blocks and thread incoming edges to the block's \n+/* Walk through all blocks and thread incoming edges to the block's\n    destinations as requested.  This is the only entry point into this\n    file.\n \n    Blocks which have one or more incoming edges have INCOMING_EDGE_THREADED\n    set in the block's annotation.\n-   this routine.\n \n    Each edge that should be threaded has the new destination edge stored in\n    the original edge's AUX field."}]}