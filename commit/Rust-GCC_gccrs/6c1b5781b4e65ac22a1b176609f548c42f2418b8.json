{"sha": "6c1b5781b4e65ac22a1b176609f548c42f2418b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxYjU3ODFiNGU2NWFjMjJhMWIxNzY2MDlmNTQ4YzQyZjI0MThiOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-02-19T15:03:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-02-19T15:03:27Z"}, "message": "re PR fortran/47348 (wrong string length with array constructor)\n\n2011-02-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47348\n\t* trans-array.c (get_array_ctor_all_strlen): Move up in file.\n\t(get_array_ctor_var_strlen): Add block dummy and add call to\n\tget_array_ctor_all_strlen instead of giving up on substrings.\n\tCall gcc_unreachable for default case.\n\t(get_array_ctor_strlen): Add extra argument to in call to\n\tget_array_ctor_var_strlen.\n\n2011-02-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47348\n\t* gfortran.dg/array_constructor_36.f90 : New test.\n\t* gfortran.dg/bounds_check_10.f90 : Change dg-output message to\n\tallow for comparison between different elements of the array\n\tconstructor at different levels of optimization.\n\nFrom-SVN: r170317", "tree": {"sha": "e9d23bf03eee0cad9d9e990d7523934bf76c250e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9d23bf03eee0cad9d9e990d7523934bf76c250e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c1b5781b4e65ac22a1b176609f548c42f2418b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1b5781b4e65ac22a1b176609f548c42f2418b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1b5781b4e65ac22a1b176609f548c42f2418b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1b5781b4e65ac22a1b176609f548c42f2418b8/comments", "author": null, "committer": null, "parents": [{"sha": "27f98305d72a39edb648da5b7a891bee29a04f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27f98305d72a39edb648da5b7a891bee29a04f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27f98305d72a39edb648da5b7a891bee29a04f86"}], "stats": {"total": 153, "additions": 102, "deletions": 51}, "files": [{"sha": "f8aa502dd4aab23931222a3e1961950ccccd4f53", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6c1b5781b4e65ac22a1b176609f548c42f2418b8", "patch": "@@ -1,3 +1,13 @@\n+2011-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47348\n+\t* trans-array.c (get_array_ctor_all_strlen): Move up in file.\n+\t(get_array_ctor_var_strlen): Add block dummy and add call to\n+\tget_array_ctor_all_strlen instead of giving up on substrings.\n+\tCall gcc_unreachable for default case.\n+\t(get_array_ctor_strlen): Add extra argument to in call to\n+\tget_array_ctor_var_strlen.\n+\n 2011-02-18  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47789"}, {"sha": "83f0189de757b01febe9b01f533efe6d63371f7e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=6c1b5781b4e65ac22a1b176609f548c42f2418b8", "patch": "@@ -1495,11 +1495,55 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n }\n \n \n+/* A catch-all to obtain the string length for anything that is not a\n+   a substring of non-constant length, a constant, array or variable.  */\n+\n+static void\n+get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n+{\n+  gfc_se se;\n+  gfc_ss *ss;\n+\n+  /* Don't bother if we already know the length is a constant.  */\n+  if (*len && INTEGER_CST_P (*len))\n+    return;\n+\n+  if (!e->ref && e->ts.u.cl && e->ts.u.cl->length\n+\t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+    {\n+      /* This is easy.  */\n+      gfc_conv_const_charlen (e->ts.u.cl);\n+      *len = e->ts.u.cl->backend_decl;\n+    }\n+  else\n+    {\n+      /* Otherwise, be brutal even if inefficient.  */\n+      ss = gfc_walk_expr (e);\n+      gfc_init_se (&se, NULL);\n+\n+      /* No function call, in case of side effects.  */\n+      se.no_function_call = 1;\n+      if (ss == gfc_ss_terminator)\n+\tgfc_conv_expr (&se, e);\n+      else\n+\tgfc_conv_expr_descriptor (&se, e, ss);\n+\n+      /* Fix the value.  */\n+      *len = gfc_evaluate_now (se.string_length, &se.pre);\n+\n+      gfc_add_block_to_block (block, &se.pre);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      e->ts.u.cl->backend_decl = *len;\n+    }\n+}\n+\n+\n /* Figure out the string length of a variable reference expression.\n    Used by get_array_ctor_strlen.  */\n \n static void\n-get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n+get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n {\n   gfc_ref *ref;\n   gfc_typespec *ts;\n@@ -1526,7 +1570,11 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \tcase REF_SUBSTRING:\n \t  if (ref->u.ss.start->expr_type != EXPR_CONSTANT\n \t      || ref->u.ss.end->expr_type != EXPR_CONSTANT)\n-\t    break;\n+\t    {\n+\t      /* Note that this might evaluate expr.  */\n+\t      get_array_ctor_all_strlen (block, expr, len);\n+\t      return;\n+\t    }\n \t  mpz_init_set_ui (char_len, 1);\n \t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n \t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n@@ -1536,60 +1584,14 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \t  return;\n \n \tdefault:\n-\t  /* TODO: Substrings are tricky because we can't evaluate the\n-\t     expression more than once.  For now we just give up, and hope\n-\t     we can figure it out elsewhere.  */\n-\t  return;\n+\t gcc_unreachable ();\n \t}\n     }\n \n   *len = ts->u.cl->backend_decl;\n }\n \n \n-/* A catch-all to obtain the string length for anything that is not a\n-   constant, array or variable.  */\n-static void\n-get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n-{\n-  gfc_se se;\n-  gfc_ss *ss;\n-\n-  /* Don't bother if we already know the length is a constant.  */\n-  if (*len && INTEGER_CST_P (*len))\n-    return;\n-\n-  if (!e->ref && e->ts.u.cl && e->ts.u.cl->length\n-\t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-    {\n-      /* This is easy.  */\n-      gfc_conv_const_charlen (e->ts.u.cl);\n-      *len = e->ts.u.cl->backend_decl;\n-    }\n-  else\n-    {\n-      /* Otherwise, be brutal even if inefficient.  */\n-      ss = gfc_walk_expr (e);\n-      gfc_init_se (&se, NULL);\n-\n-      /* No function call, in case of side effects.  */\n-      se.no_function_call = 1;\n-      if (ss == gfc_ss_terminator)\n-\tgfc_conv_expr (&se, e);\n-      else\n-\tgfc_conv_expr_descriptor (&se, e, ss);\n-\n-      /* Fix the value.  */\n-      *len = gfc_evaluate_now (se.string_length, &se.pre);\n-\n-      gfc_add_block_to_block (block, &se.pre);\n-      gfc_add_block_to_block (block, &se.post);\n-\n-      e->ts.u.cl->backend_decl = *len;\n-    }\n-}\n-\n-\n /* Figure out the string length of a character array constructor.\n    If len is NULL, don't calculate the length; this happens for recursive calls\n    when a sub-array-constructor is an element but not at the first position,\n@@ -1633,7 +1635,7 @@ get_array_ctor_strlen (stmtblock_t *block, gfc_constructor_base base, tree * len\n \tcase EXPR_VARIABLE:\n \t  is_const = false;\n \t  if (len)\n-\t    get_array_ctor_var_strlen (c->expr, len);\n+\t    get_array_ctor_var_strlen (block, c->expr, len);\n \t  break;\n \n \tdefault:"}, {"sha": "f1076f6ffdc80db501356358a248d3dfa43a32f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c1b5781b4e65ac22a1b176609f548c42f2418b8", "patch": "@@ -1,3 +1,21 @@\n+2011-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47348\n+\t* trans-array.c (get_array_ctor_all_strlen): Move up in file.\n+\t(get_array_ctor_var_strlen): Add block dummy and add call to\n+\tget_array_ctor_all_strlen instead of giving up on substrings.\n+\tCall gcc_unreachable for default case.\n+\t(get_array_ctor_strlen): Add extra argument to in call to\n+\tget_array_ctor_var_strlen.\n+\n+2011-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47348\n+\t* gfortran.dg/array_constructor_36.f90 : New test.\n+\t* gfortran.dg/bounds_check_10.f90 : Change dg-output message to\n+\tallow for comparison between different elements of the array\n+\tconstructor at different levels of optimization.\n+\n 2011-02-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/pr31167.c: Require int128 instead of lp64."}, {"sha": "a74d256d95eea2d5acb7f970f7be0751131859d6", "filename": "gcc/testsuite/gfortran.dg/array_constructor_36.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_36.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_36.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_36.f90?ref=6c1b5781b4e65ac22a1b176609f548c42f2418b8", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! Test the fix for PR47348, in which the substring length\n+! in the array constructor at line 19 would be missed and\n+! the length of q used instead.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@netcologne.de>\n+!\n+program main\n+  implicit none\n+  character(len = *), parameter :: fmt='(2(A,\"|\"))'\n+  character(len = *), parameter :: test='xyc|aec|'\n+  integer :: i\n+  character(len = 4) :: q\n+  character(len = 8) :: buffer\n+  q = 'xy'\n+  i = 2\n+  write (buffer, fmt) (/ trim(q), 'ae' /)//'c'\n+  if (buffer .ne. test) Call abort\n+  write (buffer, FMT) (/ q(1:i), 'ae' /)//'c'\n+  if (buffer .ne. test) Call abort\n+end program main"}, {"sha": "66bc308f060f59da1ea7cc44f99d1a1e1378ec01", "filename": "gcc/testsuite/gfortran.dg/bounds_check_10.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c1b5781b4e65ac22a1b176609f548c42f2418b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_10.f90?ref=6c1b5781b4e65ac22a1b176609f548c42f2418b8", "patch": "@@ -12,4 +12,4 @@ program array_char\n z = [trim(x), trim(y), \"aaaa\"] ! [ \"a\", \"cd\", \"aaaa\" ] should catch first error\n end program array_char\n \n-! { dg-output \"Different CHARACTER lengths .1/2. in array constructor\" }\n+! { dg-output \"Different CHARACTER lengths .1/.. in array constructor\" }"}]}