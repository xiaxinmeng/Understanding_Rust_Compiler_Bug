{"sha": "98182da528e7b84a12d0c01e5d8efdb1d0670141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxODJkYTUyOGU3Yjg0YTEyZDBjMDFlNWQ4ZWZkYjFkMDY3MDE0MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-11-17T04:51:25Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-11-17T04:51:25Z"}, "message": "PushbackReader.java: Merged with Classpath.\n\n\t* java/io/PushbackReader.java: Merged with Classpath.\n\t* java/util/Arrays.java: Updated from Classpath.\n\n\t* scripts/blocks.pl: New file.\n\t* java/lang/Character.java (Subset): New class.\n\t(UnicodeBlock): New class.\n\n\t* java/lang/Math.java (toDegrees, toRadians): New methods.\n\n\t* java/lang/Float.java: Implement Comparable.\n\t(compareTo): New methods.\n\t* java/lang/Double.java: Implement Comparable.\n\t(compareTo): New methods.\n\nFrom-SVN: r37512", "tree": {"sha": "589f95defa08868b8681949b702699d1636b17ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/589f95defa08868b8681949b702699d1636b17ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98182da528e7b84a12d0c01e5d8efdb1d0670141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98182da528e7b84a12d0c01e5d8efdb1d0670141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98182da528e7b84a12d0c01e5d8efdb1d0670141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98182da528e7b84a12d0c01e5d8efdb1d0670141/comments", "author": null, "committer": null, "parents": [{"sha": "dd3b81b4218512cfedc271dfde65c6011b6aefe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3b81b4218512cfedc271dfde65c6011b6aefe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3b81b4218512cfedc271dfde65c6011b6aefe9"}], "stats": {"total": 2601, "additions": 1790, "deletions": 811}, "files": [{"sha": "be8dba47ec92fbf7a8fdbdc617d915e145b1e226", "filename": "libjava/java/io/PushbackReader.java", "status": "modified", "additions": 376, "deletions": 87, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Fio%2FPushbackReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Fio%2FPushbackReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackReader.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -1,140 +1,429 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* PushbackReader.java -- An character stream that can unread chars\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 16, 1998.  \n+  * This subclass of <code>FilterReader</code> provides the ability to \n+  * unread data from a stream.  It maintains an internal buffer of unread\n+  * data that is supplied to the next read operation.  This is conceptually\n+  * similar to mark/reset functionality, except that in this case the \n+  * position to reset the stream to does not need to be known in advance.\n+  * <p>\n+  * The default pushback buffer size one char, but this can be overridden\n+  * by the creator of the stream.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  */\n+public class PushbackReader extends FilterReader\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Class Variables\n+ */\n+\n+/**\n+  * This is the default buffer size\n+  */\n+private static final int DEFAULT_BUFFER_SIZE = 1;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n+\n+/**\n+  * This is the buffer that is used to store the pushed back data\n+  */\n+private char[] buf;\n+\n+/**\n+  * This is the position in the buffer from which the next char will be\n+  * read.  Bytes are stored in reverse order in the buffer, starting from\n+  * <code>buf[buf.length - 1]</code> to <code>buf[0]</code>.  Thus when \n+  * <code>pos</code> is 0 the buffer is full and <code>buf.length</code> when \n+  * it is empty\n+  */\n+private int pos;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n  */\n- \n-public class PushbackReader extends FilterReader\n+\n+/**\n+  * This method initializes a <code>PushbackReader</code> to read from the\n+  * specified subordinate <code>Reader</code> with a default pushback buffer \n+  * size of 1.\n+  *\n+  * @code in The subordinate stream to read from\n+  */\n+public\n+PushbackReader(Reader in)\n+{\n+  this(in, DEFAULT_BUFFER_SIZE);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a <code>PushbackReader</code> to read from the\n+  * specified subordinate <code>Reader</code> with the specified buffer\n+  * size\n+  *\n+  * @param in The subordinate <code>Reader</code> to read from\n+  * @param bufsize The pushback buffer size to use\n+  */\n+public\n+PushbackReader(Reader in, int bufsize)\n+{\n+  super(in);\n+\n+  if (bufsize < 0)\n+    throw new IllegalArgumentException(\"buffer size must be positive\");\n+\n+  buf = new char[bufsize];\n+  pos = bufsize;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method closes the stream and frees any associated resources.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public void\n+close() throws IOException\n {\n-  /* Internal buffer array for data. */\n-  private char[] buf;\n-\n-  /* The current position in the buffer. */\n-  private int pos;\n-\n-  public PushbackReader(Reader in)\n-  {\n-    this(in, 1);\n-  }\n-\n-  public PushbackReader(Reader in, int size)\n-  {\n-    super(in);\n-    if (size < 0)\n-      throw new IllegalArgumentException();\n-    buf = new char[size];\n-    pos = buf.length;\n-  }\n-\n-  public void close() throws IOException\n-  {\n-    synchronized (lock)\n+  synchronized (lock)\n     {\n       buf = null;\n       super.close();\n     }\n-  }\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method throws an exception when called since this class does\n+  * not support mark/reset.\n+  *\n+  * @param read_limit Not used.\n+  *\n+  * @exception IOException Always thrown to indicate mark/reset not supported.\n+  */\n+public void\n+mark(int read_limit) throws IOException\n+{\n+  throw new IOException(\"mark not supported in this class\");\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method returns <code>false</code> to indicate that it does not support\n+  * mark/reset functionality.\n+  *\n+  * @return This method returns <code>false</code> to indicate that this class does not support mark/reset functionality\n+  *\n+  */\n+public boolean\n+markSupported()\n+{\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method always throws an IOException in this class because\n+  * mark/reset functionality is not supported.\n+  *\n+  * @exception IOException Always thrown for this class\n+  */\n+public void\n+reset() throws IOException\n+{\n+  throw new IOException(\"reset not supported in this class\");\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method determines whether or not this stream is ready to be read.\n+  * If it returns <code>false</code> to indicate that the stream is not\n+  * ready, any attempt to read from the stream could (but is not\n+  * guaranteed to) block.\n+  * <p>\n+  * This stream is ready to read if there are either chars waiting to be\n+  * read in the pushback buffer or if the underlying stream is ready to\n+  * be read.\n+  *\n+  * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public boolean\n+ready() throws IOException\n+{\n+  synchronized (lock)\n+    {\n+      if (buf == null)\n+\tthrow new IOException (\"stream closed\");\n+\n+      if (((buf.length - pos) > 0) || super.ready())\n+\treturn(true);\n+      else\n+\treturn(false);\n+    }\n+}\n+\n+/*************************************************************************/\n+\n+// Don't delete this method just because the spec says it shouldn't be there!\n+// See the CVS log for details.\n+/**\n+  * This method skips the specified number of chars in the stream.  It\n+  * returns the actual number of chars skipped, which may be less than the\n+  * requested amount.\n+  * <p>\n+  * This method first discards chars from the buffer, then calls the\n+  * <code>skip</code> method on the underlying <code>Reader</code> to \n+  * skip additional chars if necessary.\n+  *\n+  * @param num_chars The requested number of chars to skip\n+  *\n+  * @return The actual number of chars skipped.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public long\n+skip(long num_chars) throws IOException\n+{\n+  synchronized (lock)\n+    {\n+      if (num_chars <= 0)\n+\treturn(0);\n+\n+      if ((buf.length - pos) >= num_chars)\n+\t{\n+\t  pos += num_chars;\n+\t  return(num_chars);\n+\t}\n+\n+      int chars_discarded = buf.length - pos;\n+      pos = buf.length;\n+\n+      long chars_skipped = in.skip(num_chars - chars_discarded);\n \n-  public boolean markSupported()\n-  {\n-    return false;\n-  }\n+      return(chars_discarded + chars_skipped);\n+    } // synchronized\n+}\n+\n+/*************************************************************************/\n \n-  public int read() throws IOException\n-  {\n-    synchronized (lock)\n+/**\n+  * This method reads an unsigned char from the input stream and returns it\n+  * as an int in the range of 0-65535.  This method also will return -1 if\n+  * the end of the stream has been reached.  The char returned will be read\n+  * from the pushback buffer, unless the buffer is empty, in which case\n+  * the char will be read from the underlying stream.\n+  * <p>\n+  * This method will block until the char can be read.\n+  *\n+  * @return The char read or -1 if end of stream\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public int\n+read() throws IOException\n+{\n+  synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"stream closed\");\n \n-      if (pos < buf.length)\n-        return ((int) buf[pos++]) & 0xFFFF;\n+      if (pos == buf.length)\n+\treturn(super.read());\n \n-      return super.read();\n+      ++pos;\n+      return((buf[pos - 1] & 0xFFFF));\n     }\n-  }\n+}\n+\n+/*************************************************************************/\n \n-  public int read(char[] b, int off, int len) throws IOException\n-  {\n-    synchronized (lock)\n+/**\n+  * This method read chars from a stream and stores them into a caller\n+  * supplied buffer.  It starts storing the data at index <code>offset</code> into\n+  * the buffer and attempts to read <code>len</code> chars.  This method can\n+  * return before reading the number of chars requested.  The actual number\n+  * of chars read is returned as an int.  A -1 is returned to indicate the\n+  * end of the stream.\n+  *  <p>\n+  * This method will block until some data can be read.\n+  * <p>\n+  * This method first reads chars from the pushback buffer in order to \n+  * satisfy the read request.  If the pushback buffer cannot provide all\n+  * of the chars requested, the remaining chars are read from the \n+  * underlying stream.\n+  *\n+  * @param buf The array into which the chars read should be stored\n+  * @param offset The offset into the array to start storing chars\n+  * @param len The requested number of chars to read\n+  *\n+  * @return The actual number of chars read, or -1 if end of stream.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public synchronized int\n+read(char[] b, int offset, int len) throws IOException\n+{\n+  synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+        throw new IOException(\"stream closed\");\n \n-      if (off < 0 || len < 0 || off + len > b.length)\n+      if (offset < 0 || len < 0 || offset + len > b.length)\n         throw new ArrayIndexOutOfBoundsException();\n \n       int numBytes = Math.min(buf.length - pos, len);\n       if (numBytes > 0)\n \t{\n-\t  System.arraycopy (buf, pos, b, off, numBytes);\n+\t  System.arraycopy (buf, pos, b, offset, numBytes);\n \t  pos += numBytes;\n \t  return numBytes;\n \t}\n \n-      return super.read(b, off, len);\n+      return super.read(b, offset, len);\n     }\n-  }\n+}\n \n-  public boolean ready() throws IOException\n-  {\n-    synchronized (lock)\n+/*************************************************************************/\n+\n+/**\n+  * This method pushes a single char of data into the pushback buffer.\n+  * The char pushed back is the one that will be returned as the first char\n+  * of the next read.\n+  * <p>\n+  * If the pushback buffer is full, this method throws an exception.\n+  * <p>\n+  * The argument to this method is an <code>int</code>.  Only the low eight bits\n+  * of this value are pushed back.\n+  *\n+  * @param b The char to be pushed back, passed as an int\n+  *\n+  * @exception IOException If the pushback buffer is full.\n+  */\n+public void\n+unread(int b) throws IOException\n+{\n+  synchronized (lock)\n     {\n       if (buf == null)\n-        throw new IOException();\n+\tthrow new IOException(\"stream closed\");\n+      if (pos == 0)\n+\tthrow new IOException(\"Pushback buffer is full\");\n \n-      if (buf.length - pos > 0)\n-        return true;\n-\n-      return super.ready();\n-    }\n-  }\n+      --pos;\n+      buf[pos] = (char)(b & 0xFFFF);\n+    } // synchronized\n+}\n \n-  public void unread(int b) throws IOException\n-  {\n-    synchronized (lock)\n-    {\n-      if (buf == null || pos <= 0)\n-        throw new IOException();\n+/*************************************************************************/\n \n-      buf[--pos] = (char) b;\n-    }\n-  }\n+/**\n+  * This method pushes all of the chars in the passed char array into \n+  * the pushback buffer.  These chars are pushed in reverse order so that\n+  * the next char read from the stream after this operation will be\n+  * <code>buf[0]</code> followed by <code>buf[1]</code>, etc.\n+  * <p>\n+  * If the pushback buffer cannot hold all of the requested chars, an\n+  * exception is thrown.\n+  *\n+  * @param buf The char array to be pushed back\n+  *\n+  * @exception IOException If the pushback buffer is full\n+  */\n+public synchronized void\n+unread(char[] buf) throws IOException\n+{\n+  unread(buf, 0, buf.length);\n+}\n \n-  public void unread(char[] b) throws IOException\n-  {\n-    unread(b, 0, b.length);\n-  }\n+/*************************************************************************/\n \n-  public void unread(char[] b, int off, int len) throws IOException\n-  {\n-    synchronized (lock)\n+/**\n+  * This method pushed back chars from the passed in array into the pushback\n+  * buffer.  The chars from <code>buf[offset]</code> to <cdoe>buf[offset + len]</code>\n+  * are pushed in reverse order so that the next char read from the stream\n+  * after this operation will be <code>buf[offset]</code> followed by\n+  * <code>buf[offset + 1]</code>, etc.\n+  * <p>\n+  * If the pushback buffer cannot hold all of the requested chars, an\n+  * exception is thrown.\n+  *\n+  * @param buf The char array to be pushed back\n+  * @param offset The index into the array where the chars to be push start\n+  * @param len The number of chars to be pushed.\n+  *\n+  * @exception IOException If the pushback buffer is full\n+  */\n+public synchronized void\n+unread(char[] b, int offset, int len) throws IOException\n+{\n+  synchronized (lock)\n     {\n-      if (buf == null || pos < len)\n-        throw new IOException();\n+      if (buf == null)\n+        throw new IOException(\"stream closed\");\n+      if (pos < len)\n+\tthrow new IOException(\"Pushback buffer is full\");\n \n       // Note the order that these chars are being added is the opposite\n       // of what would be done if they were added to the buffer one at a time.\n       // See the Java Class Libraries book p. 1397.\n-      System.arraycopy(b, off, buf, pos - len, len);\n+      System.arraycopy(b, offset, buf, pos - len, len);\n \n       // Don't put this into the arraycopy above, an exception might be thrown\n       // and in that case we don't want to modify pos.\n       pos -= len;\n     }\n-  }\n }\n+\n+} // class PushbackReader"}, {"sha": "cdb3957578e19045d3108393caf2cccac2f699fe", "filename": "libjava/java/lang/Character.java", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -284,4 +284,208 @@ public int compareTo (Object o)\n \n   // Private data.\n   private char value;\n+\n+  public static class Subset\n+  {\n+    protected Subset (String name)\n+    {\n+      this.name = name;\n+    }\n+\n+    public final boolean equals (Object obj)\n+    {\n+      return obj == this;\n+    }\n+\n+    public final int hashCode ()\n+    {\n+      return super.hashCode ();\n+    }\n+\n+    public final String toString ()\n+    {\n+      return name;\n+    }\n+\n+    // Name of this subset.\n+    private String name;\n+  }\n+\n+  public static final class UnicodeBlock extends Subset\n+  {\n+    private UnicodeBlock (String name, char start, char end)\n+    {\n+      super (name);\n+      this.start = start;\n+      this.end = end;\n+    }\n+\n+    public static UnicodeBlock of (char c)\n+    {\n+      // A special case we need.\n+      if (c == '\\uFEFF')\n+\treturn SPECIALS;\n+\n+      // Do a binary search to find the correct subset.\n+      int hi = blocks.length;\n+      int lo = 0;\n+      while (hi > lo)\n+\t{\n+\t  int mid = (hi + lo) / 2;\n+\t  UnicodeBlock ub = blocks[mid];\n+\t  if (c < ub.start)\n+\t    hi = mid;\n+\t  else if (c > ub.end)\n+\t    lo = mid;\n+\t  else\n+\t    return ub;\n+\t}\n+\n+      return null;\n+    }\n+\n+    // Start and end characters.\n+    private char start, end;\n+\n+    // Everything from here to the end of UnicodeBlock is\n+    // automatically generated by the blocks.pl script.\n+    public static final UnicodeBlock BASIC_LATIN = new UnicodeBlock (\"Basic Latin\", '\\u0000', '\\u007F');\n+    public static final UnicodeBlock LATIN_1_SUPPLEMENT = new UnicodeBlock (\"Latin-1 Supplement\", '\\u0080', '\\u00FF');\n+    public static final UnicodeBlock LATIN_EXTENDED_A = new UnicodeBlock (\"Latin Extended-A\", '\\u0100', '\\u017F');\n+    public static final UnicodeBlock LATIN_EXTENDED_B = new UnicodeBlock (\"Latin Extended-B\", '\\u0180', '\\u024F');\n+    public static final UnicodeBlock IPA_EXTENSIONS = new UnicodeBlock (\"IPA Extensions\", '\\u0250', '\\u02AF');\n+    public static final UnicodeBlock SPACING_MODIFIER_LETTERS = new UnicodeBlock (\"Spacing Modifier Letters\", '\\u02B0', '\\u02FF');\n+    public static final UnicodeBlock COMBINING_DIACRITICAL_MARKS = new UnicodeBlock (\"Combining Diacritical Marks\", '\\u0300', '\\u036F');\n+    public static final UnicodeBlock GREEK = new UnicodeBlock (\"Greek\", '\\u0370', '\\u03FF');\n+    public static final UnicodeBlock CYRILLIC = new UnicodeBlock (\"Cyrillic\", '\\u0400', '\\u04FF');\n+    public static final UnicodeBlock ARMENIAN = new UnicodeBlock (\"Armenian\", '\\u0530', '\\u058F');\n+    public static final UnicodeBlock HEBREW = new UnicodeBlock (\"Hebrew\", '\\u0590', '\\u05FF');\n+    public static final UnicodeBlock ARABIC = new UnicodeBlock (\"Arabic\", '\\u0600', '\\u06FF');\n+    public static final UnicodeBlock DEVANAGARI = new UnicodeBlock (\"Devanagari\", '\\u0900', '\\u097F');\n+    public static final UnicodeBlock BENGALI = new UnicodeBlock (\"Bengali\", '\\u0980', '\\u09FF');\n+    public static final UnicodeBlock GURMUKHI = new UnicodeBlock (\"Gurmukhi\", '\\u0A00', '\\u0A7F');\n+    public static final UnicodeBlock GUJARATI = new UnicodeBlock (\"Gujarati\", '\\u0A80', '\\u0AFF');\n+    public static final UnicodeBlock ORIYA = new UnicodeBlock (\"Oriya\", '\\u0B00', '\\u0B7F');\n+    public static final UnicodeBlock TAMIL = new UnicodeBlock (\"Tamil\", '\\u0B80', '\\u0BFF');\n+    public static final UnicodeBlock TELUGU = new UnicodeBlock (\"Telugu\", '\\u0C00', '\\u0C7F');\n+    public static final UnicodeBlock KANNADA = new UnicodeBlock (\"Kannada\", '\\u0C80', '\\u0CFF');\n+    public static final UnicodeBlock MALAYALAM = new UnicodeBlock (\"Malayalam\", '\\u0D00', '\\u0D7F');\n+    public static final UnicodeBlock THAI = new UnicodeBlock (\"Thai\", '\\u0E00', '\\u0E7F');\n+    public static final UnicodeBlock LAO = new UnicodeBlock (\"Lao\", '\\u0E80', '\\u0EFF');\n+    public static final UnicodeBlock TIBETAN = new UnicodeBlock (\"Tibetan\", '\\u0F00', '\\u0FBF');\n+    public static final UnicodeBlock GEORGIAN = new UnicodeBlock (\"Georgian\", '\\u10A0', '\\u10FF');\n+    public static final UnicodeBlock HANGUL_JAMO = new UnicodeBlock (\"Hangul Jamo\", '\\u1100', '\\u11FF');\n+    public static final UnicodeBlock LATIN_EXTENDED_ADDITIONAL = new UnicodeBlock (\"Latin Extended Additional\", '\\u1E00', '\\u1EFF');\n+    public static final UnicodeBlock GREEK_EXTENDED = new UnicodeBlock (\"Greek Extended\", '\\u1F00', '\\u1FFF');\n+    public static final UnicodeBlock GENERAL_PUNCTUATION = new UnicodeBlock (\"General Punctuation\", '\\u2000', '\\u206F');\n+    public static final UnicodeBlock SUPERSCRIPTS_AND_SUBSCRIPTS = new UnicodeBlock (\"Superscripts and Subscripts\", '\\u2070', '\\u209F');\n+    public static final UnicodeBlock CURRENCY_SYMBOLS = new UnicodeBlock (\"Currency Symbols\", '\\u20A0', '\\u20CF');\n+    public static final UnicodeBlock COMBINING_MARKS_FOR_SYMBOLS = new UnicodeBlock (\"Combining Marks for Symbols\", '\\u20D0', '\\u20FF');\n+    public static final UnicodeBlock LETTERLIKE_SYMBOLS = new UnicodeBlock (\"Letterlike Symbols\", '\\u2100', '\\u214F');\n+    public static final UnicodeBlock NUMBER_FORMS = new UnicodeBlock (\"Number Forms\", '\\u2150', '\\u218F');\n+    public static final UnicodeBlock ARROWS = new UnicodeBlock (\"Arrows\", '\\u2190', '\\u21FF');\n+    public static final UnicodeBlock MATHEMATICAL_OPERATORS = new UnicodeBlock (\"Mathematical Operators\", '\\u2200', '\\u22FF');\n+    public static final UnicodeBlock MISCELLANEOUS_TECHNICAL = new UnicodeBlock (\"Miscellaneous Technical\", '\\u2300', '\\u23FF');\n+    public static final UnicodeBlock CONTROL_PICTURES = new UnicodeBlock (\"Control Pictures\", '\\u2400', '\\u243F');\n+    public static final UnicodeBlock OPTICAL_CHARACTER_RECOGNITION = new UnicodeBlock (\"Optical Character Recognition\", '\\u2440', '\\u245F');\n+    public static final UnicodeBlock ENCLOSED_ALPHANUMERICS = new UnicodeBlock (\"Enclosed Alphanumerics\", '\\u2460', '\\u24FF');\n+    public static final UnicodeBlock BOX_DRAWING = new UnicodeBlock (\"Box Drawing\", '\\u2500', '\\u257F');\n+    public static final UnicodeBlock BLOCK_ELEMENTS = new UnicodeBlock (\"Block Elements\", '\\u2580', '\\u259F');\n+    public static final UnicodeBlock GEOMETRIC_SHAPES = new UnicodeBlock (\"Geometric Shapes\", '\\u25A0', '\\u25FF');\n+    public static final UnicodeBlock MISCELLANEOUS_SYMBOLS = new UnicodeBlock (\"Miscellaneous Symbols\", '\\u2600', '\\u26FF');\n+    public static final UnicodeBlock DINGBATS = new UnicodeBlock (\"Dingbats\", '\\u2700', '\\u27BF');\n+    public static final UnicodeBlock CJK_SYMBOLS_AND_PUNCTUATION = new UnicodeBlock (\"CJK Symbols and Punctuation\", '\\u3000', '\\u303F');\n+    public static final UnicodeBlock HIRAGANA = new UnicodeBlock (\"Hiragana\", '\\u3040', '\\u309F');\n+    public static final UnicodeBlock KATAKANA = new UnicodeBlock (\"Katakana\", '\\u30A0', '\\u30FF');\n+    public static final UnicodeBlock BOPOMOFO = new UnicodeBlock (\"Bopomofo\", '\\u3100', '\\u312F');\n+    public static final UnicodeBlock HANGUL_COMPATIBILITY_JAMO = new UnicodeBlock (\"Hangul Compatibility Jamo\", '\\u3130', '\\u318F');\n+    public static final UnicodeBlock KANBUN = new UnicodeBlock (\"Kanbun\", '\\u3190', '\\u319F');\n+    public static final UnicodeBlock ENCLOSED_CJK_LETTERS_AND_MONTHS = new UnicodeBlock (\"Enclosed CJK Letters and Months\", '\\u3200', '\\u32FF');\n+    public static final UnicodeBlock CJK_COMPATIBILITY = new UnicodeBlock (\"CJK Compatibility\", '\\u3300', '\\u33FF');\n+    public static final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS = new UnicodeBlock (\"CJK Unified Ideographs\", '\\u4E00', '\\u9FFF');\n+    public static final UnicodeBlock HANGUL_SYLLABLES = new UnicodeBlock (\"Hangul Syllables\", '\\uAC00', '\\uD7A3');\n+    public static final UnicodeBlock HIGH_SURROGATES = new UnicodeBlock (\"High Surrogates\", '\\uD800', '\\uDB7F');\n+    public static final UnicodeBlock HIGH_PRIVATE_USE_SURROGATES = new UnicodeBlock (\"High Private Use Surrogates\", '\\uDB80', '\\uDBFF');\n+    public static final UnicodeBlock LOW_SURROGATES = new UnicodeBlock (\"Low Surrogates\", '\\uDC00', '\\uDFFF');\n+    public static final UnicodeBlock PRIVATE_USE = new UnicodeBlock (\"Private Use\", '\\uE000', '\\uF8FF');\n+    public static final UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS = new UnicodeBlock (\"CJK Compatibility Ideographs\", '\\uF900', '\\uFAFF');\n+    public static final UnicodeBlock ALPHABETIC_PRESENTATION_FORMS = new UnicodeBlock (\"Alphabetic Presentation Forms\", '\\uFB00', '\\uFB4F');\n+    public static final UnicodeBlock ARABIC_PRESENTATION_FORMS_A = new UnicodeBlock (\"Arabic Presentation Forms-A\", '\\uFB50', '\\uFDFF');\n+    public static final UnicodeBlock COMBINING_HALF_MARKS = new UnicodeBlock (\"Combining Half Marks\", '\\uFE20', '\\uFE2F');\n+    public static final UnicodeBlock CJK_COMPATIBILITY_FORMS = new UnicodeBlock (\"CJK Compatibility Forms\", '\\uFE30', '\\uFE4F');\n+    public static final UnicodeBlock SMALL_FORM_VARIANTS = new UnicodeBlock (\"Small Form Variants\", '\\uFE50', '\\uFE6F');\n+    public static final UnicodeBlock ARABIC_PRESENTATION_FORMS_B = new UnicodeBlock (\"Arabic Presentation Forms-B\", '\\uFE70', '\\uFEFE');\n+    public static final UnicodeBlock HALFWIDTH_AND_FULLWIDTH_FORMS = new UnicodeBlock (\"Halfwidth and Fullwidth Forms\", '\\uFF00', '\\uFFEF');\n+    public static final UnicodeBlock SPECIALS = new UnicodeBlock (\"Specials\", '\\uFFF0', '\\uFFFD');\n+    private static final UnicodeBlock[] blocks = {\n+      BASIC_LATIN,\n+      LATIN_1_SUPPLEMENT,\n+      LATIN_EXTENDED_A,\n+      LATIN_EXTENDED_B,\n+      IPA_EXTENSIONS,\n+      SPACING_MODIFIER_LETTERS,\n+      COMBINING_DIACRITICAL_MARKS,\n+      GREEK,\n+      CYRILLIC,\n+      ARMENIAN,\n+      HEBREW,\n+      ARABIC,\n+      DEVANAGARI,\n+      BENGALI,\n+      GURMUKHI,\n+      GUJARATI,\n+      ORIYA,\n+      TAMIL,\n+      TELUGU,\n+      KANNADA,\n+      MALAYALAM,\n+      THAI,\n+      LAO,\n+      TIBETAN,\n+      GEORGIAN,\n+      HANGUL_JAMO,\n+      LATIN_EXTENDED_ADDITIONAL,\n+      GREEK_EXTENDED,\n+      GENERAL_PUNCTUATION,\n+      SUPERSCRIPTS_AND_SUBSCRIPTS,\n+      CURRENCY_SYMBOLS,\n+      COMBINING_MARKS_FOR_SYMBOLS,\n+      LETTERLIKE_SYMBOLS,\n+      NUMBER_FORMS,\n+      ARROWS,\n+      MATHEMATICAL_OPERATORS,\n+      MISCELLANEOUS_TECHNICAL,\n+      CONTROL_PICTURES,\n+      OPTICAL_CHARACTER_RECOGNITION,\n+      ENCLOSED_ALPHANUMERICS,\n+      BOX_DRAWING,\n+      BLOCK_ELEMENTS,\n+      GEOMETRIC_SHAPES,\n+      MISCELLANEOUS_SYMBOLS,\n+      DINGBATS,\n+      CJK_SYMBOLS_AND_PUNCTUATION,\n+      HIRAGANA,\n+      KATAKANA,\n+      BOPOMOFO,\n+      HANGUL_COMPATIBILITY_JAMO,\n+      KANBUN,\n+      ENCLOSED_CJK_LETTERS_AND_MONTHS,\n+      CJK_COMPATIBILITY,\n+      CJK_UNIFIED_IDEOGRAPHS,\n+      HANGUL_SYLLABLES,\n+      HIGH_SURROGATES,\n+      HIGH_PRIVATE_USE_SURROGATES,\n+      LOW_SURROGATES,\n+      PRIVATE_USE,\n+      CJK_COMPATIBILITY_IDEOGRAPHS,\n+      ALPHABETIC_PRESENTATION_FORMS,\n+      ARABIC_PRESENTATION_FORMS_A,\n+      COMBINING_HALF_MARKS,\n+      CJK_COMPATIBILITY_FORMS,\n+      SMALL_FORM_VARIANTS,\n+      ARABIC_PRESENTATION_FORMS_B,\n+      HALFWIDTH_AND_FULLWIDTH_FORMS,\n+      SPECIALS\n+    };\n+  }\n }"}, {"sha": "8de429e4fc43b393b5a88cc5e83f4b885bf1eced", "filename": "libjava/java/lang/Double.java", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FDouble.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -18,7 +18,7 @@\n  * Status:  Believed complete and correct.\n  */\n \n-public final class Double extends Number\n+public final class Double extends Number implements Comparable\n {\n   public static final double MIN_VALUE = 5e-324;\n   public static final double MAX_VALUE = 1.7976931348623157e+308;\n@@ -147,5 +147,26 @@ public static boolean isInfinite (double v)\n   public static native long doubleToLongBits (double value);\n \n   public static native double longBitsToDouble (long bits);\n-}\n \n+  public int compareTo (Double d)\n+  {\n+    double v = d.value;\n+    if (isNaN (value))\n+      return isNaN (v) ? 1 : 0;\n+    else if (isNaN (v))\n+      return -1;\n+    else if (value == 0.0 && v == -0.0)\n+      return 1;\n+    else if (value == -0.0 && v == 0.0)\n+      return -1;\n+    else if (value == v)\n+      return 0;\n+\n+    return value > v ? 1 : -1;\n+  }\n+\n+  public int compareTo (Object o)\n+  {\n+    return compareTo ((Double) o);\n+  }\n+}"}, {"sha": "573375238dff8741164a81413bac7c16575296e8", "filename": "libjava/java/lang/Float.java", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFloat.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -18,7 +18,7 @@\n  * Status:  Believed complete and correct.\n  */\n \n-public final class Float extends Number\n+public final class Float extends Number implements Comparable\n {\n   public static final float MAX_VALUE = 3.4028235e+38f;\n   public static final float MIN_VALUE = 1.4e-45f;\n@@ -147,5 +147,25 @@ public static boolean isInfinite (float v)\n \n   public static native float intBitsToFloat (int bits);\n \n-}\n+  public int compareTo (Float d)\n+  {\n+    float v = d.value;\n+    if (isNaN (value))\n+      return isNaN (v) ? 1 : 0;\n+    else if (isNaN (v))\n+      return -1;\n+    else if (value == 0.0 && v == -0.0)\n+      return 1;\n+    else if (value == -0.0 && v == 0.0)\n+      return -1;\n+    else if (value == v)\n+      return 0;\n+\n+    return value > v ? 1 : -1;\n+  }\n \n+  public int compareTo (Object o)\n+  {\n+    return compareTo ((Float) o);\n+  }\n+}"}, {"sha": "8e3311205a4ed239e60f30694e622d452c6ed909", "filename": "libjava/java/lang/Math.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FMath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Flang%2FMath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FMath.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -110,6 +110,16 @@ public static long max (long a, long b)\n \n   public static native double max (double a, double b);\n \n+  public static double toDegrees (double radians)\n+  {\n+    return radians * 180 / PI;\n+  }\n+\n+  public static double toRadians (double degrees)\n+  {\n+    return degrees * PI / 180;\n+  }\n+\n   // Don't allow objects to be made.\n   private Math ()\n   {"}, {"sha": "b97f457be518c9557f29035086668c23c1885d48", "filename": "libjava/java/util/Arrays.java", "status": "modified", "additions": 1106, "deletions": 719, "changes": 1825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Futil%2FArrays.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fjava%2Futil%2FArrays.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrays.java?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -1,13 +1,13 @@\n /* Arrays.java -- Utility class with methods to operate on arrays\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,17 +36,20 @@\n  * arrays, and a method to provide a List \"view\" of an array to facilitate\n  * using arrays with Collection-based APIs.\n  */\n-public class Arrays {\n-\n+public class Arrays\n+{\n   /**\n    * This class is non-instantiable.\n    */\n-  private Arrays() {\n+  private Arrays()\n+  {\n   }\n \n-  private static Comparator defaultComparator = new Comparator() {\n-    public int compare(Object o1, Object o2) {\n-      return ((Comparable)o1).compareTo(o2);\n+  private static Comparator defaultComparator = new Comparator()\n+  {\n+    public int compare(Object o1, Object o2)\n+    {\n+      return ((Comparable) o1).compareTo(o2);\n     }\n   };\n \n@@ -64,21 +67,29 @@ public int compare(Object o1, Object o2) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(byte[] a, byte key) {\n+  public static int binarySearch(byte[]a, byte key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final byte d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal byte d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -96,21 +107,29 @@ public static int binarySearch(byte[] a, byte key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(char[] a, char key) {\n+  public static int binarySearch(char[]a, char key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final char d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal char d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -128,21 +147,29 @@ public static int binarySearch(char[] a, char key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(double[] a, double key) {\n+  public static int binarySearch(double[]a, double key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final double d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal double d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -160,21 +187,29 @@ public static int binarySearch(double[] a, double key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(float[] a, float key) {\n+  public static int binarySearch(float[]a, float key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final float d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal float d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -192,21 +227,29 @@ public static int binarySearch(float[] a, float key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(int[] a, int key) {\n+  public static int binarySearch(int[]a, int key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final int d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal int d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -224,21 +267,29 @@ public static int binarySearch(int[] a, int key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(long[] a, long key) {\n+  public static int binarySearch(long[]a, long key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final long d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal long d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -256,21 +307,29 @@ public static int binarySearch(long[] a, long key) {\n    *   found, where n is the index of the first value higher than key or\n    *   a.length if there is no such value.\n    */\n-  public static int binarySearch(short[] a, short key) {\n+  public static int binarySearch(short[]a, short key)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final short d = a[mid];\n-      if (d == key) {\n-        return mid;\n-      } else if (d > key) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal short d = a[mid];\n+\tif (d == key)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d > key)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -279,21 +338,29 @@ public static int binarySearch(short[] a, short key) {\n    * @exception NullPointerException if the specified comparator is null.\n    * @exception ClassCastException if the objects are not comparable by c.\n    */\n-  private static int objectSearch(Object[] a, Object key, final Comparator c) {\n+  private static int objectSearch(Object[]a, Object key, final Comparator c)\n+  {\n     int low = 0;\n     int hi = a.length - 1;\n     int mid = 0;\n-    while (low <= hi) {\n-      mid = (low + hi) >> 1;\n-      final int d = c.compare(key, a[mid]);\n-      if (d == 0) {\n-        return mid;\n-      } else if (d < 0) {\n-        hi = mid - 1;\n-      } else {\n-        low = ++mid; // This gets the insertion point right on the last loop\n+    while (low <= hi)\n+      {\n+\tmid = (low + hi) >> 1;\n+\tfinal int d = c.compare(key, a[mid]);\n+\tif (d == 0)\n+\t  {\n+\t    return mid;\n+\t  }\n+\telse if (d < 0)\n+\t  {\n+\t    hi = mid - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    // This gets the insertion point right on the last loop\n+\t    low = ++mid;\n+\t  }\t    \n       }\n-    }\n     return -mid - 1;\n   }\n \n@@ -316,7 +383,8 @@ private static int objectSearch(Object[] a, Object key, final Comparator c) {\n    *   elements of a\n    * @exception NullPointerException if a null element has compareTo called\n    */\n-  public static int binarySearch(Object[] a, Object key) {\n+  public static int binarySearch(Object[]a, Object key)\n+  {\n     return objectSearch(a, key, defaultComparator);\n   }\n \n@@ -339,7 +407,8 @@ public static int binarySearch(Object[] a, Object key) {\n    * @exception ClassCastException if key could not be compared with one of the\n    *   elements of a\n    */\n-  public static int binarySearch(Object[] a, Object key, Comparator c) {\n+  public static int binarySearch(Object[]a, Object key, Comparator c)\n+  {\n     return objectSearch(a, key, c);\n   }\n \n@@ -351,28 +420,35 @@ public static int binarySearch(Object[] a, Object key, Comparator c) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(byte[] a1, byte[] a2) {\n-\n+  public static boolean equals(byte[]a1, byte[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -385,28 +461,35 @@ public static boolean equals(byte[] a1, byte[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(char[] a1, char[] a2) {\n-\n+  public static boolean equals(char[]a1, char[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -419,28 +502,35 @@ public static boolean equals(char[] a1, char[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(double[] a1, double[] a2) {\n-\n+  public static boolean equals(double[]a1, double[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -453,28 +543,35 @@ public static boolean equals(double[] a1, double[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(float[] a1, float[] a2) {\n-\n+  public static boolean equals(float[]a1, float[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -487,28 +584,35 @@ public static boolean equals(float[] a1, float[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(long[] a1, long[] a2) {\n-\n+  public static boolean equals(long[]a1, long[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -521,28 +625,35 @@ public static boolean equals(long[] a1, long[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(short[] a1, short[] a2) {\n-\n+  public static boolean equals(short[]a1, short[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -555,28 +666,35 @@ public static boolean equals(short[] a1, short[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(boolean[] a1, boolean[] a2) {\n-\n+  public static boolean equals(boolean[]a1, boolean[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -589,28 +707,35 @@ public static boolean equals(boolean[] a1, boolean[] a2) {\n    * @returns true if a1 and a2 are both null, or if a2 is of the same length\n    *   as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]\n    */\n-  public static boolean equals(int[] a1, int[] a2) {\n-\n+  public static boolean equals(int[]a1, int[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (a1[i] != a2[i]) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (a1[i] != a2[i])\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -624,28 +749,35 @@ public static boolean equals(int[] a1, int[] a2) {\n    *   as a2, and for each 0 <= i < a.length, a1[i] == null ? a2[i] == null :\n    *   a1[i].equals(a2[i]).\n    */\n-  public static boolean equals(Object[] a1, Object[] a2) {\n-\n+  public static boolean equals(Object[]a1, Object[]a2)\n+  {\n     // Quick test which saves comparing elements of the same array, and also\n     // catches the case that both are null.\n-    if (a1 == a2) {\n-      return true;\n-    }\n-    try {\n-\n-      // If they're the same length, test each element\n-      if (a1.length == a2.length) {\n-        for (int i = 0; i < a1.length; i++) {\n-          if (!(a1[i] == null ? a2[i] == null : a1[i].equals(a2[i]))) {\n-            return false;\n-          }\n-        }\n-        return true;\n+    if (a1 == a2)\n+      {\n+\treturn true;\n       }\n+      \n+    try\n+      {\n+\t// If they're the same length, test each element\n+\tif (a1.length == a2.length)\n+\t  {\n+\t    for (int i = 0; i < a1.length; i++)\n+\t      {\n+\t\tif (!(a1[i] == null ? a2[i] == null : a1[i].equals(a2[i])))\n+\t\t  {\n+\t\t    return false;\n+\t\t  }\n+\t      }\n+\t    return true;\n+\t  }\n \n-    // If a1 == null or a2 == null but not both then we will get a NullPointer\n-    } catch (NullPointerException e) {\n-    }\n+\t// If a1 == null or a2 == null but not both then we will get a NullPointer\n+      }\n+    catch (NullPointerException e)\n+      {\n+      }\n \n     return false;\n   }\n@@ -656,7 +788,8 @@ public static boolean equals(Object[] a1, Object[] a2) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(boolean[] a, boolean val) {\n+  public static void fill(boolean[]a, boolean val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -671,11 +804,12 @@ public static void fill(boolean[] a, boolean val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(boolean[] a, int fromIndex, int toIndex,\n-                          boolean val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(boolean[]a, int fromIndex, int toIndex, boolean val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -684,7 +818,8 @@ public static void fill(boolean[] a, int fromIndex, int toIndex,\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(byte[] a, byte val) {\n+  public static void fill(byte[]a, byte val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -699,10 +834,12 @@ public static void fill(byte[] a, byte val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(byte[]a, int fromIndex, int toIndex, byte val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -711,7 +848,8 @@ public static void fill(byte[] a, int fromIndex, int toIndex, byte val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(char[] a, char val) {\n+  public static void fill(char[]a, char val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -726,10 +864,12 @@ public static void fill(char[] a, char val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(char[] a, int fromIndex, int toIndex, char val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(char[]a, int fromIndex, int toIndex, char val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -738,7 +878,8 @@ public static void fill(char[] a, int fromIndex, int toIndex, char val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(double[] a, double val) {\n+  public static void fill(double[]a, double val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -753,10 +894,12 @@ public static void fill(double[] a, double val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(double[] a, int fromIndex, int toIndex, double val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(double[]a, int fromIndex, int toIndex, double val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -765,7 +908,8 @@ public static void fill(double[] a, int fromIndex, int toIndex, double val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(float[] a, float val) {\n+  public static void fill(float[]a, float val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -780,10 +924,12 @@ public static void fill(float[] a, float val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(float[] a, int fromIndex, int toIndex, float val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(float[]a, int fromIndex, int toIndex, float val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -792,7 +938,8 @@ public static void fill(float[] a, int fromIndex, int toIndex, float val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(int[] a, int val) {\n+  public static void fill(int[]a, int val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -807,10 +954,12 @@ public static void fill(int[] a, int val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(int[] a, int fromIndex, int toIndex, int val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(int[]a, int fromIndex, int toIndex, int val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -819,7 +968,8 @@ public static void fill(int[] a, int fromIndex, int toIndex, int val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(long[] a, long val) {\n+  public static void fill(long[]a, long val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -834,10 +984,12 @@ public static void fill(long[] a, long val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(long[] a, int fromIndex, int toIndex, long val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(long[]a, int fromIndex, int toIndex, long val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -846,7 +998,8 @@ public static void fill(long[] a, int fromIndex, int toIndex, long val) {\n    * @param a the array to fill\n    * @param val the value to fill it with\n    */\n-  public static void fill(short[] a, short val) {\n+  public static void fill(short[]a, short val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -861,10 +1014,12 @@ public static void fill(short[] a, short val) {\n    * @param toIndex the index to fill to, exclusive\n    * @param val the value to fill with\n    */\n-  public static void fill(short[] a, int fromIndex, int toIndex, short val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(short[]a, int fromIndex, int toIndex, short val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   /**\n@@ -875,7 +1030,8 @@ public static void fill(short[] a, int fromIndex, int toIndex, short val) {\n    * @exception ClassCastException if val is not an instance of the element\n    *   type of a.\n    */\n-  public static void fill(Object[] a, Object val) {\n+  public static void fill(Object[]a, Object val)\n+  {\n     // This implementation is slightly inefficient timewise, but the extra\n     // effort over inlining it is O(1) and small, and I refuse to repeat code\n     // if it can be helped.\n@@ -892,10 +1048,12 @@ public static void fill(Object[] a, Object val) {\n    * @exception ClassCastException if val is not an instance of the element\n    *   type of a.\n    */\n-  public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {\n-    for (int i = fromIndex; i < toIndex; i++) {\n-      a[i] = val;\n-    }\n+  public static void fill(Object[]a, int fromIndex, int toIndex, Object val)\n+  {\n+    for (int i = fromIndex; i < toIndex; i++)\n+      {\n+\ta[i] = val;\n+      }\n   }\n \n   // Thanks to Paul Fisher <rao@gnu.org> for finding this quicksort algorithm\n@@ -911,79 +1069,110 @@ public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(byte[] a) {\n+  public static void sort(byte[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static short cmp(byte i, byte j) {\n-    return (short)(i-j);\n+  public static void sort(byte[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n   }\n \n-  private static int med3(int a, int b, int c, byte[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static short cmp(byte i, byte j)\n+  {\n+    return (short) (i - j);\n+  }\n+\n+  private static int med3(int a, int b, int c, byte[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, byte[] a) {\n+\n+  private static void swap(int i, int j, byte[]a)\n+  {\n     byte c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(byte[] a, int start, int n) {\n+  private static void qsort(byte[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     short r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, byte[] a) {\n+  private static void vecswap(int i, int j, int n, byte[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -998,79 +1187,110 @@ private static void vecswap(int i, int j, int n, byte[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(char[] a) {\n+  public static void sort(char[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static int cmp(char i, char j) {\n-    return i-j;\n+  public static void sort(char[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n+  }\n+\n+  private static int cmp(char i, char j)\n+  {\n+    return i - j;\n   }\n \n-  private static int med3(int a, int b, int c, char[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static int med3(int a, int b, int c, char[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, char[] a) {\n+\n+  private static void swap(int i, int j, char[]a)\n+  {\n     char c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(char[] a, int start, int n) {\n+  private static void qsort(char[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     int r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, char[] a) {\n+  private static void vecswap(int i, int j, int n, char[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1086,79 +1306,110 @@ private static void vecswap(int i, int j, int n, char[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(double[] a) {\n+  public static void sort(double[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static double cmp(double i, double j) {\n-    return i-j;\n+  public static void sort(double[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n   }\n \n-  private static int med3(int a, int b, int c, double[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static double cmp(double i, double j)\n+  {\n+    return i - j;\n+  }\n+\n+  private static int med3(int a, int b, int c, double[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, double[] a) {\n+\n+  private static void swap(int i, int j, double[]a)\n+  {\n     double c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(double[] a, int start, int n) {\n+  private static void qsort(double[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     double r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, double[] a) {\n+  private static void vecswap(int i, int j, int n, double[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1174,79 +1425,110 @@ private static void vecswap(int i, int j, int n, double[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(float[] a) {\n+  public static void sort(float[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static float cmp(float i, float j) {\n-    return i-j;\n+  public static void sort(float[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n+  }\n+\n+  private static float cmp(float i, float j)\n+  {\n+    return i - j;\n   }\n \n-  private static int med3(int a, int b, int c, float[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static int med3(int a, int b, int c, float[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n \n-  private static void swap(int i, int j, float[] a) {\n+  private static void swap(int i, int j, float[]a)\n+  {\n     float c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(float[] a, int start, int n) {\n+  private static void qsort(float[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     float r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, float[] a) {\n+  private static void vecswap(int i, int j, int n, float[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1261,79 +1543,110 @@ private static void vecswap(int i, int j, int n, float[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(int[] a) {\n+  public static void sort(int[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static long cmp(int i, int j) {\n-    return (long)i-(long)j;\n+  public static void sort(int[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n+  }\n+\n+  private static long cmp(int i, int j)\n+  {\n+    return (long) i - (long) j;\n   }\n \n-  private static int med3(int a, int b, int c, int[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static int med3(int a, int b, int c, int[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, int[] a) {\n+\n+  private static void swap(int i, int j, int[]a)\n+  {\n     int c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(int[] a, int start, int n) {\n+  private static void qsort(int[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     long r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, int[] a) {\n+  private static void vecswap(int i, int j, int n, int[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1348,80 +1661,110 @@ private static void vecswap(int i, int j, int n, int[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(long[] a) {\n+  public static void sort(long[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n+  public static void sort(long[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n+  }\n+\n   // The \"cmp\" method has been removed from here and replaced with direct\n   // compares in situ, to avoid problems with overflow if the difference\n   // between two numbers is bigger than a long will hold.\n   // One particular change as a result is the use of r1 and r2 in qsort\n \n-  private static int med3(int a, int b, int c, long[] d) {\n-    return d[a] < d[b] ? \n+  private static int med3(int a, int b, int c, long[]d)\n+  {\n+    return d[a] < d[b] ?\n       (d[b] < d[c] ? b : d[a] < d[c] ? c : a)\n-    : (d[b] > d[c] ? b : d[a] > d[c] ? c : a);\n+      : (d[b] > d[c] ? b : d[a] > d[c] ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, long[] a) {\n+\n+  private static void swap(int i, int j, long[]a)\n+  {\n     long c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(long[] a, int start, int n) {\n+  private static void qsort(long[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && a[j-1] > a[j]; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && a[j - 1] > a[j]; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     long r1, r2;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r1 = a[pb]) <= (r2 = a[pv])) {\n-        if (r1 == r2) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r1 = a[pc]) >= (r2 = a[pv])) {\n-        if (r1 == r2) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r1 = a[pb]) <= (r2 = a[pv]))\n+\t  {\n+\t    if (r1 == r2)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r1 = a[pc]) >= (r2 = a[pv]))\n+\t  {\n+\t    if (r1 == r2)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, long[] a) {\n+  private static void vecswap(int i, int j, int n, long[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1436,79 +1779,110 @@ private static void vecswap(int i, int j, int n, long[] a) {\n    *\n    * @param a the array to sort\n    */\n-  public static void sort(short[] a) {\n+  public static void sort(short[]a)\n+  {\n     qsort(a, 0, a.length);\n   }\n \n-  private static int cmp(short i, short j) {\n-    return i-j;\n+  public static void sort(short[] a, int fromIndex, int toIndex)\n+  {\n+    qsort(a, fromIndex, toIndex);\n   }\n \n-  private static int med3(int a, int b, int c, short[] d) {\n-    return cmp(d[a], d[b]) < 0 ? \n+  private static int cmp(short i, short j)\n+  {\n+    return i - j;\n+  }\n+\n+  private static int med3(int a, int b, int c, short[]d)\n+  {\n+    return cmp(d[a], d[b]) < 0 ?\n       (cmp(d[b], d[c]) < 0 ? b : cmp(d[a], d[c]) < 0 ? c : a)\n-    : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n+      : (cmp(d[b], d[c]) > 0 ? b : cmp(d[a], d[c]) > 0 ? c : a);\n   }\n-  \n-  private static void swap(int i, int j, short[] a) {\n+\n+  private static void swap(int i, int j, short[]a)\n+  {\n     short c = a[i];\n     a[i] = a[j];\n     a[j] = c;\n   }\n \n-  private static void qsort(short[] a, int start, int n) {\n+  private static void qsort(short[]a, int start, int n)\n+  {\n     // use an insertion sort on small arrays\n-    if (n < 7) {\n-      for (int i = start + 1; i < start + n; i++)\n-        for (int j = i; j > 0 && cmp(a[j-1], a[j]) > 0; j--)\n-          swap(j, j-1, a);\n-      return;\n-    }\n-\n-    int pm = n/2;       // small arrays, middle element\n-    if (n > 7) {\n-      int pl = start;\n-      int pn = start + n-1;\n+    if (n < 7)\n+      {\n+\tfor (int i = start + 1; i < start + n; i++)\n+\t  for (int j = i; j > 0 && cmp(a[j - 1], a[j]) > 0; j--)\n+\t    swap(j, j - 1, a);\n+\treturn;\n+      }\n \n-      if (n > 40) {     // big arrays, pseudomedian of 9\n-        int s = n/8;\n-        pl = med3(pl, pl+s, pl+2*s, a);\n-        pm = med3(pm-s, pm, pm+s, a);\n-        pn = med3(pn-2*s, pn-s, pn, a);\n+    int pm = n / 2;\t\t// small arrays, middle element\n+    if (n > 7)\n+      {\n+\tint pl = start;\n+\tint pn = start + n - 1;\n+\n+\tif (n > 40)\n+\t  {\t\t\t// big arrays, pseudomedian of 9\n+\t    int s = n / 8;\n+\t    pl = med3(pl, pl + s, pl + 2 * s, a);\n+\t    pm = med3(pm - s, pm, pm + s, a);\n+\t    pn = med3(pn - 2 * s, pn - s, pn, a);\n+\t  }\n+\tpm = med3(pl, pm, pn, a);\t// mid-size, med of 3\n       }\n-      pm = med3(pl, pm, pn, a); // mid-size, med of 3\n-    }\n \n     int pa, pb, pc, pd, pv;\n     int r;\n \n-    pv = start; swap(pv, pm, a);\n+    pv = start;\n+    swap(pv, pm, a);\n     pa = pb = start;\n-    pc = pd = start + n-1;\n-    \n-    for (;;) {\n-      while (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0) {\n-        if (r == 0) { swap(pa, pb, a); pa++; }\n-        pb++;\n-      }\n-      while (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0) {\n-        if (r == 0) { swap(pc, pd, a); pd--; }\n-        pc--;\n-      }\n-      if (pb > pc) break;\n-      swap(pb, pc, a);\n-      pb++;\n-      pc--;\n-    }\n+    pc = pd = start + n - 1;\n+\n+    for (;;)\n+      {\n+\twhile (pb <= pc && (r = cmp(a[pb], a[pv])) <= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pa, pb, a);\n+\t\tpa++;\n+\t      }\n+\t    pb++;\n+\t  }\n+\twhile (pc >= pb && (r = cmp(a[pc], a[pv])) >= 0)\n+\t  {\n+\t    if (r == 0)\n+\t      {\n+\t\tswap(pc, pd, a);\n+\t\tpd--;\n+\t      }\n+\t    pc--;\n+\t  }\n+\tif (pb > pc)\n+\t  break;\n+\tswap(pb, pc, a);\n+\tpb++;\n+\tpc--;\n+      }\n     int pn = start + n;\n     int s;\n-    s = Math.min(pa-start, pb-pa); vecswap(start, pb-s, s, a);\n-    s = Math.min(pd-pc, pn-pd-1); vecswap(pb, pn-s, s, a);\n-    if ((s = pb-pa) > 1) qsort(a, start, s);\n-    if ((s = pd-pc) > 1) qsort(a, pn-s, s);\n+    s = Math.min(pa - start, pb - pa);\n+    vecswap(start, pb - s, s, a);\n+    s = Math.min(pd - pc, pn - pd - 1);\n+    vecswap(pb, pn - s, s, a);\n+    if ((s = pb - pa) > 1)\n+      qsort(a, start, s);\n+    if ((s = pd - pc) > 1)\n+      qsort(a, pn - s, s);\n   }\n \n-  private static void vecswap(int i, int j, int n, short[] a) {\n+  private static void vecswap(int i, int j, int n, short[]a)\n+  {\n     for (; n > 0; i++, j++, n--)\n       swap(i, j, a);\n   }\n@@ -1520,94 +1894,101 @@ private static void vecswap(int i, int j, int n, short[] a) {\n    * than I can, and if I try it will make it more confusing for the\n    * JIT.  \n    */\n-  private static void mergeSort(Object[] a, int from, int to, Comparator c)\n+  private static void mergeSort(Object[]a, int from, int to, Comparator c)\n   {\n     // First presort the array in chunks of length 6 with insertion sort. \n     // mergesort would give too much overhead for this length.\n     for (int chunk = from; chunk < to; chunk += 6)\n       {\n-\tint end = Math.min(chunk+6, to);\n+\tint end = Math.min(chunk + 6, to);\n \tfor (int i = chunk + 1; i < end; i++)\n \t  {\n-\t    if (c.compare(a[i-1], a[i]) > 0)\n+\t    if (c.compare(a[i - 1], a[i]) > 0)\n \t      {\n \t\t// not already sorted\n-\t\tint j=i;\n+\t\tint j = i;\n \t\tObject elem = a[j];\n-\t\tdo \n+\t\tdo\n \t\t  {\n-\t\t    a[j] = a[j-1];\n+\t\t    a[j] = a[j - 1];\n \t\t    j--;\n-\t\t  } \n-\t\twhile (j>chunk && c.compare(a[j-1], elem) > 0);\n+\t\t  }\n+\t\twhile (j > chunk && c.compare(a[j - 1], elem) > 0);\n \t\ta[j] = elem;\n \t      }\n \t  }\n       }\n-    \n+\n     int len = to - from;\n     // If length is smaller or equal 6 we are done.\n     if (len <= 6)\n       return;\n \n-    Object[] src = a;\n-    Object[] dest = new Object[len];\n-    Object[] t = null; // t is used for swapping src and dest\n+    Object[]src = a;\n+    Object[]dest = new Object[len];\n+    Object[]t = null;\t\t// t is used for swapping src and dest\n \n     // The difference of the fromIndex of the src and dest array.\n     int srcDestDiff = -from;\n \n     // The merges are done in this loop\n-    for (int size = 6; size < len; size <<= 1) \n+    for (int size = 6; size < len; size <<= 1)\n       {\n \tfor (int start = from; start < to; start += size << 1)\n \t  {\n \t    // mid ist the start of the second sublist;\n \t    // end the start of the next sublist (or end of array).\n \t    int mid = start + size;\n \t    int end = Math.min(to, mid + size);\n-\t    \n+\n \t    // The second list is empty or the elements are already in\n \t    // order - no need to merge\n-\t    if (mid >= end || c.compare(src[mid - 1], src[mid]) <= 0) {\n-\t      System.arraycopy(src, start, \n-\t\t\t       dest, start + srcDestDiff, end - start);\n-\t      \n-\t      // The two halves just need swapping - no need to merge\n-\t    } else if (c.compare(src[start], src[end - 1]) > 0) {\n-\t      System.arraycopy(src, start, \n-\t\t\t       dest, end - size + srcDestDiff, size);\n-\t      System.arraycopy(src, mid, \n-\t\t\t       dest, start + srcDestDiff, end - mid);\n-\t      \n-\t    } else {\n-\t      // Declare a lot of variables to save repeating\n-\t      // calculations.  Hopefully a decent JIT will put these\n-\t      // in registers and make this fast\n-\t      int p1 = start;\n-\t      int p2 = mid;\n-\t      int i = start + srcDestDiff;\n-\t      \n-\t      // The main merge loop; terminates as soon as either\n-\t      // half is ended\n-\t      while (p1 < mid && p2 < end)\n-\t\t{\n-\t\t  dest[i++] = \n-\t\t    src[c.compare(src[p1], src[p2]) <= 0 ? p1++ : p2++];\n-\t\t}\n-\t      \n-\t      // Finish up by copying the remainder of whichever half\n-\t      // wasn't finished.\n-\t      if (p1 < mid)\n-\t\tSystem.arraycopy(src, p1, dest, i, mid - p1);\n-\t      else\n-\t\tSystem.arraycopy(src, p2, dest, i, end - p2);\n-\t    } \n+\t    if (mid >= end || c.compare(src[mid - 1], src[mid]) <= 0)\n+\t      {\n+\t\tSystem.arraycopy(src, start,\n+\t\t\t\t dest, start + srcDestDiff, end - start);\n+\n+\t\t// The two halves just need swapping - no need to merge\n+\t      }\n+\t    else if (c.compare(src[start], src[end - 1]) > 0)\n+\t      {\n+\t\tSystem.arraycopy(src, start,\n+\t\t\t\t dest, end - size + srcDestDiff, size);\n+\t\tSystem.arraycopy(src, mid,\n+\t\t\t\t dest, start + srcDestDiff, end - mid);\n+\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Declare a lot of variables to save repeating\n+\t\t// calculations.  Hopefully a decent JIT will put these\n+\t\t// in registers and make this fast\n+\t\tint p1 = start;\n+\t\tint p2 = mid;\n+\t\tint i = start + srcDestDiff;\n+\n+\t\t// The main merge loop; terminates as soon as either\n+\t\t// half is ended\n+\t\twhile (p1 < mid && p2 < end)\n+\t\t  {\n+\t\t    dest[i++] =\n+\t\t      src[c.compare(src[p1], src[p2]) <= 0 ? p1++ : p2++];\n+\t\t  }\n+\n+\t\t// Finish up by copying the remainder of whichever half\n+\t\t// wasn't finished.\n+\t\tif (p1 < mid)\n+\t\t  System.arraycopy(src, p1, dest, i, mid - p1);\n+\t\telse\n+\t\t  System.arraycopy(src, p2, dest, i, end - p2);\n+\t      }\n \t  }\n \t// swap src and dest ready for the next merge\n-\tt = src; src = dest; dest = t; \n+\tt = src;\n+\tsrc = dest;\n+\tdest = t;\n \tfrom += srcDestDiff;\n-\tto   += srcDestDiff;\n+\tto += srcDestDiff;\n \tsrcDestDiff = -srcDestDiff;\n       }\n \n@@ -1635,7 +2016,8 @@ private static void mergeSort(Object[] a, int from, int to, Comparator c)\n    * @exception NullPointerException if an element is null (since\n    *   null.compareTo cannot work)\n    */\n-  public static void sort(Object[] a) {\n+  public static void sort(Object[]a)\n+  {\n     mergeSort(a, 0, a.length, defaultComparator);\n   }\n \n@@ -1652,7 +2034,8 @@ public static void sort(Object[] a) {\n    * @exception ClassCastException if any two elements are not mutually\n    *   comparable by the Comparator provided\n    */\n-  public static void sort(Object[] a, Comparator c) {\n+  public static void sort(Object[]a, Comparator c)\n+  {\n     mergeSort(a, 0, a.length, c);\n   }\n \n@@ -1673,11 +2056,11 @@ public static void sort(Object[] a, Comparator c) {\n    *   are not in range.\n    * @exception IllegalArgumentException if fromIndex > toIndex\n    */\n-  public static void sort(Object[] a, int fromIndex, \n-\t\t\t  int toIndex) {\n+  public static void sort(Object[]a, int fromIndex, int toIndex)\n+  {\n     if (fromIndex > toIndex)\n-      throw new IllegalArgumentException(\"fromIndex \"+fromIndex\n-\t\t\t\t\t +\" > toIndex \"+toIndex);\n+      throw new IllegalArgumentException(\"fromIndex \" + fromIndex\n+\t\t\t\t\t + \" > toIndex \" + toIndex);\n     mergeSort(a, fromIndex, toIndex, defaultComparator);\n   }\n \n@@ -1699,11 +2082,11 @@ public static void sort(Object[] a, int fromIndex,\n    *   are not in range.\n    * @exception IllegalArgumentException if fromIndex > toIndex\n    */\n-  public static void sort(Object[] a, int fromIndex, \n-\t\t\t  int toIndex, Comparator c) {\n+  public static void sort(Object[]a, int fromIndex, int toIndex, Comparator c)\n+  {\n     if (fromIndex > toIndex)\n-      throw new IllegalArgumentException(\"fromIndex \"+fromIndex\n-\t\t\t\t\t +\" > toIndex \"+toIndex);\n+      throw new IllegalArgumentException(\"fromIndex \" + fromIndex\n+\t\t\t\t\t + \" > toIndex \" + toIndex);\n     mergeSort(a, fromIndex, toIndex, c);\n   }\n \n@@ -1715,13 +2098,14 @@ public static void sort(Object[] a, int fromIndex,\n    * @param a the array to return a view of\n    * @returns a fixed-size list, changes to which \"write through\" to the array\n    */\n-  public static List asList(final Object[] a) {\n-\n-    if (a == null) {\n-      throw new NullPointerException();\n-    }\n+  public static List asList(final Object[]a)\n+  {\n+    if (a == null)\n+      {\n+\tthrow new NullPointerException();\n+      }\n \n-    return new ListImpl( a );\n+    return new ListImpl(a);\n   }\n \n \n@@ -1731,27 +2115,30 @@ public static List asList(final Object[] a) {\n    * Note: When Sun fully specify serialized forms, this class will have to\n    * be renamed.\n    */\n-  private static class ListImpl extends AbstractList {\n-\n-    ListImpl(Object[] a) {\n+  private static class ListImpl extends AbstractList\n+  {\n+    ListImpl(Object[]a)\n+    {\n       this.a = a;\n     }\n \n-    public Object get(int index) {\n+    public Object get(int index)\n+    {\n       return a[index];\n     }\n \n-    public int size() {\n+    public int size()\n+    {\n       return a.length;\n     }\n \n-    public Object set(int index, Object element) {\n+    public Object set(int index, Object element)\n+    {\n       Object old = a[index];\n       a[index] = element;\n       return old;\n     }\n \n     private Object[] a;\n   }\n-    \n }"}, {"sha": "400967145a6065e3780936edeeee9482e94361a4", "filename": "libjava/scripts/blocks.pl", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fscripts%2Fblocks.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98182da528e7b84a12d0c01e5d8efdb1d0670141/libjava%2Fscripts%2Fblocks.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fscripts%2Fblocks.pl?ref=98182da528e7b84a12d0c01e5d8efdb1d0670141", "patch": "@@ -0,0 +1,48 @@\n+#! /usr/bin/perl\n+\n+if ($ARGV[0] eq '')\n+{\n+    $file = 'Blocks.txt';\n+    if (! -f $file)\n+    {\n+\t# Too painful to figure out how to get Perl to do it.\n+\t# FIXME.\n+\tsystem 'wget -o .wget-log http://www.isi.edu/in-notes/iana/unidata/Blocks.txt';\n+    }\n+}\n+else\n+{\n+    $file = $ARGV[0];\n+}\n+\n+open (INPUT, \"< $file\") || die \"couldn't open $file: $!\";\n+\n+@array = ();\n+while (<INPUT>)\n+{\n+    next if /^#/;\n+    chop;\n+\n+    ($start, $to, $text) = split (/; /);\n+    ($symbol = $text) =~ tr/a-z/A-Z/;\n+    $symbol =~ s/[- ]/_/g;\n+\n+    # Special case for one of the SPECIALS.\n+    next if $start eq 'FEFF';\n+\n+    printf \"    public static final UnicodeBlock %s = new UnicodeBlock (\\\"%s\\\", '\\\\u%s', '\\\\u%s');\\n\",\n+           $symbol, $text, $start, $to;\n+\n+    push (@array, $symbol);\n+}\n+\n+printf \"    private static final UnicodeBlock[] blocks = {\\n\";\n+foreach (@array)\n+{\n+    printf \"      %s\", $_;\n+    printf \",\" unless $_ eq 'SPECIALS';\n+    printf \"\\n\";\n+}\n+printf \"    };\\n\";\n+\n+close (INPUT);"}]}