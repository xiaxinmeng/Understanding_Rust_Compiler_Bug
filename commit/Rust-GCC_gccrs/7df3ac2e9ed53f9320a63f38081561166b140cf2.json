{"sha": "7df3ac2e9ed53f9320a63f38081561166b140cf2", "node_id": "C_kwDOANBUbNoAKDdkZjNhYzJlOWVkNTNmOTMyMGE2M2YzODA4MTU2MTE2NmIxNDBjZjI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-10-27T21:51:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-11-09T09:44:50Z"}, "message": "[Ada] Tidy up implementation of Has_Compatible_Type\n\ngcc/ada/\n\n\t* sem_ch4.adb (Analyze_Membership_Op) <Find_Interpretation>: Handle\n\tboth overloaded and non-overloaded cases.\n\t<Try_One_Interp>: Do a reversed call to Covers if the outcome of the\n\tcall to Has_Compatible_Type is false.\n\tSimplify implementation after change to Find_Interpretation.\n\t(Analyze_User_Defined_Binary_Op): Be prepared for previous errors.\n\t(Find_Comparison_Types) <Try_One_Interp>: Do a reversed call to\n\tCovers if the outcome of the call to Has_Compatible_Type is false.\n\t(Find_Equality_Types) <Try_One_Interp>: Likewise.\n\t* sem_type.adb (Has_Compatible_Type): Remove the reversed calls to\n\tCovers.  Add explicit return on all paths.", "tree": {"sha": "2db1cc6bae11c9ffb3005ececb868c8edca6e4a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2db1cc6bae11c9ffb3005ececb868c8edca6e4a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7df3ac2e9ed53f9320a63f38081561166b140cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df3ac2e9ed53f9320a63f38081561166b140cf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df3ac2e9ed53f9320a63f38081561166b140cf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df3ac2e9ed53f9320a63f38081561166b140cf2/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2e4ebe02b1be5ee81b24ff504f58ac9078953c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e4ebe02b1be5ee81b24ff504f58ac9078953c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e4ebe02b1be5ee81b24ff504f58ac9078953c0"}], "stats": {"total": 87, "additions": 39, "deletions": 48}, "files": [{"sha": "9b1d908097db1b7124fc5fff82b59f05898ea3af", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df3ac2e9ed53f9320a63f38081561166b140cf2/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df3ac2e9ed53f9320a63f38081561166b140cf2/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7df3ac2e9ed53f9320a63f38081561166b140cf2", "patch": "@@ -2976,10 +2976,7 @@ package body Sem_Ch4 is\n \n       procedure Find_Interpretation;\n       function Find_Interpretation return Boolean;\n-      --  Routine and wrapper to find a matching interpretation in case\n-      --  of overloading. The wrapper returns True iff a matching\n-      --  interpretation is found. Beware, in absence of overloading,\n-      --  using this function will break gnat's bootstrapping.\n+      --  Routine and wrapper to find a matching interpretation\n \n       procedure Try_One_Interp (T1 : Entity_Id);\n       --  Routine to try one proposed interpretation. Note that the context\n@@ -3091,11 +3088,16 @@ package body Sem_Ch4 is\n \n       procedure Find_Interpretation is\n       begin\n-         Get_First_Interp (L, Index, It);\n-         while Present (It.Typ) loop\n-            Try_One_Interp (It.Typ);\n-            Get_Next_Interp (Index, It);\n-         end loop;\n+         if not Is_Overloaded (L) then\n+            Try_One_Interp (Etype (L));\n+\n+         else\n+            Get_First_Interp (L, Index, It);\n+            while Present (It.Typ) loop\n+               Try_One_Interp (It.Typ);\n+               Get_Next_Interp (Index, It);\n+            end loop;\n+         end if;\n       end Find_Interpretation;\n \n       function Find_Interpretation return Boolean is\n@@ -3111,7 +3113,7 @@ package body Sem_Ch4 is\n \n       procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n-         if Has_Compatible_Type (R, T1) then\n+         if Has_Compatible_Type (R, T1) or else Covers (Etype (R), T1) then\n             if Found\n               and then Base_Type (T1) /= Base_Type (T_F)\n             then\n@@ -3156,12 +3158,7 @@ package body Sem_Ch4 is\n       then\n          Analyze (R);\n \n-         if not Is_Overloaded (L) then\n-            Try_One_Interp (Etype (L));\n-\n-         else\n-            Find_Interpretation;\n-         end if;\n+         Find_Interpretation;\n \n       --  If not a range, it can be a subtype mark, or else it is a degenerate\n       --  membership test with a singleton value, i.e. a test for equality,\n@@ -3170,16 +3167,11 @@ package body Sem_Ch4 is\n       else\n          Analyze (R);\n \n-         if Is_Entity_Name (R)\n-           and then Is_Type (Entity (R))\n-         then\n+         if Is_Entity_Name (R) and then Is_Type (Entity (R)) then\n             Find_Type (R);\n             Check_Fully_Declared (Entity (R), R);\n \n-         elsif Ada_Version >= Ada_2012 and then\n-           ((Is_Overloaded (L) and then Find_Interpretation) or else\n-           (not Is_Overloaded (L) and then Has_Compatible_Type (R, Etype (L))))\n-         then\n+         elsif Ada_Version >= Ada_2012 and then Find_Interpretation then\n             if Nkind (N) = N_In then\n                Op := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n             else\n@@ -5918,14 +5910,16 @@ package body Sem_Ch4 is\n       begin\n          --  Verify that Op_Id is a visible binary function. Note that since\n          --  we know Op_Id is overloaded, potentially use visible means use\n-         --  visible for sure (RM 9.4(11)).\n+         --  visible for sure (RM 9.4(11)). Be prepared for previous errors.\n \n          if Ekind (Op_Id) = E_Function\n            and then Present (F2)\n            and then (Is_Immediately_Visible (Op_Id)\n                       or else Is_Potentially_Use_Visible (Op_Id))\n-           and then Has_Compatible_Type (Left_Opnd (N), Etype (F1))\n-           and then Has_Compatible_Type (Right_Opnd (N), Etype (F2))\n+           and then (Has_Compatible_Type (Left_Opnd (N), Etype (F1))\n+                      or else Etype (F1) = Any_Type)\n+           and then (Has_Compatible_Type (Right_Opnd (N), Etype (F2))\n+                      or else Etype (F2) = Any_Type)\n          then\n             Add_One_Interp (N, Op_Id, Etype (Op_Id));\n \n@@ -6612,7 +6606,10 @@ package body Sem_Ch4 is\n             return;\n          end if;\n \n-         if Valid_Comparison_Arg (T1) and then Has_Compatible_Type (R, T1) then\n+         if Valid_Comparison_Arg (T1)\n+           and then (Has_Compatible_Type (R, T1)\n+                      or else Covers (Etype (R), T1))\n+         then\n             if Found and then Base_Type (T1) /= Base_Type (T_F) then\n                It := Disambiguate (L, I_F, Index, Any_Type);\n \n@@ -6710,6 +6707,7 @@ package body Sem_Ch4 is\n                Get_Next_Interp (Index, It);\n             end loop;\n          end if;\n+\n       elsif Has_Compatible_Type (R, T1) or else Covers (Etype (R), T1) then\n          Add_One_Interp (N, Op_Id, Standard_Boolean, Base_Type (T1));\n       end if;\n@@ -7100,7 +7098,9 @@ package body Sem_Ch4 is\n          --  Finally, also check for RM 4.5.2 (9.6/2).\n \n          if T1 /= Standard_Void_Type\n-           and then (Universal_Access or else Has_Compatible_Type (R, T1))\n+           and then (Universal_Access\n+                      or else Has_Compatible_Type (R, T1)\n+                      or else Covers (Etype (R), T1))\n \n            and then\n              ((not Is_Limited_Type (T1)\n@@ -7161,9 +7161,7 @@ package body Sem_Ch4 is\n       --  If left operand is aggregate, the right operand has to\n       --  provide a usable type for it.\n \n-      if Nkind (L) = N_Aggregate\n-        and then Nkind (R) /= N_Aggregate\n-      then\n+      if Nkind (L) = N_Aggregate and then Nkind (R) /= N_Aggregate then\n          Find_Equality_Types (L => R, R => L, Op_Id => Op_Id, N => N);\n          return;\n       end if;"}, {"sha": "923c8f94ee14c18c9ef6ebc44350416da367f3aa", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df3ac2e9ed53f9320a63f38081561166b140cf2/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df3ac2e9ed53f9320a63f38081561166b140cf2/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=7df3ac2e9ed53f9320a63f38081561166b140cf2", "patch": "@@ -2449,11 +2449,8 @@ package body Sem_Type is\n          return False;\n       end if;\n \n-      if Nkind (N) = N_Subtype_Indication\n-        or else not Is_Overloaded (N)\n-      then\n-         return\n-           Covers (Typ, Etype (N))\n+      if Nkind (N) = N_Subtype_Indication or else not Is_Overloaded (N) then\n+         if Covers (Typ, Etype (N))\n \n             --  Ada 2005 (AI-345): The context may be a synchronized interface.\n             --  If the type is already frozen use the corresponding_record\n@@ -2471,11 +2468,6 @@ package body Sem_Type is\n                and then Present (Corresponding_Record_Type (Typ))\n                and then Covers (Corresponding_Record_Type (Typ), Etype (N)))\n \n-           or else\n-             (not Is_Tagged_Type (Typ)\n-               and then Ekind (Typ) /= E_Anonymous_Access_Type\n-               and then Covers (Etype (N), Typ))\n-\n            or else\n              (Nkind (N) = N_Integer_Literal\n                and then Present (Find_Aspect (Typ, Aspect_Integer_Literal)))\n@@ -2486,7 +2478,10 @@ package body Sem_Type is\n \n            or else\n              (Nkind (N) = N_String_Literal\n-               and then Present (Find_Aspect (Typ, Aspect_String_Literal)));\n+               and then Present (Find_Aspect (Typ, Aspect_String_Literal)))\n+         then\n+            return True;\n+         end if;\n \n       --  Overloaded case\n \n@@ -2501,24 +2496,22 @@ package body Sem_Type is\n                --  Ada 2005 (AI-345)\n \n               or else\n-                (Is_Concurrent_Type (It.Typ)\n+                (Is_Record_Type (Typ)\n+                  and then Is_Concurrent_Type (It.Typ)\n                   and then Present (Corresponding_Record_Type\n                                                              (Etype (It.Typ)))\n                   and then Covers (Typ, Corresponding_Record_Type\n                                                              (Etype (It.Typ))))\n \n-              or else (not Is_Tagged_Type (Typ)\n-                         and then Ekind (Typ) /= E_Anonymous_Access_Type\n-                         and then Covers (It.Typ, Typ))\n             then\n                return True;\n             end if;\n \n             Get_Next_Interp (I, It);\n          end loop;\n-\n-         return False;\n       end if;\n+\n+      return False;\n    end Has_Compatible_Type;\n \n    ---------------------"}]}