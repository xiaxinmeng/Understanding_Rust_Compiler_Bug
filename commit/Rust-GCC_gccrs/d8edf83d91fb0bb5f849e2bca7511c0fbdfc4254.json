{"sha": "d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlZGY4M2Q5MWZiMGJiNWY4NDllMmJjYTc1MTFjMGZiZGZjNDI1NA==", "commit": {"author": {"name": "Revital Eres", "email": "revital.eres@linaro.org", "date": "2011-09-30T13:25:30Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2011-09-30T13:25:30Z"}, "message": "SMS: Support instructions with REG_INC_NOTE\n\nFrom-SVN: r179381", "tree": {"sha": "719fcfc0091e715491d3570d58ada90b4bd5d2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/719fcfc0091e715491d3570d58ada90b4bd5d2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/comments", "author": null, "committer": null, "parents": [{"sha": "442b891d022ef2a3a57fcc6210cab4bd9759902c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442b891d022ef2a3a57fcc6210cab4bd9759902c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442b891d022ef2a3a57fcc6210cab4bd9759902c"}], "stats": {"total": 185, "additions": 174, "deletions": 11}, "files": [{"sha": "bbf1897c3d72eb2681e3db896ee6f742f1ac54c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -1,3 +1,12 @@\n+2011-09-30  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* ddg.c (autoinc_var_is_used_p): New function.\n+\t(create_ddg_dep_from_intra_loop_link,\n+\tadd_cross_iteration_register_deps): Call it.\n+\t* ddg.h (autoinc_var_is_used_p): Declare.\n+\t* modulo-sched.c (generate_reg_moves): Call autoinc_var_is_used_p.\n+\t(sms_schedule): Handle instructions with REG_INC.\n+\n 2011-09-30  Revital Eres  <revital.eres@linaro.org>\n \n \t* modulo-sched.c (generate_reg_moves): Skip instructions that"}, {"sha": "2b1cfe827b98dc011bfd7f058ccc01a81e7a5b4f", "filename": "gcc/ddg.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -145,6 +145,27 @@ mem_access_insn_p (rtx insn)\n   return rtx_mem_access_p (PATTERN (insn));\n }\n \n+/* Return true if DEF_INSN contains address being auto-inc or auto-dec\n+   which is used in USE_INSN.  Otherwise return false.  The result is\n+   being used to decide whether to remove the edge between def_insn and\n+   use_insn when -fmodulo-sched-allow-regmoves is set.  This function\n+   doesn't need to consider the specific address register; no reg_moves\n+   will be allowed for any life range defined by def_insn and used\n+   by use_insn, if use_insn uses an address register auto-inc'ed by\n+   def_insn.  */\n+bool\n+autoinc_var_is_used_p (rtx def_insn, rtx use_insn)\n+{\n+  rtx note;\n+\n+  for (note = REG_NOTES (def_insn); note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_INC\n+\t&& reg_referenced_p (XEXP (note, 0), PATTERN (use_insn)))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Computes the dependence parameters (latency, distance etc.), creates\n    a ddg_edge and adds it to the given DDG.  */\n static void\n@@ -173,10 +194,15 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n      compensate for that by generating reg-moves based on the life-range\n      analysis.  The anti-deps that will be deleted are the ones which\n      have true-deps edges in the opposite direction (in other words\n-     the kernel has only one def of the relevant register).  TODO:\n-     support the removal of all anti-deps edges, i.e. including those\n+     the kernel has only one def of the relevant register).\n+     If the address that is being auto-inc or auto-dec in DEST_NODE\n+     is used in SRC_NODE then do not remove the edge to make sure\n+     reg-moves will not be created for this address.  \n+     TODO: support the removal of all anti-deps edges, i.e. including those\n      whose register has multiple defs in the loop.  */\n-  if (flag_modulo_sched_allow_regmoves && (t == ANTI_DEP && dt == REG_DEP))\n+  if (flag_modulo_sched_allow_regmoves \n+      && (t == ANTI_DEP && dt == REG_DEP)\n+      && !autoinc_var_is_used_p (dest_node->insn, src_node->insn))\n     {\n       rtx set;\n \n@@ -302,10 +328,14 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \t  gcc_assert (first_def_node);\n \n          /* Always create the edge if the use node is a branch in\n-            order to prevent the creation of reg-moves.  */\n+            order to prevent the creation of reg-moves.  \n+            If the address that is being auto-inc or auto-dec in LAST_DEF\n+            is used in USE_INSN then do not remove the edge to make sure\n+            reg-moves will not be created for that address.  */\n           if (DF_REF_ID (last_def) != DF_REF_ID (first_def)\n               || !flag_modulo_sched_allow_regmoves\n-\t      || JUMP_P (use_node->insn))\n+\t      || JUMP_P (use_node->insn)\n+              || autoinc_var_is_used_p (DF_REF_INSN (last_def), use_insn))\n             create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n                                     REG_DEP, 1);\n "}, {"sha": "8452a366253060e437d01cd81c295fc264e68743", "filename": "gcc/ddg.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -186,4 +186,6 @@ void free_ddg_all_sccs (ddg_all_sccs_ptr);\n int find_nodes_on_paths (sbitmap result, ddg_ptr, sbitmap from, sbitmap to);\n int longest_simple_path (ddg_ptr, int from, int to, sbitmap via);\n \n+bool autoinc_var_is_used_p (rtx, rtx);\n+\n #endif /* GCC_DDG_H */"}, {"sha": "57186ec8710a84a584ca860de201167078493c19", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -506,6 +506,10 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n \t\t   we assume no regmoves are generated as the doloop\n \t\t   instructions are tied to the branch with an edge.  */\n \t\tgcc_assert (set);\n+\t\t/* If the instruction contains auto-inc register then\n+\t\t   validate that the regmov is being generated for the\n+\t\t   target regsiter rather then the inc'ed register.\t*/\n+\t\tgcc_assert (!autoinc_var_is_used_p (u->insn, e->dest->insn));\n \t      }\n \t    \n \t    nreg_moves = MAX (nreg_moves, nreg_moves4e);\n@@ -1281,12 +1285,10 @@ sms_schedule (void)\n \tcontinue;\n       }\n \n-      /* Don't handle BBs with calls or barriers or auto-increment insns \n-\t (to avoid creating invalid reg-moves for the auto-increment insns),\n+      /* Don't handle BBs with calls or barriers\n \t or !single_set with the exception of instructions that include\n \t count_reg---these instructions are part of the control part\n \t that do-loop recognizes.\n-         ??? Should handle auto-increment insns.\n          ??? Should handle insns defining subregs.  */\n      for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n       {\n@@ -1297,7 +1299,6 @@ sms_schedule (void)\n             || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n                 && !reg_mentioned_p (count_reg, insn))\n-            || (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n             || (INSN_P (insn) && (set = single_set (insn))\n                 && GET_CODE (SET_DEST (set)) == SUBREG))\n         break;\n@@ -1311,8 +1312,6 @@ sms_schedule (void)\n \t\tfprintf (dump_file, \"SMS loop-with-call\\n\");\n \t      else if (BARRIER_P (insn))\n \t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n-              else if (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n-                fprintf (dump_file, \"SMS reg inc\\n\");\n               else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n                 fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");"}, {"sha": "0b1e69f154e0136b483f9f74215730077488c21b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -1,3 +1,7 @@\n+2011-09-30  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* gcc.dg/sms-10.c: New file\n+\n 2011-09-30  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n \t* gcc.target/arm/pr50099.c: New test."}, {"sha": "c1de07f161976cd6199384a056b40ff6c15f68f1", "filename": "gcc/testsuite/gcc.dg/sms-10.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-10.c?ref=d8edf83d91fb0bb5f849e2bca7511c0fbdfc4254", "patch": "@@ -0,0 +1,119 @@\n+ /* { dg-do run } */\n+ /* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -fdump-rtl-sms\" } */\n+\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *malloc (size_t);\n+extern void free (void *);\n+extern void abort (void);\n+\n+struct regstat_n_sets_and_refs_t\n+{\n+  int sets;\n+  int refs;\n+};\n+\n+struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;\n+\n+struct df_reg_info\n+{\n+  unsigned int n_refs;\n+};\n+\n+struct df_d\n+{\n+  struct df_reg_info **def_regs;\n+  struct df_reg_info **use_regs;\n+};\n+struct df_d *df;\n+\n+static inline int\n+REG_N_SETS (int regno)\n+{\n+  return regstat_n_sets_and_refs[regno].sets;\n+}\n+\n+__attribute__ ((noinline))\n+     int max_reg_num (void)\n+{\n+  return 100;\n+}\n+\n+__attribute__ ((noinline))\n+     void regstat_init_n_sets_and_refs (void)\n+{\n+  unsigned int i;\n+  unsigned int max_regno = max_reg_num ();\n+\n+  for (i = 0; i < max_regno; i++)\n+    {\n+      (regstat_n_sets_and_refs[i].sets = (df->def_regs[(i)]->n_refs));\n+      (regstat_n_sets_and_refs[i].refs =\n+       (df->use_regs[(i)]->n_refs) + REG_N_SETS (i));\n+    }\n+}\n+\n+int a_sets[100] =\n+  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n+  40, 41, 42,\n+  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n+  62, 63, 64,\n+  65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n+  84, 85, 86,\n+  87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n+};\n+\n+int a_refs[100] =\n+  { 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,\n+  40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,\n+  78, 80, 82,\n+  84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,\n+  118, 120,\n+  122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,\n+  152, 154, 156,\n+  158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,\n+  188, 190, 192,\n+  194, 196, 198\n+};\n+\n+int\n+main ()\n+{\n+  struct df_reg_info *b[100], *c[100];\n+  struct df_d df1;\n+  size_t s = sizeof (struct df_reg_info);\n+  struct regstat_n_sets_and_refs_t a[100];\n+\n+  df = &df1;\n+  regstat_n_sets_and_refs = a;\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    {\n+      b[i] = (struct df_reg_info *) malloc (s);\n+      b[i]->n_refs = i;\n+      c[i] = (struct df_reg_info *) malloc (s);\n+      c[i]->n_refs = i;\n+    }\n+\n+  df1.def_regs = b;\n+  df1.use_regs = c;\n+  regstat_init_n_sets_and_refs ();\n+\n+  for (i = 0; i < 100; i++)\n+    if ((a[i].sets != a_sets[i]) || (a[i].refs != a_refs[i]))\n+      abort ();\n+\n+  for (i = 0; i < 100; i++)\n+    {\n+      free (b[i]);\n+      free (c[i]);\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"SMS succeeded\" 1 \"sms\" { target powerpc*-*-* } } } */\n+/* { dg-final { cleanup-rtl-dump \"sms\" } } */\n+"}]}