{"sha": "8d83f79225703195e325dba0138432382e4dfab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4M2Y3OTIyNTcwMzE5NWUzMjVkYmEwMTM4NDMyMzgyZTRkZmFiMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-14T21:32:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-14T21:32:26Z"}, "message": "re PR c++/11509 (ICE with expression with static member in template arg)\n\n\tPR c++/11509\n\t* pt.c (dependent_scope_ref_p): New function.\n\t(value_dependent_expression_p): Use it.\n\t(type_dependent_expression_p): Likewise.\n\n\t* pt.c (tsubst_friend_function): Use reregister_specialization.\n\n\tPR c++/11509\n\t* g++.dg/template/crash6.C: New test.\n\nFrom-SVN: r69363", "tree": {"sha": "c5857ccbf256f835830b88bb2af505be5dcce634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5857ccbf256f835830b88bb2af505be5dcce634"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d83f79225703195e325dba0138432382e4dfab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d83f79225703195e325dba0138432382e4dfab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d83f79225703195e325dba0138432382e4dfab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d83f79225703195e325dba0138432382e4dfab0/comments", "author": null, "committer": null, "parents": [{"sha": "9ae130f857c95929cd8af833b66f526827a7f701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae130f857c95929cd8af833b66f526827a7f701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae130f857c95929cd8af833b66f526827a7f701"}], "stats": {"total": 94, "additions": 60, "deletions": 34}, "files": [{"sha": "85e47ea543c7a46dfca774b2094c389c94441c52", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d83f79225703195e325dba0138432382e4dfab0", "patch": "@@ -1,5 +1,12 @@\n 2003-07-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/11509\n+\t* pt.c (dependent_scope_ref_p): New function.\n+\t(value_dependent_expression_p): Use it.\n+\t(type_dependent_expression_p): Likewise.\t\n+\t\n+\t* pt.c (tsubst_friend_function): Use reregister_specialization.\n+\n \tPR c++/7019\n \t* cp-tree.h (lookup_qualified_name): Adjust prototype.\n \t* decl.c (lookup_qualified_name): Add complain parameter.  Adjust"}, {"sha": "eb108e6338f5444ceb1252d8054d13e3ce61cb4d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8d83f79225703195e325dba0138432382e4dfab0", "patch": "@@ -4912,17 +4912,9 @@ tsubst_friend_function (tree decl, tree args)\n \t      DECL_TEMPLATE_INFO (old_decl) = new_friend_template_info;\n \n \t      if (TREE_CODE (old_decl) != TEMPLATE_DECL)\n-\t\t{\n-\t\t  tree t;\n-\t\t  tree spec;\n-\n-\t\t  t = most_general_template (old_decl);\n-\t\t  for (spec = DECL_TEMPLATE_SPECIALIZATIONS (t);\n-\t\t       spec;\n-\t\t       spec = TREE_CHAIN (spec))\n-\t\t    if (TREE_VALUE (spec) == new_friend)\n-\t\t      TREE_VALUE (spec) = old_decl;\n-\t\t}\n+\t\treregister_specialization (new_friend,\n+\t\t\t\t\t   most_general_template (old_decl),\n+\t\t\t\t\t   old_decl);\n \t      else \n \t\t{\n \t\t  tree t;\n@@ -11455,6 +11447,40 @@ dependent_type_p (tree type)\n   return TYPE_DEPENDENT_P (type);\n }\n \n+/* Returns TRUE if EXPRESSION is dependent, according to CRITERION.  */\n+\n+static bool\n+dependent_scope_ref_p (tree expression, bool criterion (tree))\n+{\n+  tree scope;\n+  tree name;\n+\n+  my_friendly_assert (TREE_CODE (expression) == SCOPE_REF, 20030714);\n+\n+  if (!TYPE_P (TREE_OPERAND (expression, 0)))\n+    return true;\n+\n+  scope = TREE_OPERAND (expression, 0);\n+  name = TREE_OPERAND (expression, 1);\n+\n+  /* [temp.dep.expr]\n+\n+     An id-expression is type-dependent if it contains a\n+     nested-name-specifier that contains a class-name that names a\n+     dependent type.  */\n+  /* The suggested resolution to Core Issue 2 implies that if the\n+     qualifying type is the current class, then we must peek\n+     inside it.  */\n+  if (DECL_P (name) \n+      && currently_open_class (scope)\n+      && !criterion (name))\n+    return false;\n+  if (dependent_type_p (scope))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Returns TRUE if the EXPRESSION is value-dependent, in the sense of\n    [temp.dep.constexpr] */\n \n@@ -11518,6 +11544,8 @@ value_dependent_expression_p (tree expression)\n \treturn dependent_type_p (expression);\n       return type_dependent_expression_p (expression);\n     }\n+  if (TREE_CODE (expression) == SCOPE_REF)\n+    return dependent_scope_ref_p (expression, value_dependent_expression_p);\n   /* A constant expression is value-dependent if any subexpression is\n      value-dependent.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expression))))\n@@ -11604,30 +11632,10 @@ type_dependent_expression_p (tree expression)\n \treturn dependent_type_p (type);\n     }\n \n-  /* [temp.dep.expr]\n-\n-     An id-expression is type-dependent if it contains a\n-     nested-name-specifier that contains a class-name that names a\n-     dependent type.  */\n   if (TREE_CODE (expression) == SCOPE_REF\n-      && TYPE_P (TREE_OPERAND (expression, 0)))\n-    {\n-      tree scope;\n-      tree name;\n-\n-      scope = TREE_OPERAND (expression, 0);\n-      name = TREE_OPERAND (expression, 1);\n-\n-      /* The suggested resolution to Core Issue 2 implies that if the\n-\t qualifying type is the current class, then we must peek\n-\t inside it.  */\n-      if (DECL_P (name) \n-\t  && currently_open_class (scope)\n-\t  && !type_dependent_expression_p (name))\n-\treturn false;\n-      if (dependent_type_p (scope))\n-\treturn true;\n-    }\n+      && dependent_scope_ref_p (expression,\n+\t\t\t\ttype_dependent_expression_p))\n+    return true;\n \n   if (TREE_CODE (expression) == FUNCTION_DECL\n       && DECL_LANG_SPECIFIC (expression)"}, {"sha": "7844bb1a2a4d81b9e514264e69563e256eb1c3f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d83f79225703195e325dba0138432382e4dfab0", "patch": "@@ -1,5 +1,8 @@\n 2003-07-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/11509\n+\t* g++.dg/template/crash6.C: New test.\n+\n \tPR c++/7053\n \t* g++.dg/template/friend20.C: New test.\n "}, {"sha": "776e01ebb6dbf9451594f8e84f72bbfb757c64b3", "filename": "gcc/testsuite/g++.dg/template/crash6.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d83f79225703195e325dba0138432382e4dfab0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash6.C?ref=8d83f79225703195e325dba0138432382e4dfab0", "patch": "@@ -0,0 +1,8 @@\n+template <class> struct A { static const int n = 1; } ;\n+template <int> struct B;\n+\n+template <class S>\n+struct restype_order {\n+    static const int s = A<S>::n;\n+    typedef typename B<(s > 0)>::t t;\n+};"}]}