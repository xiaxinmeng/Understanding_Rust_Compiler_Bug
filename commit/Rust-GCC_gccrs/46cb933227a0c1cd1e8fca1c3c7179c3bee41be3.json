{"sha": "46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjYjkzMzIyN2EwYzFjZDFlOGZjYTFjM2M3MTc5YzNiZWU0MWJlMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-02-05T22:27:37Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-02-05T22:27:37Z"}, "message": "PR c++/69662 - -Wplacement-new on allocated one element array members\n\ngcc/testsuite/ChangeLog:\n\tPR c++/69662\n\t* g++.dg/warn/Wplacement-new-size-1.C: New test.\n\t* g++.dg/warn/Wplacement-new-size-2.C: New test.\n\ngcc/cp/ChangeLog:\n\tPR c++/69662\n\t* init.c (find_field_init): New function.\n\t(warn_placement_new_too_small): Call it.  Handle one-element arrays\n        at ends of structures special.\n\ngcc/c-family/ChangeLog:\n\tPR c++/69662\n\t* c.opt (Warning options): Update -Wplacement-new to take\n        an optional argument.\n\ngcc/ChangeLog:\n\tPR c++/69662\n\t* doc/invoke.texi: Update -Wplacement-new to take an optional\n        argument.\n\nFrom-SVN: r233190", "tree": {"sha": "541c8bae08fe762974822bede51ea47ee085418f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/541c8bae08fe762974822bede51ea47ee085418f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be2083eab7d8d276bafcd63b02fbf8ed0748e8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2083eab7d8d276bafcd63b02fbf8ed0748e8d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2083eab7d8d276bafcd63b02fbf8ed0748e8d4"}], "stats": {"total": 493, "additions": 478, "deletions": 15}, "files": [{"sha": "9a51133e00e67334375889360e12ed73dd891304", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -1,3 +1,9 @@\n+2016-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69662\n+\t* doc/invoke.texi: Update -Wplacement-new to take an optional\n+\targument.\n+\n 2016-02-06  Richard Henderson  <rth@redhat.com>\n \n \tPR c/69643"}, {"sha": "c4f6bc42a7ca01f85c9148fc66da6486f263b639", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -1,3 +1,9 @@\n+2016-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69662\n+\t* c.opt (Warning options): Update -Wplacement-new to take\n+\tan optional argument.\n+\n 2016-02-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/69543"}, {"sha": "04dec78eb8e11b883c661f388cee74916e16fb8a", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -777,7 +777,11 @@ ObjC ObjC++ Var(warn_protocol) Init(1) Warning\n Warn if inherited methods are unimplemented.\n \n Wplacement-new\n-C++ Var(warn_placement_new) Init(1) Warning\n+C++ Warning Alias(Wplacement-new=, 1, 0)\n+Warn for placement new expressions with undefined behavior.\n+\n+Wplacement-new=\n+C++ Joined RejectNegative UInteger Var(warn_placement_new) Init(-1) Warning\n Warn for placement new expressions with undefined behavior.\n \n Wredundant-decls"}, {"sha": "427425ae17a9c13057d6f4628bbcc3f4d820e16b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -1,3 +1,10 @@\n+2016-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69662\n+\t* init.c (find_field_init): New function.\n+\t(warn_placement_new_too_small): Call it.  Handle one-element arrays\n+\tat ends of structures special.\n+\n 2016-02-05  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/68948"}, {"sha": "cb2e852fdfc5e42458d9a48b2cfd8c4f876adf25", "filename": "gcc/cp/init.c", "status": "modified", "additions": 79, "deletions": 12, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -2285,6 +2285,33 @@ throw_bad_array_new_length (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \n+/* Attempt to find the initializer for field T in the initializer INIT,\n+   when non-null.  Returns the initializer when successful and NULL\n+   otherwise.  */\n+static tree\n+find_field_init (tree t, tree init)\n+{\n+  if (!init)\n+    return NULL_TREE;\n+\n+  unsigned HOST_WIDE_INT idx;\n+  tree field, elt;\n+\n+  /* Iterate over all top-level initializer elements.  */\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n+    {\n+      /* If the member T is found, return it.  */\n+      if (field == t)\n+\treturn elt;\n+\n+      /* Otherwise continue and/or recurse into nested initializers.  */\n+      if (TREE_CODE (elt) == CONSTRUCTOR\n+\t  && (init = find_field_init (t, elt)))\n+\treturn init;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Attempt to verify that the argument, OPER, of a placement new expression\n    refers to an object sufficiently large for an object of TYPE or an array\n    of NELTS of such objects when NELTS is non-null, and issue a warning when\n@@ -2375,10 +2402,25 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n       oper = TREE_OPERAND (oper, 0);\n     }\n \n+  /* Refers to the declared object that constains the subobject referenced\n+     by OPER.  When the object is initialized, makes it possible to determine\n+     the actual size of a flexible array member used as the buffer passed\n+     as OPER to placement new.  */\n+  tree var_decl = NULL_TREE;\n+  /* True when operand is a COMPONENT_REF, to distinguish flexible array\n+     members from arrays of unspecified size.  */\n+  bool compref = TREE_CODE (oper) == COMPONENT_REF;\n+\n   /* Descend into a struct or union to find the member whose address\n      is being used as the agument.  */\n   while (TREE_CODE (oper) == COMPONENT_REF)\n-    oper = TREE_OPERAND (oper, 1);\n+    {\n+      tree op0 = oper;\n+      while (TREE_CODE (op0 = TREE_OPERAND (op0, 0)) == COMPONENT_REF);\n+      if (TREE_CODE (op0) == VAR_DECL)\n+\tvar_decl = op0;\n+      oper = TREE_OPERAND (oper, 1);\n+    }\n \n   if ((addr_expr || !POINTER_TYPE_P (TREE_TYPE (oper)))\n       && (TREE_CODE (oper) == VAR_DECL\n@@ -2387,7 +2429,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n     {\n       /* A possibly optimistic estimate of the number of bytes available\n \t in the destination buffer.  */\n-      unsigned HOST_WIDE_INT bytes_avail;\n+      unsigned HOST_WIDE_INT bytes_avail = 0;\n       /* True when the estimate above is in fact the exact size\n \t of the destination buffer rather than an estimate.  */\n       bool exact_size = true;\n@@ -2410,20 +2452,45 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t     as the optimistic estimate of the available space in it.  */\n \t  bytes_avail = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (oper)));\n \t}\n+      else if (var_decl)\n+\t{\n+\t  /* Constructing into a buffer provided by the flexible array\n+\t     member of a declared object (which is permitted as a G++\n+\t     extension).  If the array member has been initialized,\n+\t     determine its size from the initializer.  Otherwise,\n+\t     the array size is zero.  */\n+\t  bytes_avail = 0;\n+\n+\t  if (tree init = find_field_init (oper, DECL_INITIAL (var_decl)))\n+\t    bytes_avail = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (init)));\n+\t}\n       else\n \t{\n \t  /* Bail if neither the size of the object nor its type is known.  */\n \t  return;\n \t}\n \n-      /* Avoid diagnosing flexible array members (accepted as an extension\n-\t and diagnosed with -Wpedantic).\n-\t Constructing objects that appear to overflow the C99 equivalent of\n-\t flexible array members (i.e., array members of size zero or one)\n-\t are diagnosed in C++ since their declaration cannot be diagnosed.  */\n-      if (bytes_avail == 0 && TREE_CODE (TREE_TYPE (oper)) == ARRAY_TYPE)\n-\treturn;\n+      tree_code oper_code = TREE_CODE (TREE_TYPE (oper));\n \n+      if (compref && oper_code == ARRAY_TYPE)\n+\t{\n+\t  /* Avoid diagnosing flexible array members (which are accepted\n+\t     as an extension and diagnosed with -Wpedantic) and zero-length\n+\t     arrays (also an extension).\n+\t     Overflowing construction in one-element arrays is diagnosed\n+\t     only at level 2.  */\n+\t  if (bytes_avail == 0 && !var_decl)\n+\t    return;\n+\n+\t  tree nelts = array_type_nelts_top (TREE_TYPE (oper));\n+\t  tree nelts_cst = maybe_constant_value (nelts);\n+\t  if (TREE_CODE (nelts_cst) == INTEGER_CST\n+\t      && integer_onep (nelts_cst)\n+\t      && !var_decl\n+\t      && warn_placement_new < 2)\n+\t    return;\n+\t}\n+\t  \n       /* The size of the buffer can only be adjusted down but not up.  */\n       gcc_checking_assert (0 <= adjust);\n \n@@ -2452,7 +2519,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t{\n \t  if (nelts)\n \t    if (CONSTANT_CLASS_P (nelts))\n-\t      warning_at (loc, OPT_Wplacement_new,\n+\t      warning_at (loc, OPT_Wplacement_new_,\n \t\t\t  exact_size ?\n \t\t\t  \"placement new constructing an object of type \"\n \t\t\t  \"%<%T [%wu]%> and size %qwu in a region of type %qT \"\n@@ -2464,7 +2531,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t\t  TREE_TYPE (oper),\n \t\t\t  bytes_avail);\n \t    else\n-\t      warning_at (loc, OPT_Wplacement_new,\n+\t      warning_at (loc, OPT_Wplacement_new_,\n \t\t\t  exact_size ?\n \t\t\t  \"placement new constructing an array of objects \"\n \t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n@@ -2475,7 +2542,7 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t\t  type, bytes_need, TREE_TYPE (oper),\n \t\t\t  bytes_avail);\n \t  else\n-\t    warning_at (loc, OPT_Wplacement_new,\n+\t    warning_at (loc, OPT_Wplacement_new_,\n \t\t\texact_size ?\n \t\t\t\"placement new constructing an object of type %qT \"\n \t\t\t\"and size %qwu in a region of type %qT and size %qwi\""}, {"sha": "0a2a6f45d7cf916a84dc48b6885cf04d43b12d8a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -281,7 +281,8 @@ Objective-C and Objective-C++ Dialects}.\n -Woverride-init-side-effects -Woverlength-strings @gol\n -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol\n -Wparentheses -Wno-pedantic-ms-format @gol\n--Wplacement-new -Wpointer-arith  -Wno-pointer-to-int-cast @gol\n+-Wplacement-new -Wplacement-new=@var{n} @gol\n+-Wpointer-arith  -Wno-pointer-to-int-cast @gol\n -Wno-pragmas -Wredundant-decls  -Wno-return-local-addr @gol\n -Wreturn-type  -Wsequence-point  -Wshadow  -Wno-shadow-ivar @gol\n -Wshift-overflow -Wshift-overflow=@var{n} @gol\n@@ -4894,6 +4895,7 @@ width specifiers @code{I32}, @code{I64}, and @code{I} used on Windows targets,\n which depend on the MS runtime.\n \n @item -Wplacement-new\n+@itemx -Wplacement-new=@var{n}\n @opindex Wplacement-new\n @opindex Wno-placement-new\n Warn about placement new expressions with undefined behavior, such as\n@@ -4906,7 +4908,36 @@ char buf [64];\n new (buf) int[64];\n @end smallexample\n This warning is enabled by default.\n-  \n+\n+@table @gcctabopt\n+@item -Wplacement-new=1\n+This is the default warning level of @option{-Wplacement-new}.  At this\n+level the warning is not issued for some strictly undefined constructs that\n+GCC allows as extensions for compatibility with legacy code.  For example,\n+the following @code{new} expression is not diagnosed at this level even\n+though it has undefined behavior according to the C++ standard because\n+it writes past the end of the one-element array.\n+@smallexample\n+struct S @{ int n, a[1]; @};\n+S *s = (S *)malloc (sizeof *s + 31 * sizeof s->a[0]);\n+new (s->a)int [32]();\n+@end smallexample\n+\n+@item -Wplacement-new=2\n+At this level, in addition to diagnosing all the same constructs as at level\n+1, a diagnostic is also issued for placement new expressions that construct\n+an object in the last member of structure whose type is an array of a single\n+element and whose size is less than the size of the object being constructed.\n+While the previous example would be diagnosed, the following construct makes\n+use of the flexible member array extension to avoid the warning at level 2.\n+@smallexample\n+struct S @{ int n, a[]; @};\n+S *s = (S *)malloc (sizeof *s + 32 * sizeof s->a[0]);\n+new (s->a)int [32]();\n+@end smallexample\n+\n+@end table\n+\n @item -Wpointer-arith\n @opindex Wpointer-arith\n @opindex Wno-pointer-arith"}, {"sha": "cce24b4eb2f592511e32a2347d919091f03771e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -1,3 +1,9 @@\n+2016-02-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69662\n+\t* g++.dg/warn/Wplacement-new-size-1.C: New test.\n+\t* g++.dg/warn/Wplacement-new-size-2.C: New test.\n+\n 2016-02-06  Richard HEnderson  <rth@redhat.com>\n \n \tPR c/69643"}, {"sha": "b549ae18e892e74a9369d5e586be6d7f77976497", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-1.C", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -0,0 +1,139 @@\n+// PR c++/69662 - -Wplacement-new on allocated one element array members\n+// Exercising the more permissive -Wplacement-new=1.  The difference\n+// between -Wplacement-new=1 is denoted by \"no warning at level 1\" in\n+// the comments below.\n+// { dg-do compile }\n+// { dg-options \"-Wno-pedantic -Wplacement-new=1\" }\n+\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void *p) { return p; }\n+void* operator new[] (size_t, void *p) { return p; }\n+\n+struct Ax { char n, a []; };\n+struct A0 { char n, a [0]; };\n+struct A1 { char n, a [1]; };\n+struct A2 { char n, a [2]; };\n+\n+typedef __INT16_TYPE__ Int16;\n+typedef __INT32_TYPE__ Int32;\n+\n+void fAx (Ax *px, Ax &rx)\n+{\n+  Ax ax;\n+  new (ax.a) Int32;    // { dg-warning \"placement\" }\n+  new (px->a) Int32;\n+  new (rx.a) Int32;\n+}\n+\n+void fAx2 ()\n+{\n+  Ax ax2 = { 1, { 2, 3 } };\n+\n+  new (ax2.a) Int16;\n+  new (ax2.a) Int32;    // { dg-warning \"placement\" }\n+}\n+\n+void fA0 (A0 *p0, A0 &r0)\n+{\n+  A0 a0;\n+  new (a0.a) Int32;    // { dg-warning \"placement\" }\n+  new (p0->a) Int32;\n+  new (r0.a) Int32;\n+}\n+\n+void fA1 (A1 *p1, A1 &r1)\n+{\n+  A1 a1;\n+  new (a1.a) Int32;    // { dg-warning \"placement\" }\n+  new (p1->a) Int32;   // no warning at level 1\n+  new (r1.a) Int32;    // no warning at level 1\n+}\n+\n+void fA2 (A2 *p2, A2 &r2)\n+{\n+  A2 a2;\n+  new (a2.a) Int32;    // { dg-warning \"placement\" }\n+  new (p2->a) Int32;   // { dg-warning \"placement\" }\n+  new (r2.a) Int32;    // { dg-warning \"placement\" }\n+}\n+\n+struct BAx { int i; Ax ax; };\n+struct BA0 { int i; A0 a0; };\n+struct BA1 { int i; A1 a1; };\n+struct BA2 { int i; A2 a2; };\n+\n+void fBx (BAx *pbx, BAx &rbx)\n+{\n+  BAx bax;\n+  new (bax.ax.a) char;     // { dg-warning \"placement\" }\n+  new (bax.ax.a) Int16;    // { dg-warning \"placement\" }\n+  new (bax.ax.a) Int32;    // { dg-warning \"placement\" }\n+\n+  new (pbx->ax.a) char;\n+  new (rbx.ax.a) char;\n+  new (pbx->ax.a) Int16;\n+  new (rbx.ax.a) Int16;\n+  new (pbx->ax.a) Int32;\n+  new (rbx.ax.a) Int32;\n+  new (pbx->ax.a) int[1234];\n+  new (rbx.ax.a) int[5678];\n+}\n+\n+void fBx1 ()\n+{\n+  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\n+\n+  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int16;    // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int32;    // { dg-warning \"placement\" }\n+}\n+\n+void fBx2 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\n+\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int16;\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fBx3 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\n+\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) Int16;\n+  new (bax2.ax.a) char[3];\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fB0 (BA0 *pb0, BA0 &rb0)\n+{\n+  BA0 ba0;\n+  new (ba0.a0.a) Int32;     // { dg-warning \"placement\" }\n+  new (pb0->a0.a) Int32;\n+  new (rb0.a0.a) Int32;\n+}\n+\n+void fB1 (BA1 *pb1, BA1 &rb1)\n+{\n+  BA1 ba1;\n+  new (ba1.a1.a) Int32;     // { dg-warning \"placement\" }\n+  new (pb1->a1.a) Int32;    // no warning at level 1\n+  new (rb1.a1.a) Int32;     // no warning at level 1\n+}\n+\n+void fB2 (BA2 *pb2, BA2 &rb2)\n+{\n+  BA2 ba2;\n+  new (ba2.a2.a) Int32;     // { dg-warning \"placement\" }\n+  new (pb2->a2.a) Int32;    // { dg-warning \"placement\" }\n+  new (rb2.a2.a) Int32;     // { dg-warning \"placement\" }\n+}"}, {"sha": "23d4324ff8782292ef9fe3cfd9338333e5c2f386", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-2.C", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C?ref=46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "patch": "@@ -0,0 +1,197 @@\n+// PR c++/69662 - -Wplacement-new on allocated one element array members\n+// Exercising -Wplacement-new=2.\n+// { dg-do compile }\n+// { dg-options \"-Wno-pedantic -Wplacement-new=2\" }\n+\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void *p) { return p; }\n+void* operator new[] (size_t, void *p) { return p; }\n+\n+struct Ax { char n, a []; };\n+struct A0 { char n, a [0]; };\n+struct A1 { char n, a [1]; };\n+struct A2 { char n, a [2]; };\n+\n+typedef __INT16_TYPE__ Int16;\n+typedef __INT32_TYPE__ Int32;\n+\n+void fAx (Ax *px, Ax &rx)\n+{\n+  Ax ax;\n+\n+  new (ax.a) Int32;           // { dg-warning \"placement\" }\n+  new (ax.a) Int32[1];        // { dg-warning \"placement\" }\n+\n+  new (px->a) Int32;\n+  new (px->a) Int32[1];\n+\n+  new (rx.a) Int32;\n+  new (rx.a) Int32[2];\n+}\n+\n+void fAx2 ()\n+{\n+  // Initialization of non-static objects with flexible array members\n+  // isn't allowed in C and should perhaps be disallowed in C++ as\n+  // well to avoid c++/69696 - incorrect initialization of block-scope\n+  // flexible array members.\n+  Ax ax2 = { 1, { 2, 3 } };\n+\n+  new (ax2.a) Int16;\n+  new (ax2.a) Int16[1];\n+  new (ax2.a) Int16[2];       // { dg-warning \"placement\" }\n+  new (ax2.a) Int32;          // { dg-warning \"placement\" }\n+  new (ax2.a) Int32[2];       // { dg-warning \"placement\" }\n+}\n+\n+void fAx3 ()\n+{\n+  static Ax ax3 = { 1, { 2, 3, 4 } };\n+\n+  new (ax3.a) Int16;\n+  new (ax3.a) Int16[1];\n+  new (ax3.a) Int16[2];       // { dg-warning \"placement\" }\n+  new (ax3.a) Int32;          // { dg-warning \"placement\" }\n+  new (ax3.a) Int32[1];       // { dg-warning \"placement\" }\n+}\n+\n+static Ax ax4 = { 1, { 2, 3, 4, 5 } };\n+\n+void fAx4 ()\n+{\n+  new (ax4.a) Int16;\n+  new (ax4.a) Int16[1]; \n+  new (ax4.a) Int16[2]; \n+  new (ax4.a) Int32;\n+  new (ax4.a) Int32[1];\n+  new (ax4.a) Int32[2];       // { dg-warning \"placement\" }\n+}\n+\n+void fA0 (A0 *p0, A0 &r0)\n+{\n+  A0 a0;\n+\n+  new (a0.a) Int32;           // { dg-warning \"placement\" }\n+  new (a0.a) Int32[1];        // { dg-warning \"placement\" }\n+\n+  new (p0->a) Int32;\n+  new (p0->a) Int32[1];\n+  new (p0->a) Int32[2];\n+\n+  new (r0.a) Int32;\n+  new (r0.a) Int32[1];\n+  new (r0.a) Int32[2];\n+}\n+\n+void fA1 (A1 *p1, A1 &r1)\n+{\n+  A1 a1;\n+\n+  new (a1.a) Int32;           // { dg-warning \"placement\" }\n+  new (a1.a) Int32[1];        // { dg-warning \"placement\" }\n+\n+  new (p1->a) Int32;          // { dg-warning \"placement\" }\n+  new (p1->a) Int32[1];       // { dg-warning \"placement\" }\n+  new (p1->a) Int32[2];       // { dg-warning \"placement\" }\n+\n+  new (r1.a) Int32;           // { dg-warning \"placement\" }\n+  new (r1.a) Int32[1];        // { dg-warning \"placement\" }\n+  new (r1.a) Int32[2];        // { dg-warning \"placement\" }\n+}\n+\n+void fA2 (A2 *p2, A2 &r2)\n+{\n+  A2 a2;\n+  new (a2.a) Int32;           // { dg-warning \"placement\" }\n+  new (a2.a) Int32[1];        // { dg-warning \"placement\" }\n+  new (a2.a) Int32[2];        // { dg-warning \"placement\" }\n+\n+  new (p2->a) Int32;          // { dg-warning \"placement\" }\n+  new (p2->a) Int32[1];       // { dg-warning \"placement\" }\n+  new (p2->a) Int32[2];       // { dg-warning \"placement\" }\n+\n+  new (r2.a) Int32;           // { dg-warning \"placement\" }\n+  new (r2.a) Int32[1];        // { dg-warning \"placement\" }\n+  new (r2.a) Int32[2];        // { dg-warning \"placement\" }\n+}\n+\n+struct BAx { int i; Ax ax; };\n+struct BA0 { int i; A0 a0; };\n+struct BA1 { int i; A1 a1; };\n+struct BA2 { int i; A2 a2; };\n+\n+void fBx (BAx *pbx, BAx &rbx)\n+{\n+  BAx bax;\n+  new (bax.ax.a) char;        // { dg-warning \"placement\" }\n+  new (bax.ax.a) Int16;       // { dg-warning \"placement\" }\n+  new (bax.ax.a) Int32;       // { dg-warning \"placement\" }\n+\n+  new (pbx->ax.a) char;\n+  new (rbx.ax.a) char;\n+  new (pbx->ax.a) Int16;\n+  new (rbx.ax.a) Int16;\n+  new (pbx->ax.a) Int32;\n+  new (rbx.ax.a) Int32;\n+  new (pbx->ax.a) int[1234];\n+  new (rbx.ax.a) int[5678];\n+}\n+\n+void fBx1 ()\n+{\n+  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\n+\n+  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char[2];    // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int16;      // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fBx2 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\n+\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int16;\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fBx3 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\n+\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) Int16;\n+  new (bax2.ax.a) char[3];\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fB0 (BA0 *pb0, BA0 &rb0)\n+{\n+  BA0 ba0;\n+  new (ba0.a0.a) Int32;       // { dg-warning \"placement\" }\n+  new (pb0->a0.a) Int32;\n+  new (rb0.a0.a) Int32;\n+}\n+\n+void fB1 (BA1 *pb1, BA1 &rb1)\n+{\n+  BA1 ba1;\n+  new (ba1.a1.a) Int32;       // { dg-warning \"placement\" }\n+  new (pb1->a1.a) Int32;      // { dg-warning \"placement\" }\n+  new (rb1.a1.a) Int32;       // { dg-warning \"placement\" }\n+}\n+\n+void fB2 (BA2 *pb2, BA2 &rb2)\n+{\n+  BA2 ba2;\n+  new (ba2.a2.a) Int32;       // { dg-warning \"placement\" }\n+  new (pb2->a2.a) Int32;      // { dg-warning \"placement\" }\n+  new (rb2.a2.a) Int32;       // { dg-warning \"placement\" }\n+}"}]}