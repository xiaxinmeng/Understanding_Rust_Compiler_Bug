{"sha": "2871d24f4a83bbe1131a6a08536193c125afdfdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3MWQyNGY0YTgzYmJlMTEzMWE2YTA4NTM2MTkzYzEyNWFmZGZkZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-09T13:51:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-09T13:51:20Z"}, "message": "(record_constant_1): Handle NON_LVALUE_EXPR.\n\nRewrite to use switch instead of if/then/elseif/else.\n\nFrom-SVN: r9141", "tree": {"sha": "65ea3b5086f8f9456a47bc9c3c2fef8407313a65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ea3b5086f8f9456a47bc9c3c2fef8407313a65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2871d24f4a83bbe1131a6a08536193c125afdfdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2871d24f4a83bbe1131a6a08536193c125afdfdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2871d24f4a83bbe1131a6a08536193c125afdfdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2871d24f4a83bbe1131a6a08536193c125afdfdd/comments", "author": null, "committer": null, "parents": [{"sha": "9040d8731a6606c504d55565b9523a2d02351fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9040d8731a6606c504d55565b9523a2d02351fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9040d8731a6606c504d55565b9523a2d02351fb8"}], "stats": {"total": 137, "additions": 73, "deletions": 64}, "files": [{"sha": "9bd761e676e850a89e0870862a221d8d0eee48df", "filename": "gcc/varasm.c", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2871d24f4a83bbe1131a6a08536193c125afdfdd/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2871d24f4a83bbe1131a6a08536193c125afdfdd/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2871d24f4a83bbe1131a6a08536193c125afdfdd", "patch": "@@ -2403,102 +2403,111 @@ record_constant_1 (exp)\n \n   obstack_1grow (&permanent_obstack, (unsigned int) code);\n \n-  if (code == INTEGER_CST)\n+  switch (code)\n     {\n+    case INTEGER_CST:\n       obstack_1grow (&permanent_obstack, TYPE_PRECISION (TREE_TYPE (exp)));\n       strp = (char *) &TREE_INT_CST_LOW (exp);\n       len = 2 * sizeof TREE_INT_CST_LOW (exp);\n-    }\n-  else if (code == REAL_CST)\n-    {\n+      break;\n+\n+    case REAL_CST:\n       obstack_1grow (&permanent_obstack, TYPE_PRECISION (TREE_TYPE (exp)));\n       strp = (char *) &TREE_REAL_CST (exp);\n       len = sizeof TREE_REAL_CST (exp);\n-    }\n-  else if (code == STRING_CST)\n-    {\n+      break;\n+\n+    case STRING_CST:\n       if (flag_writable_strings)\n \treturn;\n+\n       strp = TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n       obstack_grow (&permanent_obstack, (char *) &TREE_STRING_LENGTH (exp),\n \t\t    sizeof TREE_STRING_LENGTH (exp));\n-    }\n-  else if (code == COMPLEX_CST)\n-    {\n+      break;\n+\n+    case COMPLEX_CST:\n       record_constant_1 (TREE_REALPART (exp));\n       record_constant_1 (TREE_IMAGPART (exp));\n       return;\n-    }\n-  else if (code == CONSTRUCTOR && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-    {\n-      int nbytes = int_size_in_bytes (TREE_TYPE (exp));\n-      obstack_grow (&permanent_obstack, &nbytes, sizeof (nbytes));\n-      obstack_blank (&permanent_obstack, nbytes);\n-      get_set_constructor_bytes (exp,\n-\t\t\t\t (unsigned char *) permanent_obstack.next_free,\n-\t\t\t\t nbytes);\n-      return;\n-    }\n-  else if (code == CONSTRUCTOR)\n-    {\n-      register tree link;\n-      int length = list_length (CONSTRUCTOR_ELTS (exp));\n-      tree type;\n-\n-      obstack_grow (&permanent_obstack, (char *) &length, sizeof length);\n \n-      /* For record constructors, insist that the types match.\n-\t For arrays, just verify both constructors are for arrays.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-\ttype = TREE_TYPE (exp);\n-      else\n-\ttype = 0;\n-      obstack_grow (&permanent_obstack, (char *) &type, sizeof type);\n-\n-      /* For arrays, insist that the size in bytes match.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+    case CONSTRUCTOR:\n+      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n \t{\n-\t  int size = int_size_in_bytes (TREE_TYPE (exp));\n-\t  obstack_grow (&permanent_obstack, (char *) &size, sizeof size);\n+\t  int nbytes = int_size_in_bytes (TREE_TYPE (exp));\n+\t  obstack_grow (&permanent_obstack, &nbytes, sizeof (nbytes));\n+\t  obstack_blank (&permanent_obstack, nbytes);\n+\t  get_set_constructor_bytes\n+\t    (exp, (unsigned char *) permanent_obstack.next_free, nbytes);\n+\t  return;\n \t}\n-\n-      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+      else\n \t{\n-\t  if (TREE_VALUE (link))\n-\t    record_constant_1 (TREE_VALUE (link));\n+\t  register tree link;\n+\t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n+\t  tree type;\n+\n+\t  obstack_grow (&permanent_obstack, (char *) &length, sizeof length);\n+\n+\t  /* For record constructors, insist that the types match.\n+\t     For arrays, just verify both constructors are for arrays.  */\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\t    type = TREE_TYPE (exp);\n \t  else\n+\t    type = 0;\n+\t  obstack_grow (&permanent_obstack, (char *) &type, sizeof type);\n+\n+\t  /* For arrays, insist that the size in bytes match.  */\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n \t    {\n-\t      tree zero = 0;\n+\t      int size = int_size_in_bytes (TREE_TYPE (exp));\n+\t      obstack_grow (&permanent_obstack, (char *) &size, sizeof size);\n+\t    }\n \n-\t      obstack_grow (&permanent_obstack, (char *) &zero, sizeof zero);\n+\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t    {\n+\t      if (TREE_VALUE (link))\n+\t\trecord_constant_1 (TREE_VALUE (link));\n+\t      else\n+\t\t{\n+\t\t  tree zero = 0;\n+\n+\t\t  obstack_grow (&permanent_obstack,\n+\t\t\t\t(char *) &zero, sizeof zero);\n+\t\t}\n \t    }\n \t}\n-\n       return;\n-    }\n-  else if (code == ADDR_EXPR)\n-    {\n-      struct addr_const value;\n-      decode_addr_const (exp, &value);\n-      /* Record the offset.  */\n-      obstack_grow (&permanent_obstack,\n-\t\t    (char *) &value.offset, sizeof value.offset);\n-      /* Record the symbol name.  */\n-      obstack_grow (&permanent_obstack, XSTR (value.base, 0),\n-\t\t    strlen (XSTR (value.base, 0)) + 1);\n+\n+    case ADDR_EXPR:\n+      {\n+\tstruct addr_const value;\n+\n+\tdecode_addr_const (exp, &value);\n+\t/* Record the offset.  */\n+\tobstack_grow (&permanent_obstack,\n+\t\t      (char *) &value.offset, sizeof value.offset);\n+\t/* Record the symbol name.  */\n+\tobstack_grow (&permanent_obstack, XSTR (value.base, 0),\n+\t\t      strlen (XSTR (value.base, 0)) + 1);\n+      }\n       return;\n-    }\n-  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n-    {\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n       record_constant_1 (TREE_OPERAND (exp, 0));\n       record_constant_1 (TREE_OPERAND (exp, 1));\n       return;\n-    }\n-  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n-    {\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n       record_constant_1 (TREE_OPERAND (exp, 0));\n       return;\n+\n+    default:\n+      abort ();\n     }\n \n   /* Record constant contents.  */"}]}