{"sha": "1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0Yjk5YzE3MmI4YTU0ODVkODRlMjRkYjE2Y2NiZDg0N2E0YjFiNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-28T07:15:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-28T07:15:57Z"}, "message": "tree-vectorizer.h (struct _slp_instance): Remove body_cost_vec member.\n\n2015-05-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct _slp_instance): Remove body_cost_vec\n\tmember.\n\t(SLP_INSTANCE_BODY_COST_VEC): Remove.\n\t(vect_update_slp_costs_according_to_vf): Likewise.\n\t(vect_slp_analyze_operations): Update prototype.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Remove call to\n\tvect_update_slp_costs_according_to_vf, adjust.\n\t* tree-vect-slp.c (vect_free_slp_instance): Adjust.\n\t(vect_analyze_slp_cost_1): Likewise.\n\t(vect_analyze_slp_cost): Likewise.  Properly deal with\n\twidening reduction ops.  Commit body costs.\n\t(vect_analyze_slp_instance): Adjust.  Do not analyze SLP\n\tcost for loops from here.\n\t(vect_slp_analyze_operations): But do it from here when\n\tthe vectorization factor is known and stmts are analyzed.\n\t(vect_bb_vectorization_profitable_p): Simplify.\n\t(vect_slp_analyze_bb_1): Do not compute SLP cost here.\n\t(vect_update_slp_costs_according_to_vf): Remove.\n\nFrom-SVN: r223798", "tree": {"sha": "b9a3b761a0bd416561dd650f412b812fb82bf201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9a3b761a0bd416561dd650f412b812fb82bf201"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "428b381275bc95032274440f02d7719225de2c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428b381275bc95032274440f02d7719225de2c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428b381275bc95032274440f02d7719225de2c17"}], "stats": {"total": 185, "additions": 78, "deletions": 107}, "files": [{"sha": "8742a222141b485df0e43671d6c72598d0287a21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "patch": "@@ -1,3 +1,24 @@\n+2015-05-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct _slp_instance): Remove body_cost_vec\n+\tmember.\n+\t(SLP_INSTANCE_BODY_COST_VEC): Remove.\n+\t(vect_update_slp_costs_according_to_vf): Likewise.\n+\t(vect_slp_analyze_operations): Update prototype.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Remove call to\n+\tvect_update_slp_costs_according_to_vf, adjust.\n+\t* tree-vect-slp.c (vect_free_slp_instance): Adjust.\n+\t(vect_analyze_slp_cost_1): Likewise.\n+\t(vect_analyze_slp_cost): Likewise.  Properly deal with\n+\twidening reduction ops.  Commit body costs.\n+\t(vect_analyze_slp_instance): Adjust.  Do not analyze SLP\n+\tcost for loops from here.\n+\t(vect_slp_analyze_operations): But do it from here when\n+\tthe vectorization factor is known and stmts are analyzed.\n+\t(vect_bb_vectorization_profitable_p): Simplify.\n+\t(vect_slp_analyze_bb_1): Do not compute SLP cost here.\n+\t(vect_update_slp_costs_according_to_vf): Remove.\n+\n 2015-05-27  Magnus Granberg  <zorry@gentoo.org>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "8fe4dc6ad30995685065e74d2b3fe71077b4c50e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "patch": "@@ -1814,15 +1814,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n \t  /* Update the vectorization factor based on the SLP decision.  */\n \t  vect_update_vf_for_slp (loop_vinfo);\n \n-\t  /* Once VF is set, SLP costs should be updated since the number of\n-\t     created vector stmts depends on VF.  */\n-\t  vect_update_slp_costs_according_to_vf (loop_vinfo);\n-\n \t  /* Analyze operations in the SLP instances.  Note this may\n \t     remove unsupported SLP instances which makes the above\n \t     SLP kind detection invalid.  */\n \t  unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n-\t  vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n+\t  vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n+\t\t\t\t       LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n \t  if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n \t    return false;\n \t}"}, {"sha": "9137144e67a8b86636484cc329f55a49055e708f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 53, "deletions": 96, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "patch": "@@ -130,7 +130,6 @@ vect_free_slp_instance (slp_instance instance)\n {\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n   SLP_INSTANCE_LOADS (instance).release ();\n-  SLP_INSTANCE_BODY_COST_VEC (instance).release ();\n   free (instance);\n }\n \n@@ -1546,13 +1545,11 @@ vect_find_last_scalar_stmt_in_slp (slp_tree node)\n /* Compute the cost for the SLP node NODE in the SLP instance INSTANCE.  */\n \n static void\n-vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-\t\t\t slp_instance instance, slp_tree node,\n+vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t\t\t stmt_vector_for_cost *prologue_cost_vec,\n+\t\t\t stmt_vector_for_cost *body_cost_vec,\n \t\t\t unsigned ncopies_for_cost)\n {\n-  stmt_vector_for_cost *body_cost_vec = &SLP_INSTANCE_BODY_COST_VEC (instance);\n-\n   unsigned i;\n   slp_tree child;\n   gimple stmt, s;\n@@ -1563,9 +1560,8 @@ vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Recurse down the SLP tree.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (child)\n-      vect_analyze_slp_cost_1 (loop_vinfo, bb_vinfo,\n-\t\t\t       instance, child, prologue_cost_vec,\n-\t\t\t       ncopies_for_cost);\n+      vect_analyze_slp_cost_1 (instance, child, prologue_cost_vec,\n+\t\t\t       body_cost_vec, ncopies_for_cost);\n \n   /* Look at the first scalar stmt to determine the cost.  */\n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -1622,7 +1618,8 @@ vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       enum vect_def_type dt;\n       if (!op || op == lhs)\n \tcontinue;\n-      if (vect_is_simple_use (op, NULL, loop_vinfo, bb_vinfo,\n+      if (vect_is_simple_use (op, NULL, STMT_VINFO_LOOP_VINFO (stmt_info),\n+\t\t\t      STMT_VINFO_BB_VINFO (stmt_info),\n \t\t\t      &def_stmt, &def, &dt))\n \t{\n \t  /* Without looking at the actual initializer a vector of\n@@ -1642,8 +1639,7 @@ vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n /* Compute the cost for the SLP instance INSTANCE.  */\n \n static void\n-vect_analyze_slp_cost (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-\t\t       slp_instance instance, unsigned nunits)\n+vect_analyze_slp_cost (slp_instance instance, void *data)\n {\n   stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n   unsigned ncopies_for_cost;\n@@ -1654,20 +1650,38 @@ vect_analyze_slp_cost (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n      GROUP_SIZE / NUNITS otherwise.  */\n   unsigned group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+  slp_tree node = SLP_INSTANCE_TREE (instance);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n+  /* Adjust the group_size by the vectorization factor which is always one\n+     for basic-block vectorization.  */\n+  if (STMT_VINFO_LOOP_VINFO (stmt_info))\n+    group_size *= LOOP_VINFO_VECT_FACTOR (STMT_VINFO_LOOP_VINFO (stmt_info));\n+  unsigned nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+  /* For reductions look at a reduction operand in case the reduction\n+     operation is widening like DOT_PROD or SAD.  */\n+  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    {\n+      gimple stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+      switch (gimple_assign_rhs_code (stmt))\n+\t{\n+\tcase DOT_PROD_EXPR:\n+\tcase SAD_EXPR:\n+\t  nunits = TYPE_VECTOR_SUBPARTS (get_vectype_for_scalar_type\n+\t\t\t\t(TREE_TYPE (gimple_assign_rhs1 (stmt))));\n+\t  break;\n+\tdefault:;\n+\t}\n+    }\n   ncopies_for_cost = least_common_multiple (nunits, group_size) / nunits;\n \n   prologue_cost_vec.create (10);\n   body_cost_vec.create (10);\n-  SLP_INSTANCE_BODY_COST_VEC (instance) = body_cost_vec;\n-  vect_analyze_slp_cost_1 (loop_vinfo, bb_vinfo,\n-\t\t\t   instance, SLP_INSTANCE_TREE (instance),\n-\t\t\t   &prologue_cost_vec, ncopies_for_cost);\n+  vect_analyze_slp_cost_1 (instance, SLP_INSTANCE_TREE (instance),\n+\t\t\t   &prologue_cost_vec, &body_cost_vec,\n+\t\t\t   ncopies_for_cost);\n \n   /* Record the prologue costs, which were delayed until we were\n-     sure that SLP was successful.  Unlike the body costs, we know\n-     the final values now regardless of the loop vectorization factor.  */\n-  void *data = (loop_vinfo ? LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n-\t\t: BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n+     sure that SLP was successful.  */\n   FOR_EACH_VEC_ELT (prologue_cost_vec, i, si)\n     {\n       struct _stmt_vec_info *stmt_info\n@@ -1676,7 +1690,17 @@ vect_analyze_slp_cost (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t    si->misalign, vect_prologue);\n     }\n \n+  /* Record the instance's instructions in the target cost model.  */\n+  FOR_EACH_VEC_ELT (body_cost_vec, i, si)\n+    {\n+      struct _stmt_vec_info *stmt_info\n+\t= si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+      (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n+\t\t\t    si->misalign, vect_body);\n+    }\n+\n   prologue_cost_vec.release ();\n+  body_cost_vec.release ();\n }\n \n /* Analyze an SLP instance starting from a group of grouped stores.  Call\n@@ -1811,7 +1835,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_TREE (new_instance) = node;\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n-      SLP_INSTANCE_BODY_COST_VEC (new_instance) = vNULL;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n \n       /* Compute the load permutation.  */\n@@ -1863,13 +1886,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \n       if (loop_vinfo)\n-\t{\n-\t  /* Compute the costs of this SLP instance.  Delay this for BB\n-\t     vectorization as we don't have vector types computed yet.  */\n-\t  vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n-\t\t\t\t new_instance, TYPE_VECTOR_SUBPARTS (vectype));\n-\t  LOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n-\t}\n+\tLOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n       else\n         BB_VINFO_SLP_INSTANCES (bb_vinfo).safe_push (new_instance);\n \n@@ -2237,7 +2254,7 @@ vect_slp_analyze_node_operations (slp_tree node)\n    operations are supported. */\n \n bool\n-vect_slp_analyze_operations (vec<slp_instance> slp_instances)\n+vect_slp_analyze_operations (vec<slp_instance> slp_instances, void *data)\n {\n   slp_instance instance;\n   int i;\n@@ -2259,7 +2276,11 @@ vect_slp_analyze_operations (vec<slp_instance> slp_instances)\n           slp_instances.ordered_remove (i);\n \t}\n       else\n-        i++;\n+\t{\n+\t  /* Compute the costs of the SLP instance.  */\n+\t  vect_analyze_slp_cost (instance, data);\n+\t  i++;\n+\t}\n     }\n \n   if (!slp_instances.length ())\n@@ -2342,26 +2363,9 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n {\n   vec<slp_instance> slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n   slp_instance instance;\n-  int i, j;\n+  int i;\n   unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n   unsigned int vec_prologue_cost = 0, vec_epilogue_cost = 0;\n-  void *target_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n-  stmt_vec_info stmt_info = NULL;\n-  stmt_vector_for_cost body_cost_vec;\n-  stmt_info_for_cost *ci;\n-\n-  /* Calculate vector costs.  */\n-  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    {\n-      body_cost_vec = SLP_INSTANCE_BODY_COST_VEC (instance);\n-\n-      FOR_EACH_VEC_ELT (body_cost_vec, j, ci)\n-\t{\n-\t  stmt_info = ci->stmt ? vinfo_for_stmt (ci->stmt) : NULL;\n-\t  (void) add_stmt_cost (target_cost_data, ci->count, ci->kind,\n-\t\t\t\tstmt_info, ci->misalign, vect_body);\n-\t}\n-    }\n \n   /* Calculate scalar cost.  */\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n@@ -2519,7 +2523,8 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo)))\n+  if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo),\n+\t\t\t\t    BB_VINFO_TARGET_COST_DATA (bb_vinfo)))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2529,15 +2534,6 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  /* Compute the costs of the SLP instances.  */\n-  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    {\n-      gimple stmt = SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0];\n-      tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-      vect_analyze_slp_cost (NULL, bb_vinfo,\n-\t\t\t     instance, TYPE_VECTOR_SUBPARTS (vectype));\n-    }\n-\n   /* Cost model: check if the vectorization is worthwhile.  */\n   if (!unlimited_cost_model (NULL)\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))\n@@ -2616,45 +2612,6 @@ vect_slp_analyze_bb (basic_block bb)\n }\n \n \n-/* SLP costs are calculated according to SLP instance unrolling factor (i.e.,\n-   the number of created vector stmts depends on the unrolling factor).\n-   However, the actual number of vector stmts for every SLP node depends on\n-   VF which is set later in vect_analyze_operations ().  Hence, SLP costs\n-   should be updated.  In this function we assume that the inside costs\n-   calculated in vect_model_xxx_cost are linear in ncopies.  */\n-\n-void\n-vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n-{\n-  unsigned int i, j, vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  vec<slp_instance> slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  slp_instance instance;\n-  stmt_vector_for_cost body_cost_vec;\n-  stmt_info_for_cost *si;\n-  void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_update_slp_costs_according_to_vf ===\\n\");\n-\n-  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    {\n-      /* We assume that costs are linear in ncopies.  */\n-      int ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (instance);\n-\n-      /* Record the instance's instructions in the target cost model.\n-\t This was delayed until here because the count of instructions\n-\t isn't known beforehand.  */\n-      body_cost_vec = SLP_INSTANCE_BODY_COST_VEC (instance);\n-\n-      FOR_EACH_VEC_ELT (body_cost_vec, j, si)\n-\t(void) add_stmt_cost (data, si->count * ncopies, si->kind,\n-\t\t\t      vinfo_for_stmt (si->stmt), si->misalign,\n-\t\t\t      vect_body);\n-    }\n-}\n-\n-\n /* For constant and loop invariant defs of SLP_NODE this function returns\n    (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.\n    OP_NUM determines if we gather defs for operand 0 or operand 1 of the RHS of"}, {"sha": "9976096d476a1501e3905216d6046670b1060f3a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4b99c172b8a5485d84e24db16ccbd847a4b1b7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1a4b99c172b8a5485d84e24db16ccbd847a4b1b7", "patch": "@@ -128,9 +128,6 @@ typedef struct _slp_instance {\n   /* The unrolling factor required to vectorized this SLP instance.  */\n   unsigned int unrolling_factor;\n \n-  /* Vectorization costs associated with SLP instance.  */\n-  stmt_vector_for_cost body_cost_vec;\n-\n   /* The group of nodes that contain loads of this SLP instance.  */\n   vec<slp_tree> loads;\n } *slp_instance;\n@@ -140,7 +137,6 @@ typedef struct _slp_instance {\n #define SLP_INSTANCE_TREE(S)                     (S)->root\n #define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n-#define SLP_INSTANCE_BODY_COST_VEC(S)            (S)->body_cost_vec\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n@@ -1114,9 +1110,9 @@ extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           gimple_stmt_iterator *, int,\n                                           slp_instance, bool);\n-extern bool vect_slp_analyze_operations (vec<slp_instance> slp_instances);\n+extern bool vect_slp_analyze_operations (vec<slp_instance> slp_instances,\n+\t\t\t\t\t void *);\n extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n-extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n extern bool vect_analyze_slp (loop_vec_info, bb_vec_info, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);"}]}