{"sha": "a5bcc58230c173c6923908cd7622dca7240f18de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTViY2M1ODIzMGMxNzNjNjkyMzkwOGNkNzYyMmRjYTcyNDBmMThkZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-01T09:34:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-01T09:34:09Z"}, "message": "re PR c++/11295 (ICE when using a non-trivial object in a compound statement expression)\n\n\tPR c++/11295\n\t* doc/extend.texi (Statement Expressions): Document C++ semantics.\ncp:\n\tPR c++/11295\n\t* cp-tree.h (tubst_flags_t): Add tf_stmt_expr_cmpd,\n\ttf_stmt_expr_body.\n\t(finish_stmt_expr_expr): Declare.\n\t* parser.c (cp_parser_primary_expression): Tell\n\tcp_parser_compount_statement that it is a statement expression.\n\t(cp_parser_statement, cp_parser_labeled_statement,\n\tcp_parser_compound_statement, cp_parser_statement_seq_opt): Add\n\tin_statement_expr_p parameter.\n\t(cp_parser_expression_statement): Likewise. Call\n\tfinish_stmt_expr_expr for final expression of a statement\n\texpression.\n\t(cp_parser_for_init_statement,\n\tcp_parser_implicitly_scoped_statement,\n\tcp_parser_already_scoped_statement, cp_parser_function_definition,\n\tcp_parser_try_block, cp_parser_handled): Adjust.\n\t* pt.c (tsubst_copy) <STMT_EXPR case>: Pass tf_stmt_expr.\n\t(tsubst_expr): Process tf_stmt_expr and tf_stmt_exprs flags.\n\t(tsubst_expr) <EXPR_STMT case>: Check tf_stmt_exprs flag.\n\t* semantics.c (finish_expr_stmt): Do not deal with statement\n\texpressions.\n\t(begin_stmt_expr): Clear last_expr_type.\n\t(finish_stmt_expr_expr): New.\n\t(finish_stmt_expr): Process the value expression.\ntestsuite:\n\tPR c++/11295\n\t* g++.dg/ext/stmtexpr1.C: New test.\n\nFrom-SVN: r70043", "tree": {"sha": "bbb501c90255aea4dd7368daf077d8f0d4280c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbb501c90255aea4dd7368daf077d8f0d4280c1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5bcc58230c173c6923908cd7622dca7240f18de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5bcc58230c173c6923908cd7622dca7240f18de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5bcc58230c173c6923908cd7622dca7240f18de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5bcc58230c173c6923908cd7622dca7240f18de/comments", "author": null, "committer": null, "parents": [{"sha": "d340e53fc39cdfc88b89ec4a420719dc31aadca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d340e53fc39cdfc88b89ec4a420719dc31aadca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d340e53fc39cdfc88b89ec4a420719dc31aadca8"}], "stats": {"total": 421, "additions": 322, "deletions": 99}, "files": [{"sha": "56fe21a8a30c85c4b41284b5489a494734748f90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -1,3 +1,8 @@\n+2003-08-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11295\n+\t* doc/extend.texi (Statement Expressions): Document C++ semantics.\n+\n 2003-07-31  SUGIOKA Toshinobu  <sugioka@itonet.co.jp>\n \n \t* config.gcc (sh-*-linux*): Do not override sh/t-linux with sh/t-le."}, {"sha": "07fffc2f97554cc880fe03b528a56fd55844733a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -1,5 +1,30 @@\n 2003-08-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR c++/11295\n+\t* cp-tree.h (tubst_flags_t): Add tf_stmt_expr_cmpd,\n+\ttf_stmt_expr_body.\n+\t(finish_stmt_expr_expr): Declare.\n+\t* parser.c (cp_parser_primary_expression): Tell\n+\tcp_parser_compount_statement that it is a statement expression.\n+\t(cp_parser_statement, cp_parser_labeled_statement,\n+\tcp_parser_compound_statement, cp_parser_statement_seq_opt): Add\n+\tin_statement_expr_p parameter.\n+\t(cp_parser_expression_statement): Likewise. Call\n+\tfinish_stmt_expr_expr for final expression of a statement\n+\texpression.\n+\t(cp_parser_for_init_statement,\n+\tcp_parser_implicitly_scoped_statement,\n+\tcp_parser_already_scoped_statement, cp_parser_function_definition,\n+\tcp_parser_try_block, cp_parser_handled): Adjust.\n+\t* pt.c (tsubst_copy) <STMT_EXPR case>: Pass tf_stmt_expr.\n+\t(tsubst_expr): Process tf_stmt_expr and tf_stmt_exprs flags.\n+\t(tsubst_expr) <EXPR_STMT case>: Check tf_stmt_exprs flag.\n+\t* semantics.c (finish_expr_stmt): Do not deal with statement\n+\texpressions.\n+\t(begin_stmt_expr): Clear last_expr_type.\n+\t(finish_stmt_expr_expr): New.\n+\t(finish_stmt_expr): Process the value expression.\n+\t\n \t* typeck.c (build_compound_expr): If RHS is a TARGET_EXPR, put the\n \tcompound expr inside the target's initializer.\n \t"}, {"sha": "f62255b2f39c6ee6c4a3771509b309885d7c4fff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -3056,8 +3056,13 @@ typedef enum tsubst_flags_t {\n \t\t\t\t   (make_typename_type use) */\n   tf_ptrmem_ok = 1 << 4,        /* pointers to member ok (internal\n \t\t\t\t   instantiate_type use) */\n-  tf_user = 1 << 5\t\t/* Found template must be a user template\n+  tf_user = 1 << 5,\t\t/* found template must be a user template\n \t\t\t\t   (lookup_template_class use) */\n+  tf_stmt_expr_cmpd = 1 << 6,   /* tsubsting the compound statement of\n+\t\t\t\t   a statement expr.  */\n+  tf_stmt_expr_body = 1 << 7    /* tsubsting the statements in the\n+\t\t\t       \t   body of the compound statement of a\n+\t\t\t       \t   statement expr.  */\n } tsubst_flags_t;\n \n /* The kind of checking we can do looking in a class hierarchy.  */\n@@ -4134,6 +4139,7 @@ extern void finish_subobject                    (tree);\n extern tree finish_parenthesized_expr           (tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n extern tree begin_stmt_expr                     (void);\n+extern tree finish_stmt_expr_expr \t\t(tree);\n extern tree finish_stmt_expr                    (tree);\n extern tree perform_koenig_lookup               (tree, tree);\n extern tree finish_call_expr                    (tree, tree, bool);"}, {"sha": "51f4eda4a6afd264ac9176a8f626352b9cad6e96", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -1367,15 +1367,15 @@ static tree cp_parser_constant_expression\n /* Statements [gram.stmt.stmt]  */\n \n static void cp_parser_statement\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_labeled_statement\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_expression_statement\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_compound_statement\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static void cp_parser_statement_seq_opt\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_selection_statement\n   (cp_parser *);\n static tree cp_parser_condition\n@@ -2244,7 +2244,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Start the statement-expression.  */\n \t    expr = begin_stmt_expr ();\n \t    /* Parse the compound-statement.  */\n-\t    cp_parser_compound_statement (parser);\n+\t    cp_parser_compound_statement (parser, true);\n \t    /* Finish up.  */\n \t    expr = finish_stmt_expr (expr);\n \t  }\n@@ -5075,7 +5075,7 @@ cp_parser_constant_expression (cp_parser* parser,\n      try-block  */\n \n static void\n-cp_parser_statement (cp_parser* parser)\n+cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n {\n   tree statement;\n   cp_token *token;\n@@ -5097,7 +5097,8 @@ cp_parser_statement (cp_parser* parser)\n \t{\n \tcase RID_CASE:\n \tcase RID_DEFAULT:\n-\t  statement = cp_parser_labeled_statement (parser);\n+\t  statement = cp_parser_labeled_statement (parser,\n+\t\t\t\t\t\t   in_statement_expr_p);\n \t  break;\n \n \tcase RID_IF:\n@@ -5134,11 +5135,11 @@ cp_parser_statement (cp_parser* parser)\n \t labeled-statement.  */\n       token = cp_lexer_peek_nth_token (parser->lexer, 2);\n       if (token->type == CPP_COLON)\n-\tstatement = cp_parser_labeled_statement (parser);\n+\tstatement = cp_parser_labeled_statement (parser, in_statement_expr_p);\n     }\n   /* Anything that starts with a `{' must be a compound-statement.  */\n   else if (token->type == CPP_OPEN_BRACE)\n-    statement = cp_parser_compound_statement (parser);\n+    statement = cp_parser_compound_statement (parser, false);\n \n   /* Everything else must be a declaration-statement or an\n      expression-statement.  Try for the declaration-statement \n@@ -5156,7 +5157,7 @@ cp_parser_statement (cp_parser* parser)\n \t    return;\n \t}\n       /* Look for an expression-statement instead.  */\n-      statement = cp_parser_expression_statement (parser);\n+      statement = cp_parser_expression_statement (parser, in_statement_expr_p);\n     }\n \n   /* Set the line number for the statement.  */\n@@ -5175,7 +5176,7 @@ cp_parser_statement (cp_parser* parser)\n    an ordinary label, returns a LABEL_STMT.  */\n \n static tree\n-cp_parser_labeled_statement (cp_parser* parser)\n+cp_parser_labeled_statement (cp_parser* parser, bool in_statement_expr_p)\n {\n   cp_token *token;\n   tree statement = NULL_TREE;\n@@ -5222,7 +5223,7 @@ cp_parser_labeled_statement (cp_parser* parser)\n   /* Require the `:' token.  */\n   cp_parser_require (parser, CPP_COLON, \"`:'\");\n   /* Parse the labeled statement.  */\n-  cp_parser_statement (parser);\n+  cp_parser_statement (parser, in_statement_expr_p);\n \n   /* Return the label, in the case of a `case' or `default' label.  */\n   return statement;\n@@ -5234,25 +5235,35 @@ cp_parser_labeled_statement (cp_parser* parser)\n      expression [opt] ;\n \n    Returns the new EXPR_STMT -- or NULL_TREE if the expression\n-   statement consists of nothing more than an `;'.  */\n+   statement consists of nothing more than an `;'. IN_STATEMENT_EXPR_P\n+   indicates whether this expression-statement is part of an\n+   expression statement.  */\n \n static tree\n-cp_parser_expression_statement (cp_parser* parser)\n+cp_parser_expression_statement (cp_parser* parser, bool in_statement_expr_p)\n {\n-  tree statement;\n+  tree statement = NULL_TREE;\n \n-  /* If the next token is not a `;', then there is an expression to parse.  */\n+  /* If the next token is a ';', then there is no expression\n+     statement. */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    statement = finish_expr_stmt (cp_parser_expression (parser));\n-  /* Otherwise, we do not even bother to build an EXPR_STMT.  */\n-  else\n-    {\n-      finish_stmt ();\n-      statement = NULL_TREE;\n-    }\n+    statement = cp_parser_expression (parser);\n+  \n   /* Consume the final `;'.  */\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n+  if (in_statement_expr_p\n+      && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+    {\n+      /* This is the final expression statement of a statement\n+\t expression.  */\n+      statement = finish_stmt_expr_expr (statement);\n+    }\n+  else if (statement)\n+    statement = finish_expr_stmt (statement);\n+  else\n+    finish_stmt ();\n+  \n   return statement;\n }\n \n@@ -5264,7 +5275,7 @@ cp_parser_expression_statement (cp_parser* parser)\n    Returns a COMPOUND_STMT representing the statement.  */\n \n static tree\n-cp_parser_compound_statement (cp_parser *parser)\n+cp_parser_compound_statement (cp_parser *parser, bool in_statement_expr_p)\n {\n   tree compound_stmt;\n \n@@ -5274,7 +5285,7 @@ cp_parser_compound_statement (cp_parser *parser)\n   /* Begin the compound-statement.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/false);\n   /* Parse an (optional) statement-seq.  */\n-  cp_parser_statement_seq_opt (parser);\n+  cp_parser_statement_seq_opt (parser, in_statement_expr_p);\n   /* Finish the compound-statement.  */\n   finish_compound_stmt (compound_stmt);\n   /* Consume the `}'.  */\n@@ -5290,7 +5301,7 @@ cp_parser_compound_statement (cp_parser *parser)\n      statement-seq [opt] statement  */\n \n static void\n-cp_parser_statement_seq_opt (cp_parser* parser)\n+cp_parser_statement_seq_opt (cp_parser* parser, bool in_statement_expr_p)\n {\n   /* Scan statements until there aren't any more.  */\n   while (true)\n@@ -5301,7 +5312,7 @@ cp_parser_statement_seq_opt (cp_parser* parser)\n \tbreak;\n \n       /* Parse the statement.  */\n-      cp_parser_statement (parser);\n+      cp_parser_statement (parser, in_statement_expr_p);\n     }\n }\n \n@@ -5631,7 +5642,7 @@ cp_parser_for_init_statement (cp_parser* parser)\n \treturn;\n     }\n \n-  cp_parser_expression_statement (parser);\n+  cp_parser_expression_statement (parser, false);\n }\n \n /* Parse a jump-statement.\n@@ -5756,13 +5767,13 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser)\n       /* Create a compound-statement.  */\n       statement = begin_compound_stmt (/*has_no_scope=*/false);\n       /* Parse the dependent-statement.  */\n-      cp_parser_statement (parser);\n+      cp_parser_statement (parser, false);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n     }\n   /* Otherwise, we simply parse the statement directly.  */\n   else\n-    statement = cp_parser_compound_statement (parser);\n+    statement = cp_parser_compound_statement (parser, false);\n \n   /* Return the statement.  */\n   return statement;\n@@ -5784,13 +5795,13 @@ cp_parser_already_scoped_statement (cp_parser* parser)\n       /* Create a compound-statement.  */\n       statement = begin_compound_stmt (/*has_no_scope=*/true);\n       /* Parse the dependent-statement.  */\n-      cp_parser_statement (parser);\n+      cp_parser_statement (parser, false);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n     }\n   /* Otherwise, we simply parse the statement directly.  */\n   else\n-    cp_parser_statement (parser);\n+    cp_parser_statement (parser, false);\n }\n \n /* Declarations [gram.dcl.dcl] */\n@@ -10693,7 +10704,7 @@ cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n static void\n cp_parser_function_body (cp_parser *parser)\n {\n-  cp_parser_compound_statement (parser);\n+  cp_parser_compound_statement (parser, false);\n }\n \n /* Parse a ctor-initializer-opt followed by a function-body.  Return\n@@ -12244,7 +12255,7 @@ cp_parser_try_block (cp_parser* parser)\n \n   cp_parser_require_keyword (parser, RID_TRY, \"`try'\");\n   try_block = begin_try_block ();\n-  cp_parser_compound_statement (parser);\n+  cp_parser_compound_statement (parser, false);\n   finish_try_block (try_block);\n   cp_parser_handler_seq (parser);\n   finish_handler_sequence (try_block);\n@@ -12320,7 +12331,7 @@ cp_parser_handler (cp_parser* parser)\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-  cp_parser_compound_statement (parser);\n+  cp_parser_compound_statement (parser, false);\n   finish_handler (handler);\n }\n "}, {"sha": "9cfefb2ed0c37a7338e629460074be134740e2eb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -7403,7 +7403,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (!processing_template_decl)\n \t{\n \t  tree stmt_expr = begin_stmt_expr ();\n-\t  tsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl);\n+\t  \n+\t  tsubst_expr (STMT_EXPR_STMT (t), args,\n+\t\t       complain | tf_stmt_expr_cmpd, in_decl);\n \t  return finish_stmt_expr (stmt_expr);\n \t}\n       \n@@ -7530,7 +7532,10 @@ static tree\n tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree stmt, tmp;\n+  tsubst_flags_t stmt_expr\n+    = complain & (tf_stmt_expr_cmpd | tf_stmt_expr_body);\n \n+  complain ^= stmt_expr;\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n@@ -7556,10 +7561,18 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case EXPR_STMT:\n-      prep_stmt (t);\n-      finish_expr_stmt (tsubst_expr (EXPR_STMT_EXPR (t),\n-\t\t\t\t     args, complain, in_decl));\n-      break;\n+      {\n+\ttree r;\n+\t\n+\tprep_stmt (t);\n+\n+\tr = tsubst_expr (EXPR_STMT_EXPR (t), args, complain, in_decl);\n+\tif (stmt_expr & tf_stmt_expr_body && !TREE_CHAIN (t))\n+\t  finish_stmt_expr_expr (r);\n+\telse\n+\t  finish_expr_stmt (r);\n+\tbreak;\n+      }\n \n     case USING_STMT:\n       prep_stmt (t);\n@@ -7711,7 +7724,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \telse\n \t  stmt = begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n \n-\ttsubst_expr (COMPOUND_BODY (t), args, complain, in_decl);\n+\ttsubst_expr (COMPOUND_BODY (t), args,\n+\t\t     complain | ((stmt_expr & tf_stmt_expr_cmpd) << 1),\n+\t\t     in_decl);\n \n \tif (COMPOUND_STMT_BODY_BLOCK (t))\n \t  finish_function_body (stmt);\n@@ -7849,7 +7864,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       abort ();\n     }\n \n-  return tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n+  return tsubst_expr (TREE_CHAIN (t), args, complain | stmt_expr, in_decl);\n }\n \n /* T is a postfix-expression that is not being used in a function"}, {"sha": "80a3d60136db4ee27780a8127ea82db70b81f0ef", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -416,32 +416,17 @@ tree\n finish_expr_stmt (tree expr)\n {\n   tree r = NULL_TREE;\n-  tree expr_type = NULL_TREE;;\n \n   if (expr != NULL_TREE)\n     {\n-      if (!processing_template_decl\n-\t  && !(stmts_are_full_exprs_p ())\n-\t  && ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t       && lvalue_p (expr))\n-\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n-\texpr = decay_conversion (expr);\n-      \n-      /* Remember the type of the expression.  */\n-      expr_type = TREE_TYPE (expr);\n-\n-      if (!processing_template_decl && stmts_are_full_exprs_p ())\n+      if (!processing_template_decl)\n \texpr = convert_to_void (expr, \"statement\");\n       \n       r = add_stmt (build_stmt (EXPR_STMT, expr));\n     }\n \n   finish_stmt ();\n \n-  /* This was an expression-statement, so we save the type of the\n-     expression.  */\n-  last_expr_type = expr_type;\n-\n   return r;\n }\n \n@@ -1415,14 +1400,73 @@ begin_stmt_expr (void)\n   if (! cfun && !last_tree)\n     begin_stmt_tree (&scope_chain->x_saved_tree);\n \n+  last_expr_type = NULL_TREE;\n+  \n   keep_next_level (1);\n-  /* If we're building a statement tree, then the upcoming compound\n-     statement will be chained onto the tree structure, starting at\n-     last_tree.  We return last_tree so that we can later unhook the\n-     compound statement.  */\n+  \n   return last_tree; \n }\n \n+/* Process the final expression of a statement expression. EXPR can be\n+   NULL, if the final expression is empty.  Build up a TARGET_EXPR so\n+   that the result value can be safely returned to the enclosing\n+   expression.  */\n+\n+tree\n+finish_stmt_expr_expr (tree expr)\n+{\n+  tree result = NULL_TREE;\n+  tree type = void_type_node;\n+\n+  if (expr)\n+    {\n+      type = TREE_TYPE (expr);\n+      \n+      if (!processing_template_decl && !VOID_TYPE_P (TREE_TYPE (expr)))\n+\t{\n+\t  if (TREE_CODE (type) == ARRAY_TYPE\n+\t      || TREE_CODE (type) == FUNCTION_TYPE)\n+\t    expr = decay_conversion (expr);\n+\n+\t  expr = convert_from_reference (expr);\n+\t  expr = require_complete_type (expr);\n+\n+\t  /* Build a TARGET_EXPR for this aggregate.  finish_stmt_expr\n+\t     will then pull it apart so the lifetime of the target is\n+\t     within the scope of the expresson containing this statement\n+\t     expression.  */\n+\t  if (TREE_CODE (expr) == TARGET_EXPR)\n+\t    ;\n+\t  else if (!IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_INIT_REF (type))\n+\t    expr = build_target_expr_with_type (expr, type);\n+\t  else\n+\t    {\n+\t      /* Copy construct.  */\n+\t      expr = build_special_member_call\n+\t\t(NULL_TREE, complete_ctor_identifier,\n+\t\t build_tree_list (NULL_TREE, expr),\n+\t\t TYPE_BINFO (type), LOOKUP_NORMAL);\n+\t      expr = build_cplus_new (type, expr);\n+\t      my_friendly_assert (TREE_CODE (expr) == TARGET_EXPR, 20030729);\n+\t    }\n+\t}\n+\n+      if (expr != error_mark_node)\n+\t{\n+\t  result = build_stmt (EXPR_STMT, expr);\n+\t  add_stmt (result);\n+\t}\n+    }\n+  \n+  finish_stmt ();\n+\n+  /* Remember the last expression so that finish_stmt_expr can pull it\n+     apart.  */\n+  last_expr_type = result ? result : void_type_node;\n+  \n+  return result;\n+}\n+\n /* Finish a statement-expression.  RTL_EXPR should be the value\n    returned by the previous begin_stmt_expr; EXPR is the\n    statement-expression.  Returns an expression representing the\n@@ -1432,18 +1476,27 @@ tree\n finish_stmt_expr (tree rtl_expr)\n {\n   tree result;\n-\n-  /* If the last thing in the statement-expression was not an\n-     expression-statement, then it has type `void'.  In a template, we\n-     cannot distinguish the case where the last expression-statement\n-     had a dependent type from the case where the last statement was\n-     not an expression-statement.  Therefore, we (incorrectly) treat\n-     the STMT_EXPR as dependent in that case.  */\n-  if (!last_expr_type && !processing_template_decl)\n-    last_expr_type = void_type_node;\n-  result = build_min (STMT_EXPR, last_expr_type, last_tree);\n+  tree result_stmt = last_expr_type;\n+  tree type;\n+  \n+  if (!last_expr_type)\n+    type = void_type_node;\n+  else\n+    {\n+      if (result_stmt == void_type_node)\n+\t{\n+\t  type = void_type_node;\n+\t  result_stmt = NULL_TREE;\n+\t}\n+      else\n+\ttype = TREE_TYPE (EXPR_STMT_EXPR (result_stmt));\n+    }\n+  \n+  result = build_min (STMT_EXPR, type, last_tree);\n   TREE_SIDE_EFFECTS (result) = 1;\n   \n+  last_expr_type = NULL_TREE;\n+  \n   /* Remove the compound statement from the tree structure; it is\n      now saved in the STMT_EXPR.  */\n   last_tree = rtl_expr;\n@@ -1455,6 +1508,22 @@ finish_stmt_expr (tree rtl_expr)\n       && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n     finish_stmt_tree (&scope_chain->x_saved_tree);\n \n+  if (processing_template_decl)\n+    return result;\n+\n+  if (!VOID_TYPE_P (type))\n+    {\n+      /* Pull out the TARGET_EXPR that is the final expression. Put\n+\t the target's init_expr as the final expression and then put\n+\t the statement expression itself as the target's init\n+\t expr. Finally, return the target expression.  */\n+      tree last_expr = EXPR_STMT_EXPR (result_stmt);\n+      \n+      my_friendly_assert (TREE_CODE (last_expr) == TARGET_EXPR, 20030729);\n+      EXPR_STMT_EXPR (result_stmt) = TREE_OPERAND (last_expr, 1);\n+      TREE_OPERAND (last_expr, 1) = result;\n+      result = last_expr;\n+    }\n   return result;\n }\n "}, {"sha": "f636d33215da9f80ac71068f406e9c7ef71b8220", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -539,32 +539,46 @@ the initial value of a static variable.\n If you don't know the type of the operand, you can still do this, but you\n must use @code{typeof} (@pxref{Typeof}).\n \n-Statement expressions are not supported fully in G++, and their fate\n-there is unclear.  (It is possible that they will become fully supported\n-at some point, or that they will be deprecated, or that the bugs that\n-are present will continue to exist indefinitely.)  Presently, statement\n-expressions do not work well as default arguments.\n+In G++, the result value of a statement expression undergoes array and\n+function pointer decay, and is returned by value to the enclosing\n+expression. For instance, if @code{A} is a class, then\n \n-In addition, there are semantic issues with statement-expressions in\n-C++.  If you try to use statement-expressions instead of inline\n-functions in C++, you may be surprised at the way object destruction is\n-handled.  For example:\n+@smallexample\n+        A a;\n \n-@example\n-#define foo(a)  (@{int b = (a); b + 3; @})\n-@end example\n+        (@{a;@}).Foo ()\n+@end smallexample\n \n @noindent\n-does not work the same way as:\n+will construct a temporary @code{A} object to hold the result of the\n+statement expression, and that will be used to invoke @code{Foo}.\n+Therefore the @code{this} pointer observed by @code{Foo} will not be the\n+address of @code{a}.\n+\n+Any temporaries created within a statement within a statement expression\n+will be destroyed at the statement's end.  This makes statement\n+expressions inside macros slightly different from function calls.  In\n+the latter case temporaries introduced during argument evaluation will\n+be destroyed at the end of the statement that includes the function\n+call.  In the statement expression case they will be destroyed during\n+the statement expression.  For instance,\n \n-@example\n-inline int foo(int a) @{ int b = a; return b + 3; @}\n-@end example\n+@smallexample\n+#define macro(a)  (@{__typeof__(a) b = (a); b + 3; @})\n+template<typename T> T function(T a) @{ T b = a; return b + 3; @}\n+\n+void foo ()\n+@{\n+  macro (X ());\n+  function (X ());\n+@}\n+@end smallexample\n \n @noindent\n-In particular, if the expression passed into @code{foo} involves the\n-creation of temporaries, the destructors for those temporaries will be\n-run earlier in the case of the macro than in the case of the function.\n+will have different places where temporaries are destroyed.  For the\n+@code{macro} case, the temporary @code{X} will be destroyed just after\n+the initialization of @code{b}.  In the @code{function} case that\n+temporary will be destroyed when the function returns.\n \n These considerations mean that it is probably a bad idea to use\n statement-expressions of this form in header files that are designed to\n@@ -3476,9 +3490,10 @@ in an @code{__attribute__} will still only provide you with 8 byte\n alignment.  See your linker documentation for further information.\n \n @item packed\n-This attribute, attached to an @code{enum}, @code{struct}, or\n-@code{union} type definition, specifies that the minimum required memory\n-be used to represent the type.\n+This attribute, attached to @code{struct} or @code{union} type\n+definition, specifies that each member of the structure or union is\n+placed to minimize the memory required. When attached to an @code{enum}\n+definition, it indicates that the smallest integral type should be used.\n \n @opindex fshort-enums\n Specifying this attribute for @code{struct} and @code{union} types is\n@@ -3487,9 +3502,29 @@ structure or union members.  Specifying the @option{-fshort-enums}\n flag on the line is equivalent to specifying the @code{packed}\n attribute on all @code{enum} definitions.\n \n-You may only specify this attribute after a closing curly brace on an\n-@code{enum} definition, not in a @code{typedef} declaration, unless that\n-declaration also contains the definition of the @code{enum}.\n+In the following example @code{struct my_packed_struct}'s members are\n+packed closely together, but the internal layout of its @code{s} member\n+is not packed -- to do that, @code{struct my_unpacked_struct} would need to\n+be packed too.\n+\n+@smallexample\n+struct my_unpacked_struct\n+ @{\n+    char c;\n+    int i;\n+ @};\n+\n+struct my_packed_struct __attribute__ ((__packed__))\n+  @{\n+     char c;\n+     int  i;\n+     struct my_unpacked_struct s;\n+  @};\n+@end smallexample\n+\n+You may only specify this attribute on the definition of a @code{enum},\n+@code{struct} or @code{union}, not on a @code{typedef} which does not\n+also define the enumerated type, structure or union.\n \n @item transparent_union\n This attribute, attached to a @code{union} type definition, indicates"}, {"sha": "28e6e20eb0b0289d161ac7cc6d60af39c234f292", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -1,5 +1,8 @@\n 2003-08-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR c++/11295\n+\t* g++.dg/ext/stmtexpr1.C: New test.\n+\n \t* g++.dg/opt/tmp1.C: New test.\n \n \tPR c++/11525"}, {"sha": "afdf64403177e272196948f8cfffe08b632e04e0", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr1.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5bcc58230c173c6923908cd7622dca7240f18de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C?ref=a5bcc58230c173c6923908cd7622dca7240f18de", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do run }\n+// { dg-options \"\" }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 30 Jul 2003 <nathan@codesourcery.com>\n+\n+// make statement expressions work properly\n+\n+extern \"C\" int printf (char const *, ...);\n+extern \"C\" void abort ();\n+\n+static unsigned order[] = \n+{\n+  1, 101, 2, 102,\n+  3, 4, 104, 103,\n+  5, 6, 105, 106,\n+  7, 107, 8, 408, 9, 109, 108,\n+  10, 11, 110, 411, 12, 112, 111,\n+  13, 113,\n+  14, 214, 114, 114,\n+  0\n+};\n+\n+static unsigned point;\n+\n+static void Check (unsigned t, unsigned i, void const *ptr, char const *name)\n+{\n+  printf (\"%d %d %p %s\\n\", t, i, ptr, name);\n+  \n+  if (order[point++] != i + t)\n+    abort ();\n+}\n+\n+template <int I> struct A \n+{\n+  A () { Check (0, I, this, __PRETTY_FUNCTION__); }\n+  ~A () { Check (100, I, this, __PRETTY_FUNCTION__); }\n+  A (A const &) { Check (200, I, this, __PRETTY_FUNCTION__); }\n+  A &operator= (A const &) { Check (300, I, this, __PRETTY_FUNCTION__); }\n+  void Foo () const { Check (400, I, this, __PRETTY_FUNCTION__); }\n+};\n+\n+int main ()\n+{\n+  ({A<1> (); A<2> (); ;});\n+  ({A<3> (), A<4> (); ;});\n+  ({A<5> (), A<6> ();});\n+  ({A <7> (); A<8> (); }).Foo (), A<9> ();\n+  ({A <10> (), A<11> (); }).Foo (), A<12> ();\n+  ({A<13> a; a; ; });\n+  ({A<14> a; a; });\n+  Check (0, 0, 0, \"end\");\n+}\n+"}]}