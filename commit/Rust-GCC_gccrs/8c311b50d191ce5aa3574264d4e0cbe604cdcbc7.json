{"sha": "8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzMTFiNTBkMTkxY2U1YWEzNTc0MjY0ZDRlMGNiZTYwNGNkY2JjNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-02-07T23:26:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-07T23:26:39Z"}, "message": "gimple-fold.c (gimple_get_virt_method_for_vtable): Do O(1) lookup in the vtable constructor.\n\n\n\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Do O(1)\n\tlookup in the vtable constructor.\n\nFrom-SVN: r207616", "tree": {"sha": "4cf6c8e79aad80187b4c85a925b5b93037ecafd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cf6c8e79aad80187b4c85a925b5b93037ecafd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7/comments", "author": null, "committer": null, "parents": [{"sha": "63e6247dfe1fb16b2c179d1b1e04b7ca0efb506d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e6247dfe1fb16b2c179d1b1e04b7ca0efb506d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e6247dfe1fb16b2c179d1b1e04b7ca0efb506d"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "a0ae1882316d3f8566e82bb175bb848ed2c8640d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "patch": "@@ -1,3 +1,8 @@\n+2014-02-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Do O(1)\n+\tlookup in the vtable constructor.\n+\n 2014-02-07  Jeff Law  <law@redhat.com>\n \n \tPR target/40977"}, {"sha": "fd25939be3aec58028e9059832befa53ef6f5207", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c311b50d191ce5aa3574264d4e0cbe604cdcbc7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8c311b50d191ce5aa3574264d4e0cbe604cdcbc7", "patch": "@@ -3179,6 +3179,8 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n {\n   tree vtable = v, init, fn;\n   unsigned HOST_WIDE_INT size;\n+  unsigned HOST_WIDE_INT elt_size, access_index;\n+  tree domain_type;\n \n   /* First of all double check we have virtual table.  */\n   if (TREE_CODE (v) != VAR_DECL\n@@ -3202,10 +3204,31 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n   offset *= BITS_PER_UNIT;\n   offset += token * size;\n \n-  /* Do not pass from_decl here, we want to know even about values we can\n-     not use and will check can_refer_decl_in_current_unit_p ourselves.  */\n-  fn = fold_ctor_reference (TREE_TYPE (TREE_TYPE (v)), init,\n-\t\t\t    offset, size, NULL);\n+  /* Lookup the value in the constructor that is assumed to be array.\n+     This is equivalent to\n+     fn = fold_ctor_reference (TREE_TYPE (TREE_TYPE (v)), init,\n+\t\t\t       offset, size, NULL);\n+     but in a constant time.  We expect that frontend produced a simple\n+     array without indexed initializers.  */\n+\n+  gcc_checking_assert (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE);\n+  domain_type = TYPE_DOMAIN (TREE_TYPE (init));\n+  gcc_checking_assert (integer_zerop (TYPE_MIN_VALUE (domain_type)));\n+  elt_size = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (init))));\n+\n+  access_index = offset / BITS_PER_UNIT / elt_size;\n+  gcc_checking_assert (offset % (elt_size * BITS_PER_UNIT) == 0);\n+\n+  /* This code makes an assumption that there are no \n+     indexed fileds produced by C++ FE, so we can directly index the array. */\n+  if (access_index < CONSTRUCTOR_NELTS (init))\n+    {\n+      fn = CONSTRUCTOR_ELT (init, access_index)->value;\n+      gcc_checking_assert (!CONSTRUCTOR_ELT (init, access_index)->index);\n+      STRIP_NOPS (fn);\n+    }\n+  else\n+    fn = NULL;\n \n   /* For type inconsistent program we may end up looking up virtual method\n      in virtual table that does not contain TOKEN entries.  We may overrun"}]}