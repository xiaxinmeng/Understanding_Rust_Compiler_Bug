{"sha": "f78f04627d5805bbcc07e05a41352b0de36f3dba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4ZjA0NjI3ZDU4MDViYmNjMDdlMDVhNDEzNTJiMGRlMzZmM2RiYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-10-24T20:16:31Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-10-24T20:16:31Z"}, "message": "rs6000.c (TARGET_MANGLE_DECL_ASSEMBLER_NAME): Define as rs6000_mangle_decl_assembler_name.\n\n[gcc]\n2018-10-24  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (TARGET_MANGLE_DECL_ASSEMBLER_NAME):\n\tDefine as rs6000_mangle_decl_assembler_name.\n\t(rs6000_mangle_decl_assembler_name): If the user switched from IBM\n\tlong double to IEEE long double, switch the names of the long\n\tdouble built-in functions to be <func>f128 instead of <func>l.\n\n[gcc/testsuite]\n2018-10-24  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* gcc.target/powerpc/float128-math.c: New test to make sure the\n\tlong double built-in function names use the f128 form if the user\n\tswitched from IBM long double to IEEE long double.\n\t* gcc.target/powerpc/ppc-fortran/ieee128-math.f90: Likewise.\n\nFrom-SVN: r265471", "tree": {"sha": "fcdccbdd90f627454a160f3c0bb42b84965d0b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcdccbdd90f627454a160f3c0bb42b84965d0b9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f78f04627d5805bbcc07e05a41352b0de36f3dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78f04627d5805bbcc07e05a41352b0de36f3dba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78f04627d5805bbcc07e05a41352b0de36f3dba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78f04627d5805bbcc07e05a41352b0de36f3dba/comments", "author": null, "committer": null, "parents": [{"sha": "df51934dcee2328fb6a257bdda7e177f8b2cc6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df51934dcee2328fb6a257bdda7e177f8b2cc6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df51934dcee2328fb6a257bdda7e177f8b2cc6a2"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "f7faf892a9dc9f14080550b6ba502a2d6a562a99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f78f04627d5805bbcc07e05a41352b0de36f3dba", "patch": "@@ -1,3 +1,11 @@\n+2018-10-24  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (TARGET_MANGLE_DECL_ASSEMBLER_NAME):\n+\tDefine as rs6000_mangle_decl_assembler_name.\n+\t(rs6000_mangle_decl_assembler_name): If the user switched from IBM\n+\tlong double to IEEE long double, switch the names of the long\n+\tdouble built-in functions to be <func>f128 instead of <func>l.\n+\n 2018-10-24  Martin Sebor  <msebor@redhat.com>\n \n \t* doc/extend.texi (nonnull): List no-argument form.  Reference"}, {"sha": "726038ef2b74410d70d16dedd2a929cf4052630a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f78f04627d5805bbcc07e05a41352b0de36f3dba", "patch": "@@ -1981,6 +1981,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P\n #define TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P hook_bool_void_true\n+\n+#undef TARGET_MANGLE_DECL_ASSEMBLER_NAME\n+#define TARGET_MANGLE_DECL_ASSEMBLER_NAME rs6000_mangle_decl_assembler_name\n \f\n \n /* Processor table.  */\n@@ -38964,6 +38967,76 @@ rs6000_globalize_decl_name (FILE * stream, tree decl)\n }\n #endif\n \n+\f\n+/* On 64-bit Linux and Freebsd systems, possibly switch the long double library\n+   function names from <foo>l to <foo>f128 if the default long double type is\n+   IEEE 128-bit.  Typically, with the C and C++ languages, the standard math.h\n+   include file switches the names on systems that support long double as IEEE\n+   128-bit, but that doesn't work if the user uses __builtin_<foo>l directly.\n+   In the future, glibc will export names like __ieee128_sinf128 and we can\n+   switch to using those instead of using sinf128, which pollutes the user's\n+   namespace.\n+\n+   This will switch the names for Fortran math functions as well (which doesn't\n+   use math.h).  However, Fortran needs other changes to the compiler and\n+   library before you can switch the real*16 type at compile time.\n+\n+   We use the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change this name.  We\n+   only do this if the default is that long double is IBM extended double, and\n+   the user asked for IEEE 128-bit.  */\n+\n+static tree\n+rs6000_mangle_decl_assembler_name (tree decl, tree id)\n+{\n+  if (!TARGET_IEEEQUAD_DEFAULT && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n+      && TREE_CODE (decl) == FUNCTION_DECL && DECL_IS_BUILTIN (decl) )\n+    {\n+      size_t len = IDENTIFIER_LENGTH (id);\n+      const char *name = IDENTIFIER_POINTER (id);\n+\n+      if (name[len - 1] == 'l')\n+\t{\n+\t  bool uses_ieee128_p = false;\n+\t  tree type = TREE_TYPE (decl);\n+\t  machine_mode ret_mode = TYPE_MODE (type);\n+\n+\t  /* See if the function returns a IEEE 128-bit floating point type or\n+\t     complex type.  */\n+\t  if (ret_mode == TFmode || ret_mode == TCmode)\n+\t    uses_ieee128_p = true;\n+\t  else\n+\t    {\n+\t      function_args_iterator args_iter;\n+\t      tree arg;\n+\n+\t      /* See if the function passes a IEEE 128-bit floating point type\n+\t\t or complex type.  */\n+\t      FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n+\t\t{\n+\t\t  machine_mode arg_mode = TYPE_MODE (arg);\n+\t\t  if (arg_mode == TFmode || arg_mode == TCmode)\n+\t\t    {\n+\t\t      uses_ieee128_p = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* If we passed or returned an IEEE 128-bit floating point type,\n+\t     change the name.  */\n+\t  if (uses_ieee128_p)\n+\t    {\n+\t      char *name2 = (char *) alloca (len + 4);\n+\t      memcpy (name2, name, len - 1);\n+\t      strcpy (name2 + len - 1, \"f128\");\n+\t      id = get_identifier (name2);\n+\t    }\n+\t}\n+    }\n+\n+  return id;\n+}\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "54334c9717deeee3db7d3251d0bab9919db62033", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f78f04627d5805bbcc07e05a41352b0de36f3dba", "patch": "@@ -1,3 +1,10 @@\n+2018-10-24  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-math.c: New test to make sure the\n+\tlong double built-in function names use the f128 form if the user\n+\tswitched from IBM long double to IEEE long double.\n+\t* gcc.target/powerpc/ppc-fortran/ieee128-math.f90: Likewise.\n+\n 2018-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/86288"}, {"sha": "4ad3b5b8363e5102d510ff1a6bfff8436eaed87b", "filename": "gcc/testsuite/gcc.target/powerpc/float128-math.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c?ref=f78f04627d5805bbcc07e05a41352b0de36f3dba", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2 -mfloat128 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* Test whether we convert __builtin_<math>l to __builtin_<math>f128 if the\n+   default long double type is IEEE 128-bit.  Also test that using the explicit\n+   __builtin_<math>f128 function does not interfere with the __builtin_<math>l\n+   function.  */\n+\n+extern __float128 sinf128 (__float128);\n+\n+void foo (__float128 *p, long double *q, long double *r)\n+{\n+  *p = sinf128 (*p);\n+  *q = __builtin_sinl (*q);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mbl sinf128\\M} 2 } } */\n+/* { dg-final { scan-assembler-not   {\\mbl sinl\\M}      } } */"}, {"sha": "d74c8d723f12a64a3142adc6a60bef690734c5b6", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fortran/ieee128-math.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fortran%2Fieee128-math.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78f04627d5805bbcc07e05a41352b0de36f3dba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fortran%2Fieee128-math.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fortran%2Fieee128-math.f90?ref=f78f04627d5805bbcc07e05a41352b0de36f3dba", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile { target { powerpc*-*-linux* } } }\n+! { dg-require-effective-target ppc_float128_sw }\n+! { dg-require-effective-target vsx_hw }\n+! { dg-options \"-mvsx -mabi=ieeelongdouble -mfloat128\" }\n+! { dg-excess-errors \"expect error due to switching long double type\" }\n+! Since the error message is not associated with a particular line\n+! number, we cannot use the dg-error directive and cannot specify a\n+! regexp to describe the expected error message.  The expected warning\n+! message is:\n+!  \"Warning: Using IEEE extended precision long double [-Wpsabi]\"\n+\n+program test_qp\n+   implicit none\n+   real(16), volatile :: fp1, fp2;\n+   fp1 = 2.0\n+   fp2 = log (fp1)\n+end\n+\n+! { dg-final { scan-assembler-not {\\mbl logl\\M}    } }\n+! { dg-final { scan-assembler     {\\mbl logf128\\M} } }"}]}