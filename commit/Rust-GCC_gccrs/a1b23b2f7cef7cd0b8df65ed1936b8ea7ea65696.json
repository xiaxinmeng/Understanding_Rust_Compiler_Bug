{"sha": "a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiMjNiMmY3Y2VmN2NkMGI4ZGY2NWVkMTkzNmI4ZWE3ZWE2NTY5Ng==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2005-10-19T16:27:10Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-10-19T16:27:10Z"}, "message": "cfgexpand.c (discover_nonconstant_array_refs_r, [...]): Move here from tree-outof-ssa.c\n\n\t* cfgexpand.c (discover_nonconstant_array_refs_r,\n\tdiscover_nonconstant_array_refs): Move here from tree-outof-ssa.c\n\t(tree_expand_cfg): Call discover_nonconstant_array_refs.\n\t* tree-outof-ssa.c (rewrite_out_of_ssa): Remove call to\n\tdiscover_nonconstant_array_refs.\n\nFrom-SVN: r105623", "tree": {"sha": "c114fff08f7b39691bd889779fe938aaad5a6e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c114fff08f7b39691bd889779fe938aaad5a6e05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/comments", "author": null, "committer": null, "parents": [{"sha": "f95f80d1a762998d6b8731d506f6667ccbdaf996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95f80d1a762998d6b8731d506f6667ccbdaf996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95f80d1a762998d6b8731d506f6667ccbdaf996"}], "stats": {"total": 138, "additions": 72, "deletions": 66}, "files": [{"sha": "139c6174be7bf4a429cd6cb3ebd61b092b434156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "patch": "@@ -1,3 +1,11 @@\n+2005-10-19  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* cfgexpand.c (discover_nonconstant_array_refs_r,\n+\tdiscover_nonconstant_array_refs): Move here from tree-outof-ssa.c\n+\t(tree_expand_cfg): Call discover_nonconstant_array_refs.\n+\t* tree-outof-ssa.c (rewrite_out_of_ssa): Remove call to\n+\tdiscover_nonconstant_array_refs.\n+\n 2005-10-19  Steven Bosscher  <stevenb@suse.de>\n \n \tPR c/23228"}, {"sha": "f3a340ac251ac391609f55c47d484a0a766f8393", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "patch": "@@ -1463,6 +1463,67 @@ construct_exit_block (void)\n   update_bb_for_insn (exit_block);\n }\n \n+/* Helper function for discover_nonconstant_array_refs. \n+   Look for ARRAY_REF nodes with non-constant indexes and mark them\n+   addressable.  */\n+\n+static tree\n+discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n+\t\t\t\t   void *data ATTRIBUTE_UNUSED)\n+{\n+  tree t = *tp;\n+\n+  if (IS_TYPE_OR_DECL_P (t))\n+    *walk_subtrees = 0;\n+  else if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n+    {\n+      while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t      && is_gimple_min_invariant (TREE_OPERAND (t, 1))\n+\t      && (!TREE_OPERAND (t, 2)\n+\t\t  || is_gimple_min_invariant (TREE_OPERAND (t, 2))))\n+\t     || (TREE_CODE (t) == COMPONENT_REF\n+\t\t && (!TREE_OPERAND (t,2)\n+\t\t     || is_gimple_min_invariant (TREE_OPERAND (t, 2))))\n+\t     || TREE_CODE (t) == BIT_FIELD_REF\n+\t     || TREE_CODE (t) == REALPART_EXPR\n+\t     || TREE_CODE (t) == IMAGPART_EXPR\n+\t     || TREE_CODE (t) == VIEW_CONVERT_EXPR\n+\t     || TREE_CODE (t) == NOP_EXPR\n+\t     || TREE_CODE (t) == CONVERT_EXPR)\n+\tt = TREE_OPERAND (t, 0);\n+\n+      if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t{\n+\t  t = get_base_address (t);\n+\t  if (t && DECL_P (t))\n+\t    TREE_ADDRESSABLE (t) = 1;\n+\t}\n+\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* RTL expansion is not able to compile array references with variable\n+   offsets for arrays stored in single register.  Discover such\n+   expressions and mark variables as addressable to avoid this\n+   scenario.  */\n+\n+static void\n+discover_nonconstant_array_refs (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\twalk_tree (bsi_stmt_ptr (bsi), discover_nonconstant_array_refs_r,\n+\t\t   NULL , NULL);\n+    }\n+}\n+\n /* Translate the intermediate representation contained in the CFG\n    from GIMPLE trees to RTL.\n \n@@ -1484,6 +1545,9 @@ tree_expand_cfg (void)\n   /* Prepare the rtl middle end to start recording block changes.  */\n   reset_block_changes ();\n \n+  /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n+  discover_nonconstant_array_refs ();\n+\n   /* Expand the variables recorded during gimple lowering.  */\n   expand_used_vars ();\n "}, {"sha": "5a2150694b972682e59b8243cf079affbeaf39a1", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=a1b23b2f7cef7cd0b8df65ed1936b8ea7ea65696", "patch": "@@ -1826,69 +1826,6 @@ dump_replaceable_exprs (FILE *f, tree *expr)\n }\n \n \n-/* Helper function for discover_nonconstant_array_refs. \n-   Look for ARRAY_REF nodes with non-constant indexes and mark them\n-   addressable.  */\n-\n-static tree\n-discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n-\t\t\t\t   void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (IS_TYPE_OR_DECL_P (t))\n-    *walk_subtrees = 0;\n-  else if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n-    {\n-      while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n-\t      && is_gimple_min_invariant (TREE_OPERAND (t, 1))\n-\t      && (!TREE_OPERAND (t, 2)\n-\t\t  || is_gimple_min_invariant (TREE_OPERAND (t, 2))))\n-\t     || (TREE_CODE (t) == COMPONENT_REF\n-\t\t && (!TREE_OPERAND (t,2)\n-\t\t     || is_gimple_min_invariant (TREE_OPERAND (t, 2))))\n-\t     || TREE_CODE (t) == BIT_FIELD_REF\n-\t     || TREE_CODE (t) == REALPART_EXPR\n-\t     || TREE_CODE (t) == IMAGPART_EXPR\n-\t     || TREE_CODE (t) == VIEW_CONVERT_EXPR\n-\t     || TREE_CODE (t) == NOP_EXPR\n-\t     || TREE_CODE (t) == CONVERT_EXPR)\n-\tt = TREE_OPERAND (t, 0);\n-\n-      if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n-\t{\n-\t  t = get_base_address (t);\n-\t  if (t && DECL_P (t))\n-\t    TREE_ADDRESSABLE (t) = 1;\n-\t}\n-\n-      *walk_subtrees = 0;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* RTL expansion is not able to compile array references with variable\n-   offsets for arrays stored in single register.  Discover such\n-   expressions and mark variables as addressable to avoid this\n-   scenario.  */\n-\n-static void\n-discover_nonconstant_array_refs (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator bsi;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\twalk_tree (bsi_stmt_ptr (bsi), discover_nonconstant_array_refs_r,\n-\t\t   NULL , NULL);\n-    }\n-}\n-\n-\n /* This function will rewrite the current program using the variable mapping\n    found in MAP.  If the replacement vector VALUES is provided, any \n    occurrences of partitions with non-null entries in the vector will be \n@@ -2598,9 +2535,6 @@ rewrite_out_of_ssa (void)\n   /* Flush out flow graph and SSA data.  */\n   delete_var_map (map);\n \n-  /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n-  discover_nonconstant_array_refs ();\n-\n   in_ssa_p = false;\n }\n "}]}