{"sha": "f134997face560846198bd6a81013e49bb1420ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzNDk5N2ZhY2U1NjA4NDYxOThiZDZhODEwMTNlNDliYjE0MjBlYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-27T07:07:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-27T07:07:34Z"}, "message": "flow.c (count_reg_sets_1): Remove.\n\n        * flow.c (count_reg_sets_1): Remove.\n        (count_reg_sets, count_reg_references): Remove.\n        (recompute_reg_usage): Implement with update_life_info.\n        Reallocate life data.\n\nFrom-SVN: r33470", "tree": {"sha": "1aa3b654656a75d4799d955bfedf05174145c87a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aa3b654656a75d4799d955bfedf05174145c87a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f134997face560846198bd6a81013e49bb1420ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f134997face560846198bd6a81013e49bb1420ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f134997face560846198bd6a81013e49bb1420ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f134997face560846198bd6a81013e49bb1420ea/comments", "author": null, "committer": null, "parents": [{"sha": "693d9e2fe73e3a0022837da94efce7d23cd4286c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693d9e2fe73e3a0022837da94efce7d23cd4286c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/693d9e2fe73e3a0022837da94efce7d23cd4286c"}], "stats": {"total": 278, "additions": 9, "deletions": 269}, "files": [{"sha": "859dd28d68039b982c21f77d33d04247f034c257", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f134997face560846198bd6a81013e49bb1420ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f134997face560846198bd6a81013e49bb1420ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f134997face560846198bd6a81013e49bb1420ea", "patch": "@@ -1,3 +1,10 @@\n+2000-04-26  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (count_reg_sets_1): Remove.\n+\t(count_reg_sets, count_reg_references): Remove.\n+\t(recompute_reg_usage): Implement with update_life_info.\n+\tReallocate life data.\n+\n 2000-04-26  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (update_life_info): Consider blocks null to mean the"}, {"sha": "8ee75052a8aba891c8047d9613fc7147216d733c", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 269, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f134997face560846198bd6a81013e49bb1420ea/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f134997face560846198bd6a81013e49bb1420ea/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f134997face560846198bd6a81013e49bb1420ea", "patch": "@@ -353,9 +353,6 @@ void dump_flow_info\t\t\tPARAMS ((FILE *));\n void debug_flow_info\t\t\tPARAMS ((void));\n static void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n \n-static void count_reg_sets_1\t\tPARAMS ((rtx, int));\n-static void count_reg_sets\t\tPARAMS ((rtx, int));\n-static void count_reg_references\tPARAMS ((rtx, int));\n static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t  rtx));\n static void remove_fake_successors\tPARAMS ((basic_block));\n@@ -5534,208 +5531,6 @@ compute_immediate_dominators (idom, dominators)\n   sbitmap_vector_free (tmp);\n }\n \n-/* Count for a single SET rtx, X.  */\n-\n-static void\n-count_reg_sets_1 (x, loop_depth)\n-     rtx x;\n-     int loop_depth;\n-{\n-  register int regno;\n-  register rtx reg = SET_DEST (x);\n-\n-  /* Find the register that's set/clobbered.  */\n-  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n-\t || GET_CODE (reg) == SIGN_EXTRACT\n-\t || GET_CODE (reg) == STRICT_LOW_PART)\n-    reg = XEXP (reg, 0);\n-\n-  if (GET_CODE (reg) == PARALLEL\n-      && GET_MODE (reg) == BLKmode)\n-    {\n-      register int i;\n-      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tcount_reg_sets_1 (XVECEXP (reg, 0, i), loop_depth);\n-      return;\n-    }\n-\n-  if (GET_CODE (reg) == REG)\n-    {\n-      regno = REGNO (reg);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* Count (weighted) references, stores, etc.  This counts a\n-\t     register twice if it is modified, but that is correct.  */\n-\t  REG_N_SETS (regno)++;\n-\t  REG_N_REFS (regno) += loop_depth + 1;\n-\t}\n-    }\n-}\n-\n-/* Increment REG_N_SETS for each SET or CLOBBER found in X; also increment\n-   REG_N_REFS by the current loop depth for each SET or CLOBBER found.  */\n-\n-static void\n-count_reg_sets  (x, loop_depth)\n-     rtx x;\n-     int loop_depth;\n-{\n-  register RTX_CODE code = GET_CODE (x);\n-\n-  if (code == SET || code == CLOBBER)\n-    count_reg_sets_1 (x, loop_depth);\n-  else if (code == PARALLEL)\n-    {\n-      register int i;\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t{\n-\t  code = GET_CODE (XVECEXP (x, 0, i));\n-\t  if (code == SET || code == CLOBBER)\n-\t    count_reg_sets_1 (XVECEXP (x, 0, i), loop_depth);\n-\t}\n-    }\n-}\n-\n-/* Increment REG_N_REFS by the current loop depth each register reference\n-   found in X.  */\n-\n-static void\n-count_reg_references (x, loop_depth)\n-     rtx x;\n-     int loop_depth;\n-{\n-  register RTX_CODE code;\n-\n- retry:\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST_INT:\n-    case CONST:\n-    case CONST_DOUBLE:\n-    case PC:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-    case ASM_INPUT:\n-      return;\n-\n-#ifdef HAVE_cc0\n-    case CC0:\n-      return;\n-#endif\n-\n-    case CLOBBER:\n-      /* If we are clobbering a MEM, mark any registers inside the address\n-\t as being used.  */\n-      if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tcount_reg_references (XEXP (XEXP (x, 0), 0), loop_depth);\n-      return;\n-\n-    case SUBREG:\n-      /* While we're here, optimize this case.  */\n-      x = SUBREG_REG (x);\n-\n-      /* In case the SUBREG is not of a register, don't optimize */\n-      if (GET_CODE (x) != REG)\n-\t{\n-\t  count_reg_references (x, loop_depth);\n-\t  return;\n-\t}\n-\n-      /* ... fall through ...  */\n-\n-    case REG:\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\tREG_N_REFS (REGNO (x)) += loop_depth + 1;\n-      return;\n-\n-    case SET:\n-      {\n-\tregister rtx testreg = SET_DEST (x);\n-\tint mark_dest = 0;\n-\n-\t/* If storing into MEM, don't show it as being used.  But do\n-\t   show the address as being used.  */\n-\tif (GET_CODE (testreg) == MEM)\n-\t  {\n-\t    count_reg_references (XEXP (testreg, 0), loop_depth);\n-\t    count_reg_references (SET_SRC (x), loop_depth);\n-\t    return;\n-\t  }\n-\t    \n-\t/* Storing in STRICT_LOW_PART is like storing in a reg\n-\t   in that this SET might be dead, so ignore it in TESTREG.\n-\t   but in some other ways it is like using the reg.\n-\n-\t   Storing in a SUBREG or a bit field is like storing the entire\n-\t   register in that if the register's value is not used\n-\t   then this SET is not needed.  */\n-\twhile (GET_CODE (testreg) == STRICT_LOW_PART\n-\t       || GET_CODE (testreg) == ZERO_EXTRACT\n-\t       || GET_CODE (testreg) == SIGN_EXTRACT\n-\t       || GET_CODE (testreg) == SUBREG)\n-\t  {\n-\t    /* Modifying a single register in an alternate mode\n-\t       does not use any of the old value.  But these other\n-\t       ways of storing in a register do use the old value.  */\n-\t    if (GET_CODE (testreg) == SUBREG\n-\t\t&& !(REG_SIZE (SUBREG_REG (testreg)) > REG_SIZE (testreg)))\n-\t      ;\n-\t    else\n-\t      mark_dest = 1;\n-\n-\t    testreg = XEXP (testreg, 0);\n-\t  }\n-\n-\t/* If this is a store into a register,\n-\t   recursively scan the value being stored.  */\n-\n-\tif ((GET_CODE (testreg) == PARALLEL\n-\t     && GET_MODE (testreg) == BLKmode)\n-\t    || GET_CODE (testreg) == REG)\n-\t  {\n-\t    count_reg_references (SET_SRC (x), loop_depth);\n-\t    if (mark_dest)\n-\t      count_reg_references (SET_DEST (x), loop_depth);\n-\t    return;\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Recursively scan the operands of this expression.  */\n-\n-  {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n-    \n-    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-      {\n-\tif (fmt[i] == 'e')\n-\t  {\n-\t    /* Tail recursive case: save a function call level.  */\n-\t    if (i == 0)\n-\t      {\n-\t\tx = XEXP (x, 0);\n-\t\tgoto retry;\n-\t      }\n-\t    count_reg_references (XEXP (x, i), loop_depth);\n-\t  }\n-\telse if (fmt[i] == 'E')\n-\t  {\n-\t    register int j;\n-\t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      count_reg_references (XVECEXP (x, i, j), loop_depth);\n-\t  }\n-      }\n-  }\n-}\n-\n /* Recompute register set/reference counts immediately prior to register\n    allocation.\n \n@@ -5760,70 +5555,8 @@ recompute_reg_usage (f, loop_step)\n      rtx f ATTRIBUTE_UNUSED;\n      int loop_step ATTRIBUTE_UNUSED;\n {\n-  rtx insn;\n-  int i, max_reg;\n-  int index;\n-  int loop_depth;\n-\n-  /* Clear out the old data.  */\n-  max_reg = max_reg_num ();\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_reg; i++)\n-    {\n-      REG_N_SETS (i) = 0;\n-      REG_N_REFS (i) = 0;\n-    }\n-\n-  /* Scan each insn in the chain and count how many times each register is\n-     set/used.  */\n-  for (index = 0; index < n_basic_blocks; index++)\n-    {\n-      basic_block bb = BASIC_BLOCK (index);\n-      loop_depth = bb->loop_depth;\n-      for (insn = bb->head; insn; insn = NEXT_INSN (insn))\n- \t{\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    {\n-\t      rtx links;\n-\n-\t      /* This call will increment REG_N_SETS for each SET or CLOBBER\n-\t\t of a register in INSN.  It will also increment REG_N_REFS\n-\t\t by the loop depth for each set of a register in INSN.  */\n-\t      count_reg_sets (PATTERN (insn), loop_depth);\n-\n-\t      /* count_reg_sets does not detect autoincrement address modes, so\n-\t\t detect them here by looking at the notes attached to INSN.  */\n-\t      for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n-\t\t{\n-\t\t  if (REG_NOTE_KIND (links) == REG_INC)\n-\t\t    /* Count (weighted) references, stores, etc.  This\n-\t\t       counts a register twice if it is modified, but\n-\t\t       that is correct.  */\n-\t\t    REG_N_SETS (REGNO (XEXP (links, 0)))++;\n-\t\t}\n-\n-\t      /* This call will increment REG_N_REFS by the current loop depth\n-\t\t for each reference to a register in INSN.  */\n-\t      count_reg_references (PATTERN (insn), loop_depth);\n-\n-\t      /* count_reg_references will not include counts for arguments to\n-\t\t function calls, so detect them here by examining the\n-\t\t CALL_INSN_FUNCTION_USAGE data.  */\n-\t      if (GET_CODE (insn) == CALL_INSN)\n-\t\t{\n-\t\t  rtx note;\n-\n-\t\t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n-\t\t       note;\n-\t\t       note = XEXP (note, 1))\n-\t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t      count_reg_references (XEXP (XEXP (note, 0), 0),\n-\t\t\t\t\t    loop_depth);\n-\t\t}\n-\t    }\n-\t  if (insn == bb->end)\n-\t    break;\n-\t}\n-    }\n+  allocate_reg_life_data ();\n+  update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO);\n }\n \n /* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of"}]}