{"sha": "a7e8c268ed44dd8f09259ba8000be311af7562e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlOGMyNjhlZDQ0ZGQ4ZjA5MjU5YmE4MDAwYmUzMTFhZjc1NjJlNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-09-15T00:59:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-09-15T00:59:28Z"}, "message": "re PR c++/3907 (nested template parm collides with member name)\n\n\t* coverage.c (create_coverage): Do not call pushlevel/poplevel.\n\t* langhooks-def.h (lhd_do_nothing_iii_return_null_tree): New\n\tfunction.\n\t* langhooks.c (lhd_do_nothing_iii_return_null_tree): Define it.\n\n\tPR c++/3907\n\t* class.c (maybe_note_name_used_in_class): Refine test for whether\n\tor not we are in a class scope.\n\n\t* cp-tree.h (language_function): Remove x_expanding_p.\n\t(expanding_p): Remove.\n\t(doing_semantic_analysis_p): Remove.\n\t(scope_kind): Add sk_function_parms, sk_class,\n\tsk_namespace.\n\t(innermost_scope_kind): New method.\n\t* call.c (cxx_type_promotes_to): Use type_decays_to.\n\t* cp-lang.c (LANG_HOOKS_PUSHLEVEL): Redefine.\n\t(LANG_HOOKS_POPLEVEL): Likewise.\n\t* decl.c (cp_binding_level): Remove parm_flag, template_parms_p,\n\ttemplate_spec_p, namespace_p, is_for_scope, is_try_scope, and\n\tis_catch_scope.  Add kind and explicit_spec_p.\n\t(cxx_scope_descriptor): Use a lookup table.\n\t(find_class_binding_level): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(pop_binding_level): Likewise.\n\t(innermost_nonclass_level): Likewise.\n\t(toplevel_bindings_p): Likewise.\n\t(namespace_bindings_p): Likewise.\n\t(template_parm_scope_p): Likewise.\n\t(innermost_scope_kind): New method.\n\t(current_tmpl_spec_kind): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(pushlevel): Remove check for doing_semantic_analysis_p.\n\t(begin_scope): Simplify.\n\t(add_decl_to_level): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(push_local_binding): Likewise.\n\t(pop_label): Remove check for doing_semantic_analysis_p.\n\t(poplevel): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(set_block): Remove check for doing_semantic_analysis_p.\n\t(pushlevel_class): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(poplevel_class): Likewise.\n\t(initial_push_namespace_scope): Likewise.\n\t(maybe_push_to_top_level): Likewise.\n\t(set_identifier_type_value_with_scope): Likewise.\n\t(pop_everything): Likewise.\n\t(maybe_process_template_type_declaration): Likewise.\n\t(pushtag): Likewise.\n\t(pushdecl): Likewise.\n\t(pushdecl_with_scope): Likewise.\n\t(check_previous_goto_1): Likewise.\n\t(define_label): Likewise.\n\t(finish_case_label): Likewise.\n\t(lookup_tag): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_name_real): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(lookup_type_current_level): Likewise.\n\t(record_builtin_type): Likewise.\n\t(cp_make_fname_decl): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(cp_finish_decl): Remove check for doing_semantic_analysis_p.\n\t(start_function): Use begin_scope, not pushlevel.\n\t(finish_function): Use \"kind\" field in binding_level, not\n\tthe various flags.\n\t(start_method): Use begin_scope, not pushlevel.\n\t(make_label_decl): Do not check expanding_p.\n\t(save_function-data): Do not set expanding_p.\n\t(cxx_push_function_context): Do not clear expanding_p.\n\t* semantics.c (cxx_expand_function_start): Do not set expanding_p.\n\n\tPR c++/3907\n\t* g++.dg/parse/template12.C: New test.\n\n\t* g++.dg/abi/bitfield11.C: New test.\n\t* g++.dg/abi/bitfield12.C: Likewise.\n\nFrom-SVN: r71393", "tree": {"sha": "f3051c561271e0d6315435584c95dbebfa9c2c8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3051c561271e0d6315435584c95dbebfa9c2c8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e8c268ed44dd8f09259ba8000be311af7562e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e8c268ed44dd8f09259ba8000be311af7562e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e8c268ed44dd8f09259ba8000be311af7562e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e8c268ed44dd8f09259ba8000be311af7562e7/comments", "author": null, "committer": null, "parents": [{"sha": "29edb15c5637738f3ac9c9d63003303127848204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29edb15c5637738f3ac9c9d63003303127848204", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29edb15c5637738f3ac9c9d63003303127848204"}], "stats": {"total": 435, "additions": 230, "deletions": 205}, "files": [{"sha": "d7e7d64d829f314459a286918a5be9ed1ca81b2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -1,3 +1,10 @@\n+2003-09-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* coverage.c (create_coverage): Do not call pushlevel/poplevel.\n+\t* langhooks-def.h (lhd_do_nothing_iii_return_null_tree): New\n+\tfunction.\n+\t* langhooks.c (lhd_do_nothing_iii_return_null_tree): Define it.\n+\t\n 2003-09-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* combine.c (simplify_comparison): Convert"}, {"sha": "e6f4129dd79011e368cd01ea477d1d2503e9b04a", "filename": "gcc/coverage.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -854,19 +854,18 @@ create_coverage (void)\n   rest_of_decl_compilation (ctor, 0, 1, 0);\n   announce_function (ctor);\n   current_function_decl = ctor;\n-  DECL_INITIAL (ctor) = error_mark_node;\n   make_decl_rtl (ctor, NULL);\n   init_function_start (ctor);\n-  (*lang_hooks.decls.pushlevel) (0);\n   expand_function_start (ctor, 0);\n-\n   /* Actually generate the code to call __gcov_init.  */\n   gcov_info_address = force_reg (Pmode, XEXP (DECL_RTL (gcov_info), 0));\n   emit_library_call (gcov_init_libfunc, LCT_NORMAL, VOIDmode, 1,\n \t\t     gcov_info_address, Pmode);\n \n   expand_function_end ();\n-  (*lang_hooks.decls.poplevel) (1, 0, 1);\n+  /* Create a dummy BLOCK.  */\n+  DECL_INITIAL (ctor) = make_node (BLOCK);\n+  TREE_USED (DECL_INITIAL (ctor)) = 1;\n \n   rest_of_compilation (ctor);\n "}, {"sha": "374e7e57e66986b1b0e3e211b5caa5dbba5c97b8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -1,3 +1,73 @@\n+2003-09-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/3907\n+\t* class.c (maybe_note_name_used_in_class): Refine test for whether\n+\tor not we are in a class scope.\n+\n+\t* cp-tree.h (language_function): Remove x_expanding_p.\n+\t(expanding_p): Remove.\n+\t(doing_semantic_analysis_p): Remove.\n+\t(scope_kind): Add sk_function_parms, sk_class,\n+\tsk_namespace.\n+\t(innermost_scope_kind): New method.\n+\t* call.c (cxx_type_promotes_to): Use type_decays_to.\n+\t* cp-lang.c (LANG_HOOKS_PUSHLEVEL): Redefine.\n+\t(LANG_HOOKS_POPLEVEL): Likewise.\n+\t* decl.c (cp_binding_level): Remove parm_flag, template_parms_p,\n+\ttemplate_spec_p, namespace_p, is_for_scope, is_try_scope, and\n+\tis_catch_scope.  Add kind and explicit_spec_p.\n+\t(cxx_scope_descriptor): Use a lookup table.\n+\t(find_class_binding_level): Use \"kind\" field in binding_level, not\n+\tthe various flags.\n+\t(pop_binding_level): Likewise.\n+\t(innermost_nonclass_level): Likewise.\n+\t(toplevel_bindings_p): Likewise.\n+\t(namespace_bindings_p): Likewise.\n+\t(template_parm_scope_p): Likewise.\n+\t(innermost_scope_kind): New method.\n+\t(current_tmpl_spec_kind): Use \"kind\" field in binding_level, not\n+\tthe various flags.\n+\t(pushlevel): Remove check for doing_semantic_analysis_p.\n+\t(begin_scope): Simplify.\n+\t(add_decl_to_level): Use \"kind\" field in binding_level, not\n+\tthe various flags.\n+\t(push_local_binding): Likewise.\n+\t(pop_label): Remove check for doing_semantic_analysis_p.\n+\t(poplevel): Use \"kind\" field in binding_level, not\n+\tthe various flags.\n+\t(set_block): Remove check for doing_semantic_analysis_p.\n+\t(pushlevel_class): Use \"kind\" field in binding_level, not\n+\tthe various flags. \n+\t(poplevel_class): Likewise.\n+\t(initial_push_namespace_scope): Likewise.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(set_identifier_type_value_with_scope): Likewise.\n+\t(pop_everything): Likewise.\n+\t(maybe_process_template_type_declaration): Likewise.\n+\t(pushtag): Likewise.\n+\t(pushdecl): Likewise.\n+\t(pushdecl_with_scope): Likewise.\n+\t(check_previous_goto_1): Likewise.\n+\t(define_label): Likewise.\n+\t(finish_case_label): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(lookup_type_current_level): Likewise.\n+\t(record_builtin_type): Likewise.\n+\t(cp_make_fname_decl): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(cp_finish_decl): Remove check for doing_semantic_analysis_p.\n+\t(start_function): Use begin_scope, not pushlevel.\n+\t(finish_function): Use \"kind\" field in binding_level, not\n+\tthe various flags.\n+\t(start_method): Use begin_scope, not pushlevel.\n+\t(make_label_decl): Do not check expanding_p.\n+\t(save_function-data): Do not set expanding_p.\n+\t(cxx_push_function_context): Do not clear expanding_p.\n+\t* semantics.c (cxx_expand_function_start): Do not set expanding_p.\n+\t\n 2003-09-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_class_type): Make DECL_MODE match TYPE_MODE for"}, {"sha": "214fbae07a38917ee70d2428f78092a6c949122d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -4278,11 +4278,9 @@ cxx_type_promotes_to (tree type)\n {\n   tree promote;\n \n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_pointer_type (TREE_TYPE (type));\n-\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    return build_pointer_type (type);\n+  /* Perform the array-to-pointer and function-to-pointer\n+     conversions.  */\n+  type = type_decays_to (type);\n \n   promote = type_promotes_to (type);\n   if (same_type_p (type, promote))"}, {"sha": "1809f2d4961c2f756f4a03887fce3943d8a7ce1f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -6358,7 +6358,7 @@ maybe_note_name_used_in_class (tree name, tree decl)\n   splay_tree names_used;\n \n   /* If we're not defining a class, there's nothing to do.  */\n-  if (!current_class_type || !TYPE_BEING_DEFINED (current_class_type))\n+  if (innermost_scope_kind() != sk_class)\n     return;\n   \n   /* If there's already a binding for this NAME, then we don't have"}, {"sha": "3e229a01004cf75672a89fa99162171e4650a58b", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -102,6 +102,10 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tcxx_printable_name\n #undef LANG_HOOKS_PRINT_ERROR_FUNCTION\n #define LANG_HOOKS_PRINT_ERROR_FUNCTION\tcxx_print_error_function\n+#undef LANG_HOOKS_PUSHLEVEL\n+#define LANG_HOOKS_PUSHLEVEL lhd_do_nothing_i\n+#undef LANG_HOOKS_POPLEVEL\n+#define LANG_HOOKS_POPLEVEL lhd_do_nothing_iii_return_null_tree\n #undef LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL cxx_warn_unused_global_decl\n #undef LANG_HOOKS_WRITE_GLOBALS"}, {"sha": "1d126e85618bad0c4fe510529f9db16d2997fbaa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -798,7 +798,6 @@ struct language_function GTY(())\n   int returns_abnormally;\n   int in_function_try_handler;\n   int in_base_initializer;\n-  int x_expanding_p;\n \n   /* True if this function can throw an exception.  */\n   bool can_throw : 1;\n@@ -860,17 +859,6 @@ struct language_function GTY(())\n #define current_function_returns_abnormally \\\n   cp_function_chain->returns_abnormally\n \n-/* Nonzero if we should generate RTL for functions that we process.\n-   When this is zero, we just accumulate tree structure, without\n-   interacting with the back end.  */\n-\n-#define expanding_p cp_function_chain->x_expanding_p\n-\n-/* Nonzero if we are in the semantic analysis phase for the current\n-   function.  */\n-\n-#define doing_semantic_analysis_p() (!expanding_p)\n-\n /* Nonzero if we are processing a base initializer.  Zero elsewhere.  */\n #define in_base_initializer cp_function_chain->in_base_initializer\n \n@@ -2942,15 +2930,24 @@ typedef enum cp_lvalue_kind {\n \n /* The kinds of scopes we recognize.  */\n typedef enum scope_kind {\n-  sk_block,          /* An ordinary block scope.  */\n+  sk_block = 0,      /* An ordinary block scope.  This enumerator must\n+\t\t\thave the value zero because \"cp_binding_level\"\n+\t\t\tis initialized by using \"memset\" to set the\n+\t\t\tcontents to zero, and the default scope kind\n+\t\t\tis \"sk_block\".  */\n   sk_try,\t     /* A try-block.  */\n   sk_catch,          /* A catch-block.  */\n   sk_for,            /* The scope of the variable declared in a\n \t\t\tfor-init-statement.  */\n+  sk_function_parms, /* The scope containing function parameters.  */\n+  sk_class,          /* The scope containing the members of a class.  */\n+  sk_namespace,      /* The scope containing the members of a\n+\t\t\tnamespace, including the global scope.  */\n   sk_template_parms, /* A scope for template parameters.  */\n-  sk_template_spec   /* A scope corresponding to a template\n-\t\t\tspecialization.  There is never anything in\n-\t\t\tthis scope.  */\n+  sk_template_spec   /* Like sk_template_parms, but for an explicit\n+\t\t\tspecialization.  Since, by definition, an\n+\t\t\texplicit specialization is introduced by\n+\t\t\t\"template <>\", this scope is always empty.  */\n } scope_kind;\n \n /* Various kinds of template specialization, instantiation, etc.  */\n@@ -3622,6 +3619,7 @@ extern void cxx_mark_function_context\t\t(struct function *);\n extern int toplevel_bindings_p\t\t\t(void);\n extern int namespace_bindings_p\t\t\t(void);\n extern void keep_next_level\t\t\t(int);\n+extern scope_kind innermost_scope_kind          (void);\n extern int template_parm_scope_p\t\t(void);\n extern void set_class_shadows\t\t\t(tree);\n extern void maybe_push_cleanup_level\t\t(tree);"}, {"sha": "92e8597efd51d19a4a0876c4fa58ba1f7741f900", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 104, "deletions": 175, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -370,51 +370,31 @@ struct cp_binding_level GTY(())\n        TREE_LIST; the TREE_VALUE is the actual declaration.  */\n     tree dead_vars_from_for;\n \n-    /* 1 for the level that holds the parameters of a function.\n-       2 for the level that holds a class declaration.  */\n-    unsigned parm_flag : 2;\n+    /* Binding depth at which this level began.  */\n+    unsigned binding_depth;\n+\n+    /* The kind of scope that this object represents.  However, a\n+       SK_TEMPLATE_SPEC scope is represented with KIND set to\n+       SK_TEMPALTE_PARMS and EXPLICIT_SPEC_P set to true.  */\n+    enum scope_kind kind : 4;\n+\n+    /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is\n+       only valid if KIND == SK_TEMPLATE_PARMS.  */\n+    bool explicit_spec_p : 1;\n \n     /* 1 means make a BLOCK for this level regardless of all else.\n        2 for temporary binding contours created by the compiler.  */\n     unsigned keep : 2;\n \n-    /* Nonzero if this level \"doesn't exist\" for tags.  */\n-    unsigned tag_transparent : 1;\n-\n     /* Nonzero if this level can safely have additional\n        cleanup-needing variables added to it.  */\n     unsigned more_cleanups_ok : 1;\n     unsigned have_cleanups : 1;\n \n-    /* Nonzero if this scope is for storing the decls for template\n-       parameters and generic decls; these decls will be discarded and\n-       replaced with a TEMPLATE_DECL.  */\n-    unsigned template_parms_p : 1;\n-\n-    /* Nonzero if this scope corresponds to the `<>' in a\n-       `template <>' clause.  Whenever this flag is set,\n-       TEMPLATE_PARMS_P will be set as well.  */\n-    unsigned template_spec_p : 1;\n-\n-    /* This is set for a namespace binding level.  */\n-    unsigned namespace_p : 1;\n-\n-    /* True if this level is that of a for-statement where we need to\n-       worry about ambiguous (ARM or ISO) scope rules.  */\n-    unsigned is_for_scope : 1;\n-\n-    /* True if this level corresponds to a TRY block.  Currently this\n-       information is only available while building the tree structure.  */\n-    unsigned is_try_scope : 1;\n-\n-    /* True if this level corresponds to a CATCH block.  Currently this\n-       information is only available while building the tree structure.  */\n-    unsigned is_catch_scope : 1;\n-\n-    /* Three bits left for this word.  */\n+    /* Nonzero if this level \"doesn't exist\" for tags.  */\n+    unsigned tag_transparent : 1;\n \n-    /* Binding depth at which this level began.  */\n-    unsigned binding_depth;\n+    /* 20 bits left to fill a 32-bit word.  */\n   };\n \n #define NULL_BINDING_LEVEL ((struct cp_binding_level *) NULL)\n@@ -468,28 +448,18 @@ static tree pushdecl_with_scope\t(tree, struct cp_binding_level *);\n static const char *\n cxx_scope_descriptor (cxx_scope *scope)\n {\n-  const char *desc;\n-\n-  if (scope->namespace_p)\n-    desc = \"namespace-scope\";\n-  else if (scope->parm_flag == 1)\n-    desc = \"function-prototype-scope\";\n-  else if (scope->parm_flag == 2)\n-    desc = \"class-scope\";\n-  else if (scope->is_for_scope)\n-    desc = \"for-scope\";\n-  else if (scope->is_try_scope)\n-    desc = \"try-scope\";\n-  else if (scope->is_catch_scope)\n-    desc = \"catch-scope\";\n-  else if (scope->template_spec_p)\n-    desc = \"template-explicit-spec-scope\";\n-  else if (scope->template_parms_p)\n-    desc = \"template-prototype-scope\";\n-  else\n-    desc = \"block-scope\";\n+  /* The order of this table must match the \"scope_kind\"\n+     enumerators.  */\n+  static const char* scope_kind_names[] = {\n+    \"block-scope\",\n+    \"try-scope\",\n+    \"catch-scope\",\n+    \"for-scope\",\n+    \"template-parameter-scope\",\n+    \"template-explicit-spec-scope\"\n+  };\n \n-  return desc;\n+  return scope_kind_names[scope->kind];\n }\n \n /* Output a debugging information about SCOPE when performning\n@@ -555,9 +525,9 @@ find_class_binding_level (void)\n {\n   struct cp_binding_level *level = current_binding_level;\n \n-  while (level && level->parm_flag != 2)\n+  while (level && level->kind != sk_class)\n     level = level->level_chain;\n-  if (level && level->parm_flag == 2)\n+  if (level && level->kind == sk_class)\n     class_binding_level = level;\n   else\n     class_binding_level = 0;\n@@ -586,7 +556,7 @@ pop_binding_level (void)\n     register struct cp_binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n     level->level_chain = free_binding_level;\n-    if (level->parm_flag == 2)\n+    if (level->kind == sk_class)\n       level->type_decls = NULL;\n     else\n       binding_table_free (level->type_decls);\n@@ -659,7 +629,7 @@ innermost_nonclass_level (void)\n   struct cp_binding_level *b;\n \n   b = current_binding_level;\n-  while (b->parm_flag == 2)\n+  while (b->kind == sk_class)\n     b = b->level_chain;\n \n   return b;\n@@ -676,7 +646,7 @@ toplevel_bindings_p (void)\n {\n   struct cp_binding_level *b = innermost_nonclass_level ();\n \n-  return b->namespace_p || b->template_parms_p;\n+  return b->kind == sk_namespace || b->kind == sk_template_parms;\n }\n \n /* Nonzero if this is a namespace scope, or if we are defining a class\n@@ -688,7 +658,7 @@ namespace_bindings_p (void)\n {\n   struct cp_binding_level *b = innermost_nonclass_level ();\n \n-  return b->namespace_p;\n+  return b->kind == sk_namespace;\n }\n \n /* If KEEP is nonzero, make a BLOCK node for the next binding level,\n@@ -713,13 +683,21 @@ kept_level_p (void)\n \t      && !current_binding_level->tag_transparent));\n }\n \n+/* Returns the kind of the innermost scope.  */\n+\n+scope_kind\n+innermost_scope_kind (void)\n+{\n+  return current_binding_level->kind;\n+}\n+\n /* Returns nonzero if this scope was created to store template\n    parameters.  */\n \n int\n template_parm_scope_p (void)\n {\n-  return current_binding_level->template_parms_p;\n+  return innermost_scope_kind () == sk_template_parms;\n }\n \n /* Returns the kind of template specialization we are currently\n@@ -735,7 +713,9 @@ current_tmpl_spec_kind (int n_class_scopes)\n   struct cp_binding_level *b;\n \n   /* Scan through the template parameter scopes.  */\n-  for (b = current_binding_level; b->template_parms_p; b = b->level_chain)\n+  for (b = current_binding_level; \n+       b->kind == sk_template_parms; \n+       b = b->level_chain)\n     {\n       /* If we see a specialization scope inside a parameter scope,\n \t then something is wrong.  That corresponds to a declaration\n@@ -746,7 +726,7 @@ current_tmpl_spec_kind (int n_class_scopes)\n \t which is always invalid since [temp.expl.spec] forbids the\n \t specialization of a class member template if the enclosing\n \t class templates are not explicitly specialized as well.  */\n-      if (b->template_spec_p)\n+      if (b->explicit_spec_p)\n \t{\n \t  if (n_template_parm_scopes == 0)\n \t    innermost_specialization_p = 1;\n@@ -823,9 +803,6 @@ set_class_shadows (tree shadows)\n void\n pushlevel (int tag_transparent)\n {\n-  if (cfun && !doing_semantic_analysis_p ())\n-    return;\n-\n   push_binding_level (make_cxx_scope (tag_transparent, keep_next_level_flag));\n   keep_next_level_flag = 0;\n }\n@@ -854,35 +831,12 @@ void\n begin_scope (scope_kind sk)\n {\n   pushlevel (0);\n-\n-  switch (sk)\n+  if (sk == sk_template_spec)\n     {\n-    case sk_block:\n-      break;\n-\n-    case sk_try:\n-      current_binding_level->is_try_scope = 1;\n-      break;\n-\n-    case sk_catch:\n-      current_binding_level->is_catch_scope = 1;\n-      break;\n-\n-    case sk_for:\n-      current_binding_level->is_for_scope = 1;\n-      break;\n-\n-    case sk_template_spec:\n-      current_binding_level->template_spec_p = 1;\n-      /* Fall through.  */\n-\n-    case sk_template_parms:\n-      current_binding_level->template_parms_p = 1;\n-      break;\n-\n-    default:\n-      abort ();\n+      current_binding_level->explicit_spec_p = true;\n+      sk = sk_template_parms;\n     }\n+  current_binding_level->kind = sk;\n }\n \n /* Exit the current scope.  */\n@@ -937,7 +891,7 @@ add_decl_to_level (tree decl,\n       b->names_size++;\n \n       /* If appropriate, add decl to separate list of statics */\n-      if (b->namespace_p)\n+      if (b->kind == sk_namespace)\n \tif ((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n \t    || (TREE_CODE (decl) == FUNCTION_DECL\n \t\t&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))\n@@ -957,9 +911,7 @@ push_local_binding (tree id, tree decl, int flags)\n \n   /* Skip over any local classes.  This makes sense if we call\n      push_local_binding with a friend decl of a local class.  */\n-  b = current_binding_level;\n-  while (b->parm_flag == 2)\n-    b = b->level_chain;\n+  b = innermost_nonclass_level ();\n \n   if (lookup_name_current_level (id))\n     {\n@@ -1091,7 +1043,7 @@ pop_binding (tree id, tree decl)\n static void\n pop_label (tree label, tree old_value)\n {\n-  if (!processing_template_decl && doing_semantic_analysis_p ())\n+  if (!processing_template_decl)\n     {\n       if (DECL_INITIAL (label) == NULL_TREE)\n \t{\n@@ -1163,11 +1115,8 @@ poplevel (int keep, int reverse, int functionbody)\n   int leaving_for_scope;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  if (cfun && !doing_semantic_analysis_p ())\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \n-  my_friendly_assert (current_binding_level->parm_flag != 2,\n-\t\t      19990916);\n+  my_friendly_assert (current_binding_level->kind != sk_class, 19990916);\n \n   real_functionbody = (current_binding_level->keep == 2\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n@@ -1198,9 +1147,9 @@ poplevel (int keep, int reverse, int functionbody)\n \t    if (labels->binding_level == current_binding_level)\n \t      {\n \t\ttree decl;\n-\t\tif (current_binding_level->is_try_scope)\n+\t\tif (current_binding_level->kind == sk_try)\n \t\t  labels->in_try_scope = 1;\n-\t\tif (current_binding_level->is_catch_scope)\n+\t\tif (current_binding_level->kind == sk_catch)\n \t\t  labels->in_catch_scope = 1;\n \t\tfor (decl = labels->names_in_scope; decl;\n \t\t     decl = TREE_CHAIN (decl))\n@@ -1282,7 +1231,7 @@ poplevel (int keep, int reverse, int functionbody)\n      ended.  We only use the new rules if flag_new_for_scope is\n      nonzero.  */\n   leaving_for_scope\n-    = current_binding_level->is_for_scope && flag_new_for_scope == 1;\n+    = current_binding_level->kind == sk_for && flag_new_for_scope == 1;\n \n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n@@ -1499,7 +1448,6 @@ set_block (tree block ATTRIBUTE_UNUSED )\n {\n   /* The RTL expansion machinery requires us to provide this callback,\n      but it is not applicable in function-at-a-time mode.  */\n-  my_friendly_assert (cfun && !doing_semantic_analysis_p (), 20000911);\n }\n \n /* Do a pushlevel for class declarations.  */\n@@ -1510,10 +1458,8 @@ pushlevel_class (void)\n   if (ENABLE_SCOPE_CHECKING)\n     is_class_level = 1;\n \n-  push_binding_level (make_cxx_scope (false, 0));\n-\n+  begin_scope (sk_class);\n   class_binding_level = current_binding_level;\n-  class_binding_level->parm_flag = 2;\n   class_binding_level->this_entity = current_class_type;\n }\n \n@@ -1546,7 +1492,7 @@ poplevel_class (void)\n       /* Find the next enclosing class, and recreate\n \t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n       b = level->level_chain;\n-      while (b && b->parm_flag != 2)\n+      while (b && b->kind != sk_class)\n \tb = b->level_chain;\n \n       if (b)\n@@ -1937,9 +1883,8 @@ initial_push_namespace_scope (tree ns)\n   tree name = DECL_NAME (ns);\n   cxx_scope *scope;\n \n-  pushlevel (0);\n+  begin_scope (sk_namespace);\n   scope = current_binding_level;\n-  scope->namespace_p = true;\n   scope->type_decls = binding_table_new (name == std_identifier\n                                          ? NAMESPACE_STD_HT_SIZE\n                                          : (name == global_scope_name\n@@ -2167,13 +2112,13 @@ maybe_push_to_top_level (int pseudo)\n \t inserted into namespace level, finish_file wouldn't find them\n \t when doing pending instantiations. Therefore, don't stop at\n \t namespace level, but continue until :: .  */\n-      if (global_scope_p (b) || (pseudo && b->template_parms_p))\n+      if (global_scope_p (b) || (pseudo && b->kind == sk_template_parms))\n \tbreak;\n \n       old_bindings = store_bindings (b->names, old_bindings);\n       /* We also need to check class_shadowed to save class-level type\n \t bindings, since pushclass doesn't fill in b->names.  */\n-      if (b->parm_flag == 2)\n+      if (b->kind == sk_class)\n \told_bindings = store_bindings (b->class_shadowed, old_bindings);\n \n       /* Unwind type-value slots back to top level.  */\n@@ -2244,7 +2189,7 @@ set_identifier_type_value_with_scope (tree id,\n {\n   tree type;\n \n-  if (!b->namespace_p)\n+  if (b->kind != sk_namespace)\n     {\n       /* Shadow the marker, not the real thing, so that the marker\n \t gets restored later.  */\n@@ -2311,7 +2256,7 @@ pop_everything (void)\n     verbatim (\"XXX entering pop_everything ()\\n\");\n   while (!toplevel_bindings_p ())\n     {\n-      if (current_binding_level->parm_flag == 2)\n+      if (current_binding_level->kind == sk_class)\n \tpop_nested_class ();\n       else\n \tpoplevel (0, 0, 0);\n@@ -2367,8 +2312,8 @@ maybe_process_template_type_declaration (tree type,\n \t     friend case, push_template_decl will already have put the\n \t     friend into global scope, if appropriate.  */\n \t  if (TREE_CODE (type) != ENUMERAL_TYPE\n-\t      && !globalize && b->template_parms_p\n-\t      && b->level_chain->parm_flag == 2)\n+\t      && !globalize && b->kind == sk_template_parms\n+\t      && b->level_chain->kind == sk_class)\n \t    {\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n \t      /* Put this UDT in the table of UDTs for the class, since\n@@ -2464,7 +2409,7 @@ pushtag (tree name, tree type, int globalize)\n   timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n   while (b->tag_transparent\n-\t || (b->parm_flag == 2\n+\t || (b->kind == sk_class\n \t     && (globalize\n \t\t /* We may be defining a new type in the initializer\n \t\t    of a static member variable. We allow this when\n@@ -2501,8 +2446,9 @@ pushtag (tree name, tree type, int globalize)\n \t  if (!context)\n \t    context = current_namespace;\n \n-\t  if ((b->template_parms_p && b->level_chain->parm_flag == 2)\n-\t      || b->parm_flag == 2)\n+\t  if (b->kind == sk_class\n+\t      || (b->kind == sk_template_parms \n+\t\t  && b->level_chain->kind == sk_class))\n \t    in_class = 1;\n \n \t  if (current_lang_name == lang_name_java)\n@@ -2516,7 +2462,7 @@ pushtag (tree name, tree type, int globalize)\n \t  d = maybe_process_template_type_declaration (type,\n \t\t\t\t\t\t       globalize, b);\n \n-\t  if (b->parm_flag == 2)\n+\t  if (b->kind == sk_class)\n \t    {\n \t      if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n@@ -2546,14 +2492,12 @@ pushtag (tree name, tree type, int globalize)\n \t      && !processing_template_decl)\n \t    VARRAY_PUSH_TREE (local_classes, type);\n         }\n-      if (b->parm_flag == 2)\n+      if (b->kind == sk_class\n+\t  && !COMPLETE_TYPE_P (current_class_type))\n \t{\n-\t  if (!COMPLETE_TYPE_P (current_class_type))\n-\t    {\n-\t      maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t\t  type, /*friend_p=*/0);\n-\t      CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n-\t    }\n+\t  maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t      type, /*friend_p=*/0);\n+\t  CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n \t}\n     }\n \n@@ -3559,10 +3503,6 @@ pushdecl (tree x)\n   int need_new_binding;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  /* We shouldn't be calling pushdecl when we're generating RTL for a\n-     function that we already did semantic analysis on previously.  */\n-  my_friendly_assert (!cfun || doing_semantic_analysis_p (),\n-\t\t      19990913);\n \n   need_new_binding = 1;\n \n@@ -3943,10 +3883,10 @@ pushdecl (tree x)\n \t\t  b = b->level_chain;\n \n \t\t  /* ARM $8.3 */\n-\t\t  if (b->parm_flag == 1)\n+\t\t  if (b->kind == sk_function_parms)\n \t\t    {\n \t\t      error (\"declaration of `%#D' shadows a parameter\",\n-\t\t\t\tname);\n+\t\t\t     name);\n \t\t      err = true;\n \t\t    }\n \t\t}\n@@ -4007,7 +3947,7 @@ pushdecl_with_scope (tree x, struct cp_binding_level* level)\n \n   timevar_push (TV_NAME_LOOKUP);\n   current_function_decl = NULL_TREE;\n-  if (level->parm_flag == 2)\n+  if (level->kind == sk_class)\n     {\n       b = class_binding_level;\n       class_binding_level = level;\n@@ -4574,9 +4514,6 @@ make_label_decl (tree id, int local_p)\n   tree decl;\n \n   decl = build_decl (LABEL_DECL, id, void_type_node);\n-  if (expanding_p)\n-    /* Make sure every label has an rtx.  */\n-    label_rtx (decl);\n \n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_MODE (decl) = VOIDmode;\n@@ -4745,7 +4682,7 @@ check_previous_goto_1 (tree decl,\n \n       if (b == level)\n \tbreak;\n-      if ((b->is_try_scope || b->is_catch_scope) && ! saw_eh)\n+      if ((b->kind == sk_try || b->kind == sk_catch) && ! saw_eh)\n \t{\n \t  if (! identified)\n \t    {\n@@ -4758,7 +4695,7 @@ check_previous_goto_1 (tree decl,\n \t\tpedwarn (\"%H  from here\", locus);\n \t      identified = 1;\n \t    }\n-\t  if (b->is_try_scope)\n+\t  if (b->kind == sk_try)\n \t    error (\"  enters try block\");\n \t  else\n \t    error (\"  enters catch block\");\n@@ -4880,7 +4817,9 @@ define_label (location_t location, tree name)\n \n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n-  for (p = current_binding_level; !(p->parm_flag); p = p->level_chain)\n+  for (p = current_binding_level; \n+       p->kind != sk_function_parms; \n+       p = p->level_chain)\n     p->more_cleanups_ok = 0;\n \n   if (name == get_identifier (\"wchar_t\"))\n@@ -4995,7 +4934,9 @@ finish_case_label (tree low_value, tree high_value)\n \n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n-  for (p = current_binding_level; !(p->parm_flag); p = p->level_chain)\n+  for (p = current_binding_level; \n+       p->kind != sk_function_parms; \n+       p = p->level_chain)\n     p->more_cleanups_ok = 0;\n \n   return r;\n@@ -5104,7 +5045,7 @@ lookup_tag (enum tree_code form, tree name,\n           if (type != NULL)\n             POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n         }\n-      else if (level->namespace_p)\n+      else if (level->kind == sk_namespace)\n \t/* Do namespace lookup.  */\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n \t  {\n@@ -5165,7 +5106,7 @@ lookup_tag (enum tree_code form, tree name,\n \t  }\n       if (thislevel_only && ! level->tag_transparent)\n \t{\n-\t  if (level->template_parms_p && allow_template_parms_p)\n+\t  if (level->kind == sk_template_parms && allow_template_parms_p)\n \t    {\n \t      /* We must deal with cases like this:\n \n@@ -5628,7 +5569,7 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n \n       /* Add all _DECLs seen through local using-directives.  */\n       for (level = current_binding_level;\n-\t   !level->namespace_p;\n+\t   level->kind != sk_namespace;\n \t   level = level->level_chain)\n \tif (!lookup_using_namespace (name, &binding, level->using_directives,\n                                      scope, flags, spacesp))\n@@ -5813,15 +5754,15 @@ lookup_name_real (tree name, int prefer_type, int nonclass,\n       struct cp_binding_level *level;\n \n       for (level = current_binding_level; \n-\t   level && !level->namespace_p; \n+\t   level && level->kind != sk_namespace;\n \t   level = level->level_chain)\n \t{\n \t  tree class_type;\n \t  tree operators;\n \t  \n \t  /* A conversion operator can only be declared in a class \n \t     scope.  */\n-\t  if (level->parm_flag != 2)\n+\t  if (level->kind != sk_class)\n \t    continue;\n \t  \n \t  /* Lookup the conversion operator in the class.  */\n@@ -5911,11 +5852,9 @@ lookup_name_current_level (tree name)\n   tree t = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  b = current_binding_level;\n-  while (b->parm_flag == 2)\n-    b = b->level_chain;\n+  b = innermost_nonclass_level ();\n \n-  if (b->namespace_p)\n+  if (b->kind == sk_namespace)\n     {\n       t = IDENTIFIER_NAMESPACE_VALUE (name);\n \n@@ -5949,7 +5888,8 @@ lookup_type_current_level (tree name)\n   register tree t = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (! current_binding_level->namespace_p, 980716);\n+  my_friendly_assert (current_binding_level->kind != sk_namespace, \n+\t\t      980716);\n \n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n       && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n@@ -5998,8 +5938,7 @@ record_builtin_type (enum rid rid_index,\n     {\n       tdecl = build_decl (TYPE_DECL, tname, type);\n       DECL_ARTIFICIAL (tdecl) = 1;\n-      if (tname)\n-\tSET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n+      SET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n   if (rname)\n     {\n@@ -6381,7 +6320,7 @@ cp_make_fname_decl (tree id, int type_dep)\n   if (current_function_decl)\n     {\n       struct cp_binding_level *b = current_binding_level;\n-      while (b->level_chain->parm_flag == 0)\n+      while (b->level_chain->kind != sk_function_parms)\n \tb = b->level_chain;\n       pushdecl_with_scope (decl, b);\n     }\t\n@@ -7830,7 +7769,7 @@ maybe_inject_for_scope_var (tree decl)\n       return;\n     }\n \n-  if (current_binding_level->is_for_scope)\n+  if (current_binding_level->kind == sk_for)\n     {\n       struct cp_binding_level *outer\n \t= current_binding_level->level_chain;\n@@ -7853,7 +7792,7 @@ maybe_inject_for_scope_var (tree decl)\n \t{\n \t  BINDING_VALUE (outer_binding)\n \t    = DECL_SHADOWED_FOR_VAR (BINDING_VALUE (outer_binding));\n-\t  current_binding_level->is_for_scope = 0;\n+\t  current_binding_level->kind = sk_block;\n \t}\n     }\n   timevar_pop (TV_NAME_LOOKUP);\n@@ -8144,8 +8083,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  if (DECL_FUNCTION_SCOPE_P (decl))\n \t    {\n \t      /* This is a local declaration.  */\n-\t      if (doing_semantic_analysis_p ())\n-\t\tmaybe_inject_for_scope_var (decl);\n+\t      maybe_inject_for_scope_var (decl);\n \t      /* Initialize the local variable.  */\n \t      if (processing_template_decl)\n \t\t{\n@@ -13630,8 +13568,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n \n-  pushlevel (0);\n-  current_binding_level->parm_flag = 1;\n+  begin_scope (sk_function_parms);\n \n   ++function_depth;\n \n@@ -13752,9 +13689,6 @@ save_function_data (tree decl)\n   f->bindings = NULL;\n   f->x_local_names = NULL;\n \n-  /* When we get back here again, we will be expanding.  */\n-  f->x_expanding_p = 1;\n-\n   /* If we've already decided that we cannot inline this function, we\n      must remember that fact when we actually go to expand the\n      function.  */\n@@ -14006,7 +13940,7 @@ finish_function (int flags)\n   /* If the current binding level isn't the outermost binding level\n      for this function, either there is a bug, or we have experienced\n      syntax errors and the statement tree is malformed.  */\n-  if (current_binding_level->parm_flag != 1)\n+  if (current_binding_level->kind != sk_function_parms)\n     {\n       /* Make sure we have already experienced errors.  */\n       if (errorcount == 0)\n@@ -14016,9 +13950,9 @@ finish_function (int flags)\n          levels.  */\n       DECL_SAVED_TREE (fndecl) = build_stmt (COMPOUND_STMT, NULL_TREE);\n \n-      while (current_binding_level->parm_flag != 1)\n+      while (current_binding_level->kind != sk_function_parms)\n \t{\n-\t  if (current_binding_level->parm_flag == 2)\n+\t  if (current_binding_level->kind == sk_class)\n \t    pop_nested_class ();\n \t  else\n \t    poplevel (0, 0, 0);\n@@ -14211,8 +14145,7 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n   cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);\n \n   /* Make a place for the parms */\n-  pushlevel (0);\n-  current_binding_level->parm_flag = 1;\n+  begin_scope (sk_function_parms);\n \n   DECL_IN_AGGR_P (fndecl) = 1;\n   return fndecl;\n@@ -14416,10 +14349,6 @@ cxx_push_function_context (struct function * f)\n     = ggc_alloc_cleared (sizeof (struct language_function));\n   f->language = p;\n \n-  /* It takes an explicit call to expand_body to generate RTL for a\n-     function.  */\n-  expanding_p = 0;\n-\n   /* Whenever we start a new function, we destroy temporaries in the\n      usual way.  */\n   current_stmt_tree ()->stmts_are_full_exprs_p = 1;"}, {"sha": "4956b418a04a87b81e9582c0adecb8a05c4df0c8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -2971,10 +2971,6 @@ nullify_returns_r (tree* tp, int* walk_subtrees, void* data)\n void\n cxx_expand_function_start (void)\n {\n-  /* Let everybody know that we're expanding this function, not doing\n-     semantic analysis.  */\n-  expanding_p = 1;\n-\n   /* Give our named return value the same RTL as our RESULT_DECL.  */\n   if (current_function_return_value)\n     COPY_DECL_RTL (DECL_RESULT (cfun->decl), current_function_return_value);"}, {"sha": "2f34664185db5c7942bae1131fd62e52fb5a9525", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -47,6 +47,7 @@ extern bool lhd_post_options (const char **);\n extern HOST_WIDE_INT lhd_get_alias_set (tree);\n extern tree lhd_return_tree (tree);\n extern tree lhd_return_null_tree (tree);\n+extern tree lhd_do_nothing_iii_return_null_tree (int, int, int);\n extern int lhd_safe_from_p (rtx, tree);\n extern int lhd_staticp (tree);\n extern int lhd_unsafe_for_reeval (tree);"}, {"sha": "6c74ed2044f8420c3d06dd9e472aa02abef854b1", "filename": "gcc/langhooks.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -56,6 +56,16 @@ lhd_do_nothing_i (int i ATTRIBUTE_UNUSED)\n {\n }\n \n+/* Do nothing (int, int, int).  Return NULL_TREE.  */\n+\n+tree\n+lhd_do_nothing_iii_return_null_tree (int i ATTRIBUTE_UNUSED, \n+\t\t\t\t     int j ATTRIBUTE_UNUSED,\n+\t\t\t\t     int k ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Do nothing (function).  */\n \n void"}, {"sha": "d3dc2c0b2c09690cf1ff841bfd52aed04f5b7b5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -1,5 +1,8 @@\n 2003-09-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/3907\n+\t* g++.dg/parse/template12.C: New test.\n+\n \t* g++.dg/abi/bitfield11.C: New test.\n \t* g++.dg/abi/bitfield12.C: Likewise.\n "}, {"sha": "ba375bc437a898f9fc2a20bbf1b38fc070f2927d", "filename": "gcc/testsuite/g++.dg/parse/template12.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e8c268ed44dd8f09259ba8000be311af7562e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate12.C?ref=a7e8c268ed44dd8f09259ba8000be311af7562e7", "patch": "@@ -0,0 +1,10 @@\n+template <int J>\n+struct A {\n+};\n+\n+struct B {\n+  template <int I>\n+  struct C : public A<I> {};\n+\n+  typedef double I;\n+};"}]}