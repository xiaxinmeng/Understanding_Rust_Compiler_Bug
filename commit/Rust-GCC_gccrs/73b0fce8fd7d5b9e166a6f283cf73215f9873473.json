{"sha": "73b0fce8fd7d5b9e166a6f283cf73215f9873473", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNiMGZjZThmZDdkNWI5ZTE2NmE2ZjI4M2NmNzMyMTVmOTg3MzQ3Mw==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@scf.usc.edu", "date": "1998-01-22T11:03:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-01-22T11:03:56Z"}, "message": "pt.c (coerce_template_parms): Don't access elements of ARGLIST that is not really present.\n\nWed Jan 21 10:29:57 1998  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n\t* pt.c (coerce_template_parms): Don't access elements of ARGLIST\n\tthat is not really present.  Substitute default arguments in\n\ttemplate template arguments.  Correctly convert TEMPLATE_DECL to\n\tTEMPLATE_TEMPLATE_PARM.\n\t(comp_template_args): TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM\n\tare no longer treated specially here.\n\t* parse.y (template_template_parm): Fix copy error.\n\t* decl.c (grokdeclarator): Warn about missing `typename' for nested\n\ttype created from template template parameters.\n\t* parse.y (bad_parm): Likewise\n\t* class.c (finish_struct): Handle TEMPLATE_TEMPLATE_PARM.\n\t(push_nested_class): Likewise.\n\t* cp-tree.def (TEMPLATE_TEMPLATE_PARM): New tree code.\n\t* cp-tree.h (DECL_TEMPLATE_TEMPLATE_PARM_P): New macro.\n\t(copy_template_template_parm): Declare.\n\t* decl.c (arg_looking_for_template): New variable.\n\t(lookup_name_real): Handle TEMPLATE_TEMPLATE_PARM.\n\tTry to return TEMPLATE_DECL or TEMPLATE_TEMPLATE_PARM\n\tnode if arg_looking_for_template is nonzero.\n\t(pushdecl): Handle TEMPLATE_TEMPLATE_PARM.\n\t(grok_op_properties, xref_tag, xref_basetypes): Likewise.\n\t(grokdeclarator): Handle TEMPLATE_DECL.\n\t* decl2.c (constructor_name_full): Handle TEMPLATE_TEMPLATE_PARM.\n\t* error.c (dump_type): Add TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM.\n\t(dump_type_prefix, dump_type_suffix) Handle TEMPLATE_TEMPLATE_PARM.\n\t(dump_decl): Handle unnamed template type parameters.\n\tHandle template template parameters.\n\t(dump_function_name): Handle template template parameters.\n\t* init.c (is_aggr_typedef, is_aggr_type, get_aggr_from_typedef):\n\tHandle TEMPLATE_TEMPLATE_PARM.\n\t* method.c (build_template_template_parm_names): New function.\n\t(build_template_parm_names): Handle TEMPLATE_DECL.\n\t(build_overload_nested_name, build_overload_name):\n\tHandle TEMPLATE_TEMPLATE_PARM.\n\t* parse.y (maybe_identifier): New nonterminal.\n\t(template_type_parm): Use it.\n\t(template_template_parm, template_arg1): New nonterminal.\n\t(template_parm): Add template_template_parm rules.\n\t(template_arg): Set processing_template_arg.\n\t(template_arg1): Rules moved from template_arg.\n\t(primary, nonnested_type): Set arg_looking_for_template if we are\n\tprocessing template arguments.\n\t* pt.c (begin_member_template_processing): Handle TEMPLATE_DECL.\n\t(process_template_parm): Handle template template parameters.\n\t(coerce_template_parms, comp_template_args): Likewise.\n\t(mangle_class_name_for_template, lookup_template_class): Likewise.\n\t(uses_template_parms): Handle TEMPLATE_DECL and\n\tTEMPLATE_TEMPLATE_PARM.\n\t(current_template_args): Handle TEMPLATE_DECL.\n\t(tsubst, tsubst_copy, unify): Handle TEMPLATE_TEMPLATE_PARM.\n\t* search.c (dfs_walk, dfs_record_inheritance):\n\tHandle TEMPLATE_TEMPLATE_PARM.\n\t* tree.c (copy_template_template_parm): New function.\n\t(mapcar): Handle TEMPLATE_TEMPLATE_PARM.\n\t* typeck.c (comptypes): Handle TEMPLATE_TEMPLATE_PARM.\n\nFrom-SVN: r17441", "tree": {"sha": "e8ac9bf91fd53264ac4c5925a5bc8accea94a3ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ac9bf91fd53264ac4c5925a5bc8accea94a3ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73b0fce8fd7d5b9e166a6f283cf73215f9873473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b0fce8fd7d5b9e166a6f283cf73215f9873473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b0fce8fd7d5b9e166a6f283cf73215f9873473", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b0fce8fd7d5b9e166a6f283cf73215f9873473/comments", "author": null, "committer": null, "parents": [{"sha": "84303d9a68d0aef3b30c426ac7183cf3afb449d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84303d9a68d0aef3b30c426ac7183cf3afb449d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84303d9a68d0aef3b30c426ac7183cf3afb449d3"}], "stats": {"total": 9522, "additions": 5122, "deletions": 4400}, "files": [{"sha": "611c9f865500be4790fed404b828d58fe01a51d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -1,3 +1,62 @@\n+Wed Jan 21 10:29:57 1998  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n+\n+\t* pt.c (coerce_template_parms): Don't access elements of ARGLIST\n+\tthat is not really present.  Substitute default arguments in \n+\ttemplate template arguments.  Correctly convert TEMPLATE_DECL to \n+\tTEMPLATE_TEMPLATE_PARM.\n+\t(comp_template_args): TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM \n+\tare no longer treated specially here.\n+\t* parse.y (template_template_parm): Fix copy error.\n+\t* decl.c (grokdeclarator): Warn about missing `typename' for nested\n+\ttype created from template template parameters.\n+\t* parse.y (bad_parm): Likewise\n+\n+\t* class.c (finish_struct): Handle TEMPLATE_TEMPLATE_PARM.\n+\t(push_nested_class): Likewise.\n+\t* cp-tree.def (TEMPLATE_TEMPLATE_PARM): New tree code.\n+\t* cp-tree.h (DECL_TEMPLATE_TEMPLATE_PARM_P): New macro.\n+\t(copy_template_template_parm): Declare.\n+\t* decl.c (arg_looking_for_template): New variable.\n+\t(lookup_name_real): Handle TEMPLATE_TEMPLATE_PARM.\n+\tTry to return TEMPLATE_DECL or TEMPLATE_TEMPLATE_PARM\n+\tnode if arg_looking_for_template is nonzero.\n+\t(pushdecl): Handle TEMPLATE_TEMPLATE_PARM.\n+\t(grok_op_properties, xref_tag, xref_basetypes): Likewise.\n+\t(grokdeclarator): Handle TEMPLATE_DECL.\n+\t* decl2.c (constructor_name_full): Handle TEMPLATE_TEMPLATE_PARM.\n+\t* error.c (dump_type): Add TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM.\n+\t(dump_type_prefix, dump_type_suffix) Handle TEMPLATE_TEMPLATE_PARM.\n+\t(dump_decl): Handle unnamed template type parameters.\n+\tHandle template template parameters.\n+\t(dump_function_name): Handle template template parameters.\n+\t* init.c (is_aggr_typedef, is_aggr_type, get_aggr_from_typedef): \n+\tHandle TEMPLATE_TEMPLATE_PARM.\n+\t* method.c (build_template_template_parm_names): New function.\n+\t(build_template_parm_names): Handle TEMPLATE_DECL.\n+\t(build_overload_nested_name, build_overload_name): \n+\tHandle TEMPLATE_TEMPLATE_PARM.\n+\t* parse.y (maybe_identifier): New nonterminal.\n+\t(template_type_parm): Use it.\n+\t(template_template_parm, template_arg1): New nonterminal.\n+\t(template_parm): Add template_template_parm rules.\n+\t(template_arg): Set processing_template_arg.\n+\t(template_arg1): Rules moved from template_arg.\n+\t(primary, nonnested_type): Set arg_looking_for_template if we are\n+\tprocessing template arguments.\n+\t* pt.c (begin_member_template_processing): Handle TEMPLATE_DECL.\n+\t(process_template_parm): Handle template template parameters.\n+\t(coerce_template_parms, comp_template_args): Likewise.\n+\t(mangle_class_name_for_template, lookup_template_class): Likewise.\n+\t(uses_template_parms): Handle TEMPLATE_DECL and \n+\tTEMPLATE_TEMPLATE_PARM.\n+\t(current_template_args): Handle TEMPLATE_DECL.\n+\t(tsubst, tsubst_copy, unify): Handle TEMPLATE_TEMPLATE_PARM.\n+\t* search.c (dfs_walk, dfs_record_inheritance): \n+\tHandle TEMPLATE_TEMPLATE_PARM.\n+\t* tree.c (copy_template_template_parm): New function.\n+\t(mapcar): Handle TEMPLATE_TEMPLATE_PARM.\n+\t* typeck.c (comptypes): Handle TEMPLATE_TEMPLATE_PARM.\n+\n Mon Jan 19 22:40:03 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* decl.c (start_decl): Don't allow duplicate definitions of static"}, {"sha": "d2cb7ae3cd4a4d570e7c2bce2a13c35ad6819df0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -4479,7 +4479,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n              parms, we've seen all the injected decls.  */\n \t  if ((TREE_CODE (d) == TYPE_DECL\n \t       && (TREE_TYPE (d) == t\n-\t\t   || TREE_CODE (TREE_TYPE (d)) == TEMPLATE_TYPE_PARM))\n+\t\t   || TREE_CODE (TREE_TYPE (d)) == TEMPLATE_TYPE_PARM\n+\t\t   || TREE_CODE (TREE_TYPE (d)) == TEMPLATE_TEMPLATE_PARM))\n \t      || TREE_CODE (d) == CONST_DECL)\n \t    break;\n \t  /* Don't inject cache decls.  */\n@@ -4883,7 +4884,8 @@ push_nested_class (type, modify)\n   tree context;\n \n   if (type == NULL_TREE || type == error_mark_node || ! IS_AGGR_TYPE (type)\n-      || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+      || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n     return;\n   \n   context = DECL_CONTEXT (TYPE_MAIN_DECL (type));"}, {"sha": "5d3f75f74d3888a7ca9100227115afe8484e7d27", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -91,6 +91,12 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", 'd', 0)\n    Use TYPE_FIELDS to find parmlist and index.  */\n DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n \n+/* Index into a template parameter list.  This parameter must be a type.\n+   If it is used in signature of a template, TEMPLATE_INFO is NULL_TREE.\n+   Otherwise it is used to declare a type like TT<int>.\n+   Use TYPE_FIELDS to find parmlist and index.  */\n+DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n+\n /* A type designated by 'typename T::t'. */\n DEFTREECODE (TYPENAME_TYPE, \"typename_type\", 't', 0)\n "}, {"sha": "b2cb28cf58a4f8956d4b5c06ab0438697405d308", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -1350,6 +1350,12 @@ extern int flag_new_for_scope;\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n #define DECL_TEMPLATE_INJECT(NODE)\tDECL_INITIAL(NODE)\n \n+/* Nonzero for TEMPLATE_DECL nodes that represents template template\n+   parameters */\n+#define DECL_TEMPLATE_TEMPLATE_PARM_P(NODE) \\\n+  (TREE_CODE (NODE) == TEMPLATE_DECL && TREE_TYPE (NODE) \\\n+   && TREE_CODE (TREE_TYPE (NODE)) == TEMPLATE_TEMPLATE_PARM)\n+\n #define DECL_FUNCTION_TEMPLATE_P(NODE)  \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n@@ -1920,11 +1926,13 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n #define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n \n-/* These macros are for accessing the fields of TEMPLATE...PARM nodes.  */\n+/* These macros are for accessing the fields of TEMPLATE_TYPE_PARM \n+   and TEMPLATE_TEMPLATE_PARM nodes.  */\n #define TEMPLATE_TYPE_IDX(NODE) TREE_INT_CST_LOW (TYPE_FIELDS (NODE))\n #define TEMPLATE_TYPE_LEVEL(NODE) TREE_INT_CST_HIGH (TYPE_FIELDS (NODE))\n #define TEMPLATE_TYPE_SET_INFO(NODE,I,L) \\\n   (TYPE_FIELDS (NODE) = build_int_2 (I, L))\n+/* These macros are for accessing the fields of TEMPLATE_CONST_PARM nodes.  */\n #define TEMPLATE_CONST_IDX(NODE) (TREE_INT_CST_LOW(NODE))\n #define TEMPLATE_CONST_LEVEL(NODE) (TREE_INT_CST_HIGH(NODE))\n #define TEMPLATE_CONST_SET_INFO(NODE,I,L) \\\n@@ -2463,6 +2471,7 @@ extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n extern int is_aggr_type_2\t\t\tPROTO((tree, tree));\n extern char *lang_printable_name\t\tPROTO((tree, int));\n extern tree build_exception_variant\t\tPROTO((tree, tree));\n+extern tree copy_template_template_parm\t\tPROTO((tree));\n extern tree copy_to_permanent\t\t\tPROTO((tree));\n extern void print_lang_statistics\t\tPROTO((void));\n extern void __eprintf"}, {"sha": "a6075e0f4fa14976db53ecacbce4bc6139966f16", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -397,6 +397,9 @@ static struct named_label_list *named_label_uses = NULL;\n    in the TREE_PURPOSE slot.  */\n tree static_aggregates;\n \n+/* Nonzero if we lookup name inside template argument.  */\n+int arg_looking_for_template;\n+\n /* -- end of C++ */\n \n /* Two expressions that are constants with value zero.\n@@ -3104,7 +3107,8 @@ pushdecl (x)\n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use.  */\n   if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n-      || TREE_CODE (x) == NAMESPACE_DECL || TREE_CODE (x) == TEMPLATE_TYPE_PARM)\n+      || TREE_CODE (x) == NAMESPACE_DECL || TREE_CODE (x) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (x) == TEMPLATE_TEMPLATE_PARM)\n     name = DECL_NAME (x);\n \n   if (name)\n@@ -4534,6 +4538,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+\t\t   || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n \t\t   || TREE_CODE (type) == TYPENAME_TYPE)\n \t    /* Someone else will give an error about this if needed.  */\n \t    val = NULL_TREE;\n@@ -4667,7 +4672,13 @@ lookup_name_real (name, prefer_type, nonclass)\n \t  val = from_obj;\n \t}\n \n-      if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n+      if (TREE_CODE (val) == TEMPLATE_DECL && arg_looking_for_template)\n+\t{\n+\t  /* TEMPLATE_TEMPLATE_PARM node is preferred over TEMPLATE_DECL.  */\n+\t  if (DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n+\t  \tval = TREE_TYPE (val);\n+\t}\n+      else if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n \t  || TREE_CODE (val) == TYPE_DECL || prefer_type <= 0)\n \t;\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n@@ -7996,7 +8007,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      else if (TREE_OPERAND (decl, 1)\n \t\t       && TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)\n \t\tctype = cname;\n-\t      else if (TREE_CODE (cname) == TEMPLATE_TYPE_PARM)\n+\t      else if (TREE_CODE (cname) == TEMPLATE_TYPE_PARM\n+\t\t       || TREE_CODE (cname) == TEMPLATE_TEMPLATE_PARM)\n \t\t{\n \t\t  cp_error (\"`%T::%D' is not a valid declarator\", cname,\n \t\t\t    TREE_OPERAND (decl, 1));\n@@ -8205,7 +8217,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    }\n \t}\n       /* C++ aggregate types.  */\n-      else if (TREE_CODE (id) == TYPE_DECL)\n+      else if (TREE_CODE (id) == TYPE_DECL || TREE_CODE (id) == TEMPLATE_DECL)\n \t{\n \t  if (type)\n \t    cp_error (\"multiple declarations `%T' and `%T'\", type,\n@@ -10592,7 +10604,8 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t    /* This lets bad template code slip through.  */\n \t\t    if (IS_AGGR_TYPE (arg)\n \t\t\t|| TREE_CODE (arg) == ENUMERAL_TYPE\n-\t\t\t|| TREE_CODE (arg) == TEMPLATE_TYPE_PARM)\n+\t\t\t|| TREE_CODE (arg) == TEMPLATE_TYPE_PARM\n+\t\t\t|| TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n \t\t      goto foundaggr;\n \t\t  }\n \t      cp_error\n@@ -10821,12 +10834,14 @@ xref_tag (code_type_node, name, binfo, globalize)\n     }\n   else\n     t = IDENTIFIER_TYPE_VALUE (name);\n-  if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM)\n+  if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM)\n     t = NULL_TREE;\n \n   if (! globalize)\n     {\n-      if (pedantic && t && TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+      if (pedantic && t && (TREE_CODE (t) == TEMPLATE_TYPE_PARM \n+\t\t\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM))\n \t{\n \t  cp_pedwarn (\"redeclaration of template type-parameter `%T'\", name);\n \t  cp_pedwarn_at (\"  previously declared here\", t);\n@@ -11023,7 +11038,8 @@ xref_basetypes (code_type_node, name, ref, binfo)\n       if (!basetype\n \t  || (TREE_CODE (basetype) != RECORD_TYPE\n \t      && TREE_CODE (basetype) != TYPENAME_TYPE\n-\t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM))\n+\t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n+\t      && TREE_CODE (basetype) != TEMPLATE_TEMPLATE_PARM))\n \t{\n \t  cp_error (\"base type `%T' fails to be a struct or class type\",\n \t\t    TREE_VALUE (binfo));"}, {"sha": "8c4efc6fc367ee743254d543bf5cd6fad20f33c5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -1997,7 +1997,8 @@ tree\n constructor_name_full (thing)\n      tree thing;\n {\n-  if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM)\n+  if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (thing) == TEMPLATE_TEMPLATE_PARM)\n     thing = TYPE_NAME (thing);\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n     {"}, {"sha": "f6acd4b0c243cfd94b6698390aadfeefe8a46ab9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -229,6 +229,86 @@ dump_type (t, v)\n       OB_PUTID (TYPE_IDENTIFIER (t));\n       break;\n \n+      /* A substituted template template parameter.  Default template \n+\t argument handling are different from dump_decl.  */\n+    case TEMPLATE_DECL:\n+      {\n+\ttree orig_args = DECL_TEMPLATE_PARMS (t);\n+\ttree args;\n+\tint i; \n+\tfor (args = orig_args = nreverse (orig_args); \n+\t     args;\n+\t     args = TREE_CHAIN (args))\n+\t  {\n+\t    int len = TREE_VEC_LENGTH (TREE_VALUE (args));\n+\n+\t    OB_PUTS (\"template <\");\n+\t    for (i = 0; i < len; i++)\n+\t      {\n+\t\ttree arg = TREE_VEC_ELT (TREE_VALUE (args), i);\n+\t\ttree defval = TREE_PURPOSE (arg);\n+\t\targ = TREE_VALUE (arg);\n+\t\tif (TREE_CODE (arg) == TYPE_DECL)\n+\t\t  {\n+\t\t    OB_PUTS (\"class \");\n+\t\t    if (DECL_NAME (arg))\n+\t\t      OB_PUTID (DECL_NAME (arg));\n+\t\t    else\n+\t\t      OB_PUTS (\"{anon}\");\n+\t\t  }\n+\t\telse\n+\t\t  dump_decl (arg, 1);\n+\t\t\n+\t\tif (defval)\n+\t\t  {\n+\t\t    OB_PUTS (\" = \");\n+\t\t    if (TREE_CODE (arg) == TYPE_DECL)\n+\t\t      dump_type (defval, 1);\n+\t\t    else\n+\t\t      dump_expr (defval, 1);\n+\t\t  }\n+\t\t\n+\t\tOB_PUTC2 (',', ' ');\n+\t      }\n+\t    if (len != 0)\n+\t      OB_UNPUT (2);\n+\t    OB_PUTC2 ('>', ' ');\n+\t  }\n+\tnreverse(orig_args);\n+\tdump_type (TREE_TYPE (t), v);\n+      }\n+      break;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+      if (!CLASSTYPE_TEMPLATE_INFO (t))\n+\t{\n+\t  /* For parameters inside template signature. */\n+\t  if (TYPE_IDENTIFIER (t))\n+\t    OB_PUTID (TYPE_IDENTIFIER (t));\n+\t  else\n+\t    OB_PUTS (\"{anonymous template template parm}\");\n+\t}\n+      else\n+\t{\n+\t  int i;\n+\t  tree args = CLASSTYPE_TI_ARGS (t);\n+\t  OB_PUTID (TYPE_IDENTIFIER (t));\n+\t  OB_PUTC ('<');\n+\t  for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n+\t    {\n+\t      tree arg = TREE_VEC_ELT (args, i);\n+\t      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n+\t\t  || TREE_CODE (arg) == TEMPLATE_DECL)\n+\t        dump_type (arg, 0);\n+\t      else\n+\t        dump_expr (arg, 0);\n+\t      if (i < TREE_VEC_LENGTH (args)-1)\n+\t        OB_PUTC2 (',', ' ');\n+\t    }\n+\t  OB_PUTC ('>');\n+\t}\n+      break;\n+\n     case TEMPLATE_TYPE_PARM:\n       dump_readonly_or_volatile (t, after);\n       if (TYPE_IDENTIFIER (t))\n@@ -447,6 +527,7 @@ dump_type_prefix (t, v)\n     case REAL_TYPE:\n     case RECORD_TYPE:\n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n     case TREE_LIST:\n     case TYPE_DECL:\n     case TREE_VEC:\n@@ -529,6 +610,7 @@ dump_type_suffix (t, v)\n     case REAL_TYPE:\n     case RECORD_TYPE:\n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n     case TREE_LIST:\n     case TYPE_DECL:\n     case TREE_VEC:\n@@ -740,7 +822,10 @@ dump_decl (t, v)\n \t\tif (TREE_CODE (arg) == TYPE_DECL)\n \t\t  {\n \t\t    OB_PUTS (\"class \");\n-\t\t    OB_PUTID (DECL_NAME (arg));\n+\t\t    if (DECL_NAME (arg))\n+\t\t      OB_PUTID (DECL_NAME (arg));\n+\t\t    else\n+\t\t      OB_PUTS (\"{anon}\");\n \t\t  }\n \t\telse\n \t\t  dump_decl (arg, 1);\n@@ -786,7 +871,8 @@ dump_decl (t, v)\n \tOB_PUTC ('<');\n \tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n \t  {\n-\t    if (TREE_CODE_CLASS (TREE_CODE (TREE_VALUE (args))) == 't')\n+\t    if (TREE_CODE_CLASS (TREE_CODE (TREE_VALUE (args))) == 't'\n+\t\t|| TREE_CODE (TREE_VALUE (args)) == TEMPLATE_DECL)\n \t      dump_type (TREE_VALUE (args), 0);\n \t    else\n \t      dump_expr (TREE_VALUE (args), 0);\n@@ -995,7 +1081,8 @@ dump_function_name (t)\n \n \t\t      if (a)\n \t\t\t{\n-\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n+\t\t\t      || TREE_CODE (a) == TEMPLATE_DECL)\n \t\t\t    dump_type (a, 0);\n \t\t\t  else\n \t\t\t    dump_expr (a, 0);\n@@ -1023,7 +1110,8 @@ dump_function_name (t)\n \n \t\t      if (a)\n \t\t\t{\n-\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't'\n+\t\t\t      || TREE_CODE (a) == TEMPLATE_DECL)\n \t\t\t    dump_type (a, 0);\n \t\t\t  else\n \t\t\t    dump_expr (a, 0);"}, {"sha": "e383405334889c26a4c0c6f70ac46ff494ee3955", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -1606,7 +1606,8 @@ is_aggr_typedef (name, or_else)\n     }\n \n   if (! IS_AGGR_TYPE (type)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n \tcp_error (\"`%T' is not an aggregate type\", type);\n@@ -1627,7 +1628,8 @@ is_aggr_type (type, or_else)\n     return 0;\n \n   if (! IS_AGGR_TYPE (type)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n \tcp_error (\"`%T' is not an aggregate type\", type);\n@@ -1658,7 +1660,8 @@ get_aggr_from_typedef (name, or_else)\n     }\n \n   if (! IS_AGGR_TYPE (type)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n \tcp_error (\"type `%T' is of non-aggregate type\", type);"}, {"sha": "1eeab3e6734ff7ec67e6a27d32e7793ec100ae41", "filename": "gcc/cp/method.c", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -73,6 +73,7 @@ static void do_build_copy_constructor PROTO((tree));\n static tree largest_union_member PROTO((tree));\n static tree build_decl_overload_real PROTO((tree, tree, tree, tree,\n \t\t\t\t\t    tree, int)); \n+static void build_template_template_parm_names PROTO((tree));\n static void build_template_parm_names PROTO((tree, tree));\n static void build_underscore_int PROTO((int));\n \n@@ -388,8 +389,11 @@ build_overload_nested_name (decl)\n     {\n       tree context = DECL_CONTEXT (decl);\n       /* For a template type parameter, we want to output an 'Xn'\n-\t rather than 'T' or some such. */\n-      if (TREE_CODE (context) == TEMPLATE_TYPE_PARM)\n+\t rather than 'T' or some such.  For a template template \n+\t parameter, we also want an extra prefix 'z' and the\n+\t parameter list.  */\n+      if (TREE_CODE (context) == TEMPLATE_TYPE_PARM \n+\t  || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n \tbuild_overload_name (context, 0, 0);\n       else\n \t{\n@@ -661,6 +665,41 @@ build_overload_value (type, value, in_template)\n }\n \n \n+/* Add encodings for the declaration of template template parameters.\n+   PARMLIST must be a TREE_VEC */\n+\n+static void\n+build_template_template_parm_names (parmlist)\n+     tree parmlist;\n+{\n+  int i, nparms;\n+\n+  my_friendly_assert (TREE_CODE (parmlist) == TREE_VEC, 246.5);\n+  nparms = TREE_VEC_LENGTH (parmlist);\n+  icat (nparms);\n+  for (i = 0; i < nparms; i++)\n+    {\n+      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n+      if (TREE_CODE (parm) == TYPE_DECL)\n+\t{\n+\t  /* This parameter is a type.  */\n+\t  OB_PUTC ('Z');\n+\t}\n+      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n+\t{\n+\t  /* This parameter is a template. */\n+\t  OB_PUTC ('z');\n+\t  build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n+\t}\n+      else\n+\t{\n+\t  /* It's a PARM_DECL.  */\n+\t  build_overload_name (TREE_TYPE (parm), 0, 0);\n+\t}\n+    }\n+}\n+\n+\n /* Add encodings for the vector of template parameters in PARMLIST,\n    given the vector of arguments to be substituted in ARGLIST.  */\n \n@@ -683,6 +722,23 @@ build_template_parm_names (parmlist, arglist)\n \t  OB_PUTC ('Z');\n \t  build_overload_name (arg, 0, 0);\n \t}\n+      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n+\t{\n+\t  /* This parameter is a template. */\n+\t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t    /* Output parameter declaration, argument index and level */\n+\t    build_overload_name (arg, 0, 0);\n+\t  else\n+\t    {\n+\t      /* A TEMPLATE_DECL node, output the parameter declaration \n+\t\t and template name */\n+\n+\t      OB_PUTC ('z');\n+\t      build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n+\t      icat (IDENTIFIER_LENGTH (DECL_NAME (arg)));\n+\t      OB_PUTID (DECL_NAME (arg));\n+\t    }\n+\t}\n       else\n \t{\n \t  parm = tsubst (parm, arglist,\n@@ -1053,6 +1109,34 @@ build_overload_name (parmtypes, begin, end)\n \t  OB_PUTC ('v');\n \t  break;\n \n+\tcase TEMPLATE_TEMPLATE_PARM:\n+\t  /* Find and output the original template parameter \n+\t     declaration. */\n+\t  if (CLASSTYPE_TEMPLATE_INFO (parmtype))\n+\t    {\n+\t      OB_PUTC ('t');\n+\t      OB_PUTC ('z');\n+\t      OB_PUTC ('X');\n+\t      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+\t      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+\n+\t      build_template_parm_names (\n+\t\tDECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n+\t\tCLASSTYPE_TI_ARGS (parmtype));\n+\t    }\n+\t  else\n+\t    {\n+\t      OB_PUTC ('Z');\n+\t      OB_PUTC ('z');\n+\t      OB_PUTC ('X');\n+\t      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+\t      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+\n+\t      build_template_template_parm_names (\n+\t\tDECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n+\t    }\n+\t  break;\n+\n \tcase TEMPLATE_TYPE_PARM:\n \t  OB_PUTC ('X');\n \t  build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));"}, {"sha": "16a12a791c3c267ee65f3c75f365b469b4c07005", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4399, "deletions": 4343, "changes": 8742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473"}, {"sha": "754dbefc6aaf38bb5c67c89c4e6a7681e668a6fd", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -71,6 +71,12 @@ extern tree strip_attrs\t\tPROTO((tree));\n    error message if the user supplies an empty conditional expression.  */\n static char *cond_stmt_keyword;\n \n+/* If nonzero, we try to treat TEMPLATE_DECL as argument in template\n+   template parameter. */\n+static int processing_template_arg;\n+\n+extern int arg_looking_for_template;\n+\n static tree empty_parms PROTO((void));\n static tree finish_member_template_decl PROTO((tree, tree));\n \n@@ -222,7 +228,7 @@ finish_member_template_decl (template_arguments, decl)\n %type <code> unop\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n-%type <ttype> PFUNCNAME\n+%type <ttype> PFUNCNAME maybe_identifier\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> reserved_declspecs boolean.literal\n@@ -284,9 +290,10 @@ finish_member_template_decl (template_arguments, decl)\n %type <ttype> nonmomentary_expr maybe_parmlist\n %type <itype> initdcl0 notype_initdcl0 member_init_list\n %type <ttype> template_header template_parm_list template_parm\n-%type <ttype> template_type_parm\n+%type <ttype> template_type_parm template_template_parm\n %type <code>  template_close_bracket\n-%type <ttype> template_type template_arg_list template_arg_list_opt template_arg\n+%type <ttype> template_type template_arg_list template_arg_list_opt\n+%type <ttype> template_arg template_arg1\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> complete_type_name notype_identifier nonnested_type\n@@ -473,11 +480,16 @@ template_parm_list:\n \t\t{ $$ = process_template_parm ($1, $3); }\n \t;\n \n+maybe_identifier:\n+\t  identifier\n+\t  \t{ $$ = $1; }\n+\t|\t/* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\n template_type_parm:\n-\t  aggr\n+\t  aggr maybe_identifier\n \t\t{ \n-\t\t  $$ = build_tree_list ($1, NULL_TREE);\n-\t\t ttpa:\n+\t\t  $$ = build_tree_list ($1, $2);\n \t\t  if (TREE_PURPOSE ($$) == signature_type_node)\n \t\t    sorry (\"signature as template type parameter\");\n \t\t  else if (TREE_PURPOSE ($$) != class_type_node)\n@@ -486,14 +498,28 @@ template_type_parm:\n \t\t      TREE_PURPOSE ($$) = class_type_node;\n \t\t    }\n \t\t}\n-\t| aggr identifier\n-\t\t{ $$ = build_tree_list ($1, $2); goto ttpa; }\n-\t| TYPENAME_KEYWORD\n-\t\t{ $$ = build_tree_list (class_type_node, NULL_TREE); }\n-\t| TYPENAME_KEYWORD identifier\n+\t| TYPENAME_KEYWORD maybe_identifier\n \t\t{ $$ = build_tree_list (class_type_node, $2); }\n \t;\n \n+template_template_parm:\n+\t  template_header aggr maybe_identifier\n+\t\t{\n+\t\t  tree decl = build_decl (TYPE_DECL, $3, NULL_TREE);\n+\t\t  tree tmpl = build_lang_decl (TEMPLATE_DECL, $3, NULL_TREE);\n+\t\t  DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n+\t\t  DECL_TEMPLATE_RESULT (tmpl) = decl;\n+\t\t  SET_DECL_ARTIFICIAL (decl);\n+\t\t  end_template_decl ();\n+\n+\t\t  if ($2 == signature_type_node)\n+\t\t    sorry (\"signature as template template parameter\");\n+\t\t  else if ($2 != class_type_node)\n+\t\t    pedwarn (\"template template parameters must use the keyword `class'\");\n+\t\t  $$ = build_tree_list (class_type_node, tmpl);\n+\t\t}\n+\t;\n+\n template_parm:\n \t/* The following rules introduce a new reduce/reduce\n \t   conflict on the ',' and '>' input tokens: they are valid\n@@ -510,6 +536,21 @@ template_parm:\n \t\t{ $$ = build_tree_list (NULL_TREE, $1.t); }\n \t| parm '=' expr_no_commas  %prec ARITHCOMPARE\n \t\t{ $$ = build_tree_list ($3, $1.t); }\n+\t| template_template_parm\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| template_template_parm '=' PTYPENAME\n+\t  \t{\n+\t\t  tree defarg;\n+\t  \t  arg_looking_for_template = 1;\n+\t  \t  defarg = lookup_name ($3, 0);\n+\t  \t  arg_looking_for_template = 0;\n+\t\t\t\n+\t\t  if (!defarg || defarg == error_mark_node\n+\t\t      || (TREE_CODE (defarg) != TEMPLATE_DECL\n+\t\t\t  && TREE_CODE (defarg) != TEMPLATE_TEMPLATE_PARM))\n+\t\t    defarg = do_identifier ($3, 1);\n+\t\t  $$ = build_tree_list (defarg, $1);\n+\t  \t}\n \t;\n \n template_def:\n@@ -945,6 +986,12 @@ template_arg_list:\n \t;\n \n template_arg:\n+\t\t{ processing_template_arg = 1; }\n+\t  template_arg1\n+\t\t{ $$ = $2;\n+\t\t  processing_template_arg = 0; }\n+\n+template_arg1:\n \t  type_id\n \t\t{ $$ = groktypename ($1.t); }\n \t| expr_no_commas  %prec ARITHCOMPARE\n@@ -1360,7 +1407,21 @@ primary:\n \t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n \t\t  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)\n-\t\t    $$ = do_identifier ($$, 1);\n+\t\t    if (processing_template_arg)\n+\t\t      {\n+\t\t\ttree id;\n+\t\t\targ_looking_for_template = processing_template_arg;\n+\t\t\tid = lookup_name ($$, 0);\n+\t\t\targ_looking_for_template = 0;\n+\t\t\t\n+\t\t\tif (!id || id == error_mark_node\n+\t\t\t    || (TREE_CODE (id) != TEMPLATE_DECL\n+\t\t\t\t&& TREE_CODE (id) != TEMPLATE_TEMPLATE_PARM))\n+\t\t\t  id = do_identifier ($$, 1);\n+\t\t\t$$ = id;\n+\t\t      } \n+\t\t    else\n+\t\t      $$ = do_identifier ($$, 1);\n \t\t}\t\t\n \t| CONSTANT\n \t| boolean.literal\n@@ -3014,7 +3075,10 @@ nonnested_type:\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    {\n+\t\t      arg_looking_for_template = processing_template_arg;\n \t\t      $$ = lookup_name ($1, 1);\n+\t\t      arg_looking_for_template = 0;\n+\n \t\t      if (current_class_type\n \t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n \t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n@@ -4247,7 +4311,8 @@ bad_parm:\n \t\t{\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE ($$) == SCOPE_REF\n-\t\t      && TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM)\n+\t\t      && (TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM\n+\t\t\t  || TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TEMPLATE_PARM))\n \t\t    cp_error (\"  perhaps you want `typename %E' to make it a type\", $$);\n \t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}"}, {"sha": "4e631ca22566d1a261cb2a0e5bf9f7c0b1f537e6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 297, "deletions": 21, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -111,6 +111,7 @@ begin_member_template_processing (decl)\n       switch (TREE_CODE (parm))\n \t{\n \tcase TYPE_DECL:\n+\tcase TEMPLATE_DECL:\n \t  pushdecl (parm);\n \t  break;\n \n@@ -951,6 +952,8 @@ process_template_parm (list, next)\n \n       if (TREE_CODE (p) == TYPE_DECL)\n \tidx = TEMPLATE_TYPE_IDX (TREE_TYPE (p));\n+      else if (TREE_CODE (p) == TEMPLATE_DECL)\n+\tidx = TEMPLATE_TYPE_IDX (TREE_TYPE (DECL_TEMPLATE_RESULT (p)));\n       else\n \tidx = TEMPLATE_CONST_IDX (DECL_INITIAL (p));\n       ++idx;\n@@ -996,9 +999,26 @@ process_template_parm (list, next)\n     }\n   else\n     {\n-      tree t = make_lang_type (TEMPLATE_TYPE_PARM);\n+      tree t;\n+      parm = TREE_VALUE (parm);\n+      \n+      if (parm && TREE_CODE (parm) == TEMPLATE_DECL)\n+\t{\n+\t  t = make_lang_type (TEMPLATE_TEMPLATE_PARM);\n+\t  /* This is for distinguishing between real templates and template \n+\t     template parameters */\n+\t  TREE_TYPE (parm) = t;\n+\t  TREE_TYPE (DECL_TEMPLATE_RESULT (parm)) = t;\n+\t  decl = parm;\n+\t}\n+      else\n+\t{\n+\t  t = make_lang_type (TEMPLATE_TYPE_PARM);\n+\t  /* parm is either IDENTIFIER_NODE or NULL_TREE */\n+\t  decl = build_decl (TYPE_DECL, parm, t);\n+\t}\n+        \n       CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-      decl = build_decl (TYPE_DECL, TREE_VALUE (parm), t);\n       TYPE_NAME (t) = decl;\n       TYPE_STUB_DECL (t) = decl;\n       parm = decl;\n@@ -1077,7 +1097,8 @@ current_template_args ()\n \t    {\n \t      t = TREE_VALUE (t);\n \t      \n-\t      if (TREE_CODE (t) == TYPE_DECL)\n+\t      if (TREE_CODE (t) == TYPE_DECL \n+\t\t  || TREE_CODE (t) == TEMPLATE_DECL)\n \t\tt = TREE_TYPE (t);\n \t      else\n \t\tt = DECL_INITIAL (t);\n@@ -1637,6 +1658,7 @@ coerce_template_parms (parms, arglist, in_decl,\n      int require_all_arguments;\n {\n   int nparms, nargs, i, lost = 0;\n+  int is_tmpl_parm = 0;\n   tree vec = NULL_TREE;\n \n   if (arglist == NULL_TREE)\n@@ -1667,7 +1689,31 @@ coerce_template_parms (parms, arglist, in_decl,\n     }\n \n   if (arglist && TREE_CODE (arglist) == TREE_VEC)\n-    vec = copy_node (arglist);\n+    if (nargs == nparms)\n+      vec = copy_node (arglist);\n+    else\n+      {\n+\t/* We arrive here when a template with some default arguments\n+\t   is used as template template argument.  */\n+\tis_tmpl_parm = 1;\n+\tvec = make_tree_vec (nparms);\n+\tfor (i = 0; i < nparms; i++)\n+\t  {\n+\t    tree arg;\n+\n+\t    if (i < nargs)\n+\t      arg = TREE_VEC_ELT (arglist, i);\n+\t    else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n+\t\t     == TYPE_DECL)\n+\t      arg = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n+\t\t\t    vec, i, in_decl);\n+\t    else\n+\t      arg = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n+\t\t\t\t vec, i, in_decl);\n+\n+\t    TREE_VEC_ELT (vec, i) = arg;\n+\t  }\n+      }\n   else\n     {\n       vec = make_tree_vec (nparms);\n@@ -1705,7 +1751,7 @@ coerce_template_parms (parms, arglist, in_decl,\n       tree arg = TREE_VEC_ELT (vec, i);\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n       tree val = 0;\n-      int is_type, requires_type;\n+      int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n \n       if (arg == NULL_TREE)\n \t/* We're out of arguments.  */\n@@ -1721,8 +1767,29 @@ coerce_template_parms (parms, arglist, in_decl,\n \t  continue;\n \t}\n \n-      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n-      requires_type = TREE_CODE (parm) == TYPE_DECL;\n+      /* In case we are checking arguments inside a template template\n+\t parameter, ARG that does not come from default argument is \n+\t also a TREE_LIST node */\n+      if (TREE_CODE (arg) == TREE_LIST)\n+\t{\n+          is_tmpl_parm = 1;\n+\t  arg = TREE_VALUE (arg);\n+\t}\n+\n+      /* Check if it is a class template.  */\n+      is_tmpl_type = (TREE_CODE (arg) == TEMPLATE_DECL\n+\t\t      && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n+\t\t     || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+\t\t\t && !CLASSTYPE_TEMPLATE_INFO (arg));\n+      if (is_tmpl_type && TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\targ = TYPE_STUB_DECL (arg);\n+      \n+      requires_tmpl_type = TREE_CODE (parm) == TEMPLATE_DECL;\n+      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n+\t\t|| is_tmpl_type\n+\t\t|| (is_tmpl_parm && TREE_CODE (arg) == TYPE_DECL);\n+      requires_type = TREE_CODE (parm) == TYPE_DECL\n+\t\t      || requires_tmpl_type;\n \n       if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n \t  && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n@@ -1744,7 +1811,8 @@ coerce_template_parms (parms, arglist, in_decl,\n \t\t\t    i + 1, in_decl);\n \t\t  if (is_type)\n \t\t    cp_error (\"  expected a constant of type `%T', got `%T'\",\n-\t\t\t      TREE_TYPE (parm), arg);\n+\t\t\t      TREE_TYPE (parm),\n+\t\t\t      (is_tmpl_type ? DECL_NAME (arg) : arg));\n \t\t  else\n \t\t    cp_error (\"  expected a type, got `%E'\", arg);\n \t\t}\n@@ -1753,18 +1821,71 @@ coerce_template_parms (parms, arglist, in_decl,\n \t  TREE_VEC_ELT (vec, i) = error_mark_node;\n \t  continue;\n \t}\n+      if (is_tmpl_type ^ requires_tmpl_type)\n+\t{\n+\t  if (in_decl)\n+\t    {\n+\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t\ti, in_decl);\n+\t      if (is_tmpl_type)\n+\t\tcp_error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n+\t      else\n+\t\tcp_error (\"  expected a class template, got `%T'\", arg);\n+\t    }\n+\t  lost++;\n+\t  TREE_VEC_ELT (vec, i) = error_mark_node;\n+\t  continue;\n+\t}\n+      if (is_tmpl_parm)\n+\t{\n+\t  if (requires_tmpl_type)\n+\t    {\n+\t      cp_error (\"nested template template parameter not implemented\");\n+\t      lost++;\n+\t      TREE_VEC_ELT (vec, i) = error_mark_node;\n+\t    }\n+\t  continue;\n+\t}\n+        \n       if (is_type)\n \t{\n-\t  val = groktypename (arg);\n-\t  if (! processing_template_decl)\n+\t  if (requires_tmpl_type)\n+\t    {\n+\t      tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n+\t      tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n+\n+\t      /* The parameter and argument roles have to be switched \n+\t\t here in order to handle default arguments properly.  \n+\t\t For example, \n+\t\t   template<template <class> class TT> void f(TT<int>) \n+\t\t should be able to accept vector<int> which comes from \n+\t\t   template <class T, class Allcator = allocator> \n+\t\t   class vector.  */\n+\n+\t      val = coerce_template_parms (argparm, parmparm, in_decl, 1, 1);\n+\t      if (val != error_mark_node)\n+\t\tval = arg;\n+\t\t    \n+\t      /* TEMPLATE_TEMPLATE_PARM node is preferred over \n+\t\t TEMPLATE_DECL.  */\n+\t      if (val != error_mark_node \n+\t\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n+\t\tval = TREE_TYPE (val);\n+\t    }\n+\t  else\n \t    {\n-\t      tree t = target_type (val);\n-\t      if (TREE_CODE (t) != TYPENAME_TYPE \n-\t\t  && IS_AGGR_TYPE (t)\n-\t\t  && decl_function_context (TYPE_MAIN_DECL (t)))\n+\t      val = groktypename (arg);\n+\t      if (! processing_template_decl)\n \t\t{\n-\t\t  cp_error (\"type `%T' composed from a local class is not a valid template-argument\", val);\n-\t\t  return error_mark_node;\n+\t\t  tree t = target_type (val);\n+\t\t  if (TREE_CODE (t) != TYPENAME_TYPE \n+\t\t      && IS_AGGR_TYPE (t)\n+\t\t      && decl_function_context (TYPE_MAIN_DECL (t)))\n+\t\t    {\n+\t\t      cp_error (\"type `%T' composed from a local class is not a valid template-argument\",\n+\t\t\t\tval);\n+\t\t      return error_mark_node;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -1899,6 +2020,17 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n \t  cat (type_as_string (arg, 0));\n \t  continue;\n \t}\n+      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n+\t{\n+\t  if (TREE_CODE (arg) == TEMPLATE_DECL)\n+\t    /* Already substituted with real template.  Just output \n+\t       the template name here */\n+\t    cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n+\t  else\n+\t    /* Output the parameter declaration */\n+\t    cat (type_as_string (arg, 0));\n+\t  continue;\n+\t}\n       else\n \tmy_friendly_assert (TREE_CODE (parm) == PARM_DECL, 269);\n \n@@ -2029,9 +2161,15 @@ lookup_template_class (d1, arglist, in_decl, function_context)\n \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n-      template = IDENTIFIER_GLOBAL_VALUE (d1); /* XXX */\n-      if (! template)\n-\ttemplate = IDENTIFIER_CLASS_VALUE (d1);\n+      if (IDENTIFIER_LOCAL_VALUE (d1) \n+\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (IDENTIFIER_LOCAL_VALUE (d1)))\n+\ttemplate = IDENTIFIER_LOCAL_VALUE (d1);\n+      else\n+\t{\n+\t  template = IDENTIFIER_GLOBAL_VALUE (d1); /* XXX */\n+\t  if (! template)\n+\t    template = IDENTIFIER_CLASS_VALUE (d1);\n+\t}\n     }\n   else if (TREE_CODE (d1) == TYPE_DECL && IS_AGGR_TYPE (TREE_TYPE (d1)))\n     {\n@@ -2060,7 +2198,29 @@ lookup_template_class (d1, arglist, in_decl, function_context)\n       return error_mark_node;\n     }\n \n-  if (PRIMARY_TEMPLATE_P (template))\n+  if (DECL_TEMPLATE_TEMPLATE_PARM_P (template))\n+    {\n+      /* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store\n+         template arguments */\n+\n+      tree parm = copy_template_template_parm (TREE_TYPE (template));\n+      tree template2 = TYPE_STUB_DECL (parm);\n+      tree arglist2;\n+\n+      CLASSTYPE_GOT_SEMICOLON (parm) = 1;\n+      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n+\n+      arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1);\n+      if (arglist2 == error_mark_node)\n+\treturn error_mark_node;\n+\n+      arglist2 = copy_to_permanent (arglist2);\n+      CLASSTYPE_TEMPLATE_INFO (parm)\n+\t= perm_tree_cons (template2, arglist2, NULL_TREE);\n+      TYPE_SIZE (parm) = 0;\n+      return parm;\n+    }\n+  else if (PRIMARY_TEMPLATE_P (template))\n     {\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n@@ -2244,6 +2404,15 @@ uses_template_parms (t)\n     case TYPE_DECL:\n       return uses_template_parms (TREE_TYPE (t));\n \n+    case TEMPLATE_DECL:\n+      /* A template template parameter is encountered */\n+      if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n+        /* We are parsing a template declaration */\n+        return 1;\n+      /* We are instantiating templates with template template\n+         parameter */\n+      return 0;\n+      \n     case FUNCTION_DECL:\n     case VAR_DECL:\n       /* ??? What about FIELD_DECLs?  */\n@@ -2266,6 +2435,7 @@ uses_template_parms (t)\n \n       /* template parm nodes */\n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_CONST_PARM:\n       return 1;\n \n@@ -2864,12 +3034,14 @@ tsubst (t, args, nargs, in_decl)\n       }\n \n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_CONST_PARM:\n       {\n \tint idx;\n \tint level;\n \n-\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \t  {\n \t    idx = TEMPLATE_TYPE_IDX (t);\n \t    level = TEMPLATE_TYPE_LEVEL (t);\n@@ -2899,6 +3071,34 @@ tsubst (t, args, nargs, in_decl)\n \t\t  return cp_build_type_variant\n \t\t    (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n \t\t     TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+\t\t  {\n+\t\t    if (CLASSTYPE_TEMPLATE_INFO (t))\n+\t\t      {\n+\t\t\t/* We are processing a type constructed from\n+\t\t\t   a template template parameter */\n+\t\t\ttree argvec = tsubst (\n+\t\t\t\t\tTREE_VALUE (CLASSTYPE_TEMPLATE_INFO (t)), \n+\t\t\t\t\targs, nargs, in_decl);\n+\t\t\ttree r;\n+\n+\t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n+\t\t\t   we are resolving nested-types in the signature of \n+\t\t\t   a member function templates.\n+\t\t\t   Otherwise ARG is a TEMPLATE_DECL and is the real \n+\t\t\t   template to be instantiated.  */\n+\t\t\tif (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t\t\t  arg = TYPE_NAME (arg);\n+\n+\t\t\tr = lookup_template_class (DECL_NAME (arg), \n+\t\t\t\t\t\t   argvec, in_decl, NULL_TREE);\n+\t\t\treturn cp_build_type_variant (r, TYPE_READONLY (t),\n+\t\t\t\t\t\t      TYPE_VOLATILE (t));\n+\t\t      }\n+\t\t    else\n+\t\t      /* We are processing a template argument list.  */ \n+\t\t      return arg;\n+\t\t  }\n \t\telse\n \t\t  return arg;\n \t      }\n@@ -2909,6 +3109,8 @@ tsubst (t, args, nargs, in_decl)\n \tmy_friendly_assert((TREE_CODE (t) == TEMPLATE_CONST_PARM \n \t\t\t    && TEMPLATE_CONST_LEVEL (t) > 1) \n \t\t\t   || (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t\t\t       && TEMPLATE_TYPE_LEVEL (t) > 1)\n+\t\t\t   || (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n \t\t\t       && TEMPLATE_TYPE_LEVEL (t) > 1),\n \t\t\t   0);\n \treturn t;\n@@ -3903,6 +4105,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case ENUMERAL_TYPE:\n     case INTEGER_TYPE:\n     case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_CONST_PARM:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -4641,6 +4844,79 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \treturn 1;\n       targs[idx] = arg;\n       return 0;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+      (*nsubsts)++;\n+      idx = TEMPLATE_TYPE_IDX (parm);\n+      /* Check for mixed types and values.  */\n+      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TEMPLATE_DECL)\n+\treturn 1;\n+\n+      if (!strict && targs[idx] != NULL_TREE && \n+\t  TREE_CODE (targs[idx]) == NOP_EXPR)\n+\t/* An explicit template argument.  Don't even try to match\n+\t   here; the overload resolution code will manage check to\n+\t   see whether the call is legal.  */ \n+\treturn 0;\n+\n+      if (CLASSTYPE_TEMPLATE_INFO (parm))\n+\t{\n+\t  /* We arrive here when PARM does not involve template \n+\t     specialization.  */\n+\n+\t  /* ARG must be constructed from a template class.  */\n+\t  if (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg))\n+\t    return 1;\n+\n+\t  {\n+\t    tree parmtmpl = CLASSTYPE_TI_TEMPLATE (parm);\n+\t    tree parmvec = CLASSTYPE_TI_ARGS (parm);\n+\t    tree argvec = CLASSTYPE_TI_ARGS (arg);\n+\t    tree argtmplvec\n+\t      = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n+\t    int i, j;\n+\n+\t    /* The parameter and argument roles have to be switched here \n+\t       in order to handle default arguments properly.  For example, \n+\t\t template<template <class> class TT> void f(TT<int>) \n+\t       should be able to accept vector<int> which comes from \n+\t\t template <class T, class Allcator = allocator> \n+\t\t   class vector.  */\n+\n+\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1)\n+\t\t== error_mark_node)\n+\t      return 1;\n+\t  \n+\t    /* Deduce arguments T, i from TT<T> or TT<i>.  */\n+\t    for (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n+\t      {\n+\t\ttree t = TREE_VEC_ELT (parmvec, i);\n+\t\tif (TREE_CODE (t) != TEMPLATE_TYPE_PARM\n+\t\t    && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n+\t\t    && TREE_CODE (t) != TEMPLATE_CONST_PARM)\n+\t\t  continue;\n+\n+\t\t/* This argument can be deduced.  */\n+\n+\t\tif (unify (tparms, targs, ntparms, t, \n+\t\t\t   TREE_VEC_ELT (argvec, i), nsubsts, strict))\n+\t\t  return 1;\n+\t      }\n+\t  }\n+\t  arg = CLASSTYPE_TI_TEMPLATE (arg);\n+\t}\n+\n+      /* Simple cases: Value already set, does match or doesn't.  */\n+      if (targs[idx] == arg \n+\t  || (targs[idx] \n+\t      && TREE_CODE (targs[idx]) == NOP_EXPR \n+\t      && TREE_OPERAND (targs[idx], 0) == arg))\n+\treturn 0;\n+      else if (targs[idx])\n+\treturn 1;\n+      targs[idx] = arg;\n+      return 0;\n+\n     case TEMPLATE_CONST_PARM:\n       (*nsubsts)++;\n       idx = TEMPLATE_CONST_IDX (parm);"}, {"sha": "7e1fb49618d74d8628ceabdb707f453c7be43b67", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -2471,7 +2471,8 @@ dfs_walk (binfo, fn, qfn)\n \n       if (qfn == 0 || (*qfn)(base_binfo))\n \t{\n-\t  if (TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TYPE_PARM)\n+\t  if (TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TYPE_PARM\n+\t      || TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TEMPLATE_PARM)\n \t    /* Pass */;\n \t  else if (fn == dfs_init_vbase_pointers)\n \t    {\n@@ -3134,7 +3135,8 @@ dfs_record_inheritance (binfo)\n       tree baseclass = BINFO_TYPE (base_binfo);\n       mi_boolean *base_row = BINFO_DERIVES_FROM_STAR (base_binfo);\n \n-      if (TREE_CODE (baseclass) == TEMPLATE_TYPE_PARM)\n+      if (TREE_CODE (baseclass) == TEMPLATE_TYPE_PARM\n+          || TREE_CODE (baseclass) == TEMPLATE_TEMPLATE_PARM)\n \tcontinue;\n       my_friendly_assert (CLASSTYPE_CID (baseclass) != 0, 2365);\n "}, {"sha": "04c71f659bc2ad3838de7ec54f98fa66da05d63c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -1438,6 +1438,27 @@ build_exception_variant (type, raises)\n   return v;\n }\n \n+/* Given a TEMPLATE_TEMPLATE_PARM node T, create a new one together with its \n+   lang_specific field and its corresponding TEMPLATE_DECL node */\n+\n+tree\n+copy_template_template_parm (t)\n+     tree t;\n+{\n+  tree template = TYPE_NAME (t);\n+  tree t2 = make_lang_type (TEMPLATE_TEMPLATE_PARM);\n+  template = copy_node (template);\n+  copy_lang_decl (template);\n+  TREE_TYPE (template) = t2;\n+  TYPE_NAME (t2) = template;\n+  TYPE_STUB_DECL (t2) = template;\n+\n+  /* No need to copy these */\n+  TYPE_FIELDS (t2) = TYPE_FIELDS (t);\n+  CLASSTYPE_TEMPLATE_INFO (t2) = CLASSTYPE_TEMPLATE_INFO (t);\n+  return t2;\n+}\n+\n /* Subroutine of copy_to_permanent\n \n    Assuming T is a node build bottom-up, make it all exist on\n@@ -1629,6 +1650,9 @@ mapcar (t, func)\n       CONSTRUCTOR_ELTS (t) = mapcar (CONSTRUCTOR_ELTS (t), func);\n       return t;\n \n+    case TEMPLATE_TEMPLATE_PARM:\n+      return copy_template_template_parm (t);\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type"}, {"sha": "8be397f33cfe44f83e600c7649543e2ebafa656d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b0fce8fd7d5b9e166a6f283cf73215f9873473/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=73b0fce8fd7d5b9e166a6f283cf73215f9873473", "patch": "@@ -836,6 +836,37 @@ comptypes (type1, type2, strict)\n       val = comp_array_types (comptypes, t1, t2, strict);\n       break;\n \n+    case TEMPLATE_TEMPLATE_PARM:\n+      if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n+\t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n+\treturn 0;\n+\n+      if (CLASSTYPE_TEMPLATE_INFO (t1) && CLASSTYPE_TEMPLATE_INFO (t2))\n+\t{\n+\t  int i = TREE_VEC_LENGTH (CLASSTYPE_TI_ARGS (t1));\n+\t  tree *p1 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t1), 0);\n+\t  tree *p2 = &TREE_VEC_ELT (CLASSTYPE_TI_ARGS (t2), 0);\n+\t\n+\t  while (i--)\n+\t    {\n+\t      if (TREE_CODE_CLASS (TREE_CODE (p1[i])) == 't')\n+\t\t{\n+\t\t  if (! comptypes (p1[i], p2[i], 1))\n+\t\t    return 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (simple_cst_equal (p1[i], p2[i]) <= 0)\n+\t\t    return 0;\n+\t\t}\n+\t    }\n+\t  return 1;\n+\t}\n+      else if (CLASSTYPE_TEMPLATE_INFO (t1) || CLASSTYPE_TEMPLATE_INFO (t2))\n+\treturn 0;\n+      else\n+\treturn 1;\n+\n     case TEMPLATE_TYPE_PARM:\n       return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n \t&& TEMPLATE_TYPE_LEVEL (t1) == TEMPLATE_TYPE_LEVEL (t2);"}]}