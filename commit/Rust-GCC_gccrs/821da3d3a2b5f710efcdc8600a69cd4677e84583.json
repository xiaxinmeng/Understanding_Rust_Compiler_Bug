{"sha": "821da3d3a2b5f710efcdc8600a69cd4677e84583", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIxZGEzZDNhMmI1ZjcxMGVmY2RjODYwMGE2OWNkNDY3N2U4NDU4Mw==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-06-13T20:14:17Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:16Z"}, "message": "Refactor type resolution scoping to use a simple class akin to backend code", "tree": {"sha": "eccddc81a4f9a80b7bfc80f70d528e7f4de2f51e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eccddc81a4f9a80b7bfc80f70d528e7f4de2f51e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/821da3d3a2b5f710efcdc8600a69cd4677e84583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821da3d3a2b5f710efcdc8600a69cd4677e84583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821da3d3a2b5f710efcdc8600a69cd4677e84583", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821da3d3a2b5f710efcdc8600a69cd4677e84583/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15280699c13f799f25bfc95656415c0ec2c1b901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15280699c13f799f25bfc95656415c0ec2c1b901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15280699c13f799f25bfc95656415c0ec2c1b901"}], "stats": {"total": 214, "additions": 159, "deletions": 55}, "files": [{"sha": "9d59d7c10d0bc817450f1efc61b3b869ce84275b", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=821da3d3a2b5f710efcdc8600a69cd4677e84583", "patch": "@@ -12,7 +12,7 @@\n       segs.push_back (::std::move (typePath));                                 \\\n       auto bType = new AST::TypePath (::std::move (segs),                      \\\n \t\t\t\t      Linemap::unknown_location (), false);    \\\n-      _S.Insert (_X, bType);                                                   \\\n+      _S.InsertType (_X, bType);                                               \\\n     }                                                                          \\\n   while (0)\n \n@@ -22,28 +22,35 @@ namespace Analysis {\n TypeResolution::TypeResolution (AST::Crate &crate, TopLevelScan &toplevel)\n   : Resolution (crate, toplevel)\n {\n-  functionScope.Push ();\n+  scope.Push ();\n \n   // push all builtin types - this is probably too basic for future needs\n-  ADD_BUILTIN_TYPE (\"u8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"i8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"f32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"f64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"char\", typeScope);\n-  ADD_BUILTIN_TYPE (\"str\", typeScope);\n-  ADD_BUILTIN_TYPE (\"bool\", typeScope);\n+  ADD_BUILTIN_TYPE (\"u8\", scope);\n+  ADD_BUILTIN_TYPE (\"u16\", scope);\n+  ADD_BUILTIN_TYPE (\"u32\", scope);\n+  ADD_BUILTIN_TYPE (\"u64\", scope);\n+\n+  ADD_BUILTIN_TYPE (\"i8\", scope);\n+  ADD_BUILTIN_TYPE (\"i16\", scope);\n+  ADD_BUILTIN_TYPE (\"i32\", scope);\n+  ADD_BUILTIN_TYPE (\"i64\", scope);\n+\n+  ADD_BUILTIN_TYPE (\"f32\", scope);\n+  ADD_BUILTIN_TYPE (\"f64\", scope);\n+\n+  ADD_BUILTIN_TYPE (\"char\", scope);\n+  ADD_BUILTIN_TYPE (\"str\", scope);\n+  ADD_BUILTIN_TYPE (\"bool\", scope);\n+\n+  // now its the crate scope\n+  scope.Push ();\n }\n \n-TypeResolution::~TypeResolution () { functionScope.Pop (); }\n+TypeResolution::~TypeResolution ()\n+{\n+  scope.Pop (); // crate\n+  scope.Pop (); // builtins\n+}\n \n bool\n TypeResolution::Resolve (AST::Crate &crate, TopLevelScan &toplevel)\n@@ -96,13 +103,7 @@ TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n     }\n \n   AST::Type *val = NULL;\n-  if (!typeScope.Lookup (lhsTypeStr, &val))\n-    {\n-      rust_error_at (locus, \"unknown type\");\n-      return false;\n-    }\n-\n-  return true;\n+  return scope.LookupType (lhsTypeStr, &val);\n }\n \n bool\n@@ -121,13 +122,7 @@ TypeResolution::isTypeInScope (AST::Type *type, Location locus)\n   typeComparisonBuffer.pop_back ();\n \n   AST::Type *val = NULL;\n-  if (!typeScope.Lookup (t, &val))\n-    {\n-      rust_error_at (locus, \"unknown type\");\n-      return false;\n-    }\n-\n-  return true;\n+  return scope.LookupType (t, &val);\n }\n \n AST::Function *\n@@ -162,7 +157,7 @@ void\n TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n {\n   AST::Type *type = NULL;\n-  bool ok = scope.Lookup (ident_expr.ident, &type);\n+  bool ok = scope.LookupType (ident_expr.ident, &type);\n   if (!ok)\n     {\n       rust_error_at (ident_expr.locus, \"unknown identifier\");\n@@ -190,7 +185,7 @@ TypeResolution::visit (AST::PathInExpression &path)\n {\n   // look up in the functionScope else lookup in the toplevel scan\n   AST::Function *fndecl = NULL;\n-  if (functionScope.Lookup (path.as_string (), &fndecl))\n+  if (scope.LookupFunction (path.as_string (), &fndecl))\n     {\n       functionLookup.push_back (fndecl);\n       return;\n@@ -282,7 +277,7 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n     }\n \n   AST::Type *val = NULL;\n-  bool ok = typeScope.Lookup (type, &val);\n+  bool ok = scope.LookupType (type, &val);\n   if (ok)\n     typeBuffer.push_back (val);\n   else\n@@ -516,9 +511,18 @@ TypeResolution::visit (AST::FieldAccessExpr &expr)\n void\n TypeResolution::visit (AST::ClosureExprInner &expr)\n {}\n+\n void\n TypeResolution::visit (AST::BlockExpr &expr)\n-{}\n+{\n+  scope.Push ();\n+  for (auto &stmt : expr.statements)\n+    {\n+      stmt->accept_vis (*this);\n+    }\n+  scope.Pop ();\n+}\n+\n void\n TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n {}\n@@ -564,15 +568,27 @@ TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n void\n TypeResolution::visit (AST::ForLoopExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::IfExpr &expr)\n-{}\n+{\n+  expr.vis_if_block (*this);\n+}\n+\n void\n TypeResolution::visit (AST::IfExprConseqElse &expr)\n-{}\n+{\n+  expr.vis_if_block (*this);\n+  expr.vis_else_block (*this);\n+}\n+\n void\n TypeResolution::visit (AST::IfExprConseqIf &expr)\n-{}\n+{\n+  expr.vis_if_block (*this);\n+  expr.vis_conseq_if_expr (*this);\n+}\n+\n void\n TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n {}\n@@ -647,11 +663,10 @@ TypeResolution::visit (AST::Function &function)\n {\n   // always emit the function with return type in the event of nil return type\n   // its  a marker for a void function\n-  scope.Insert (function.function_name, function.return_type.get ());\n-  functionScope.Insert (function.function_name, &function);\n-\n-  functionScope.Push ();\n+  scope.InsertType (function.function_name, function.return_type.get ());\n+  scope.InsertFunction (function.function_name, &function);\n   scope.Push ();\n+\n   for (auto &param : function.function_params)\n     {\n       if (!isTypeInScope (param.type.get (), param.locus))\n@@ -667,7 +682,7 @@ TypeResolution::visit (AST::Function &function)\n \n       auto paramName = letPatternBuffer.back ();\n       letPatternBuffer.pop_back ();\n-      scope.Insert (paramName.variable_ident, param.type.get ());\n+      scope.InsertType (paramName.variable_ident, param.type.get ());\n     }\n \n   // ensure the return type is resolved\n@@ -683,8 +698,11 @@ TypeResolution::visit (AST::Function &function)\n       stmt->accept_vis (*this);\n     }\n \n+  auto localMap = scope.PeekLocals ();\n+  for (auto &[_, value] : localMap)\n+    function.locals.push_back (value);\n+\n   scope.Pop ();\n-  functionScope.Pop ();\n }\n \n void\n@@ -705,7 +723,7 @@ TypeResolution::visit (AST::StructStruct &struct_item)\n \t}\n     }\n \n-  structsPerBlock.Insert (struct_item.struct_name, &struct_item);\n+  scope.InsertStruct (struct_item.struct_name, &struct_item);\n }\n \n void\n@@ -886,6 +904,7 @@ TypeResolution::visit (AST::EmptyStmt &stmt)\n void\n TypeResolution::visit (AST::LetStmt &stmt)\n {\n+  scope.InsertLocal (stmt.as_string (), &stmt);\n   if (!stmt.has_init_expr () && !stmt.has_type ())\n     {\n       rust_error_at (stmt.locus,\n@@ -942,10 +961,9 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \n   // get all the names part of this declaration and add the types to the scope\n   stmt.variables_pattern->accept_vis (*this);\n-  for (auto it = letPatternBuffer.begin (); it != letPatternBuffer.end (); it++)\n-    {\n-      scope.Insert (it->variable_ident, inferedType);\n-    }\n+  for (auto &pattern : letPatternBuffer)\n+    scope.InsertType (pattern.variable_ident, inferedType);\n+\n   letPatternBuffer.clear ();\n }\n \n@@ -957,7 +975,16 @@ TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n \n void\n TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n+{\n+  scope.Push ();\n+  stmt.expr->accept_vis (*this);\n+  auto localMap = scope.PeekLocals ();\n+  for (auto &[_, value] : localMap)\n+    {\n+      stmt.locals.push_back (value);\n+    }\n+  scope.Pop ();\n+}\n \n // rust-type.h\n void"}, {"sha": "fede04f206113f57cd0a5a9aa5c9dac61f2aff1c", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=821da3d3a2b5f710efcdc8600a69cd4677e84583", "patch": "@@ -5,8 +5,85 @@\n namespace Rust {\n namespace Analysis {\n \n+class TypeScoping\n+{\n+public:\n+  TypeScoping () {}\n+\n+  ~TypeScoping () {}\n+\n+  void Push ()\n+  {\n+    functionScope.Push ();\n+    localsPerBlock.Push ();\n+    structsPerBlock.Push ();\n+    typeScope.Push ();\n+  }\n+\n+  void Pop ()\n+  {\n+    functionScope.Pop ();\n+    localsPerBlock.Pop ();\n+    structsPerBlock.Pop ();\n+    typeScope.Pop ();\n+  }\n+\n+  void InsertFunction (std::string ident, AST::Function *fn)\n+  {\n+    functionScope.Insert (ident, fn);\n+  }\n+\n+  bool LookupFunction (std::string ident, AST::Function **fn)\n+  {\n+    return functionScope.Lookup (ident, fn);\n+  }\n+\n+  void InsertLocal (std::string ident, AST::LetStmt *let)\n+  {\n+    localsPerBlock.Insert (ident, let);\n+  }\n+\n+  bool LookupLocal (std::string ident, AST::LetStmt **let)\n+  {\n+    return localsPerBlock.Lookup (ident, let);\n+  }\n+\n+  std ::map<std::string, AST::LetStmt *> PeekLocals ()\n+  {\n+    return localsPerBlock.Peek ();\n+  }\n+\n+  void InsertStruct (std::string ident, AST::StructStruct *s)\n+  {\n+    structsPerBlock.Insert (ident, s);\n+  }\n+\n+  bool LookupStruct (std::string ident, AST::StructStruct **s)\n+  {\n+    return structsPerBlock.Lookup (ident, s);\n+  }\n+\n+  void InsertType (std::string ident, AST::Type *s)\n+  {\n+    typeScope.Insert (ident, s);\n+  }\n+\n+  bool LookupType (std::string ident, AST::Type **s)\n+  {\n+    return typeScope.Lookup (ident, s);\n+  }\n+\n+private:\n+  Scope<AST::Function *> functionScope;\n+  Scope<AST::LetStmt *> localsPerBlock;\n+  Scope<AST::StructStruct *> structsPerBlock;\n+  Scope<AST::Type *> typeScope;\n+};\n+\n class TypeResolution : public Resolution\n {\n+  friend class TypeScoping;\n+\n public:\n   ~TypeResolution ();\n   static bool Resolve (AST::Crate &crate, TopLevelScan &toplevel);\n@@ -223,9 +300,7 @@ class TypeResolution : public Resolution\n   AST::Function *lookupFndecl (AST::Expr *expr);\n   bool isTypeInScope (AST::Type *type, Location locus);\n \n-  Scope<AST::Function *> functionScope;\n-  Scope<AST::LetStmt *> localsPerBlock;\n-  Scope<AST::StructStruct *> structsPerBlock;\n+  TypeScoping scope;\n };\n \n } // namespace Analysis"}, {"sha": "41bcee61737b5ea5b56eec982c4d8106a61c82a1", "filename": "gcc/rust/analysis/scope.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/821da3d3a2b5f710efcdc8600a69cd4677e84583/gcc%2Frust%2Fanalysis%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Fscope.h?ref=821da3d3a2b5f710efcdc8600a69cd4677e84583", "patch": "@@ -47,6 +47,8 @@ template <class T> class Scope\n     return toplevel;\n   }\n \n+  std ::map<std::string, T> Peek () { return scopeStack.back (); }\n+\n private:\n   std::vector<std::map<std::string, T> > scopeStack;\n };"}]}