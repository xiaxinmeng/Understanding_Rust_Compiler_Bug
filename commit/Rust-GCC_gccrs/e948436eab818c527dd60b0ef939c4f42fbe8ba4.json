{"sha": "e948436eab818c527dd60b0ef939c4f42fbe8ba4", "node_id": "C_kwDOANBUbNoAKGU5NDg0MzZlYWI4MThjNTI3ZGQ2MGIwZWY5MzljNGY0MmZiZThiYTQ", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-01T21:00:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-07T00:23:16Z"}, "message": "c++: loop over array elts w/o explicit init [PR92385]\n\nThe PR complains that initializing a large array with {} takes a long time\nto compile; this was because digest_init would turn {} into a long\nCONSTRUCTOR with an initializer for each element, instead of more sensibly\ngenerating a loop.  The standard doesn't specify this implementation, but it\ndoes allow for it by specifying that a temporary created \"when a default\nconstructor is called to initialize an element of an array with no\ncorresponding initializer\" is destroyed \"before the construction of the next\narray element, if any.\" rather than living until the end of the complete\nobject initialization as usual.\n\nThis change is also needed before the PR94041 fix extends the lifetime of\ntemporaries from elements with explicit initializers.\n\nTo implement this, I change digest_init so that in cases where\ninitialization of trailing array elements isn't constant, we return a\nVEC_INIT_EXPR instead of a bare CONSTRUCTOR; when it is encountered later,\nwe call build_vec_init to generate the actual initialization code.\n\n\tPR c++/92385\n\ngcc/cp/ChangeLog:\n\n\t* typeck2.c (PICFLAG_VEC_INIT): New.\n\t(process_init_constructor_array): Set it.\n\t(process_init_constructor): Handle it.\n\t(split_nonconstant_init_1): Handle VEC_INIT_EXPR.\n\t* init.c (build_vec_init): Likewise.\n\t* cp-gimplify.c (cp_gimplify_expr): Factor out...\n\t* tree.c (expand_vec_init_expr): ...this function.\n\t(build_vec_init_elt): Handle BRACE_ENCLOSED_INITIALIZER_P.\n\t(build_vec_init_expr): Likewise.\n\t* constexpr.c (cxx_eval_vec_init): Likewise.\n\t(reduced_constant_expression_p): Check arrays before C++20.\n\t* cp-tree.h (expand_vec_init_expr): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/init/array61.C: New test.", "tree": {"sha": "71b7313390be11341e0c975d27076d8387b9c39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b7313390be11341e0c975d27076d8387b9c39c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e948436eab818c527dd60b0ef939c4f42fbe8ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e948436eab818c527dd60b0ef939c4f42fbe8ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e948436eab818c527dd60b0ef939c4f42fbe8ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e948436eab818c527dd60b0ef939c4f42fbe8ba4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad64a821970ef5547d77ece22d302b0e599ae0d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad64a821970ef5547d77ece22d302b0e599ae0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad64a821970ef5547d77ece22d302b0e599ae0d2"}], "stats": {"total": 143, "additions": 112, "deletions": 31}, "files": [{"sha": "4a4b347c31d86ebfe485da16a5758c22cf3e6bd7", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -3020,8 +3020,7 @@ reduced_constant_expression_p (tree t)\n \t  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n \t    /* An initialized vector would have a VECTOR_CST.  */\n \t    return false;\n-\t  else if (cxx_dialect >= cxx20\n-\t\t   && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t    {\n \t      /* There must be a valid constant initializer at every array\n \t\t index.  */\n@@ -4955,8 +4954,36 @@ cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n {\n   tree atype = TREE_TYPE (t);\n   tree init = VEC_INIT_EXPR_INIT (t);\n-  tree r = cxx_eval_vec_init_1 (ctx, atype, init,\n-\t\t\t\tVEC_INIT_EXPR_VALUE_INIT (t),\n+  bool value_init = VEC_INIT_EXPR_VALUE_INIT (t);\n+  if (!init || !BRACE_ENCLOSED_INITIALIZER_P (init))\n+    ;\n+  else if (CONSTRUCTOR_NELTS (init) == 0)\n+    {\n+      /* Handle {} as value-init.  */\n+      init = NULL_TREE;\n+      value_init = true;\n+    }\n+  else\n+    {\n+      /* This is a more complicated case, like needing to loop over trailing\n+\t elements; call build_vec_init and evaluate the result.  */\n+      tsubst_flags_t complain = ctx->quiet ? tf_none : tf_warning_or_error;\n+      constexpr_ctx new_ctx = *ctx;\n+      if (!ctx->object)\n+\t{\n+\t  /* We want to have an initialization target for an VEC_INIT_EXPR.\n+\t     If we don't already have one in CTX, use the VEC_INIT_EXPR_SLOT.  */\n+\t  new_ctx.object = VEC_INIT_EXPR_SLOT (t);\n+\t  tree ctor = new_ctx.ctor = build_constructor (atype, NULL);\n+\t  CONSTRUCTOR_NO_CLEARING (ctor) = true;\n+\t  ctx->global->values.put (new_ctx.object, ctor);\n+\t  ctx = &new_ctx;\n+\t}\n+      init = expand_vec_init_expr (ctx->object, t, complain);\n+      return cxx_eval_constant_expression (ctx, init, lval, non_constant_p,\n+\t\t\t\t\t   overflow_p);\n+    }\n+  tree r = cxx_eval_vec_init_1 (ctx, atype, init, value_init,\n \t\t\t\tlval, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;"}, {"sha": "e4f244286292945369e31ef1cf7282b2a1b06895", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -462,21 +462,14 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n     case VEC_INIT_EXPR:\n       {\n-\tlocation_t loc = input_location;\n-\ttree init = VEC_INIT_EXPR_INIT (*expr_p);\n-\tint from_array = (init && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE);\n-\tgcc_assert (EXPR_HAS_LOCATION (*expr_p));\n-\tinput_location = EXPR_LOCATION (*expr_p);\n-\t*expr_p = build_vec_init (VEC_INIT_EXPR_SLOT (*expr_p), NULL_TREE,\n-\t\t\t\t  init, VEC_INIT_EXPR_VALUE_INIT (*expr_p),\n-\t\t\t\t  from_array,\n-\t\t\t\t  tf_warning_or_error);\n+\t*expr_p = expand_vec_init_expr (NULL_TREE, *expr_p,\n+\t\t\t\t\ttf_warning_or_error);\n+\n \thash_set<tree> pset;\n \tcp_walk_tree (expr_p, cp_fold_r, &pset, NULL);\n \tcp_genericize_tree (expr_p, false);\n \tcopy_if_shared (expr_p);\n \tret = GS_OK;\n-\tinput_location = loc;\n       }\n       break;\n "}, {"sha": "0a3697f2f98b7cbf990542c9a00d968a6b82ca8a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -7779,6 +7779,7 @@ extern bool array_of_runtime_bound_p\t\t(tree);\n extern bool vla_type_p\t\t\t\t(tree);\n extern tree build_array_copy\t\t\t(tree);\n extern tree build_vec_init_expr\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree expand_vec_init_expr\t\t(tree, tree, tsubst_flags_t);\n extern void diagnose_non_constexpr_vec_init\t(tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);"}, {"sha": "2a7dfe2b50561937e593280bbd0e8bc227e9a8ca", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -4337,12 +4337,19 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && from_array != 2)\n     init = TARGET_EXPR_INITIAL (init);\n \n+  if (init && TREE_CODE (init) == VEC_INIT_EXPR)\n+    {\n+      gcc_checking_assert (false);\n+      init = VEC_INIT_EXPR_INIT (init);\n+    }\n+\n   bool direct_init = false;\n   if (from_array && init && BRACE_ENCLOSED_INITIALIZER_P (init)\n       && CONSTRUCTOR_NELTS (init) == 1)\n     {\n       tree elt = CONSTRUCTOR_ELT (init, 0)->value;\n-      if (TREE_CODE (TREE_TYPE (elt)) == ARRAY_TYPE)\n+      if (TREE_CODE (TREE_TYPE (elt)) == ARRAY_TYPE\n+\t  && TREE_CODE (elt) != VEC_INIT_EXPR)\n \t{\n \t  direct_init = DIRECT_LIST_INIT_P (init);\n \t  init = elt;\n@@ -4516,6 +4523,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (digested)\n \t    one_init = build2 (INIT_EXPR, type, baseref, elt);\n+\t  else if (TREE_CODE (elt) == VEC_INIT_EXPR)\n+\t    one_init = expand_vec_init_expr (baseref, elt, complain);\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else"}, {"sha": "8bd1964e867035c839fabfc4c32621ea5f77b446", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -756,13 +756,11 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n   else if (init == void_type_node)\n     return build_value_init (inner_type, complain);\n \n-  gcc_assert (init == NULL_TREE\n-\t      || (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (type, TREE_TYPE (init))));\n-\n   releasing_vec argvec;\n-  if (init)\n+  if (init && !BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n+      gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (type, TREE_TYPE (init)));\n       tree init_type = strip_array_types (TREE_TYPE (init));\n       tree dummy = build_dummy_object (init_type);\n       if (!lvalue_p (init))\n@@ -788,25 +786,28 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n tree\n build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)\n {\n-  tree slot;\n-  bool value_init = false;\n-  tree elt_init;\n-  if (init && TREE_CODE (init) == CONSTRUCTOR)\n+  if (init && TREE_CODE (init) == VEC_INIT_EXPR)\n     {\n-      gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));\n-      /* We built any needed constructor calls in digest_init.  */\n-      elt_init = init;\n+      gcc_checking_assert (false);\n+      return init;\n     }\n+\n+  tree elt_init;\n+  if (init && TREE_CODE (init) == CONSTRUCTOR\n+      && !BRACE_ENCLOSED_INITIALIZER_P (init))\n+    /* We built any needed constructor calls in digest_init.  */\n+    elt_init = init;\n   else\n     elt_init = build_vec_init_elt (type, init, complain);\n \n+  bool value_init = false;\n   if (init == void_type_node)\n     {\n       value_init = true;\n       init = NULL_TREE;\n     }\n \n-  slot = build_local_temp (type);\n+  tree slot = build_local_temp (type);\n   init = build2 (VEC_INIT_EXPR, type, slot, init);\n   TREE_SIDE_EFFECTS (init) = true;\n   SET_EXPR_LOCATION (init, input_location);\n@@ -819,6 +820,23 @@ build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)\n   return init;\n }\n \n+/* Call build_vec_init to expand VEC_INIT into TARGET (for which NULL_TREE\n+   means VEC_INIT_EXPR_SLOT).  */\n+\n+tree\n+expand_vec_init_expr (tree target, tree vec_init, tsubst_flags_t complain)\n+{\n+  iloc_sentinel ils = EXPR_LOCATION (vec_init);\n+\n+  if (!target)\n+    target = VEC_INIT_EXPR_SLOT (vec_init);\n+  tree init = VEC_INIT_EXPR_INIT (vec_init);\n+  int from_array = (init && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE);\n+  return build_vec_init (target, NULL_TREE, init,\n+\t\t\t VEC_INIT_EXPR_VALUE_INIT (vec_init),\n+\t\t\t from_array, complain);\n+}\n+\n /* Give a helpful diagnostic for a non-constexpr VEC_INIT_EXPR in a context\n    that requires a constant expression.  */\n "}, {"sha": "3d4d35e13c626f5dd4a0d83b4b3c4ccf23e53177", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -1317,6 +1317,7 @@ digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n #define PICFLAG_NOT_ALL_CONSTANT 2\n #define PICFLAG_NOT_ALL_SIMPLE 4\n #define PICFLAG_SIDE_EFFECTS 8\n+#define PICFLAG_VEC_INIT 16\n \n /* Given an initializer INIT, return the flag (PICFLAG_*) which better\n    describe it.  */\n@@ -1460,10 +1461,19 @@ process_init_constructor_array (tree type, tree init, int nested, int flags,\n \n \tif (next)\n \t  {\n-\t    picflags |= picflag_from_initializer (next);\n-\t    if (len > i+1\n+\t    if (next != error_mark_node\n+\t\t&& ! seen_error () // Improves error-recovery on anew5.C.\n \t\t&& (initializer_constant_valid_p (next, TREE_TYPE (next))\n-\t\t    == null_pointer_node))\n+\t\t    != null_pointer_node))\n+\t      {\n+\t\t/* Use VEC_INIT_EXPR for non-constant initialization of\n+\t\t   trailing elements with no explicit initializers.  */\n+\t\tpicflags |= PICFLAG_VEC_INIT;\n+\t\tbreak;\n+\t      }\n+\n+\t    picflags |= picflag_from_initializer (next);\n+\t    if (len > i+1)\n \t      {\n \t\ttree range = build2 (RANGE_EXPR, size_type_node,\n \t\t\t\t     build_int_cst (size_type_node, i),\n@@ -1858,6 +1868,13 @@ process_init_constructor (tree type, tree init, int nested, int flags,\n       if (!(picflags & PICFLAG_NOT_ALL_SIMPLE))\n \tTREE_STATIC (init) = 1;\n     }\n+  if (picflags & PICFLAG_VEC_INIT)\n+    {\n+      /* Defer default-initialization of array elements with no corresponding\n+\t initializer-clause until later so we can use a loop.  */\n+      TREE_TYPE (init) = init_list_type_node;\n+      init = build_vec_init_expr (type, init, complain);\n+    }\n   return init;\n }\n \f"}, {"sha": "eaf535c254604c4a6bfc9696cdaa4da3ea644902", "filename": "gcc/testsuite/g++.dg/init/array61.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray61.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e948436eab818c527dd60b0ef939c4f42fbe8ba4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray61.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray61.C?ref=e948436eab818c527dd60b0ef939c4f42fbe8ba4", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/92385\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options -fdump-tree-gimple }\n+// { dg-final { scan-tree-dump-times \"item::item\" 1 \"gimple\" } }\n+\n+struct item {\n+  int i;\n+  item();\n+};\n+\n+struct item_array {\n+  item a[10];\n+  item_array();\n+};\n+\n+item_array::item_array() : a{} {}"}]}