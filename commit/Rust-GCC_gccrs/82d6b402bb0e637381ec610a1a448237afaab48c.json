{"sha": "82d6b402bb0e637381ec610a1a448237afaab48c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJkNmI0MDJiYjBlNjM3MzgxZWM2MTBhMWE0NDgyMzdhZmFhYjQ4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-05-03T14:19:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-05-03T14:19:46Z"}, "message": "Support for official Sparc V9 ABI:\n\n        * sparc.c (sparc_override_options): Force stack bias off for !arch64.\n        Care for flag_pcc_struct_return default.\n        (output_move_quad): Rewrite to move by halves on v9 and in the\n        proper direction.\n        (move_quad_direction): New function.\n        (output_fp_move_quad): Use it to determine the direction of copy.\n        (function_arg_slotno): Return -1 for FP reg overflow as well.\n        (function_arg_record_value*): New functions.\n        (function_arg): Use them.  Streamline unprototyped parameter passing.\n        (function_arg_pass_by_reference): Pass TCmode by reference.\n        (function_value): New function.\n        * sparc.h (PTRDIFF_TYPE, SIZE_TYPE): For -pedantic's sake, don't use\n        long long in 64-bit mode.\n        (RETURN_IN_MEMORY): v9 returns structs < 32-bytes in regs.\n        (DEFAULT_PCC_STRUCT_RETURN): Make the default detectable.\n        (BASE_RETURN_VALUE_REG): Consider complex float types for arch64.\n        (BASE_OUTGOING_VALUE_REG, BASE_PASSING_ARG_REG): Likewise.\n        (BASE_INCOMING_ARG_REG): Likewise.\n        (FUNCTION_VALUE): Call function_value.\n        (FUNCTION_OUTGOING_VALUE, LIBCALL_VALUE): Likewise.\n        * sparc.md (movdi_sp32_v9): Disable for arch64.\n        (movsf, movdf, movtf): Sort all ulternatives using fp regs first.\n        (call_value_address_sp64): Remove register class constraints.\n        (call_value_symbolic_sp64): Likewise.\n        (nonlocal_goto): Pass label reg directly to goto_handlers.  Constrain\n        v9 case to 32-bit constants.\n        (goto_handler_and_restore_v9): Provide a version for arch64.\n        * sparc/linux64.h (SIZE_TYPE, PTRDIFF_TYPE): Remove private definition.\n        * sparc/sp64-aout.h (TARGET_DEFAULT): Turn on stack bias.\n        (CPP_PREDEFINES): New.\n        * sparc/sp64-elf.h: Likewise.\n        (PREFERRED_DEBUGGING_TYPE): Dwarf2.\n        (ASM_OUTPUT_DWARF2_ADDR_CONST): New.\n        * sparc/sysv4.h (SIZE_TYPE, PTRDIFF_TYPE): Undo svr4.h's changes.\n\nFrom-SVN: r19526", "tree": {"sha": "74046c7306c56e7c32bd1dc66a7f2387740a3fbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74046c7306c56e7c32bd1dc66a7f2387740a3fbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82d6b402bb0e637381ec610a1a448237afaab48c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d6b402bb0e637381ec610a1a448237afaab48c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82d6b402bb0e637381ec610a1a448237afaab48c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d6b402bb0e637381ec610a1a448237afaab48c/comments", "author": null, "committer": null, "parents": [{"sha": "959d87966a28c5f67a33db114e4d342fe7072f0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959d87966a28c5f67a33db114e4d342fe7072f0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/959d87966a28c5f67a33db114e4d342fe7072f0c"}], "stats": {"total": 1077, "additions": 761, "deletions": 316}, "files": [{"sha": "1a38402b9b8a7b7ba47a1464b24412b48721f4c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -1,3 +1,41 @@\n+Sun May  3 13:51:34 PDT 1998  Richard Henerson  <rth@cygnus.com>\n+\n+\tSupport for official Sparc V9 ABI:\n+\t* sparc.c (sparc_override_options): Force stack bias off for !arch64.\n+\tCare for flag_pcc_struct_return default.\n+\t(output_move_quad): Rewrite to move by halves on v9 and in the\n+\tproper direction.\n+\t(move_quad_direction): New function.\n+\t(output_fp_move_quad): Use it to determine the direction of copy.\n+\t(function_arg_slotno): Return -1 for FP reg overflow as well.\n+\t(function_arg_record_value*): New functions.\n+\t(function_arg): Use them.  Streamline unprototyped parameter passing.\n+\t(function_arg_pass_by_reference): Pass TCmode by reference.\n+\t(function_value): New function.\n+\t* sparc.h (PTRDIFF_TYPE, SIZE_TYPE): For -pedantic's sake, don't use\n+\tlong long in 64-bit mode.\n+\t(RETURN_IN_MEMORY): v9 returns structs < 32-bytes in regs.\n+\t(DEFAULT_PCC_STRUCT_RETURN): Make the default detectable.\n+\t(BASE_RETURN_VALUE_REG): Consider complex float types for arch64.\n+\t(BASE_OUTGOING_VALUE_REG, BASE_PASSING_ARG_REG): Likewise.\n+\t(BASE_INCOMING_ARG_REG): Likewise.\n+\t(FUNCTION_VALUE): Call function_value.\n+\t(FUNCTION_OUTGOING_VALUE, LIBCALL_VALUE): Likewise.\n+\t* sparc.md (movdi_sp32_v9): Disable for arch64.\n+\t(movsf, movdf, movtf): Sort all ulternatives using fp regs first.\n+\t(call_value_address_sp64): Remove register class constraints.\n+\t(call_value_symbolic_sp64): Likewise.\n+\t(nonlocal_goto): Pass label reg directly to goto_handlers.  Constrain\n+\tv9 case to 32-bit constants.\n+\t(goto_handler_and_restore_v9): Provide a version for arch64.\n+\t* sparc/linux64.h (SIZE_TYPE, PTRDIFF_TYPE): Remove private definition.\n+\t* sparc/sp64-aout.h (TARGET_DEFAULT): Turn on stack bias.\n+\t(CPP_PREDEFINES): New.\n+\t* sparc/sp64-elf.h: Likewise.\n+\t(PREFERRED_DEBUGGING_TYPE): Dwarf2.\n+\t(ASM_OUTPUT_DWARF2_ADDR_CONST): New.\n+\t* sparc/sysv4.h (SIZE_TYPE, PTRDIFF_TYPE): Undo svr4.h's changes.\n+\n Sat May 2 17:47:17 PDT 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "3f359363b5991ccc1af709517b66f3acf69c426a", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -84,12 +84,6 @@ Boston, MA 02111-1307, USA.  */\n #undef SPARC_DEFAULT_CMODEL\n #define SPARC_DEFAULT_CMODEL CM_MEDANY\n \n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"long long unsigned int\"\n- \n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"long long int\"\n-  \n #undef WCHAR_TYPE\n #define WCHAR_TYPE \"long int\"\n    "}, {"sha": "e3056dfbc54e24d0bb25c0c10e1fe8f3d85339e2", "filename": "gcc/config/sparc/sp64-aout.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsp64-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsp64-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-aout.h?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for SPARC64, a.out.\n-   Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 1997, 1998  Free Software Foundation, Inc.\n    Contributed by Doug Evans, dje@cygnus.com.\n \n This file is part of GNU CC.\n@@ -28,8 +28,11 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n   (MASK_V9 + MASK_PTR64 + MASK_64BIT + MASK_HARD_QUAD \\\n-   + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n+   + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU + MASK_STACK_BIAS)\n \n /* The only code model supported is Medium/Low.  */\n #undef SPARC_DEFAULT_CMODEL\n #define SPARC_DEFAULT_CMODEL CM_MEDLOW\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dsparc -Acpu(sparc) -Amachine(sparc)\""}, {"sha": "a6f3e72c1dfc7c22897ecb0b1e2eeaad95e0745f", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for SPARC64, ELF.\n-   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998  Free Software Foundation, Inc.\n    Contributed by Doug Evans, dje@cygnus.com.\n \n This file is part of GNU CC.\n@@ -29,19 +29,19 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (sparc64-elf)\")\n \n-/* A 64 bit v9 compiler without stack-bias,\n-   in a Medium/Anywhere code model environment.\n-   There is no stack bias as this configuration is intended for\n-   embedded systems.  */\n+/* A 64 bit v9 compiler in a Medium/Anywhere code model environment.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n (MASK_V9 + MASK_PTR64 + MASK_64BIT + MASK_HARD_QUAD \\\n- + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n+ + MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU + MASK_STACK_BIAS)\n \n #undef SPARC_DEFAULT_CMODEL\n #define SPARC_DEFAULT_CMODEL CM_EMBMEDANY\n \n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dsparc -D__ELF__ -Acpu(sparc) -Amachine(sparc)\"\n+\n /* __svr4__ is used by the C library (FIXME) */\n #undef CPP_SUBTARGET_SPEC\n #define CPP_SUBTARGET_SPEC \"-D__svr4__\"\n@@ -99,11 +99,6 @@ crtbegin.o%s \\\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE 128\n \n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"long long int\"\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"long long unsigned int\"\n-\n /* The medium/anywhere code model practically requires us to put jump tables\n    in the text section as gcc is unable to distinguish LABEL_REF's of jump\n    tables from other label refs (when we need to).  */\n@@ -120,7 +115,7 @@ crtbegin.o%s \\\n #define DBX_DEBUGGING_INFO\n \n #undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n /* Stabs doesn't use this, and it confuses a simulator.  */\n /* ??? Need to see what DWARF needs, if anything.  */\n@@ -150,6 +145,9 @@ do {\t\t\t\t\t\t\t\t\\\n   fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n } while (0)\n \n+#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE, ADDR) \\\n+  fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_LONGLONG_ASM_OP, (ADDR))\n+\n /* ??? Not sure if this should be 4 or 8 bytes.  4 works for now.  */\n #define ASM_OUTPUT_DWARF_REF(FILE, LABEL) \\\n do {\t\t\t\t\t\t\t\t\\"}, {"sha": "806ece4e9d831615bea318fa8f5a35d9cd4a9e36", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 603, "deletions": 233, "changes": 836, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -280,6 +280,10 @@ sparc_override_options ()\n   if (! TARGET_V9)\n     target_flags &= ~MASK_V8PLUS;\n \n+  /* Don't use stack biasing in 32 bit mode.  */\n+  if (TARGET_ARCH32)\n+    target_flags &= ~MASK_STACK_BIAS;\n+\n   /* Validate -malign-loops= value, or provide default.  */\n   if (sparc_align_loops_string)\n     {\n@@ -321,6 +325,10 @@ sparc_override_options ()\n   else\n     sparc_align_funcs = DEFAULT_SPARC_ALIGN_FUNCS;\n \n+  /* Validate PCC_STRUCT_RETURN.  */\n+  if (flag_pcc_struct_return == DEFAULT_PCC_STRUCT_RETURN)\n+    flag_pcc_struct_return = (TARGET_ARCH64 ? 0 : 1);\n+\n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n }\n@@ -2150,9 +2158,18 @@ output_move_quad (operands)\n   register enum optype optype0;\n   register enum optype optype1;\n   rtx wordpart[4][2];\n+  rtx load_late[4];\n+  int load_late_half[2];\n   rtx addreg0 = 0;\n   rtx addreg1 = 0;\n \n+  load_late_half[0] = 0; load_late_half[1] = 0;\n+  load_late[0] = 0; load_late[1] = 0; load_late[2] = 0; \n+  load_late[3] = 0;\n+\n+  wordpart[0][0] = NULL;  wordpart[1][0] = NULL;  wordpart[2][0] = NULL;\n+  wordpart[3][0] = NULL;\n+\n   /* First classify both operands.  */\n \n   if (REG_P (op0))\n@@ -2183,6 +2200,72 @@ output_move_quad (operands)\n       || (optype0 == MEM && optype1 == MEM))\n     abort ();\n \n+  if (optype0 == REGOP)\n+    {\n+      wordpart[0][0] = gen_rtx (REG, word_mode, REGNO (op0) + 0);\n+      if (TARGET_ARCH64 && FP_REG_P (op0) \n+\t  && REGNO (op0) < SPARC_FIRST_V9_FP_REG)\n+\twordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n+      else\n+\twordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 1);\n+\n+      if (TARGET_ARCH32)\n+\t{\n+\t  wordpart[2][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n+\t  wordpart[3][0] = gen_rtx (REG, word_mode, REGNO (op0) + 3);\n+\t}\n+  \n+      /* Loading into a register which overlaps a register used in the\n+\t address.  */\n+      if (optype1 != REGOP && reg_overlap_mentioned_p (op0, op1))\n+\t{\n+\t  int i;\n+\t  int count;\n+\n+\t  count = 0;\n+\n+\t  for (i = 0; i < 4 && wordpart[i][0] != NULL; i++)\n+\t    {\n+\t      if (reg_mentioned_p (wordpart[i][0], op1))\n+\t\t{\n+\t\t  load_late[i] = wordpart[i][0];\n+\t\t  load_late_half[TARGET_ARCH64 ? i : i/2] = 1;\n+\t\t  count++;\n+\t\t}\n+\t    }\n+\t  if (count > 2)\n+\t    {\n+\t      /* Not sure what to do here. Multiple adds? Can't happen. */\n+\t      abort ();\n+\t    }\n+\t  else if (count == 2)\n+\t    {\n+\t      /* We have a two-address source operand, and both registers\n+\t\t overlap with the dest quad. Add them together and\n+\t\t store the result into the last register of the quad being\n+\t\t loaded, then generate an appropriate MEM insn. */\n+\t      rtx temp[3];\n+\t      int place = 0;\n+\n+\t      for (i = 0; i < 4; i++)\n+\t\t{\n+\t\t  if (load_late[i])\n+\t\t    {\n+\t\t      temp[place++] = load_late[i];\n+\t\t      load_late[i] = 0;\n+\t\t    }\n+\t\t}\n+\t      temp[2] = wordpart[3][0];\n+\t      output_asm_insn (\"add %0, %1, %2\", temp);\n+\t      load_late_half[0] = 0;\n+\t      load_late_half[1] = 1;\n+\t      op1 = gen_rtx (MEM, TFmode, wordpart[3][0]);\n+\t      operands[1] = op1;\n+\t      optype1 = OFFSOP;\n+\t    }\n+\t}\n+    }\n+\n   /* If an operand is an unoffsettable memory ref, find a register\n      we can increment temporarily to make it refer to the later words.  */\n \n@@ -2195,17 +2278,7 @@ output_move_quad (operands)\n   /* Ok, we can do one word at a time.\n      Set up in wordpart the operands to use for each word of the arguments.  */\n \n-  if (optype0 == REGOP)\n-    {\n-      wordpart[0][0] = gen_rtx (REG, word_mode, REGNO (op0) + 0);\n-      wordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 1);\n-      if (TARGET_ARCH32)\n-\t{\n-\t  wordpart[2][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n-\t  wordpart[3][0] = gen_rtx (REG, word_mode, REGNO (op0) + 3);\n-\t}\n-    }\n-  else if (optype0 == OFFSOP)\n+  if (optype0 == OFFSOP)\n     {\n       wordpart[0][0] = adj_offsettable_operand (op0, 0);\n       if (TARGET_ARCH32)\n@@ -2217,7 +2290,7 @@ output_move_quad (operands)\n       else\n \twordpart[1][0] = adj_offsettable_operand (op0, 8);\n     }\n-  else\n+  else if (optype0 != REGOP)\n     {\n       wordpart[0][0] = op0;\n       wordpart[1][0] = op0;\n@@ -2228,7 +2301,12 @@ output_move_quad (operands)\n   if (optype1 == REGOP)\n     {\n       wordpart[0][1] = gen_rtx (REG, word_mode, REGNO (op1) + 0);\n-      wordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 1);\n+      if (TARGET_ARCH64 && FP_REG_P (op1)\n+\t  && REGNO (op1) < SPARC_FIRST_V9_FP_REG)\n+\twordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 2);\n+      else\n+\twordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 1);\n+\n       if (TARGET_ARCH32)\n \t{\n \t  wordpart[2][1] = gen_rtx (REG, word_mode, REGNO (op1) + 2);\n@@ -2282,6 +2360,7 @@ output_move_quad (operands)\n       || (optype0 == OFFSOP && optype1 == REGOP && (REGNO (op1) & 1) == 0))\n     {\n       rtx mem, reg;\n+      int use_ldx;\n \n       if (optype0 == REGOP)\n \tmem = op1, reg = op0;\n@@ -2294,19 +2373,33 @@ output_move_quad (operands)\n \t     the register number.  */\n \t  || (TARGET_V9 && REGNO (reg) >= SPARC_FIRST_V9_FP_REG))\n \t{\n+\t  static char * const mov_by_64[2][2][2] = {\n+\t    { { \"std %S1,%2;std %1,%0\", \"stx %R1,%2;stx %1,%0\" },\n+\t      { \"ldd %2,%S0;ldd %1,%0\", \"ldx %2,%R0;ldx %1,%0\" } },\n+\t    { { \"std %1,%0;std %S1,%2\", \"stx %1,%0;stx %R1,%2\" },\n+\t      { \"ldd %1,%0;ldd %2,%S0\", \"ldx %1,%0;ldx %2,%R0\" } }\n+\t  };\n+\n \t  if (TARGET_V9 && FP_REG_P (reg) && TARGET_HARD_QUAD)\n \t    {\n-\t      if ((REGNO (reg) & 3) != 0)\n-\t\tabort ();\n-\t      /* ??? Can `mem' have an inappropriate alignment here?  */\n-\t      return (mem == op1 ? \"ldq %1,%0\" : \"stq %1,%0\");\n+\t      /* Only abort if the register # requires that we use ldq. */\n+\t      if ((REGNO (reg) & 3) == 0)\n+\t\t{\n+\t\t  /* ??? Can `mem' have an inappropriate alignment here?  */\n+\t\t  return (mem == op1 ? \"ldq %1,%0\" : \"stq %1,%0\");\n+\t\t}\n+\t      else \n+\t\t{\n+\t\t  if (REGNO (reg) >= SPARC_FIRST_V9_FP_REG)\n+\t\t    abort();\n+\t\t}\n \t    }\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n-\t  /* ??? In arch64 case, shouldn't we use ldd/std for fp regs.  */\n-\t  if (mem == op1)\n-\t    return TARGET_ARCH64 ? \"ldx %1,%0\\n\\tldx %2,%R0\" : \"ldd %1,%0\\n\\tldd %2,%S0\";\n-\t  else\n-\t    return TARGET_ARCH64 ? \"stx %1,%0\\n\\tstx %R1,%2\" : \"std %1,%0\\n\\tstd %S1,%2\";\n+\n+\t  /* Do the loads in the right order; can't overwrite our address\n+\t     register. */\n+\t  use_ldx = TARGET_ARCH64 && !FP_REG_P (reg);\n+\t  return mov_by_64[!load_late_half[0]][mem != op1][use_ldx];\n \t}\n     }\n \n@@ -2343,77 +2436,124 @@ output_move_quad (operands)\n \t}\n     }\n \n-  /* Loading into a register which overlaps a register used in the address.  */\n-  if (optype0 == REGOP && optype1 != REGOP\n-      && reg_overlap_mentioned_p (op0, op1))\n-    {\n-      /* ??? Not implemented yet.  This is a bit complicated, because we\n-\t must load which ever part overlaps the address last.  If the address\n-\t is a double-reg address, then there are two parts which need to\n-\t be done last, which is impossible.  We would need a scratch register\n-\t in that case.  */\n-      abort ();\n-    }\n-\n-  /* Normal case: move the words in lowest to highest address order.  */\n+  /* Normal case: move the words in lowest to highest address order.\n+     There may have an overlapping register; in that case, skip and go\n+     back. */\n \n   if (TARGET_ARCH32)\n     {\n-      output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n-\n-      /* Make any unoffsettable addresses point at the second word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n-\n-      /* Do the second word.  */\n-      output_asm_insn (singlemove_string (wordpart[1]), wordpart[1]);\n-\n-      /* Make any unoffsettable addresses point at the third word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n-\n-      /* Do the third word.  */\n-      output_asm_insn (singlemove_string (wordpart[2]), wordpart[2]);\n+      int i;\n+      int offset = 0xc;\n+      rtx temp[2];\n \n-      /* Make any unoffsettable addresses point at the fourth word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (! load_late[i])\n+\t    output_asm_insn (singlemove_string (wordpart[i]), wordpart[i]);\n \n-      /* Do the fourth word.  */\n-      output_asm_insn (singlemove_string (wordpart[3]), wordpart[3]);\n+\t  if (i != 3)\n+\t    {\n+\t      /* Make any unoffsettable addresses point at the next word.  */\n+\t      if (addreg0)\n+\t\toutput_asm_insn (\"add %0,0x4,%0\", &addreg0);\n+\t      if (addreg1)\n+\t\toutput_asm_insn (\"add %0,0x4,%0\", &addreg1);\n+\t    }\n+\t}\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (load_late[i])\n+\t    {\n+\t      int fix = offset - i * 4;\n \n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,-0xc,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,-0xc,%0\", &addreg1);\n+\t      /* Back up to the appropriate place. */\n+\t      temp[1] = gen_rtx (CONST_INT, VOIDmode, -fix);\n+\t      if (addreg0)\n+\t\t{\n+\t\t  temp[0] = addreg0;\n+\t\t  output_asm_insn (\"add %0,%1,%0\", temp);\n+\t\t}\n+\t      if (addreg1)\n+\t\t{\n+\t\t  temp[0] = addreg1;\n+\t\t  output_asm_insn (\"add %0,%1,%0\", temp);\n+\t\t}\n+\t      output_asm_insn (singlemove_string (wordpart[i]),\n+\t\t\t       wordpart[i]);\n+\t      /* Don't modify the register that's the destination of the\n+\t\t move. */\n+\t      temp[0] = gen_rtx (CONST_INT, VOIDmode, -(offset - fix));\n+\t      if (addreg0 && REGNO (addreg0) != REGNO (wordpart[i][0]))\n+\t\t{\n+\t\t  temp[1] = addreg0;\n+\t\t  output_asm_insn(\"add %0,%1,%0\", temp);\n+\t\t}\n+\t      if (addreg1 && REGNO (addreg1) != REGNO (wordpart[i][0]))\n+\t\t{\n+\t\t  temp[1] = addreg1;\n+\t\t  output_asm_insn(\"add %0,%1,%0\",temp);\n+\t\t}\n+\t      offset = 0;\n+\t      break;\n+\t    }\n+\t}\n+      if (offset)\n+\t{\n+\t  temp[1] = gen_rtx (CONST_INT, VOIDmode, -offset);\n+\t  /* Undo the adds we just did.  */\n+\t  if (addreg0)\n+\t    {\n+\t      temp[0] = addreg0;\n+\t      output_asm_insn (\"add %0,%1,%0\", temp);\n+\t    }\n+\t  if (addreg1)\n+\t    {\n+\t      temp[0] = addreg1;\n+\t      output_asm_insn (\"add %0,%1,%0\", temp);\n+\t    }\n+\t}\n     }\n   else /* TARGET_ARCH64 */\n     {\n-      output_asm_insn (doublemove_string (wordpart[0]), wordpart[0]);\n+      if (load_late_half[0]) \n+\t{\n+\t  /* Load the second half first. */\n+\t  if (addreg0)\n+\t    output_asm_insn (\"add %0,0x8,%0\", &addreg0);\n+\t  if (addreg1)\n+\t    output_asm_insn (\"add %0,0x8,%0\", &addreg1);\n \n-      /* Make any unoffsettable addresses point at the second word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,0x8,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,0x8,%0\", &addreg1);\n+\t  output_asm_insn (doublemove_string (wordpart[1]), wordpart[1]);\n \n-      /* Do the second word.  */\n-      output_asm_insn (doublemove_string (wordpart[1]), wordpart[1]);\n+\t  /* Undo the adds we just did.  */\n+\t  if (addreg0)\n+\t    output_asm_insn (\"add %0,-0x8,%0\", &addreg0);\n+\t  if (addreg1)\n+\t    output_asm_insn (\"add %0,-0x8,%0\", &addreg1);\n \n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add %0,-0x8,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add %0,-0x8,%0\", &addreg1);\n-    }\n+\t  output_asm_insn (doublemove_string (wordpart[0]), wordpart[0]);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (doublemove_string (wordpart[0]), wordpart[0]);\n \n+\t  if (addreg0)\n+\t    output_asm_insn (\"add %0,0x8,%0\", &addreg0);\n+\t  if (addreg1)\n+\t    output_asm_insn (\"add %0,0x8,%0\", &addreg1);\n+\n+\t  /* Do the second word.  */\n+\t  output_asm_insn (doublemove_string (wordpart[1]), wordpart[1]);\n+\n+\t  /* Undo the adds we just did.  But don't modify the dest of\n+\t     the move. */\n+\t  if (addreg0 && REGNO (addreg0) != REGNO (wordpart[1][0]))\n+\t    output_asm_insn (\"add %0,-0x8,%0\", &addreg0);\n+\t  if (addreg1 && REGNO (addreg1) != REGNO (wordpart[1][0]))\n+\t    output_asm_insn (\"add %0,-0x8,%0\", &addreg1);\n+\t}\n+    }\n+  \n   return \"\";\n }\n \f\n@@ -2448,6 +2588,24 @@ output_fp_move_double (operands)\n   else abort ();\n }\n \n+/* When doing a quad-register move, determine the drection in which\n+   the move needs to be performed. SRC and DST are the source and\n+   destination registers.\n+\n+   A value of -1 indicates that the move needs to be done from the\n+   highest register to the lowest. */\n+\n+static int\n+move_quad_direction (src, dst)\n+     rtx src, dst;\n+{\n+  if ((REGNO (dst) > REGNO (src))\n+      && (REGNO (dst) < (REGNO (src) + 4)))\n+    return -1;\n+  else\n+    return 1;\n+}\n+\n /* Output assembler code to perform a quadword move insn with operands\n    OPERANDS, one of which must be a floating point register.  */\n \n@@ -2465,9 +2623,21 @@ output_fp_move_quad (operands)\n \t  if (TARGET_V9 && TARGET_HARD_QUAD)\n \t    return \"fmovq %1,%0\";\n \t  else if (TARGET_V9)\n-\t    return \"fmovd %1,%0\\n\\tfmovd %S1,%S0\";\n+\t    {\n+\t      int dir = move_quad_direction (op1, op0);\n+\t      if (dir > 0)\n+\t\treturn \"fmovd %1,%0\\n\\tfmovd %S1,%S0\";\n+\t      else \n+\t\treturn \"fmovd %S1,%S0\\n\\tfmovd %1,%0\";\n+\t    }\n \t  else\n-\t    return \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n+\t    {\n+\t      int dir = move_quad_direction (op0, op1);\n+\t      if (dir > 0)\n+\t\treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n+\t      else\n+\t\treturn \"fmovs %T1,%T0\\n\\tfmovs %S1,%S0\\n\\tfmovs %R1,%R0\\n\\tfmovs %1,%0\";\n+\t    }\n \t}\n       else if (GET_CODE (op1) == REG)\n \tabort ();\n@@ -3777,7 +3947,7 @@ function_arg_slotno (cum, mode, type, named, incoming_p, pregno, ppadding)\n \t  if (TARGET_FPU && named)\n \t    {\n \t      if (slotno >= SPARC_FP_ARG_MAX)\n-\t\treturn 0;\n+\t\treturn -1;\n \t      regno = SPARC_FP_ARG_FIRST + slotno * 2;\n \t      if (mode == SFmode)\n \t\tregno++;\n@@ -3855,6 +4025,271 @@ function_arg_slotno (cum, mode, type, named, incoming_p, pregno, ppadding)\n   return slotno;\n }\n \n+/* Handle recursive register counting for structure field layout.  */\n+\n+struct function_arg_record_value_parms\n+{\n+  rtx ret;\n+  int slotno, named, regbase;\n+  int nregs, intoffset;\n+};\n+\n+static void\n+function_arg_record_value_1 (type, startbitpos, parms)\n+     tree type;\n+     int startbitpos;\n+     struct function_arg_record_value_parms *parms;\n+{\n+  tree field;\n+\n+  /* The ABI obviously doesn't specify how packed structures are\n+     passed.  These are defined to be passed in int regs if possible,\n+     otherwise memory.  */\n+  int packed_p = 0;\n+\n+  /* We need to compute how many registers are needed so we can\n+     allocate the PARALLEL but before we can do that we need to know\n+     whether there are any packed fields.  If there are, int regs are\n+     used regardless of whether there are fp values present.  */\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n+\t{\n+\t  packed_p = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Compute how many registers we need.  */\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL)\n+\t{\n+\t  int bitpos = startbitpos;\n+\t  if (DECL_FIELD_BITPOS (field))\n+\t    bitpos += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  /* ??? FIXME: else assume zero offset.  */\n+\n+\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n+\t    {\n+\t      function_arg_record_value_1 (TREE_TYPE (field), bitpos, parms);\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t           && TARGET_FPU\n+\t           && ! packed_p\n+\t           && parms->named)\n+\t    {\n+\t      if (parms->intoffset != -1)\n+\t\t{\n+\t\t  int intslots, this_slotno;\n+\n+\t\t  intslots = (bitpos - parms->intoffset + BITS_PER_WORD - 1)\n+\t\t    / BITS_PER_WORD;\n+\t\t  this_slotno = parms->slotno + parms->intoffset\n+\t\t    / BITS_PER_WORD;\n+\n+\t\t  intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n+\t\t  intslots = MAX (intslots, 0);\n+\t\t  parms->nregs += intslots;\n+\t\t  parms->intoffset = -1;\n+\t\t}\n+\n+\t      /* There's no need to check this_slotno < SPARC_FP_ARG MAX.\n+\t\t If it wasn't true we wouldn't be here.  */\n+\t      parms->nregs += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (parms->intoffset == -1)\n+\t\tparms->intoffset = bitpos;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Handle recursive structure field register assignment.  */\n+\n+static void \n+function_arg_record_value_3 (bitpos, parms)\n+     int bitpos;\n+     struct function_arg_record_value_parms *parms;\n+{\n+  enum machine_mode mode;\n+  int regno, this_slotno, intslots, intoffset;\n+  rtx reg;\n+\n+  if (parms->intoffset == -1)\n+    return;\n+  intoffset = parms->intoffset;\n+  parms->intoffset = -1;\n+\n+  intslots = (bitpos - intoffset + BITS_PER_WORD - 1) / BITS_PER_WORD;\n+  this_slotno = parms->slotno + intoffset / BITS_PER_WORD;\n+\n+  intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n+  if (intslots <= 0)\n+    return;\n+\n+  /* If this is the trailing part of a word, only load that much into\n+     the register.  Otherwise load the whole register.  Note that in\n+     the latter case we may pick up unwanted bits.  It's not a problem\n+     at the moment but may wish to revisit.  */\n+\n+  if (intoffset % BITS_PER_WORD != 0)\n+    {\n+      mode = mode_for_size (BITS_PER_WORD - intoffset%BITS_PER_WORD,\n+\t\t\t    MODE_INT, 0);\n+    }\n+  else\n+    mode = word_mode;\n+\n+  intoffset /= BITS_PER_UNIT;\n+  do\n+    {\n+      regno = parms->regbase + this_slotno;\n+      reg = gen_rtx (REG, mode, regno);\n+      XVECEXP (parms->ret, 0, parms->nregs)\n+\t= gen_rtx (EXPR_LIST, VOIDmode, reg, GEN_INT (intoffset));\n+\n+      this_slotno += 1;\n+      intoffset = (intoffset | (UNITS_PER_WORD-1)) + 1;\n+      parms->nregs += 1;\n+      intslots -= 1;\n+    }\n+  while (intslots > 0);\n+}\n+\n+static void\n+function_arg_record_value_2 (type, startbitpos, parms)\n+     tree type;\n+     int startbitpos;\n+     struct function_arg_record_value_parms *parms;\n+{\n+  tree field;\n+  int packed_p = 0;\n+\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n+\t{\n+\t  packed_p = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) == FIELD_DECL)\n+\t{\n+\t  int bitpos = startbitpos;\n+\t  if (DECL_FIELD_BITPOS (field))\n+\t    bitpos += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  /* ??? FIXME: else assume zero offset.  */\n+\n+\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n+\t    {\n+\t      function_arg_record_value_2 (TREE_TYPE (field), bitpos, parms);\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t           && TARGET_FPU\n+\t           && ! packed_p\n+\t           && parms->named)\n+\t    {\n+\t      int this_slotno = parms->slotno + bitpos / BITS_PER_WORD;\n+\t      rtx reg;\n+\n+\t      function_arg_record_value_3 (bitpos, parms);\n+\n+\t      reg = gen_rtx (REG, DECL_MODE (field),\n+\t\t\t         (SPARC_FP_ARG_FIRST + this_slotno * 2\n+\t\t\t          + (DECL_MODE (field) == SFmode\n+\t\t\t\t     && (bitpos & 32) != 0)));\n+\t      XVECEXP (parms->ret, 0, parms->nregs)\n+\t\t= gen_rtx (EXPR_LIST, VOIDmode, reg,\n+\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n+\t      parms->nregs += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (parms->intoffset == -1)\n+\t\tparms->intoffset = bitpos;\n+\t    }\n+\t}\n+    }\n+}\n+\n+static rtx\n+function_arg_record_value (type, slotno, named, regbase)\n+     tree type;\n+     int slotno, named, regbase;\n+{\n+  HOST_WIDE_INT typesize = int_size_in_bytes (type);\n+  struct function_arg_record_value_parms parms;\n+  int nregs;\n+\n+  parms.ret = NULL_RTX;\n+  parms.slotno = slotno;\n+  parms.named = named;\n+  parms.regbase = regbase;\n+\n+  /* Compute how many registers we need.  */\n+  parms.nregs = 0;\n+  parms.intoffset = 0;\n+  function_arg_record_value_1 (type, 0, &parms);\n+\n+  if (parms.intoffset != -1)\n+    {\n+      int intslots, this_slotno;\n+\n+      intslots = (typesize*BITS_PER_UNIT - parms.intoffset + BITS_PER_WORD - 1)\n+\t/ BITS_PER_WORD;\n+      this_slotno = slotno + parms.intoffset / BITS_PER_WORD;\n+\n+      intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n+      intslots = MAX (intslots, 0);\n+\n+      parms.nregs += intslots;\n+    }\n+  nregs = parms.nregs;\n+\n+  /* Allocate the vector and handle some annoying special cases.  */\n+  if (nregs == 0)\n+    {\n+      /* ??? Empty structure has no value?  Duh?  */\n+      if (typesize <= 0)\n+\t{\n+\t  /* Though there's nothing really to store, return a word register\n+\t     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL\n+\t     leads to breakage due to the fact that there are zero bytes to\n+\t     load.  */\n+\t  return gen_rtx (REG, DImode, regbase);\n+\t}\n+      else\n+\t{\n+\t  /* ??? C++ has structures with no fields, and yet a size.  Give up\n+\t     for now and pass everything back in integer registers.  */\n+\t  nregs = (typesize + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\t}\n+      if (nregs + slotno > SPARC_INT_ARG_MAX)\n+\tnregs = SPARC_INT_ARG_MAX - slotno;\n+    }\n+  if (nregs == 0)\n+    abort();\n+\n+  parms.ret = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (nregs));\n+\n+  /* Fill in the entries.  */\n+  parms.nregs = 0;\n+  parms.intoffset = 0;\n+  function_arg_record_value_2 (type, 0, &parms);\n+  function_arg_record_value_3 (typesize * BITS_PER_UNIT, &parms);\n+\n+  if (parms.nregs != nregs)\n+    abort ();\n+\n+  return parms.ret;\n+}\n+\n /* Handle the FUNCTION_ARG macro.\n    Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -3909,6 +4344,7 @@ function_arg (cum, mode, type, named, incoming_p)\n \t{\n \t  /* \"* 2\" because fp reg numbers are recorded in 4 byte\n \t     quantities.  */\n+#if 0\n \t  /* ??? This will cause the value to be passed in the fp reg and\n \t     in the stack.  When a prototype exists we want to pass the\n \t     value in the reg but reserve space on the stack.  That's an\n@@ -3921,172 +4357,58 @@ function_arg (cum, mode, type, named, incoming_p)\n \t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n \t\t\t\t\t\treg, const0_rtx)));\n \t  else\n+#else\n+\t  /* ??? It seems that passing back a register even when past\n+\t     the area declared by REG_PARM_STACK_SPACE will allocate\n+\t     space appropriately, and will not copy the data onto the\n+\t     stack, exactly as we desire.\n+\n+\t     This is due to locate_and_pad_parm being called in\n+\t     expand_call whenever reg_parm_stack_space > 0, which\n+\t     while benefical to our example here, would seem to be\n+\t     in error from what had been intended.  Ho hum...  -- r~ */\n+#endif\n \t    return reg;\n \t}\n       else\n \t{\n+\t  rtx v0, v1;\n+\n \t  if ((regno - SPARC_FP_ARG_FIRST) < SPARC_INT_ARG_MAX * 2)\n \t    {\n-\t      int regbase = (incoming_p\n-\t\t\t     ? SPARC_INCOMING_INT_ARG_FIRST\n-\t\t\t     : SPARC_OUTGOING_INT_ARG_FIRST);\n-\t      int intreg = regbase + (regno - SPARC_FP_ARG_FIRST) / 2;\n-\t      return gen_rtx (PARALLEL, mode,\n-\t\t\t      gen_rtvec (2,\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\t  reg, const0_rtx),\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\t  gen_rtx (REG, mode, intreg),\n-\t\t\t\t\t\t  const0_rtx)));\n+\t      int intreg;\n+\n+\t      /* On incoming, we don't need to know that the value\n+\t\t is passed in %f0 and %i0, and it confuses other parts\n+\t\t causing needless spillage even on the simplest cases.  */\n+\t      if (incoming_p)\n+\t\treturn reg;\n+\n+\t      intreg = (SPARC_OUTGOING_INT_ARG_FIRST\n+\t\t\t+ (regno - SPARC_FP_ARG_FIRST) / 2);\n+\n+\t      v0 = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n+\t      v1 = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_REG (mode, intreg),\n+\t\t\t\t      const0_rtx);\n+\t      return gen_rtx_PARALLEL (mode, gen_rtvec (2, v0, v1));\n \t    }\n \t  else\n-\t    return gen_rtx (PARALLEL, mode,\n-\t\t\t    gen_rtvec (2,\n-\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\tNULL_RTX, const0_rtx),\n-\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t\treg, const0_rtx)));\n+\t    {\n+\t      v0 = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+\t      v1 = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n+\t      return gen_rtx_PARALLEL (mode, gen_rtvec (2, v0, v1));\n+\t    }\n \t}\n     }\n   else if (type && TREE_CODE (type) == RECORD_TYPE)\n     {\n       /* Structures up to 16 bytes in size are passed in arg slots on the\n \t stack and are promoted to registers where possible.  */\n-      tree field;\n-      rtx ret;\n-      int i;\n-      int nregs;\n-      /* Starting bit position of a sequence of integer fields, counted from\n-\t msb of left most byte, -1 if last field wasn't an int.  */\n-      /* ??? This isn't entirely necessary, some simplification\n-\t may be possible.  */\n-      int start_int_bitpos;\n-      /* Current bitpos in struct, counted from msb of left most byte.  */\n-      int bitpos, this_slotno;\n-      /* The ABI obviously doesn't specify how packed\n-\t structures are passed.  These are defined to be passed\n-\t in int regs if possible, otherwise memory.  */\n-      int packed_p = 0;\n \n       if (int_size_in_bytes (type) > 16)\n \tabort (); /* shouldn't get here */\n \n-      /* We need to compute how many registers are needed so we can allocate\n-\t the PARALLEL but before we can do that we need to know whether there\n-\t are any packed fields.  If there are, int regs are used regardless of\n-\t whether there are fp values present.  */\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) == FIELD_DECL\n-\t      && DECL_PACKED (field))\n-\t    {\n-\t      packed_p = 1;\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* Compute how many registers we need.  */\n-      nregs = 0;\n-      start_int_bitpos = -1;\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t{\n-\t  bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n-\t  this_slotno = slotno + bitpos / BITS_PER_WORD;\n-\t  if (TREE_CODE (field) == FIELD_DECL)\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n-\t\t  && TARGET_FPU\n-\t\t  && ! packed_p\n-\t\t  && named)\n-\t\t{\n-\t\t  /* There's no need to check this_slotno < SPARC_FP_ARG MAX.\n-\t\t     If it wasn't true we wouldn't be here.  */\n-\t\t  nregs++;\n-\t\t  start_int_bitpos = -1;\n-\t\t}\n-\t      else if (this_slotno < SPARC_INT_ARG_MAX)\n-\t\t{\n-\t\t  if (start_int_bitpos == -1)\n-\t\t    {\n-\t\t      nregs++;\n-\t\t      start_int_bitpos = bitpos;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (bitpos % BITS_PER_WORD == 0)\n-\t\t\tnregs++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      if (nregs == 0)\n-\tabort ();\n-\n-      ret = gen_rtx (PARALLEL, BLKmode, rtvec_alloc (nregs + 1));\n-\n-      /* ??? This causes the entire struct to be passed in memory.\n-\t This isn't necessary, but is left for later.  */\n-      XVECEXP (ret, 0, 0) = gen_rtx (EXPR_LIST, VOIDmode, NULL_RTX,\n-\t\t\t\t     const0_rtx);\n-\n-      /* Fill in the entries.  */\n-      start_int_bitpos = -1;\n-      for (i = 1, field = TYPE_FIELDS (type);\n-\t   field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n-\t  this_slotno = slotno + bitpos / BITS_PER_WORD;\n-\t  if (TREE_CODE (field) == FIELD_DECL)\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n-\t\t  && TARGET_FPU\n-\t\t  && ! packed_p\n-\t\t  && named)\n-\t\t{\n-\t\t  reg = gen_rtx (REG, DECL_MODE (field),\n-\t\t\t\t (SPARC_FP_ARG_FIRST + this_slotno * 2\n-\t\t\t\t  + (DECL_MODE (field) == SFmode\n-\t\t\t\t     && (bitpos & 32) != 0)));\n-\t\t  XVECEXP (ret, 0, i) = gen_rtx (EXPR_LIST, VOIDmode, reg,\n-\t\t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n-\t\t  i++;\n-\t\t  start_int_bitpos = -1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (this_slotno < SPARC_INT_ARG_MAX\n-\t\t      && (start_int_bitpos == -1\n-\t\t\t  || bitpos % BITS_PER_WORD == 0))\n-\t\t    {\n-\t\t      enum machine_mode mode;\n-\n-\t\t      /* If this is the trailing part of a word, only load\n-\t\t\t that much into the register.  Otherwise load the\n-\t\t\t whole register.  Note that in the latter case we may\n-\t\t\t pick up unwanted bits.  It's not a problem at the\n-\t\t\t moment but may wish to revisit.  */\n-\t\t      if (bitpos % BITS_PER_WORD != 0)\n-\t\t\tmode = mode_for_size (BITS_PER_WORD - bitpos % BITS_PER_WORD,\n-\t\t\t\t\t      MODE_INT, 0);\n-\t\t      else\n-\t\t\tmode = word_mode;\n-\n-\t\t      regno = regbase + this_slotno;\n-\t\t      reg = gen_rtx (REG, mode, regno);\n-\t\t      XVECEXP (ret, 0, i) = gen_rtx (EXPR_LIST, VOIDmode, reg,\n-\t\t\t\t\t\t     GEN_INT (bitpos / BITS_PER_UNIT));\n-\t\t      i++;\n-\t\t      if (start_int_bitpos == -1)\n-\t\t\tstart_int_bitpos = bitpos;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      if (i != nregs + 1)\n-\tabort ();\n-\n-      return ret;\n+      return function_arg_record_value (type, slotno, named, regbase);\n     }\n   else if (type && TREE_CODE (type) == UNION_TYPE)\n     {\n@@ -4187,7 +4509,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n /* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.\n    !v9: The SPARC ABI stipulates passing struct arguments (of any size) and\n    quad-precision floats by invisible reference.\n-   v9: aggregates greater than 16 bytes are passed by reference.\n+   v9: Aggregates greater than 16 bytes are passed by reference.\n    For Pascal, also pass arrays by reference.  */\n \n int\n@@ -4205,6 +4527,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n   else\n     {\n       return ((type && TREE_CODE (type) == ARRAY_TYPE)\n+\t      /* Consider complex values as aggregates, so care for TCmode. */\n+\t      || GET_MODE_SIZE (mode) > 16\n \t      || (type && AGGREGATE_TYPE_P (type)\n \t\t  && int_size_in_bytes (type) > 16));\n     }\n@@ -4288,7 +4612,53 @@ function_arg_padding (mode, type)\n \t      : GET_MODE_BITSIZE (mode) < PARM_BOUNDARY)\n \t     ? downward : upward));\n }\n-\f\n+\n+/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE macros.\n+   For v9, function return values are subject to the same rules as arguments,\n+   except that up to 32-bytes may be returned in registers.  */\n+\n+rtx\n+function_value (type, mode, incoming_p)\n+     tree type;\n+     enum machine_mode mode;\n+     int incoming_p;\n+{\n+  int regno;\n+  int regbase = (incoming_p\n+\t\t ? SPARC_OUTGOING_INT_ARG_FIRST\n+\t\t : SPARC_INCOMING_INT_ARG_FIRST);\n+\n+  if (TARGET_ARCH64 && type)\n+    {\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  /* Structures up to 32 bytes in size are passed in registers,\n+\t     promoted to fp registers where possible.  */\n+\n+\t  if (int_size_in_bytes (type) > 32)\n+\t    abort (); /* shouldn't get here */\n+\n+\t  return function_arg_record_value (type, 0, 1, regbase);\n+\t}\n+      else if (TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  int bytes = int_size_in_bytes (type);\n+\n+\t  if (bytes > 32)\n+\t    abort ();\n+\n+\t  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n+\t}\n+    }\n+\n+  if (incoming_p)\n+    regno = BASE_RETURN_VALUE_REG (mode);\n+  else\n+    regno = BASE_OUTGOING_VALUE_REG (mode);\n+\n+  return gen_rtx (REG, mode, regno);\n+}\n+\n /* Do what is necessary for `va_start'.  The argument is ignored.\n \n    We look at the current function to determine if stdarg or varargs"}, {"sha": "629d5425065830c0213793abb6d1a923f374caf2", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -276,8 +276,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define NO_BUILTIN_PTRDIFF_TYPE\n #define NO_BUILTIN_SIZE_TYPE\n #endif\n-#define PTRDIFF_TYPE (TARGET_ARCH64 ? \"long long int\" : \"int\")\n-#define SIZE_TYPE (TARGET_ARCH64 ? \"long long unsigned int\" : \"unsigned int\")\n+#define PTRDIFF_TYPE (TARGET_ARCH64 ? \"long int\" : \"int\")\n+#define SIZE_TYPE (TARGET_ARCH64 ? \"long unsigned int\" : \"unsigned int\")\n \n /* ??? This should be 32 bits for v9 but what can we do?  */\n #define WCHAR_TYPE \"short unsigned int\"\n@@ -1078,18 +1078,24 @@ extern int sparc_mode_class[];\n #define INITIALIZE_PIC initialize_pic ()\n #define FINALIZE_PIC finalize_pic ()\n \n+/* Pick a default value we can notice from override_options:\n+   !v9: Default is on.\n+   v9: Default is off.  */\n+\n+#define DEFAULT_PCC_STRUCT_RETURN -1\n+\n /* Sparc ABI says that quad-precision floats and all structures are returned\n    in memory.\n    For v9: unions <= 32 bytes in size are returned in int regs,\n-   structures up to 32 bytes are returned in int and fp regs.\n-   FIXME: wip */\n+   structures up to 32 bytes are returned in int and fp regs.  */\n \n #define RETURN_IN_MEMORY(TYPE)\t\t\t\t\\\n (TARGET_ARCH32\t\t\t\t\t\t\\\n  ? (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\\\n     || TYPE_MODE (TYPE) == TFmode\t\t\t\\\n     || TYPE_MODE (TYPE) == TCmode)\t\t\t\\\n- : TYPE_MODE (TYPE) == BLKmode)\n+ : (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\\\n+    && int_size_in_bytes (TYPE) > 32))\n \n /* Functions which return large structures get the address\n    to place the wanted value at offset 64 from the frame.\n@@ -1449,9 +1455,14 @@ extern char leaf_reg_remap[];\n    : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n /* When a parameter is passed in a register, stack space is still\n-   allocated for it.  */\n-/* This only takes into account the int regs.\n-   fp regs are handled elsewhere.  */\n+   allocated for it.\n+   !v9: All 6 possible integer registers have backing store allocated.\n+   v9: Only space for the arguments passed is allocated. */\n+/* ??? Ideally, we'd use zero here (as the minimum), but zero has special\n+   meaning to the backend.  Further, we need to be able to detect if a\n+   varargs/unprototyped function is called, as they may want to spill more\n+   registers than we've provided space.  Ugly, ugly.  So for now we retain\n+   all 6 slots even for v9.  */\n #define REG_PARM_STACK_SPACE(DECL) (6 * UNITS_PER_WORD)\n \n /* Keep the stack pointer constant throughout the function.\n@@ -1472,24 +1483,28 @@ extern char leaf_reg_remap[];\n /* Some subroutine macros specific to this machine.\n    When !TARGET_FPU, put float return values in the general registers,\n    since we don't have any fp registers.  */\n-#define BASE_RETURN_VALUE_REG(MODE) \\\n-  (TARGET_ARCH64 \\\n-   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+#define BASE_RETURN_VALUE_REG(MODE)\t\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\t\\\n+   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\t\t\t\\\n    : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 8))\n-#define BASE_OUTGOING_VALUE_REG(MODE) \\\n-  (TARGET_ARCH64 \\\n-   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-      : TARGET_FLAT ? 8 : 24) \\\n+\n+#define BASE_OUTGOING_VALUE_REG(MODE)\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\\\n+   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32\t\t\t\\\n+      : TARGET_FLAT ? 8 : 24)\t\t\t\t\t\\\n    : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n       : (TARGET_FLAT ? 8 : 24)))\n-#define BASE_PASSING_ARG_REG(MODE) \\\n-  (TARGET_ARCH64 \\\n-   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+\n+#define BASE_PASSING_ARG_REG(MODE)\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\\\n+   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32 : 8)\t\t\\\n    : 8)\n-#define BASE_INCOMING_ARG_REG(MODE) \\\n-  (TARGET_ARCH64 \\\n-   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-      : TARGET_FLAT ? 8 : 24) \\\n+\n+/* ??? FIXME -- seems wrong for v9 structure passing... */\n+#define BASE_INCOMING_ARG_REG(MODE)\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\\\n+   ? (TARGET_FPU && FLOAT_MODE_P (MODE) ? 32\t\t\t\\\n+      : TARGET_FLAT ? 8 : 24)\t\t\t\t\t\\\n    : (TARGET_FLAT ? 8 : 24))\n \n /* Define this macro if the target machine has \"register windows\".  This\n@@ -1515,19 +1530,20 @@ extern char leaf_reg_remap[];\n \n /* On SPARC the value is found in the first \"output\" register.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n+extern struct rtx_def *function_value ();\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  function_value ((VALTYPE), TYPE_MODE (VALTYPE), 1)\n \n /* But the called function leaves it in the first \"input\" register.  */\n \n-#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_OUTGOING_VALUE_REG (TYPE_MODE (VALTYPE)))\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC) \\\n+  function_value ((VALTYPE), TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)\t\\\n-  gen_rtx_REG (MODE, BASE_RETURN_VALUE_REG (MODE))\n+#define LIBCALL_VALUE(MODE) \\\n+  function_value (NULL_TREE, (MODE), 1)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller."}, {"sha": "a86434c34f14a17540c13eaa2ab2f001c16579b3", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -2202,7 +2202,7 @@\n (define_insn \"*movdi_sp32_v9\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,Q,r,r,?e,?e,?Q,?b\")\n \t(match_operand:DI 1 \"general_operand\" \"r,J,r,Q,i,e,Q,e,J\"))]\n-  \"TARGET_V9\n+  \"TARGET_V9 && ! TARGET_ARCH64\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n        || operands[1] == const0_rtx)\n@@ -2297,7 +2297,7 @@\n     case 3:\n       return \\\"stx %r1,%0\\\";\n     case 4:\n-      return \\\"mov %1,%0\\\";\n+      return \\\"fmovd %1,%0\\\";\n     case 5:\n       return \\\"ldd %1,%0\\\";\n     case 6:\n@@ -2367,8 +2367,8 @@\n ;; to be reloaded by putting the constant into memory.\n ;; It must come before the more general movsf pattern.\n (define_insn \"*movsf_const_insn\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m,d\")\n-\t(match_operand:SF 1 \"\" \"?F,m,G,G\"))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,d,m,?r\")\n+\t(match_operand:SF 1 \"\" \"m,G,G,?F\"))]\n   \"TARGET_FPU\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n    && (GET_CODE (operands[0]) == REG\n@@ -2378,19 +2378,19 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return singlemove_string (operands);\n-    case 1:\n       return \\\"ld %1,%0\\\";\n+    case 1:\n+      return \\\"fzeros %0\\\";\n     case 2:\n       return \\\"st %%g0,%0\\\";\n     case 3:\n-      return \\\"fzeros %0\\\";\n+      return singlemove_string (operands);\n     default:\n       abort ();\n     }\n }\"\n-  [(set_attr \"type\" \"load,fpload,store,fpmove\")\n-   (set_attr \"length\" \"2,1,1,1\")])\n+  [(set_attr \"type\" \"fpload,fpmove,store,load\")\n+   (set_attr \"length\" \"1,1,1,2\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -2403,19 +2403,19 @@\n }\")\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,f,r,Q,Q\")\n-\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,Q,Q,f,r\"))]\n+  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=f,f,Q,r,r,Q\")\n+\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\"  \"f,Q,f,r,Q,r\"))]\n   \"TARGET_FPU\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n   \"@\n    fmovs %1,%0\n-   mov %1,%0\n-   ld %1,%0\n    ld %1,%0\n    st %1,%0\n+   mov %1,%0\n+   ld %1,%0\n    st %1,%0\"\n-  [(set_attr \"type\" \"fpmove,move,fpload,load,fpstore,store\")])\n+  [(set_attr \"type\" \"fpmove,fpload,fpstore,move,load,store\")])\n \n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n@@ -2492,8 +2492,8 @@\n }\")\n \n (define_insn \"*movdf_insn\"\n-  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=T,U,e,r,Q,Q,e,r\")\n-\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\" \"U,T,e,r,e,r,Q,Q\"))]\n+  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=e,Q,e,T,U,r,Q,r\")\n+\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\"  \"e,e,Q,U,T,r,r,Q\"))]\n   \"TARGET_FPU\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -2512,7 +2512,7 @@\n \n (define_insn \"*movdf_no_e_insn\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=T,U,r,Q,&r\")\n-\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\" \"U,T,r,r,Q\"))]\n+\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\"  \"U,T,r,r,Q\"))]\n   \"! TARGET_FPU\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -2619,8 +2619,8 @@\n }\")\n \n (define_insn \"*movtf_insn\"\n-  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=e,r,Q,Q,e,&r\")\n-\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"e,r,e,r,Q,Q\"))]\n+  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=e,Q,e,r,Q,r\")\n+\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\"  \"e,e,Q,r,r,Q\"))]\n   \"TARGET_FPU\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode))\"\n@@ -5517,7 +5517,8 @@ if (! TARGET_ARCH64)\n   \"\"\n   \"*\n {\n-  /* Some implementations are reported to have problems with\n+  /* Some implementations (e.g. TurboSparc) are reported to have problems\n+     with\n \tfoo: b,a foo\n      i.e. an empty loop with the annul bit set.  The workaround is to use \n         foo: b foo; nop\n@@ -5824,7 +5825,7 @@ if (! TARGET_ARCH64)\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_value_address_sp64\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n+  [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"address_operand\" \"p\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 15))]\n@@ -5834,7 +5835,7 @@ if (! TARGET_ARCH64)\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_value_symbolic_sp64\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n+  [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"symbolic_operand\" \"s\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 15))]\n@@ -5982,6 +5983,7 @@ if (! TARGET_ARCH64)\n   rtx fp = operands[1];\n   rtx stack = operands[2];\n   rtx lab = operands[3];\n+  rtx labreg;\n \n   /* Trap instruction to flush all the register windows.  */\n   emit_insn (gen_flush_register_windows ());\n@@ -5995,7 +5997,8 @@ if (! TARGET_ARCH64)\n \n   /* Find the containing function's current nonlocal goto handler,\n      which will do any cleanups and then jump to the label.  */\n-  emit_move_insn (gen_rtx (REG, Pmode, 8), lab);\n+  labreg = gen_rtx (REG, Pmode, 8);\n+  emit_move_insn (labreg, lab);\n \n   /* Restore %fp from stack pointer value for containing function.\n      The restore insn that follows will move this to %sp,\n@@ -6007,16 +6010,18 @@ if (! TARGET_ARCH64)\n   /*emit_insn (gen_rtx (USE, VOIDmode, frame_pointer_rtx));*/\n   emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n   /* Return, restoring reg window and jumping to goto handler.  */\n-  if (TARGET_V9 && GET_CODE (chain) == CONST_INT)\n+  if (TARGET_V9 && GET_CODE (chain) == CONST_INT\n+      && ! (INTVAL (chain) & ~(HOST_WIDE_INT)0xffffffff))\n     {\n-      emit_insn (gen_goto_handler_and_restore_v9 (static_chain_rtx, chain));\n+      emit_insn (gen_goto_handler_and_restore_v9 (labreg, static_chain_rtx,\n+\t\t\t\t\t\t  chain));\n       emit_barrier ();\n       DONE;\n     }\n   /* Put in the static chain register the nonlocal label address.  */\n   emit_move_insn (static_chain_rtx, chain);\n   emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n-  emit_insn (gen_goto_handler_and_restore ());\n+  emit_insn (gen_goto_handler_and_restore (labreg));\n   emit_barrier ();\n   DONE;\n }\")\n@@ -6029,20 +6034,31 @@ if (! TARGET_ARCH64)\n   [(set_attr \"type\" \"misc\")])\n \n (define_insn \"goto_handler_and_restore\"\n-  [(unspec_volatile [(reg:SI 8)] 2)]\n-  \"! TARGET_V9\"\n-  \"jmp %%o0+0\\;restore\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"=r\")] 2)]\n+  \"\"\n+  \"jmp %0+0\\;restore\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"goto_handler_and_restore_v9\"\n-  [(unspec_volatile [(reg:SI 8)\n-\t\t     (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t\t     (match_operand:SI 1 \"const_int_operand\" \"I,n\")] 3)]\n-  \"TARGET_V9\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"=r,r\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n+  \"TARGET_V9 && ! TARGET_ARCH64\"\n+  \"@\n+   return %0+0\\;mov %2,%Y1\n+   sethi %%hi(%2),%1\\;return %0+0\\;or %Y1,%%lo(%2),%Y1\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"2,3\")])\n+\n+(define_insn \"*goto_handler_and_restore_v9_sp64\"\n+  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t\t     (match_operand:DI 1 \"register_operand\" \"=r,r\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n+  \"TARGET_V9 && TARGET_ARCH64\"\n   \"@\n-   return %%o0+0\\;mov %1,%Y0\n-   sethi %%hi(%1),%0\\;return %%o0+0\\;or %Y0,%%lo(%1),%Y0\"\n+   return %0+0\\;mov %2,%Y1\n+   sethi %%hi(%2),%1\\;return %0+0\\;or %Y1,%%lo(%2),%Y1\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2,3\")])\n "}, {"sha": "7e90bdd4036dfa35ab9ea68b6ea92b2db4da974a", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6b402bb0e637381ec610a1a448237afaab48c/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=82d6b402bb0e637381ec610a1a448237afaab48c", "patch": "@@ -33,6 +33,16 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"svr4.h\"\n \n+/* ??? Put back the SIZE_TYPE/PTRDIFF_TYPE definitions set by sparc.h.\n+   Why, exactly, is svr4.h messing with this?  Seems like the chip \n+   would know best.  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (TARGET_ARCH64 ? \"long unsigned int\" : \"unsigned int\")\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (TARGET_ARCH64 ? \"long int\" : \"int\")\n+\n /* Undefined some symbols which are defined in \"svr4.h\" but which are\n    appropriate only for typical svr4 systems, but not for the specific\n    case of svr4 running on a Sparc.  */"}]}