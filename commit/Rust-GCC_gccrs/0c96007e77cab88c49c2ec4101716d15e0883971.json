{"sha": "0c96007e77cab88c49c2ec4101716d15e0883971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5NjAwN2U3N2NhYjg4YzQ5YzJlYzQxMDE3MTZkMTVlMDg4Mzk3MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "2000-04-25T23:16:20Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-04-25T23:16:20Z"}, "message": "Add partial support for IA-64 unwind sections.\n\n\t* config/ia64/crtbegin.asm: Add IA-64 unwind support.  Correct alloc\n\tand gp save/restore problems.\n\t* config/ia64/crtend.asm: Add IA-64 unwind support.\n\t* config/ia64/ia64.c (ia64_compute_frame_size): Don't include pr_size\n\tin fr_pad_size calculation.\n\t...\n\nCo-Authored-By: Andrew Haley <aph@cygnus.com>\nCo-Authored-By: Jim Wilson <wilson@cygnus.com>\n\nFrom-SVN: r33424", "tree": {"sha": "78e5d186b619a72ae72af8c80bdab781f4d07835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78e5d186b619a72ae72af8c80bdab781f4d07835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c96007e77cab88c49c2ec4101716d15e0883971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c96007e77cab88c49c2ec4101716d15e0883971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c96007e77cab88c49c2ec4101716d15e0883971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c96007e77cab88c49c2ec4101716d15e0883971/comments", "author": null, "committer": null, "parents": [{"sha": "7d7f30cfa079711cb56d1b48fa107c398af4f514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7f30cfa079711cb56d1b48fa107c398af4f514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d7f30cfa079711cb56d1b48fa107c398af4f514"}], "stats": {"total": 720, "additions": 652, "deletions": 68}, "files": [{"sha": "9ec11162b96e43131356dea41ef9eaf308e328f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -1,3 +1,33 @@\n+Tue Apr 25 16:16:04 2000  Andrew MacLeod  <amacleod@cygnus.com>\n+\t\t\t  Jim Wilson  <wilson@cygnus.com>\n+\t\t\t  Andrew Haley  <aph@cygnus.com>\n+\t\n+\t* config/ia64/crtbegin.asm: Add IA-64 unwind support.  Correct alloc\n+\tand gp save/restore problems.\n+\t* config/ia64/crtend.asm: Add IA-64 unwind support.\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Don't include pr_size\n+\tin fr_pad_size calculation.\n+\t(save_restore_insns): Move PR save area.  Correct uses of\n+ \tRTX_FRAME_RELATED_P.\n+\t(ia64_expand_prologue): Mark alloc with RTX_FRAME_RELATED_P.\n+\t(ia64_expand_epilogue): Add eh_epilogue support.\n+\t(ia64_function_prologue): Emit .prologue directive.\n+\t(ia64_init_machine_status, ia64_mark_machine_status): New functions.\n+\t(ia64_override_options): Set init_machine_status and\n+\tmark_machine_status.\n+\t(rtx_needs_barrier): Handle bsp reads and writes.\n+\t(spill_offset, sp_offset, spill_offset_emitted, tmp_reg, tmp_saved):\n+\tNew static variables.\n+\t(process_set, process_for_unwind_directive): New functions.\n+\t* config/ia64/ia64.h (ASM_OUTPUT_XDATA_CHAR, ASM_OUTPUT_XDATA_SHORT,\n+\tASM_OUTPUT_XDATA_INT, ASM_OUTPUT_XDATA_DOUBLE_INT, ASM_OUTPUT_EH_CHAR,\n+\tASM_OUTPUT_EH_SHORT, ASM_OUTPUT_EH_INT, ASM_OUTPUT_EH_DOUBLE_INT): New\n+\tmacros.\n+\t(EH_FRAME_SECTION_ASM_OP): Define to IA_64.unwind section.\n+\t(IA64_UNWIND_INFO, HANDLER_SECTION, IA64_UNWIND_EMIT): Define.\n+\t(struct machine_function): Define.\n+\t* config/ia64/ia64.md (bsp_value, set_bsp, eh_epilogue): New patterns.\n+\t\n 2000-04-25  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/Makefile.in: make the removal of old programs more"}, {"sha": "d44df5b16106be114530aba60f29a34b7490e30c", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 121, "deletions": 7, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -26,12 +26,17 @@ __CTOR_LIST__:\n __DTOR_LIST__:\n \tdata8\t-1\n \n+.section .IA_64.unwind\n+__EH_FRAME_BEGIN__:\n+\n .section .sdata\n+5:\tdata8\t@segrel(6f)\n \t.type dtor_ptr#,@object\n \t.size dtor_ptr#,8\n dtor_ptr:\n \tdata8\t__DTOR_LIST__# + 8\n \n+/* A handle for __cxa_finalize to manage c++ local destructors.  */\n \t.global __dso_handle#\n \t.type __dso_handle#,@object\n \t.size __dso_handle#,8\n@@ -45,6 +50,16 @@ __dso_handle:\n \tdata8\t0\n #endif\n \n+/* The frame object.  */\n+/* ??? How can we rationally keep this size correct?  */\n+\n+.section .bss\n+\t.type frame_object#,@object\n+\t.size frame_object#,56\n+\t.align 8\n+frame_object:\n+\t.zero 56\n+\n /*\n  * Fragment of the ELF _fini routine that invokes our dtor cleanup.\n  *\n@@ -65,38 +80,55 @@ __dso_handle:\n \t  ;;\n \t}\n \n-.text\n+/*\n+ * Fragment of the ELF _init routine that sets up the frame info.\n+ */\n+\n+.section .init,\"ax\",\"progbits\"\n+\t{ .mfb\n+\t  st8 [r12] = gp, -16\n+\t  br.call.sptk.many b0 = __do_frame_setup#\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  adds r12 = 16, r12\n+\t  ;;\n+\t  ld8 gp = [r12]\n+\t  ;;\n+\t}\n \n+.section .text\n \t.align\t16\n \t.proc\t__do_global_dtors_aux#\n-\n __do_global_dtors_aux:\n #ifndef SHARED\n \t{ .mii\n-\t  alloc loc2 = ar.pfs, 0, 3, 0, 0\n+\t  alloc loc3 = ar.pfs, 0, 4, 1, 0\n \t  addl loc0 = @gprel(dtor_ptr#), gp\n \t  mov loc1 = b0\n \t}\n+\tmov loc2 = gp\n #else\n \t/*\n \t\tif (__cxa_finalize)\n \t\t  __cxa_finalize(__dso_handle)\n \t*/\n \t{ .mii\n-\t  alloc loc2 = ar.pfs, 1, 3, 0, 0\n+\t  alloc loc3 = ar.pfs, 0, 4, 1, 0\n \t  addl loc0 = @gprel(dtor_ptr#), gp\n \t  addl r16 = @ltoff(@fptr(__cxa_finalize#)), gp\n \t  ;;\n \t}\n+\tmov loc2 = gp\n \t{ .mmi\n \t  ld8 r16 = [r16]\n \t  ;;\n-\t  addl r32 = @ltoff(__dso_handle#), gp\n+\t  addl out0 = @ltoff(__dso_handle#), gp\n \t  cmp.ne p7, p0 = r0, r16\n \t  ;;\n \t}\n \t{ .mmi\n-\t  ld8 r32 = [r32]\n+\t  ld8 out0 = [out0]\n (p7)\t  ld8 r18 = [r16], 8\n \t  mov loc1 = b0\n \t  ;;\n@@ -138,17 +170,99 @@ __do_global_dtors_aux:\n \t{ .mfb\n \t  cmp.ne p6, p0 = r0, r16\n (p6)\t  br.cond.sptk.few 0b\n+\t}\n+\tmov gp = loc2\n+\t;;\n+\t/*\n+\t\tif (__deregister_frame_info)\n+\t\t  __deregister_frame_info(__EH_FRAME_BEGIN__)\n+\t*/\n+\t{ .mii\n+\t  addl r16 = @ltoff(@fptr(__deregister_frame_info#)), gp\n+\t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  ld8 r16 = [r16]\n+\t  ld8 out0 = [out0]\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  cmp.ne p7, p0 = r0, r16\n+\t  ;;\n+(p7)\t  ld8 r18 = [r16], 8\n+\t  ;;\n+\t}\n+\t{ .mib\n+(p7)\t  ld8 gp = [r16]\n+(p7)\t  mov b6 = r18\n+(p7)\t  br.call.sptk.many b0 = b6\n \t}\n \t{ .mii\n \t  mov b0 = loc1\n-\t  mov ar.pfs = loc2\n+\t  mov ar.pfs = loc3\n \t}\n \t{ .bbb\n \t  br.ret.sptk.many b0\n \t  ;;\n \t}\n \t.endp\t__do_global_dtors_aux#\n \n+\t.proc\t__do_frame_setup#\n+__do_frame_setup:\n+\t/*\n+\t\tif (__register_frame_info)\n+\t\t  __register_frame_info(__EH_FRAME_BEGIN__)\n+\t*/\n+\t{ .mii\n+\t  alloc loc3 = ar.pfs, 0, 4, 2, 0\n+\t  addl r16 = @ltoff(@fptr(__register_frame_info#)), gp\n+\t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n+\t  ;;\n+\t}\n+\taddl out1 = @ltoff(frame_object#), gp\n+\t;;\n+\t/* frame_object.pc_base = segment_base_offset;\n+\t      pc_base is at offset 0 within frame_object.  */\n+6:\n+\tmov loc0 = ip\n+\taddl loc1 = @gprel(5b), gp\n+\t;;\n+\tld8 loc1 = [loc1]\n+\tld8 out1 = [out1]\n+\t;;\n+\tsub loc2 = loc0, loc1\n+\t;;\n+\tst8 [out1] = loc2\n+\t{ .mmi\n+\t  ld8 r16 = [r16]\n+\t  ld8 out0 = [out0]  \n+\t  mov loc0 = b0\n+\t  ;;\n+\t}\n+\t{ .mmi\n+\t  cmp.ne p7, p0 = r0, r16\n+\t  ;;\n+(p7)\t  ld8 r18 = [r16], 8\n+\t  ;;\n+\t}\n+\t{ .mib\n+(p7)\t  ld8 gp = [r16]\n+(p7)\t  mov b6 = r18\n+(p7)\t  br.call.sptk.many b0 = b6\n+\t}\n+\t{ .mii\n+\t  mov b0 = loc0\n+\t  mov ar.pfs = loc3\n+\t}\n+\t{ .bbb\n+\t  br.ret.sptk.many b0\n+\t  ;;\n+\t}\n+\t.endp\t__do_frame_setup#\n+\n #ifdef SHARED\n .weak __cxa_finalize#\n #endif\n+.weak __deregister_frame_info#\n+.weak __register_frame_info#"}, {"sha": "208c469c9dbeb680a536a36e2c3858133388ba7e", "filename": "gcc/config/ia64/crtend.asm", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -26,6 +26,10 @@ __CTOR_END__:\n __DTOR_END__:\n \tdata8\t0\n \n+.section .IA_64.unwind\n+__EH_FRAME_END__:\n+\tdata8\t-1\n+\n /*\n  * Fragment of the ELF _init routine that invokes our dtor cleanup.\n  *"}, {"sha": "dbc89d7dfb77dec5393f27b10c7244bc1f843755", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 361, "deletions": 60, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -567,7 +567,7 @@ ia64_compute_frame_size (size)\n   /* The FR save area needs to be 16-byte aligned.  */\n   if (fr_size)\n     {\n-      tmp = (size + fr_size + pr_size + br_size);\n+      tmp = (size + fr_size + br_size);\n       fr_pad_size = IA64_STACK_ALIGN (tmp) - tmp;\n     }\n   else\n@@ -653,14 +653,36 @@ save_restore_insns (save_p)\n \t{\n \t  offset_rtx = tmp_reg;\n \t  insn = emit_insn (gen_movdi (tmp_reg, GEN_INT (offset)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  if (save_p)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       insn = emit_insn (gen_adddi3 (tmp_reg,\n \t\t\t\t    (frame_pointer_needed ? frame_pointer_rtx\n \t\t\t\t     : stack_pointer_rtx),\n \t\t\t\t    offset_rtx));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (save_p)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n \n+      /* If one is used, we save/restore all of them.  */\n+      for (regno = PR_REG (0); regno <= PR_REG (63); regno++)\n+\tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n+\t  {\n+\t    rtx mem = gen_rtx_MEM (DImode, tmp_post_inc);\n+\t    if (save_p)\n+\t      {\n+\t\tinsn = emit_insn (gen_pr_spill (tmp2_reg));\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t\tinsn = emit_insn (gen_movdi (mem, tmp2_reg));\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t      }\n+\t    else\n+\t      {\n+\t\tinsn = emit_insn (gen_movdi (tmp2_reg, mem));\n+\t\tinsn = emit_insn (gen_pr_restore (tmp2_reg));\n+\t      }\n+\t    break;\n+\t  }\n+\t\t\n       /* Must save/restore ar.unat if any GR is spilled/restored.  */\n       if (current_frame_info.gr_size != 0\n \t  || current_function_varargs || current_function_stdarg)\n@@ -669,18 +691,21 @@ save_restore_insns (save_p)\n \t  if (save_p)\n \t    {\n \t      insn = emit_insn (gen_unat_spill (tmp2_reg));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (save_p)\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n \t      insn = emit_insn (gen_movdi (mem, tmp2_reg));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (save_p)\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    {\n \t      insn = emit_insn (gen_movdi (tmp2_reg, mem));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (save_p)\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n \t      /* The restore happens after the last ld8.fill instruction.  */\n \t    }\n \t}\n-\n+\t\n       for (regno = GR_REG (0); regno <= GR_REG (127); regno++)\n \tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n \t  {\n@@ -691,7 +716,8 @@ save_restore_insns (save_p)\n \t    else\n \t      insn = emit_insn (gen_gr_restore (gen_rtx_REG (DImode, regno),\n \t\t\t\t\t\tmem));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    if (save_p)\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n \n       /* Now restore the unat register if necessary.  */\n@@ -710,31 +736,10 @@ save_restore_insns (save_p)\n \t    else\n \t      insn = emit_insn (gen_fr_restore (gen_rtx_REG (XFmode, regno),\n \t\t\t\t\t\tmem));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t  }\n-\n-      /* If one is used, we save/restore all of them.  */\n-      for (regno = PR_REG (0); regno <= PR_REG (63); regno++)\n-\tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n-\t  {\n-\t    rtx mem = gen_rtx_MEM (DImode, tmp_post_inc);\n \t    if (save_p)\n-\t      {\n-\t\tinsn = emit_insn (gen_pr_spill (tmp2_reg));\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t\tinsn = emit_insn (gen_movdi (mem, tmp2_reg));\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t      }\n-\t    else\n-\t      {\n-\t\tinsn = emit_insn (gen_movdi (tmp2_reg, mem));\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t\tinsn = emit_insn (gen_pr_restore (tmp2_reg));\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t      }\n-\t    break;\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n-\t\t\t\t\t     \n+\t\t     \n       for (regno = BR_REG (0); regno <= BR_REG (7); regno++)\n \tif (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n \t  {\n@@ -752,9 +757,11 @@ save_restore_insns (save_p)\n \t      }\n \n \t    insn = emit_insn (gen_movdi (tmp2_reg, src));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    if (save_p)\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    insn = emit_insn (gen_movdi (dest, tmp2_reg));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    if (save_p)\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n     }\n }\n@@ -933,9 +940,10 @@ ia64_expand_prologue ()\n       ia64_need_regstk = 0;\n       ia64_arpfs_regno = LOC_REG (locals - 1);\n \n-      emit_insn (gen_alloc (gen_rtx_REG (DImode, ia64_arpfs_regno),\n-\t\t\t    GEN_INT (inputs), GEN_INT (locals),\n-\t\t\t    GEN_INT (outputs), GEN_INT (rotates)));\n+      insn = emit_insn (gen_alloc (gen_rtx_REG (DImode, ia64_arpfs_regno),\n+\t\t\t\t   GEN_INT (inputs), GEN_INT (locals),\n+\t\t\t\t   GEN_INT (outputs), GEN_INT (rotates)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n \n       /* Emit a save of BR_REG (0) if we call other functions.\n \t Do this even if this function doesn't return, as EH\n@@ -1020,32 +1028,38 @@ ia64_expand_epilogue ()\n      pointer updates anti-dependent on them.  */\n   emit_insn (gen_blockage ());\n \n-  if (frame_pointer_needed)\n+  if (cfun->machine->ia64_eh_epilogue_sp == NULL_RTX)\n     {\n-      /* If there is a frame pointer, then we need to make the stack pointer\n-\t restore depend on the frame pointer, so that the stack pointer\n-\t restore won't be moved up past fp-relative loads from the frame.  */\n-      emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n-\t\t\t\t\t\thard_frame_pointer_rtx));\n-    }\n-  else\n-    {\n-      int frame_size = current_frame_info.total_size;\n-      rtx offset;\n+    if (frame_pointer_needed)\n+      {\n+\t/* If there is a frame pointer, then we need to make the stack pointer\n+\t   restore depend on the frame pointer, so that the stack pointer\n+\t   restore won't be moved up past fp-relative loads from the frame.  */\n+\temit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,\n+\t\t\t\t\t\t  hard_frame_pointer_rtx));\n+      }\n+    else\n+      {\n+\tint frame_size = current_frame_info.total_size;\n+\trtx offset;\n \n-      if (frame_size != 0)\n-\t{\n-\t  if (CONST_OK_FOR_I (frame_size))\n-\t    offset = GEN_INT (frame_size);\n-\t  else\n-\t    {\n-\t      offset = gen_rtx_REG (DImode, GR_REG (2));\n-\t      emit_insn (gen_movdi (offset, GEN_INT (frame_size)));\n-\t    }\n-\t  emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t offset));\n-\t}\n+\tif (frame_size != 0)\n+\t  {\n+\t    if (CONST_OK_FOR_I (frame_size))\n+\t      offset = GEN_INT (frame_size);\n+\t    else\n+\t      {\n+\t\toffset = gen_rtx_REG (DImode, GR_REG (2));\n+\t\temit_insn (gen_movdi (offset, GEN_INT (frame_size)));\n+\t      }\n+\t    emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   offset));\n+\t  }\n+      }\n     }\n+    /* Return via eh_epilogue, so we already have our new stack pointer.  */\n+  else\n+    emit_insn (gen_movdi (stack_pointer_rtx, cfun->machine->ia64_eh_epilogue_sp));\n \n   if (ia64_arpfs_regno)\n     emit_insn (gen_pfs_restore (gen_rtx_REG (DImode, ia64_arpfs_regno)));\n@@ -1054,6 +1068,11 @@ ia64_expand_epilogue ()\n     emit_move_insn (gen_rtx_REG (DImode, BR_REG (0)),\n \t\t    gen_rtx_REG (DImode, ia64_rp_regno));\n \n+  if (cfun->machine->ia64_eh_epilogue_bsp != NULL_RTX)\n+    {\n+      /* We have to restore the bsp.  */\n+      emit_insn (gen_set_bsp (cfun->machine->ia64_eh_epilogue_bsp));\n+    }\n   emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n }\n \n@@ -1064,10 +1083,39 @@ ia64_function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n+  rtx insn;\n   if (ia64_need_regstk)\n     fprintf (file, \"\\t.regstk %d, 0, 0, 0\\n\", ia64_input_regs);\n \n-  /* ??? Emit .body directive.  GNU as ignores .body currently.  */\n+  if (!flag_unwind_tables && (!flag_exceptions || exceptions_via_longjmp))\n+    return;\n+\n+  /* Emit the .prologue directive. in order to do this, we need to find\n+     where the stack pointer is moved toa GR, if it is, and mark it.  */\n+  \n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    {\n+      if (RTX_FRAME_RELATED_P (insn) && GET_CODE (insn) == INSN)\n+        {\n+\t  rtx pat = PATTERN (insn);\n+\t  if (GET_CODE (pat) == SET)\n+\t    {\n+\t      rtx dest = SET_DEST (pat);\n+\t      rtx src = SET_SRC (pat);\n+\t      if (GET_CODE (src) == REG && REGNO (src) == STACK_POINTER_REGNUM\n+\t\t  && GET_CODE (dest) == REG)\n+\t\t{\n+\t\t  int reg = REGNO (dest);\n+\t\t  if (REGNO (dest) == FRAME_POINTER_REGNUM)\n+\t\t    reg = ia64_fp_regno;\n+\t\t  fprintf (file, \"\\t.prologue 0x2, %d\\n\", reg);\n+\t\t  break;\n+\t\t}\n+\t    }\n+        }\n+    }\n+  if (insn == NULL_RTX)\n+    fprintf (file, \"\\t.prologue\\n\");\n }\n \n /* Emit the function epilogue.  */\n@@ -1987,6 +2035,23 @@ ia64_add_gc_roots ()\n   ggc_add_rtx_root (&ia64_compare_op1, 1);\n }\n \n+static void\n+ia64_init_machine_status (p)\n+     struct function *p;\n+{\n+  p->machine =\n+    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n+}\n+\n+static void\n+ia64_mark_machine_status (p)\n+     struct function *p;\n+{\n+  ggc_mark_rtx (p->machine->ia64_eh_epilogue_sp);\n+  ggc_mark_rtx (p->machine->ia64_eh_epilogue_bsp);\n+}\n+\n+\n /* Handle TARGET_OPTIONS switches.  */\n \n void\n@@ -1997,6 +2062,9 @@ ia64_override_options ()\n \n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n+  init_machine_status = ia64_init_machine_status;\n+  mark_machine_status = ia64_mark_machine_status;\n+\n   ia64_add_gc_roots ();\n }\n \f\n@@ -2445,6 +2513,9 @@ rtx_needs_barrier (x, flags, pred)\n           break;\n         case 19: /* fetchadd_acq */\n           break;\n+\tcase 20: /* mov = ar.bsp */\n+          break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -2485,6 +2556,10 @@ rtx_needs_barrier (x, flags, pred)\n \t    need_barrier |= rws_access_reg (i, new_flags, pred);\n \t  break;\n \n+\tcase 5: /* set_bsp  */\n+\t  need_barrier = 1;\n+          break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -2749,6 +2824,232 @@ ia64_encode_section_info (decl)\n \t}\n     }\n }\n+\f\n+/* Output assmebly directives for prologue regions.  */\n+\n+static int spill_offset;\n+static int sp_offset;\n+static int spill_offset_emitted = 1;\n+static rtx tmp_reg = NULL_RTX;\n+static int tmp_saved = -1;\n+\n+\n+/* This function processes a SET pattern looking for specific patterns\n+   which result in emitting an assembly directive required for unwinding.  */\n+static int\n+process_set (asm_out_file, pat)\n+     FILE *asm_out_file;\n+     rtx pat;\n+{\n+  rtx src = SET_SRC (pat);\n+  rtx dest = SET_DEST (pat);\n+  static rtx frame_reg = NULL_RTX;\n+  static int frame_size = 0;\n+\n+  /* Look for the ALLOC insn.  reg = alloc .... */\n+  if (GET_CODE (src) == UNSPEC_VOLATILE && XINT (src, 1) == 0\n+      && GET_CODE (dest) == REG && GR_REGNO_P (REGNO (dest)))\n+    {\n+      /* Assume this is a stack allocate insn.  */\n+      fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\", \n+\t       REGNO (dest) + ia64_input_regs);\n+      return 1;\n+    }\n+\n+  /* look for SP = .... */\n+  if (GET_CODE (dest) == REG && REGNO (dest) == STACK_POINTER_REGNUM)\n+    {\n+      if (GET_CODE (src) == PLUS)\n+        {\n+\t  rtx op0 = XEXP (src, 0);\n+\t  rtx op1 = XEXP (src, 1);\n+\t  if (op0 == dest && GET_CODE (op1) == CONST_INT)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t.fframe %d\\n\", -INTVAL (op1));\n+\t      frame_size = INTVAL (op1);\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    if (op0 == dest && GET_CODE (op1) == REG)\n+\t     {\n+\t\tfprintf (asm_out_file, \"\\t.vframe r%d\\n\", REGNO (op1));\n+\t        frame_size = 0;\n+\t\treturn 1;\n+\t     }\n+\t}\n+    }\n+  /* Look for a frame offset.  */\n+  if (GET_CODE (dest) == REG)\n+    {\n+      if (GET_CODE (src) == PLUS)\n+        {\n+\t  rtx op0 = XEXP (src, 0);\n+\t  rtx op1 = XEXP (src, 1);\n+\t  if (GET_CODE (op0) == REG && REGNO (op0) == FRAME_POINTER_REGNUM\n+\t      && GET_CODE (op1) == CONST_INT)\n+\t    {\n+\t      sp_offset = -frame_size + INTVAL (op1);\n+\t      spill_offset = INTVAL (op1);\n+\t      spill_offset_emitted = 0;\n+\t      frame_reg = dest;\n+\t      /* We delay issuing the spill offset since we might\n+\t\t be saving non-spill things off this register,\n+\t\t thus adjusting its offset before a spill is seen.  */\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Register move we need to look at.  */\n+  if (GET_CODE (dest) == REG && GET_CODE (src) == REG)\n+    {\n+      int regno = REGNO (src);\n+      if (BR_REGNO_P (regno))\n+        {\n+\t  /* Saving return address pointer.  */\n+\t  if (regno == BR_REG (0))\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t.save rp, r%d\\n\", \n+\t\t       REGNO (dest) + ia64_input_regs);\n+\t      return 1;\n+\t    }\n+\t  /* If its br1 to br5, we copy them to temp regs, then save the\n+\t     temp reg to memory next.  */\n+\t  if (regno >= BR_REG (1) && regno <= BR_REG (5))\n+\t    {\n+\t      tmp_reg = dest;\n+\t      tmp_saved = regno;\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+  /* Search for special reg moves.  */\n+  if (GET_CODE (dest) == REG && GET_CODE (src) == UNSPEC)\n+    {\n+      int unspec_code = XINT (src, 1);\n+      /* Copied to a temp register, save it until we see the temp\n+\t register stored.  */\n+      if (unspec_code == 5 || unspec_code == 9)\n+\t{\n+\t  tmp_reg = dest;\n+\t  tmp_saved = unspec_code;\n+\t  return 1;\n+\t}\n+    }\n+  if (GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == POST_INC \n+      && GET_CODE (XEXP (XEXP (dest, 0), 0)) == REG)\n+    {\n+      int spill_unspec = 0;\n+      /* We adjust the spill_offset early, so we dont miss it later.  */\n+      spill_offset += 8;  \n+      sp_offset += 8;  \n+      if (GET_CODE (src) == UNSPEC)\n+\t{\n+\t  spill_unspec = XINT (src, 1);\n+\t  /* 1 and 3 are unspecs for the GR and FR spills.  */\n+\t  if (spill_unspec != 1 && spill_unspec != 3)\n+\t    spill_unspec = 0;\n+\t}\n+      /* ST8 or st8.spill insn.  */\n+      if ((GET_CODE (src) == REG) || spill_unspec != 0)\n+        {\n+\t  int regno;\n+\t  if (spill_unspec != 0)\n+\t    {\n+\t      regno = REGNO (XVECEXP (src, 0, 0));\n+\t      if (!spill_offset_emitted)\n+\t        {\n+\t\t  fprintf (asm_out_file, \"\\t.spill %d\\n\", \n+/*\t\t\t   (frame_size + 16 - spill_offset ) / 4); */\n+\t\t\t   (-(spill_offset - 8) + 16) / 4);\n+\t\t  spill_offset_emitted = 1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    regno = REGNO (src);\n+\n+          if (GR_REGNO_P (regno))\n+\t    {\n+\t      if (regno >= GR_REG (4) && regno <= GR_REG (7))\n+\t\tfprintf (asm_out_file, \"\\t.save.g 0x%x\\n\", \n+\t\t\t 1 << (regno - GR_REG (4)));\n+\t      else if (tmp_reg != NULL_RTX && regno == REGNO (tmp_reg))\n+\t        {\n+\t\t  /* We saved a special reg to a temp reg, and now we're \n+\t\t     dumping it to memory.  */\n+\t\t  tmp_reg = NULL_RTX;\n+\t\t  /* register 9 is ar.unat.  */\n+\t\t  if (tmp_saved == 9)\n+\t\t    fprintf (asm_out_file, \"\\t.savesp ar.unat, %d\\n\", \n+\t\t\t     (sp_offset - 8) / 4);\n+\t\t  else if (tmp_saved == 5)\n+\t\t    fprintf (asm_out_file, \"\\t.savesp pr, %d\\n\",\n+\t\t\t     (sp_offset - 8) / 4);\n+\t\t  else if (tmp_saved >= BR_REG (1) && tmp_saved <= BR_REG (5))\n+\t\t    {\n+\t\t      /* BR regs are saved this way too.  */\n+\t\t      fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\", \n+\t\t\t       1 << (tmp_saved - BR_REG (1)));\n+\t\t    }\n+\t\t}\n+\t      else \n+\t        return 0;\n+\t    }\n+\t  if (FR_REGNO_P (regno))\n+\t    {\n+\t      if (regno >= FR_REG (2) && regno <= FR_REG (5))\n+\t\tfprintf (asm_out_file, \"\\t.save.f 0x%x\\n\", \n+\t\t\t 1 << (regno - FR_REG (2)));\n+\t      else\n+\t\tif (regno >= FR_REG (16) && regno <= FR_REG (31))\n+\t\t  fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\", \n+\t\t\t   1 << (regno - FR_REG (12)));\n+\t\telse \n+\t\t  return 0;\n+\t    }\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* This function looks at a single insn and emits any directives\n+   required to unwind this insn.  */\n+void\n+process_for_unwind_directive (asm_out_file, insn)\n+     FILE *asm_out_file;\n+     rtx insn;\n+{\n+  if ((flag_unwind_tables \n+       || (flag_exceptions && !exceptions_via_longjmp))\n+      && RTX_FRAME_RELATED_P (insn))\n+    {\n+      rtx code, pat;\n+      pat = PATTERN (insn);\n+\n+      switch (GET_CODE (pat))\n+        {\n+\t  case SET:\n+\t    {\n+\t      process_set (asm_out_file, pat);\n+\t      break;\n+\t    }\n+\t  case PARALLEL:\n+\t    {\n+\t      int par_index;\n+\t      int limit = XVECLEN (pat, 0);\n+\t      for (par_index = 0; par_index < limit; par_index++)\n+\t        {\n+\t\t  rtx x = XVECEXP (pat, 0, par_index);\n+\t\t  if (GET_CODE (x) == SET)\n+\t\t    process_set (asm_out_file, x);\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n \n #define def_builtin(name, type, code) \\\n   builtin_function ((name), (type), (code), BUILT_IN_MD, NULL_PTR)"}, {"sha": "be921f958b45a72ff10f9a7198c2a4b848028114", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -2115,6 +2115,71 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n } while (0)\n \n+/* This is how to output an assembler line defining a `char' constant\n+   to an xdata segment.  */\n+\n+#define ASM_OUTPUT_XDATA_CHAR(FILE, SECTION, VALUE)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.xdata1\\t\\\"%s\\\", \", SECTION);\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `short' constant\n+   to an xdata segment.  */\n+\n+#define ASM_OUTPUT_XDATA_SHORT(FILE, SECTION, VALUE)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.xdata2\\t\\\"%s\\\", \", SECTION);\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant\n+   to an xdata segment.  We also handle symbol output here.  */\n+\n+/* ??? For ILP32, also need to handle function addresses here.  */\n+\n+#define ASM_OUTPUT_XDATA_INT(FILE, SECTION, VALUE)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.xdata4\\t\\\"%s\\\", \", SECTION);\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `long' constant\n+   to an xdata segment.  We also handle symbol output here.  */\n+\n+#define ASM_OUTPUT_XDATA_DOUBLE_INT(FILE, SECTION, VALUE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.xdata8\\t\\\"%s\\\", \", SECTION);\t\t\t\\\n+  if (GET_CODE (VALUE) == SYMBOL_REF)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (SYMBOL_REF_FLAG (VALUE))\t\t\t\t\t\\\n+\tfprintf (FILE, \"@fptr(\");\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"@segrel(\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n+  if (GET_CODE (VALUE) == SYMBOL_REF)\t\t\t\t\t\\\n+    fprintf (FILE, \")\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+\n+/* Output EH data to the unwind segment. */\n+#define ASM_OUTPUT_EH_CHAR(FILE, VALUE)\t\t\t\t\t\\\n+\t\tASM_OUTPUT_XDATA_CHAR(FILE, \".IA_64.unwind_info\", VALUE)\n+\n+#define ASM_OUTPUT_EH_SHORT(FILE, VALUE)\t\t\t\t\\\n+\t\tASM_OUTPUT_XDATA_SHORT(FILE, \".IA_64.unwind_info\", VALUE)\n+\n+#define ASM_OUTPUT_EH_INT(FILE, VALUE)\t\t\t\t\t\\\n+\t\tASM_OUTPUT_XDATA_INT(FILE, \".IA_64.unwind_info\", VALUE)\n+\n+#define ASM_OUTPUT_EH_DOUBLE_INT(FILE, VALUE)\t\t\t\t\\\n+\t\tASM_OUTPUT_XDATA_DOUBLE_INT(FILE, \".IA_64.unwind_info\", VALUE)\n+\n /* A C statement to output to the stdio stream STREAM an assembler instruction\n    to assemble a single byte containing the number VALUE.  */\n \n@@ -2453,7 +2518,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n    You should define this symbol if your target supports DWARF 2 frame unwind\n    information and the default definition does not work.  */\n-/* #define EH_FRAME_SECTION_ASM_OP */\n+#define EH_FRAME_SECTION_ASM_OP \".section\\t.IA_64.unwind,\\\"aw\\\"\"\n \n /* A C expression that is nonzero if the normal exception table output should\n    be omitted.\n@@ -2739,6 +2804,21 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ISSUE_RATE 3\n \n+#define IA64_UNWIND_INFO\t1\n+#define HANDLER_SECTION fprintf (asm_out_file, \"\\t.personality\\t__ia64_personality_v1\\n\\t.handlerdata\\n\");\n+#define IA64_UNWIND_EMIT(f,i)\tprocess_for_unwind_directive (f,i)\n+\n+/* This function contains machine specific function data.  */\n+struct machine_function\n+{\n+  /* The new stack pointer when unwinding from EH.  */\n+  struct rtx_def* ia64_eh_epilogue_sp;\n+\n+  /* The new bsp value when unwinding from EH. */\n+  struct rtx_def* ia64_eh_epilogue_bsp;\n+};\n+\n+\n enum ia64_builtins\n {\n   IA64_BUILTIN_SYNCHRONIZE,"}, {"sha": "e9ef493ecdd1f563bfeff7ea58d5382b2be5b5df", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c96007e77cab88c49c2ec4101716d15e0883971/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=0c96007e77cab88c49c2ec4101716d15e0883971", "patch": "@@ -3083,6 +3083,33 @@\n   \"mov ar.unat = %0\"\n   [(set_attr \"type\" \"M\")])\n \n+(define_insn \"bsp_value\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(const_int 0)] 20))]\n+  \"\"\n+  \"mov %0 = ar.bsp\"\n+  [(set_attr \"type\" \"I\")])\n+\n+(define_insn \"set_bsp\"\n+  [(unspec_volatile [(const_int 0)] 5)\n+   (use (match_operand:DI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"flushrs\\;\t\t\t\\\n+   mov r19=ar.rsc\\;\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   and r19=0x1c,r19\\;\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   mov ar.rsc=r19\\;\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   mov ar.bspstore=%0\\;\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   or r19=0x3,r19\\;\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   loadrs\\;\t\t\t\\\n+   invala\\;\t\t\t\\\n+   ;;\\;\t\t\t\t\\\n+   mov ar.rsc=r19\\;\"\n+  [(set_attr \"type\" \"I\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3166,6 +3193,34 @@\n   DONE;\n }\")\n \n+(define_expand \"eh_epilogue\"\n+  [(use (match_operand:DI 0 \"register_operand\" \"r\"))\n+   (use (match_operand:DI 1 \"register_operand\" \"r\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"\n+{\n+  rtx bsp = gen_rtx_REG (Pmode, 10);\n+  rtx sp = gen_rtx_REG (Pmode, 9);\n+\n+  if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) != 10)\n+    {\n+      emit_move_insn (bsp, operands[0]);\n+      operands[0] = bsp;\n+    }\n+  if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 9)\n+    {\n+      emit_move_insn (sp, operands[2]);\n+      operands[2] = sp;\n+    }\n+  emit_insn (gen_rtx_USE (VOIDmode, sp));\n+  emit_insn (gen_rtx_USE (VOIDmode, bsp));\n+\n+  cfun->machine->ia64_eh_epilogue_sp = sp;\n+  cfun->machine->ia64_eh_epilogue_bsp = bsp;\n+\n+}\")\n+\n ;; This flushes at least 64 bytes starting from the address pointed\n ;; to by operand[0].\n "}]}