{"sha": "5a153b2787e167cb9f065e6fd91424b0475b2790", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWExNTNiMjc4N2UxNjdjYjlmMDY1ZTZmZDkxNDI0YjA0NzViMjc5MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:35:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:35:58Z"}, "message": "[multiple changes]\n\n2010-06-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch9.adb, checks.adb, sem_util.adb, sem_util.ads, sem_res.adb,\n\tsem_attr.adb (Get_E_First_Or_Last): Use attribute references on E to\n\textract bounds, to ensure that we get the proper captured values,\n\trather than an expression that may have changed value since the point\n\twhere the subtype was elaborated.\n\t(Find_Body_Discriminal): New utility subprogram to share code between...\n\t(Eval_Attribute): For the case of a subtype bound that references a\n\tdiscriminant of the current concurrent type, insert appropriate\n\tdiscriminal reference.\n\t(Resolve_Entry.Actual_Index_Type.Actual_Discriminant_Ref): For a\n\trequeue to an entry in a family in the current task, use corresponding\n\tbody discriminal. \n\t(Analyze_Accept_Statement): Rely on expansion of attribute references\n\tto insert proper discriminal references in range check for entry in\n\tfamily.\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb (Compile): Fix handling of big patterns.\n\n2010-06-21  Robert Dewar  <dewar@adacore.com>\n\n\t* a-tifiio.adb: Minor reformatting.\n\nFrom-SVN: r161076", "tree": {"sha": "785d0e17bdbe412c5fe6f2c81b39566c3706c168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/785d0e17bdbe412c5fe6f2c81b39566c3706c168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a153b2787e167cb9f065e6fd91424b0475b2790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a153b2787e167cb9f065e6fd91424b0475b2790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a153b2787e167cb9f065e6fd91424b0475b2790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a153b2787e167cb9f065e6fd91424b0475b2790/comments", "author": null, "committer": null, "parents": [{"sha": "008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5"}], "stats": {"total": 356, "additions": 154, "deletions": 202}, "files": [{"sha": "30a6f602dbfce328faea85cfc6e8ed3b34248601", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -1,3 +1,29 @@\n+2010-06-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch9.adb, checks.adb, sem_util.adb, sem_util.ads, sem_res.adb,\n+\tsem_attr.adb (Get_E_First_Or_Last): Use attribute references on E to\n+\textract bounds, to ensure that we get the proper captured values,\n+\trather than an expression that may have changed value since the point\n+\twhere the subtype was elaborated.\n+\t(Find_Body_Discriminal): New utility subprogram to share code between...\n+\t(Eval_Attribute): For the case of a subtype bound that references a\n+\tdiscriminant of the current concurrent type, insert appropriate\n+\tdiscriminal reference.\n+\t(Resolve_Entry.Actual_Index_Type.Actual_Discriminant_Ref): For a\n+\trequeue to an entry in a family in the current task, use corresponding\n+\tbody discriminal. \n+\t(Analyze_Accept_Statement): Rely on expansion of attribute references\n+\tto insert proper discriminal references in range check for entry in\n+\tfamily.\n+\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb (Compile): Fix handling of big patterns.\n+\n+2010-06-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-tifiio.adb: Minor reformatting.\n+\n 2010-06-21  Pascal Obry  <obry@adacore.com>\n \n \t* prj-nmsc.adb (Search_Directories): Use the non-translated directory"}, {"sha": "82aeb8a83e6632b3264d2919b3ab538bfcecae54", "filename": "gcc/ada/a-tifiio.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -304,7 +304,7 @@ package body Ada.Text_IO.Fixed_IO is\n       Fore : Integer;\n       Aft  : Field;\n       Exp  : Field);\n-   --  Actual output function, used internally by all other Put routines\n+   --  Actual output function, used internally by all other Put routines.\n    --  The formal Fore is an Integer, not a Field, because the routine is\n    --  also called from the version of Put that performs I/O to a string,\n    --  where the starting position depends on the size of the String, and"}, {"sha": "ebe6e5ade69996c6dfd8825c26a74f142a41b2ff", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 42, "deletions": 119, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -6249,7 +6249,8 @@ package body Checks is\n       --    Expr > Typ'Last\n \n       function Get_E_First_Or_Last\n-        (E    : Entity_Id;\n+        (Loc  : Source_Ptr;\n+         E    : Entity_Id;\n          Indx : Nat;\n          Nam  : Name_Id) return Node_Id;\n       --  Returns expression to compute:\n@@ -6320,7 +6321,7 @@ package body Checks is\n                      Duplicate_Subexpr_No_Checks (Expr)),\n                  Right_Opnd =>\n                    Convert_To (Base_Type (Typ),\n-                               Get_E_First_Or_Last (Typ, 0, Name_First))),\n+                               Get_E_First_Or_Last (Loc, Typ, 0, Name_First))),\n \n              Right_Opnd =>\n                Make_Op_Gt (Loc,\n@@ -6330,7 +6331,7 @@ package body Checks is\n                  Right_Opnd =>\n                    Convert_To\n                      (Base_Type (Typ),\n-                      Get_E_First_Or_Last (Typ, 0, Name_Last))));\n+                      Get_E_First_Or_Last (Loc, Typ, 0, Name_Last))));\n       end Discrete_Expr_Cond;\n \n       -------------------------\n@@ -6368,7 +6369,8 @@ package body Checks is\n \n              Right_Opnd =>\n                Convert_To\n-                 (Base_Type (Typ), Get_E_First_Or_Last (Typ, 0, Name_First)));\n+                 (Base_Type (Typ),\n+                  Get_E_First_Or_Last (Loc, Typ, 0, Name_First)));\n \n          if Base_Type (Typ) = Typ then\n             return Left_Opnd;\n@@ -6403,7 +6405,7 @@ package body Checks is\n              Right_Opnd =>\n                Convert_To\n                  (Base_Type (Typ),\n-                  Get_E_First_Or_Last (Typ, 0, Name_Last)));\n+                  Get_E_First_Or_Last (Loc, Typ, 0, Name_Last)));\n \n          return Make_Or_Else (Loc, Left_Opnd, Right_Opnd);\n       end Discrete_Range_Cond;\n@@ -6413,115 +6415,23 @@ package body Checks is\n       -------------------------\n \n       function Get_E_First_Or_Last\n-        (E    : Entity_Id;\n+        (Loc  : Source_Ptr;\n+         E    : Entity_Id;\n          Indx : Nat;\n          Nam  : Name_Id) return Node_Id\n       is\n-         N     : Node_Id;\n-         LB    : Node_Id;\n-         HB    : Node_Id;\n-         Bound : Node_Id;\n-\n+         Exprs : List_Id;\n       begin\n-         if Is_Array_Type (E) then\n-            N := First_Index (E);\n-\n-            for J in 2 .. Indx loop\n-               Next_Index (N);\n-            end loop;\n-\n+         if Indx > 0 then\n+            Exprs := New_List (Make_Integer_Literal (Loc, UI_From_Int (Indx)));\n          else\n-            N := Scalar_Range (E);\n+            Exprs := No_List;\n          end if;\n \n-         if Nkind (N) = N_Subtype_Indication then\n-            LB := Low_Bound (Range_Expression (Constraint (N)));\n-            HB := High_Bound (Range_Expression (Constraint (N)));\n-\n-         elsif Is_Entity_Name (N) then\n-            LB := Type_Low_Bound  (Etype (N));\n-            HB := Type_High_Bound (Etype (N));\n-\n-         else\n-            LB := Low_Bound  (N);\n-            HB := High_Bound (N);\n-         end if;\n-\n-         if Nam = Name_First then\n-            Bound := LB;\n-         else\n-            Bound := HB;\n-         end if;\n-\n-         if Nkind (Bound) = N_Identifier\n-           and then Ekind (Entity (Bound)) = E_Discriminant\n-         then\n-            --  If this is a task discriminant, and we are the body, we must\n-            --  retrieve the corresponding body discriminal. This is another\n-            --  consequence of the early creation of discriminals, and the\n-            --  need to generate constraint checks before their declarations\n-            --  are made visible.\n-\n-            if Is_Concurrent_Record_Type (Scope (Entity (Bound)))  then\n-               declare\n-                  Tsk : constant Entity_Id :=\n-                          Corresponding_Concurrent_Type\n-                           (Scope (Entity (Bound)));\n-                  Disc : Entity_Id;\n-\n-               begin\n-                  if In_Open_Scopes (Tsk)\n-                    and then Has_Completion (Tsk)\n-                  then\n-                     --  Find discriminant of original task, and use its\n-                     --  current discriminal, which is the renaming within\n-                     --  the task body.\n-\n-                     Disc := First_Discriminant (Tsk);\n-                     while Present (Disc) loop\n-                        if Chars (Disc) = Chars (Entity (Bound)) then\n-                           Set_Scope (Discriminal (Disc), Tsk);\n-                           return New_Occurrence_Of (Discriminal (Disc), Loc);\n-                        end if;\n-\n-                        Next_Discriminant (Disc);\n-                     end loop;\n-\n-                     --  That loop should always succeed in finding a matching\n-                     --  entry and returning. Fatal error if not.\n-\n-                     raise Program_Error;\n-\n-                  else\n-                     return\n-                       New_Occurrence_Of (Discriminal (Entity (Bound)), Loc);\n-                  end if;\n-               end;\n-            else\n-               return New_Occurrence_Of (Discriminal (Entity (Bound)), Loc);\n-            end if;\n-\n-         elsif Nkind (Bound) = N_Identifier\n-           and then Ekind (Entity (Bound)) = E_In_Parameter\n-           and then not Inside_Init_Proc\n-         then\n-            return Get_Discriminal (E, Bound);\n-\n-         elsif Nkind (Bound) = N_Integer_Literal then\n-            return Make_Integer_Literal (Loc, Intval (Bound));\n-\n-         --  Case of a bound rewritten to an N_Raise_Constraint_Error node\n-         --  because it is an out-of-range value. Duplicate_Subexpr cannot be\n-         --  called on this node because an N_Raise_Constraint_Error is not\n-         --  side effect free, and we may not assume that we are in the proper\n-         --  context to remove side effects on it at the point of reference.\n-\n-         elsif Nkind (Bound) = N_Raise_Constraint_Error then\n-            return New_Copy_Tree (Bound);\n-\n-         else\n-            return Duplicate_Subexpr_No_Checks (Bound);\n-         end if;\n+         return Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Occurrence_Of (E, Loc),\n+                  Attribute_Name => Nam,\n+                  Expressions    => Exprs);\n       end Get_E_First_Or_Last;\n \n       -----------------\n@@ -6568,13 +6478,17 @@ package body Checks is\n            Make_Or_Else (Loc,\n              Left_Opnd =>\n                Make_Op_Lt (Loc,\n-                 Left_Opnd => Get_E_First_Or_Last (Exptyp, Indx, Name_First),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_First)),\n+                 Left_Opnd   =>\n+                   Get_E_First_Or_Last (Loc, Exptyp, Indx, Name_First),\n+                 Right_Opnd  =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_First)),\n \n              Right_Opnd =>\n                Make_Op_Gt (Loc,\n-                 Left_Opnd => Get_E_First_Or_Last (Exptyp, Indx, Name_Last),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_Last)));\n+                 Left_Opnd   =>\n+                   Get_E_First_Or_Last (Loc, Exptyp, Indx, Name_Last),\n+                 Right_Opnd  =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_E_Cond;\n \n       ------------------------\n@@ -6591,12 +6505,17 @@ package body Checks is\n            Make_Or_Else (Loc,\n              Left_Opnd =>\n                Make_Op_Ne (Loc,\n-                 Left_Opnd => Get_E_First_Or_Last (Exptyp, Indx, Name_First),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_First)),\n+                 Left_Opnd   =>\n+                   Get_E_First_Or_Last (Loc, Exptyp, Indx, Name_First),\n+                 Right_Opnd  =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_First)),\n+\n              Right_Opnd =>\n                Make_Op_Ne (Loc,\n-                 Left_Opnd => Get_E_First_Or_Last (Exptyp, Indx, Name_Last),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_Last)));\n+                 Left_Opnd   =>\n+                   Get_E_First_Or_Last (Loc, Exptyp, Indx, Name_Last),\n+                 Right_Opnd  =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_Equal_E_Cond;\n \n       ------------------\n@@ -6613,13 +6532,17 @@ package body Checks is\n            Make_Or_Else (Loc,\n              Left_Opnd =>\n                Make_Op_Lt (Loc,\n-                 Left_Opnd => Get_N_First (Expr, Indx),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_First)),\n+                 Left_Opnd  =>\n+                   Get_N_First (Expr, Indx),\n+                 Right_Opnd =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_First)),\n \n              Right_Opnd =>\n                Make_Op_Gt (Loc,\n-                 Left_Opnd => Get_N_Last (Expr, Indx),\n-                 Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_Last)));\n+                 Left_Opnd  =>\n+                   Get_N_Last (Expr, Indx),\n+                 Right_Opnd =>\n+                   Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_N_Cond;\n \n    --  Start of processing for Selected_Range_Checks"}, {"sha": "187d8fb992c3677811d7b4a6fc648fab7c1b7fa7", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -781,7 +781,7 @@ package body System.Regpat is\n \n       procedure Link_Operand_Tail (P, Val : Pointer) is\n       begin\n-         if Program (P) = BRANCH then\n+         if P <= PM.Size and then Program (P) = BRANCH then\n             Link_Tail (Operand (P), Val);\n          end if;\n       end Link_Operand_Tail;\n@@ -796,14 +796,10 @@ package body System.Regpat is\n          Offset : Pointer;\n \n       begin\n-         if Emit_Ptr > PM.Size then\n-            return;\n-         end if;\n-\n          --  Find last node\n \n          Scan := P;\n-         loop\n+         while Scan <= PM.Size loop\n             Temp := Get_Next (Program, Scan);\n             exit when Temp = Scan;\n             Scan := Temp;\n@@ -914,7 +910,7 @@ package body System.Regpat is\n \n          Link_Tail (IP, Ender);\n \n-         if Have_Branch then\n+         if Have_Branch and then Emit_Ptr <= PM.Size then\n \n             --  Hook the tails of the branches to the closing node\n "}, {"sha": "73e77e3d738d967bfdbf13082cb6a05ad6f9e181", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -4811,6 +4811,12 @@ package body Sem_Attr is\n       --  Computes Aft value for current attribute prefix (used by Aft itself\n       --  and also by Width for computing the Width of a fixed point type).\n \n+      procedure Check_Concurrent_Discriminant (Bound : Node_Id);\n+      --  If Bound is a reference to a discriminant of a task or protected type\n+      --  occurring within the object's body, rewrite attribute reference into\n+      --  a reference to the corresponding discriminal. Use for the expansion\n+      --  of checks against bounds of entry family index subtypes.\n+\n       procedure Check_Expressions;\n       --  In case where the attribute is not foldable, the expressions, if\n       --  any, of the attribute, are in a non-static context. This procedure\n@@ -4895,6 +4901,33 @@ package body Sem_Attr is\n          return Result;\n       end Aft_Value;\n \n+      -----------------------------------\n+      -- Check_Concurrent_Discriminant --\n+      -----------------------------------\n+\n+      procedure Check_Concurrent_Discriminant (Bound : Node_Id) is\n+         Tsk  : Entity_Id;\n+         --  The concurrent (task or protected) type\n+      begin\n+         if Nkind (Bound) = N_Identifier\n+           and then Ekind (Entity (Bound)) = E_Discriminant\n+           and then Is_Concurrent_Record_Type (Scope (Entity (Bound)))\n+         then\n+            Tsk := Corresponding_Concurrent_Type (Scope (Entity (Bound)));\n+            if In_Open_Scopes (Tsk)\n+                 and then Has_Completion (Tsk)\n+            then\n+               --  Find discriminant of original concurrent type, and use\n+               --  its current discriminal, which is the renaming within\n+               --  the task/protected body.\n+\n+               Rewrite (N,\n+                 New_Occurrence_Of\n+                   (Find_Body_Discriminal (Entity (Bound)), Loc));\n+            end if;\n+         end if;\n+      end Check_Concurrent_Discriminant;\n+\n       -----------------------\n       -- Check_Expressions --\n       -----------------------\n@@ -5982,6 +6015,8 @@ package body Sem_Attr is\n             else\n                Fold_Uint  (N, Expr_Value (Lo_Bound), Static);\n             end if;\n+         else\n+            Check_Concurrent_Discriminant (Lo_Bound);\n          end if;\n       end First_Attr;\n \n@@ -6170,6 +6205,8 @@ package body Sem_Attr is\n             else\n                Fold_Uint  (N, Expr_Value (Hi_Bound), Static);\n             end if;\n+         else\n+            Check_Concurrent_Discriminant (Hi_Bound);\n          end if;\n       end Last;\n "}, {"sha": "dd23fc0ba978defee4b243a384cdc52852c11e2c", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -30,7 +30,6 @@ with Errout;   use Errout;\n with Exp_Ch9;  use Exp_Ch9;\n with Elists;   use Elists;\n with Freeze;   use Freeze;\n-with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -167,73 +166,6 @@ package body Sem_Ch9 is\n       Kind      : Entity_Kind;\n       Task_Nam  : Entity_Id;\n \n-      -----------------------\n-      -- Actual_Index_Type --\n-      -----------------------\n-\n-      function Actual_Index_Type (E : Entity_Id) return Entity_Id;\n-      --  If the bounds of an entry family depend on task discriminants, create\n-      --  a new index type where a discriminant is replaced by the local\n-      --  variable that renames it in the task body.\n-\n-      -----------------------\n-      -- Actual_Index_Type --\n-      -----------------------\n-\n-      function Actual_Index_Type (E : Entity_Id) return Entity_Id is\n-         Typ   : constant Entity_Id := Entry_Index_Type (E);\n-         Lo    : constant Node_Id   := Type_Low_Bound  (Typ);\n-         Hi    : constant Node_Id   := Type_High_Bound (Typ);\n-         New_T : Entity_Id;\n-\n-         function Actual_Discriminant_Ref (Bound : Node_Id) return Node_Id;\n-         --  If bound is discriminant reference, replace with corresponding\n-         --  local variable of the same name.\n-\n-         -----------------------------\n-         -- Actual_Discriminant_Ref --\n-         -----------------------------\n-\n-         function Actual_Discriminant_Ref (Bound : Node_Id) return Node_Id is\n-            Typ : constant Entity_Id := Etype (Bound);\n-            Ref : Node_Id;\n-         begin\n-            if not Is_Entity_Name (Bound)\n-              or else Ekind (Entity (Bound)) /= E_Discriminant\n-            then\n-               return Bound;\n-            else\n-               Ref := Make_Identifier (Sloc (N), Chars (Entity (Bound)));\n-               Analyze (Ref);\n-               Resolve (Ref, Typ);\n-               return Ref;\n-            end if;\n-         end Actual_Discriminant_Ref;\n-\n-      --  Start of processing for Actual_Index_Type\n-\n-      begin\n-         if not Has_Discriminants (Task_Nam)\n-           or else (not Is_Entity_Name (Lo)\n-                     and then not Is_Entity_Name (Hi))\n-         then\n-            return Entry_Index_Type (E);\n-         else\n-            New_T := Create_Itype (Ekind (Typ), N);\n-            Set_Etype        (New_T, Base_Type (Typ));\n-            Set_Size_Info    (New_T, Typ);\n-            Set_RM_Size      (New_T, RM_Size (Typ));\n-            Set_Scalar_Range (New_T,\n-              Make_Range (Sloc (N),\n-                Low_Bound  => Actual_Discriminant_Ref (Lo),\n-                High_Bound => Actual_Discriminant_Ref (Hi)));\n-\n-            return New_T;\n-         end if;\n-      end Actual_Index_Type;\n-\n-   --  Start of processing for Analyze_Accept_Statement\n-\n    begin\n       Tasking_Used := True;\n \n@@ -370,7 +302,7 @@ package body Sem_Ch9 is\n             Error_Msg_N (\"missing entry index in accept for entry family\", N);\n          else\n             Analyze_And_Resolve (Index, Entry_Index_Type (E));\n-            Apply_Range_Check (Index, Actual_Index_Type (E));\n+            Apply_Range_Check (Index, Entry_Index_Type (E));\n          end if;\n \n       elsif Present (Index) then"}, {"sha": "418d57f4893c1f1899f545307feb5e42a84d22c5", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -5929,7 +5929,8 @@ package body Sem_Res is\n               and then In_Open_Scopes (Tsk)\n               and then Nkind (Parent (Entry_Name)) = N_Requeue_Statement\n             then\n-               return New_Occurrence_Of (Discriminal (Entity (Bound)), Loc);\n+               return New_Occurrence_Of\n+                        (Find_Body_Discriminal (Entity (Bound)), Loc);\n \n             else\n                Ref :="}, {"sha": "262a890c8ab99bcd10fae2ce758cb4f3dc5edb93", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -3062,6 +3062,37 @@ package body Sem_Util is\n       Call   := Empty;\n    end Find_Actual;\n \n+   ---------------------------\n+   -- Find_Body_Discriminal --\n+   ---------------------------\n+\n+   function Find_Body_Discriminal\n+     (Spec_Discriminant : Entity_Id) return Entity_Id\n+   is\n+      pragma Assert (Is_Concurrent_Record_Type (Scope (Spec_Discriminant)));\n+      Tsk  : constant Entity_Id :=\n+               Corresponding_Concurrent_Type (Scope (Spec_Discriminant));\n+      Disc : Entity_Id;\n+   begin\n+      --  Find discriminant of original concurrent type, and use its current\n+      --  discriminal, which is the renaming within the task/protected body.\n+\n+      Disc := First_Discriminant (Tsk);\n+      while Present (Disc) loop\n+         if Chars (Disc) = Chars (Spec_Discriminant) then\n+            Set_Scope (Discriminal (Disc), Tsk);\n+            return Discriminal (Disc);\n+         end if;\n+\n+         Next_Discriminant (Disc);\n+      end loop;\n+\n+      --  That loop should always succeed in finding a matching entry and\n+      --  returning. Fatal error if not.\n+\n+      raise Program_Error;\n+   end Find_Body_Discriminal;\n+\n    -------------------------------------\n    -- Find_Corresponding_Discriminant --\n    -------------------------------------"}, {"sha": "2d786a4d94c2a557caad12e5e1598d326ca57b19", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a153b2787e167cb9f065e6fd91424b0475b2790/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5a153b2787e167cb9f065e6fd91424b0475b2790", "patch": "@@ -329,11 +329,11 @@ package Sem_Util is\n    function Find_Corresponding_Discriminant\n      (Id   : Node_Id;\n       Typ  : Entity_Id) return Entity_Id;\n-   --  Because discriminants may have different names in a generic unit\n-   --  and in an instance, they are resolved positionally when possible.\n-   --  A reference to a discriminant carries the discriminant that it\n-   --  denotes when analyzed. Subsequent uses of this id on a different\n-   --  type denote the discriminant at the same position in this new type.\n+   --  Because discriminants may have different names in a generic unit and in\n+   --  an instance, they are resolved positionally when possible. A reference\n+   --  to a discriminant carries the discriminant that it denotes when\n+   --  analyzed. Subsequent uses of this id on a different type denotes the\n+   --  discriminant at the same position in this new type.\n \n    procedure Find_Overlaid_Entity\n      (N   : Node_Id;\n@@ -355,6 +355,12 @@ package Sem_Util is\n    --  Determine the alternative chosen, so that the code of non-selected\n    --  alternatives, and the warnings that may apply to them, are removed.\n \n+   function Find_Body_Discriminal\n+     (Spec_Discriminant : Entity_Id) return Entity_Id;\n+   --  Given a discriminant of the record type that implements a task or\n+   --  protected type, return the discriminal of the corresponding discriminant\n+   --  of the actual concurrent type.\n+\n    function First_Actual (Node : Node_Id) return Node_Id;\n    --  Node is an N_Function_Call or N_Procedure_Call_Statement node. The\n    --  result returned is the first actual parameter in declaration order"}]}