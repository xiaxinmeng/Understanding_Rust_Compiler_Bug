{"sha": "c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhNDcxOGExNGM0NjI3ZGQ2ZGRjMjM2NGI4ZTkxZTk5NzViYWNlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-09-09T22:06:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-09-09T22:06:20Z"}, "message": "re PR middle-end/37356 (ICE in gsi_insert_seq_nodes_after, at gimple-iterator.c:222)\n\n\tPR middle-end/37356\n\t* tree-inline.c (copy_bb): Insert stmt into copy_basic_block before\n\tcalling gimple_regimplify_operands on it.  Iterate over all newly\n\tadded statements, not just the last one.\n\t(insert_init_stmt): Insert stmt into seq first, then call\n\tgimple_regimplify_operands on it.  Don't create new gimplification\n\tcontext, nor find referenced vars.\n\n\t* g++.dg/tree-ssa/pr37356.C: New test.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r140177", "tree": {"sha": "08de3cd92e5e40dda70ea9b6eaa5ee262cbd1d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08de3cd92e5e40dda70ea9b6eaa5ee262cbd1d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18802917af53a9423fe496aa68cf6c2aa67f8ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18802917af53a9423fe496aa68cf6c2aa67f8ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18802917af53a9423fe496aa68cf6c2aa67f8ca9"}], "stats": {"total": 108, "additions": 72, "deletions": 36}, "files": [{"sha": "094094971e2b948b06031d40f45c688f0b1581f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "patch": "@@ -1,3 +1,14 @@\n+2008-09-09  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/37356\n+\t* tree-inline.c (copy_bb): Insert stmt into copy_basic_block before\n+\tcalling gimple_regimplify_operands on it.  Iterate over all newly\n+\tadded statements, not just the last one.\n+\t(insert_init_stmt): Insert stmt into seq first, then call\n+\tgimple_regimplify_operands on it.  Don't create new gimplification\n+\tcontext, nor find referenced vars.\n+\n 2008-09-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/37419"}, {"sha": "55464c0c396f42b45de9abbdb099de425a0704fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "patch": "@@ -1,5 +1,8 @@\n 2008-09-09  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/37356\n+\t* g++.dg/tree-ssa/pr37356.C: New test.\n+\n \tPR target/37438\n \t* gcc.dg/pr37438.c: New test.\n "}, {"sha": "45b99a037b9693e8bfe16d03aa9cb908df893a15", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr37356.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr37356.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr37356.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr37356.C?ref=c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "patch": "@@ -0,0 +1,34 @@\n+// PR middle-end/37356 */\n+// { dg-do compile }\n+// { dg-options \"-O\" }\n+\n+bool foo ();\n+int bar ();\n+\n+bool\n+baz (int v)\n+{\n+  return v == bar ();\n+}\n+\n+struct A\n+{\n+  A () { baz (1) || foo (); }\n+};\n+\n+struct B\n+{\n+  static A get () { return A (); }\n+  B (const int &x) { }\n+  B () : b (get ()) { }\n+  A b;\n+};\n+\n+B c;\n+\n+void\n+test ()\n+{\n+  int d;\n+  c = d;\n+}"}, {"sha": "decdd6c0f31a8cfd0c21ae408926f48eb4d13751", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a4718a14c4627dd6ddc2364b8e91e9975bacee/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c2a4718a14c4627dd6ddc2364b8e91e9975bacee", "patch": "@@ -1232,7 +1232,7 @@ static basic_block\n copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n          gcov_type count_scale)\n {\n-  gimple_stmt_iterator gsi, copy_gsi;\n+  gimple_stmt_iterator gsi, copy_gsi, seq_gsi;\n   basic_block copy_basic_block;\n   tree decl;\n \n@@ -1263,6 +1263,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \tcontinue;\n \n       gimple_duplicate_stmt_histograms (cfun, stmt, id->src_cfun, orig_stmt);\n+      seq_gsi = copy_gsi;\n \n       /* With return slot optimization we can end up with\n \t non-gimple (foo *)&this->m, fix that here.  */\n@@ -1271,21 +1272,31 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t  && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n \t{\n \t  tree new_rhs;\n-\t  new_rhs = force_gimple_operand_gsi (&copy_gsi,\n+\t  new_rhs = force_gimple_operand_gsi (&seq_gsi,\n \t                                      gimple_assign_rhs1 (stmt),\n \t                                      true, NULL, true, GSI_SAME_STMT);\n \t  gimple_assign_set_rhs1 (stmt, new_rhs);\n+\t  id->regimplify = false;\n \t}\n-      else if (id->regimplify)\n-\tgimple_regimplify_operands (stmt, &copy_gsi);\n \n-      gsi_insert_after (&copy_gsi, stmt, GSI_NEW_STMT);\n+      gsi_insert_after (&seq_gsi, stmt, GSI_NEW_STMT);\n+\n+      if (id->regimplify)\n+\tgimple_regimplify_operands (stmt, &seq_gsi);\n+\n+      /* If copy_basic_block has been empty at the start of this iteration,\n+\t call gsi_start_bb again to get at the newly added statements.  */\n+      if (gsi_end_p (copy_gsi))\n+\tcopy_gsi = gsi_start_bb (copy_basic_block);\n+      else\n+\tgsi_next (&copy_gsi);\n \n       /* Process the new statement.  The call to gimple_regimplify_operands\n \t possibly turned the statement into multiple statements, we\n \t need to process all of them.  */\n-      while (!gsi_end_p (copy_gsi))\n+      do\n \t{\n+\t  stmt = gsi_stmt (copy_gsi);\n \t  if (is_gimple_call (stmt)\n \t      && gimple_call_va_arg_pack_p (stmt)\n \t      && id->gimple_call)\n@@ -1459,6 +1470,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n \t  gsi_next (&copy_gsi);\n \t}\n+      while (!gsi_end_p (copy_gsi));\n \n       copy_gsi = gsi_last_bb (copy_basic_block);\n     }\n@@ -1889,40 +1901,16 @@ self_inlining_addr_expr (tree value, tree fn)\n static void\n insert_init_stmt (basic_block bb, gimple init_stmt)\n {\n-  gimple_stmt_iterator si = gsi_last_bb (bb);\n-  gimple_stmt_iterator i;\n-  gimple_seq seq = gimple_seq_alloc ();\n-  struct gimplify_ctx gctx;\n-\n-  push_gimplify_context (&gctx);\n-\n-  i = gsi_start (seq);\n-  gimple_regimplify_operands (init_stmt, &i);\n-\n-  if (init_stmt\n-      && !gimple_seq_empty_p (seq))\n-    {\n-      /* The replacement can expose previously unreferenced\n-\t variables.  */\n-      if (gimple_in_ssa_p (cfun))\n-        for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n-\t  find_new_referenced_vars (gsi_stmt (i));\n-\n-      /* Insert the gimplified sequence needed for INIT_STMT\n-\t after SI.  INIT_STMT will be inserted after SEQ.  */\n-      gsi_insert_seq_after (&si, seq, GSI_NEW_STMT);\n-     }\n-\n-  pop_gimplify_context (NULL);\n-\n   /* If VAR represents a zero-sized variable, it's possible that the\n      assignment statement may result in no gimple statements.  */\n   if (init_stmt)\n-    gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);\n+    {\n+      gimple_stmt_iterator si = gsi_last_bb (bb);\n \n-  if (gimple_in_ssa_p (cfun))\n-    for (;!gsi_end_p (si); gsi_next (&si))\n-      mark_symbols_for_renaming (gsi_stmt (si));\n+      gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);\n+      gimple_regimplify_operands (init_stmt, &si);\n+      mark_symbols_for_renaming (init_stmt);\n+    }\n }\n \n /* Initialize parameter P with VALUE.  If needed, produce init statement"}]}