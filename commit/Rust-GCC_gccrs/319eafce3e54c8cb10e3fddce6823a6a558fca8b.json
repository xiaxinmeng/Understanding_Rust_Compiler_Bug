{"sha": "319eafce3e54c8cb10e3fddce6823a6a558fca8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5ZWFmY2UzZTU0YzhjYjEwZTNmZGRjZTY4MjNhNmE1NThmY2E4Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-06T18:05:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-06T18:05:02Z"}, "message": "x86: Fix vextract* masked patterns [PR93069]\n\nThe AVX512F documentation clearly states that in instructions where the\ndestination is a memory only merging-masking is possible, not zero-masking,\nand the assembler enforces that.\n\nThe testcase in this patch fails to assemble because of\nError: unsupported masking for `vextracti32x8'\non\n        vextracti32x8   $0x0, %zmm1, -64(%rsp){%k1}{z}\nFor the vector extraction patterns, we apparently have 7 *_maskm patterns\nthat only accept memory destinations and rtx_equal_p merge-masking source\nfor it, 7 *<mask_name> corresponding patterns that allow memory destination\nonly for the non-masked cases (through <store_mask_constraint>), then 2\n*<mask_name> patterns (lo ssehalf V16FI and lo ssehalf VI8F_256 ones) which\ndo allow memory destination even for masked cases and are the cause of the\ntestsuite failure, because we must not allow C constraint if the destination\nis m, and finally one pair of patterns (separate * and *_mask, hi ssehalf\nVI4F_256), which has another issue (for which I don't have a testcase\nthough), where if it would match zero-masking with register destination,\nit wouldn't emit the needed {z} into assembly.\nThe attached patch fixes those 3 issues only, perhaps more suitable for\nbackporting.\nBut, even with that fixed, we are missing 3 further *_maskm patterns and\nmore importantly, I find the split into 3 separate patterns after subst,\n*_maskm for masking with memory destination, *_mask for masking with\nregister destination and * for non-masking unnecessarily complex and harder\nfor reload, so the included patch below (non-attached) instead kills all\n*_maskm patterns and splits the *<mask_name> patterns into * and *_mask\nby hand instead of subst, where the *_mask ones make sure that with v\ndestination they use 0C, while with m destination they use 0 and as\ncondition enforce that either destination is not MEM, or rtx_equal_p between\nthe destination and corresponding merging-masking operand source.\nIf we had those 3 missing *_maskm patterns, this patch would actually result\nin both shorter sse.md and shorter machine description after subst (e.g.\nlength of tmp-mddump.md), as we don't have them, the patch is actually 16\nlines longer sse.md, but still shorter tmp-mddump.md.\n\n2020-05-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/93069\n\t* config/i386/subst.md (store_mask_constraint, store_mask_predicate):\n\tRemove.\n\t(avx512dq_vextract<shuffletype>64x2_1_maskm,\n\tavx512f_vextract<shuffletype>32x4_1_maskm,\n\tvec_extract_lo_<mode>_maskm, vec_extract_hi_<mode>_maskm): Remove.\n\t(<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>): Split\n\tinto ...\n\t(*avx512dq_vextract<shuffletype>64x2_1,\n\tavx512dq_vextract<shuffletype>64x2_1_mask): ... these new\n\tdefine_insns.  Even in the masked variant allow memory output but in\n\tthat case use 0 rather than 0C constraint on the source of masked-out\n\telts.\n\t(<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>): Split\n\tinto ...\n\t(*avx512f_vextract<shuffletype>32x4_1,\n\tavx512f_vextract<shuffletype>32x4_1_mask): ... these new define_insns.\n\tEven in the masked variant allow memory output but in that case use\n\t0 rather than 0C constraint on the source of masked-out elts.\n\t(vec_extract_lo_<mode><mask_name>): Split into ...\n\t(vec_extract_lo_<mode>, vec_extract_lo_<mode>_mask): ... these new\n\tdefine_insns.  Even in the masked variant allow memory output but in\n\tthat case use 0 rather than 0C constraint on the source of masked-out\n\telts.\n\t(vec_extract_hi_<mode><mask_name>): Split into ...\n\t(vec_extract_hi_<mode>, vec_extract_hi_<mode>_mask): ... these new\n\tdefine_insns.  Even in the masked variant allow memory output but in\n\tthat case use 0 rather than 0C constraint on the source of masked-out\n\telts.", "tree": {"sha": "e4dfe0248dc302a8c47aa21b56ef55b93bd04297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4dfe0248dc302a8c47aa21b56ef55b93bd04297"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/319eafce3e54c8cb10e3fddce6823a6a558fca8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319eafce3e54c8cb10e3fddce6823a6a558fca8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/319eafce3e54c8cb10e3fddce6823a6a558fca8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319eafce3e54c8cb10e3fddce6823a6a558fca8b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "530b44094354758d0dea5374188caa6863647114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530b44094354758d0dea5374188caa6863647114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/530b44094354758d0dea5374188caa6863647114"}], "stats": {"total": 469, "additions": 256, "deletions": 213}, "files": [{"sha": "1afb7824fa5f1a6dbe5ba206dcfc463f7ccc006f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=319eafce3e54c8cb10e3fddce6823a6a558fca8b", "patch": "@@ -1,3 +1,35 @@\n+2020-05-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/93069\n+\t* config/i386/subst.md (store_mask_constraint, store_mask_predicate):\n+\tRemove.\n+\t(avx512dq_vextract<shuffletype>64x2_1_maskm,\n+\tavx512f_vextract<shuffletype>32x4_1_maskm,\n+\tvec_extract_lo_<mode>_maskm, vec_extract_hi_<mode>_maskm): Remove.\n+\t(<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>): Split\n+\tinto ...\n+\t(*avx512dq_vextract<shuffletype>64x2_1,\n+\tavx512dq_vextract<shuffletype>64x2_1_mask): ... these new\n+\tdefine_insns.  Even in the masked variant allow memory output but in\n+\tthat case use 0 rather than 0C constraint on the source of masked-out\n+\telts.\n+\t(<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>): Split\n+\tinto ...\n+\t(*avx512f_vextract<shuffletype>32x4_1,\n+\tavx512f_vextract<shuffletype>32x4_1_mask): ... these new define_insns.\n+\tEven in the masked variant allow memory output but in that case use\n+\t0 rather than 0C constraint on the source of masked-out elts.\n+\t(vec_extract_lo_<mode><mask_name>): Split into ...\n+\t(vec_extract_lo_<mode>, vec_extract_lo_<mode>_mask): ... these new\n+\tdefine_insns.  Even in the masked variant allow memory output but in\n+\tthat case use 0 rather than 0C constraint on the source of masked-out\n+\telts.\n+\t(vec_extract_hi_<mode><mask_name>): Split into ...\n+\t(vec_extract_hi_<mode>, vec_extract_hi_<mode>_mask): ... these new\n+\tdefine_insns.  Even in the masked variant allow memory output but in\n+\tthat case use 0 rather than 0C constraint on the source of masked-out\n+\telts.\n+\n 2020-05-06  qing zhao  <qing.zhao@oracle.com>\n \n \tPR c/94230\n@@ -111,27 +143,27 @@\n 2020-05-06  Hongtao Liu  <hongtao.liu@intel.com>\n \t    Wei Xiao  <wei3.xiao@intel.com>\n \n-\t* gcc/common/config/i386/i386-common.c (OPTION_MASK_ISA2_SERIALIZE_SET,\n+\t* common/config/i386/i386-common.c (OPTION_MASK_ISA2_SERIALIZE_SET,\n \tOPTION_MASK_ISA2_SERIALIZE_UNSET): New macros.\n \t(ix86_handle_option): Handle -mserialize.\n-\t* gcc/config.gcc (serializeintrin.h): New header file.\n-\t* gcc/config/i386/cpuid.h (bit_SERIALIZE): New bit.\n-\t* gcc/config/i386/driver-i386.c (host_detect_local_cpu): Detect\n+\t* config.gcc (serializeintrin.h): New header file.\n+\t* config/i386/cpuid.h (bit_SERIALIZE): New bit.\n+\t* config/i386/driver-i386.c (host_detect_local_cpu): Detect\n \t-mserialize.\n-\t* gcc/config/i386/i386-builtin.def: Add new builtin.\n-\t* gcc/config/i386/i386-c.c (__SERIALIZE__): New macro.\n-\t* gcc/config/i386/i386-options.c (ix86_target_opts_isa2_opts):\n+\t* config/i386/i386-builtin.def: Add new builtin.\n+\t* config/i386/i386-c.c (__SERIALIZE__): New macro.\n+\t* config/i386/i386-options.c (ix86_target_opts_isa2_opts):\n \t  Add -mserialize.\n \t* (ix86_valid_target_attribute_inner_p): Add target attribute\n \t* for serialize.\n-\t* gcc/config/i386/i386.h (TARGET_SERIALIZE, TARGET_SERIALIZE_P):\n+\t* config/i386/i386.h (TARGET_SERIALIZE, TARGET_SERIALIZE_P):\n \t  New macros.\n-\t* gcc/config/i386/i386.md (UNSPECV_SERIALIZE): New unspec.\n+\t* config/i386/i386.md (UNSPECV_SERIALIZE): New unspec.\n \t  (serialize): New define_insn.\n-\t* gcc/config/i386/i386.opt (mserialize): New option\n-\t* gcc/config/i386/immintrin.h: Include serailizeintrin.h.\n-\t* gcc/config/i386/serializeintrin.h: New header file.\n-\t* gcc/doc/invoke.texi: Add documents for -mserialize.\n+\t* config/i386/i386.opt (mserialize): New option\n+\t* config/i386/immintrin.h: Include serailizeintrin.h.\n+\t* config/i386/serializeintrin.h: New header file.\n+\t* doc/invoke.texi: Add documents for -mserialize.\n \n 2020-05-06  Richard Biener  <rguenther@suse.de>\n \n@@ -144,7 +176,7 @@\n \tprivate branch.\n \t* config/rs6000/rs6000-c.c: Likewise.\n \t* config/rs6000/rs6000-call.c: Likewise.\n-\t* gcc/config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n \n 2020-05-05  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n@@ -865,7 +897,7 @@\n 2020-04-28  Alexandre Oliva <oliva@adacore.com>\n \n \tPR target/94812\n-\t* gcc/config/rs6000/rs6000.md (rs6000_mffsl): Copy result to\n+\t* config/rs6000/rs6000.md (rs6000_mffsl): Copy result to\n \toutput operand in emulation.  Don't overwrite pseudos.\n \n 2020-04-28  Jeff Law  <law@redhat.com>\n@@ -1120,7 +1152,7 @@\n \n 2020-04-23  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n-\t* gcc/doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n+\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n \tReplace outdated link to ELFv2 ABI.\n \n 2020-04-23  Jakub Jelinek  <jakub@redhat.com>\n@@ -2700,7 +2732,7 @@\n \n 2020-03-29  John David Anglin  <dave.anglin@bell.net>\n \n-\t* gcc/config/pa/pa.c (pa_asm_output_aligned_bss): Delete duplicate\n+\t* config/pa/pa.c (pa_asm_output_aligned_bss): Delete duplicate\n \t.align output.\n \n 2020-03-28  Jakub Jelinek  <jakub@redhat.com>\n@@ -3192,7 +3224,7 @@\n 2020-03-21 Iain Sandoe <iain@sandoe.co.uk>\n \n \tPR target/93694\n-\t* gcc/config/darwin.opt: Amend options descriptions.\n+\t* config/darwin.opt: Amend options descriptions.\n \n 2020-03-21  Richard Sandiford  <richard.sandiford@arm.com>\n \n@@ -3214,7 +3246,7 @@\n 2020-03-20  Carl Love  <cel@us.ibm.com>\n \n \tPR/target 87583\n-\t* gcc/config/rs6000/rs6000.c (rs6000_option_override_internal):\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal):\n \tAdd check for TARGET_FPRND for Power 7 or newer.\n \n 2020-03-20  Jan Hubicka  <hubicka@ucw.cz>\n@@ -10798,7 +10830,7 @@\n 2020-03-10  Jiufu Guo  <guojiufu@linux.ibm.com>\n \n \tPR target/93709\n-\t* gcc/config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): Check\n+\t* config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): Check\n \tNAN and SIGNED_ZEROR for smax/smin.\n \n 2020-03-10  Will Schmidt  <will_schmidt@vnet.ibm.com>\n@@ -11856,9 +11888,9 @@\n \n 2020-02-21  John David Anglin  <danglin@gcc.gnu.org>\n \n-\t* gcc/config/pa/pa.c (pa_function_value): Fix check for word and\n+\t* config/pa/pa.c (pa_function_value): Fix check for word and\n \tdouble-word size when handling aggregate return values.\n-\t* gcc/config/pa/som.h (ASM_DECLARE_FUNCTION_NAME): Fix to indicate\n+\t* config/pa/som.h (ASM_DECLARE_FUNCTION_NAME): Fix to indicate\n \tthat homogeneous SFmode and DFmode aggregates are passed and returned\n \tin general registers.\n \n@@ -13983,7 +14015,7 @@\n \n 2020-01-21  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n \n-\t* gcc/config/arm/arm.c (clear_operation_p):\n+\t* config/arm/arm.c (clear_operation_p):\n \tInitialise last_regno, skip first iteration\n \tbased on the first_set value and use ints instead\n \tof the unnecessary HOST_WIDE_INTs."}, {"sha": "7a7ecd4be87bfb0c94948fbd3663b717106332ee", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 201, "deletions": 188, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=319eafce3e54c8cb10e3fddce6823a6a558fca8b", "patch": "@@ -8323,60 +8323,31 @@\n   DONE;\n })\n \n-(define_insn \"avx512dq_vextract<shuffletype>64x2_1_maskm\"\n-  [(set (match_operand:<ssequartermode> 0 \"memory_operand\" \"=m\")\n+(define_insn \"avx512dq_vextract<shuffletype>64x2_1_mask\"\n+  [(set (match_operand:<ssequartermode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_merge:<ssequartermode>\n \t  (vec_select:<ssequartermode>\n-\t    (match_operand:V8FI 1 \"register_operand\" \"v\")\n-\t    (parallel [(match_operand 2  \"const_0_to_7_operand\")\n-\t      (match_operand 3  \"const_0_to_7_operand\")]))\n-\t  (match_operand:<ssequartermode> 4 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 5 \"register_operand\" \"Yk\")))]\n+\t    (match_operand:V8FI 1 \"register_operand\" \"v,v\")\n+\t    (parallel [(match_operand 2 \"const_0_to_7_operand\")\n+\t\t       (match_operand 3 \"const_0_to_7_operand\")]))\n+\t  (match_operand:<ssequartermode> 4 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 5 \"register_operand\" \"Yk,Yk\")))]\n   \"TARGET_AVX512DQ\n    && INTVAL (operands[2]) % 2 == 0\n    && INTVAL (operands[2]) == INTVAL (operands[3]) - 1\n-   && rtx_equal_p (operands[4], operands[0])\"\n-{\n-  operands[2] = GEN_INT ((INTVAL (operands[2])) >> 1);\n-  return \"vextract<shuffletype>64x2\\t{%2, %1, %0%{%5%}|%0%{%5%}, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"memory\" \"store\")\n-   (set_attr \"prefix\" \"evex\")\n-   (set_attr \"mode\" \"<sseinsnmode>\")])\n-\n-(define_insn \"avx512f_vextract<shuffletype>32x4_1_maskm\"\n-  [(set (match_operand:<ssequartermode> 0 \"memory_operand\" \"=m\")\n-\t(vec_merge:<ssequartermode>\n-\t  (vec_select:<ssequartermode>\n-\t    (match_operand:V16FI 1 \"register_operand\" \"v\")\n-\t    (parallel [(match_operand 2  \"const_0_to_15_operand\")\n-\t      (match_operand 3  \"const_0_to_15_operand\")\n-\t      (match_operand 4  \"const_0_to_15_operand\")\n-\t      (match_operand 5  \"const_0_to_15_operand\")]))\n-\t  (match_operand:<ssequartermode> 6 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 7 \"register_operand\" \"Yk\")))]\n-  \"TARGET_AVX512F\n-   && INTVAL (operands[2]) % 4 == 0\n-   && INTVAL (operands[2]) == INTVAL (operands[3]) - 1\n-   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1\n-   && INTVAL (operands[4]) == INTVAL (operands[5]) - 1\n-   && rtx_equal_p (operands[6], operands[0])\"\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[4]))\"\n {\n-  operands[2] = GEN_INT (INTVAL (operands[2]) >> 2);\n-  return \"vextract<shuffletype>32x4\\t{%2, %1, %0%{%7%}|%0%{%7%}, %1, %2}\";\n+  operands[2] = GEN_INT (INTVAL (operands[2]) >> 1);\n+  return \"vextract<shuffletype>64x2\\t{%2, %1, %0%{%5%}%N4|%0%{%5%}%N4, %1, %2}\";\n }\n-  [(set_attr \"type\" \"sselog\")\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"memory\" \"store\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"<mask_codefor>avx512dq_vextract<shuffletype>64x2_1<mask_name>\"\n-  [(set (match_operand:<ssequartermode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n+(define_insn \"*avx512dq_vextract<shuffletype>64x2_1\"\n+  [(set (match_operand:<ssequartermode> 0 \"nonimmediate_operand\" \"=vm\")\n \t(vec_select:<ssequartermode>\n \t  (match_operand:V8FI 1 \"register_operand\" \"v\")\n \t  (parallel [(match_operand 2  \"const_0_to_7_operand\")\n@@ -8386,7 +8357,7 @@\n    && INTVAL (operands[2]) == INTVAL (operands[3]) - 1\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) >> 1);\n-  return \"vextract<shuffletype>64x2\\t{%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2}\";\n+  return \"vextract<shuffletype>64x2\\t{%2, %1, %0|%0, %1, %2}\";\n }\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n@@ -8415,22 +8386,49 @@\n     operands[1] = gen_lowpart (<ssequartermode>mode, operands[1]);\n })\n \n-(define_insn \"<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>\"\n-  [(set (match_operand:<ssequartermode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n+(define_insn \"avx512f_vextract<shuffletype>32x4_1_mask\"\n+  [(set (match_operand:<ssequartermode> 0 \"nonimmediate_operand\" \"=v,m\")\n+\t(vec_merge:<ssequartermode>\n+\t  (vec_select:<ssequartermode>\n+\t    (match_operand:V16FI 1 \"register_operand\" \"v,v\")\n+\t    (parallel [(match_operand 2 \"const_0_to_15_operand\")\n+\t\t       (match_operand 3 \"const_0_to_15_operand\")\n+\t\t       (match_operand 4 \"const_0_to_15_operand\")\n+\t\t       (match_operand 5 \"const_0_to_15_operand\")]))\n+\t  (match_operand:<ssequartermode> 6 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 7 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512F\n+   && INTVAL (operands[2]) % 4 == 0\n+   && INTVAL (operands[2]) == INTVAL (operands[3]) - 1\n+   && INTVAL (operands[3]) == INTVAL (operands[4]) - 1\n+   && INTVAL (operands[4]) == INTVAL (operands[5]) - 1\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[6]))\"\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) >> 2);\n+  return \"vextract<shuffletype>32x4\\t{%2, %1, %0%{%7%}%N6|%0%{%7%}%N6, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"*avx512f_vextract<shuffletype>32x4_1\"\n+  [(set (match_operand:<ssequartermode> 0 \"nonimmediate_operand\" \"=vm\")\n \t(vec_select:<ssequartermode>\n \t  (match_operand:V16FI 1 \"register_operand\" \"v\")\n-\t  (parallel [(match_operand 2  \"const_0_to_15_operand\")\n-            (match_operand 3  \"const_0_to_15_operand\")\n-            (match_operand 4  \"const_0_to_15_operand\")\n-            (match_operand 5  \"const_0_to_15_operand\")])))]\n+\t  (parallel [(match_operand 2 \"const_0_to_15_operand\")\n+\t\t     (match_operand 3 \"const_0_to_15_operand\")\n+\t\t     (match_operand 4 \"const_0_to_15_operand\")\n+\t\t     (match_operand 5 \"const_0_to_15_operand\")])))]\n   \"TARGET_AVX512F\n    && INTVAL (operands[2]) % 4 == 0\n    && INTVAL (operands[2]) == INTVAL (operands[3]) - 1\n    && INTVAL (operands[3]) == INTVAL (operands[4]) - 1\n    && INTVAL (operands[4]) == INTVAL (operands[5]) - 1\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) >> 2);\n-  return \"vextract<shuffletype>32x4\\t{%2, %1, %0<mask_operand6>|%0<mask_operand6>, %1, %2}\";\n+  return \"vextract<shuffletype>32x4\\t{%2, %1, %0|%0, %1, %2}\";\n }\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n@@ -8514,35 +8512,35 @@\n   [(set (match_dup 0) (match_dup 1))]\n   \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n-(define_insn \"vec_extract_lo_<mode>_maskm\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+(define_insn \"vec_extract_lo_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_merge:<ssehalfvecmode>\n \t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:V8FI 1 \"register_operand\" \"v\")\n+\t    (match_operand:V8FI 1 \"register_operand\" \"v,v\")\n \t    (parallel [(const_int 0) (const_int 1)\n-\t      (const_int 2) (const_int 3)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 3 \"register_operand\" \"Yk\")))]\n+\t\t       (const_int 2) (const_int 3)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n   \"TARGET_AVX512F\n-   && rtx_equal_p (operands[2], operands[0])\"\n-  \"vextract<shuffletype>64x4\\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}\"\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>64x4\\t{$0x0, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x0}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_lo_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,<store_mask_constraint>,v\")\n+(define_insn \"vec_extract_lo_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,vm,v\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:V8FI 1 \"<store_mask_predicate>\" \"v,v,<store_mask_constraint>\")\n+\t  (match_operand:V8FI 1 \"nonimmediate_operand\" \"v,v,vm\")\n \t  (parallel [(const_int 0) (const_int 1)\n-            (const_int 2) (const_int 3)])))]\n-  \"TARGET_AVX512F\n-   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))\"\n+\t\t     (const_int 2) (const_int 3)])))]\n+  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n-  if (<mask_applied> || (!TARGET_AVX512VL && !MEM_P (operands[1])))\n-    return \"vextract<shuffletype>64x4\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n+  if (!TARGET_AVX512VL && !MEM_P (operands[1]))\n+    return \"vextract<shuffletype>64x4\\t{$0x0, %1, %0|%0, %1, 0x0}\";\n   else\n     return \"#\";\n }\n@@ -8553,70 +8551,69 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_hi_<mode>_maskm\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+(define_insn \"vec_extract_hi_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_merge:<ssehalfvecmode>\n \t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:V8FI 1 \"register_operand\" \"v\")\n+\t    (match_operand:V8FI 1 \"register_operand\" \"v,v\")\n \t    (parallel [(const_int 4) (const_int 5)\n-\t      (const_int 6) (const_int 7)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 3 \"register_operand\" \"Yk\")))]\n+\t\t       (const_int 6) (const_int 7)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n   \"TARGET_AVX512F\n-   && rtx_equal_p (operands[2], operands[0])\"\n-  \"vextract<shuffletype>64x4\\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}\"\n-  [(set_attr \"type\" \"sselog\")\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>64x4\\t{$0x1, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x1}\"\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"memory\" \"store\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_hi_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>\")\n+(define_insn \"vec_extract_hi_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=vm\")\n \t(vec_select:<ssehalfvecmode>\n \t  (match_operand:V8FI 1 \"register_operand\" \"v\")\n \t  (parallel [(const_int 4) (const_int 5)\n-            (const_int 6) (const_int 7)])))]\n+\t\t     (const_int 6) (const_int 7)])))]\n   \"TARGET_AVX512F\"\n-  \"vextract<shuffletype>64x4\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\"\n+  \"vextract<shuffletype>64x4\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_hi_<mode>_maskm\"\n-   [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+(define_insn \"vec_extract_hi_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_merge:<ssehalfvecmode>\n \t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:V16FI 1 \"register_operand\" \"v\")\n+\t    (match_operand:V16FI 1 \"register_operand\" \"v,v\")\n \t    (parallel [(const_int 8) (const_int 9)\n-\t      (const_int 10) (const_int 11)\n-\t      (const_int 12) (const_int 13)\n-\t      (const_int 14) (const_int 15)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 3 \"register_operand\" \"Yk\")))]\n+\t\t       (const_int 10) (const_int 11)\n+\t\t       (const_int 12) (const_int 13)\n+\t\t       (const_int 14) (const_int 15)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n   \"TARGET_AVX512DQ\n-   && rtx_equal_p (operands[2], operands[0])\"\n-  \"vextract<shuffletype>32x8\\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}\"\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>32x8\\t{$0x1, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x1}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_hi_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=<store_mask_constraint>,vm\")\n+(define_insn \"vec_extract_hi_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=vm,vm\")\n \t(vec_select:<ssehalfvecmode>\n \t  (match_operand:V16FI 1 \"register_operand\" \"v,v\")\n \t  (parallel [(const_int 8) (const_int 9)\n-            (const_int 10) (const_int 11)\n-\t    (const_int 12) (const_int 13)\n-\t    (const_int 14) (const_int 15)])))]\n-  \"TARGET_AVX512F && <mask_avx512dq_condition>\"\n+\t\t     (const_int 10) (const_int 11)\n+\t\t     (const_int 12) (const_int 13)\n+\t\t     (const_int 14) (const_int 15)])))]\n+  \"TARGET_AVX512F\"\n   \"@\n-   vextract<shuffletype>32x8\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\n+   vextract<shuffletype>32x8\\t{$0x1, %1, %0|%0, %1, 0x1}\n    vextracti64x4\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n@@ -8692,27 +8689,44 @@\n   DONE;\n })\n \n-(define_insn \"vec_extract_lo_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\"\n-\t\t\t\t\t  \"=v,v,<store_mask_constraint>\")\n+(define_insn \"vec_extract_lo_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:V16FI 1 \"register_operand\" \"v,v\")\n+\t    (parallel [(const_int 0) (const_int 1)\n+\t\t       (const_int 2) (const_int 3)\n+\t\t       (const_int 4) (const_int 5)\n+\t\t       (const_int 6) (const_int 7)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512DQ\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>32x8\\t{$0x0, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x0}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"memory\" \"none,store\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_lo_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,v,m\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:V16FI 1 \"<store_mask_predicate>\"\n-\t\t\t\t \"v,<store_mask_constraint>,v\")\n+\t  (match_operand:V16FI 1 \"nonimmediate_operand\" \"v,m,v\")\n \t  (parallel [(const_int 0) (const_int 1)\n-                     (const_int 2) (const_int 3)\n-                     (const_int 4) (const_int 5)\n-                     (const_int 6) (const_int 7)])))]\n+\t\t     (const_int 2) (const_int 3)\n+\t\t     (const_int 4) (const_int 5)\n+\t\t     (const_int 6) (const_int 7)])))]\n   \"TARGET_AVX512F\n-   && <mask_avx512dq_condition>\n-   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))\"\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n-  if (<mask_applied>\n-      || (!TARGET_AVX512VL\n-\t  && !REG_P (operands[0])\n-\t  && EXT_REX_SSE_REG_P (operands[1])))\n+  if (!TARGET_AVX512VL\n+      && !REG_P (operands[0])\n+      && EXT_REX_SSE_REG_P (operands[1]))\n     {\n       if (TARGET_AVX512DQ)\n-\treturn \"vextract<shuffletype>32x8\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n+\treturn \"vextract<shuffletype>32x8\\t{$0x0, %1, %0|%0, %1, 0x0}\";\n       else\n \treturn \"vextract<shuffletype>64x4\\t{$0x0, %1, %0|%0, %1, 0x0}\";\n     }\n@@ -8750,29 +8764,34 @@\n     operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\n })\n \n-(define_insn \"vec_extract_lo_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\"\n-\t\t\t\t\t  \"=v,v,<store_mask_constraint>\")\n-\t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI8F_256 1 \"<store_mask_predicate>\"\n-\t\t\t\t    \"v,<store_mask_constraint>,v\")\n-\t  (parallel [(const_int 0) (const_int 1)])))]\n-  \"TARGET_AVX\n-   && <mask_avx512vl_condition> && <mask_avx512dq_condition>\n-   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))\"\n-{\n-  if (<mask_applied>)\n-    return \"vextract<shuffletype>64x2\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n-  else\n-    return \"#\";\n-}\n+(define_insn \"vec_extract_lo_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:VI8F_256 1 \"register_operand\" \"v,v\")\n+\t    (parallel [(const_int 0) (const_int 1)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512DQ\n+   && TARGET_AVX512VL\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>64x2\\t{$0x0, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x0}\"\n    [(set_attr \"type\" \"sselog1\")\n     (set_attr \"prefix_extra\" \"1\")\n     (set_attr \"length_immediate\" \"1\")\n-    (set_attr \"memory\" \"none,load,store\")\n+    (set_attr \"memory\" \"none,store\")\n     (set_attr \"prefix\" \"evex\")\n     (set_attr \"mode\" \"XI\")])\n \n+(define_insn \"vec_extract_lo_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=vm,v\")\n+\t(vec_select:<ssehalfvecmode>\n+\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\" \"v,vm\")\n+\t  (parallel [(const_int 0) (const_int 1)])))]\n+  \"TARGET_AVX\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"#\")\n+\n (define_split\n   [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n \t(vec_select:<ssehalfvecmode>\n@@ -8783,20 +8802,38 @@\n   [(set (match_dup 0) (match_dup 1))]\n   \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n-(define_insn \"vec_extract_hi_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\" \"=v,<store_mask_constraint>\")\n+(define_insn \"vec_extract_hi_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n+\t(vec_merge:<ssehalfvecmode>\n+\t  (vec_select:<ssehalfvecmode>\n+\t    (match_operand:VI8F_256 1 \"register_operand\" \"v,v\")\n+\t    (parallel [(const_int 2) (const_int 3)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512DQ\n+   && TARGET_AVX512VL\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>64x2\\t{$0x1, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x1}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n+(define_insn \"vec_extract_hi_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=vm\")\n \t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI8F_256 1 \"register_operand\" \"v,v\")\n+\t  (match_operand:VI8F_256 1 \"register_operand\" \"v\")\n \t  (parallel [(const_int 2) (const_int 3)])))]\n-  \"TARGET_AVX && <mask_avx512vl_condition> && <mask_avx512dq_condition>\"\n+  \"TARGET_AVX\"\n {\n   if (TARGET_AVX512VL)\n-  {\n-    if (TARGET_AVX512DQ)\n-      return \"vextract<shuffletype>64x2\\t{$0x1, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x1}\";\n-    else\n-      return \"vextract<shuffletype>32x4\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n-  }\n+    {\n+      if (TARGET_AVX512DQ)\n+\treturn \"vextract<shuffletype>64x2\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+      else\n+\treturn \"vextract<shuffletype>32x4\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+    }\n   else\n     return \"vextract<i128>\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n }\n@@ -8817,74 +8854,50 @@\n   [(set (match_dup 0) (match_dup 1))]\n   \"operands[1] = gen_lowpart (<ssehalfvecmode>mode, operands[1]);\")\n \n-(define_insn \"vec_extract_lo_<mode><mask_name>\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"<store_mask_predicate>\"\n-\t\t\t\t\t  \"=<store_mask_constraint>,v\")\n-\t(vec_select:<ssehalfvecmode>\n-\t  (match_operand:VI4F_256 1 \"<store_mask_predicate>\"\n-\t\t\t\t    \"v,<store_mask_constraint>\")\n-\t  (parallel [(const_int 0) (const_int 1)\n-\t\t     (const_int 2) (const_int 3)])))]\n-  \"TARGET_AVX\n-   && <mask_avx512vl_condition>\n-   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))\"\n-{\n-  if (<mask_applied>)\n-    return \"vextract<shuffletype>32x4\\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}\";\n-  else\n-    return \"#\";\n-}\n-  [(set_attr \"type\" \"sselog1\")\n-   (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"prefix\" \"evex\")\n-   (set_attr \"mode\" \"<sseinsnmode>\")])\n-\n-(define_insn \"vec_extract_lo_<mode>_maskm\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n+(define_insn \"vec_extract_lo_<mode>_mask\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=v,m\")\n \t(vec_merge:<ssehalfvecmode>\n \t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n+\t    (match_operand:VI4F_256 1 \"register_operand\" \"v,v\")\n \t    (parallel [(const_int 0) (const_int 1)\n-\t\t      (const_int 2) (const_int 3)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n-\t  (match_operand:QI 3 \"register_operand\" \"Yk\")))]\n-  \"TARGET_AVX512VL && TARGET_AVX512F\n-   && rtx_equal_p (operands[2], operands[0])\"\n-  \"vextract<shuffletype>32x4\\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}\"\n+\t\t       (const_int 2) (const_int 3)]))\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:QI 3 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512VL\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n+  \"vextract<shuffletype>32x4\\t{$0x0, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x0}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"vec_extract_hi_<mode>_maskm\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"memory_operand\" \"=m\")\n-\t(vec_merge:<ssehalfvecmode>\n-\t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n-\t    (parallel [(const_int 4) (const_int 5)\n-\t\t      (const_int 6) (const_int 7)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"memory_operand\" \"0\")\n-\t  (match_operand:<ssehalfvecmode> 3 \"register_operand\" \"Yk\")))]\n-  \"TARGET_AVX512F && TARGET_AVX512VL\n-   && rtx_equal_p (operands[2], operands[0])\"\n-  \"vextract<shuffletype>32x4\\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}\"\n+(define_insn \"vec_extract_lo_<mode>\"\n+  [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=vm,v\")\n+\t(vec_select:<ssehalfvecmode>\n+\t  (match_operand:VI4F_256 1 \"nonimmediate_operand\" \"v,vm\")\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 2) (const_int 3)])))]\n+  \"TARGET_AVX\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"#\"\n   [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn \"vec_extract_hi_<mode>_mask\"\n-  [(set (match_operand:<ssehalfvecmode> 0 \"register_operand\" \"=v\")\n+  [(set (match_operand:<ssehalfvecmode> 0 \"register_operand\" \"=v,m\")\n \t(vec_merge:<ssehalfvecmode>\n \t  (vec_select:<ssehalfvecmode>\n-\t    (match_operand:VI4F_256 1 \"register_operand\" \"v\")\n+\t    (match_operand:VI4F_256 1 \"register_operand\" \"v,v\")\n \t    (parallel [(const_int 4) (const_int 5)\n \t\t       (const_int 6) (const_int 7)]))\n-\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C\")\n-\t  (match_operand:<avx512fmaskmode> 3 \"register_operand\" \"Yk\")))]\n-  \"TARGET_AVX512VL\"\n+\t  (match_operand:<ssehalfvecmode> 2 \"nonimm_or_0_operand\" \"0C,0\")\n+\t  (match_operand:<avx512fmaskmode> 3 \"register_operand\" \"Yk,Yk\")))]\n+  \"TARGET_AVX512VL\n+   && (!MEM_P (operands[0]) || rtx_equal_p (operands[0], operands[2]))\"\n   \"vextract<shuffletype>32x4\\t{$0x1, %1, %0%{%3%}%N2|%0%{%3%}%N2, %1, 0x1}\"\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"length_immediate\" \"1\")"}, {"sha": "a5ca144c7f70ac148c3ef798c867775ea4cca9d3", "filename": "gcc/config/i386/subst.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2Fconfig%2Fi386%2Fsubst.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319eafce3e54c8cb10e3fddce6823a6a558fca8b/gcc%2Fconfig%2Fi386%2Fsubst.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsubst.md?ref=319eafce3e54c8cb10e3fddce6823a6a558fca8b", "patch": "@@ -57,8 +57,6 @@\n (define_subst_attr \"mask_avx512vl_condition\" \"mask\" \"1\" \"TARGET_AVX512VL\")\n (define_subst_attr \"mask_avx512bw_condition\" \"mask\" \"1\" \"TARGET_AVX512BW\")\n (define_subst_attr \"mask_avx512dq_condition\" \"mask\" \"1\" \"TARGET_AVX512DQ\")\n-(define_subst_attr \"store_mask_constraint\" \"mask\" \"vm\" \"v\")\n-(define_subst_attr \"store_mask_predicate\" \"mask\" \"nonimmediate_operand\" \"register_operand\")\n (define_subst_attr \"mask_prefix\" \"mask\" \"vex\" \"evex\")\n (define_subst_attr \"mask_prefix2\" \"mask\" \"maybe_vex\" \"evex\")\n (define_subst_attr \"mask_prefix3\" \"mask\" \"orig,vex\" \"evex,evex\")"}]}