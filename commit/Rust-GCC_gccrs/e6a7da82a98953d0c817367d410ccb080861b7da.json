{"sha": "e6a7da82a98953d0c817367d410ccb080861b7da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhN2RhODJhOTg5NTNkMGM4MTczNjdkNDEwY2NiMDgwODYxYjdkYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-11T18:54:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-11T18:54:47Z"}, "message": "ira-build.c (ira_loop_tree_body_rev_postorder): New function.\n\n\n\t* ira-build.c (ira_loop_tree_body_rev_postorder): New function.\n\t(ira_traverse_loop_tree): Traverse a loop's basic blocks in\n\treverse post-order of the reversed control-flow direction.\n\t* ira-conflicts.c (ira_build_conflicts): Pass add_copies as\n\tthe pre-order function to ira_traverse_loop_tree to preserve\n\tthe existing semantics.\n\n\t* ira-lives.c (remove_some_program_points_and_update_live_ranges):\n\tSqueeze out live range chain elements if their program points are\n\tconnected.\n\nFrom-SVN: r192378", "tree": {"sha": "c1dfc7cfd88768e4decf85c593946bf539aa4254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1dfc7cfd88768e4decf85c593946bf539aa4254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6a7da82a98953d0c817367d410ccb080861b7da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a7da82a98953d0c817367d410ccb080861b7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a7da82a98953d0c817367d410ccb080861b7da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a7da82a98953d0c817367d410ccb080861b7da/comments", "author": null, "committer": null, "parents": [{"sha": "d2a934a5a55627c87d94fda02d563aa9b69390be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a934a5a55627c87d94fda02d563aa9b69390be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a934a5a55627c87d94fda02d563aa9b69390be"}], "stats": {"total": 164, "additions": 152, "deletions": 12}, "files": [{"sha": "17ab28b46a3f8b966ddd6f53ff3969cca6dfef20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6a7da82a98953d0c817367d410ccb080861b7da", "patch": "@@ -1,3 +1,16 @@\n+2012-10-11  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ira-build.c (ira_loop_tree_body_rev_postorder): New function.\n+\t(ira_traverse_loop_tree): Traverse a loop's basic blocks in\n+\treverse post-order of the reversed control-flow direction.\n+\t* ira-conflicts.c (ira_build_conflicts): Pass add_copies as\n+\tthe pre-order function to ira_traverse_loop_tree to preserve\n+\tthe existing semantics.\n+\n+\t* ira-lives.c (remove_some_program_points_and_update_live_ranges):\n+\tSqueeze out live range chain elements if their program points are\n+\tconnected.\n+\n 2012-10-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.def (REDUC_PLUS_EXPR): Fix up comment."}, {"sha": "cc4ff34f70753d81a34b2a7e2238a3c142b4bcce", "filename": "gcc/ira-build.c", "status": "modified", "additions": 127, "deletions": 9, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=e6a7da82a98953d0c817367d410ccb080861b7da", "patch": "@@ -1458,6 +1458,96 @@ finish_cost_vectors (void)\n \n \f\n \n+/* Compute a post-ordering of the reverse control flow of the loop body\n+   designated by the children nodes of LOOP_NODE, whose body nodes in\n+   pre-order are input as LOOP_PREORDER.  Return a VEC with a post-order\n+   of the reverse loop body.\n+\n+   For the post-order of the reverse CFG, we visit the basic blocks in\n+   LOOP_PREORDER array in the reverse order of where they appear.\n+   This is important: We do not just want to compute a post-order of\n+   the reverse CFG, we want to make a best-guess for a visiting order that\n+   minimizes the number of chain elements per allocno live range.  If the\n+   blocks would be visited in a different order, we would still compute a\n+   correct post-ordering but it would be less likely that two nodes\n+   connected by an edge in the CFG are neighbours in the topsort.  */\n+\n+static VEC (ira_loop_tree_node_t, heap) *\n+ira_loop_tree_body_rev_postorder (ira_loop_tree_node_t loop_node ATTRIBUTE_UNUSED,\n+\t\t\t\t  VEC (ira_loop_tree_node_t, heap) *loop_preorder)\n+{\n+  VEC (ira_loop_tree_node_t, heap) *topsort_nodes = NULL;\n+  unsigned int n_loop_preorder;\n+\n+  n_loop_preorder = VEC_length (ira_loop_tree_node_t, loop_preorder);\n+  if (n_loop_preorder != 0)\n+    {\n+      ira_loop_tree_node_t subloop_node;\n+      unsigned int i;\n+      VEC (ira_loop_tree_node_t, heap) *dfs_stack;\n+\n+      /* This is a bit of strange abuse of the BB_VISITED flag:  We use\n+\t the flag to mark blocks we still have to visit to add them to\n+\t our post-order.  Define an alias to avoid confusion.  */\n+#define BB_TO_VISIT BB_VISITED\n+\n+      FOR_EACH_VEC_ELT (ira_loop_tree_node_t, loop_preorder, i, subloop_node)\n+\t{\n+\t  gcc_checking_assert (! (subloop_node->bb->flags & BB_TO_VISIT));\n+\t  subloop_node->bb->flags |= BB_TO_VISIT;\n+\t}\n+\n+      topsort_nodes = VEC_alloc (ira_loop_tree_node_t, heap, n_loop_preorder);\n+      dfs_stack = VEC_alloc (ira_loop_tree_node_t, heap, n_loop_preorder);\n+\n+      FOR_EACH_VEC_ELT_REVERSE (ira_loop_tree_node_t, loop_preorder,\n+\t\t\t\ti, subloop_node)\n+\t{\n+\t  if (! (subloop_node->bb->flags & BB_TO_VISIT))\n+\t    continue;\n+\n+\t  subloop_node->bb->flags &= ~BB_TO_VISIT;\n+\t  VEC_quick_push (ira_loop_tree_node_t, dfs_stack, subloop_node);\n+\t  while (! VEC_empty (ira_loop_tree_node_t, dfs_stack))\n+\t    {\n+\t      edge e;\n+\t      edge_iterator ei;\n+\n+\t      ira_loop_tree_node_t n = VEC_last (ira_loop_tree_node_t,\n+\t\t\t\t\t\t dfs_stack);\n+\t      FOR_EACH_EDGE (e, ei, n->bb->preds)\n+\t\t{\n+\t\t  ira_loop_tree_node_t pred_node;\n+\t\t  basic_block pred_bb = e->src;\n+\n+\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t    continue;\n+\n+\t\t  pred_node = IRA_BB_NODE_BY_INDEX (pred_bb->index);\n+\t\t  if (pred_node != n\n+\t\t      && (pred_node->bb->flags & BB_TO_VISIT))\n+\t\t    {\n+\t\t      pred_node->bb->flags &= ~BB_TO_VISIT;\n+\t\t      VEC_quick_push (ira_loop_tree_node_t, dfs_stack, pred_node);\n+\t\t    }\n+\t\t}\n+\t      if (n == VEC_last (ira_loop_tree_node_t, dfs_stack))\n+\t\t{\n+\t\t  VEC_pop (ira_loop_tree_node_t, dfs_stack);\n+\t\t  VEC_quick_push (ira_loop_tree_node_t, topsort_nodes, n);\n+\t\t}\n+\t    }\n+\t}\n+\n+#undef BB_TO_VISIT\n+      VEC_free (ira_loop_tree_node_t, heap, dfs_stack);\n+    }\n+\n+  gcc_assert (VEC_length (ira_loop_tree_node_t, topsort_nodes)\n+\t      == n_loop_preorder);\n+  return topsort_nodes;\n+}\n+\n /* The current loop tree node and its regno allocno map.  */\n ira_loop_tree_node_t ira_curr_loop_tree_node;\n ira_allocno_t *ira_curr_regno_allocno_map;\n@@ -1467,7 +1557,16 @@ ira_allocno_t *ira_curr_regno_allocno_map;\n    correspondingly in preorder and postorder.  The function sets up\n    IRA_CURR_LOOP_TREE_NODE and IRA_CURR_REGNO_ALLOCNO_MAP.  If BB_P,\n    basic block nodes of LOOP_NODE is also processed (before its\n-   subloop nodes).  */\n+   subloop nodes).\n+   \n+   If BB_P is set and POSTORDER_FUNC is given, the basic blocks in\n+   the loop are passed in the *reverse* post-order of the *reverse*\n+   CFG.  This is only used by ira_create_allocno_live_ranges, which\n+   wants to visit basic blocks in this order to minimize the number\n+   of elements per live range chain.\n+   Note that the loop tree nodes are still visited in the normal,\n+   forward post-order of  the loop tree.  */\n+\n void\n ira_traverse_loop_tree (bool bb_p, ira_loop_tree_node_t loop_node,\n \t\t\tvoid (*preorder_func) (ira_loop_tree_node_t),\n@@ -1483,18 +1582,37 @@ ira_traverse_loop_tree (bool bb_p, ira_loop_tree_node_t loop_node,\n     (*preorder_func) (loop_node);\n \n   if (bb_p)\n-    for (subloop_node = loop_node->children;\n-\t subloop_node != NULL;\n-\t subloop_node = subloop_node->next)\n-      if (subloop_node->bb != NULL)\n-\t{\n-\t  if (preorder_func != NULL)\n-\t    (*preorder_func) (subloop_node);\n+    {\n+      VEC (ira_loop_tree_node_t, heap) *loop_preorder = NULL;\n+      unsigned int i;\n+\n+      /* Add all nodes to the set of nodes to visit.  The IRA loop tree\n+\t is set up such that nodes in the loop body appear in a pre-order\n+\t of their place in the CFG.  */\n+      for (subloop_node = loop_node->children;\n+\t   subloop_node != NULL;\n+\t   subloop_node = subloop_node->next)\n+\tif (subloop_node->bb != NULL)\n+\t  VEC_safe_push (ira_loop_tree_node_t, heap,\n+\t\t\t loop_preorder, subloop_node);\n+\n+      if (preorder_func != NULL)\n+\tFOR_EACH_VEC_ELT (ira_loop_tree_node_t, loop_preorder, i, subloop_node)\n+\t  (*preorder_func) (subloop_node);\n \n-\t  if (postorder_func != NULL)\n+      if (postorder_func != NULL)\n+\t{\n+\t  VEC (ira_loop_tree_node_t, heap) *loop_rev_postorder =\n+\t    ira_loop_tree_body_rev_postorder (loop_node, loop_preorder);\n+\t  FOR_EACH_VEC_ELT_REVERSE (ira_loop_tree_node_t, loop_rev_postorder,\n+\t\t\t\t    i, subloop_node)\n \t    (*postorder_func) (subloop_node);\n+\t  VEC_free (ira_loop_tree_node_t, heap, loop_rev_postorder);\n \t}\n \n+      VEC_free (ira_loop_tree_node_t, heap, loop_preorder);\n+    }\n+\n   for (subloop_node = loop_node->subloops;\n        subloop_node != NULL;\n        subloop_node = subloop_node->subloop_next)"}, {"sha": "d124ef28cab28b9345ba4a20d22edd2e691a7a84", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=e6a7da82a98953d0c817367d410ccb080861b7da", "patch": "@@ -860,7 +860,7 @@ ira_build_conflicts (void)\n \t  ira_object_iterator oi;\n \n \t  build_conflicts ();\n-\t  ira_traverse_loop_tree (true, ira_loop_tree_root, NULL, add_copies);\n+\t  ira_traverse_loop_tree (true, ira_loop_tree_root, add_copies, NULL);\n \t  /* We need finished conflict table for the subsequent call.  */\n \t  if (flag_ira_region == IRA_REGION_ALL\n \t      || flag_ira_region == IRA_REGION_MIXED)"}, {"sha": "109e3c4c9f3d3cbd8dd9acee1006d03c94f092fe", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a7da82a98953d0c817367d410ccb080861b7da/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=e6a7da82a98953d0c817367d410ccb080861b7da", "patch": "@@ -1458,7 +1458,7 @@ remove_some_program_points_and_update_live_ranges (void)\n   int *map;\n   ira_object_t obj;\n   ira_object_iterator oi;\n-  live_range_t r;\n+  live_range_t r, prev_r, next_r;\n   sbitmap born_or_dead, born, dead;\n   sbitmap_iterator sbi;\n   bool born_p, dead_p, prev_born_p, prev_dead_p;\n@@ -1502,10 +1502,19 @@ remove_some_program_points_and_update_live_ranges (void)\n   ira_max_point = n;\n \n   FOR_EACH_OBJECT (obj, oi)\n-    for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n+    for (r = OBJECT_LIVE_RANGES (obj), prev_r = NULL; r != NULL; r = next_r)\n       {\n+\tnext_r = r->next;\n \tr->start = map[r->start];\n \tr->finish = map[r->finish];\n+\tif (prev_r == NULL || prev_r->start > r->finish + 1)\n+\t  {\n+\t    prev_r = r;\n+\t    continue;\n+\t  }\n+\tprev_r->start = r->start;\n+\tprev_r->next = next_r;\n+\tira_finish_live_range (r);\n       }\n \n   ira_free (map);"}]}