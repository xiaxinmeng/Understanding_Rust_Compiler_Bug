{"sha": "fd9aef9d180a377a8804a40a89284956f36f0016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ5YWVmOWQxODBhMzc3YTg4MDRhNDBhODkyODQ5NTZmMzZmMDAxNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-02T18:52:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-02T18:52:16Z"}, "message": "re PR c++/9447 (using Base<T>::member does not work)\n\ncp:\n\tPR c++/9447\n\t* cp-tree.def (USING_DECL): Document its type.\n\t* class.c (pushclass): If we're entering a template, push any\n\tdependent using decls it has.\n\t* decl2.c (do_class_using_decl): Refactor. Type is NULL iff it is\n\ta dependent scope.\n\t* pt.c (tsubst_decl) <USING_DECL case>: Set type.\n\t(tsubst): Remove USING_DECL checks.\n\t(type_dependent_expression_p): Remove USING_DECL case.\n\t* semantics.c (finish_member_declaration): A USING_DECL's type\n\tindicates whether it is dependent.\ntestsuite:\n\tPR c++/9447\n\t* g++.dg/template/using7.C: New test.\n\nFrom-SVN: r70107", "tree": {"sha": "81299072d7ee64d2599788c3e47f00daaea546e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81299072d7ee64d2599788c3e47f00daaea546e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd9aef9d180a377a8804a40a89284956f36f0016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9aef9d180a377a8804a40a89284956f36f0016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9aef9d180a377a8804a40a89284956f36f0016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9aef9d180a377a8804a40a89284956f36f0016/comments", "author": null, "committer": null, "parents": [{"sha": "49634b3a45f7d9e65a521ac665014d6a81194dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49634b3a45f7d9e65a521ac665014d6a81194dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49634b3a45f7d9e65a521ac665014d6a81194dc4"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "de0923a96cf14b4bcfb8095932b7837a3f9877a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -1,3 +1,17 @@\n+2003-08-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9447\n+\t* cp-tree.def (USING_DECL): Document its type.\n+\t* class.c (pushclass): If we're entering a template, push any\n+\tdependent using decls it has.\n+\t* decl2.c (do_class_using_decl): Refactor. Type is NULL iff it is\n+\ta dependent scope.\n+\t* pt.c (tsubst_decl) <USING_DECL case>: Set type.\n+\t(tsubst): Remove USING_DECL checks.\n+\t(type_dependent_expression_p): Remove USING_DECL case.\n+\t* semantics.c (finish_member_declaration): A USING_DECL's type\n+\tindicates whether it is dependent.\n+\n 2003-08-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (pushclass): Remove unneeded parameter."}, {"sha": "bf1672127bfd9f22ff713825487cb844f07bbf53", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -5457,7 +5457,21 @@ pushclass (tree type)\n   pushlevel_class ();\n \n   if (type != previous_class_type || current_class_depth > 1)\n-    push_class_decls (type);\n+    {\n+      push_class_decls (type);\n+      if (CLASSTYPE_IS_TEMPLATE (type))\n+\t{\n+\t  /* If we are entering the scope of a template (not a\n+\t     specialization), we need to push all the using decls with\n+\t     dependent scope too.  */\n+\t  tree fields;\n+\n+\t  for (fields = TYPE_FIELDS (type);\n+\t       fields; fields = TREE_CHAIN (fields))\n+\t    if (TREE_CODE (fields) == USING_DECL && !TREE_TYPE (fields))\n+\t      pushdecl_class_level (fields);\n+\t}\n+    }\n   else\n     {\n       tree item;"}, {"sha": "f020a23d6a2f65e68c57d3f1fbf69dd4be943b0c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -195,7 +195,9 @@ DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", 't', 0)\n DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", 't', 0)\n \n /* A using declaration.  DECL_INITIAL contains the specified scope.  \n-   This is not an alias, but is later expanded into multiple aliases.  */\n+   This is not an alias, but is later expanded into multiple aliases.\n+   The decl will have a NULL_TYPE iff the scope is a dependent scope,\n+   otherwise it will have a void type. */\n DEFTREECODE (USING_DECL, \"using_decl\", 'd', 0)\n \n /* A using directive. The operand is USING_STMT_NAMESPACE. */     "}, {"sha": "ab6913cc0c81ae584645612d49b7a6e7d70417bc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -11632,7 +11632,8 @@ grokdeclarator (tree declarator,\n \t\t\t    inlinep, friendp, raises != NULL_TREE);\n \t  }\n       }\n-    else if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    else if (TREE_CODE (type) == FUNCTION_TYPE\n+\t     || TREE_CODE (type) == METHOD_TYPE)\n       {\n \ttree original_name;\n \tint publicp = 0;"}, {"sha": "8ec34b2e03e5292f3e1e1b89fc9eb1ce8b5520f7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -4045,59 +4045,53 @@ do_local_using_decl (tree decl)\n tree\n do_class_using_decl (tree decl)\n {\n-  tree name, value;\n-\n+  tree name, value, scope, type;\n+  \n   if (TREE_CODE (decl) != SCOPE_REF\n       || !TREE_OPERAND (decl, 0)\n       || !TYPE_P (TREE_OPERAND (decl, 0)))\n     {\n       error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n     }\n+  scope = TREE_OPERAND (decl, 0);\n   name = TREE_OPERAND (decl, 1);\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      error (\"using-declaration for destructor\");\n+      error (\"using-declaration cannot name destructor\");\n       return NULL_TREE;\n     }\n   else if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n-      name = TREE_OPERAND (name, 0);\n-      error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", TREE_OPERAND (decl, 0), name);\n+    template_id_error:;\n+      \n+      error (\"a using-declaration cannot specify a template-id\");\n       return NULL_TREE;\n     }\n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n-      tree type = TREE_TYPE (name);\n       if (CLASSTYPE_USE_TEMPLATE (TREE_TYPE (name)))\n-\t{\n-\t  name = DECL_NAME (CLASSTYPE_TI_TEMPLATE (type));\n-\t  error (\"a using-declaration cannot specify a template-id.\");\n-\t  return NULL_TREE;\n-\t}\n+\tgoto template_id_error;\n       name = DECL_NAME (name);\n     }\n   else if (TREE_CODE (name) == TEMPLATE_DECL)\n      name = DECL_NAME (name);\n   else if (BASELINK_P (name))\n     {\n-      tree fns;\n-\n-      fns = BASELINK_FUNCTIONS (name);\n+      tree fns = BASELINK_FUNCTIONS (name);\n+      \n       if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  fns = TREE_OPERAND (fns, 0);\n-\t  error (\"a using-declaration cannot specify a template-id.  Try  `using %T::%D'\", \n-\t\t BASELINK_ACCESS_BINFO (name),\n-\t\t DECL_NAME (get_first_fn (fns)));\n-\t}\n+\tgoto template_id_error;\n       name = DECL_NAME (get_first_fn (fns));\n     }\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n \n-  value = build_lang_decl (USING_DECL, name, NULL_TREE);\n-  DECL_INITIAL (value) = TREE_OPERAND (decl, 0);\n+  /* Dependent using decls have a NULL type, non-dependent ones have a\n+     void type.  */\n+  type = dependent_type_p (scope) ? NULL_TREE : void_type_node;\n+  value = build_lang_decl (USING_DECL, name, type);\n+  DECL_INITIAL (value) = scope;\n   return value;\n }\n "}, {"sha": "185a203c20024cd29d067cb10d2ec8103e972b04", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -6093,6 +6093,8 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n     case USING_DECL:\n       {\n \tr = copy_node (t);\n+\t/* It is not a dependent using decl any more.  */\n+\tTREE_TYPE (r) = void_type_node;\n \tDECL_INITIAL (r)\n \t  = tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n@@ -6403,15 +6405,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   else\n     type = TREE_TYPE (t);\n \n-  my_friendly_assert (type != unknown_type_node\n-\t\t      || TREE_CODE (t) == USING_DECL, 20030716);\n+  my_friendly_assert (type != unknown_type_node, 20030716);\n \n   if (type && TREE_CODE (t) != FUNCTION_DECL\n       && TREE_CODE (t) != TYPENAME_TYPE\n       && TREE_CODE (t) != TEMPLATE_DECL\n       && TREE_CODE (t) != IDENTIFIER_NODE\n       && TREE_CODE (t) != FUNCTION_TYPE\n-      && TREE_CODE (t) != USING_DECL\n       && TREE_CODE (t) != METHOD_TYPE)\n     type = tsubst (type, args, complain, in_decl);\n   if (type == error_mark_node)\n@@ -11623,8 +11623,6 @@ type_dependent_expression_p (tree expression)\n \n   if (TREE_TYPE (expression) == unknown_type_node)\n     {\n-      if (TREE_CODE (expression) == USING_DECL)\n-\treturn true;\n       if (TREE_CODE (expression) == ADDR_EXPR)\n \treturn type_dependent_expression_p (TREE_OPERAND (expression, 0));\n       if (TREE_CODE (expression) == BASELINK)"}, {"sha": "0931e891e048bc13fcc8eba3b2af053fcfa5233d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -2099,8 +2099,7 @@ finish_member_declaration (tree decl)\n \t\t\t\t\t  /*friend_p=*/0);\n     }\n   /* Enter the DECL into the scope of the class.  */\n-  else if ((TREE_CODE (decl) == USING_DECL && !processing_template_decl\n-\t    && !dependent_type_p (DECL_INITIAL (decl)))\n+  else if ((TREE_CODE (decl) == USING_DECL && TREE_TYPE (decl))\n \t   || pushdecl_class_level (decl))\n     {\n       /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields"}, {"sha": "93da3595af9078562e95f49a2d74cb1f712a6702", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -1,3 +1,8 @@\n+2003-08-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9447\n+\t* g++.dg/template/using7.C: New test.\n+\n 2003-08-02  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* import1.c, import2.c: New tests."}, {"sha": "390dfbaace9d185fd5bf7d7e50a6662b39571bfa", "filename": "gcc/testsuite/g++.dg/template/using7.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd9aef9d180a377a8804a40a89284956f36f0016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing7.C?ref=fd9aef9d180a377a8804a40a89284956f36f0016", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 1 Aug 2003 <nathan@codesourcery.com>\n+\n+// PR 9447. Using decls in reopened template classes.\n+\n+template <typename> struct A { int i; };\n+\n+template <typename T> struct B : public A<T>\n+{\n+    using A<T>::i;\n+    int foo() const;\n+};\n+\n+struct C {};\n+\n+template <typename T> int B<T>::foo() const\n+{\n+  return i;\n+}"}]}