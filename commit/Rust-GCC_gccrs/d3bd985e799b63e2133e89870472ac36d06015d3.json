{"sha": "d3bd985e799b63e2133e89870472ac36d06015d3", "node_id": "C_kwDOANBUbNoAKGQzYmQ5ODVlNzk5YjYzZTIxMzNlODk4NzA0NzJhYzM2ZDA2MDE1ZDM", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-12-13T14:14:21Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-12-13T15:16:32Z"}, "message": "aarch64: Use +mops to inline memset operations\n\nThis 3rd patch in the series adds an inline sequence for the memset operation.\nThe aarch64-mops-memset-size-threshold param is added to control the size threshold for the sequence.\nIts default setting is 256, which may seem a bit high, but it is consistent with the current\nSIMD memset inline sequence limit, and future CPU tunings can override it easily as needed.\n\nBootstrapped and tested on aarch64-none-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64.c (aarch64_expand_setmem_mops): Define.\n\t(aarch64_expand_setmem): Adjust for TARGET_MOPS.\n\t* config/aarch64/aarch64.h (CLEAR_RATIO): Adjust for TARGET_MOPS.\n\t(SET_RATIO): Likewise.\n\t* config/aarch64/aarch64.md (\"unspec\"): Add UNSPEC_SETMEM.\n\t(aarch64_setmemdi): Define.\n\t(setmemdi): Adjust for TARGET_MOPS.\n\t* config/aarch64/aarch64.opt (aarch64-mops-memset-size-threshold):\n\tNew param.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/mops_3.c: New test.", "tree": {"sha": "62305a321b88d3a922ae81fd0dca5977e3335e4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62305a321b88d3a922ae81fd0dca5977e3335e4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3bd985e799b63e2133e89870472ac36d06015d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3bd985e799b63e2133e89870472ac36d06015d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3bd985e799b63e2133e89870472ac36d06015d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3bd985e799b63e2133e89870472ac36d06015d3/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb768f8b45aa7ccf12774aa0c00b295032ee7c47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb768f8b45aa7ccf12774aa0c00b295032ee7c47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb768f8b45aa7ccf12774aa0c00b295032ee7c47"}], "stats": {"total": 206, "additions": 181, "deletions": 25}, "files": [{"sha": "d11a40c02cd478d5d5eaa7c7fee9dfd27e834a68", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=d3bd985e799b63e2133e89870472ac36d06015d3", "patch": "@@ -23754,6 +23754,28 @@ aarch64_set_one_block_and_progress_pointer (rtx src, rtx *dst,\n   *dst = aarch64_progress_pointer (*dst);\n }\n \n+/* Expand a setmem using the MOPS instructions.  OPERANDS are the same\n+   as for the setmem pattern.  Return true iff we succeed.  */\n+static bool\n+aarch64_expand_setmem_mops (rtx *operands)\n+{\n+  if (!TARGET_MOPS)\n+    return false;\n+\n+  rtx addr_dst = XEXP (operands[0], 0);\n+  rtx sz_reg = operands[1];\n+  rtx val = operands[2];\n+\n+  if (!REG_P (sz_reg))\n+   sz_reg = force_reg (DImode, sz_reg);\n+  if (!REG_P (addr_dst))\n+   addr_dst = force_reg (DImode, addr_dst);\n+  if (!REG_P (val) && val != CONST0_RTX (QImode))\n+   val = force_reg (QImode, val);\n+  emit_insn (gen_aarch64_setmemdi (addr_dst, val, sz_reg));\n+  return true;\n+}\n+\n /* Expand setmem, as if from a __builtin_memset.  Return true if\n    we succeed, otherwise return false.  */\n \n@@ -23767,39 +23789,59 @@ aarch64_expand_setmem (rtx *operands)\n   rtx base;\n   machine_mode cur_mode = BLKmode, next_mode;\n \n-  /* We can't do anything smart if the amount to copy is not constant.  */\n-  if (!CONST_INT_P (operands[1]))\n-    return false;\n+  /* If we don't have SIMD registers or the size is variable use the MOPS\n+     inlined sequence if possible.  */\n+  if (!CONST_INT_P (operands[1]) || !TARGET_SIMD)\n+    return aarch64_expand_setmem_mops (operands);\n \n   bool size_p = optimize_function_for_size_p (cfun);\n \n-  /* Default the maximum to 256-bytes.  */\n+  /* Default the maximum to 256-bytes when considering only libcall vs\n+     SIMD broadcast sequence.  */\n   unsigned max_set_size = 256;\n \n   len = INTVAL (operands[1]);\n-\n-  /* Upper bound check.  */\n-  if (len > max_set_size)\n+  if (len > max_set_size && !TARGET_MOPS)\n     return false;\n \n+  int cst_val = !!(CONST_INT_P (val) && (INTVAL (val) != 0));\n+  /* The MOPS sequence takes:\n+     3 instructions for the memory storing\n+     + 1 to move the constant size into a reg\n+     + 1 if VAL is a non-zero constant to move into a reg\n+    (zero constants can use XZR directly).  */\n+  unsigned mops_cost = 3 + 1 + cst_val;\n+  /* A libcall to memset in the worst case takes 3 instructions to prepare\n+     the arguments + 1 for the call.  */\n+  unsigned libcall_cost = 4;\n+\n+  /* Upper bound check.  For large constant-sized setmem use the MOPS sequence\n+     when available.  */\n+  if (TARGET_MOPS\n+      && len >= (unsigned HOST_WIDE_INT) aarch64_mops_memset_size_threshold)\n+    return aarch64_expand_setmem_mops (operands);\n+\n   /* Attempt a sequence with a vector broadcast followed by stores.\n-     Count the number of operations involved to see if it's worth it for\n-     code size.  */\n+     Count the number of operations involved to see if it's worth it\n+     against the alternatives.  A simple counter simd_ops on the\n+     algorithmically-relevant operations is used rather than an rtx_insn count\n+     as all the pointer adjusmtents and mode reinterprets will be optimized\n+     away later.  */\n   start_sequence ();\n-  unsigned nops = 0;\n+  unsigned simd_ops = 0;\n+\n   base = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n \n   /* Prepare the val using a DUP/MOVI v0.16B, val.  */\n   src = expand_vector_broadcast (V16QImode, val);\n   src = force_reg (V16QImode, src);\n-  nops++;\n+  simd_ops++;\n   /* Convert len to bits to make the rest of the code simpler.  */\n   n = len * BITS_PER_UNIT;\n \n   /* Maximum amount to copy in one go.  We allow 256-bit chunks based on the\n-     AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS tuning parameter.  setmem expand\n-     pattern is only turned on for TARGET_SIMD.  */\n+     AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS tuning parameter.  */\n   const int copy_limit = (aarch64_tune_params.extra_tuning_flags\n \t\t\t  & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS)\n \t\t\t  ? GET_MODE_BITSIZE (TImode) : 256;\n@@ -23817,7 +23859,7 @@ aarch64_expand_setmem (rtx *operands)\n \n       mode_bits = GET_MODE_BITSIZE (cur_mode).to_constant ();\n       aarch64_set_one_block_and_progress_pointer (src, &dst, cur_mode);\n-      nops++;\n+      simd_ops++;\n       n -= mode_bits;\n \n       /* Do certain trailing copies as overlapping if it's going to be\n@@ -23835,12 +23877,25 @@ aarch64_expand_setmem (rtx *operands)\n     }\n   rtx_insn *seq = get_insns ();\n   end_sequence ();\n-  /* A call to memset in the worst case requires 3 instructions to prepare\n-     the arguments + 1 for the call.  Prefer the inline sequence for size if\n-     it is no longer than that.  */\n-  if (size_p && nops > 4)\n-    return false;\n \n+  if (size_p)\n+    {\n+      /* When optimizing for size we have 3 options: the SIMD broadcast sequence,\n+\t call to memset or the MOPS expansion.  */\n+      if (TARGET_MOPS\n+\t  && mops_cost <= libcall_cost\n+\t  && mops_cost <= simd_ops)\n+\treturn aarch64_expand_setmem_mops (operands);\n+      /* If MOPS is not available or not shorter pick a libcall if the SIMD\n+\t sequence is too long.  */\n+      else if (libcall_cost < simd_ops)\n+\treturn false;\n+      emit_insn (seq);\n+      return true;\n+    }\n+\n+  /* At this point the SIMD broadcast sequence is the best choice when\n+     optimizing for speed.  */\n   emit_insn (seq);\n   return true;\n }"}, {"sha": "2478d0db29017dbae601dddb65c067e27ad74200", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=d3bd985e799b63e2133e89870472ac36d06015d3", "patch": "@@ -1063,14 +1063,14 @@ typedef struct\n    Otherwise follow a sensible default: when optimizing for size, give a better\n    estimate of the length of a memset call, but use the default otherwise.  */\n #define CLEAR_RATIO(speed) \\\n-  (!STRICT_ALIGNMENT ? 4 : (speed) ? 15 : AARCH64_CALL_RATIO)\n+  (!STRICT_ALIGNMENT ? (TARGET_MOPS ? 0 : 4) : (speed) ? 15 : AARCH64_CALL_RATIO)\n \n /* SET_RATIO is similar to CLEAR_RATIO, but for a non-zero constant.  Without\n    -mstrict-align, make decisions in \"setmem\".  Otherwise follow a sensible\n    default: when optimizing for size adjust the ratio to account for the\n    overhead of loading the constant.  */\n #define SET_RATIO(speed) \\\n-  (!STRICT_ALIGNMENT ? 0 : (speed) ? 15 : AARCH64_CALL_RATIO - 2)\n+  ((!STRICT_ALIGNMENT || TARGET_MOPS) ? 0 : (speed) ? 15 : AARCH64_CALL_RATIO - 2)\n \n /* Disable auto-increment in move_by_pieces et al.  Use of auto-increment is\n    rarely a good idea in straight-line code since it adds an extra address"}, {"sha": "9e50a26e6f4ce8e69987794861ab2354df158d17", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=d3bd985e799b63e2133e89870472ac36d06015d3", "patch": "@@ -204,6 +204,7 @@\n     UNSPEC_SABDL2\n     UNSPEC_SADALP\n     UNSPEC_SCVTF\n+    UNSPEC_SETMEM\n     UNSPEC_SISD_NEG\n     UNSPEC_SISD_SSHL\n     UNSPEC_SISD_USHL\n@@ -1650,18 +1651,29 @@\n }\n )\n \n+(define_insn \"aarch64_setmemdi\"\n+  [(parallel [\n+   (set (match_operand:DI 2 \"register_operand\" \"+&r\") (const_int 0))\n+   (clobber (match_operand:DI 0 \"register_operand\" \"+&r\"))\n+   (set (mem:BLK (match_dup 0))\n+        (unspec:BLK [(match_operand:QI 1 \"aarch64_reg_or_zero\" \"rZ\")\n+                    (match_dup 2)] UNSPEC_SETMEM))])]\n+ \"TARGET_MOPS\"\n+ \"setp\\t[%x0]!, %x2!, %x1\\;setm\\t[%x0]!, %x2!, %x1\\;sete\\t[%x0]!, %x2!, %x1\"\n+ [(set_attr \"length\" \"12\")]\n+)\n+\n ;; 0 is dst\n ;; 1 is val\n ;; 2 is size of copy in bytes\n ;; 3 is alignment\n-\n (define_expand \"setmemdi\"\n   [(set (match_operand:BLK 0 \"memory_operand\")     ;; Dest\n         (match_operand:QI  2 \"nonmemory_operand\")) ;; Value\n-   (use (match_operand:DI  1 \"immediate_operand\")) ;; Length\n+   (use (match_operand:DI  1 \"general_operand\")) ;; Length\n    (match_operand          3 \"immediate_operand\")] ;; Align\n-  \"TARGET_SIMD\"\n-{\n+ \"TARGET_SIMD || TARGET_MOPS\"\n+ {\n   if (aarch64_expand_setmem (operands))\n     DONE;\n "}, {"sha": "264739e61433d96204f94426cad47d4320772996", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=d3bd985e799b63e2133e89870472ac36d06015d3", "patch": "@@ -288,3 +288,7 @@ Constant memcpy size in bytes above which to start using MOPS sequence.\n -param=aarch64-mops-memmove-size-threshold=\n Target Joined UInteger Var(aarch64_mops_memmove_size_threshold) Init(0) Param\n Constant memmove size in bytes above which to start using MOPS sequence.\n+\n+-param=aarch64-mops-memset-size-threshold=\n+Target Joined UInteger Var(aarch64_mops_memset_size_threshold) Init(256) Param\n+Constant memset size in bytes from which to start using MOPS sequence."}, {"sha": "0eda2ffb578fcc604b75bec5408db98cf82d316c", "filename": "gcc/testsuite/gcc.target/aarch64/mops_3.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3bd985e799b63e2133e89870472ac36d06015d3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmops_3.c?ref=d3bd985e799b63e2133e89870472ac36d06015d3", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=armv8.6-a+mops --param=aarch64-mops-memset-size-threshold=0\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdlib.h>\n+\n+/* We want to inline variable-sized memset.\n+** do_it_set:\n+**\tsetp\t\\[x0\\]\\!, x2\\!, x1\n+**\tsetm\t\\[x0\\]\\!, x2\\!, x1\n+**\tsete\t\\[x0\\]\\!, x2\\!, x1\n+**\tret\n+*/\n+void do_it_set (char * out, int n, size_t size)\n+{\n+  __builtin_memset (out, n, size);\n+}\n+\n+/*\n+** do_it_set_large:\n+**\tmov\tw2, 1\n+**\tmov\tx1, 1024\n+**\tsetp\t\\[x0\\]\\!, x1\\!, x2\n+**\tsetm\t\\[x0\\]\\!, x1\\!, x2\n+**\tsete\t\\[x0\\]\\!, x1\\!, x2\n+**\tret\n+*/\n+void do_it_set_large (char * out)\n+{\n+  __builtin_memset (out, 1, 1024);\n+}\n+\n+/*\n+** do_it_set_256:\n+**\tmov\tw2, 1\n+**\tmov\tx1, 256\n+**\tsetp\t\\[x0\\]\\!, x1\\!, x2\n+**\tsetm\t\\[x0\\]\\!, x1\\!, x2\n+**\tsete\t\\[x0\\]\\!, x1\\!, x2\n+**\tret\n+*/\n+void do_it_set_256 (char * out)\n+{\n+  __builtin_memset (out, 1, 256);\n+}\n+\n+/*\n+** do_it_set_255:\n+**\tmov\tw2, 1\n+**\tmov\tx1, 255\n+**\tsetp\t\\[x0\\]\\!, x1\\!, x2\n+**\tsetm\t\\[x0\\]\\!, x1\\!, x2\n+**\tsete\t\\[x0\\]\\!, x1\\!, x2\n+**\tret\n+*/\n+void do_it_set_255 (char * out)\n+{\n+  __builtin_memset (out, 1, 255);\n+}\n+\n+/*\n+** do_it_set_0:\n+**\tsetp\t\\[x0\\]\\!, x1\\!, xzr\n+**\tsetm\t\\[x0\\]\\!, x1\\!, xzr\n+**\tsete\t\\[x0\\]\\!, x1\\!, xzr\n+**\tret\n+*/\n+void do_it_set_0 (char * out, size_t n)\n+{\n+  __builtin_memset (out, 0, n);\n+}\n+\n+/*\n+** do_it_set_0_255:\n+**\tmov\tx1, 255\n+**\tsetp\t\\[x0\\]\\!, x1\\!, xzr\n+**\tsetm\t\\[x0\\]\\!, x1\\!, xzr\n+**\tsete\t\\[x0\\]\\!, x1\\!, xzr\n+**\tret\n+*/\n+void do_it_set_0_255 (char * out)\n+{\n+  __builtin_memset (out, 0, 255);\n+}\n+"}]}