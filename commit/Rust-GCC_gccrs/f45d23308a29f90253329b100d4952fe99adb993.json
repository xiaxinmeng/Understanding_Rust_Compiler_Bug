{"sha": "f45d23308a29f90253329b100d4952fe99adb993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1ZDIzMzA4YTI5ZjkwMjUzMzI5YjEwMGQ0OTUyZmU5OWFkYjk5Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-11-21T22:59:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-11-21T22:59:13Z"}, "message": "* porting.texi: New file.\n\nFrom-SVN: r37630", "tree": {"sha": "8389d94a15ff7d99b735085d3a6269949425b24b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8389d94a15ff7d99b735085d3a6269949425b24b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f45d23308a29f90253329b100d4952fe99adb993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45d23308a29f90253329b100d4952fe99adb993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f45d23308a29f90253329b100d4952fe99adb993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45d23308a29f90253329b100d4952fe99adb993/comments", "author": null, "committer": null, "parents": [{"sha": "0736a307e3f507096f37fbbd1e65738137beda6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0736a307e3f507096f37fbbd1e65738137beda6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0736a307e3f507096f37fbbd1e65738137beda6d"}], "stats": {"total": 447, "additions": 447, "deletions": 0}, "files": [{"sha": "bc93dd86ea2119589f4f2e4fec19c94a7c84f660", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45d23308a29f90253329b100d4952fe99adb993/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45d23308a29f90253329b100d4952fe99adb993/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f45d23308a29f90253329b100d4952fe99adb993", "patch": "@@ -1,3 +1,7 @@\n+2000-11-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* porting.texi: New file.\n+\n 2000-11-21  Branko Cibej  <brankoe@xbc.nu>\n \n         * config/os/solaris/solaris2.6/bits/os_defines.h: Define"}, {"sha": "6cd1c48b6360b1428aeb71eddf5f9f815edde59e", "filename": "libstdc++-v3/porting.texi", "status": "added", "additions": 443, "deletions": 0, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45d23308a29f90253329b100d4952fe99adb993/libstdc%2B%2B-v3%2Fporting.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45d23308a29f90253329b100d4952fe99adb993/libstdc%2B%2B-v3%2Fporting.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fporting.texi?ref=f45d23308a29f90253329b100d4952fe99adb993", "patch": "@@ -0,0 +1,443 @@\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+%\n+% File:   porting.texi\n+% Author: Mark Mitchell\n+% Date:   11/21/2000\n+%\n+% Contents:\n+%\n+% Copyright (c) 2000 by CodeSourcery, LLC.  All rights reserved. \n+%\n+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n+\n+\\input texinfo\n+\n+@c ---------------------------------------------------------------------\n+@c Prologue\n+@c ---------------------------------------------------------------------\n+\n+@setfilename porting.info\n+@settitle Porting libstdc++-v3\n+@setchapternewpage odd\n+\n+@ifinfo\n+This file explains how to port libstdc++-v3 (the GNU C++ library) to \n+a new target.\n+\n+Copyright (c) 2000 Free Software Foundation, Inc.\n+@end ifinfo\n+\n+@c ---------------------------------------------------------------------\n+@c Titlepage\n+@c ---------------------------------------------------------------------\n+\n+@titlepage\n+@title Porting libstdc++-v3\n+@author Mark Mitchell\n+@page\n+@vskip 0pt plus 1filll\n+Copyright @copyright{} 2000 Free Software Foundation, Inc.\n+@end titlepage\n+\n+@c ---------------------------------------------------------------------\n+@c Top\n+@c ---------------------------------------------------------------------\n+\n+@node Top\n+@top Porting libstdc++-v3\n+\n+This document explains how to port libstdc++-v3 (the GNU C++ library) to \n+a new target.\n+\n+In order to make the GNU C++ library (libstdc++-v3) work with a new\n+target, you must edit some configuration files and provide some new\n+header files.  \n+\n+Before you get started, make sure that you have a working C library on\n+your target.  The C library need not precisely comply with any\n+particular standard, but should generally conform to the requirements\n+imposed by the ANSI/ISO standard.\n+\n+In addition, you should try to verify that the C++ compiler generally\n+works.  It is difficult to test the C++ compiler without a working\n+library, but you should at least try some minimal test cases.\n+\n+Here are the primary steps required to port the library:\n+\n+@menu\n+* Operating system::    Configuring for your operating system.\n+* Character types::     Implementing character classification.\n+* Thread safety::       Implementing atomic operations.\n+* Libtool::             Using libtool.\n+@end menu\n+\n+@c ---------------------------------------------------------------------\n+@c Operating system\n+@c ---------------------------------------------------------------------\n+\n+@node Operating system\n+@chapter Operating system\n+\n+If you are porting to a new operating-system (as opposed to a new chip\n+using an existing operating system), you will need to create a new\n+directory in the @file{config/os} hierarchy.  For example, the IRIX\n+configuration files are all in @file{config/os/irix}.  There is no set\n+way to organize the OS configuration directory.  For example,\n+@file{config/os/solaris/solaris-2.6} and\n+@file{config/os/solaris/solaris-2.7} are used as configuration\n+directories for these two versions of Solaris.  On the other hand, both\n+Solaris 2.7 and Solaris 2.8 use the @file{config/os/solaris/solaris-2.7}\n+directory.  The important information is that there needs to be a\n+directory under @file{config/os} to store the files for your operating\n+system.\n+\n+You'll have to change the @file{configure.target} file to ensure that\n+your new directory is activated.  Look for the switch statement that\n+sets @code{os_include_dir}, and add a pattern to handle your operating\n+system.  The switch statement switches on only the OS portion of the\n+standard target triplet; e.g., the @code{solaris2.8} in\n+@code{sparc-sun-solaris2.8}.\n+\n+The first file to create in this directory, should be called\n+@file{bits/os_defines.h}.  This file contains basic macro definitions\n+that are required to allow the C++ library to work with your C library.\n+This file should provide macro definitions for @code{__off_t},\n+@code{__off64_t}, and @code{__ssize_t}.  Typically, this just looks\n+like:\n+\n+@example\n+#define __off_t off_t\n+#define __off64_t off64_t\n+#define __ssize_t ssize_t\n+@end example\n+\n+@noindent\n+You don't have to provide these definitions if your system library\n+already defines these types -- but the only library known to provide\n+these types is the GNU C Library, so you will almost certainly have to\n+provide these macros.  Note that this file does not have to include a\n+header file that defines @code{off_t}, or the other types; you simply\n+have to provide the macros.\n+\n+In addition, several V3 source files unconditionally define the macro\n+@code{_POSIX_SOURCE}.  On many systems, defining this macro causes large\n+portions of the C library header files to be eliminated at preprocessing\n+time.  Therefore, you may have to @code{#undef} this macro, or define\n+other macros (like @code{_LARGEFILE_SOURCE} or @code{__EXTENSIONS__}).\n+You won't know what macros to define or undefine at this point; you'll\n+have to try compiling the library and seeing what goes wrong.  If you\n+see errors about calling functions that have not been declared, look in\n+your C library headers to see if the functions are declared there, and\n+then figure out what macros you should but in @file{bits/os_defines.h}\n+to make these declarations available.\n+\n+Finally, you should bracket the entire file in an include-guard, like\n+this:\n+\n+@example\n+#ifndef _GLIBCPP_OS_DEFINES\n+#define _GLIBCPP_OS_DEFINES\n+...\n+#endif\n+@end example\n+\n+@c ---------------------------------------------------------------------\n+@c Character types\n+@c ---------------------------------------------------------------------\n+\n+@node Character types\n+@chapter Character types\n+\n+The library requires that you provide three header files to implement\n+character classification, analagous to that provided by the C libraries\n+@file{<ctype.h>} header.  You can model these on the files provided in\n+@file{config/os/generic/bits}.  However, these files will almost\n+certainly need some modification.\n+\n+The first file to write is @file{bits/ctype_base.h}.  This file provides\n+some very basic information about character classification.  The V3\n+library assumes that your C library implements @file{<ctype.h>} by using\n+a table (indexed by character code) containing integers, where each of\n+these integers is a bit-mask indicating whether the charcter is\n+upper-case, lower-case, alphabetic, etc.  The @file{bits/ctype_base.h}\n+file gives the type of the integer, and the values of the various bit\n+masks.  You will have to peer at your own @file{<ctype.h>} to figure out\n+how to define the values required by this file.\n+\n+The @file{bits/ctype_base.h} header file does not need include guards.\n+It should contain a single @code{struct} definition called\n+@code{ctype_base}.  This @code{struct} should contain two type\n+declarations, and one enumeration declaration, like this example, taken\n+from the IRIX configuration:\n+\n+@example\n+struct ctype_base\n+@{\n+  typedef unsigned int \tmask;\n+  typedef int* \t\t__to_type;\n+\n+  enum\n+  @{\n+    space = _ISspace,\n+    print = _ISprint,\n+    cntrl = _IScntrl,\n+    upper = _ISupper,\n+    lower = _ISlower,\n+    alpha = _ISalpha,\n+    digit = _ISdigit,\n+    punct = _ISpunct,\n+    xdigit = _ISxdigit,\n+    alnum = _ISalnum,\n+    graph = _ISgraph\n+  @};\n+@};\n+@end example\n+\n+@noindent\n+The @code{mask} type is the type of the elements in the table.  If your\n+C library uses a table to map lower-case numbers to upper-case numbers,\n+and vice versa, you should define @code{__to_type} to be the type of the\n+elements in that table.  If you don't mind taking a minor performance\n+penalty, or if your library doesn't implement @code{toupper} and\n+@code{tolower} in this way, you can pick any pointer-to-integer type,\n+but you must still define the type.\n+\n+The enumeration should give definitions for all the values in the above\n+example, using the values from your native @file{<ctype.h>}.  They can\n+be given symbolically (as above), or numerically, if you prefer.  You do\n+not have to include @file{<ctype.h>} in this header; it will always be\n+included before @file{bits/ctype_base.h} is included.\n+\n+The next file to write is @file{bits/ctype_noninline.h}, which also does\n+not require include guards.  This file defines a few member functions\n+that will be included in @file{include/bits/locale_facets.h}.  The first\n+function that must be written is the @code{ctype<char>::ctype}\n+constructor.  Here is the IRIX example:\n+\n+@example\n+ctype<char>::ctype(const mask* __table = 0, bool __del = false, \n+      size_t __refs = 0)\n+  : _Ctype_nois<char>(__refs), _M_del(__table != 0 && __del), \n+    _M_toupper(NULL),\n+    _M_tolower(NULL),\n+    _M_ctable(NULL), \n+    _M_table(!__table\n+             ? (const mask*) (__libc_attr._ctype_tbl->_class + 1)\n+             : __table) \n+  @{ @}\n+@end example\n+\n+@noindent\n+There are two parts of this that you might choose to alter. The first,\n+and most important, is the line involving @code{__libc_attr}.  That is\n+IRIX system-dependent code that gets the base of the table mapping\n+character codes to attributes.  You need to substitute code that obtains\n+the address of this table on your system.  If you want to use your\n+operating system's tables to map upper-case letters to lower-case, and\n+vice versa, you should initialize @code{_M_toupper} and\n+@code{_M_tolower} with those tables, in similar fashion.\n+\n+Now, you have to write two functions to convert from upper-case to\n+lower-case, and vice versa.  Here are the IRIX versions:\n+\n+@example\n+char\n+ctype<char>::do_toupper(char __c) const\n+@{ return _toupper(__c); @}\n+\n+char\n+ctype<char>::do_tolower(char __c) const\n+@{ return _tolower(__c); @}\n+@end example\n+\n+@noindent\n+Your C library provides equivalents to IRIX's @code{_toupper} and\n+@code{_tolower}.  If you initialized @code{_M_toupper} and\n+@code{_M_tolower} above, then you could use those tables instead.\n+\n+Finally, you have to provide two utility functions that convert strings\n+of characters.  The versions provided here will always work -- but you\n+could use specialized routines for greater performance if you have\n+machinery to do that on your system:\n+\n+@example\n+const char*\n+ctype<char>::do_toupper(char* __low, const char* __high) const\n+@{\n+  while (__low < __high)\n+    @{\n+      *__low = do_toupper(*__low);\n+      ++__low;\n+    @}\n+  return __high;\n+@}\n+\n+const char* \n+ctype<char>::do_tolower(char* __low, const char* __high) const\n+@{\n+  while (__low < __high)\n+    @{\n+      *__low = do_tolower(*__low);\n+      ++__low;\n+    @}\n+  return __high;\n+@}\n+@end example\n+\n+You must also provide the @file{bits/ctype_inline.h} file, which\n+contains a few more functions.  On most systems, you can just copy\n+@file{config/os/generic/ctype_inline.h} and use it on your system.\n+\n+In detail, the functions provided test characters for particular\n+properties; they are analagous to the functions like @code{isalpha} and\n+@code{islower} provided by the C library.\n+\n+The first function is implemented like this on IRIX:\n+\n+@example\n+bool\n+ctype<char>::\n+is(mask __m, char __c) const throw()\n+@{ return (_M_table)[(unsigned char)(__c)] & __m; @}\n+@end example\n+\n+@noindent\n+The @code{_M_table} is the table passed in above, in the constructor.\n+This is the table that contains the bitmasks for each character.  The\n+implementation here should work on all systems.\n+\n+The next function is:\n+\n+@example\n+const char*\n+ctype<char>::\n+is(const char* __low, const char* __high, mask* __vec) const throw()\n+@{\n+  while (__low < __high)\n+    *__vec++ = (_M_table)[(unsigned char)(*__low++)];\n+  return __high;\n+@}\n+@end example\n+\n+@noindent\n+This function is similar; it copies the masks for all the characters\n+from @code{__low} up until @code{__high} into the vector given by\n+@code{__vec}.\n+\n+The last two functions again are entirely generic:\n+\n+@example\n+const char*\n+ctype<char>::\n+scan_is(mask __m, const char* __low, const char* __high) const throw()\n+@{\n+  while (__low < __high && !this->is(__m, *__low))\n+    ++__low;\n+  return __low;\n+@}\n+\n+const char*\n+ctype<char>::\n+scan_not(mask __m, const char* __low, const char* __high) const throw()\n+@{\n+  while (__low < __high && this->is(__m, *__low))\n+    ++__low;\n+  return __low;\n+@}\n+@end example\n+\n+@c ---------------------------------------------------------------------\n+@c Thread safety\n+@c ---------------------------------------------------------------------\n+\n+@node Thread safety\n+@chapter Thread safety\n+\n+The C++ library string functionality requires a couple of atomic\n+operations to provide thread-safety.  If you don't take any special\n+action, the library will use stub versions of these functions that are\n+not thread-safe.  They will work fine, unless your applications are\n+multi-threaded.\n+\n+If you want to provide custom, safe, versions of these functions, there\n+are two distinct approaches.  One is to provide a version for your CPU,\n+using assembly language constructs.  The other is to use the\n+thread-safety primitives in your operating system.  In either case, you\n+make a file called @file{bits/atomicity.h}.  \n+\n+If you are using the assembly-language approach, put this code in\n+@file{config/cpu/<chip>/bits/atomicity.h}, where chip is the name of\n+your chip.  In that case, edit the switch statement in\n+@file{configure.target} to set the @code{cpu_include_dir}.  In either\n+case, set the switch statement that sets @code{ATOMICITYH} to be the\n+directory containing @file{bits/atomicity.h}.\n+\n+With those bits out of the way, you have to actually write\n+@file{bits/atomicity.h} itself.  This file should be wrapped in an\n+include guard named @code{_BITS_ATOMICITY_H}.  It should define one\n+type, and two functions.  \n+\n+The type is @code{_Atomic_word}.  Here is the version used on IRIX:\n+\n+@example\n+typedef long _Atomic_word;\n+@end example\n+\n+@noindent\n+This type must be a signed integral type supporting atomic operations.\n+If you're using the OS approach, use the same type used by your system's\n+primitives.  Otherwise, use the type for which your CPU provides atomic\n+primitives.\n+\n+Then, you must provide two functions.  The bodies of these functions\n+must be equivalent to those provided here, but using atomic operations:\n+\n+@example\n+static inline _Atomic_word\n+__attribute__ ((__unused__))\n+__exchange_and_add (_Atomic_word* __mem, int __val)\n+@{\n+  _Atomic_word __result = *__mem;\n+  *__mem += __val;\n+  return __result;\n+@}\n+\n+static inline void\n+__attribute__ ((__unused__))\n+__atomic_add (_Atomic_word* __mem, int __val)\n+@{\n+  *__mem += __val;\n+@}\n+@end example\n+\n+@c ---------------------------------------------------------------------\n+@c Libtool\n+@c ---------------------------------------------------------------------\n+\n+@node Libtool\n+@chapter Libtool\n+\n+The C++ library is linked with libtool.  Explaining the full workings of\n+libtool is beyond the scope of this document, but there is one\n+particular bit that should be explained here.  The C++ run-time library\n+contains initialization code that needs to be run as the library is\n+loaded.  Often, that requires linking in special object files when the\n+C++ library is built as a shared library, or taking other\n+system-specific actions.\n+\n+The V3 library is linked with the C version of libtool, even though it\n+is a C++ library.  Therefore, the C version of libtool needs to ensure\n+that the run-time library initializers are run.  The usual way to do\n+this is to build the library using @code{gcc -shared}.\n+\n+If you need to change how the library is linked, look at\n+@file{ltcf-c.sh} in the top-level directory.  Find the switch statement\n+that sets @code{archive_cmds}.  Here, adjust the setting for your\n+operating system.\n+\n+@c ---------------------------------------------------------------------\n+@c Epilogue\n+@c ---------------------------------------------------------------------\n+\n+@contents\n+@bye"}]}