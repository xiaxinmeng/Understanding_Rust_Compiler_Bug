{"sha": "eb6f9a86c5a7406cabd069093d34d435cf92bd13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2ZjlhODZjNWE3NDA2Y2FiZDA2OTA5M2QzNGQ0MzVjZjkyYmQxMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-06-19T15:33:55Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-06-19T15:33:55Z"}, "message": "gfortran.h (gfc_expr): Use mpc_t to represent complex numbers.\n\n\t* gfortran.h (gfc_expr): Use mpc_t to represent complex numbers.\n\n\t* arith.c, dump-parse-tree.c, expr.c, module.c, resolve.c,\n\tsimplify.c, target-memory.c, target-memory.h, trans-const.c,\n\ttrans-expr.c: Convert to mpc_t throughout.\n\nFrom-SVN: r148711", "tree": {"sha": "83e5c787fecb044f7803f22a3aa5b3d699b063b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e5c787fecb044f7803f22a3aa5b3d699b063b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6f9a86c5a7406cabd069093d34d435cf92bd13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6f9a86c5a7406cabd069093d34d435cf92bd13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6f9a86c5a7406cabd069093d34d435cf92bd13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6f9a86c5a7406cabd069093d34d435cf92bd13/comments", "author": null, "committer": null, "parents": [{"sha": "642324bb16ffe88f0aa81c4ced9bdc1ba63471ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642324bb16ffe88f0aa81c4ced9bdc1ba63471ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642324bb16ffe88f0aa81c4ced9bdc1ba63471ab"}], "stats": {"total": 416, "additions": 313, "deletions": 103}, "files": [{"sha": "911e14312c03322c9354f9cb63de31193009a153", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -1,3 +1,11 @@\n+2009-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gfortran.h (gfc_expr): Use mpc_t to represent complex numbers.\n+\n+\t* arith.c, dump-parse-tree.c, expr.c, module.c, resolve.c,\n+\tsimplify.c, target-memory.c, target-memory.h, trans-const.c,\n+\ttrans-expr.c: Convert to mpc_t throughout.\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* cpp.c (struct gfc_cpp_option_data): Give this struct, used for"}, {"sha": "2aa3c40fd4098f7f69ffa258ff32589c139e169d", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 146, "deletions": 38, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -429,8 +429,12 @@ gfc_constant_result (bt type, int kind, locus *where)\n \n     case BT_COMPLEX:\n       gfc_set_model_kind (kind);\n+#ifdef HAVE_mpc\n+      mpc_init2 (result->value.complex, mpfr_get_default_prec());\n+#else\n       mpfr_init (result->value.complex.r);\n       mpfr_init (result->value.complex.i);\n+#endif\n       break;\n \n     default:\n@@ -543,21 +547,23 @@ gfc_range_check (gfc_expr *e)\n       break;\n \n     case BT_COMPLEX:\n-      rc = gfc_check_real_range (e->value.complex.r, e->ts.kind);\n+      rc = gfc_check_real_range (mpc_realref (e->value.complex), e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-\tmpfr_set_ui (e->value.complex.r, 0, GFC_RND_MODE);\n+\tmpfr_set_ui (mpc_realref (e->value.complex), 0, GFC_RND_MODE);\n       if (rc == ARITH_OVERFLOW)\n-\tmpfr_set_inf (e->value.complex.r, mpfr_sgn (e->value.complex.r));\n+\tmpfr_set_inf (mpc_realref (e->value.complex),\n+\t\t      mpfr_sgn (mpc_realref (e->value.complex)));\n       if (rc == ARITH_NAN)\n-\tmpfr_set_nan (e->value.complex.r);\n+\tmpfr_set_nan (mpc_realref (e->value.complex));\n \n-      rc2 = gfc_check_real_range (e->value.complex.i, e->ts.kind);\n+      rc2 = gfc_check_real_range (mpc_imagref (e->value.complex), e->ts.kind);\n       if (rc == ARITH_UNDERFLOW)\n-\tmpfr_set_ui (e->value.complex.i, 0, GFC_RND_MODE);\n+\tmpfr_set_ui (mpc_imagref (e->value.complex), 0, GFC_RND_MODE);\n       if (rc == ARITH_OVERFLOW)\n-\tmpfr_set_inf (e->value.complex.i, mpfr_sgn (e->value.complex.i));\n+\tmpfr_set_inf (mpc_imagref (e->value.complex), \n+\t\t      mpfr_sgn (mpc_imagref (e->value.complex)));\n       if (rc == ARITH_NAN)\n-\tmpfr_set_nan (e->value.complex.i);\n+\tmpfr_set_nan (mpc_imagref (e->value.complex));\n \n       if (rc == ARITH_OK)\n \trc = rc2;\n@@ -633,8 +639,12 @@ gfc_arith_uminus (gfc_expr *op1, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+      mpc_neg (result->value.complex, op1->value.complex, GFC_MPC_RND_MODE);\n+#else\n       mpfr_neg (result->value.complex.r, op1->value.complex.r, GFC_RND_MODE);\n       mpfr_neg (result->value.complex.i, op1->value.complex.i, GFC_RND_MODE);\n+#endif\n       break;\n \n     default:\n@@ -667,11 +677,16 @@ gfc_arith_plus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+      mpc_add (result->value.complex, op1->value.complex, op2->value.complex,\n+\t       GFC_MPC_RND_MODE);\n+#else\n       mpfr_add (result->value.complex.r, op1->value.complex.r,\n \t\top2->value.complex.r, GFC_RND_MODE);\n \n       mpfr_add (result->value.complex.i, op1->value.complex.i,\n \t\top2->value.complex.i, GFC_RND_MODE);\n+#endif\n       break;\n \n     default:\n@@ -704,11 +719,16 @@ gfc_arith_minus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+      mpc_sub (result->value.complex, op1->value.complex,\n+\t       op2->value.complex, GFC_MPC_RND_MODE);\n+#else\n       mpfr_sub (result->value.complex.r, op1->value.complex.r,\n \t\top2->value.complex.r, GFC_RND_MODE);\n \n       mpfr_sub (result->value.complex.i, op1->value.complex.i,\n \t\top2->value.complex.i, GFC_RND_MODE);\n+#endif\n       break;\n \n     default:\n@@ -725,7 +745,6 @@ static arith\n gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n-  mpfr_t x, y;\n   arith rc;\n \n   result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n@@ -742,7 +761,13 @@ gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-      gfc_set_model (op1->value.complex.r);\n+      gfc_set_model (mpc_realref (op1->value.complex));\n+#ifdef HAVE_mpc\n+      mpc_mul (result->value.complex, op1->value.complex, op2->value.complex,\n+\t       GFC_MPC_RND_MODE);\n+#else\n+    {\n+      mpfr_t x, y;\n       mpfr_init (x);\n       mpfr_init (y);\n \n@@ -755,6 +780,8 @@ gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       mpfr_add (result->value.complex.i, x, y, GFC_RND_MODE);\n \n       mpfr_clears (x, y, NULL);\n+    }\n+#endif\n       break;\n \n     default:\n@@ -771,7 +798,6 @@ static arith\n gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n-  mpfr_t x, y, div;\n   arith rc;\n \n   rc = ARITH_OK;\n@@ -803,15 +829,35 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-      if (mpfr_sgn (op2->value.complex.r) == 0\n+      if (\n+#ifdef HAVE_mpc\n+\t  mpc_cmp_si_si (op2->value.complex, 0, 0) == 0\n+#else\n+\t  mpfr_sgn (op2->value.complex.r) == 0\n \t  && mpfr_sgn (op2->value.complex.i) == 0\n+#endif\n \t  && gfc_option.flag_range_check == 1)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n \t}\n \n-      gfc_set_model (op1->value.complex.r);\n+      gfc_set_model (mpc_realref (op1->value.complex));\n+\t  \n+#ifdef HAVE_mpc\n+      if (mpc_cmp_si_si (op2->value.complex, 0, 0) == 0)\n+      {\n+\t/* In Fortran, return (NaN + NaN I) for any zero divisor.  See\n+\t   PR 40318. */\n+\tmpfr_set_nan (mpc_realref (result->value.complex));\n+\tmpfr_set_nan (mpc_imagref (result->value.complex));\n+      }\n+      else\n+\tmpc_div (result->value.complex, op1->value.complex, op2->value.complex,\n+\t\t GFC_MPC_RND_MODE);\n+#else\n+    {\n+      mpfr_t x, y, div;\n       mpfr_init (x);\n       mpfr_init (y);\n       mpfr_init (div);\n@@ -833,6 +879,8 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t\tGFC_RND_MODE);\n \n       mpfr_clears (x, y, div, NULL);\n+    }\n+#endif\n       break;\n \n     default:\n@@ -851,9 +899,13 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n static void\n complex_reciprocal (gfc_expr *op)\n {\n+  gfc_set_model (mpc_realref (op->value.complex));\n+#ifdef HAVE_mpc\n+  mpc_ui_div (op->value.complex, 1, op->value.complex, GFC_MPC_RND_MODE);\n+#else\n+  {\n   mpfr_t mod, tmp;\n \n-  gfc_set_model (op->value.complex.r);\n   mpfr_init (mod);\n   mpfr_init (tmp);\n \n@@ -867,6 +919,8 @@ complex_reciprocal (gfc_expr *op)\n   mpfr_div (op->value.complex.i, op->value.complex.i, mod, GFC_RND_MODE);\n \n   mpfr_clears (tmp, mod, NULL);\n+  }\n+#endif\n }\n \n \n@@ -883,20 +937,24 @@ complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n {\n   mpfr_t x_r, x_i, tmp, re, im;\n \n-  gfc_set_model (base->value.complex.r);\n+  gfc_set_model (mpc_realref (base->value.complex));\n   mpfr_init (x_r);\n   mpfr_init (x_i);\n   mpfr_init (tmp);\n   mpfr_init (re);\n   mpfr_init (im);\n \n   /* res = 1 */\n+#ifdef HAVE_mpc\n+  mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n+#else\n   mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n   mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \n   /* x = base */\n-  mpfr_set (x_r, base->value.complex.r, GFC_RND_MODE);\n-  mpfr_set (x_i, base->value.complex.i, GFC_RND_MODE);\n+  mpfr_set (x_r, mpc_realref (base->value.complex), GFC_RND_MODE);\n+  mpfr_set (x_i, mpc_imagref (base->value.complex), GFC_RND_MODE);\n \n   /* Macro for complex multiplication. We have to take care that\n      res_r/res_i and a_r/a_i can (and will) be the same variable.  */\n@@ -910,8 +968,8 @@ complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n     mpfr_add (res_i, im, tmp, GFC_RND_MODE), \\\n     mpfr_set (res_r, re, GFC_RND_MODE)\n   \n-#define res_r result->value.complex.r\n-#define res_i result->value.complex.i\n+#define res_r mpc_realref (result->value.complex)\n+#define res_i mpc_imagref (result->value.complex)\n \n   /* for (; power > 0; x *= x) */\n   for (; mpz_cmp_si (power, 0) > 0; CMULT(x_r,x_i,x_r,x_i,x_r,x_i))\n@@ -966,8 +1024,12 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t      break;\n \n \t    case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+\t      mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n+#else\n \t      mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n \t      mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \t      break;\n \n \t    default:\n@@ -1089,8 +1151,6 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n     case BT_COMPLEX:\n       {\n-\tmpfr_t x, y, r, t;\n-\n \tif (init_flag)\n \t  {\n \t    if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n@@ -1099,42 +1159,58 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t      return ARITH_PROHIBIT;\n \t  }\n \n-\tgfc_set_model (op1->value.complex.r);\n+\t{\n+\tmpfr_t x, y, r, t;\n+\n+\tgfc_set_model (mpc_realref (op1->value.complex));\n \n \tmpfr_init (r);\n \n+#ifdef HAVE_mpc\n+\tmpc_abs (r, op1->value.complex, GFC_RND_MODE);\n+#else\n \tmpfr_hypot (r, op1->value.complex.r, op1->value.complex.i,\n \t\t    GFC_RND_MODE);\n+#endif\n \tif (mpfr_cmp_si (r, 0) == 0)\n \t  {\n+#ifdef HAVE_mpc\n+\t    mpc_set_ui (result->value.complex, 0, GFC_MPC_RND_MODE);\n+#else\n \t    mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n \t    mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \t    mpfr_clear (r);\n \t    break;\n \t  }\n \tmpfr_log (r, r, GFC_RND_MODE);\n \n \tmpfr_init (t);\n \n+#ifdef HAVE_mpc\n+\tmpc_arg (t, op1->value.complex, GFC_RND_MODE);\n+#else\n \tmpfr_atan2 (t, op1->value.complex.i, op1->value.complex.r, \n \t\t    GFC_RND_MODE);\n+#endif\n \n \tmpfr_init (x);\n \tmpfr_init (y);\n \n-\tmpfr_mul (x, op2->value.complex.r, r, GFC_RND_MODE);\n-\tmpfr_mul (y, op2->value.complex.i, t, GFC_RND_MODE);\n+\tmpfr_mul (x, mpc_realref (op2->value.complex), r, GFC_RND_MODE);\n+\tmpfr_mul (y, mpc_imagref (op2->value.complex), t, GFC_RND_MODE);\n \tmpfr_sub (x, x, y, GFC_RND_MODE);\n \tmpfr_exp (x, x, GFC_RND_MODE);\n \n-\tmpfr_mul (y, op2->value.complex.r, t, GFC_RND_MODE);\n-\tmpfr_mul (t, op2->value.complex.i, r, GFC_RND_MODE);\n+\tmpfr_mul (y, mpc_realref (op2->value.complex), t, GFC_RND_MODE);\n+\tmpfr_mul (t, mpc_imagref (op2->value.complex), r, GFC_RND_MODE);\n \tmpfr_add (y, y, t, GFC_RND_MODE);\n \tmpfr_cos (t, y, GFC_RND_MODE);\n \tmpfr_sin (y, y, GFC_RND_MODE);\n-\tmpfr_mul (result->value.complex.r, x, t, GFC_RND_MODE);\n-\tmpfr_mul (result->value.complex.i, x, y, GFC_RND_MODE);\n+\tmpfr_mul (mpc_realref (result->value.complex), x, t, GFC_RND_MODE);\n+\tmpfr_mul (mpc_imagref (result->value.complex), x, y, GFC_RND_MODE);\n \tmpfr_clears (r, t, x, y, NULL);\n+\t}\n       }\n       break;\n     default:\n@@ -1252,8 +1328,12 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n static int\n compare_complex (gfc_expr *op1, gfc_expr *op2)\n {\n+#ifdef HAVE_mpc\n+  return mpc_cmp (op1->value.complex, op2->value.complex) == 0;\n+#else\n   return (mpfr_equal_p (op1->value.complex.r, op2->value.complex.r)\n \t  && mpfr_equal_p (op1->value.complex.i, op2->value.complex.i));\n+#endif\n }\n \n \n@@ -2122,8 +2202,13 @@ gfc_convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n   gfc_expr *e;\n \n   e = gfc_constant_result (BT_COMPLEX, kind, &real->where);\n+#ifdef HAVE_mpc\n+  mpc_set_fr_fr (e->value.complex, real->value.real, imag->value.real,\n+\t\t GFC_MPC_RND_MODE);\n+#else\n   mpfr_set (e->value.complex.r, real->value.real, GFC_RND_MODE);\n   mpfr_set (e->value.complex.i, imag->value.real, GFC_RND_MODE);\n+#endif\n \n   return e;\n }\n@@ -2243,10 +2328,15 @@ gfc_int2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n+#ifdef HAVE_mpc\n+  mpc_set_z (result->value.complex, src->value.integer, GFC_MPC_RND_MODE);\n+#else\n   mpfr_set_z (result->value.complex.r, src->value.integer, GFC_RND_MODE);\n   mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \n-  if ((rc = gfc_check_real_range (result->value.complex.r, kind)) != ARITH_OK)\n+  if ((rc = gfc_check_real_range (mpc_realref (result->value.complex), kind))\n+      != ARITH_OK)\n     {\n       arith_error (rc, &src->ts, &result->ts, &src->where);\n       gfc_free_expr (result);\n@@ -2321,16 +2411,20 @@ gfc_real2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n+#ifdef HAVE_mpc\n+  mpc_set_fr (result->value.complex, src->value.real, GFC_MPC_RND_MODE);\n+#else\n   mpfr_set (result->value.complex.r, src->value.real, GFC_RND_MODE);\n   mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \n-  rc = gfc_check_real_range (result->value.complex.r, kind);\n+  rc = gfc_check_real_range (mpc_realref (result->value.complex), kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n \tgfc_warning (gfc_arith_error (rc), &src->where);\n-      mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n+      mpfr_set_ui (mpc_realref (result->value.complex), 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2353,7 +2447,8 @@ gfc_complex2int (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n \n-  gfc_mpfr_to_mpz (result->value.integer, src->value.complex.r, &src->where);\n+  gfc_mpfr_to_mpz (result->value.integer, mpc_realref (src->value.complex),\n+\t\t   &src->where);\n \n   if ((rc = gfc_check_integer_range (result->value.integer, kind)) != ARITH_OK)\n     {\n@@ -2376,7 +2471,11 @@ gfc_complex2real (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_REAL, kind, &src->where);\n \n+#ifdef HAVE_mpc\n+  mpc_real (result->value.real, src->value.complex, GFC_RND_MODE);\n+#else\n   mpfr_set (result->value.real, src->value.complex.r, GFC_RND_MODE);\n+#endif\n \n   rc = gfc_check_real_range (result->value.real, kind);\n \n@@ -2407,16 +2506,20 @@ gfc_complex2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n+#ifdef HAVE_mpc\n+  mpc_set (result->value.complex, src->value.complex, GFC_MPC_RND_MODE);\n+#else\n   mpfr_set (result->value.complex.r, src->value.complex.r, GFC_RND_MODE);\n   mpfr_set (result->value.complex.i, src->value.complex.i, GFC_RND_MODE);\n+#endif\n \n-  rc = gfc_check_real_range (result->value.complex.r, kind);\n+  rc = gfc_check_real_range (mpc_realref (result->value.complex), kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n \tgfc_warning (gfc_arith_error (rc), &src->where);\n-      mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n+      mpfr_set_ui (mpc_realref (result->value.complex), 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2425,13 +2528,13 @@ gfc_complex2complex (gfc_expr *src, int kind)\n       return NULL;\n     }\n \n-  rc = gfc_check_real_range (result->value.complex.i, kind);\n+  rc = gfc_check_real_range (mpc_imagref (result->value.complex), kind);\n \n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n \tgfc_warning (gfc_arith_error (rc), &src->where);\n-      mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+      mpfr_set_ui (mpc_imagref (result->value.complex), 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n     {\n@@ -2579,8 +2682,13 @@ gfc_hollerith2complex (gfc_expr *src, int kind)\n \n   hollerith2representation (result, src);\n   gfc_interpret_complex (kind, (unsigned char *) result->representation.string,\n-\t\t\t result->representation.length, result->value.complex.r,\n-\t\t\t result->value.complex.i);\n+\t\t\t result->representation.length,\n+#ifdef HAVE_mpc\n+\t\t\t result->value.complex\n+#else\n+\t\t\t result->value.complex.r, result->value.complex.i\n+#endif\n+\t\t\t );\n \n   return result;\n }"}, {"sha": "cfd8a7d9d04a93b9d111c9c540b8bd423fd6d6de", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -402,13 +402,15 @@ show_expr (gfc_expr *p)\n \tcase BT_COMPLEX:\n \t  fputs (\"(complex \", dumpfile);\n \n-\t  mpfr_out_str (stdout, 10, 0, p->value.complex.r, GFC_RND_MODE);\n+\t  mpfr_out_str (stdout, 10, 0, mpc_realref (p->value.complex),\n+\t\t\tGFC_RND_MODE);\n \t  if (p->ts.kind != gfc_default_complex_kind)\n \t    fprintf (dumpfile, \"_%d\", p->ts.kind);\n \n \t  fputc (' ', dumpfile);\n \n-\t  mpfr_out_str (stdout, 10, 0, p->value.complex.i, GFC_RND_MODE);\n+\t  mpfr_out_str (stdout, 10, 0, mpc_imagref (p->value.complex),\n+\t\t\tGFC_RND_MODE);\n \t  if (p->ts.kind != gfc_default_complex_kind)\n \t    fprintf (dumpfile, \"_%d\", p->ts.kind);\n "}, {"sha": "d2f73d6d461b9f08c9c67261055495a3190fdfa9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -156,8 +156,12 @@ free_expr0 (gfc_expr *e)\n \t  break;\n \n \tcase BT_COMPLEX:\n+#ifdef HAVE_mpc\n+\t  mpc_clear (e->value.complex);\n+#else\n \t  mpfr_clear (e->value.complex.r);\n \t  mpfr_clear (e->value.complex.i);\n+#endif\n \t  break;\n \n \tdefault:\n@@ -439,10 +443,15 @@ gfc_copy_expr (gfc_expr *p)\n \n \tcase BT_COMPLEX:\n \t  gfc_set_model_kind (q->ts.kind);\n+#ifdef HAVE_mpc\n+\t  mpc_init2 (q->value.complex, mpfr_get_default_prec());\n+\t  mpc_set (q->value.complex, p->value.complex, GFC_MPC_RND_MODE);\n+#else\n \t  mpfr_init (q->value.complex.r);\n \t  mpfr_init (q->value.complex.i);\n \t  mpfr_set (q->value.complex.r, p->value.complex.r, GFC_RND_MODE);\n \t  mpfr_set (q->value.complex.i, p->value.complex.i, GFC_RND_MODE);\n+#endif\n \t  break;\n \n \tcase BT_CHARACTER:"}, {"sha": "f0de489d3df8a1d89f758e4702690d28bde829f4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -1555,6 +1555,12 @@ gfc_intrinsic_sym;\n \n #include <gmp.h>\n #include <mpfr.h>\n+#ifdef HAVE_mpc\n+#include <mpc.h>\n+#else\n+#define mpc_realref(X) ((X).r)\n+#define mpc_imagref(X) ((X).i)\n+#endif\n #define GFC_RND_MODE GMP_RNDN\n #define GFC_MPC_RND_MODE MPC_RNDNN\n \n@@ -1613,10 +1619,14 @@ typedef struct gfc_expr\n \n     mpfr_t real;\n \n+#ifdef HAVE_mpc\n+    mpc_t\n+#else\n     struct\n     {\n       mpfr_t r, i;\n     }\n+#endif\n     complex;\n \n     struct"}, {"sha": "8cf829af4085771b2ee2b578f038b940d09aa525", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -3027,8 +3027,8 @@ mio_expr (gfc_expr **ep)\n \n \tcase BT_COMPLEX:\n \t  gfc_set_model_kind (e->ts.kind);\n-\t  mio_gmp_real (&e->value.complex.r);\n-\t  mio_gmp_real (&e->value.complex.i);\n+\t  mio_gmp_real (&mpc_realref (e->value.complex));\n+\t  mio_gmp_real (&mpc_imagref (e->value.complex));\n \t  break;\n \n \tcase BT_LOGICAL:"}, {"sha": "ccee61f00f09087bf8660c5778b63b0c39a28044", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -7610,31 +7610,39 @@ build_default_init_expr (gfc_symbol *sym)\n       break;\n \t  \n     case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+      mpc_init2 (init_expr->value.complex, mpfr_get_default_prec());\n+#else\n       mpfr_init (init_expr->value.complex.r);\n       mpfr_init (init_expr->value.complex.i);\n+#endif\n       switch (gfc_option.flag_init_real)\n \t{\n \tcase GFC_INIT_REAL_SNAN:\n \t  init_expr->is_snan = 1;\n \t  /* Fall through.  */\n \tcase GFC_INIT_REAL_NAN:\n-\t  mpfr_set_nan (init_expr->value.complex.r);\n-\t  mpfr_set_nan (init_expr->value.complex.i);\n+\t  mpfr_set_nan (mpc_realref (init_expr->value.complex));\n+\t  mpfr_set_nan (mpc_imagref (init_expr->value.complex));\n \t  break;\n \n \tcase GFC_INIT_REAL_INF:\n-\t  mpfr_set_inf (init_expr->value.complex.r, 1);\n-\t  mpfr_set_inf (init_expr->value.complex.i, 1);\n+\t  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);\n+\t  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);\n \t  break;\n \n \tcase GFC_INIT_REAL_NEG_INF:\n-\t  mpfr_set_inf (init_expr->value.complex.r, -1);\n-\t  mpfr_set_inf (init_expr->value.complex.i, -1);\n+\t  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);\n+\t  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);\n \t  break;\n \n \tcase GFC_INIT_REAL_ZERO:\n+#ifdef HAVE_mpc\n+\t  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);\n+#else\n \t  mpfr_set_ui (init_expr->value.complex.r, 0.0, GFC_RND_MODE);\n \t  mpfr_set_ui (init_expr->value.complex.i, 0.0, GFC_RND_MODE);\n+#endif\n \t  break;\n \n \tdefault:"}, {"sha": "11650f3ee48841796dfa1f637b2a0c62c0cc691b", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -214,26 +214,6 @@ convert_mpz_to_signed (mpz_t x, int bitsize)\n     }\n }\n \n-/* Helper function to convert to/from mpfr_t & mpc_t and call the\n-   supplied mpc function on the respective values.  */\n-\n-#ifdef HAVE_mpc\n-static void\n-call_mpc_func (mpfr_ptr result_re, mpfr_ptr result_im,\n-\t       mpfr_srcptr input_re, mpfr_srcptr input_im,\n-\t       int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n-{\n-  mpc_t c;\n-  mpc_init2 (c, mpfr_get_default_prec());\n-  mpc_set_fr_fr (c, input_re, input_im, GFC_MPC_RND_MODE);\n-  func (c, c, GFC_MPC_RND_MODE);\n-  mpfr_set (result_re, mpc_realref (c), GFC_RND_MODE);\n-  mpfr_set (result_im, mpc_imagref (c), GFC_RND_MODE);\n-  mpc_clear (c);\n-}\n-#endif\n-\n-\n /* Test that the expression is an constant array.  */\n \n static bool\n@@ -303,8 +283,12 @@ init_result_expr (gfc_expr *e, int init, gfc_expr *array)\n \t    break;\n \n \t  case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+\t    mpc_set_si (e->value.complex, init, GFC_MPC_RND_MODE);\n+#else\n \t    mpfr_set_si (e->value.complex.r, init, GFC_RND_MODE);\n \t    mpfr_set_si (e->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \t    break;\n \n \t  case BT_CHARACTER:\n@@ -660,8 +644,12 @@ gfc_simplify_abs (gfc_expr *e)\n \n       gfc_set_model_kind (e->ts.kind);\n \n+#ifdef HAVE_mpc\n+      mpc_abs (result->value.real, e->value.complex, GFC_RND_MODE);\n+#else\n       mpfr_hypot (result->value.real, e->value.complex.r, \n \t\t  e->value.complex.i, GFC_RND_MODE);\n+#endif\n       result = range_check (result, \"CABS\");\n       break;\n \n@@ -867,7 +855,7 @@ gfc_simplify_aimag (gfc_expr *e)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n-  mpfr_set (result->value.real, e->value.complex.i, GFC_RND_MODE);\n+  mpfr_set (result->value.real, mpc_imagref (e->value.complex), GFC_RND_MODE);\n \n   return range_check (result, \"AIMAG\");\n }\n@@ -1286,22 +1274,36 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &x->where);\n \n+#ifndef HAVE_mpc\n   mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+#endif\n \n   switch (x->ts.type)\n     {\n     case BT_INTEGER:\n       if (!x->is_boz)\n+#ifdef HAVE_mpc\n+\tmpc_set_z (result->value.complex, x->value.integer, GFC_MPC_RND_MODE);\n+#else\n \tmpfr_set_z (result->value.complex.r, x->value.integer, GFC_RND_MODE);\n+#endif\n       break;\n \n     case BT_REAL:\n+#ifdef HAVE_mpc\n+      mpc_set_fr (result->value.complex, x->value.real, GFC_RND_MODE);\n+#else\n       mpfr_set (result->value.complex.r, x->value.real, GFC_RND_MODE);\n+#endif\n       break;\n \n     case BT_COMPLEX:\n+#ifdef HAVE_mpc\n+      mpc_set (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+#else\n       mpfr_set (result->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n       mpfr_set (result->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n+#endif\n       break;\n \n     default:\n@@ -1314,12 +1316,13 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n \t{\n \tcase BT_INTEGER:\n \t  if (!y->is_boz)\n-\t    mpfr_set_z (result->value.complex.i, y->value.integer,\n-\t\t\tGFC_RND_MODE);\n+\t    mpfr_set_z (mpc_imagref (result->value.complex),\n+\t\t\ty->value.integer, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_REAL:\n-\t  mpfr_set (result->value.complex.i, y->value.real, GFC_RND_MODE);\n+\t  mpfr_set (mpc_imagref (result->value.complex),\n+\t\t    y->value.real, GFC_RND_MODE);\n \t  break;\n \n \tdefault:\n@@ -1336,7 +1339,8 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n       ts.type = BT_REAL;\n       if (!gfc_convert_boz (x, &ts))\n \treturn &gfc_bad_expr;\n-      mpfr_set (result->value.complex.r, x->value.real, GFC_RND_MODE);\n+      mpfr_set (mpc_realref (result->value.complex),\n+\t\tx->value.real, GFC_RND_MODE);\n     }\n \n   if (y && y->is_boz)\n@@ -1347,7 +1351,8 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n       ts.type = BT_REAL;\n       if (!gfc_convert_boz (y, &ts))\n \treturn &gfc_bad_expr;\n-      mpfr_set (result->value.complex.i, y->value.real, GFC_RND_MODE);\n+      mpfr_set (mpc_imagref (result->value.complex),\n+\t\ty->value.real, GFC_RND_MODE);\n     }\n \n   return range_check (result, name);\n@@ -1429,7 +1434,11 @@ gfc_simplify_conjg (gfc_expr *e)\n     return NULL;\n \n   result = gfc_copy_expr (e);\n+#ifdef HAVE_mpc\n+  mpc_conj (result->value.complex, result->value.complex, GFC_MPC_RND_MODE);\n+#else\n   mpfr_neg (result->value.complex.i, result->value.complex.i, GFC_RND_MODE);\n+#endif\n \n   return range_check (result, \"CONJG\");\n }\n@@ -1453,8 +1462,7 @@ gfc_simplify_cos (gfc_expr *x)\n     case BT_COMPLEX:\n       gfc_set_model_kind (x->ts.kind);\n #ifdef HAVE_mpc\n-      call_mpc_func (result->value.complex.r, result->value.complex.i,\n-\t\t     x->value.complex.r, x->value.complex.i, mpc_cos);\n+      mpc_cos (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n #else\n     {\n       mpfr_t xp, xq;\n@@ -1898,8 +1906,7 @@ gfc_simplify_exp (gfc_expr *x)\n     case BT_COMPLEX:\n       gfc_set_model_kind (x->ts.kind);\n #ifdef HAVE_mpc\n-      call_mpc_func (result->value.complex.r, result->value.complex.i,\n-\t\t     x->value.complex.r, x->value.complex.i, mpc_exp);\n+      mpc_exp (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n #else\n     {\n       mpfr_t xp, xq;\n@@ -3281,8 +3288,8 @@ gfc_simplify_log (gfc_expr *x)\n       break;\n \n     case BT_COMPLEX:\n-      if ((mpfr_sgn (x->value.complex.r) == 0)\n-\t  && (mpfr_sgn (x->value.complex.i) == 0))\n+      if ((mpfr_sgn (mpc_realref (x->value.complex)) == 0)\n+\t  && (mpfr_sgn (mpc_imagref (x->value.complex)) == 0))\n \t{\n \t  gfc_error (\"Complex argument of LOG at %L cannot be zero\",\n \t\t     &x->where);\n@@ -3292,8 +3299,7 @@ gfc_simplify_log (gfc_expr *x)\n \n       gfc_set_model_kind (x->ts.kind);\n #ifdef HAVE_mpc\n-      call_mpc_func (result->value.complex.r, result->value.complex.i,\n-\t\t     x->value.complex.r, x->value.complex.i, mpc_log);\n+      mpc_log (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n #else\n     {\n       mpfr_t xr, xi;\n@@ -4204,7 +4210,11 @@ gfc_simplify_realpart (gfc_expr *e)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n+#ifdef HAVE_mpc\n+  mpc_real (result->value.real, e->value.complex, GFC_RND_MODE);\n+#else\n   mpfr_set (result->value.real, e->value.complex.r, GFC_RND_MODE);\n+#endif\n \n   return range_check (result, \"REALPART\");\n }\n@@ -4986,8 +4996,7 @@ gfc_simplify_sin (gfc_expr *x)\n     case BT_COMPLEX:\n       gfc_set_model (x->value.real);\n #ifdef HAVE_mpc\n-      call_mpc_func (result->value.complex.r, result->value.complex.i,\n-\t\t     x->value.complex.r, x->value.complex.i, mpc_sin);\n+      mpc_sin (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n #else\n     {\n       mpfr_t xp, xq;\n@@ -5200,8 +5209,7 @@ gfc_simplify_sqrt (gfc_expr *e)\n     case BT_COMPLEX:\n       gfc_set_model (e->value.real);\n #ifdef HAVE_mpc\n-      call_mpc_func (result->value.complex.r, result->value.complex.i,\n-\t\t     e->value.complex.r, e->value.complex.i, mpc_sqrt);\n+      mpc_sqrt (result->value.complex, e->value.complex, GFC_MPC_RND_MODE);\n #else\n     {\n       /* Formula taken from Numerical Recipes to avoid over- and"}, {"sha": "4fe41d58ffb00954cba6877bf3288f35b9cd6f17", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -164,12 +164,29 @@ encode_float (int kind, mpfr_t real, unsigned char *buffer, size_t buffer_size)\n \n \n static int\n-encode_complex (int kind, mpfr_t real, mpfr_t imaginary, unsigned char *buffer,\n-\t\tsize_t buffer_size)\n+encode_complex (int kind,\n+#ifdef HAVE_mpc\n+\t\tmpc_t cmplx,\n+#else\n+\t\tmpfr_t real, mpfr_t imaginary,\n+#endif\n+\t\tunsigned char *buffer, size_t buffer_size)\n {\n   int size;\n-  size = encode_float (kind, real, &buffer[0], buffer_size);\n-  size += encode_float (kind, imaginary, &buffer[size], buffer_size - size);\n+  size = encode_float (kind,\n+#ifdef HAVE_mpc\n+\t\t       mpc_realref (cmplx),\n+#else\n+\t\t       real,\n+#endif\n+\t\t       &buffer[0], buffer_size);\n+  size += encode_float (kind,\n+#ifdef HAVE_mpc\n+\t\t\tmpc_imagref (cmplx),\n+#else\n+\t\t\timaginary,\n+#endif\n+\t\t\t&buffer[size], buffer_size - size);\n   return size;\n }\n \n@@ -266,8 +283,14 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n       return encode_float (source->ts.kind, source->value.real, buffer,\n \t\t\t   buffer_size);\n     case BT_COMPLEX:\n-      return encode_complex (source->ts.kind, source->value.complex.r,\n-\t\t\t     source->value.complex.i, buffer, buffer_size);\n+      return encode_complex (source->ts.kind,\n+#ifdef HAVE_mpc\n+\t\t\t     source->value.complex,\n+#else\n+\t\t\t     source->value.complex.r,\n+\t\t\t     source->value.complex.i,\n+#endif\n+\t\t\t     buffer, buffer_size);\n     case BT_LOGICAL:\n       return encode_logical (source->ts.kind, source->value.logical, buffer,\n \t\t\t     buffer_size);\n@@ -368,12 +391,28 @@ gfc_interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n \n int\n gfc_interpret_complex (int kind, unsigned char *buffer, size_t buffer_size,\n-\t\t   mpfr_t real, mpfr_t imaginary)\n+#ifdef HAVE_mpc\n+\t\t       mpc_t complex\n+#else\n+\t\t       mpfr_t real, mpfr_t imaginary\n+#endif\n+\t\t       )\n {\n   int size;\n-  size = gfc_interpret_float (kind, &buffer[0], buffer_size, real);\n+  size = gfc_interpret_float (kind, &buffer[0], buffer_size,\n+#ifdef HAVE_mpc\n+\t\t\t      mpc_realref (complex)\n+#else\n+\t\t\t      real\n+#endif\n+\t\t\t      );\n   size += gfc_interpret_float (kind, &buffer[size], buffer_size - size,\n-\t\t\t       imaginary);\n+#ifdef HAVE_mpc\n+\t\t\t       mpc_imagref (complex)\n+#else\n+\t\t\t       imaginary\n+#endif\n+\t\t\t       );\n   return size;\n }\n \n@@ -520,8 +559,13 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n     case BT_COMPLEX:\n       result->representation.length = \n         gfc_interpret_complex (result->ts.kind, buffer, buffer_size,\n+#ifdef HAVE_mpc\n+\t\t\t       result->value.complex\n+#else\n \t\t\t       result->value.complex.r,\n-\t\t\t       result->value.complex.i);\n+\t\t\t       result->value.complex.i\n+#endif\n+\t\t\t       );\n       break;\n \n     case BT_LOGICAL:\n@@ -722,10 +766,19 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n     }\n   else\n     {\n+#ifdef HAVE_mpc\n+      mpc_init2 (expr->value.complex, mpfr_get_default_prec());\n+#else\n       mpfr_init (expr->value.complex.r);\n       mpfr_init (expr->value.complex.i);\n+#endif\n       gfc_interpret_complex (ts->kind, buffer, buffer_size,\n-\t\t\t     expr->value.complex.r, expr->value.complex.i);\n+#ifdef HAVE_mpc\n+\t\t\t     expr->value.complex\n+#else\n+\t\t\t     expr->value.complex.r, expr->value.complex.i\n+#endif\n+\t\t\t     );\n     }\n   expr->is_boz = 0;  \n   expr->ts.type = ts->type;"}, {"sha": "0052e5aed8f6502346360fe8dfba61d732cb1aa0", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -39,7 +39,11 @@ int gfc_target_encode_expr (gfc_expr *, unsigned char *, size_t);\n \n int gfc_interpret_integer (int, unsigned char *, size_t, mpz_t);\n int gfc_interpret_float (int, unsigned char *, size_t, mpfr_t);\n+#ifdef HAVE_mpc\n+int gfc_interpret_complex (int, unsigned char *, size_t, mpc_t);\n+#else\n int gfc_interpret_complex (int, unsigned char *, size_t, mpfr_t, mpfr_t);\n+#endif\n int gfc_interpret_logical (int, unsigned char *, size_t, int *);\n int gfc_interpret_character (unsigned char *, size_t, gfc_expr *);\n int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);"}, {"sha": "4b7b2c027ee9c0884fdb1d734f24c7a72e6111d2", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -307,9 +307,9 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \t\t\t\t\t\t    expr->representation.string));\n       else\n \t{\n-\t  tree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,\n+\t  tree real = gfc_conv_mpfr_to_tree (mpc_realref (expr->value.complex),\n \t\t\t\t\t  expr->ts.kind, expr->is_snan);\n-\t  tree imag = gfc_conv_mpfr_to_tree (expr->value.complex.i,\n+\t  tree imag = gfc_conv_mpfr_to_tree (mpc_imagref (expr->value.complex),\n \t\t\t\t\t  expr->ts.kind, expr->is_snan);\n \n \t  return build_complex (gfc_typenode_for_spec (&expr->ts),"}, {"sha": "d363e6d3d5a9058bbbb7b20e15c748bbc8e1967f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6f9a86c5a7406cabd069093d34d435cf92bd13/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=eb6f9a86c5a7406cabd069093d34d435cf92bd13", "patch": "@@ -4407,10 +4407,10 @@ is_zero_initializer_p (gfc_expr * expr)\n       return expr->value.logical == 0;\n \n     case BT_COMPLEX:\n-      return mpfr_zero_p (expr->value.complex.r)\n-\t     && MPFR_SIGN (expr->value.complex.r) >= 0\n-             && mpfr_zero_p (expr->value.complex.i)\n-\t     && MPFR_SIGN (expr->value.complex.i) >= 0;\n+      return mpfr_zero_p (mpc_realref (expr->value.complex))\n+\t     && MPFR_SIGN (mpc_realref (expr->value.complex)) >= 0\n+             && mpfr_zero_p (mpc_imagref (expr->value.complex))\n+\t     && MPFR_SIGN (mpc_imagref (expr->value.complex)) >= 0;\n \n     default:\n       break;"}]}