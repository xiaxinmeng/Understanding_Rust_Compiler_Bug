{"sha": "49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhYjYwOThlZWZiOTQxNGQ4NDliNzlkZjNmMjdjZmM4MmMzZmZlNg==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2012-06-02T16:08:39Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2012-06-02T16:08:39Z"}, "message": "2012-06-2  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* expmed.c (expand_mult, choose_multiplier): Change \"2 *\n\tHOST_BITS_PER_WIDE_INT\" to \"HOST_BITS_PER_DOUBLE_INT\".\n\t* expr.c (convert_modes): Likewise.\n\t* explow.c (plus_constant): Likewise.\n\t* fixed-value.c (fixed_saturate1, fixed_saturate2)\n\t(do_fixed_add, do_fixed_multiply, do_fixed_multiply)\n\t(do_fixed_multiply, do_fixed_multiply, do_fixed_divide)\n\t(do_fixed_divide, do_fixed_divide, do_fixed_divide)\n\t(do_fixed_divide, do_fixed_divide, do_fixed_shift, do_fixed_shift)\n\t(do_fixed_shift, fixed_convert, fixed_convert)\n\t(fixed_convert_from_int, fixed_convert_from_int)\n\t(fixed_convert_from_real): Likewise.\n\t* fold-const.c (fold_convert_const_int_from_fixed, sign_bit_p)\n\t(native_interpret_int, fold_binary_loc, fold_ternary_loc): Likewise.\n\t* varasm.c (output_constructor_bitfield): Likewise.\n\t* tree-vrp.c (register_edge_assert_for_2): Likewise.\n\t* double-int.c (rshift_double, lshift_double): Likewise.\n\t* double-int.h (double_int_fits_in_uhwi_p, double_int, double_int): Likewise.\n\t* simplify-rtx.c (mode_signbit_p)\n\t(simplify_const_unary_operation, simplify_binary_operation_1)\n\t(simplify_immed_subreg): Likewise.\n\t* builtins.c (c_readstr, fold_builtin_bitop): Likewise.\n\t* tree-vect-generic.c (build_replicated_const): Likewise.\n\t* dbxout.c (stabstr_O): Likewise.\n\t* emit-rtl.c (immed_double_int_const, immed_double_const)\n\t(gen_lowpart_common, init_emit_once): Likewise.\n\t* tree.c (integer_pow2p, tree_log2, tree_floor_log2)\n\t(widest_int_cst_value, upper_bound_in_type): Likewise.\n\t* stor-layout.c (initialize_sizetypes, fixup_signed_type)\n\t(fixup_unsigned_type): Likewise.\n\t* real.c (real_to_integer2, real_from_integer): Likewise.\n\t* dwarf2out.c (size_of_loc_descr, size_of_die, output_die)\n\t(clz_loc_descriptor, mem_loc_descriptor): Likewise.\n\nFrom-SVN: r188139", "tree": {"sha": "54bcdf56261e3cfcb1001f1f939e53c80efd210e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54bcdf56261e3cfcb1001f1f939e53c80efd210e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3c888eb0e3923981bcb914f818c29a054843d9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c888eb0e3923981bcb914f818c29a054843d9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c888eb0e3923981bcb914f818c29a054843d9e"}], "stats": {"total": 224, "additions": 130, "deletions": 94}, "files": [{"sha": "5a43bb7a8e87b6c318d1c90087363e2aa3fedf07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -1,3 +1,39 @@\n+2012-06-2  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* expmed.c (expand_mult, choose_multiplier): Change \"2 *\n+\tHOST_BITS_PER_WIDE_INT\" to \"HOST_BITS_PER_DOUBLE_INT\".\n+\t* expr.c (convert_modes): Likewise.\n+\t* explow.c (plus_constant): Likewise.\n+\t* fixed-value.c (fixed_saturate1, fixed_saturate2)\n+\t(do_fixed_add, do_fixed_multiply, do_fixed_multiply)\n+\t(do_fixed_multiply, do_fixed_multiply, do_fixed_divide)\n+\t(do_fixed_divide, do_fixed_divide, do_fixed_divide)\n+\t(do_fixed_divide, do_fixed_divide, do_fixed_shift, do_fixed_shift)\n+\t(do_fixed_shift, fixed_convert, fixed_convert)\n+\t(fixed_convert_from_int, fixed_convert_from_int)\n+\t(fixed_convert_from_real): Likewise.\n+\t* fold-const.c (fold_convert_const_int_from_fixed, sign_bit_p)\n+\t(native_interpret_int, fold_binary_loc, fold_ternary_loc): Likewise.\n+\t* varasm.c (output_constructor_bitfield): Likewise.\n+\t* tree-vrp.c (register_edge_assert_for_2): Likewise.\n+\t* double-int.c (rshift_double, lshift_double): Likewise.\n+\t* double-int.h (double_int_fits_in_uhwi_p, double_int, double_int): Likewise.\n+\t* simplify-rtx.c (mode_signbit_p)\n+\t(simplify_const_unary_operation, simplify_binary_operation_1)\n+\t(simplify_immed_subreg): Likewise.\n+\t* builtins.c (c_readstr, fold_builtin_bitop): Likewise.\n+\t* tree-vect-generic.c (build_replicated_const): Likewise.\n+\t* dbxout.c (stabstr_O): Likewise.\n+\t* emit-rtl.c (immed_double_int_const, immed_double_const)\n+\t(gen_lowpart_common, init_emit_once): Likewise.\n+\t* tree.c (integer_pow2p, tree_log2, tree_floor_log2)\n+\t(widest_int_cst_value, upper_bound_in_type): Likewise.\n+\t* stor-layout.c (initialize_sizetypes, fixup_signed_type)\n+\t(fixup_unsigned_type): Likewise.\n+\t* real.c (real_to_integer2, real_from_integer): Likewise.\n+\t* dwarf2out.c (size_of_loc_descr, size_of_die, output_die)\n+\t(clz_loc_descriptor, mem_loc_descriptor): Likewise.\n+\n 2012-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/53501"}, {"sha": "b9dd3999b6b54c3de653592576970288f15d0ee0", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -713,7 +713,7 @@ c_readstr (const char *str, enum machine_mode mode)\n \t  && GET_MODE_SIZE (mode) >= UNITS_PER_WORD)\n \tj = j + UNITS_PER_WORD - 2 * (j % UNITS_PER_WORD) - 1;\n       j *= BITS_PER_UNIT;\n-      gcc_assert (j < 2 * HOST_BITS_PER_WIDE_INT);\n+      gcc_assert (j < HOST_BITS_PER_DOUBLE_INT);\n \n       if (ch)\n \tch = (unsigned char) str[i];\n@@ -8143,7 +8143,7 @@ fold_builtin_bitop (tree fndecl, tree arg)\n       if (width > HOST_BITS_PER_WIDE_INT)\n \t{\n \t  hi = TREE_INT_CST_HIGH (arg);\n-\t  if (width < 2 * HOST_BITS_PER_WIDE_INT)\n+\t  if (width < HOST_BITS_PER_DOUBLE_INT)\n \t    hi &= ~((unsigned HOST_WIDE_INT) (-1)\n \t\t    << (width - HOST_BITS_PER_WIDE_INT));\n \t}"}, {"sha": "65753befa0a73f78926865f0722382f97a40618b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -703,7 +703,7 @@ stabstr_O (tree cst)\n      present.  */\n   {\n     const unsigned int width = TYPE_PRECISION (TREE_TYPE (cst));\n-    if (width == HOST_BITS_PER_WIDE_INT * 2)\n+    if (width == HOST_BITS_PER_DOUBLE_INT)\n       ;\n     else if (width > HOST_BITS_PER_WIDE_INT)\n       high &= (((HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT)) - 1);"}, {"sha": "ff31c5c57e7d41002c2aaec8c604960e6022852e", "filename": "gcc/double-int.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -206,7 +206,7 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   if (SHIFT_COUNT_TRUNCATED)\n     count %= prec;\n \n-  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n+  if (count >= HOST_BITS_PER_DOUBLE_INT)\n     {\n       /* Shifting by the host word size is undefined according to the\n \t ANSI standard, so we must handle this as a special case.  */\n@@ -233,7 +233,7 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n       *hv = signmask;\n       *lv = signmask;\n     }\n-  else if ((prec - count) >= 2 * HOST_BITS_PER_WIDE_INT)\n+  else if ((prec - count) >= HOST_BITS_PER_DOUBLE_INT)\n     ;\n   else if ((prec - count) >= HOST_BITS_PER_WIDE_INT)\n     {\n@@ -270,7 +270,7 @@ lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   if (SHIFT_COUNT_TRUNCATED)\n     count %= prec;\n \n-  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n+  if (count >= HOST_BITS_PER_DOUBLE_INT)\n     {\n       /* Shifting by the host word size is undefined according to the\n \t ANSI standard, so we must handle this as a special case.  */\n@@ -296,7 +296,7 @@ lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t   >> (prec - HOST_BITS_PER_WIDE_INT - 1))\n \t\t: (*lv >> (prec - 1))) & 1);\n \n-  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n+  if (prec >= HOST_BITS_PER_DOUBLE_INT)\n     ;\n   else if (prec >= HOST_BITS_PER_WIDE_INT)\n     {"}, {"sha": "5e7bef0477c42a399373396d22365a0cdb262822", "filename": "gcc/double-int.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -129,7 +129,7 @@ double_int_fits_in_uhwi_p (double_int cst)\n /* The following operations perform arithmetics modulo 2^precision,\n    so you do not need to call double_int_ext between them, even if\n    you are representing numbers with precision less than\n-   2 * HOST_BITS_PER_WIDE_INT bits.  */\n+   HOST_BITS_PER_DOUBLE_INT bits.  */\n \n double_int double_int_mul (double_int, double_int);\n double_int double_int_mul_with_sign (double_int, double_int, bool, int *);\n@@ -139,7 +139,7 @@ double_int double_int_neg (double_int);\n \n /* You must ensure that double_int_ext is called on the operands\n    of the following operations, if the precision of the numbers\n-   is less than 2 * HOST_BITS_PER_WIDE_INT bits.  */\n+   is less than HOST_BITS_PER_DOUBLE_INT bits.  */\n double_int double_int_div (double_int, double_int, bool, unsigned);\n double_int double_int_sdiv (double_int, double_int, unsigned);\n double_int double_int_udiv (double_int, double_int, unsigned);\n@@ -249,7 +249,7 @@ double_int double_int_min_value (unsigned int, bool);\n \n /* The operands of the following comparison functions must be processed\n    with double_int_ext, if their precision is less than\n-   2 * HOST_BITS_PER_WIDE_INT bits.  */\n+   HOST_BITS_PER_DOUBLE_INT bits.  */\n \n /* Returns true if CST is zero.  */\n "}, {"sha": "babc5ba51f312db58a115620de5c3a4f5731a357", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -1578,7 +1578,7 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n \t    size += HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT;\n \t    break;\n \t  case dw_val_class_const_double:\n-\t    size += 2 * HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT;\n+\t    size += HOST_BITS_PER_DOUBLE_INT / BITS_PER_UNIT;\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -7133,7 +7133,7 @@ size_of_die (dw_die_ref die)\n \t  }\n \t  break;\n \tcase dw_val_class_const_double:\n-\t  size += 2 * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+\t  size += HOST_BITS_PER_DOUBLE_INT / HOST_BITS_PER_CHAR;\n \t  if (HOST_BITS_PER_WIDE_INT >= 64)\n \t    size++; /* block */\n \t  break;\n@@ -7772,7 +7772,7 @@ output_die (dw_die_ref die)\n \n \t    if (HOST_BITS_PER_WIDE_INT >= 64)\n \t      dw2_asm_output_data (1,\n-\t\t\t\t   2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t\t   HOST_BITS_PER_DOUBLE_INT\n \t\t\t\t   / HOST_BITS_PER_CHAR,\n \t\t\t\t   NULL);\n \n@@ -10629,7 +10629,7 @@ clz_loc_descriptor (rtx rtl, enum machine_mode mode,\n   if (GET_MODE_CLASS (mode) != MODE_INT\n       || GET_MODE (XEXP (rtl, 0)) != mode\n       || (GET_CODE (rtl) == CLZ\n-\t  && GET_MODE_BITSIZE (mode) > 2 * HOST_BITS_PER_WIDE_INT))\n+\t  && GET_MODE_BITSIZE (mode) > HOST_BITS_PER_DOUBLE_INT))\n     return NULL;\n \n   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n@@ -11545,7 +11545,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t}\n       if (!dwarf_strict\n \t  && (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT\n-\t      || GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT))\n+\t      || GET_MODE_BITSIZE (mode) == HOST_BITS_PER_DOUBLE_INT))\n \t{\n \t  dw_die_ref type_die = base_type_for_mode (mode, 1);\n \t  enum machine_mode amode;\n@@ -11597,7 +11597,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t     adequately represented.  We output CONST_DOUBLEs as blocks.  */\n \t  if (mode == VOIDmode\n \t      || (GET_MODE (rtl) == VOIDmode\n-\t\t  && GET_MODE_BITSIZE (mode) != 2 * HOST_BITS_PER_WIDE_INT))\n+\t\t  && GET_MODE_BITSIZE (mode) != HOST_BITS_PER_DOUBLE_INT))\n \t    break;\n \t  type_die = base_type_for_mode (mode,\n \t\t\t\t\t GET_MODE_CLASS (mode) == MODE_INT);"}, {"sha": "f6d0a2e4bb672b9485606439857b9779bfd840ab", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -517,7 +517,7 @@ immed_double_int_const (double_int i, enum machine_mode mode)\n \n /* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair\n    of ints: I0 is the low-order word and I1 is the high-order word.\n-   For values that are larger than 2*HOST_BITS_PER_WIDE_INT, the\n+   For values that are larger than HOST_BITS_PER_DOUBLE_INT, the\n    implied upper bits are copies of the high bit of i1.  The value\n    itself is neither signed nor unsigned.  Do not use this routine for\n    non-integer modes; convert to REAL_VALUE_TYPE and use\n@@ -530,7 +530,7 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n   unsigned int i;\n \n   /* There are the following cases (note that there are no modes with\n-     HOST_BITS_PER_WIDE_INT < GET_MODE_BITSIZE (mode) < 2 * HOST_BITS_PER_WIDE_INT):\n+     HOST_BITS_PER_WIDE_INT < GET_MODE_BITSIZE (mode) < HOST_BITS_PER_DOUBLE_INT):\n \n      1) If GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT, then we use\n \tgen_int_mode.\n@@ -1206,7 +1206,7 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n       && msize * BITS_PER_UNIT <= HOST_BITS_PER_WIDE_INT)\n     innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n   else if (innermode == VOIDmode)\n-    innermode = mode_for_size (HOST_BITS_PER_WIDE_INT * 2, MODE_INT, 0);\n+    innermode = mode_for_size (HOST_BITS_PER_DOUBLE_INT, MODE_INT, 0);\n \n   xsize = GET_MODE_SIZE (innermode);\n \n@@ -5787,7 +5787,7 @@ init_emit_once (void)\n       FCONST1(mode).data.low = 0;\n       FCONST1(mode).mode = mode;\n       lshift_double (1, 0, GET_MODE_FBIT (mode),\n-                     2 * HOST_BITS_PER_WIDE_INT,\n+                     HOST_BITS_PER_DOUBLE_INT,\n                      &FCONST1(mode).data.low,\n \t\t     &FCONST1(mode).data.high,\n                      SIGNED_FIXED_POINT_MODE_P (mode));\n@@ -5810,7 +5810,7 @@ init_emit_once (void)\n       FCONST1(mode).data.low = 0;\n       FCONST1(mode).mode = mode;\n       lshift_double (1, 0, GET_MODE_FBIT (mode),\n-                     2 * HOST_BITS_PER_WIDE_INT,\n+                     HOST_BITS_PER_DOUBLE_INT,\n                      &FCONST1(mode).data.low,\n \t\t     &FCONST1(mode).data.high,\n                      SIGNED_FIXED_POINT_MODE_P (mode));"}, {"sha": "1cfe93bc7dbd73088ca4f82ff91f15300e7e0022", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -127,7 +127,7 @@ plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n \tif (add_double_with_sign (l1, h1, l2, h2, &lv, &hv, false))\n \t  /* Sorry, we have no way to represent overflows this wide.\n \t     To fix, add constant support wider than CONST_DOUBLE.  */\n-\t  gcc_assert (GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT);\n+\t  gcc_assert (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT);\n \n \treturn immed_double_const (lv, hv, VOIDmode);\n       }"}, {"sha": "98f7c0916c3aa64d4961cc4cdf1c52e78d59c06e", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -3155,8 +3155,8 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t    {\n \t      int shift = floor_log2 (CONST_DOUBLE_HIGH (op1))\n \t\t\t  + HOST_BITS_PER_WIDE_INT;\n-\t      if (shift < 2 * HOST_BITS_PER_WIDE_INT - 1\n-\t\t  || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT)\n+\t      if (shift < HOST_BITS_PER_DOUBLE_INT - 1\n+\t\t  || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT)\n \t\treturn expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t     shift, target, unsignedp);\n \t    }\n@@ -3316,7 +3316,7 @@ choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n   /* We could handle this with some effort, but this case is much\n      better handled directly with a scc insn, so rely on caller using\n      that.  */\n-  gcc_assert (pow != 2 * HOST_BITS_PER_WIDE_INT);\n+  gcc_assert (pow != HOST_BITS_PER_DOUBLE_INT);\n \n   /* mlow = 2^(N + lgup)/d */\n  if (pow >= HOST_BITS_PER_WIDE_INT)"}, {"sha": "2cee62fa27a9e23f63a44786a69ba945c49dd85c", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -723,7 +723,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n      make the high-order word of the constant zero, not all ones.  */\n \n   if (unsignedp && GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT\n+      && GET_MODE_BITSIZE (mode) == HOST_BITS_PER_DOUBLE_INT\n       && CONST_INT_P (x) && INTVAL (x) < 0)\n     {\n       double_int val = uhwi_to_double_int (INTVAL (x));"}, {"sha": "97aa8b5263b8182b402f5eb17dc2e14d78b3022b", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -177,7 +177,7 @@ fixed_saturate1 (enum machine_mode mode, double_int a, double_int *f,\n       min.high = 0;\n       min.low = 1;\n       lshift_double (min.low, min.high, i_f_bits,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &min.low, &min.high, 1);\n       min = double_int_ext (min, 1 + i_f_bits, 0);\n       if (double_int_cmp (a, max, 0) == 1)\n@@ -245,7 +245,7 @@ fixed_saturate2 (enum machine_mode mode, double_int a_high, double_int a_low,\n       min_s.high = 0;\n       min_s.low = 1;\n       lshift_double (min_s.low, min_s.high, i_f_bits,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &min_s.low, &min_s.high, 1);\n       min_s = double_int_ext (min_s, 1 + i_f_bits, 0);\n       if (double_int_cmp (a_high, max_r, 0) == 1\n@@ -354,7 +354,7 @@ do_fixed_add (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t      f->data.low = 1;\n \t      f->data.high = 0;\n \t      lshift_double (f->data.low, f->data.high, i_f_bits,\n-\t\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t\t     &f->data.low, &f->data.high, 1);\n \t      if (get_fixed_sign_bit (a->data, i_f_bits) == 0)\n \t\t{\n@@ -389,7 +389,7 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       f->data = double_int_mul (a->data, b->data);\n       lshift_double (f->data.low, f->data.high,\n \t\t     (-GET_MODE_FBIT (f->mode)),\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &f->data.low, &f->data.high, !unsigned_p);\n       overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n     }\n@@ -451,7 +451,7 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \tr = double_int_sub (r, a->data);\n \n       /* Shift right the result by FBIT.  */\n-      if (GET_MODE_FBIT (f->mode) == 2 * HOST_BITS_PER_WIDE_INT)\n+      if (GET_MODE_FBIT (f->mode) == HOST_BITS_PER_DOUBLE_INT)\n \t{\n \t  s.low = r.low;\n \t  s.high = r.high;\n@@ -472,20 +472,20 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t{\n \t  lshift_double (s.low, s.high,\n \t\t\t (-GET_MODE_FBIT (f->mode)),\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &s.low, &s.high, 0);\n \t  lshift_double (r.low, r.high,\n-\t\t\t (2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t (HOST_BITS_PER_DOUBLE_INT\n \t\t\t  - GET_MODE_FBIT (f->mode)),\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &f->data.low, &f->data.high, 0);\n \t  f->data.low = f->data.low | s.low;\n \t  f->data.high = f->data.high | s.high;\n \t  s.low = f->data.low;\n \t  s.high = f->data.high;\n \t  lshift_double (r.low, r.high,\n \t\t\t (-GET_MODE_FBIT (f->mode)),\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &r.low, &r.high, !unsigned_p);\n \t}\n \n@@ -512,7 +512,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n     {\n       lshift_double (a->data.low, a->data.high,\n \t\t     GET_MODE_FBIT (f->mode),\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &f->data.low, &f->data.high, !unsigned_p);\n       f->data = double_int_div (f->data, b->data, unsigned_p, TRUNC_DIV_EXPR);\n       overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n@@ -543,7 +543,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \tpos_b = b->data;\n \n       /* Left shift pos_a to {r, s} by FBIT.  */\n-      if (GET_MODE_FBIT (f->mode) == 2 * HOST_BITS_PER_WIDE_INT)\n+      if (GET_MODE_FBIT (f->mode) == HOST_BITS_PER_DOUBLE_INT)\n \t{\n \t  r = pos_a;\n \t  s.high = 0;\n@@ -553,12 +553,12 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n  \t{\n \t  lshift_double (pos_a.low, pos_a.high,\n \t\t\t GET_MODE_FBIT (f->mode),\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &s.low, &s.high, 0);\n \t  lshift_double (pos_a.low, pos_a.high,\n-\t\t\t - (2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t - (HOST_BITS_PER_DOUBLE_INT\n \t\t\t    - GET_MODE_FBIT (f->mode)),\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &r.low, &r.high, 0);\n  \t}\n \n@@ -570,21 +570,21 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       quo_s.high = 0;\n       quo_s.low = 0;\n \n-      for (i = 0; i < 2 * HOST_BITS_PER_WIDE_INT; i++)\n+      for (i = 0; i < HOST_BITS_PER_DOUBLE_INT; i++)\n \t{\n \t  /* Record the leftmost bit of mod.  */\n \t  int leftmost_mod = (mod.high < 0);\n \n \t  /* Shift left mod by 1 bit.  */\n-\t  lshift_double (mod.low, mod.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t  lshift_double (mod.low, mod.high, 1, HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &mod.low, &mod.high, 0);\n \n \t  /* Test the leftmost bit of s to add to mod.  */\n \t  if (s.high < 0)\n \t    mod.low += 1;\n \n \t  /* Shift left quo_s by 1 bit.  */\n-\t  lshift_double (quo_s.low, quo_s.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t  lshift_double (quo_s.low, quo_s.high, 1, HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &quo_s.low, &quo_s.high, 0);\n \n \t  /* Try to calculate (mod - pos_b).  */\n@@ -597,7 +597,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t    }\n \n \t  /* Shift left s by 1 bit.  */\n-\t  lshift_double (s.low, s.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t  lshift_double (s.low, s.high, 1, HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &s.low, &s.high, 0);\n \n \t}\n@@ -645,15 +645,15 @@ do_fixed_shift (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n     {\n       lshift_double (a->data.low, a->data.high,\n \t\t     left_p ? b->data.low : (-b->data.low),\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &f->data.low, &f->data.high, !unsigned_p);\n       if (left_p) /* Only left shift saturates.  */\n \toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n     }\n   else /* We need two double_int to store the left-shift result.  */\n     {\n       double_int temp_high, temp_low;\n-      if (b->data.low == 2 * HOST_BITS_PER_WIDE_INT)\n+      if (b->data.low == HOST_BITS_PER_DOUBLE_INT)\n \t{\n \t  temp_high = a->data;\n \t  temp_low.high = 0;\n@@ -663,12 +663,12 @@ do_fixed_shift (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t{\n \t  lshift_double (a->data.low, a->data.high,\n \t\t\t b->data.low,\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &temp_low.low, &temp_low.high, !unsigned_p);\n \t  /* Logical shift right to temp_high.  */\n \t  lshift_double (a->data.low, a->data.high,\n-\t\t\t b->data.low - 2 * HOST_BITS_PER_WIDE_INT,\n-\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t b->data.low - HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT,\n \t\t\t &temp_high.low, &temp_high.high, 0);\n \t}\n       if (!unsigned_p && a->data.high < 0) /* Signed-extend temp_high.  */\n@@ -837,13 +837,13 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n       int amount = GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode);\n       lshift_double (a->data.low, a->data.high,\n \t\t     amount,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &temp_low.low, &temp_low.high,\n \t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n       /* Logical shift right to temp_high.  */\n       lshift_double (a->data.low, a->data.high,\n-\t\t     amount - 2 * HOST_BITS_PER_WIDE_INT,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     amount - HOST_BITS_PER_DOUBLE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &temp_high.low, &temp_high.high, 0);\n       if (SIGNED_FIXED_POINT_MODE_P (a->mode)\n \t  && a->data.high < 0) /* Signed-extend temp_high.  */\n@@ -905,7 +905,7 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n       double_int temp;\n       lshift_double (a->data.low, a->data.high,\n \t\t     GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode),\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &temp.low, &temp.high,\n \t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n       f->mode = mode;\n@@ -980,7 +980,7 @@ fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n   /* Left shift a to temp_high, temp_low.  */\n   double_int temp_high, temp_low;\n   int amount = GET_MODE_FBIT (mode);\n-  if (amount == 2 * HOST_BITS_PER_WIDE_INT)\n+  if (amount == HOST_BITS_PER_DOUBLE_INT)\n     {\n        temp_high = a;\n        temp_low.low = 0;\n@@ -990,13 +990,13 @@ fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n     {\n       lshift_double (a.low, a.high,\n \t\t     amount,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &temp_low.low, &temp_low.high, 0);\n \n       /* Logical shift right to temp_high.  */\n       lshift_double (a.low, a.high,\n-\t\t     amount - 2 * HOST_BITS_PER_WIDE_INT,\n-\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     amount - HOST_BITS_PER_DOUBLE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t     &temp_high.low, &temp_high.high, 0);\n     }\n   if (!unsigned_p && a.high < 0) /* Signed-extend temp_high.  */\n@@ -1094,7 +1094,7 @@ fixed_convert_from_real (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t      f->data.low = 1;\n \t      f->data.high = 0;\n \t      lshift_double (f->data.low, f->data.high, i_f_bits,\n-\t\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t     HOST_BITS_PER_DOUBLE_INT,\n \t\t\t     &f->data.low, &f->data.high, 1);\n \t      f->data = double_int_ext (f->data, 1 + i_f_bits, 0);\n \t    }"}, {"sha": "877cf32717e700eadcfc2a495d2f894729ae50e3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -1590,7 +1590,7 @@ fold_convert_const_int_from_fixed (tree type, const_tree arg1)\n   /* Right shift FIXED_CST to temp by fbit.  */\n   temp = TREE_FIXED_CST (arg1).data;\n   mode = TREE_FIXED_CST (arg1).mode;\n-  if (GET_MODE_FBIT (mode) < 2 * HOST_BITS_PER_WIDE_INT)\n+  if (GET_MODE_FBIT (mode) < HOST_BITS_PER_DOUBLE_INT)\n     {\n       temp = double_int_rshift (temp, GET_MODE_FBIT (mode),\n \t\t\t        HOST_BITS_PER_DOUBLE_INT,\n@@ -3633,7 +3633,7 @@ sign_bit_p (tree exp, const_tree val)\n       lo = 0;\n \n       mask_hi = ((unsigned HOST_WIDE_INT) -1\n-\t\t >> (2 * HOST_BITS_PER_WIDE_INT - width));\n+\t\t >> (HOST_BITS_PER_DOUBLE_INT - width));\n       mask_lo = -1;\n     }\n   else\n@@ -7379,7 +7379,7 @@ native_interpret_int (tree type, const unsigned char *ptr, int len)\n \n   if (total_bytes > len)\n     return NULL_TREE;\n-  if (total_bytes * BITS_PER_UNIT > 2 * HOST_BITS_PER_WIDE_INT)\n+  if (total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)\n     return NULL_TREE;\n \n   result = double_int_zero;\n@@ -13291,7 +13291,7 @@ fold_binary_loc (location_t loc,\n \tunsigned int width = TYPE_PRECISION (arg1_type);\n \n \tif (TREE_CODE (arg1) == INTEGER_CST\n-\t    && width <= 2 * HOST_BITS_PER_WIDE_INT\n+\t    && width <= HOST_BITS_PER_DOUBLE_INT\n \t    && (INTEGRAL_TYPE_P (arg1_type) || POINTER_TYPE_P (arg1_type)))\n \t  {\n \t    HOST_WIDE_INT signed_max_hi;\n@@ -13891,7 +13891,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t      if (outer_width > HOST_BITS_PER_WIDE_INT)\n \t\t{\n \t\t  mask_hi = ((unsigned HOST_WIDE_INT) -1\n-\t\t\t     >> (2 * HOST_BITS_PER_WIDE_INT - outer_width));\n+\t\t\t     >> (HOST_BITS_PER_DOUBLE_INT - outer_width));\n \t\t  mask_lo = -1;\n \t\t}\n \t      else"}, {"sha": "e4f6492e70d1503640ef3fa099860eef7449c7a0", "filename": "gcc/real.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -1423,10 +1423,10 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n \t undefined, so it doesn't matter what we return, and some callers\n \t expect to be able to use this routine for both signed and\n \t unsigned conversions.  */\n-      if (exp > 2*HOST_BITS_PER_WIDE_INT)\n+      if (exp > HOST_BITS_PER_DOUBLE_INT)\n \tgoto overflow;\n \n-      rshift_significand (&t, r, 2*HOST_BITS_PER_WIDE_INT - exp);\n+      rshift_significand (&t, r, HOST_BITS_PER_DOUBLE_INT - exp);\n       if (HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG)\n \t{\n \t  high = t.sig[SIGSZ-1];\n@@ -2160,7 +2160,7 @@ real_from_integer (REAL_VALUE_TYPE *r, enum machine_mode mode,\n       memset (r, 0, sizeof (*r));\n       r->cl = rvc_normal;\n       r->sign = high < 0 && !unsigned_p;\n-      SET_REAL_EXP (r, 2 * HOST_BITS_PER_WIDE_INT);\n+      SET_REAL_EXP (r, HOST_BITS_PER_DOUBLE_INT);\n \n       if (r->sign)\n \t{"}, {"sha": "e43ee5bdf38b985a5549c06b0f001addd12cb7d7", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -88,7 +88,7 @@ mode_signbit_p (enum machine_mode mode, const_rtx x)\n   if (width <= HOST_BITS_PER_WIDE_INT\n       && CONST_INT_P (x))\n     val = INTVAL (x);\n-  else if (width <= 2 * HOST_BITS_PER_WIDE_INT\n+  else if (width <= HOST_BITS_PER_DOUBLE_INT\n \t   && GET_CODE (x) == CONST_DOUBLE\n \t   && CONST_DOUBLE_LOW (x) == 0)\n     {\n@@ -1356,7 +1356,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n \n       if (op_mode == VOIDmode\n-\t  || GET_MODE_PRECISION (op_mode) > 2 * HOST_BITS_PER_WIDE_INT)\n+\t  || GET_MODE_PRECISION (op_mode) > HOST_BITS_PER_DOUBLE_INT)\n \t/* We should never get a negative number.  */\n \tgcc_assert (hv >= 0);\n       else if (GET_MODE_PRECISION (op_mode) <= HOST_BITS_PER_WIDE_INT)\n@@ -1517,7 +1517,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n   /* We can do some operations on integer CONST_DOUBLEs.  Also allow\n      for a DImode operation on a CONST_INT.  */\n   else if (GET_MODE (op) == VOIDmode\n-\t   && width <= HOST_BITS_PER_WIDE_INT * 2\n+\t   && width <= HOST_BITS_PER_DOUBLE_INT\n \t   && (GET_CODE (op) == CONST_DOUBLE\n \t       || CONST_INT_P (op)))\n     {\n@@ -1713,7 +1713,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else if (GET_CODE (op) == CONST_DOUBLE\n \t   && SCALAR_FLOAT_MODE_P (GET_MODE (op))\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && width <= 2 * HOST_BITS_PER_WIDE_INT && width > 0)\n+\t   && width <= HOST_BITS_PER_DOUBLE_INT && width > 0)\n     {\n       /* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX\n \t operators are intentionally left unspecified (to ease implementation\n@@ -1778,7 +1778,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    return const0_rtx;\n \n \t  /* Test against the unsigned upper bound.  */\n-\t  if (width == 2 * HOST_BITS_PER_WIDE_INT)\n+\t  if (width == HOST_BITS_PER_DOUBLE_INT)\n \t    {\n \t      th = -1;\n \t      tl = -1;\n@@ -2376,8 +2376,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t  && GET_MODE (op0) == mode\n \t  && CONST_DOUBLE_LOW (trueop1) == 0\n \t  && (val = exact_log2 (CONST_DOUBLE_HIGH (trueop1))) >= 0\n-\t  && (val < 2 * HOST_BITS_PER_WIDE_INT - 1\n-\t      || GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT))\n+\t  && (val < HOST_BITS_PER_DOUBLE_INT - 1\n+\t      || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT))\n \treturn simplify_gen_binary (ASHIFT, mode, op0,\n \t\t\t\t    GEN_INT (val + HOST_BITS_PER_WIDE_INT));\n \n@@ -5216,7 +5216,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \n \t      for (i = 0; i < HOST_BITS_PER_WIDE_INT; i += value_bit)\n \t\t*vp++ = CONST_DOUBLE_LOW (el) >> i;\n-\t      while (i < HOST_BITS_PER_WIDE_INT * 2 && i < elem_bitsize)\n+\t      while (i < HOST_BITS_PER_DOUBLE_INT && i < elem_bitsize)\n \t\t{\n \t\t  *vp++\n \t\t    = CONST_DOUBLE_HIGH (el) >> (i - HOST_BITS_PER_WIDE_INT);\n@@ -5271,7 +5271,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t    {\n \t      for (i = 0; i < HOST_BITS_PER_WIDE_INT; i += value_bit)\n \t\t*vp++ = CONST_FIXED_VALUE_LOW (el) >> i;\n-              for (; i < 2 * HOST_BITS_PER_WIDE_INT && i < elem_bitsize;\n+              for (; i < HOST_BITS_PER_DOUBLE_INT && i < elem_bitsize;\n \t\t   i += value_bit)\n \t\t*vp++ = CONST_FIXED_VALUE_HIGH (el)\n \t\t\t>> (i - HOST_BITS_PER_WIDE_INT);\n@@ -5364,7 +5364,7 @@ simplify_immed_subreg (enum machine_mode outermode, rtx op,\n \t       know why.  */\n \t    if (elem_bitsize <= HOST_BITS_PER_WIDE_INT)\n \t      elems[elem] = gen_int_mode (lo, outer_submode);\n-\t    else if (elem_bitsize <= 2 * HOST_BITS_PER_WIDE_INT)\n+\t    else if (elem_bitsize <= HOST_BITS_PER_DOUBLE_INT)\n \t      elems[elem] = immed_double_const (lo, hi, outer_submode);\n \t    else\n \t      return NULL_RTX;"}, {"sha": "0d3d5d29a89988c857242f37d5775bb885e00178", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -2480,8 +2480,8 @@ initialize_sizetypes (void)\n     = MIN (precision + BITS_PER_UNIT_LOG + 1, MAX_FIXED_MODE_SIZE);\n   bprecision\n     = GET_MODE_PRECISION (smallest_mode_for_size (bprecision, MODE_INT));\n-  if (bprecision > HOST_BITS_PER_WIDE_INT * 2)\n-    bprecision = HOST_BITS_PER_WIDE_INT * 2;\n+  if (bprecision > HOST_BITS_PER_DOUBLE_INT)\n+    bprecision = HOST_BITS_PER_DOUBLE_INT;\n \n   /* Create stubs for sizetype and bitsizetype so we can create constants.  */\n   sizetype = make_node (INTEGER_TYPE);\n@@ -2582,10 +2582,10 @@ fixup_signed_type (tree type)\n   int precision = TYPE_PRECISION (type);\n \n   /* We can not represent properly constants greater then\n-     2 * HOST_BITS_PER_WIDE_INT, still we need the types\n+     HOST_BITS_PER_DOUBLE_INT, still we need the types\n      as they are used by i386 vector extensions and friends.  */\n-  if (precision > HOST_BITS_PER_WIDE_INT * 2)\n-    precision = HOST_BITS_PER_WIDE_INT * 2;\n+  if (precision > HOST_BITS_PER_DOUBLE_INT)\n+    precision = HOST_BITS_PER_DOUBLE_INT;\n \n   set_min_and_max_values_for_integral_type (type, precision,\n \t\t\t\t\t    /*is_unsigned=*/false);\n@@ -2604,10 +2604,10 @@ fixup_unsigned_type (tree type)\n   int precision = TYPE_PRECISION (type);\n \n   /* We can not represent properly constants greater then\n-     2 * HOST_BITS_PER_WIDE_INT, still we need the types\n+     HOST_BITS_PER_DOUBLE_INT, still we need the types\n      as they are used by i386 vector extensions and friends.  */\n-  if (precision > HOST_BITS_PER_WIDE_INT * 2)\n-    precision = HOST_BITS_PER_WIDE_INT * 2;\n+  if (precision > HOST_BITS_PER_DOUBLE_INT)\n+    precision = HOST_BITS_PER_DOUBLE_INT;\n \n   TYPE_UNSIGNED (type) = 1;\n "}, {"sha": "06334bb8fd1406d69388d91726b56b63cf4bd4d2", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -64,7 +64,7 @@ build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n     low &= ((HOST_WIDE_INT)1 << TYPE_PRECISION (type)) - 1, high = 0;\n   else if (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT)\n     high = 0;\n-  else if (TYPE_PRECISION (type) == 2 * HOST_BITS_PER_WIDE_INT)\n+  else if (TYPE_PRECISION (type) == HOST_BITS_PER_DOUBLE_INT)\n     high = low;\n   else\n     gcc_unreachable ();"}, {"sha": "c6f1d8e0a0ec83d82bb02bf4c6a00d0977e0b482", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -4604,7 +4604,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      && host_integerp (cst2, 1)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && IN_RANGE (tree_low_cst (cst2, 1), 1, prec - 1)\n-\t      && prec <= 2 * HOST_BITS_PER_WIDE_INT\n+\t      && prec <= HOST_BITS_PER_DOUBLE_INT\n \t      && prec == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (val)))\n \t      && live_on_edge (e, name2)\n \t      && !has_single_use (name2))\n@@ -4681,7 +4681,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && TREE_CODE (cst2) == INTEGER_CST\n \t      && !integer_zerop (cst2)\n-\t      && prec <= 2 * HOST_BITS_PER_WIDE_INT\n+\t      && prec <= HOST_BITS_PER_DOUBLE_INT\n \t      && (prec > 1\n \t\t  || TYPE_UNSIGNED (TREE_TYPE (val))))\n \t    {"}, {"sha": "e180340c12ce80281835d3165e2f980e33b1d564", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -1872,7 +1872,7 @@ integer_pow2p (const_tree expr)\n   /* First clear all bits that are beyond the type's precision in case\n      we've been sign extended.  */\n \n-  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+  if (prec == HOST_BITS_PER_DOUBLE_INT)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n     high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n@@ -1936,7 +1936,7 @@ tree_log2 (const_tree expr)\n   /* First clear all bits that are beyond the type's precision in case\n      we've been sign extended.  */\n \n-  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+  if (prec == HOST_BITS_PER_DOUBLE_INT)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n     high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n@@ -1973,7 +1973,7 @@ tree_floor_log2 (const_tree expr)\n      we've been sign extended.  Ignore if type's precision hasn't been set\n      since what we are doing is setting it.  */\n \n-  if (prec == 2 * HOST_BITS_PER_WIDE_INT || prec == 0)\n+  if (prec == HOST_BITS_PER_DOUBLE_INT || prec == 0)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n     high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n@@ -10201,7 +10201,7 @@ widest_int_cst_value (const_tree x)\n   unsigned HOST_WIDEST_INT val = TREE_INT_CST_LOW (x);\n \n #if HOST_BITS_PER_WIDEST_INT > HOST_BITS_PER_WIDE_INT\n-  gcc_assert (HOST_BITS_PER_WIDEST_INT >= 2 * HOST_BITS_PER_WIDE_INT);\n+  gcc_assert (HOST_BITS_PER_WIDEST_INT >= HOST_BITS_PER_DOUBLE_INT);\n   val |= (((unsigned HOST_WIDEST_INT) TREE_INT_CST_HIGH (x))\n \t  << HOST_BITS_PER_WIDE_INT);\n #else\n@@ -10319,7 +10319,7 @@ upper_bound_in_type (tree outer, tree inner)\n   else\n     {\n       high.high = ((~(unsigned HOST_WIDE_INT) 0)\n-\t    >> (2 * HOST_BITS_PER_WIDE_INT - prec));\n+\t    >> (HOST_BITS_PER_DOUBLE_INT - prec));\n       high.low = ~(unsigned HOST_WIDE_INT) 0;\n     }\n "}, {"sha": "89bd7caa198d805e38e2c6959fc2d23f0ebb181b", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ab6098eefb9414d849b79df3f27cfc82c3ffe6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=49ab6098eefb9414d849b79df3f27cfc82c3ffe6", "patch": "@@ -4951,7 +4951,7 @@ output_constructor_bitfield (oc_local_state *local, oc_outer_state *outer)\n \t    value = TREE_INT_CST_LOW (local->val);\n \t  else\n \t    {\n-\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n+\t      gcc_assert (shift < HOST_BITS_PER_DOUBLE_INT);\n \t      value = TREE_INT_CST_HIGH (local->val);\n \t      shift -= HOST_BITS_PER_WIDE_INT;\n \t    }\n@@ -4983,7 +4983,7 @@ output_constructor_bitfield (oc_local_state *local, oc_outer_state *outer)\n \t    value = TREE_INT_CST_LOW (local->val);\n \t  else\n \t    {\n-\t      gcc_assert (shift < 2 * HOST_BITS_PER_WIDE_INT);\n+\t      gcc_assert (shift < HOST_BITS_PER_DOUBLE_INT);\n \t      value = TREE_INT_CST_HIGH (local->val);\n \t      shift -= HOST_BITS_PER_WIDE_INT;\n \t    }"}]}