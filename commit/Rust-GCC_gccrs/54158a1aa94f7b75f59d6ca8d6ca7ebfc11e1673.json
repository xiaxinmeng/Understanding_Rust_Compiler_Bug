{"sha": "54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQxNThhMWFhOTRmN2I3NWY1OWQ2Y2E4ZDZjYTdlYmZjMTFlMTY3Mw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-07-18T10:47:09Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-07-18T10:47:09Z"}, "message": "S/390: Fix alignment check for literal pool references.\n\ngcc/ChangeLog:\n\n2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_encode_section_info): Always set\n\tnotaligned marker if mode size is 0 or no MEM_ALIGN info could be\n\tfound.\n\ngcc/testsuite/ChangeLog:\n\n2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/nolrl-1.c: New test.\n\nFrom-SVN: r238427", "tree": {"sha": "551d229cd8785ac2afb871f356d248c72a6a7a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/551d229cd8785ac2afb871f356d248c72a6a7a94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/comments", "author": null, "committer": null, "parents": [{"sha": "2e7565b2681274a88ec2c74c6486ca4657295d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7565b2681274a88ec2c74c6486ca4657295d21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7565b2681274a88ec2c74c6486ca4657295d21"}], "stats": {"total": 64, "additions": 44, "deletions": 20}, "files": [{"sha": "55a8771bdf13452629c8f963e384ea5cd5b3712e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "patch": "@@ -1,3 +1,9 @@\n+2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_encode_section_info): Always set\n+\tnotaligned marker if mode size is 0 or no MEM_ALIGN info could be\n+\tfound.\n+\n 2016-07-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71893"}, {"sha": "318c021290ffda23f55f16c81f7aba196cc4f35f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "patch": "@@ -12412,36 +12412,31 @@ s390_encode_section_info (tree decl, rtx rtl, int first)\n     {\n       /* Store the alignment to be able to check if we can use\n \t a larl/load-relative instruction.  We only handle the cases\n-\t that can go wrong (i.e. no FUNC_DECLs).  If a symref does\n-\t not have any flag we assume it to be correctly aligned.  */\n-\n-      if (DECL_ALIGN (decl) % 64)\n-\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n-\n-      if (DECL_ALIGN (decl) % 32)\n-\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n-\n-      if (DECL_ALIGN (decl) == 0 || DECL_ALIGN (decl) % 16)\n+\t that can go wrong (i.e. no FUNC_DECLs).  */\n+      if (DECL_ALIGN (decl) == 0\n+\t  || DECL_ALIGN (decl) % 16)\n \tSYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));\n+      else if (DECL_ALIGN (decl) % 32)\n+\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n+      else if (DECL_ALIGN (decl) % 64)\n+\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n     }\n \n   /* Literal pool references don't have a decl so they are handled\n      differently here.  We rely on the information in the MEM_ALIGN\n      entry to decide upon the alignment.  */\n   if (MEM_P (rtl)\n       && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n-      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0))\n-      && MEM_ALIGN (rtl) != 0\n-      && GET_MODE_BITSIZE (GET_MODE (rtl)) != 0)\n+      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0)))\n     {\n-      if (MEM_ALIGN (rtl) % 64)\n-\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n-\n-      if (MEM_ALIGN (rtl) % 32)\n-\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n-\n-      if (MEM_ALIGN (rtl) == 0 || MEM_ALIGN (rtl) % 16)\n+      if (MEM_ALIGN (rtl) == 0\n+\t  || GET_MODE_SIZE (GET_MODE (rtl)) == 0\n+\t  || MEM_ALIGN (rtl) % 16)\n \tSYMBOL_FLAG_SET_NOTALIGN2 (XEXP (rtl, 0));\n+      else if (MEM_ALIGN (rtl) % 32)\n+\tSYMBOL_FLAG_SET_NOTALIGN4 (XEXP (rtl, 0));\n+      else if (MEM_ALIGN (rtl) % 64)\n+\tSYMBOL_FLAG_SET_NOTALIGN8 (XEXP (rtl, 0));\n     }\n }\n "}, {"sha": "f0032870fc90f4e8634d54046099717a47c3bfbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "patch": "@@ -1,3 +1,7 @@\n+2016-07-18  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/nolrl-1.c: New test.\n+\n 2016-07-17  Fritz Reese  <fritzoreese@gmail.com>\n \n \tPR fortran/71523"}, {"sha": "e0d1213f78fca7facf432ba04ed243fba911aae7", "filename": "gcc/testsuite/gcc.target/s390/nolrl-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnolrl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnolrl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnolrl-1.c?ref=54158a1aa94f7b75f59d6ca8d6ca7ebfc11e1673", "patch": "@@ -0,0 +1,19 @@\n+/* Make sure the compiler does not try to use a relative long\n+   instruction to load the string since it might not meet the\n+   alignment requirements of the instruction.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-march=z10 -O3 -mzarch\" } */\n+\n+extern void foo (char*);\n+\n+void\n+bar ()\n+{\n+    unsigned char z[32];\n+\n+    __builtin_memcpy (z, \"\\001\\000\\000\\000\", 4);\n+    foo (z);\n+}\n+\n+/* { dg-final { scan-assembler-not \"lrl\" } } */"}]}