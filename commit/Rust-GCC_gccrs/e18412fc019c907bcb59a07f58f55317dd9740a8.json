{"sha": "e18412fc019c907bcb59a07f58f55317dd9740a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4NDEyZmMwMTljOTA3YmNiNTlhMDdmNThmNTUzMTdkZDk3NDBhOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-05T23:06:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-05T23:06:10Z"}, "message": "cgraphunit.c (walk_polymorphic_call_targets): Break out from ...\n\n\t* cgraphunit.c (walk_polymorphic_call_targets): Break out from ...\n\t(analyze_functions): ... here.\n\nFrom-SVN: r202299", "tree": {"sha": "e5e3d8cfae6afc78d3c883a7b5b629c65e817437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5e3d8cfae6afc78d3c883a7b5b629c65e817437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e18412fc019c907bcb59a07f58f55317dd9740a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18412fc019c907bcb59a07f58f55317dd9740a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e18412fc019c907bcb59a07f58f55317dd9740a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18412fc019c907bcb59a07f58f55317dd9740a8/comments", "author": null, "committer": null, "parents": [{"sha": "d352b2459fa6e4d5bc320af9912769ff3416a3d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d352b2459fa6e4d5bc320af9912769ff3416a3d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d352b2459fa6e4d5bc320af9912769ff3416a3d5"}], "stats": {"total": 141, "additions": 79, "deletions": 62}, "files": [{"sha": "9e56b4a947901497d2f28a00ca2b2f7074bd05eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18412fc019c907bcb59a07f58f55317dd9740a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18412fc019c907bcb59a07f58f55317dd9740a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e18412fc019c907bcb59a07f58f55317dd9740a8", "patch": "@@ -1,3 +1,8 @@\n+2013-09-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (walk_polymorphic_call_targets): Break out from ...\n+\t(analyze_functions): ... here.\n+\n 2013-09-04  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/58201"}, {"sha": "08e0ff277f2f7f14aa160199a0d68f6ade9704fc", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 74, "deletions": 62, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18412fc019c907bcb59a07f58f55317dd9740a8/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18412fc019c907bcb59a07f58f55317dd9740a8/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e18412fc019c907bcb59a07f58f55317dd9740a8", "patch": "@@ -821,6 +821,76 @@ varpool_finalize_decl (tree decl)\n     varpool_assemble_decl (node);\n }\n \n+/* EDGE is an polymorphic call.  Mark all possible targets as reachable\n+   and if there is only one target, perform trivial devirtualization. \n+   REACHABLE_CALL_TARGETS collects target lists we already walked to\n+   avoid udplicate work.  */\n+\n+static void\n+walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n+\t\t\t       struct cgraph_edge *edge)\n+{\n+  unsigned int i;\n+  void *cache_token;\n+  bool final;\n+  vec <cgraph_node *>targets\n+    = possible_polymorphic_call_targets\n+\t(edge, &final, &cache_token);\n+\n+  if (!pointer_set_insert (reachable_call_targets,\n+\t\t\t   cache_token))\n+    {\n+      if (cgraph_dump_file)\n+\tdump_possible_polymorphic_call_targets \n+\t  (cgraph_dump_file, edge);\n+\n+      for (i = 0; i < targets.length(); i++)\n+\t{\n+\t  /* Do not bother to mark virtual methods in anonymous namespace;\n+\t     either we will find use of virtual table defining it, or it is\n+\t     unused.  */\n+\t  if (targets[i]->symbol.definition\n+\t      && TREE_CODE\n+\t\t  (TREE_TYPE (targets[i]->symbol.decl))\n+\t\t   == METHOD_TYPE\n+\t      && !type_in_anonymous_namespace_p\n+\t\t   (method_class_type\n+\t\t     (TREE_TYPE (targets[i]->symbol.decl))))\n+\t  enqueue_node ((symtab_node) targets[i]);\n+\t}\n+    }\n+\n+  /* Very trivial devirtualization; when the type is\n+     final or anonymous (so we know all its derivation)\n+     and there is only one possible virtual call target,\n+     make the edge direct.  */\n+  if (final)\n+    {\n+      gcc_assert (targets.length());\n+      if (targets.length() == 1)\n+\t{\n+\t  if (cgraph_dump_file)\n+\t    {\n+\t      fprintf (cgraph_dump_file,\n+\t\t       \"Devirtualizing call: \");\n+\t      print_gimple_stmt (cgraph_dump_file,\n+\t\t\t\t edge->call_stmt, 0,\n+\t\t\t\t TDF_SLIM);\n+\t    }\n+\t  cgraph_make_edge_direct (edge, targets[0]);\n+\t  cgraph_redirect_edge_call_stmt_to_callee (edge);\n+\t  if (cgraph_dump_file)\n+\t    {\n+\t      fprintf (cgraph_dump_file,\n+\t\t       \"Devirtualized as: \");\n+\t      print_gimple_stmt (cgraph_dump_file,\n+\t\t\t\t edge->call_stmt, 0,\n+\t\t\t\t TDF_SLIM);\n+\t    }\n+\t}\n+    }\n+}\n+\n \n /* Discover all functions and variables that are trivially needed, analyze\n    them as well as all functions and variables referred by them  */\n@@ -923,71 +993,13 @@ analyze_functions (void)\n \t      if (optimize && flag_devirtualize)\n \t\t{\n \t\t  struct cgraph_edge *next;\n-\t          for (edge = cnode->indirect_calls; edge; edge = next)\n+\n+\t\t  for (edge = cnode->indirect_calls; edge; edge = next)\n \t\t    {\n \t\t      next = edge->next_callee;\n \t\t      if (edge->indirect_info->polymorphic)\n-\t\t\t{\n-\t\t\t  unsigned int i;\n-\t\t\t  void *cache_token;\n-\t\t\t  bool final;\n-\t\t\t  vec <cgraph_node *>targets\n-\t\t\t    = possible_polymorphic_call_targets\n-\t\t\t\t(edge, &final, &cache_token);\n-\n-\t\t\t  if (!pointer_set_insert (reachable_call_targets,\n-\t\t\t\t\t\t   cache_token))\n-\t\t\t    {\n-\t\t\t      if (cgraph_dump_file)\n-\t\t\t\tdump_possible_polymorphic_call_targets \n-\t\t\t\t  (cgraph_dump_file, edge);\n-\n-\t\t\t      for (i = 0; i < targets.length(); i++)\n-\t\t\t\t{\n-\t\t\t\t  /* Do not bother to mark virtual methods in anonymous namespace;\n-\t\t\t\t     either we will find use of virtual table defining it, or it is\n-\t\t\t\t     unused.  */\n-\t\t\t\t  if (targets[i]->symbol.definition\n-\t\t\t\t      && TREE_CODE\n-\t\t\t\t\t  (TREE_TYPE (targets[i]->symbol.decl))\n-\t\t\t\t\t   == METHOD_TYPE\n-\t\t\t\t      && !type_in_anonymous_namespace_p\n-\t\t\t\t\t   (method_class_type\n-\t\t\t\t\t     (TREE_TYPE (targets[i]->symbol.decl))))\n-\t\t\t\t  enqueue_node ((symtab_node) targets[i]);\n-\t\t\t\t}\n-\t\t\t    }\n-\n-\t\t\t  /* Very trivial devirtualization; when the type is\n-\t\t\t     final or anonymous (so we know all its derivation)\n-\t\t\t     and there is only one possible virtual call target,\n-\t\t\t     make the edge direct.  */\n-\t\t\t  if (final)\n-\t\t\t    {\n-\t\t\t      gcc_assert (targets.length());\n-\t\t\t      if (targets.length() == 1)\n-\t\t\t\t{\n-\t\t\t\t  if (cgraph_dump_file)\n-\t\t\t\t    {\n-\t\t\t\t      fprintf (cgraph_dump_file,\n-\t\t\t\t\t       \"Devirtualizing call: \");\n-\t\t\t\t      print_gimple_stmt (cgraph_dump_file,\n-\t\t\t\t\t\t\t edge->call_stmt, 0,\n-\t\t\t\t\t\t\t TDF_SLIM);\n-\t\t\t\t    }\n-\t\t\t\t  cgraph_make_edge_direct (edge, targets[0]);\n-\t\t\t\t  cgraph_redirect_edge_call_stmt_to_callee (edge);\n-\t\t\t\t  if (cgraph_dump_file)\n-\t\t\t\t    {\n-\t\t\t\t      fprintf (cgraph_dump_file,\n-\t\t\t\t\t       \"Devirtualized as: \");\n-\t\t\t\t      print_gimple_stmt (cgraph_dump_file,\n-\t\t\t\t\t\t\t edge->call_stmt, 0,\n-\t\t\t\t\t\t\t TDF_SLIM);\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n+\t\t\twalk_polymorphic_call_targets (reachable_call_targets,\n+\t\t\t\t\t\t       edge);\n \t\t    }\n \t\t}\n "}]}