{"sha": "4c868789e492c923f3e8736d92eeaac352518151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM4Njg3ODllNDkyYzkyM2YzZTg3MzZkOTJlZWFhYzM1MjUxODE1MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2016-01-13T17:03:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-01-13T17:03:42Z"}, "message": "re PR target/68964 (Internal compiler error for test case gcc.dg/tm/20100610.c since r231674)\n\nPR 68964\n\ngcc/\n PR tree-opt/68964\n * target.def (builtin_tm_load, builtin_tm_store): Remove.\n * config/i386/i386.c (ix86_builtin_tm_load): Remove.\n (ix86_builtin_tm_store): Remove.\n (TARGET_VECTORIZE_BUILTIN_TM_LOAD): Remove.\n (TARGET_VECTORIZE_BUILTIN_TM_STORE): Remove.\n * doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_TM_LOAD): Remove.\n (TARGET_VECTORIZE_BUILTIN_TM_STORE): Remove.\n * doc/tm.texi: Rebuild.\n * gtm-builtins.def (BUILT_IN_TM_MEMCPY_RNWT): New.\n (BUILT_IN_TM_MEMCPY_RTWN): New.\n * trans-mem.c (tm_log_emit_stmt): Rearrange code for better\n fallback from vector to integer helpers.\n (build_tm_load): Handle vector types directly, instead of\n via target hook.\n (build_tm_store): Likewise.\n (expand_assign_tm): Prepare for register types not handled by\n the above.  Copy them to memory and use memcpy.\n * tree.c (tm_define_builtin): New.\n (find_tm_vector_type): New.\n (build_tm_vector_builtins): New.\n (build_common_builtin_nodes): Call it.\n\nlibitm/\n * Makefile.am (libitm_la_SOURCES) [ARCH_AARCH64]: Add vect128.cc\n (libitm_la_SOURCES) [ARCH_ARM]: Add neon.cc\n (libitm_la_SOURCES) [ARCH_PPC]: Add vect128.cc\n (libitm_la_SOURCES) [ARCH_S390]: Add vect128.cc\n * configure.ac (ARCH_AARCH64): New conditional.\n (ARCH_PPC, ARCH_S390): Likewise.\n * Makefile.in, configure: Rebuild.\n * libitm.h (_ITM_TYPE_M128): Always define.\n * vect64.cc: Split ...\n * vect128.cc: ... out of...\n * config/x86/x86_sse.cc: ... here.\n * config/arm/neon.cc: New file.\n\nFrom-SVN: r232330", "tree": {"sha": "f728a754bf3a0dcace0dede256cd49817a1cc56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f728a754bf3a0dcace0dede256cd49817a1cc56e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c868789e492c923f3e8736d92eeaac352518151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c868789e492c923f3e8736d92eeaac352518151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c868789e492c923f3e8736d92eeaac352518151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c868789e492c923f3e8736d92eeaac352518151/comments", "author": null, "committer": null, "parents": [{"sha": "ef6d1772682f6929016159bb23a5640a9676718a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6d1772682f6929016159bb23a5640a9676718a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6d1772682f6929016159bb23a5640a9676718a"}], "stats": {"total": 726, "additions": 508, "deletions": 218}, "files": [{"sha": "ae3afded35e4b4c807d36368bfa9b1d9f25b88ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -1,3 +1,29 @@\n+2016-01-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/68964\n+\t* target.def (builtin_tm_load, builtin_tm_store): Remove.\n+\t* config/i386/i386.c (ix86_builtin_tm_load): Remove.\n+\t(ix86_builtin_tm_store): Remove.\n+\t(TARGET_VECTORIZE_BUILTIN_TM_LOAD): Remove.\n+\t(TARGET_VECTORIZE_BUILTIN_TM_STORE): Remove.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_TM_LOAD): Remove.\n+\t(TARGET_VECTORIZE_BUILTIN_TM_STORE): Remove.\n+\t* doc/tm.texi: Rebuild.\n+\n+\t* gtm-builtins.def (BUILT_IN_TM_MEMCPY_RNWT): New.\n+\t(BUILT_IN_TM_MEMCPY_RTWN): New.\n+\t* trans-mem.c (tm_log_emit_stmt): Rearrange code for better\n+\tfallback from vector to integer helpers.\n+\t(build_tm_load): Handle vector types directly, instead of\n+\tvia target hook.\n+\t(build_tm_store): Likewise.\n+\t(expand_assign_tm): Prepare for register types not handled by\n+\tthe above.  Copy them to memory and use memcpy.\n+\t* tree.c (tm_define_builtin): New.\n+\t(find_tm_vector_type): New.\n+\t(build_tm_vector_builtins): New.\n+\t(build_common_builtin_nodes): Call it.\n+\n 2016-01-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (TARGET_FLT_EVAL_METHOD): Return -1 for"}, {"sha": "996913b17d71295485400a80e40a85562d01a2af", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -35214,48 +35214,6 @@ static const struct builtin_description bdesc_tm[] =\n   { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_LM256\", (enum ix86_builtins) BUILT_IN_TM_LOG_M256, UNKNOWN, VOID_FTYPE_PCVOID },\n };\n \n-/* TM callbacks.  */\n-\n-/* Return the builtin decl needed to load a vector of TYPE.  */\n-\n-static tree\n-ix86_builtin_tm_load (tree type)\n-{\n-  if (TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      switch (tree_to_uhwi (TYPE_SIZE (type)))\n-\t{\n-\tcase 64:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M64);\n-\tcase 128:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M128);\n-\tcase 256:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M256);\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Return the builtin decl needed to store a vector of TYPE.  */\n-\n-static tree\n-ix86_builtin_tm_store (tree type)\n-{\n-  if (TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      switch (tree_to_uhwi (TYPE_SIZE (type)))\n-\t{\n-\tcase 64:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M64);\n-\tcase 128:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M128);\n-\tcase 256:\n-\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M256);\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\f\n /* Initialize the transactional memory vector load/store builtins.  */\n \n static void\n@@ -54340,12 +54298,6 @@ ix86_addr_space_zero_address_valid (addr_space_t as)\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n   ix86_builtin_vectorized_function\n \n-#undef TARGET_VECTORIZE_BUILTIN_TM_LOAD\n-#define TARGET_VECTORIZE_BUILTIN_TM_LOAD ix86_builtin_tm_load\n-\n-#undef TARGET_VECTORIZE_BUILTIN_TM_STORE\n-#define TARGET_VECTORIZE_BUILTIN_TM_STORE ix86_builtin_tm_store\n-\n #undef TARGET_VECTORIZE_BUILTIN_GATHER\n #define TARGET_VECTORIZE_BUILTIN_GATHER ix86_vectorize_builtin_gather\n "}, {"sha": "7a11552408d60bc58067e1bda36a17ee06eee237", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -5728,14 +5728,6 @@ This hook should complete calculations of the cost of vectorizing a loop or basi\n This hook should release @var{data} and any related data structures allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the accumulator.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_TM_LOAD (tree)\n-This hook should return the built-in decl needed to load a vector of the given type within a transaction.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_TM_STORE (tree)\n-This hook should return the built-in decl needed to store a vector of the given type within a transaction.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_GATHER (const_tree @var{mem_vectype}, const_tree @var{index_type}, int @var{scale})\n Target builtin that implements vector gather operation.  @var{mem_vectype}\n is the vector type of the load and @var{index_type} is scalar type of"}, {"sha": "f31c763991c595db02b2b1ef2939a05becb58a70", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -4253,10 +4253,6 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_DESTROY_COST_DATA\n \n-@hook TARGET_VECTORIZE_BUILTIN_TM_LOAD\n-\n-@hook TARGET_VECTORIZE_BUILTIN_TM_STORE\n-\n @hook TARGET_VECTORIZE_BUILTIN_GATHER\n \n @hook TARGET_VECTORIZE_BUILTIN_SCATTER"}, {"sha": "6d5cfb9b4060742ee72d0e2264b3749c71a528a6", "filename": "gcc/gtm-builtins.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fgtm-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Fgtm-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgtm-builtins.def?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -12,6 +12,10 @@ DEF_TM_BUILTIN (BUILT_IN_TM_IRREVOCABLE, \"_ITM_changeTransactionMode\",\n \n DEF_TM_BUILTIN (BUILT_IN_TM_MEMCPY, \"_ITM_memcpyRtWt\",\n \t\tBT_FN_VOID_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_MEMCPY_RNWT, \"_ITM_memcpyRnWt\",\n+\t\tBT_FN_VOID_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_MEMCPY_RTWN, \"_ITM_memcpyRtWn\",\n+\t\tBT_FN_VOID_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n DEF_TM_BUILTIN (BUILT_IN_TM_MEMMOVE, \"_ITM_memmoveRtWt\",\n \t\tBT_FN_VOID_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n DEF_TM_BUILTIN (BUILT_IN_TM_MEMSET, \"_ITM_memsetW\","}, {"sha": "946d2e5b5480c9067b138ea453b9def2961f57ae", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -1808,24 +1808,6 @@ parameter is true if the memory access is defined in a packed struct.\",\n  (machine_mode mode, const_tree type, int misalignment, bool is_packed),\n  default_builtin_support_vector_misalignment)\n \n-/* Return the builtin decl needed to load a vector of TYPE.  */\n-DEFHOOK\n-(builtin_tm_load,\n- \"This hook should return the built-in decl needed to load a vector of the \"\n- \"given type within a transaction.\",\n- tree,\n- (tree),\n- default_builtin_tm_load_store)\n-\n-/* Return the builtin decl needed to store a vector of TYPE.  */\n-DEFHOOK\n-(builtin_tm_store,\n- \"This hook should return the built-in decl needed to store a vector of the \"\n- \"given type within a transaction.\",\n- tree,\n- (tree),\n- default_builtin_tm_load_store)\n-\n /* Returns the preferred mode for SIMD operations for the specified\n    scalar mode.  */\n DEFHOOK"}, {"sha": "43cef533529aeec217d042e4bc5bda9ad518709d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -1,3 +1,8 @@\n+2016-01-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/tm/memopt-13.c: Update expected function.\n+\t* gcc.dg/tm/memopt-6.c: Likewise.\n+\n 2016-01-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/pr45685.c (dg-options): Add -mno-sse4."}, {"sha": "9db096a3407c8d185a101f96ffb52f9a5e636790", "filename": "gcc/testsuite/gcc.dg/tm/memopt-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -12,4 +12,4 @@ void f()\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"memmoveRtWt \\\\\\(&large_global,\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpyRnWt \\\\\\(&large_global,\" 1 \"tmmark\" } } */"}, {"sha": "d1a2f1de39c408e21bce8d6a854ca36b010eb0a8", "filename": "gcc/testsuite/gcc.dg/tm/memopt-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -18,4 +18,4 @@ int f()\n   return lala.x[i];\n }\n \n-/* { dg-final { scan-tree-dump-times \"memmoveRtWt \\\\\\(.*, &lacopy\" 1 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpyRtWn \\\\\\(.*, &lacopy\" 1 \"tmedge\" } } */"}, {"sha": "c4623071386e911fb22ac8006565749401e44eec", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 186, "deletions": 109, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -1190,7 +1190,6 @@ static void\n tm_log_emit_stmt (tree addr, gimple *stmt)\n {\n   tree type = TREE_TYPE (addr);\n-  tree size = TYPE_SIZE_UNIT (type);\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   gimple *log;\n   enum built_in_function code = BUILT_IN_TM_LOG;\n@@ -1201,43 +1200,60 @@ tm_log_emit_stmt (tree addr, gimple *stmt)\n     code = BUILT_IN_TM_LOG_DOUBLE;\n   else if (type == long_double_type_node)\n     code = BUILT_IN_TM_LOG_LDOUBLE;\n-  else if (tree_fits_uhwi_p (size))\n+  else if (TYPE_SIZE (type) != NULL\n+\t   && tree_fits_uhwi_p (TYPE_SIZE (type)))\n     {\n-      unsigned int n = tree_to_uhwi (size);\n-      switch (n)\n+      unsigned HOST_WIDE_INT type_size = tree_to_uhwi (TYPE_SIZE (type));\n+\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n \t{\n-\tcase 1:\n-\t  code = BUILT_IN_TM_LOG_1;\n-\t  break;\n-\tcase 2:\n-\t  code = BUILT_IN_TM_LOG_2;\n-\t  break;\n-\tcase 4:\n-\t  code = BUILT_IN_TM_LOG_4;\n-\t  break;\n-\tcase 8:\n-\t  code = BUILT_IN_TM_LOG_8;\n-\t  break;\n-\tdefault:\n-\t  code = BUILT_IN_TM_LOG;\n-\t  if (TREE_CODE (type) == VECTOR_TYPE)\n+\t  switch (type_size)\n \t    {\n-\t      if (n == 8 && builtin_decl_explicit (BUILT_IN_TM_LOG_M64))\n-\t\tcode = BUILT_IN_TM_LOG_M64;\n-\t      else if (n == 16 && builtin_decl_explicit (BUILT_IN_TM_LOG_M128))\n-\t\tcode = BUILT_IN_TM_LOG_M128;\n-\t      else if (n == 32 && builtin_decl_explicit (BUILT_IN_TM_LOG_M256))\n-\t\tcode = BUILT_IN_TM_LOG_M256;\n+\t    case 64:\n+\t      code = BUILT_IN_TM_LOG_M64;\n+\t      break;\n+\t    case 128:\n+\t      code = BUILT_IN_TM_LOG_M128;\n+\t      break;\n+\t    case 256:\n+\t      code = BUILT_IN_TM_LOG_M256;\n+\t      break;\n+\t    default:\n+\t      goto unhandled_vec;\n+\t    }\n+\t  if (!builtin_decl_explicit_p (code))\n+\t    goto unhandled_vec;\n+\t}\n+      else\n+\t{\n+\tunhandled_vec:\n+\t  switch (type_size)\n+\t    {\n+\t    case 1:\n+\t      code = BUILT_IN_TM_LOG_1;\n+\t      break;\n+\t    case 2:\n+\t      code = BUILT_IN_TM_LOG_2;\n+\t      break;\n+\t    case 4:\n+\t      code = BUILT_IN_TM_LOG_4;\n+\t      break;\n+\t    case 8:\n+\t      code = BUILT_IN_TM_LOG_8;\n+\t      break;\n \t    }\n-\t  break;\n \t}\n     }\n \n+  if (code != BUILT_IN_TM_LOG && !builtin_decl_explicit_p (code))\n+    code = BUILT_IN_TM_LOG;\n+  tree decl = builtin_decl_explicit (code);\n+\n   addr = gimplify_addr (&gsi, addr);\n   if (code == BUILT_IN_TM_LOG)\n-    log = gimple_build_call (builtin_decl_explicit (code), 2, addr,  size);\n+    log = gimple_build_call (decl, 2, addr, TYPE_SIZE_UNIT (type));\n   else\n-    log = gimple_build_call (builtin_decl_explicit (code), 1, addr);\n+    log = gimple_build_call (decl, 1, addr);\n   gsi_insert_before (&gsi, log, GSI_SAME_STMT);\n }\n \n@@ -2171,44 +2187,66 @@ transaction_subcode_ior (struct tm_region *region, unsigned flags)\n static gcall *\n build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n {\n-  enum built_in_function code = END_BUILTINS;\n-  tree t, type = TREE_TYPE (rhs), decl;\n+  tree t, type = TREE_TYPE (rhs);\n   gcall *gcall;\n \n+  built_in_function code;\n   if (type == float_type_node)\n     code = BUILT_IN_TM_LOAD_FLOAT;\n   else if (type == double_type_node)\n     code = BUILT_IN_TM_LOAD_DOUBLE;\n   else if (type == long_double_type_node)\n     code = BUILT_IN_TM_LOAD_LDOUBLE;\n-  else if (TYPE_SIZE_UNIT (type) != NULL\n-\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n+  else\n     {\n-      switch (tree_to_uhwi (TYPE_SIZE_UNIT (type)))\n+      if (TYPE_SIZE (type) == NULL || !tree_fits_uhwi_p (TYPE_SIZE (type)))\n+\treturn NULL;\n+      unsigned HOST_WIDE_INT type_size = tree_to_uhwi (TYPE_SIZE (type));\n+\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n \t{\n-\tcase 1:\n-\t  code = BUILT_IN_TM_LOAD_1;\n-\t  break;\n-\tcase 2:\n-\t  code = BUILT_IN_TM_LOAD_2;\n-\t  break;\n-\tcase 4:\n-\t  code = BUILT_IN_TM_LOAD_4;\n-\t  break;\n-\tcase 8:\n-\t  code = BUILT_IN_TM_LOAD_8;\n-\t  break;\n+\t  switch (type_size)\n+\t    {\n+\t    case 64:\n+\t      code = BUILT_IN_TM_LOAD_M64;\n+\t      break;\n+\t    case 128:\n+\t      code = BUILT_IN_TM_LOAD_M128;\n+\t      break;\n+\t    case 256:\n+\t      code = BUILT_IN_TM_LOAD_M256;\n+\t      break;\n+\t    default:\n+\t      goto unhandled_vec;\n+\t    }\n+\t  if (!builtin_decl_explicit_p (code))\n+\t    goto unhandled_vec;\n+\t}\n+      else\n+\t{\n+\tunhandled_vec:\n+\t  switch (type_size)\n+\t    {\n+\t    case 8:\n+\t      code = BUILT_IN_TM_LOAD_1;\n+\t      break;\n+\t    case 16:\n+\t      code = BUILT_IN_TM_LOAD_2;\n+\t      break;\n+\t    case 32:\n+\t      code = BUILT_IN_TM_LOAD_4;\n+\t      break;\n+\t    case 64:\n+\t      code = BUILT_IN_TM_LOAD_8;\n+\t      break;\n+\t    default:\n+\t      return NULL;\n+\t    }\n \t}\n     }\n \n-  if (code == END_BUILTINS)\n-    {\n-      decl = targetm.vectorize.builtin_tm_load (type);\n-      if (!decl)\n-\treturn NULL;\n-    }\n-  else\n-    decl = builtin_decl_explicit (code);\n+  tree decl = builtin_decl_explicit (code);\n+  gcc_assert (decl);\n \n   t = gimplify_addr (gsi, rhs);\n   gcall = gimple_build_call (decl, 1, t);\n@@ -2243,44 +2281,66 @@ build_tm_load (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n static gcall *\n build_tm_store (location_t loc, tree lhs, tree rhs, gimple_stmt_iterator *gsi)\n {\n-  enum built_in_function code = END_BUILTINS;\n   tree t, fn, type = TREE_TYPE (rhs), simple_type;\n   gcall *gcall;\n \n+  built_in_function code;\n   if (type == float_type_node)\n     code = BUILT_IN_TM_STORE_FLOAT;\n   else if (type == double_type_node)\n     code = BUILT_IN_TM_STORE_DOUBLE;\n   else if (type == long_double_type_node)\n     code = BUILT_IN_TM_STORE_LDOUBLE;\n-  else if (TYPE_SIZE_UNIT (type) != NULL\n-\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n+  else\n     {\n-      switch (tree_to_uhwi (TYPE_SIZE_UNIT (type)))\n+      if (TYPE_SIZE (type) == NULL || !tree_fits_uhwi_p (TYPE_SIZE (type)))\n+\treturn NULL;\n+      unsigned HOST_WIDE_INT type_size = tree_to_uhwi (TYPE_SIZE (type));\n+\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n \t{\n-\tcase 1:\n-\t  code = BUILT_IN_TM_STORE_1;\n-\t  break;\n-\tcase 2:\n-\t  code = BUILT_IN_TM_STORE_2;\n-\t  break;\n-\tcase 4:\n-\t  code = BUILT_IN_TM_STORE_4;\n-\t  break;\n-\tcase 8:\n-\t  code = BUILT_IN_TM_STORE_8;\n-\t  break;\n+\t  switch (type_size)\n+\t    {\n+\t    case 64:\n+\t      code = BUILT_IN_TM_STORE_M64;\n+\t      break;\n+\t    case 128:\n+\t      code = BUILT_IN_TM_STORE_M128;\n+\t      break;\n+\t    case 256:\n+\t      code = BUILT_IN_TM_STORE_M256;\n+\t      break;\n+\t    default:\n+\t      goto unhandled_vec;\n+\t    }\n+\t  if (!builtin_decl_explicit_p (code))\n+\t    goto unhandled_vec;\n+\t}\n+      else\n+\t{\n+\tunhandled_vec:\n+\t  switch (type_size)\n+\t    {\n+\t    case 8:\n+\t      code = BUILT_IN_TM_STORE_1;\n+\t      break;\n+\t    case 16:\n+\t      code = BUILT_IN_TM_STORE_2;\n+\t      break;\n+\t    case 32:\n+\t      code = BUILT_IN_TM_STORE_4;\n+\t      break;\n+\t    case 64:\n+\t      code = BUILT_IN_TM_STORE_8;\n+\t      break;\n+\t    default:\n+\t      return NULL;\n+\t    }\n \t}\n     }\n \n-  if (code == END_BUILTINS)\n-    {\n-      fn = targetm.vectorize.builtin_tm_store (type);\n-      if (!fn)\n-\treturn NULL;\n-    }\n-  else\n-    fn = builtin_decl_explicit (code);\n+  fn = builtin_decl_explicit (code);\n+  gcc_assert (fn);\n \n   simple_type = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn))));\n \n@@ -2342,63 +2402,80 @@ expand_assign_tm (struct tm_region *region, gimple_stmt_iterator *gsi)\n       return;\n     }\n \n+  if (load_p)\n+    transaction_subcode_ior (region, GTMA_HAVE_LOAD);\n+  if (store_p)\n+    transaction_subcode_ior (region, GTMA_HAVE_STORE);\n+\n   // Remove original load/store statement.\n   gsi_remove (gsi, true);\n \n+  // Attempt to use a simple load/store helper function.\n   if (load_p && !store_p)\n-    {\n-      transaction_subcode_ior (region, GTMA_HAVE_LOAD);\n-      gcall = build_tm_load (loc, lhs, rhs, gsi);\n-    }\n+    gcall = build_tm_load (loc, lhs, rhs, gsi);\n   else if (store_p && !load_p)\n-    {\n-      transaction_subcode_ior (region, GTMA_HAVE_STORE);\n-      gcall = build_tm_store (loc, lhs, rhs, gsi);\n-    }\n+    gcall = build_tm_store (loc, lhs, rhs, gsi);\n+\n+  // If gcall has not been set, then we do not have a simple helper\n+  // function available for the type.  This may be true of larger\n+  // structures, vectors, and non-standard float types.\n   if (!gcall)\n     {\n-      tree lhs_addr, rhs_addr, tmp;\n-\n-      if (load_p)\n-\ttransaction_subcode_ior (region, GTMA_HAVE_LOAD);\n-      if (store_p)\n-\ttransaction_subcode_ior (region, GTMA_HAVE_STORE);\n+      tree lhs_addr, rhs_addr, ltmp = NULL, copy_fn;\n \n-      /* ??? Figure out if there's any possible overlap between the LHS\n-\t and the RHS and if not, use MEMCPY.  */\n+      // If this is a type that we couldn't handle above, but it's\n+      // in a register, we must spill it to memory for the copy.\n+      if (is_gimple_reg (lhs))\n+\t{\n+\t  ltmp = create_tmp_var (TREE_TYPE (lhs));\n+\t  lhs_addr = build_fold_addr_expr (ltmp);\n+\t}\n+      else\n+\tlhs_addr = gimplify_addr (gsi, lhs);\n+      if (is_gimple_reg (rhs))\n+\t{\n+\t  tree rtmp = create_tmp_var (TREE_TYPE (rhs));\n+\t  rhs_addr = build_fold_addr_expr (rtmp);\n+\t  gcall = gimple_build_assign (rtmp, rhs);\n+\t  gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n+\t}\n+      else\n+\trhs_addr = gimplify_addr (gsi, rhs);\n \n-      if (load_p && is_gimple_reg (lhs))\n+      // Choose the appropriate memory transfer function.\n+      if (load_p && store_p)\n+\t{\n+\t  // ??? Figure out if there's any possible overlap between\n+\t  // the LHS and the RHS and if not, use MEMCPY.\n+\t  copy_fn = builtin_decl_explicit (BUILT_IN_TM_MEMMOVE);\n+\t}\n+      else if (load_p)\n \t{\n-\t  tmp = create_tmp_var (TREE_TYPE (lhs));\n-\t  lhs_addr = build_fold_addr_expr (tmp);\n+\t  // Note that the store is non-transactional and cannot overlap.\n+\t  copy_fn = builtin_decl_explicit (BUILT_IN_TM_MEMCPY_RTWN);\n \t}\n       else\n \t{\n-\t  tmp = NULL_TREE;\n-\t  lhs_addr = gimplify_addr (gsi, lhs);\n+\t  // Note that the load is non-transactional and cannot overlap.\n+\t  copy_fn = builtin_decl_explicit (BUILT_IN_TM_MEMCPY_RNWT);\n \t}\n-      rhs_addr = gimplify_addr (gsi, rhs);\n-      gcall = gimple_build_call (builtin_decl_explicit (BUILT_IN_TM_MEMMOVE),\n-\t\t\t\t 3, lhs_addr, rhs_addr,\n+\n+      gcall = gimple_build_call (copy_fn, 3, lhs_addr, rhs_addr,\n \t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (lhs)));\n       gimple_set_location (gcall, loc);\n       gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n \n-      if (tmp)\n+      if (ltmp)\n \t{\n-\t  gcall = gimple_build_assign (lhs, tmp);\n+\t  gcall = gimple_build_assign (lhs, ltmp);\n \t  gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n \t}\n     }\n \n-  /* Now that we have the load/store in its instrumented form, add\n-     thread private addresses to the log if applicable.  */\n+  // Now that we have the load/store in its instrumented form, add\n+  // thread private addresses to the log if applicable.\n   if (!store_p)\n     requires_barrier (region->entry_block, lhs, gcall);\n-\n-  // The calls to build_tm_{store,load} above inserted the instrumented\n-  // call into the stream.\n-  // gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n }\n \n "}, {"sha": "e6880f05b2975bc52e4c061fb62f6b32731d61bd", "filename": "gcc/tree.c", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -10330,6 +10330,143 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n   set_builtin_decl (code, decl, true);\n }\n \n+/* A subroutine of build_tm_vector_builtins.  Define a builtin with\n+   all of the appropriate attributes.  */\n+static void\n+tm_define_builtin (const char *name, tree type, built_in_function code,\n+\t\t   tree decl_attrs, tree type_attrs)\n+{\n+  tree decl = add_builtin_function (name, type, code, BUILT_IN_NORMAL,\n+\t\t\t            name + strlen (\"__builtin_\"), decl_attrs);\n+  decl_attributes (&TREE_TYPE (decl), type_attrs, ATTR_FLAG_BUILT_IN);\n+  set_builtin_decl (code, decl, true);\n+}\n+\n+/* A subroutine of build_tm_vector_builtins.  Find a supported vector\n+   type VECTOR_BITS wide with inner mode ELEM_MODE.  */\n+static tree\n+find_tm_vector_type (unsigned vector_bits, machine_mode elem_mode)\n+{\n+  unsigned elem_bits = GET_MODE_BITSIZE (elem_mode);\n+  unsigned nunits = vector_bits / elem_bits;\n+\n+  gcc_assert (elem_bits * nunits == vector_bits);\n+\n+  machine_mode vector_mode = mode_for_vector (elem_mode, nunits);\n+  if (!VECTOR_MODE_P (vector_mode)\n+      || !targetm.vector_mode_supported_p (vector_mode))\n+    return NULL_TREE;\n+\n+  tree innertype = lang_hooks.types.type_for_mode (elem_mode, 0);\n+  return build_vector_type_for_mode (innertype, vector_mode);\n+}\n+\n+/* A subroutine of build_common_builtin_nodes.  Define TM builtins for\n+   vector types.  This is done after the target hook, so that the target\n+   has a chance to override these.  */\n+static void\n+build_tm_vector_builtins (void)\n+{\n+  tree vtype, pvtype, ftype, decl;\n+  tree attrs_load, attrs_type_load;\n+  tree attrs_store, attrs_type_store;\n+  tree attrs_log, attrs_type_log;\n+\n+  /* Do nothing if TM is turned off, either with switch or\n+     not enabled in the language.  */\n+  if (!flag_tm || !builtin_decl_explicit_p (BUILT_IN_TM_LOAD_1))\n+    return;\n+\n+  /* Use whatever attributes a normal TM load has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_LOAD_1);\n+  attrs_load = DECL_ATTRIBUTES (decl);\n+  attrs_type_load = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+  /* Use whatever attributes a normal TM store has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_STORE_1);\n+  attrs_store = DECL_ATTRIBUTES (decl);\n+  attrs_type_store = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+  /* Use whatever attributes a normal TM log has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_LOG);\n+  attrs_log = DECL_ATTRIBUTES (decl);\n+  attrs_type_log = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+\n+  /* By default, 64 bit vectors go through the long long helpers.  */\n+\n+  /* If a 128-bit vector is supported, declare those builtins.  */\n+  if (!builtin_decl_declared_p (BUILT_IN_TM_STORE_M128)\n+      && ((vtype = find_tm_vector_type (128, SImode))\n+\t  || (vtype = find_tm_vector_type (128, SFmode))))\n+    {\n+      pvtype = build_pointer_type (vtype);\n+\n+      ftype = build_function_type_list (void_type_node, pvtype, vtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_WM128\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_M128,\n+\t\t\t attrs_store, attrs_type_store);\n+      tm_define_builtin (\"__builtin__ITM_WaRM128\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_WAR_M128,\n+\t\t\t attrs_store, attrs_type_store);\n+      tm_define_builtin (\"__builtin__ITM_WaWM128\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_WAW_M128,\n+\t\t\t attrs_store, attrs_type_store);\n+\n+      ftype = build_function_type_list (vtype, pvtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_RM128\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_M128,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RaRM128\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RAR_M128,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RaWM128\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RAW_M128,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RfWM128\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RFW_M128,\n+\t\t\t attrs_load, attrs_type_load);\n+\n+      ftype = build_function_type_list (void_type_node, pvtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_LM128\", ftype,\n+\t\t\t BUILT_IN_TM_LOG_M128, attrs_log, attrs_type_log);\n+    }\n+\n+  /* If a 256-bit vector is supported, declare those builtins.  */\n+  if (!builtin_decl_declared_p (BUILT_IN_TM_STORE_M256)\n+      && ((vtype = find_tm_vector_type (256, SImode))\n+\t  || (vtype = find_tm_vector_type (256, SFmode))))\n+    {\n+      pvtype = build_pointer_type (vtype);\n+\n+      ftype = build_function_type_list (void_type_node, pvtype, vtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_WM256\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_M256,\n+\t\t\t attrs_store, attrs_type_store);\n+      tm_define_builtin (\"__builtin__ITM_WaRM256\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_WAR_M256,\n+\t\t\t attrs_store, attrs_type_store);\n+      tm_define_builtin (\"__builtin__ITM_WaWM256\", ftype,\n+\t\t\t BUILT_IN_TM_STORE_WAW_M256,\n+\t\t\t attrs_store, attrs_type_store);\n+\n+      ftype = build_function_type_list (vtype, pvtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_RM256\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_M256,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RaRM256\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RAR_M256,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RaWM256\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RAW_M256,\n+\t\t\t attrs_load, attrs_type_load);\n+      tm_define_builtin (\"__builtin__ITM_RfWM256\", ftype,\n+\t\t\t BUILT_IN_TM_LOAD_RFW_M256,\n+\t\t\t attrs_load, attrs_type_load);\n+\n+      ftype = build_function_type_list (void_type_node, pvtype, NULL);\n+      tm_define_builtin (\"__builtin__ITM_LM256\", ftype,\n+\t\t\t BUILT_IN_TM_LOG_M256, attrs_log, attrs_type_log);\n+    }\n+}\n+\n /* Call this function after instantiating all builtins that the language\n    front end cares about.  This will build the rest of the builtins\n    and internal functions that are relied upon by the tree optimizers and\n@@ -10568,6 +10705,7 @@ build_common_builtin_nodes (void)\n       }\n   }\n \n+  build_tm_vector_builtins ();\n   init_internal_fns ();\n }\n "}, {"sha": "7f7225a9b55678c5df8e9fb25cd7e218ebc88988", "filename": "libitm/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -1,3 +1,19 @@\n+2016-01-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (libitm_la_SOURCES) [ARCH_AARCH64]: Add vect128.cc\n+\t(libitm_la_SOURCES) [ARCH_ARM]: Add neon.cc\n+\t(libitm_la_SOURCES) [ARCH_PPC]: Add vect128.cc\n+\t(libitm_la_SOURCES) [ARCH_S390]: Add vect128.cc\n+\t* configure.ac (ARCH_AARCH64): New conditional.\n+\t(ARCH_PPC, ARCH_S390): Likewise.\n+\t* Makefile.in, configure: Rebuild.\n+\n+\t* libitm.h (_ITM_TYPE_M128): Always define.\n+\t* vect64.cc: Split ...\n+\t* vect128.cc: ... out of...\n+\t* config/x86/x86_sse.cc: ... here.\n+\t* config/arm/neon.cc: New file.\n+\n 2016-01-13  Torvald Riegel  <triegel@redhat.com>\n \n \t* beginend.cc (gtm_thread::trycommit): Fix privatization safety."}, {"sha": "6e1438d6191993fcf4c70c6051c7a096b125c603", "filename": "libitm/Makefile.am", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FMakefile.am?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -62,16 +62,26 @@ libitm_la_SOURCES = \\\n \tquery.cc retry.cc rwlock.cc useraction.cc util.cc \\\n \tsjlj.S tls.cc method-serial.cc method-gl.cc method-ml.cc\n \n+if ARCH_AARCH64\n+libitm_la_SOURCES += vect128.cc\n+endif\n if ARCH_ARM\n-libitm_la_SOURCES += hwcap.cc\n+libitm_la_SOURCES += hwcap.cc neon.cc\n+endif\n+if ARCH_PPC\n+libitm_la_SOURCES += vect128.cc\n+vect128.lo : override CXXFLAGS += -maltivec\n+endif\n+if ARCH_S390\n+libitm_la_SOURCES += vect128.cc\n+vect128.lo : override CXXFLAGS += -march=z13\n endif\n if ARCH_X86\n-libitm_la_SOURCES += x86_sse.cc x86_avx.cc\n-# Make sure -msse is appended at the end.\n-x86_sse.lo : override CXXFLAGS += -msse\n+libitm_la_SOURCES += vect64.cc vect128.cc x86_avx.cc\n+vect64.lo : override CXXFLAGS += -msse\n+vect128.lo : override CXXFLAGS += -msse\n endif\n if ARCH_X86_AVX\n-# Make sure -mavx is appended at the end.\n x86_avx.lo : override CXXFLAGS += -mavx\n endif\n "}, {"sha": "f2cbb5cb7209e126615874d7c79316e4b2928049", "filename": "libitm/Makefile.in", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FMakefile.in?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -53,9 +53,12 @@ POST_UNINSTALL = :\n build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n-@ARCH_ARM_TRUE@am__append_1 = hwcap.cc\n-@ARCH_X86_TRUE@am__append_2 = x86_sse.cc x86_avx.cc\n-@ARCH_FUTEX_TRUE@am__append_3 = futex.cc\n+@ARCH_AARCH64_TRUE@am__append_1 = vect128.cc\n+@ARCH_ARM_TRUE@am__append_2 = hwcap.cc neon.cc\n+@ARCH_PPC_TRUE@am__append_3 = vect128.cc\n+@ARCH_S390_TRUE@am__append_4 = vect128.cc\n+@ARCH_X86_TRUE@am__append_5 = vect64.cc vect128.cc x86_avx.cc\n+@ARCH_FUTEX_TRUE@am__append_6 = futex.cc\n subdir = .\n DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n \t$(top_srcdir)/configure $(am__configure_deps) \\\n@@ -117,14 +120,18 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibdir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n libitm_la_LIBADD =\n-@ARCH_ARM_TRUE@am__objects_1 = hwcap.lo\n-@ARCH_X86_TRUE@am__objects_2 = x86_sse.lo x86_avx.lo\n-@ARCH_FUTEX_TRUE@am__objects_3 = futex.lo\n+@ARCH_AARCH64_TRUE@am__objects_1 = vect128.lo\n+@ARCH_ARM_TRUE@am__objects_2 = hwcap.lo neon.lo\n+@ARCH_PPC_TRUE@am__objects_3 = vect128.lo\n+@ARCH_S390_TRUE@am__objects_4 = vect128.lo\n+@ARCH_X86_TRUE@am__objects_5 = vect64.lo vect128.lo x86_avx.lo\n+@ARCH_FUTEX_TRUE@am__objects_6 = futex.lo\n am_libitm_la_OBJECTS = aatree.lo alloc.lo alloc_c.lo alloc_cpp.lo \\\n \tbarrier.lo beginend.lo clone.lo eh_cpp.lo local.lo query.lo \\\n \tretry.lo rwlock.lo useraction.lo util.lo sjlj.lo tls.lo \\\n \tmethod-serial.lo method-gl.lo method-ml.lo $(am__objects_1) \\\n-\t$(am__objects_2) $(am__objects_3)\n+\t$(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+\t$(am__objects_5) $(am__objects_6)\n libitm_la_OBJECTS = $(am_libitm_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n@@ -362,7 +369,8 @@ libitm_la_SOURCES = aatree.cc alloc.cc alloc_c.cc alloc_cpp.cc \\\n \tbarrier.cc beginend.cc clone.cc eh_cpp.cc local.cc query.cc \\\n \tretry.cc rwlock.cc useraction.cc util.cc sjlj.S tls.cc \\\n \tmethod-serial.cc method-gl.cc method-ml.cc $(am__append_1) \\\n-\t$(am__append_2) $(am__append_3)\n+\t$(am__append_2) $(am__append_3) $(am__append_4) \\\n+\t$(am__append_5) $(am__append_6)\n \n # Automake Documentation:\n # If your package has Texinfo files in many directories, you can use the\n@@ -495,15 +503,17 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/method-gl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/method-ml.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/method-serial.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/neon.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/query.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/retry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rwlock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sjlj.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tls.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/useraction.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vect128.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vect64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x86_avx.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x86_sse.Plo@am__quote@\n \n .S.o:\n @am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -1096,9 +1106,10 @@ vpath % $(strip $(search_path))\n @LIBITM_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBITM_BUILD_VERSIONED_SHLIB_TRUE@\t `echo $(libitm_la_LIBADD) | \\\n @LIBITM_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBITM_BUILD_VERSIONED_SHLIB_TRUE@\t    sed 's,/\\([^/.]*\\)\\.la,/.libs/\\1.a,g'` \\\n @LIBITM_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBITM_BUILD_VERSIONED_SHLIB_TRUE@\t > $@ || (rm -f $@ ; exit 1)\n-# Make sure -msse is appended at the end.\n-@ARCH_X86_TRUE@x86_sse.lo : override CXXFLAGS += -msse\n-# Make sure -mavx is appended at the end.\n+@ARCH_PPC_TRUE@vect128.lo : override CXXFLAGS += -maltivec\n+@ARCH_S390_TRUE@vect128.lo : override CXXFLAGS += -march=z13\n+@ARCH_X86_TRUE@vect64.lo : override CXXFLAGS += -msse\n+@ARCH_X86_TRUE@vect128.lo : override CXXFLAGS += -msse\n @ARCH_X86_AVX_TRUE@x86_avx.lo : override CXXFLAGS += -mavx\n \n all-local: $(STAMP_GENINSRC)"}, {"sha": "a9c3074405e4dcae06c454c0e8ba77cbcdefba89", "filename": "libitm/config/arm/neon.cc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfig%2Farm%2Fneon.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfig%2Farm%2Fneon.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Farm%2Fneon.cc?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -0,0 +1,3 @@\n+#ifdef __ARM_NEON\n+#include <vect128.cc>\n+#endif"}, {"sha": "637fcd19669d4a48aea3ddbb7ab77e96a623344b", "filename": "libitm/configure", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -607,8 +607,14 @@ ARCH_X86_AVX_FALSE\n ARCH_X86_AVX_TRUE\n ARCH_X86_FALSE\n ARCH_X86_TRUE\n+ARCH_S390_FALSE\n+ARCH_S390_TRUE\n+ARCH_PPC_FALSE\n+ARCH_PPC_TRUE\n ARCH_ARM_FALSE\n ARCH_ARM_TRUE\n+ARCH_AARCH64_FALSE\n+ARCH_AARCH64_TRUE\n link_itm\n XLDFLAGS\n XCFLAGS\n@@ -9762,7 +9768,7 @@ _LT_EOF\n \tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n \t  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n \telse\n-\t  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n+\t  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"L\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n \tfi\n \taix_use_runtimelinking=no\n \n@@ -11790,7 +11796,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11793 \"configure\"\n+#line 11799 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11896,7 +11902,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11899 \"configure\"\n+#line 11905 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -14248,7 +14254,7 @@ $as_echo_n \"checking whether the $compiler linker ($LD) supports shared librarie\n     if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n       export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n     else\n-      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n+      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"L\")) && (substr(\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n     fi\n     ;;\n   pw32*)\n@@ -17603,6 +17609,14 @@ else\n fi\n \n \n+ if test \"$ARCH\" = aarch64; then\n+  ARCH_AARCH64_TRUE=\n+  ARCH_AARCH64_FALSE='#'\n+else\n+  ARCH_AARCH64_TRUE='#'\n+  ARCH_AARCH64_FALSE=\n+fi\n+\n  if test \"$ARCH\" = arm; then\n   ARCH_ARM_TRUE=\n   ARCH_ARM_FALSE='#'\n@@ -17611,6 +17625,22 @@ else\n   ARCH_ARM_FALSE=\n fi\n \n+ if test \"$ARCH\" = powerpc -o \"$ARCH\" = powerpc64; then\n+  ARCH_PPC_TRUE=\n+  ARCH_PPC_FALSE='#'\n+else\n+  ARCH_PPC_TRUE='#'\n+  ARCH_PPC_FALSE=\n+fi\n+\n+ if test \"$ARCH\" = s390 -o \"$ARCH\" = s390x; then\n+  ARCH_S390_TRUE=\n+  ARCH_S390_FALSE='#'\n+else\n+  ARCH_S390_TRUE='#'\n+  ARCH_S390_FALSE=\n+fi\n+\n  if test \"$ARCH\" = x86; then\n   ARCH_X86_TRUE=\n   ARCH_X86_FALSE='#'\n@@ -17788,10 +17818,22 @@ if test -z \"${LIBITM_BUILD_VERSIONED_SHLIB_SUN_TRUE}\" && test -z \"${LIBITM_BUILD\n   as_fn_error \"conditional \\\"LIBITM_BUILD_VERSIONED_SHLIB_SUN\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${ARCH_AARCH64_TRUE}\" && test -z \"${ARCH_AARCH64_FALSE}\"; then\n+  as_fn_error \"conditional \\\"ARCH_AARCH64\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${ARCH_ARM_TRUE}\" && test -z \"${ARCH_ARM_FALSE}\"; then\n   as_fn_error \"conditional \\\"ARCH_ARM\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${ARCH_PPC_TRUE}\" && test -z \"${ARCH_PPC_FALSE}\"; then\n+  as_fn_error \"conditional \\\"ARCH_PPC\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${ARCH_S390_TRUE}\" && test -z \"${ARCH_S390_FALSE}\"; then\n+  as_fn_error \"conditional \\\"ARCH_S390\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${ARCH_X86_TRUE}\" && test -z \"${ARCH_X86_FALSE}\"; then\n   as_fn_error \"conditional \\\"ARCH_X86\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "36e065140d840aa05b667987f482370f4146e3e6", "filename": "libitm/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.ac?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -281,7 +281,10 @@ else\n fi\n AC_SUBST(link_itm)\n \n+AM_CONDITIONAL([ARCH_AARCH64], [test \"$ARCH\" = aarch64])\n AM_CONDITIONAL([ARCH_ARM], [test \"$ARCH\" = arm])\n+AM_CONDITIONAL([ARCH_PPC], [test \"$ARCH\" = powerpc -o \"$ARCH\" = powerpc64])\n+AM_CONDITIONAL([ARCH_S390], [test \"$ARCH\" = s390 -o \"$ARCH\" = s390x])\n AM_CONDITIONAL([ARCH_X86], [test \"$ARCH\" = x86])\n AM_CONDITIONAL([ARCH_X86_AVX], [test \"$libitm_cv_as_avx\" = yes])\n AM_CONDITIONAL([ARCH_FUTEX], [test $enable_linux_futex = yes])"}, {"sha": "1a6738b9dd331013ab14d7dd5df86d831997686e", "filename": "libitm/libitm.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Flibitm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Flibitm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.h?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -232,7 +232,11 @@ ITM_LOG(CE)\n   ITM_BARRIERS(M256)\n   ITM_LOG(M256)\n # endif\n-#endif /* i386 */\n+#else\n+  typedef int _ITM_TYPE_M128 __attribute__((vector_size(16), may_alias));\n+  ITM_BARRIERS(M128)\n+  ITM_LOG(M128)\n+#endif\n \n #undef ITM_BARRIERS\n #undef ITM_LOG"}, {"sha": "18453acf7351293eca9aad34ad80b2a6d071b009", "filename": "libitm/vect128.cc", "status": "renamed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fvect128.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fvect128.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fvect128.cc?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -27,15 +27,8 @@\n \n // ??? Use memcpy for now, until we have figured out how to best instantiate\n // these loads/stores.\n-CREATE_DISPATCH_FUNCTIONS_T_MEMCPY(M64, GTM::abi_disp()->, )\n CREATE_DISPATCH_FUNCTIONS_T_MEMCPY(M128, GTM::abi_disp()->, )\n \n-void ITM_REGPARM\n-_ITM_LM64 (const _ITM_TYPE_M64 *ptr)\n-{\n-  GTM::GTM_LB (ptr, sizeof (*ptr));\n-}\n-\n void ITM_REGPARM\n _ITM_LM128 (const _ITM_TYPE_M128 *ptr)\n {", "previous_filename": "libitm/config/x86/x86_sse.cc"}, {"sha": "c451c58717d2c123b77605c577dfaaf276072bbc", "filename": "libitm/vect64.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fvect64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c868789e492c923f3e8736d92eeaac352518151/libitm%2Fvect64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fvect64.cc?ref=4c868789e492c923f3e8736d92eeaac352518151", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2009-2016 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+#include \"dispatch.h\"\n+\n+// ??? Use memcpy for now, until we have figured out how to best instantiate\n+// these loads/stores.\n+CREATE_DISPATCH_FUNCTIONS_T_MEMCPY(M64, GTM::abi_disp()->, )\n+\n+void ITM_REGPARM\n+_ITM_LM64 (const _ITM_TYPE_M64 *ptr)\n+{\n+  GTM::GTM_LB (ptr, sizeof (*ptr));\n+}"}]}