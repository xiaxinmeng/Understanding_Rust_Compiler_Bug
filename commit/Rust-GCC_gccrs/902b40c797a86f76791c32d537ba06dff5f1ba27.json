{"sha": "902b40c797a86f76791c32d537ba06dff5f1ba27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAyYjQwYzc5N2E4NmY3Njc5MWMzMmQ1MzdiYTA2ZGZmNWYxYmEyNw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-20T13:18:50Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-20T13:18:50Z"}, "message": "libstdc++: Implement P2259R1 changes [PR95983]\n\nThis implements the wording changes of P2259R1 \"Repairing input range\nadaptors and counted_iterator\", which resolves LWG 3283, 3289 and 3408.\n\nThe wording changes are relatively straightforward, but they require\nsome boilerplate to implement: the changes to make a type alias\n\"conditionally present\" in some iterator class are realized by defining\na base class template and an appropriately constrained partial\nspecialization thereof that contains the type alias, and having the\niterator class derive from this base class.  Sometimes the relevant\ncondition depend on members from the iterator class, but because a\nclass is incomplete when instantiating its bases, the constraints on\nthe partial specialization can't use anything from the iterator class.\nThis patch works around this by hoisting these members out to the\nenclosing scope (e.g. transform_view::_Iterator::_Base is hoisted out\nto transform_view::_Base so that transform_view::__iter_cat can use it).\n\nThis patch also implements the proposed resolution of LWG 3291 to rename\niota_view::iterator_category to iota_view::iterator_concept, which was\npreviously problematic due to LWG 3408.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/95983\n\t* include/bits/stl_iterator.h (__detail::__move_iter_cat):\n\tDefine.\n\t(move_iterator): Derive from the above in C++20 in order to\n\tconditionally define iterator_category as per P2259.\n\t(move_iterator::__base_cat): No longer used, so remove.\n\t(move_iterator::iterator_category): Remove in C++20.\n\t(__detail::__common_iter_use_postfix_proxy): Define.\n\t(common_iterator::_Proxy): Rename to ...\n\t(common_iterator:__arrow_proxy): ... this.\n\t(common_iterator::__postfix_proxy): Define as per P2259.\n\t(common_iterator::operator->): Adjust.\n\t(common_iterator::operator++): Adjust as per P2259.\n\t(iterator_traits<common_iterator>::_S_iter_cat): Define.\n\t(iterator_traits<common_iterator>::iterator_category): Change as\n\tper P2259.\n\t(__detail::__counted_iter_value_type): Define.\n\t(__detail::__counted_iter_concept): Define.\n\t(__detail::__counted_iter_cat): Define.\n\t(counted_iterator): Derive from the above three classes in order\n\tto conditionally define value_type, iterator_concept and\n\titerator category respectively as per P2259.\n\t(counted_iterator::operator->): Define as per P2259.\n\t(incrementable_traits<counted_iterator>): Remove as per P2259.\n\t(iterator_traits<counted_iterator>): Adjust as per P2259.\n\t* include/std/ranges (__detail::__iota_view_iter_cat): Define.\n\t(iota_view::_Iterator): Derive from the above in order to\n\tconditionally define iterator_category as per P2259.\n\t(iota_view::_S_iter_cat): Rename to ...\n\t(iota_view::_S_iter_concept): ... this.\n\t(iota_view::iterator_concept): Use it to apply LWG 3291 changes.\n\t(iota_view::iterator_category): Remove.\n\t(__detail::__filter_view_iter_cat): Define.\n\t(filter_view::_Iterator): Derive from the above in order to\n\tconditionally define iterator_category as per P2259.\n\t(filter_view::_Iterator): Move to struct __filter_view_iter_cat.\n\t(filter_view::_Iterator::iterator_category): Remove.\n\t(transform_view::_Base): Define.\n\t(transform_view::__iter_cat): Define.\n\t(transform_view::_Iterator): Derive from the above in order to\n\tconditionally define iterator_category as per P2259.\n\t(transform_view::_Iterator::_Base): Just alias\n\ttransform_view::_Base.\n\t(transform_view::_Iterator::_S_iter_cat): Move to struct\n\ttransform_view::__iter_cat.\n\t(transform_view::_Iterator::iterator_category): Remove.\n\t(transform_view::_Sentinel::_Base): Just alias\n\ttransform_view::_Base.\n\t(join_view::_Base): Define.\n\t(join_view::_Outer_iter): Define.\n\t(join_view::_Inner_iter): Define.\n\t(join_view::_S_ref_is_glvalue): Define.\n\t(join_view::__iter_cat): Define.\n\t(join_view::_Iterator): Derive from it in order to conditionally\n\tdefine iterator_category as per P2259.\n\t(join_view::_Iterator::_Base): Just alias join_view::_Base.\n\t(join_view::_Iterator::_S_ref_is_glvalue): Just alias\n\tjoin_view::_S_ref_is_glvalue.\n\t(join_view::_Iterator::_S_iter_cat): Move to struct\n\ttransform_view::__iter_cat.\n\t(join_view::_Iterator::_Outer_iter): Just alias\n\tjoin_view::_Outer_iter.\n\t(join_view::_Iterator::_Inner_iter): Just alias\n\tjoin_view::_Inner_iter.\n\t(join_view::_Iterator::iterator_category): Remove.\n\t(join_view::_Sentinel::_Base): Just alias join_view::_Base.\n\t(__detail::__split_view_outer_iter_cat): Define.\n\t(__detail::__split_view_inner_iter_cat): Define.\n\t(split_view::_Base): Define.\n\t(split_view::_Outer_iter): Derive from __split_view_outer_iter_cat\n\tin order to conditionally define iterator_category as per P2259.\n\t(split_view::_Outer_iter::iterator_category): Remove.\n\t(split_view::_Inner_iter): Derive from __split_view_inner_iter_cat\n\tin order to conditionally define iterator_category as per P2259.\n\t(split_view::_Inner_iter::_S_iter_cat): Move to\n\t__split_view_inner_iter_cat.\n\t(split_view::_Inner_iter::iterator_category): Remove.\n\t(elements_view::_Base): Define.\n\t(elements_view::__iter_cat): Define.\n\t(elements_view::_Iterator): Derive from the above in order to\n\tconditionall define iterator_category as per P2259.\n\t(elements_view::_Iterator::_Base): Just alias\n\telements_view::_Base.\n\t(elements_view::_Iterator::_S_iter_concept)\n\t(elements_view::_Iterator::iterator_concept): Define as per\n\tP2259.\n\t(elements_view::_Iterator::iterator_category): Remove.\n\t(elements_view::_Sentinel::_Base): Just alias\n\telements_view::_Base.\n\t* testsuite/24_iterators/headers/iterator/synopsis_c++20.cc:\n\tAdjust constraints on iterator_traits<counted_iterator>.\n\t* testsuite/std/ranges/p2259.cc: New test.", "tree": {"sha": "f99436f15018ca4bef7cae83cc22b28f26d13423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f99436f15018ca4bef7cae83cc22b28f26d13423"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/902b40c797a86f76791c32d537ba06dff5f1ba27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902b40c797a86f76791c32d537ba06dff5f1ba27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/902b40c797a86f76791c32d537ba06dff5f1ba27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902b40c797a86f76791c32d537ba06dff5f1ba27/comments", "author": null, "committer": null, "parents": [{"sha": "7f5deba1c21888aacedae93e9f324827073a1d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5deba1c21888aacedae93e9f324827073a1d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f5deba1c21888aacedae93e9f324827073a1d1e"}], "stats": {"total": 519, "additions": 412, "deletions": 107}, "files": [{"sha": "049f83cff90a0482b1e67e273be3bdc0aaa47598", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 109, "deletions": 19, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=902b40c797a86f76791c32d537ba06dff5f1ba27", "patch": "@@ -1302,6 +1302,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #endif // C++20\n \n+  namespace __detail\n+  {\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+    template<typename _Iterator>\n+      struct __move_iter_cat\n+      { };\n+\n+    template<typename _Iterator>\n+      requires requires { typename iterator_traits<_Iterator>::iterator_category; }\n+      struct __move_iter_cat<_Iterator>\n+      {\n+\tusing iterator_category\n+\t  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,\n+\t\t\t     random_access_iterator_tag>;\n+      };\n+#endif\n+  }\n+\n   // 24.4.3  Move iterators\n   /**\n    *  Class template move_iterator is an iterator adapter with the same\n@@ -1313,13 +1331,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _Iterator>\n     class move_iterator\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+      : public __detail::__move_iter_cat<_Iterator>\n+#endif\n     {\n       _Iterator _M_current;\n \n       using __traits_type = iterator_traits<_Iterator>;\n-#if __cplusplus > 201703L && __cpp_lib_concepts\n-      using __base_cat = typename __traits_type::iterator_category;\n-#else\n+#if ! (__cplusplus > 201703L && __cpp_lib_concepts)\n       using __base_ref = typename __traits_type::reference;\n #endif\n \n@@ -1339,8 +1358,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if __cplusplus > 201703L && __cpp_lib_concepts\n       using iterator_concept = input_iterator_tag;\n-      using iterator_category\n-\t= __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;\n+      // iterator_category defined in __move_iter_cat\n       using value_type = iter_value_t<_Iterator>;\n       using difference_type = iter_difference_t<_Iterator>;\n       using pointer = _Iterator;\n@@ -1662,6 +1680,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    || is_reference_v<iter_reference_t<_It>>\n \t    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);\n \n+    template<typename _It>\n+      concept __common_iter_use_postfix_proxy\n+\t= (!requires (_It& __i) { { *__i++ } -> __can_reference; })\n+\t  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>;\n   } // namespace __detail\n \n   /// An iterator/sentinel adaptor for representing a non-common range.\n@@ -1684,11 +1706,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_noexcept()\n       { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }\n \n-    class _Proxy\n+    class __arrow_proxy\n     {\n       iter_value_t<_It> _M_keep;\n \n-      _Proxy(iter_reference_t<_It>&& __x)\n+      __arrow_proxy(iter_reference_t<_It>&& __x)\n       : _M_keep(std::move(__x)) { }\n \n       friend class common_iterator;\n@@ -1699,6 +1721,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return std::__addressof(_M_keep); }\n     };\n \n+    class __postfix_proxy\n+    {\n+      iter_value_t<_It> _M_keep;\n+\n+      __postfix_proxy(iter_reference_t<_It>&& __x)\n+      : _M_keep(std::move(__x)) { }\n+\n+      friend class common_iterator;\n+\n+    public:\n+      const iter_value_t<_It>&\n+      operator*() const\n+      { return _M_keep; }\n+    };\n+\n   public:\n     constexpr\n     common_iterator()\n@@ -1855,7 +1892,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return std::__addressof(__tmp);\n \t}\n       else\n-\treturn _Proxy{*_M_it};\n+\treturn __arrow_proxy{*_M_it};\n     }\n \n     common_iterator&\n@@ -1876,8 +1913,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ++*this;\n \t  return __tmp;\n \t}\n-      else\n+      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)\n \treturn _M_it++;\n+      else\n+\t{\n+\t  __postfix_proxy __p(**this);\n+\t  ++*this;\n+\t  return __p;\n+\t}\n     }\n \n     template<typename _It2, sentinel_for<_It> _Sent2>\n@@ -2008,12 +2051,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  using type = decltype(std::declval<const _CIter&>().operator->());\n \t};\n \n+      static auto\n+      _S_iter_cat()\n+      {\n+\tusing _Traits = iterator_traits<_It>;\n+\tif constexpr (requires { requires derived_from<typename _Traits::iterator_category,\n+\t\t\t\t\t\t       forward_iterator_tag>; })\n+\t  return forward_iterator_tag{};\n+\telse\n+\t  return input_iterator_tag{};\n+      }\n+\n     public:\n       using iterator_concept = conditional_t<forward_iterator<_It>,\n \t    forward_iterator_tag, input_iterator_tag>;\n-      using iterator_category = __detail::__clamp_iter_cat<\n-\ttypename iterator_traits<_It>::iterator_category,\n-\tforward_iterator_tag, input_iterator_tag>;\n+      using iterator_category = decltype(_S_iter_cat());\n       using value_type = iter_value_t<_It>;\n       using difference_type = iter_difference_t<_It>;\n       using pointer = typename __ptr<_It>::type;\n@@ -2022,12 +2074,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // [iterators.counted] Counted iterators\n \n+  namespace __detail\n+  {\n+    template<typename _It>\n+      struct __counted_iter_value_type\n+      { };\n+\n+    template<indirectly_readable _It>\n+      struct __counted_iter_value_type<_It>\n+      { using value_type = iter_value_t<_It>; };\n+\n+    template<typename _It>\n+      struct __counted_iter_concept\n+      { };\n+\n+    template<typename _It>\n+      requires requires { typename _It::iterator_concept; }\n+      struct __counted_iter_concept<_It>\n+      { using iterator_concept = typename _It::iterator_concept; };\n+\n+    template<typename _It>\n+      struct __counted_iter_cat\n+      { };\n+\n+    template<typename _It>\n+      requires requires { typename _It::iterator_category; }\n+      struct __counted_iter_cat<_It>\n+      { using iterator_category = typename _It::iterator_category; };\n+  }\n+\n   /// An iterator adaptor that keeps track of the distance to the end.\n   template<input_or_output_iterator _It>\n     class counted_iterator\n+      : public __detail::__counted_iter_value_type<_It>,\n+\tpublic __detail::__counted_iter_concept<_It>,\n+\tpublic __detail::__counted_iter_cat<_It>\n     {\n     public:\n       using iterator_type = _It;\n+      // value_type defined in __counted_iter_value_type\n+      using difference_type = iter_difference_t<_It>;\n+      // iterator_concept defined in __counted_iter_concept\n+      // iterator_category defined in __counted_iter_cat\n \n       constexpr counted_iterator() = default;\n \n@@ -2084,6 +2172,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *_M_current;\n       }\n \n+      constexpr auto\n+      operator->() const noexcept\n+      requires contiguous_iterator<_It>\n+      { return std::to_address(_M_current); }\n+\n       constexpr counted_iterator&\n       operator++()\n       {\n@@ -2232,16 +2325,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       iter_difference_t<_It> _M_length = 0;\n     };\n \n-  template<typename _It>\n-    struct incrementable_traits<counted_iterator<_It>>\n-    {\n-      using difference_type = iter_difference_t<_It>;\n-    };\n-\n   template<input_iterator _It>\n+    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>\n     struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>\n     {\n-      using pointer = void;\n+      using pointer = conditional_t<contiguous_iterator<_It>,\n+\t\t\t\t    add_pointer_t<iter_reference_t<_It>>,\n+\t\t\t\t    void>;\n     };\n #endif // C++20\n "}, {"sha": "74075a2d6d38a9798487554e0b4fe04413c9b9b0", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 211, "deletions": 88, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=902b40c797a86f76791c32d537ba06dff5f1ba27", "patch": "@@ -290,6 +290,13 @@ namespace ranges\n \t  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;\n \t};\n \n+    template<typename _Winc>\n+      struct __iota_view_iter_cat\n+      { };\n+\n+    template<incrementable _Winc>\n+      struct __iota_view_iter_cat<_Winc>\n+      { using iterator_category = input_iterator_tag; };\n   } // namespace __detail\n \n   template<weakly_incrementable _Winc,\n@@ -301,11 +308,11 @@ namespace ranges\n     private:\n       struct _Sentinel;\n \n-      struct _Iterator\n+      struct _Iterator : __detail::__iota_view_iter_cat<_Winc>\n       {\n       private:\n \tstatic auto\n-\t_S_iter_cat()\n+\t_S_iter_concept()\n \t{\n \t  using namespace __detail;\n \t  if constexpr (__advanceable<_Winc>)\n@@ -319,7 +326,8 @@ namespace ranges\n \t}\n \n       public:\n-\tusing iterator_category = decltype(_S_iter_cat());\n+\tusing iterator_concept = decltype(_S_iter_concept());\n+\t// iterator_category defined in __iota_view_iter_cat\n \tusing value_type = _Winc;\n \tusing difference_type = __detail::__iota_diff_t<_Winc>;\n \n@@ -1100,7 +1108,32 @@ namespace views::__adaptor\n \t  _M_offset = __it - ranges::begin(__r);\n \t}\n       };\n+  } // namespace __detail\n+\n+  namespace __detail\n+  {\n+    template<typename _Base>\n+      struct __filter_view_iter_cat\n+      { };\n \n+    template<forward_range _Base>\n+      struct __filter_view_iter_cat<_Base>\n+      {\n+      private:\n+\tstatic auto\n+\t_S_iter_cat()\n+\t{\n+\t  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return _Cat{};\n+\t}\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+      };\n   } // namespace __detail\n \n   template<input_range _Vp,\n@@ -1111,7 +1144,7 @@ namespace views::__adaptor\n     private:\n       struct _Sentinel;\n \n-      struct _Iterator\n+      struct _Iterator : __detail::__filter_view_iter_cat<_Vp>\n       {\n       private:\n \tstatic constexpr auto\n@@ -1125,18 +1158,6 @@ namespace views::__adaptor\n \t    return input_iterator_tag{};\n \t}\n \n-\tstatic constexpr auto\n-\t_S_iter_cat()\n-\t{\n-\t  using _Cat = typename iterator_traits<_Vp_iter>::iterator_category;\n-\t  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n-\t    return bidirectional_iterator_tag{};\n-\t  else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n-\t    return forward_iterator_tag{};\n-\t  else\n-\t    return _Cat{};\n-\t}\n-\n \tfriend filter_view;\n \n \tusing _Vp_iter = iterator_t<_Vp>;\n@@ -1146,7 +1167,7 @@ namespace views::__adaptor\n \n       public:\n \tusing iterator_concept = decltype(_S_iter_concept());\n-\tusing iterator_category = decltype(_S_iter_cat());\n+\t// iterator_category defined in __filter_view_iter_cat\n \tusing value_type = range_value_t<_Vp>;\n \tusing difference_type = range_difference_t<_Vp>;\n \n@@ -1344,36 +1365,26 @@ namespace views::__adaptor\n     {\n     private:\n       template<bool _Const>\n-\tstruct _Sentinel;\n+\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n \n       template<bool _Const>\n-\tstruct _Iterator\n+\tstruct __iter_cat\n+\t{ };\n+\n+      template<bool _Const>\n+\trequires forward_range<_Base<_Const>>\n+\tstruct __iter_cat<_Const>\n \t{\n \tprivate:\n-\t  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n-\n-\t  static constexpr auto\n-\t  _S_iter_concept()\n-\t  {\n-\t    if constexpr (random_access_range<_Vp>)\n-\t      return random_access_iterator_tag{};\n-\t    else if constexpr (bidirectional_range<_Vp>)\n-\t      return bidirectional_iterator_tag{};\n-\t    else if constexpr (forward_range<_Vp>)\n-\t      return forward_iterator_tag{};\n-\t    else\n-\t      return input_iterator_tag{};\n-\t  }\n-\n-\t  static constexpr auto\n+\t  static auto\n \t  _S_iter_cat()\n \t  {\n+\t    using _Base = transform_view::_Base<_Const>;\n \t    using _Res = invoke_result_t<_Fp&, range_reference_t<_Base>>;\n \t    if constexpr (is_lvalue_reference_v<_Res>)\n \t      {\n \t\tusing _Cat\n-\t\t  = typename iterator_traits<_Base_iter>::iterator_category;\n+\t\t  = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n \t\tif constexpr (derived_from<_Cat, contiguous_iterator_tag>)\n \t\t  return random_access_iterator_tag{};\n \t\telse\n@@ -1382,6 +1393,32 @@ namespace views::__adaptor\n \t    else\n \t      return input_iterator_tag{};\n \t  }\n+\tpublic:\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t};\n+\n+      template<bool _Const>\n+\tstruct _Sentinel;\n+\n+      template<bool _Const>\n+\tstruct _Iterator : __iter_cat<_Const>\n+\t{\n+\tprivate:\n+\t  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;\n+\t  using _Base = transform_view::_Base<_Const>;\n+\n+\t  static auto\n+\t  _S_iter_concept()\n+\t  {\n+\t    if constexpr (random_access_range<_Vp>)\n+\t      return random_access_iterator_tag{};\n+\t    else if constexpr (bidirectional_range<_Vp>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (forward_range<_Vp>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return input_iterator_tag{};\n+\t  }\n \n \t  using _Base_iter = iterator_t<_Base>;\n \n@@ -1390,7 +1427,7 @@ namespace views::__adaptor\n \n \tpublic:\n \t  using iterator_concept = decltype(_S_iter_concept());\n-\t  using iterator_category = decltype(_S_iter_cat());\n+\t  // iterator_category defined in __transform_view_iter_cat\n \t  using value_type\n \t    = remove_cvref_t<invoke_result_t<_Fp&, range_reference_t<_Base>>>;\n \t  using difference_type = range_difference_t<_Base>;\n@@ -1556,7 +1593,7 @@ namespace views::__adaptor\n \t{\n \tprivate:\n \t  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = transform_view::_Base<_Const>;\n \n \t  template<bool _Const2>\n \t    constexpr auto\n@@ -2210,18 +2247,62 @@ namespace views::__adaptor\n     private:\n       using _InnerRange = range_reference_t<_Vp>;\n \n+      template<bool _Const>\n+\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n+      template<bool _Const>\n+\tusing _Outer_iter = iterator_t<_Base<_Const>>;\n+\n+      template<bool _Const>\n+\tusing _Inner_iter = iterator_t<range_reference_t<_Base<_Const>>>;\n+\n+      template<bool _Const>\n+\tstatic constexpr bool _S_ref_is_glvalue\n+\t  = is_reference_v<range_reference_t<_Base<_Const>>>;\n+\n+      template<bool _Const>\n+\tstruct __iter_cat\n+\t{ };\n+\n+      template<bool _Const>\n+\trequires _S_ref_is_glvalue<_Const>\n+\t  && forward_range<_Base<_Const>>\n+\t  && forward_range<range_reference_t<_Base<_Const>>>\n+\tstruct __iter_cat<_Const>\n+\t{\n+\tprivate:\n+\t  static constexpr auto\n+\t  _S_iter_cat()\n+\t  {\n+\t    using _Outer_iter = join_view::_Outer_iter<_Const>;\n+\t    using _Inner_iter = join_view::_Inner_iter<_Const>;\n+\t    using _OuterCat = typename iterator_traits<_Outer_iter>::iterator_category;\n+\t    using _InnerCat = typename iterator_traits<_Inner_iter>::iterator_category;\n+\t    if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag>\n+\t\t\t  && derived_from<_InnerCat, bidirectional_iterator_tag>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (derived_from<_OuterCat, forward_iterator_tag>\n+\t\t\t       && derived_from<_InnerCat, forward_iterator_tag>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return input_iterator_tag{};\n+\t  }\n+\tpublic:\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t};\n+\n       template<bool _Const>\n \tstruct _Sentinel;\n \n       template<bool _Const>\n-\tstruct _Iterator\n+\tstruct _Iterator : __iter_cat<_Const>\n \t{\n \tprivate:\n \t  using _Parent = __detail::__maybe_const_t<_Const, join_view>;\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = join_view::_Base<_Const>;\n \n \t  static constexpr bool _S_ref_is_glvalue\n-\t    = is_reference_v<range_reference_t<_Base>>;\n+\t    = join_view::_S_ref_is_glvalue<_Const>;\n \n \t  constexpr void\n \t  _M_satisfy()\n@@ -2261,38 +2342,16 @@ namespace views::__adaptor\n \t      return input_iterator_tag{};\n \t  }\n \n-\t  static constexpr auto\n-\t  _S_iter_cat()\n-\t  {\n-\t    using _OuterCat\n-\t      = typename iterator_traits<_Outer_iter>::iterator_category;\n-\t    using _InnerCat\n-\t      = typename iterator_traits<_Inner_iter>::iterator_category;\n-\t    if constexpr (_S_ref_is_glvalue\n-\t\t\t  && derived_from<_OuterCat, bidirectional_iterator_tag>\n-\t\t\t  && derived_from<_InnerCat, bidirectional_iterator_tag>)\n-\t      return bidirectional_iterator_tag{};\n-\t    else if constexpr (_S_ref_is_glvalue\n-\t\t\t       && derived_from<_OuterCat, forward_iterator_tag>\n-\t\t\t       && derived_from<_InnerCat, forward_iterator_tag>)\n-\t      return forward_iterator_tag{};\n-\t    else if constexpr (derived_from<_OuterCat, input_iterator_tag>\n-\t\t\t       && derived_from<_InnerCat, input_iterator_tag>)\n-\t      return input_iterator_tag{};\n-\t    else\n-\t      return output_iterator_tag{};\n-\t  }\n-\n-\t  using _Outer_iter = iterator_t<_Base>;\n-\t  using _Inner_iter = iterator_t<range_reference_t<_Base>>;\n+\t  using _Outer_iter = join_view::_Outer_iter<_Const>;\n+\t  using _Inner_iter = join_view::_Inner_iter<_Const>;\n \n \t  _Outer_iter _M_outer = _Outer_iter();\n \t  _Inner_iter _M_inner = _Inner_iter();\n \t  _Parent* _M_parent = nullptr;\n \n \tpublic:\n \t  using iterator_concept = decltype(_S_iter_concept());\n-\t  using iterator_category = decltype(_S_iter_cat());\n+\t  // iterator_category defined in __join_view_iter_cat\n \t  using value_type = range_value_t<range_reference_t<_Base>>;\n \t  using difference_type\n \t    = common_type_t<range_difference_t<_Base>,\n@@ -2412,7 +2471,7 @@ namespace views::__adaptor\n \t{\n \tprivate:\n \t  using _Parent = __detail::__maybe_const_t<_Const, join_view>;\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = join_view::_Base<_Const>;\n \n \t  template<bool _Const2>\n \t    constexpr bool\n@@ -2550,6 +2609,35 @@ namespace views::__adaptor\n \t&& requires\n \t   { typename __require_constant<remove_reference_t<_Range>::size()>; }\n \t&& (remove_reference_t<_Range>::size() <= 1);\n+\n+    template<typename _Base>\n+      struct __split_view_outer_iter_cat\n+      { };\n+\n+    template<forward_range _Base>\n+      struct __split_view_outer_iter_cat<_Base>\n+      { using iterator_category = input_iterator_tag; };\n+\n+    template<typename _Base>\n+      struct __split_view_inner_iter_cat\n+      { };\n+\n+    template<forward_range _Base>\n+      struct __split_view_inner_iter_cat<_Base>\n+      {\n+      private:\n+\tstatic constexpr auto\n+\t_S_iter_cat()\n+\t{\n+\t  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t  if constexpr (derived_from<_Cat, forward_iterator_tag>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return _Cat{};\n+\t}\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+      };\n   }\n \n   template<input_range _Vp, forward_range _Pattern>\n@@ -2560,15 +2648,19 @@ namespace views::__adaptor\n     class split_view : public view_interface<split_view<_Vp, _Pattern>>\n     {\n     private:\n+      template<bool _Const>\n+\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n       template<bool _Const>\n \tstruct _InnerIter;\n \n       template<bool _Const>\n \tstruct _OuterIter\n+\t  : __detail::__split_view_outer_iter_cat<_Base<_Const>>\n \t{\n \tprivate:\n \t  using _Parent = __detail::__maybe_const_t<_Const, split_view>;\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = split_view::_Base<_Const>;\n \n \t  constexpr bool\n \t  __at_end() const\n@@ -2607,7 +2699,7 @@ namespace views::__adaptor\n \t  using iterator_concept = conditional_t<forward_range<_Base>,\n \t\t\t\t\t\t forward_iterator_tag,\n \t\t\t\t\t\t input_iterator_tag>;\n-\t  using iterator_category = input_iterator_tag;\n+\t  // iterator_category defined in __split_view_outer_iter_cat\n \t  using difference_type = range_difference_t<_Base>;\n \n \t  struct value_type : view_interface<value_type>\n@@ -2723,9 +2815,10 @@ namespace views::__adaptor\n \n       template<bool _Const>\n \tstruct _InnerIter\n+\t  : __detail::__split_view_inner_iter_cat<_Base<_Const>>\n \t{\n \tprivate:\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = split_view::_Base<_Const>;\n \n \t  constexpr bool\n \t  __at_end() const\n@@ -2759,17 +2852,6 @@ namespace views::__adaptor\n \t      }\n \t  }\n \n-\t  static constexpr auto\n-\t  _S_iter_cat()\n-\t  {\n-\t    using _Cat\n-              = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n-\t    if constexpr (derived_from<_Cat, forward_iterator_tag>)\n-\t      return forward_iterator_tag{};\n-\t    else\n-\t      return _Cat{};\n-\t  }\n-\n \t  constexpr auto&\n \t  _M_i_current() noexcept\n \t  { return _M_i.__current(); }\n@@ -2784,7 +2866,7 @@ namespace views::__adaptor\n \tpublic:\n \t  using iterator_concept\n \t    = typename _OuterIter<_Const>::iterator_concept;\n-\t  using iterator_category = decltype(_S_iter_cat());\n+\t  // iterator_category defined in __split_view_inner_iter_cat\n \t  using value_type = range_value_t<_Base>;\n \t  using difference_type = range_difference_t<_Base>;\n \n@@ -3292,14 +3374,42 @@ namespace views::__adaptor\n       { return ranges::size(_M_base); }\n \n     private:\n+      template<bool _Const>\n+\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n+      template<bool _Const>\n+\tstruct __iter_cat\n+\t{ };\n+\n+      template<bool _Const>\n+\trequires forward_range<_Base<_Const>>\n+\tstruct __iter_cat<_Const>\n+\t{\n+\tprivate:\n+\t  static auto _S_iter_cat()\n+\t  {\n+\t    using _Base = elements_view::_Base<_Const>;\n+\t    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t    using _Res = decltype((std::get<_Nm>(*std::declval<iterator_t<_Base>>())));\n+\t    if constexpr (!is_lvalue_reference_v<_Res>)\n+\t      return input_iterator_tag{};\n+\t    else if constexpr (derived_from<_Cat, random_access_iterator_tag>)\n+\t      return random_access_iterator_tag{};\n+\t    else\n+\t      return _Cat{};\n+\t  }\n+\tpublic:\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t};\n+\n       template<bool _Const>\n \tstruct _Sentinel;\n \n       template<bool _Const>\n-\tstruct _Iterator\n+\tstruct _Iterator : __iter_cat<_Const>\n \t{\n \tprivate:\n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = elements_view::_Base<_Const>;\n \n \t  iterator_t<_Base> _M_current = iterator_t<_Base>();\n \n@@ -3315,11 +3425,24 @@ namespace views::__adaptor\n \t      }\n \t  }\n \n+\t  static auto\n+\t  _S_iter_concept()\n+\t  {\n+\t    if constexpr (random_access_range<_Vp>)\n+\t      return random_access_iterator_tag{};\n+\t    else if constexpr (bidirectional_range<_Vp>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (forward_range<_Vp>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return input_iterator_tag{};\n+\t  }\n+\n \t  friend _Iterator<!_Const>;\n \n \tpublic:\n-\t  using iterator_category\n-\t    = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t  using iterator_concept = decltype(_S_iter_concept());\n+\t  // iterator_category defined in elements_view::__iter_cat\n \t  using value_type\n \t    = remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;\n \t  using difference_type = range_difference_t<_Base>;\n@@ -3471,7 +3594,7 @@ namespace views::__adaptor\n \t  _M_equal(const _Iterator<_Const>& __x) const\n \t  { return __x._M_current == _M_end; }\n \n-\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\t  using _Base = elements_view::_Base<_Const>;\n \t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n \n \tpublic:"}, {"sha": "3103094b36cfd25da5e2bd63e446976452b8ebbb", "filename": "libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc?ref=902b40c797a86f76791c32d537ba06dff5f1ba27", "patch": "@@ -73,6 +73,7 @@ namespace std\n     struct incrementable_traits<counted_iterator<I>>;\n \n   template<input_iterator I>\n+    requires same_as<__detail::__iter_traits<I>, iterator_traits<I>>\n     struct iterator_traits<counted_iterator<I>>;\n \n   struct unreachable_sentinel_t;"}, {"sha": "1b422e44f164e2a0711e581c6a8b663cebb34db7", "filename": "libstdc++-v3/testsuite/std/ranges/p2259.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2259.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/902b40c797a86f76791c32d537ba06dff5f1ba27/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2259.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fp2259.cc?ref=902b40c797a86f76791c32d537ba06dff5f1ba27", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Verify P2259 changes.\n+\n+#include <ranges>\n+#include <tuple>\n+#include <vector>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+using std::__detail::__iter_without_category;\n+\n+template<typename _Range>\n+concept only_cxx20_input_range = ranges::input_range<_Range>\n+  && !ranges::forward_range<_Range>\n+  && __iter_without_category<ranges::iterator_t<_Range>>;\n+\n+void\n+test01()\n+{\n+  extern std::vector<int> vec;\n+  only_cxx20_input_range auto v0\n+    = vec\n+    | views::transform([](int c) { return views::single(c); })\n+    | views::join;\n+\n+  // Verify the changes to filter_view.\n+  only_cxx20_input_range auto v1 = v0 | views::filter([](int c) { return c > 0; });\n+\n+  // Verify the changes to transform_view.\n+  only_cxx20_input_range auto v2 = v0 | views::transform([](int& c) -> auto& { return c; });\n+\n+  // Verify the changes to split_view.\n+  only_cxx20_input_range auto v3 = v0 | views::split(12);\n+  static_assert(only_cxx20_input_range<decltype(*v3.begin())>);\n+\n+  // Verify the changes to join_view.\n+  only_cxx20_input_range auto v4 = v0 | views::split(12) | views::join;\n+\n+  // Verify the changes to elements_view.\n+  only_cxx20_input_range auto v5\n+    = v0\n+    | views::transform([](int c) { return std::make_tuple(c, c); })\n+    | views::elements<0>;\n+\n+  // Verify the changes to common_iterator.\n+  only_cxx20_input_range auto v6 = v0 | views::common;\n+  *(v6.begin()++);\n+\n+  // Verify the changes to iota_view.\n+  only_cxx20_input_range auto v8 = ranges::iota_view{v0.begin()};\n+\n+  // Verify the changes to move_iterator.\n+  __iter_without_category auto i9 = std::make_move_iterator(v0.begin());\n+\n+  // Verify the changes to counted_iterator.\n+  extern std::counted_iterator<int*> i10;\n+  static_assert(std::contiguous_iterator<decltype(i10)>);\n+  static_assert(std::same_as<std::iterator_traits<decltype(i10)>::iterator_category,\n+\t\t\t     std::random_access_iterator_tag>);\n+  i10.operator->();\n+  __iter_without_category auto i11 = std::counted_iterator{v0.begin(), 5};\n+}\n+\n+void\n+test02()\n+{\n+  // Verify LWG 3291 example.\n+  auto v = views::iota(0);\n+  auto i = std::counted_iterator{v.begin(), 5};\n+  static_assert(std::random_access_iterator<decltype(i)>);\n+}"}]}