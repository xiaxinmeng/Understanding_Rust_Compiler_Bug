{"sha": "b47595f765ce51aaa9154e65cd5df6369184a79f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ3NTk1Zjc2NWNlNTFhYWE5MTU0ZTY1Y2Q1ZGY2MzY5MTg0YTc5Zg==", "commit": {"author": {"name": "Mircea Namolaru", "email": "mircea.namolaru@inria.fr", "date": "2014-08-11T15:05:48Z"}, "committer": {"name": "Mircea Namolaru", "email": "mircea@gcc.gnu.org", "date": "2014-08-11T15:05:48Z"}, "message": "Replacement of isl_int by isl_val\n\nFrom-SVN: r213816", "tree": {"sha": "ec40baa6e93fa6be67bdf487f2098cdc926b38b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec40baa6e93fa6be67bdf487f2098cdc926b38b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b47595f765ce51aaa9154e65cd5df6369184a79f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47595f765ce51aaa9154e65cd5df6369184a79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47595f765ce51aaa9154e65cd5df6369184a79f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47595f765ce51aaa9154e65cd5df6369184a79f/comments", "author": null, "committer": null, "parents": [{"sha": "7cadcdc162d79633ff9cc15f46094eb9ad3756ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cadcdc162d79633ff9cc15f46094eb9ad3756ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cadcdc162d79633ff9cc15f46094eb9ad3756ab"}], "stats": {"total": 216, "additions": 123, "deletions": 93}, "files": [{"sha": "af940e00fc0c563e1eab15332dc236f1abcd01fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -1,3 +1,24 @@\n+2014-08-11  Mircea Namolaru  <mircea.namolaru@inria.fr>\n+\n+\tReplacement of isl_int by isl_val\n+\t* graphite-clast-to-gimple.c: include isl/val.h, isl/val_gmp.h\n+\t(compute_bounds_for_param): use isl_val instead of isl_int\n+\t(compute_bounds_for_loop): likewise\n+\t* graphite-interchange.c: include isl/val.h, isl/val_gmp.h\n+        (build_linearized_memory_access): use isl_val instead of isl_int\n+        (pdr_stride_in_loop): likewise\n+\t* graphite-optimize-isl.c:\n+\t(getPrevectorMap): use isl_val instead of isl_int\n+\t* graphite-poly.c:\n+\t(pbb_number_of_iterations_at_time): use isl_val instead of isl_int\n+\tgraphite-sese-to-poly.c: include isl/val.h, isl/val_gmp.h\n+\t(extern the_isl_ctx): declare\n+\t(build_pbb_scattering_polyhedrons): use isl_val instead of isl_int\n+\t(extract_affine_gmp): likewise\n+\t(wrap): likewise\n+\t(build_loop_iteration_domains): likewise\n+\t(add_param_constraints): likewise\n+\n 2014-08-11  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/62075"}, {"sha": "0b0bf520160637fac772ea4f0baac8aedb93e9d3", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -28,6 +28,14 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/constraint.h>\n #include <isl/ilp.h>\n #include <isl/aff.h>\n+#include <isl/val.h>\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif\n+#include <isl/val_gmp.h>\n+#if defined(__cplusplus)\n+}\n+#endif\n #include <cloog/cloog.h>\n #include <cloog/isl/domain.h>\n #endif\n@@ -871,18 +879,18 @@ graphite_create_new_guard (edge entry_edge, struct clast_guard *stmt,\n static void\n compute_bounds_for_param (scop_p scop, int param, mpz_t low, mpz_t up)\n {\n-  isl_int v;\n+  isl_val *v;\n   isl_aff *aff = isl_aff_zero_on_domain\n     (isl_local_space_from_space (isl_set_get_space (scop->context)));\n \n   aff = isl_aff_add_coefficient_si (aff, isl_dim_param, param, 1);\n \n-  isl_int_init (v);\n-  isl_set_min (scop->context, aff, &v);\n-  isl_int_get_gmp (v, low);\n-  isl_set_max (scop->context, aff, &v);\n-  isl_int_get_gmp (v, up);\n-  isl_int_clear (v);\n+  v = isl_set_min_val (scop->context, aff);\n+  isl_val_get_num_gmp (v, low);\n+  isl_val_free (v);\n+  v = isl_set_max_val (scop->context, aff);\n+  isl_val_get_num_gmp (v, up);\n+  isl_val_free (v);\n   isl_aff_free (aff);\n }\n \n@@ -901,8 +909,7 @@ compute_bounds_for_loop (struct clast_for *loop, mpz_t low, mpz_t up)\n   isl_set *domain;\n   isl_aff *dimension;\n   isl_local_space *local_space;\n-  isl_int isl_value;\n-  enum isl_lp_result lp_result;\n+  isl_val *isl_value;\n \n   domain = isl_set_copy (isl_set_from_cloog_domain (loop->domain));\n   local_space = isl_local_space_from_space (isl_set_get_space (domain));\n@@ -911,17 +918,12 @@ compute_bounds_for_loop (struct clast_for *loop, mpz_t low, mpz_t up)\n \t\t\t\t\t  isl_set_dim (domain, isl_dim_set) - 1,\n \t\t\t\t\t  1);\n \n-  isl_int_init (isl_value);\n-\n-  lp_result = isl_set_min (domain, dimension, &isl_value);\n-  assert (lp_result == isl_lp_ok);\n-  isl_int_get_gmp (isl_value, low);\n-\n-  lp_result = isl_set_max (domain, dimension, &isl_value);\n-  assert (lp_result == isl_lp_ok);\n-  isl_int_get_gmp (isl_value, up);\n-\n-  isl_int_clear (isl_value);\n+  isl_value = isl_set_min_val (domain, dimension);\n+  isl_val_get_num_gmp (isl_value, low);\n+  isl_val_free (isl_value);\n+  isl_value = isl_set_max_val (domain, dimension);\n+  isl_val_get_num_gmp (isl_value, up);\n+  isl_val_free (isl_value);\n   isl_set_free (domain);\n   isl_aff_free (dimension);\n }"}, {"sha": "45db539f420a4d7a3c57d9317352f296cdbdfe25", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -29,6 +29,14 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/map.h>\n #include <isl/union_map.h>\n #include <isl/ilp.h>\n+#include <isl/val.h>\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif\n+#include <isl/val_gmp.h>\n+#if defined(__cplusplus)\n+}\n+#endif\n #include <cloog/cloog.h>\n #include <cloog/isl/domain.h>\n #endif\n@@ -79,13 +87,13 @@ build_linearized_memory_access (isl_map *map, poly_dr_p pdr)\n   isl_local_space *ls = isl_local_space_from_space (isl_map_get_space (map));\n   unsigned offset, nsubs;\n   int i;\n-  isl_int size, subsize;\n+  isl_ctx *ctx;\n+\n+  isl_val *size, *subsize, *size1;\n \n   res = isl_equality_alloc (ls);\n-  isl_int_init (size);\n-  isl_int_set_ui (size, 1);\n-  isl_int_init (subsize);\n-  isl_int_set_ui (subsize, 1);\n+  ctx = isl_local_space_get_ctx (ls);\n+  size = isl_val_int_from_ui (ctx, 1);\n \n   nsubs = isl_set_dim (pdr->extent, isl_dim_set);\n   /* -1 for the already included L dimension.  */\n@@ -98,18 +106,17 @@ build_linearized_memory_access (isl_map *map, poly_dr_p pdr)\n       isl_space *dc;\n       isl_aff *aff;\n \n-      res = isl_constraint_set_coefficient (res, isl_dim_out, offset + i, size);\n-\n+      size1 = isl_val_copy (size);\n+      res = isl_constraint_set_coefficient_val (res, isl_dim_out, offset + i, size);\n       dc = isl_set_get_space (pdr->extent);\n       aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n       aff = isl_aff_set_coefficient_si (aff, isl_dim_in, i, 1);\n-      isl_set_max (pdr->extent, aff, &subsize);\n+      subsize = isl_set_max_val (pdr->extent, aff);\n       isl_aff_free (aff);\n-      isl_int_mul (size, size, subsize);\n+      size = isl_val_mul (size1, subsize);\n     }\n \n-  isl_int_clear (subsize);\n-  isl_int_clear (size);\n+  isl_val_free (size);\n \n   return res;\n }\n@@ -126,7 +133,7 @@ pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n   isl_aff *aff;\n   isl_space *dc;\n   isl_constraint *lma, *c;\n-  isl_int islstride;\n+  isl_val *islstride;\n   graphite_dim_t time_depth;\n   unsigned offset, nt;\n   unsigned i;\n@@ -239,10 +246,9 @@ pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n   aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n   aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset - 1, -1);\n   aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset + offset - 1, 1);\n-  isl_int_init (islstride);\n-  isl_set_max (set, aff, &islstride);\n-  isl_int_get_gmp (islstride, stride);\n-  isl_int_clear (islstride);\n+  islstride = isl_set_max_val (set, aff);\n+  isl_val_get_num_gmp (islstride, stride);\n+  isl_val_free (islstride);\n   isl_aff_free (aff);\n   isl_set_free (set);\n "}, {"sha": "31f30185cecb1c19b5dd04d214f3f456ada6e8ea", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -244,7 +244,7 @@ getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n   isl_aff *Aff;\n   int PointDimension; /* ip */\n   int TileDimension;  /* it */\n-  isl_int VectorWidthMP;\n+  isl_val *VectorWidthMP;\n   int i;\n \n   /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n@@ -275,10 +275,9 @@ getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n   Aff = isl_aff_zero_on_domain (LocalSpaceRange);\n   Aff = isl_aff_set_constant_si (Aff, VectorWidth);\n   Aff = isl_aff_set_coefficient_si (Aff, isl_dim_in, TileDimension, 1);\n-  isl_int_init (VectorWidthMP);\n-  isl_int_set_si (VectorWidthMP, VectorWidth);\n-  Aff = isl_aff_mod (Aff, VectorWidthMP);\n-  isl_int_clear (VectorWidthMP);\n+\n+  VectorWidthMP = isl_val_int_from_si (ctx, VectorWidth);\n+  Aff = isl_aff_mod_val (Aff, VectorWidthMP);\n   Modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (Aff));\n   TilingMap = isl_map_intersect_range (TilingMap, Modulo);\n "}, {"sha": "28ab4df9f16d5791120121cb62aa4e299ef017e4", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -28,6 +28,14 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/constraint.h>\n #include <isl/ilp.h>\n #include <isl/aff.h>\n+#include <isl/val.h>\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif\n+#include <isl/val_gmp.h>\n+#if defined(__cplusplus)\n+}\n+#endif\n #include <cloog/cloog.h>\n #include <cloog/isl/domain.h>\n #endif\n@@ -1029,10 +1037,7 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,\n   isl_set *transdomain;\n   isl_space *dc;\n   isl_aff *aff;\n-  isl_int isllb, islub;\n-\n-  isl_int_init (isllb);\n-  isl_int_init (islub);\n+  isl_val *isllb, *islub;\n \n   /* Map the iteration domain through the current scatter, and work\n      on the resulting set.  */\n@@ -1046,15 +1051,14 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,\n \n   /* And find the min/max for that function.  */\n   /* XXX isl check results?  */\n-  isl_set_min (transdomain, aff, &isllb);\n-  isl_set_max (transdomain, aff, &islub);\n+  isllb = isl_set_min_val (transdomain, aff);\n+  islub = isl_set_max_val (transdomain, aff);\n \n-  isl_int_sub (islub, islub, isllb);\n-  isl_int_add_ui (islub, islub, 1);\n-  isl_int_get_gmp (islub, res);\n+  islub = isl_val_sub (islub, isllb);\n+  islub = isl_val_add_ui (islub, 1);\n+  isl_val_get_num_gmp (islub, res);\n \n-  isl_int_clear (isllb);\n-  isl_int_clear (islub);\n+  isl_val_free (islub);\n   isl_aff_free (aff);\n   isl_set_free (transdomain);\n }"}, {"sha": "c36420a2b78f5dddddcc2bc72efa498f66144a8a", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47595f765ce51aaa9154e65cd5df6369184a79f/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=b47595f765ce51aaa9154e65cd5df6369184a79f", "patch": "@@ -26,6 +26,18 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/union_map.h>\n #include <isl/constraint.h>\n #include <isl/aff.h>\n+#include <isl/val.h>\n+/* For C++ linkage of C functions.\n+   Missing from  isl/val_gmp.h in isl 0.12 versions.\n+   Appearing in isl/val_gmp.h in isl 0.13.\n+   To be removed when passing to isl 0.13. */\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif\n+#include <isl/val_gmp.h>\n+#if defined(__cplusplus)\n+}\n+#endif\n #include <cloog/cloog.h>\n #include <cloog/cloog.h>\n #include <cloog/isl/domain.h>\n@@ -480,13 +492,11 @@ build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n   int i;\n   int nb_iterators = pbb_dim_iter_domain (pbb);\n   int used_scattering_dimensions = nb_iterators * 2 + 1;\n-  isl_int val;\n+  isl_val *val;\n   isl_space *dc, *dm;\n \n   gcc_assert (scattering_dimensions >= used_scattering_dimensions);\n \n-  isl_int_init (val);\n-\n   dc = isl_set_get_space (pbb->domain);\n   dm = isl_space_add_dims (isl_space_from_domain (dc),\n \t\t\t   isl_dim_out, scattering_dimensions);\n@@ -500,12 +510,10 @@ build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n \t  isl_constraint *c = isl_equality_alloc\n \t      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));\n \n-\t  if (0 != isl_aff_get_coefficient (static_sched, isl_dim_in,\n-\t\t\t\t\t    i / 2, &val))\n-\t    gcc_unreachable ();\n+\t  val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, i / 2);\n \n-\t  isl_int_neg (val, val);\n-\t  c = isl_constraint_set_constant (c, val);\n+\t  val = isl_val_neg (val);\n+\t  c = isl_constraint_set_constant_val (c, val);\n \t  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n \t  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n \t}\n@@ -519,8 +527,6 @@ build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n \t}\n     }\n \n-  isl_int_clear (val);\n-\n   pbb->transformed = isl_map_copy (pbb->schedule);\n }\n \n@@ -699,12 +705,12 @@ extract_affine_gmp (mpz_t g, __isl_take isl_space *space)\n   isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n   isl_aff *aff = isl_aff_zero_on_domain (ls);\n   isl_set *dom = isl_set_universe (space);\n-  isl_int v;\n+  isl_val *v;\n+  isl_ctx *ct;\n \n-  isl_int_init (v);\n-  isl_int_set_gmp (v, g);\n-  aff = isl_aff_add_constant (aff, v);\n-  isl_int_clear (v);\n+  ct = isl_aff_get_ctx (aff);\n+  v = isl_val_int_from_gmp (ct, g);\n+  aff = isl_aff_add_constant_val (aff, v);\n \n   return isl_pw_aff_alloc (dom, aff);\n }\n@@ -727,18 +733,16 @@ extract_affine_int (tree e, __isl_take isl_space *space)\n \n /* Compute pwaff mod 2^width.  */\n \n+extern isl_ctx *the_isl_ctx;\n+\n static isl_pw_aff *\n wrap (isl_pw_aff *pwaff, unsigned width)\n {\n-  isl_int mod;\n-\n-  isl_int_init (mod);\n-  isl_int_set_si (mod, 1);\n-  isl_int_mul_2exp (mod, mod, width);\n-\n-  pwaff = isl_pw_aff_mod (pwaff, mod);\n+  isl_val *mod;\n \n-  isl_int_clear (mod);\n+  mod = isl_val_int_from_ui(the_isl_ctx, width);\n+  mod = isl_val_2exp (mod);\n+  pwaff = isl_pw_aff_mod_val (pwaff, mod);\n \n   return pwaff;\n }\n@@ -994,11 +998,10 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n   isl_space *space;\n   isl_constraint *c;\n   int pos = isl_set_dim (outer, isl_dim_set);\n-  isl_int v;\n+  isl_val *v;\n   mpz_t g;\n \n   mpz_init (g);\n-  isl_int_init (v);\n \n   inner = isl_set_add_dims (inner, isl_dim_set, 1);\n   space = isl_set_get_space (inner);\n@@ -1016,8 +1019,8 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \t  (isl_local_space_from_space (isl_space_copy (space)));\n       c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n       tree_int_to_gmp (nb_iters, g);\n-      isl_int_set_gmp (v, g);\n-      c = isl_constraint_set_constant (c, v);\n+      v = isl_val_int_from_gmp (the_isl_ctx, g);\n+      c = isl_constraint_set_constant_val (c, v);\n       inner = isl_set_add_constraint (inner, c);\n     }\n \n@@ -1071,9 +1074,9 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \t  c = isl_inequality_alloc\n \t      (isl_local_space_from_space (isl_space_copy (space)));\n \t  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n-\t  isl_int_set_gmp (v, g);\n+\t  v = isl_val_int_from_gmp (the_isl_ctx, g);\n \t  mpz_clear (g);\n-\t  c = isl_constraint_set_constant (c, v);\n+\t  c = isl_constraint_set_constant_val (c, v);\n \t  inner = isl_set_add_constraint (inner, c);\n \t}\n       else\n@@ -1096,7 +1099,6 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \n   isl_set_free (outer);\n   isl_space_free (space);\n-  isl_int_clear (v);\n   mpz_clear (g);\n }\n \n@@ -1330,17 +1332,15 @@ add_param_constraints (scop_p scop, graphite_dim_t p)\n       isl_space *space = isl_set_get_space (scop->context);\n       isl_constraint *c;\n       mpz_t g;\n-      isl_int v;\n+      isl_val *v;\n \n       c = isl_inequality_alloc (isl_local_space_from_space (space));\n       mpz_init (g);\n-      isl_int_init (v);\n       tree_int_to_gmp (lb, g);\n-      isl_int_set_gmp (v, g);\n-      isl_int_neg (v, v);\n+      v = isl_val_int_from_gmp (the_isl_ctx, g);\n+      v = isl_val_neg (v);\n       mpz_clear (g);\n-      c = isl_constraint_set_constant (c, v);\n-      isl_int_clear (v);\n+      c = isl_constraint_set_constant_val (c, v);\n       c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, 1);\n \n       scop->context = isl_set_add_constraint (scop->context, c);\n@@ -1351,17 +1351,15 @@ add_param_constraints (scop_p scop, graphite_dim_t p)\n       isl_space *space = isl_set_get_space (scop->context);\n       isl_constraint *c;\n       mpz_t g;\n-      isl_int v;\n+      isl_val *v;\n \n       c = isl_inequality_alloc (isl_local_space_from_space (space));\n \n       mpz_init (g);\n-      isl_int_init (v);\n       tree_int_to_gmp (ub, g);\n-      isl_int_set_gmp (v, g);\n+      v = isl_val_int_from_gmp (the_isl_ctx, g);\n       mpz_clear (g);\n-      c = isl_constraint_set_constant (c, v);\n-      isl_int_clear (v);\n+      c = isl_constraint_set_constant_val (c, v);\n       c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, -1);\n \n       scop->context = isl_set_add_constraint (scop->context, c);"}]}