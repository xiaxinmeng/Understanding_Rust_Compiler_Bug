{"sha": "4b7f8314ba66ab03974e94bf80718b157cc1350f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI3ZjgzMTRiYTY2YWIwMzk3NGU5NGJmODA3MThiMTU3Y2MxMzUwZg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-21T15:33:37Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-21T15:33:37Z"}, "message": "re PR fortran/35846 (ICE on nested character constructors)\n\n2008-09-21  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35846\n\t* trans.h (gfc_conv_string_length): New argument `expr'.\n\t* trans-expr.c (flatten_array_ctors_without_strlen): New method.\n\t(gfc_conv_string_length): New argument `expr' that is used in a new\n\tspecial case handling if cl->length is NULL.\n\t(gfc_conv_subref_array_arg): Pass expr to gfc_conv_string_length.\n\t* trans-array.c (gfc_conv_expr_descriptor): Ditto.\n\t(gfc_trans_auto_array_allocation): Pass NULL as new expr.\n\t(gfc_trans_g77_array), (gfc_trans_dummy_array_bias): Ditto.\n\t(gfc_trans_deferred_array): Ditto.\n\t(gfc_trans_array_constructor): Save and restore old values of globals\n\tused for bounds checking.\n\t* trans-decl.c (gfc_trans_dummy_character): Ditto.\n\t(gfc_trans_auto_character_variable): Ditto.\n\n2008-09-21  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35846\n\t* gfortran.dg/nested_array_constructor_1.f90: New test.\n\t* gfortran.dg/nested_array_constructor_2.f90: New test.\n\t* gfortran.dg/nested_array_constructor_3.f90: New test.\n\t* gfortran.dg/nested_array_constructor_4.f90: New test.\n\t* gfortran.dg/nested_array_constructor_5.f90: New test.\n\t* gfortran.dg/nested_array_constructor_6.f90: New test.\n\nFrom-SVN: r140529", "tree": {"sha": "7e12ab2f71e4936cfd889e91f274ac7585d3640b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e12ab2f71e4936cfd889e91f274ac7585d3640b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b7f8314ba66ab03974e94bf80718b157cc1350f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7f8314ba66ab03974e94bf80718b157cc1350f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7f8314ba66ab03974e94bf80718b157cc1350f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7f8314ba66ab03974e94bf80718b157cc1350f/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74a9b8976475b250d6d9d68b2ea557cc0e778f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a9b8976475b250d6d9d68b2ea557cc0e778f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74a9b8976475b250d6d9d68b2ea557cc0e778f4e"}], "stats": {"total": 265, "additions": 250, "deletions": 15}, "files": [{"sha": "6b466ed93823e7e26c41bdd78cc21bb94362787b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -1,3 +1,20 @@\n+2008-09-21  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35846\n+\t* trans.h (gfc_conv_string_length): New argument `expr'.\n+\t* trans-expr.c (flatten_array_ctors_without_strlen): New method.\n+\t(gfc_conv_string_length): New argument `expr' that is used in a new\n+\tspecial case handling if cl->length is NULL.\n+\t(gfc_conv_subref_array_arg): Pass expr to gfc_conv_string_length.\n+\t* trans-array.c (gfc_conv_expr_descriptor): Ditto.\n+\t(gfc_trans_auto_array_allocation): Pass NULL as new expr.\n+\t(gfc_trans_g77_array), (gfc_trans_dummy_array_bias): Ditto.\n+\t(gfc_trans_deferred_array): Ditto.\n+\t(gfc_trans_array_constructor): Save and restore old values of globals\n+\tused for bounds checking.\n+\t* trans-decl.c (gfc_trans_dummy_character): Ditto.\n+\t(gfc_trans_auto_character_variable): Ditto.\n+\n 2008-09-21  Daniel Kraft  <d@domob.eu>\n \n \t* decl.c (match_procedure_in_type): Changed misleading error message"}, {"sha": "42b9967764f4901e764ec9f93a664ad904af5ce7", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -1694,6 +1694,13 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   tree type;\n   tree loopfrom;\n   bool dynamic;\n+  bool old_first_len, old_typespec_chararray_ctor;\n+  tree old_first_len_val;\n+\n+  /* Save the old values for nested checking.  */\n+  old_first_len = first_len;\n+  old_first_len_val = first_len_val;\n+  old_typespec_chararray_ctor = typespec_chararray_ctor;\n \n   /* Do bounds-checking here and in gfc_trans_array_ctor_element only if no\n      typespec was given for the array constructor.  */\n@@ -1792,7 +1799,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \t  if (size && compare_tree_int (size, nelem) == 0)\n \t    {\n \t      gfc_trans_constant_array_constructor (loop, ss, type);\n-\t      return;\n+\t      goto finish;\n \t    }\n \t}\n     }\n@@ -1849,6 +1856,12 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n       gcc_unreachable ();\n     }\n #endif\n+\n+finish:\n+  /* Restore old values of globals.  */\n+  first_len = old_first_len;\n+  first_len_val = old_first_len_val;\n+  typespec_chararray_ctor = old_typespec_chararray_ctor;\n }\n \n \n@@ -4080,7 +4093,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   if (sym->ts.type == BT_CHARACTER\n       && onstack && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.cl, &block);\n+      gfc_conv_string_length (sym->ts.cl, NULL, &block);\n \n       gfc_trans_vla_type_sizes (sym, &block);\n \n@@ -4104,7 +4117,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n-    gfc_conv_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n \n   size = gfc_trans_array_bounds (type, sym, &offset, &block);\n \n@@ -4170,7 +4183,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n \n   /* Evaluate the bounds of the array.  */\n   gfc_trans_array_bounds (type, sym, &offset, &block);\n@@ -4262,7 +4275,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n-    gfc_conv_string_length (sym->ts.cl, &block);\n+    gfc_conv_string_length (sym->ts.cl, NULL, &block);\n \n   checkparm = (sym->as->type == AS_EXPLICIT && flag_bounds_check);\n \n@@ -4848,7 +4861,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       break;\n     }\n \n-\n   gfc_init_loopinfo (&loop);\n \n   /* Associate the SS with the loop.  */\n@@ -4872,7 +4884,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->next = gfc_ss_terminator;\n \n       if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n-\tgfc_conv_string_length (expr->ts.cl, &se->pre);\n+\tgfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n \n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n \n@@ -5672,7 +5684,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))\n     {\n-      gfc_conv_string_length (sym->ts.cl, &fnblock);\n+      gfc_conv_string_length (sym->ts.cl, NULL, &fnblock);\n       gfc_trans_vla_type_sizes (sym, &fnblock);\n     }\n "}, {"sha": "20253e668ca252ab6a893a65767cf69ac8e2a065", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -2583,7 +2583,7 @@ gfc_trans_dummy_character (gfc_symbol *sym, gfc_charlen *cl, tree fnbody)\n   gfc_start_block (&body);\n \n   /* Evaluate the string length expression.  */\n-  gfc_conv_string_length (cl, &body);\n+  gfc_conv_string_length (cl, NULL, &body);\n \n   gfc_trans_vla_type_sizes (sym, &body);\n \n@@ -2607,7 +2607,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n   gfc_start_block (&body);\n \n   /* Evaluate the string length expression.  */\n-  gfc_conv_string_length (sym->ts.cl, &body);\n+  gfc_conv_string_length (sym->ts.cl, NULL, &body);\n \n   gfc_trans_vla_type_sizes (sym, &body);\n "}, {"sha": "e0f2f77cd599ddc807f813e2dc5ae9e85fabb48d", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -241,17 +241,102 @@ gfc_get_expr_charlen (gfc_expr *e)\n   return length;\n }\n \n-  \n+\n+/* For each character array constructor subexpression without a ts.cl->length,\n+   replace it by its first element (if there aren't any elements, the length\n+   should already be set to zero).  */\n+\n+static void\n+flatten_array_ctors_without_strlen (gfc_expr* e)\n+{\n+  gfc_actual_arglist* arg;\n+  gfc_constructor* c;\n+\n+  if (!e)\n+    return;\n+\n+  switch (e->expr_type)\n+    {\n+\n+    case EXPR_OP:\n+      flatten_array_ctors_without_strlen (e->value.op.op1); \n+      flatten_array_ctors_without_strlen (e->value.op.op2); \n+      break;\n+\n+    case EXPR_COMPCALL:\n+      /* TODO: Implement as with EXPR_FUNCTION when needed.  */\n+      gcc_unreachable ();\n+\n+    case EXPR_FUNCTION:\n+      for (arg = e->value.function.actual; arg; arg = arg->next)\n+\tflatten_array_ctors_without_strlen (arg->expr);\n+      break;\n+\n+    case EXPR_ARRAY:\n+\n+      /* We've found what we're looking for.  */\n+      if (e->ts.type == BT_CHARACTER && !e->ts.cl->length)\n+\t{\n+\t  gfc_expr* new_expr;\n+\t  gcc_assert (e->value.constructor);\n+\n+\t  new_expr = e->value.constructor->expr;\n+\t  e->value.constructor->expr = NULL;\n+\n+\t  flatten_array_ctors_without_strlen (new_expr);\n+\t  gfc_replace_expr (e, new_expr);\n+\t  break;\n+\t}\n+\n+      /* Otherwise, fall through to handle constructor elements.  */\n+    case EXPR_STRUCTURE:\n+      for (c = e->value.constructor; c; c = c->next)\n+\tflatten_array_ctors_without_strlen (c->expr);\n+      break;\n+\n+    default:\n+      break;\n+\n+    }\n+}\n+\n \n /* Generate code to initialize a string length variable. Returns the\n-   value.  */\n+   value.  For array constructors, cl->length might be NULL and in this case,\n+   the first element of the constructor is needed.  expr is the original\n+   expression so we can access it but can be NULL if this is not needed.  */\n \n void\n-gfc_conv_string_length (gfc_charlen * cl, stmtblock_t * pblock)\n+gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n {\n   gfc_se se;\n \n   gfc_init_se (&se, NULL);\n+\n+  /* If cl->length is NULL, use gfc_conv_expr to obtain the string length but\n+     \"flatten\" array constructors by taking their first element; all elements\n+     should be the same length or a cl->length should be present.  */\n+  if (!cl->length)\n+    {\n+      gfc_expr* expr_flat;\n+      gcc_assert (expr);\n+\n+      expr_flat = gfc_copy_expr (expr);\n+      flatten_array_ctors_without_strlen (expr_flat);\n+      gfc_resolve_expr (expr_flat);\n+\n+      gfc_conv_expr (&se, expr_flat);\n+      gfc_add_block_to_block (pblock, &se.pre);\n+      cl->backend_decl = convert (gfc_charlen_type_node, se.string_length);\n+\n+      gfc_free_expr (expr_flat);\n+      return;\n+    }\n+\n+  /* Convert cl->length.  */\n+\n+  gcc_assert (cl->length);\n+\n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n   se.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, se.expr,\n \t\t\t build_int_cst (gfc_charlen_type_node, 0));\n@@ -2092,7 +2177,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n \n   /* Build an ss for the temporary.  */\n   if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n-    gfc_conv_string_length (expr->ts.cl, &parmse->pre);\n+    gfc_conv_string_length (expr->ts.cl, expr, &parmse->pre);\n \n   base_type = gfc_typenode_for_spec (&expr->ts);\n   if (GFC_ARRAY_TYPE_P (base_type)"}, {"sha": "b3a0368160fb1b273b13fedb60686f2b8874d46b", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -340,7 +340,7 @@ tree gfc_conv_string_tmp (gfc_se *, tree, tree);\n /* Get the string length variable belonging to an expression.  */\n tree gfc_get_expr_charlen (gfc_expr *);\n /* Initialize a string length variable.  */\n-void gfc_conv_string_length (gfc_charlen *, stmtblock_t *);\n+void gfc_conv_string_length (gfc_charlen *, gfc_expr *, stmtblock_t *);\n /* Ensure type sizes can be gimplified.  */\n void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n "}, {"sha": "7ffa03a4d387ca00c28e548f2602ecf5e06c89c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -1,3 +1,13 @@\n+2008-09-21  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35846\n+\t* gfortran.dg/nested_array_constructor_1.f90: New test.\n+\t* gfortran.dg/nested_array_constructor_2.f90: New test.\n+\t* gfortran.dg/nested_array_constructor_3.f90: New test.\n+\t* gfortran.dg/nested_array_constructor_4.f90: New test.\n+\t* gfortran.dg/nested_array_constructor_5.f90: New test.\n+\t* gfortran.dg/nested_array_constructor_6.f90: New test.\n+\n 2008-09-21  Daniel Kraft  <d@domob.eu>\n \n \t* gfortran.dg/typebound_proc_4.f03: Changed expected error for not"}, {"sha": "54417a0dedda8b281d063b9e1d76cf047bdcf220", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_1.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! This test is run with result-checking and -fbounds-check as\n+! nested_array_constructor_2.f90\n+\n+! PR fortran/35846\n+! This used to ICE because the charlength of the trim-expression was\n+! NULL.\n+\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+implicit none\n+character(len=2) :: c(3)\n+\n+c = 'a'\n+c = (/ (/ trim(c(1)), 'a' /)//'c', 'cd' /)\n+\n+print *, c\n+\n+end"}, {"sha": "28c2b49e81629af81a39447d6e0e112d650afde8", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_2.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+\n+! PR fortran/35846\n+! This used to ICE because the charlength of the trim-expression was\n+! NULL.\n+\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+implicit none\n+character(len=2) :: c(3)\n+\n+c = 'a'\n+c = (/ (/ trim(c(1)), 'a' /)//'c', 'cd' /)\n+\n+print *, c\n+\n+if (c(1) /= 'ac' .or. c(2) /= 'ac' .or. c(3) /= 'cd') then\n+  call abort ()\n+end if\n+\n+end"}, {"sha": "dd10e5fafc9cb185999c6ebd734ee4e82cb9b8da", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_3.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_3.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+\n+! PR fortran/35846\n+! Alternate test that also produced an ICE because of a missing length.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+  CHARACTER(LEN=2) :: x\n+\n+  x = 'a'\n+  CALL sub ( (/ TRIM(x), 'a' /) // 'c')\n+END PROGRAM\n+\n+SUBROUTINE sub(str)\n+  IMPLICIT NONE\n+  CHARACTER(LEN=*) :: str(2)\n+  WRITE (*,*) str\n+\n+  IF (str(1) /= 'ac' .OR. str(2) /= 'ac') THEN\n+    CALL abort ()\n+  END IF\n+END SUBROUTINE sub"}, {"sha": "cb113e9c9aeb0cdf00cc610b74da408ac00c0940", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_4.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+\n+! PR fortran/35846\n+! Alternate test that also produced an ICE because of a missing length.\n+\n+PROGRAM test\n+  IMPLICIT NONE\n+  CHARACTER(LEN=2) :: x\n+  INTEGER :: length\n+\n+  x = 'a'\n+  length = LEN ( (/ TRIM(x), 'a' /) // 'c')\n+\n+  IF (length /= 2) THEN\n+    CALL abort ()\n+  END IF\n+END PROGRAM"}, {"sha": "7744f1ffe94d1eee12f41c1f8ffd7830625443f5", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_5.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_5.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+\n+! PR fortran/35846\n+! This used to ICE because the charlength of the trim-expression was\n+! NULL, but it is switched around to test for the right operand of // being\n+! not a constant, too.\n+\n+implicit none\n+character(len=2) :: c(2)\n+\n+c = 'a'\n+c = (/ (/ trim(c(1)), 'a' /) // (/ trim(c(1)), 'a' /) /)\n+\n+print *, c\n+\n+end"}, {"sha": "6eee6d0b32e18ba05eceaff22f323738e011e2ea", "filename": "gcc/testsuite/gfortran.dg/nested_array_constructor_6.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7f8314ba66ab03974e94bf80718b157cc1350f/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_array_constructor_6.f90?ref=4b7f8314ba66ab03974e94bf80718b157cc1350f", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+\n+! PR fortran/35846\n+! Nested three levels deep.\n+\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+implicit none\n+character(len=3) :: c(3)\n+c = 'a'\n+c = (/ (/ 'A'//(/ trim(c(1)), 'a' /)/)//'c', 'dcd' /)\n+print *, c(1)\n+print *, c(2)\n+print *, c(3)\n+end"}]}