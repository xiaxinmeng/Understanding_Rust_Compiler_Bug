{"sha": "239630dc0c90e049f3f63e97ab41b708bd1d48e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM5NjMwZGMwYzkwZTA0OWYzZjYzZTk3YWI0MWI3MDhiZDFkNDhlOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-12-17T00:08:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-12-17T00:08:02Z"}, "message": "re PR ipa/44563 (GCC uses a lot of RAM when compiling a large numbers of functions)\n\n\n\tPR middle-end/44563 \n\t* ipa-inline.c: Update doplevel comment. \n\t(cgraph_estimate_size_after_inlining): Remove times attribute. \n\t(cgraph_mark_inline_edge): Update. \n\t(cgraph_mark_inline): Remove. \n\t(cgraph_estimate_growth): Update. \n\t(cgraph_check_inline_limits): Remove one only argument. \n\t(cgraph_edge_badness): Update. \n\t(cgraph_decide_recursive_inlining): Update. \n\t(cgraph_decide_inlining_of_small_function): Fix handling of tree_can_inline_p \n\tand call_stmt_cannot_inline_p. \n\t(cgraph_flatten): Likewise. \n\t(cgraph_decide_inlining): Update. \n\t(cgraph_decide_inlining_incrementally): Fix handling of call_stmt_cannot_inline_p.\n\nFrom-SVN: r167964", "tree": {"sha": "b2b703135ed608745ebe2346d26ed5f4f7a77f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2b703135ed608745ebe2346d26ed5f4f7a77f2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/239630dc0c90e049f3f63e97ab41b708bd1d48e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/239630dc0c90e049f3f63e97ab41b708bd1d48e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/239630dc0c90e049f3f63e97ab41b708bd1d48e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/239630dc0c90e049f3f63e97ab41b708bd1d48e9/comments", "author": null, "committer": null, "parents": [{"sha": "391fbfb8ca6687adf9e03633c56e0f90541fd3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391fbfb8ca6687adf9e03633c56e0f90541fd3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391fbfb8ca6687adf9e03633c56e0f90541fd3f3"}], "stats": {"total": 266, "additions": 181, "deletions": 85}, "files": [{"sha": "0e3794355dd198498186dd159ad38c5453ef2b2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239630dc0c90e049f3f63e97ab41b708bd1d48e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239630dc0c90e049f3f63e97ab41b708bd1d48e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=239630dc0c90e049f3f63e97ab41b708bd1d48e9", "patch": "@@ -1,3 +1,20 @@\n+2010-12-16  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/44563 \n+\t* ipa-inline.c: Update doplevel comment. \n+\t(cgraph_estimate_size_after_inlining): Remove times attribute. \n+\t(cgraph_mark_inline_edge): Update. \n+\t(cgraph_mark_inline): Remove. \n+\t(cgraph_estimate_growth): Update. \n+\t(cgraph_check_inline_limits): Remove one only argument. \n+\t(cgraph_edge_badness): Update. \n+\t(cgraph_decide_recursive_inlining): Update. \n+\t(cgraph_decide_inlining_of_small_function): Fix handling of tree_can_inline_p \n+\tand call_stmt_cannot_inline_p. \n+\t(cgraph_flatten): Likewise. \n+\t(cgraph_decide_inlining): Update. \n+\t(cgraph_decide_inlining_incrementally): Fix handling of call_stmt_cannot_inline_p. \n+\n 2010-12-16  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/darwin.opt (dylinker, headerpad_max_install_names,\n@@ -126,6 +143,134 @@\n \t* config/spu/t-spu-elf (dp-bit.c, fp-bit.c): Don't undefine\n \tUS_SOFTWARE_GOFAST.\n \n+2010-12-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* config/darwin.opt (dylinker, headerpad_max_install_names,\n+\tkeep_private_externs, nofixprebinding, nomultidefs, noprebind,\n+\tnoseglinkedit, object, prebind, prebind_all_twolevel_modules,\n+\tpreload, private_bundle, pthread, seglinkedit, twolevel_namespace,\n+\ttwolevel_namespace_hints, whatsloaded, whyload, y, Mach, X): New\n+\tDriver options.\n+\t* config/darwin.h (LINK_SPEC): Remove '*' after\n+\theaderpad_max_install_names.\n+\n+2010-12-16  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/46924\n+\t* graphite-sese-to-poly.c (detect_commutative_reduction): Do not\n+\tdetect reductions outside the current SESE region.\n+\t* sese.h (stmt_in_sese_p): New.\n+\t(defined_in_sese_p): Call stmt_in_sese_p.\n+\n+2010-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/46966\n+\t* graphite-sese-to-poly.c (build_scop_drs): Call free_gimple_bb for\n+\tfor bbs that are removed from SCOP_BBS vector.\n+\n+2010-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Always punt if the call to\n+\tget_ref_base_and_extent returns -1 as the max size.\n+\n+2010-12-16  Konrad Eisele  <konrad@gaisler.com>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tSupport for LEON processor\n+\t* config.gcc (sparc-*-elf*): Deal with sparc-leon specifically.\n+\t(sparc-*-linux*): Likewise.\n+\t(sparc-*-rtems*): Remove Solaris left-overs.\n+\t(sparc*-*-*): Remove obsolete sparc86x setting.\n+\t(sparc-leon*): Default to --with-cpu=v8 and --with-tune=leon.\n+\t* doc/invoke.texi (SPARC Options): Document -mcpu/-mtune=leon.\n+\t* config/sparc/sparc.h (TARGET_CPU_leon): Define.\n+\t(TARGET_CPU_sparc86x): Delete.\n+\t(TARGET_CPU_cypress): Define as alias to TARGET_CPU_v7.\n+\t(TARGET_CPU_f930): Define as alias to TARGET_CPU_sparclite.\n+\t(TARGET_CPU_f934): Likewise.\n+\t(TARGET_CPU_tsc701): Define as alias to TARGET_CPU_sparclet.\n+\t(CPP_CPU_SPEC): Add entry for -mcpu=leon.\n+\t(enum processor_type): Add PROCESSOR_LEON.  Reorganize.\n+\t* config/sparc/sparc.c (leon_costs): New cost array.\n+\t(sparc_option_override): Add entry for TARGET_CPU_leon and -mcpu=leon.\n+\tInitialize cost array to leon_costs if -mtune=leon.\n+\t* config/sparc/sparc.md (cpu attribute): Add leon.  Reorganize.\n+\tInclude leon.md scheduling description.\n+\t* config/sparc/leon.md: New file.\n+\t* config/sparc/t-elf: Do not assemble Solaris startup files.\n+\t* config/sparc/t-leon: New file.\n+\t* config/sparc/t-leon3: Likewise.\n+\n+2010-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/43655\n+\t* tree-ssa-ter.c (is_replaceable_p): Don't use\n+\tgimple_references_memory_p for -O0, instead check for load\n+\tby looking at rhs.\n+\n+2010-12-16  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/46404\n+\t* graphite-clast-to-gimple.c (gloog): Call scev_reset.\n+\n+2010-12-16  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/sh/sh.h (OUTPUT_ADDR_CONST_EXTRA): Remove.\n+\t* config/sh/sh.c (sh_asm_output_addr_const_extra): New function.\n+\t(TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA): Define.\n+\n+2010-12-16  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/t-spu-elf (LIB2_SIDITI_CONV_FUNC): Define.\n+\t* config/spu/spu.h (MIN_UNITS_PER_WORD): Do not define.\n+\t(LIBGCC2_UNITS_PER_WORD): Define if not already defined.\n+\n+2010-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/46893\n+\t* cfgexpand.c (expand_debug_expr): If GET_MODE (op0) is VOIDmode,\n+\tuse TYPE_MODE (TREE_TYPE (tem)) instead of mode1.\n+\n+2010-12-16  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\tPR target/46883\n+\t* config/arm/arm.md\n+\t(zero_extendhisi2 for register input splitter): Change\n+\t\"register_operand\" to \"s_register_operand\".\n+\t(zero_extendqisi2 for register input splitter): Same.\n+\n+2010-12-16  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/46939\n+\t* predic.c (predict_paths_leading_to_edge): New function.\n+\t(apply_return_prediction): Use it.\n+\t(predict_paths_for_bb): Do not special case abnormals.\n+\n+2010-12-16  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config.gcc (powerpc-*-lynxos*): Don't add lynx.opt to\n+\textra_options twice.\n+\n+2010-12-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* doc/tm.texi.in (US_SOFTWARE_GOFAST): Don't document.\n+\t* doc/tm.texi: Regenerate.\n+\t* system.h (US_SOFTWARE_GOFAST): Poison.\n+\t* config.gcc (enable_gofast): Don't handle.\n+\t* config/gofast.h: Remove.\n+\t* config/mips/t-gofast: Remove.\n+\t* config/fp-bit.c (US_SOFTWARE_GOFAST): Don't handle.\n+\t* config/fp-bit.h (US_SOFTWARE_GOFAST): Don't handle.\n+\t* config/mips/elforion.h: Don't mention GOFAST in comment.\n+\t* config/mips/mips.c: Don't include gofast.h.\n+\t(mips_init_libfuncs): Don't call gofast_maybe_init_libfuncs.\n+\t* config/mips/t-sr71k (dp-bit.c, fp-bit.c): Don't define\n+\tUS_SOFTWARE_GOFAST.\n+\t* config/sparc/sparc.c: Don't include gofast.h.\n+\t(sparc_init_libfuncs): Don't call gofast_maybe_init_libfuncs.\n+\t* config/spu/t-spu-elf (dp-bit.c, fp-bit.c): Don't undefine\n+\tUS_SOFTWARE_GOFAST.\n+\n 2010-12-14  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (get_file_function_name): Avoid using random seed on GLOBAL_sub_I"}, {"sha": "7ac50dd31bb9a07835e3f141cfddf22ba5255def", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 36, "deletions": 85, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239630dc0c90e049f3f63e97ab41b708bd1d48e9/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239630dc0c90e049f3f63e97ab41b708bd1d48e9/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=239630dc0c90e049f3f63e97ab41b708bd1d48e9", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n \n     There are three major parts of this file:\n \n-    cgraph_mark_inline implementation\n+    cgraph_mark_inline_edge implementation\n \n       This function allows to mark given call inline and performs necessary\n       modifications of cgraph (production of the clones and updating overall\n@@ -91,31 +91,13 @@ along with GCC; see the file COPYING3.  If not see\n      optimized allowing it to unfold abstraction penalty on C++ effectively and\n      cheaply.\n \n-   pass_ipa_early_inlining\n-\n-     With profiling, the early inlining is also necessary to reduce\n-     instrumentation costs on program with high abstraction penalty (doing\n-     many redundant calls).  This can't happen in parallel with early\n-     optimization and profile instrumentation, because we would end up\n-     re-instrumenting already instrumented function bodies we brought in via\n-     inlining.\n-\n-     To avoid this, this pass is executed as IPA pass before profiling.  It is\n-     simple wrapper to pass_early_inlining and ensures first inlining.\n-\n    pass_ipa_inline\n \n      This is the main pass implementing simple greedy algorithm to do inlining\n      of small functions that results in overall growth of compilation unit and\n      inlining of functions called once.  The pass compute just so called inline\n      plan (representation of inlining to be done in callgraph) and unlike early\n      inlining it is not performing the inlining itself.\n-\n-   pass_apply_inline\n-\n-     This pass performs actual inlining according to pass_ipa_inline on given\n-     function.  Possible the function body before inlining is saved when it is\n-     needed for further inlining later.\n  */\n \n #include \"config.h\"\n@@ -199,14 +181,14 @@ cgraph_estimate_time_after_inlining (int frequency, struct cgraph_node *to,\n   return time;\n }\n \n-/* Estimate self time of the function after inlining WHAT into TO.  */\n+/* Estimate self size of the function after inlining WHAT into TO.  */\n \n static inline int\n-cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n+cgraph_estimate_size_after_inlining (struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n   int size = ((what->global.size - inline_summary (what)->size_inlining_benefit)\n-\t      * times + to->global.size);\n+\t      + to->global.size);\n   gcc_assert (size >= 0);\n   return size;\n }\n@@ -335,7 +317,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     {\n       to = e->caller;\n       old_size = e->caller->global.size;\n-      new_size = cgraph_estimate_size_after_inlining (1, to, what);\n+      new_size = cgraph_estimate_size_after_inlining (to, what);\n       to->global.size = new_size;\n       to->global.time = cgraph_estimate_time_after_inlining (freq, to, what);\n     }\n@@ -352,30 +334,6 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     return false;\n }\n \n-/* Mark all calls of EDGE->CALLEE inlined into EDGE->CALLER.  */\n-\n-static void\n-cgraph_mark_inline (struct cgraph_edge *edge)\n-{\n-  struct cgraph_node *to = edge->caller;\n-  struct cgraph_node *what = edge->callee;\n-  struct cgraph_edge *e, *next;\n-\n-  gcc_assert (!edge->call_stmt_cannot_inline_p);\n-  /* Look for all calls, mark them inline and clone recursively\n-     all inlined functions.  */\n-  for (e = what->callers; e; e = next)\n-    {\n-      next = e->next_caller;\n-      if (e->caller == to && e->inline_failed)\n-\t{\n-          cgraph_mark_inline_edge (e, true, NULL);\n-\t  if (e == edge)\n-\t    edge = next;\n-\t}\n-    }\n-}\n-\n /* Estimate the growth caused by inlining NODE into all callees.  */\n \n static int\n@@ -393,7 +351,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n       if (e->caller == node)\n         self_recursive = true;\n       if (e->inline_failed)\n-\tgrowth += (cgraph_estimate_size_after_inlining (1, e->caller, node)\n+\tgrowth += (cgraph_estimate_size_after_inlining (e->caller, node)\n \t\t   - e->caller->global.size);\n     }\n \n@@ -424,21 +382,12 @@ cgraph_estimate_growth (struct cgraph_node *node)\n \n static bool\n cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t\t    cgraph_inline_failed_t *reason, bool one_only)\n+\t\t\t    cgraph_inline_failed_t *reason)\n {\n-  int times = 0;\n-  struct cgraph_edge *e;\n   int newsize;\n   int limit;\n   HOST_WIDE_INT stack_size_limit, inlined_stack;\n \n-  if (one_only)\n-    times = 1;\n-  else\n-    for (e = to->callees; e; e = e->next_callee)\n-      if (e->callee == what)\n-\ttimes++;\n-\n   if (to->global.inlined_to)\n     to = to->global.inlined_to;\n \n@@ -453,7 +402,7 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n-  newsize = cgraph_estimate_size_after_inlining (times, to, what);\n+  newsize = cgraph_estimate_size_after_inlining (to, what);\n   if (newsize >= to->global.size\n       && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n@@ -565,7 +514,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n   int growth =\n-    (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n+    (cgraph_estimate_size_after_inlining (edge->caller, edge->callee)\n      - edge->caller->global.size);\n \n   if (edge->callee->local.disregard_inline_limits)\n@@ -895,7 +844,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n   if (!max_depth\n-      || cgraph_estimate_size_after_inlining (1, node, node)  >= limit)\n+      || cgraph_estimate_size_after_inlining (node, node)  >= limit)\n     return false;\n   heap = fibheap_new ();\n   lookup_recursive_calls (node, node, heap);\n@@ -921,7 +870,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \n   /* Do the inlining and update list of recursive call during process.  */\n   while (!fibheap_empty (heap)\n-\t && (cgraph_estimate_size_after_inlining (1, node, master_clone)\n+\t && (cgraph_estimate_size_after_inlining (node, master_clone)\n \t     <= limit))\n     {\n       struct cgraph_edge *curr\n@@ -1128,7 +1077,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       \n       callee = edge->callee;\n \n-      growth = (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n+      growth = (cgraph_estimate_size_after_inlining (edge->caller, edge->callee)\n \t\t- edge->caller->global.size);\n \n       if (dump_file)\n@@ -1220,7 +1169,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t  continue;\n \t}\n-      if (!tree_can_inline_p (edge))\n+      if (!tree_can_inline_p (edge)\n+\t  || edge->call_stmt_cannot_inline_p)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \" inline_failed:%s.\\n\",\n@@ -1244,9 +1194,8 @@ cgraph_decide_inlining_of_small_functions (void)\n       else\n \t{\n \t  struct cgraph_node *callee;\n-\t  if (edge->call_stmt_cannot_inline_p\n-\t      || !cgraph_check_inline_limits (edge->caller, edge->callee,\n-\t\t\t\t\t      &edge->inline_failed, true))\n+\t  if (!cgraph_check_inline_limits (edge->caller, edge->callee,\n+\t\t\t\t           &edge->inline_failed))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" Not inlining into %s:%s.\\n\",\n@@ -1368,7 +1317,12 @@ cgraph_flatten (struct cgraph_node *node)\n       struct cgraph_node *orig_callee;\n \n       if (e->call_stmt_cannot_inline_p)\n-\tcontinue;\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not inlining: %s\",\n+\t\t     cgraph_inline_failed_string (e->inline_failed));\n+\t  continue;\n+\t}\n \n       if (!e->callee->analyzed)\n \t{\n@@ -1555,10 +1509,10 @@ cgraph_decide_inlining (void)\n \t\t}\n \n \t      if (cgraph_check_inline_limits (node->callers->caller, node,\n-\t\t\t\t\t      &reason, false))\n+\t\t\t\t\t      &reason))\n \t\t{\n \t\t  struct cgraph_node *caller = node->callers->caller;\n-\t\t  cgraph_mark_inline (node->callers);\n+\t\t  cgraph_mark_inline_edge (node->callers, true, NULL);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \" Inlined into %s which now has %i size\"\n@@ -1636,8 +1590,6 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \tif (!e->callee->local.disregard_inline_limits\n \t    && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \t  continue;\n-\tif (e->call_stmt_cannot_inline_p)\n-\t  continue;\n \tif (dump_file)\n \t  fprintf (dump_file,\n \t\t   \"Considering to always inline inline candidate %s.\\n\",\n@@ -1648,7 +1600,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t      fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n \t    continue;\n \t  }\n-\tif (!tree_can_inline_p (e))\n+\tif (!tree_can_inline_p (e)\n+\t    || e->call_stmt_cannot_inline_p)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file,\n@@ -1675,7 +1628,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  fprintf (dump_file, \" Inlining %s into %s.\\n\",\n \t\t   cgraph_node_name (e->callee),\n \t\t   cgraph_node_name (e->caller));\n-\tcgraph_mark_inline (e);\n+\tcgraph_mark_inline_edge (e, true, NULL);\n \tinlined = true;\n       }\n \n@@ -1725,25 +1678,24 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  if (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n \t       || (!flag_inline_functions\n \t\t   && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n-\t      && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n+\t      && (cgraph_estimate_size_after_inlining (e->caller, e->callee)\n \t\t  > e->caller->global.size + allowed_growth)\n \t      && cgraph_estimate_growth (e->callee) > allowed_growth)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"Not inlining: code size would grow by %i.\\n\",\n-\t\t\t cgraph_estimate_size_after_inlining (1, e->caller,\n+\t\t\t cgraph_estimate_size_after_inlining (e->caller,\n \t\t\t\t\t\t\t      e->callee)\n \t\t\t - e->caller->global.size);\n \t      continue;\n \t    }\n-\t  if (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t\t\t\t\t   false)\n-\t      || e->call_stmt_cannot_inline_p)\n+\t  if (e->call_stmt_cannot_inline_p\n+\t      || !tree_can_inline_p (e))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \"Not inlining: %s.\\n\",\n-\t\t\t cgraph_inline_failed_string (e->inline_failed));\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: call site not inlinable.\\n\");\n \t      continue;\n \t    }\n \t  if (!e->callee->analyzed)\n@@ -1753,11 +1705,10 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t\t\t \"Not inlining: Function body no longer available.\\n\");\n \t      continue;\n \t    }\n-\t  if (!tree_can_inline_p (e))\n+\t  if (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: %s.\",\n+\t\tfprintf (dump_file, \"Not inlining: %s.\\n\",\n \t\t\t cgraph_inline_failed_string (e->inline_failed));\n \t      continue;\n \t    }\n@@ -1767,7 +1718,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t\tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n \t\t\t cgraph_node_name (e->callee),\n \t\t\t cgraph_node_name (e->caller));\n-\t      cgraph_mark_inline (e);\n+\t      cgraph_mark_inline_edge (e, true, NULL);\n \t      inlined = true;\n \t    }\n \t}"}]}