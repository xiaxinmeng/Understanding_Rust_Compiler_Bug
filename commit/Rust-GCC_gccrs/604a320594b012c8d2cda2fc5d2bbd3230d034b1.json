{"sha": "604a320594b012c8d2cda2fc5d2bbd3230d034b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0YTMyMDU5NGIwMTJjOGQyY2RhMmZjNWQyYmJkMzIzMGQwMzRiMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-07T10:21:04Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-07T10:21:04Z"}, "message": "tree.h (TYPE_BINFO_OFFSET, [...]): Remove.\n\n\t* tree.h (TYPE_BINFO_OFFSET, TYPE_BINFO_VTABLE,\n\tTYPE_BINFO_VIRTUALS, TYPE_BINFO_BASETYPES,\n\tTYPE_BINFO_BASETYPE): Remove.\n\t(BINFO_BASETYPES, BINFO_N_BASETYPES, BINFO_BASETYPE): Rename\n\tto ...\n\t(BINFO_BASE_BINFOS, BINFO_N_BASE_BINFOS, BINFO_BASE_BINFO): ...\n\there.\n\t(BINFO_BASEACCESSES, BINFO_BASEACCESS): Rename to ...\n\t(BINFO_BASE_ACCESSES, BINFO_BASE_ACCESS): ... here.\n\t(BINFO_INHERITANCE_CHAIN): Redocument as it is actually used.\n\t(struct tree_binfo): Rename base_types to base_binfos.\n\t* alias.c (record_component_aliases): Adjust BINFO macros.\n\t* dbxout.c (dbxout_type): Likewise.\n\t* dwarf2out.c (gen_member_die): Likewise.\n\t* sdbout.c (sdbout_one_type): Likewise.\n\t* tree-dump.c (deque_and_dump): Likewise.\n\t* config/i386/i386.c (classify_argument,\n\tcontains_128bit_aligned_vector_p): Likewise.\n\n\t* cp/cp-tree.h (CLASSTYPE_N_BASECLASSES): Remove.\n\t* cp/class.c (build_primary_vtable, check_bases,\n\tdetermine_primary_base, finish_struct_bits,\n\tmaybe_warn_about_overly_private_class, dfs_find_final_overrider_q,\n\tget_basefndecls, warn_hidden, walk_subobject_offsets,\n\tbuild_base_fields, create_vtable_ptr, propagate_binfo_offsets,\n\tlayout_virtual_bases, end_of_class, warn_about_ambiguous_bases,\n\tfinish_struct_1, get_vfield_name, contains_empty_class_p,\n\tdump_class_hierarchy_r, finish_vtbls, build_vtt_inits,\n\tdfs_ctor_vtable_bases_queue_p, accumulate_vtbl_inits,\n\tadd_vcall_offset_vtbl_entries_r, cp_fold_obj_type_ref): Adjust\n\tBINFO macros.\n\t* cp/decl.c (xref_basetypes): Likewise.\n\t* cp/dump.c (cp_dump_tree): Likewise.\n\t* cp/error.c (dump_expr): Likewise.\n\t* cp/init.c (sort_mem_initializers, expand_member_init,\n\tpush_base_cleanups): Likewise.\n\t* cp/method.c (do_build_copy_constructor, do_build_assign_reg,\n\tsynthesize_exception_spec): Likewise.\n\t* cp/name-lookup.c (arg_assoc_class):\n\t* cp/pt.c (instantiate_class_template, tsubst,\n\tget_template_base_recursive):\n\t* cp/ptree.c (cxx_print_type):\n\t* cp/rtti.c (get_psuedo_ti_init, get_pseudo_ti_desc): Likewise.\n\t* cp/search.c (lookup_base_r, dynamic_cast_base_recurse,\n\tdfs_access_in_type, access_in_type, lookup_field_queue_p,\n\tbfs_walk, dfs_walk_real, look_for_overrides, markedp, unmarkedp,\n\tmarked_pushdecls_p, unmarked_pushdecls_p, dfs_debug_markedp,\n\tdfs_debug_unmarkedp, dfs_check_overlap, dfs_no_overlap_yet,\n\tbinfo_for_vtable, copied_binfo, original_binfo): Likewise\n\t* cp/tree.c (copy_base_binfos, make_binfo): Likewise.\n\t* cp/typeck.c (commmon_base_type): Likewise\n\t* cp/typeck2.c (process_init_constructor): Likewise\n\n\t* java/java-tree.h (CLASSTYPE_SPUER): Adjust BINFO macros.\n\t(TYPE_NVIRTUALS, TYPE_VTABLE): Likewise.\n\t* java/class.c (set_super_info, class_depth, interface_of_p,\n\tmaybe_add_interface, add_interface, make_class_data,\n\tlayout_class, add_miranda_methods): Adjust BINFO macros.\n\t* java/expr.c (can_widen_reference_to, lookup_field): Likewise.\n\t* java/jcf-write.c (generate_classfile): Likewise.\n\t* java/parse.y (patch_anonymous_class,\n\tcheck_inner_circular_reference, check_circular_reference,\n\tjava_complete_class, check_abstract_method_definitions,\n\tjava_check_abstract_method_definitions,\n\tcheck_interface_throws_clauses, java_check_abstract_methods,\n\tlookup_java_interface_method2,\n\tfind_applicable_accessible_methods_list): Likewise.\n\t* java/typeck.c (find_method_in_interface): Likewise.\n\t* java/verify.c (merge_types): Likewise.\n\nFrom-SVN: r84198", "tree": {"sha": "f1107852a967ee8014a46e51df142dd36d2f7735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1107852a967ee8014a46e51df142dd36d2f7735"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/604a320594b012c8d2cda2fc5d2bbd3230d034b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604a320594b012c8d2cda2fc5d2bbd3230d034b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/604a320594b012c8d2cda2fc5d2bbd3230d034b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604a320594b012c8d2cda2fc5d2bbd3230d034b1/comments", "author": null, "committer": null, "parents": [{"sha": "6b66447a5241687f20ce263f8e51f5a9950aad97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b66447a5241687f20ce263f8e51f5a9950aad97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b66447a5241687f20ce263f8e51f5a9950aad97"}], "stats": {"total": 533, "additions": 300, "deletions": 233}, "files": [{"sha": "48e5f0ddbba7c5a8f0349c53377d5fb46863eb1f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1,3 +1,24 @@\n+2004-07-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (TYPE_BINFO_OFFSET, TYPE_BINFO_VTABLE,\n+\tTYPE_BINFO_VIRTUALS, TYPE_BINFO_BASETYPES,\n+\tTYPE_BINFO_BASETYPE): Remove.\n+\t(BINFO_BASETYPES, BINFO_N_BASETYPES, BINFO_BASETYPE): Rename\n+\tto ...\n+\t(BINFO_BASE_BINFOS, BINFO_N_BASE_BINFOS, BINFO_BASE_BINFO): ...\n+\there.\n+\t(BINFO_BASEACCESSES, BINFO_BASEACCESS): Rename to ...\n+\t(BINFO_BASE_ACCESSES, BINFO_BASE_ACCESS): ... here.\n+\t(BINFO_INHERITANCE_CHAIN): Redocument as it is actually used.\n+\t(struct tree_binfo): Rename base_types to base_binfos.\n+\t* alias.c (record_component_aliases): Adjust BINFO macros.\n+\t* dbxout.c (dbxout_type): Likewise.\n+\t* dwarf2out.c (gen_member_die): Likewise.\n+\t* sdbout.c (sdbout_one_type): Likewise.\n+\t* tree-dump.c (deque_and_dump): Likewise.\n+\t* config/i386/i386.c (classify_argument,\n+\tcontains_128bit_aligned_vector_p): Likewise.\n+\n 2004-07-07  Nick Clifton  <nickc@redhat.com>\n \n \t* config/fr30/fr30.c (fr30_setup_incoming_varargs): Change"}, {"sha": "9b920b9f34fbfe0b4470e5774aa87cf48b9701da", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -718,12 +718,12 @@ record_component_aliases (tree type)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       /* Recursively record aliases for the base classes, if there are any.  */\n-      if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+      if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t{\n \t  int i;\n-\t  for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)); i++)\n+\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n \t    {\n-\t      tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n+\t      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t      record_alias_subset (superset,\n \t\t\t\t   get_alias_set (BINFO_TYPE (binfo)));\n \t    }"}, {"sha": "288ce7b7b29a0d97179757b9bb6d6ec623ce3bb4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -2063,10 +2063,10 @@ classify_argument (enum machine_mode mode, tree type,\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n \t  /* For classes first merge in the field of the subclasses.  */\n-\t  if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n-\t      tree bases = TYPE_BINFO_BASETYPES (type);\n-\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n+\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n \t      int i;\n \n \t      for (i = 0; i < n_bases; ++i)\n@@ -2151,10 +2151,10 @@ classify_argument (enum machine_mode mode, tree type,\n \t       || TREE_CODE (type) == QUAL_UNION_TYPE)\n \t{\n \t  /* For classes first merge in the field of the subclasses.  */\n-\t  if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n-\t      tree bases = TYPE_BINFO_BASETYPES (type);\n-\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n+\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n \t      int i;\n \n \t      for (i = 0; i < n_bases; ++i)\n@@ -2759,11 +2759,10 @@ contains_128bit_aligned_vector_p (tree type)\n \t{\n \t  tree field;\n \n-\t  if (TYPE_BINFO (type) != NULL\n-\t      && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t  if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n-\t      tree bases = TYPE_BINFO_BASETYPES (type);\n-\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      tree bases = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n+\t      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n \t      int i;\n \n \t      for (i = 0; i < n_bases; ++i)"}, {"sha": "488d0377a00936ee950e91aba526ee2a50ae31c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1,3 +1,39 @@\n+2004-07-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (CLASSTYPE_N_BASECLASSES): Remove.\n+\t* class.c (build_primary_vtable, check_bases,\n+\tdetermine_primary_base, finish_struct_bits,\n+\tmaybe_warn_about_overly_private_class, dfs_find_final_overrider_q,\n+\tget_basefndecls, warn_hidden, walk_subobject_offsets,\n+\tbuild_base_fields, create_vtable_ptr, propagate_binfo_offsets,\n+\tlayout_virtual_bases, end_of_class, warn_about_ambiguous_bases,\n+\tfinish_struct_1, get_vfield_name, contains_empty_class_p,\n+\tdump_class_hierarchy_r, finish_vtbls, build_vtt_inits,\n+\tdfs_ctor_vtable_bases_queue_p, accumulate_vtbl_inits,\n+\tadd_vcall_offset_vtbl_entries_r, cp_fold_obj_type_ref): Adjust\n+\tBINFO macros.\n+\t* decl.c (xref_basetypes): Likewise.\n+\t* dump.c (cp_dump_tree): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* init.c (sort_mem_initializers, expand_member_init,\n+\tpush_base_cleanups): Likewise.\n+\t* method.c (do_build_copy_constructor, do_build_assign_reg,\n+\tsynthesize_exception_spec): Likewise.\n+\t* name-lookup.c (arg_assoc_class):\n+\t* pt.c (instantiate_class_template, tsubst,\n+\tget_template_base_recursive):\n+\t* ptree.c (cxx_print_type):\n+\t* rtti.c (get_psuedo_ti_init, get_pseudo_ti_desc): Likewise.\n+\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n+\tdfs_access_in_type, access_in_type, lookup_field_queue_p,\n+\tbfs_walk, dfs_walk_real, look_for_overrides, markedp, unmarkedp,\n+\tmarked_pushdecls_p, unmarked_pushdecls_p, dfs_debug_markedp,\n+\tdfs_debug_unmarkedp, dfs_check_overlap, dfs_no_overlap_yet,\n+\tbinfo_for_vtable, copied_binfo, original_binfo): Likewise\n+\t* tree.c (copy_base_binfos, make_binfo): Likewise.\n+\t* typeck.c (commmon_base_type): Likewise\n+\t* typeck2.c (process_init_constructor): Likewise\n+\n 2004-07-06  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* decl.c (check_tag_decl): Name redeclared type in diagnostic."}, {"sha": "4cfa5875a907bacc9b07a7402c4f0ac80b9f3d92", "filename": "gcc/cp/class.c", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -693,8 +693,8 @@ build_primary_vtable (tree binfo, tree type)\n \n   /* Initialize the association list for this type, based\n      on our first approximation.  */\n-  TYPE_BINFO_VTABLE (type) = decl;\n-  TYPE_BINFO_VIRTUALS (type) = virtuals;\n+  BINFO_VTABLE (TYPE_BINFO (type)) = decl;\n+  BINFO_VIRTUALS (TYPE_BINFO (type)) = virtuals;\n   SET_BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (type));\n   return 1;\n }\n@@ -1194,8 +1194,8 @@ check_bases (tree t,\n   int seen_non_virtual_nearly_empty_base_p;\n   tree binfos;\n \n-  binfos = TYPE_BINFO_BASETYPES (t);\n-  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (t));\n+  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   seen_non_virtual_nearly_empty_base_p = 0;\n \n   /* An aggregate cannot have baseclasses.  */\n@@ -1334,8 +1334,8 @@ set_primary_base (tree t, tree binfo)\n \n   CLASSTYPE_PRIMARY_BINFO (t) = binfo;\n   basetype = BINFO_TYPE (binfo);\n-  TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n-  TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n+  BINFO_VTABLE (TYPE_BINFO (t)) = BINFO_VTABLE (TYPE_BINFO (basetype));\n+  BINFO_VIRTUALS (TYPE_BINFO (t)) = BINFO_VIRTUALS (TYPE_BINFO (basetype));\n   TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n }\n \n@@ -1344,7 +1344,7 @@ set_primary_base (tree t, tree binfo)\n static void\n determine_primary_base (tree t)\n {\n-  unsigned i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  unsigned i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   tree type_binfo;\n   tree vbase_binfo;\n \n@@ -1356,7 +1356,7 @@ determine_primary_base (tree t)\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree base_binfo = BINFO_BASETYPE (type_binfo, i);\n+      tree base_binfo = BINFO_BASE_BINFO (type_binfo, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_CONTAINS_VPTR_P (basetype))\n@@ -1406,7 +1406,7 @@ determine_primary_base (tree t)\n \t{\n \t  unsigned k;\n \t  tree base_vbase_binfo;\n-\t  tree basetype = TYPE_BINFO_BASETYPE (t, j);\n+\t  tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), j));\n \t  \n \t  for (k = 0; (base_vbase_binfo = VEC_iterate\n \t\t       (tree, CLASSTYPE_VBASECLASSES (basetype), k)); k++)\n@@ -1483,7 +1483,7 @@ determine_primary_base (tree t)\n static void\n finish_struct_bits (tree t)\n {\n-  int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  int i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n \n   /* Fix up variants (if any).  */\n   tree variants = TYPE_NEXT_VARIANT (t);\n@@ -1525,7 +1525,7 @@ finish_struct_bits (tree t)\n     {\n       /* Notice whether this class has type conversion functions defined.  */\n       tree binfo = TYPE_BINFO (t);\n-      tree binfos = BINFO_BASETYPES (binfo);\n+      tree binfos = BINFO_BASE_BINFOS (binfo);\n       tree basetype;\n \n       for (i = n_baseclasses-1; i >= 0; i--)\n@@ -1626,8 +1626,8 @@ maybe_warn_about_overly_private_class (tree t)\n       int i;\n       tree binfo = TYPE_BINFO (t);\n       \n-      for (i = 0; i < BINFO_N_BASETYPES (binfo); i++)\n-\tif (BINFO_BASEACCESS (binfo, i) != access_private_node)\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n+\tif (BINFO_BASE_ACCESS (binfo, i) != access_private_node)\n \t  {\n \t    has_nonprivate_method = 1;\n \t    break;\n@@ -2005,7 +2005,7 @@ dfs_find_final_overrider (tree binfo, void* data)\n static tree\n dfs_find_final_overrider_q (tree derived, int ix, void *data)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n   if (BINFO_VIRTUAL_P (binfo))\n@@ -2393,7 +2393,7 @@ get_basefndecls (tree name, tree t)\n {\n   tree methods;\n   tree base_fndecls = NULL_TREE;\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   int i;\n \n   /* Find virtual functions in T with the indicated NAME.  */\n@@ -2415,7 +2415,7 @@ get_basefndecls (tree name, tree t)\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree basetype = TYPE_BINFO_BASETYPE (t, i);\n+      tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), i));\n       base_fndecls = chainon (get_basefndecls (name, basetype),\n \t\t\t      base_fndecls);\n     }\n@@ -2480,9 +2480,9 @@ warn_hidden (tree t)\n       base_fndecls = NULL_TREE;\n       /* Iterate through all of the base classes looking for possibly\n \t hidden functions.  */\n-      for (j = 0; j < CLASSTYPE_N_BASECLASSES (t); j++)\n+      for (j = 0; j < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); j++)\n \t{\n-\t  tree basetype = TYPE_BINFO_BASETYPE (t, j);\n+\t  tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), j));\n \t  base_fndecls = chainon (get_basefndecls (name, basetype),\n \t\t\t\t  base_fndecls);\n \t}\n@@ -3266,11 +3266,11 @@ walk_subobject_offsets (tree type,\n       /* Iterate through the direct base classes of TYPE.  */\n       if (!type_binfo)\n \ttype_binfo = TYPE_BINFO (type);\n-      for (i = 0; i < BINFO_N_BASETYPES (type_binfo); ++i)\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (type_binfo); ++i)\n \t{\n \t  tree binfo_offset;\n \n-\t  binfo = BINFO_BASETYPE (type_binfo, i);\n+\t  binfo = BINFO_BASE_BINFO (type_binfo, i);\n \n \t  if (abi_version_at_least (2) \n \t      && BINFO_VIRTUAL_P (binfo))\n@@ -3291,7 +3291,7 @@ walk_subobject_offsets (tree type,\n \t      /* We cannot rely on BINFO_OFFSET being set for the base\n \t\t class yet, but the offsets for direct non-virtual\n \t\t bases can be calculated by going back to the TYPE.  */\n-\t      orig_binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\t      orig_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t      binfo_offset = size_binop (PLUS_EXPR,\t      \n \t\t\t\t\t offset,\n \t\t\t\t\t BINFO_OFFSET (orig_binfo));\n@@ -3735,7 +3735,7 @@ build_base_fields (record_layout_info rli,\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n   tree t = rli->t;\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   int i;\n \n   /* The primary base class is always allocated first.  */\n@@ -3748,7 +3748,7 @@ build_base_fields (record_layout_info rli,\n     {\n       tree base_binfo;\n \n-      base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n \n       /* The primary base was already allocated above, so we don't\n \t need to allocate it again here.  */\n@@ -4281,7 +4281,7 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n       /* This class is non-empty.  */\n       CLASSTYPE_EMPTY_P (t) = 0;\n \n-      if (CLASSTYPE_N_BASECLASSES (t))\n+      if (BINFO_N_BASE_BINFOS (TYPE_BINFO (t)))\n \t/* If there were any baseclasses, they can't possibly be at\n \t   offset zero any more, because that's where the vtable\n \t   pointer is.  So, converting to a base class is going to\n@@ -4364,7 +4364,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \n   /* Scan all of the bases, pushing the BINFO_OFFSET adjust\n      downwards.  */\n-  for (i = -1; i < BINFO_N_BASETYPES (binfo); ++i)\n+  for (i = -1; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n     {\n       tree base_binfo;\n \n@@ -4380,7 +4380,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \t}\n       else\n \t{\n-\t  base_binfo = BINFO_BASETYPE (binfo, i);\n+\t  base_binfo = BINFO_BASE_BINFO (binfo, i);\n \t  /* Don't do the primary base twice.  */\n \t  if (base_binfo == primary_binfo)\n \t    continue;\n@@ -4407,7 +4407,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n   bool first_vbase = true;\n   tree *next_field;\n \n-  if (CLASSTYPE_N_BASECLASSES (t) == 0)\n+  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (t)) == 0)\n     return;\n \n   if (!abi_version_at_least(2))\n@@ -4502,9 +4502,9 @@ end_of_class (tree t, int include_virtuals_p)\n   tree offset;\n   int i;\n \n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n     {\n-      binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n \n       if (!include_virtuals_p\n \t  && BINFO_VIRTUAL_P (binfo) \n@@ -4547,9 +4547,9 @@ warn_about_ambiguous_bases (tree t)\n   tree binfo;\n \n   /* Check direct bases.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n     {\n-      basetype = TYPE_BINFO_BASETYPE (t, i);\n+      basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), i));\n \n       if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \twarning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n@@ -5092,15 +5092,16 @@ finish_struct_1 (tree t)\n       int vindex;\n       tree fn;\n \n-      if (TYPE_BINFO_VTABLE (t))\n-\tmy_friendly_assert (DECL_VIRTUAL_P (TYPE_BINFO_VTABLE (t)),\n+      if (BINFO_VTABLE (TYPE_BINFO (t)))\n+\tmy_friendly_assert (DECL_VIRTUAL_P (BINFO_VTABLE (TYPE_BINFO (t))),\n \t\t\t    20000116);\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-\tmy_friendly_assert (TYPE_BINFO_VIRTUALS (t) == NULL_TREE,\n+\tmy_friendly_assert (BINFO_VIRTUALS (TYPE_BINFO (t)) == NULL_TREE,\n \t\t\t    20000116);\n \n       /* Add entries for virtual functions introduced by this class.  */\n-      TYPE_BINFO_VIRTUALS (t) = chainon (TYPE_BINFO_VIRTUALS (t), virtuals);\n+      BINFO_VIRTUALS (TYPE_BINFO (t))\n+\t= chainon (BINFO_VIRTUALS (TYPE_BINFO (t)), virtuals);\n \n       /* Set DECL_VINDEX for all functions declared in this class.  */\n       for (vindex = 0, fn = BINFO_VIRTUALS (TYPE_BINFO (t)); \n@@ -6255,10 +6256,10 @@ get_vfield_name (tree type)\n   tree binfo = TYPE_BINFO (type);\n   char *buf;\n \n-  while (BINFO_BASETYPES (binfo)\n-\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n-\t && ! BINFO_VIRTUAL_P (BINFO_BASETYPE (binfo, 0)))\n-    binfo = BINFO_BASETYPE (binfo, 0);\n+  while (BINFO_BASE_BINFOS (binfo)\n+\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASE_BINFO (binfo, 0)))\n+\t && ! BINFO_VIRTUAL_P (BINFO_BASE_BINFO (binfo, 0)))\n+    binfo = BINFO_BASE_BINFO (binfo, 0);\n \n   type = BINFO_TYPE (binfo);\n   buf = alloca (sizeof (VFIELD_NAME_FORMAT) + TYPE_NAME_LENGTH (type) + 2);\n@@ -6341,8 +6342,9 @@ contains_empty_class_p (tree type)\n       tree field;\n       int i;\n \n-      for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); ++i)\n-\tif (contains_empty_class_p (TYPE_BINFO_BASETYPE (type, i)))\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); ++i)\n+\tif (contains_empty_class_p\n+\t    (BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type), i))))\n \t  return true;\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL\n@@ -6583,7 +6585,7 @@ dump_class_hierarchy_r (FILE *stream,\n \tfprintf (stream, \"\\n\");\n     }\n   \n-  base_binfos = BINFO_BASETYPES (binfo);\n+  base_binfos = BINFO_BASE_BINFOS (binfo);\n   if (base_binfos)\n     {\n       int ix, n;\n@@ -6770,7 +6772,7 @@ finish_vtbls (tree t)\n   /* We lay out the primary and secondary vtables in one contiguous\n      vtable.  The primary vtable is first, followed by the non-virtual\n      secondary vtables in inheritance graph order.  */\n-  list = build_tree_list (TYPE_BINFO_VTABLE (t), NULL_TREE);\n+  list = build_tree_list (BINFO_VTABLE (TYPE_BINFO (t)), NULL_TREE);\n   accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n \t\t\t TYPE_BINFO (t), t, list);\n   \n@@ -6782,7 +6784,7 @@ finish_vtbls (tree t)\n       accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n     }\n \n-  if (TYPE_BINFO_VTABLE (t))\n+  if (BINFO_VTABLE (TYPE_BINFO (t)))\n     initialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n }\n \n@@ -6925,11 +6927,11 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n \t\t       \n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n-  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n     {\n-      b = BINFO_BASETYPE (binfo, i);\n+      b = BINFO_BASE_BINFO (binfo, i);\n       if (!BINFO_VIRTUAL_P (b))\n-\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, \n+\tinits = build_vtt_inits (BINFO_BASE_BINFO (binfo, i), t, \n \t\t\t\t inits, index);\n     }\n       \n@@ -7059,7 +7061,7 @@ static tree\n dfs_ctor_vtable_bases_queue_p (tree derived, int ix,\n \t\t\t       void* data)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   if (!BINFO_MARKED (binfo) == VTT_MARKED_BINFO_P ((tree) data))\n     return NULL_TREE;\n@@ -7191,15 +7193,15 @@ accumulate_vtbl_inits (tree binfo,\n      secondary vtable lies from the primary vtable.  We can't use\n      dfs_walk here because we need to iterate through bases of BINFO\n      and RTTI_BINFO simultaneously.  */\n-  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i)\n     {\n-      tree base_binfo = BINFO_BASETYPE (binfo, i);\n+      tree base_binfo = BINFO_BASE_BINFO (binfo, i);\n       \n       /* Skip virtual bases.  */\n       if (BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n       accumulate_vtbl_inits (base_binfo,\n-\t\t\t     BINFO_BASETYPE (orig_binfo, i),\n+\t\t\t     BINFO_BASE_BINFO (orig_binfo, i),\n \t\t\t     rtti_binfo, t,\n \t\t\t     inits);\n     }\n@@ -7683,11 +7685,11 @@ add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n   add_vcall_offset_vtbl_entries_1 (binfo, vid);\n \n   /* Scan the non-primary bases of BINFO.  */\n-  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i) \n+  for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); ++i) \n     {\n       tree base_binfo;\n       \n-      base_binfo = BINFO_BASETYPE (binfo, i);\n+      base_binfo = BINFO_BASE_BINFO (binfo, i);\n       if (base_binfo != primary_binfo)\n \tadd_vcall_offset_vtbl_entries_r (base_binfo, vid);\n     }\n@@ -7908,7 +7910,7 @@ cp_fold_obj_type_ref (tree ref, tree known_type)\n {\n   HOST_WIDE_INT index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n   HOST_WIDE_INT i = 0;\n-  tree v = TYPE_BINFO_VIRTUALS (known_type); \n+  tree v = BINFO_VIRTUALS (TYPE_BINFO (known_type));\n   tree fndecl;\n \n   while (i != index)"}, {"sha": "87e610eaa19c1a54fc4bf9578a069358d42118c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1258,10 +1258,6 @@ struct lang_type GTY(())\n    should be initialized.)  */\n #define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n \n-/* Number of direct baseclasses of NODE.  */\n-#define CLASSTYPE_N_BASECLASSES(NODE) \\\n-  (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n-\n /* The type corresponding to NODE when NODE is used as a base class,\n    i.e., NODE without virtual base classes.  */\n "}, {"sha": "d8feecdbc132c94937d1d39fa7035a830f67a4ad", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -9082,8 +9082,8 @@ xref_basetypes (tree ref, tree base_list)\n       tree binfos = make_tree_vec (i);\n       tree accesses = make_tree_vec (i);\n       \n-      BINFO_BASETYPES (binfo) = binfos;\n-      BINFO_BASEACCESSES (binfo) = accesses;\n+      BINFO_BASE_BINFOS (binfo) = binfos;\n+      BINFO_BASE_ACCESSES (binfo) = accesses;\n   \n       for (i = 0; base_list; base_list = TREE_CHAIN (base_list))\n \t{\n@@ -9178,7 +9178,7 @@ xref_basetypes (tree ref, tree base_list)\n       if (i)\n \tTREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n       else\n-\tBINFO_BASEACCESSES (binfo) = BINFO_BASETYPES (binfo) = NULL_TREE;\n+\tBINFO_BASE_ACCESSES (binfo) = BINFO_BASE_BINFOS (binfo) = NULL_TREE;\n       if (max_vbases)\n \tCLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n       \n@@ -9206,7 +9206,7 @@ xref_basetypes (tree ref, tree base_list)\n   /* Unmark all the types.  */\n   while (i--)\n     {\n-      tree basetype = BINFO_TYPE (BINFO_BASETYPE (TYPE_BINFO (ref), i));\n+      tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (ref), i));\n       \n       CLEAR_CLASSTYPE_MARKED (basetype);\n       if (CLASS_TYPE_P (basetype))"}, {"sha": "64a462eb1a77b3cf4ea0360dbd2eccdef112959f", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -268,9 +268,9 @@ cp_dump_tree (void* dump_info, tree t)\n \t{\n \t  int i;\n \t  \n-\t  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n \t    {\n-\t      tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+\t      tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n \t      dump_child (\"base\", BINFO_TYPE (base_binfo));\n \t      if (BINFO_VIRTUAL_P (base_binfo)) \n \t\tdump_string (di, \"virtual\");"}, {"sha": "6d57963040028b03fdf605375348df81710f17be", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1633,7 +1633,7 @@ dump_expr (tree t, int flags)\n \n \t      t = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n \t      t = TYPE_METHOD_BASETYPE (t);\n-\t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n+\t      virtuals = BINFO_VIRTUALS (TYPE_BINFO (TYPE_MAIN_VARIANT (t)));\n \n \t      n = tree_low_cst (idx, 0);\n "}, {"sha": "e899b01f1f47c6eaae36b7ca4afa7da6b5cca084", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -475,9 +475,9 @@ sort_mem_initializers (tree t, tree mem_inits)\n     sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n   \n   /* Process the direct bases.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n     {\n-      base = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      base = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n       if (!BINFO_VIRTUAL_P (base))\n \tsorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n     }\n@@ -941,14 +941,15 @@ expand_member_init (tree name)\n     {\n       /* This is an obsolete unnamed base class initializer.  The\n \t parser will already have warned about its use.  */\n-      switch (CLASSTYPE_N_BASECLASSES (current_class_type))\n+      switch (BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type)))\n \t{\n \tcase 0:\n \t  error (\"unnamed initializer for `%T', which has no base classes\",\n \t\t current_class_type);\n \t  return NULL_TREE;\n \tcase 1:\n-\t  basetype = TYPE_BINFO_BASETYPE (current_class_type, 0);\n+\t  basetype = BINFO_TYPE\n+\t    (BINFO_BASE_BINFO (TYPE_BINFO (current_class_type), 0));\n \t  break;\n \tdefault:\n \t  error (\"unnamed initializer for `%T', which uses multiple inheritance\",\n@@ -981,11 +982,12 @@ expand_member_init (tree name)\n       virtual_binfo = NULL_TREE;\n \n       /* Look for a direct base.  */\n-      for (i = 0; i < BINFO_N_BASETYPES (class_binfo); ++i)\n-\tif (same_type_p (basetype, \n-\t\t\t TYPE_BINFO_BASETYPE (current_class_type, i)))\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (class_binfo); ++i)\n+\tif (same_type_p\n+\t    (basetype, BINFO_TYPE\n+\t     (BINFO_BASE_BINFO (TYPE_BINFO (current_class_type), i))))\n \t  {\n-\t    direct_binfo = BINFO_BASETYPE (class_binfo, i);\n+\t    direct_binfo = BINFO_BASE_BINFO (class_binfo, i);\n \t    break;\n \t  }\n       /* Look for a virtual base -- unless the direct base is itself\n@@ -2910,8 +2912,8 @@ push_base_cleanups (void)\n \t}\n     }\n \n-  binfos = BINFO_BASETYPES (TYPE_BINFO (current_class_type));\n-  n_baseclasses = CLASSTYPE_N_BASECLASSES (current_class_type);\n+  binfos = BINFO_BASE_BINFOS (TYPE_BINFO (current_class_type));\n+  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n \n   /* Take care of the remaining baseclasses.  */\n   for (i = 0; i < n_baseclasses; i++)"}, {"sha": "6acf765cbc5f48eb3f403d6d84a5241f72662cee", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -515,8 +515,8 @@ do_build_copy_constructor (tree fndecl)\n   else\n     {\n       tree fields = TYPE_FIELDS (current_class_type);\n-      int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n-      tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n+      int n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n+      tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (current_class_type));\n       tree member_init_list = NULL_TREE;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n@@ -623,12 +623,14 @@ do_build_assign_ref (tree fndecl)\n       int i;\n \n       /* Assign to each of the direct base classes.  */\n-      for (i = 0; i < CLASSTYPE_N_BASECLASSES (current_class_type); ++i)\n+      for (i = 0;\n+\t   i < BINFO_N_BASE_BINFOS (TYPE_BINFO (current_class_type));\n+\t   ++i)\n \t{\n \t  tree binfo;\n \t  tree converted_parm;\n \n-\t  binfo = BINFO_BASETYPE (TYPE_BINFO (current_class_type), i);\n+\t  binfo = BINFO_BASE_BINFO (TYPE_BINFO (current_class_type), i);\n \t  /* We must convert PARM directly to the base class\n \t     explicitly since the base class may be ambiguous.  */\n \t  converted_parm = build_base_path (PLUS_EXPR, parm, binfo, 1);\n@@ -789,8 +791,8 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n {\n   tree raises = empty_except_spec;\n   tree fields = TYPE_FIELDS (type);\n-  int i, n_bases = CLASSTYPE_N_BASECLASSES (type);\n-  tree binfos = TYPE_BINFO_BASETYPES (type);\n+  int i, n_bases = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+  tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n \n   for (i = 0; i != n_bases; i++)\n     {"}, {"sha": "7c44c8970d89360465ebe0ff1804f5d182722644", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -4313,8 +4313,9 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n     return true;\n   \n   /* Process baseclasses.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n-    if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n+  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+    if (arg_assoc_class\n+\t(k, BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type), i))))\n       return true;\n   \n   /* Process friends.  */"}, {"sha": "20f7a0179f6f8bddbe948d94aaab732b2783965e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -5419,11 +5419,11 @@ instantiate_class_template (tree type)\n     abort ();\n #endif\n \n-  if (BINFO_BASETYPES (pbinfo))\n+  if (BINFO_BASE_BINFOS (pbinfo))\n     {\n       tree base_list = NULL_TREE;\n-      tree pbases = BINFO_BASETYPES (pbinfo);\n-      tree paccesses = BINFO_BASEACCESSES (pbinfo);\n+      tree pbases = BINFO_BASE_BINFOS (pbinfo);\n+      tree paccesses = BINFO_BASE_ACCESSES (pbinfo);\n       tree context = TYPE_CONTEXT (type);\n       bool pop_p;\n       int i;\n@@ -6888,7 +6888,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       \n     case TREE_BINFO:\n       /* A binfo node.  We always need to make a copy, of the node\n-\t itself and of its BINFO_BASETYPES.  */\n+\t itself and of its BINFO_BASE_BINFOS.  */\n       my_friendly_assert (type, 20040628);\n       \n       t = copy_node (t);\n@@ -6899,10 +6899,11 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       TREE_TYPE (t) = complete_type (type);\n       if (IS_AGGR_TYPE (type))\n \t{\n-\t  BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (type);\n-\t  BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (type);\n-\t  if (TYPE_BINFO_BASETYPES (type) != NULL_TREE)\n-\t    BINFO_BASETYPES (t) = copy_node (TYPE_BINFO_BASETYPES (type));\n+\t  BINFO_VTABLE (t) = BINFO_VTABLE (TYPE_BINFO (type));\n+\t  BINFO_VIRTUALS (t) = BINFO_VIRTUALS (TYPE_BINFO (type));\n+\t  if (BINFO_BASE_BINFOS (TYPE_BINFO (type)) != NULL_TREE)\n+\t    BINFO_BASE_BINFOS (t)\n+\t      = copy_node (BINFO_BASE_BINFOS (TYPE_BINFO (type)));\n \t}\n       return t;\n \n@@ -9402,7 +9403,7 @@ get_template_base_recursive (tree tparms,\n \trval = r;\n     }\n \n-  binfos = BINFO_BASETYPES (arg_binfo);\n+  binfos = BINFO_BASE_BINFOS (arg_binfo);\n   n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n   /* Process base types.  */"}, {"sha": "c9eccf2239b407b9afa49ee94d050fac9b8d413a", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -128,7 +128,7 @@ cxx_print_type (FILE *file, tree node, int indent)\n \n   if (TREE_CODE (node) == RECORD_TYPE)\n     {\n-      fprintf (file, \" n_parents %d\", CLASSTYPE_N_BASECLASSES (node));\n+      fprintf (file, \" n_parents %d\", BINFO_N_BASE_BINFOS (TYPE_BINFO (node)));\n       fprintf (file, \" use_template=%d\", CLASSTYPE_USE_TEMPLATE (node));\n       if (CLASSTYPE_INTERFACE_ONLY (node))\n \tfprintf (file, \" interface-only\");"}, {"sha": "c23b186e1780198deb45ee382de1c309235a21d6", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1033,7 +1033,7 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n         }\n       else if (var_desc == si_class_desc_type_node)\n \t{\n-          tree base_binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n+          tree base_binfos = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n \t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n \t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n@@ -1044,9 +1044,9 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n         {\n \t  int hint = class_hint_flags (type);\n \t  tree binfo = TYPE_BINFO (type);\n-          int nbases = BINFO_N_BASETYPES (binfo);\n-          tree base_binfos = BINFO_BASETYPES (binfo);\n-\t  tree base_accesses = BINFO_BASEACCESSES (binfo);\n+          int nbases = BINFO_N_BASE_BINFOS (binfo);\n+          tree base_binfos = BINFO_BASE_BINFOS (binfo);\n+\t  tree base_accesses = BINFO_BASE_ACCESSES (binfo);\n           tree base_inits = NULL_TREE;\n           int ix;\n           \n@@ -1188,13 +1188,13 @@ get_pseudo_ti_desc (tree type)\n \t    cxx_incomplete_type_error (NULL_TREE, type);\n \t  return class_desc_type_node;\n \t}\n-      else if (!CLASSTYPE_N_BASECLASSES (type))\n+      else if (!BINFO_N_BASE_BINFOS (TYPE_BINFO (type)))\n \treturn class_desc_type_node;\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n-\t  tree base_binfos = BINFO_BASETYPES (binfo);\n-\t  tree base_accesses = BINFO_BASEACCESSES (binfo);\n+\t  tree base_binfos = BINFO_BASE_BINFOS (binfo);\n+\t  tree base_accesses = BINFO_BASE_ACCESSES (binfo);\n \t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n \t  int num_bases = TREE_VEC_LENGTH (base_binfos);\n \t  "}, {"sha": "0c9188dfa225bdfcbf077a80b0ed14feaa6ecaac", "filename": "gcc/cp/search.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -185,8 +185,8 @@ lookup_base_r (tree binfo, tree base, base_access access,\n       return found;\n     }\n   \n-  bases = BINFO_BASETYPES (binfo);\n-  accesses = BINFO_BASEACCESSES (binfo);\n+  bases = BINFO_BASE_BINFOS (binfo);\n+  accesses = BINFO_BASE_ACCESSES (binfo);\n   if (!bases)\n     return bk_not_base;\n   \n@@ -363,8 +363,8 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n         }\n     }\n   \n-  binfos = BINFO_BASETYPES (binfo);\n-  accesses = BINFO_BASEACCESSES (binfo);\n+  binfos = BINFO_BASE_BINFOS (binfo);\n+  accesses = BINFO_BASE_ACCESSES (binfo);\n   n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n   for (i = 0; i < n_baselinks; i++)\n     {\n@@ -682,8 +682,8 @@ dfs_access_in_type (tree binfo, void *data)\n \t  \n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n-\t  binfos = BINFO_BASETYPES (binfo);\n-\t  accesses = BINFO_BASEACCESSES (binfo);\n+\t  binfos = BINFO_BASE_BINFOS (binfo);\n+\t  accesses = BINFO_BASE_ACCESSES (binfo);\n \t  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \t  for (i = 0; i < n_baselinks; ++i)\n \t    {\n@@ -759,14 +759,14 @@ access_in_type (tree type, tree decl)\n static tree\n dfs_accessible_queue_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   if (BINFO_MARKED (binfo))\n     return NULL_TREE;\n \n   /* If this class is inherited via private or protected inheritance,\n      then we can't see it, unless we are a friend of the derived class.  */\n-  if (BINFO_BASEACCESS (derived, ix) != access_public_node\n+  if (BINFO_BASE_ACCESS (derived, ix) != access_public_node\n       && !is_friend (BINFO_TYPE (derived), current_scope ()))\n     return NULL_TREE;\n \n@@ -1021,7 +1021,7 @@ struct lookup_field_info {\n static tree\n lookup_field_queue_p (tree derived, int ix, void *data)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n \n   /* Don't look for constructors or destructors in base classes.  */\n@@ -1595,15 +1595,15 @@ bfs_walk (tree binfo,\n       if (rval)\n \tgoto done;\n \n-      n_bases = BINFO_N_BASETYPES (binfo);\n+      n_bases = BINFO_N_BASE_BINFOS (binfo);\n       for (ix = 0; ix != n_bases; ix++)\n \t{\n \t  tree base_binfo;\n \t  \n \t  if (qfn)\n \t    base_binfo = (*qfn) (binfo, ix, data);\n \t  else\n-\t    base_binfo = BINFO_BASETYPE (binfo, ix);\n+\t    base_binfo = BINFO_BASE_BINFO (binfo, ix);\n \t  \n  \t  if (base_binfo)\n \t    {\n@@ -1657,17 +1657,17 @@ dfs_walk_real (tree binfo,\n     }\n \n   /* Process the basetypes.  */\n-  if (BINFO_BASETYPES (binfo))\n+  if (BINFO_BASE_BINFOS (binfo))\n     {\n-      int i, n = TREE_VEC_LENGTH (BINFO_BASETYPES (binfo));\n+      int i, n = TREE_VEC_LENGTH (BINFO_BASE_BINFOS (binfo));\n       for (i = 0; i != n; i++)\n \t{\n \t  tree base_binfo;\n       \n \t  if (qfn)\n \t    base_binfo = (*qfn) (binfo, i, data);\n \t  else\n-\t    base_binfo = BINFO_BASETYPE (binfo, i);\n+\t    base_binfo = BINFO_BASE_BINFO (binfo, i);\n \t  \n \t  if (base_binfo)\n \t    {\n@@ -1806,7 +1806,7 @@ int\n look_for_overrides (tree type, tree fndecl)\n {\n   tree binfo = TYPE_BINFO (type);\n-  tree basebinfos = BINFO_BASETYPES (binfo);\n+  tree basebinfos = BINFO_BASE_BINFOS (binfo);\n   int nbasebinfos = basebinfos ? TREE_VEC_LENGTH (basebinfos) : 0;\n   int ix;\n   int found = 0;\n@@ -1959,23 +1959,23 @@ get_pure_virtuals (tree type)\n tree \n markedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n tree\n unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   return !BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n static tree\n marked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   return (!BINFO_DEPENDENT_BASE_P (binfo)\n \t  && BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE; \n@@ -1984,7 +1984,7 @@ marked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n static tree\n unmarked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n { \n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   return (!BINFO_DEPENDENT_BASE_P (binfo)\n \t  && !BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE;\n@@ -2067,7 +2067,7 @@ dfs_debug_mark (tree binfo, void *data ATTRIBUTE_UNUSED)\n static tree \n dfs_debug_unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   \n   return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n \t  ? binfo : NULL_TREE);\n@@ -2415,14 +2415,14 @@ dfs_check_overlap (tree empty_binfo, void *data)\n   tree binfo;\n   for (binfo = TYPE_BINFO (oi->compare_type); \n        ; \n-       binfo = BINFO_BASETYPE (binfo, 0))\n+       binfo = BINFO_BASE_BINFO (binfo, 0))\n     {\n       if (BINFO_TYPE (binfo) == BINFO_TYPE (empty_binfo))\n \t{\n \t  oi->found_overlap = 1;\n \t  break;\n \t}\n-      else if (BINFO_BASETYPES (binfo) == NULL_TREE)\n+      else if (BINFO_BASE_BINFOS (binfo) == NULL_TREE)\n \tbreak;\n     }\n \n@@ -2434,7 +2434,7 @@ dfs_check_overlap (tree empty_binfo, void *data)\n static tree\n dfs_no_overlap_yet (tree derived, int ix, void *data)\n {\n-  tree binfo = BINFO_BASETYPE (derived, ix);\n+  tree binfo = BINFO_BASE_BINFO (derived, ix);\n   struct overlap_info *oi = (struct overlap_info *) data;\n   \n   return !oi->found_overlap ? binfo : NULL_TREE;\n@@ -2466,8 +2466,8 @@ tree\n binfo_for_vtable (tree var)\n {\n   tree main_binfo = TYPE_BINFO (DECL_CONTEXT (var));\n-  tree binfos = TYPE_BINFO_BASETYPES (BINFO_TYPE (main_binfo));\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (BINFO_TYPE (main_binfo));\n+  tree binfos = BINFO_BASE_BINFOS (TYPE_BINFO (BINFO_TYPE (main_binfo)));\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (BINFO_TYPE (main_binfo)));\n   int i;\n \n   for (i = 0; i < n_baseclasses; i++)\n@@ -2540,7 +2540,7 @@ copied_binfo (tree binfo, tree here)\n       int ix, n;\n       \n       base_binfos = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n-      base_binfos = BINFO_BASETYPES (base_binfos);\n+      base_binfos = BINFO_BASE_BINFOS (base_binfos);\n       n = TREE_VEC_LENGTH (base_binfos);\n       for (ix = 0; ix != n; ix++)\n \t{\n@@ -2601,7 +2601,7 @@ original_binfo (tree binfo, tree here)\n \t{\n \t  int ix, n;\n \t  \n-\t  base_binfos = BINFO_BASETYPES (base_binfos);\n+\t  base_binfos = BINFO_BASE_BINFOS (base_binfos);\n \t  n = TREE_VEC_LENGTH (base_binfos);\n \t  for (ix = 0; ix != n; ix++)\n \t    {"}, {"sha": "35679eb5215f2171ee7b5bda02db16577a8b3b24", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -584,7 +584,7 @@ canonical_type_variant (tree t)\n tree\n copy_base_binfos (tree binfo, tree t, tree prev)\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n+  tree binfos = BINFO_BASE_BINFOS (binfo);\n   int n, ix;\n \n   if (prev)\n@@ -792,11 +792,11 @@ make_binfo (tree offset, tree binfo, tree vtable, tree virtuals)\n   BINFO_VIRTUALS (new_binfo) = virtuals;\n \n   if (binfo && !BINFO_DEPENDENT_BASE_P (binfo)\n-      && BINFO_BASETYPES (binfo) != NULL_TREE)\n+      && BINFO_BASE_BINFOS (binfo) != NULL_TREE)\n     {\n-      BINFO_BASETYPES (new_binfo) = copy_node (BINFO_BASETYPES (binfo));\n+      BINFO_BASE_BINFOS (new_binfo) = copy_node (BINFO_BASE_BINFOS (binfo));\n       /* We do not need to copy the accesses, as they are read only.  */\n-      BINFO_BASEACCESSES (new_binfo) = BINFO_BASEACCESSES (binfo);\n+      BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (binfo);\n     }\n   return new_binfo;\n }"}, {"sha": "1588cbceebe27be87d794f1d8397c51640396d1d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1143,10 +1143,11 @@ common_base_type (tree tt1, tree tt2)\n \n   /* Otherwise, try to find a unique baseclass of TT1\n      that is shared by TT2, and follow that down.  */\n-  for (i = CLASSTYPE_N_BASECLASSES (tt1)-1; i >= 0; i--)\n+  for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (tt1))-1; i >= 0; i--)\n     {\n-      tree basetype = TYPE_BINFO_BASETYPE (tt1, i);\n+      tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (tt1), i));\n       tree trial = common_base_type (basetype, tt2);\n+      \n       if (trial)\n \t{\n \t  if (trial == error_mark_node)\n@@ -1159,10 +1160,11 @@ common_base_type (tree tt1, tree tt2)\n     }\n \n   /* Same for TT2.  */\n-  for (i = CLASSTYPE_N_BASECLASSES (tt2)-1; i >= 0; i--)\n+  for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (tt2))-1; i >= 0; i--)\n     {\n-      tree basetype = TYPE_BINFO_BASETYPE (tt2, i);\n+      tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (tt2), i));\n       tree trial = common_base_type (tt1, basetype);\n+      \n       if (trial)\n \t{\n \t  if (trial == error_mark_node)"}, {"sha": "5ddfdd5bcee764c1b84d3f4f15f65b00df090189", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -804,7 +804,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (TYPE_BINFO_BASETYPES (type))\n+\t  if (BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n \t    {\n \t      sorry (\"initializer list for object of class with base classes\");\n \t      return error_mark_node;"}, {"sha": "aa863bda031dad16121fc9bcfb49dbe76b8b75ee", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1635,9 +1635,8 @@ dbxout_type (tree type, int full)\n       {\n \tint i, n_baseclasses = 0;\n \n-\tif (TYPE_BINFO (type) != 0\n-\t    && TYPE_BINFO_BASETYPES (type) != 0)\n-\t  n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));\n+\tif (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t  n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n \n \t/* Output a structure type.  We must use the same test here as we\n \t   use in the DBX_NO_XREFS case above.  */\n@@ -1696,9 +1695,9 @@ dbxout_type (tree type, int full)\n \tfor (i = 0; i < n_baseclasses; i++)\n \t  {\n \t    tree binfo = TYPE_BINFO (type);\n-\t    tree child = BINFO_BASETYPE (binfo, i);\n-\t    tree access = (BINFO_BASEACCESSES (binfo)\n-\t\t\t   ? BINFO_BASEACCESS (binfo, i) : access_public_node);\n+\t    tree child = BINFO_BASE_BINFO (binfo, i);\n+\t    tree access = (BINFO_BASE_ACCESSES (binfo)\n+\t\t\t   ? BINFO_BASE_ACCESS (binfo, i) : access_public_node);\n \n \t    if (use_gnu_debug_info_extensions)\n \t      {"}, {"sha": "48994856bcc2f94373e005b57887a064e7b864e9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -11891,10 +11891,10 @@ gen_member_die (tree type, dw_die_ref context_die)\n      the TREE node representing the appropriate (containing) type.  */\n \n   /* First output info about the base classes.  */\n-  if (binfo && BINFO_BASETYPES (binfo))\n+  if (binfo && BINFO_BASE_BINFOS (binfo))\n     {\n-      tree bases = BINFO_BASETYPES (binfo);\n-      tree accesses = BINFO_BASEACCESSES (binfo);\n+      tree bases = BINFO_BASE_BINFOS (binfo);\n+      tree accesses = BINFO_BASE_ACCESSES (binfo);\n       int n_bases = TREE_VEC_LENGTH (bases);\n       int i;\n "}, {"sha": "46251af7cfd1fd9a9279922737ab35b657e28974", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1,3 +1,22 @@\n+2004-07-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* java-tree.h (CLASSTYPE_SPUER): Adjust BINFO macros.\n+\t(TYPE_NVIRTUALS, TYPE_VTABLE): Likewise.\n+\t* java/class.c (set_super_info, class_depth, interface_of_p,\n+\tmaybe_add_interface, add_interface, make_class_data,\n+\tlayout_class, add_miranda_methods): Adjust BINFO macros.\n+\t* expr.c (can_widen_reference_to, lookup_field): Likewise.\n+\t* jcf-write.c (generate_classfile): Likewise.\n+\t* parse.y (patch_anonymous_class,\n+\tcheck_inner_circular_reference, check_circular_reference,\n+\tjava_complete_class, check_abstract_method_definitions,\n+\tjava_check_abstract_method_definitions,\n+\tcheck_interface_throws_clauses, java_check_abstract_methods,\n+\tlookup_java_interface_method2,\n+\tfind_applicable_accessible_methods_list): Likewise.\n+\t* typeck.c (find_method_in_interface): Likewise.\n+\t* verify.c (merge_types): Likewise.\n+\n 2004-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* java-tree.h (CLASS_HAS_SUPER_FLAG): Use BINFO_FLAG_1."}, {"sha": "48f6b8609cab68b58316ac1c5b8ce5c4f1a1ca2b", "filename": "gcc/java/class.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -477,13 +477,13 @@ set_super_info (int access_flags, tree this_class,\n     total_supers++;\n \n   TYPE_VFIELD (this_class) = TYPE_VFIELD (object_type_node);\n-  TYPE_BINFO_BASETYPES (this_class) = make_tree_vec (total_supers);\n+  BINFO_BASE_BINFOS (TYPE_BINFO (this_class)) = make_tree_vec (total_supers);\n   if (super_class)\n     {\n       tree super_binfo = make_tree_binfo (0);\n       BINFO_TYPE (super_binfo) = super_class;\n       BINFO_OFFSET (super_binfo) = integer_zero_node;\n-      TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (this_class)), 0)\n+      TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (this_class)), 0)\n \t= super_binfo;\n       CLASS_HAS_SUPER (this_class) = 1;\n     }\n@@ -519,7 +519,7 @@ class_depth (tree clas)\n   while (clas != object_type_node)\n     {\n       depth++;\n-      clas = TYPE_BINFO_BASETYPE (clas, 0);\n+      clas = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (clas), 0));\n     }\n   return depth;\n }\n@@ -532,7 +532,7 @@ interface_of_p (tree type1, tree type2)\n   int n, i;\n   tree basetype_vec;\n \n-  if (!(basetype_vec = TYPE_BINFO_BASETYPES (type2)))\n+  if (!(basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (type2))))\n     return 0;\n   n = TREE_VEC_LENGTH (basetype_vec);\n   for (i = 0; i < n; i++)\n@@ -627,7 +627,7 @@ add_interface_do (tree basetype_vec, tree interface_class, int i)\n tree\n maybe_add_interface (tree this_class, tree interface_class)\n {\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n   int i;\n   int n = TREE_VEC_LENGTH (basetype_vec);\n   for (i = 0; ; i++)\n@@ -651,7 +651,7 @@ maybe_add_interface (tree this_class, tree interface_class)\n void\n add_interface (tree this_class, tree interface_class)\n {\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n   int i;\n   int n = TREE_VEC_LENGTH (basetype_vec);\n   for (i = 0; ; i++)\n@@ -1627,7 +1627,8 @@ make_class_data (tree type)\n \n   /* Build and emit the array of implemented interfaces. */\n   if (type != object_type_node)\n-      interface_len = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)) - 1;\n+    interface_len = BINFO_N_BASE_BINFOS (TYPE_BINFO (type)) - 1;\n+  \n   if (interface_len > 0)\n     {\n       tree init = NULL_TREE;\n@@ -1639,7 +1640,7 @@ make_class_data (tree type)\n \t\t\t  interface_array_type);\n       for (i = interface_len;  i > 0; i--)\n \t{\n-\t  tree child = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n+\t  tree child = TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (type)), i);\n \t  tree iclass = BINFO_TYPE (child);\n \t  tree index;\n \t  if (! flag_indirect_dispatch\n@@ -2032,7 +2033,7 @@ layout_class (tree this_class)\n      of this itself.  */\n   if (!CLASS_FROM_SOURCE_P (this_class))\n     {\n-      tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n+      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (this_class));\n \n       if (basetype_vec)\n \t{\n@@ -2068,7 +2069,7 @@ layout_class (tree this_class)\n static void\n add_miranda_methods (tree base_class, tree search_class)\n {\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (search_class);\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (search_class));\n   int i, n = TREE_VEC_LENGTH (basetype_vec);\n   for (i = 1; i < n; ++i)\n     {"}, {"sha": "f2df129bdda99a053fda7cb0aa3e86ff021a195a", "filename": "gcc/java/expr.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -427,7 +427,7 @@ can_widen_reference_to (tree source_type, tree target_type)\n \t      /* target_type is OK if source_type or source_type ancestors\n \t\t implement target_type. We handle multiple sub-interfaces  */\n \n-\t      tree basetype_vec = TYPE_BINFO_BASETYPES (source_type);\n+\t      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (source_type));\n \t      int n = TREE_VEC_LENGTH (basetype_vec), i;\n \t      for (i=0 ; i < n; i++)\n \t        if (can_widen_reference_to \n@@ -440,7 +440,8 @@ can_widen_reference_to (tree source_type, tree target_type)\n \n \t  for ( ; source_depth > target_depth;  source_depth--) \n \t    {\n-\t      source_type = TYPE_BINFO_BASETYPE (source_type, 0); \n+\t      source_type\n+\t\t= BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (source_type), 0));\n \t    }\n \t  return source_type == target_type;\n \t}\n@@ -1466,7 +1467,7 @@ lookup_field (tree *typep, tree name)\n \t  return field;\n \n       /* Process implemented interfaces. */\n-      basetype_vec = TYPE_BINFO_BASETYPES (*typep);\n+      basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (*typep));\n       n = TREE_VEC_LENGTH (basetype_vec);\n       save_field = NULL_TREE;\n       for (i = 0; i < n; i++)"}, {"sha": "a07f5752f65c330ff5774b033879ac87080248c9", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -125,8 +125,9 @@ struct JCF;\n #define CLASS_HAS_SUPER(TYPE) CLASS_HAS_SUPER_FLAG (TYPE_BINFO (TYPE))\n \n /* Return the supertype of class TYPE, or NULL_TREE is it has none. */\n-#define CLASSTYPE_SUPER(TYPE) (CLASS_HAS_SUPER (TYPE) ? \\\n-  BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (TYPE), 0)) : NULL_TREE)\n+#define CLASSTYPE_SUPER(TYPE) (CLASS_HAS_SUPER (TYPE) \\\n+  ? BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (TYPE), 0)) \\\n+  : NULL_TREE)\n \n /* True if the class we are compiling is a .java source file;\n    false if it is a .class bytecode file. */\n@@ -1433,11 +1434,11 @@ extern int in_same_package (tree, tree);\n /* The number of virtual methods in this class's dispatch table.\n    Does not include initial two dummy entries (one points to the\n    Class object, and the other is for G++ -fvtable-thunks compatibility). */\n-#define TYPE_NVIRTUALS(TYPE) TYPE_BINFO_VIRTUALS (TYPE)\n+#define TYPE_NVIRTUALS(TYPE) BINFO_VIRTUALS (TYPE_BINFO (TYPE))\n \n /* A TREE_VEC (indexed by DECL_VINDEX) containing this class's\n    virtual methods. */\n-#define TYPE_VTABLE(TYPE) TYPE_BINFO_VTABLE(TYPE)\n+#define TYPE_VTABLE(TYPE) BINFO_VTABLE(TYPE_BINFO (TYPE))\n \n /* Use CLASS_LOADED_P? FIXME */\n #define CLASS_COMPLETE_P(DECL) DECL_LANG_FLAG_2 (DECL) "}, {"sha": "c95df1eb561b43c2a5e403e02c6c2527b1fb531b", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -2921,8 +2921,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n   int methods_count = 0;\n   tree part;\n   int total_supers\n-    = clas == object_type_node ? 0\n-    : TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (clas));\n+    = clas == object_type_node ? 0 : BINFO_N_BASE_BINFOS (TYPE_BINFO (clas));\n   \n   ptr = append_chunk (NULL, 8, state);\n   PUT4 (0xCafeBabe);  /* Magic number */\n@@ -2948,7 +2947,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n     }\n   else\n     {\n-      tree basetypes = TYPE_BINFO_BASETYPES (clas);\n+      tree basetypes = BINFO_BASE_BINFOS (TYPE_BINFO (clas));\n       tree base = BINFO_TYPE (TREE_VEC_ELT (basetypes, 0));\n       int j = find_class_constant (&state->cpool, base);\n       PUT2 (j);  /* super_class */"}, {"sha": "3df330d3c253108f621b63ef0be95e190882b791", "filename": "gcc/java/parse.y", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -3889,10 +3889,10 @@ patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n       if (parser_check_super_interface (type_decl, class_decl, wfl))\n \treturn;\n \n-      s_binfo = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (class)), 0);\n-      length = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (class))+1;\n-      TYPE_BINFO_BASETYPES (class) = make_tree_vec (length);\n-      TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (class)), 0) = s_binfo;\n+      s_binfo = TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (class)), 0);\n+      length = TREE_VEC_LENGTH (BINFO_BASE_BINFOS (TYPE_BINFO (class)))+1;\n+      BINFO_BASE_BINFOS (TYPE_BINFO (class)) = make_tree_vec (length);\n+      TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (class)), 0) = s_binfo;\n       /* And add the interface */\n       parser_add_interface (class_decl, type_decl, wfl);\n     }\n@@ -3901,7 +3901,7 @@ patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n     {\n       if (parser_check_super (type_decl, class_decl, wfl))\n \treturn;\n-      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo), 0)) = type;\n+      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASE_BINFOS (binfo), 0)) = type;\n     }\n }\n \n@@ -5214,7 +5214,7 @@ register_incomplete_type (int kind, tree wfl, tree decl, tree ptr)\n static tree\n check_inner_circular_reference (tree source, tree target)\n {\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (source);\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (source));\n   tree ctx, cl;\n   int i;\n \n@@ -5260,7 +5260,7 @@ check_inner_circular_reference (tree source, tree target)\n static tree\n check_circular_reference (tree type)\n {\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (type);\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n   int i;\n \n   if (!basetype_vec)\n@@ -5569,7 +5569,7 @@ java_complete_class (void)\n \t      /* Simply patch super */\n \t      if (parser_check_super (decl, JDEP_DECL (dep), JDEP_WFL (dep)))\n \t\tcontinue;\n-\t      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO\n+\t      BINFO_TYPE (TREE_VEC_ELT (BINFO_BASE_BINFOS (TYPE_BINFO\n \t        (TREE_TYPE (JDEP_DECL (dep)))), 0)) = TREE_TYPE (decl);\n \t      break;\n \n@@ -6198,7 +6198,7 @@ check_abstract_method_definitions (int do_interface, tree class_decl,\n     {\n       /* Check for implemented interfaces. */\n       int i;\n-      tree vector = TYPE_BINFO_BASETYPES (type);\n+      tree vector = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n       for (i = 1; ok && vector && i < TREE_VEC_LENGTH (vector); i++)\n \t{\n \t  tree super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n@@ -6230,7 +6230,7 @@ java_check_abstract_method_definitions (tree class_decl)\n   } while (super != object_type_node);\n \n   /* Check for implemented interfaces. */\n-  vector = TYPE_BINFO_BASETYPES (class);\n+  vector = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n   for (i = 1; i < TREE_VEC_LENGTH (vector); i++)\n     {\n       super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n@@ -6505,7 +6505,7 @@ check_interface_throws_clauses (tree check_class_decl, tree class_decl)\n \t    load_class (class_decl, 1);\n \t}\n \n-      bases = TYPE_BINFO_BASETYPES (class_decl);\n+      bases = BINFO_BASE_BINFOS (TYPE_BINFO (class_decl));\n       iface_len = TREE_VEC_LENGTH (bases) - 1;\n       for (i = iface_len; i > 0; --i)\n \t{\n@@ -6637,7 +6637,7 @@ java_check_abstract_methods (tree interface_decl)\n     }\n \n   /* 4- Inherited methods can't differ by their returned types */\n-  if (!(basetype_vec = TYPE_BINFO_BASETYPES (interface)))\n+  if (!(basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (interface))))\n     return;\n   n = TREE_VEC_LENGTH (basetype_vec);\n   for (i = 0; i < n; i++)\n@@ -6677,7 +6677,8 @@ static tree\n lookup_java_interface_method2 (tree class, tree method_decl)\n {\n   int i, n;\n-  tree basetype_vec = TYPE_BINFO_BASETYPES (class), to_return;\n+  tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n+  tree to_return;\n \n   if (!basetype_vec)\n     return NULL_TREE;\n@@ -11023,7 +11024,7 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n       && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n       int i, n;\n-      tree basetype_vec = TYPE_BINFO_BASETYPES (class);\n+      tree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n       search_applicable_methods_list (lc, TYPE_METHODS (class),\n \t\t\t\t      name, arglist, &list, &all_list);\n       n = TREE_VEC_LENGTH (basetype_vec);\n@@ -11056,7 +11057,7 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n       /* We must search all interfaces of this class */\n       if (!lc)\n       {\n-\ttree basetype_vec = TYPE_BINFO_BASETYPES (class);\n+\ttree basetype_vec = BINFO_BASE_BINFOS (TYPE_BINFO (class));\n \tint n = TREE_VEC_LENGTH (basetype_vec), i;\n \tfor (i = 1; i < n; i++)\n \t  {"}, {"sha": "8cfe5e4d3bee23e27fb759fe9b1bcc9426e56424", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -797,12 +797,11 @@ find_method_in_interfaces (tree searched_class, int flags, tree method_name,\n {\n   int i;\n   int interface_len = \n-    TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (searched_class)) - 1;\n+    TREE_VEC_LENGTH (BINFO_BASE_BINFOS (TYPE_BINFO (searched_class))) - 1;\n \n   for (i = interface_len; i > 0; i--)\n     {\n-      tree child = \n-\tTREE_VEC_ELT (TYPE_BINFO_BASETYPES (searched_class), i);\n+      tree child = BINFO_BASE_BINFO (TYPE_BINFO (searched_class), i);\n       tree iclass = BINFO_TYPE (child);\n       tree method;\n \t  "}, {"sha": "84824694032632407a29fe7f48348ca55be73e32", "filename": "gcc/java/verify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -226,13 +226,13 @@ merge_types (tree type1, tree type2)\n       depth1 = class_depth (type1);\n       depth2 = class_depth (type2);\n       for ( ; depth1 > depth2;  depth1--)\n-\ttype1 = TYPE_BINFO_BASETYPE (type1, 0);\n+\ttype1 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type1), 0));\n       for ( ; depth2 > depth1;  depth2--)\n-\ttype2 = TYPE_BINFO_BASETYPE (type2, 0);\n+\ttype2 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type2), 0));\n       while (type1 != type2)\n \t{\n-\t  type1 = TYPE_BINFO_BASETYPE (type1, 0);\n-\t  type2 = TYPE_BINFO_BASETYPE (type2, 0);\n+\t  type1 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type1), 0));\n+\t  type2 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type2), 0));\n \t}\n       return promote_type (type1);\n     }"}, {"sha": "0398a5ad32bb2ef8b5fdb30aae1fb568aa69bf20", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -1151,13 +1151,12 @@ sdbout_one_type (tree type)\n \t   case.  */\n \tif (TREE_CODE (type) != ENUMERAL_TYPE)\n \t  {\n-\t    if (TYPE_BINFO (type)\n-\t\t&& TYPE_BINFO_BASETYPES (type))\n-\t      n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));\n+\t    if (TYPE_BINFO (type) && BINFO_BASE_BINFOS (TYPE_BINFO (type)))\n+\t      n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t    \n \t    for (i = 0; i < n_baseclasses; i++)\n \t      {\n-\t\ttree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)),\n-\t\t\t\t\t   i);\n+\t\ttree child = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t\ttree child_type = BINFO_TYPE (child);\n \t\ttree child_type_name;\n \t\tif (TYPE_NAME (child_type) == 0)"}, {"sha": "659531f0300dbc3c1602ad0dc2d137e0a2c7c9cf", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -251,9 +251,9 @@ dequeue_and_dump (dump_info_p di)\n   if (dni->binfo_p)\n     {\n       unsigned ix;\n-      tree bases = BINFO_BASETYPES (t);\n+      tree bases = BINFO_BASE_BINFOS (t);\n       unsigned n_bases = bases ? TREE_VEC_LENGTH (bases): 0;\n-      tree accesses = BINFO_BASEACCESSES (t);\n+      tree accesses = BINFO_BASE_ACCESSES (t);\n \n       dump_child (\"type\", BINFO_TYPE (t));\n "}, {"sha": "ab22cda92b1b5315a052154952153b99d09d541d", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604a320594b012c8d2cda2fc5d2bbd3230d034b1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=604a320594b012c8d2cda2fc5d2bbd3230d034b1", "patch": "@@ -202,7 +202,7 @@ struct tree_common GTY(())\n \n        TREE_STATIC in\n            VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n-       TREE_VIA_VIRTUAL in\n+       BINFO_VIRTUAL_P in\n            TREE_BINFO\n        TREE_CONSTANT_OVERFLOW in\n            INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n@@ -1616,21 +1616,18 @@ struct tree_type GTY(())\n    This is always 0 except when there is multiple inheritance.  */\n \n #define BINFO_OFFSET(NODE) (TREE_BINFO_CHECK(NODE)->binfo.offset)\n-#define TYPE_BINFO_OFFSET(NODE) BINFO_OFFSET (TYPE_BINFO (NODE))\n #define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))\n \n /* The virtual function table belonging to this basetype.  Virtual\n    function tables provide a mechanism for run-time method dispatching.\n    The entries of a virtual function table are language-dependent.  */\n \n #define BINFO_VTABLE(NODE) (TREE_BINFO_CHECK(NODE)->binfo.vtable)\n-#define TYPE_BINFO_VTABLE(NODE) BINFO_VTABLE (TYPE_BINFO (NODE))\n \n /* The virtual functions in the virtual function table.  This is\n    a TREE_LIST that is used as an initial approximation for building\n    a virtual function table for this basetype.  */\n #define BINFO_VIRTUALS(NODE) (TREE_BINFO_CHECK(NODE)->binfo.virtuals)\n-#define TYPE_BINFO_VIRTUALS(NODE) BINFO_VIRTUALS (TYPE_BINFO (NODE))\n \n /* A vector of binfos for the direct basetypes inherited by this\n    basetype.\n@@ -1643,17 +1640,14 @@ struct tree_type GTY(())\n    base types at the end of this TREE_VEC (instead of using\n    another TREE_VEC).  This would simplify the calculation\n    of how many basetypes a given type had.  */\n-#define BINFO_BASETYPES(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_types)\n-#define TYPE_BINFO_BASETYPES(NODE) BINFO_BASETYPES (TYPE_BINFO (NODE))\n+#define BINFO_BASE_BINFOS(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_binfos)\n \n /* The number of basetypes for NODE.  */\n-#define BINFO_N_BASETYPES(NODE) \\\n-  (BINFO_BASETYPES (NODE) ? TREE_VEC_LENGTH (BINFO_BASETYPES (NODE)) : 0)\n+#define BINFO_N_BASE_BINFOS(NODE) \\\n+  (BINFO_BASE_BINFOS (NODE) ? TREE_VEC_LENGTH (BINFO_BASE_BINFOS (NODE)) : 0)\n \n-/* Accessor macro to get to the Nth basetype of this basetype.  */\n-#define BINFO_BASETYPE(NODE,N) TREE_VEC_ELT (BINFO_BASETYPES (NODE), (N))\n-#define TYPE_BINFO_BASETYPE(NODE,N) \\\n-  BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n+/* Accessor macro to get to the Nth base binfo of this binfo.  */\n+#define BINFO_BASE_BINFO(NODE,N) TREE_VEC_ELT (BINFO_BASE_BINFOS (NODE), (N))\n \n /* For a BINFO record describing a virtual base class, i.e., one where\n    TREE_VIA_VIRTUAL is set, this field assists in locating the virtual\n@@ -1665,25 +1659,17 @@ struct tree_type GTY(())\n /* Indicates the accesses this binfo has to its bases. The values are\n    access_public_node, access_protected_node or access_private_node.\n    If this array is not present, public access is implied.  */\n-#define BINFO_BASEACCESSES(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_accesses)\n-#define BINFO_BASEACCESS(NODE,N) TREE_VEC_ELT (BINFO_BASEACCESSES(NODE), (N))\n+#define BINFO_BASE_ACCESSES(NODE) (TREE_BINFO_CHECK(NODE)->binfo.base_accesses)\n+#define BINFO_BASE_ACCESS(NODE,N) TREE_VEC_ELT (BINFO_BASE_ACCESSES(NODE), (N))\n \n /* Number of language independent elements in a binfo.  Languages may\n    add additional trailing elements.  */\n \n #define BINFO_LANG_SLOT(NODE,N) (TREE_BINFO_CHECK(NODE)->binfo.lang_slots[N])\n \n-/* Slot used to build a chain that represents a use of inheritance.\n-   For example, if X is derived from Y, and Y is derived from Z,\n-   then this field can be used to link the binfo node for X to\n-   the binfo node for X's Y to represent the use of inheritance\n-   from X to Y.  Similarly, this slot of the binfo node for X's Y\n-   can point to the Z from which Y is inherited (in X's inheritance\n-   hierarchy).  In this fashion, one can represent and traverse specific\n-   uses of inheritance using the binfo nodes themselves (instead of\n-   consing new space pointing to binfo nodes).\n-   It is up to the language-dependent front-ends to maintain\n-   this information as necessary.  */\n+/* The BINFO_INHERITANCE_CHAIN points at the binfo for the base\n+   inheriting this base for non-virtual bases. For virtual bases it\n+   points to the binfo of the most derived type.  */\n #define BINFO_INHERITANCE_CHAIN(NODE) \\\n \t(TREE_BINFO_CHECK(NODE)->binfo.inheritance)\n \n@@ -1694,7 +1680,7 @@ struct tree_binfo GTY (())\n   tree offset;\n   tree vtable;\n   tree virtuals;\n-  tree base_types;\n+  tree base_binfos;\n   tree vptr_field;\n   tree base_accesses;\n   tree inheritance;"}]}