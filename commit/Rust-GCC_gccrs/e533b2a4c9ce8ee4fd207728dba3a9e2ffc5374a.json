{"sha": "e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUzM2IyYTRjOWNlOGVlNGZkMjA3NzI4ZGJhM2E5ZTJmZmM1Mzc0YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-03-25T00:52:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-03-25T00:52:40Z"}, "message": "alpha: Use byte-manipulation helper expanders more often.\n\nFrom-SVN: r171439", "tree": {"sha": "59dbfdc6212c7805c5fd719c4d6198af92e69d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59dbfdc6212c7805c5fd719c4d6198af92e69d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a/comments", "author": null, "committer": null, "parents": [{"sha": "0b2a73678bb58b1c91ae7ee93e3ddfff1830baf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2a73678bb58b1c91ae7ee93e3ddfff1830baf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2a73678bb58b1c91ae7ee93e3ddfff1830baf8"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "0ba43047d8bd270ab3e1f7d412561931df5bdf21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "patch": "@@ -1,3 +1,11 @@\n+2011-02-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_expand_unaligned_load): Use extql.\n+\t(alpha_expand_unaligned_store): Use mskwl, mskll, mskql.\n+\t(alpha_expand_unaligned_load_words): Use extql.\n+\t(alpha_expand_unaligned_store_words): Use insqh, mskqh, mskql.\n+\t(emit_insxl): Handle all modes for consistency.\n+\n 2011-02-24  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (get_aligned_mem): Don't test WORDS_BIG_ENDIAN."}, {"sha": "c55587b217ff3942d983fbea6bd6570cd0c91aff", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e533b2a4c9ce8ee4fd207728dba3a9e2ffc5374a", "patch": "@@ -3347,7 +3347,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n     {\n       emit_move_insn (addr, plus_constant (mema, ofs+2));\n \n-      emit_insn (gen_extxl (extl, meml, GEN_INT (64), addr));\n+      emit_insn (gen_extql (extl, meml, addr));\n       emit_insn (gen_extqh (exth, memh, addr));\n \n       /* We must use tgt here for the target.  Alpha-vms port fails if we use\n@@ -3367,17 +3367,14 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \t  emit_insn (gen_extwh (exth, memh, addr));\n \t  mode = HImode;\n \t  break;\n-\n \tcase 4:\n \t  emit_insn (gen_extlh (exth, memh, addr));\n \t  mode = SImode;\n \t  break;\n-\n \tcase 8:\n \t  emit_insn (gen_extqh (exth, memh, addr));\n \t  mode = DImode;\n \t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -3475,16 +3472,13 @@ alpha_expand_unaligned_store (rtx dst, rtx src,\n   switch ((int) size)\n     {\n     case 2:\n-      emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffff), addr));\n+      emit_insn (gen_mskwl (dstl, dstl, addr));\n       break;\n     case 4:\n-      {\n-\trtx msk = immed_double_const (0xffffffff, 0, DImode);\n-\temit_insn (gen_mskxl (dstl, dstl, msk, addr));\n-\tbreak;\n-      }\n+      emit_insn (gen_mskll (dstl, dstl, addr));\n+      break;\n     case 8:\n-      emit_insn (gen_mskxl (dstl, dstl, constm1_rtx, addr));\n+      emit_insn (gen_mskql (dstl, dstl, addr));\n       break;\n     default:\n       gcc_unreachable ();\n@@ -3516,7 +3510,6 @@ alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n \t\t\t\t   HOST_WIDE_INT words, HOST_WIDE_INT ofs)\n {\n   rtx const im8 = GEN_INT (-8);\n-  rtx const i64 = GEN_INT (64);\n   rtx ext_tmps[MAX_MOVE_WORDS], data_regs[MAX_MOVE_WORDS+1];\n   rtx sreg, areg, tmp, smema;\n   HOST_WIDE_INT i;\n@@ -3563,7 +3556,7 @@ alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n \t\t       1, OPTAB_WIDEN);\n   for (i = 0; i < words; ++i)\n     {\n-      emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, sreg));\n+      emit_insn (gen_extql (data_regs[i], data_regs[i], sreg));\n       emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], sreg));\n       emit_insn (gen_rtx_SET (VOIDmode, ext_tmps[i],\n \t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n@@ -3588,7 +3581,6 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n \t\t\t\t    HOST_WIDE_INT words, HOST_WIDE_INT ofs)\n {\n   rtx const im8 = GEN_INT (-8);\n-  rtx const i64 = GEN_INT (64);\n   rtx ins_tmps[MAX_MOVE_WORDS];\n   rtx st_tmp_1, st_tmp_2, dreg;\n   rtx st_addr_1, st_addr_2, dmema;\n@@ -3628,7 +3620,7 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n     {\n       for (i = words-1; i >= 0; --i)\n \t{\n-\t  emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dreg));\n+\t  emit_insn (gen_insqh (ins_tmps[i], data_regs[i], dreg));\n \t  emit_insn (gen_insql (data_regs[i], data_regs[i], dreg));\n \t}\n       for (i = words-1; i > 0; --i)\n@@ -3640,8 +3632,8 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n     }\n \n   /* Split and merge the ends with the destination data.  */\n-  emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dreg));\n-  emit_insn (gen_mskxl (st_tmp_1, st_tmp_1, constm1_rtx, dreg));\n+  emit_insn (gen_mskqh (st_tmp_2, st_tmp_2, dreg));\n+  emit_insn (gen_mskql (st_tmp_1, st_tmp_1, dreg));\n \n   if (data_regs != NULL)\n     {\n@@ -4311,12 +4303,24 @@ emit_insxl (enum machine_mode mode, rtx op1, rtx op2)\n   rtx ret = gen_reg_rtx (DImode);\n   rtx (*fn) (rtx, rtx, rtx);\n \n-  if (mode == QImode)\n-    fn = gen_insbl;\n-  else\n-    fn = gen_inswl;\n+  switch (mode)\n+    {\n+    case QImode:\n+      fn = gen_insbl;\n+      break;\n+    case HImode:\n+      fn = gen_inswl;\n+      break;\n+    case SImode:\n+      fn = gen_insll;\n+      break;\n+    case DImode:\n+      fn = gen_insql;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  /* The insbl and inswl patterns require a register operand.  */\n   op1 = force_reg (mode, op1);\n   emit_insn (fn (ret, op1, op2));\n "}]}