{"sha": "764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY0Njc4ZDE3ZDdlMjJhM2I1ZDA4N2IzZjNlMWQ5YTUxOGRmOWEyMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-05-02T04:57:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-05-02T04:57:47Z"}, "message": "frv-protos.h (frv_expand_epilogue, [...]): Add bool argument.\n\n* config/frv/frv-protos.h (frv_expand_epilogue,\nfrv_expand_fdpic_call): Add bool argument.\n* config/frv/frv.c (frv_function_ok_for_sibcall): New.\n(TARGET_FUNCTION_OK_FOR_SIBCALL): Define to it.\n(frv_expand_epilogue): Use new argument to decide whether to emit\nreturn instruction or copy the return address to LR.\n(frv_expand_fdpic_call): Inline PLT entry when emitting direct\nsibcalls.\n(sibcall_operand): New.\n* config/frv/frv.h (PREDICATE_CODES): call_operand doesn't match\nPLUS nor LABEL_REF.  Add sibcall_operand.\n* config/frv/frv.md (call, call_value): Pass false to\nfrv_expand_fdpic_call.\n(call_fdpicdi, call_value_fdpicdi): Insert %i0 in calll.\n(sibcall, sibcall_internal, sibcall_fdpicdi, sibcall_value,\nsibcall_value_internal, sibcall_value_fdpicdi): New.\n(return_unsigned_true, return_unsigned_false): New.\n(epilogue): Adjust call to frv_expand_epilogue.\n(sibcall_epilogue): New.\n\nFrom-SVN: r81405", "tree": {"sha": "1d04e1233f03f836fa8708f2a315b1ba2834a01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d04e1233f03f836fa8708f2a315b1ba2834a01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/comments", "author": null, "committer": null, "parents": [{"sha": "afbe7e61febc8df565418161787af714550c8244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbe7e61febc8df565418161787af714550c8244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbe7e61febc8df565418161787af714550c8244"}], "stats": {"total": 236, "additions": 217, "deletions": 19}, "files": [{"sha": "fb929086eed28a0baf520958ed10fadf30eeb4bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "patch": "@@ -1,5 +1,25 @@\n 2004-05-02  Alexandre Oliva  <aoliva@redhat.com>\n \n+\t* config/frv/frv-protos.h (frv_expand_epilogue,\n+\tfrv_expand_fdpic_call): Add bool argument.\n+\t* config/frv/frv.c (frv_function_ok_for_sibcall): New.\n+\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Define to it.\n+\t(frv_expand_epilogue): Use new argument to decide whether to emit\n+\treturn instruction or copy the return address to LR.\n+\t(frv_expand_fdpic_call): Inline PLT entry when emitting direct\n+\tsibcalls.\n+\t(sibcall_operand): New.\n+\t* config/frv/frv.h (PREDICATE_CODES): call_operand doesn't match\n+\tPLUS nor LABEL_REF.  Add sibcall_operand.\n+\t* config/frv/frv.md (call, call_value): Pass false to\n+\tfrv_expand_fdpic_call.\n+\t(call_fdpicdi, call_value_fdpicdi): Insert %i0 in calll.\n+\t(sibcall, sibcall_internal, sibcall_fdpicdi, sibcall_value,\n+\tsibcall_value_internal, sibcall_value_fdpicdi): New.\n+\t(return_unsigned_true, return_unsigned_false): New.\n+\t(epilogue): Adjust call to frv_expand_epilogue.\n+\t(sibcall_epilogue): New.\n+\n \t* config/frv/frv.h (ASM_SPEC): Pass -mno-fdpic as -mnopic.\n \t(CPP_SPEC, CPP_SIMPLE_SPEC): Undefine __FRV_ACC__ and __FRV_FPR__\n \tbefore redefining them."}, {"sha": "3a0e386d25d0cf71848fd1455963720cf61edac6", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "patch": "@@ -53,7 +53,7 @@ extern frv_cpu_t frv_cpu_type;\t\t\t/* value of -mcpu= */\n \n /* Define functions defined in frv.c */\n extern void frv_expand_prologue\t\t\t(void);\n-extern void frv_expand_epilogue\t\t\t(int);\n+extern void frv_expand_epilogue\t\t\t(bool);\n extern void frv_override_options\t\t(void);\n extern void frv_optimization_options\t\t(int, int);\n extern void frv_conditional_register_usage\t(void);\n@@ -225,7 +225,7 @@ extern int even_acc_operand\t\t(rtx, enum machine_mode);\n extern int quad_acc_operand\t\t(rtx, enum machine_mode);\n extern int accg_operand\t\t\t(rtx, enum machine_mode);\n extern rtx frv_matching_accg_for_acc\t(rtx);\n-extern void frv_expand_fdpic_call\t(rtx *, int);\n+extern void frv_expand_fdpic_call\t(rtx *, bool, bool);\n extern rtx frv_gen_GPsym2reg\t\t(rtx, rtx);\n #endif\n "}, {"sha": "92e0dd213fa5afdde9c4e30af33faa679cba6979", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "patch": "@@ -285,6 +285,7 @@ static bool frv_cannot_force_const_mem\t\t(rtx);\n static const char *unspec_got_name\t\t(int);\n static void frv_output_const_unspec\t\t(FILE *,\n \t\t\t\t\t\t const struct frv_unspec *);\n+static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n \f\n /* Initialize the GCC target structure.  */\n@@ -319,6 +320,8 @@ static rtx frv_struct_value_rtx\t\t\t(tree, int);\n #undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE frv_use_dfa_pipeline_interface\n \n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL frv_function_ok_for_sibcall\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM frv_cannot_force_const_mem\n \n@@ -332,6 +335,16 @@ static rtx frv_struct_value_rtx\t\t\t(tree, int);\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Any function call that satisfies the machine-independent\n+   requirements is eligible on FR-V.  */\n+\n+static bool\n+frv_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n+\t\t\t     tree exp ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n /* Return true if SYMBOL is a small data symbol and relocation RELOC\n    can be used to access it directly in a load or store.  */\n \n@@ -1749,7 +1762,7 @@ frv_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n    slots for arguments passed to the current function.  */\n \n void\n-frv_expand_epilogue (int sibcall_p)\n+frv_expand_epilogue (bool emit_return)\n {\n   frv_stack_t *info = frv_stack_info ();\n   rtx fp = frame_pointer_rtx;\n@@ -1769,9 +1782,7 @@ frv_expand_epilogue (int sibcall_p)\n \n   /* Set RETURN_ADDR to the address we should return to.  Set it to NULL if\n      no return instruction should be emitted.  */\n-  if (sibcall_p)\n-    return_addr = 0;\n-  else if (info->save_p[LR_REGNO])\n+  if (info->save_p[LR_REGNO])\n     {\n       int lr_offset;\n       rtx mem;\n@@ -1814,8 +1825,20 @@ frv_expand_epilogue (int sibcall_p)\n   if (current_function_calls_eh_return)\n     emit_insn (gen_stack_adjust (sp, sp, EH_RETURN_STACKADJ_RTX));\n \n-  if (return_addr)\n+  if (emit_return)\n     emit_jump_insn (gen_epilogue_return (return_addr));\n+  else\n+    {\n+      rtx lr = return_addr;\n+\n+      if (REGNO (return_addr) != LR_REGNO)\n+\t{\n+\t  lr = gen_rtx_REG (Pmode, LR_REGNO);\n+\t  emit_move_insn (lr, return_addr);\n+\t}\n+\n+      emit_insn (gen_rtx_USE (VOIDmode, lr));\n+    }\n }\n \n \f\n@@ -3529,7 +3552,7 @@ frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n }\n \n void\n-frv_expand_fdpic_call (rtx *operands, int ret_value)\n+frv_expand_fdpic_call (rtx *operands, bool ret_value, bool sibcall)\n {\n   rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n   rtx picreg = get_hard_reg_initial_val (SImode, FDPIC_REG);\n@@ -3565,8 +3588,9 @@ frv_expand_fdpic_call (rtx *operands, int ret_value)\n      all external functions, so one would have to also mark function\n      declarations available in the same module with non-default\n      visibility, which is advantageous in itself.  */\n-  if (GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (addr)\n-      && TARGET_INLINE_PLT)\n+  if (GET_CODE (addr) == SYMBOL_REF\n+      && ((!SYMBOL_REF_LOCAL_P (addr) && TARGET_INLINE_PLT)\n+\t  || sibcall))\n     {\n       rtx x, dest;\n       dest = gen_reg_rtx (SImode);\n@@ -3598,7 +3622,11 @@ frv_expand_fdpic_call (rtx *operands, int ret_value)\n   picreg = gen_reg_rtx (DImode);\n   emit_insn (gen_movdi_ldd (picreg, addr));\n \n-  if (ret_value)\n+  if (sibcall && ret_value)\n+    c = gen_sibcall_value_fdpicdi (rvrtx, picreg, const0_rtx);\n+  else if (sibcall)\n+    c = gen_sibcall_fdpicdi (picreg, const0_rtx);\n+  else if (ret_value)\n     c = gen_call_value_fdpicdi (rvrtx, picreg, const0_rtx, lr);\n   else\n     c = gen_call_fdpicdi (picreg, const0_rtx, lr);\n@@ -4766,6 +4794,21 @@ call_operand (rtx op, enum machine_mode mode)\n   return gpr_or_int12_operand (op, mode);\n }\n \n+/* Return true if operand is a memory reference suitable for a sibcall.  */\n+\n+int\n+sibcall_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode && GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  /* Note this doesn't allow reg+reg or reg+imm12 addressing (which should\n+     never occur anyway), but prevents reload from not handling the case\n+     properly of a call through a pointer on a function that calls\n+     vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */\n+  return gpr_or_int12_operand (op, mode);\n+}\n+\n /* Return true if operator is a kind of relational operator.  */\n \n int"}, {"sha": "e6baec07973661a8eb8f66b5341d1b9005c05241", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "patch": "@@ -3111,8 +3111,10 @@ do {                                                                    \\\n   { \"odd_fpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n   { \"dbl_memory_one_insn_operand\",\t{ MEM }},\t\t\t\\\n   { \"dbl_memory_two_insn_operand\",\t{ MEM }},\t\t\t\\\n-  { \"call_operand\",\t\t\t{ REG, SUBREG, PLUS, CONST_INT,\t\\\n-\t\t\t\t\t  SYMBOL_REF, LABEL_REF, CONST }}, \\\n+  { \"call_operand\",\t\t\t{ REG, SUBREG, CONST_INT,\t\\\n+\t\t\t\t\t  CONST, SYMBOL_REF }}, \t\\\n+  { \"sibcall_operand\",\t\t\t{ REG, SUBREG, CONST_INT,\t\\\n+\t\t\t\t\t  CONST }}, \t\t\t\\\n   { \"upper_int16_operand\",\t\t{ CONST_INT }},\t\t\t\\\n   { \"uint16_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n   { \"relational_operator\",\t\t{ EQ, NE, LE, LT, GE, GT,\t\\"}, {"sha": "36b6d8e7afc5d25a7ca7e690e36729f478ceaa4b", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 139, "deletions": 6, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764678d17d7e22a3b5d087b3f3e1d9a518df9a22/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=764678d17d7e22a3b5d087b3f3e1d9a518df9a22", "patch": "@@ -5260,7 +5260,7 @@\n     operands[2] = const0_rtx;\n \n   if (TARGET_FDPIC)\n-    frv_expand_fdpic_call (operands, 0);\n+    frv_expand_fdpic_call (operands, false, false);\n   else\n     emit_call_insn (gen_call_internal (addr, operands[1], operands[2], lr));\n \n@@ -5308,7 +5308,7 @@\n \t (match_operand 1 \"\" \"\"))\n    (clobber (match_operand:SI 2 \"lr_operand\" \"=l\"))]\n   \"TARGET_FDPIC\"\n-  \"calll %M0\"\n+  \"call%i0l %M0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"jumpl\")])\n \n@@ -5325,6 +5325,65 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call,jumpl\")])\n \n+(define_expand \"sibcall\"\n+  [(use (match_operand:QI 0 \"\" \"\"))\n+   (use (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (match_operand 3 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx addr;\n+\n+  if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+\n+  addr = XEXP (operands[0], 0);\n+  if (! sibcall_operand (addr, Pmode))\n+    addr = force_reg (Pmode, addr);\n+\n+  if (! operands[2])\n+    operands[2] = const0_rtx;\n+\n+  if (TARGET_FDPIC)\n+    frv_expand_fdpic_call (operands, false, true);\n+  else\n+    emit_call_insn (gen_sibcall_internal (addr, operands[1], operands[2]));\n+\n+  DONE;\n+}\")\n+  \n+;; It might seem that these sibcall patterns are missing references to\n+;; LR, but they're not necessary because sibcall_epilogue will make\n+;; sure LR is restored, and having LR here will set\n+;; regs_ever_used[REG_LR], forcing it to be saved on the stack, and\n+;; then restored in sibcalls and regular return code paths, even if\n+;; the function becomes a leaf function after tail-call elimination.\n+\n+;; We must not use a call-saved register here.  `W' limits ourselves\n+;; to gr14 or gr15, but since we're almost running out of constraint\n+;; letters, and most other call-clobbered registers are often used for\n+;; argument-passing, this will do.\n+(define_insn \"sibcall_internal\"\n+  [(call (mem:QI (match_operand:SI 0 \"sibcall_operand\" \"WNOP\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (return)]\n+  \"! TARGET_FDPIC\"\n+  \"jmp%i0l %M0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n+(define_insn \"sibcall_fdpicdi\"\n+  [(call (mem:QI (match_operand:DI 0 \"fdpic_fptr_operand\" \"W\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (return)]\n+  \"TARGET_FDPIC\"\n+  \"jmp%i0l %M0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n+\n ;; Subroutine call instruction returning a value.  Operand 0 is the hard\n ;; register in which the value is returned.  There are three more operands, the\n ;; same as the three operands of the `call' instruction (but with numbers\n@@ -5355,7 +5414,7 @@\n     operands[3] = const0_rtx;\n \n   if (TARGET_FDPIC)\n-    frv_expand_fdpic_call (operands, 1);\n+    frv_expand_fdpic_call (operands, true, false);\n   else\n     emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],\n \t\t\t\t\t     operands[3], lr));\n@@ -5382,7 +5441,7 @@\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"lr_operand\" \"=l\"))]\n   \"TARGET_FDPIC\"\n-  \"calll %M1\"\n+  \"call%i1l %M1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"jumpl\")])\n \n@@ -5400,6 +5459,56 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"call,jumpl\")])\n \n+(define_expand \"sibcall_value\"\n+  [(use (match_operand 0 \"\" \"\"))\n+   (use (match_operand:QI 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (match_operand 3 \"\" \"\"))\n+   (use (match_operand 4 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx addr;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n+  addr = XEXP (operands[1], 0);\n+  if (! sibcall_operand (addr, Pmode))\n+    addr = force_reg (Pmode, addr);\n+\n+  if (! operands[3])\n+    operands[3] = const0_rtx;\n+\n+  if (TARGET_FDPIC)\n+    frv_expand_fdpic_call (operands, true, true);\n+  else\n+    emit_call_insn (gen_sibcall_value_internal (operands[0], addr, operands[2],\n+\t\t\t\t\t\toperands[3]));\n+  DONE;\n+}\")\n+\n+(define_insn \"sibcall_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t(call (mem:QI (match_operand:SI 1 \"sibcall_operand\" \"WNOP\"))\n+\t\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (return)]\n+  \"! TARGET_FDPIC\"\n+  \"jmp%i1l %M1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n+(define_insn \"sibcall_value_fdpicdi\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t(call (mem:QI (match_operand:DI 1 \"fdpic_fptr_operand\" \"W\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (return)]\n+  \"TARGET_FDPIC\"\n+  \"jmp%i1l %M1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n ;; return instruction generated instead of jmp to epilog\n (define_expand \"return\"\n   [(parallel [(return)\n@@ -5430,6 +5539,30 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"jump,jumpl\")])\n \n+(define_insn \"*return_unsigned_true\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n+\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t\t      (const_int 0)])\n+\t\t      (return)\n+\t\t      (pc)))]\n+  \"direct_return_p ()\"\n+  \"b%c0lr %1,%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jump\")])\n+\n+(define_insn \"*return_unsigned_false\"\n+  [(set (pc)\n+\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n+\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t\t      (const_int 0)])\n+\t\t      (pc)\n+\t\t      (return)))]\n+  \"direct_return_p ()\"\n+  \"b%C0lr %1,%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jump\")])\n+\n ;; A version of addsi3 for deallocating stack space at the end of the\n ;; epilogue.  The addition is done in parallel with an (unspec_volatile),\n ;; which represents the clobbering of the deallocated space.\n@@ -5634,7 +5767,7 @@\n   \"\"\n   \"\n {\n-  frv_expand_epilogue (FALSE);\n+  frv_expand_epilogue (true);\n   DONE;\n }\")\n \n@@ -5650,7 +5783,7 @@\n   \"\"\n   \"\n {\n-  frv_expand_epilogue (TRUE);\n+  frv_expand_epilogue (false);\n   DONE;\n }\")\n "}]}