{"sha": "7ddc639b7717278075ab1989568d1769ccc040e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RkYzYzOWI3NzE3Mjc4MDc1YWIxOTg5NTY4ZDE3NjljY2MwNDBlMQ==", "commit": {"author": {"name": "Nicolas Roche", "email": "roche@adacore.com", "date": "2019-07-22T13:56:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:56:59Z"}, "message": "[Ada] Ensure meaningless digits in a string are discarded\n\n2019-07-22  Nicolas Roche  <roche@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-valrea.adb (Scan_Real): Ignore non significative\n\tdigits to avoid converging to infinity in some cases.\n\ngcc/testsuite/\n\n\t* gnat.dg/float_value1.adb: New testcase.\n\nFrom-SVN: r273675", "tree": {"sha": "1477f342b83f62fafa3f575a5875330166c756b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1477f342b83f62fafa3f575a5875330166c756b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ddc639b7717278075ab1989568d1769ccc040e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddc639b7717278075ab1989568d1769ccc040e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ddc639b7717278075ab1989568d1769ccc040e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddc639b7717278075ab1989568d1769ccc040e1/comments", "author": {"login": "Nikokrock", "id": 7796165, "node_id": "MDQ6VXNlcjc3OTYxNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7796165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nikokrock", "html_url": "https://github.com/Nikokrock", "followers_url": "https://api.github.com/users/Nikokrock/followers", "following_url": "https://api.github.com/users/Nikokrock/following{/other_user}", "gists_url": "https://api.github.com/users/Nikokrock/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nikokrock/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nikokrock/subscriptions", "organizations_url": "https://api.github.com/users/Nikokrock/orgs", "repos_url": "https://api.github.com/users/Nikokrock/repos", "events_url": "https://api.github.com/users/Nikokrock/events{/privacy}", "received_events_url": "https://api.github.com/users/Nikokrock/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52860cc145a7075a9f30840703f96b242cd0150f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52860cc145a7075a9f30840703f96b242cd0150f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52860cc145a7075a9f30840703f96b242cd0150f"}], "stats": {"total": 153, "additions": 101, "deletions": 52}, "files": [{"sha": "276fdba98529b97ed46e47cd3a827e4a7379bdc4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7ddc639b7717278075ab1989568d1769ccc040e1", "patch": "@@ -1,3 +1,8 @@\n+2019-07-22  Nicolas Roche  <roche@adacore.com>\n+\n+\t* libgnat/s-valrea.adb (Scan_Real): Ignore non significative\n+\tdigits to avoid converging to infinity in some cases.\n+\n 2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* libgnat/g-encstr.adb (Encode_Wide_String): Fix oversight."}, {"sha": "99c736046fd1811f12cfbecd34f00ec3259fa5a2", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=7ddc639b7717278075ab1989568d1769ccc040e1", "patch": "@@ -71,16 +71,13 @@ package body System.Val_Real is\n       After_Point : Natural := 0;\n       --  Set to 1 after the point\n \n-      Num_Saved_Zeroes : Natural := 0;\n-      --  This counts zeroes after the decimal point. A non-zero value means\n-      --  that this number of previously scanned digits are zero. If the end\n-      --  of the number is reached, these zeroes are simply discarded, which\n-      --  ensures that trailing zeroes after the point never affect the value\n-      --  (which might otherwise happen as a result of rounding). With this\n-      --  processing in place, we can ensure that, for example, we get the\n-      --  same exact result from 1.0E+49 and 1.0000000E+49. This is not\n-      --  necessarily required in a case like this where the result is not\n-      --  a machine number, but it is certainly a desirable behavior.\n+      Precision_Limit : constant Long_Long_Float :=\n+         2.0 ** (Long_Long_Float'Machine_Mantissa - 1);\n+      --  This is an upper bound for the number of bits used to represent the\n+      --  mantissa. Beyond that number, any digits parsed by Scanf are useless.\n+      --  Thus, only the scale should be updated. This ensures that infinity is\n+      --  not reached by the temporary Uval, which could lead to erroneous\n+      --  rounding (for example: 0.4444444... or 1<n zero>E-n).\n \n       procedure Scanf;\n       --  Scans integer literal value starting at current character position.\n@@ -96,56 +93,50 @@ package body System.Val_Real is\n       -----------\n \n       procedure Scanf is\n-         Digit : Natural;\n-\n+         Digit                   : Natural;\n+         Uval_Tmp                : Long_Long_Float;\n+         Precision_Limit_Reached : Boolean := False;\n       begin\n          loop\n             Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n-            P := P + 1;\n-\n-            --  Save up trailing zeroes after the decimal point\n-\n-            if Digit = 0 and then After_Point = 1 then\n-               Num_Saved_Zeroes := Num_Saved_Zeroes + 1;\n-\n-            --  Here for a non-zero digit\n-\n-            else\n-               --  First deal with any previously saved zeroes\n-\n-               if Num_Saved_Zeroes /= 0 then\n-                  while Num_Saved_Zeroes > Maxpow loop\n-                     Uval := Uval * Powten (Maxpow);\n-                     Num_Saved_Zeroes := Num_Saved_Zeroes - Maxpow;\n-                     Scale := Scale - Maxpow;\n-                  end loop;\n \n-                  Uval := Uval * Powten (Num_Saved_Zeroes);\n-                  Scale := Scale - Num_Saved_Zeroes;\n+            if not Precision_Limit_Reached then\n+               --  Compute potential new value\n+               Uval_Tmp := Uval * 10.0 + Long_Long_Float (Digit);\n \n-                  Num_Saved_Zeroes := 0;\n+               if Uval_Tmp > Precision_Limit then\n+                  Precision_Limit_Reached := True;\n                end if;\n+            end if;\n \n-               --  Accumulate new digit\n-\n-               Uval := Uval * 10.0 + Long_Long_Float (Digit);\n+            if Precision_Limit_Reached then\n+               --  If beyond the precision of the mantissa then just ignore the\n+               --  digit, to avoid rounding issues.\n+               if After_Point = 0 then\n+                  Scale := Scale + 1;\n+               end if;\n+            else\n+               Uval := Uval_Tmp;\n                Scale := Scale - After_Point;\n             end if;\n \n-            --  Done if end of input field\n+            --  Check next character\n+            P := P + 1;\n \n             if P > Max then\n+               --  Done if end of input field\n                return;\n \n-            --  Check next character\n-\n             elsif Str (P) not in Digs then\n+               --  If next character is not a digit, check if this is an\n+               --  underscore. If this is not the case, then return.\n                if Str (P) = '_' then\n                   Scan_Underscore (Str, P, Ptr, Max, False);\n                else\n                   return;\n                end if;\n             end if;\n+\n          end loop;\n       end Scanf;\n \n@@ -198,7 +189,8 @@ package body System.Val_Real is\n             Base_Char : constant Character := Str (P);\n             Digit     : Natural;\n             Fdigit    : Long_Long_Float;\n-\n+            Uval_Tmp  : Long_Long_Float;\n+            Precision_Limit_Reached : Boolean := False;\n          begin\n             --  Set bad base if out of range, and use safe base of 16.0,\n             --  to guard against division by zero in the loop below.\n@@ -243,22 +235,24 @@ package body System.Val_Real is\n                   Bad_Value (Str);\n                end if;\n \n-               --  Save up trailing zeroes after the decimal point\n+               if not Precision_Limit_Reached then\n+                  --  Compute potential new value\n+                  Uval_Tmp := Uval * Base + Long_Long_Float (Digit);\n \n-               if Digit = 0 and then After_Point = 1 then\n-                  Num_Saved_Zeroes := Num_Saved_Zeroes + 1;\n+                  if Uval_Tmp > Precision_Limit then\n+                     Precision_Limit_Reached := True;\n+                  end if;\n+               end if;\n \n-               --  Here for a non-zero digit\n+               if Precision_Limit_Reached then\n+                  --  If beyond precision of the mantissa then just update\n+                  --  the scale and discard remaining digits.\n \n-               else\n-                  --  First deal with any previously saved zeroes\n-\n-                  if Num_Saved_Zeroes /= 0 then\n-                     Uval := Uval * Base ** Num_Saved_Zeroes;\n-                     Scale := Scale - Num_Saved_Zeroes;\n-                     Num_Saved_Zeroes := 0;\n+                  if After_Point = 0 then\n+                     Scale := Scale + 1;\n                   end if;\n \n+               else\n                   --  Now accumulate the new digit\n \n                   Fdigit := Long_Long_Float (Digit);\n@@ -267,7 +261,7 @@ package body System.Val_Real is\n                      Bad_Base := True;\n                   else\n                      Scale := Scale - After_Point;\n-                     Uval := Uval * Base + Fdigit;\n+                     Uval := Uval_Tmp;\n                   end if;\n                end if;\n "}, {"sha": "d49f01851d3214274cc9f365b29264471bedd722", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ddc639b7717278075ab1989568d1769ccc040e1", "patch": "@@ -1,3 +1,7 @@\n+2019-07-22  Nicolas Roche  <roche@adacore.com>\n+\n+\t* gnat.dg/float_value1.adb: New testcase.\n+\n 2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/encode_string1.adb, gnat.dg/encode_string1_pkg.adb,"}, {"sha": "8e36767bf6bb9492aadb1215e9af2ff15c80a508", "filename": "gcc/testsuite/gnat.dg/float_value1.adb", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddc639b7717278075ab1989568d1769ccc040e1/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ffloat_value1.adb?ref=7ddc639b7717278075ab1989568d1769ccc040e1", "patch": "@@ -0,0 +1,46 @@\n+--  { dg-do run }\n+\n+with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n+\n+procedure Float_Value1 is\n+   Str1 : String := \"0.\" & 50000 * \"4\";\n+   Str2 : String := \"1.\" & 5000 * \"4\";\n+   Str3 : String := \"16#0.\" & 500000 * \"4\" & \"#\";\n+   Str4 : String := \"1\" & (5000 * \"0\") & \"E-5000\";\n+   Str5 : String := \"1\" & \".\" & 50000 * \"0\" & \"1\";\n+   Str6 : String := 50000 * \"0\" & \".\" & 50000 * \"2\" & \"1\";\n+   Str7 : String := \"1\" & (5000 * \"0\") & \"1\" & \"E-5000\";\n+   Str8 : String := \"16#1\" & \".\" & 50000 * \"0\" & \"1#\";\n+\n+   procedure Test (Msg, Str, Expected : String) is\n+      Number     : Long_Long_Float;\n+   begin\n+      Number := Long_Long_Float'Value (Str);\n+      if Number'Img /= Expected then\n+         raise Program_Error;\n+      end if;\n+   end Test;\n+\n+begin\n+   Test (\"0.4444...[50000 times]   \", Str1, \" 4.44444444444444444E-01\");\n+   Test (\"1.4...[5000 times]       \", Str2, \" 1.44444444444444444E+00\");\n+   Test (\"16#0.[50000 '4']#        \", Str3, \" 2.66666666666666667E-01\");\n+   Test (\"1[5000 zeros]E-5000      \", Str4, \" 1.00000000000000000E+00\");\n+   Test (\"1.[50000zeros]1          \", Str5, \" 1.00000000000000000E+00\");\n+   Test (\"[50000zeros].[50000 '2']1\", Str6, \" 2.22222222222222222E-01\");\n+   Test (\"1[50000zeros]1.E-5000    \", Str7, \" 1.00000000000000000E+01\");\n+   Test (\"16#1.[50000zeros]1#      \", Str8, \" 1.00000000000000000E+00\");\n+\n+   --  Check that number of trailing zero after point does not change\n+   --  the value\n+\n+   for J in 1 .. 10000 loop\n+      declare\n+         Str : String := \"0.1\" & J * \"0\";\n+      begin\n+         if Long_Long_Float'Value (Str) /= 0.1 then\n+            raise Program_Error;\n+         end if;\n+      end;\n+   end loop;\n+end Float_Value1;"}]}