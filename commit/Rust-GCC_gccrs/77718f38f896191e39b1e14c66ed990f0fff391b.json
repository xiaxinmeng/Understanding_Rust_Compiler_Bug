{"sha": "77718f38f896191e39b1e14c66ed990f0fff391b", "node_id": "C_kwDOANBUbNoAKDc3NzE4ZjM4Zjg5NjE5MWUzOWIxZTE0YzY2ZWQ5OTBmMGZmZjM5MWI", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-11T10:40:00Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-13T14:37:13Z"}, "message": "d: Match function declarations of gcc built-ins from any module.\n\nDeclarations of recognised gcc built-in functions are now matched from\nany module.  Previously, only the `core.stdc' package was scanned.\n\nIn addition to matching of the symbol, any user-applied `@attributes' or\n`pragma(mangle)' name will be applied to the built-in decl as well.\nBecause there would now be no control over where built-in declarations\nare coming from, the warning option `-Wbuiltin-declaration-mismatch' has\nbeen implemented in the D front-end too.\n\ngcc/d/ChangeLog:\n\n\t* d-builtins.cc: Include builtins.h.\n\t(gcc_builtins_libfuncs): Remove.\n\t(strip_type_modifiers): New function.\n\t(matches_builtin_type): New function.\n\t(covariant_with_builtin_type_p): New function.\n\t(maybe_set_builtin_1): Set front-end built-in if identifier matches\n\tgcc built-in name.  Apply user-specified attributes and assembler name\n\toverrides to the built-in.  Warn about built-in declaration mismatches.\n\t(d_builtin_function): Set IDENTIFIER_DECL_TREE of built-in functions.\n\t* d-compiler.cc (Compiler::onParseModule): Scan all modules for any\n\tidentifiers that match built-in function names.\n\t* lang.opt (Wbuiltin-declaration-mismatch): New option.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/Wbuiltin_declaration_mismatch.d: New test.\n\t* gdc.dg/builtins.d: New test.", "tree": {"sha": "12501410623ab6c27871a8584af8d38f9b7d0928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12501410623ab6c27871a8584af8d38f9b7d0928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77718f38f896191e39b1e14c66ed990f0fff391b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77718f38f896191e39b1e14c66ed990f0fff391b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77718f38f896191e39b1e14c66ed990f0fff391b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77718f38f896191e39b1e14c66ed990f0fff391b/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a"}], "stats": {"total": 234, "additions": 203, "deletions": 31}, "files": [{"sha": "c2ef0c836e16f6b2c5ecae42676e26f786329b9e", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 122, "deletions": 14, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=77718f38f896191e39b1e14c66ed990f0fff391b", "patch": "@@ -37,14 +37,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n #include \"stringpool.h\"\n #include \"stor-layout.h\"\n+#include \"builtins.h\"\n \n #include \"d-tree.h\"\n #include \"d-frontend.h\"\n #include \"d-target.h\"\n \n \n static GTY(()) vec <tree, va_gc> *gcc_builtins_functions = NULL;\n-static GTY(()) vec <tree, va_gc> *gcc_builtins_libfuncs = NULL;\n static GTY(()) vec <tree, va_gc> *gcc_builtins_types = NULL;\n \n /* Record built-in types and their associated decls for re-use when\n@@ -672,6 +672,87 @@ d_build_builtins_module (Module *m)\n   m->members->push (LinkDeclaration::create (Loc (), LINK::c, members));\n }\n \n+/* Remove all type modifiers from TYPE, returning the naked type.  */\n+\n+static Type *\n+strip_type_modifiers (Type *type)\n+{\n+  if (type->ty == TY::Tpointer)\n+    {\n+      Type *tnext = strip_type_modifiers (type->nextOf ());\n+      return tnext->pointerTo ();\n+    }\n+\n+  return type->castMod (0);\n+}\n+\n+/* Returns true if types T1 and T2 representing return types or types of\n+   function arguments are close enough to be considered interchangeable.  */\n+\n+static bool\n+matches_builtin_type (Type *t1, Type *t2)\n+{\n+  Type *tb1 = strip_type_modifiers (t1);\n+  Type *tb2 = strip_type_modifiers (t2);\n+\n+  if (same_type_p (t1, t2))\n+    return true;\n+\n+  if (((tb1->isTypePointer () && tb2->isTypePointer ())\n+       || (tb1->isTypeVector () && tb2->isTypeVector ()))\n+      && tb1->implicitConvTo (tb2) != MATCH::nomatch)\n+    return true;\n+\n+  if (tb1->isintegral () == tb2->isintegral ()\n+      && tb1->size () == tb2->size ())\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Check whether the declared function type T1 is covariant with the built-in\n+   function type T2.  Returns true if they are covariant.  */\n+\n+static bool\n+covariant_with_builtin_type_p (Type *t1, Type *t2)\n+{\n+  /* Check whether the declared function matches the built-in.  */\n+  if (same_type_p (t1, t2) || t1->covariant (t2) == Covariant::yes)\n+    return true;\n+\n+  /* May not be covariant because of D attributes applied on t1.\n+     Strip them all off and compare again.  */\n+  TypeFunction *tf1 = t1->isTypeFunction ();\n+  TypeFunction *tf2 = t2->isTypeFunction ();\n+\n+  /* Check for obvious reasons why types may be distinct.  */\n+  if (tf1 == NULL || tf2 == NULL\n+      || tf1->isref () != tf2->isref ()\n+      || tf1->parameterList.varargs != tf2->parameterList.varargs\n+      || tf1->parameterList.length () != tf2->parameterList.length ())\n+    return false;\n+\n+  /* Check return type and each parameter type for mismatch.  */\n+  if (!matches_builtin_type (tf1->next, tf2->next))\n+    return false;\n+\n+  const size_t nparams = tf1->parameterList.length ();\n+  for (size_t i = 0; i < nparams; i++)\n+    {\n+      Parameter *fparam1 = tf1->parameterList[i];\n+      Parameter *fparam2 = tf2->parameterList[i];\n+\n+      if (fparam1->isReference () != fparam2->isReference ()\n+\t  || fparam1->isLazy () != fparam2->isLazy ())\n+\treturn false;\n+\n+      if (!matches_builtin_type (fparam1->type, fparam2->type))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Search for any `extern(C)' functions that match any known GCC library builtin\n    function in D and override its internal back-end symbol.  */\n \n@@ -694,23 +775,46 @@ maybe_set_builtin_1 (Dsymbol *d)\n \t    }\n \t}\n     }\n-  else if (fd && !fd->fbody)\n+  else if (fd && !fd->fbody && fd->resolvedLinkage () == LINK::c)\n     {\n-      tree t;\n+      tree ident = get_identifier (fd->ident->toChars ());\n+      tree decl = IDENTIFIER_DECL_TREE (ident);\n \n-      for (size_t i = 0; vec_safe_iterate (gcc_builtins_libfuncs, i, &t); ++i)\n+      if (decl && TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t  && fndecl_built_in_p (decl, BUILT_IN_NORMAL))\n \t{\n-\t  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (t));\n-\n-\t  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n-\t  if (fd->ident != Identifier::idPool (name))\n-\t    continue;\n-\n \t  /* Found a match, tell the frontend this is a builtin.  */\n-\t  DECL_LANG_SPECIFIC (t) = build_lang_decl (fd);\n-\t  fd->csym = t;\n+\t  DECL_LANG_SPECIFIC (decl) = build_lang_decl (fd);\n+\t  fd->csym = decl;\n \t  fd->builtin = BUILTIN::gcc;\n-\t  return;\n+\n+\t  /* Copy front-end attributes to the builtin.  */\n+\t  apply_user_attributes (fd, fd->csym);\n+\n+\t  /* Function has `pragma(mangle)' specified, override its name.  */\n+\t  if (fd->mangleOverride.length)\n+\t    {\n+\t      tree mangle =\n+\t\tget_identifier_with_length (fd->mangleOverride.ptr,\n+\t\t\t\t\t    fd->mangleOverride.length);\n+\t      const char *asmname = IDENTIFIER_POINTER (mangle);\n+\t      set_builtin_user_assembler_name (decl, asmname);\n+\t    }\n+\n+\t  /* Warn when return and argument types of the user defined function is\n+\t     not covariant with the built-in function type.  */\n+\t  if (Type *type = build_frontend_type (TREE_TYPE (decl)))\n+\t    {\n+\t      if (!covariant_with_builtin_type_p (fd->type, type))\n+\t\t{\n+\t\t  warning_at (make_location_t (fd->loc),\n+\t\t\t      OPT_Wbuiltin_declaration_mismatch,\n+\t\t\t      \"conflicting types for built-in function %qs; \"\n+\t\t\t      \"expected %qs\",\n+\t\t\t      fd->toChars (), type->toChars ());\n+\t\t}\n+\t    }\n \t}\n     }\n }\n@@ -1221,7 +1325,11 @@ tree\n d_builtin_function (tree decl)\n {\n   if (!flag_no_builtin && DECL_ASSEMBLER_NAME_SET_P (decl))\n-    vec_safe_push (gcc_builtins_libfuncs, decl);\n+    {\n+      /* Associate the assembler identifier with the built-in.  */\n+      tree ident = DECL_ASSEMBLER_NAME (decl);\n+      IDENTIFIER_DECL_TREE (ident) = decl;\n+    }\n \n   vec_safe_push (gcc_builtins_functions, decl);\n   return decl;"}, {"sha": "881f3863d2a7da65db6058152fa8e27ba970a37d", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=77718f38f896191e39b1e14c66ed990f0fff391b", "patch": "@@ -119,31 +119,37 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n    Modules we look out for are:\n     - object: For D runtime type information.\n     - gcc.builtins: For all gcc builtins.\n-    - core.stdc.*: For all gcc library builtins.  */\n+    - all other modules for extern(C) gcc library builtins.  */\n \n void\n Compiler::onParseModule (Module *m)\n {\n   ModuleDeclaration *md = m->md;\n \n-  if (!md || !md->id|| md->packages.length == 0)\n+  if (md && md->id)\n     {\n-      Identifier *id = (md && md->id) ? md->id : m->ident;\n-      if (!strcmp (id->toChars (), \"object\"))\n-\tcreate_tinfo_types (m);\n-    }\n-  else if (md->packages.length == 1)\n-    {\n-      if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n-\t  && !strcmp (md->id->toChars (), \"builtins\"))\n-\td_build_builtins_module (m);\n-    }\n-  else if (md->packages.length == 2)\n-    {\n-      if (!strcmp (md->packages.ptr[0]->toChars (), \"core\")\n-\t  && !strcmp (md->packages.ptr[1]->toChars (), \"stdc\"))\n-\td_add_builtin_module (m);\n+      if (md->packages.length == 0)\n+    \t{\n+    \t  Identifier *id = (md && md->id) ? md->id : m->ident;\n+    \t  if (!strcmp (id->toChars (), \"object\"))\n+\t    {\n+\t      create_tinfo_types (m);\n+\t      return;\n+\t    }\n+\t}\n+      else if (md->packages.length == 1)\n+    \t{\n+    \t  if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n+    \t      && !strcmp (md->id->toChars (), \"builtins\"))\n+    \t    {\n+    \t      d_build_builtins_module (m);\n+    \t      return;\n+    \t    }\n+\t}\n     }\n+\n+  if (!flag_no_builtin)\n+    d_add_builtin_module (m);\n }\n \n /* A callback function that is called once an imported module is parsed."}, {"sha": "bd9c61d540d7de020320314223df80c8e34d60e6", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=77718f38f896191e39b1e14c66ed990f0fff391b", "patch": "@@ -118,6 +118,10 @@ Wno-alloca-larger-than\n D\n ; Documented in C\n \n+Wbuiltin-declaration-mismatch\n+D\n+; Documented in C\n+\n Wcast-result\n D Warning Var(warn_cast_result) LangEnabledBy(D, Wextra)\n Warn about casts that will produce a null result."}, {"sha": "53406474a851cc54331b1134f9dec919b60d106f", "filename": "gcc/testsuite/gdc.dg/Wbuiltin_declaration_mismatch.d", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2FWbuiltin_declaration_mismatch.d?ref=77718f38f896191e39b1e14c66ed990f0fff391b", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-Wbuiltin-declaration-mismatch\" }\n+\n+extern(C):\n+\n+// Mismatched parameter lengths\n+double tan();             // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Mismatched variadic arguments\n+int printf(const(char)*); // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Mismatched return type\n+void puts(char*);         // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Mismatched return storage class\n+ref int isalnum(int);     // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Mismatched parameter type\n+double sin(long);         // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Mismatched parameter storage class\n+double frexp(double, lazy int*); // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+double log(ref double);          // { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+\n+// Verify that storage classes don't affect covariance matching\n+@trusted nothrow @nogc pure double fabs(double);\n+\n+// Verify inout is allowed instead of const\n+inout(char)* strstr(return scope inout(char)*, scope const char*) pure;\n+\n+// Verify that FILE* is allowed as it is implicitly convertable to void*\n+struct _IO_FILE{}\n+alias FILE = shared(_IO_FILE);\n+int fprintf(FILE*, scope const char*, scope const ...);\n+\n+// Verify integral types with same size are treated as if equivalent\n+int putchar(dchar);"}, {"sha": "21e3a1ee0ac80c95e3fb5cf1b0d82580b07c7b4c", "filename": "gcc/testsuite/gdc.dg/builtins.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Ftestsuite%2Fgdc.dg%2Fbuiltins.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77718f38f896191e39b1e14c66ed990f0fff391b/gcc%2Ftestsuite%2Fgdc.dg%2Fbuiltins.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fbuiltins.d?ref=77718f38f896191e39b1e14c66ed990f0fff391b", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-fdump-tree-original\" }\n+\n+// { dg-final { scan-tree-dump \" __builtin_sqrt \" \"original\" } }\n+extern(C) double sqrt(double);\n+double test_sqrt(double a) { return sqrt(a); }\n+\n+// { dg-final { scan-tree-dump-not \" __builtin_tan \" \"original\" } }\n+pragma(mangle, \"tan\")\n+extern(C) double libc_tan(double);\n+double test_tan(double a) { return libc_tan(a); }\n+\n+// { dg-final { scan-tree-dump \" __builtin_malloc \" \"original\" } }\n+// { dg-final { scan-assembler \"mangle_override\" } }\n+pragma(mangle, \"mangle_override\")\n+extern(C) void *malloc(size_t);\n+void* test_malloc(size_t a) { return malloc(a); }"}]}