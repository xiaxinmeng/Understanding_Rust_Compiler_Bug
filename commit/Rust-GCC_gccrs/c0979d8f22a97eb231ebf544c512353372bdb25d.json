{"sha": "c0979d8f22a97eb231ebf544c512353372bdb25d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA5NzlkOGYyMmE5N2ViMjMxZWJmNTQ0YzUxMjM1MzM3MmJkYjI1ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T18:19:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T18:19:07Z"}, "message": "c++: Name lookup for modules\n\nThis augments the name lookup with knowledge about the BINDING_VECTOR.\nThat holds per-module namespace bindings, and we need to collect the\nbindings in visible imports when we do lookup.  We also need to do\nsome checking when we're pushing a new decl to check we're not\noverriding an existing visible binding in some way.\n\nTo deal with the Global Module and Module Partitions, we reserve 1 or\n2 slots inthe BINDING_VECTOR to record those entities that may\nlegitimately appear in more than one module.\n\nAs mentioned before, the BINDING_VECTOR is created lazily, when\nimported bindings appear.  The current TUs decls then appear on slot\nzero.\n\n\tgcc/cp/\n\t* cp-tree.h (visible_instantiation_path): Renamed.\n\t* module.cc (get_originating_module_decl, lazy_load_binding)\n\t(lazy_load_members, visible_instantiation_path): Stubs.\n\t* name-lookup.c (STAT_TYPE_VISIBLE_P, STAT_VISIBLE): New.\n\t(search_imported_binding_slot, init_global_partition)\n\t(get_fixed_binding_slot): New.\n\t(name_lookup::process_module_binding): New.\n\t(name_lookup::search_namespace_only): Search BINDING_VECTOR.\n\t(name_lookup::adl_namespace_fns): Likewise.\n\t(name_lookip::search_adl): Search visible instantiation path.\n\t(maybe_lazily_declare): Maybe lazy load members.\n\t(implicitly_exporT_namespace): New.\n\t(maybe_record_mergeable_decl): New.\n\t(check_module_override): New.\n\t(do_pushdecl): Deal with BINDING_VECTOR, check override.\n\t(add_mergeable_namespace_entity): New.\n\t(get_namespace_binding): Deal with BINDING_VECTOR.\n\t(do_namespace_alias): Call set_originating_module.\n\t(lookup_elaborated_type_1): Deal with BINDING_VECTOR.\n\t(do_pushtag): Call set_originating_module.\n\t(reuse_namespace): New.\n\t(make_namespace_finish): Add FROM_IMPORT parm.\n\t(push_namespace): Deal with BINDING_VECTOR & namespace reuse.\n\t(maybe_save_operator_binding): Save when module CMI in play.\n\t* name-lookup.h (add_mergeable_namespace_entity): Declare.", "tree": {"sha": "eee4547b3de1b712fc97b99b9767d5c1f5428644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eee4547b3de1b712fc97b99b9767d5c1f5428644"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0979d8f22a97eb231ebf544c512353372bdb25d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0979d8f22a97eb231ebf544c512353372bdb25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0979d8f22a97eb231ebf544c512353372bdb25d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0979d8f22a97eb231ebf544c512353372bdb25d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc14c8d0a9e7af13698a7eec84226a3cc4b0e67"}], "stats": {"total": 996, "additions": 940, "deletions": 56}, "files": [{"sha": "5304f6b86a200a2a1bc00393230f53d8d8a7a0d1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c0979d8f22a97eb231ebf544c512353372bdb25d", "patch": "@@ -6993,7 +6993,7 @@ extern void maybe_check_all_macros (cpp_reader *);\n extern void finish_module_processing (cpp_reader *);\n extern char const *module_name (unsigned, bool header_ok);\n extern bitmap get_import_bitmap ();\n-extern bitmap module_visible_instantiation_path (bitmap *);\n+extern bitmap visible_instantiation_path (bitmap *);\n extern void module_begin_main_file (cpp_reader *, line_maps *,\n \t\t\t\t    const line_map_ordinary *);\n extern void module_preprocess_options (cpp_reader *);"}, {"sha": "c98df14c45e41879331201cbb5bdc494bccedfea", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=c0979d8f22a97eb231ebf544c512353372bdb25d", "patch": "@@ -135,11 +135,33 @@ set_defining_module (tree)\n {\n }\n \n+tree\n+get_originating_module_decl (tree decl)\n+{\n+  return decl;\n+}\n+\n void\n set_originating_module (tree, bool)\n {\n }\n \n+void\n+lazy_load_binding (unsigned, tree, tree, binding_slot *)\n+{\n+}\n+\n+void\n+lazy_load_members (tree)\n+{\n+}\n+\n+bitmap\n+visible_instantiation_path (bitmap *)\n+{\n+  return nullptr;\n+}\n+\n void\n import_module (module_state *, location_t, bool, tree, cpp_reader *)\n {"}, {"sha": "9c945842fa1a004f75675fdb361b4441fd0b83ec", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 914, "deletions": 55, "changes": 969, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c0979d8f22a97eb231ebf544c512353372bdb25d", "patch": "@@ -61,14 +61,19 @@ enum binding_slots\n \n /* Create an overload suitable for recording an artificial TYPE_DECL\n    and another decl.  We use this machanism to implement the struct\n-   stat hack within a namespace.  It'd be nice to use it everywhere.  */\n+   stat hack.  */\n \n #define STAT_HACK_P(N) ((N) && TREE_CODE (N) == OVERLOAD && OVL_LOOKUP_P (N))\n+#define STAT_TYPE_VISIBLE_P(N) TREE_USED (OVERLOAD_CHECK (N))\n #define STAT_TYPE(N) TREE_TYPE (N)\n #define STAT_DECL(N) OVL_FUNCTION (N)\n+#define STAT_VISIBLE(N) OVL_CHAIN (N)\n #define MAYBE_STAT_DECL(N) (STAT_HACK_P (N) ? STAT_DECL (N) : N)\n #define MAYBE_STAT_TYPE(N) (STAT_HACK_P (N) ? STAT_TYPE (N) : NULL_TREE)\n \n+/* When a STAT_HACK_P is true, OVL_USING_P and OVL_EXPORT_P are valid\n+   and apply to the hacked type.  */\n+\n /* For regular (maybe) overloaded functions, we have OVL_HIDDEN_P.\n    But we also need to indicate hiddenness on implicit type decls\n    (injected friend classes), and (coming soon) decls injected from\n@@ -129,7 +134,197 @@ find_namespace_value (tree ns, tree name)\n   return b ? MAYBE_STAT_DECL (*b) : NULL_TREE;\n }\n \n-/* Add DECL to the list of things declared in B.  */\n+/* Look in *SLOT for a the binding of NAME in imported module IX.\n+   Returns pointer to binding's slot, or NULL if not found.  Does a\n+   binary search, as this is mainly used for random access during\n+   importing.  Do not use for the fixed slots.  */\n+\n+static binding_slot *\n+search_imported_binding_slot (tree *slot, unsigned ix)\n+{\n+  gcc_assert (ix);\n+\n+  if (!*slot)\n+    return NULL;\n+\n+  if (TREE_CODE (*slot) != BINDING_VECTOR)\n+    return NULL;\n+  \n+  unsigned clusters = BINDING_VECTOR_NUM_CLUSTERS (*slot);\n+  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (*slot);\n+\n+  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+    {\n+      clusters--;\n+      cluster++;\n+    }\n+\n+  while (clusters > 1)\n+    {\n+      unsigned half = clusters / 2;\n+      gcc_checking_assert (cluster[half].indices[0].span);\n+      if (cluster[half].indices[0].base > ix)\n+\tclusters = half;\n+      else\n+\t{\n+\t  clusters -= half;\n+\t  cluster += half;\n+\t}\n+    }\n+\n+  if (clusters)\n+    /* Is it in this cluster?  */\n+    for (unsigned off = 0; off != BINDING_VECTOR_SLOTS_PER_CLUSTER; off++)\n+      {\n+\tif (!cluster->indices[off].span)\n+\t  break;\n+\tif (cluster->indices[off].base > ix)\n+\t  break;\n+\n+\tif (cluster->indices[off].base + cluster->indices[off].span > ix)\n+\t  return &cluster->slots[off];\n+      }\n+\n+  return NULL;\n+}\n+\n+static void\n+init_global_partition (binding_cluster *cluster, tree decl)\n+{\n+  bool purview = true;\n+\n+  if (header_module_p ())\n+    purview = false;\n+  else if (TREE_PUBLIC (decl)\n+\t   && TREE_CODE (decl) == NAMESPACE_DECL\n+\t   && !DECL_NAMESPACE_ALIAS (decl))\n+    purview = false;\n+  else if (!get_originating_module (decl))\n+    purview = false;\n+\n+  binding_slot *mslot;\n+  if (!purview)\n+    mslot = &cluster[0].slots[BINDING_SLOT_GLOBAL];\n+  else\n+    mslot = &cluster[BINDING_SLOT_PARTITION\n+\t\t     / BINDING_VECTOR_SLOTS_PER_CLUSTER]\n+      .slots[BINDING_SLOT_PARTITION\n+\t     % BINDING_VECTOR_SLOTS_PER_CLUSTER];\n+\n+  if (*mslot)\n+    decl = ovl_make (decl, *mslot);\n+  *mslot = decl;\n+\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    {\n+      tree type = TREE_TYPE (decl);\n+      if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t  && IDENTIFIER_ANON_P (DECL_NAME (TYPE_NAME (type)))\n+\t  && decl == TREE_VALUE (TYPE_VALUES (type)))\n+\t/* Anonymous enums are keyed by their first enumerator, put\n+\t   the TYPE_DECL here too.  */\n+\t*mslot = ovl_make (TYPE_NAME (type), *mslot);\n+    }\n+}\n+\n+/* Get the fixed binding slot IX.  Creating the vector if CREATE is\n+   non-zero.  If CREATE is < 0, make sure there is at least 1 spare\n+   slot for an import.  (It is an error for CREATE < 0 and the slot to\n+   already exist.)  */\n+\n+static tree *\n+get_fixed_binding_slot (tree *slot, tree name, unsigned ix, int create)\n+{\n+  gcc_checking_assert (ix <= BINDING_SLOT_PARTITION);\n+\n+  /* An assumption is that the fixed slots all reside in one cluster.  */\n+  gcc_checking_assert (BINDING_VECTOR_SLOTS_PER_CLUSTER >= BINDING_SLOTS_FIXED);\n+\n+  if (!*slot || TREE_CODE (*slot) != BINDING_VECTOR)\n+    {\n+      if (ix == BINDING_SLOT_CURRENT)\n+\t/* The current TU can just use slot directly.  */\n+\treturn slot;\n+\n+      if (!create)\n+\treturn NULL;\n+\n+      /* The partition slot is only needed when we know we're a named\n+\t module.  */\n+      bool partition_slot = named_module_p ();\n+      unsigned want = ((BINDING_SLOTS_FIXED + partition_slot + (create < 0)\n+\t\t\t+ BINDING_VECTOR_SLOTS_PER_CLUSTER - 1)\n+\t\t       / BINDING_VECTOR_SLOTS_PER_CLUSTER);\n+      tree new_vec = make_binding_vec (name, want);\n+      BINDING_VECTOR_NUM_CLUSTERS (new_vec) = want;\n+      binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (new_vec);\n+\n+      /* Initialize the fixed slots.  */\n+      for (unsigned jx = BINDING_SLOTS_FIXED; jx--;)\n+\t{\n+\t  cluster[0].indices[jx].base = 0;\n+\t  cluster[0].indices[jx].span = 1;\n+\t  cluster[0].slots[jx] = NULL_TREE;\n+\t}\n+\n+      if (partition_slot)\n+\t{\n+\t  unsigned off = BINDING_SLOT_PARTITION % BINDING_VECTOR_SLOTS_PER_CLUSTER;\n+\t  unsigned ind = BINDING_SLOT_PARTITION / BINDING_VECTOR_SLOTS_PER_CLUSTER;\n+\t  cluster[ind].indices[off].base = 0;\n+\t  cluster[ind].indices[off].span = 1;\n+\t  cluster[ind].slots[off] = NULL_TREE;\n+\t}\n+\n+      if (tree orig = *slot)\n+\t{\n+\t  /* Propagate existing value to current slot.  */\n+\n+\t  /* Propagate global & module entities to the global and\n+\t     partition slots.  */\n+\t  if (tree type = MAYBE_STAT_TYPE (orig))\n+\t    init_global_partition (cluster, type);\n+\n+\t  for (ovl_iterator iter (MAYBE_STAT_DECL (orig)); iter; ++iter)\n+\t    {\n+\t      tree decl = *iter;\n+\n+\t      /* Internal linkage entities are in deduplicateable.  */\n+\t      init_global_partition (cluster, decl);\n+\t    }\n+\n+\t  if (cluster[0].slots[BINDING_SLOT_GLOBAL]\n+\t      && !(TREE_CODE (orig) == NAMESPACE_DECL\n+\t\t   && !DECL_NAMESPACE_ALIAS (orig)))\n+\t    {\n+\t      /* Note that we had some GMF entries.  */\n+\t      if (!STAT_HACK_P (orig))\n+\t\torig = stat_hack (orig);\n+\n+\t      MODULE_BINDING_GLOBAL_P (orig) = true;\n+\t    }\n+\n+\t  cluster[0].slots[BINDING_SLOT_CURRENT] = orig;\n+\t}\n+\n+      *slot = new_vec;\n+    }\n+  else\n+    gcc_checking_assert (create >= 0);\n+\n+  unsigned off = ix % BINDING_VECTOR_SLOTS_PER_CLUSTER;\n+  binding_cluster &cluster\n+    = BINDING_VECTOR_CLUSTER (*slot, ix / BINDING_VECTOR_SLOTS_PER_CLUSTER);\n+\n+  /* There must always be slots for these indices  */\n+  gcc_checking_assert (cluster.indices[off].span == 1\n+\t\t       && !cluster.indices[off].base\n+\t\t       && !cluster.slots[off].is_lazy ());\n+\n+  return reinterpret_cast<tree *> (&cluster.slots[off]);\n+}\n+\n+/* Add DECL to the list of things declared in binding level B.  */\n \n static void\n add_decl_to_level (cp_binding_level *b, tree decl)\n@@ -256,7 +451,7 @@ class name_lookup\n   void add_value (tree new_val);\n   void add_type (tree new_type);\n   bool process_binding (tree val_bind, tree type_bind);\n-\n+  unsigned process_module_binding (tree val_bind, tree type_bind, unsigned);\n   /* Look in only namespace.  */\n   bool search_namespace_only (tree scope);\n   /* Look in namespace and its (recursive) inlines. Ignore using\n@@ -291,7 +486,7 @@ class name_lookup\n   void adl_class_only (tree);\n   void adl_namespace (tree);\n   void adl_class_fns (tree);\n-  void adl_namespace_fns (tree);\n+  void adl_namespace_fns (tree, bitmap);\n \n public:\n   /* Search namespace + inlines + maybe usings as qualified lookup.  */\n@@ -561,36 +756,190 @@ name_lookup::process_binding (tree new_val, tree new_type)\n   return new_val != NULL_TREE;\n }\n \n+/* If we're importing a module containing this binding, add it to the\n+   lookup set.  The trickiness is with namespaces, we only want to\n+   find it once.  */\n+\n+unsigned\n+name_lookup::process_module_binding (tree new_val, tree new_type,\n+\t\t\t\t     unsigned marker)\n+{\n+  /* Optimize for (re-)finding a public namespace.  We only need to\n+     look once.  */\n+  if (new_val && !new_type\n+      && TREE_CODE (new_val) == NAMESPACE_DECL\n+      && TREE_PUBLIC (new_val)\n+      && !DECL_NAMESPACE_ALIAS (new_val))\n+    {\n+      if (marker & 2)\n+\treturn marker;\n+      marker |= 2;\n+    }\n+\n+  if (new_type || new_val)\n+    marker |= process_binding (new_val, new_type);\n+\n+  return marker;\n+}\n+\n /* Look in exactly namespace SCOPE.  */\n \n bool\n name_lookup::search_namespace_only (tree scope)\n {\n   bool found = false;\n-\n   if (tree *binding = find_namespace_slot (scope, name))\n     {\n-      tree value = *binding, type = NULL_TREE;\n-\n-      if (STAT_HACK_P (value))\n+      tree val = *binding;\n+      if (TREE_CODE (val) == BINDING_VECTOR)\n \t{\n-\t  type = STAT_TYPE (value);\n-\t  value = STAT_DECL (value);\n-\t  \n-\t  if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\t  /* I presume the binding list is going to be sparser than\n+\t     the import bitmap.  Hence iterate over the former\n+\t     checking for bits set in the bitmap.  */\n+\t  bitmap imports = get_import_bitmap ();\n+\t  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (val);\n+\t  int marker = 0;\n+\t  int dup_detect = 0;\n+\n+\t  if (tree bind = cluster->slots[BINDING_SLOT_CURRENT])\n \t    {\n-\t      if (STAT_TYPE_HIDDEN_P (*binding))\n-\t\ttype = NULL_TREE;\n-\t      if (STAT_DECL_HIDDEN_P (*binding))\n-\t\tvalue = NULL_TREE;\n-\t      else\n+\t      if (!deduping)\n+\t\t{\n+\t\t  if (named_module_purview_p ())\n+\t\t    {\n+\t\t      dup_detect |= 2;\n+\n+\t\t      if (STAT_HACK_P (bind) && MODULE_BINDING_GLOBAL_P (bind))\n+\t\t\tdup_detect |= 1;\n+\t\t    }\n+\t\t  else\n+\t\t    dup_detect |= 1;\n+\t\t}\n+\t      tree type = NULL_TREE;\n+\t      tree value = bind;\n+\n+\t      if (STAT_HACK_P (bind))\n+\t\t{\n+\t\t  type = STAT_TYPE (bind);\n+\t\t  value = STAT_DECL (bind);\n+\n+\t\t  if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\t\t    {\n+\t\t      if (STAT_TYPE_HIDDEN_P (bind))\n+\t\t\ttype = NULL_TREE;\n+\t\t      if (STAT_DECL_HIDDEN_P (bind))\n+\t\t\tvalue = NULL_TREE;\n+\t\t      else\n+\t\t\tvalue = ovl_skip_hidden (value);\n+\t\t    }\n+\t\t}\n+\t      else if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n \t\tvalue = ovl_skip_hidden (value);\n+\n+\t      marker = process_module_binding (value, type, marker);\n+\t    }\n+\n+\t  /* Scan the imported bindings.  */\n+\t  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (val);\n+\t  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t    {\n+\t      ix--;\n+\t      cluster++;\n \t    }\n+\n+\t  /* Do this in forward order, so we load modules in an order\n+\t     the user expects.  */\n+\t  for (; ix--; cluster++)\n+\t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t      {\n+\t\t/* Are we importing this module?  */\n+\t\tif (unsigned base = cluster->indices[jx].base)\n+\t\t  if (unsigned span = cluster->indices[jx].span)\n+\t\t    do\n+\t\t      if (bitmap_bit_p (imports, base))\n+\t\t\tgoto found;\n+\t\t    while (++base, --span);\n+\t\tcontinue;\n+\n+\t      found:;\n+\t\t/* Is it loaded?  */\n+\t\tif (cluster->slots[jx].is_lazy ())\n+\t\t  {\n+\t\t    gcc_assert (cluster->indices[jx].span == 1);\n+\t\t    lazy_load_binding (cluster->indices[jx].base,\n+\t\t\t\t       scope, name, &cluster->slots[jx]);\n+\t\t  }\n+\t\ttree bind = cluster->slots[jx];\n+\t\tif (!bind)\n+\t\t  /* Load errors could mean there's nothing here.  */\n+\t\t  continue;\n+\n+\t\t/* Extract what we can see from here.  If there's no\n+\t\t   stat_hack, then everything was exported.  */\n+\t\ttree type = NULL_TREE;\n+\n+\n+\t\t/* If STAT_HACK_P is false, everything is visible, and\n+\t\t   there's no duplication possibilities.  */\n+\t\tif (STAT_HACK_P (bind))\n+\t\t  {\n+\t\t    if (!deduping)\n+\t\t      {\n+\t\t\t/* Do we need to engage deduplication?  */\n+\t\t\tint dup = 0;\n+\t\t\tif (MODULE_BINDING_GLOBAL_P (bind))\n+\t\t\t  dup = 1;\n+\t\t\telse if (MODULE_BINDING_PARTITION_P (bind))\n+\t\t\t  dup = 2;\n+\t\t\tif (unsigned hit = dup_detect & dup)\n+\t\t\t  {\n+\t\t\t    if ((hit & 1 && BINDING_VECTOR_GLOBAL_DUPS_P (val))\n+\t\t\t\t|| (hit & 2\n+\t\t\t\t    && BINDING_VECTOR_PARTITION_DUPS_P (val)))\n+\t\t\t      {\n+\t\t\t\tlookup_mark (value, true);\n+\t\t\t\tdeduping = true;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tdup_detect |= dup;\n+\t\t      }\n+\n+\t\t    if (STAT_TYPE_VISIBLE_P (bind))\n+\t\t      type = STAT_TYPE (bind);\n+\t\t    bind = STAT_VISIBLE (bind);\n+\t\t  }\n+\n+\t\t/* And process it.  */\n+\t\tmarker = process_module_binding (bind, type, marker);\n+\t      }\n+\t  found |= marker & 1;\n \t}\n-      else if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n-\tvalue = ovl_skip_hidden (value);\n+      else\n+\t{\n+\t  /* Only a current module binding, visible from the current module.  */\n+\t  tree bind = *binding;\n+\t  tree value = bind, type = NULL_TREE;\n+\n+\t  if (STAT_HACK_P (bind))\n+\t    {\n+\t      type = STAT_TYPE (bind);\n+\t      value = STAT_DECL (bind);\n+\n+\t      if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\t\t{\n+\t\t  if (STAT_TYPE_HIDDEN_P (bind))\n+\t\t    type = NULL_TREE;\n+\t\t  if (STAT_DECL_HIDDEN_P (bind))\n+\t\t    value = NULL_TREE;\n+\t\t  else\n+\t\t    value = ovl_skip_hidden (value);\n+\t\t}\n+\t    }\n+\t  else if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\t    value = ovl_skip_hidden (value);\n \n-      found |= process_binding (value, type);\n+\t  found |= process_binding (value, type);\n+\t}\n     }\n \n   return found;\n@@ -801,12 +1150,103 @@ name_lookup::add_fns (tree fns)\n /* Add the overloaded fns of SCOPE.  */\n \n void\n-name_lookup::adl_namespace_fns (tree scope)\n+name_lookup::adl_namespace_fns (tree scope, bitmap imports)\n {\n   if (tree *binding = find_namespace_slot (scope, name))\n     {\n       tree val = *binding;\n-      add_fns (ovl_skip_hidden (MAYBE_STAT_DECL (val)));\n+      if (TREE_CODE (val) != BINDING_VECTOR)\n+\tadd_fns (ovl_skip_hidden (MAYBE_STAT_DECL (val)));\n+      else\n+\t{\n+\t  /* I presume the binding list is going to be sparser than\n+\t     the import bitmap.  Hence iterate over the former\n+\t     checking for bits set in the bitmap.  */\n+\t  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (val);\n+\t  int dup_detect = 0;\n+\n+\t  if (tree bind = cluster->slots[BINDING_SLOT_CURRENT])\n+\t    {\n+\t      /* The current TU's bindings must be visible, we don't\n+\t\t need to check the bitmaps.  */\n+\n+\t      if (!deduping)\n+\t\t{\n+\t\t  if (named_module_purview_p ())\n+\t\t    {\n+\t\t      dup_detect |= 2;\n+\n+\t\t      if (STAT_HACK_P (bind) && MODULE_BINDING_GLOBAL_P (bind))\n+\t\t\tdup_detect |= 1;\n+\t\t    }\n+\t\t  else\n+\t\t    dup_detect |= 1;\n+\t\t}\n+\n+\t      add_fns (ovl_skip_hidden (MAYBE_STAT_DECL (bind)));\n+\t    }\n+\n+\t  /* Scan the imported bindings.  */\n+\t  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (val);\n+\t  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t    {\n+\t      ix--;\n+\t      cluster++;\n+\t    }\n+\n+\t  /* Do this in forward order, so we load modules in an order\n+\t     the user expects.  */\n+\t  for (; ix--; cluster++)\n+\t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t      {\n+\t\t/* Functions are never on merged slots.  */\n+\t\tif (!cluster->indices[jx].base\n+\t\t    || cluster->indices[jx].span != 1)\n+\t\t  continue;\n+\n+\t\t/* Is this slot visible?  */\n+\t\tif (!bitmap_bit_p (imports, cluster->indices[jx].base))\n+\t\t  continue;\n+\n+\t\t/* Is it loaded.  */\n+\t\tif (cluster->slots[jx].is_lazy ())\n+\t\t  lazy_load_binding (cluster->indices[jx].base,\n+\t\t\t\t     scope, name, &cluster->slots[jx]);\n+\n+\t\ttree bind = cluster->slots[jx];\n+\t\tif (!bind)\n+\t\t  /* Load errors could mean there's nothing here.  */\n+\t\t  continue;\n+\n+\t\tif (STAT_HACK_P (bind))\n+\t\t  {\n+\t\t    if (!deduping)\n+\t\t      {\n+\t\t\t/* Do we need to engage deduplication?  */\n+\t\t\tint dup = 0;\n+\t\t\tif (MODULE_BINDING_GLOBAL_P (bind))\n+\t\t\t  dup = 1;\n+\t\t\telse if (MODULE_BINDING_PARTITION_P (bind))\n+\t\t\t  dup = 2;\n+\t\t\tif (unsigned hit = dup_detect & dup)\n+\t\t\t  {\n+\t\t\t    if ((hit & 1 && BINDING_VECTOR_GLOBAL_DUPS_P (val))\n+\t\t\t\t|| (hit & 2\n+\t\t\t\t    && BINDING_VECTOR_PARTITION_DUPS_P (val)))\n+\t\t\t      {\n+\t\t\t\tlookup_mark (value, true);\n+\t\t\t\tdeduping = true;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tdup_detect |= dup;\n+\t\t      }\n+\n+\t\t    bind = STAT_VISIBLE (bind);\n+\t\t  }\n+\n+\t\tadd_fns (bind);\n+\t      }\n+\t}\n     }\n }\n \n@@ -1146,13 +1586,77 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n \t}\n       value = fns;\n \n+      /* INST_PATH will be NULL, if this is /not/ 2nd-phase ADL.  */\n+      bitmap inst_path = NULL;\n+      /* VISIBLE is the regular import bitmap.  */\n+      bitmap visible = visible_instantiation_path (&inst_path);\n+\n       for (unsigned ix = scopes->length (); ix--;)\n \t{\n \t  tree scope = (*scopes)[ix];\n \t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n-\t    adl_namespace_fns (scope);\n-\t  else if (RECORD_OR_UNION_TYPE_P (scope))\n-\t    adl_class_fns (scope);\n+\t    adl_namespace_fns (scope, visible);\n+\t  else\n+\t    {\n+\t      if (RECORD_OR_UNION_TYPE_P (scope))\n+\t\tadl_class_fns (scope);\n+\n+\t      /* During 2nd phase ADL: Any exported declaration D in N\n+\t\t declared within the purview of a named module M\n+\t\t (10.2) is visible if there is an associated entity\n+\t\t attached to M with the same innermost enclosing\n+\t\t non-inline namespace as D.\n+\t\t [basic.lookup.argdep]/4.4 */ \n+\n+\t      if (!inst_path)\n+\t\t/* Not 2nd phase.  */\n+\t\tcontinue;\n+\n+\t      tree ctx = CP_DECL_CONTEXT (TYPE_NAME (scope));\n+\t      if (TREE_CODE (ctx) != NAMESPACE_DECL)\n+\t\t/* Not namespace-scope class.  */\n+\t\tcontinue;\n+\n+\t      tree origin = get_originating_module_decl (TYPE_NAME (scope));\n+\t      if (!DECL_LANG_SPECIFIC (origin)\n+\t\t  || !DECL_MODULE_IMPORT_P (origin))\n+\t\t/* Not imported.  */\n+\t\tcontinue;\n+\n+\t      unsigned module = get_importing_module (origin);\n+\n+\t      if (!bitmap_bit_p (inst_path, module))\n+\t\t/* Not on path of instantiation.  */\n+\t\tcontinue;\n+\n+\t      if (bitmap_bit_p (visible, module))\n+\t\t/* If the module was in the visible set, we'll look at\n+\t\t   its namespace partition anyway.  */\n+\t\tcontinue;\n+\n+\t      if (tree *slot = find_namespace_slot (ctx, name, false))\n+\t\tif (binding_slot *mslot = search_imported_binding_slot (slot, module))\n+\t\t  {\n+\t\t    if (mslot->is_lazy ())\n+\t\t      lazy_load_binding (module, ctx, name, mslot);\n+\n+\t\t    if (tree bind = *mslot)\n+\t\t      {\n+\t\t\tif (!deduping)\n+\t\t\t  {\n+\t\t\t    /* We must turn on deduping, because some\n+\t\t\t       other class from this module might also\n+\t\t\t       be in this namespace.  */\n+\t\t\t    deduping = true;\n+\t\t\t    lookup_mark (value, true);\n+\t\t\t  }\n+\n+\t\t\t/* Add the exported fns  */\n+\t\t\tif (STAT_HACK_P (bind))\n+\t\t\t  add_fns (STAT_VISIBLE (bind));\n+\t\t      }\n+\t\t  }\n+\t    }\n \t}\n \n       fns = value;\n@@ -1357,6 +1861,11 @@ get_class_binding_direct (tree klass, tree name, bool want_type)\n static void\n maybe_lazily_declare (tree klass, tree name)\n {\n+  tree main_decl = TYPE_NAME (TYPE_MAIN_VARIANT (klass));\n+  if (DECL_LANG_SPECIFIC (main_decl)\n+      && DECL_MODULE_PENDING_MEMBERS_P (main_decl))\n+    lazy_load_members (main_decl);\n+\n   /* Lazily declare functions, if we're going to search these.  */\n   if (IDENTIFIER_CTOR_P (name))\n     {\n@@ -2926,6 +3435,18 @@ push_local_extern_decl_alias (tree decl)\n   DECL_LOCAL_DECL_ALIAS (decl) = alias;\n }\n \n+/* NS needs to be exported, mark it and all its parents as exported.  */\n+\n+static void\n+implicitly_export_namespace (tree ns)\n+{\n+  while (!DECL_MODULE_EXPORT_P (ns))\n+    {\n+      DECL_MODULE_EXPORT_P (ns) = true;\n+      ns = CP_DECL_CONTEXT (ns);\n+    }\n+}\n+\n /* DECL has just been bound at LEVEL.  finish up the bookkeeping.  */\n \n static void\n@@ -2961,6 +3482,135 @@ newbinding_bookkeeping (tree name, tree decl, cp_binding_level *level)\n     }\n }\n \n+/* DECL is a global or module-purview entity.  If it has non-internal\n+   linkage, and we have a module vector, record it in the appropriate\n+   slot.  We have already checked for duplicates.  */\n+\n+static void\n+maybe_record_mergeable_decl (tree *slot, tree name, tree decl)\n+{\n+  if (TREE_CODE (*slot) != BINDING_VECTOR)\n+    return;\n+\n+  if (!TREE_PUBLIC (CP_DECL_CONTEXT (decl)))\n+    /* Member of internal namespace.  */\n+    return;\n+\n+  tree not_tmpl = STRIP_TEMPLATE (decl);\n+  if ((TREE_CODE (not_tmpl) == FUNCTION_DECL\n+       || TREE_CODE (not_tmpl) == VAR_DECL)\n+      && DECL_THIS_STATIC (not_tmpl))\n+    /* Internal linkage.  */\n+    return;\n+\n+  bool partition = named_module_p ();\n+  tree *gslot = get_fixed_binding_slot\n+    (slot, name, partition ? BINDING_SLOT_PARTITION : BINDING_SLOT_GLOBAL, true);\n+\n+  if (!partition)\n+    {\n+      binding_slot &orig\n+\t= BINDING_VECTOR_CLUSTER (*gslot, 0).slots[BINDING_SLOT_CURRENT];\n+\n+      if (!STAT_HACK_P (tree (orig)))\n+\torig = stat_hack (tree (orig));\n+\n+      MODULE_BINDING_GLOBAL_P (tree (orig)) = true;\n+    }\n+\n+  add_mergeable_namespace_entity (gslot, decl);\n+}\n+\n+/* DECL is being pushed.  Check whether it hides or ambiguates\n+   something seen as an import.  This include decls seen in our own\n+   interface, which is OK.  Also, check for merging a\n+   global/partition decl.  */\n+\n+static tree\n+check_module_override (tree decl, tree mvec, bool hiding,\n+\t\t       tree scope, tree name)\n+{\n+  bitmap imports = get_import_bitmap ();\n+  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (mvec);\n+  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (mvec);\n+\n+  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+    {\n+      cluster++;\n+      ix--;\n+    }\n+\n+  for (; ix--; cluster++)\n+    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+      {\n+\t/* Are we importing this module?  */\n+\tif (cluster->indices[jx].span != 1)\n+\t  continue;\n+\tif (!cluster->indices[jx].base)\n+\t  continue;\n+\tif (!bitmap_bit_p (imports, cluster->indices[jx].base))\n+\t  continue;\n+\t/* Is it loaded? */\n+\tif (cluster->slots[jx].is_lazy ())\n+\t  {\n+\t    gcc_assert (cluster->indices[jx].span == 1);\n+\t    lazy_load_binding (cluster->indices[jx].base,\n+\t\t\t       scope, name, &cluster->slots[jx]);\n+\t  }\n+\ttree bind = cluster->slots[jx];\n+\tif (!bind)\n+\t  /* Errors could cause there to be nothing.  */\n+\t  continue;\n+\n+\tif (STAT_HACK_P (bind))\n+\t  /* We do not have to check STAT_TYPE here, the xref_tag\n+\t     machinery deals with that problem. */\n+\t  bind = STAT_VISIBLE (bind);\n+\n+\tfor (ovl_iterator iter (bind); iter; ++iter)\n+\t  if (iter.using_p ())\n+\t    ;\n+\t  else if (tree match = duplicate_decls (decl, *iter, hiding))\n+\t    {\n+\t      if (TREE_CODE (match) == TYPE_DECL)\n+\t\t/* The IDENTIFIER will have the type referring to the\n+\t\t   now-smashed TYPE_DECL, because ...?  Reset it.  */\n+\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n+\n+\t      return match;\n+\t    }\n+      }\n+\n+  if (TREE_PUBLIC (scope) && TREE_PUBLIC (decl) && !not_module_p ()\n+      /* Namespaces are dealt with specially in\n+\t make_namespace_finish.  */\n+      && !(TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl)))\n+    {\n+      /* Look in the appropriate mergeable decl slot.  */\n+      tree mergeable = NULL_TREE;\n+      if (named_module_p ())\n+\tmergeable = BINDING_VECTOR_CLUSTER (mvec, BINDING_SLOT_PARTITION\n+\t\t\t\t\t   / BINDING_VECTOR_SLOTS_PER_CLUSTER)\n+\t  .slots[BINDING_SLOT_PARTITION % BINDING_VECTOR_SLOTS_PER_CLUSTER];\n+      else\n+\tmergeable = BINDING_VECTOR_CLUSTER (mvec, 0).slots[BINDING_SLOT_GLOBAL];\n+\n+      for (ovl_iterator iter (mergeable); iter; ++iter)\n+\t{\n+\t  tree match = *iter;\n+\t  \n+\t  if (duplicate_decls (decl, match, hiding))\n+\t    {\n+\t      if (TREE_CODE (match) == TYPE_DECL)\n+\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n+\t      return match;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Record DECL as belonging to the current lexical scope.  Check for\n    errors (such as an incompatible declaration for the same name\n    already seen in the same scope).  IS_FRIEND is true if DECL is\n@@ -2994,6 +3644,7 @@ do_pushdecl (tree decl, bool hiding)\n       cxx_binding *binding = NULL; /* Local scope binding.  */\n       tree ns = NULL_TREE; /* Searched namespace.  */\n       tree *slot = NULL; /* Binding slot in namespace.  */\n+      tree *mslot = NULL; /* Current module slot in namespace.  */\n       tree old = NULL_TREE;\n \n       if (level->kind == sk_namespace)\n@@ -3007,7 +3658,11 @@ do_pushdecl (tree decl, bool hiding)\n \t     that's where we'll be pushing anyway.  */\n \t  slot = find_namespace_slot (ns, name, ns == current_namespace);\n \t  if (slot)\n-\t    old = MAYBE_STAT_DECL (*slot);\n+\t    {\n+\t      mslot = get_fixed_binding_slot (slot, name, BINDING_SLOT_CURRENT,\n+\t\t\t\t\t      ns == current_namespace);\n+\t      old = MAYBE_STAT_DECL (*mslot);\n+\t    }\n \t}\n       else\n \t{\n@@ -3022,6 +3677,10 @@ do_pushdecl (tree decl, bool hiding)\n       for (ovl_iterator iter (old); iter; ++iter)\n \tif (iter.using_p ())\n \t  ; /* Ignore using decls here.  */\n+\telse if (iter.hidden_p ()\n+\t\t && DECL_LANG_SPECIFIC (*iter)\n+\t\t && DECL_MODULE_IMPORT_P (*iter))\n+\t  ; /* An undeclared builtin imported from elsewhere.  */\n \telse if (tree match\n \t\t = duplicate_decls (decl, *iter, hiding, iter.hidden_p ()))\n \t  {\n@@ -3060,6 +3719,26 @@ do_pushdecl (tree decl, bool hiding)\n \t    return match;\n \t  }\n \n+      /* Check for redeclaring an import.  */\n+      if (slot && *slot && TREE_CODE (*slot) == BINDING_VECTOR)\n+\tif (tree match\n+\t    = check_module_override (decl, *slot, hiding, ns, name))\n+\t  {\n+\t    if (match == error_mark_node)\n+\t      return match;\n+\n+\t    /* We found a decl in an interface, push it into this\n+\t       binding.  */\n+\t    decl = update_binding (NULL, binding, mslot, old,\n+\t\t\t\t   match, hiding);\n+\n+\t    if (match == decl && DECL_MODULE_EXPORT_P (decl)\n+\t\t&& !DECL_MODULE_EXPORT_P (level->this_entity))\n+\t      implicitly_export_namespace (level->this_entity);\n+\n+\t    return decl;\n+\t  }\n+\n       /* We are pushing a new decl.  */\n \n       /* Skip a hidden builtin we failed to match already.  There can\n@@ -3104,25 +3783,37 @@ do_pushdecl (tree decl, bool hiding)\n \t{\n \t  ns = current_namespace;\n \t  slot = find_namespace_slot (ns, name, true);\n+\t  mslot = get_fixed_binding_slot (slot, name, BINDING_SLOT_CURRENT, true);\n \t  /* Update OLD to reflect the namespace we're going to be\n \t     pushing into.  */\n-\t  old = MAYBE_STAT_DECL (*slot);\n+\t  old = MAYBE_STAT_DECL (*mslot);\n \t}\n \n-      old = update_binding (level, binding, slot, old, decl, hiding);\n+      old = update_binding (level, binding, mslot, old, decl, hiding);\n \n       if (old != decl)\n \t/* An existing decl matched, use it.  */\n \tdecl = old;\n       else\n \t{\n \t  newbinding_bookkeeping (name, decl, level);\n-\t  \n \n \t  if (VAR_OR_FUNCTION_DECL_P (decl)\n \t      && DECL_LOCAL_DECL_P (decl)\n \t      && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n \t    push_local_extern_decl_alias (decl);\n+\n+\t  if (level->kind == sk_namespace\n+\t      && TREE_PUBLIC (level->this_entity))\n+\t    {\n+\t      if (TREE_CODE (decl) != CONST_DECL\n+\t\t  && DECL_MODULE_EXPORT_P (decl)\n+\t\t  && !DECL_MODULE_EXPORT_P (level->this_entity))\n+\t\timplicitly_export_namespace (level->this_entity);\n+\n+\t      if (!not_module_p ())\n+\t\tmaybe_record_mergeable_decl (slot, name, decl);\n+\t    }\n \t}\n     }\n   else\n@@ -3144,6 +3835,15 @@ pushdecl (tree x, bool hiding)\n   return ret;\n }\n \n+/* DECL is a new mergeable namespace-scope decl.  Add it to the\n+   mergeable entities on GSLOT.  */\n+\n+void\n+add_mergeable_namespace_entity (tree *gslot, tree decl)\n+{\n+  *gslot = ovl_make (decl, *gslot);\n+}\n+\n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n    DECL, or a modified version thereof.  */\n \n@@ -4816,7 +5516,18 @@ get_namespace_binding (tree ns, tree name)\n   if (!ns)\n     ns = global_namespace;\n   gcc_checking_assert (!DECL_NAMESPACE_ALIAS (ns));\n-  tree ret = find_namespace_value (ns, name);\n+  tree ret = NULL_TREE;\n+\n+  if (tree *b = find_namespace_slot (ns, name))\n+    {\n+      ret = *b;\n+\n+      if (TREE_CODE (ret) == BINDING_VECTOR)\n+\tret = BINDING_VECTOR_CLUSTER (ret, 0).slots[0];\n+      if (ret)\n+\tret = MAYBE_STAT_DECL (ret);\n+    }\n+\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -5119,6 +5830,8 @@ do_namespace_alias (tree alias, tree name_space)\n   DECL_CONTEXT (alias) = FROB_CONTEXT (current_scope ());\n   pushdecl (alias);\n \n+  set_originating_module (alias);\n+\n   /* Emit debug info for namespace alias.  */\n   if (!building_stmt_list_p ())\n     (*debug_hooks->early_global_decl) (alias);\n@@ -6840,31 +7553,115 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n   tree ns = b->this_entity;\n   if (tree *slot = find_namespace_slot (ns, name))\n     {\n-      /* If this is the kind of thing we're looking for, we're done.  */\n-      if (tree type = MAYBE_STAT_TYPE (*slot))\n-\t{\n-\t  if (how != TAG_how::HIDDEN_FRIEND)\n-\t    /* No longer hidden.  */\n-\t    STAT_TYPE_HIDDEN_P (*slot) = false;\n+      tree bind = *slot;\n+      if (TREE_CODE (bind) == BINDING_VECTOR)\n+\tbind = BINDING_VECTOR_CLUSTER (bind, 0).slots[BINDING_SLOT_CURRENT];\n \n-\t  return type;\n-\t}\n-      else if (tree decl = MAYBE_STAT_DECL (*slot))\n+      if (bind)\n \t{\n-\t  if (qualify_lookup (decl, LOOK_want::TYPE))\n+\t  /* If this is the kind of thing we're looking for, we're done.  */\n+\t  if (tree type = MAYBE_STAT_TYPE (bind))\n \t    {\n-\t      if (how != TAG_how::HIDDEN_FRIEND && STAT_HACK_P (*slot)\n-\t\t  && STAT_DECL_HIDDEN_P (*slot))\n+\t      if (how != TAG_how::HIDDEN_FRIEND)\n+\t\t/* No longer hidden.  */\n+\t\tSTAT_TYPE_HIDDEN_P (*slot) = false;\n+\t      \n+\t      return type;\n+\t    }\n+\t  else if (tree decl = MAYBE_STAT_DECL (bind))\n+\t    {\n+\t      if (qualify_lookup (decl, LOOK_want::TYPE))\n \t\t{\n-\t\t  if (STAT_TYPE (*slot))\n-\t\t    STAT_DECL_HIDDEN_P (*slot) = false;\n-\t\t  else\n-\t\t    /* There is no type, just remove the stat\n-\t\t       hack.  */\n-\t\t    *slot = decl;\n+\t\t  if (how != TAG_how::HIDDEN_FRIEND && STAT_HACK_P (bind)\n+\t\t      && STAT_DECL_HIDDEN_P (bind))\n+\t\t    {\n+\t\t      if (STAT_TYPE (bind))\n+\t\t\tSTAT_DECL_HIDDEN_P (bind) = false;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* There is no type, just remove the stat\n+\t\t\t     hack.  */\n+\t\t\t  if (*slot == bind)\n+\t\t\t    *slot = decl;\n+\t\t\t  else\n+\t\t\t    BINDING_VECTOR_CLUSTER (bind, 0)\n+\t\t\t      .slots[BINDING_SLOT_CURRENT] = decl;\n+\t\t\t}\n+\t\t    }\n+\t\t  return decl;\n \t\t}\n+\t    }\n+\t}\n \n-\t      return decl;\n+      if (TREE_CODE (*slot) == BINDING_VECTOR)\n+\t{\n+\t  /* We could be redeclaring a global module entity, (from GMF\n+   \t     or header unit), or from another partition, or\n+   \t     specializing an imported template.  */\n+\t  bitmap imports = get_import_bitmap ();\n+\t  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (*slot);\n+\n+\t  /* Scan the imported bindings.  */\n+\t  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (*slot);\n+\t  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t    {\n+\t      ix--;\n+\t      cluster++;\n+\t    }\n+\n+\t  /* Do this in forward order, so we load modules in an order\n+\t     the user expects.  */\n+\t  for (; ix--; cluster++)\n+\t    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t      {\n+\t\t/* Are we importing this module?  */\n+\t\tif (unsigned base = cluster->indices[jx].base)\n+\t\t  if (unsigned span = cluster->indices[jx].span)\n+\t\t    do\n+\t\t      if (bitmap_bit_p (imports, base))\n+\t\t\tgoto found;\n+\t\t    while (++base, --span);\n+\t\tcontinue;\n+\n+\t      found:;\n+\t\t/* Is it loaded?  */\n+\t\tif (cluster->slots[jx].is_lazy ())\n+\t\t  {\n+\t\t    gcc_assert (cluster->indices[jx].span == 1);\n+\t\t    lazy_load_binding (cluster->indices[jx].base,\n+\t\t\t\t       ns, name, &cluster->slots[jx]);\n+\t\t  }\n+\t\ttree bind = cluster->slots[jx];\n+\t\tif (!bind)\n+\t\t  /* Load errors could mean there's nothing here.  */\n+\t\t  continue;\n+\n+\t\t/* Extract what we can see from here.  If there's no\n+\t\t   stat_hack, then everything was exported.  */\n+\t\ttree type = NULL_TREE;\n+\n+\t\t/* If no stat hack, everything is visible.  */\n+\t\tif (STAT_HACK_P (bind))\n+\t\t  {\n+\t\t    if (STAT_TYPE_VISIBLE_P (bind))\n+\t\t      type = STAT_TYPE (bind);\n+\t\t    bind = STAT_VISIBLE (bind);\n+\t\t  }\n+\n+\t\tif (type && qualify_lookup (type, LOOK_want::TYPE))\n+\t\t  return type;\n+\n+\t\tif (bind && qualify_lookup (bind, LOOK_want::TYPE))\n+\t\t  return bind;\n+\t      }\n+\n+\t  if (!module_purview_p ())\n+\t    {\n+\t      /* We're in the global module, perhaps there's a tag\n+\t\t there?  */\n+\t      // FIXME: This isn't quite right, if we find something\n+\t      // here, from the language PoV we're not supposed to\n+\t      // know it?\n \t    }\n \t}\n     }\n@@ -7028,6 +7825,8 @@ do_pushtag (tree name, tree type, TAG_how how)\n \n       tdef = create_implicit_typedef (name, type);\n       DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n+      set_originating_module (tdef);\n+\n       decl = maybe_process_template_type_declaration\n \t(type, how == TAG_how::HIDDEN_FRIEND, b);\n       if (decl == error_mark_node)\n@@ -7487,7 +8286,31 @@ push_inline_namespaces (tree ns)\n   return count;\n }\n \n-/* Create a new namespace decl NAME in CTX.  */\n+/* SLOT is the (possibly empty) binding slot for NAME in CTX.\n+   Reuse or create a namespace NAME.  NAME is null for the anonymous\n+   namespace.  */\n+\n+static tree\n+reuse_namespace (tree *slot, tree ctx, tree name)\n+{\n+  if (modules_p () && *slot && TREE_PUBLIC (ctx) && name)\n+    {\n+      /* Public namespace.  Shared.  */\n+      tree *global_slot = slot;\n+      if (TREE_CODE (*slot) == BINDING_VECTOR)\n+\tglobal_slot = get_fixed_binding_slot (slot, name,\n+\t\t\t\t\t      BINDING_SLOT_GLOBAL, false);\n+\n+      for (ovl_iterator iter (*global_slot); iter; ++iter)\n+\t{\n+\t  tree decl = *iter;\n+\n+\t  if (TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl))\n+\t    return decl;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n \n static tree\n make_namespace (tree ctx, tree name, location_t loc, bool inline_p)\n@@ -7519,8 +8342,16 @@ make_namespace (tree ctx, tree name, location_t loc, bool inline_p)\n /* NS was newly created, finish off making it.  */\n \n static void\n-make_namespace_finish (tree ns)\n+make_namespace_finish (tree ns, tree *slot, bool from_import = false)\n {\n+  if (modules_p () && TREE_PUBLIC (ns) && (from_import || *slot != ns))\n+    {\n+      /* Merge into global slot.  */\n+      tree *gslot = get_fixed_binding_slot (slot, DECL_NAME (ns),\n+\t\t\t\t\t    BINDING_SLOT_GLOBAL, true);\n+      *gslot = ns;\n+    }\n+\n   tree ctx = CP_DECL_CONTEXT (ns);\n   cp_binding_level *scope = ggc_cleared_alloc<cp_binding_level> ();\n   scope->this_entity = ns;\n@@ -7616,6 +8447,24 @@ push_namespace (tree name, bool make_inline)\n     {\n       /* DR2061.  NS might be a member of an inline namespace.  We\n \t need to push into those namespaces.  */\n+      if (modules_p ())\n+\t{\n+\t  for (tree parent, ctx = ns; ctx != current_namespace;\n+\t       ctx = parent)\n+\t    {\n+\t      parent = CP_DECL_CONTEXT (ctx);\n+\n+\t      tree bind = *find_namespace_slot (parent, DECL_NAME (ctx), false);\n+\t      if (bind != ctx)\n+\t\t{\n+\t\t  auto &cluster = BINDING_VECTOR_CLUSTER (bind, 0);\n+\t\t  binding_slot &slot = cluster.slots[BINDING_SLOT_CURRENT];\n+\t\t  gcc_checking_assert (!(tree)slot || (tree)slot == ctx);\n+\t\t  slot = ctx;\n+\t\t}\n+\t    }\n+\t}\n+\n       count += push_inline_namespaces (CP_DECL_CONTEXT (ns));\n       if (DECL_SOURCE_LOCATION (ns) == BUILTINS_LOCATION)\n \t/* It's not builtin now.  */\n@@ -7626,7 +8475,11 @@ push_namespace (tree name, bool make_inline)\n       /* Before making a new namespace, see if we already have one in\n \t the existing partitions of the current namespace.  */\n       tree *slot = find_namespace_slot (current_namespace, name, false);\n-      ns = make_namespace (current_namespace, name, input_location, make_inline);\n+      if (slot)\n+\tns = reuse_namespace (slot, current_namespace, name);\n+      if (!ns)\n+\tns = make_namespace (current_namespace, name,\n+\t\t\t     input_location, make_inline);\n \n       if (pushdecl (ns) == error_mark_node)\n \tns = NULL_TREE;\n@@ -7640,7 +8493,7 @@ push_namespace (tree name, bool make_inline)\n \t      /* This should find the slot created by pushdecl.  */\n \t      gcc_checking_assert (slot && *slot == ns);\n \t    }\n-\t  make_namespace_finish (ns);\n+\t  make_namespace_finish (ns, slot);\n \n \t  /* Add the anon using-directive here, we don't do it in\n \t     make_namespace_finish.  */\n@@ -7651,6 +8504,12 @@ push_namespace (tree name, bool make_inline)\n \n   if (ns)\n     {\n+      /* A public namespace is exported only if explicitly marked, or\n+\t it contains exported entities.  */\n+      if (!DECL_MODULE_EXPORT_P (ns) && TREE_PUBLIC (ns)\n+\t  && module_exporting_p ())\n+\timplicitly_export_namespace (ns);\n+\n       if (make_inline && !DECL_NAMESPACE_INLINE_P (ns))\n \t{\n \t  error_at (input_location,\n@@ -7836,8 +8695,8 @@ maybe_save_operator_binding (tree e)\n \n   /* Do this for lambdas and code that will emit a CMI.  In a module's\n      GMF we don't yet know whether there will be a CMI.  */\n-  if (!current_lambda_expr ())\n-    return;\n+  if (!module_has_cmi_p () && !global_purview_p () && !current_lambda_expr())\n+     return;\n \n   tree fnname = ovl_op_identifier (false, TREE_CODE (e));\n   if (!fnname)"}, {"sha": "4386debf99d83a9fb35a4db664d335abe649899f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0979d8f22a97eb231ebf544c512353372bdb25d/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c0979d8f22a97eb231ebf544c512353372bdb25d", "patch": "@@ -480,4 +480,7 @@ extern void maybe_save_operator_binding (tree);\n extern void push_operator_bindings (void);\n extern void discard_operator_bindings (tree);\n \n+/* Lower level interface for modules. */\n+extern void add_mergeable_namespace_entity (tree *slot, tree decl);\n+\n #endif /* GCC_CP_NAME_LOOKUP_H */"}]}