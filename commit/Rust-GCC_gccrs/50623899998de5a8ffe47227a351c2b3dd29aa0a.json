{"sha": "50623899998de5a8ffe47227a351c2b3dd29aa0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2MjM4OTk5OThkZTVhOGZmZTQ3MjI3YTM1MWMyYjNkZDI5YWEwYQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-05T00:14:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-05T00:14:00Z"}, "message": "Merge #655\n\n655: Generic Qualified Paths r=philberty a=philberty\n\nThis fixes how we handle associated types in relation to generic\r\ntraits. Generic traits are interesting because, a TypePath usually\r\nresolves to a normal TyTy type which can be substituted using the\r\nmapper classes, but a trait is a definition of behaviour which \r\nis made up of types, constants or functions. In order to handle\r\ngeneric traits we must add substitution support to the associated types\r\nwhich are represented by projections see this commit for detail on the changes\r\n0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759\r\n\r\nAlso see https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/struct.ProjectionTy.html\r\n\r\nFixes #434 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "4fac02e7fc1b271b1bf50d8812e150ab8ee30db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fac02e7fc1b271b1bf50d8812e150ab8ee30db9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50623899998de5a8ffe47227a351c2b3dd29aa0a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhNAvICRBK7hj4Ov3rIwAA3voIAGnwPLDGdYk9WyXBLUX6dskn\nOGfknU5pUII5dITNmHwCox0h+zopfl2GesRKg3E7xcbzzrdlCN+a0T9f5xGXbsT/\nxTotm74SZHOU2XXIdPYcYJEvHKyt+6ivVtiYzx5W/NwhqqQlRfY5RJgEK3YIGrwY\nMzL/WeE0+IPvUvf5TcHLo5c0Yz5VdC/TdOOPDbWciZvTyqFm6eGebNV5e0MNEnYu\n10IjqeQAq5RpXFwy69D0Uj3Y0fnZeqNJXE48EJp9GZ2IAmeA+COLKaUkLn466Z5B\nZEH9OpXo3kWGkLmTFbb0LFhI+it5UkvRH+BVV2Cm82ZauhXwDYvq43PnX9Y8zTI=\n=++jh\n-----END PGP SIGNATURE-----\n", "payload": "tree 4fac02e7fc1b271b1bf50d8812e150ab8ee30db9\nparent c33c6f3676dfca1a6bd7984cebf5028c015ea182\nparent 0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630800840 +0000\ncommitter GitHub <noreply@github.com> 1630800840 +0000\n\nMerge #655\n\n655: Generic Qualified Paths r=philberty a=philberty\n\nThis fixes how we handle associated types in relation to generic\r\ntraits. Generic traits are interesting because, a TypePath usually\r\nresolves to a normal TyTy type which can be substituted using the\r\nmapper classes, but a trait is a definition of behaviour which \r\nis made up of types, constants or functions. In order to handle\r\ngeneric traits we must add substitution support to the associated types\r\nwhich are represented by projections see this commit for detail on the changes\r\n0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759\r\n\r\nAlso see https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/struct.ProjectionTy.html\r\n\r\nFixes #434 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50623899998de5a8ffe47227a351c2b3dd29aa0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50623899998de5a8ffe47227a351c2b3dd29aa0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50623899998de5a8ffe47227a351c2b3dd29aa0a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c33c6f3676dfca1a6bd7984cebf5028c015ea182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33c6f3676dfca1a6bd7984cebf5028c015ea182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c33c6f3676dfca1a6bd7984cebf5028c015ea182"}, {"sha": "0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0798add3d3c1bf4b20ecc1b4fa1047ba4ba19759"}], "stats": {"total": 1085, "additions": 915, "deletions": 170}, "files": [{"sha": "64b9247de8d72e7e24802cac44041f206bef3ab3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -83,6 +83,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n+    rust/rust-hir-type-check-type.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     $(END)"}, {"sha": "0578329f54b90f28f1b0a500c712bb60ee8fad14", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -3535,7 +3535,16 @@ class Trait : public VisItem\n \n   void insert_implict_self (std::unique_ptr<AST::GenericParam> &&param)\n   {\n-    generic_params.push_back (std::move (param));\n+    std::vector<std::unique_ptr<GenericParam>> new_list;\n+    new_list.reserve (generic_params.size () + 1);\n+\n+    new_list.push_back (std::move (param));\n+    for (auto &p : generic_params)\n+      {\n+\tnew_list.push_back (std::move (p));\n+      }\n+\n+    generic_params = std::move (new_list);\n   }\n \n protected:"}, {"sha": "8992993c15d931480fb9140941bc6ce3d45a04a0", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -1029,6 +1029,15 @@ class QualifiedPathInType : public TypeNoBounds\n   }\n \n   Location get_locus () const override final { return locus; }\n+\n+  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n };\n } // namespace AST\n } // namespace Rust"}, {"sha": "bffe97c5e8c4f7d483a9d6316aff37880c669242", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -336,7 +336,10 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    type.get ()->accept_vis (*this);\n+  }\n \n   void visit (TyTy::PlaceholderType &type) override\n   {"}, {"sha": "464045a43169001e4260e69ab49910424469bf25", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -28,6 +28,7 @@ namespace HIR {\n \n class ASTLowerTypePath : public ASTLoweringBase\n {\n+protected:\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n@@ -88,9 +89,30 @@ class ASTLowerTypePath : public ASTLoweringBase\n     mappings->insert_hir_type (crate_num, hirid, translated);\n   }\n \n+protected:\n+  HIR::TypePathSegment *translated_segment;\n+\n private:\n   HIR::TypePath *translated;\n-  HIR::TypePathSegment *translated_segment;\n+};\n+\n+class ASTLowerQualifiedPathInType : public ASTLowerTypePath\n+{\n+  using ASTLowerTypePath::visit;\n+\n+public:\n+  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type)\n+  {\n+    ASTLowerQualifiedPathInType resolver;\n+    type.accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::QualifiedPathInType &path) override;\n+\n+private:\n+  HIR::QualifiedPathInType *translated;\n };\n \n class ASTLoweringType : public ASTLoweringBase\n@@ -187,6 +209,11 @@ class ASTLoweringType : public ASTLoweringBase\n     translated = ASTLowerTypePath::translate (path);\n   }\n \n+  void visit (AST::QualifiedPathInType &path) override\n+  {\n+    translated = ASTLowerQualifiedPathInType::translate (path);\n+  }\n+\n   void visit (AST::ArrayType &type) override\n   {\n     HIR::Type *translated_type"}, {"sha": "e8784b61da5a95f681a7bd865373fc93f16f5d5e", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -450,6 +450,62 @@ ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n     segment.get_locus ());\n }\n \n+void\n+ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping qual_mappings (\n+    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n+    UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Type *qual_type = ASTLoweringType::translate (\n+    path.get_qualified_path_type ().get_type ().get ());\n+  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n+    path.get_qualified_path_type ().get_as_type_path ());\n+\n+  HIR::QualifiedPathType qual_path_type (\n+    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n+    std::unique_ptr<HIR::TypePath> (qual_trait),\n+    path.get_qualified_path_type ().get_locus ());\n+\n+  translated_segment = nullptr;\n+  path.get_associated_segment ()->accept_vis (*this);\n+  if (translated_segment == nullptr)\n+    {\n+      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n+\t\t\t\"failed to translate AST TypePathSegment\");\n+      return;\n+    }\n+  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n+\n+  std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n+  path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n+    translated_segment = nullptr;\n+    seg->accept_vis (*this);\n+    if (translated_segment == nullptr)\n+      {\n+\trust_fatal_error (seg->get_locus (),\n+\t\t\t  \"failed to translate AST TypePathSegment\");\n+\treturn false;\n+      }\n+\n+    translated_segments.push_back (\n+      std::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    return true;\n+  });\n+\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::QualifiedPathInType (std::move (mapping),\n+\t\t\t\t\t     std::move (qual_path_type),\n+\t\t\t\t\t     std::move (associated_segment),\n+\t\t\t\t\t     std::move (translated_segments),\n+\t\t\t\t\t     path.get_locus ());\n+  mappings->insert_hir_type (crate_num, hirid, translated);\n+}\n+\n // rust-ast-lower-base\n \n HIR::Type *"}, {"sha": "13e246ff489b50337cd4bf342df651b16ab0f60a", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -767,6 +767,27 @@ struct QualifiedPathType\n     rust_assert (has_as_clause ());\n     return trait;\n   }\n+\n+  bool trait_has_generic_args () const\n+  {\n+    rust_assert (has_as_clause ());\n+    bool is_generic_seg = trait->get_final_segment ()->get_type ()\n+\t\t\t  == TypePathSegment::SegmentType::GENERIC;\n+    if (!is_generic_seg)\n+      return false;\n+\n+    TypePathSegmentGeneric *seg = static_cast<TypePathSegmentGeneric *> (\n+      trait->get_final_segment ().get ());\n+    return seg->has_generic_args ();\n+  }\n+\n+  GenericArgs &get_trait_generic_args ()\n+  {\n+    rust_assert (trait_has_generic_args ());\n+    TypePathSegmentGeneric *seg = static_cast<TypePathSegmentGeneric *> (\n+      trait->get_final_segment ().get ());\n+    return seg->get_generic_args ();\n+  }\n };\n \n /* HIR node representing a qualified path-in-expression pattern (path that\n@@ -819,6 +840,7 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n class QualifiedPathInType : public TypeNoBounds\n {\n   QualifiedPathType path_type;\n+  std::unique_ptr<TypePathSegment> associated_segment;\n   std::vector<std::unique_ptr<TypePathSegment> > segments;\n   Location locus;\n \n@@ -840,9 +862,11 @@ class QualifiedPathInType : public TypeNoBounds\n public:\n   QualifiedPathInType (\n     Analysis::NodeMapping mappings, QualifiedPathType qual_path_type,\n+    std::unique_ptr<TypePathSegment> associated_segment,\n     std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n     Location locus = Location ())\n     : TypeNoBounds (mappings), path_type (std::move (qual_path_type)),\n+      associated_segment (std::move (associated_segment)),\n       segments (std::move (path_segments)), locus (locus)\n   {}\n \n@@ -883,6 +907,20 @@ class QualifiedPathInType : public TypeNoBounds\n   std::string as_string () const override;\n \n   void accept_vis (HIRVisitor &vis) override;\n+\n+  QualifiedPathType &get_path_type () { return path_type; }\n+\n+  std::unique_ptr<TypePathSegment> &get_associated_segment ()\n+  {\n+    return associated_segment;\n+  }\n+\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+\n+  Location get_locus () { return locus; }\n };\n } // namespace HIR\n } // namespace Rust"}, {"sha": "9ad465a274ba35086b1e746d81d7f7ce375f9cd3", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -97,6 +97,7 @@ class ResolveTraitItemTypeToCanonicalPath\n \n class ResolveTypeToCanonicalPath : public ResolverBase\n {\n+protected:\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n@@ -128,7 +129,7 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n \n   static bool type_resolve_generic_args (AST::GenericArgs &args);\n \n-private:\n+protected:\n   ResolveTypeToCanonicalPath (bool include_generic_args,\n \t\t\t      bool type_resolve_generic_args)\n     : ResolverBase (UNKNOWN_NODEID), result (CanonicalPath::create_empty ()),\n@@ -182,8 +183,10 @@ class TraitImplProjection\n   }\n };\n \n-class ResolveRelativeTypePath\n+class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n {\n+  using ResolveTypeToCanonicalPath::visit;\n+\n public:\n   static NodeId go (AST::TypePath &path, NodeId parent,\n \t\t    const CanonicalPath &prefix,\n@@ -218,6 +221,64 @@ class ResolveRelativeTypePath\n \n     return resolved_node;\n   }\n+\n+  static NodeId go (AST::QualifiedPathInType &path, NodeId parent,\n+\t\t    const CanonicalPath &prefix,\n+\t\t    bool canonicalize_type_with_generics)\n+  {\n+    auto &qualified_path = path.get_qualified_path_type ();\n+    CanonicalPath result = prefix;\n+    if (!resolve_qual_seg (qualified_path, result))\n+      return UNKNOWN_NODEID;\n+\n+    // resolve the associated impl\n+    auto resolver = Resolver::get ();\n+    NodeId projection_resolved_id = UNKNOWN_NODEID;\n+    if (!resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+      {\n+\trust_error_at (path.get_locus (),\n+\t\t       \"failed to resolve associated path: %s\",\n+\t\t       result.get ().c_str ());\n+\n+\treturn UNKNOWN_NODEID;\n+      }\n+    // mark the resolution for this\n+    resolver->insert_resolved_name (qualified_path.get_node_id (),\n+\t\t\t\t    projection_resolved_id);\n+\n+    // qualified types are similar to other paths in that we cannot guarantee\n+    // that we can resolve the path at name resolution. We must look up\n+    // associated types and type information to figure this out properly\n+\n+    ResolveRelativeTypePath o (result);\n+    std::unique_ptr<AST::TypePathSegment> &associated\n+      = path.get_associated_segment ();\n+\n+    associated->accept_vis (o);\n+    if (o.failure_flag)\n+      return UNKNOWN_NODEID;\n+\n+    for (auto &seg : path.get_segments ())\n+      {\n+\tseg->accept_vis (o);\n+\tif (o.failure_flag)\n+\t  return UNKNOWN_NODEID;\n+      }\n+\n+    // we only return the projection id for now since we need the type system to\n+    // resolve the associated types in this path\n+    return projection_resolved_id;\n+  }\n+\n+private:\n+  ResolveRelativeTypePath (CanonicalPath qualified_path)\n+    : ResolveTypeToCanonicalPath (true, true)\n+  {\n+    result = qualified_path;\n+  }\n+\n+  static bool resolve_qual_seg (AST::QualifiedPathType &seg,\n+\t\t\t\tCanonicalPath &result);\n };\n \n class ResolveType : public ResolverBase\n@@ -275,6 +336,15 @@ class ResolveType : public ResolverBase\n       }\n   }\n \n+  void visit (AST::QualifiedPathInType &path) override\n+  {\n+    resolved_node\n+      = ResolveRelativeTypePath::go (path, parent,\n+\t\t\t\t     CanonicalPath::create_empty (),\n+\t\t\t\t     canonicalize_type_with_generics);\n+    ok = resolved_node != UNKNOWN_NODEID;\n+  }\n+\n   void visit (AST::ArrayType &type) override;\n \n   void visit (AST::ReferenceType &type) override"}, {"sha": "fab70b5916aec77522e9b58cf9df8b268c855385", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -243,8 +243,8 @@ Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n void\n Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n {\n-  auto it = resolved_types.find (refId);\n-  rust_assert (it == resolved_types.end ());\n+  // auto it = resolved_types.find (refId);\n+  // rust_assert (it == resolved_types.end ());\n \n   resolved_types[refId] = defId;\n   get_type_scope ().append_reference_for_def (refId, defId);\n@@ -560,17 +560,15 @@ ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n   ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n \t\t   canonicalize_type_with_generics);\n \n-  bool canonicalize_type_args = true;\n   bool type_resolve_generic_args = true;\n-\n   CanonicalPath impl_type_seg\n     = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n-\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   canonicalize_type_with_generics,\n \t\t\t\t\t   type_resolve_generic_args);\n \n   CanonicalPath trait_type_seg\n     = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n-\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   canonicalize_type_with_generics,\n \t\t\t\t\t   type_resolve_generic_args);\n   CanonicalPath root_seg_path\n     = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n@@ -744,5 +742,48 @@ ResolveItem::resolve_extern_item (AST::ExternalItem *item)\n   ResolveExternItem::go (item);\n }\n \n+// qualified path in type\n+\n+bool\n+ResolveRelativeTypePath::resolve_qual_seg (AST::QualifiedPathType &seg,\n+\t\t\t\t\t   CanonicalPath &result)\n+{\n+  if (seg.is_error ())\n+    {\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return false;\n+    }\n+  bool include_generic_args_in_path = false;\n+\n+  NodeId type_resolved_node\n+    = ResolveType::go (seg.get_type ().get (), seg.get_node_id ());\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*seg.get_type ().get (),\n+\t\t\t\t\t   include_generic_args_in_path);\n+  if (!seg.has_as_clause ())\n+    {\n+      result = result.append (impl_type_seg);\n+      return true;\n+    }\n+\n+  NodeId trait_resolved_node\n+    = ResolveType::go (&seg.get_as_type_path (), seg.get_node_id ());\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (seg.get_as_type_path (),\n+\t\t\t\t\t   include_generic_args_in_path);\n+  CanonicalPath projection\n+    = TraitImplProjection::resolve (seg.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  result = result.append (projection);\n+  return true;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "dd51f837df19a75c97d0c80b439f65274458268b", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -276,6 +276,18 @@ class PathProbeType : public TypeCheckBase\n \n \tTyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n \n+\tif (impl != nullptr)\n+\t  {\n+\t    HirId impl_block_id = impl->get_mappings ().get_hirid ();\n+\t    AssociatedImplTrait *lookup_associated = nullptr;\n+\t    bool found_impl_trait\n+\t      = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t       &lookup_associated);\n+\t    // see testsuite/rust/compile/torture/traits10.rs this can be false\n+\t    if (found_impl_trait)\n+\t      lookup_associated->setup_associated_types ();\n+\t  }\n+\n \t// we can substitute the Self with the receiver here\n \tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n \t  {"}, {"sha": "f05ff0c7ab04ee3ca7d3eb1ab53ae0eced8b084d", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -47,26 +47,7 @@ class TraitItemReference\n \n   TraitItemReference (TraitItemReference const &other);\n \n-  TraitItemReference &operator= (TraitItemReference const &other)\n-  {\n-    identifier = other.identifier;\n-    optional_flag = other.optional_flag;\n-    type = other.type;\n-    hir_trait_item = other.hir_trait_item;\n-    self = other.self;\n-    locus = other.locus;\n-    context = other.context;\n-\n-    inherited_substitutions.clear ();\n-    inherited_substitutions.reserve (other.inherited_substitutions.size ());\n-    for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n-      inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n-\n-    return *this;\n-  }\n-\n-  TraitItemReference (TraitItemReference &&other) = default;\n-  TraitItemReference &operator= (TraitItemReference &&other) = default;\n+  TraitItemReference &operator= (TraitItemReference const &other);\n \n   static TraitItemReference error ()\n   {\n@@ -368,6 +349,7 @@ class AssociatedImplTrait\n \n   TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n \t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n+\t\t\t\t      HIR::GenericArgs &trait_generics,\n \t\t\t\t      Location expr_locus);\n \n private:"}, {"sha": "be58840d8e9517bf2ab46cc861a67020e2937249", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -58,7 +58,7 @@ ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n \n   resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t TraitItemReference::TraitItemType::FN, &fn,\n-\t\t\t\t self, substitutions, locus);\n+\t\t\t\t self, std::move (substitutions), locus);\n }\n \n // TraitItemReference items\n@@ -196,7 +196,7 @@ TraitItemReference::get_parent_trait_mappings () const\n TyTy::BaseType *\n AssociatedImplTrait::get_projected_type (\n   const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n-  Location expr_locus)\n+  HIR::GenericArgs &trait_generics, Location expr_locus)\n {\n   TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n \n@@ -219,11 +219,17 @@ AssociatedImplTrait::get_projected_type (\n       std::vector<TyTy::SubstitutionArg> mappings;\n       mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n \n-      Location locus; // FIXME\n-      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n+\t\t\t\t\t       expr_locus);\n       trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n     }\n \n+  if (!trait_generics.is_empty ())\n+    {\n+      trait_item_tyty\n+\t= SubstMapper::Resolve (trait_item_tyty, expr_locus, &trait_generics);\n+    }\n+\n   return trait_item_tyty;\n }\n "}, {"sha": "365994fbd552aed52d48f6201691d7acd02750e7", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -37,9 +37,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    ResolveTraitItemToRef resolver (self, substitutions);\n+    ResolveTraitItemToRef resolver (self, std::move (substitutions));\n     item.accept_vis (resolver);\n-    return resolver.resolved;\n+    return std::move (resolver.resolved);\n   }\n \n   void visit (HIR::TraitItemType &type) override;\n@@ -51,9 +51,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n private:\n   ResolveTraitItemToRef (\n     TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+    std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n     : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n-      substitutions (substitutions)\n+      substitutions (std::move (substitutions))\n   {}\n \n   TraitItemReference resolved;\n@@ -146,8 +146,14 @@ class TraitResolver : public TypeCheckBase\n     std::vector<TraitItemReference> item_refs;\n     for (auto &item : trait_reference->get_trait_items ())\n       {\n+\t// make a copy of the substs\n+\tstd::vector<TyTy::SubstitutionParamMapping> item_subst;\n+\tfor (auto &sub : substitutions)\n+\t  item_subst.push_back (sub.clone ());\n+\n \tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get (), self, substitutions);\n+\t  = ResolveTraitItemToRef::Resolve (*item.get (), self,\n+\t\t\t\t\t    std::move (item_subst));\n \titem_refs.push_back (std::move (trait_item_ref));\n       }\n "}, {"sha": "59ea4ef781b830703f35c8d1a1ea3a655cae146d", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -303,11 +303,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static const TraitItemReference &Resolve (HIR::ImplItem *item,\n-\t\t\t\t\t    TyTy::BaseType *self,\n-\t\t\t\t\t    TraitReference &trait_reference)\n+  static const TraitItemReference &\n+  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n+\t   TraitReference &trait_reference,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    TypeCheckImplItemWithTrait resolver (self, trait_reference);\n+    TypeCheckImplItemWithTrait resolver (self, trait_reference, substitutions);\n     item->accept_vis (resolver);\n     return resolver.resolved_trait_item;\n   }\n@@ -383,7 +384,17 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \t  trait_reference.get_name ().c_str ());\n       }\n \n-    resolved_trait_item.associated_type_set (lookup);\n+    rust_debug_loc (type.get_locus (), \"type-alias within impl block\");\n+    lookup->debug ();\n+\n+    // its actually a projection, since we need a way to actually bind the\n+    // generic substitutions to the type itself\n+    TyTy::ProjectionType *projection = new TyTy::ProjectionType (\n+      type.get_mappings ().get_hirid (), lookup, &trait_reference,\n+      resolved_trait_item.get_mappings ().get_defid (), substitutions);\n+\n+    context->insert_type (type.get_mappings (), projection);\n+    resolved_trait_item.associated_type_set (projection);\n   }\n \n   void visit (HIR::Function &function) override\n@@ -452,10 +463,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   }\n \n private:\n-  TypeCheckImplItemWithTrait (TyTy::BaseType *self,\n-\t\t\t      TraitReference &trait_reference)\n+  TypeCheckImplItemWithTrait (\n+    TyTy::BaseType *self, TraitReference &trait_reference,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n     : TypeCheckImplItem (self), trait_reference (trait_reference),\n-      resolved_trait_item (TraitItemReference::error_node ())\n+      resolved_trait_item (TraitItemReference::error_node ()),\n+      substitutions (substitutions)\n   {\n     rust_assert (is_trait_impl_block ());\n   }\n@@ -464,6 +477,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   TraitReference &trait_reference;\n   TraitItemReference &resolved_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n } // namespace Resolver"}, {"sha": "476a9616aed3b732cc60da4019dac72377100c92", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -43,6 +43,33 @@ class TypeCheckItem : public TypeCheckBase\n \n   void visit (HIR::ImplBlock &impl_block) override\n   {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (impl_block.has_generics ())\n+      {\n+\tfor (auto &generic_param : impl_block.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  TyTy::BaseType *l = nullptr;\n+\t\t  bool ok = context->lookup_type (\n+\t\t    generic_param->get_mappings ().get_hirid (), &l);\n+\t\t  if (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t\t    {\n+\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n+\t\t\tstatic_cast<TyTy::ParamType *> (l)));\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n     TraitReference *trait_reference = &TraitReference::error_node ();\n     if (impl_block.has_trait_ref ())\n       {\n@@ -72,7 +99,8 @@ class TypeCheckItem : public TypeCheckBase\n \t  {\n \t    auto &trait_item_ref\n \t      = TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n-\t\t\t\t\t\t     *trait_reference);\n+\t\t\t\t\t\t     *trait_reference,\n+\t\t\t\t\t\t     substitutions);\n \t    trait_item_refs.push_back (trait_item_ref);\n \t  }\n       }"}, {"sha": "8b53e440ce9b9a1b94265b80977468e4bfaa8934", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -74,7 +74,6 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n   rust_assert (found_impl_trait);\n \n-  DefId resolved_item_id = UNKNOWN_DEFID;\n   HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n \n   const TraitItemReference *trait_item_ref = nullptr;\n@@ -85,10 +84,14 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n       rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n       return;\n     }\n-  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n \n+  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n+\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n+\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+\n+  lookup_associated->setup_associated_types ();\n   infered = lookup_associated->get_projected_type (\n-    trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+    trait_item_ref, root, item_seg.get_mappings ().get_hirid (), trait_generics,\n     item_seg.get_locus ());\n \n   // turbo-fish segment path::<ty>\n@@ -106,12 +109,6 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n \t\t\t\t      &item_seg.get_generic_args ());\n     }\n \n-  TyTy::ProjectionType *projection\n-    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n-\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\tresolved_item_id, lookup_associated);\n-  context->insert_type (qual_path_type.get_mappings (), projection);\n-\n   // continue on as a path-in-expression\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = expr.get_segments ().size () <= 1;\n@@ -340,6 +337,7 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  candidates\n \t    = PathProbeType::Probe (prev_segment, seg.get_segment (), false,\n \t\t\t\t    probe_bounds, ignore_mandatory_trait_items);\n+\n \t  if (candidates.size () == 0)\n \t    {\n \t      rust_error_at ("}, {"sha": "b54a403757d3315afbbf28c59bccc764ee42732d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -0,0 +1,225 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckType::visit (HIR::TypePath &path)\n+{\n+  // lookup the Node this resolves to\n+  NodeId ref;\n+  auto nid = path.get_mappings ().get_nodeid ();\n+  if (!resolver->lookup_resolved_type (nid, &ref))\n+    {\n+      rust_fatal_error (path.get_locus (), \"failed to resolve node '%d' to HIR\",\n+\t\t\tnid);\n+      return;\n+    }\n+\n+  HirId hir_lookup;\n+  if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR %d for node '%s'\",\n+\t\t     ref, path.as_string ().c_str ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!context->lookup_type (hir_lookup, &lookup))\n+    {\n+      rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *path_type = lookup->clone ();\n+  path_type->set_ref (path.get_mappings ().get_hirid ());\n+\n+  HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n+  HIR::GenericArgs args = TypeCheckResolveGenericArguments::resolve (final_seg);\n+\n+  bool is_big_self = final_seg->is_ident_only ()\n+\t\t     && (final_seg->as_string ().compare (\"Self\") == 0);\n+\n+  if (path_type->needs_generic_substitutions ())\n+    {\n+      if (is_big_self)\n+\t{\n+\t  translated = path_type;\n+\t  return;\n+\t}\n+\n+      translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n+      if (translated->get_kind () != TyTy::TypeKind::ERROR\n+\t  && mappings != nullptr)\n+\t{\n+\t  check_for_unconstrained (args.get_type_args ());\n+\t}\n+    }\n+  else if (!args.is_empty ())\n+    {\n+      rust_error_at (path.get_locus (),\n+\t\t     \"TypePath %s declares generic arguments but \"\n+\t\t     \"the type %s does not have any\",\n+\t\t     path.as_string ().c_str (),\n+\t\t     translated->as_string ().c_str ());\n+    }\n+  else\n+    {\n+      translated = path_type;\n+    }\n+}\n+\n+void\n+TypeCheckType::visit (HIR::QualifiedPathInType &path)\n+{\n+  HIR::QualifiedPathType qual_path_type = path.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_debug_loc (path.get_locus (), \"failed to resolve the root\");\n+      return;\n+    }\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      // then this is just a normal path-in-expression\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      bool ok = resolver->lookup_resolved_type (\n+\tqual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t&root_resolved_node_id);\n+      rust_assert (ok);\n+\n+      resolve_segments (root_resolved_node_id, path.get_segments (), 0,\n+\t\t\ttranslated, path.get_mappings (), path.get_locus ());\n+    }\n+\n+  // Resolve the trait now\n+  TraitReference *trait_ref\n+    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    return;\n+\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool ok = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  rust_assert (ok);\n+\n+  HirId impl_block_id;\n+  ok = mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n+\t\t\t\t     impl_resolved_id, &impl_block_id);\n+  rust_assert (ok);\n+\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  bool found_impl_trait\n+    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n+  rust_assert (found_impl_trait);\n+\n+  std::unique_ptr<HIR::TypePathSegment> &item_seg\n+    = path.get_associated_segment ();\n+\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  ok\n+    = trait_ref->lookup_trait_item (item_seg->get_ident_segment ().as_string (),\n+\t\t\t\t    &trait_item_ref);\n+  if (!ok)\n+    {\n+      rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+\n+  // project\n+  lookup_associated->setup_associated_types ();\n+\n+  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n+\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n+\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+\n+  translated = lookup_associated->get_projected_type (\n+    trait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n+    trait_generics, item_seg->get_locus ());\n+\n+  if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n+    {\n+      // lets grab the actual projection type\n+      TyTy::PlaceholderType *p\n+\t= static_cast<TyTy::PlaceholderType *> (translated);\n+      if (p->can_resolve ())\n+\t{\n+\t  translated = p->resolve ();\n+\t}\n+    }\n+\n+  if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n+    {\n+      HIR::TypePathSegmentGeneric &generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric &> (*item_seg.get ());\n+\n+      // turbo-fish segment path::<ty>\n+      if (generic_seg.has_generic_args ())\n+\t{\n+\t  if (!translated->can_substitute ())\n+\t    {\n+\t      rust_error_at (item_seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     translated->as_string ().c_str ());\n+\t      translated\n+\t\t= new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t      return;\n+\t    }\n+\t  translated = SubstMapper::Resolve (translated, path.get_locus (),\n+\t\t\t\t\t     &generic_seg.get_generic_args ());\n+\t}\n+    }\n+\n+  // continue on as a path-in-expression\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = path.get_segments ().empty ();\n+  if (fully_resolved)\n+    {\n+      resolver->insert_resolved_name (path.get_mappings ().get_nodeid (),\n+\t\t\t\t      root_resolved_node_id);\n+      context->insert_receiver (path.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  resolve_segments (root_resolved_node_id, path.get_segments (), 0, translated,\n+\t\t    path.get_mappings (), path.get_locus ());\n+}\n+\n+void\n+TypeCheckType::resolve_segments (\n+  NodeId root_resolved_node_id,\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+  TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+  Location expr_locus)\n+{\n+  gcc_unreachable ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c02a3693e206ec205d55a7b978152b7bde763533", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright (C) 2020 Free Software Foundation, Inc.\n \n // This file is part of GCC.\n@@ -117,72 +116,9 @@ class TypeCheckType : public TypeCheckBase\n       = new TyTy::TupleType (tuple.get_mappings ().get_hirid (), fields);\n   }\n \n-  void visit (HIR::TypePath &path) override\n-  {\n-    // lookup the Node this resolves to\n-    NodeId ref;\n-    auto nid = path.get_mappings ().get_nodeid ();\n-    if (!resolver->lookup_resolved_type (nid, &ref))\n-      {\n-\trust_fatal_error (path.get_locus (),\n-\t\t\t  \"failed to resolve node '%d' to HIR\", nid);\n-\treturn;\n-      }\n-\n-    HirId hir_lookup;\n-    if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"failed to lookup HIR %d for node '%s'\", ref,\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *lookup = nullptr;\n-    if (!context->lookup_type (hir_lookup, &lookup))\n-      {\n-\trust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *path_type = lookup->clone ();\n-    path_type->set_ref (path.get_mappings ().get_hirid ());\n-\n-    HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n-    HIR::GenericArgs args\n-      = TypeCheckResolveGenericArguments::resolve (final_seg);\n+  void visit (HIR::TypePath &path) override;\n \n-    bool is_big_self = final_seg->is_ident_only ()\n-\t\t       && (final_seg->as_string ().compare (\"Self\") == 0);\n-\n-    if (path_type->needs_generic_substitutions ())\n-      {\n-\tif (is_big_self)\n-\t  {\n-\t    translated = path_type;\n-\t    return;\n-\t  }\n-\n-\ttranslated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n-\tif (translated->get_kind () != TyTy::TypeKind::ERROR\n-\t    && mappings != nullptr)\n-\t  {\n-\t    check_for_unconstrained (args.get_type_args ());\n-\t  }\n-      }\n-    else if (!args.is_empty ())\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"TypePath %s declares generic arguments but \"\n-\t\t       \"the type %s does not have any\",\n-\t\t       path.as_string ().c_str (),\n-\t\t       translated->as_string ().c_str ());\n-      }\n-    else\n-      {\n-\ttranslated = path_type;\n-      }\n-  }\n+  void visit (HIR::QualifiedPathInType &path) override;\n \n   void visit (HIR::ArrayType &type) override;\n \n@@ -246,6 +182,12 @@ class TypeCheckType : public TypeCheckBase\n       }\n   }\n \n+  void resolve_segments (\n+    NodeId root_resolved_node_id,\n+    std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n+    TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n+    Location expr_locus);\n+\n   std::vector<TyTy::SubstitutionParamMapping> *subst_mappings;\n   TyTy::BaseType *translated;\n };"}, {"sha": "453f7431ce9d42e81d4fa5e1b323afcacb10a974", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -408,8 +408,9 @@ TraitItemReference::TraitItemReference (\n   HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n   std::vector<TyTy::SubstitutionParamMapping> substitutions, Location locus)\n   : identifier (identifier), optional_flag (optional), type (type),\n-    hir_trait_item (hir_trait_item), inherited_substitutions (substitutions),\n-    locus (locus), self (self), context (TypeCheckContext::get ())\n+    hir_trait_item (hir_trait_item),\n+    inherited_substitutions (std::move (substitutions)), locus (locus),\n+    self (self), context (TypeCheckContext::get ())\n {}\n \n TraitItemReference::TraitItemReference (TraitItemReference const &other)\n@@ -420,7 +421,28 @@ TraitItemReference::TraitItemReference (TraitItemReference const &other)\n   inherited_substitutions.clear ();\n   inherited_substitutions.reserve (other.inherited_substitutions.size ());\n   for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n-    inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+}\n+\n+TraitItemReference &\n+TraitItemReference::operator= (TraitItemReference const &other)\n+{\n+  identifier = other.identifier;\n+  optional_flag = other.optional_flag;\n+  type = other.type;\n+  hir_trait_item = other.hir_trait_item;\n+  self = other.self;\n+  locus = other.locus;\n+  context = other.context;\n+\n+  inherited_substitutions.clear ();\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (\n+      other.inherited_substitutions.at (i).clone ());\n+\n+  return *this;\n }\n \n TyTy::BaseType *\n@@ -524,10 +546,13 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n       context->insert_type (param.get_mappings (), param_tyty);\n     }\n \n-  return new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t   fn.get_mappings ().get_defid (),\n-\t\t\t   function.get_function_name (), function.is_method (),\n-\t\t\t   std::move (params), ret_type, substitutions);\n+  auto resolved\n+    = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\tfn.get_mappings ().get_defid (),\n+\t\t\tfunction.get_function_name (), function.is_method (),\n+\t\t\tstd::move (params), ret_type, substitutions);\n+  context->insert_type (fn.get_mappings (), resolved);\n+  return resolved;\n }\n \n } // namespace Resolver"}, {"sha": "491de857d21bddf8ad01c40ac58072f613ebba93", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -42,6 +42,8 @@ class TypeCheckContext\n \t\t    TyTy::BaseType *type);\n   bool lookup_type (HirId id, TyTy::BaseType **type);\n \n+  void insert_implicit_type (HirId id, TyTy::BaseType *type);\n+\n   void insert_type_by_node_id (NodeId ref, HirId id);\n   bool lookup_type_by_node_id (NodeId ref, HirId *id);\n "}, {"sha": "28cbeb8fb42ebb1fd8ee013846f83d1f6541b547", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -90,6 +90,36 @@ class SubstMapper : public TyTy::TyVisitor\n       resolved = concrete;\n   }\n \n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    TyTy::ProjectionType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n@@ -107,8 +137,6 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n@@ -177,6 +205,17 @@ class SubstMapperInternal : public TyTy::TyVisitor\n     resolved = type.handle_substitions (mappings);\n   }\n \n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    resolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n   // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n@@ -191,8 +230,6 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::CharType &) override { gcc_unreachable (); }\n   void visit (TyTy::StrType &) override { gcc_unreachable (); }\n   void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)"}, {"sha": "95a16fa283e452ac5d0591ed49404d5d1c1065fb", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -83,6 +83,13 @@ TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n   resolved[id] = type;\n }\n \n+void\n+TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n bool\n TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type)\n {"}, {"sha": "f12ffb4b968e73cfa1d493ec85d4f1aee57db46c", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -46,6 +46,19 @@ class BaseCoercionRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+    else if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tProjectionType *p = static_cast<ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "db7d8c02e221aa3d0236972480043ae80d758c7b", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -76,6 +76,11 @@ class BaseRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tProjectionType *p = static_cast<ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "7eb717fde93691852818909b5d9e7b95ecdc071f", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -414,8 +414,6 @@ SubstitutionArgumentMappings\n SubstitutionRef::adjust_mappings_for_this (\n   SubstitutionArgumentMappings &mappings)\n {\n-  Analysis::Mappings *mappings_table = Analysis::Mappings::get ();\n-\n   std::vector<SubstitutionArg> resolved_mappings;\n   for (size_t i = 0; i < substitutions.size (); i++)\n     {\n@@ -442,20 +440,16 @@ SubstitutionRef::adjust_mappings_for_this (\n \t}\n \n       bool ok = !arg.is_error ();\n-      if (!ok)\n+      if (ok)\n \t{\n-\t  rust_error_at (mappings_table->lookup_location (\n-\t\t\t   subst.get_param_ty ()->get_ref ()),\n-\t\t\t \"failed to find parameter type: %s vs mappings [%s]\",\n-\t\t\t subst.get_param_ty ()->as_string ().c_str (),\n-\t\t\t mappings.as_string ().c_str ());\n-\t  return SubstitutionArgumentMappings::error ();\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n \t}\n-\n-      SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-      resolved_mappings.push_back (std::move (adjusted));\n     }\n \n+  if (resolved_mappings.empty ())\n+    return SubstitutionArgumentMappings::error ();\n+\n   return SubstitutionArgumentMappings (resolved_mappings,\n \t\t\t\t       mappings.get_locus ());\n }\n@@ -907,7 +901,9 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\t{\n+\t  sub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+\t}\n     }\n \n   auto fty = fn->get_return_type ();\n@@ -2139,42 +2135,106 @@ ProjectionType::accept_vis (TyConstVisitor &vis) const\n std::string\n ProjectionType::as_string () const\n {\n-  return \"<Projection>\";\n+  return \"<Projection=\" + subst_as_string () + \"::\" + base->as_string () + \">\";\n }\n \n BaseType *\n ProjectionType::unify (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->unify (other);\n }\n \n BaseType *\n ProjectionType::coerce (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->coerce (other);\n }\n \n BaseType *\n ProjectionType::cast (BaseType *other)\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return base->cast (other);\n }\n \n bool\n ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  return base->can_eq (other, emit_errors);\n }\n \n BaseType *\n ProjectionType::clone () const\n {\n   return new ProjectionType (get_ref (), get_ty_ref (), base, trait, item,\n-\t\t\t     associated, get_combined_refs ());\n+\t\t\t     clone_substs (), used_arguments,\n+\t\t\t     get_combined_refs ());\n+}\n+\n+ProjectionType *\n+ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  ProjectionType *projection = static_cast<ProjectionType *> (clone ());\n+  projection->set_ty_ref (mappings->get_next_hir_id ());\n+  projection->used_arguments = subst_mappings;\n+\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_implicit_type (projection->get_ty_ref (), projection);\n+\n+  for (auto &sub : projection->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty (), subst_mappings.get_locus ());\n+    }\n+\n+  auto fty = projection->base;\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      projection->base = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->needs_generic_substitutions ()\n+\t   || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete == nullptr || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      projection->base = new_field;\n+    }\n+\n+  return projection;\n }\n \n // rust-tyty-call.h"}, {"sha": "0dfae3705616b23e9aa99cf985662648d6a81c7a", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -1709,7 +1709,11 @@ class PlaceholderType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  bool is_unit () const override { return true; }\n+  bool is_unit () const override\n+  {\n+    rust_assert (can_resolve ());\n+    return resolve ()->is_unit ();\n+  }\n \n   std::string get_symbol () const { return symbol; }\n \n@@ -1723,26 +1727,38 @@ class PlaceholderType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n+  bool contains_type_parameters () const override\n+  {\n+    rust_assert (can_resolve ());\n+    return resolve ()->contains_type_parameters ();\n+  }\n+\n private:\n   std::string symbol;\n };\n \n-class ProjectionType : public BaseType\n+class ProjectionType : public BaseType, public SubstitutionRef\n {\n public:\n-  ProjectionType (HirId ref, TyVar base, Resolver::TraitReference *trait,\n-\t\t  DefId item, Resolver::AssociatedImplTrait *associated,\n+  ProjectionType (HirId ref, BaseType *base, Resolver::TraitReference *trait,\n+\t\t  DefId item, std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item), associated (associated)\n+    : BaseType (ref, ref, TypeKind::PROJECTION, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n   {}\n \n-  ProjectionType (HirId ref, HirId ty_ref, TyVar base,\n+  ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n \t\t  Resolver::TraitReference *trait, DefId item,\n-\t\t  Resolver::AssociatedImplTrait *associated,\n+\t\t  std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs), base (base),\n-      trait (trait), item (item), associated (associated)\n+    : BaseType (ref, ty_ref, TypeKind::PROJECTION, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1761,11 +1777,32 @@ class ProjectionType : public BaseType\n \n   bool is_unit () const override { return false; }\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  BaseType *get () { return base; }\n+\n+  bool contains_type_parameters () const override\n+  {\n+    return base->contains_type_parameters ();\n+  }\n+\n+  ProjectionType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n private:\n-  TyVar base;\n+  BaseType *base;\n   Resolver::TraitReference *trait;\n   DefId item;\n-  Resolver::AssociatedImplTrait *associated;\n };\n \n } // namespace TyTy"}, {"sha": "a55b965baf0bffae71889072696c8cda0457817b", "filename": "gcc/testsuite/rust/compile/torture/traits12.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits12.rs?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -0,0 +1,29 @@\n+trait Foo {\n+    type A;\n+\n+    fn test(a: Self::A) -> Self::A {\n+        a\n+    }\n+}\n+\n+struct Bar(i32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Bar {\n+    type A = i32;\n+}\n+\n+struct Baz(f32);\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Baz {\n+    type A = f32;\n+}\n+\n+fn main() {\n+    let a: <Baz as Foo>::A;\n+    a = 123f32;\n+\n+    let b;\n+    b = <Baz as Foo>::test(a);\n+}"}, {"sha": "326f03907567fcb83062879ed1d8a210b7de4773", "filename": "gcc/testsuite/rust/compile/torture/traits13.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits13.rs?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -0,0 +1,17 @@\n+trait Trait {\n+    const FOO: usize;\n+    type Target;\n+}\n+\n+struct S;\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl Trait for S {\n+    const FOO: usize = 0;\n+    type Target = usize;\n+}\n+\n+fn main() {\n+    let a: <S as Trait>::Target;\n+    a = <S as Trait>::FOO;\n+}"}, {"sha": "8bca0d5c1f6c4f0e564c00327400fbe126059aeb", "filename": "gcc/testsuite/rust/compile/torture/traits14.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits14.rs?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -0,0 +1,23 @@\n+trait Foo<T> {\n+    type A;\n+\n+    fn test(a: T) -> T {\n+        a\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl<T> Foo<T> for Bar<T> {\n+    type A = T;\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b: <Bar<i32> as Foo<i32>>::A;\n+    b = 456;\n+\n+    let c: <Bar<i32> as Foo<i32>>::A;\n+    c = <Bar<i32> as Foo<i32>>::test(a.0);\n+}"}, {"sha": "c8c40b78b45e7550245c1c17e338bc0ab24d9829", "filename": "gcc/testsuite/rust/compile/torture/traits15.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50623899998de5a8ffe47227a351c2b3dd29aa0a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits15.rs?ref=50623899998de5a8ffe47227a351c2b3dd29aa0a", "patch": "@@ -0,0 +1,23 @@\n+trait Foo<T> {\n+    type A;\n+\n+    fn test(a: T, b: Self::A) -> (T, Self::A) {\n+        (a, b)\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl<T> Foo<T> for Bar<T> {\n+    type A = T;\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b: <Bar<i32> as Foo<i32>>::A;\n+    b = 456;\n+\n+    let c;\n+    c = <Bar<i32> as Foo<i32>>::test(a.0, 123);\n+}"}]}