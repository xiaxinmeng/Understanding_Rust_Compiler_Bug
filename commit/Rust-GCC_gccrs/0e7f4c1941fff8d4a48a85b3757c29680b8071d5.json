{"sha": "0e7f4c1941fff8d4a48a85b3757c29680b8071d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3ZjRjMTk0MWZmZjhkNGE0OGE4NWIzNzU3YzI5NjgwYjgwNzFkNQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-09-13T15:39:59Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-09-13T15:39:59Z"}, "message": "(compute_xdepi_operands_from_integer): New function.\n\nSome code come from output_zdepi.\n(output_zdepi): Removed. (depi_cint_operand): New name for zdepi_operand.\n(consec_zeros_p, and_operand, ior_mask_p, ior_operand,\noutput_and, output_ior): New functions.\n(output_load_address): Removed.  Nothing uses it.\n\nFrom-SVN: r2115", "tree": {"sha": "d2f2ddae83815ca7d9addeaae7791355b1bebbe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f2ddae83815ca7d9addeaae7791355b1bebbe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e7f4c1941fff8d4a48a85b3757c29680b8071d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7f4c1941fff8d4a48a85b3757c29680b8071d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7f4c1941fff8d4a48a85b3757c29680b8071d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7f4c1941fff8d4a48a85b3757c29680b8071d5/comments", "author": null, "committer": null, "parents": [{"sha": "7254dbd49778f0842a6ed26cfb92fd5c0d60e7a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7254dbd49778f0842a6ed26cfb92fd5c0d60e7a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7254dbd49778f0842a6ed26cfb92fd5c0d60e7a7"}], "stats": {"total": 249, "additions": 146, "deletions": 103}, "files": [{"sha": "1e18a145fac303e6794690efe8643f9084d2ffba", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 146, "deletions": 103, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7f4c1941fff8d4a48a85b3757c29680b8071d5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7f4c1941fff8d4a48a85b3757c29680b8071d5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=0e7f4c1941fff8d4a48a85b3757c29680b8071d5", "patch": "@@ -316,7 +316,8 @@ arith5_operand (op, mode)\n }\n \n /* True iff zdepi can be used to generate this CONST_INT.  */\n-zdepi_operand (op, mode)\n+int\n+depi_cint_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n@@ -334,6 +335,45 @@ zdepi_operand (op, mode)\n   return ((t & (t - 1)) == 0);\n }\n \n+/* True iff depi or extru can be used to compute (reg & mask).  */\n+int\n+consec_zeros_p (mask)\n+     unsigned mask;\n+{\n+  mask = ~mask;\n+  mask += mask & -mask;\n+  return (mask & (mask - 1)) == 0;\n+}\n+\n+/* True iff depi or extru can be used to compute (reg & OP).  */\n+int\n+and_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && consec_zeros_p (INTVAL (op))));\n+}\n+\n+/* True iff depi can be used to compute (reg | MASK).  */\n+int\n+ior_mask_p (mask)\n+     unsigned mask;\n+{\n+  mask += mask & -mask;\n+  return (mask & (mask - 1)) == 0;\n+}\n+\n+/* True iff depi can be used to compute (reg | OP).  */\n+int\n+ior_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op))));\n+}\n+\n int\n arith32_operand (op, mode)\n      rtx op;\n@@ -648,7 +688,7 @@ emit_move_sequence (operands, mode)\n \t      return 1;\n \t    }\n \t}\n-      else if (zdepi_operand (operand1, VOIDmode))\n+      else if (depi_cint_operand (operand1, VOIDmode))\n \treturn 0;\n       else if (GET_CODE (operand1) == CONST_INT\n \t       ? (! SMALL_INT (operand1)\n@@ -699,43 +739,43 @@ singlemove_string (operands)\n }\n \f\n \n-char *\n-output_zdepi (operands)\n+/* Compute position (in OPERANDS[2]) and width (in OPERANDS[3])\n+   useful for copying or or'ing IMM to a register using bit field\n+   instructions.  Store the immediate value to insert in OPERANDS[1].  */\n+void\n+compute_xdepi_operands_from_integer (imm, operands)\n+     unsigned imm;\n      rtx *operands;\n {\n-  unsigned long x = INTVAL (operands[1]);\n-  int i;\n+  int lsb, len;\n \n-  for (i = 0; i < 32; i++)\n+  /* Find the least significant set bit in IMM.  */\n+  for (lsb = 0; lsb < 32; lsb++)\n     {\n-      if ((x & 1) != 0)\n+      if ((imm & 1) != 0)\n         break;\n-      x >>= 1;\n+      imm >>= 1;\n     }\n \n-  if ((x & 0x10) == 0)\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, x);\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode, 31 - i);\n-      operands[3] = gen_rtx (CONST_INT, VOIDmode, 32 - i < 4 ? 32 - i : 4);\n-    }\n+  /* Choose variants based on *sign* of the 5-bit field.  */\n+  if ((imm & 0x10) == 0)\n+    len = (lsb <= 28) ? 4 : 32 - lsb;\n   else\n     {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, (x & 0xf) - 0x10);\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode, 31 - i);\n-\n-      x >>= 5;\n-      for (i = 0; i < 32; i++)\n+      /* Find the width of the bitstring in IMM.  */\n+      for (len = 5; len < 32; len++)\n \t{\n-\t  if ((x & 1) == 0)\n+\t  if ((imm & (1 << len)) == 0)\n \t    break;\n-\t  x >>= 1;\n \t}\n \n-      operands[3] = gen_rtx (CONST_INT, VOIDmode, i + 5);\n+      /* Sign extend IMM as a 5-bit value.  */\n+      imm = (imm & 0xf) - 0x10;\n     }\n \n-  return \"zdepi %1,%2,%3,%0\";\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, imm);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, 31 - lsb);\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, len);\n }\n \n /* Output assembler code to perform a doubleword move insn\n@@ -1011,85 +1051,6 @@ find_addr_reg (addr)\n   abort ();\n }\n \n-/* Load the address specified by OPERANDS[3] into the register\n-   specified by OPERANDS[0].\n-\n-   OPERANDS[3] may be the result of a sum, hence it could either be:\n-\n-   (1) CONST\n-   (2) REG\n-   (2) REG + CONST_INT\n-   (3) REG + REG + CONST_INT\n-   (4) REG + REG  (special case of 3).\n-\n-   Note that (3) is not a legitimate address.\n-   All cases are handled here.  */\n-\n-void\n-output_load_address (operands)\n-     rtx *operands;\n-{\n-  rtx base, offset;\n-\n-  if (CONSTANT_P (operands[3]))\n-    {\n-      output_asm_insn (\"ldi %3,%0\", operands);\n-      return;\n-    }\n-\n-  if (REG_P (operands[3]))\n-    {\n-      if (REGNO (operands[0]) != REGNO (operands[3]))\n-\toutput_asm_insn (\"copy %3,%0\", operands);\n-      return;\n-    }\n-\n-  if (GET_CODE (operands[3]) != PLUS)\n-    abort ();\n-\n-  base = XEXP (operands[3], 0);\n-  offset = XEXP (operands[3], 1);\n-\n-  if (GET_CODE (base) == CONST_INT)\n-    {\n-      rtx tmp = base;\n-      base = offset;\n-      offset = tmp;\n-    }\n-\n-  if (GET_CODE (offset) != CONST_INT)\n-    {\n-      /* Operand is (PLUS (REG) (REG)).  */\n-      base = operands[3];\n-      offset = const0_rtx;\n-    }\n-\n-  if (REG_P (base))\n-    {\n-      operands[6] = base;\n-      operands[7] = offset;\n-      if (INT_14_BITS (offset))\n-\toutput_asm_insn (\"ldo %7(%6),%0\", operands);\n-      else\n-\toutput_asm_insn (\"addil L'%7,%6\\n\\tldo R'%7(1),%0\", operands);\n-    }\n-  else if (GET_CODE (base) == PLUS)\n-    {\n-      operands[6] = XEXP (base, 0);\n-      operands[7] = XEXP (base, 1);\n-      operands[8] = offset;\n-\n-      if (offset == const0_rtx)\n-\toutput_asm_insn (\"add %6,%7,%0\", operands);\n-      else if (INT_14_BITS (offset))\n-\toutput_asm_insn (\"add %6,%7,%0\\n\\tldo %8(%0),%0\", operands);\n-      else\n-\toutput_asm_insn (\"addil L'%8,%6\\n\\tldo R'%8(1),%0\\n\\tadd %0,%7,%0\", operands);\n-    }\n-  else\n-    abort ();\n-}\n-\n /* Emit code to perform a block move.\n \n    Restriction: If the length argument is non-constant, alignment\n@@ -1262,6 +1223,88 @@ output_block_move (operands, size_is_constant)\n }\n \f\n \n+char *\n+output_and (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      unsigned mask = INTVAL (operands[2]);\n+      int ls0, ls1, ms0, p, len;\n+\n+      for (ls0 = 0; ls0 < 32; ls0++)\n+\tif ((mask & (1 << ls0)) == 0)\n+\t  break;\n+\n+      for (ls1 = ls0; ls1 < 32; ls1++)\n+\tif ((mask & (1 << ls1)) != 0)\n+\t  break;\n+\n+      for (ms0 = ls1; ms0 < 32; ms0++)\n+\tif ((mask & (1 << ms0)) == 0)\n+\t  break;\n+\n+      if (ms0 != 32)\n+\tabort();\n+\n+      if (ls1 == 32)\n+\t{\n+\t  len = ls0;\n+\n+\t  if (len == 0)\n+\t    abort ();\n+\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, len);\n+\t  return \"extru %1,31,%2,%0\";\n+\t}\n+      else\n+\t{\n+\t  /* We could use this `depi' for the case above as well, but `depi'\n+\t     requires one more register file access than an `extru'.  */\n+\n+\t  p = 31 - ls0;\n+\t  len = ls1 - ls0;\n+\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, p);\n+\t  operands[3] = gen_rtx (CONST_INT, VOIDmode, len);\n+\t  return \"depi 0,%2,%3,%0\";\n+\t}\n+    }\n+  else\n+    return \"and %1,%2,%0\";\n+}\n+\n+char *\n+output_ior (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      unsigned mask = INTVAL (operands[2]);\n+      int bs0, bs1, bs2, p, len;\n+\n+      for (bs0 = 0; bs0 < 32; bs0++)\n+\tif ((mask & (1 << bs0)) != 0)\n+\t  break;\n+\n+      for (bs1 = bs0; bs1 < 32; bs1++)\n+\tif ((mask & (1 << bs1)) == 0)\n+\t  break;\n+\n+      if (bs1 != 32 && ((unsigned) 1 << bs1) <= mask)\n+\tabort();\n+\n+      p = 31 - bs0;\n+      len = bs1 - bs0;\n+\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, p);\n+      operands[3] = gen_rtx (CONST_INT, VOIDmode, len);\n+      return \"depi -1,%2,%3,%0\";\n+    }\n+  else\n+    return \"or %1,%2,%0\";\n+}\n+\f\n /* Output an ascii string.  */\n output_ascii (file, p, size)\n      FILE *file;"}]}