{"sha": "3831381763ca5f41d6f7406d590e1e38a8531e1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzMTM4MTc2M2NhNWY0MWQ2Zjc0MDZkNTkwZTFlMzhhODUzMWUxYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-18T15:40:16Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-18T15:40:16Z"}, "message": "javaprims.h: Updated class declaration list.\n\n\t* gcj/javaprims.h: Updated class declaration list.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (core_java_source_files): Added\n\tPropertyPermissionCollection.java.\n\t* java/lang/Thread.java (group, name): Now package-private.\n\t* java/lang/ThreadGroup.java: Re-merge with Classpath.\n\t* java/util/AbstractList.java: Likewise.\n\t* java/util/AbstractMap.java: Likewise.\n\t* java/util/Calendar.java: Likewise.\n\t* java/util/Collections.java: Likewise.\n\t* java/util/HashMap.java: Likewise.\n\t* java/util/Hashtable.java: Likewise.\n\t* java/util/LinkedHashMap.java: Likewise.\n\t* java/util/LinkedList.java: Likewise.\n\t* java/util/List.java: Likewise.\n\t* java/util/ListResourceBundle.java: Likewise.\n\t* java/util/Map.java: Likewise.\n\t* java/util/Observable.java: Likewise.\n\t* java/util/Properties.java: Likewise.\n\t* java/util/PropertyPermission.java: Likewise.\n\t* java/util/PropertyPermissionCollection.java: Likewise.\n\t* java/util/PropertyResourceBundle.java: Likewise.\n\t* java/util/Random.java: Likewise.\n\t* java/util/SimpleTimeZone.java: Likewise.\n\t* java/util/StringTokenizer.java: Likewise.\n\t* java/util/TimerTask.java: Likewise.\n\t* java/util/TreeMap.java: Likewise.\n\t* java/util/WeakHashMap.java: Likewise.\n\t* java/util/jar/Attributes.java: Likewise.\n\t* java/util/jar/JarException.java: Likewise.\n\t* java/util/jar/Manifest.java: Likewise.\n\nFrom-SVN: r54743", "tree": {"sha": "6b8dcd38b7dbb7c4c618080eb1958b6f042d581c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b8dcd38b7dbb7c4c618080eb1958b6f042d581c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3831381763ca5f41d6f7406d590e1e38a8531e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3831381763ca5f41d6f7406d590e1e38a8531e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3831381763ca5f41d6f7406d590e1e38a8531e1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3831381763ca5f41d6f7406d590e1e38a8531e1c/comments", "author": null, "committer": null, "parents": [{"sha": "0fd534ed06e92a7232b2373321f113ee8dd482c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd534ed06e92a7232b2373321f113ee8dd482c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd534ed06e92a7232b2373321f113ee8dd482c4"}], "stats": {"total": 3824, "additions": 2305, "deletions": 1519}, "files": [{"sha": "d189b02af9aa75150f1c88da8c803b9eb285c757", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,3 +1,37 @@\n+2002-06-18  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj/javaprims.h: Updated class declaration list.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added\n+\tPropertyPermissionCollection.java.\n+\t* java/lang/Thread.java (group, name): Now package-private.\n+\t* java/lang/ThreadGroup.java: Re-merge with Classpath.\n+\t* java/util/AbstractList.java: Likewise.\n+\t* java/util/AbstractMap.java: Likewise.\n+\t* java/util/Calendar.java: Likewise.\n+\t* java/util/Collections.java: Likewise.\n+\t* java/util/HashMap.java: Likewise.\n+\t* java/util/Hashtable.java: Likewise.\n+\t* java/util/LinkedHashMap.java: Likewise.\n+\t* java/util/LinkedList.java: Likewise.\n+\t* java/util/List.java: Likewise.\n+\t* java/util/ListResourceBundle.java: Likewise.\n+\t* java/util/Map.java: Likewise.\n+\t* java/util/Observable.java: Likewise.\n+\t* java/util/Properties.java: Likewise.\n+\t* java/util/PropertyPermission.java: Likewise.\n+\t* java/util/PropertyPermissionCollection.java: Likewise.\n+\t* java/util/PropertyResourceBundle.java: Likewise.\n+\t* java/util/Random.java: Likewise.\n+\t* java/util/SimpleTimeZone.java: Likewise.\n+\t* java/util/StringTokenizer.java: Likewise.\n+\t* java/util/TimerTask.java: Likewise.\n+\t* java/util/TreeMap.java: Likewise.\n+\t* java/util/WeakHashMap.java: Likewise.\n+\t* java/util/jar/Attributes.java: Likewise.\n+\t* java/util/jar/JarException.java: Likewise.\n+\t* java/util/jar/Manifest.java: Likewise.\n+\n 2002-06-17  Tom Tromey  <tromey@redhat.com>\n \n \t* gcj/javaprims.h: Updated class declaration list."}, {"sha": "86bae703be03b8ebb066fcd87753381fdbed731d", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1220,6 +1220,7 @@ java/util/Observable.java \\\n java/util/Observer.java\t\\\n java/util/Properties.java \\\n java/util/PropertyPermission.java \\\n+java/util/PropertyPermissionCollection.java \\\n java/util/PropertyResourceBundle.java \\\n java/util/Random.java \\\n java/util/RandomAccess.java \\"}, {"sha": "e281b10a2bc799bda3a4e0f1c5fec0b30be8e990", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -987,6 +987,7 @@ java/util/Observable.java \\\n java/util/Observer.java\t\\\n java/util/Properties.java \\\n java/util/PropertyPermission.java \\\n+java/util/PropertyPermissionCollection.java \\\n java/util/PropertyResourceBundle.java \\\n java/util/Random.java \\\n java/util/RandomAccess.java \\\n@@ -2550,6 +2551,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\\n+.deps/java/util/PropertyPermissionCollection.P \\\n .deps/java/util/PropertyResourceBundle.P .deps/java/util/Random.P \\\n .deps/java/util/RandomAccess.P .deps/java/util/ResourceBundle.P \\\n .deps/java/util/Set.P .deps/java/util/SimpleTimeZone.P \\"}, {"sha": "26bbee89115d2af55f8fed6e4f0be4686dc35554", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -243,6 +243,7 @@ extern \"Java\"\n       class AbstractCollection;\n       class AbstractList;\n       class AbstractMap;\n+      class AbstractMap$BasicMapEntry;\n       class AbstractSequentialList;\n       class AbstractSet;\n       class ArrayList;\n@@ -317,11 +318,13 @@ extern \"Java\"\n       class Map$Entry;\n       class Map$Map;\n       class MissingResourceException;\n+      class MyResources;\n       class NoSuchElementException;\n       class Observable;\n       class Observer;\n       class Properties;\n       class PropertyPermission;\n+      class PropertyPermissionCollection;\n       class PropertyResourceBundle;\n       class Random;\n       class RandomAccess;"}, {"sha": "af5b95f14c6bd55e1b02578aecfa956dc13f51aa", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -301,8 +301,8 @@ public String toString ()\n   public static native void yield ();\n \n   // Private data.\n-  private ThreadGroup group;\n-  private String name;\n+  ThreadGroup group;\n+  String name;\n   private Runnable runnable;\n   private int priority;\n   private boolean daemon_flag;"}, {"sha": "80f62b6a7a772b137f1fb4e5d5667d51ad443232", "filename": "libjava/java/lang/ThreadGroup.java", "status": "modified", "additions": 570, "deletions": 449, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Flang%2FThreadGroup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Flang%2FThreadGroup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadGroup.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.ThreadGroup\n-   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n+/* ThreadGroup -- a group of Threads\n+   Copyright (C) 1998, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -34,166 +34,213 @@\n this exception to your version of the library, but you are not\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n- \n+\n package java.lang;\n \n import java.util.Vector;\n-import java.util.Enumeration;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 from http://www.javasoft.com.\n- * Status:  Complete for 1.2.  Some parts from the JDK 1.0 spec only are\n- * not implemented. \n- */\n- \n /**\n- * ThreadGroup allows you to group Threads together.  There is a\n- * hierarchy of ThreadGroups, and only the initial ThreadGroup has\n- * no parent.  A Thread may access information about its own\n- * ThreadGroup, but not its parents or others outside the tree.\n+ * ThreadGroup allows you to group Threads together.  There is a hierarchy\n+ * of ThreadGroups, and only the initial ThreadGroup has no parent.  A Thread\n+ * may access information about its own ThreadGroup, but not its parents or\n+ * others outside the tree.\n  *\n  * @author John Keiser\n  * @author Tom Tromey\n  * @author Bryce McKinlay\n- * @version 1.2.0\n- * @since JDK1.0\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Thread\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n-\n public class ThreadGroup\n {\n-  /* The Initial, top-level ThreadGroup. */\n+  /** The Initial, top-level ThreadGroup. */\n   static ThreadGroup root = new ThreadGroup();\n-  /* This flag is set if an uncaught exception occurs. The runtime should \n-  check this and exit with an error status if it is set. */\n-  static boolean had_uncaught_exception = false;\n \n-  private ThreadGroup parent;\n-  private String name;\n-  private Vector threads = new Vector();\n+  /**\n+   * This flag is set if an uncaught exception occurs. The runtime should\n+   * check this and exit with an error status if it is set.\n+   */\n+  static boolean had_uncaught_exception;\n+\n+  /** The parent thread group. */\n+  private final ThreadGroup parent;\n+\n+  /** The group name, non-null. */\n+  final String name;\n+\n+  /** The threads in the group. */\n+  private final Vector threads = new Vector();\n+\n+  /** Child thread groups, or null when this group is destroyed. */\n   private Vector groups = new Vector();\n+\n+  /** If all threads in the group are daemons. */\n   private boolean daemon_flag = false;\n-  private int maxpri = Thread.MAX_PRIORITY;\n \n+  /** The maximum group priority. */\n+  private int maxpri;\n+\n+  /**\n+   * Hidden constructor to build the root node.\n+   */\n   private ThreadGroup()\n   {\n-    name = \"main\";    \n+    name = \"main\";\n+    parent = null;\n+    maxpri = Thread.MAX_PRIORITY;\n   }\n \n-  /** Create a new ThreadGroup using the given name and the\n-   *  current thread's ThreadGroup as a parent.\n-   *  @param name the name to use for the ThreadGroup.\n+  /**\n+   * Create a new ThreadGroup using the given name and the current thread's\n+   * ThreadGroup as a parent. There may be a security check,\n+   * <code>checkAccess</code>.\n+   *\n+   * @param name the name to use for the ThreadGroup\n+   * @throws SecurityException if the current thread cannot create a group\n+   * @see #checkAccess()\n    */\n   public ThreadGroup(String name)\n   {\n-    this (Thread.currentThread().getThreadGroup(), name);\n+    this(Thread.currentThread().group, name);\n   }\n \n-  /** Create a new ThreadGroup using the given name and\n-   *  parent group.\n-   *  @param name the name to use for the ThreadGroup.\n-   *  @param parent the ThreadGroup to use as a parent.\n-   *  @exception NullPointerException if parent is null.\n-   *  @exception SecurityException if you cannot change\n-   *             the intended parent group.\n+  /**\n+   * Create a new ThreadGroup using the given name and parent group. The new\n+   * group inherits the maximum priority and daemon status of its parent\n+   * group. There may be a security check, <code>checkAccess</code>.\n+   *\n+   * @param name the name to use for the ThreadGroup\n+   * @param parent the ThreadGroup to use as a parent\n+   * @throws NullPointerException if parent is null\n+   * @throws SecurityException if the current thread cannot create a group\n+   * @throws IllegalThreadStateException if the parent is destroyed\n+   * @see #checkAccess()\n    */\n   public ThreadGroup(ThreadGroup parent, String name)\n   {\n     parent.checkAccess();\n     this.parent = parent;\n-    if (parent.isDestroyed())\n-      throw new IllegalArgumentException ();\n     this.name = name;\n     maxpri = parent.maxpri;\n     daemon_flag = parent.daemon_flag;\n-    parent.addGroup(this);\n+    synchronized (parent)\n+      {\n+        if (parent.groups == null)\n+          throw new IllegalThreadStateException();\n+        parent.groups.add(this);\n+      }\n   }\n \n-  /** Get the name of this ThreadGroup.\n-   *  @return the name of this ThreadGroup.\n+  /**\n+   * Get the name of this ThreadGroup.\n+   *\n+   * @return the name of this ThreadGroup\n    */\n   public final String getName()\n   {\n     return name;\n   }\n \n-  /** Get the parent of this ThreadGroup.\n-   *  @return the parent of this ThreadGroup.\n+  /**\n+   * Get the parent of this ThreadGroup. If the parent is not null, there\n+   * may be a security check, <code>checkAccess</code>.\n+   *\n+   * @return the parent of this ThreadGroup\n+   * @throws SecurityException if permission is denied\n    */\n   public final ThreadGroup getParent()\n   {\n+    if (parent != null)\n+      parent.checkAccess();\n     return parent;\n   }\n \n-  /** Set the maximum priority for Threads in this ThreadGroup. setMaxPriority\n-   *  can only be used to reduce the current maximum. If maxpri\n-   *  is greater than the current Maximum, the current value is not changed.\n-   *  Calling this does not effect threads already in this ThreadGroup.\n-   *  @param maxpri the new maximum priority for this ThreadGroup.\n-   *  @exception SecurityException if you cannoy modify this ThreadGroup.\n-   */\n-  public final synchronized void setMaxPriority(int maxpri)\n-  {\n-    checkAccess();\n-    if (maxpri < this.maxpri\n-        && maxpri >= Thread.MIN_PRIORITY\n-\t&& maxpri <= Thread.MAX_PRIORITY)\n-      {\n-\tthis.maxpri = maxpri;        \n-      }  \n-  }\n-\n-  /** Get the maximum priority of Threads in this ThreadGroup.\n-   *  @return the maximum priority of Threads in this ThreadGroup.\n+  /**\n+   * Get the maximum priority of Threads in this ThreadGroup. Threads created\n+   * after this call in this group may not exceed this priority.\n+   *\n+   * @return the maximum priority of Threads in this ThreadGroup\n    */\n   public final int getMaxPriority()\n   {\n     return maxpri;\n   }\n \n-  /** Set whether this ThreadGroup is a daemon group.  A daemon\n-   *  group will be destroyed when its last thread is stopped and\n-   *  its last thread group is destroyed.\n-   *  @specnote The Java API docs indicate that the group is destroyed\n-   * \t\twhen either of those happen, but that doesn't make\n-   * \t\tsense.\n-   *  @param daemon whether this ThreadGroup should be a daemon group.\n-   *  @exception SecurityException if you cannoy modify this ThreadGroup.\n+  /**\n+   * Tell whether this ThreadGroup is a daemon group.  A daemon group will\n+   * be automatically destroyed when its last thread is stopped and\n+   * its last thread group is destroyed.\n+   *\n+   * @return whether this ThreadGroup is a daemon group\n    */\n-  public final void setDaemon (boolean daemon)\n-  {\n-    checkAccess();\n-    daemon_flag = daemon;\n-  }\n-   \n-  /** Tell whether this ThreadGroup is a daemon group.  A daemon\n-    * group will be destroyed when its last thread is stopped and\n-    * its last thread group is destroyed.\n-    * @specnote The Java API docs indicate that the group is destroyed\n-    *\t\twhen either of those happen, but that doesn't make\n-    *\t\tsense.\n-    * @return whether this ThreadGroup is a daemon group.\n-    */\n   public final boolean isDaemon()\n   {\n     return daemon_flag;\n   }\n \n-  /** Tell whether this ThreadGroup has been destroyed or not.\n-    * @return whether this ThreadGroup has been destroyed or not.\n-    */\n+  /**\n+   * Tell whether this ThreadGroup has been destroyed or not.\n+   *\n+   * @return whether this ThreadGroup has been destroyed or not\n+   * @since 1.1\n+   */\n   public synchronized boolean isDestroyed()\n   {\n-    return parent == null && this != root;\n+    return groups == null;\n   }\n \n-  /** Check whether this ThreadGroup is an ancestor of the\n-    * specified ThreadGroup, or if they are the same.\n-    *\n-    * @param g the group to test on.\n-    * @return whether this ThreadGroup is a parent of the\n-    *\t      specified group.\n-    */\n+  /**\n+   * Set whether this ThreadGroup is a daemon group.  A daemon group will be\n+   * destroyed when its last thread is stopped and its last thread group is\n+   * destroyed. There may be a security check, <code>checkAccess</code>.\n+   *\n+   * @param daemon whether this ThreadGroup should be a daemon group\n+   * @throws SecurityException if you cannot modify this ThreadGroup\n+   * @see #checkAccess()\n+   */\n+  public final void setDaemon(boolean daemon)\n+  {\n+    checkAccess();\n+    daemon_flag = daemon;\n+  }\n+\n+  /**\n+   * Set the maximum priority for Threads in this ThreadGroup. setMaxPriority\n+   * can only be used to reduce the current maximum. If maxpri is greater\n+   * than the current Maximum of the parent group, the current value is not\n+   * changed. Otherwise, all groups which belong to this have their priority\n+   * adjusted as well. Calling this does not affect threads already in this\n+   * ThreadGroup. There may be a security check, <code>checkAccess</code>.\n+   *\n+   * @param maxpri the new maximum priority for this ThreadGroup\n+   * @throws SecurityException if you cannot modify this ThreadGroup\n+   * @see #getMaxPriority()\n+   * @see #checkAccess()\n+   */\n+  public final synchronized void setMaxPriority(int maxpri)\n+  {\n+    checkAccess();\n+    if (maxpri < Thread.MIN_PRIORITY || maxpri > Thread.MAX_PRIORITY)\n+      return;\n+    if (parent != null && maxpri > parent.maxpri)\n+      maxpri = parent.maxpri;\n+    this.maxpri = maxpri;\n+    if (groups == null)\n+      return;\n+    int i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).setMaxPriority(maxpri);\n+  }\n+\n+  /**\n+   * Check whether this ThreadGroup is an ancestor of the specified\n+   * ThreadGroup, or if they are the same.\n+   *\n+   * @param g the group to test on\n+   * @return whether this ThreadGroup is a parent of the specified group\n+   */\n   public final boolean parentOf(ThreadGroup tg)\n   {\n     while (tg != null)\n@@ -205,423 +252,497 @@ public final boolean parentOf(ThreadGroup tg)\n     return false;\n   }\n \n-  /** Return the total number of active threads in this ThreadGroup\n-    * and all its descendants.<P>\n-    *\n-    * This cannot return an exact number, since the status of threads\n-    * may change after they were counted.  But it should be pretty\n-    * close.<P>\n-    *\n-    * @return the number of active threads in this ThreadGroup and\n-    *\t      its descendants.\n-    * @specnote it isn't clear what the definition of an \"Active\" thread is.\n-    *           Current JDKs regard a thread as active if has been\n-    *           started and not finished.  We implement this behaviour.\n-    *           There is a JDC bug, <A HREF=\"http://developer.java.sun.com/developer/bugParade/bugs/4089701.html\">\n-    *           4089701</A>, regarding this issue.\n-    *           \n-    */\n-  public synchronized int activeCount()\n+  /**\n+   * Find out if the current Thread can modify this ThreadGroup. This passes\n+   * the check on to <code>SecurityManager.checkAccess(this)</code>.\n+   *\n+   * @throws SecurityException if the current Thread cannot modify this\n+   *         ThreadGroup\n+   * @see SecurityManager#checkAccess(ThreadGroup)\n+   */\n+  public final void checkAccess()\n   {\n-    int total = 0;\n-    for (int i = 0; i < threads.size(); ++i)\n-      {\n-\tif (((Thread) threads.elementAt(i)).isAlive ())\n-\t  ++total;\n-      }\n-\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup g = (ThreadGroup) groups.elementAt(i);\n-        total += g.activeCount();\n-      }\n-    return total;\n+    // Bypass System.getSecurityManager, for bootstrap efficiency.\n+    SecurityManager sm = Runtime.securityManager;\n+    if (sm != null)\n+      sm.checkAccess(this);\n   }\n \n-  /** Get the number of active groups in this ThreadGroup.  This group\n-    * itself is not included in the count.\n-    * @specnote it is unclear what exactly constitutes an\n-    *\t\tactive ThreadGroup.  Currently we assume that\n-    *\t\tall sub-groups are active, per current JDKs.\n-    * @return the number of active groups in this ThreadGroup.\n-    */\n-  public synchronized int activeGroupCount()\n+  /**\n+   * Return an estimate of the total number of active threads in this\n+   * ThreadGroup and all its descendants. This cannot return an exact number,\n+   * since the status of threads may change after they were counted; but it\n+   * should be pretty close. Based on a JDC bug,\n+   * <a href=\"http://developer.java.sun.com/developer/bugParade/bugs/4089701.html\">\n+   * 4089701</a>, we take active to mean isAlive().\n+   *\n+   * @return count of active threads in this ThreadGroup and its descendants\n+   */\n+  public int activeCount()\n   {\n-    int total = groups.size();\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-\tThreadGroup g = (ThreadGroup) groups.elementAt(i);\n-\ttotal += g.activeGroupCount();\n-      }\n+    int total = 0;\n+    if (groups == null)\n+      return total;\n+    int i = threads.size();\n+    while (--i >= 0)\n+      if (((Thread) threads.get(i)).isAlive())\n+        total++;\n+    i = groups.size();\n+    while (--i >= 0)\n+      total += ((ThreadGroup) groups.get(i)).activeCount();\n     return total;\n   }\n \n-  /** Copy all of the active Threads from this ThreadGroup and\n-    * its descendants into the specified array.  If the array is\n-    * not big enough to hold all the Threads, extra Threads will\n-    * simply not be copied.\n-    *\n-    * @param threads the array to put the threads into.\n-    * @return the number of threads put into the array.\n-    */\n-  public int enumerate(Thread[] threads)\n-  {\n-    return enumerate(threads, 0, true);\n-  }\n-\n-  /** Copy all of the active Threads from this ThreadGroup and,\n-    * if desired, from its descendants, into the specified array.\n-    * If the array is not big enough to hold all the Threads,\n-    * extra Threads will simply not be copied.\n-    *\n-    * @param threads the array to put the threads into.\n-    * @param useDescendants whether to count Threads in this\n-    *\t     ThreadGroup's descendants or not.\n-    * @return the number of threads put into the array.\n-    */\n-  public int enumerate(Thread[] threads, boolean useDescendants)\n-  {\n-    return enumerate(threads, 0, useDescendants);\n-  }\n-\n-  // This actually implements enumerate.\n-  private synchronized int enumerate(Thread[] list, int next_index, \n-\t\t\t\t     boolean recurse)\n-  {\n-    Enumeration e = threads.elements();\n-    while (e.hasMoreElements() && next_index < list.length)\n-      {\n-\tThread t = (Thread) e.nextElement();\n-\tif (t.isAlive ())\n-\t  list[next_index++] = t;\n-      }\n-    if (recurse && next_index != list.length)\n-      {\n-\te = groups.elements();\n-\twhile (e.hasMoreElements() && next_index < list.length)\n-\t  {\n-\t    ThreadGroup g = (ThreadGroup) e.nextElement();\n-\t    next_index = g.enumerate(list, next_index, true);\n-\t  }\n-      }\n-    return next_index;\n-  }\n-\n-  /** Copy all active ThreadGroups that are descendants of this\n-    * ThreadGroup into the specified array.  If the array is not\n-    * large enough to hold all active ThreadGroups, extra\n-    * ThreadGroups simply will not be copied.\n-    *\n-    * @param groups the array to put the ThreadGroups into.\n-    * @return the number of ThreadGroups copied into the array.\n-    */\n-  public int enumerate(ThreadGroup[] groups)\n-  {\n-    return enumerate(groups, 0, true);\n-  }\n-\n-  /** Copy all active ThreadGroups that are children of this\n-    * ThreadGroup into the specified array, and if desired, also\n-    * copy all active descendants into the array.  If the array\n-    * is not large enough to hold all active ThreadGroups, extra\n-    * ThreadGroups simply will not be copied.\n-    *\n-    * @param groups the array to put the ThreadGroups into.\n-    * @param recurse whether to include all descendants\n-    *\t     of this ThreadGroup's children in determining\n-    *\t     activeness.\n-    * @return the number of ThreadGroups copied into the array.\n-    */\n-  public int enumerate(ThreadGroup[] groups, boolean recurse)\n+  /**\n+   * Copy all of the active Threads from this ThreadGroup and its descendants\n+   * into the specified array.  If the array is not big enough to hold all\n+   * the Threads, extra Threads will simply not be copied. There may be a\n+   * security check, <code>checkAccess</code>.\n+   *\n+   * @param array the array to put the threads into\n+   * @return the number of threads put into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if array is null\n+   * @throws ArrayStoreException if a thread does not fit in the array\n+   * @see #activeCount()\n+   * @see #checkAccess()\n+   * @see #enumerate(Thread[], boolean)\n+   */\n+  public int enumerate(Thread[] array)\n+  {\n+    return enumerate(array, 0, true);\n+  }\n+\n+  /**\n+   * Copy all of the active Threads from this ThreadGroup and, if desired,\n+   * from its descendants, into the specified array. If the array is not big\n+   * enough to hold all the Threads, extra Threads will simply not be copied.\n+   * There may be a security check, <code>checkAccess</code>.\n+   *\n+   * @param array the array to put the threads into\n+   * @param recurse whether to recurse into descendent ThreadGroups\n+   * @return the number of threads put into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if array is null\n+   * @throws ArrayStoreException if a thread does not fit in the array\n+   * @see #activeCount()\n+   * @see #checkAccess()\n+   */\n+  public int enumerate(Thread[] array, boolean recurse)\n   {\n-    return enumerate(groups, 0, recurse);\n+    return enumerate(array, 0, recurse);\n   }\n \n-  // This actually implements enumerate.\n-  private synchronized int enumerate (ThreadGroup[] list, int next_index, \n-\t\t\t\t      boolean recurse)\n+  /**\n+   * Get the number of active groups in this ThreadGroup.  This group itself\n+   * is not included in the count. A sub-group is active if it has not been\n+   * destroyed. This cannot return an exact number, since the status of\n+   * threads may change after they were counted; but it should be pretty close.\n+   *\n+   * @return the number of active groups in this ThreadGroup\n+   */\n+  public int activeGroupCount()\n   {\n-    Enumeration e = groups.elements();\n-    while (e.hasMoreElements() && next_index < list.length)\n-      {\n-\tThreadGroup g = (ThreadGroup) e.nextElement();\n-\tlist[next_index++] = g;\n-\tif (recurse && next_index != list.length)\n-\t  next_index = g.enumerate(list, next_index, true);\n-      }\n-    return next_index;\n+    if (groups == null)\n+      return 0;\n+    int total = groups.size();\n+    int i = total;\n+    while (--i >= 0)\n+      total += ((ThreadGroup) groups.get(i)).activeGroupCount();\n+    return total;\n   }\n \n-  /** Interrupt all Threads in this ThreadGroup and its sub-groups.\n-    * @exception SecurityException if you cannot modify this\n-    *\t\t ThreadGroup or any of its Threads or children\n-    *\t\t ThreadGroups.\n-    * @since JDK1.2\n-    */\n-  public final synchronized void interrupt()\n+  /**\n+   * Copy all active ThreadGroups that are descendants of this ThreadGroup\n+   * into the specified array.  If the array is not large enough to hold all\n+   * active ThreadGroups, extra ThreadGroups simply will not be copied. There\n+   * may be a security check, <code>checkAccess</code>.\n+   *\n+   * @param array the array to put the ThreadGroups into\n+   * @return the number of ThreadGroups copied into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if array is null\n+   * @throws ArrayStoreException if a group does not fit in the array\n+   * @see #activeCount()\n+   * @see #checkAccess()\n+   * @see #enumerate(ThreadGroup[], boolean)\n+   */\n+  public int enumerate(ThreadGroup[] array)\n+  {\n+    return enumerate(array, 0, true);\n+  }\n+\n+  /**\n+   * Copy all active ThreadGroups that are children of this ThreadGroup into\n+   * the specified array, and if desired, also all descendents.  If the array\n+   * is not large enough to hold all active ThreadGroups, extra ThreadGroups\n+   * simply will not be copied. There may be a security check,\n+   * <code>checkAccess</code>.\n+   *\n+   * @param array the array to put the ThreadGroups into\n+   * @param recurse whether to recurse into descendent ThreadGroups\n+   * @return the number of ThreadGroups copied into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if array is null\n+   * @throws ArrayStoreException if a group does not fit in the array\n+   * @see #activeCount()\n+   * @see #checkAccess()\n+   */\n+  public int enumerate(ThreadGroup[] array, boolean recurse)\n+  {\n+    return enumerate(array, 0, recurse);\n+  }\n+\n+  /**\n+   * Stop all Threads in this ThreadGroup and its descendants.\n+   *\n+   * <p>This is inherently unsafe, as it can interrupt synchronized blocks and\n+   * leave data in bad states.  Hence, there is a security check:\n+   * <code>checkAccess()</code>, followed by further checks on each thread\n+   * being stopped.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see #checkAccess()\n+   * @see Thread#stop(Throwable)\n+   * @deprecated unsafe operation, try not to use\n+   */\n+  public final synchronized void stop()\n   {\n     checkAccess();\n-    for (int i=0; i < threads.size(); i++)\n-      {\n-        Thread t = (Thread) threads.elementAt(i);\n-        t.interrupt();\n-      }\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-        tg.interrupt();\n-      }\n-  }\n-\n-  /** Stop all Threads in this ThreadGroup and its descendants.\n-    * @exception SecurityException if you cannot modify this\n-    *\t\t ThreadGroup or any of its Threads or children\n-    *\t\t ThreadGroups.\n-    * @deprecated This method calls Thread.stop(), which is dangerous.\n-    */\n-  public final synchronized void stop()\n+    if (groups == null)\n+      return;\n+    int i = threads.size();\n+    while (--i >= 0)\n+      ((Thread) threads.get(i)).stop();\n+    i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).stop();\n+  }\n+\n+  /**\n+   * Interrupt all Threads in this ThreadGroup and its sub-groups. There may\n+   * be a security check, <code>checkAccess</code>.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see #checkAccess()\n+   * @see Thread#interrupt()\n+   * @since 1.2\n+   */\n+  public final synchronized void interrupt()\n   {\n     checkAccess();\n-    for (int i=0; i<threads.size(); i++)\n-      {\n-        Thread t = (Thread) threads.elementAt(i);\n-\tt.stop();\n-      }\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-        tg.stop();\n-      }\n-  }\n-\n-  /** Suspend all Threads in this ThreadGroup and its descendants.\n-    * @exception SecurityException if you cannot modify this\n-    *\t\t ThreadGroup or any of its Threads or children\n-    *\t\t ThreadGroups.\n-    * @deprecated This method calls Thread.suspend(), which is dangerous.\n-    */\n+    if (groups == null)\n+      return;\n+    int i = threads.size();\n+    while (--i >= 0)\n+      ((Thread) threads.get(i)).interrupt();\n+    i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).interrupt();\n+  }\n+\n+  /**\n+   * Suspend all Threads in this ThreadGroup and its descendants.\n+   *\n+   * <p>This is inherently unsafe, as suspended threads still hold locks,\n+   * which can lead to deadlock.  Hence, there is a security check:\n+   * <code>checkAccess()</code>, followed by further checks on each thread\n+   * being suspended.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see #checkAccess()\n+   * @see Thread#suspend()\n+   * @deprecated unsafe operation, try not to use\n+   */\n   public final synchronized void suspend()\n   {\n     checkAccess();\n-    for (int i=0; i<threads.size(); i++)\n-      {\n-        Thread t = (Thread) threads.elementAt(i);\n-        t.suspend();\n-      }\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-        tg.suspend();\n-      }\n-  }\n-\n-  /** Resume all Threads in this ThreadGroup and its descendants.\n-    * @exception SecurityException if you cannot modify this\n-    *\t\t ThreadGroup or any of its Threads or children\n-    *\t\t ThreadGroups.\n-    * @deprecated This method relies on Thread.suspend(), which is dangerous.\n-    */\n+    if (groups == null)\n+      return;\n+    int i = threads.size();\n+    while (--i >= 0)\n+      ((Thread) threads.get(i)).suspend();\n+    i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).suspend();\n+  }\n+\n+  /**\n+   * Resume all suspended Threads in this ThreadGroup and its descendants.\n+   * To mirror suspend(), there is a security check:\n+   * <code>checkAccess()</code>, followed by further checks on each thread\n+   * being resumed.\n+   *\n+   * @throws SecurityException if permission is denied\n+   * @see #checkAccess()\n+   * @see Thread#suspend()\n+   * @deprecated pointless, since suspend is deprecated\n+   */\n   public final synchronized void resume()\n   {\n     checkAccess();\n-    for (int i=0; i < threads.size(); i++)\n-      {\n-        Thread t = (Thread) threads.elementAt(i);\n-\tt.resume();\n-      }\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-        tg.resume();\n-      }\n-  }\n-\n-  // This is a helper that is used to implement the destroy method.\n-  private synchronized void checkDestroy ()\n-  {\n-    if (! threads.isEmpty())\n-      throw new IllegalThreadStateException (\"ThreadGroup has threads\");\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-\ttg.checkDestroy();\n-      }\n-  }\n-\n-  /** Destroy this ThreadGroup.  There can be no Threads in it,\n-    * and none of its descendants (sub-groups) may have Threads in them.\n-    * All its descendants will be destroyed as well.\n-    * @exception IllegalThreadStateException if the ThreadGroup or\n-    *\t\t its descendants have Threads remaining in them, or\n-    *\t\t if the ThreadGroup in question is already destroyed.\n-    * @exception SecurityException if you cannot modify this\n-    *\t\t ThreadGroup or any of its descendants.\n-    */\n+    if (groups == null)\n+      return;\n+    int i = threads.size();\n+    while (--i >= 0)\n+      ((Thread) threads.get(i)).resume();\n+    i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).resume();\n+  }\n+\n+  /**\n+   * Destroy this ThreadGroup.  The group must be empty, meaning that all\n+   * threads and sub-groups have completed execution. Daemon groups are\n+   * destroyed automatically. There may be a security check,\n+   * <code>checkAccess</code>.\n+   *\n+   * @throws IllegalThreadStateException if the ThreadGroup is not empty, or\n+   *         was previously destroyed\n+   * @throws SecurityException if permission is denied\n+   * @see #checkAccess()\n+   */\n   public final synchronized void destroy()\n   {\n     checkAccess();\n-    if (isDestroyed())\n-      throw new IllegalThreadStateException(\"Already destroyed.\");\n-    checkDestroy ();\n+    if (! threads.isEmpty() || groups == null)\n+      throw new IllegalThreadStateException();\n+    int i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).destroy();\n+    groups = null;\n     if (parent != null)\n       parent.removeGroup(this);\n-    parent = null;\n-\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-\ttg.destroy();\n-      }\n   }\n-  \n-  /** Print out information about this ThreadGroup to System.out.\n-    */\n+\n+  /**\n+   * Print out information about this ThreadGroup to System.out. This is\n+   * meant for debugging purposes. <b>WARNING:</b> This method is not secure,\n+   * and can print the name of threads to standard out even when you cannot\n+   * otherwise get at such threads.\n+   */\n   public void list()\n   {\n     list(\"\");\n   }\n \n-  private synchronized void list(String indentation)\n-  {\n-    System.out.print(indentation);\n-    System.out.println(toString ());\n-    String sub = indentation + \"    \";\n-    for (int i=0; i < threads.size(); i++)\n-      {\n-        Thread t = (Thread) threads.elementAt(i);\n-\tSystem.out.print(sub);\n-\tSystem.out.println(t.toString());\n-      }\n-    for (int i=0; i < groups.size(); i++)\n-      {\n-        ThreadGroup tg = (ThreadGroup) groups.elementAt(i);\n-\ttg.list(sub);\n-      }\n-  }\n-\n-  /** When a Thread in this ThreadGroup does not catch an exception,\n-    * this method of the ThreadGroup is called.<P>\n-    *\n-    * ThreadGroup's implementation does the following:<BR>\n-    * <OL>\n-    * <LI>If there is a parent ThreadGroup, call uncaughtException()\n-    *\t  in the parent.</LI>\n-    * <LI>If the Throwable passed is a ThreadDeath, don't do\n-    *\t  anything.</LI>\n-    * <LI>Otherwise, call <CODE>exception.printStackTrace().</CODE></LI>\n-    * </OL>\n-    *\n-    * @param thread the thread that exited.\n-    * @param exception the uncaught exception.\n-    */\n+  /**\n+   * When a Thread in this ThreadGroup does not catch an exception, the\n+   * virtual machine calls this method. The default implementation simply\n+   * passes the call to the parent; then in top ThreadGroup, it will\n+   * ignore ThreadDeath and print the stack trace of any other throwable.\n+   * Override this method if you want to handle the exception in a different\n+   * manner.\n+   *\n+   * @param thread the thread that exited\n+   * @param exception the uncaught exception\n+   * @throws NullPointerException if t is null\n+   * @see ThreadDeath\n+   * @see System#err\n+   * @see Throwable#printStackTrace()\n+   */\n   public void uncaughtException(Thread thread, Throwable t)\n   {\n     if (parent != null)\n-      parent.uncaughtException (thread, t);\n+      parent.uncaughtException(thread, t);\n     else if (! (t instanceof ThreadDeath))\n       {\n-        if (thread != null)\n-          System.err.print (\"Exception in thread \\\"\"\n-\t\t\t    + thread.getName() + \"\\\" \");\n-\ttry\n-\t  {\n-\t    t.printStackTrace(System.err);\n-\t  }\n-\tcatch (Throwable x)\n-\t  {\n-\t    // This means that something is badly screwed up with the runtime,\n-\t    // or perhaps someone is messing with the SecurityManager. In any\n-\t    // case, try to deal with it gracefully.\n-\t    System.err.println(t);\n-\t    System.err.println(\"*** Got \" + x.toString() + \n-\t\t\t       \" while trying to print stack trace\");\n-\t  }\n-\thad_uncaught_exception = true;\n+        if (t == null)\n+          throw new NullPointerException();\n+        had_uncaught_exception = true;\n+        try\n+          {\n+            if (thread != null)\n+              System.err.print(\"Exception in thread \\\"\" + thread.name + \"\\\" \");\n+            t.printStackTrace(System.err);\n+          }\n+        catch (Throwable x)\n+          {\n+            // This means that something is badly screwed up with the runtime,\n+            // or perhaps someone overloaded the Throwable.printStackTrace to\n+            // die. In any case, try to deal with it gracefully.\n+            try\n+              {\n+                System.err.println(t);\n+                System.err.println(\"*** Got \" + x\n+                                   + \" while trying to print stack trace.\");\n+              }\n+            catch (Throwable x2)\n+              {\n+                // Here, someone may have overloaded t.toString() or\n+                // x.toString() to die. Give up all hope; we can't even chain\n+                // the exception, because the chain would likewise die.\n+                System.err.println(\"*** Catastrophic failure while handling \"\n+                                   + \"uncaught exception.\");\n+                throw new InternalError();\n+              }\n+          }\n       }\n   }\n \n-  /** Tell the VM whether it may suspend Threads in low memory\n-    * situations.\n-    * @deprecated This method is unimplemented, because it would rely on\n-    *\t\t  suspend(), which is deprecated. There is no way for a Java\n-    *\t\t  program to determine whether this has any effect whatsoever,\n-    *\t\t  so we don't need it.\n-    * @return false\n-    */\n+  /**\n+   * Originally intended to tell the VM whether it may suspend Threads in\n+   * low memory situations, this method was never implemented by Sun, and\n+   * is hence a no-op.\n+   *\n+   * @param allow whether to allow low-memory thread suspension; ignored\n+   * @return false\n+   * @since 1.1\n+   * @deprecated pointless, since suspend is deprecated\n+   */\n   public boolean allowThreadSuspension(boolean allow)\n   {\n     return false;\n   }\n \n-  /** Get a human-readable representation of this ThreadGroup.\n-    * @return a String representing this ThreadGroup.\n-    * @specnote Language Spec and Class Libraries book disagree a bit here.\n-    *\t\tWe follow the Spec, but add \"ThreadGroup\" per the book.  We\n-    *\t\tinclude \"java.lang\" based on the list() example in the Class\n-    *\t\tLibraries book.\n-    */\n-  public String toString ()\n+  /**\n+   * Return a human-readable String representing this ThreadGroup. The format\n+   * of the string is:<br>\n+   * <code>getClass().getName() + \"[name=\" + getName() + \",maxpri=\"\n+   * + getMaxPriority() + ']'</code>.\n+   *\n+   * @return a human-readable String representing this ThreadGroup\n+   */\n+  public String toString()\n+  {\n+    return getClass().getName() + \"[name=\" + name + \",maxpri=\" + maxpri + ']';\n+  }\n+\n+  /**\n+   * Implements enumerate.\n+   *\n+   * @param list the array to put the threads into\n+   * @param next the next open slot in the array\n+   * @param recurse whether to recurse into descendent ThreadGroups\n+   * @return the number of threads put into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if list is null\n+   * @throws ArrayStoreException if a thread does not fit in the array\n+   * @see #enumerate(Thread[])\n+   * @see #enumerate(Thread[], boolean)\n+   */\n+  private int enumerate(Thread[] list, int next, boolean recurse)\n   {\n-    return \"java.lang.ThreadGroup[name=\" + name + \n-           \",maxpri=\" + maxpri + \"]\";\n-  }\n-\n-  /** Find out if the current Thread can modify this ThreadGroup.\n-    * Calls the current SecurityManager's checkAccess() method to\n-    * find out.  If there is none, it assumes everything's OK.\n-    * @exception SecurityException if the current Thread cannot\n-    *\t\t modify this ThreadGroup.\n-    */\n-  public final void checkAccess()\n+    checkAccess();\n+    if (groups == null)\n+      return next;\n+    int i = threads.size();\n+    while (--i >= 0 && next < list.length)\n+      {\n+        Thread t = (Thread) threads.get(i);\n+        if (t.isAlive())\n+          list[next++] = t;\n+      }\n+    if (recurse)\n+      {\n+        i = groups.size();\n+        while (--i >= 0 && next < list.length)\n+          {\n+            ThreadGroup g = (ThreadGroup) groups.get(i);\n+            next = g.enumerate(list, next, true);\n+          }\n+      }\n+    return next;\n+  }\n+\n+  /**\n+   * Implements enumerate.\n+   *\n+   * @param list the array to put the groups into\n+   * @param next the next open slot in the array\n+   * @param recurse whether to recurse into descendent ThreadGroups\n+   * @return the number of groups put into the array\n+   * @throws SecurityException if permission was denied\n+   * @throws NullPointerException if list is null\n+   * @throws ArrayStoreException if a group does not fit in the array\n+   * @see #enumerate(ThreadGroup[])\n+   * @see #enumerate(ThreadGroup[], boolean)\n+   */\n+  private int enumerate(ThreadGroup[] list, int next, boolean recurse)\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkAccess(this);\n+    checkAccess();\n+    if (groups == null)\n+      return next;\n+    int i = groups.size();\n+    while (--i >= 0 && next < list.length)\n+      {\n+        ThreadGroup g = (ThreadGroup) groups.get(i);\n+        list[next++] = g;\n+        if (recurse && next != list.length)\n+          next = g.enumerate(list, next, true);\n+      }\n+    return next;\n   }\n \n-  // This is called to add a Thread to our internal list.\n+  /**\n+   * Implements list.\n+   *\n+   * @param indentation the current level of indentation\n+   * @see #list()\n+   */\n+  private void list(String indentation)\n+  {\n+    if (groups == null)\n+      return;\n+    System.out.print(indentation + this);\n+    indentation += \"    \";\n+    int i = threads.size();\n+    while (--i >= 0)\n+      System.out.println(indentation + threads.get(i));\n+    i = groups.size();\n+    while (--i >= 0)\n+      ((ThreadGroup) groups.get(i)).list(indentation);\n+  }\n+\n+  /**\n+   * Add a thread to the group. Called by Thread constructors.\n+   *\n+   * @param t the thread to add, non-null\n+   * @throws IllegalThreadStateException if the group is destroyed\n+   */\n   final synchronized void addThread(Thread t)\n   {\n-    if (isDestroyed())\n-      throw new IllegalThreadStateException (\"ThreadGroup is destroyed\");\n-  \n-    threads.addElement(t);\n+    if (groups == null)\n+      throw new IllegalThreadStateException(\"ThreadGroup is destroyed\");\n+    threads.add(t);\n   }\n \n-  // This is called to remove a Thread from our internal list.\n+  /**\n+   * Called by the VM to remove a thread that has died.\n+   *\n+   * @param t the thread to remove, non-null\n+   * @XXX A ThreadListener to call this might be nice.\n+   */\n   final synchronized void removeThread(Thread t)\n   {\n-    if (isDestroyed())\n-      throw new IllegalThreadStateException ();\n-  \n-    threads.removeElement(t);\n+    if (groups == null)\n+      return;\n+    threads.remove(t);\n     // Daemon groups are automatically destroyed when all their threads die.\n     if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n       {\n-\t// We inline destroy to avoid the access check.\n-\tif (parent != null)\n-\t  parent.removeGroup(this);\n-\tparent = null;\n+        // We inline destroy to avoid the access check.\n+        groups = null;\n+        if (parent != null)\n+          parent.removeGroup(this);\n       }\n   }\n \n-  // This is called to add a ThreadGroup to our internal list.\n-  final synchronized void addGroup(ThreadGroup g)\n-  {\n-    groups.addElement(g);\n-  }\n-\n-  // This is called to remove a ThreadGroup from our internal list.\n+  /**\n+   * Called when a group is destroyed, to remove it from its parent.\n+   *\n+   * @param g the destroyed group, non-null\n+   */\n   final synchronized void removeGroup(ThreadGroup g)\n   {\n-    groups.removeElement(g);\n+    groups.remove(g);\n     // Daemon groups are automatically destroyed when all their threads die.\n     if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n       {\n-\t// We inline destroy to avoid the access check.\n-\tif (parent != null)\n-\t  parent.removeGroup(this);\n-\tparent = null;\n+        // We inline destroy to avoid the access check.\n+        groups = null;\n+        if (parent != null)\n+          parent.removeGroup(this);\n       }\n   }\n-}\n+} // class ThreadGroup"}, {"sha": "be0bc307a561f83a1fc3db050577c7acc4c5d910", "filename": "libjava/java/util/AbstractList.java", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FAbstractList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FAbstractList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractList.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n /* AbstractList.java -- Abstract implementation of most of List\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -237,20 +237,22 @@ public boolean equals(Object o)\n   }\n \n   /**\n-   * Obtain a hash code for this list. In order to obey the general contract of\n-   * the hashCode method of class Object, this value is calculated as follows:\n-   * <pre>\n-   *   hashCode = 1;\n-   *   Iterator i = list.iterator();\n-   *   while (i.hasNext())\n-   *     {\n-   *       Object obj = i.next();\n-   *       hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n-   *     }\n-   * </pre>\n+   * Obtains a hash code for this list. In order to obey the general\n+   * contract of the hashCode method of class Object, this value is\n+   * calculated as follows:\n+   * \n+<pre>hashCode = 1;\n+Iterator i = list.iterator();\n+while (i.hasNext())\n+{\n+  Object obj = i.next();\n+  hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+}</pre>\n+   *\n    * This ensures that the general contract of Object.hashCode() is adhered to.\n    *\n    * @return the hash code of this list\n+   *\n    * @see Object#hashCode()\n    * @see #equals(Object)\n    */\n@@ -611,19 +613,21 @@ public List subList(int fromIndex, int toIndex)\n \n /**\n  * This class follows the implementation requirements set forth in\n- * {@link AbstractList#subList(int, int)}. Some compilers have problems\n- * with AbstractList.this.modCount if this class is nested in AbstractList,\n- * even though the JLS defines that to be legal, so we make it a top-level\n- * class.\n+ * {@link AbstractList#subList(int, int)}. It matches Sun's implementation\n+ * by using a non-public top-level class in the same package.\n  *\n  * @author Original author unknown\n  * @author Eric Blake <ebb9@email.byu.edu>\n  */\n class SubList extends AbstractList\n {\n-  private final AbstractList backingList;\n-  private final int offset;\n-  private int size;\n+  // Package visible, for use by iterator.\n+  /** The original list. */\n+  final AbstractList backingList;\n+  /** The index of the first element of the sublist. */\n+  final int offset;\n+  /** The size of the sublist. */\n+  int size;\n \n   /**\n    * Construct the sublist.\n@@ -647,8 +651,8 @@ class SubList extends AbstractList\n    * @throws ConcurrentModificationException if the backing list has been\n    *         modified externally to this sublist\n    */\n-  // This will get inlined, since it is private.\n-  private void checkMod()\n+  // This can be inlined. Package visible, for use by iterator.\n+  void checkMod()\n   {\n     if (modCount != backingList.modCount)\n       throw new ConcurrentModificationException();"}, {"sha": "11c8f5b544ce8bdf1fd0daf9c3542cc354bf016c", "filename": "libjava/java/util/AbstractMap.java", "status": "modified", "additions": 127, "deletions": 1, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FAbstractMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FAbstractMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n /* AbstractMap.java -- Abstract implementation of most of Map\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -518,4 +518,130 @@ static final int hashCode(Object o)\n   {\n     return o == null ? 0 : o.hashCode();\n   }\n+\n+  /**\n+   * A class which implements Map.Entry. It is shared by HashMap, TreeMap,\n+   * Hashtable, and Collections. It is not specified by the JDK, but makes\n+   * life much easier.\n+   *\n+   * @author Jon Zeppieri\n+   * @author Eric Blake <ebb9@email.byu.edu>\n+   */\n+  static class BasicMapEntry implements Map.Entry\n+  {\t// XXX - FIXME Use fully qualified implements as gcj 3.1 workaround.\n+    /**\n+     * The key. Package visible for direct manipulation.\n+     */\n+    Object key;\n+\n+    /**\n+     * The value. Package visible for direct manipulation.\n+     */\n+    Object value;\n+\n+    /**\n+     * Basic constructor initializes the fields.\n+     * @param newKey the key\n+     * @param newValue the value\n+     */\n+    BasicMapEntry(Object newKey, Object newValue)\n+    {\n+      key = newKey;\n+      value = newValue;\n+    }\n+\n+    /**\n+     * Compares the specified object with this entry. Returns true only if\n+     * the object is a mapping of identical key and value. In other words,\n+     * this must be:\n+     * \n+<pre>(o instanceof Map.Entry) &&\n+(getKey() == null ? ((HashMap) o).getKey() == null\n+                  : getKey().equals(((HashMap) o).getKey())) &&\n+(getValue() == null ? ((HashMap) o).getValue() == null\n+                    : getValue().equals(((HashMap) o).getValue()))</pre>\n+     *\n+     * @param o the object to compare\n+     *\n+     * @return <code>true</code> if it is equal\n+     */\n+    public final boolean equals(Object o)\n+    {\n+      if (! (o instanceof Map.Entry))\n+        return false;\n+      // Optimize for our own entries.\n+      if (o instanceof BasicMapEntry)\n+        {\n+          BasicMapEntry e = (BasicMapEntry) o;\n+          return (AbstractMap.equals(key, e.key)\n+                  && AbstractMap.equals(value, e.value));\n+        }\n+      Map.Entry e = (Map.Entry) o;\n+      return (AbstractMap.equals(key, e.getKey())\n+              && AbstractMap.equals(value, e.getValue()));\n+    }\n+\n+    /**\n+     * Get the key corresponding to this entry.\n+     *\n+     * @return the key\n+     */\n+    public final Object getKey()\n+    {\n+      return key;\n+    }\n+\n+    /**\n+     * Get the value corresponding to this entry. If you already called\n+     * Iterator.remove(), the behavior undefined, but in this case it works.\n+     *\n+     * @return the value\n+     */\n+    public final Object getValue()\n+    {\n+      return value;\n+    }\n+\n+    /**\n+     * Returns the hash code of the entry.  This is defined as the exclusive-or\n+     * of the hashcodes of the key and value (using 0 for null). In other\n+     * words, this must be:\n+     * \n+<pre>(getKey() == null ? 0 : getKey().hashCode())\n+^ (getValue() == null ? 0 : getValue().hashCode())</pre>\n+     *\n+     * @return the hash code\n+     */\n+    public final int hashCode()\n+    {\n+      return (AbstractMap.hashCode(key) ^ AbstractMap.hashCode(value));\n+    }\n+\n+    /**\n+     * Replaces the value with the specified object. This writes through\n+     * to the map, unless you have already called Iterator.remove(). It\n+     * may be overridden to restrict a null value.\n+     *\n+     * @param newVal the new value to store\n+     * @return the old value\n+     * @throws NullPointerException if the map forbids null values\n+     */\n+    public Object setValue(Object newVal)\n+    {\n+      Object r = value;\n+      value = newVal;\n+      return r;\n+    }\n+\n+    /**\n+     * This provides a string representation of the entry. It is of the form\n+     * \"key=value\", where string concatenation is used on key and value.\n+     *\n+     * @return the string representation\n+     */\n+    public final String toString()\n+    {\n+      return key + \"=\" + value;\n+    }\n+  } // class BasicMapEntry\n }"}, {"sha": "999f10511bae58a93ff12860a29672829a3b6754", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -73,13 +73,12 @@\n  * and for the first line all fields are set, that line is used to\n  * compute the day. <br>\n  *\n- * <pre>\n- * month + day_of_month\n- * month + week_of_month + day_of_week\n- * month + day_of_week_of_month + day_of_week\n- * day_of_year\n- * day_of_week + week_of_year\n- * </pre>\n+ * \n+<pre>month + day_of_month\n+month + week_of_month + day_of_week\n+month + day_of_week_of_month + day_of_week\n+day_of_year\n+day_of_week + week_of_year</pre>\n  * \n  * The hour_of_day-field takes precedence over the ampm and\n  * hour_of_ampm fields. <br>"}, {"sha": "815afccc80721c4224625a9aec3e1ca98a572f47", "filename": "libjava/java/util/Collections.java", "status": "modified", "additions": 257, "deletions": 31, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCollections.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n /* Collections.java -- Utility class with methods to operate on collections\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -60,7 +60,6 @@\n  * modify the set.\n  *\n  * @author Original author unknown\n- * @author Bryce McKinlay\n  * @author Eric Blake <ebb9@email.byu.edu>\n  * @see Collection\n  * @see Set\n@@ -108,24 +107,6 @@ private Collections()\n    */\n   public static final Set EMPTY_SET = new EmptySet();\n \n-  private static final Iterator EMPTY_ITERATOR = new Iterator()\n-    {\n-      public boolean hasNext()\n-      {\n-\treturn false;\n-      }\n-\n-      public Object next()\n-      {\n-\tthrow new NoSuchElementException();\n-      }\n-\n-      public void remove()\n-      {\n-\tthrow new UnsupportedOperationException();\n-      }\n-    };\n-\n   /**\n    * The implementation of {@link #EMPTY_SET}. This class name is required\n    * for compatibility with Sun's JDK serializability.\n@@ -158,9 +139,94 @@ public int size()\n     /**\n      * Returns an iterator that does not iterate.\n      */\n+    // This is really cheating! I think it's perfectly valid, though.\n     public Iterator iterator()\n     {\n-      return EMPTY_ITERATOR;\n+      return EMPTY_LIST.iterator();\n+    }\n+\n+    // The remaining methods are optional, but provide a performance\n+    // advantage by not allocating unnecessary iterators in AbstractSet.\n+    /**\n+     * The empty set never contains anything.\n+     */\n+    public boolean contains(Object o)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * This is true only if the given collection is also empty.\n+     */\n+    public boolean containsAll(Collection c)\n+    {\n+      return c.isEmpty();\n+    }\n+\n+    /**\n+     * Equal only if the other set is empty.\n+     */\n+    public boolean equals(Object o)\n+    {\n+      return o instanceof Set && ((Set) o).isEmpty();\n+    }\n+\n+    /**\n+     * The hashcode is always 0.\n+     */\n+    public int hashCode()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean remove(Object o)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean removeAll(Collection c)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean retainAll(Collection c)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * The array is always empty.\n+     */\n+    public Object[] toArray()\n+    {\n+      return new Object[0];\n+    }\n+\n+    /**\n+     * We don't even need to use reflection!\n+     */\n+    public Object[] toArray(Object[] a)\n+    {\n+      if (a.length > 0)\n+        a[0] = null;\n+      return a;\n+    }\n+\n+    /**\n+     * The string never changes.\n+     */\n+    public String toString()\n+    {\n+      return \"[]\";\n     }\n   } // class EmptySet\n \n@@ -207,15 +273,106 @@ public Object get(int index)\n     {\n       throw new IndexOutOfBoundsException();\n     }\n-    \n+\n+    // The remaining methods are optional, but provide a performance\n+    // advantage by not allocating unnecessary iterators in AbstractList.\n     /**\n-     * Returns an iterator that does not iterate. Optional, but avoids \n-     * allocation of an iterator in AbstractList.\n+     * Never contains anything.\n      */\n-    public Iterator iterator()\n+    public boolean contains(Object o)\n     {\n-      return EMPTY_ITERATOR;\n-    }    \n+      return false;\n+    }\n+\n+    /**\n+     * This is true only if the given collection is also empty.\n+     */\n+    public boolean containsAll(Collection c)\n+    {\n+      return c.isEmpty();\n+    }\n+\n+    /**\n+     * Equal only if the other set is empty.\n+     */\n+    public boolean equals(Object o)\n+    {\n+      return o instanceof List && ((List) o).isEmpty();\n+    }\n+\n+    /**\n+     * The hashcode is always 1.\n+     */\n+    public int hashCode()\n+    {\n+      return 1;\n+    }\n+\n+    /**\n+     * Returns -1.\n+     */\n+    public int indexOf(Object o)\n+    {\n+      return -1;\n+    }\n+\n+    /**\n+     * Returns -1.\n+     */\n+    public int lastIndexOf(Object o)\n+    {\n+      return -1;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean remove(Object o)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean removeAll(Collection c)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * Always succeeds with false result.\n+     */\n+    public boolean retainAll(Collection c)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * The array is always empty.\n+     */\n+    public Object[] toArray()\n+    {\n+      return new Object[0];\n+    }\n+\n+    /**\n+     * We don't even need to use reflection!\n+     */\n+    public Object[] toArray(Object[] a)\n+    {\n+      if (a.length > 0)\n+        a[0] = null;\n+      return a;\n+    }\n+\n+    /**\n+     * The string never changes.\n+     */\n+    public String toString()\n+    {\n+      return \"[]\";\n+    }\n   } // class EmptyList\n \n   /**\n@@ -253,6 +410,64 @@ public Set entrySet()\n       return EMPTY_SET;\n     }\n \n+    // The remaining methods are optional, but provide a performance\n+    // advantage by not allocating unnecessary iterators in AbstractMap.\n+    /**\n+     * No entries!\n+     */\n+    public boolean containsKey(Object key)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * No entries!\n+     */\n+    public boolean containsValue(Object value)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * Equal to all empty maps.\n+     */\n+    public boolean equals(Object o)\n+    {\n+      return o instanceof Map && ((Map) o).isEmpty();\n+    }\n+\n+    /**\n+     * No mappings, so this returns null.\n+     */\n+    public Object get(Object o)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * The hashcode is always 0.\n+     */\n+    public int hashCode()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * No entries.\n+     */\n+    public Set keySet()\n+    {\n+      return EMPTY_SET;\n+    }\n+\n+    /**\n+     * Remove always succeeds, with null result.\n+     */\n+    public Object remove(Object o)\n+    {\n+      return null;\n+    }\n+\n     /**\n      * Size is always 0.\n      */\n@@ -269,8 +484,17 @@ public Collection values()\n     {\n       return EMPTY_SET;\n     }\n+\n+    /**\n+     * The string never changes.\n+     */\n+    public String toString()\n+    {\n+      return \"[]\";\n+    }\n   } // class EmptyMap\n \n+\f\n   /**\n    * Compare two objects with or without a Comparator. If c is null, uses the\n    * natural ordering. Slightly slower than doing it inline if the JVM isn't\n@@ -502,7 +726,7 @@ public static int lastIndexOfSubList(List source, List target)\n   }\n \n   /**\n-   * Returns an array list holding the elements visited by a given\n+   * Returns an ArrayList holding the elements visited by a given\n    * Enumeration. This method exists for interoperability between legacy\n    * APIs and the new Collection API.\n    *\n@@ -511,9 +735,9 @@ public static int lastIndexOfSubList(List source, List target)\n    * @see ArrayList\n    * @since 1.4\n    */\n-  public static List list(Enumeration e)\n+  public static ArrayList list(Enumeration e)\n   {\n-    List l = new ArrayList();\n+    ArrayList l = new ArrayList();\n     while (e.hasMoreElements())\n       l.add(e.nextElement());\n     return l;\n@@ -1353,7 +1577,7 @@ private static final class SingletonMap extends AbstractMap\n     public Set entrySet()\n     {\n       if (entries == null)\n-        entries = singleton(new BasicMapEntry(k, v)\n+        entries = singleton(new AbstractMap.BasicMapEntry(k, v)\n         {\n           public Object setValue(Object o)\n           {\n@@ -1500,6 +1724,7 @@ public static void swap(List l, int i, int j)\n     l.set(i, l.set(j, l.get(i)));\n   }\n \n+\f\n   /**\n    * Returns a synchronized (thread-safe) collection wrapper backed by the\n    * given collection. Notice that element access through the iterators\n@@ -2682,6 +2907,7 @@ public SortedSet tailSet(Object fromElement)\n     }\n   } // class SynchronizedSortedSet\n \n+\f\n   /**\n    * Returns an unmodifiable view of the given collection. This allows\n    * \"read-only\" access, although changes in the backing collection show up"}, {"sha": "a78eb9a1ff5dfcfcc14b77a9edb649db09685b58", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,6 +1,6 @@\n /* HashMap.java -- a class providing a basic hashtable data structure,\n    mapping Object --> Object\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -162,7 +162,7 @@ public class HashMap extends AbstractMap\n    *\n    * @author Eric Blake <ebb9@email.byu.edu>\n    */\n-  static class HashEntry extends BasicMapEntry\n+  static class HashEntry extends AbstractMap.BasicMapEntry\n   {\n     /**\n      * The next entry in the linked list. Package visible for use by subclass.\n@@ -373,9 +373,9 @@ public void putAll(Map m)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n         // Optimize in case the Entry is one of our own.\n-        if (e instanceof BasicMapEntry)\n+        if (e instanceof AbstractMap.BasicMapEntry)\n           {\n-            BasicMapEntry entry = (BasicMapEntry) e;\n+            AbstractMap.BasicMapEntry entry = (AbstractMap.BasicMapEntry) e;\n             put(entry.key, entry.value);\n           }\n         else\n@@ -647,7 +647,8 @@ void addEntry(Object key, Object value, int idx, boolean callRemove)\n    * @return the matching entry, if found, or null\n    * @see #entrySet()\n    */\n-  private HashEntry getEntry(Object o)\n+  // Package visible, for use in nested classes.\n+  HashEntry getEntry(Object o)\n   {\n     if (!(o instanceof Map.Entry))\n       return null;\n@@ -710,14 +711,13 @@ void putAllInternal(Map m)\n   }\n \n   /**\n-   * Increases the size of the HashMap and rehashes all keys to new array\n-   * indices; this is called when the addition of a new value would cause\n-   * size() > threshold. Note that the existing Entry objects are reused in\n-   * the new hash table.\n-   * <p>\n+   * Increases the size of the HashMap and rehashes all keys to new\n+   * array indices; this is called when the addition of a new value\n+   * would cause size() &gt; threshold. Note that the existing Entry\n+   * objects are reused in the new hash table.\n    *\n-   * This is not specified, but the new size is twice the current size plus\n-   * one; this number is not always prime, unfortunately.\n+   * <p>This is not specified, but the new size is twice the current size\n+   * plus one; this number is not always prime, unfortunately.\n    */\n   private void rehash()\n   {"}, {"sha": "a94143b8f09ae8ee0028988c86adadf1c6392993", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,6 +1,6 @@\n /* Hashtable.java -- a class providing a basic hashtable data structure,\n    mapping Object --> Object\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -102,6 +102,9 @@\n public class Hashtable extends Dictionary\n   implements Map, Cloneable, Serializable\n {\n+  // WARNING: Hashtable is a CORE class in the bootstrap cycle. See the\n+  // comments in vm/reference/java/lang/Runtime for implications of this fact.\n+\n   /** Default number of buckets. This is the value the JDK 1.3 uses. Some\n    * early documentation specified this value as 101. That is incorrect.\n    */\n@@ -176,7 +179,7 @@ public class Hashtable extends Dictionary\n    * pair. A Hashtable Entry is identical to a HashMap Entry, except that\n    * `null' is not allowed for keys and values.\n    */\n-  private static final class HashEntry extends BasicMapEntry\n+  private static final class HashEntry extends AbstractMap.BasicMapEntry\n   {\n     /** The next entry in the linked list. */\n     HashEntry next;\n@@ -340,9 +343,9 @@ public synchronized boolean contains(Object value)\n    *\n    * @param value the value to search for in this Hashtable\n    * @return true if at least one key maps to the value\n-   * @throws NullPointerException if <code>value</code> is null\n    * @see #contains(Object)\n    * @see #containsKey(Object)\n+   * @throws NullPointerException if <code>value</code> is null\n    * @since 1.2\n    */\n   public boolean containsValue(Object value)\n@@ -361,7 +364,7 @@ public boolean containsValue(Object value)\n     // Must throw on null argument even if the table is empty\n     if (value == null)\n       throw new NullPointerException();\n-\n+ \n     return false;\n   }\n \n@@ -511,9 +514,9 @@ public synchronized void putAll(Map m)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n         // Optimize in case the Entry is one of our own.\n-        if (e instanceof BasicMapEntry)\n+        if (e instanceof AbstractMap.BasicMapEntry)\n           {\n-            BasicMapEntry entry = (BasicMapEntry) e;\n+            AbstractMap.BasicMapEntry entry = (AbstractMap.BasicMapEntry) e;\n             put(entry.key, entry.value);\n           }\n         else\n@@ -763,9 +766,9 @@ public boolean remove(Object o)\n   /**\n    * Returns true if this Hashtable equals the supplied Object <code>o</code>.\n    * As specified by Map, this is:\n-   * <pre>\n+   * <code>\n    * (o instanceof Map) && entrySet().equals(((Map) o).entrySet());\n-   * </pre>\n+   * </code>\n    *\n    * @param o the object to compare to\n    * @return true if o is an equal map\n@@ -812,7 +815,10 @@ public synchronized int hashCode()\n    */\n   private int hash(Object key)\n   {\n-    return Math.abs(key.hashCode() % buckets.length);\n+    // Note: Inline Math.abs here, for less method overhead, and to avoid\n+    // a bootstrap dependency, since Math relies on native methods.\n+    int hash = key.hashCode() % buckets.length;\n+    return hash < 0 ? -hash : hash;\n   }\n \n   /**\n@@ -823,7 +829,8 @@ private int hash(Object key)\n    * @return the matching entry, if found, or null\n    * @see #entrySet()\n    */\n-  private HashEntry getEntry(Object o)\n+  // Package visible, for use in nested classes.\n+  HashEntry getEntry(Object o)\n   {\n     if (! (o instanceof Map.Entry))\n       return null;\n@@ -869,7 +876,7 @@ void putAllInternal(Map m)\n   /**\n    * Increases the size of the Hashtable and rehashes all keys to new array\n    * indices; this is called when the addition of a new value would cause\n-   * size() > threshold. Note that the existing Entry objects are reused in\n+   * size() &gt; threshold. Note that the existing Entry objects are reused in\n    * the new hash table.\n    * <p>\n    *\n@@ -1139,4 +1146,4 @@ public Object nextElement()\n       return type == VALUES ? e.value : e.key;\n     }\n   } // class Enumerator\n-}\n+} // class Hashtable"}, {"sha": "2716ac100d0f65083b3d16ab7ce90b65933c50fc", "filename": "libjava/java/util/LinkedHashMap.java", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FLinkedHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedHashMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -71,7 +71,7 @@\n  * <p>\n  *\n  * Under ideal circumstances (no collisions), LinkedHashMap offers O(1) \n- * performance on most operations (<pre>containsValue()</pre> is,\n+ * performance on most operations (<code>containsValue()</code> is,\n  * of course, O(n)).  In the worst case (all keys map to the same \n  * hash code -- very unlikely), most operations are O(n).\n  * <p>\n@@ -87,7 +87,7 @@\n  * {@link ConcurrentModificationException} rather than exhibit\n  * non-deterministic behavior.\n  *\n- * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Eric Blake (ebb9@email.byu.edu)\n  * @see Object#hashCode()\n  * @see Collection\n  * @see Map\n@@ -256,8 +256,9 @@ public LinkedHashMap(int initialCapacity, float loadFactor)\n    * @param initialCapacity the initial capacity (>=0)\n    * @param loadFactor the load factor (>0, not NaN)\n    * @param accessOrder true for access-order, false for insertion-order\n-   * @throws IllegalArgumentException if (initialCapacity < 0) ||\n-   *                                     ! (loadFactor > 0.0)\n+   *\n+   * @throws IllegalArgumentException if (initialCapacity &lt; 0) ||\n+   *                                     ! (loadFactor &gt; 0.0)\n    */\n   public LinkedHashMap(int initialCapacity, float loadFactor,\n                        boolean accessOrder)\n@@ -277,11 +278,12 @@ public void clear()\n   }\n \n   /**\n-   * Returns true if this HashMap contains a value <pre>o</pre>, such that\n-   * <pre>o.equals(value)</pre>.\n+   * Returns <code>true</code> if this HashMap contains a value\n+   * <code>o</code>, such that <code>o.equals(value)</code>.\n    *\n    * @param value the value to search for in this HashMap\n-   * @return true if at least one key maps to the value\n+   *\n+   * @return <code>true</code> if at least one key maps to the value\n    */\n   public boolean containsValue(Object value)\n   {\n@@ -297,7 +299,7 @@ public boolean containsValue(Object value)\n \n   /**\n    * Return the value in this Map associated with the supplied key,\n-   * or <pre>null</pre> if the key maps to nothing.  If this is an\n+   * or <code>null</code> if the key maps to nothing.  If this is an\n    * access-ordered Map and the key is found, this performs structural\n    * modification, moving the key to the newest end of the list. NOTE:\n    * Since the value could also be null, you must use containsKey to\n@@ -350,14 +352,14 @@ public Object get(Object key)\n    * <p>\n    *\n    * For example, to keep the Map limited to 100 entries, override as follows:\n-   * <pre>\n-   * private static final int MAX_ENTRIES = 100;\n-   *\n-   * protected boolean removeEldestEntry(Map.Entry eldest)\n-   * {\n-   *   return size() > MAX_ENTRIES;\n-   * }\n-   * </pre><p>\n+   * \n+<pre>private static final int MAX_ENTRIES = 100;\n+\n+protected boolean removeEldestEntry(Map.Entry eldest)\n+{\n+  return size() &gt; MAX_ENTRIES;\n+}\n+</pre><p>\n    *\n    * Typically, this method does not modify the map, but just uses the\n    * return value as an indication to <code>put</code> whether to proceed.\n@@ -376,6 +378,7 @@ public Object get(Object key)\n    *        returns true. For an access-order map, this is the least\n    *        recently accessed; for an insertion-order map, this is the\n    *        earliest element inserted.\n+   *\n    * @return true if <code>eldest</code> should be removed\n    */\n   protected boolean removeEldestEntry(Map.Entry eldest)\n@@ -467,8 +470,10 @@ public Object next()\n       \n       /**\n        * Removes from the backing HashMap the last element which was fetched\n-       * with the <pre>next()</pre> method.\n+       * with the <code>next()</code> method.\n+       *\n        * @throws ConcurrentModificationException if the HashMap was modified\n+       *\n        * @throws IllegalStateException if called when there is no last element\n        */\n       public void remove()"}, {"sha": "c891f8230f086d2fdfa50cee05991ffe3022473d", "filename": "libjava/java/util/LinkedList.java", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n /* LinkedList.java -- Linked list implementation of the List interface\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -125,12 +125,13 @@ public class LinkedList extends AbstractSequentialList\n    * entry in the list is obtained in constant time, which is a very desirable\n    * property.\n    * For speed and flexibility, range checking is not done in this method:\n-   * Incorrect values will be returned if (n < 0) or (n >= size).\n+   * Incorrect values will be returned if (n &lt; 0) or (n &gt;= size).\n    *\n    * @param n the number of the entry to get\n    * @return the entry at position n\n    */\n-  private Entry getEntry(int n)\n+  // Package visible for use in nested classes.\n+  Entry getEntry(int n)\n   {\n     Entry e;\n     if (n < size / 2)\n@@ -156,7 +157,8 @@ private Entry getEntry(int n)\n    *\n    * @param e the entry to remove\n    */\n-  private void removeEntry(Entry e)\n+  // Package visible for use in nested classes.\n+  void removeEntry(Entry e)\n   {\n     modCount++;\n     size--;"}, {"sha": "22a6b83fc378d6fc03e8fdd68ea88ec9ba728983", "filename": "libjava/java/util/List.java", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FList.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -201,7 +201,7 @@ public interface List extends Collection\n    * @see Object#equals(Object)\n    * @see #hashCode()\n    */\n- /* boolean equals(Object o);*/\n+  boolean equals(Object o);\n \n   /**\n    * Get the element at a given index in this list.\n@@ -213,18 +213,20 @@ public interface List extends Collection\n   Object get(int index);\n \n   /**\n-   * Obtain a hash code for this list. In order to obey the general contract of\n-   * the hashCode method of class Object, this value is calculated as follows:\n-   * <pre>\n-   *   hashCode = 1;\n-   *   Iterator i = list.iterator();\n-   *   while (i.hasNext())\n-   *     {\n-   *       Object obj = i.next();\n-   *       hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n-   *     }\n-   * </pre>\n-   * This ensures that the general contract of Object.hashCode() is adhered to.\n+   * Obtains a hash code for this list. In order to obey the general\n+   * contract of the hashCode method of class Object, this value is\n+   * calculated as follows:\n+   * \n+<p><pre>hashCode = 1;\n+Iterator i = list.iterator();\n+while (i.hasNext())\n+{\n+  Object obj = i.next();\n+  hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+}</pre>\n+   *\n+   * <p>This ensures that the general contract of Object.hashCode()\n+   * is adhered to.\n    *\n    * @return the hash code of this list\n    * @see Object#hashCode()"}, {"sha": "b7b32c212f917279c835395311f7c6cac2efcd4f", "filename": "libjava/java/util/ListResourceBundle.java", "status": "modified", "additions": 73, "deletions": 44, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FListResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FListResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FListResourceBundle.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.ListResourceBundle\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* ListResourceBundle -- a resource bundle build around a list\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,73 +39,102 @@\n package java.util;\n \n /**\n- * A <code>ListResouceBundle</code> provides an easy way, to create\n- * your own resource bundle.  It is an abstract class that you can\n- * subclass.  You should then overwrite the getContents method, that\n- * provides a key/value list.\n- * <br>\n- * The key/value list is a two dimensional list of Object.  The first\n- * dimension ranges over the resources. The second dimension ranges\n- * from zero (key) to one (value).  The keys must be of type String.\n- * <br>\n- * XXX Example!\n+ * A <code>ListResouceBundle</code> provides an easy way, to create your own\n+ * resource bundle. It is an abstract class that you can subclass. You should\n+ * then overwrite the getContents method, that provides a key/value list.\n  *\n+ * <p>The key/value list is a two dimensional list of Object.  The first\n+ * dimension ranges over the resources. The second dimension ranges from\n+ * zero (key) to one (value). The keys must be of type String, and they are\n+ * case-sensitive. For example:\n+ *\n+<br><pre>public class MyResources\n+  extends ListResourceBundle\n+{\n+  public Object[][] getContents()\n+  {\n+    return contents;\n+  }\n+\n+  static final Object[][] contents =\n+  {\n+    // LOCALIZED STRINGS\n+    {\"s1\", \"The disk \\\"{1}\\\" contains {0}.\"},  // MessageFormat pattern\n+    {\"s2\", \"1\"},                       // location of {0} in pattern\n+    {\"s3\", \"My Disk\"},                 // sample disk name\n+    {\"s4\", \"no files\"},                // first ChoiceFormat choice\n+    {\"s5\", \"one file\"},                // second ChoiceFormat choice\n+    {\"s6\", \"{0,number} files\"}         // third ChoiceFormat choice\n+    {\"s7\", \"3 Mar 96\"},                // sample date\n+    {\"s8\", new Dimension(1,5)}         // real object, not just string\n+    // END OF LOCALIZED MATERIAL\n+  };\n+}</pre>\n+ *\n+ * @author Jochen Hoenicke\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @see Locale\n  * @see PropertyResourceBundle\n- * @author Jochen Hoenicke */\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n public abstract class ListResourceBundle extends ResourceBundle\n {\n   /**\n-   * The constructor.  It does nothing special.\n+   * The constructor. It does nothing special.\n    */\n   public ListResourceBundle()\n   {\n   }\n \n   /**\n-   * Gets the key/value list.  You must override this method.\n-   * @return a two dimensional list of Objects.  The first dimension\n-   * ranges over the objects, and the second dimension ranges from\n-   * zero (key) to one (value).  \n-   */\n-  protected abstract Object[][] getContents();\n-\n-  /**\n-   * Override this method to provide the resource for a keys.  This gets\n-   * called by <code>getObject</code>.\n-   * @param key The key of the resource.\n-   * @return The resource for the key or null if it doesn't exists.\n+   * Gets a resource for a given key. This is called by <code>getObject</code>.\n+   *\n+   * @param key the key of the resource\n+   * @return the resource for the key, or null if it doesn't exist\n    */\n   public final Object handleGetObject(String key)\n   {\n     Object[][] contents = getContents();\n-    for (int i = 0; i < contents.length; i++)\n-      {\n-\tif (key.equals(contents[i][0]))\n-\t  return contents[i][1];\n-      }\n+    int i = contents.length;\n+    while (--i >= 0)\n+      if (key.equals(contents[i][0]))\n+        return contents[i][1];\n     return null;\n   }\n \n   /**\n    * This method should return all keys for which a resource exists.\n-   * @return An enumeration of the keys.\n+   *\n+   * @return an enumeration of the keys\n    */\n   public Enumeration getKeys()\n   {\n+    // We make a new Set that holds all the keys, then return an enumeration\n+    // for that. This prevents modifications from ruining the enumeration,\n+    // as well as ignoring duplicates.\n     final Object[][] contents = getContents();\n-    \n-    return new Enumeration()\n-    {\n-      int i = 0;\n-      public boolean hasMoreElements()\n-      {\n-\treturn i < contents.length;\n-      }\n-      public Object nextElement()\n+    Set s = new HashSet();\n+    int i = contents.length;\n+    while (--i >= 0)\n+      s.add(contents[i][0]);\n+    ResourceBundle bundle = parent;\n+    // Eliminate tail recursion.\n+    while (bundle != null)\n       {\n-\treturn contents[i++][0];\n+        Enumeration e = bundle.getKeys();\n+        while (e.hasMoreElements())\n+          s.add(e.nextElement());\n+        bundle = bundle.parent;\n       }\n-    };\n+    return Collections.enumeration(s);\n   }\n-}\n+\n+  /**\n+   * Gets the key/value list. You must override this method, and should not\n+   * provide duplicate keys or null entries.\n+   *\n+   * @return a two dimensional list of String key / Object resouce pairs\n+   */\n+  protected abstract Object[][] getContents();\n+} // class ListResourceBundle"}, {"sha": "01f9b23762c167f485f865880e2585ba1e94eb6d", "filename": "libjava/java/util/Map.java", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -296,14 +296,14 @@\n      */\n     public Object setValue(Object value);\n \n+\n     /**\n-     * Returns the hash code of the entry.  This is defined as the exclusive-or\n-     * of the hashcodes of the key and value (using 0 for null). In other\n-     * words, this must be:\n-     * <pre>\n-     *  (getKey() == null ? 0 : getKey().hashCode()) ^\n-     *  (getValue() == null ? 0 : getValue().hashCode())\n-     * </pre>\n+     * Returns the hash code of the entry.  This is defined as the\n+     * exclusive-or of the hashcodes of the key and value (using 0 for\n+     * <code>null</code>). In other words, this must be:\n+     * \n+<p><pre>(getKey() == null ? 0 : getKey().hashCode())\n+^ (getValue() == null ? 0 : getValue().hashCode())</pre>\n      *\n      * @return the hash code\n      */\n@@ -313,16 +313,16 @@\n      * Compares the specified object with this entry. Returns true only if\n      * the object is a mapping of identical key and value. In other words,\n      * this must be:\n-     * <pre>\n-     * (o instanceof Map.Entry)\n-     * && (getKey() == null ? ((HashMap) o).getKey() == null\n-     *                      : getKey().equals(((HashMap) o).getKey()))\n-     * && (getValue() == null ? ((HashMap) o).getValue() == null\n-     *                        : getValue().equals(((HashMap) o).getValue()))\n-     * </pre>\n+     * \n+<p><pre>(o instanceof Map.Entry)\n+&& (getKey() == null ? ((HashMap) o).getKey() == null\n+                     : getKey().equals(((HashMap) o).getKey()))\n+&& (getValue() == null ? ((HashMap) o).getValue() == null\n+                       : getValue().equals(((HashMap) o).getValue()))</pre>\n      *\n      * @param o the object to compare\n-     * @return true if it is equal\n+     *\n+     * @return <code>true</code> if it is equal\n      */\n     public boolean equals(Object o);\n   }"}, {"sha": "7616f5160f822906826e1ea3381afb6aca8718cc", "filename": "libjava/java/util/Observable.java", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FObservable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FObservable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FObservable.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.Observable\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+/* Observable.java -- an object to be observed\n+   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,63 +38,63 @@\n \n package java.util;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n-\n /**\n+ * This class represents an object which is observable.  Other objects may\n+ * register their intent to be notified when this object changes; and when\n+ * this object does change, it will trigger the <code>update</code> method\n+ * of each observer.\n+ *\n+ * Note that the <code>notifyObservers()</code> method of this class is\n+ * unrelated to the <code>notify()</code> of Object.\n+ *\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Observer\n+ * @status updated to 1.4\n  */\n public class Observable\n {\n-  /** tracks whether this object has changed */\n+  /** Tracks whether this object has changed. */\n   private boolean changed;\n \n-  /* list of the Observers registered as interested in this Observable */\n-  private Vector observers;\n-\n-  /* TBD: This might be better implemented as an Observer[]\n-   * but that would mean writing more code rather than making use of\n-   * the existing Vector class (this also implies a larger text code\n-   * space in resulting executables).  The tradeoff is one of speed\n-   * (manipulating the Observer[] directly) vs. size/reuse.  In the future,\n-   * we may decide to make the tradeoff and reimplement with an Observer[].\n-   */\n+  /* List of the Observers registered as interested in this Observable. */\n+  private LinkedHashSet observers;\n \n   /**\n    * Constructs an Observable with zero Observers.\n    */\n   public Observable()\n   {\n-    changed = false;\n-    observers = new Vector();\n+    observers = new LinkedHashSet();\n   }\n \n   /**\n    * Adds an Observer. If the observer was already added this method does\n    * nothing.\n    *\n-   * @param observer Observer to add.\n+   * @param observer Observer to add\n+   * @throws NullPointerException if observer is null\n    */\n   public synchronized void addObserver(Observer observer)\n   {\n-    if (!observers.contains(observer))\n-      observers.addElement(observer);\n+    observers.add(observer);\n   }\n \n   /**\n-   * Reset this Observable's state to unchanged.\n+   * Reset this Observable's state to unchanged. This is called automatically\n+   * by <code>notifyObservers</code> once all observers have been notified.\n+   *\n+   * @see #notifyObservers()\n    */\n   protected synchronized void clearChanged()\n   {\n     changed = false;\n   }\n \n   /**\n-   * @return Number of Observers for this Observable.\n+   * Returns the number of observers for this object.\n+   *\n+   * @return number of Observers for this\n    */\n   public synchronized int countObservers()\n   {\n@@ -104,23 +104,26 @@ public synchronized int countObservers()\n   /**\n    * Deletes an Observer of this Observable.\n    *\n-   * @param victim Observer to delete.\n+   * @param victim Observer to delete\n    */\n   public synchronized void deleteObserver(Observer victim)\n   {\n-    observers.removeElement(victim);\n+    observers.remove(victim);\n   }\n \n   /**\n    * Deletes all Observers of this Observable.\n    */\n   public synchronized void deleteObservers()\n   {\n-    observers.removeAllElements();\n+    observers.clear();\n   }\n \n   /**\n-   * @return Whether or not this Observable has changed.\n+   * True if <code>setChanged</code> has been called more recently than\n+   * <code>clearChanged</code>.\n+   *\n+   * @return whether or not this Observable has changed\n    */\n   public synchronized boolean hasChanged()\n   {\n@@ -129,7 +132,10 @@ public synchronized boolean hasChanged()\n \n   /**\n    * If the Observable has actually changed then tell all Observers about it,\n-   * then resets state to unchanged.\n+   * then reset state to unchanged.\n+   *\n+   * @see #notifyObservers(Object)\n+   * @see Observer#update(Observable, Object)\n    */\n   public void notifyObservers()\n   {\n@@ -138,21 +144,29 @@ public void notifyObservers()\n \n   /**\n    * If the Observable has actually changed then tell all Observers about it,\n-   * then resets state to unchanged. \n-   * Note that though the order of notification is unspecified in subclasses,\n-   * in Observable it is in the order of registration.\n+   * then reset state to unchanged. Note that though the order of\n+   * notification is unspecified in subclasses, in Observable it is in the\n+   * order of registration.\n    *\n-   * @param obj Arguement to Observer's update method.\n+   * @param obj argument to Observer's update method\n+   * @see Observer#update(Observable, Object)\n    */\n   public void notifyObservers(Object obj)\n   {\n-    if (!hasChanged())\n+    if (! hasChanged())\n       return;\n-    Vector ob1 = (Vector) observers.clone();\n-\n-    for (int i = 0; i < ob1.size(); i++)\n-      ((Observer) ob1.elementAt(i)).update(this, obj);\n-\n+    // Create clone inside monitor, as that is relatively fast and still\n+    // important to keep threadsafe, but update observers outside of the\n+    // lock since update() can call arbitrary code.\n+    Set s;\n+    synchronized (this)\n+      {\n+        s = (Set) observers.clone();\n+      }\n+    int i = s.size();\n+    Iterator iter = s.iterator();\n+    while (--i >= 0)\n+      ((Observer) iter.next()).update(this, obj);\n     clearChanged();\n   }\n "}, {"sha": "adad25055ac15039c455b545c5909d3910e94c13", "filename": "libjava/java/util/Properties.java", "status": "modified", "additions": 349, "deletions": 347, "changes": 696, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FProperties.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.Properties\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+/* Properties.java -- a set of persistent properties\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,70 +37,109 @@\n \n \n package java.util;\n-import java.io.*;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.PrintStream;\n+import java.io.OutputStreamWriter;\n \n /**\n+ * A set of persistent properties, which can be saved or loaded from a stream.\n+ * A property list may also contain defaults, searched if the main list\n+ * does not contain a property for a given key.\n+ *\n  * An example of a properties file for the german language is given\n  * here.  This extends the example given in ListResourceBundle.\n  * Create a file MyResource_de.properties with the following contents\n  * and put it in the CLASSPATH.  (The character\n  * <code>\\</code><code>u00e4</code> is the german &auml;)\n+ *\n  * \n- * <pre>\n- * s1=3\n- * s2=MeineDisk\n- * s3=3. M\\<code></code>u00e4rz 96\n- * s4=Die Diskette ''{1}'' enth\\<code></code>u00e4lt {0} in {2}.\n- * s5=0\n- * s6=keine Dateien\n- * s7=1\n- * s8=eine Datei\n- * s9=2\n- * s10={0,number} Dateien\n- * s11=Das Formatieren schlug fehl mit folgender Exception: {0}\n- * s12=FEHLER\n- * s13=Ergebnis\n- * s14=Dialog\n- * s15=Auswahlkriterium\n- * s16=1,3\n- * </pre>\n+<pre>s1=3\n+s2=MeineDisk\n+s3=3. M\\<code></code>u00e4rz 96\n+s4=Die Diskette ''{1}'' enth\\<code></code>u00e4lt {0} in {2}.\n+s5=0\n+s6=keine Dateien\n+s7=1\n+s8=eine Datei\n+s9=2\n+s10={0,number} Dateien\n+s11=Das Formatieren schlug fehl mit folgender Exception: {0}\n+s12=FEHLER\n+s13=Ergebnis\n+s14=Dialog\n+s15=Auswahlkriterium\n+s16=1,3</pre>\n  *\n- * Although this is a sub class of a hash table, you should never\n+ * <p>Although this is a sub class of a hash table, you should never\n  * insert anything other than strings to this property, or several\n  * methods, that need string keys and values, will fail.  To ensure\n  * this, you should use the <code>get/setProperty</code> method instead\n  * of <code>get/put</code>.\n  *\n- * @see PropertyResourceBundle\n+ * Properties are saved in ISO 8859-1 encoding, using Unicode escapes with\n+ * a single <code>u</code> for any character which cannot be represented.\n+ *\n  * @author Jochen Hoenicke\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see PropertyResourceBundle\n+ * @status updated to 1.4\n  */\n public class Properties extends Hashtable\n {\n+  // WARNING: Properties is a CORE class in the bootstrap cycle. See the\n+  // comments in vm/reference/java/lang/Runtime for implications of this fact.\n+\n   /**\n    * The property list that contains default values for any keys not\n-   * in this property list.  \n+   * in this property list.\n+   *\n+   * @serial the default properties\n    */\n   protected Properties defaults;\n \n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n   private static final long serialVersionUID = 4112578634029874840L;\n \n   /**\n-   * Creates a new empty property list.\n+   * Creates a new empty property list with no default values.\n    */\n   public Properties()\n   {\n-    this.defaults = null;\n   }\n \n   /**\n    * Create a new empty property list with the specified default values.\n-   * @param defaults a Properties object containing the default values.\n+   *\n+   * @param defaults a Properties object containing the default values\n    */\n   public Properties(Properties defaults)\n   {\n     this.defaults = defaults;\n   }\n \n+  /**\n+   * Adds the given key/value pair to this properties.  This calls\n+   * the hashtable method put.\n+   *\n+   * @param key the key for this property\n+   * @param value the value for this property\n+   * @return The old value for the given key\n+   * @see #getProperty(String)\n+   * @since 1.2\n+   */\n+  public Object setProperty(String key, String value)\n+  {\n+    return put(key, value);\n+  }\n+\n   /**\n    * Reads a property list from an input stream.  The stream should\n    * have the following format: <br>\n@@ -120,235 +159,234 @@ public Properties(Properties defaults)\n    *\n    * Escape sequences <code>\\t, \\n, \\r, \\\\, \\\", \\', \\!, \\#, \\ </code>(a\n    * space), and unicode characters with the\n-   * <code>\\</code><code>u</code>xxxx notation are detected, and \n+   * <code>\\\\u</code><em>xxxx</em> notation are detected, and\n    * converted to the corresponding single character. <br>\n    *\n-   * <pre>\n-   * # This is a comment\n-   * key     = value\n-   * k\\:5      \\ a string starting with space and ending with newline\\n\n-   * # This is a multiline specification; note that the value contains\n-   * # no white space.\n-   * weekdays: Sunday,Monday,Tuesday,Wednesday,\\\n-   *           Thursday,Friday,Saturday\n-   * # The safest way to include a space at the end of a value:\n-   * label   = Name:\\<code></code>u0020\n-   * </pre>\n+   * \n+<pre># This is a comment\n+key     = value\n+k\\:5      \\ a string starting with space and ending with newline\\n\n+# This is a multiline specification; note that the value contains\n+# no white space.\n+weekdays: Sunday,Monday,Tuesday,Wednesday,\\\\\n+          Thursday,Friday,Saturday\n+# The safest way to include a space at the end of a value:\n+label   = Name:\\\\u0020</pre>\n    *\n    * @param in the input stream\n-   * @exception IOException if an error occurred when reading\n-   * from the input.  */\n+   * @throws IOException if an error occurred when reading the input\n+   * @throws NullPointerException if in is null\n+   */\n   public void load(InputStream inStream) throws IOException\n   {\n     // The spec says that the file must be encoded using ISO-8859-1.\n     BufferedReader reader =\n       new BufferedReader(new InputStreamReader(inStream, \"ISO-8859-1\"));\n     String line;\n-    \n+\n     while ((line = reader.readLine()) != null)\n       {\n-\tchar c = 0;\n-\tint pos = 0;\n-\twhile (pos < line.length()\n-\t       && Character.isWhitespace(c = line.charAt(pos)))\n-\t  pos++;\n+        char c = 0;\n+        int pos = 0;\n+        while (pos < line.length()\n+               && Character.isWhitespace(c = line.charAt(pos)))\n+          pos++;\n \n-\t// If line is empty or begins with a comment character,\n-\t// skip this line.\n-\tif (pos == line.length() || c == '#' || c == '!')\n-\t  continue;\n+        // If line is empty or begins with a comment character,\n+        // skip this line.\n+        if (pos == line.length() || c == '#' || c == '!')\n+          continue;\n \n-\t// The characters up to the next Whitespace, ':', or '='\n-\t// describe the key.  But look for escape sequences.\n-\tStringBuffer key = new StringBuffer();\n-\twhile (pos < line.length()\n-\t       && !Character.isWhitespace(c = line.charAt(pos++))\n-\t       && c != '=' && c != ':')\n-\t  {\n-\t    if (c == '\\\\')\n-\t      {\n-\t\tif (pos == line.length())\n-\t\t  {\n-\t\t    // The line continues on the next line.\n-\t\t    line = reader.readLine();\n-\t\t    pos = 0;\n-\t\t    while (pos < line.length()\n-\t\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n-\t\t      pos++;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    c = line.charAt(pos++);\n-\t\t    switch (c)\n-\t\t      {\n-\t\t      case 'n':\n-\t\t\tkey.append('\\n');\n-\t\t\tbreak;\n-\t\t      case 't':\n-\t\t\tkey.append('\\t');\n-\t\t\tbreak;\n-\t\t      case 'r':\n-\t\t\tkey.append('\\r');\n-\t\t\tbreak;\n-\t\t      case 'u':\n-\t\t\tif (pos + 4 <= line.length())\n-\t\t\t  {\n-\t\t\t    char uni = (char) Integer.parseInt\n-\t\t\t      (line.substring(pos, pos + 4), 16);\n-\t\t\t    key.append(uni);\n-\t\t\t    pos += 4;\n-\t\t\t  }\t// else throw exception?\n-\t\t\tbreak;\n-\t\t      default:\n-\t\t\tkey.append(c);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t    else\n-\t      key.append(c);\n-\t  }\n+        // The characters up to the next Whitespace, ':', or '='\n+        // describe the key.  But look for escape sequences.\n+        StringBuffer key = new StringBuffer();\n+        while (pos < line.length()\n+               && ! Character.isWhitespace(c = line.charAt(pos++))\n+               && c != '=' && c != ':')\n+          {\n+            if (c == '\\\\')\n+              {\n+                if (pos == line.length())\n+                  {\n+                    // The line continues on the next line.\n+                    line = reader.readLine();\n+                    pos = 0;\n+                    while (pos < line.length()\n+                           && Character.isWhitespace(c = line.charAt(pos)))\n+                      pos++;\n+                  }\n+                else\n+                  {\n+                    c = line.charAt(pos++);\n+                    switch (c)\n+                      {\n+                      case 'n':\n+                        key.append('\\n');\n+                        break;\n+                      case 't':\n+                        key.append('\\t');\n+                        break;\n+                      case 'r':\n+                        key.append('\\r');\n+                        break;\n+                      case 'u':\n+                        if (pos + 4 <= line.length())\n+                          {\n+                            char uni = (char) Integer.parseInt\n+                              (line.substring(pos, pos + 4), 16);\n+                            key.append(uni);\n+                            pos += 4;\n+                          }        // else throw exception?\n+                        break;\n+                      default:\n+                        key.append(c);\n+                        break;\n+                      }\n+                  }\n+              }\n+            else\n+              key.append(c);\n+          }\n \n-\tboolean isDelim = (c == ':' || c == '=');\n-\twhile (pos < line.length()\n-\t       && Character.isWhitespace(c = line.charAt(pos)))\n-\t  pos++;\n+        boolean isDelim = (c == ':' || c == '=');\n+        while (pos < line.length()\n+               && Character.isWhitespace(c = line.charAt(pos)))\n+          pos++;\n \n-\tif (!isDelim && (c == ':' || c == '='))\n-\t  {\n-\t    pos++;\n-\t    while (pos < line.length()\n-\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n-\t      pos++;\n-\t  }\n+        if (! isDelim && (c == ':' || c == '='))\n+          {\n+            pos++;\n+            while (pos < line.length()\n+                   && Character.isWhitespace(c = line.charAt(pos)))\n+              pos++;\n+          }\n \n-\tStringBuffer element = new StringBuffer(line.length() - pos);\n-\twhile (pos < line.length())\n-\t  {\n-\t    c = line.charAt(pos++);\n-\t    if (c == '\\\\')\n-\t      {\n-\t\tif (pos == line.length())\n-\t\t  {\n-\t\t    // The line continues on the next line.\n-\t\t    line = reader.readLine();\n-\t\t    pos = 0;\n-\t\t    while (pos < line.length()\n-\t\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n-\t\t      pos++;\n-\t\t    element.ensureCapacity(line.length() - pos +\n-\t\t\t\t\t   element.length());\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    c = line.charAt(pos++);\n-\t\t    switch (c)\n-\t\t      {\n-\t\t      case 'n':\n-\t\t\telement.append('\\n');\n-\t\t\tbreak;\n-\t\t      case 't':\n-\t\t\telement.append('\\t');\n-\t\t\tbreak;\n-\t\t      case 'r':\n-\t\t\telement.append('\\r');\n-\t\t\tbreak;\n-\t\t      case 'u':\n-\t\t\tif (pos + 4 <= line.length())\n-\t\t\t  {\n-\t\t\t    char uni = (char) Integer.parseInt\n-\t\t\t      (line.substring(pos, pos + 4), 16);\n-\t\t\t    element.append(uni);\n-\t\t\t    pos += 4;\n-\t\t\t  }\t// else throw exception?\n-\t\t\tbreak;\n-\t\t      default:\n-\t\t\telement.append(c);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t    else\n-\t      element.append(c);\n-\t  }\n-\tput(key.toString(), element.toString());\n+        StringBuffer element = new StringBuffer(line.length() - pos);\n+        while (pos < line.length())\n+          {\n+            c = line.charAt(pos++);\n+            if (c == '\\\\')\n+              {\n+                if (pos == line.length())\n+                  {\n+                    // The line continues on the next line.\n+                    line = reader.readLine();\n+                    pos = 0;\n+                    while (pos < line.length()\n+                           && Character.isWhitespace(c = line.charAt(pos)))\n+                      pos++;\n+                    element.ensureCapacity(line.length() - pos +\n+                                           element.length());\n+                  }\n+                else\n+                  {\n+                    c = line.charAt(pos++);\n+                    switch (c)\n+                      {\n+                      case 'n':\n+                        element.append('\\n');\n+                        break;\n+                      case 't':\n+                        element.append('\\t');\n+                        break;\n+                      case 'r':\n+                        element.append('\\r');\n+                        break;\n+                      case 'u':\n+                        if (pos + 4 <= line.length())\n+                          {\n+                            char uni = (char) Integer.parseInt\n+                              (line.substring(pos, pos + 4), 16);\n+                            element.append(uni);\n+                            pos += 4;\n+                          }        // else throw exception?\n+                        break;\n+                      default:\n+                        element.append(c);\n+                        break;\n+                      }\n+                  }\n+              }\n+            else\n+              element.append(c);\n+          }\n+        put(key.toString(), element.toString());\n       }\n   }\n \n   /**\n    * Calls <code>store(OutputStream out, String header)</code> and\n    * ignores the IOException that may be thrown.\n-   * @deprecated use store instead.\n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n+   *\n+   * @param out the stream to write to\n+   * @param header a description of the property list\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that are not strings\n+   * @deprecated use {@link #store(OutputStream, String)} instead\n    */\n   public void save(OutputStream out, String header)\n   {\n     try\n       {\n-\tstore(out, header);\n+        store(out, header);\n       }\n     catch (IOException ex)\n       {\n       }\n   }\n \n   /**\n-   * Writes the key/value pairs to the given output stream. <br>\n+   * Writes the key/value pairs to the given output stream, in a format\n+   * suitable for <code>load</code>.<br>\n    *\n    * If header is not null, this method writes a comment containing\n    * the header as first line to the stream.  The next line (or first\n    * line if header is null) contains a comment with the current date.\n    * Afterwards the key/value pairs are written to the stream in the\n-   * following format. <br>\n+   * following format.<br>\n    *\n    * Each line has the form <code>key = value</code>.  Newlines,\n    * Returns and tabs are written as <code>\\n,\\t,\\r</code> resp.\n    * The characters <code>\\, !, #, =</code> and <code>:</code> are\n    * preceeded by a backslash.  Spaces are preceded with a backslash,\n    * if and only if they are at the beginning of the key.  Characters\n    * that are not in the ascii range 33 to 127 are written in the\n-   * <code>\\</code><code>u</code>xxxx Form.\n+   * <code>\\</code><code>u</code>xxxx Form.<br>\n+   *\n+   * Following the listing, the output stream is flushed but left open.\n    *\n    * @param out the output stream\n-   * @param header the header written in the first line, may be null.\n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n+   * @param header the header written in the first line, may be null\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that isn't a string\n+   * @throws IOException if writing to the stream fails\n+   * @throws NullPointerException if out is null\n+   * @since 1.2\n    */\n   public void store(OutputStream out, String header) throws IOException\n   {\n     // The spec says that the file must be encoded using ISO-8859-1.\n     PrintWriter writer\n-      = new PrintWriter(new OutputStreamWriter (out, \"ISO-8859-1\"));\n+      = new PrintWriter(new OutputStreamWriter(out, \"ISO-8859-1\"));\n     if (header != null)\n       writer.println(\"#\" + header);\n-    writer.println(\"#\" + new Date().toString());\n+    writer.println(\"#\" + new Date());\n     list(writer);\n     writer.flush();\n   }\n \n-  /**\n-   * Adds the given key/value pair to this properties.  This calls\n-   * the hashtable method put.\n-   * @param key the key for this property\n-   * @param value the value for this property\n-   * @return The old value for the given key.\n-   * @since JDK1.2 */\n-  public Object setProperty(String key, String value)\n-  {\n-    return put(key, value);\n-  }\n-\n   /**\n    * Gets the property with the specified key in this property list.\n    * If the key is not found, the default property list is searched.\n-   * If the property is not found in default or the default of\n-   * default, null is returned.\n-   * @param key The key for this property.\n-   * @param defaulValue A default value\n-   * @return The value for the given key, or null if not found. \n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n+   * If the property is not found in the default, null is returned.\n+   *\n+   * @param key The key for this property\n+   * @return the value for the given key, or null if not found\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that isn't a string\n+   * @see #defaults\n+   * @see #setProperty(String, String)\n+   * @see #getProperty(String, String)\n    */\n   public String getProperty(String key)\n   {\n@@ -358,198 +396,162 @@ public String getProperty(String key)\n   /**\n    * Gets the property with the specified key in this property list.  If\n    * the key is not found, the default property list is searched.  If the\n-   * property is not found in default or the default of default, the \n-   * specified defaultValue is returned.\n-   * @param key The key for this property.\n-   * @param defaulValue A default value\n-   * @return The value for the given key.\n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n+   * property is not found in the default, the specified defaultValue is\n+   * returned.\n+   *\n+   * @param key The key for this property\n+   * @param defaultValue A default value\n+   * @return The value for the given key\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that isn't a string\n+   * @see #defaults\n+   * @see #setProperty(String, String)\n    */\n   public String getProperty(String key, String defaultValue)\n   {\n     Properties prop = this;\n     // Eliminate tail recursion.\n     do\n       {\n-\tString value = (String) prop.get(key);\n-\tif (value != null)\n-\t  return value;\n-\tprop = prop.defaults;\n+        String value = (String) prop.get(key);\n+        if (value != null)\n+          return value;\n+        prop = prop.defaults;\n       }\n     while (prop != null);\n     return defaultValue;\n   }\n \n-  private final void addHashEntries(Hashtable base)\n-  {\n-    if (defaults != null)\n-      defaults.addHashEntries(base);\n-    Enumeration keys = keys();\n-    while (keys.hasMoreElements())\n-      base.put(keys.nextElement(), base);\n-  }\n-\n   /**\n    * Returns an enumeration of all keys in this property list, including\n    * the keys in the default property list.\n+   *\n+   * @return an Enumeration of all defined keys\n    */\n   public Enumeration propertyNames()\n   {\n-    // We make a new Hashtable that holds all the keys.  Then we\n-    // return an enumeration for this hash.  We do this because we\n-    // don't want modifications to be reflected in the enumeration\n-    // (per JCL), and because there doesn't seem to be a\n-    // particularly better way to ensure that duplicates are\n-    // ignored.\n-    Hashtable t = new Hashtable();\n-    addHashEntries(t);\n-    return t.keys();\n+    // We make a new Set that holds all the keys, then return an enumeration\n+    // for that. This prevents modifications from ruining the enumeration,\n+    // as well as ignoring duplicates.\n+    Properties prop = this;\n+    Set s = new HashSet();\n+    // Eliminate tail recursion.\n+    do\n+      {\n+        s.addAll(prop.keySet());\n+        prop = prop.defaults;\n+      }\n+    while (prop != null);\n+    return Collections.enumeration(s);\n   }\n \n   /**\n-   * Formats a key/value pair for output in a properties file.\n-   * See store for a description of the format.\n-   * @param key the key.\n-   * @param value the value.\n-   * @see #store\n+   * Writes the key/value pairs to the given print stream.  They are\n+   * written in the way described in the method store. This does not visit\n+   * the keys in the default properties.\n+   *\n+   * @param out the stream, where the key/value pairs are written to\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that isn't a string\n+   * @see #store(OutputStream, String)\n    */\n-  private String formatForOutput(String key, String value)\n+  public void list(PrintStream out)\n   {\n-    // This is a simple approximation of the expected line size.\n-    StringBuffer result =\n-      new StringBuffer(key.length() + value.length() + 16);\n-    boolean head = true;\n-    for (int i = 0; i < key.length(); i++)\n+    Iterator iter = entrySet().iterator();\n+    int i = size();\n+    StringBuffer s = new StringBuffer(); // Reuse the same buffer.\n+    while (--i >= 0)\n       {\n-\tchar c = key.charAt(i);\n-\tswitch (c)\n-\t  {\n-\t  case '\\n':\n-\t    result.append(\"\\\\n\");\n-\t    break;\n-\t  case '\\r':\n-\t    result.append(\"\\\\r\");\n-\t    break;\n-\t  case '\\t':\n-\t    result.append(\"\\\\t\");\n-\t    break;\n-\t  case '\\\\':\n-\t    result.append(\"\\\\\\\\\");\n-\t    break;\n-\t  case '!':\n-\t    result.append(\"\\\\!\");\n-\t    break;\n-\t  case '#':\n-\t    result.append(\"\\\\#\");\n-\t    break;\n-\t  case '=':\n-\t    result.append(\"\\\\=\");\n-\t    break;\n-\t  case ':':\n-\t    result.append(\"\\\\:\");\n-\t    break;\n-\t  case ' ':\n-\t    result.append(\"\\\\ \");\n-\t    break;\n-\t  default:\n-\t    if (c < 32 || c > '~')\n-\t      {\n-\t\tString hex = Integer.toHexString(c);\n-\t\tresult.append(\"\\\\u0000\".substring(0, 6 - hex.length()));\n-\t\tresult.append(hex);\n-\t      }\n-\t    else\n-\t        result.append(c);\n-\t  }\n-\tif (c != 32)\n-\t  head = false;\n+        Map.Entry entry = (Map.Entry) iter.next();\n+        formatForOutput((String) entry.getKey(), s, true);\n+        s.append('=');\n+        formatForOutput((String) entry.getValue(), s, false);\n+        out.println(s);\n       }\n-    result.append('=');\n-    head = true;\n-    for (int i = 0; i < value.length(); i++)\n-      {\n-\tchar c = value.charAt(i);\n-\tswitch (c)\n-\t  {\n-\t  case '\\n':\n-\t    result.append(\"\\\\n\");\n-\t    break;\n-\t  case '\\r':\n-\t    result.append(\"\\\\r\");\n-\t    break;\n-\t  case '\\t':\n-\t    result.append(\"\\\\t\");\n-\t    break;\n-\t  case '\\\\':\n-\t    result.append(\"\\\\\\\\\");\n-\t    break;\n-\t  case '!':\n-\t    result.append(\"\\\\!\");\n-\t    break;\n-\t  case '#':\n-\t    result.append(\"\\\\#\");\n-\t    break;\n-\t  case ' ':\n-\t    result.append(head ? \"\\\\ \" : \" \");\n-\t    break;\n-\t  default:\n-\t    if (c < 32 || c > '~')\n-\t      {\n-\t\tString hex = Integer.toHexString(c);\n-\t\tresult.append(\"\\\\u0000\".substring(0, 6 - hex.length()));\n-\t\tresult.append(hex);\n-\t      }\n-\t    else\n-\t      result.append(c);\n-\t  }\n-\tif (c != 32)\n-\t  head = false;\n-      }\n-    return result.toString();\n   }\n \n   /**\n-   * Writes the key/value pairs to the given print stream.  They are\n+   * Writes the key/value pairs to the given print writer.  They are\n    * written in the way, described in the method store.\n-   * @param out the stream, where the key/value pairs are written to.\n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n-   * @see #store\n+   *\n+   * @param out the writer, where the key/value pairs are written to\n+   * @throws ClassCastException if this property contains any key or\n+   *         value that isn't a string\n+   * @see #store(OutputStream, String)\n+   * @see #list(PrintStream)\n+   * @since 1.1\n    */\n-  public void list(PrintStream out)\n+  public void list(PrintWriter out)\n   {\n-    Enumeration keys = keys();\n-    Enumeration elts = elements();\n-    while (keys.hasMoreElements())\n+    Iterator iter = entrySet().iterator();\n+    int i = size();\n+    StringBuffer s = new StringBuffer(); // Reuse the same buffer.\n+    while (--i >= 0)\n       {\n-\tString key = (String) keys.nextElement();\n-\tString elt = (String) elts.nextElement();\n-\tString output = formatForOutput(key, elt);\n-\tout.println(output);\n+        Map.Entry entry = (Map.Entry) iter.next();\n+        formatForOutput((String) entry.getKey(), s, true);\n+        s.append('=');\n+        formatForOutput((String) entry.getValue(), s, false);\n+        out.println(s);\n       }\n   }\n \n   /**\n-   * Writes the key/value pairs to the given print writer.  They are\n-   * written in the way, described in the method store.\n-   * @param out the writer, where the key/value pairs are written to.\n-   * @exception ClassCastException if this property contains any key or\n-   * value that isn't a string.\n-   * @see #store\n-   * @see #list(java.io.PrintStream)\n-   * @since JDK1.1\n+   * Formats a key or value for output in a properties file.\n+   * See store for a description of the format.\n+   *\n+   * @param str the string to format\n+   * @param buffer the buffer to add it to\n+   * @param key true if all ' ' must be escaped for the key, false if only\n+   *        leading spaces must be escaped for the value\n+   * @see #store(OutputStream, String)\n    */\n-  public void list(PrintWriter out)\n+  private void formatForOutput(String str, StringBuffer buffer, boolean key)\n   {\n-    Enumeration keys = keys();\n-    Enumeration elts = elements();\n-    while (keys.hasMoreElements())\n+    if (key)\n+      {\n+        buffer.setLength(0);\n+        buffer.ensureCapacity(str.length());\n+      }\n+    else\n+      buffer.ensureCapacity(buffer.length() + str.length());\n+    boolean head = true;\n+    int size = str.length();\n+    for (int i = 0; i < size; i++)\n       {\n-\tString key = (String) keys.nextElement();\n-\tString elt = (String) elts.nextElement();\n-\tString output = formatForOutput(key, elt);\n-\tout.println(output);\n+        char c = str.charAt(i);\n+        switch (c)\n+          {\n+          case '\\n':\n+            buffer.append(\"\\\\n\");\n+            break;\n+          case '\\r':\n+            buffer.append(\"\\\\r\");\n+            break;\n+          case '\\t':\n+            buffer.append(\"\\\\t\");\n+            break;\n+          case ' ':\n+            buffer.append(head ? \"\\\\ \" : \" \");\n+            break;\n+          case '\\\\':\n+          case '!':\n+          case '#':\n+          case '=':\n+          case ':':\n+            buffer.append('\\\\').append(c);\n+          default:\n+            if (c < ' ' || c > '~')\n+              {\n+                String hex = Integer.toHexString(c);\n+                buffer.append(\"\\\\u0000\".substring(0, 6 - hex.length()));\n+                buffer.append(hex);\n+              }\n+            else\n+              buffer.append(c);\n+          }\n+        if (c != ' ')\n+          head = key;\n       }\n   }\n-}\n+} // class Properties"}, {"sha": "bb03e45f3624ba950eef40d26126825cf8e767b6", "filename": "libjava/java/util/PropertyPermission.java", "status": "modified", "additions": 116, "deletions": 131, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FPropertyPermission.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.PropertyPermission\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* PropertyPermission.java -- permission to get and set System properties\n+   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n \n package java.util;\n+\n import java.security.Permission;\n import java.security.BasicPermission;\n import java.security.PermissionCollection;\n@@ -49,214 +50,198 @@\n  * This class represents the permission to access and modify a property.<br>\n  *\n  * The name is the name of the property, e.g. xxx.  You can also\n- * use an asterisk \"*\" as described in BasicPermission <br>\n+ * use an asterisk \"*\" as described in BasicPermission.<br>\n  *\n- * The action string is a comma-separated list if keywords.  There are\n+ * The action string is a comma-separated list of keywords.  There are\n  * two possible actions:\n  * <dl>\n- * <dt>read</dt> \n+ * <dt>read</dt>\n  * <dd>Allows to read the property via <code>System.getProperty</code>.</dd>\n- * <dt>write</dt> \n+ * <dt>write</dt>\n  * <dd>Allows to write the property via <code>System.setProperty</code>.</dd>\n  * </dl>\n- * \n+ *\n  * The action string is case insensitive (it is converted to lower case).\n  *\n  * @see Permission\n  * @see BasicPermission\n- * @author Jochen Hoenicke \n+ * @see SecurityManager\n+ * @author Jochen Hoenicke\n+ * @since 1.2\n+ * @status updated to 1.4\n  */\n public final class PropertyPermission extends BasicPermission\n {\n   /**\n-   * @serialField action String\n-   *   The action string.\n+   * PropertyPermission uses a more efficient representation than the\n+   * serialized form; this documents the difference.\n+   *\n+   * @serialField action String the action string\n    */\n   private static final ObjectStreamField[] serialPersistentFields =\n   {\n     new ObjectStreamField(\"action\", String.class)\n   };\n \n+  /**\n+   * Compatible with JDK 1.2+.\n+   */\n   private static final long serialVersionUID = 885438825399942851L;\n \n+  /** Permission to read. */\n   private static final int READ = 1;\n+  /** Permission to write. */\n   private static final int WRITE = 2;\n-  private transient int actions;\n \n+  /** The set of actions permitted. */\n+  // Package visible for use by PropertyPermissionCollection.\n+  transient int actions;\n+\n+  /**\n+   * The String forms of the actions permitted.\n+   */\n   private static final String actionStrings[] =\n   {\n     \"\", \"read\", \"write\", \"read,write\"\n   };\n \n   /**\n-   * Constructs a PropertyPermission witha he specified property.  Possible\n-   * actions are read and write.\n-   * @param name the name of the property.\n-   * @param actions the action string.\n-   * @exception IllegalArgumentException if name string contains an\n-   * illegal wildcard or actions string contains an illegal action\n+   * Constructs a PropertyPermission with the specified property.  Possible\n+   * actions are read and write, comma-separated and case-insensitive.\n+   *\n+   * @param name the name of the property\n+   * @param actions the action string\n+   * @throws NullPointerException if name is null\n+   * @throws IllegalArgumentException if name string contains an\n+   *         illegal wildcard or actions string contains an illegal action\n+   *         (this includes a null actions string)\n    */\n   public PropertyPermission(String name, String actions)\n   {\n     super(name);\n+    if (actions == null)\n+      throw new IllegalArgumentException();\n     setActions(actions.toLowerCase());\n   }\n \n   /**\n    * Parse the action string and convert actions from external to internal\n    * form.  This will set the internal actions field.\n-   * @param actions the action string.\n-   * @exception IllegalArgumentException if actions string contains an\n-   * illegal action */\n-  private void setActions(String actions)\n+   *\n+   * @param str the action string\n+   * @throws IllegalArgumentException if actions string contains an\n+   *         illegal action\n+   */\n+  private void setActions(String str)\n   {\n-    this.actions = 0;\n-    StringTokenizer actionTokenizer = new StringTokenizer(actions, \",\");\n-    while (actionTokenizer.hasMoreElements())\n-      {\n-\tString anAction = actionTokenizer.nextToken();\n-\tif (\"read\".equals(anAction))\n-\t  this.actions |= READ;\n-\telse if (\"write\".equals(anAction))\n-\t  this.actions |= WRITE;\n-\telse\n-\t  throw new IllegalArgumentException(\"illegal action \" + anAction);\n-      }\n+    if (\"read\".equals(str))\n+      actions = READ;\n+    else if (\"write\".equals(str))\n+      actions = WRITE;\n+    else if (\"read,write\".equals(str) || \"write,read\".equals(str))\n+      actions = READ | WRITE;\n+    else\n+      throw new IllegalArgumentException(\"illegal action \" + str);\n+  }\n+\n+  /**\n+   * Reads an object from the stream. This converts the external to the\n+   * internal representation.\n+   *\n+   * @param s the stream to read from\n+   * @throws IOException if the stream fails\n+   * @throws ClassNotFoundException if reserialization fails\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    ObjectInputStream.GetField fields = s.readFields();\n+    setActions((String) fields.get(\"actions\", null));\n+  }\n+\n+  /**\n+   * Writes an object to the stream. This converts the internal to the\n+   * external representation.\n+   *\n+   * @param s the stram to write to\n+   * @throws IOException if the stream fails\n+   */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n+  {\n+    ObjectOutputStream.PutField fields = s.putFields();\n+    fields.put(\"actions\", getActions());\n+    s.writeFields();\n   }\n \n   /**\n    * Check if this permission implies p.  This returns true iff all of\n    * the following conditions are true:\n    * <ul>\n    * <li> p is a PropertyPermission </li>\n-   * <li> this.getName() implies p.getName(),  \n+   * <li> this.getName() implies p.getName(),\n    *  e.g. <code>java.*</code> implies <code>java.home</code> </li>\n    * <li> this.getActions is a subset of p.getActions </li>\n    * </ul>\n+   *\n+   * @param p the permission to check\n+   * @return true if this permission implies p\n    */\n   public boolean implies(Permission p)\n   {\n-    if (!(p instanceof PropertyPermission))\n-      return false;\n-\n-    // We have to check the actions.\n-    PropertyPermission pp = (PropertyPermission) p;\n-    if ((pp.actions & ~actions) != 0)\n-      return false;\n-\n-    // BasicPermission checks for name.\n-    if (!super.implies(p))\n-      return false;\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Returns the action string.  Note that this may differ from the string\n-   * given at the constructor:  The actions are converted to lowercase and\n-   * may be reordered.\n-   */\n-  public String getActions()\n-  {\n-    return actionStrings[actions];\n+    // BasicPermission checks for name and type.\n+    if (super.implies(p))\n+      {\n+        // We have to check the actions.\n+        PropertyPermission pp = (PropertyPermission) p;\n+        return (pp.actions & ~actions) == 0;\n+      }\n+    return false;\n   }\n \n   /**\n    * Check to see whether this object is the same as another\n-   * PropertyPermission object.\n+   * PropertyPermission object; this is true if it has the same name and\n+   * actions.\n    *\n-   * @param obj The other object\n+   * @param obj the other object\n+   * @return true if the two are equivalent\n    */\n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n-    if (! (obj instanceof PropertyPermission))\n-      return false;\n-    PropertyPermission p = (PropertyPermission) obj;\n-    return actions == p.actions && super.equals (p);\n+    return super.equals(obj) && actions == ((PropertyPermission) obj).actions;\n   }\n \n   /**\n-   * Reads an object from the stream. This converts the external to the\n-   * internal representation.\n+   * Returns the hash code for this permission.  It is equivalent to\n+   * <code>getName().hashCode()</code>.\n+   *\n+   * @return the hash code\n    */\n-  private void readObject(ObjectInputStream s)\n-    throws IOException, ClassNotFoundException\n+  public int hashCode()\n   {\n-    ObjectInputStream.GetField fields = s.readFields();\n-    setActions((String) fields.get(\"actions\", null));\n+    return super.hashCode();\n   }\n \n   /**\n-   * Writes an object to the stream. This converts the internal to the\n-   * external representation.\n+   * Returns the action string.  Note that this may differ from the string\n+   * given at the constructor:  The actions are converted to lowercase and\n+   * may be reordered.\n+   *\n+   * @return one of \"read\", \"write\", or \"read,write\"\n    */\n-  private void writeObject(ObjectOutputStream s) throws IOException\n+  public String getActions()\n   {\n-    ObjectOutputStream.PutField fields = s.putFields();\n-    fields.put(\"actions\", getActions());\n-    s.writeFields();\n+    return actionStrings[actions];\n   }\n \n   /**\n    * Returns a permission collection suitable to take\n    * PropertyPermission objects.\n-   * @return a new empty PermissionCollection.  \n+   *\n+   * @return a new empty PermissionCollection\n    */\n   public PermissionCollection newPermissionCollection()\n   {\n-    return new PermissionCollection()\n-    {\n-      Hashtable permissions = new Hashtable();\n-      int allActions = 0;\n-\n-      public void add(Permission permission)\n-      {\n-\tif (isReadOnly())\n-\t  throw new IllegalStateException(\"readonly\");\n-\n-\t// also check that permission is of correct type.\n-\tPropertyPermission pp = (PropertyPermission) permission;\n-\tString name = pp.getName();\n-\tif (name.equals(\"*\"))\n-\t  allActions |= pp.actions;\n-\tpermissions.put(name, pp);\n-      }\n-\n-      public boolean implies(Permission permission)\n-      {\n-\tif (!(permission instanceof PropertyPermission))\n-\t  return false;\n-\n-\tPropertyPermission toImply = (PropertyPermission) permission;\n-\tif ((toImply.actions & ~allActions) == 0)\n-\t  return true;\n-\n-\tString name = toImply.getName();\n-\tif (name.equals(\"*\"))\n-\t  return false;\n-\n-\tint prefixLength = name.length();\n-\tif (name.endsWith(\"*\"))\n-\t  prefixLength -= 2;\n-\n-\twhile (true)\n-\t  {\n-\t    PropertyPermission forName =\n-\t      (PropertyPermission) permissions.get(name);\n-\t    if (forName != null && (toImply.actions & ~forName.actions) == 0)\n-\t      return true;\n-\n-\t    prefixLength = name.lastIndexOf('.', prefixLength);\n-\t    if (prefixLength < 0)\n-\t      return false;\n-\t    name = name.substring(0, prefixLength + 1) + '*';\n-\t  }\n-      }\n-\n-      public Enumeration elements()\n-      {\n-\treturn permissions.elements();\n-      }\n-    };\n+    return new PropertyPermissionCollection();\n   }\n }"}, {"sha": "8f9c71d3e590c8265d63feb42e01f8c7fed9166d", "filename": "libjava/java/util/PropertyPermissionCollection.java", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyPermissionCollection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyPermissionCollection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FPropertyPermissionCollection.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -0,0 +1,164 @@\n+/* PropertyPermissionCollection.java -- a collection of PropertyPermissions\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.util;\n+\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+\n+/**\n+ * This class provides the implementation for\n+ * <code>PropertyPermission.newPermissionCollection()</code>. It only accepts\n+ * PropertyPermissions, and correctly implements <code>implies</code>. It\n+ * is synchronized, as specified in the superclass.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @status an undocumented class, but this matches Sun's serialization\n+ */\n+class PropertyPermissionCollection extends PermissionCollection\n+{\n+  /**\n+   * Compatible with JDK 1.4.\n+   */\n+  private static final long serialVersionUID = 7015263904581634791L;\n+\n+  /**\n+   * The permissions.\n+   *\n+   * @serial the table of permissions in the collection\n+   */\n+  private final Hashtable permissions = new Hashtable();\n+\n+  /**\n+   * A flag to detect if \"*\" is in the collection.\n+   *\n+   * @serial true if \"*\" is in the collection \n+   */\n+  private boolean all_allowed;\n+\n+  /**\n+   * Adds a PropertyPermission to this collection.\n+   *\n+   * @param permission the permission to add\n+   * @throws IllegalArgumentException if permission is not a PropertyPermission\n+   * @throws SecurityException if collection is read-only\n+   */\n+  public void add(Permission permission)\n+  {\n+    if (isReadOnly())\n+      throw new SecurityException(\"readonly\");\n+    if (! (permission instanceof PropertyPermission))\n+      throw new IllegalArgumentException();\n+    PropertyPermission pp = (PropertyPermission) permission;\n+    String name = pp.getName();\n+    if (name.equals(\"*\"))\n+        all_allowed = true;\n+    PropertyPermission old = (PropertyPermission) permissions.get(name);\n+    if (old != null)\n+      {\n+        if ((pp.actions | old.actions) == old.actions)\n+          pp = old; // Old implies pp.\n+        else if ((pp.actions | old.actions) != pp.actions)\n+          // Here pp doesn't imply old; the only case left is both actions.\n+          pp = new PropertyPermission(name, \"read,write\");\n+      }\n+    permissions.put(name, pp);\n+  }\n+\n+  /**\n+   * Returns true if this collection implies the given permission. This even\n+   * returns true for this case:\n+   * <p>\n+<pre>collection.add(new PropertyPermission(\"a.*\", \"read\"));\n+collection.add(new PropertyPermission(\"a.b.*\", \"write\"));\n+collection.implies(new PropertyPermission(\"a.b.c\", \"read,write\"));</pre>\n+   *\n+   * @param permission the permission to check\n+   * @return true if it is implied by this\n+   */\n+  public boolean implies(Permission permission)\n+  {\n+    if (! (permission instanceof PropertyPermission))\n+      return false;\n+    PropertyPermission toImply = (PropertyPermission) permission;\n+    int actions = toImply.actions;\n+\n+    if (all_allowed)\n+      {\n+        int all_actions = ((PropertyPermission) permissions.get(\"*\")).actions;\n+        actions &= ~all_actions;\n+        if (actions == 0)\n+          return true;\n+      }\n+\n+    String name = toImply.getName();\n+    if (name.equals(\"*\"))\n+      return false;\n+\n+    int prefixLength = name.length();\n+    if (name.endsWith(\"*\"))\n+      prefixLength -= 2;\n+\n+    while (true)\n+      {\n+        PropertyPermission forName =\n+          (PropertyPermission) permissions.get(name);\n+        if (forName != null)\n+          {\n+            actions &= ~forName.actions;\n+            if (actions == 0)\n+              return true;\n+          }\n+\n+        prefixLength = name.lastIndexOf('.', prefixLength);\n+        if (prefixLength < 0)\n+          return false;\n+        name = name.substring(0, prefixLength + 1) + '*';\n+      }\n+  }\n+\n+  /**\n+   * Enumerate over the collection.\n+   *\n+   * @return an enumeration of the collection contents\n+   */\n+  public Enumeration elements()\n+  {\n+    return permissions.elements();\n+  }\n+}"}, {"sha": "a3173cf9eb7e46f79f4ac981ef910454250d114e", "filename": "libjava/java/util/PropertyResourceBundle.java", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FPropertyResourceBundle.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.PropertyResourceBundle\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* PropertyResourceBundle -- a resource bundle built from a Property file\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,11 +38,13 @@\n \n package java.util;\n \n+import java.io.IOException;\n+import java.io.InputStream;\n import gnu.java.util.DoubleEnumeration;\n \n /**\n  * This class is a concrete <code>ResourceBundle</code> that gets it\n- * resources from a property file.  This implies that the resources are\n+ * resources from a property file. This implies that the resources are\n  * strings. For more information about resource bundles see the class\n  * <code>ResourceBundle</code>.\n  *\n@@ -52,75 +54,68 @@\n  * file.\n  *\n  * If there is also a class for this resource and the same locale, the\n- * class does win.\n- *\n- * The properties file should have the name of the resource bundle,\n- * appended with the locale (e.g. <code>_de</code) and the extension\n- * <code>.properties</code>.  The file should have the same format\n+ * class will be chosen. The properties file should have the name of the\n+ * resource bundle, appended with the locale (e.g. <code>_de</code) and the\n+ * extension <code>.properties</code>. The file should have the same format\n  * as for <code>Properties.load()</code>\n  *\n- * XXX- move this to properties.\n- * The file should have the following\n- * format: An empty line or a line starting with <code>#</code> is\n- * ignored.  An backslash (<code>\\</code>) at the end of the line\n- * makes the line continueing on the next line.  Otherwise, each line\n- * describes a key/value pair.  The chars up to the first whitespace,\n- * = or : are the key.  The key is followed by one or more\n- * whitespaces, <code>=</code> or <code>:</code>.  The rest of the\n- * line is the resource belonging to the key.  You can give unicode\n- * characters with the <code>\\\\uxxxx</code> notation, where\n- * <code>xxxx</code> is the hex encoding of the 16 bit unicode char\n- * number.\n- *\n  * An example of a properties file for the german language is given\n- * here.  This extends the example given in ListResourceBundle.\n+ * here. This extends the example given in ListResourceBundle.\n  * Create a file MyResource_de.properties with the following contents\n- * and put it in the CLASSPATH.  (The char <code>\\u00e4<char> is the \n+ * and put it in the CLASSPATH. (The char <code>\\u00e4<char> is the\n  * german &auml;)\n- * \n- * <pre>\n- * s1=3\n- * s2=MeineDisk\n- * s3=3. M\\u00e4rz 96\n- * s4=Die Diskette ''{1}'' enth\\u00e4lt {0} in {2}.\n- * s5=0\n- * s6=keine Dateien\n- * s7=1\n- * s8=eine Datei\n- * s9=2\n- * s10={0,number} Dateien\n- * s11=Die Formatierung warf eine Exception: {0}\n- * s12=FEHLER\n- * s13=Ergebnis\n- * s14=Dialog\n- * s15=Auswahlkriterium\n- * s16=1,3\n- * </pre>\n  *\n+ *\n+<pre>\n+s1=3\n+s2=MeineDisk\n+s3=3. M\\u00e4rz 96\n+s4=Die Diskette ''{1}'' enth\\u00e4lt {0} in {2}.\n+s5=0\n+s6=keine Dateien\n+s7=1\n+s8=eine Datei\n+s9=2\n+s10={0,number} Dateien\n+s11=Die Formatierung warf eine Exception: {0}\n+s12=FEHLER\n+s13=Ergebnis\n+s14=Dialog\n+s15=Auswahlkriterium\n+s16=1,3\n+</pre>\n+ *\n+ * @author Jochen Hoenicke\n  * @see ResourceBundle\n  * @see ListResourceBundle\n  * @see Properties#load()\n- * @author Jochen Hoenicke */\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n public class PropertyResourceBundle extends ResourceBundle\n {\n-  Properties properties;\n+  /** The properties file this bundle is based on. */\n+  private Properties properties;\n \n   /**\n    * Creates a new property resource bundle.\n-   * @param stream An input stream, where the resources are read from.\n+   *\n+   * @param stream an input stream, where the resources are read from\n+   * @throws NullPointerException if stream is null\n+   * @throws IOException if reading the stream fails\n    */\n-  public PropertyResourceBundle(java.io.InputStream stream)\n-    throws java.io.IOException\n+  public PropertyResourceBundle(InputStream stream) throws IOException\n   {\n     properties = new Properties();\n     properties.load(stream);\n   }\n \n   /**\n-   * Called by <code>getObject</code> when a resource is needed.  This\n+   * Called by <code>getObject</code> when a resource is needed. This\n    * returns the resource given by the key.\n-   * @param key The key of the resource.\n-   * @return The resource for the key or null if it doesn't exists.\n+   *\n+   * @param key the key of the resource\n+   * @return the resource for the key, or null if it doesn't exist\n    */\n   public Object handleGetObject(String key)\n   {\n@@ -129,16 +124,30 @@ public Object handleGetObject(String key)\n \n   /**\n    * This method should return all keys for which a resource exists.\n-   * @return An enumeration of the keys.\n+   *\n+   * @return an enumeration of the keys\n    */\n   public Enumeration getKeys()\n   {\n-    // We must also return the keys of our parent.\n-    if (parent != null)\n+    if (parent == null)\n+      return properties.propertyNames();\n+    // We make a new Set that holds all the keys, then return an enumeration\n+    // for that. This prevents modifications from ruining the enumeration,\n+    // as well as ignoring duplicates.\n+    Set s = new HashSet();\n+    Enumeration e = properties.propertyNames();\n+    while (e.hasMoreElements())\n+      s.add(e.nextElement());\n+    ResourceBundle bundle = parent;\n+    // Eliminate tail recursion.\n+    do\n       {\n-\treturn new DoubleEnumeration(properties.propertyNames(),\n-\t\t\t\t     parent.getKeys());\n+        e = bundle.getKeys();\n+        while (e.hasMoreElements())\n+          s.add(e.nextElement());\n+        bundle = bundle.parent;\n       }\n-    return properties.propertyNames();\n+    while (bundle != null);\n+    return Collections.enumeration(s);\n   }\n-}\n+} // class PropertyResourceBundle"}, {"sha": "500a02d3765ed0b61aa39fe6727dba74ee9d1319", "filename": "libjava/java/util/Random.java", "status": "modified", "additions": 199, "deletions": 160, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FRandom.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FRandom.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FRandom.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.Random\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+/* Random.java -- a pseudo-random number generator\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,13 +38,16 @@\n \n package java.util;\n \n+import java.io.Serializable;\n+\n /**\n  * This class generates pseudorandom numbers.  It uses the same\n  * algorithm as the original JDK-class, so that your programs behave\n  * exactly the same way, if started with the same seed.\n  *\n  * The algorithm is described in <em>The Art of Computer Programming,\n- * Volume 2</em> by Donald Knuth in Section 3.2.1.\n+ * Volume 2</em> by Donald Knuth in Section 3.2.1.  It is a 48-bit seed,\n+ * linear congruential formula.\n  *\n  * If two instances of this class are created with the same seed and\n  * the same calls to these classes are made, they behave exactly the\n@@ -57,7 +60,7 @@\n  * <code>setSeed(long)</code> method.  In that case the above\n  * paragraph doesn't apply to you.\n  *\n- * This class shouldn't be used for security sensitive purposes (like \n+ * This class shouldn't be used for security sensitive purposes (like\n  * generating passwords or encryption keys.  See <code>SecureRandom</code>\n  * in package <code>java.security</code> for this purpose.\n  *\n@@ -66,51 +69,65 @@\n  *\n  * @see java.security.SecureRandom\n  * @see Math#random()\n- * @author Jochen Hoenicke */\n-public class Random implements java.io.Serializable\n+ * @author Jochen Hoenicke\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ * @status updated to 1.4\n+ */\n+public class Random implements Serializable\n {\n   /**\n    * True if the next nextGaussian is available.  This is used by\n    * nextGaussian, which generates two gaussian numbers by one call,\n-   * and returns the second on the second call.  \n-   * @see #nextGaussian.  */\n+   * and returns the second on the second call.\n+   *\n+   * @serial whether nextNextGaussian is available\n+   * @see #nextGaussian()\n+   * @see #nextNextGaussian\n+   */\n   private boolean haveNextNextGaussian;\n+\n   /**\n-   * The next nextGaussian if available.  This is used by nextGaussian,\n+   * The next nextGaussian, when available.  This is used by nextGaussian,\n    * which generates two gaussian numbers by one call, and returns the\n    * second on the second call.\n-   * @see #nextGaussian.\n+   *\n+   * @serial the second gaussian of a pair\n+   * @see #nextGaussian()\n+   * @see #haveNextNextGaussian\n    */\n   private double nextNextGaussian;\n+\n   /**\n    * The seed.  This is the number set by setSeed and which is used\n    * in next.\n-   * @see #next\n+   *\n+   * @serial the internal state of this generator\n+   * @see #next()\n    */\n   private long seed;\n \n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n   private static final long serialVersionUID = 3905348978240129619L;\n \n   /**\n    * Creates a new pseudorandom number generator.  The seed is initialized\n-   * to the current time as follows.\n-   * <pre>\n-   * setSeed(System.currentTimeMillis());\n-   * </pre>\n+   * to the current time, as if by\n+   * <code>setSeed(System.currentTimeMillis());</code>.\n+   *\n    * @see System#currentTimeMillis()\n    */\n   public Random()\n   {\n-    setSeed(System.currentTimeMillis());\n+    this(System.currentTimeMillis());\n   }\n \n   /**\n    * Creates a new pseudorandom number generator, starting with the\n-   * specified seed. This does:\n-   * <pre>\n-   * setSeed(seed);\n-   * </pre>\n-   * @param seed the initial seed.\n+   * specified seed, using <code>setSeed(seed);</code>.\n+   *\n+   * @param seed the initial seed\n    */\n   public Random(long seed)\n   {\n@@ -122,12 +139,14 @@ public Random(long seed)\n    * above, two instances of the same random class, starting with the\n    * same seed, should produce the same results, if the same methods\n    * are called.  The implementation for java.util.Random is:\n-   * <pre>\n-   * public synchronized void setSeed(long seed) {\n-   *     this.seed = (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1);\n-   *     haveNextNextGaussian = false;\n-   * }\n-   * </pre>\n+   *\n+<pre>public synchronized void setSeed(long seed)\n+{\n+  this.seed = (seed ^ 0x5DEECE66DL) & ((1L &lt;&lt; 48) - 1);\n+  haveNextNextGaussian = false;\n+}</pre>\n+   *\n+   * @param seed the new seed\n    */\n   public synchronized void setSeed(long seed)\n   {\n@@ -140,20 +159,18 @@ public synchronized void setSeed(long seed)\n    * an int value whose <code>bits</code> low order bits are\n    * independent chosen random bits (0 and 1 are equally likely).\n    * The implementation for java.util.Random is:\n-   * <pre>\n-   * protected synchronized int next(int bits) {\n-   *     seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\n-   *     return (int) (seed >>> (48 - bits));\n-   * }\n-   * </pre>\n-   * @param bits the number of random bits to generate.  Must be in range\n-   * 1..32.\n-   * @return the next pseudorandom value.\n-   * @since JDK1.1\n+   *\n+<pre>protected synchronized int next(int bits)\n+{\n+  seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L &lt;&lt; 48) - 1);\n+  return (int) (seed &gt;&gt;&gt; (48 - bits));\n+}</pre>\n+   *\n+   * @param bits the number of random bits to generate, in the range 1..32\n+   * @return the next pseudorandom value\n+   * @since 1.1\n    */\n   protected synchronized int next(int bits)\n-    /*{ require { 1 <= bits && bits <=32 :: \n-       \"bits \"+bits+\" not in range [1..32]\" } } */\n   {\n     seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\n     return (int) (seed >>> (48 - bits));\n@@ -163,42 +180,45 @@ protected synchronized int next(int bits)\n    * Fills an array of bytes with random numbers.  All possible values\n    * are (approximately) equally likely.\n    * The JDK documentation gives no implementation, but it seems to be:\n-   * <pre>\n-   * public void nextBytes(byte[] bytes) {\n-   *     for (int i=0; i< bytes.length; i+=4) {\n-   *         int random = next(32);\n-   *         for (int j=0; i+j< bytes.length && j<4; j++)\n-   *             bytes[i+j] = (byte) (random & 0xff)\n-   *             random >>= 8;\n-   *         }\n-   *     }\n-   * }\n-   * </pre>\n-   * @param bytes The byte array that should be filled.\n-   * @since JDK1.1\n+   *\n+<pre>public void nextBytes(byte[] bytes)\n+{\n+  for (int i = 0; i &lt; bytes.length; i += 4)\n+  {\n+    int random = next(32);\n+    for (int j = 0; i + j &lt; bytes.length && j &lt; 4; j++)\n+    {\n+      bytes[i+j] = (byte) (random & 0xff)\n+      random &gt;&gt;= 8;\n+    }\n+  }\n+}</pre>\n+   *\n+   * @param bytes the byte array that should be filled\n+   * @throws NullPointerException if bytes is null\n+   * @since 1.1\n    */\n   public void nextBytes(byte[] bytes)\n-    /*{ require { bytes != null :: \"bytes is null\"; } } */\n   {\n     int random;\n-    /* Do a little bit unrolling of the above algorithm. */\n+    // Do a little bit unrolling of the above algorithm.\n     int max = bytes.length & ~0x3;\n     for (int i = 0; i < max; i += 4)\n       {\n-\trandom = next(32);\n-\tbytes[i] = (byte) random;\n-\tbytes[i + 1] = (byte) (random >> 8);\n-\tbytes[i + 2] = (byte) (random >> 16);\n-\tbytes[i + 3] = (byte) (random >> 24);\n+        random = next(32);\n+        bytes[i] = (byte) random;\n+        bytes[i + 1] = (byte) (random >> 8);\n+        bytes[i + 2] = (byte) (random >> 16);\n+        bytes[i + 3] = (byte) (random >> 24);\n       }\n     if (max < bytes.length)\n       {\n-\trandom = next(32);\n-\tfor (int j = max; j < bytes.length; j++)\n-\t  {\n-\t    bytes[j] = (byte) random;\n-\t    random >>= 8;\n-\t  }\n+        random = next(32);\n+        for (int j = max; j < bytes.length; j++)\n+          {\n+            bytes[j] = (byte) random;\n+            random >>= 8;\n+          }\n       }\n   }\n \n@@ -207,13 +227,14 @@ public void nextBytes(byte[] bytes)\n    * an int value whose 32 bits are independent chosen random bits\n    * (0 and 1 are equally likely).  The implementation for\n    * java.util.Random is:\n-   * <pre>\n-   * public int nextInt() {\n-   *     return next(32);\n-   * }\n-   * </pre>\n+   * \n+<pre>public int nextInt()\n+{\n+  return next(32);\n+}</pre>\n    *\n-   * @return the next pseudorandom value.  */\n+   * @return the next pseudorandom value\n+   */\n   public int nextInt()\n   {\n     return next(32);\n@@ -225,51 +246,58 @@ public int nextInt()\n    * each value has the same likelihodd (1/<code>n</code>).\n    * (0 and 1 are equally likely).  The implementation for\n    * java.util.Random is:\n-   * <pre>\n-   * public int nextInt(int n) {\n-   *     if (n<=0)\n-   *         throw new IllegalArgumentException(\"n must be positive\");\n-   *     if ((n & -n) == n)  // i.e., n is a power of 2\n-   *         return (int)((n * (long)next(31)) >> 31);\n-   *     int bits, val;\n-   *     do {\n-   *         bits = next(32);\n-   *         val = bits % n;\n-   *     } while(bits - val + (n-1) < 0);\n-   *     return val;\n-   * }\n-   * </pre>\n-   * This algorithm would return every value with exactly the same \n+   * \n+<pre>\n+public int nextInt(int n)\n+{\n+  if (n &lt;= 0)\n+    throw new IllegalArgumentException(\"n must be positive\");\n+\n+  if ((n & -n) == n)  // i.e., n is a power of 2\n+    return (int)((n * (long) next(31)) &gt;&gt; 31);\n+\n+  int bits, val;\n+  do\n+  {\n+    bits = next(32);\n+    val = bits % n;\n+  }\n+  while(bits - val + (n-1) &lt; 0);\n+\n+  return val;\n+}</pre>\n+   *   \n+   * <p>This algorithm would return every value with exactly the same\n    * probability, if the next()-method would be a perfect random number\n    * generator.\n-   * \n+   *\n    * The loop at the bottom only accepts a value, if the random\n    * number was between 0 and the highest number less then 1<<31,\n    * which is divisible by n.  The probability for this is high for small\n    * n, and the worst case is 1/2 (for n=(1<<30)+1).\n    *\n-   * The special treatment for n = power of 2, selects the high bits of \n+   * The special treatment for n = power of 2, selects the high bits of\n    * the random number (the loop at the bottom would select the low order\n    * bits).  This is done, because the low order bits of linear congruential\n-   * number generators (like the one used in this class) are known to be \n+   * number generators (like the one used in this class) are known to be\n    * ``less random'' than the high order bits.\n    *\n-   * @param n the upper bound.\n-   * @exception IllegalArgumentException if the given upper bound is negative\n-   * @return the next pseudorandom value.  \n+   * @param n the upper bound\n+   * @throws IllegalArgumentException if the given upper bound is negative\n+   * @return the next pseudorandom value\n+   * @since 1.2\n    */\n   public int nextInt(int n)\n-    /*{ require { n > 0 :: \"n must be positive\"; } } */\n   {\n     if (n <= 0)\n       throw new IllegalArgumentException(\"n must be positive\");\n-    if ((n & -n) == n)\t\t// i.e., n is a power of 2\n+    if ((n & -n) == n) // i.e., n is a power of 2\n       return (int) ((n * (long) next(31)) >> 31);\n     int bits, val;\n     do\n       {\n-\tbits = next(32);\n-\tval = bits % n;\n+        bits = next(32);\n+        val = bits % n;\n       }\n     while (bits - val + (n - 1) < 0);\n     return val;\n@@ -279,12 +307,13 @@ public int nextInt(int n)\n    * Generates the next pseudorandom long number.  All bits of this\n    * long are independently chosen and 0 and 1 have equal likelihood.\n    * The implementation for java.util.Random is:\n-   * <pre>\n-   * public long nextLong() {\n-   *     return ((long)next(32) << 32) + next(32);\n-   * }\n-   * </pre>\n-   * @return the next pseudorandom value.  \n+   *\n+<pre>public long nextLong()\n+{\n+  return ((long) next(32) &lt;&lt; 32) + next(32);\n+}</pre>\n+   *\n+   * @return the next pseudorandom value\n    */\n   public long nextLong()\n   {\n@@ -294,12 +323,14 @@ public long nextLong()\n   /**\n    * Generates the next pseudorandom boolean.  True and false have\n    * the same probability.  The implementation is:\n-   * <pre>\n-   * public boolean nextBoolean() {\n-   *     return next(1) != 0;\n-   * }\n-   * </pre>\n-   * @return the next pseudorandom boolean.\n+   * \n+<pre>public boolean nextBoolean()\n+{\n+  return next(1) != 0;\n+}</pre>\n+   *\n+   * @return the next pseudorandom boolean\n+   * @since 1.2\n    */\n   public boolean nextBoolean()\n   {\n@@ -308,83 +339,91 @@ public boolean nextBoolean()\n \n   /**\n    * Generates the next pseudorandom float uniformly distributed\n-   * between 0.0f (inclusive) and 1.0 (exclusive).  The\n+   * between 0.0f (inclusive) and 1.0f (exclusive).  The\n    * implementation is as follows.\n-   * <pre>\n-   * public float nextFloat() {\n-   *     return next(24) / ((float)(1 << 24));\n-   * }\n-   * </pre>\n-   * @return the next pseudorandom float.  */\n+   * \n+<pre>public float nextFloat()\n+{\n+  return next(24) / ((float)(1 &lt;&lt; 24));\n+}</pre>\n+   *\n+   * @return the next pseudorandom float\n+   */\n   public float nextFloat()\n   {\n-    return next(24) / ((float) (1 << 24));\n+    return next(24) / (float) (1 << 24);\n   }\n \n   /**\n    * Generates the next pseudorandom double uniformly distributed\n-   * between 0.0f (inclusive) and 1.0 (exclusive).  The\n+   * between 0.0 (inclusive) and 1.0 (exclusive).  The\n    * implementation is as follows.\n-   * <pre>\n-   * public double nextDouble() {\n-   *     return (((long)next(26) << 27) + next(27)) / (double)(1 << 53);\n-   * }\n-   * </pre>\n-   * @return the next pseudorandom double.  */\n+   *\n+<pre>public double nextDouble()\n+{\n+  return (((long) next(26) &lt;&lt; 27) + next(27)) / (double)(1L &lt;&lt; 53);\n+}</pre>\n+   *\n+   * @return the next pseudorandom double\n+   */\n   public double nextDouble()\n   {\n     return (((long) next(26) << 27) + next(27)) / (double) (1L << 53);\n   }\n \n   /**\n-   * Generates the next pseudorandom, Gaussian (normally) distributed \n+   * Generates the next pseudorandom, Gaussian (normally) distributed\n    * double value, with mean 0.0 and standard deviation 1.0.\n    * The algorithm is as follows.\n-   * <pre>\n-   * public synchronized double nextGaussian() {\n-   *     if (haveNextNextGaussian) {\n-   *         haveNextNextGaussian = false;\n-   *         return nextNextGaussian;\n-   *     } else {\n-   *         double v1, v2, s;\n-   *         do {\n-   *             v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n-   *             v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n-   *             s = v1 * v1 + v2 * v2;\n-   *         } while (s >= 1);\n-   *         double norm = Math.sqrt(-2 * Math.log(s)/s);\n-   *         nextNextGaussian = v2 * norm;\n-   *         haveNextNextGaussian = true;\n-   *         return v1 * norm;\n-   *     }\n-   * }\n-   * </pre>\n-   * This is described in section 3.4.1 of <em>The Art of Computer\n+   * \n+<pre>public synchronized double nextGaussian()\n+{\n+  if (haveNextNextGaussian)\n+  {\n+    haveNextNextGaussian = false;\n+    return nextNextGaussian;\n+  }\n+  else\n+  {\n+    double v1, v2, s;\n+    do\n+    {\n+      v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n+      v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0\n+      s = v1 * v1 + v2 * v2;\n+    }\n+    while (s >= 1);\n+\n+    double norm = Math.sqrt(-2 * Math.log(s) / s);\n+    nextNextGaussian = v2 * norm;\n+    haveNextNextGaussian = true;\n+    return v1 * norm;\n+  }\n+}</pre>\n+   *\n+   * <p>This is described in section 3.4.1 of <em>The Art of Computer\n    * Programming, Volume 2</em> by Donald Knuth.\n    *\n-   * @return the next pseudorandom Gaussian distributed double.  \n+   * @return the next pseudorandom Gaussian distributed double\n    */\n   public synchronized double nextGaussian()\n   {\n     if (haveNextNextGaussian)\n       {\n-\thaveNextNextGaussian = false;\n-\treturn nextNextGaussian;\n+        haveNextNextGaussian = false;\n+        return nextNextGaussian;\n       }\n-    else\n+    double v1, v2, s;\n+    do\n       {\n-\tdouble v1, v2, s;\n-\tdo\n-\t  {\n-\t    v1 = 2 * nextDouble() - 1;\t// between -1.0 and 1.0\n-\t    v2 = 2 * nextDouble() - 1;\t// between -1.0 and 1.0\n-\t    s = v1 * v1 + v2 * v2;\n-\t  }\n-\twhile (s >= 1);\n-\tdouble norm = Math.sqrt(-2 * Math.log(s) / s);\n-\tnextNextGaussian = v2 * norm;\n-\thaveNextNextGaussian = true;\n-\treturn v1 * norm;\n+        v1 = 2 * nextDouble() - 1; // Between -1.0 and 1.0.\n+        v2 = 2 * nextDouble() - 1; // Between -1.0 and 1.0.\n+        s = v1 * v1 + v2 * v2;\n       }\n+    while (s >= 1);\n+    double norm = Math.sqrt(-2 * Math.log(s) / s);\n+    nextNextGaussian = v2 * norm;\n+    haveNextNextGaussian = true;\n+    return v1 * norm;\n   }\n }"}, {"sha": "c2e2560fc7803d0d1c144c2b7ef2701dfff5193f", "filename": "libjava/java/util/SimpleTimeZone.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSimpleTimeZone.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -52,7 +52,8 @@\n  *\n  * @see Calendar\n  * @see GregorianCalender \n- * @author Jochen Hoenicke */\n+ * @author Jochen Hoenicke\n+ */\n public class SimpleTimeZone extends TimeZone\n {\n   /**\n@@ -436,9 +437,9 @@ public void setEndRule(int month, int day, int dayOfWeek, int time)\n    * In the standard JDK the results given by this method may result in\n    * inaccurate results at the end of February or the beginning of March.\n    * To avoid this, you should use Calendar instead:\n-   * <pre>\n-   * offset = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);\n-   * </pre>\n+   * <code>offset = cal.get(Calendar.ZONE_OFFSET)\n+   * + cal.get(Calendar.DST_OFFSET);</code>\n+   *\n    * You could also use in\n    *\n    * This version doesn't suffer this inaccuracy."}, {"sha": "e7fc6fd00d2bd0e84b1a2570d6cf5140d001b9b4", "filename": "libjava/java/util/StringTokenizer.java", "status": "modified", "additions": 93, "deletions": 98, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FStringTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FStringTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FStringTokenizer.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.StringTokenizer\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* StringTokenizer -- breaks a String into tokens\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,75 +39,79 @@\n package java.util;\n \n /**\n- * This class splits a string into tokens.  The caller can set on which \n+ * This class splits a string into tokens.  The caller can set on which\n  * delimiters the string should be split and if the delimiters should be\n- * returned.\n+ * returned. This is much simpler than {@link java.io.StreamTokenizer}.\n  *\n- * You may change the delimiter set on the fly by calling\n+ * <p>You may change the delimiter set on the fly by calling\n  * nextToken(String).  But the semantic is quite difficult; it even\n  * depends on calling <code>hasMoreTokens()</code>.  You should call\n  * <code>hasMoreTokens()</code> before, otherwise the old delimiters\n- * after the last token are returned.\n+ * after the last token are candidates for being returned.\n  *\n- * If you want to get the delimiters, you have to use the three argument\n+ * <p>If you want to get the delimiters, you have to use the three argument\n  * constructor.  The delimiters are returned as token consisting of a\n- * single character.  \n+ * single character.\n  *\n  * @author Jochen Hoenicke\n  * @author Warren Levy <warrenl@cygnus.com>\n+ * @see java.io.StreamTokenizer\n+ * @status updated to 1.4\n  */\n public class StringTokenizer implements Enumeration\n {\n+  // WARNING: StringTokenizer is a CORE class in the bootstrap cycle. See the\n+  // comments in vm/reference/java/lang/Runtime for implications of this fact.\n+\n   /**\n    * The position in the str, where we currently are.\n    */\n   private int pos;\n+\n   /**\n    * The string that should be split into tokens.\n    */\n-  private String str;\n+  private final String str;\n+\n+  /**\n+   * The length of the string.\n+   */\n+  private final int len;\n+\n   /**\n    * The string containing the delimiter characters.\n    */\n   private String delim;\n+\n   /**\n    * Tells, if we should return the delimiters.\n    */\n-  private boolean retDelims;\n-\n-  /*{ \n-     invariant {\n-     pos >= 0 :: \"position is negative\";\n-     pos <= str.length() :: \"position is out of string\";\n-     str != null :: \"String is null\";\n-     delim != null :: \"Delimiters are null\";\n-     }\n-     } */\n+  private final boolean retDelims;\n \n   /**\n    * Creates a new StringTokenizer for the string <code>str</code>,\n-   * that should split on the default delimiter set (space, tap,\n+   * that should split on the default delimiter set (space, tab,\n    * newline, return and formfeed), and which doesn't return the\n    * delimiters.\n-   * @param str The string to split.\n+   *\n+   * @param str The string to split\n+   * @throws NullPointerException if str is null\n    */\n   public StringTokenizer(String str)\n-    /*{ require { str != null :: \"str must not be null\"; } } */\n   {\n     this(str, \" \\t\\n\\r\\f\", false);\n   }\n \n   /**\n-   * Create a new StringTokenizer, that splits the given string on \n+   * Create a new StringTokenizer, that splits the given string on\n    * the given delimiter characters.  It doesn't return the delimiter\n    * characters.\n    *\n-   * @param str The string to split.\n-   * @param delim A string containing all delimiter characters.\n+   * @param str the string to split\n+   * @param delim a string containing all delimiter characters\n+   * @throws NullPointerException if either argument is null\n    */\n   public StringTokenizer(String str, String delim)\n-    /*{ require { str != null :: \"str must not be null\";\n-       delim != null :: \"delim must not be null\"; } } */\n   {\n     this(str, delim, false);\n   }\n@@ -119,91 +123,83 @@ public StringTokenizer(String str, String delim)\n    * characters are returned as tokens of their own.  The delimiter\n    * tokens always consist of a single character.\n    *\n-   * @param str The string to split.\n-   * @param delim A string containing all delimiter characters.\n-   * @param returnDelims Tells, if you want to get the delimiters.\n+   * @param str the string to split\n+   * @param delim a string containing all delimiter characters\n+   * @param returnDelims tells, if you want to get the delimiters\n+   * @throws NullPointerException if str or delim is null\n    */\n   public StringTokenizer(String str, String delim, boolean returnDelims)\n-    /*{ require { str != null :: \"str must not be null\";\n-       delim != null :: \"delim must not be null\"; } } */\n   {\n+    len = str.length();\n     this.str = str;\n-    this.delim = delim;\n+    // The toString() hack causes the NullPointerException.\n+    this.delim = delim.toString();\n     this.retDelims = returnDelims;\n     this.pos = 0;\n   }\n \n   /**\n    * Tells if there are more tokens.\n-   * @return True, if the next call of nextToken() succeeds, false otherwise.\n+   *\n+   * @return true if the next call of nextToken() will succeed\n    */\n   public boolean hasMoreTokens()\n   {\n-    if (!retDelims)\n+    if (! retDelims)\n       {\n-\twhile (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n-\t  {\n-\t    pos++;\n-\t  }\n+        while (pos < len && delim.indexOf(str.charAt(pos)) >= 0)\n+          pos++;\n       }\n-    return pos < str.length();\n+    return pos < len;\n   }\n \n   /**\n    * Returns the nextToken, changing the delimiter set to the given\n    * <code>delim</code>.  The change of the delimiter set is\n    * permanent, ie. the next call of nextToken(), uses the same\n    * delimiter set.\n-   * @param delim a string containing the new delimiter characters.\n-   * @return the next token with respect to the new delimiter characters.\n-   * @exception NoSuchElementException if there are no more tokens.\n+   *\n+   * @param delim a string containing the new delimiter characters\n+   * @return the next token with respect to the new delimiter characters\n+   * @throws NoSuchElementException if there are no more tokens\n+   * @throws NullPointerException if delim is null\n    */\n   public String nextToken(String delim) throws NoSuchElementException\n-    /*{ require { hasMoreTokens() :: \"no more Tokens available\";\n-       ensure { $return != null && $return.length() > 0; } } */\n   {\n     this.delim = delim;\n     return nextToken();\n   }\n \n   /**\n    * Returns the nextToken of the string.\n-   * @param delim a string containing the new delimiter characters.\n-   * @return the next token with respect to the new delimiter characters.\n-   * @exception NoSuchElementException if there are no more tokens.\n+   *\n+   * @return the next token with respect to the current delimiter characters\n+   * @throws NoSuchElementException if there are no more tokens\n    */\n   public String nextToken() throws NoSuchElementException\n-    /*{ require { hasMoreTokens() :: \"no more Tokens available\";\n-       ensure { $return != null && $return.length() > 0; } } */\n   {\n-    if (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n+    if (pos < len && delim.indexOf(str.charAt(pos)) >= 0)\n       {\n-\tif (retDelims)\n-\t  return str.substring(pos, ++pos);\n-\n-\twhile (++pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)\n-\t  {\n-\t    /* empty */\n-\t  }\n+        if (retDelims)\n+          return str.substring(pos, ++pos);\n+        while (++pos < len && delim.indexOf(str.charAt(pos)) >= 0);\n       }\n-    if (pos < str.length())\n+    if (pos < len)\n       {\n-\tint start = pos;\n-\twhile (++pos < str.length() && delim.indexOf(str.charAt(pos)) == -1)\n-\t  {\n-\t    /* empty */\n-\t  }\n-\treturn str.substring(start, pos);\n+        int start = pos;\n+        while (++pos < len && delim.indexOf(str.charAt(pos)) < 0);\n+\n+        return str.substring(start, pos);\n       }\n     throw new NoSuchElementException();\n   }\n \n   /**\n    * This does the same as hasMoreTokens. This is the\n    * <code>Enumeration</code interface method.\n-   * @return True, if the next call of nextElement() succeeds, false\n-   * otherwise.  \n-   * @see #hasMoreTokens\n+   *\n+   * @return true, if the next call of nextElement() will succeed\n+   * @see #hasMoreTokens()\n    */\n   public boolean hasMoreElements()\n   {\n@@ -213,9 +209,10 @@ public boolean hasMoreElements()\n   /**\n    * This does the same as nextTokens. This is the\n    * <code>Enumeration</code interface method.\n-   * @return the next token with respect to the new delimiter characters.\n-   * @exception NoSuchElementException if there are no more tokens.\n-   * @see #nextToken\n+   *\n+   * @return the next token with respect to the current delimiter characters\n+   * @throws NoSuchElementException if there are no more tokens\n+   * @see #nextToken()\n    */\n   public Object nextElement() throws NoSuchElementException\n   {\n@@ -225,49 +222,47 @@ public Object nextElement() throws NoSuchElementException\n   /**\n    * This counts the number of remaining tokens in the string, with\n    * respect to the current delimiter set.\n-   * @return the number of times <code>nextTokens()</code> will\n-   * succeed.  \n-   * @see #nextToken\n+   *\n+   * @return the number of times <code>nextTokens()</code> will succeed\n+   * @see #nextToken()\n    */\n   public int countTokens()\n   {\n     int count = 0;\n     int delimiterCount = 0;\n-    boolean tokenFound = false;\t\t// Set when a non-delimiter is found\n+    boolean tokenFound = false; // Set when a non-delimiter is found\n     int tmpPos = pos;\n \n     // Note for efficiency, we count up the delimiters rather than check\n     // retDelims every time we encounter one.  That way, we can\n     // just do the conditional once at the end of the method\n-    while (tmpPos < str.length())\n+    while (tmpPos < len)\n       {\n-\tif (delim.indexOf(str.charAt(tmpPos++)) > -1)\n-\t  {\n-\t    if (tokenFound)\n-\t      {\n-\t\t// Got to the end of a token\n-\t        count++;\n-\t        tokenFound = false;\n-\t      }\n-\n-\t    delimiterCount++;\t\t// Increment for this delimiter\n-\t  }\n-\telse\n-\t  {\n-\t    tokenFound = true;\n-\n-\t    // Get to the end of the token\n-\t    while (tmpPos < str.length()\n-\t\t   && delim.indexOf(str.charAt(tmpPos)) == -1)\n-\t      ++tmpPos;\n-\t  }\n+        if (delim.indexOf(str.charAt(tmpPos++)) >= 0)\n+          {\n+            if (tokenFound)\n+              {\n+                // Got to the end of a token\n+                count++;\n+                tokenFound = false;\n+              }\n+            delimiterCount++; // Increment for this delimiter\n+          }\n+        else\n+          {\n+            tokenFound = true;\n+            // Get to the end of the token\n+            while (tmpPos < len\n+                   && delim.indexOf(str.charAt(tmpPos)) < 0)\n+              ++tmpPos;\n+          }\n       }\n \n-    // Make sure to count the last token \n+    // Make sure to count the last token\n     if (tokenFound)\n       count++;\n \n     // if counting delmiters add them into the token count\n     return retDelims ? count + delimiterCount : count;\n   }\n-}\n+} // class StringTokenizer"}, {"sha": "1b32b67f62c410824e9d496f9fa51789f5a8b00f", "filename": "libjava/java/util/TimerTask.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FTimerTask.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FTimerTask.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimerTask.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -44,19 +44,19 @@\n  * it should have been scheduled and cancel itself when no longer needed.\n  * <p>\n  * Example:\n- * <code>\n+ * <pre>\n  *  Timer timer = new Timer();\n  *  TimerTask task = new TimerTask() {\n  *      public void run() {\n- *      if (this.scheduledExecutionTime() < System.currentTimeMillis() + 500)\n+ *      if (this.scheduledExecutionTime() &lt; System.currentTimeMillis() + 500)\n  *          // Do something\n  *      else\n  *          // Complain: We are more then half a second late!\n  *      if (someStopCondition)\n  *          this.cancel(); // This was our last execution\n  *  };\n  *  timer.scheduleAtFixedRate(task, 1000, 1000); // schedule every second\n- * </code>\n+ * </pre>\n  * <p>\n  * Note that a TimerTask object is a one shot object and can only given once\n  * to a Timer. (The Timer will use the TimerTask object for bookkeeping,"}, {"sha": "dfa9bc638812beac4de761a4697b3de4c4cf3f6b", "filename": "libjava/java/util/TreeMap.java", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FTreeMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FTreeMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTreeMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,6 +1,6 @@\n /* TreeMap.java -- a class providing a basic Red-Black Tree data structure,\n    mapping Object --> Object\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -162,7 +162,7 @@ public class TreeMap extends AbstractMap\n    *\n    * @author Eric Blake <ebb9@email.byu.edu>\n    */\n-  private static final class Node extends BasicMapEntry\n+  private static final class Node extends AbstractMap.BasicMapEntry\n   {\n     // All fields package visible for use by nested classes.\n     /** The color of this node. */\n@@ -623,8 +623,10 @@ public Object remove(Object key)\n     Node n = getNode(key);\n     if (n == nil)\n       return null;\n+    // Note: removeNode can alter the contents of n, so save value now.\n+    Object result = n.value;\n     removeNode(n);\n-    return n.value;\n+    return result;\n   }\n \n   /**\n@@ -1768,7 +1770,7 @@ public void clear()\n             SubMap.this.clear();\n           }\n         };\n-      return this.keys;\n+      return this.values;\n     }\n   } // class SubMap  \n } // class TreeMap"}, {"sha": "3431ac921e116f0789f8112f7de02aa97341026c", "filename": "libjava/java/util/WeakHashMap.java", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FWeakHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2FWeakHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FWeakHashMap.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,4 +1,4 @@\n-/* java.util.WeakHashMap -- a hashtable that keeps only weak references\n+/* WeakHashMap -- a hashtable that keeps only weak references\n    to its keys, allowing the virtual machine to reclaim them\n    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n@@ -43,41 +43,41 @@\n import java.lang.ref.ReferenceQueue;\n \n /**\n- * A weak hash map has only weak references to the key.  This means\n- * that it allows the key to be garbage collected if they are not used\n- * otherwise.  If this happens, the weak hash map will eventually\n- * remove the whole entry from this map. <br>\n+ * A weak hash map has only weak references to the key. This means that it\n+ * allows the key to be garbage collected if it is not used otherwise. If\n+ * this happens, the entry will eventually disappear from the map,\n+ * asynchronously.\n  *\n- * A weak hash map makes most sense, if the keys doesn't override the\n- * <code>equals</code>-method: If there is no other reference to the\n+ * <p>A weak hash map makes most sense when the keys doesn't override the\n+ * <code>equals</code> method: If there is no other reference to the\n  * key nobody can ever look up the key in this table and so the entry\n- * can be removed.  This table also works, if the <code>equals</code>\n- * method is overloaded, e.g. with Strings as keys, but you should be\n- * prepared that some entries disappear spontaneously. <br>\n+ * can be removed.  This table also works when the <code>equals</code>\n+ * method is overloaded, such as String keys, but you should be prepared\n+ * to deal with some entries disappearing spontaneously.\n  *\n- * You should also be prepared that this hash map behaves very\n- * strange: The size of this map may spontaneously shrink (even if you\n- * use a synchronized map and synchronize it); it behaves as if\n- * another thread removes entries from this table without\n- * synchronizations.  The entry set returned by <code>entrySet</code>\n+ * <p>Other strange behaviors to be aware of: The size of this map may\n+ * spontaneously shrink (even if you use a synchronized map and synchronize\n+ * it); it behaves as if another thread removes entries from this table\n+ * without synchronization.  The entry set returned by <code>entrySet</code>\n  * has similar phenomenons: The size may spontaneously shrink, or an\n- * entry, that was in the set before, suddenly disappears. <br>\n+ * entry, that was in the set before, suddenly disappears.\n  *\n- * A weak hash map is not meant for caches; use a normal map, with\n- * soft references as values instead, or try {@link LinkedHashMap}.  <br>\n+ * <p>A weak hash map is not meant for caches; use a normal map, with\n+ * soft references as values instead, or try {@link LinkedHashMap}.\n  *\n- * The weak hash map supports null values and null keys.  The null key\n- * is never deleted from the map (except explictly of course).\n- * The performance of the methods are similar to that of a hash map. <br>\n+ * <p>The weak hash map supports null values and null keys.  The null key\n+ * is never deleted from the map (except explictly of course). The\n+ * performance of the methods are similar to that of a hash map.\n  *\n- * The value objects are strongly referenced by this table.  So if a\n+ * <p>The value objects are strongly referenced by this table.  So if a\n  * value object maintains a strong reference to the key (either direct\n  * or indirect) the key will never be removed from this map.  According\n  * to Sun, this problem may be fixed in a future release.  It is not\n  * possible to do it with the jdk 1.2 reference model, though.\n  *\n  * @author Jochen Hoenicke\n- * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ *\n  * @see HashMap\n  * @see WeakReference\n  * @see LinkedHashMap\n@@ -86,6 +86,9 @@\n  */\n public class WeakHashMap extends AbstractMap implements Map\n {\n+  // WARNING: WeakHashMap is a CORE class in the bootstrap cycle. See the\n+  // comments in vm/reference/java/lang/Runtime for implications of this fact.\n+\n   /**\n    * The default capacity for an instance of HashMap.\n    * Sun's documentation mildly suggests that this (11) is the correct\n@@ -148,7 +151,7 @@ public boolean equals(Object o)\n   /**\n    * The rounded product of the capacity (i.e. number of buckets) and\n    * the load factor. When the number of elements exceeds the\n-   * threshold, the HashMap calls <pre>rehash()</pre>.\n+   * threshold, the HashMap calls <code>rehash()</code>.\n    */\n   private int threshold;\n \n@@ -364,11 +367,11 @@ private static class WeakBucket extends WeakReference\n \n     /**\n      * The slot of this entry. This should be\n-     * <pre>\n-     *  Math.abs(key.hashCode() % buckets.length)\n-     * </pre>\n+     * <code>Math.abs(key.hashCode() % buckets.length)</code>.\n+     *\n      * But since the key may be silently removed we have to remember\n      * the slot number.\n+     *\n      * If this bucket was removed the slot is -1.  This marker will\n      * prevent the bucket from being removed twice.\n      */\n@@ -503,9 +506,10 @@ WeakEntry getEntry()\n   private final WeakEntrySet theEntrySet;\n \n   /**\n-   * The hash buckets.  These are linked lists.\n+   * The hash buckets.  These are linked lists. Package visible for use in\n+   * nested classes.\n    */\n-  private WeakBucket[] buckets;\n+  WeakBucket[] buckets;\n \n   /**\n    * Creates a new weak hash map with default load factor and default\n@@ -676,10 +680,12 @@ private void internalAdd(Object key, Object value)\n \n   /**\n    * Removes a bucket from this hash map, if it wasn't removed before\n-   * (e.g. one time through rehashing and one time through reference queue)\n+   * (e.g. one time through rehashing and one time through reference queue).\n+   * Package visible for use in nested classes.\n+   *\n    * @param bucket the bucket to remove.\n    */\n-  private void internalRemove(WeakBucket bucket)\n+  void internalRemove(WeakBucket bucket)\n   {\n     int slot = bucket.slot;\n     if (slot == -1)\n@@ -870,4 +876,4 @@ public Collection values()\n     cleanQueue();\n     return super.values();\n   }\n-}\n+} // class WeakHashMap"}, {"sha": "0bf27bdb9ec29adf67e0a546345123a7fb7f7b9c", "filename": "libjava/java/util/jar/Attributes.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -430,7 +430,7 @@ public String putValue(String name, String value)\n    * @returns the old value of the attribute name or null if it didn't exist\n    * yet\n    */\n-  private String putValue(Name name, String value)\n+  String putValue(Name name, String value)\n   {\n     return (String) put(name, value);\n   }"}, {"sha": "54291c687d56bcbd275429f5450785b99b90fa40", "filename": "libjava/java/util/jar/JarException.java", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarException.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -1,5 +1,5 @@\n-/* Attributes.java -- exception thrown to indicate an problem with a jar file\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+/* JarException.java -- thrown to indicate an problem with a jar file\n+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,35 +41,34 @@\n \n /**\n  * This exception is thrown to indicate an problem with a jar file.\n- * It can be constructed with or without a descriptive message of the problem.\n- * <p>\n  * Note that none of the methods in the java.util.jar package actually declare\n  * to throw this exception, most just declare that they throw an IOException\n  * which is super class of JarException.\n- * \n- * @since 1.2\n+ *\n  * @author Mark Wielaard (mark@klomp.org)\n+ * @since 1.2\n  */\n-\n public class JarException extends ZipException\n {\n-  // Constructors\n+  /**\n+   * Compatible with JDK 1.2+.\n+   */\n+  private static final long serialVersionUID = 7159778400963954473L;\n \n   /**\n    * Create a new JarException without a descriptive error message.\n    */\n   public JarException()\n   {\n-    super();\n   }\n \n   /**\n    * Create a new JarException with a descriptive error message indicating\n    * what went wrong. This message can later be retrieved by calling the\n    * <code>getMessage()</code> method.\n-   * @see java.lang.Throwable@getMessage()\n    *\n    * @param message The descriptive error message\n+   * @see #getMessage()\n    */\n   public JarException(String message)\n   {"}, {"sha": "9a153760ef8cbcc469a86ba0b456cb7bb6979e30", "filename": "libjava/java/util/jar/Manifest.java", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3831381763ca5f41d6f7406d590e1e38a8531e1c/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FManifest.java?ref=3831381763ca5f41d6f7406d590e1e38a8531e1c", "patch": "@@ -174,18 +174,27 @@ public void read(InputStream in) throws IOException\n   private static void read_main_section(Attributes attr,\n \t\t\t\t\tBufferedReader br) throws IOException\n   {\n-    read_version_info(attr, br);\n+    // According to the spec we should actually call read_version_info() here.\n     read_attributes(attr, br);\n+    // Explicitly set Manifest-Version attribute if not set in Main\n+    // attributes of Manifest.\n+    if (attr.getValue(Attributes.Name.MANIFEST_VERSION) == null)\n+\t    attr.putValue(Attributes.Name.MANIFEST_VERSION, \"0.0\");\n   }\n \n+  /**\n+   * Pedantic method that requires the next attribute in the Manifest to be\n+   * the \"Manifest-Version\". This follows the Manifest spec closely but\n+   * reject some jar Manifest files out in the wild.\n+   */\n   private static void read_version_info(Attributes attr,\n \t\t\t\t\tBufferedReader br) throws IOException\n   {\n     String version_header = Attributes.Name.MANIFEST_VERSION.toString();\n     try\n       {\n \tString value = expect_header(version_header, br);\n-\tattr.putValue(version_header, value);\n+\tattr.putValue(Attributes.Name.MANIFEST_VERSION, value);\n       }\n     catch (IOException ioe)\n       {"}]}