{"sha": "6336436e0657638a62683444a41c27a234f640df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMzNjQzNmUwNjU3NjM4YTYyNjgzNDQ0YTQxYzI3YTIzNGY2NDBkZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T23:06:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T23:06:01Z"}, "message": "Initial revision\n\nFrom-SVN: r890", "tree": {"sha": "b87dfb47599d7015a18bbb3cf66e17030abdcc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b87dfb47599d7015a18bbb3cf66e17030abdcc3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6336436e0657638a62683444a41c27a234f640df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6336436e0657638a62683444a41c27a234f640df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6336436e0657638a62683444a41c27a234f640df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6336436e0657638a62683444a41c27a234f640df/comments", "author": null, "committer": null, "parents": [{"sha": "193e995bde2d059917cfbe9581dc91fcc6c3be51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193e995bde2d059917cfbe9581dc91fcc6c3be51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193e995bde2d059917cfbe9581dc91fcc6c3be51"}], "stats": {"total": 2269, "additions": 2269, "deletions": 0}, "files": [{"sha": "3402414d037090cfafb030f56d8df31e539b554f", "filename": "gcc/config/we32k/we32k.h", "status": "added", "additions": 1036, "deletions": 0, "changes": 1036, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=6336436e0657638a62683444a41c27a234f640df", "patch": "@@ -0,0 +1,1036 @@\n+/* Definitions of target machine for GNU compiler.  AT&T we32000 version.\n+   Contributed by John Wehle (john@feith1.uucp)\n+   Copyright (C) 1991-1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dwe32000 -Du3b -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (we32000)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 0\n+\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the we32000.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword is lowest numbered.  */\n+/* For we32000 we can decide arbitrarily\n+   since there are no machine instructions for them.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a we32000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\n+/* Define number of bits in most basic integer type.\n+   (If undefined, default is BITS_PER_WORD).  */\n+#define INT_TYPE_SIZE 32\n+\n+/* Integer bit fields should have the same size and alignment\n+   as actual integers */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers. */\n+#define FIRST_PSEUDO_REGISTER 16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator. */\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 1, 1, 1, 1, 1, 1, 1, }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 0, 0, 0, 0, 0, \\\n+  0, 1, 1, 1, 1, 1, 1, 1, }\n+\n+/* Make sure everything's fine if we *don't* have a given processor.\n+   This assumes that putting a register in fixed_regs will keep the\n+   compilers mitt's completely off it.  We don't bother to zero it out\n+   of register classes.  */\n+/* #define CONDITIONAL_REGISTER_USAGE */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers. */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 0\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register used for the program counter */\n+#define PC_REGNUM  15\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 12\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 9\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 10\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 8\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 2\n+\n+/* Order in which to allocate registers. */\n+#define REG_ALLOC_ORDER  \\\n+ {0, 1, 8, 7, 6, 5, 4, 3}\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS,\n+  ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ { \"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t\t\t\t\\\n+ 0,\t\t\t/* NO_REGS */\t\t\\\n+ 0x000017ff,\t\t/* GENERAL_REGS */\t\\\n+ 0x0000ffff,\t\t/* ALL_REGS */\t\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\\\n+  (((REGNO) < 11 || (REGNO) == 12) ? GENERAL_REGS : ALL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.\n+   We do a trick here to modify the effective constraints on the\n+   machine description; we zorch the constraint letters that aren't\n+   appropriate for a specific target.  This allows us to guarantee\n+   that a specific kind of register will not be used for a given target\n+   without fiddling with the register classes above. */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'r' ? GENERAL_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C. */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+/*\n+ */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class. */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+/* #define STACK_GROWS_DOWNWARD */\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by. */\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name. */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) (SIZE)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the we32000 the return value is in r0 regardless.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the we32000 the return value is in r0 regardless.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the we32000, r0 is the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+/* #define PCC_STATIC_STRUCT_RETURN */\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the we32000, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the we32k, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the we32k, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the we32000 all args are pushed */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int nregs_to_save;\t\t\t\t\t\\\n+  register int regno;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  nregs_to_save = 0;\t\t\t\t\t\t\\\n+  for (regno = 8; regno > 2; regno--)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      nregs_to_save = (9 - regno);\t\t\t\t\\\n+  fprintf (FILE, \"\\tsave &%d\\n\", nregs_to_save);  \t\t\\\n+  if (SIZE)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\taddw2 &%d,%%sp\\n\", ((SIZE) + 3) & ~3);\t}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tmovw &.LP%d,%%r0\\n\\tjsb _mcount\\n\", (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tcmpw .LPBX0,&0\\n\\tjne .LPI%d\\n\\tpushw &.LPBX0\\n\\tcall &1,__bb_init_func\\n.LPI%d:\\n\",  \\\n+\t   LABELNO, LABELNO);\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+  fprintf (FILE, \"\\taddw2 &1,.LPBX2+%d\\n\", 4 * BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int nregs_to_restore;\t\t\t\t\\\n+  register int regno;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  nregs_to_restore = 0;\t\t\t\t\t\t\\\n+  for (regno = 8; regno > 2; regno--)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       nregs_to_restore = (9 - regno);\t\t\t\t\\\n+  fprintf (FILE, \"\\tret &%d\\n\", nregs_to_restore);  \t\t}\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the we32k, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n+   macro doesn't matter.  But it must be defined.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0;\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the we32k, the trampoline contains two instructions:\n+     mov #STATIC,%r8\n+     jmp #FUNCTION */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x844f));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0x48));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x247f));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 13\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 2)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 9)), FNADDR); \\\n+}\n+\f\n+/* Generate calls to memcpy() and memset() rather\n+   than bcopy() and bzero() */\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t0\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\\\n+  ((REGNO) < 11 || (REGNO) == 12 ||\t\\\n+  (unsigned)reg_renumber[REGNO] < 11 || (unsigned)reg_renumber[REGNO] == 12)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P(X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (REGNO(X) < 11 || REGNO(X) == 12 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address. */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n+{ register rtx Addr = X;\t\t\t\t\t\t\\\n+  if (REG_P(Addr) && REG_OK_FOR_BASE_P(Addr))\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P(Addr))\t\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE(Addr) == PLUS &&\t\t\t\t\t\t\\\n+    ((REG_P(XEXP(Addr, 0)) && REG_OK_FOR_BASE_P(XEXP(Addr, 0)) &&\t\\\n+     CONSTANT_ADDRESS_P(XEXP(Addr, 1))) ||\t\t\t\t\\\n+     (REG_P(XEXP(Addr, 1)) && REG_OK_FOR_BASE_P(XEXP(Addr, 1)) &&\t\\\n+     CONSTANT_ADDRESS_P(XEXP(Addr, 0)))))\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output. */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   { }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for. */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t{ }\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE -1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{\t\t\t\t\t\t\t\t\\\n+  { CC_STATUS_INIT; }\t\t\t\t\t\t\\\n+}\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+\n+#define STARTFILE_SPEC  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}\"\n+\n+#define ENDFILE_SPEC \"crtn.o%s\"\n+\n+/* The .file command should always begin the output.  */\n+\n+#define ASM_FILE_START(FILE) output_file_directive ((FILE), main_input_filename)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output before code.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Read-only data goes in the data section because\n+   AT&T's assembler doesn't guarantee the proper alignment\n+   of data in the text section even if an align statement\n+   is used. */\n+\n+#define READONLY_DATA_SECTION() data_section()\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n+ \"r8\", \"fp\", \"ap\", \"psw\", \"sp\", \"pcbp\", \"isp\", \"pc\"\t}\n+\n+/* How to renumber registers for dbx and gdb. */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Output SDB debugging info in response to the -g option.  */\n+\n+#define SDB_DEBUGGING_INFO\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\\\n+    fputs (\".globl \", FILE);\t\t\\\n+    assemble_name (FILE, NAME);\t\t\\\n+    fputs (\"\\n\", FILE);\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \".%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an internal numbered label which\n+   labels a jump table.  */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\\\n+  } while (0)\n+\n+/* Assembler pseudo to introduce byte constants.  */\n+\n+#define ASM_BYTE_OP \"\\t.byte\"\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+/* AT&T's assembler can't handle floating constants written as floating.\n+   However, when cross-compiling, always use that in case format differs.  */\n+\n+#ifdef CROSS_COMPILER\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\\\n+  fprintf (FILE, \"\\t.double 0r%.20g\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\\\n+  fprintf (FILE, \"\\t.float 0r%.10g\\n\", (VALUE))\n+\n+#else\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\\\n+do { union { double d; long l[2];} tem;\t\t\t\t\\\n+     tem.d = (VALUE);\t\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.word 0x%x, 0x%x\\n\", tem.l[0], tem.l[1]);\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\\\n+do { union { float f; long l;} tem;\t\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.word 0x%x\\n\", tem.l);\t\t\t\\\n+   } while (0)\n+\n+#endif /* not CROSS_COMPILER */\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)  \\\n+{\t\t\t\t\t\t\t\\\n+  unsigned char *s;\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\\\n+  for (i = 0, s = (PTR); i < (LEN); s++, i++)\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((i % 8) == 0)\t\t\t\t\t\\\n+\tfprintf ((FILE),\"%s\\t.byte\\t\",(i?\"\\n\":\"\"));\t\\\n+      fprintf ((FILE), \"%s0x%x\", (i%8?\",\":\"\"), (unsigned)*s); \\\n+    }\t\t\t\t\t\t\t\\\n+  fputs (\"\\n\", (FILE));\t\t\t\t\t\\\n+}\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO) \\\n+  fprintf (FILE, \"\\tpushw %s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\\\n+  fprintf (FILE, \"\\tPOPW %s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute. */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+/* The `space' pseudo in the text segment outputs nop insns rather than 0s,\n+   so we must output 0s explicitly in the text segment.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  if (in_text_section ())                                           \t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      int i;\t\t\t\t\t\t\t\t    \\\n+      for (i = 0; i < (SIZE) - 20; i += 20)\t\t\t\t    \\\n+\tfprintf (FILE, \"\\t.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n\"); \\\n+      if (i < (SIZE))\t\t\t\t\t\t\t    \\\n+        {\t\t\t\t\t\t\t\t    \\\n+\t  fprintf (FILE, \"\\t.byte 0\");\t\t\t\t\t    \\\n+\t  i++;\t\t\t\t\t\t\t\t    \\\n+\t  for (; i < (SIZE); i++)\t\t\t\t\t    \\\n+\t    fprintf (FILE, \",0\");\t\t\t\t\t    \\\n+\t  fprintf (FILE, \"\\n\");\t\t\t\t\t\t    \\\n+\t}\t\t\t\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+  else\t\t\t\t\t\t\t\t\t    \\\n+    fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    data_section();\t\t\t\t\t\\\n+    fputs (\"\\t.comm \", (FILE));\t\t\t\t\\\n+    assemble_name ((FILE), (NAME));\t\t\t\\\n+    fprintf ((FILE), \",%u\\n\", (SIZE));\t\t\t\\\n+  } while (0)\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    data_section();\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\\\n+    ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n+    fprintf ((FILE), \"\\t.zero %u\\n\", (SIZE));\t\t\\\n+  } while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME)\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null. */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) 0\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ int i;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%%%s\", reg_names[REGNO (X)]);\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+         {\t\t\t\t\t\t\t\t\\\n+         union { double d; long l[2]; } dtem;\t\t\t\t\\\n+         union { float f; long l; } ftem;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+         dtem.l[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n+         dtem.l[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n+         ftem.f = dtem.d;\t\t\t\t\t\t\\\n+         fprintf(FILE, \"&0x%lx\", ftem.l);\t\t\t\t\\\n+         }\t\t\t\t\t\t\t\t\\\n+  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n+\f\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx Addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  rtx reg;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (Addr) == MEM) {\t\t\t\t\t\t\\\n+    putc ('*', FILE);\t\t\t\t\t\t\t\\\n+    Addr = XEXP (Addr, 0);\t\t\t\t\t\t\\\n+    if (GET_CODE (Addr) == REG)\t\t\t\t\t\t\\\n+      putc ('0', FILE);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (Addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%%%s)\", reg_names[REGNO (Addr)]);\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      offset = NULL;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (Addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (Addr, 0);\t\t\t\t\t\\\n+\t  Addr = XEXP (Addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (Addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (Addr, 1);\t\t\t\t\t\\\n+\t  Addr = XEXP (Addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        abort();\t\t\t\t\t\t\t\\\n+      if (REG_P (Addr))\t\t\t\t\t\t\t\\\n+        reg = Addr;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        abort();\t\t\t\t\t\t\t\\\n+      output_addr_const(FILE, offset);\t\t\t\t\t\\\n+      fprintf(FILE, \"(%%%s)\", reg_names[REGNO(reg)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if ( !CONSTANT_ADDRESS_P(Addr))\t\t\t\t\t\\\n+\tabort();\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, Addr);\t\t\t\t\t\\\n+    }}\n+\f\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}, {"sha": "ca0da26c977e5a9b9a58e91af1ba633c79085979", "filename": "gcc/config/we32k/we32k.md", "status": "added", "additions": 1181, "deletions": 0, "changes": 1181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fwe32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.md?ref=6336436e0657638a62683444a41c27a234f640df", "patch": "@@ -0,0 +1,1181 @@\n+;;- Machine description for GNU compiler\n+;;- AT&T we32000 Version\n+;;  Contributed by John Wehle (john@feith1.uucp)\n+;;   Copyright (C) 1991-1992 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 1, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- instruction definitions\n+\n+;;- @@The original PO technology requires these to be ordered by speed,\n+;;- @@    so that assigner will pick the fastest.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- When naming insn's (operand 0 of define_insn) be careful about using\n+;;- names from other targets machine descriptions.\n+\f\n+;; move instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=m\")\n+        (match_operand:DF 1 \"general_operand\" \"mrF\"))]\n+  \"\"\n+  \"*\n+  {\n+  output_push_double(&operands[1]);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:DF 1 \"general_operand\" \"mrF\"))]\n+  \"\"\n+  \"*\n+  {\n+  output_move_double(operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=m\")\n+        (match_operand:SF 1 \"general_operand\" \"mrF\"))]\n+  \"\"\n+  \"pushw %1\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:SF 1 \"general_operand\" \"mrF\"))]\n+  \"\"\n+  \"movw %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=m\")\n+        (match_operand:DI 1 \"general_operand\" \"mriF\"))]\n+  \"\"\n+  \"*\n+  {\n+  output_push_double(&operands[1]);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:DI 1 \"general_operand\" \"mriF\"))]\n+  \"\"\n+  \"*\n+  {\n+  output_move_double(operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+        (match_operand:SI 1 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"pushw %1\")\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:SI 1 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"movw %1, %0\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:HI 1 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"movh %1, %0\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (match_operand:QI 1 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"movb %1, %0\")\n+\f\n+;; add instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&or\")\n+        (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:DI 2 \"general_operand\" \"oriF\")))]\n+  \"\"\n+  \"*\n+  {\n+  rtx label[1];\n+  rtx lsw_operands[3];\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      abort();\n+\n+  if (GET_CODE (operands[2]) == REG)\n+    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n+      lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n+    else\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[2] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[2]));\n+        operands[2] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[2]));\n+        }\n+      else\n+        if (GET_CODE (operands[2]) == CONST_INT)\n+          {\n+          lsw_operands[2] = operands[2];\n+          operands[2] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  label[0] = gen_label_rtx();\n+  LABEL_NUSES(label[0]) = 1;\n+\n+  output_asm_insn(\\\"addw2 %2, %0\\\", operands);\n+  output_asm_insn(\\\"addw2 %2, %0\\\", lsw_operands);\n+  output_asm_insn(\\\"BCCB %l0\\\", label);\n+  output_asm_insn(\\\"INCW %0\\\", operands);\n+  output_asm_insn(\\\"%l0:\\\", label);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&or\")\n+        (plus:DI (match_operand:DI 1 \"general_operand\" \"oriF\")\n+                 (match_operand:DI 2 \"general_operand\" \"oriF\")))]\n+  \"\"\n+  \"*\n+  {\n+  rtx label[1];\n+  rtx lsw_operands[3];\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      abort();\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    lsw_operands[1] = gen_rtx(REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1]))\n+      lsw_operands[1] = adj_offsettable_operand(operands[1], 4);\n+    else\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[1] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[1]));\n+        operands[1] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[1]));\n+        }\n+      else\n+        if (GET_CODE (operands[1]) == CONST_INT)\n+          {\n+          lsw_operands[1] = operands[1];\n+          operands[1] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  if (GET_CODE (operands[2]) == REG)\n+    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n+      lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n+    else\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[2] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[2]));\n+        operands[2] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[2]));\n+        }\n+      else\n+        if (GET_CODE (operands[2]) == CONST_INT)\n+          {\n+          lsw_operands[2] = operands[2];\n+          operands[2] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  label[0] = gen_label_rtx();\n+  LABEL_NUSES(label[0]) = 1;\n+\n+  output_asm_insn(\\\"addw3 %2, %1, %0\\\", operands);\n+  output_asm_insn(\\\"addw3 %2, %1, %0\\\", lsw_operands);\n+  output_asm_insn(\\\"BCCB %l0\\\", label);\n+  output_asm_insn(\\\"INCW %0\\\", operands);\n+  output_asm_insn(\\\"%l0:\\\", label);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addw2 %2, %0\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addw3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addh2 %2, %0\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:HI (match_operand:HI 1 \"general_operand\" \"mri\")\n+                 (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addh3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addb2 %2, %0\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (plus:QI (match_operand:QI 1 \"general_operand\" \"mri\")\n+                 (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"addb3 %2, %1, %0\")\n+\f\n+;; subtract instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&or\")\n+        (minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:DI 2 \"general_operand\" \"oriF\")))]\n+  \"\"\n+  \"*\n+  {\n+  rtx label[1];\n+  rtx lsw_operands[3];\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      abort();\n+\n+  if (GET_CODE (operands[2]) == REG)\n+    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n+      lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n+    else\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[2] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[2]));\n+        operands[2] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[2]));\n+        }\n+      else\n+        if (GET_CODE (operands[2]) == CONST_INT)\n+          {\n+          lsw_operands[2] = operands[2];\n+          operands[2] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  label[0] = gen_label_rtx();\n+  LABEL_NUSES(label[0]) = 1;\n+\n+  output_asm_insn(\\\"subw2 %2, %0\\\", operands);\n+  output_asm_insn(\\\"subw2 %2, %0\\\", lsw_operands);\n+  output_asm_insn(\\\"BCCB %l0\\\", label);\n+  output_asm_insn(\\\"DECW %0\\\", operands);\n+  output_asm_insn(\\\"%l0:\\\", label);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&or\")\n+        (minus:DI (match_operand:DI 1 \"general_operand\" \"oriF\")\n+                 (match_operand:DI 2 \"general_operand\" \"oriF\")))]\n+  \"\"\n+  \"*\n+  {\n+  rtx label[1];\n+  rtx lsw_operands[3];\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    lsw_operands[0] = gen_rtx(REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    if (GET_CODE (operands[0]) == MEM && offsettable_memref_p (operands[0]))\n+      lsw_operands[0] = adj_offsettable_operand(operands[0], 4);\n+    else\n+      abort();\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    lsw_operands[1] = gen_rtx(REG, SImode, REGNO (operands[1]) + 1);\n+  else\n+    if (GET_CODE (operands[1]) == MEM && offsettable_memref_p (operands[1]))\n+      lsw_operands[1] = adj_offsettable_operand(operands[1], 4);\n+    else\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[1] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[1]));\n+        operands[1] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[1]));\n+        }\n+      else\n+        if (GET_CODE (operands[1]) == CONST_INT)\n+          {\n+          lsw_operands[1] = operands[1];\n+          operands[1] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  if (GET_CODE (operands[2]) == REG)\n+    lsw_operands[2] = gen_rtx(REG, SImode, REGNO (operands[2]) + 1);\n+  else\n+    if (GET_CODE (operands[2]) == MEM && offsettable_memref_p (operands[2]))\n+      lsw_operands[2] = adj_offsettable_operand(operands[2], 4);\n+    else\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+        {\n+        lsw_operands[2] = gen_rtx(CONST_INT, SImode,\n+                                  CONST_DOUBLE_HIGH(operands[2]));\n+        operands[2] = gen_rtx(CONST_INT, SImode,\n+                              CONST_DOUBLE_LOW(operands[2]));\n+        }\n+      else\n+        if (GET_CODE (operands[2]) == CONST_INT)\n+          {\n+          lsw_operands[2] = operands[2];\n+          operands[2] = const0_rtx;\n+          }\n+        else\n+          abort();\n+\n+  label[0] = gen_label_rtx();\n+  LABEL_NUSES(label[0]) = 1;\n+\n+  output_asm_insn(\\\"subw3 %2, %1, %0\\\", operands);\n+  output_asm_insn(\\\"subw3 %2, %1, %0\\\", lsw_operands);\n+  output_asm_insn(\\\"BCCB %l0\\\", label);\n+  output_asm_insn(\\\"DECW %0\\\", operands);\n+  output_asm_insn(\\\"%l0:\\\", label);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                  (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subw2 %2, %0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                  (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subw3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+                  (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subh2 %2, %0\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:HI (match_operand:HI 1 \"general_operand\" \"mri\")\n+                  (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subh3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+                  (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subb2 %2, %0\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (minus:QI (match_operand:QI 1 \"general_operand\" \"mri\")\n+                  (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"subb3 %2, %1, %0\")\n+\f\n+;; signed multiply instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mulw2 %2, %0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (mult:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mulw3 %2, %1, %0\")\n+\n+;; signed divide instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (div:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"divw2 %2, %0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (div:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"divw3 %2, %1, %0\")\n+\n+;; signed modulus instruction\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (mod:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"modw2 %2, %0\")\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (mod:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"modw3 %2, %1, %0\")\n+\f\n+;; unsigned divide instruction\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"udivw2 %2, %0\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (udiv:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"udivw3 %2, %1, %0\")\n+\n+;; unsigned modulus instruction\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (umod:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"umodw2 %2, %0\")\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (umod:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                 (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"umodw3 %2, %1, %0\")\n+\f\n+;; logical-and instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andw2 %2, %0\")\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andw3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andh2 %2, %0\")\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:HI (match_operand:HI 1 \"general_operand\" \"mri\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andh3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andb2 %2, %0\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (and:QI (match_operand:QI 1 \"general_operand\" \"mri\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"andb3 %2, %1, %0\")\n+\f\n+;; inclusive-or instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orw2 %2, %0\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orw3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orh2 %2, %0\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:HI (match_operand:HI 1 \"general_operand\" \"mri\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orh3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orb2 %2, %0\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ior:QI (match_operand:QI 1 \"general_operand\" \"mri\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"orb3 %2, %1, %0\")\n+\f\n+;; exclusive-or instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorw2 %2, %0\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorw3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorh2 %2, %0\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:HI (match_operand:HI 1 \"general_operand\" \"mri\")\n+                (match_operand:HI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorh3 %2, %1, %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorb2 %2, %0\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (xor:QI (match_operand:QI 1 \"general_operand\" \"mri\")\n+                (match_operand:QI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"xorb3 %2, %1, %0\")\n+\f\n+;; arithmetic shift instructions\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ashift:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                   (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"LLSW3 %2, %1, %0\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                     (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"ARSW3 %2, %1, %0\")\n+\n+;; logical shift instructions\n+\n+;; (define_insn \"lshlsi3\"\n+;;   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+;;         (lshift:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+;;                    (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+;;   \"\"\n+;;   \"LLSW3 %2, %1, %0\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                     (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"LRSW3 %2, %1, %0\")\n+\n+;; rotate instruction\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (rotatert: SI (match_operand:SI 1 \"general_operand\" \"mri\")\n+                      (match_operand:SI 2 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"ROTW %2, %1, %0\")\n+\f\n+;; negate instructions\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (neg:SI (match_operand:SI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mnegw %1, %0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (neg:HI (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mnegh %1, %0\")\n+\n+;; complement instructions\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (not:SI (match_operand:SI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mcomw %1, %0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (not:HI (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mcomh %1, %0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (not:QI (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"mcomb %1, %0\")\n+\f\n+;; compare instruction\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"general_operand\" \"mri\")\n+                       (match_operand:SI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"CMPW %1, %0\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0) (compare (match_operand:HI 0 \"general_operand\" \"mri\")\n+                       (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"*\n+  {\n+\n+  if (GET_CODE (operands[0]) == CONST_INT && \n+    ((unsigned long)INTVAL (operands[0]) & 0x8000L))\n+    operands[0] = gen_rtx(CONST_INT, SImode, INTVAL(operands[0]) | 0xffff0000L);\n+\n+  if (GET_CODE (operands[1]) == CONST_INT &&\n+    ((unsigned long)INTVAL (operands[1]) & 0x8000L))\n+    operands[1] = gen_rtx(CONST_INT, SImode, INTVAL(operands[1]) | 0xffff0000L);\n+\n+  output_asm_insn(\\\"CMPH %1, %0\\\",operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"general_operand\" \"mri\")\n+                       (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"*\n+  {\n+\n+  if (GET_CODE (operands[0]) == CONST_INT && \n+    ((unsigned long)INTVAL (operands[0]) & 0x80L))\n+    operands[0] = gen_rtx(CONST_INT, SImode, INTVAL(operands[0]) | 0xffffff00L);\n+\n+  if (GET_CODE (operands[1]) == CONST_INT &&\n+    ((unsigned long)INTVAL (operands[1]) & 0x80L))\n+    operands[1] = gen_rtx(CONST_INT, SImode, INTVAL(operands[1]) | 0xffffff00L);\n+\n+  output_asm_insn(\\\"CMPB {sbyte}%1, {sbyte}%0\\\",operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+;; test instruction\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"TSTW %0\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0) (match_operand:HI 0 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"*\n+  {\n+\n+  if (GET_CODE (operands[0]) == CONST_INT &&\n+    ((unsigned long)INTVAL (operands[0]) & 0x8000L))\n+    operands[0] = gen_rtx(CONST_INT, SImode, INTVAL(operands[0]) | 0xffff0000L);\n+\n+  output_asm_insn(\\\"TSTH %0\\\",operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0) (match_operand:QI 0 \"general_operand\" \"mri\"))]\n+  \"\"\n+  \"*\n+  {\n+\n+  if (GET_CODE (operands[0]) == CONST_INT &&\n+    ((unsigned long)INTVAL (operands[0]) & 0x80L))\n+    operands[0] = gen_rtx(CONST_INT, SImode, INTVAL(operands[0]) | 0xffffff00L);\n+\n+  output_asm_insn(\\\"TSTB {sbyte}%0\\\",operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\f\n+;; truncate instructions\n+\n+(define_insn \"truncdfsf2\"\n+  [(clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (set (match_operand:SF 0 \"nonimmediate_operand\" \"=mr\")\n+        (float_truncate:SF (match_operand:DF 1 \"general_operand\" \"orF\")))]\n+  \"\"\n+  \"*\n+  {\n+  output_push_double(&operands[1]);\n+  output_asm_insn(\\\"call &2, _fdtos\\\");\n+\n+  if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) != 0)\n+    output_asm_insn(\\\"movw %%r0, %0\\\", operands);\n+\n+  return \\\"\\\";\n+  }\")\n+\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (truncate:HI (match_operand:SI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movtwh %1, %0\")\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (truncate:QI (match_operand:SI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movtwb %1, %0\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=mr\")\n+        (truncate:QI (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movthb %1, %0\")\n+\f\n+;; sign-extend move instructions\n+\n+(define_insn \"extendsfdf2\"\n+  [(clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (set (match_operand:DF 0 \"nonimmediate_operand\" \"=or\")\n+        (float_extend:DF (match_operand:SF 1 \"general_operand\" \"mrF\")))]\n+  \"\"\n+  \"*\n+  {\n+  rtx xoperands[2];\n+\n+  output_asm_insn(\\\"pushw %1\\\", operands);\n+  output_asm_insn(\\\"call &1, _fstod\\\");\n+\n+  if (GET_CODE (operands[0]) != REG || REGNO (operands[0]) != 0) {\n+    xoperands[0] = operands[0];\n+    xoperands[1] = gen_rtx(REG, DFmode, 0);\n+    output_move_double(xoperands);\n+    }\n+\n+  return \\\"\\\";\n+  }\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movbhw %1, %0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (sign_extend:SI (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movbbw %1, %0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movbbh %1, %0\")\n+\n+;; zero-extend move instructions\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movzhw %1, %0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+        (zero_extend:SI (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movzbw %1, %0\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=mr\")\n+        (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"mri\")))]\n+  \"\"\n+  \"movzbh %1, %0\")\n+\f\n+;; bit field instructions\n+\n+;; (define_insn \"extzv\"\n+;;   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mr\")\n+;;         (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"mr\")\n+;;                          (match_operand:SI 2 \"general_operand\" \"mri\")\n+;;                          (match_operand:SI 3 \"general_operand\" \"mri\")))]\n+;;   \"\"\n+;;   \"EXTFW %2, %3, %1, %0\")\n+\n+;; (define_insn \"insv\"\n+;;   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+mr\")\n+;;                          (match_operand:SI 1 \"general_operand\" \"mri\")\n+;;                          (match_operand:SI 2 \"general_operand\" \"mri\"))\n+;;         (match_operand:SI 3 \"general_operand\" \"mri\"))]\n+;;   \"\"\n+;;   \"INSFW %1, %2, %3, %0\")\n+\f\n+;; conditional branch instructions\n+\n+(define_insn \"beq\"\n+  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"je %l0\")\n+\n+(define_insn \"bne\"\n+  [(set (pc) (if_then_else (ne (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jne %l0\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc) (if_then_else (gt (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jg %l0\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jgu %l0\")\n+\n+(define_insn \"blt\"\n+  [(set (pc) (if_then_else (lt (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jl %l0\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc) (if_then_else (ltu (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jlu %l0\")\n+\n+(define_insn \"bge\"\n+  [(set (pc) (if_then_else (ge (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jge %l0\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc) (if_then_else (geu (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jgeu %l0\")\n+\n+(define_insn \"ble\"\n+  [(set (pc) (if_then_else (le (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jle %l0\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc) (if_then_else (leu (cc0) (const_int 0))\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"jleu %l0\")\n+\f\n+;; reverse-conditional branch instructions\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jne %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (ne (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"je %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (gt (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jle %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jleu %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (lt (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jge %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (ltu (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgeu %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (ge (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jl %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (geu (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jlu %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (le (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jg %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc) (if_then_else (leu (cc0) (const_int 0))\n+                           (pc)\n+                           (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"jgu %l0\")\n+\f\n+;; call instructions\n+\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+         (match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"call %1/4, %0\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+        (call (match_operand:QI 1 \"memory_operand\" \"m\")\n+              (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"call %2/4, %1\")\n+\n+;; No-op instruction\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"NOP\")\n+\n+;; jump through a dispatch table instruction\n+\n+(define_expand \"casesi\"\n+  [(use (match_operand:SI 0 \"general_operand\" \"mri\"))\n+   (set (cc0) (compare (match_dup 5)\n+                       (match_operand:SI 1 \"general_operand\" \"mri\")))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+                           (label_ref (match_operand 4 \"\" \"\"))\n+                           (pc)))\n+   (set (match_dup 5) (minus:SI (match_dup 5)\n+                                (match_dup 1)))\n+   (set (cc0) (compare (match_dup 5)\n+                       (match_operand:SI 2 \"general_operand\" \"mri\")))\n+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+                           (label_ref (match_operand 4 \"\" \"\"))\n+                           (pc)))\n+   (set (match_dup 5) (ashift:SI (match_dup 5)\n+                                 (const_int 2)))\n+   (set (pc) (mem:SI (plus:SI (label_ref (match_operand 3 \"\" \"\"))\n+                              (match_dup 5))))]\n+  \"\"\n+  \"\n+  {\n+  operands[5] = gen_reg_rtx(GET_MODE (operands[0]));\n+  emit_move_insn(operands[5], operands[0]);\n+  }\")\n+\n+;; jump instructions\n+\n+(define_insn \"\"\n+  [(set (pc) (mem:SI (match_operand:SI 0 \"address_operand\" \"p\")))]\n+  \"GET_CODE (operands[0]) != MEM\"\n+  \"jmp *%a0\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"jmp %a0\")\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %l0\")\n+\f\n+;; peephole optimizations\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"nonimmediate_operand\" \"or\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+        (mem:SI (match_dup 0)))]\n+  \"REGNO (operands[0]) == REGNO (operands[2]) && (REG_P (operands[1]) || offsettable_memref_p (operands[1]))\"\n+  \"movw %a1, %0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"nonimmediate_operand\" \"or\"))\n+   (set (match_operand:HI 2 \"register_operand\" \"=r\")\n+        (mem:HI (match_dup 0)))]\n+  \"REGNO (operands[0]) == REGNO (operands[2]) && (REG_P (operands[1]) || offsettable_memref_p (operands[1]))\"\n+  \"movh %a1, %0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"nonimmediate_operand\" \"or\"))\n+   (set (match_operand:QI 2 \"register_operand\" \"=r\")\n+        (mem:QI (match_dup 0)))]\n+  \"REGNO (operands[0]) == REGNO (operands[2]) && (REG_P (operands[1]) || offsettable_memref_p (operands[1]))\"\n+  \"movb %a1, %0\")"}, {"sha": "9bc70cf5ce02fb6b4332e2b0b7648f4a5c1cc50a", "filename": "gcc/config/we32k/xm-we32k.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fxm-we32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6336436e0657638a62683444a41c27a234f640df/gcc%2Fconfig%2Fwe32k%2Fxm-we32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fxm-we32k.h?ref=6336436e0657638a62683444a41c27a234f640df", "patch": "@@ -0,0 +1,52 @@\n+/* Configuration for GNU C-compiler for AT&T we32000 Family.\n+   Contributed by John Wehle (john@feith1.uucp)\n+   Copyright (C) 1991-1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+#define USG\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+#define bcopy(a,b,c) memcpy (b,a,c)\n+#define bzero(a,b) memset (a,0,b)\n+#define bcmp(a,b,c) memcmp (a,b,c)\n+\n+#ifdef __GNUC__\n+#define alloca(n) __builtin_alloca(n)\n+#endif\n+\n+#ifndef MAXPATHLEN\n+#define MAXPATHLEN 512\n+#endif"}]}