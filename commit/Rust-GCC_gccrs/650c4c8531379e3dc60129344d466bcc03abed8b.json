{"sha": "650c4c8531379e3dc60129344d466bcc03abed8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUwYzRjODUzMTM3OWUzZGM2MDEyOTM0NGQ0NjZiY2MwM2FiZWQ4Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-01-09T04:42:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-01-09T04:42:38Z"}, "message": "ree.c (get_sub_rtx): New function, extracted from...\n\n        * ree.c (get_sub_rtx): New function, extracted from...\n        (merge_def_and_ext): Here.\n        (combine_reaching_defs): Use get_sub_rtx.\n\nFrom-SVN: r206454", "tree": {"sha": "449a7c44b14521cd88aa80abdacd04b1983912a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/449a7c44b14521cd88aa80abdacd04b1983912a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/650c4c8531379e3dc60129344d466bcc03abed8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650c4c8531379e3dc60129344d466bcc03abed8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/650c4c8531379e3dc60129344d466bcc03abed8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650c4c8531379e3dc60129344d466bcc03abed8b/comments", "author": null, "committer": null, "parents": [{"sha": "cfb28d297f6f80e0eb01abada1bf7eeacd506378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb28d297f6f80e0eb01abada1bf7eeacd506378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb28d297f6f80e0eb01abada1bf7eeacd506378"}], "stats": {"total": 60, "additions": 41, "deletions": 19}, "files": [{"sha": "e4872f24a06efae1b9f6c94c379339b725118b72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650c4c8531379e3dc60129344d466bcc03abed8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650c4c8531379e3dc60129344d466bcc03abed8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=650c4c8531379e3dc60129344d466bcc03abed8b", "patch": "@@ -1,3 +1,9 @@\n+2014-01-08  Jeff Law  <law@redhat.com>\n+\n+\t* ree.c (get_sub_rtx): New function, extracted from...\n+\t(merge_def_and_ext): Here.\n+\t(combine_reaching_defs): Use get_sub_rtx.\n+\n 2014-01-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cgraph.h (varpool_variable_node): Do not choke on null node."}, {"sha": "1c4f3ad6fa2ad3a24eae5985cf057d2e65b7dd4d", "filename": "gcc/ree.c", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650c4c8531379e3dc60129344d466bcc03abed8b/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650c4c8531379e3dc60129344d466bcc03abed8b/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=650c4c8531379e3dc60129344d466bcc03abed8b", "patch": "@@ -580,27 +580,21 @@ make_defs_and_copies_lists (rtx extend_insn, const_rtx set_pat,\n   return ret;\n }\n \n-/* Merge the DEF_INSN with an extension.  Calls combine_set_extension\n-   on the SET pattern.  */\n-\n-static bool\n-merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n+/* If DEF_INSN has single SET expression, possibly buried inside\n+   a PARALLEL, return the address of the SET expression, else\n+   return NULL.  This is similar to single_set, except that\n+   single_set allows multiple SETs when all but one is dead.  */\n+static rtx *\n+get_sub_rtx (rtx def_insn)\n {\n-  enum machine_mode ext_src_mode;\n-  enum rtx_code code;\n-  rtx *sub_rtx;\n-  rtx s_expr;\n-  int i;\n-\n-  ext_src_mode = GET_MODE (XEXP (SET_SRC (cand->expr), 0));\n-  code = GET_CODE (PATTERN (def_insn));\n-  sub_rtx = NULL;\n+  enum rtx_code code = GET_CODE (PATTERN (def_insn));\n+  rtx *sub_rtx = NULL;\n \n   if (code == PARALLEL)\n     {\n-      for (i = 0; i < XVECLEN (PATTERN (def_insn), 0); i++)\n+      for (int i = 0; i < XVECLEN (PATTERN (def_insn), 0); i++)\n         {\n-          s_expr = XVECEXP (PATTERN (def_insn), 0, i);\n+          rtx s_expr = XVECEXP (PATTERN (def_insn), 0, i);\n           if (GET_CODE (s_expr) != SET)\n             continue;\n \n@@ -609,7 +603,7 @@ merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n           else\n             {\n               /* PARALLEL with multiple SETs.  */\n-              return false;\n+              return NULL;\n             }\n         }\n     }\n@@ -618,10 +612,27 @@ merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n   else\n     {\n       /* It is not a PARALLEL or a SET, what could it be ? */\n-      return false;\n+      return NULL;\n     }\n \n   gcc_assert (sub_rtx != NULL);\n+  return sub_rtx;\n+}\n+\n+/* Merge the DEF_INSN with an extension.  Calls combine_set_extension\n+   on the SET pattern.  */\n+\n+static bool\n+merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n+{\n+  enum machine_mode ext_src_mode;\n+  rtx *sub_rtx;\n+\n+  ext_src_mode = GET_MODE (XEXP (SET_SRC (cand->expr), 0));\n+  sub_rtx = get_sub_rtx (def_insn);\n+\n+  if (sub_rtx == NULL)\n+    return false;\n \n   if (REG_P (SET_DEST (*sub_rtx))\n       && (GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode\n@@ -707,8 +718,13 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n       /* If there is an overlap between the destination of DEF_INSN and\n \t CAND->insn, then this transformation is not safe.  Note we have\n \t to test in the widened mode.  */\n+      rtx *dest_sub_rtx = get_sub_rtx (def_insn);\n+      if (dest_sub_rtx == NULL\n+\t  || !REG_P (SET_DEST (*dest_sub_rtx)))\n+\treturn false;\n+\n       rtx tmp_reg = gen_rtx_REG (GET_MODE (SET_DEST (PATTERN (cand->insn))),\n-\t\t\t\t REGNO (SET_DEST (PATTERN (def_insn))));\n+\t\t\t\t REGNO (SET_DEST (*dest_sub_rtx)));\n       if (reg_overlap_mentioned_p (tmp_reg, SET_DEST (PATTERN (cand->insn))))\n \treturn false;\n "}]}