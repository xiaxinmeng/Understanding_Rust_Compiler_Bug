{"sha": "3c84109eae52da59c09e8a91bfb5e79bd0527809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M4NDEwOWVhZTUyZGE1OWMwOWU4YTkxYmZiNWU3OWJkMDUyNzgwOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:17:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:17:54Z"}, "message": "[54/77] Add explicit int checks for alternative optab implementations\n\nexpand_unop can expand narrow clz, clrsb, ctz, bswap, parity and\nffs operations using optabs for wider modes.  These expansions\napply only to scalar integer modes (and not for example to vectors),\nso the patch adds explicit checks for that.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs.c (widen_leading): Change the type of the mode argument\n\tto scalar_int_mode.  Use opt_scalar_int_mode for the mode iterator.\n\t(widen_bswap): Likewise.\n\t(expand_parity): Likewise.\n\t(expand_ctz): Change the type of the mode argument to scalar_int_mode.\n\t(expand_ffs): Likewise.\n\t(epand_unop): Check for scalar integer modes before calling the\n\tabove routines.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251506", "tree": {"sha": "62076c2966744eb351ccc7da3ed1080dad4c6f72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62076c2966744eb351ccc7da3ed1080dad4c6f72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c84109eae52da59c09e8a91bfb5e79bd0527809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c84109eae52da59c09e8a91bfb5e79bd0527809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c84109eae52da59c09e8a91bfb5e79bd0527809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c84109eae52da59c09e8a91bfb5e79bd0527809/comments", "author": null, "committer": null, "parents": [{"sha": "04d6ea36a7f0b2124d1a102eae3727efddeb5875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d6ea36a7f0b2124d1a102eae3727efddeb5875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d6ea36a7f0b2124d1a102eae3727efddeb5875"}], "stats": {"total": 192, "additions": 104, "deletions": 88}, "files": [{"sha": "e4805908254daebed0d35a09f0937b38a8a59914", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c84109eae52da59c09e8a91bfb5e79bd0527809/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c84109eae52da59c09e8a91bfb5e79bd0527809/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c84109eae52da59c09e8a91bfb5e79bd0527809", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs.c (widen_leading): Change the type of the mode argument\n+\tto scalar_int_mode.  Use opt_scalar_int_mode for the mode iterator.\n+\t(widen_bswap): Likewise.\n+\t(expand_parity): Likewise.\n+\t(expand_ctz): Change the type of the mode argument to scalar_int_mode.\n+\t(expand_ffs): Likewise.\n+\t(epand_unop): Check for scalar integer modes before calling the\n+\tabove routines.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3cc37c3ef13eddcfe3dc452f4e1445f417065d33", "filename": "gcc/optabs.c", "status": "modified", "additions": 91, "deletions": 88, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c84109eae52da59c09e8a91bfb5e79bd0527809/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c84109eae52da59c09e8a91bfb5e79bd0527809/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3c84109eae52da59c09e8a91bfb5e79bd0527809", "patch": "@@ -2129,39 +2129,36 @@ expand_simple_unop (machine_mode mode, enum rtx_code code, rtx op0,\n    A similar operation can be used for clrsb.  UNOPTAB says which operation\n    we are trying to expand.  */\n static rtx\n-widen_leading (machine_mode mode, rtx op0, rtx target, optab unoptab)\n+widen_leading (scalar_int_mode mode, rtx op0, rtx target, optab unoptab)\n {\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-  if (CLASS_HAS_WIDER_MODES_P (mclass))\n+  opt_scalar_int_mode wider_mode_iter;\n+  FOR_EACH_WIDER_MODE (wider_mode_iter, mode)\n     {\n-      machine_mode wider_mode;\n-      FOR_EACH_WIDER_MODE (wider_mode, mode)\n+      scalar_int_mode wider_mode = wider_mode_iter.require ();\n+      if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n \t{\n-\t  if (optab_handler (unoptab, wider_mode) != CODE_FOR_nothing)\n-\t    {\n-\t      rtx xop0, temp;\n-\t      rtx_insn *last;\n+\t  rtx xop0, temp;\n+\t  rtx_insn *last;\n \n-\t      last = get_last_insn ();\n+\t  last = get_last_insn ();\n \n-\t      if (target == 0)\n-\t\ttarget = gen_reg_rtx (mode);\n-\t      xop0 = widen_operand (op0, wider_mode, mode,\n-\t\t\t\t    unoptab != clrsb_optab, false);\n-\t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n-\t\t\t\t  unoptab != clrsb_optab);\n-\t      if (temp != 0)\n-\t\ttemp = expand_binop\n-\t\t  (wider_mode, sub_optab, temp,\n-\t\t   gen_int_mode (GET_MODE_PRECISION (wider_mode)\n-\t\t\t\t - GET_MODE_PRECISION (mode),\n-\t\t\t\t wider_mode),\n-\t\t   target, true, OPTAB_DIRECT);\n-\t      if (temp == 0)\n-\t\tdelete_insns_since (last);\n+\t  if (target == 0)\n+\t    target = gen_reg_rtx (mode);\n+\t  xop0 = widen_operand (op0, wider_mode, mode,\n+\t\t\t\tunoptab != clrsb_optab, false);\n+\t  temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n+\t\t\t      unoptab != clrsb_optab);\n+\t  if (temp != 0)\n+\t    temp = expand_binop\n+\t      (wider_mode, sub_optab, temp,\n+\t       gen_int_mode (GET_MODE_PRECISION (wider_mode)\n+\t\t\t     - GET_MODE_PRECISION (mode),\n+\t\t\t     wider_mode),\n+\t       target, true, OPTAB_DIRECT);\n+\t  if (temp == 0)\n+\t    delete_insns_since (last);\n \n-\t      return temp;\n-\t    }\n+\t  return temp;\n \t}\n     }\n   return 0;\n@@ -2295,22 +2292,21 @@ expand_doubleword_parity (machine_mode mode, rtx op0, rtx target)\n    as\n \t(lshiftrt:wide (bswap:wide x) ((width wide) - (width narrow))).  */\n static rtx\n-widen_bswap (machine_mode mode, rtx op0, rtx target)\n+widen_bswap (scalar_int_mode mode, rtx op0, rtx target)\n {\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-  machine_mode wider_mode;\n   rtx x;\n   rtx_insn *last;\n+  opt_scalar_int_mode wider_mode_iter;\n \n-  if (!CLASS_HAS_WIDER_MODES_P (mclass))\n-    return NULL_RTX;\n+  FOR_EACH_WIDER_MODE (wider_mode_iter, mode)\n+    if (optab_handler (bswap_optab, wider_mode_iter.require ())\n+\t!= CODE_FOR_nothing)\n+      break;\n \n-  FOR_EACH_WIDER_MODE (wider_mode, mode)\n-    if (optab_handler (bswap_optab, wider_mode) != CODE_FOR_nothing)\n-      goto found;\n-  return NULL_RTX;\n+  if (!wider_mode_iter.exists ())\n+    return NULL_RTX;\n \n- found:\n+  scalar_int_mode wider_mode = wider_mode_iter.require ();\n   last = get_last_insn ();\n \n   x = widen_operand (op0, wider_mode, mode, true, true);\n@@ -2361,42 +2357,40 @@ expand_doubleword_bswap (machine_mode mode, rtx op, rtx target)\n /* Try calculating (parity x) as (and (popcount x) 1), where\n    popcount can also be done in a wider mode.  */\n static rtx\n-expand_parity (machine_mode mode, rtx op0, rtx target)\n+expand_parity (scalar_int_mode mode, rtx op0, rtx target)\n {\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n-  if (CLASS_HAS_WIDER_MODES_P (mclass))\n+  opt_scalar_int_mode wider_mode_iter;\n+  FOR_EACH_MODE_FROM (wider_mode_iter, mode)\n     {\n-      machine_mode wider_mode;\n-      FOR_EACH_MODE_FROM (wider_mode, mode)\n+      scalar_int_mode wider_mode = wider_mode_iter.require ();\n+      if (optab_handler (popcount_optab, wider_mode) != CODE_FOR_nothing)\n \t{\n-\t  if (optab_handler (popcount_optab, wider_mode) != CODE_FOR_nothing)\n-\t    {\n-\t      rtx xop0, temp;\n-\t      rtx_insn *last;\n+\t  rtx xop0, temp;\n+\t  rtx_insn *last;\n \n-\t      last = get_last_insn ();\n+\t  last = get_last_insn ();\n \n-\t      if (target == 0 || GET_MODE (target) != wider_mode)\n-\t\ttarget = gen_reg_rtx (wider_mode);\n+\t  if (target == 0 || GET_MODE (target) != wider_mode)\n+\t    target = gen_reg_rtx (wider_mode);\n \n-\t      xop0 = widen_operand (op0, wider_mode, mode, true, false);\n-\t      temp = expand_unop (wider_mode, popcount_optab, xop0, NULL_RTX,\n-\t\t\t\t  true);\n-\t      if (temp != 0)\n-\t\ttemp = expand_binop (wider_mode, and_optab, temp, const1_rtx,\n-\t\t\t\t     target, true, OPTAB_DIRECT);\n+\t  xop0 = widen_operand (op0, wider_mode, mode, true, false);\n+\t  temp = expand_unop (wider_mode, popcount_optab, xop0, NULL_RTX,\n+\t\t\t      true);\n+\t  if (temp != 0)\n+\t    temp = expand_binop (wider_mode, and_optab, temp, const1_rtx,\n+\t\t\t\t target, true, OPTAB_DIRECT);\n \n-\t      if (temp)\n-\t\t{\n-\t\t  if (mclass != MODE_INT\n-\t\t      || !TRULY_NOOP_TRUNCATION_MODES_P (mode, wider_mode))\n-\t\t    return convert_to_mode (mode, temp, 0);\n-\t\t  else\n-\t\t    return gen_lowpart (mode, temp);\n-\t\t}\n+\t  if (temp)\n+\t    {\n+\t      if (mclass != MODE_INT\n+\t\t  || !TRULY_NOOP_TRUNCATION_MODES_P (mode, wider_mode))\n+\t\treturn convert_to_mode (mode, temp, 0);\n \t      else\n-\t\tdelete_insns_since (last);\n+\t\treturn gen_lowpart (mode, temp);\n \t    }\n+\t  else\n+\t    delete_insns_since (last);\n \t}\n     }\n   return 0;\n@@ -2415,7 +2409,7 @@ expand_parity (machine_mode mode, rtx op0, rtx target)\n    less convenient for expand_ffs anyway.  */\n \n static rtx\n-expand_ctz (machine_mode mode, rtx op0, rtx target)\n+expand_ctz (scalar_int_mode mode, rtx op0, rtx target)\n {\n   rtx_insn *seq;\n   rtx temp;\n@@ -2458,7 +2452,7 @@ expand_ctz (machine_mode mode, rtx op0, rtx target)\n    may have an undefined value in that case.  If they do not give us a\n    convenient value, we have to generate a test and branch.  */\n static rtx\n-expand_ffs (machine_mode mode, rtx op0, rtx target)\n+expand_ffs (scalar_int_mode mode, rtx op0, rtx target)\n {\n   HOST_WIDE_INT val = 0;\n   bool defined_at_zero = false;\n@@ -2715,26 +2709,32 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n   /* Widening (or narrowing) clz needs special treatment.  */\n   if (unoptab == clz_optab)\n     {\n-      temp = widen_leading (mode, op0, target, unoptab);\n-      if (temp)\n-\treturn temp;\n-\n-      if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t  && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n \t{\n-\t  temp = expand_doubleword_clz (mode, op0, target);\n+\t  temp = widen_leading (int_mode, op0, target, unoptab);\n \t  if (temp)\n \t    return temp;\n+\n+\t  if (GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+\t      && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n+\t    {\n+\t      temp = expand_doubleword_clz (int_mode, op0, target);\n+\t      if (temp)\n+\t\treturn temp;\n+\t    }\n \t}\n \n       goto try_libcall;\n     }\n \n   if (unoptab == clrsb_optab)\n     {\n-      temp = widen_leading (mode, op0, target, unoptab);\n-      if (temp)\n-\treturn temp;\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n+\t{\n+\t  temp = widen_leading (int_mode, op0, target, unoptab);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n       goto try_libcall;\n     }\n \n@@ -2806,16 +2806,19 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t  delete_insns_since (last);\n \t}\n \n-      temp = widen_bswap (mode, op0, target);\n-      if (temp)\n-\treturn temp;\n-\n-      if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t  && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n+      if (is_a <scalar_int_mode> (mode, &int_mode))\n \t{\n-\t  temp = expand_doubleword_bswap (mode, op0, target);\n+\t  temp = widen_bswap (int_mode, op0, target);\n \t  if (temp)\n \t    return temp;\n+\n+\t  if (GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+\t      && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n+\t    {\n+\t      temp = expand_doubleword_bswap (mode, op0, target);\n+\t      if (temp)\n+\t\treturn temp;\n+\t    }\n \t}\n \n       goto try_libcall;\n@@ -2916,25 +2919,25 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n     }\n \n   /* Try calculating parity (x) as popcount (x) % 2.  */\n-  if (unoptab == parity_optab)\n+  if (unoptab == parity_optab && is_a <scalar_int_mode> (mode, &int_mode))\n     {\n-      temp = expand_parity (mode, op0, target);\n+      temp = expand_parity (int_mode, op0, target);\n       if (temp)\n \treturn temp;\n     }\n \n   /* Try implementing ffs (x) in terms of clz (x).  */\n-  if (unoptab == ffs_optab)\n+  if (unoptab == ffs_optab && is_a <scalar_int_mode> (mode, &int_mode))\n     {\n-      temp = expand_ffs (mode, op0, target);\n+      temp = expand_ffs (int_mode, op0, target);\n       if (temp)\n \treturn temp;\n     }\n \n   /* Try implementing ctz (x) in terms of clz (x).  */\n-  if (unoptab == ctz_optab)\n+  if (unoptab == ctz_optab && is_a <scalar_int_mode> (mode, &int_mode))\n     {\n-      temp = expand_ctz (mode, op0, target);\n+      temp = expand_ctz (int_mode, op0, target);\n       if (temp)\n \treturn temp;\n     }"}]}