{"sha": "df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY4YTFkMjhhNTBmZTMyZGM4N2Y5ODliYTBhNzJmMDAyMjdhMzhlYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-06-10T15:41:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-06-10T15:41:52Z"}, "message": "re PR target/56564 (movdqa on possibly-8-byte-aligned struct with -O3)\n\n\tPR target/56564\n\t* varasm.c (align_variable): Don't use DATA_ALIGNMENT or\n\tCONSTANT_ALIGNMENT if !decl_binds_to_current_def_p (decl).\n\tUse DATA_ABI_ALIGNMENT for that case instead if defined.\n\t(get_variable_align): New function.\n\t(get_variable_section, emit_bss, emit_common,\n\tassemble_variable_contents, place_block_symbol): Use\n\tget_variable_align instead of DECL_ALIGN.\n\t(assemble_noswitch_variable): Add align argument, use it\n\tinstead of DECL_ALIGN.\n\t(assemble_variable): Adjust caller.  Use get_variable_align\n\tinstead of DECL_ALIGN.\n\t* config/i386/i386.h (DATA_ALIGNMENT): Adjust x86_data_alignment\n\tcaller.\n\t(DATA_ABI_ALIGNMENT): Define.\n\t* config/i386/i386-protos.h (x86_data_alignment): Adjust prototype.\n\t* config/i386/i386.c (x86_data_alignment): Add opt argument.  If\n\topt is false, only return the psABI mandated alignment increase.\n\t* config/c6x/c6x.h (DATA_ALIGNMENT): Renamed to...\n\t(DATA_ABI_ALIGNMENT): ... this.\n\t* config/mmix/mmix.h (DATA_ALIGNMENT): Renamed to...\n\t(DATA_ABI_ALIGNMENT): ... this.\n\t* config/mmix/mmix.c (mmix_data_alignment): Adjust function comment.\n\t* config/s390/s390.h (DATA_ALIGNMENT): Renamed to...\n\t(DATA_ABI_ALIGNMENT): ... this.\n\t* doc/tm.texi.in (DATA_ABI_ALIGNMENT): Document.\n\t* doc/tm.texi: Regenerated.\n\n\t* gcc.target/i386/pr56564-1.c: New test.\n\t* gcc.target/i386/pr56564-2.c: New test.\n\t* gcc.target/i386/pr56564-3.c: New test.\n\t* gcc.target/i386/pr56564-4.c: New test.\n\t* gcc.target/i386/avx256-unaligned-load-4.c: Add -fno-common.\n\t* gcc.target/i386/avx256-unaligned-store-1.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-3.c: Likewise.\n\t* gcc.target/i386/avx256-unaligned-store-4.c: Likewise.\n\t* gcc.target/i386/vect-sizes-1.c: Likewise.\n\t* gcc.target/i386/memcpy-1.c: Likewise.\n\t* gcc.dg/vect/costmodel/i386/costmodel-vect-31.c (tmp): Initialize.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c (tmp): Likewise.\n\nFrom-SVN: r199898", "tree": {"sha": "7f5e2fcbb34a0e22a4e842599006ba571e4aad8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f5e2fcbb34a0e22a4e842599006ba571e4aad8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57b29ca675a87d5dd79371925f19f945990a2bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b29ca675a87d5dd79371925f19f945990a2bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b29ca675a87d5dd79371925f19f945990a2bea"}], "stats": {"total": 327, "additions": 289, "deletions": 38}, "files": [{"sha": "cf75717403313ef4b80c162d61dee49af371602f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,3 +1,33 @@\n+2013-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/56564\n+\t* varasm.c (align_variable): Don't use DATA_ALIGNMENT or\n+\tCONSTANT_ALIGNMENT if !decl_binds_to_current_def_p (decl).\n+\tUse DATA_ABI_ALIGNMENT for that case instead if defined.\n+\t(get_variable_align): New function.\n+\t(get_variable_section, emit_bss, emit_common,\n+\tassemble_variable_contents, place_block_symbol): Use\n+\tget_variable_align instead of DECL_ALIGN.\n+\t(assemble_noswitch_variable): Add align argument, use it\n+\tinstead of DECL_ALIGN.\n+\t(assemble_variable): Adjust caller.  Use get_variable_align\n+\tinstead of DECL_ALIGN.\n+\t* config/i386/i386.h (DATA_ALIGNMENT): Adjust x86_data_alignment\n+\tcaller.\n+\t(DATA_ABI_ALIGNMENT): Define.\n+\t* config/i386/i386-protos.h (x86_data_alignment): Adjust prototype.\n+\t* config/i386/i386.c (x86_data_alignment): Add opt argument.  If\n+\topt is false, only return the psABI mandated alignment increase.\n+\t* config/c6x/c6x.h (DATA_ALIGNMENT): Renamed to...\n+\t(DATA_ABI_ALIGNMENT): ... this.\n+\t* config/mmix/mmix.h (DATA_ALIGNMENT): Renamed to...\n+\t(DATA_ABI_ALIGNMENT): ... this.\n+\t* config/mmix/mmix.c (mmix_data_alignment): Adjust function comment.\n+\t* config/s390/s390.h (DATA_ALIGNMENT): Renamed to...\n+\t(DATA_ABI_ALIGNMENT): ... this.\n+\t* doc/tm.texi.in (DATA_ABI_ALIGNMENT): Document.\n+\t* doc/tm.texi: Regenerated.\n+\n 2013-06-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_emit_xfloating_compare): Also use"}, {"sha": "c30a9718e760df7926bc219c4fa36b219a5088ac", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -134,7 +134,7 @@ extern c6x_cpu_t c6x_arch;\n    Really only externally visible arrays must be aligned this way, as\n    only those are directly visible from another compilation unit.  But\n    we don't have that information available here.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+#define DATA_ABI_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n   (((ALIGN) < BITS_PER_UNIT * 8 && TREE_CODE (TYPE) == ARRAY_TYPE)\t\\\n    ? BITS_PER_UNIT * 8 : (ALIGN))\n "}, {"sha": "f228e87a2e4afadf1334d8580128e7b731a548b6", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -207,7 +207,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n #endif\t/* RTX_CODE  */\n \n #ifdef TREE_CODE\n-extern int ix86_data_alignment (tree, int);\n+extern int ix86_data_alignment (tree, int, bool);\n extern unsigned int ix86_local_alignment (tree, enum machine_mode,\n \t\t\t\t\t  unsigned int);\n extern unsigned int ix86_minimum_alignment (tree, enum machine_mode,"}, {"sha": "45e88996ad286ef4bcd9d93feb06b46145034328", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -25375,11 +25375,12 @@ ix86_constant_alignment (tree exp, int align)\n    instead of that alignment to align the object.  */\n \n int\n-ix86_data_alignment (tree type, int align)\n+ix86_data_alignment (tree type, int align, bool opt)\n {\n   int max_align = optimize_size ? BITS_PER_WORD : MIN (256, MAX_OFILE_ALIGNMENT);\n \n-  if (AGGREGATE_TYPE_P (type)\n+  if (opt\n+      && AGGREGATE_TYPE_P (type)\n       && TYPE_SIZE (type)\n       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n       && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= (unsigned) max_align\n@@ -25391,14 +25392,17 @@ ix86_data_alignment (tree type, int align)\n      to 16byte boundary.  */\n   if (TARGET_64BIT)\n     {\n-      if (AGGREGATE_TYPE_P (type)\n-\t   && TYPE_SIZE (type)\n-\t   && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t   && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= 128\n-\t       || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 128)\n+      if ((opt ? AGGREGATE_TYPE_P (type) : TREE_CODE (type) == ARRAY_TYPE)\n+\t  && TYPE_SIZE (type)\n+\t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t  && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= 128\n+\t      || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 128)\n \treturn 128;\n     }\n \n+  if (!opt)\n+    return align;\n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       if (TYPE_MODE (TREE_TYPE (type)) == DFmode && align < 64)"}, {"sha": "7d940f98804d9f67f712f8b9d3d81d780b0c61a2", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -859,7 +859,18 @@ enum target_cpu_default\n    cause character arrays to be word-aligned so that `strcpy' calls\n    that copy constants to character arrays can be done inline.  */\n \n-#define DATA_ALIGNMENT(TYPE, ALIGN) ix86_data_alignment ((TYPE), (ALIGN))\n+#define DATA_ALIGNMENT(TYPE, ALIGN) \\\n+  ix86_data_alignment ((TYPE), (ALIGN), true)\n+\n+/* Similar to DATA_ALIGNMENT, but for the cases where the ABI mandates\n+   some alignment increase, instead of optimization only purposes.  E.g.\n+   AMD x86-64 psABI says that variables with array type larger than 15 bytes\n+   must be aligned to 16 byte boundaries.\n+\n+   If this macro is not defined, then ALIGN is used.  */\n+\n+#define DATA_ABI_ALIGNMENT(TYPE, ALIGN) \\\n+  ix86_data_alignment ((TYPE), (ALIGN), false)\n \n /* If defined, a C expression to compute the alignment for a local\n    variable.  TYPE is the data type, and ALIGN is the alignment that"}, {"sha": "bd37067dfc49ac3fd02a88e8e697c738ee793e55", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -313,7 +313,7 @@ mmix_init_machine_status (void)\n   return ggc_alloc_cleared_machine_function ();\n }\n \n-/* DATA_ALIGNMENT.\n+/* DATA_ABI_ALIGNMENT.\n    We have trouble getting the address of stuff that is located at other\n    than 32-bit alignments (GETA requirements), so try to give everything\n    at least 32-bit alignment.  */"}, {"sha": "c5edc5777a999890b1252bfd1f79696b851651e4", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -164,7 +164,7 @@ struct GTY(()) machine_function\n /* Copied from elfos.h.  */\n #define MAX_OFILE_ALIGNMENT (32768 * 8)\n \n-#define DATA_ALIGNMENT(TYPE, BASIC_ALIGN) \\\n+#define DATA_ABI_ALIGNMENT(TYPE, BASIC_ALIGN) \\\n  mmix_data_alignment (TYPE, BASIC_ALIGN)\n \n #define CONSTANT_ALIGNMENT(CONSTANT, BASIC_ALIGN) \\"}, {"sha": "b0e530f0ed4777ee5f2570cacb585a428ac2bda3", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -221,7 +221,7 @@ enum processor_flags\n \n /* Alignment on even addresses for LARL instruction.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n-#define DATA_ALIGNMENT(TYPE, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n+#define DATA_ABI_ALIGNMENT(TYPE, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n \n /* Alignment is not required by the hardware.  */\n #define STRICT_ALIGNMENT 0"}, {"sha": "f030b56ef6daeab9644cd2b356433abf824e38dc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1078,6 +1078,15 @@ arrays to be word-aligned so that @code{strcpy} calls that copy\n constants to character arrays can be done inline.\n @end defmac\n \n+@defmac DATA_ABI_ALIGNMENT (@var{type}, @var{basic-align})\n+Similar to @code{DATA_ALIGNMENT}, but for the cases where the ABI mandates\n+some alignment increase, instead of optimization only purposes.  E.g.@\n+AMD x86-64 psABI says that variables with array type larger than 15 bytes\n+must be aligned to 16 byte boundaries.\n+\n+If this macro is not defined, then @var{basic-align} is used.\n+@end defmac\n+\n @defmac CONSTANT_ALIGNMENT (@var{constant}, @var{basic-align})\n If defined, a C expression to compute the alignment given to a constant\n that is being placed in memory.  @var{constant} is the constant and"}, {"sha": "cc25fec495ef3f6c94928bdcb31df4bc4d8d63c8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1062,6 +1062,15 @@ arrays to be word-aligned so that @code{strcpy} calls that copy\n constants to character arrays can be done inline.\n @end defmac\n \n+@defmac DATA_ABI_ALIGNMENT (@var{type}, @var{basic-align})\n+Similar to @code{DATA_ALIGNMENT}, but for the cases where the ABI mandates\n+some alignment increase, instead of optimization only purposes.  E.g.@\n+AMD x86-64 psABI says that variables with array type larger than 15 bytes\n+must be aligned to 16 byte boundaries.\n+\n+If this macro is not defined, then @var{basic-align} is used.\n+@end defmac\n+\n @defmac CONSTANT_ALIGNMENT (@var{constant}, @var{basic-align})\n If defined, a C expression to compute the alignment given to a constant\n that is being placed in memory.  @var{constant} is the constant and"}, {"sha": "1727138fb98fe3560648c4716a5dbb1e73868a09", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,3 +1,19 @@\n+2013-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/56564\n+\t* gcc.target/i386/pr56564-1.c: New test.\n+\t* gcc.target/i386/pr56564-2.c: New test.\n+\t* gcc.target/i386/pr56564-3.c: New test.\n+\t* gcc.target/i386/pr56564-4.c: New test.\n+\t* gcc.target/i386/avx256-unaligned-load-4.c: Add -fno-common.\n+\t* gcc.target/i386/avx256-unaligned-store-1.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-3.c: Likewise.\n+\t* gcc.target/i386/avx256-unaligned-store-4.c: Likewise.\n+\t* gcc.target/i386/vect-sizes-1.c: Likewise.\n+\t* gcc.target/i386/memcpy-1.c: Likewise.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-31.c (tmp): Initialize.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c (tmp): Likewise.\n+\n 2013-06-10  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* g++.dg/abi/forced.C: Extend current handling of Linux-based x86"}, {"sha": "137267619f2f3cc62547fa92a0fd24c57cd0f6a0", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -18,7 +18,7 @@ struct s{\n   struct t e;   /* unaligned (offset 2N+4N+4 B) */\n };\n  \n-struct s tmp;\n+struct s tmp = { 1 };\n \n int main1 ()\n {  "}, {"sha": "137267619f2f3cc62547fa92a0fd24c57cd0f6a0", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -18,7 +18,7 @@ struct s{\n   struct t e;   /* unaligned (offset 2N+4N+4 B) */\n };\n  \n-struct s tmp;\n+struct s tmp = { 1 };\n \n int main1 ()\n {  "}, {"sha": "c5afa061963022434e456085f3b6b8fe1a269ba6", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-load-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-load-4.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\" } */\n+/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store -fno-common\" } */\n \n #define N 1024\n "}, {"sha": "77eaa422e4b9c6bc45e38a2a4049394d601bf86f", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-1.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store\" } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store -fno-common\" } */\n \n #define N 1024\n "}, {"sha": "e6744a892bc4fb81c77f77c30269c6adaf27784f", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store -mtune=generic\" } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store -mtune=generic -fno-common\" } */\n \n #define N 1024\n "}, {"sha": "85682452fae89e14f2177c60339fde4cbf0d8e24", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-4.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\" } */\n+/* { dg-options \"-O3 -dp -mavx -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store -fno-common\" } */\n \n #define N 1024\n "}, {"sha": "b716c5d958364cd1543e3a8f07c87df7eab332b3", "filename": "gcc/testsuite/gcc.target/i386/memcpy-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-1.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target ia32 } */\n-/* { dg-options \"-O2 -march=pentiumpro -minline-all-stringops\" } */\n+/* { dg-options \"-O2 -march=pentiumpro -minline-all-stringops -fno-common\" } */\n /* { dg-final { scan-assembler \"rep\" } } */\n /* { dg-final { scan-assembler \"movs\" } } */\n /* { dg-final { scan-assembler-not \"test\" } } */"}, {"sha": "7287de00f6d66a479b6ea2d6e0a0825bb8e8e2c7", "filename": "gcc/testsuite/gcc.target/i386/pr56564-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-1.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -0,0 +1,25 @@\n+/* PR target/56564 */\n+/* { dg-do compile { target { fpic && lp64 } } } */\n+/* { dg-options \"-O3 -fpic -fdump-tree-optimized\" } */\n+\n+struct S { long a, b; } s = { 5, 6 };\n+char t[16] = { 7 };\n+\n+int\n+foo (void)\n+{\n+  return ((__UINTPTR_TYPE__) &s) & 15;\n+}\n+\n+int\n+bar (void)\n+{\n+  return ((__UINTPTR_TYPE__) &t[0]) & 15;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"&t\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]s:\" { target { *-*-linux* } } } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]t:\" { target { *-*-linux* } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fc89a4ccafc6d85a082f4a1173e794a164eaac46", "filename": "gcc/testsuite/gcc.target/i386/pr56564-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-2.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -0,0 +1,25 @@\n+/* PR target/56564 */\n+/* { dg-do compile { target { *-*-linux* && lp64 } } } */\n+/* { dg-options \"-O3 -fno-pic -fdump-tree-optimized\" } */\n+\n+struct S { long a, b; } s = { 5, 6 };\n+char t[16] = { 7 };\n+\n+int\n+foo (void)\n+{\n+  return ((__UINTPTR_TYPE__) &s) & 15;\n+}\n+\n+int\n+bar (void)\n+{\n+  return ((__UINTPTR_TYPE__) &t[0]) & 15;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&s\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"&t\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 2 \"optimized\" } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]s:\" { target { *-*-linux* } } } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]t:\" { target { *-*-linux* } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "cf39295e6e06878e60334e3c49dcd7016b00b303", "filename": "gcc/testsuite/gcc.target/i386/pr56564-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-3.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -0,0 +1,28 @@\n+/* PR target/56564 */\n+/* { dg-do compile { target { fpic && lp64 } } } */\n+/* { dg-options \"-O3 -fpic -fdump-tree-optimized\" } */\n+\n+__thread struct S { long a, b; } s = { 5, 6 };\n+__thread char t[16] = { 7 };\n+\n+int\n+foo (void)\n+{\n+  return ((__UINTPTR_TYPE__) &s) & 15;\n+}\n+\n+/* For backwards compatibility we don't assume that t must\n+   be aligned to 16 bytes, but align it anyway.  */\n+\n+int\n+bar (void)\n+{\n+  return ((__UINTPTR_TYPE__) &t[0]) & 15;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"&t\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 0 \"optimized\" } } */\n+/* { dg-final { scan-assembler-not \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]s:\" { target { *-*-linux* } } } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]t:\" { target { *-*-linux* } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a0b3d3d3940bb4824085842c2e52651eaa4b66ad", "filename": "gcc/testsuite/gcc.target/i386/pr56564-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56564-4.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -0,0 +1,22 @@\n+/* PR target/56564 */\n+/* { dg-do compile { target { *-*-linux* && lp64 } } } */\n+/* { dg-options \"-O3 -fno-pic -fdump-tree-optimized\" } */\n+\n+__thread struct S { long a, b; } s = { 5, 6 };\n+__thread char t[16] = { 7 };\n+\n+int\n+foo (void)\n+{\n+  return ((__UINTPTR_TYPE__) &s) & 15;\n+}\n+\n+int\n+bar (void)\n+{\n+  return ((__UINTPTR_TYPE__) &t[0]) & 15;\n+}\n+\n+/* { dg-final { scan-assembler-not \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]s:\" { target { *-*-linux* } } } } */\n+/* { dg-final { scan-assembler \".align\\[ \\t]*16\\[^:]*\\[\\n\\r]t:\" { target { *-*-linux* } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6ca38d2fe4768fa36641ae422d345ed42dd884c4", "filename": "gcc/testsuite/gcc.target/i386/vect-sizes-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-sizes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-sizes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-sizes-1.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -ffast-math -mavx -mtune=generic\" } */\n+/* { dg-options \"-O3 -ffast-math -mavx -mtune=generic -fno-common\" } */\n \n double a[1024];\n "}, {"sha": "cd0235fa4510de461ac61e16d91495ce5ab04efe", "filename": "gcc/varasm.c", "status": "modified", "additions": 89, "deletions": 17, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df8a1d28a50fe32dc87f989ba0a72f00227a38ec/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=df8a1d28a50fe32dc87f989ba0a72f00227a38ec", "patch": "@@ -966,13 +966,80 @@ align_variable (tree decl, bool dont_output_data)\n       align = MAX_OFILE_ALIGNMENT;\n     }\n \n-  /* On some machines, it is good to increase alignment sometimes.  */\n   if (! DECL_USER_ALIGN (decl))\n     {\n+#ifdef DATA_ABI_ALIGNMENT\n+      unsigned int data_abi_align\n+\t= DATA_ABI_ALIGNMENT (TREE_TYPE (decl), align);\n+      /* For backwards compatibility, don't assume the ABI alignment for\n+\t TLS variables.  */\n+      if (! DECL_THREAD_LOCAL_P (decl) || data_abi_align <= BITS_PER_WORD)\n+\talign = data_abi_align;\n+#endif\n+\n+      /* On some machines, it is good to increase alignment sometimes.\n+\t But as DECL_ALIGN is used both for actually emitting the variable\n+\t and for code accessing the variable as guaranteed alignment, we\n+\t can only increase the alignment if it is a performance optimization\n+\t if the references to it must bind to the current definition.  */\n+      if (decl_binds_to_current_def_p (decl))\n+\t{\n+#ifdef DATA_ALIGNMENT\n+\t  unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n+\t  /* Don't increase alignment too much for TLS variables - TLS space\n+\t     is too precious.  */\n+\t  if (! DECL_THREAD_LOCAL_P (decl) || data_align <= BITS_PER_WORD)\n+\t    align = data_align;\n+#endif\n+#ifdef CONSTANT_ALIGNMENT\n+\t  if (DECL_INITIAL (decl) != 0\n+\t      && DECL_INITIAL (decl) != error_mark_node)\n+\t    {\n+\t      unsigned int const_align\n+\t\t= CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n+\t      /* Don't increase alignment too much for TLS variables - TLS\n+\t\t space is too precious.  */\n+\t      if (! DECL_THREAD_LOCAL_P (decl) || const_align <= BITS_PER_WORD)\n+\t\talign = const_align;\n+\t    }\n+#endif\n+\t}\n+    }\n+\n+  /* Reset the alignment in case we have made it tighter, so we can benefit\n+     from it in get_pointer_alignment.  */\n+  DECL_ALIGN (decl) = align;\n+}\n+\n+/* Return DECL_ALIGN (decl), possibly increased for optimization purposes\n+   beyond what align_variable returned.  */\n+\n+static unsigned int\n+get_variable_align (tree decl)\n+{\n+  unsigned int align = DECL_ALIGN (decl);\n+\n+  /* For user aligned vars or static vars align_variable already did\n+     everything.  */\n+  if (DECL_USER_ALIGN (decl) || !TREE_PUBLIC (decl))\n+    return align;\n+\n+#ifdef DATA_ABI_ALIGNMENT\n+  if (DECL_THREAD_LOCAL_P (decl))\n+    align = DATA_ABI_ALIGNMENT (TREE_TYPE (decl), align);\n+#endif\n+\n+  /* For decls that bind to the current definition, align_variable\n+     did also everything, except for not assuming ABI required alignment\n+     of TLS variables.  For other vars, increase the alignment here\n+     as an optimization.  */\n+  if (!decl_binds_to_current_def_p (decl))\n+    {\n+      /* On some machines, it is good to increase alignment sometimes.  */\n #ifdef DATA_ALIGNMENT\n       unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n       /* Don't increase alignment too much for TLS variables - TLS space\n-\t is too precious.  */\n+         is too precious.  */\n       if (! DECL_THREAD_LOCAL_P (decl) || data_align <= BITS_PER_WORD)\n \talign = data_align;\n #endif\n@@ -986,12 +1053,10 @@ align_variable (tree decl, bool dont_output_data)\n \t  if (! DECL_THREAD_LOCAL_P (decl) || const_align <= BITS_PER_WORD)\n \t    align = const_align;\n \t}\n-#endif\n     }\n+#endif\n \n-  /* Reset the alignment in case we have made it tighter, so we can benefit\n-     from it in get_pointer_alignment.  */\n-  DECL_ALIGN (decl) = align;\n+  return align;\n }\n \n /* Return the section into which the given VAR_DECL or CONST_DECL\n@@ -1043,7 +1108,8 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n \treturn bss_noswitch_section;\n     }\n \n-  return targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n+  return targetm.asm_out.select_section (decl, reloc,\n+\t\t\t\t\t get_variable_align (decl));\n }\n \n /* Return the block into which object_block DECL should be placed.  */\n@@ -1780,7 +1846,8 @@ emit_bss (tree decl ATTRIBUTE_UNUSED,\n \t  unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n {\n #if defined ASM_OUTPUT_ALIGNED_BSS\n-  ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size, DECL_ALIGN (decl));\n+  ASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size,\n+\t\t\t  get_variable_align (decl));\n   return true;\n #endif\n }\n@@ -1796,10 +1863,11 @@ emit_common (tree decl ATTRIBUTE_UNUSED,\n {\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n   ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name,\n-\t\t\t\t  size, DECL_ALIGN (decl));\n+\t\t\t\t  size, get_variable_align (decl));\n   return true;\n #elif defined ASM_OUTPUT_ALIGNED_COMMON\n-  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size, DECL_ALIGN (decl));\n+  ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, name, size,\n+\t\t\t     get_variable_align (decl));\n   return true;\n #else\n   ASM_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n@@ -1828,7 +1896,8 @@ emit_tls_common (tree decl ATTRIBUTE_UNUSED,\n    NAME is the name of DECL's SYMBOL_REF.  */\n \n static void\n-assemble_noswitch_variable (tree decl, const char *name, section *sect)\n+assemble_noswitch_variable (tree decl, const char *name, section *sect,\n+\t\t\t    unsigned int align)\n {\n   unsigned HOST_WIDE_INT size, rounded;\n \n@@ -1850,7 +1919,7 @@ assemble_noswitch_variable (tree decl, const char *name, section *sect)\n \t     * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n \n   if (!sect->noswitch.callback (decl, name, size, rounded)\n-      && (unsigned HOST_WIDE_INT) DECL_ALIGN_UNIT (decl) > rounded)\n+      && (unsigned HOST_WIDE_INT) (align / BITS_PER_UNIT) > rounded)\n     warning (0, \"requested alignment for %q+D is greater than \"\n \t     \"implemented alignment of %wu\", decl, rounded);\n }\n@@ -1880,7 +1949,7 @@ assemble_variable_contents (tree decl, const char *name,\n \t/* Output the actual data.  */\n \toutput_constant (DECL_INITIAL (decl),\n \t\t\t tree_low_cst (DECL_SIZE_UNIT (decl), 1),\n-\t\t\t DECL_ALIGN (decl));\n+\t\t\t get_variable_align (decl));\n       else\n \t/* Leave space for it.  */\n \tassemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));\n@@ -1904,6 +1973,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   const char *name;\n   rtx decl_rtl, symbol;\n   section *sect;\n+  unsigned int align;\n   bool asan_protected = false;\n \n   /* This function is supposed to handle VARIABLES.  Ensure we have one.  */\n@@ -2003,6 +2073,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   set_mem_align (decl_rtl, DECL_ALIGN (decl));\n \n+  align = get_variable_align (decl);\n+\n   if (TREE_PUBLIC (decl))\n     maybe_assemble_visibility (decl);\n \n@@ -2032,12 +2104,12 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n       place_block_symbol (symbol);\n     }\n   else if (SECTION_STYLE (sect) == SECTION_NOSWITCH)\n-    assemble_noswitch_variable (decl, name, sect);\n+    assemble_noswitch_variable (decl, name, sect, align);\n   else\n     {\n       switch_to_section (sect);\n-      if (DECL_ALIGN (decl) > BITS_PER_UNIT)\n-\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));\n+      if (align > BITS_PER_UNIT)\n+\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n       assemble_variable_contents (decl, name, dont_output_data);\n       if (asan_protected)\n \t{\n@@ -6959,7 +7031,7 @@ place_block_symbol (rtx symbol)\n   else\n     {\n       decl = SYMBOL_REF_DECL (symbol);\n-      alignment = DECL_ALIGN (decl);\n+      alignment = get_variable_align (decl);\n       size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n       if (flag_asan && asan_protect_global (decl))\n \t{"}]}