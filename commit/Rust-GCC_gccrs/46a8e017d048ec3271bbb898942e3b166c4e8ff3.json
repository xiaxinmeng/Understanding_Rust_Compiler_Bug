{"sha": "46a8e017d048ec3271bbb898942e3b166c4e8ff3", "node_id": "C_kwDOANBUbNoAKDQ2YThlMDE3ZDA0OGVjMzI3MWJiYjg5ODk0MmUzYjE2NmM0ZThmZjM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-06T11:56:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-17T10:36:35Z"}, "message": "Vectorization of first-order recurrences\n\nThe following picks up the prototype by Ju-Zhe Zhong for vectorizing\nfirst order recurrences.  That solves two TSVC missed optimization PRs.\n\nThere's a new scalar cycle def kind, vect_first_order_recurrence\nand it's handling of the backedge value vectorization is complicated\nby the fact that the vectorized value isn't the PHI but instead\na (series of) permute(s) shifting in the recurring value from the\nprevious iteration.  I've implemented this by creating both the\nsingle vectorized PHI and the series of permutes when vectorizing\nthe scalar PHI but leave the backedge values in both unassigned.\nThe backedge values are (for the testcases) computed by a load\nwhich is also the place after which the permutes are inserted.\nThat placement also restricts the cases we can handle (without\nresorting to code motion).\n\nI added both costing and SLP handling though SLP handling is\nrestricted to the case where a single vectorized PHI is enough.\n\nMissing is epilogue handling - while prologue peeling would\nbe handled transparently by adjusting iv_phi_p the epilogue\ncase doesn't work with just inserting a scalar LC PHI since\nthat a) keeps the scalar load live and b) that loads is the\nwrong one, it has to be the last, much like when we'd vectorize\nthe LC PHI as live operation.  Unfortunately LIVE\ncompute/analysis happens too early before we decide on\npeeling.  When using fully masked loop vectorization the\nvect-recurr-6.c works as expected though.\n\nI have tested this on x86_64 for now, but since epilogue\nhandling is missing there's probably no practical cases.\nMy prototype WHILE_ULT AVX512 patch can handle vect-recurr-6.c\njust fine but I didn't feel like running SPEC within SDE nor\nis the WHILE_ULT patch complete enough.\n\n\tPR tree-optimization/99409\n\tPR tree-optimization/99394\n\t* tree-vectorizer.h (vect_def_type::vect_first_order_recurrence): Add.\n\t(stmt_vec_info_type::recurr_info_type): Likewise.\n\t(vectorizable_recurr): New function.\n\t* tree-vect-loop.cc (vect_phi_first_order_recurrence_p): New\n\tfunction.\n\t(vect_analyze_scalar_cycles_1): Look for first order\n\trecurrences.\n\t(vect_analyze_loop_operations): Handle them.\n\t(vect_transform_loop): Likewise.\n\t(vectorizable_recurr): New function.\n\t(maybe_set_vectorized_backedge_value): Handle the backedge value\n\tsetting in the first order recurrence PHI and the permutes.\n\t* tree-vect-stmts.cc (vect_analyze_stmt): Handle first order\n\trecurrences.\n\t(vect_transform_stmt): Likewise.\n\t(vect_is_simple_use): Likewise.\n\t(vect_is_simple_use): Likewise.\n\t* tree-vect-slp.cc (vect_get_and_check_slp_defs): Likewise.\n\t(vect_build_slp_tree_2): Likewise.\n\t(vect_schedule_scc): Handle the backedge value setting in the\n\tfirst order recurrence PHI and the permutes.\n\n\t* gcc.dg/vect/vect-recurr-1.c: New testcase.\n\t* gcc.dg/vect/vect-recurr-2.c: Likewise.\n\t* gcc.dg/vect/vect-recurr-3.c: Likewise.\n\t* gcc.dg/vect/vect-recurr-4.c: Likewise.\n\t* gcc.dg/vect/vect-recurr-5.c: Likewise.\n\t* gcc.dg/vect/vect-recurr-6.c: Likewise.\n\t* gcc.dg/vect/tsvc/vect-tsvc-s252.c: Un-XFAIL.\n\t* gcc.dg/vect/tsvc/vect-tsvc-s254.c: Likewise.\n\t* gcc.dg/vect/tsvc/vect-tsvc-s291.c: Likewise.\n\nCo-authored-by: Ju-Zhe Zhong <juzhe.zhong@rivai.ai>", "tree": {"sha": "e6b1a35d4364b763d6ca815781a84d61dd46dff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6b1a35d4364b763d6ca815781a84d61dd46dff2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a8e017d048ec3271bbb898942e3b166c4e8ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a8e017d048ec3271bbb898942e3b166c4e8ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a8e017d048ec3271bbb898942e3b166c4e8ff3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a8e017d048ec3271bbb898942e3b166c4e8ff3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acdb24166d13d87c374e578d2ad5d58249171930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acdb24166d13d87c374e578d2ad5d58249171930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acdb24166d13d87c374e578d2ad5d58249171930"}], "stats": {"total": 586, "additions": 558, "deletions": 28}, "files": [{"sha": "83eaa7a8ff5e9184194649abbe316ab3ca0f4406", "filename": "gcc/testsuite/gcc.dg/vect/tsvc/vect-tsvc-s252.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s252.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s252.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s252.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -40,4 +40,4 @@ int main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "06e9b0a849dc412a155cc08af95681cea38f3e1a", "filename": "gcc/testsuite/gcc.dg/vect/tsvc/vect-tsvc-s254.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s254.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s254.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s254.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -39,4 +39,4 @@ int main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "91cdc121095efe00d87124165d6185ea0390b9d7", "filename": "gcc/testsuite/gcc.dg/vect/tsvc/vect-tsvc-s291.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s291.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s291.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s291.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -39,4 +39,4 @@ int main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "6eb59fdf854b042b2afcb27056317ceac76d43fa", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-1.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, int * __restrict__ b, int * __restrict__ c)\n+{\n+  int t = *c;\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      b[i] = a[i] - t;\n+      t = a[i];\n+    }\n+}\n+\n+int a[64], b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c);\n+  for (int i = 1; i < 64; ++i)\n+    if (b[i] != a[i] - a[i-1])\n+      abort ();\n+  if (b[0] != -7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } } */"}, {"sha": "97efaaa38bce3446ed3f9de348708a38801f09d3", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-2.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, short * __restrict__ b, int * __restrict__ c)\n+{\n+  int t = *c;\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      b[i] = a[i] - t;\n+      t = a[i];\n+    }\n+}\n+\n+int a[64];\n+short b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c);\n+  for (int i = 1; i < 64; ++i)\n+    if (b[i] != a[i] - a[i-1])\n+      abort ();\n+  if (b[0] != -7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } } */"}, {"sha": "621a5d8a25717d17ec02863fa50497a005216b9f", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-3.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, signed char * __restrict__ b, int * __restrict__ c)\n+{\n+  int t = *c;\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      b[i] = a[i] - t;\n+      t = a[i];\n+    }\n+}\n+\n+int a[64];\n+signed char b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c);\n+  for (int i = 1; i < 64; ++i)\n+    if (b[i] != a[i] - a[i-1])\n+      abort ();\n+  if (b[0] != -7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } } */"}, {"sha": "f6dbc494a6279155af83f7c5035155d6b12e760b", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-4.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-4.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, int * __restrict__ b, int * __restrict__ c)\n+{\n+  int t1 = *c;\n+  int t2 = *c;\n+  for (int i = 0; i < 64; i+=2)\n+    {\n+      b[i] = a[i] - t1;\n+      t1 = a[i];\n+      b[i+1] = a[i+1] - t2;\n+      t2 = a[i+1];\n+    }\n+}\n+\n+int a[64], b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c);\n+  for (int i = 2; i < 64; i+=2)\n+    if (b[i] != a[i] - a[i-2]\n+\t|| b[i+1] != a[i+1] - a[i-1])\n+      abort ();\n+  if (b[0] != -7 || b[1] != -6)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } } */"}, {"sha": "19c56df9e8331e0a4601a99abd3a65248782a7c1", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-5.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-5.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, short * __restrict__ b, int * __restrict__ c)\n+{\n+  int t1 = *c;\n+  int t2 = *c;\n+  for (int i = 0; i < 64; i+=2)\n+    {\n+      b[i] = a[i] - t1;\n+      t1 = a[i];\n+      b[i+1] = a[i+1] - t2;\n+      t2 = a[i+1];\n+    }\n+}\n+\n+int a[64];\n+short b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c);\n+  for (int i = 2; i < 64; i+=2)\n+    if (b[i] != a[i] - a[i-2]\n+\t|| b[i+1] != a[i+1] - a[i-1])\n+      abort ();\n+  if (b[0] != -7 || b[1] != -6)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } } */"}, {"sha": "e7712680853a2eeb50d2df35d89ac39c5eb0e41d", "filename": "gcc/testsuite/gcc.dg/vect/vect-recurr-6.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-recurr-6.c?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noipa))\n+foo (int * __restrict__ a, int * __restrict__ b, int * __restrict__ c, int n)\n+{\n+  int t = *c;\n+  for (int i = 0; i < n; ++i)\n+    {\n+      b[i] = a[i] - t;\n+      t = a[i];\n+    }\n+}\n+\n+int a[64], b[64];\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      a[i] = i;\n+      __asm__ volatile (\"\" ::: \"memory\");\n+    }\n+  int c = 7;\n+  foo (a, b, &c, 63);\n+  for (int i = 1; i < 63; ++i)\n+    if (b[i] != a[i] - a[i-1])\n+      abort ();\n+  if (b[0] != -7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* ???  We miss epilogue handling for first order recurrences.  */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" { target vect_fully_masked } } } */"}, {"sha": "63e86540d12eb3e2e309d80f8b60f81ac82c1017", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 264, "deletions": 17, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -529,6 +529,45 @@ vect_inner_phi_in_double_reduction_p (loop_vec_info loop_vinfo, gphi *phi)\n   return false;\n }\n \n+/* Returns true if Phi is a first-order recurrence. A first-order\n+   recurrence is a non-reduction recurrence relation in which the value of\n+   the recurrence in the current loop iteration equals a value defined in\n+   the previous iteration.  */\n+\n+static bool\n+vect_phi_first_order_recurrence_p (loop_vec_info loop_vinfo, class loop *loop,\n+\t\t\t\t   gphi *phi)\n+{\n+  /* Ensure the loop latch definition is from within the loop.  */\n+  edge latch = loop_latch_edge (loop);\n+  tree ldef = PHI_ARG_DEF_FROM_EDGE (phi, latch);\n+  if (TREE_CODE (ldef) != SSA_NAME\n+      || SSA_NAME_IS_DEFAULT_DEF (ldef)\n+      || !flow_bb_inside_loop_p (loop, gimple_bb (SSA_NAME_DEF_STMT (ldef))))\n+    return false;\n+\n+  tree def = gimple_phi_result (phi);\n+\n+  /* Ensure every use_stmt of the phi node is dominated by the latch\n+     definition.  */\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n+    if (!is_gimple_debug (USE_STMT (use_p))\n+\t&& (SSA_NAME_DEF_STMT (ldef) == USE_STMT (use_p)\n+\t    || !vect_stmt_dominates_stmt_p (SSA_NAME_DEF_STMT (ldef),\n+\t\t\t\t\t    USE_STMT (use_p))))\n+      return false;\n+\n+  /* First-order recurrence autovectorization needs shuffle vector.  */\n+  tree scalar_type = TREE_TYPE (def);\n+  tree vectype = get_vectype_for_scalar_type (loop_vinfo, scalar_type);\n+  if (!vectype)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Function vect_analyze_scalar_cycles_1.\n \n    Examine the cross iteration def-use cycles of scalar variables\n@@ -666,6 +705,8 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop,\n                 }\n             }\n         }\n+      else if (vect_phi_first_order_recurrence_p (loop_vinfo, loop, phi))\n+\tSTMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_first_order_recurrence;\n       else\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1810,7 +1851,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \n           if ((STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope\n                || STMT_VINFO_LIVE_P (stmt_info))\n-              && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n+\t      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def\n+\t      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_first_order_recurrence)\n \t    /* A scalar-dependence cycle that we don't support.  */\n \t    return opt_result::failure_at (phi,\n \t\t\t\t\t   \"not vectorized:\"\n@@ -1831,6 +1873,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t\t       && ! PURE_SLP_STMT (stmt_info))\n \t\tok = vectorizable_reduction (loop_vinfo,\n \t\t\t\t\t     stmt_info, NULL, NULL, &cost_vec);\n+\t      else if ((STMT_VINFO_DEF_TYPE (stmt_info)\n+\t\t\t== vect_first_order_recurrence)\n+\t\t       && ! PURE_SLP_STMT (stmt_info))\n+\t\tok = vectorizable_recurr (loop_vinfo, stmt_info, NULL, NULL,\n+\t\t\t\t\t   &cost_vec);\n             }\n \n \t  /* SLP PHIs are tested by vect_slp_analyze_node_operations.  */\n@@ -8290,6 +8337,178 @@ vectorizable_phi (vec_info *,\n   return true;\n }\n \n+/* Vectorizes first order recurrences.  An overview of the transformation\n+   is described below. Suppose we have the following loop.\n+\n+     int t = 0;\n+     for (int i = 0; i < n; ++i)\n+       {\n+\t b[i] = a[i] - t;\n+\t t = a[i];\n+       }\n+\n+   There is a first-order recurrence on 'a'. For this loop, the scalar IR\n+   looks (simplified) like:\n+\n+    scalar.preheader:\n+      init = 0;\n+\n+    scalar.body:\n+      i = PHI <0(scalar.preheader), i+1(scalar.body)>\n+      _2 = PHI <(init(scalar.preheader), <_1(scalar.body)>\n+      _1 = a[i]\n+      b[i] = _1 - _2\n+      if (i < n) goto scalar.body\n+\n+   In this example, _2 is a recurrence because it's value depends on the\n+   previous iteration.  We vectorize this as (VF = 4)\n+\n+    vector.preheader:\n+      vect_init = vect_cst(..., ..., ..., 0)\n+\n+    vector.body\n+      i = PHI <0(vector.preheader), i+4(vector.body)>\n+      vect_1 = PHI <vect_init(vector.preheader), v2(vector.body)>\n+      vect_2 = a[i, i+1, i+2, i+3];\n+      vect_3 = vec_perm (vect_1, vect_2, { 3, 4, 5, 6 })\n+      b[i, i+1, i+2, i+3] = vect_2 - vect_3\n+      if (..) goto vector.body\n+\n+   In this function, vectorizable_recurr, we code generate both the\n+   vector PHI node and the permute since those together compute the\n+   vectorized value of the scalar PHI.  We do not yet have the\n+   backedge value to fill in there nor into the vec_perm.  Those\n+   are filled in maybe_set_vectorized_backedge_value and\n+   vect_schedule_scc.\n+\n+   TODO:  Since the scalar loop does not have a use of the recurrence\n+   outside of the loop the natural way to implement peeling via\n+   vectorizing the live value doesn't work.  For now peeling of loops\n+   with a recurrence is not implemented.  For SLP the supported cases\n+   are restricted to those requiring a single vector recurrence PHI.  */\n+\n+bool\n+vectorizable_recurr (loop_vec_info loop_vinfo, stmt_vec_info stmt_info,\n+\t\t     gimple **vec_stmt, slp_tree slp_node,\n+\t\t     stmt_vector_for_cost *cost_vec)\n+{\n+  if (!loop_vinfo || !is_a<gphi *> (stmt_info->stmt))\n+    return false;\n+\n+  gphi *phi = as_a<gphi *> (stmt_info->stmt);\n+\n+  /* So far we only support first-order recurrence auto-vectorization.  */\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_first_order_recurrence)\n+    return false;\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  unsigned ncopies;\n+  if (slp_node)\n+    ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+  else\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+  poly_int64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned dist = slp_node ? SLP_TREE_LANES (slp_node) : 1;\n+  /* We need to be able to make progress with a single vector.  */\n+  if (maybe_gt (dist * 2, nunits))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"first order recurrence exceeds half of \"\n+\t\t\t \"a vector\\n\");\n+      return false;\n+    }\n+\n+  /* First-order recurrence autovectorization needs to handle permutation\n+     with indices = [nunits-1, nunits, nunits+1, ...].  */\n+  vec_perm_builder sel (nunits, 1, 3);\n+  for (int i = 0; i < 3; ++i)\n+    sel.quick_push (nunits - dist + i);\n+  vec_perm_indices indices (sel, 2, nunits);\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), TYPE_MODE (vectype),\n+\t\t\t\t indices))\n+\treturn false;\n+\n+      if (slp_node)\n+\t{\n+\t  /* We eventually need to set a vector type on invariant\n+\t     arguments.  */\n+\t  unsigned j;\n+\t  slp_tree child;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (slp_node), j, child)\n+\t    if (!vect_maybe_update_slp_op_vectype\n+\t\t  (child, SLP_TREE_VECTYPE (slp_node)))\n+\t      {\n+\t\tif (dump_enabled_p ())\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"incompatible vector types for \"\n+\t\t\t\t   \"invariants\\n\");\n+\t\treturn false;\n+\t      }\n+\t}\n+      /* The recurrence costs the initialization vector and one permute\n+\t for each copy.  */\n+      unsigned prologue_cost = record_stmt_cost (cost_vec, 1, scalar_to_vec,\n+\t\t\t\t\t\t stmt_info, 0, vect_prologue);\n+      unsigned inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t\t       stmt_info, 0, vect_body);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vectorizable_recurr: inside_cost = %d, \"\n+\t\t\t \"prologue_cost = %d .\\n\", inside_cost,\n+\t\t\t prologue_cost);\n+\n+      STMT_VINFO_TYPE (stmt_info) = recurr_info_type;\n+      return true;\n+    }\n+\n+  edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+  basic_block bb = gimple_bb (phi);\n+  tree preheader = PHI_ARG_DEF_FROM_EDGE (phi, pe);\n+  tree vec_init = build_vector_from_val (vectype, preheader);\n+  vec_init = vect_init_vector (loop_vinfo, stmt_info, vec_init, vectype, NULL);\n+\n+  /* Create the vectorized first-order PHI node.  */\n+  tree vec_dest = vect_get_new_vect_var (vectype,\n+\t\t\t\t\t vect_simple_var, \"vec_recur_\");\n+  gphi *new_phi = create_phi_node (vec_dest, bb);\n+  add_phi_arg (new_phi, vec_init, pe, UNKNOWN_LOCATION);\n+\n+  /* Insert shuffles the first-order recurrence autovectorization.\n+       result = VEC_PERM <vec_recur, vect_1, index[nunits-1, nunits, ...]>.  */\n+  tree perm = vect_gen_perm_mask_checked (vectype, indices);\n+\n+  /* Insert the required permute after the latch definition.  The\n+     second and later operands are tentative and will be updated when we have\n+     vectorized the latch definition.  */\n+  edge le = loop_latch_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+  gimple_stmt_iterator gsi2\n+    = gsi_for_stmt (SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, le)));\n+  gsi_next (&gsi2);\n+\n+  for (unsigned i = 0; i < ncopies; ++i)\n+    {\n+      vec_dest = make_ssa_name (vectype);\n+      gassign *vperm\n+\t  = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n+\t\t\t\t i == 0 ? gimple_phi_result (new_phi) : NULL,\n+\t\t\t\t NULL, perm);\n+      vect_finish_stmt_generation (loop_vinfo, stmt_info, vperm, &gsi2);\n+\n+      if (slp_node)\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (vperm);\n+      else\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (vperm);\n+    }\n+\n+  if (!slp_node)\n+    *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n+  return true;\n+}\n+\n /* Return true if VECTYPE represents a vector that requires lowering\n    by the vector lowering pass.  */\n \n@@ -10242,27 +10461,53 @@ maybe_set_vectorized_backedge_value (loop_vec_info loop_vinfo,\n   imm_use_iterator iter;\n   use_operand_p use_p;\n   FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n-    if (gphi *phi = dyn_cast <gphi *> (USE_STMT (use_p)))\n-      if (gimple_bb (phi)->loop_father->header == gimple_bb (phi)\n-\t  && (phi_info = loop_vinfo->lookup_stmt (phi))\n-\t  && STMT_VINFO_RELEVANT_P (phi_info)\n-\t  && VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (phi_info))\n+    {\n+      gphi *phi = dyn_cast <gphi *> (USE_STMT (use_p));\n+      if (!phi)\n+\tcontinue;\n+      if (!(gimple_bb (phi)->loop_father->header == gimple_bb (phi)\n+\t    && (phi_info = loop_vinfo->lookup_stmt (phi))\n+\t    && STMT_VINFO_RELEVANT_P (phi_info)))\n+\tcontinue;\n+      loop_p loop = gimple_bb (phi)->loop_father;\n+      edge e = loop_latch_edge (loop);\n+      if (PHI_ARG_DEF_FROM_EDGE (phi, e) != def)\n+\tcontinue;\n+\n+      if (VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (phi_info))\n \t  && STMT_VINFO_REDUC_TYPE (phi_info) != FOLD_LEFT_REDUCTION\n \t  && STMT_VINFO_REDUC_TYPE (phi_info) != EXTRACT_LAST_REDUCTION)\n \t{\n-\t  loop_p loop = gimple_bb (phi)->loop_father;\n-\t  edge e = loop_latch_edge (loop);\n-\t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == def)\n+\t  vec<gimple *> &phi_defs = STMT_VINFO_VEC_STMTS (phi_info);\n+\t  vec<gimple *> &latch_defs = STMT_VINFO_VEC_STMTS (def_stmt_info);\n+\t  gcc_assert (phi_defs.length () == latch_defs.length ());\n+\t  for (unsigned i = 0; i < phi_defs.length (); ++i)\n+\t    add_phi_arg (as_a <gphi *> (phi_defs[i]),\n+\t\t\t gimple_get_lhs (latch_defs[i]), e,\n+\t\t\t gimple_phi_arg_location (phi, e->dest_idx));\n+\t}\n+      else if (STMT_VINFO_DEF_TYPE (phi_info) == vect_first_order_recurrence)\n+\t{\n+\t  /* For first order recurrences we have to update both uses of\n+\t     the latch definition, the one in the PHI node and the one\n+\t     in the generated VEC_PERM_EXPR.  */\n+\t  vec<gimple *> &phi_defs = STMT_VINFO_VEC_STMTS (phi_info);\n+\t  vec<gimple *> &latch_defs = STMT_VINFO_VEC_STMTS (def_stmt_info);\n+\t  gcc_assert (phi_defs.length () == latch_defs.length ());\n+\t  tree phidef = gimple_assign_rhs1 (phi_defs[0]);\n+\t  gphi *vphi = as_a <gphi *> (SSA_NAME_DEF_STMT (phidef));\n+\t  for (unsigned i = 0; i < phi_defs.length (); ++i)\n \t    {\n-\t      vec<gimple *> &phi_defs = STMT_VINFO_VEC_STMTS (phi_info);\n-\t      vec<gimple *> &latch_defs = STMT_VINFO_VEC_STMTS (def_stmt_info);\n-\t      gcc_assert (phi_defs.length () == latch_defs.length ());\n-\t      for (unsigned i = 0; i < phi_defs.length (); ++i)\n-\t\tadd_phi_arg (as_a <gphi *> (phi_defs[i]),\n-\t\t\t     gimple_get_lhs (latch_defs[i]), e,\n-\t\t\t     gimple_phi_arg_location (phi, e->dest_idx));\n+\t      gassign *perm = as_a <gassign *> (phi_defs[i]);\n+\t      if (i > 0)\n+\t\tgimple_assign_set_rhs1 (perm, gimple_get_lhs (latch_defs[i-1]));\n+\t      gimple_assign_set_rhs2 (perm, gimple_get_lhs (latch_defs[i]));\n+\t      update_stmt (perm);\n \t    }\n+\t  add_phi_arg (vphi, gimple_get_lhs (latch_defs.last ()), e,\n+\t\t       gimple_phi_arg_location (phi, e->dest_idx));\n \t}\n+    }\n }\n \n /* Vectorize STMT_INFO if relevant, inserting any new instructions before GSI.\n@@ -10671,6 +10916,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_first_order_recurrence\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def)\n \t      && ! PURE_SLP_STMT (stmt_info))\n \t    {\n@@ -10696,7 +10942,8 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n-\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def)\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_first_order_recurrence)\n \t      && ! PURE_SLP_STMT (stmt_info))\n \t    maybe_set_vectorized_backedge_value (loop_vinfo, stmt_info);\n \t}"}, {"sha": "e54414f6befadcea95419bf9b84904b9cb4245b9", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -693,6 +693,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t    case vect_reduction_def:\n \t    case vect_induction_def:\n \t    case vect_nested_cycle:\n+\t    case vect_first_order_recurrence:\n \t      break;\n \n \t    default:\n@@ -1732,7 +1733,8 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t  }\n \telse if (def_type == vect_reduction_def\n \t\t || def_type == vect_double_reduction_def\n-\t\t || def_type == vect_nested_cycle)\n+\t\t || def_type == vect_nested_cycle\n+\t\t || def_type == vect_first_order_recurrence)\n \t  {\n \t    /* Else def types have to match.  */\n \t    stmt_vec_info other_info;\n@@ -1746,7 +1748,8 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t      }\n \t    class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \t    /* Reduction initial values are not explicitely represented.  */\n-\t    if (!nested_in_vect_loop_p (loop, stmt_info))\n+\t    if (def_type != vect_first_order_recurrence\n+\t\t&& !nested_in_vect_loop_p (loop, stmt_info))\n \t      skip_args[loop_preheader_edge (loop)->dest_idx] = true;\n \t    /* Reduction chain backedge defs are filled manually.\n \t       ???  Need a better way to identify a SLP reduction chain PHI.\n@@ -9210,11 +9213,34 @@ vect_schedule_scc (vec_info *vinfo, slp_tree node, slp_instance instance,\n \t  child = SLP_TREE_CHILDREN (phi_node)[dest_idx];\n \t  if (!child || SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n \t    continue;\n+\t  unsigned n = SLP_TREE_VEC_STMTS (phi_node).length ();\n \t  /* Simply fill all args.  */\n-\t  for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n-\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]),\n-\t\t\t vect_get_slp_vect_def (child, i),\n-\t\t\t e, gimple_phi_arg_location (phi, dest_idx));\n+\t  if (STMT_VINFO_DEF_TYPE (SLP_TREE_REPRESENTATIVE (phi_node))\n+\t      != vect_first_order_recurrence)\n+\t    for (unsigned i = 0; i < n; ++i)\n+\t      add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]),\n+\t\t\t   vect_get_slp_vect_def (child, i),\n+\t\t\t   e, gimple_phi_arg_location (phi, dest_idx));\n+\t  else\n+\t    {\n+\t      /* Unless it is a first order recurrence which needs\n+\t\t args filled in for both the PHI node and the permutes.  */\n+\t      gimple *perm = SLP_TREE_VEC_STMTS (phi_node)[0];\n+\t      gimple *rphi = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (perm));\n+\t      add_phi_arg (as_a <gphi *> (rphi),\n+\t\t\t   vect_get_slp_vect_def (child, n - 1),\n+\t\t\t   e, gimple_phi_arg_location (phi, dest_idx));\n+\t      for (unsigned i = 0; i < n; ++i)\n+\t\t{\n+\t\t  gimple *perm = SLP_TREE_VEC_STMTS (phi_node)[i];\n+\t\t  if (i > 0)\n+\t\t    gimple_assign_set_rhs1 (perm,\n+\t\t\t\t\t    vect_get_slp_vect_def (child, i - 1));\n+\t\t  gimple_assign_set_rhs2 (perm,\n+\t\t\t\t\t  vect_get_slp_vect_def (child, i));\n+\t\t  update_stmt (perm);\n+\t\t}\n+\t    }\n \t}\n     }\n }"}, {"sha": "4e0d75e0d7586ad57a37850d8a70f6182ecb13d0", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -11176,6 +11176,7 @@ vect_analyze_stmt (vec_info *vinfo,\n          break;\n \n       case vect_induction_def:\n+      case vect_first_order_recurrence:\n \tgcc_assert (!bb_vinfo);\n \tbreak;\n \n@@ -11234,7 +11235,9 @@ vect_analyze_stmt (vec_info *vinfo,\n \t  || vectorizable_comparison (vinfo, stmt_info, NULL, NULL, node,\n \t\t\t\t      cost_vec)\n \t  || vectorizable_lc_phi (as_a <loop_vec_info> (vinfo),\n-\t\t\t\t  stmt_info, NULL, node));\n+\t\t\t\t  stmt_info, NULL, node)\n+\t  || vectorizable_recurr (as_a <loop_vec_info> (vinfo),\n+\t\t\t\t   stmt_info, NULL, node, cost_vec));\n   else\n     {\n       if (bb_vinfo)\n@@ -11404,6 +11407,12 @@ vect_transform_stmt (vec_info *vinfo,\n       gcc_assert (done);\n       break;\n \n+    case recurr_info_type:\n+      done = vectorizable_recurr (as_a <loop_vec_info> (vinfo),\n+\t\t\t\t  stmt_info, &vec_stmt, slp_node, NULL);\n+      gcc_assert (done);\n+      break;\n+\n     case phi_info_type:\n       done = vectorizable_phi (vinfo, stmt_info, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n@@ -11804,6 +11813,9 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n \tcase vect_nested_cycle:\n \t  dump_printf (MSG_NOTE, \"nested cycle\\n\");\n \t  break;\n+\tcase vect_first_order_recurrence:\n+\t  dump_printf (MSG_NOTE, \"first order recurrence\\n\");\n+\t  break;\n \tcase vect_unknown_def_type:\n \t  dump_printf (MSG_NOTE, \"unknown\\n\");\n \t  break;\n@@ -11852,7 +11864,8 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n       || *dt == vect_induction_def\n       || *dt == vect_reduction_def\n       || *dt == vect_double_reduction_def\n-      || *dt == vect_nested_cycle)\n+      || *dt == vect_nested_cycle\n+      || *dt == vect_first_order_recurrence)\n     {\n       *vectype = STMT_VINFO_VECTYPE (def_stmt_info);\n       gcc_assert (*vectype != NULL_TREE);"}, {"sha": "016961da8510ca7dd2d07e716cbe35623ed2d9a5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a8e017d048ec3271bbb898942e3b166c4e8ff3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=46a8e017d048ec3271bbb898942e3b166c4e8ff3", "patch": "@@ -65,6 +65,7 @@ enum vect_def_type {\n   vect_reduction_def,\n   vect_double_reduction_def,\n   vect_nested_cycle,\n+  vect_first_order_recurrence,\n   vect_unknown_def_type\n };\n \n@@ -1027,6 +1028,7 @@ enum stmt_vec_info_type {\n   cycle_phi_info_type,\n   lc_phi_info_type,\n   phi_info_type,\n+  recurr_info_type,\n   loop_exit_ctrl_vec_info_type\n };\n \n@@ -2331,6 +2333,8 @@ extern bool vectorizable_lc_phi (loop_vec_info, stmt_vec_info,\n \t\t\t\t gimple **, slp_tree);\n extern bool vectorizable_phi (vec_info *, stmt_vec_info, gimple **, slp_tree,\n \t\t\t      stmt_vector_for_cost *);\n+extern bool vectorizable_recurr (loop_vec_info, stmt_vec_info,\n+\t\t\t\t  gimple **, slp_tree, stmt_vector_for_cost *);\n extern bool vect_emulated_vector_p (tree);\n extern bool vect_can_vectorize_without_simd_p (tree_code);\n extern bool vect_can_vectorize_without_simd_p (code_helper);"}]}