{"sha": "3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiMTFiNWM5ZjliNGEyNjdjYjQ2YTllMmUxZTUzMWZiM2RmMzBmMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-13T20:35:07Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-13T20:35:07Z"}, "message": "fixunssfsi.c: Replace H8/S with H8S.\n\n\t* config/h8300/fixunssfsi.c: Replace H8/S with H8S.\n\t* config/h8300/h8300.c: Likewise.\n\t* config/h8300/h8300.h: Likewise.\n\t* config/h8300/h8300.md: Likewise.\n\t* doc/invoke.texi: Likewise.\n\nFrom-SVN: r57118", "tree": {"sha": "0adbea2d09d738c6d28f6c404ce8cf021fddf83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0adbea2d09d738c6d28f6c404ce8cf021fddf83a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/comments", "author": null, "committer": null, "parents": [{"sha": "b6894857d35430104ee2356f3715e79d92cd774f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6894857d35430104ee2356f3715e79d92cd774f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6894857d35430104ee2356f3715e79d92cd774f"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "6fd649e03ea8d4d7018d6ceef3b1492c8e184ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -1,3 +1,11 @@\n+2002-09-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/fixunssfsi.c: Replace H8/S with H8S.\n+\t* config/h8300/h8300.c: Likewise.\n+\t* config/h8300/h8300.h: Likewise.\n+\t* config/h8300/h8300.md: Likewise.\n+\t* doc/invoke.texi: Likewise.\n+\n 2002-09-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (h8300_init_once): Fix formatting."}, {"sha": "87c288292979f39bd00921163e25e033aef52978", "filename": "gcc/config/h8300/fixunssfsi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Ffixunssfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Ffixunssfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ffixunssfsi.c?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -30,7 +30,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* The libgcc2.c implementation gets confused by our type setup and creates\n    a directly recursive call, so we do our own implementation.  For\n-   the H8/300, that's in lib1funcs.asm, for H8/300H and H8/S, it's here.  */\n+   the H8/300, that's in lib1funcs.asm, for H8/300H and H8S, it's here.  */\n \n #ifndef __H8300__\n long"}, {"sha": "f6f6aad6db5e9dab7ce496976dd75b2d3659d5d8", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -301,7 +301,7 @@ h8300_init_once ()\n     }\n   else\n     {\n-      /* For this we treat the H8/300H and H8/S the same.  */\n+      /* For this we treat the H8/300H and H8S the same.  */\n       cpu_type = (int) CPU_H8300H;\n       h8_reg_names = names_extended;\n     }\n@@ -392,7 +392,7 @@ dosize (file, op, size)\n      const char *op;\n      unsigned int size;\n {\n-  /* On the H8/300H and H8/S, for sizes <= 8 bytes, it is as good or\n+  /* On the H8/300H and H8S, for sizes <= 8 bytes, it is as good or\n      better to use adds/subs insns rather than add.l/sub.l with an\n      immediate value.\n \n@@ -2036,7 +2036,7 @@ compute_logical_op_cc (mode, operands)\n \n    We devote a fair bit of code to getting efficient shifts since we\n    can only shift one bit at a time on the H8/300 and H8/300H and only\n-   one or two bits at a time on the H8/S.\n+   one or two bits at a time on the H8S.\n \n    All shift code falls into one of the following ways of\n    implementation:\n@@ -2055,7 +2055,7 @@ compute_logical_op_cc (mode, operands)\n      16.  This case also includes other oddballs that are not worth\n      explaning here.\n \n-   o SHIFT_LOOP: Emit a loop using one (or two on H8/S) bit shifts.\n+   o SHIFT_LOOP: Emit a loop using one (or two on H8S) bit shifts.\n \n    Here are some thoughts on what the absolutely positively best code\n    is.  \"Best\" here means some rational trade-off between code size\n@@ -2120,15 +2120,15 @@ compute_logical_op_cc (mode, operands)\n             do 24 bit shift, inline rest\n    31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n \n-   H8/S QImode shifts\n+   H8S QImode shifts\n    7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n-   H8/S HImode shifts\n+   H8S HImode shifts\n    8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n    9-12   - do shift by 8, inline remaining shifts\n    15     - ASHIFTRT: shll, subx, set other byte\n \n-   H8/S SImode shifts\n+   H8S SImode shifts\n    (These are complicated by the fact that we don't have byte level access to\n    the top word.)\n    A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n@@ -2812,7 +2812,7 @@ h8300_shift_needs_scratch_p (count, mode)\n       abort ();\n     }\n \n-  /* On H8/300H and H8/S, count == 8 uses the scratch register.  */\n+  /* On H8/300H and H8S, count == 8 uses the scratch register.  */\n   return (a == SHIFT_LOOP || lr == SHIFT_LOOP || ar == SHIFT_LOOP\n \t  || (!TARGET_H8300 && mode == SImode && count == 8));\n }\n@@ -3304,7 +3304,7 @@ emit_a_rotate (code, operands)\n \t  break;\n \n \tcase SImode:\n-\t  /* This code works on the H8/300H and H8/S.  */\n+\t  /* This code works on the H8/300H and H8S.  */\n \t  insn_buf = \"xor.w\\t%e0,%f0\\n\\txor.w\\t%f0,%e0\\n\\txor.w\\t%e0,%f0\";\n \t  output_asm_insn (insn_buf, operands);\n \t  break;\n@@ -3728,7 +3728,7 @@ h8300_adjust_insn_length (insn, length)\n \t}\n       else\n \t{\n-\t  /* On the H8/300H and H8/S, we subtract the difference\n+\t  /* On the H8/300H and H8S, we subtract the difference\n              between the actual length and the longest one, which is\n              @(d:24,ERs).  */\n \n@@ -3837,7 +3837,7 @@ h8300_adjust_insn_length (insn, length)\n \t  states += 6;\n \t}\n \n-      /* We use 2-bit rotatations on the H8/S.  */\n+      /* We use 2-bit rotatations on the H8S.  */\n       if (TARGET_H8300S)\n \tamount = amount / 2 + amount % 2;\n "}, {"sha": "0fc4a375663025351b4be1dc382a728b05057656", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -115,10 +115,10 @@ extern int target_flags;\n    An empty string NAME is used to identify the default VALUE.  */\n \n #define TARGET_SWITCHES  \\\n-  { {\"s\",\t\t1,     N_(\"Generate H8/S code\")},\t\t\\\n-    {\"no-s\",\t\t-1,    N_(\"Do not generate H8/S code\")},\t\\\n-    {\"s2600\",\t\t2,     N_(\"Generate H8/S2600 code\")},           \\\n-    {\"no-s2600\",\t-2,    N_(\"Do not generate H8/S2600 code\")},    \\\n+  { {\"s\",\t\t1,     N_(\"Generate H8S code\")},\t\t\\\n+    {\"no-s\",\t\t-1,    N_(\"Do not generate H8S code\")},\t\\\n+    {\"s2600\",\t\t2,     N_(\"Generate H8S/2600 code\")},           \\\n+    {\"no-s2600\",\t-2,    N_(\"Do not generate H8S/2600 code\")},    \\\n     {\"int32\",\t\t8,     N_(\"Make integers 32 bits wide\")},\t\\\n     {\"addresses\",\t64,    NULL},\t\t\t\t\t\\\n     {\"quickcall\",\t128,\t\t\t\t\t\t\\\n@@ -228,7 +228,7 @@ extern int target_flags;\n #define PCC_BITFIELD_TYPE_MATTERS  0\n \n /* No data type wants to be aligned rounder than this.\n-   32 bit values are aligned as such on the H8/300H and H8/S for speed.  */\n+   32 bit values are aligned as such on the H8/300H and H8S for speed.  */\n #define BIGGEST_ALIGNMENT \\\n (((TARGET_H8300H || TARGET_H8300S) && ! TARGET_ALIGN_300) ? 32 : 16)\n \n@@ -835,7 +835,7 @@ struct cum_arg\n \t   && (INTVAL (X) & 0x0000FFFF) <= 0xffff)))\n \n /* Nonzero if X is a constant address suitable as an 16-bit absolute\n-   on H8/300H and H8/S.  */\n+   on H8/300H and H8S.  */\n \n #define TINY_CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n   ((GET_CODE (X) == CONST_INT)\t\t\t\t\t\t\\\n@@ -851,7 +851,7 @@ struct cum_arg\n    i.e. a register, register indirect, or the eightbit memory region\n    (a SYMBOL_REF with an SYMBOL_REF_FLAG set).\n \n-   On the H8/S 'U' can also be a 16bit or 32bit absolute.  */\n+   On the H8S 'U' can also be a 16bit or 32bit absolute.  */\n #define OK_FOR_U(OP)\t\t\t\t\t\t\t\\\n   ((GET_CODE (OP) == REG && REG_OK_FOR_BASE_P (OP))\t\t\t\\\n    || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\t\\"}, {"sha": "5df7be3e0c5b6c9df8862a2b48a9afd2329c9b60", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -28,7 +28,7 @@\n ;; \"worst case\" and then be adjusted to their correct values by\n ;; h8300_adjust_insn_length.\n \n-;; On the H8/300H and H8/S, adds/subs operate on the 32bit \"er\"\n+;; On the H8/300H and H8S, adds/subs operate on the 32bit \"er\"\n ;; registers.  Right now GCC doesn't expose the \"e\" half to the\n ;; compiler, so using add/subs for addhi and subhi is safe.  Long\n ;; term, we want to expose the \"e\" half to the compiler (gives us 8\n@@ -1529,7 +1529,7 @@\n \n ;; Call subroutine with no return value.\n \n-;; ??? Even though we use HImode here, this works on the H8/300H and H8/S.\n+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n \n (define_insn \"call\"\n   [(call (match_operand:QI 0 \"call_insn_operand\" \"or\")\n@@ -1552,7 +1552,7 @@\n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n \n-;; ??? Even though we use HImode here, this works on the H8/300H and H8/S.\n+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.\n \n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"=r\")"}, {"sha": "48d87a2ec48e27e5ea50c4da392f6ae915122575", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3db11b5c9f9b4a267cb46a9e2e1e531fb3df30f0", "patch": "@@ -8381,20 +8381,20 @@ Generate code for the H8/300H@.\n \n @item -ms\n @opindex ms\n-Generate code for the H8/S@.\n+Generate code for the H8S@.\n \n @item -ms2600\n @opindex ms2600\n-Generate code for the H8/S2600.  This switch must be used with @option{-ms}.\n+Generate code for the H8S/2600.  This switch must be used with @option{-ms}.\n \n @item -mint32\n @opindex mint32\n Make @code{int} data 32 bits by default.\n \n @item -malign-300\n @opindex malign-300\n-On the H8/300H and H8/S, use the same alignment rules as for the H8/300.\n-The default for the H8/300H and H8/S is to align longs and floats on 4\n+On the H8/300H and H8S, use the same alignment rules as for the H8/300.\n+The default for the H8/300H and H8S is to align longs and floats on 4\n byte boundaries.\n @option{-malign-300} causes them to be aligned on 2 byte boundaries.\n This option has no effect on the H8/300."}]}