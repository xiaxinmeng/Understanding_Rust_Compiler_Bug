{"sha": "e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "node_id": "C_kwDOANBUbNoAKGU3ZWE1ZmI2NDAyNmM3MmY0ZjkzZTFlY2Q5MmNlN2U1ZDI5NDFiNTQ", "commit": {"author": {"name": "Sergey Bugaev", "email": "bugaevc@gmail.com", "date": "2023-04-03T15:58:43Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-04-17T08:46:19Z"}, "message": "resolve: Add \"break rust\" Easter egg\n\nWhen we encounter a \"break rust\" statement, emit a funny error message\nand intentionally cause an ICE. This matches the corresponding Easter\negg in rustc. As a GNU extension, \"break gcc\" is also supported.\n\nThe conditions for this to happen are:\n* The break expression must be literally \"rust\" or \"gcc\". For instance,\n  \"break (rust)\" will not trigger the Easter egg.\n* The name (\"rust\" or \"gcc\") must not be in scope; if it is, no error\n  is emitted, and the compilation proceeds as usual. In other words,\n  this only affects how GCC diagnoses programs that would fail to\n  compile anyway.\n\nNote that this is different from the conditions under which rustc emits\nits ICE. For rustc, it matters whether or not the \"break\" is inside a\nloop, and for us it matters whether or not the name resolves. The end\nresult should be the same anyway: valid programs continue to compile,\nand typing in\n\nfn main() {\n    break rust;\n}\n\ntriggers a funny ICE.\n\nCloses https://github.com/Rust-GCC/gccrs/issues/1996\n\ngcc/rust/ChangeLog:\n\t* resolve/rust-ast-resolve-expr.cc: Add \"break rust\" Easter egg\n\ngcc/testsuite/ChangeLog:\n\t* lib/prune.exp (prune_ices):\n\tAlso prune \"You have broken GCC Rust. This is a feature.\"\n\t* rust/compile/break-rust1.rs: New test\n\t* rust/compile/break-rust2.rs: New test\n\t* rust/compile/break-rust3.rs: New test\n\nSigned-off-by: Sergey Bugaev <bugaevc@gmail.com>", "tree": {"sha": "d6fc17cd575e6e33b1d7b133b61d0686c10907dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6fc17cd575e6e33b1d7b133b61d0686c10907dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/comments", "author": {"login": "bugaevc", "id": 10091584, "node_id": "MDQ6VXNlcjEwMDkxNTg0", "avatar_url": "https://avatars.githubusercontent.com/u/10091584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugaevc", "html_url": "https://github.com/bugaevc", "followers_url": "https://api.github.com/users/bugaevc/followers", "following_url": "https://api.github.com/users/bugaevc/following{/other_user}", "gists_url": "https://api.github.com/users/bugaevc/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugaevc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugaevc/subscriptions", "organizations_url": "https://api.github.com/users/bugaevc/orgs", "repos_url": "https://api.github.com/users/bugaevc/repos", "events_url": "https://api.github.com/users/bugaevc/events{/privacy}", "received_events_url": "https://api.github.com/users/bugaevc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd09533b321ec7f47c95356e146619e9d861836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd09533b321ec7f47c95356e146619e9d861836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd09533b321ec7f47c95356e146619e9d861836"}], "stats": {"total": 86, "additions": 85, "deletions": 1}, "files": [{"sha": "a6e4f9b211851a781143b2e3ac031cbe1c319f89", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n #include \"rust-ast-resolve-path.h\"\n+#include \"diagnostic.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -105,6 +106,45 @@ ResolveExpr::visit (AST::AssignmentExpr &expr)\n   VerifyAsignee::go (expr.get_left_expr ().get ());\n }\n \n+/* The \"break rust\" Easter egg.\n+\n+   Backstory: once upon a time, there used to be a bug in rustc: it would ICE\n+   during typechecking on a 'break' with an expression outside of a loop.  The\n+   issue has been reported [0] and fixed [1], but in recognition of this, as a\n+   special Easter egg, \"break rust\" was made to intentionally cause an ICE.\n+\n+   [0]: https://github.com/rust-lang/rust/issues/43162\n+   [1]: https://github.com/rust-lang/rust/pull/43745\n+\n+   This was made in a way that does not break valid programs: namely, it only\n+   happens when the 'break' is outside of a loop (so invalid anyway).\n+\n+   GCC Rust supports this essential feature as well, but in a slightly\n+   different way.  Instead of delaying the error until type checking, we emit\n+   it here in the resolution phase.  We, too, only do this to programs that\n+   are already invalid: we only emit our funny ICE if the name \"rust\" (which\n+   must be immediately inside a break-with-a-value expression) fails to\n+   resolve.  Note that \"break (rust)\" does not trigger our ICE, only using\n+   \"break rust\" directly does, and only if there's no \"rust\" in scope.  We do\n+   this in the same way regardless of whether the \"break\" is outside of a loop\n+   or inside one.\n+\n+   As a GNU extension, we also support \"break gcc\", much to the same effect,\n+   subject to the same rules.  */\n+\n+/* The finalizer for our funny ICE.  This prints a custom message instead of\n+   the default bug reporting instructions, as there is no bug to report.  */\n+\n+static void ATTRIBUTE_NORETURN\n+funny_ice_finalizer (diagnostic_context *context, diagnostic_info *diagnostic,\n+\t\t     diagnostic_t diag_kind)\n+{\n+  gcc_assert (diag_kind == DK_ICE_NOBT);\n+  default_diagnostic_finalizer (context, diagnostic, diag_kind);\n+  fnotice (stderr, \"You have broken GCC Rust. This is a feature.\\n\");\n+  exit (ICE_EXIT_CODE);\n+}\n+\n void\n ResolveExpr::visit (AST::IdentifierExpr &expr)\n {\n@@ -120,6 +160,17 @@ ResolveExpr::visit (AST::IdentifierExpr &expr)\n     {\n       resolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n     }\n+  else if (funny_error)\n+    {\n+      /* This was a \"break rust\" or \"break gcc\", and the identifier failed to\n+\t resolve.  Emit a funny ICE.  We set the finalizer to our custom one,\n+\t and use the lower-level emit_diagnostic () instead of the more common\n+\t internal_error_no_backtrace () in order to pass our locus.  */\n+      diagnostic_finalizer (global_dc) = funny_ice_finalizer;\n+      emit_diagnostic (DK_ICE_NOBT, expr.get_locus ().gcc_location (), -1,\n+\t\t       \"are you trying to break %s? how dare you?\",\n+\t\t       expr.as_string ().c_str ());\n+    }\n   else\n     {\n       rust_error_at (expr.get_locus (), \"failed to find name: %s\",\n@@ -407,7 +458,24 @@ ResolveExpr::visit (AST::BreakExpr &expr)\n     }\n \n   if (expr.has_break_expr ())\n-    ResolveExpr::go (expr.get_break_expr ().get (), prefix, canonical_prefix);\n+    {\n+      bool funny_error = false;\n+      AST::Expr &break_expr = *expr.get_break_expr ().get ();\n+      if (break_expr.get_ast_kind () == AST::Kind::IDENTIFIER)\n+\t{\n+\t  /* This is a break with an expression, and the expression is just a\n+\t     single identifier.  See if the identifier is either \"rust\" or\n+\t     \"gcc\", in which case we have \"break rust\" or \"break gcc\", and so\n+\t     may need to emit our funny error.  We cannot yet emit the error\n+\t     here though, because the identifier may still be in scope, and\n+\t     ICE'ing on valid programs would not be very funny.  */\n+\t  std::string ident\n+\t    = static_cast<AST::IdentifierExpr &> (break_expr).as_string ();\n+\t  if (ident == \"rust\" || ident == \"gcc\")\n+\t    funny_error = true;\n+\t}\n+      ResolveExpr::go (&break_expr, prefix, canonical_prefix, funny_error);\n+    }\n }\n \n void"}, {"sha": "8a448bbb63a250b8d26b5cc56e18cec0d5d5c4b6", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "patch": "@@ -158,6 +158,7 @@ proc prune_file_path { text } {\n proc prune_ices { text } {\n   regsub -all \"(^|\\n)\\[^\\n\\]*: internal compiler error:.*\\nSee \\[^\\n\\]*\" $text \"\" text\n   regsub -all \"(^|\\n|')*Internal compiler error:.*\\nSee \\[^\\n\\]*\" $text \"\" text\n+  regsub -all \"(^|\\n)\\[^\\n\\]*: internal compiler error:.*\\nYou have broken GCC Rust. This is a feature.\" $text \"\" text\n   return $text\n }\n "}, {"sha": "65d64f9b82b05a95a4728580fffba0b708ccd665", "filename": "gcc/testsuite/rust/compile/break-rust1.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust1.rs?ref=e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let rust = \"crab\";\n+    let res = loop {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        break rust;\n+    };\n+}"}, {"sha": "d02589e6bccda3dc6e7198477eeb7bcda4908352", "filename": "gcc/testsuite/rust/compile/break-rust2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust2.rs?ref=e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    break (rust);\n+    // { dg-error \"failed to find name: rust\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "b18666a6b722f262821c60f939dfbd8aae0feb92", "filename": "gcc/testsuite/rust/compile/break-rust3.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbreak-rust3.rs?ref=e7ea5fb64026c72f4f93e1ecd92ce7e5d2941b54", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    break rust;\n+    // { dg-ice \"are you trying to break rust? how dare you?\" }\n+}"}]}