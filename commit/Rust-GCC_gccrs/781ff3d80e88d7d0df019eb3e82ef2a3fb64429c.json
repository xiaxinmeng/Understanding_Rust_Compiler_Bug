{"sha": "781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxZmYzZDgwZTg4ZDdkMGRmMDE5ZWIzZTgyZWYyYTNmYjY0NDI5Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-06-18T16:32:59Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-06-18T16:32:59Z"}, "message": "PR tree-optimization/81384 - built-in form of strnlen missing\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/81384\n\t* builtin-types.def (BT_FN_SIZE_CONST_STRING_SIZE): New.\n\t* builtins.c (expand_builtin_strnlen): New function.\n\t(expand_builtin): Call it.\n\t(fold_builtin_n): Avoid setting TREE_NO_WARNING.\n\t* builtins.def (BUILT_IN_STRNLEN): New.\n\t* calls.c (maybe_warn_nonstring_arg): Handle BUILT_IN_STRNLEN.\n\tWarn for bounds in excess of maximum object size.\n\t* tree-ssa-strlen.c (maybe_set_strlen_range): Return tree representing\n\tsingle-value ranges.  Handle strnlen.\n\t(handle_builtin_strlen): Handle strnlen.\n\t(strlen_check_and_optimize_stmt): Same.\n\t* doc/extend.texi (Other Builtins): Document strnlen.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/81384\n\t* gcc.c-torture/execute/builtins/lib/strnlen.c: New test.\n\t* gcc.c-torture/execute/builtins/strnlen-lib.c: New test.\n\t* gcc.c-torture/execute/builtins/strnlen.c: New test.\n\t* gcc.dg/attr-nonstring-2.c: New test.\n\t* gcc.dg/attr-nonstring-3.c: New test.\n\t* gcc.dg/attr-nonstring-4.c: New test.\n\t* gcc.dg/strlenopt-45.c: New test.\n\t* gcc.dg/strlenopt.h (strnlen):  Declare.\n\nFrom-SVN: r261705", "tree": {"sha": "01c31801fe48b1c21114b772785de9eefe119e7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c31801fe48b1c21114b772785de9eefe119e7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7314856c61938db90d66f4cead8e4df73ea5d3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7314856c61938db90d66f4cead8e4df73ea5d3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7314856c61938db90d66f4cead8e4df73ea5d3af"}], "stats": {"total": 1109, "additions": 1042, "deletions": 67}, "files": [{"sha": "6a386d93691ef4444aa0791c829b7bd145621c10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -1,3 +1,19 @@\n+2018-06-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/81384\n+\t* builtin-types.def (BT_FN_SIZE_CONST_STRING_SIZE): New.\n+\t* builtins.c (expand_builtin_strnlen): New function.\n+\t(expand_builtin): Call it.\n+\t(fold_builtin_n): Avoid setting TREE_NO_WARNING.\n+\t* builtins.def (BUILT_IN_STRNLEN): New.\n+\t* calls.c (maybe_warn_nonstring_arg): Handle BUILT_IN_STRNLEN.\n+\tWarn for bounds in excess of maximum object size.\n+\t* tree-ssa-strlen.c (maybe_set_strlen_range): Return tree representing\n+\tsingle-value ranges.  Handle strnlen.\n+\t(handle_builtin_strlen): Handle strnlen.\n+\t(strlen_check_and_optimize_stmt): Same.\n+\t* doc/extend.texi (Other Builtins): Document strnlen.\n+\n 2018-06-18  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \t* tree.c (escaped_string::escape): Replace cast to char * by"}, {"sha": "b01095c420fe486ecb8547dff0665b088aa9fc22", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -318,6 +318,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_INT,\n \t\t     BT_STRING, BT_CONST_STRING, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_SIZE,\n \t\t     BT_STRING, BT_CONST_STRING, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_SIZE_CONST_STRING_SIZE,\n+\t\t     BT_SIZE, BT_CONST_STRING, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_FILEPTR,\n \t\t     BT_INT, BT_CONST_STRING, BT_FILEPTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_FILEPTR,"}, {"sha": "91658e84761b2f6573aa57cfaf920c66dca3b14d", "filename": "gcc/builtins.c", "status": "modified", "additions": 93, "deletions": 12, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -140,6 +140,7 @@ static rtx expand_builtin_memset (tree, rtx, machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n static rtx expand_builtin_strlen (tree, rtx, machine_mode);\n+static rtx expand_builtin_strnlen (tree, rtx, machine_mode);\n static rtx expand_builtin_alloca (tree);\n static rtx expand_builtin_unop (machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n@@ -2820,7 +2821,7 @@ expand_builtin_powi (tree exp, rtx target)\n }\n \n /* Expand expression EXP which is a call to the strlen builtin.  Return\n-   NULL_RTX if we failed the caller should emit a normal call, otherwise\n+   NULL_RTX if we failed and the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient.  */\n \n static rtx\n@@ -2925,6 +2926,74 @@ expand_builtin_strlen (tree exp, rtx target,\n   return target;\n }\n \n+/* Expand call EXP to the strnlen built-in, returning the result\n+   and setting it in TARGET.  Otherwise return NULL_RTX on failure.  */\n+\n+static rtx\n+expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n+{\n+  if (!validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tree src = CALL_EXPR_ARG (exp, 0);\n+  tree bound = CALL_EXPR_ARG (exp, 1);\n+\n+  if (!bound)\n+    return NULL_RTX;\n+\n+  location_t loc = UNKNOWN_LOCATION;\n+  if (EXPR_HAS_LOCATION (exp))\n+    loc = EXPR_LOCATION (exp);\n+\n+  tree maxobjsize = max_object_size ();\n+  tree func = get_callee_fndecl (exp);\n+\n+  tree len = c_strlen (src, 0);\n+\n+  if (TREE_CODE (bound) == INTEGER_CST)\n+    {\n+      if (!TREE_NO_WARNING (exp)\n+\t  && tree_int_cst_lt (maxobjsize, bound)\n+\t  && warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t \"%K%qD specified bound %E \"\n+\t\t\t \"exceeds maximum object size %E\",\n+\t\t\t exp, func, bound, maxobjsize))\n+\t  TREE_NO_WARNING (exp) = true;\n+\n+      if (!len || TREE_CODE (len) != INTEGER_CST)\n+\treturn NULL_RTX;\n+\n+      len = fold_convert_loc (loc, size_type_node, len);\n+      len = fold_build2_loc (loc, MIN_EXPR, size_type_node, len, bound);\n+      return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n+    }\n+\n+  if (TREE_CODE (bound) != SSA_NAME)\n+    return NULL_RTX;\n+\n+  wide_int min, max;\n+  enum value_range_type rng = get_range_info (bound, &min, &max);\n+  if (rng != VR_RANGE)\n+    return NULL_RTX;\n+\n+  if (!TREE_NO_WARNING (exp)\n+      && wi::ltu_p (wi::to_wide (maxobjsize), min)\n+      && warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t     \"%K%qD specified bound [%wu, %wu] \"\n+\t\t     \"exceeds maximum object size %E\",\n+\t\t     exp, func, min.to_uhwi (), max.to_uhwi (), maxobjsize))\n+      TREE_NO_WARNING (exp) = true;\n+\n+  if (!len || TREE_CODE (len) != INTEGER_CST)\n+    return NULL_RTX;\n+\n+  if (wi::gtu_p (min, wi::to_wide (len)))\n+    return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n+\n+  len = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (len), len, bound);\n+  return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n+}\n+\n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n    bytes from constant string DATA + OFFSET and return it as target\n    constant.  */\n@@ -3121,20 +3190,27 @@ check_access (tree exp, tree, tree, tree dstwrite,\n      object size.  */\n   if (range[0] && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n+      if (TREE_NO_WARNING (exp))\n+\treturn false;\n+\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n+      bool warned;\n       if (range[0] == range[1])\n-\twarning_at (loc, opt,\n-\t\t    \"%K%qD specified size %E \"\n-\t\t    \"exceeds maximum object size %E\",\n-\t\t    exp, func, range[0], maxobjsize);\n-\t  else\n-\t    warning_at (loc, opt,\n-\t\t\t\"%K%qD specified size between %E and %E \"\n-\t\t\t\"exceeds maximum object size %E\",\n-\t\t\texp, func,\n-\t\t\trange[0], range[1], maxobjsize);\n+\twarned = warning_at (loc, opt,\n+\t\t\t     \"%K%qD specified size %E \"\n+\t\t\t     \"exceeds maximum object size %E\",\n+\t\t\t     exp, func, range[0], maxobjsize);\n+      else\n+\twarned = warning_at (loc, opt,\n+\t\t\t     \"%K%qD specified size between %E and %E \"\n+\t\t\t     \"exceeds maximum object size %E\",\n+\t\t\t     exp, func,\n+\t\t\t     range[0], range[1], maxobjsize);\n+      if (warned)\n+\tTREE_NO_WARNING (exp) = true;\n+\n       return false;\n     }\n \n@@ -6963,6 +7039,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_STRNLEN:\n+      target = expand_builtin_strnlen (exp, target, target_mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_STRCAT:\n       target = expand_builtin_strcat (exp, target);\n       if (target)\n@@ -9174,7 +9256,6 @@ fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool)\n     {\n       ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n       SET_EXPR_LOCATION (ret, loc);\n-      TREE_NO_WARNING (ret) = 1;\n       return ret;\n     }\n   return NULL_TREE;"}, {"sha": "aacbd513a16692b2733aabc1cee2854d8d3eb99b", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -709,6 +709,7 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCASECMP, \"strncasecmp\", BT_FN_INT_CONST_STR\n DEF_LIB_BUILTIN        (BUILT_IN_STRNCAT, \"strncat\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRNCMP, \"strncmp\", BT_FN_INT_CONST_STRING_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRNCPY, \"strncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNLEN, \"strnlen\", BT_FN_SIZE_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRPBRK, \"strpbrk\", BT_FN_STRING_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRRCHR, \"strrchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRSPN, \"strspn\", BT_FN_SIZE_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)"}, {"sha": "02562ddc1ee87029e0ce59b6f965eb5e89f5c5a9", "filename": "gcc/calls.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -1613,6 +1613,9 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n   if (!fndecl || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n     return;\n \n+  if (TREE_NO_WARNING (exp))\n+    return;\n+\n   unsigned nargs = call_expr_nargs (exp);\n \n   /* The bound argument to a bounded string function like strncpy.  */\n@@ -1647,18 +1650,23 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \n     case BUILT_IN_STPNCPY:\n     case BUILT_IN_STRNCPY:\n-      {\n-\tunsigned argno = 2;\n-\tif (argno < nargs)\n-\t  bound = CALL_EXPR_ARG (exp, argno);\n-\tbreak;\n-      }\n+      if (2 < nargs)\n+\tbound = CALL_EXPR_ARG (exp, 2);\n+      break;\n \n     case BUILT_IN_STRNDUP:\n+      if (1 < nargs)\n+\tbound = CALL_EXPR_ARG (exp, 1);\n+      break;\n+\n+    case BUILT_IN_STRNLEN:\n       {\n-\tunsigned argno = 1;\n-\tif (argno < nargs)\n-\t  bound = CALL_EXPR_ARG (exp, argno);\n+\ttree arg = CALL_EXPR_ARG (exp, 0);\n+\tif (!get_attr_nonstring_decl (arg))\n+\t  get_range_strlen (arg, lenrng);\n+\n+\tif (1 < nargs)\n+\t  bound = CALL_EXPR_ARG (exp, 1);\n \tbreak;\n       }\n \n@@ -1674,6 +1682,29 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n       get_size_range (bound, bndrng);\n     }\n \n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  if (bndrng[0])\n+    {\n+      /* Diagnose excessive bound prior the adjustment below and\n+\t regardless of attribute nonstring.  */\n+      tree maxobjsize = max_object_size ();\n+      if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n+\t{\n+\t  if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n+\t    warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\"%K%qD specified bound %E \"\n+\t\t\t\"exceeds maximum object size %E\",\n+\t\t\texp, fndecl, bndrng[0], maxobjsize);\n+\t  else\n+\t    warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\"%K%qD specified bound [%E, %E] \"\n+\t\t\t\"exceeds maximum object size %E\",\n+\t\t\texp, fndecl, bndrng[0], bndrng[1], maxobjsize);\n+\t  return;\n+\t}\n+    }\n+\n   if (*lenrng)\n     {\n       /* Add one for the nul.  */\n@@ -1766,8 +1797,6 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n       else if (bound == void_type_node)\n \tbound = NULL_TREE;\n \n-      location_t loc = EXPR_LOCATION (exp);\n-\n       bool warned = false;\n \n       if (wi::ltu_p (asize, wibnd))"}, {"sha": "cf88175e7959a62fbc1772196f11cee9296a223a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -11255,6 +11255,7 @@ is called and the @var{flag} argument passed to it.\n @findex strncmp\n @findex strncpy\n @findex strndup\n+@findex strnlen\n @findex strpbrk\n @findex strrchr\n @findex strspn\n@@ -11338,8 +11339,8 @@ Outside strict ISO C mode (@option{-ansi}, @option{-std=c90},\n @code{significandl}, @code{significand}, @code{sincosf},\n @code{sincosl}, @code{sincos}, @code{stpcpy}, @code{stpncpy},\n @code{strcasecmp}, @code{strdup}, @code{strfmon}, @code{strncasecmp},\n-@code{strndup}, @code{toascii}, @code{y0f}, @code{y0l}, @code{y0},\n-@code{y1f}, @code{y1l}, @code{y1}, @code{ynf}, @code{ynl} and\n+@code{strndup}, @code{strnlen}, @code{toascii}, @code{y0f}, @code{y0l},\n+@code{y0}, @code{y1f}, @code{y1l}, @code{y1}, @code{ynf}, @code{ynl} and\n @code{yn}\n may be handled as built-in functions.\n All these functions have corresponding versions"}, {"sha": "024cf6b2437e79b34b3699621b10e31247f8d781", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -1,3 +1,15 @@\n+2018-06-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/81384\n+\t* gcc.c-torture/execute/builtins/lib/strnlen.c: New test.\n+\t* gcc.c-torture/execute/builtins/strnlen-lib.c: New test.\n+\t* gcc.c-torture/execute/builtins/strnlen.c: New test.\n+\t* gcc.dg/attr-nonstring-2.c: New test.\n+\t* gcc.dg/attr-nonstring-3.c: New test.\n+\t* gcc.dg/attr-nonstring-4.c: New test.\n+\t* gcc.dg/strlenopt-45.c: New test.\n+\t* gcc.dg/strlenopt.h (strnlen):  Declare.\n+\n 2018-06-18  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \tPR tree-optimization/86076"}, {"sha": "b1eb8b63004268d0605ac80c38e8f6778099c2a3", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -66,7 +66,7 @@ struct MemArrays\n void sink (int, ...);\n \n \n-#define T(call)  sink (0, (call))\n+#define T(call)  sink (0, call)\n \n void test_printf (struct MemArrays *p)\n {\n@@ -250,14 +250,14 @@ void test_stpncpy_warn (struct MemArrays *p, unsigned n)\n \n   T (stpncpy (ptr, str, N + 1));\n   T (stpncpy (ptr, arr, N + 1));          /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n-  T (stpncpy (arr, str, N + 1));          /* { dg-warning \"writing 5 bytes into a region of size 4 overflows \" \"bug 82609\" { xfail c++ } } */\n+  T (stpncpy (arr, str, N + 1));          /* { dg-warning \"writing 5 bytes into a region of size 4 overflows \" } */\n \n   T (stpncpy (ptr, ptr, N + 1));\n   T (stpncpy (ptr, parr, N + 1));\n   T (stpncpy (parr, str, N + 1));\n \n   T (stpncpy (ptr, p->arr, N + 1));       /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller\" } */\n-  T (stpncpy (p->arr, p->str, N + 1));    /* { dg-warning \"writing 5 bytes into a region of size 4 overflows\" \"bug 82609\" { xfail c++ } } */\n+  T (stpncpy (p->arr, p->str, N + 1));    /* { dg-warning \"writing 5 bytes into a region of size 4 overflows \" } */\n   T (stpncpy (p->parr, p->str, N + 1));\n }\n "}, {"sha": "73ada14eb952e528e530b312ba3b781577f34032", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strnlen.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrnlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrnlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrnlen.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,22 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern int inside_main;\n+\n+__attribute__ ((__noinline__))\n+size_t\n+strnlen (const char *s, size_t n)\n+{\n+  size_t i;\n+\n+#ifdef __OPTIMIZE__\n+  if (inside_main)\n+    abort ();\n+#endif\n+\n+  i = 0;\n+  while (s[i] != 0 && n--)\n+    i++;\n+\n+  return i;\n+}"}, {"sha": "bf9194012f1580590a604f10e8198e202dfe1ee2", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strnlen-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen-lib.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/strnlen.c\""}, {"sha": "2368d06e95dff371ed63423586a17bdc6f8110aa", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strnlen.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrnlen.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,95 @@\n+/* PR tree-optimization/81384 - built-in form of strnlen missing\n+   Test to verify that strnlen built-in expansion works correctly\n+   in the absence of tree strlen optimization.\n+   { dg-do run }\n+   { do-options \"-O2 -fno-tree-strlen\" }  */\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define SIZE_MAX    __SIZE_MAX__\n+#define NOIPA __attribute__ ((noipa))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern size_t strnlen (const char *, size_t);\n+\n+#define A(expr)\t\t\t\t\t\t\t\\\n+  ((expr) ? (void)0\t\t\t\t\t\t\\\n+   : (__builtin_printf (\"assertion on line %i failed: %s\\n\",\t\\\n+\t\t\t__LINE__, #expr),\t\t\t\\\n+      abort ()))\n+\n+NOIPA void test_strnlen_str_cst (void)\n+{\n+  A (strnlen (\"\", 0) == 0);\n+  A (strnlen (\"\", 1) == 0);\n+  A (strnlen (\"\", 9) == 0);\n+  A (strnlen (\"\", PTRDIFF_MAX) == 0);\n+  A (strnlen (\"\", SIZE_MAX) == 0);\n+  A (strnlen (\"\", -1) == 0);\n+\n+  A (strnlen (\"1\", 0) == 0);\n+  A (strnlen (\"1\", 1) == 1);\n+  A (strnlen (\"1\", 9) == 1);\n+  A (strnlen (\"1\", PTRDIFF_MAX) == 1);\n+  A (strnlen (\"1\", SIZE_MAX) == 1);\n+  A (strnlen (\"1\", -2) == 1);\n+\n+  A (strnlen (\"123\", 0) == 0);\n+  A (strnlen (\"123\", 1) == 1);\n+  A (strnlen (\"123\", 2) == 2);\n+  A (strnlen (\"123\", 3) == 3);\n+  A (strnlen (\"123\", 9) == 3);\n+  A (strnlen (\"123\", PTRDIFF_MAX) == 3);\n+  A (strnlen (\"123\", SIZE_MAX) == 3);\n+  A (strnlen (\"123\", -2) == 3);\n+}\n+\n+NOIPA void test_strnlen_str_range (size_t x)\n+{\n+  size_t r_0_3 = x & 3;\n+  size_t r_1_3 = r_0_3 | 1;\n+  size_t r_2_3 = r_0_3 | 2;\n+\n+  A (strnlen (\"\",     r_0_3) == 0);\n+  A (strnlen (\"1\",    r_0_3) <= 1);\n+  A (strnlen (\"12\",   r_0_3) <= 2);\n+  A (strnlen (\"123\",  r_0_3) <= 3);\n+  A (strnlen (\"1234\", r_0_3) <= 3);\n+\n+  A (strnlen (\"\",     r_1_3) == 0);\n+  A (strnlen (\"1\",    r_1_3) == 1);\n+  A (strnlen (\"12\",   r_1_3) <= 2);\n+  A (strnlen (\"123\",  r_1_3) <= 3);\n+  A (strnlen (\"1234\", r_1_3) <= 3);\n+\n+  A (strnlen (\"\",     r_2_3) == 0);\n+  A (strnlen (\"1\",    r_2_3) == 1);\n+  A (strnlen (\"12\",   r_2_3) == 2);\n+  A (strnlen (\"123\",  r_2_3) <= 3);\n+  A (strnlen (\"1234\", r_2_3) <= 3);\n+}\n+\n+NOIPA void test_strnlen_str_range_side_effect (size_t x)\n+{\n+  size_t r_0_3 = x & 3;\n+  size_t r_1_3 = r_0_3 | 1;\n+  size_t r_2_3 = r_0_3 | 2;\n+  size_t n = r_2_3;\n+\n+  int i = 0;\n+\n+  A (strnlen (\"1234\" + i++, n) <= 3);\n+  A (i == 1);\n+\n+  A (strnlen (\"1234\", n++) <= 3);\n+  A (n == r_2_3 + 1);\n+}\n+\n+void\n+main_test (void)\n+{\n+  test_strnlen_str_cst ();\n+  test_strnlen_str_range ((size_t)\"\");\n+  test_strnlen_str_range_side_effect ((size_t)\"\");\n+}"}, {"sha": "e9edb661b9aec0c5d64ac10ac23108e440eff914", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-2.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,115 @@\n+/* PR middle-end/81384 - built-in form of strnlen missing\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern size_t strnlen (const char*, size_t);\n+\n+#define NONSTRING __attribute__ ((nonstring))\n+\n+#define _CAT(s, n)   s ## n\n+#define CAT(s, n)    _CAT (s, n)\n+#define UNIQ(n)      CAT (n, __LINE__)\n+\n+void sink (size_t, ...);\n+\n+#define T(expr)   sink (expr)\n+\n+void test_strnlen_array_cst (void)\n+{\n+  NONSTRING char ns3[3];\n+  sink (0, ns3);    // \"initialize\" ns3\n+\n+  T (strnlen (ns3, 0));\n+  T (strnlen (ns3, 1));\n+  T (strnlen (ns3, 2));\n+  T (strnlen (ns3, 3));\n+  T (strnlen (ns3, 4));             /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n+  T (strnlen (ns3, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\[0-9\\]+\" } */\n+  T (strnlen (ns3, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  NONSTRING char ns5[5];\n+  sink (0, ns5);\n+\n+  T (strnlen (ns5, 0));\n+  T (strnlen (ns5, 1));\n+  T (strnlen (ns5, 2));\n+  T (strnlen (ns5, 3));\n+  T (strnlen (ns5, 6));             /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 6\" } */\n+  T (strnlen (ns5, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\[0-9\\]+\" } */\n+  T (strnlen (ns5, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+}\n+\n+\n+void test_strnlen_array_range (void)\n+{\n+  NONSTRING char ns3[3];\n+  sink (0, ns3);    // \"initialize\" ns3\n+\n+  T (strnlen (ns3, UR (0, 3)));\n+  T (strnlen (ns3, UR (0, 9)));\n+  T (strnlen (ns3, UR (3, 4)));\n+  T (strnlen (ns3, UR (3, DIFF_MAX)));\n+  T (strnlen (ns3, UR (4, 5)));     /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\[0-9\\]+\" } */\n+  T (strnlen (ns3, UR (DIFF_MAX, SIZE_MAX)));  /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller \" } */\n+}\n+\n+\n+#undef T\n+#define T(N, init, nelts, bound)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    extern NONSTRING char UNIQ (arr)[N];\t\t\\\n+    memcpy (UNIQ (arr), init, nelts);\t\t\t\\\n+    sink (strnlen (UNIQ (arr), bound), UNIQ (arr));\t\\\n+  } while (0)\n+\n+void test_strnlen_string_cst (void)\n+{\n+  T (3, \"1\",   2, 1);\n+  T (3, \"1\",   2, 2);\n+  T (3, \"1\",   2, 3);\n+  T (3, \"12\",  3, 1);\n+  T (3, \"12\",  3, 9);\n+  T (3, \"123\", 3, 1);\n+  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n+  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" } */\n+\n+  T (5, \"1\",   2, 1);\n+  T (5, \"1\",   2, 2);\n+  T (5, \"1\",   2, 9);\n+\n+  T (5, \"12\",  3, 1);\n+  T (5, \"12\",  3, 9);\n+  T (5, \"123\", 3, 1);\n+  T (5, \"123\", 3, 5);\n+  T (5, \"123\", 3, 6);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 6\" } */\n+\n+  /* Strnlen shouldn't trigger a warning for arrays of unknown size\n+     (except for accesses to uninitialized elements when those are\n+     detected).  */\n+  T (/* [] */, \"1\", 1, 1);\n+  T (/* [] */, \"1\", 1, 2);\n+  T (/* [] */, \"1\", 2, 1);\n+  T (/* [] */, \"1\", 2, 2);\n+  T (/* [] */, \"1\", 2, 3);\n+  T (/* [] */, \"1\", 2, 9);\n+  T (/* [] */, \"1\", 2, DIFF_MAX);\n+  T (/* [] */, \"1\", 2, SIZE_MAX);\n+\n+  size_t n = DIFF_MAX;\n+  T (/* [] */, \"123\", 3, n);\n+  T (/* [] */, \"123\", 3, n + 1);    /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \" } */\n+  n = SIZE_MAX;\n+  T (/* [] */, \"123\", 3, n);        /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \" } */\n+}\n+\n+\n+void test_strnlen_string_range (void)\n+{\n+  T (3, \"1\",   2, UR (0, 1));\n+  T (3, \"1\",   2, UR (3, 9));\n+  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n+  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+}"}, {"sha": "4a1045045550348546b036eaa7fd0979a8d494fd", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-3.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-3.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,117 @@\n+/* PR middle-end/81384 - built-in form of strnlen missing\n+\n+   Since the strnlen patch affects the handling for strncmp and other\n+   bounded functions, verify that a bound in excess of the maximum\n+   object size specified for strncmp is diagnosed regardless of\n+   attribute nonstring.  Also verify that a bound that's greater than\n+   the size of a non-string array is diagnosed, even if it's not in\n+   excess of the maximum object size.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+extern int strncmp (const char*, const char*, size_t);\n+\n+#define STR   /* not non-string */\n+#define NS    __attribute__ ((nonstring))\n+\n+#define _CAT(s, n)   s ## n\n+#define CAT(s, n)    _CAT (s, n)\n+#define UNIQ(n)      CAT (n, __LINE__)\n+\n+void sink (int);\n+\n+#define T(at1, N1, at2, N2, bound)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern at1 char UNIQ (a)[N1];\t\t\\\n+    extern at2 char UNIQ (b)[N2];\t\t\\\n+    sink (strncmp (UNIQ (a), UNIQ (b), bound));\t\\\n+  } while (0)\n+\n+void strncmp_cst (void)\n+{\n+  size_t n = DIFF_MAX;\n+\n+  T (STR, /* [] */, STR, /* [] */, n);\n+  T (STR, /* [] */, STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 1, STR, /* [] */, n);\n+  T (STR, 2, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, STR, 3, n);\n+  T (STR, /* [] */, STR, 4, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, NS, /* [] */, n);\n+  T (STR, /* [] */, NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 5, NS, /* [] */, n);\n+  T (STR, 6, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, NS, 7, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+\n+  T (STR, /* [] */, NS, 8, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, STR, /* [] */, n);\n+  T (NS, /* [] */, STR, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 9, STR, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 10, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, STR, 11, n);\n+  T (NS, /* [] */, STR, 12, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, NS, /* [] */, n);\n+  T (NS, /* [] */, NS, /* [] */, n + 1);      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 13, NS, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 14, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, NS, 15, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, /* [] */, NS, 16, n + 1);            /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+}\n+\n+\n+void strncmp_range (void)\n+{\n+  size_t n = DIFF_MAX;\n+  n = UR (n, n + 1);\n+\n+  T (STR, /* [] */, STR, /* [] */, n);\n+  T (STR, /* [] */, STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 1, STR, /* [] */, n);\n+  T (STR, 2, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, STR, 3, n);\n+  T (STR, /* [] */, STR, 4, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, NS, /* [] */, n);\n+  T (STR, /* [] */, NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 5, NS, /* [] */, n);\n+  T (STR, 6, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, /* [] */, NS, 7, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+\n+  T (STR, /* [] */, NS, 8, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, STR, /* [] */, n);\n+  T (NS, /* [] */, STR, /* [] */, n + 1);     /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 9, STR, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 10, STR, /* [] */, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, STR, 11, n);\n+  T (NS, /* [] */, STR, 12, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, NS, /* [] */, n);\n+  T (NS, /* [] */, NS, /* [] */, n + 1);      /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 13, NS, /* [] */, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 14, NS, /* [] */, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, NS, 15, n);                /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, /* [] */, NS, 16, n + 1);            /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+}"}, {"sha": "7daff9754c720fee7554c1b3d878b9eda373c619", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-4.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,64 @@\n+/* PR middle-end/81384 - built-in form of strnlen missing\n+\n+   Verify that a strnlen bound in excess of the maximum object size\n+   is diagnosed regardless of attribute nonstring.  Also verify that\n+   a bound that's greater than the size of a non-string array is\n+   diagnosed, even if it's not in excess of the maximum object size.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+extern size_t strnlen (const char*, size_t);\n+\n+#define STR   /* not non-string */\n+#define NS    __attribute__ ((nonstring))\n+\n+#define _CAT(s, n)   s ## n\n+#define CAT(s, n)    _CAT (s, n)\n+#define UNIQ(n)      CAT (n, __LINE__)\n+\n+void sink (size_t);\n+\n+#define T(attr, N, bound)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern attr char UNIQ (a)[N];\t\t\\\n+    sink (strnlen (UNIQ (a), bound));\t\t\\\n+  } while (0)\n+\n+void strnlen_cst (void)\n+{\n+  size_t n = DIFF_MAX;\n+\n+  T (STR, /* [] */, n);\n+  T (STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 1, n);\n+  T (STR, 2, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, n);\n+  T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+}\n+\n+\n+void strnlen_range (void)\n+{\n+  size_t n = DIFF_MAX;\n+  n = UR (n, n + 1);\n+\n+  T (STR, /* [] */, n);\n+  T (STR, /* [] */, n + 1);    /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (STR, 1, n);\n+  T (STR, 2, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, /* [] */, n);\n+  T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+\n+  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound\" } */\n+  T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n+}"}, {"sha": "bd9b197a75d6913407ead49dc303903a81c7b5ad", "filename": "gcc/testsuite/gcc.dg/strlenopt-45.c", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -0,0 +1,335 @@\n+/* PR tree-optimization/81384 - built-in form of strnlen missing\n+   Test to verify that strnlen built-in expansion works correctly\n+   in the absence of tree strlen optimization.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+#define SIZE_MAX    __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern size_t strnlen (const char *, size_t);\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+extern char c;\n+extern char a1[1];\n+extern char a3[3];\n+extern char a5[5];\n+extern char a3_7[3][7];\n+extern char ax[];\n+\n+void elim_strnlen_arr_cst (void)\n+{\n+  /* The length of a string stored in a one-element array must be zero.\n+     The result reported by strnlen() for such an array can be non-zero\n+     only when the bound is equal to 1 (in which case the result must\n+     be one).  */\n+  ELIM (strnlen (&c, 0) == 0);\n+  ELIM (strnlen (&c, 1) < 2);\n+  ELIM (strnlen (&c, 2) == 0);\n+  ELIM (strnlen (&c, 9) == 0);\n+  ELIM (strnlen (&c, PTRDIFF_MAX) == 0);\n+  ELIM (strnlen (&c, SIZE_MAX) == 0);\n+  ELIM (strnlen (&c, -1) == 0);\n+\n+  ELIM (strnlen (a1, 0) == 0);\n+  ELIM (strnlen (a1, 1) < 2);\n+  ELIM (strnlen (a1, 2) == 0);\n+  ELIM (strnlen (a1, 9) == 0);\n+  ELIM (strnlen (a1, PTRDIFF_MAX) == 0);\n+  ELIM (strnlen (a1, SIZE_MAX) == 0);\n+  ELIM (strnlen (a1, -1) == 0);\n+\n+  ELIM (strnlen (a3, 0) == 0);\n+  ELIM (strnlen (a3, 1) < 2);\n+  ELIM (strnlen (a3, 2) < 3);\n+  ELIM (strnlen (a3, 3) < 4);\n+  ELIM (strnlen (a3, 9) < 4);\n+  ELIM (strnlen (a3, PTRDIFF_MAX) < 4);\n+  ELIM (strnlen (a3, SIZE_MAX) < 4);\n+  ELIM (strnlen (a3, -1) < 4);\n+\n+  ELIM (strnlen (a3_7[0], 0) == 0);\n+  ELIM (strnlen (a3_7[0], 1) < 2);\n+  ELIM (strnlen (a3_7[0], 2) < 3);\n+  ELIM (strnlen (a3_7[0], 3) < 4);\n+  ELIM (strnlen (a3_7[0], 9) < 8);\n+  ELIM (strnlen (a3_7[0], PTRDIFF_MAX) < 8);\n+  ELIM (strnlen (a3_7[0], SIZE_MAX) < 8);\n+  ELIM (strnlen (a3_7[0], -1) < 8);\n+\n+  ELIM (strnlen (a3_7[2], 0) == 0);\n+  ELIM (strnlen (a3_7[2], 1) < 2);\n+  ELIM (strnlen (a3_7[2], 2) < 3);\n+  ELIM (strnlen (a3_7[2], 3) < 4);\n+  ELIM (strnlen (a3_7[2], 9) < 8);\n+  ELIM (strnlen (a3_7[2], PTRDIFF_MAX) < 8);\n+  ELIM (strnlen (a3_7[2], SIZE_MAX) < 8);\n+  ELIM (strnlen (a3_7[2], -1) < 8);\n+\n+  ELIM (strnlen ((char*)a3_7, 0) == 0);\n+  ELIM (strnlen ((char*)a3_7, 1) < 2);\n+  ELIM (strnlen ((char*)a3_7, 2) < 3);\n+  ELIM (strnlen ((char*)a3_7, 3) < 4);\n+  ELIM (strnlen ((char*)a3_7, 9) < 10);\n+  ELIM (strnlen ((char*)a3_7, 19) < 20);\n+  ELIM (strnlen ((char*)a3_7, 21) < 22);\n+  ELIM (strnlen ((char*)a3_7, 23) < 22);\n+  ELIM (strnlen ((char*)a3_7, PTRDIFF_MAX) < 22);\n+  ELIM (strnlen ((char*)a3_7, SIZE_MAX) < 22);\n+  ELIM (strnlen ((char*)a3_7, -1) < 22);\n+\n+  ELIM (strnlen (ax, 0) == 0);\n+  ELIM (strnlen (ax, 1) < 2);\n+  ELIM (strnlen (ax, 2) < 3);\n+  ELIM (strnlen (ax, 9) < 10);\n+  ELIM (strnlen (a3, PTRDIFF_MAX) <= PTRDIFF_MAX);\n+  ELIM (strnlen (a3, SIZE_MAX) < PTRDIFF_MAX);\n+  ELIM (strnlen (a3, -1) < PTRDIFF_MAX);\n+}\n+\n+struct MemArrays\n+{\n+  char c;\n+  char a0[0];\n+  char a1[1];\n+  char a3[3];\n+  char a5[5];\n+  char a3_7[3][7];\n+  char ax[1];\n+};\n+\n+void elim_strnlen_memarr_cst (struct MemArrays *p, int i)\n+{\n+  ELIM (strnlen (&p->c, 0) == 0);\n+  ELIM (strnlen (&p->c, 1) < 2);\n+  ELIM (strnlen (&p->c, 9) == 0);\n+  ELIM (strnlen (&p->c, PTRDIFF_MAX) == 0);\n+  ELIM (strnlen (&p->c, SIZE_MAX) == 0);\n+  ELIM (strnlen (&p->c, -1) == 0);\n+\n+  /* Other accesses to internal zero-length arrays are undefined.  */\n+  ELIM (strnlen (p->a0, 0) == 0);\n+\n+  ELIM (strnlen (p->a1, 0) == 0);\n+  ELIM (strnlen (p->a1, 1) < 2);\n+  ELIM (strnlen (p->a1, 9) == 0);\n+  ELIM (strnlen (p->a1, PTRDIFF_MAX) == 0);\n+  ELIM (strnlen (p->a1, SIZE_MAX) == 0);\n+  ELIM (strnlen (p->a1, -1) == 0);\n+\n+  ELIM (strnlen (p->a3, 0) == 0);\n+  ELIM (strnlen (p->a3, 1) < 2);\n+  ELIM (strnlen (p->a3, 2) < 3);\n+  ELIM (strnlen (p->a3, 3) < 4);\n+  ELIM (strnlen (p->a3, 9) < 4);\n+  ELIM (strnlen (p->a3, PTRDIFF_MAX) < 4);\n+  ELIM (strnlen (p->a3, SIZE_MAX) < 4);\n+  ELIM (strnlen (p->a3, -1) < 4);\n+\n+  ELIM (strnlen (p[i].a3, 0) == 0);\n+  ELIM (strnlen (p[i].a3, 1) < 2);\n+  ELIM (strnlen (p[i].a3, 2) < 3);\n+  ELIM (strnlen (p[i].a3, 3) < 4);\n+  ELIM (strnlen (p[i].a3, 9) < 4);\n+  ELIM (strnlen (p[i].a3, PTRDIFF_MAX) < 4);\n+  ELIM (strnlen (p[i].a3, SIZE_MAX) < 4);\n+  ELIM (strnlen (p[i].a3, -1) < 4);\n+\n+  ELIM (strnlen (p->a3_7[0], 0) == 0);\n+  ELIM (strnlen (p->a3_7[0], 1) < 2);\n+  ELIM (strnlen (p->a3_7[0], 2) < 3);\n+  ELIM (strnlen (p->a3_7[0], 3) < 4);\n+  ELIM (strnlen (p->a3_7[0], 9) < 8);\n+  ELIM (strnlen (p->a3_7[0], PTRDIFF_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[0], SIZE_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[0], -1) < 8);\n+\n+  ELIM (strnlen (p->a3_7[2], 0) == 0);\n+  ELIM (strnlen (p->a3_7[2], 1) < 2);\n+  ELIM (strnlen (p->a3_7[2], 2) < 3);\n+  ELIM (strnlen (p->a3_7[2], 3) < 4);\n+  ELIM (strnlen (p->a3_7[2], 9) < 8);\n+  ELIM (strnlen (p->a3_7[2], PTRDIFF_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[2], SIZE_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[2], -1) < 8);\n+\n+  ELIM (strnlen (p->a3_7[i], 0) == 0);\n+  ELIM (strnlen (p->a3_7[i], 1) < 2);\n+  ELIM (strnlen (p->a3_7[i], 2) < 3);\n+  ELIM (strnlen (p->a3_7[i], 3) < 4);\n+\n+#if 0\n+  /* This is tranformed into strnlen ((char*)p + offsetof (a3_7[i]), N)\n+     which makes it impssible to determine the size of the array.  */\n+  ELIM (strnlen (p->a3_7[i], 9) < 8);\n+  ELIM (strnlen (p->a3_7[i], PTRDIFF_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[i], SIZE_MAX) < 8);\n+  ELIM (strnlen (p->a3_7[i], -1) < 8);\n+#else\n+  ELIM (strnlen (p->a3_7[i], 9) < 10);\n+  ELIM (strnlen (p->a3_7[i], 19) < 20);\n+#endif\n+\n+  ELIM (strnlen ((char*)p->a3_7, 0) == 0);\n+  ELIM (strnlen ((char*)p->a3_7, 1) < 2);\n+  ELIM (strnlen ((char*)p->a3_7, 2) < 3);\n+  ELIM (strnlen ((char*)p->a3_7, 3) < 4);\n+  ELIM (strnlen ((char*)p->a3_7, 9) < 10);\n+  ELIM (strnlen ((char*)p->a3_7, 19) < 20);\n+  ELIM (strnlen ((char*)p->a3_7, 21) < 22);\n+  ELIM (strnlen ((char*)p->a3_7, 23) < 22);\n+  ELIM (strnlen ((char*)p->a3_7, PTRDIFF_MAX) < 22);\n+  ELIM (strnlen ((char*)p->a3_7, SIZE_MAX) < 22);\n+  ELIM (strnlen ((char*)p->a3_7, -1) < 22);\n+\n+  ELIM (strnlen (p->ax, 0) == 0);\n+  ELIM (strnlen (p->ax, 1) < 2);\n+  ELIM (strnlen (p->ax, 2) < 3);\n+  ELIM (strnlen (p->ax, 9) < 10);\n+  ELIM (strnlen (p->a3, PTRDIFF_MAX) <= PTRDIFF_MAX);\n+  ELIM (strnlen (p->a3, SIZE_MAX) < PTRDIFF_MAX);\n+  ELIM (strnlen (p->a3, -1) < PTRDIFF_MAX);\n+}\n+\n+\n+void elim_strnlen_str_cst (void)\n+{\n+  const char *s0 = \"\";\n+  const char *s1 = \"1\";\n+  const char *s3 = \"123\";\n+\n+  ELIM (strnlen (s0, 0) == 0);\n+  ELIM (strnlen (s0, 1) == 0);\n+  ELIM (strnlen (s0, 9) == 0);\n+  ELIM (strnlen (s0, PTRDIFF_MAX) == 0);\n+  ELIM (strnlen (s0, SIZE_MAX) == 0);\n+  ELIM (strnlen (s0, -1) == 0);\n+\n+  ELIM (strnlen (s1, 0) == 0);\n+  ELIM (strnlen (s1, 1) == 1);\n+  ELIM (strnlen (s1, 9) == 1);\n+  ELIM (strnlen (s1, PTRDIFF_MAX) == 1);\n+  ELIM (strnlen (s1, SIZE_MAX) == 1);\n+  ELIM (strnlen (s1, -2) == 1);\n+\n+  ELIM (strnlen (s3, 0) == 0);\n+  ELIM (strnlen (s3, 1) == 1);\n+  ELIM (strnlen (s3, 2) == 2);\n+  ELIM (strnlen (s3, 3) == 3);\n+  ELIM (strnlen (s3, 9) == 3);\n+  ELIM (strnlen (s3, PTRDIFF_MAX) == 3);\n+  ELIM (strnlen (s3, SIZE_MAX) == 3);\n+  ELIM (strnlen (s3, -2) == 3);\n+}\n+\n+void elim_strnlen_range (char *s)\n+{\n+  const char *s0 = \"\";\n+  const char *s1 = \"1\";\n+  const char *s3 = \"123\";\n+\n+  size_t n_0_1 = (size_t)s & 1;\n+  size_t n_0_2 = ((size_t)s & 3) < 3 ? ((size_t)s & 3) : 2;\n+  size_t n_0_3 = (size_t)s & 3;\n+  size_t n_1_2 = n_0_1 + 1;\n+\n+  ELIM (strnlen (s0, n_0_1) == 0);\n+  ELIM (strnlen (s0, n_0_2) == 0);\n+  ELIM (strnlen (s0, n_1_2) == 0);\n+\n+  ELIM (strnlen (s1, n_0_1) < 2);\n+  ELIM (strnlen (s1, n_0_2) < 2);\n+  ELIM (strnlen (s1, n_0_3) < 2);\n+\n+  ELIM (strnlen (s1, n_1_2) > 0);\n+  ELIM (strnlen (s1, n_1_2) < 2);\n+\n+  ELIM (strnlen (s3, n_0_1) < 2);\n+  ELIM (strnlen (s3, n_0_2) < 3);\n+  ELIM (strnlen (s3, n_0_3) < 4);\n+\n+  ELIM (strnlen (s3, n_1_2) > 0);\n+  ELIM (strnlen (s3, n_1_2) < 4);\n+}\n+\n+\n+#line 1000\n+\n+void keep_strnlen_arr_cst (void)\n+{\n+  KEEP (strnlen (&c, 1) == 0);\n+  KEEP (strnlen (&c, 1) == 1);\n+\n+  KEEP (strnlen (a1, 1) == 0);\n+  KEEP (strnlen (a1, 1) == 1);\n+\n+  KEEP (strnlen (ax, 9) < 9);\n+}\n+\n+struct FlexArrays\n+{\n+  char c;\n+  char a0[0];   /* Access to internal zero-length arrays are undefined.  */\n+  char a1[1];\n+};\n+\n+void keep_strnlen_memarr_cst (struct FlexArrays *p)\n+{\n+  KEEP (strnlen (&p->c, 1) == 0);\n+  KEEP (strnlen (&p->c, 1) == 1);\n+\n+#if 0\n+  /* Accesses to internal zero-length arrays are undefined so avoid\n+     exercising them.  */\n+  KEEP (strnlen (p->a0, 1) == 0);\n+  KEEP (strnlen (p->a0, 1) == 1);\n+  KEEP (strnlen (p->a0, 9) < 9);\n+#endif\n+\n+  KEEP (strnlen (p->a1, 1) == 0);\n+  KEEP (strnlen (p->a1, 1) == 1);\n+\n+  KEEP (strnlen (p->a1, 2) == 0);\n+  KEEP (strnlen (p->a1, 2) == 1);\n+  KEEP (strnlen (p->a1, 2) == 2);\n+\n+  KEEP (strnlen (p->a1, 9) < 9);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 13 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 13 \"optimized\" } } */"}, {"sha": "a4044fd28f56017ee02d33705018fa996acbf621", "filename": "gcc/testsuite/gcc.dg/strlenopt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -9,6 +9,7 @@ void *malloc (size_t);\n void free (void *);\n char *strdup (const char *);\n size_t strlen (const char *);\n+size_t strnlen (const char *, size_t);\n void *memcpy (void *__restrict, const void *__restrict, size_t);\n void *memmove (void *, const void *, size_t);\n char *strcpy (char *__restrict, const char *__restrict);"}, {"sha": "693d9d3491a273a3fb9517e167579b65fcaae640", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 122, "deletions": 39, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781ff3d80e88d7d0df019eb3e82ef2a3fb64429c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=781ff3d80e88d7d0df019eb3e82ef2a3fb64429c", "patch": "@@ -1124,16 +1124,17 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n   update_stmt (last.stmt);\n }\n \n-/* For an LHS that is an SSA_NAME with integer type and for strlen()\n-   argument SRC, set LHS range info to [0, N] if SRC refers to\n-   a character array A[N] with unknown length bounded by N.  */\n+/* For an LHS that is an SSA_NAME and for strlen() or strnlen() argument\n+   SRC, set LHS range info to [0, min (N, BOUND)] if SRC refers to\n+   a character array A[N] with unknown length bounded by N, and for\n+   strnlen(), by min (N, BOUND).  */\n \n-static void\n-maybe_set_strlen_range (tree lhs, tree src)\n+static tree\n+maybe_set_strlen_range (tree lhs, tree src, tree bound)\n {\n   if (TREE_CODE (lhs) != SSA_NAME\n       || !INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-    return;\n+    return NULL_TREE;\n \n   if (TREE_CODE (src) == SSA_NAME)\n     {\n@@ -1143,24 +1144,87 @@ maybe_set_strlen_range (tree lhs, tree src)\n \tsrc = gimple_assign_rhs1 (def);\n     }\n \n-  if (TREE_CODE (src) != ADDR_EXPR)\n-    return;\n+  wide_int max = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  wide_int min = wi::zero (max.get_precision ());\n \n-  /* The last array member of a struct can be bigger than its size\n-     suggests if it's treated as a poor-man's flexible array member.  */\n-  src = TREE_OPERAND (src, 0);\n-  if (TREE_CODE (TREE_TYPE (src)) != ARRAY_TYPE\n-      || array_at_struct_end_p (src))\n-    return;\n+  if (TREE_CODE (src) == ADDR_EXPR)\n+    {\n+      /* The last array member of a struct can be bigger than its size\n+\t suggests if it's treated as a poor-man's flexible array member.  */\n+      src = TREE_OPERAND (src, 0);\n+      bool src_is_array = TREE_CODE (TREE_TYPE (src)) == ARRAY_TYPE;\n+      if (src_is_array && !array_at_struct_end_p (src))\n+\t{\n+\t  tree type = TREE_TYPE (src);\n+\t  if (tree dom = TYPE_DOMAIN (type))\n+\t    {\n+\t      tree maxval = TYPE_MAX_VALUE (dom);\n+\t      if (maxval)\n+\t\tmax = wi::to_wide (maxval);\n+\t      else\n+\t\tmax = wi::zero (min.get_precision ());\n+\n+\t      /* For strlen() the upper bound above is equal to\n+\t\t the longest string that can be stored in the array\n+\t\t (i.e., it accounts for the terminating nul.  For\n+\t\t strnlen() bump up the maximum by one since the array\n+\t\t need not be nul-terminated.  */\n+\t      if (bound)\n+\t\t++max;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (TREE_CODE (src) == COMPONENT_REF && !src_is_array)\n+\t    src = TREE_OPERAND (src, 1);\n+\t  if (DECL_P (src))\n+\t    {\n+\t      /* Handle the unlikely case of strlen (&c) where c is some\n+\t\t variable.  */\n+\t      if (tree size = DECL_SIZE_UNIT (src))\n+\t\tif (TREE_CODE (size) == INTEGER_CST)\n+\t\t  max = wi::to_wide (size);\n+\t    }\n+\t}\n+    }\n \n-  tree type = TREE_TYPE (src);\n-  if (tree dom = TYPE_DOMAIN (type))\n-    if (tree maxval = TYPE_MAX_VALUE (dom))\n-      {\n-\twide_int max = wi::to_wide (maxval);\n-\twide_int min = wi::zero (max.get_precision ());\n-\tset_range_info (lhs, VR_RANGE, min, max);\n-      }\n+  if (bound)\n+    {\n+      /* For strnlen, adjust MIN and MAX as necessary.  If the bound\n+\t is less than the size of the array set MAX to it.  It it's\n+\t greater than MAX and MAX is non-zero bump MAX down to account\n+\t for the necessary terminating nul.  Otherwise leave it alone.  */\n+      if (TREE_CODE (bound) == INTEGER_CST)\n+\t{\n+\t  wide_int wibnd = wi::to_wide (bound);\n+\t  int cmp = wi::cmpu (wibnd, max);\n+\t  if (cmp < 0)\n+\t    max = wibnd;\n+\t  else if (cmp && wi::ne_p (max, min))\n+\t    --max;\n+\t}\n+      else if (TREE_CODE (bound) == SSA_NAME)\n+\t{\n+\t  wide_int minbound, maxbound;\n+\t  value_range_type rng = get_range_info (bound, &minbound, &maxbound);\n+\t  if (rng == VR_RANGE)\n+\t    {\n+\t      /* For a bound in a known range, adjust the range determined\n+\t\t above as necessary.  For a bound in some anti-range or\n+\t\t in an unknown range, use the range determined above.  */\n+\t      if (wi::ltu_p (minbound, min))\n+\t\tmin = minbound;\n+\t      if (wi::ltu_p (maxbound, max))\n+\t\tmax = maxbound;\n+\t    }\n+\t}\n+    }\n+\n+  if (min == max)\n+    return wide_int_to_tree (size_type_node, min);\n+\n+  set_range_info (lhs, VR_RANGE, min, max);\n+  return lhs;\n }\n \n /* Handle a strlen call.  If strlen of the argument is known, replace\n@@ -1170,16 +1234,18 @@ maybe_set_strlen_range (tree lhs, tree src)\n static void\n handle_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n-  int idx;\n-  tree src;\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (lhs == NULL_TREE)\n     return;\n \n-  src = gimple_call_arg (stmt, 0);\n-  idx = get_stridx (src);\n+  location_t loc = gimple_location (stmt);\n+  tree callee = gimple_call_fndecl (stmt);\n+  tree src = gimple_call_arg (stmt, 0);\n+  tree bound = (DECL_FUNCTION_CODE (callee) == BUILT_IN_STRNLEN\n+\t\t? gimple_call_arg (stmt, 1) : NULL_TREE);\n+  int idx = get_stridx (src);\n   if (idx)\n     {\n       strinfo *si = NULL;\n@@ -1203,8 +1269,9 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t    }\n \t  rhs = unshare_expr (rhs);\n \t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\t    rhs = fold_convert_loc (gimple_location (stmt),\n-\t\t\t\t    TREE_TYPE (lhs), rhs);\n+\t    rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n+\t  if (bound)\n+\t    rhs = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (rhs), rhs, bound);\n \t  if (!update_call_from_tree (gsi, rhs))\n \t    gimplify_and_update_call_from_tree (gsi, rhs);\n \t  stmt = gsi_stmt (*gsi);\n@@ -1225,10 +1292,8 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t    }\n \n \t  if (strlen_to_stridx)\n-\t    {\n-\t      location_t loc = gimple_location (stmt);\n-\t      strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n-\t    }\n+\t    strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n+\n \t  return;\n \t}\n     }\n@@ -1251,7 +1316,6 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      si->full_string_p = true;\n \t      if (TREE_CODE (old) == INTEGER_CST)\n \t\t{\n-\t\t  location_t loc = gimple_location (stmt);\n \t\t  old = fold_convert_loc (loc, TREE_TYPE (lhs), old);\n \t\t  tree adj = fold_build2_loc (loc, MINUS_EXPR,\n \t\t\t\t\t      TREE_TYPE (lhs), lhs, old);\n@@ -1274,14 +1338,32 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n       find_equal_ptrs (src, idx);\n \n       /* For SRC that is an array of N elements, set LHS's range\n-\t to [0, N].  */\n-      maybe_set_strlen_range (lhs, src);\n+\t to [0, min (N, BOUND)].  A constant return value means\n+\t the range would have consisted of a single value.  In\n+\t that case, fold the result into the returned constant.  */\n+      if (tree ret = maybe_set_strlen_range (lhs, src, bound))\n+\tif (TREE_CODE (ret) == INTEGER_CST)\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t      {\n+\t\tfprintf (dump_file, \"Optimizing: \");\n+\t\tprint_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      }\n+\t    if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (ret)))\n+\t      ret = fold_convert_loc (loc, TREE_TYPE (lhs), ret);\n+\t    if (!update_call_from_tree (gsi, ret))\n+\t      gimplify_and_update_call_from_tree (gsi, ret);\n+\t    stmt = gsi_stmt (*gsi);\n+\t    update_stmt (stmt);\n+\t    if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t      {\n+\t\tfprintf (dump_file, \"into: \");\n+\t\tprint_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t      }\n+\t  }\n \n       if (strlen_to_stridx)\n-\t{\n-\t  location_t loc = gimple_location (stmt);\n-\t  strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n-\t}\n+\tstrlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n     }\n }\n \n@@ -3333,6 +3415,7 @@ strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \tswitch (DECL_FUNCTION_CODE (callee))\n \t  {\n \t  case BUILT_IN_STRLEN:\n+\t  case BUILT_IN_STRNLEN:\n \t    handle_builtin_strlen (gsi);\n \t    break;\n \t  case BUILT_IN_STRCHR:"}]}