{"sha": "5823ade173ca373e8af782cc3100ff67449f8016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgyM2FkZTE3M2NhMzczZThhZjc4MmNjMzEwMGZmNjc0NDlmODAxNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-07-27T16:25:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-07-27T16:25:57Z"}, "message": "dwarf2out.c (output_cfi_p): Removed.\n\n\t* dwarf2out.c (output_cfi_p): Removed.\n\t(output_cfis): New function.\n\t(output_fde): New function, split from output_call_frame_info.\n\t(output_call_frame_info): Use it.\n\t(dwarf2out_switch_text_section): Use output_cfis.\n\nFrom-SVN: r150129", "tree": {"sha": "7931a1577055a571e7e40dcf4991ef6147eb138b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7931a1577055a571e7e40dcf4991ef6147eb138b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5823ade173ca373e8af782cc3100ff67449f8016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5823ade173ca373e8af782cc3100ff67449f8016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5823ade173ca373e8af782cc3100ff67449f8016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5823ade173ca373e8af782cc3100ff67449f8016/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4798ad6447704a7e92219c5377a115202650f09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4798ad6447704a7e92219c5377a115202650f09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4798ad6447704a7e92219c5377a115202650f09d"}], "stats": {"total": 509, "additions": 310, "deletions": 199}, "files": [{"sha": "101c42e9851aa3e849e9ff50959a9b91cd9e5f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5823ade173ca373e8af782cc3100ff67449f8016/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5823ade173ca373e8af782cc3100ff67449f8016/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5823ade173ca373e8af782cc3100ff67449f8016", "patch": "@@ -1,3 +1,11 @@\n+2009-07-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2out.c (output_cfi_p): Removed.\n+\t(output_cfis): New function.\n+\t(output_fde): New function, split from output_call_frame_info.\n+\t(output_call_frame_info): Use it.\n+\t(dwarf2out_switch_text_section): Use output_cfis.\n+\n 2009-07-24  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/cygming.h (DWARF2_UNWIND_INFO): Error build when"}, {"sha": "d3ed637e3796183c82d6cd59874959ee2002cb6f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 302, "deletions": 199, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5823ade173ca373e8af782cc3100ff67449f8016/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5823ade173ca373e8af782cc3100ff67449f8016/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5823ade173ca373e8af782cc3100ff67449f8016", "patch": "@@ -3214,65 +3214,319 @@ output_cfi_directive (dw_cfi_ref cfi)\n     }\n }\n \n-/* Return true if *CFIP should be output after switching sections.  */\n+DEF_VEC_P (dw_cfi_ref);\n+DEF_VEC_ALLOC_P (dw_cfi_ref, heap);\n \n-static bool\n-output_cfi_p (dw_cfi_ref *cfip, dw_cfi_ref *cfi_args_sizep)\n+/* Output CFIs to bring current FDE to the same state as after executing\n+   CFIs in CFI chain.  DO_CFI_ASM is true if .cfi_* directives shall\n+   be emitted, false otherwise.  If it is false, FDE and FOR_EH are the\n+   other arguments to pass to output_cfi.  */\n+\n+static void\n+output_cfis (dw_cfi_ref cfi, bool do_cfi_asm, dw_fde_ref fde, bool for_eh)\n {\n-  dw_cfi_ref cfi = *cfip, cfi2;\n+  struct dw_cfi_struct cfi_buf;\n+  dw_cfi_ref cfi2;\n+  dw_cfi_ref cfi_args_size = NULL, cfi_cfa = NULL, cfi_cfa_offset = NULL;\n+  VEC (dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n+  unsigned int len, idx;\n \n-  switch (cfi->dw_cfi_opc)\n-    {\n-    case DW_CFA_advance_loc:\n-    case DW_CFA_advance_loc1:\n-    case DW_CFA_advance_loc2:\n-    case DW_CFA_advance_loc4:\n-    case DW_CFA_MIPS_advance_loc8:\n-    case DW_CFA_set_loc:\n-      /* All advances should be ignored.  */\n-      return false;\n-    case DW_CFA_remember_state:\n-      /* Skip everything between .cfi_remember_state and\n-\t .cfi_restore_state.  */\n-      for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n-\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n+  for (;; cfi = cfi->dw_cfi_next)\n+    switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n+      {\n+      case DW_CFA_advance_loc:\n+      case DW_CFA_advance_loc1:\n+      case DW_CFA_advance_loc2:\n+      case DW_CFA_advance_loc4:\n+      case DW_CFA_MIPS_advance_loc8:\n+      case DW_CFA_set_loc:\n+\t/* All advances should be ignored.  */\n+\tbreak;\n+      case DW_CFA_remember_state:\n+\t{\n+\t  dw_cfi_ref args_size = cfi_args_size;\n+\n+\t  /* Skip everything between .cfi_remember_state and\n+\t     .cfi_restore_state.  */\n+\t  for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n+\t    if (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n+\t      break;\n+\t    else if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n+\t      args_size = cfi2;\n+\t    else\n+\t      gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n+\n+\t  if (cfi2 == NULL)\n+\t    goto flush_all;\n+\t  else\n+\t    {\n+\t      cfi = cfi2;\n+\t      cfi_args_size = args_size;\n+\t    }\n \t  break;\n-\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n-\t  *cfi_args_sizep = cfi2;\n-\telse\n-\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n-      if (cfi2 == NULL)\n-\treturn true;\n-      *cfip = cfi2;\n-      return false;\n-    case DW_CFA_def_cfa_offset:\n-    case DW_CFA_def_cfa_offset_sf:\n-      /* Only keep the last of these if they are consecutive.  */\n-      for (cfi2 = cfi->dw_cfi_next; cfi2; cfi2 = cfi2->dw_cfi_next)\n-\tif (cfi2->dw_cfi_opc == cfi->dw_cfi_opc)\n-\t  *cfip = cfi2;\n-\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n-\t  *cfi_args_sizep = cfi2;\n+\t}\n+      case DW_CFA_GNU_args_size:\n+\tcfi_args_size = cfi;\n+\tbreak;\n+      case DW_CFA_GNU_window_save:\n+\tgoto flush_all;\n+      case DW_CFA_offset:\n+      case DW_CFA_offset_extended:\n+      case DW_CFA_offset_extended_sf:\n+      case DW_CFA_restore:\n+      case DW_CFA_restore_extended:\n+      case DW_CFA_undefined:\n+      case DW_CFA_same_value:\n+      case DW_CFA_register:\n+      case DW_CFA_val_offset:\n+      case DW_CFA_val_offset_sf:\n+      case DW_CFA_expression:\n+      case DW_CFA_val_expression:\n+      case DW_CFA_GNU_negative_offset_extended:\n+\tif (VEC_length (dw_cfi_ref, regs) <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n+\t  VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n+\t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n+\tVEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num, cfi);\n+\tbreak;\n+      case DW_CFA_def_cfa:\n+      case DW_CFA_def_cfa_sf:\n+      case DW_CFA_def_cfa_expression:\n+\tcfi_cfa = cfi;\n+\tcfi_cfa_offset = cfi;\n+\tbreak;\n+      case DW_CFA_def_cfa_register:\n+\tcfi_cfa = cfi;\n+\tbreak;\n+      case DW_CFA_def_cfa_offset:\n+      case DW_CFA_def_cfa_offset_sf:\n+\tcfi_cfa_offset = cfi;\n+\tbreak;\n+      case DW_CFA_nop:\n+\tgcc_assert (cfi == NULL);\n+      flush_all:\n+\tlen = VEC_length (dw_cfi_ref, regs);\n+\tfor (idx = 0; idx < len; idx++)\n+\t  {\n+\t    cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n+\t    if (cfi2 != NULL\n+\t\t&& cfi2->dw_cfi_opc != DW_CFA_restore\n+\t\t&& cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n+\t      {\n+\t\tif (do_cfi_asm)\n+\t\t  output_cfi_directive (cfi2);\n+\t\telse\n+\t\t  output_cfi (cfi2, fde, for_eh);\n+\t      }\n+\t  }\n+\tif (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n+\t  {\n+\t    gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n+\t    cfi_buf = *cfi_cfa;\n+\t    switch (cfi_cfa_offset->dw_cfi_opc)\n+\t      {\n+\t      case DW_CFA_def_cfa_offset:\n+\t\tcfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n+\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\tbreak;\n+\t      case DW_CFA_def_cfa_offset_sf:\n+\t\tcfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n+\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n+\t\tbreak;\n+\t      case DW_CFA_def_cfa:\n+\t      case DW_CFA_def_cfa_sf:\n+\t\tcfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n+\t\tcfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t    cfi_cfa = &cfi_buf;\n+\t  }\n+\telse if (cfi_cfa_offset)\n+\t  cfi_cfa = cfi_cfa_offset;\n+\tif (cfi_cfa)\n+\t  {\n+\t    if (do_cfi_asm)\n+\t      output_cfi_directive (cfi_cfa);\n+\t    else\n+\t      output_cfi (cfi_cfa, fde, for_eh);\n+\t  }\n+\tcfi_cfa = NULL;\n+\tcfi_cfa_offset = NULL;\n+\tif (cfi_args_size\n+\t    && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n+\t  {\n+\t    if (do_cfi_asm)\n+\t      output_cfi_directive (cfi_args_size);\n+\t    else\n+\t      output_cfi (cfi_args_size, fde, for_eh);\n+\t  }\n+\tcfi_args_size = NULL;\n+\tif (cfi == NULL)\n+\t  {\n+\t    VEC_free (dw_cfi_ref, heap, regs);\n+\t    return;\n+\t  }\n+\telse if (do_cfi_asm)\n+\t  output_cfi_directive (cfi);\n \telse\n-\t  break;\n-      return true;\n-    case DW_CFA_GNU_args_size:\n-      /* One DW_CFA_GNU_args_size, the last one, is enough.  */\n-      *cfi_args_sizep = cfi;\n-      return false;\n-    default:\n-      return true;\n+\t  output_cfi (cfi, fde, for_eh);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n     }\n }\n \n+/* Output one FDE.  */\n+\n+static void\n+output_fde (dw_fde_ref fde, bool for_eh, bool second,\n+\t    char *section_start_label, int fde_encoding, char *augmentation,\n+\t    bool any_lsda_needed, int lsda_encoding)\n+{\n+  const char *begin, *end;\n+  static unsigned int j;\n+  char l1[20], l2[20];\n+  dw_cfi_ref cfi;\n+\n+  targetm.asm_out.unwind_label (asm_out_file, fde->decl, for_eh,\n+\t\t\t\t/* empty */ 0);\n+  targetm.asm_out.internal_label (asm_out_file, FDE_LABEL,\n+\t\t\t\t  for_eh + j);\n+  ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);\n+  ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);\n+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+    dw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n+\t\t\t \" indicating 64-bit DWARF extension\");\n+  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t\"FDE Length\");\n+  ASM_OUTPUT_LABEL (asm_out_file, l1);\n+\n+  if (for_eh)\n+    dw2_asm_output_delta (4, l1, section_start_label, \"FDE CIE offset\");\n+  else\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n+\t\t\t   debug_frame_section, \"FDE CIE offset\");\n+\n+  if (!fde->dw_fde_switched_sections)\n+    {\n+      begin = fde->dw_fde_begin;\n+      end = fde->dw_fde_end;\n+    }\n+  else if (second ^ fde->dw_fde_switched_cold_to_hot)\n+    {\n+      begin = fde->dw_fde_unlikely_section_label;\n+      end = fde->dw_fde_unlikely_section_end_label;\n+    }\n+  else\n+    {\n+      begin = fde->dw_fde_hot_section_label;\n+      end = fde->dw_fde_hot_section_end_label;\n+    }\n+\n+  if (for_eh)\n+    {\n+      rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, begin);\n+      SYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_LOCAL;\n+      dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref, false,\n+\t\t\t\t       \"FDE initial location\");\n+      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n+\t\t\t    end, begin, \"FDE address range\");\n+    }\n+  else\n+    {\n+      dw2_asm_output_addr (DWARF2_ADDR_SIZE, begin, \"FDE initial location\");\n+      dw2_asm_output_delta (DWARF2_ADDR_SIZE, end, begin, \"FDE address range\");\n+    }\n+\n+  if (augmentation[0])\n+    {\n+      if (any_lsda_needed)\n+\t{\n+\t  int size = size_of_encoded_value (lsda_encoding);\n+\n+\t  if (lsda_encoding == DW_EH_PE_aligned)\n+\t    {\n+\t      int offset = (  4\t\t/* Length */\n+\t\t\t    + 4\t\t/* CIE offset */\n+\t\t\t    + 2 * size_of_encoded_value (fde_encoding)\n+\t\t\t    + 1\t\t/* Augmentation size */ );\n+\t      int pad = -offset & (PTR_SIZE - 1);\n+\n+\t      size += pad;\n+\t      gcc_assert (size_of_uleb128 (size) == 1);\n+\t    }\n+\n+\t  dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n+\n+\t  if (fde->uses_eh_lsda)\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\", fde->funcdef_number);\n+\t      dw2_asm_output_encoded_addr_rtx (lsda_encoding,\n+\t\t\t\t\t       gen_rtx_SYMBOL_REF (Pmode, l1),\n+\t\t\t\t\t       false,\n+\t\t\t\t\t       \"Language Specific Data Area\");\n+\t    }\n+\t  else\n+\t    {\n+\t      if (lsda_encoding == DW_EH_PE_aligned)\n+\t\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+\t      dw2_asm_output_data (size_of_encoded_value (lsda_encoding), 0,\n+\t\t\t\t   \"Language Specific Data Area (none)\");\n+\t    }\n+\t}\n+      else\n+\tdw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n+    }\n+\n+  /* Loop through the Call Frame Instructions associated with\n+     this FDE.  */\n+  fde->dw_fde_current_label = begin;\n+  if (!fde->dw_fde_switched_sections)\n+    for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n+      output_cfi (cfi, fde, for_eh);\n+  else if (!second)\n+    {\n+      if (fde->dw_fde_switch_cfi)\n+\tfor (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n+\t  {\n+\t    output_cfi (cfi, fde, for_eh);\n+\t    if (cfi == fde->dw_fde_switch_cfi)\n+\t      break;\n+\t  }\n+    }\n+  else\n+    {\n+      dw_cfi_ref cfi_next = fde->dw_fde_cfi;\n+\n+      if (fde->dw_fde_switch_cfi)\n+\t{\n+\t  cfi_next = fde->dw_fde_switch_cfi->dw_cfi_next;\n+\t  fde->dw_fde_switch_cfi->dw_cfi_next = NULL;\n+\t  output_cfis (fde->dw_fde_cfi, false, fde, for_eh);\n+\t  fde->dw_fde_switch_cfi->dw_cfi_next = cfi_next;\n+\t}\n+      for (cfi = cfi_next; cfi != NULL; cfi = cfi->dw_cfi_next)\n+\toutput_cfi (cfi, fde, for_eh);\n+    }\n+\n+  /* Pad the FDE out to an address sized boundary.  */\n+  ASM_OUTPUT_ALIGN (asm_out_file,\n+\t\t    floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n+  ASM_OUTPUT_LABEL (asm_out_file, l2);\n+\n+  j += 2;\n+}\n+\n+\n /* Output the call frame information used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n \n static void\n output_call_frame_info (int for_eh)\n {\n-  unsigned int i, j;\n+  unsigned int i;\n   dw_fde_ref fde;\n   dw_cfi_ref cfi;\n   char l1[20], l2[20], section_start_label[20];\n@@ -3478,7 +3732,7 @@ output_call_frame_info (int for_eh)\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n   /* Loop through all of the FDE's.  */\n-  for (i = 0, j = 0; i < fde_table_in_use; i++)\n+  for (i = 0; i < fde_table_in_use; i++)\n     {\n       unsigned int k;\n       fde = &fde_table[i];\n@@ -3491,153 +3745,8 @@ output_call_frame_info (int for_eh)\n \tcontinue;\n \n       for (k = 0; k < (fde->dw_fde_switched_sections ? 2 : 1); k++)\n-\t{\n-\t  const char *begin, *end;\n-\n-\t  targetm.asm_out.unwind_label (asm_out_file, fde->decl, for_eh,\n-\t\t\t\t\t/* empty */ 0);\n-\t  targetm.asm_out.internal_label (asm_out_file, FDE_LABEL,\n-\t\t\t\t\t  for_eh + j);\n-\t  ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);\n-\t  ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);\n-\t  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n-\t    dw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n-\t\t\t\t \" indicating 64-bit DWARF extension\");\n-\t  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n-\t\t\t\t\"FDE Length\");\n-\t  ASM_OUTPUT_LABEL (asm_out_file, l1);\n-\n-\t  if (for_eh)\n-\t    dw2_asm_output_delta (4, l1, section_start_label,\n-\t\t\t\t  \"FDE CIE offset\");\n-\t  else\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n-\t\t\t\t   debug_frame_section, \"FDE CIE offset\");\n-\n-\t  if (!fde->dw_fde_switched_sections)\n-\t    {\n-\t      begin = fde->dw_fde_begin;\n-\t      end = fde->dw_fde_end;\n-\t    }\n-\t  else if (k ^ fde->dw_fde_switched_cold_to_hot)\n-\t    {\n-\t      begin = fde->dw_fde_unlikely_section_label;\n-\t      end = fde->dw_fde_unlikely_section_end_label;\n-\t    }\n-\t  else\n-\t    {\n-\t      begin = fde->dw_fde_hot_section_label;\n-\t      end = fde->dw_fde_hot_section_end_label;\n-\t    }\n-\n-\t  if (for_eh)\n-\t    {\n-\t      rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, begin);\n-\t      SYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_LOCAL;\n-\t      dw2_asm_output_encoded_addr_rtx (fde_encoding,\n-\t\t\t\t\t       sym_ref,\n-\t\t\t\t\t       false,\n-\t\t\t\t\t       \"FDE initial location\");\n-\t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\t    end, begin, \"FDE address range\");\n-\t    }\n-\t  else\n-\t    {\n-\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, begin,\n-\t\t\t\t   \"FDE initial location\");\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, end, begin,\n-\t\t\t\t    \"FDE address range\");\n-\t    }\n-\n-\t  if (augmentation[0])\n-\t    {\n-\t      if (any_lsda_needed)\n-\t\t{\n-\t\t  int size = size_of_encoded_value (lsda_encoding);\n-\n-\t\t  if (lsda_encoding == DW_EH_PE_aligned)\n-\t\t    {\n-\t\t      int offset = (  4\t\t/* Length */\n-\t\t\t\t    + 4\t\t/* CIE offset */\n-\t\t\t\t    + 2 * size_of_encoded_value (fde_encoding)\n-\t\t\t\t    + 1\t\t/* Augmentation size */ );\n-\t\t      int pad = -offset & (PTR_SIZE - 1);\n-\n-\t\t      size += pad;\n-\t\t      gcc_assert (size_of_uleb128 (size) == 1);\n-\t\t    }\n-\n-\t\t  dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n-\n-\t\t  if (fde->uses_eh_lsda)\n-\t\t    {\n-\t\t       ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\",\n-\t\t\t\t\t\t    fde->funcdef_number);\n-\t\t      dw2_asm_output_encoded_addr_rtx (lsda_encoding,\n-\t\t\t\t\t\tgen_rtx_SYMBOL_REF (Pmode, l1),\n-\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\"Language Specific Data Area\");\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (lsda_encoding == DW_EH_PE_aligned)\n-\t\t\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n-\t\t      dw2_asm_output_data (\n-\t\t\t\tsize_of_encoded_value (lsda_encoding), 0,\n-\t\t\t\t\"Language Specific Data Area (none)\");\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tdw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n-\t    }\n-\n-\t  /* Loop through the Call Frame Instructions associated with\n-\t     this FDE.  */\n-\t  fde->dw_fde_current_label = begin;\n-\t  if (!fde->dw_fde_switched_sections)\n-\t    for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n-\t      output_cfi (cfi, fde, for_eh);\n-\t  else if (k == 0)\n-\t    {\n-\t      if (fde->dw_fde_switch_cfi)\n-\t\tfor (cfi = fde->dw_fde_cfi; cfi != NULL;\n-\t\t     cfi = cfi->dw_cfi_next)\n-\t\t  {\n-\t\t    output_cfi (cfi, fde, for_eh);\n-\t\t    if (cfi == fde->dw_fde_switch_cfi)\n-\t\t      break;\n-\t\t  }\n-\t    }\n-\t  else\n-\t    {\n-\t      dw_cfi_ref cfi_next = fde->dw_fde_cfi;\n-\n-\t      if (fde->dw_fde_switch_cfi)\n-\t\t{\n-\t\t  dw_cfi_ref cfi_args_size = NULL;\n-\t\t  cfi_next = fde->dw_fde_switch_cfi->dw_cfi_next;\n-\t\t  fde->dw_fde_switch_cfi->dw_cfi_next = NULL;\n-\t\t  for (cfi = fde->dw_fde_cfi; cfi != NULL;\n-\t\t       cfi = cfi->dw_cfi_next)\n-\t\t    if (output_cfi_p (&cfi, &cfi_args_size))\n-\t\t      output_cfi (cfi, fde, for_eh);\n-\t\t  if (cfi_args_size\n-\t\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n-\t\t    output_cfi (cfi_args_size, fde, for_eh);\n-\t\t  fde->dw_fde_switch_cfi->dw_cfi_next = cfi_next;\n-\t\t}\n-\t      for (cfi = cfi_next; cfi != NULL; cfi = cfi->dw_cfi_next)\n-\t\toutput_cfi (cfi, fde, for_eh);\n-\t    }\n-\n-\t  /* Pad the FDE out to an address sized boundary.  */\n-\t  ASM_OUTPUT_ALIGN (asm_out_file,\n-\t\t\t    floor_log2 ((for_eh\n-\t\t\t\t\t ? PTR_SIZE : DWARF2_ADDR_SIZE)));\n-\t  ASM_OUTPUT_LABEL (asm_out_file, l2);\n-\n-\t  j += 2;\n-\t}\n+\toutput_fde (fde, for_eh, k, section_start_label, fde_encoding,\n+\t\t    augmentation, any_lsda_needed, lsda_encoding);\n     }\n \n   if (for_eh && targetm.terminate_dw2_eh_frame_info)\n@@ -3913,16 +4022,10 @@ dwarf2out_switch_text_section (void)\n \n   if (dwarf2out_do_cfi_asm ())\n     {\n-      dw_cfi_ref cfi, cfi_args_size = NULL;\n-\n       dwarf2out_do_cfi_startproc ();\n       /* As this is a different FDE, insert all current CFI instructions\n \t again.  */\n-      for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n-\tif (output_cfi_p (&cfi, &cfi_args_size))\n-\t  output_cfi_directive (cfi);\n-      if (cfi_args_size && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n-\toutput_cfi_directive (cfi_args_size);\n+      output_cfis (fde->dw_fde_cfi, true, fde, true);\n     }\n   else\n     {"}]}