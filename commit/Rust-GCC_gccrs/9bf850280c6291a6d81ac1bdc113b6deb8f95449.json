{"sha": "9bf850280c6291a6d81ac1bdc113b6deb8f95449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmODUwMjgwYzYyOTFhNmQ4MWFjMWJkYzExM2I2ZGViOGY5NTQ0OQ==", "commit": {"author": {"name": "Trevor Smigiel", "email": "Trevor_Smigiel@playstation.sony.com", "date": "2008-05-27T08:19:45Z"}, "committer": {"name": "Sa Liu", "email": "saliu@gcc.gnu.org", "date": "2008-05-27T08:19:45Z"}, "message": "Add TImode libgcc functions for mul and div.\n\nFrom-SVN: r135973", "tree": {"sha": "ad00c0ed4a8bfc16ce765c4f3c22294faa45f7eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad00c0ed4a8bfc16ce765c4f3c22294faa45f7eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf850280c6291a6d81ac1bdc113b6deb8f95449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf850280c6291a6d81ac1bdc113b6deb8f95449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf850280c6291a6d81ac1bdc113b6deb8f95449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf850280c6291a6d81ac1bdc113b6deb8f95449/comments", "author": null, "committer": null, "parents": [{"sha": "ebe74ac50b01a591558cab26fb88ef7ee80748ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe74ac50b01a591558cab26fb88ef7ee80748ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe74ac50b01a591558cab26fb88ef7ee80748ad"}], "stats": {"total": 325, "additions": 323, "deletions": 2}, "files": [{"sha": "ca643cc33bf36dd6278c7deba7c5d35d64851501", "filename": "gcc/config/spu/divmodti4.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fdivmodti4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fdivmodti4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fdivmodti4.c?ref=9bf850280c6291a6d81ac1bdc113b6deb8f95449", "patch": "@@ -0,0 +1,168 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2 of the License, or (at your option)\n+   any later version.\n+ \n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+ \n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License.  The exception does not\n+   however invalidate any other reasons why the executable file might be covered\n+   by the GNU General Public License. */\n+\n+#include <spu_intrinsics.h>\n+\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+typedef int TItype __attribute__ ((mode (TI)));\n+TItype __divti3 (TItype u, TItype v);\n+TItype __modti3 (TItype u, TItype v);\n+UTItype __udivti3 (UTItype u, UTItype v);\n+UTItype __umodti3 (UTItype u, UTItype v);\n+UTItype __udivmodti4 (UTItype u, UTItype v, UTItype *w);\n+\n+inline static unsigned int\n+count_leading_zeros (UTItype x)\n+{\n+  qword c = si_clz (*(qword *) & x);\n+  qword cmp0 = si_cgti (c, 31);\n+  qword cmp1 = si_and (cmp0, si_shlqbyi (cmp0, 4));\n+  qword cmp2 = si_and (cmp1, si_shlqbyi (cmp0, 8));\n+  qword s = si_a (c, si_and (cmp0, si_shlqbyi (c, 4)));\n+  s = si_a (s, si_and (cmp1, si_shlqbyi (c, 8)));\n+  s = si_a (s, si_and (cmp2, si_shlqbyi (c, 12)));\n+  return si_to_uint (s);\n+}\n+\n+/* Based on implementation of udivmodsi4, which is essentially\n+ * an optimized version of gcc/config/udivmodsi4.c\n+        clz      %7,%2\n+        clz      %4,%1\n+        il       %5,1\n+        fsmbi    %0,0\n+        sf       %7,%4,%7\n+        ori      %3,%1,0\n+        shl      %5,%5,%7\n+        shl      %4,%2,%7\n+1:      or       %8,%0,%5\n+        rotmi    %5,%5,-1\n+        clgt     %6,%4,%3\n+        sf       %7,%4,%3\n+        rotmi    %4,%4,-1\n+        selb     %0,%8,%0,%6\n+        selb     %3,%7,%3,%6\n+3:      brnz     %5,1b\n+ */\n+\n+UTItype\n+__udivmodti4 (UTItype num, UTItype den, UTItype * rp)\n+{\n+  qword shift =\n+    si_from_uint (count_leading_zeros (den) - count_leading_zeros (num));\n+  qword n0 = *(qword *) & num;\n+  qword d0 = *(qword *) & den;\n+  qword bit = si_andi (si_fsmbi (1), 1);\n+  qword r0 = si_il (0);\n+  qword m1 = si_fsmbi (0x000f);\n+  qword mask, r1, n1;\n+\n+  d0 = si_shlqbybi (si_shlqbi (d0, shift), shift);\n+  bit = si_shlqbybi (si_shlqbi (bit, shift), shift);\n+\n+  do\n+    {\n+      r1 = si_or (r0, bit);\n+\n+      // n1 = n0 - d0 in TImode\n+      n1 = si_bg (d0, n0);\n+      n1 = si_shlqbyi (n1, 4);\n+      n1 = si_sf (m1, n1);\n+      n1 = si_bgx (d0, n0, n1);\n+      n1 = si_shlqbyi (n1, 4);\n+      n1 = si_sf (m1, n1);\n+      n1 = si_bgx (d0, n0, n1);\n+      n1 = si_shlqbyi (n1, 4);\n+      n1 = si_sf (m1, n1);\n+      n1 = si_sfx (d0, n0, n1);\n+\n+      mask = si_fsm (si_cgti (n1, -1));\n+      r0 = si_selb (r0, r1, mask);\n+      n0 = si_selb (n0, n1, mask);\n+      bit = si_rotqmbii (bit, -1);\n+      d0 = si_rotqmbii (d0, -1);\n+    }\n+  while (si_to_uint (si_orx (bit)));\n+  if (rp)\n+    *rp = *(UTItype *) & n0;\n+  return *(UTItype *) & r0;\n+}\n+\n+UTItype\n+__udivti3 (UTItype n, UTItype d)\n+{\n+  return __udivmodti4 (n, d, (UTItype *)0);\n+}\n+\n+UTItype\n+__umodti3 (UTItype n, UTItype d)\n+{\n+  UTItype w;\n+  __udivmodti4 (n, d, &w);\n+  return w;\n+}\n+\n+TItype\n+__divti3 (TItype n, TItype d)\n+{\n+  int c = 0;\n+  TItype w;\n+\n+  if (n < 0)\n+    {\n+        c = ~c;\n+        n = -n;\n+    }\n+  if (d < 0)\n+    {\n+        c = ~c;\n+        d = -d;\n+    }\n+\n+  w = __udivmodti4 (n, d, (UTItype *)0);\n+  if (c)\n+    w = -w;\n+  return w;\n+}\n+\n+TItype\n+__modti3 (TItype n, TItype d)\n+{\n+  int c = 0;\n+  TItype w;\n+\n+  if (n < 0)\n+    {\n+        c = ~c;\n+        n = -n;\n+    }\n+  if (d < 0)\n+    {\n+        c = ~c;\n+        d = -d;\n+    }\n+\n+  __udivmodti4 (n, d, (UTItype *) &w);\n+  if (c)\n+    w = -w;\n+  return w;\n+}"}, {"sha": "6998ed026f86b4ee9a8f64f32bf8ee6f748d14f6", "filename": "gcc/config/spu/multi3.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fmulti3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fmulti3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmulti3.c?ref=9bf850280c6291a6d81ac1bdc113b6deb8f95449", "patch": "@@ -0,0 +1,99 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2 of the License, or (at your option)\n+   any later version.\n+ \n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+ \n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License.  The exception does not\n+   however invalidate any other reasons why the executable file might be covered\n+   by the GNU General Public License. */\n+\n+#include <spu_intrinsics.h>\n+\n+typedef int TItype __attribute__ ((mode (TI)));\n+\n+/* A straight forward vectorization and unrolling of\n+ *   short l[8], r[8];\n+ *   TItype total = 0;\n+ *   for (i = 0; i < 8; i++)\n+ *     for (j = 0; j < 8; j++)\n+ *       total += (TItype)((l[7-i] * r[7-j]) << (16 * (i + j)));\n+ */\n+TItype\n+__multi3 (TItype l, TItype r)\n+{\n+  qword u = *(qword *) & l;\n+  qword v = *(qword *) & r;\n+  qword splat0 = si_shufb (v, v, si_ilh (0x0001));\n+  qword splat1 = si_shufb (v, v, si_ilh (0x0203));\n+  qword splat2 = si_shufb (v, v, si_ilh (0x0405));\n+  qword splat3 = si_shufb (v, v, si_ilh (0x0607));\n+  qword splat4 = si_shufb (v, v, si_ilh (0x0809));\n+  qword splat5 = si_shufb (v, v, si_ilh (0x0a0b));\n+  qword splat6 = si_shufb (v, v, si_ilh (0x0c0d));\n+  qword splat7 = si_shufb (v, v, si_ilh (0x0e0f));\n+\n+  qword part0l = si_shlqbyi (si_mpyu   (u, splat0), 14);\n+  qword part1h = si_shlqbyi (si_mpyhhu (u, splat1), 14);\n+  qword part1l = si_shlqbyi (si_mpyu   (u, splat1), 12);\n+  qword part2h = si_shlqbyi (si_mpyhhu (u, splat2), 12);\n+  qword part2l = si_shlqbyi (si_mpyu   (u, splat2), 10);\n+  qword part3h = si_shlqbyi (si_mpyhhu (u, splat3), 10);\n+  qword part3l = si_shlqbyi (si_mpyu   (u, splat3), 8);\n+  qword part4h = si_shlqbyi (si_mpyhhu (u, splat4), 8);\n+  qword part4l = si_shlqbyi (si_mpyu   (u, splat4), 6);\n+  qword part5h = si_shlqbyi (si_mpyhhu (u, splat5), 6);\n+  qword part5l = si_shlqbyi (si_mpyu   (u, splat5), 4);\n+  qword part6h = si_shlqbyi (si_mpyhhu (u, splat6), 4);\n+  qword part6l = si_shlqbyi (si_mpyu   (u, splat6), 2);\n+  qword part7h = si_shlqbyi (si_mpyhhu (u, splat7), 2);\n+  qword part7l = si_mpyu (u, splat7);\n+\n+  qword carry, total0, total1, total2, total3, total4;\n+  qword total5, total6, total7, total8, total9, total10;\n+  qword total;\n+\n+  total0 = si_a (si_a (si_a (part0l, part1h), si_a (part1l, part2h)), part7l);\n+  total1 = si_a (part2l, part3h);\n+  total2 = si_a (part3l, part4h);\n+  total3 = si_a (part4l, part5h);\n+  total4 = si_a (part5l, part6h);\n+  total5 = si_a (part6l, part7h);\n+  total6 = si_a (total0, total1);\n+  total7 = si_a (total2, total3);\n+  total8 = si_a (total4, total5);\n+  total9 = si_a (total6, total7);\n+  total10 = si_a (total8, total9);\n+\n+  carry = si_cg (part2l, part3h);\n+  carry = si_a (carry, si_cg (part3l, part4h));\n+  carry = si_a (carry, si_cg (part4l, part5h));\n+  carry = si_a (carry, si_cg (part5l, part6h));\n+  carry = si_a (carry, si_cg (part6l, part7h));\n+  carry = si_a (carry, si_cg (total0, total1));\n+  carry = si_a (carry, si_cg (total2, total3));\n+  carry = si_a (carry, si_cg (total4, total5));\n+  carry = si_a (carry, si_cg (total6, total7));\n+  carry = si_a (carry, si_cg (total8, total9));\n+  carry = si_shlqbyi (carry, 4);\n+\n+  total = si_cg (total10, carry);\n+  total = si_shlqbyi (total, 4);\n+  total = si_cgx (total10, carry, total);\n+  total = si_shlqbyi (total, 4);\n+  total = si_addx (total10, carry, total);\n+  return *(TItype *) & total;\n+}"}, {"sha": "de307ab32ed95a5ea790bbf545443ae74ed19c9f", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=9bf850280c6291a6d81ac1bdc113b6deb8f95449", "patch": "@@ -4422,6 +4422,13 @@ spu_init_libfuncs (void)\n \n   set_conv_libfunc (ufloat_optab, DFmode, SImode, \"__float_unssidf\");\n   set_conv_libfunc (ufloat_optab, DFmode, DImode, \"__float_unsdidf\");\n+\n+  set_optab_libfunc (smul_optab, TImode, \"__multi3\");\n+  set_optab_libfunc (sdiv_optab, TImode, \"__divti3\");\n+  set_optab_libfunc (smod_optab, TImode, \"__modti3\");\n+  set_optab_libfunc (udiv_optab, TImode, \"__udivti3\");\n+  set_optab_libfunc (umod_optab, TImode, \"__umodti3\");\n+  set_optab_libfunc (udivmod_optab, TImode, \"__udivmodti4\");\n }\n \n /* Make a subreg, stripping any existing subreg.  We could possibly just\n@@ -4473,7 +4480,7 @@ spu_init_builtins (void)\n   unsigned_V4SI_type_node = build_vector_type (unsigned_intSI_type_node, 4);\n   unsigned_V2DI_type_node = build_vector_type (unsigned_intDI_type_node, 2);\n \n-  spu_builtin_types[SPU_BTI_QUADWORD] = V16QI_type_node;\n+  spu_builtin_types[SPU_BTI_QUADWORD] = intTI_type_node;\n \n   spu_builtin_types[SPU_BTI_7] = global_trees[TI_INTSI_TYPE];\n   spu_builtin_types[SPU_BTI_S7] = global_trees[TI_INTSI_TYPE];\n@@ -5368,7 +5375,8 @@ spu_expand_builtin_1 (struct spu_builtin_description *d,\n       if (VECTOR_MODE_P (mode)\n \t  && (GET_CODE (ops[i]) == CONST_INT\n \t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_INT\n-\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_FLOAT))\n+\t      || GET_MODE_CLASS (GET_MODE (ops[i])) == MODE_FLOAT)\n+\t  && d->parm[i] != SPU_BTI_QUADWORD)\n \t{\n \t  if (GET_CODE (ops[i]) == CONST_INT)\n \t    ops[i] = spu_const (mode, INTVAL (ops[i]));"}, {"sha": "0363e34207514eb28d08c026a28a05b4b61eabe6", "filename": "gcc/testsuite/gcc.target/spu/muldivti3.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf850280c6291a6d81ac1bdc113b6deb8f95449/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fmuldivti3.c?ref=9bf850280c6291a6d81ac1bdc113b6deb8f95449", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99\" } */\n+#include <stdlib.h>\n+typedef unsigned int uqword __attribute__((mode(TI)));\n+typedef int qword __attribute__((mode(TI)));\n+\n+typedef union\n+{\n+  uqword                uq;\n+  qword                 q;\n+  unsigned long long    ull[2];\n+} u;\n+\n+int main(void)\n+{\n+  uqword e, f;\n+  qword g, h;\n+\n+  e = 0x1111111111111111ULL;\n+  f = 0xFULL;\n+  g = 0x0000000000111100ULL;\n+  h = 0x0000000000000000ULL;\n+\n+  u m, n, o, p, q;\n+\n+  m.ull[0] = f;\n+  m.ull[1] = e;\n+  n.ull[0] = h;\n+  n.ull[1] = g;\n+\n+  /* __multi3  */\n+  o.q = m.q * n.q;\n+\n+  o.q = o.q + n.q + 0x1110FF;\n+  /* __udivti3, __umodti3  */\n+  p.uq = o.uq / n.uq;\n+  q.uq = o.uq % n.uq;\n+  if (p.uq != (m.uq+1)) abort();\n+  if (q.uq != 0x1110FF) abort();\n+  /* __divti3, __modti3  */\n+  p.q = -o.q / n.q;\n+  q.q = -o.q % n.q;\n+  if ((-p.q * n.q - q.q) != o.q) abort();\n+\n+  return 0;\n+}"}]}