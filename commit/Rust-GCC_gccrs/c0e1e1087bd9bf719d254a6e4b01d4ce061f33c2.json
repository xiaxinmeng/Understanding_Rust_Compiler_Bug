{"sha": "c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlMWUxMDg3YmQ5YmY3MTlkMjU0YTZlNGIwMWQ0Y2UwNjFmMzNjMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-26T08:38:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-26T08:38:38Z"}, "message": "decl.c (gnat_to_gnu_entity): Factor out common predicate.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Factor\n\tout common predicate.  Use the maximum to compute the upper bound of\n\tthe index type only when it is not wider than sizetype.  Perform the\n\tcomparison in the index type for the generic expression.  Use real\n\tprecision to decide whether to generate special types for debugging\n\tinformation.\n\nFrom-SVN: r148964", "tree": {"sha": "84b7b9a216c4deb10a7def8f4cfe282842c5f7c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84b7b9a216c4deb10a7def8f4cfe282842c5f7c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/comments", "author": null, "committer": null, "parents": [{"sha": "ffa5876ff310c92f033bca4259b6530fbeddbb34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa5876ff310c92f033bca4259b6530fbeddbb34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa5876ff310c92f033bca4259b6530fbeddbb34"}], "stats": {"total": 86, "additions": 66, "deletions": 20}, "files": [{"sha": "bb576e837a8ddc2570edcfef761224016f8ac565", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "patch": "@@ -1,3 +1,12 @@\n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Factor\n+\tout common predicate.  Use the maximum to compute the upper bound of\n+\tthe index type only when it is not wider than sizetype.  Perform the\n+\tcomparison in the index type for the generic expression.  Use real\n+\tprecision to decide whether to generate special types for debugging\n+\tinformation.\n+\n 2009-06-26  Matthew Gingell  <gingell@adacore.com>\n \n \t* adaint.c: Do not use the dummy version of convert_addresses on LynxOS\n@@ -11,6 +20,15 @@\n \n \t* exp_ch4.adb, gnatcmd.adb, make.adb: Minor reformatting\n \n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Factor\n+\tout common predicate.  Use the maximum to compute the upper bound of\n+\tthe index type only when it is not wider than sizetype.  Perform the\n+\tcomparison in the index type for the generic expression.  Use real\n+\tprecision to decide whether to generate special types for debugging\n+\tinformation.\n+\n 2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Pass"}, {"sha": "08e9a7dd6cb9a981ac1487017764087d767fa444", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "patch": "@@ -2143,6 +2143,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n+\t      tree prec = TYPE_RM_SIZE (gnu_index_type);\n+\t      const bool wider_p\n+\t\t= (compare_tree_int (prec, TYPE_PRECISION (sizetype)) > 0\n+\t\t   || (compare_tree_int (prec, TYPE_PRECISION (sizetype)) == 0\n+\t\t       && TYPE_UNSIGNED (gnu_index_type)\n+\t\t\t  != TYPE_UNSIGNED (sizetype)));\n \t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n \t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n \t      tree gnu_min = convert (sizetype, gnu_orig_min);\n@@ -2167,10 +2173,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Similarly, if one of the values overflows in sizetype and the\n \t\t range is null, use 1..0 for the sizetype bounds.  */\n-\t      else if ((TYPE_PRECISION (gnu_index_type)\n-\t\t\t> TYPE_PRECISION (sizetype)\n-\t\t        || TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t   != TYPE_UNSIGNED (sizetype))\n+\t      else if (wider_p\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n@@ -2184,10 +2187,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      /* If the minimum and maximum values both overflow in sizetype,\n \t\t but the difference in the original type does not overflow in\n \t\t sizetype, ignore the overflow indication.  */\n-\t      else if ((TYPE_PRECISION (gnu_index_type)\n-\t\t\t> TYPE_PRECISION (sizetype)\n-\t\t\t|| TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t   != TYPE_UNSIGNED (sizetype))\n+\t      else if (wider_p\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n@@ -2209,9 +2209,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     \"superflat\" case.  There are three ways to do this.  If\n \t\t     we can prove that the array can never be superflat, we\n \t\t     can just use the high bound of the index subtype.  If we\n-\t\t     can prove that the low bound minus one can't overflow,\n-\t\t     we can do this as MAX (hb, lb - 1).  Otherwise, we have\n-\t\t     to use the expression hb >= lb ? hb : lb - 1.  */\n+\t\t     can prove that the low bound minus one and the high bound\n+\t\t     can't overflow, we can do this as MAX (hb, lb - 1).  But,\n+\t\t     otherwise, we have to use (hb >= lb) ? hb : lb - 1.  Note\n+\t\t     that the comparison must be done in the original index\n+\t\t     type, to avoid any overflow during the conversion.  */\n \t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n \n \t\t  /* If gnu_high is a constant that has overflowed, the array\n@@ -2220,20 +2222,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TREE_OVERFLOW (gnu_high))\n \t\t    gnu_high = gnu_max;\n \n-\t\t  /* gnu_high cannot overflow if the subtype is unsigned and\n-\t\t     sizetype is signed, or if it is a constant that hasn't\n-\t\t     overflowed.  */\n-\t\t  else if ((TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t    && !TYPE_UNSIGNED (sizetype))\n-\t\t\t   || TREE_CODE (gnu_high) == INTEGER_CST)\n+\t\t  /* If the index type is not wider and gnu_high is a constant\n+\t\t     that hasn't overflowed, we can use the maximum.  */\n+\t\t  else if (!wider_p && TREE_CODE (gnu_high) == INTEGER_CST)\n \t\t    gnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n \n \t\t  else\n \t\t    gnu_high\n \t\t      = build_cond_expr (sizetype,\n \t\t\t\t\t build_binary_op (GE_EXPR,\n \t\t\t\t\t\t\t  integer_type_node,\n-\t\t\t\t\t\t\t  gnu_max, gnu_min),\n+\t\t\t\t\t\t\t  gnu_orig_max,\n+\t\t\t\t\t\t\t  gnu_orig_min),\n \t\t\t\t\t gnu_max, gnu_high);\n \t\t}\n \n@@ -2306,8 +2306,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n \t\t\t != INTEGER_TYPE)\n \t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)\n-\t\t  || (TYPE_PRECISION (gnu_index_type)\n-\t\t      > TYPE_PRECISION (sizetype)))\n+\t\t  || compare_tree_int (prec, TYPE_PRECISION (sizetype)) > 0)\n \t\tneed_index_type_struct = true;\n \t    }\n "}, {"sha": "95ae9827dbef4583d8cbb53846f2fd36ca2517da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "patch": "@@ -1,3 +1,7 @@\n+2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/array6.adb: New test.\n+\n 2009-06-25  Ian Lance Taylor  <iant@google.com>\n \n \t* g++.dg/warn/Wsign-compare-3.C: New testcase."}, {"sha": "1cc9d109318ca5b8d5377e7200f50986a72ab4a2", "filename": "gcc/testsuite/gnat.dg/array6.adb", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Ftestsuite%2Fgnat.dg%2Farray6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2/gcc%2Ftestsuite%2Fgnat.dg%2Farray6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray6.adb?ref=c0e1e1087bd9bf719d254a6e4b01d4ce061f33c2", "patch": "@@ -0,0 +1,25 @@\n+-- { dg-do run }\n+\n+with Interfaces; use Interfaces;\n+\n+procedure Array6 is\n+\n+   type buf_t is array (unsigned_32 range <>) of character;\n+   type v_str_t (first, last : unsigned_32) is\n+      record\n+         buf : buf_t (first .. last) := (others => ' ');\n+      end record;\n+   type v_str_ptr_t is access all v_str_t;\n+\n+   v_str : v_str_ptr_t;\n+\n+   function build_v_str (f, l : unsigned_32) return v_str_ptr_t is\n+      vp : v_str_ptr_t := new v_str_t (f, l);\n+   begin\n+      return vp;\n+   end;\n+\n+begin\n+   v_str := build_v_str (unsigned_32'last/2 - 256,\n+                         unsigned_32'last/2 + 1024*1024);\n+end;"}]}