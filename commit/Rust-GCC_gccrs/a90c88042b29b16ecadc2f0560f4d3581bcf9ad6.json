{"sha": "a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkwYzg4MDQyYjI5YjE2ZWNhZGMyZjA1NjBmNGQzNTgxYmNmOWFkNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:55:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:55:37Z"}, "message": "poly_int: get_addr_base_and_unit_offset\n\nThis patch changes the values returned by\nget_addr_base_and_unit_offset from HOST_WIDE_INT to poly_int64.\n\nmaxsize in gimple_fold_builtin_memory_op goes from HOST_WIDE_INT\nto poly_uint64 (rather than poly_int) to match the previous use\nof tree_fits_uhwi_p.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-dfa.h (get_addr_base_and_unit_offset_1): Return the offset\n\tas a poly_int64_pod rather than a HOST_WIDE_INT.\n\t(get_addr_base_and_unit_offset): Likewise.\n\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Likewise.\n\t(get_addr_base_and_unit_offset): Likewise.\n\t* doc/match-and-simplify.texi: Change off from HOST_WIDE_INT\n\tto poly_int64 in example.\n\t* fold-const.c (fold_binary_loc): Update call to\n\tget_addr_base_and_unit_offset.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Likewise.\n\t(maybe_canonicalize_mem_ref_addr): Likewise.\n\t(gimple_fold_stmt_to_constant_1): Likewise.\n\t* gimple-ssa-warn-restrict.c (builtin_memref::builtin_memref):\n\tLikewise.\n\t* ipa-param-manipulation.c (ipa_modify_call_arguments): Likewise.\n\t* match.pd: Likewise.\n\t* omp-low.c (lower_omp_target): Likewise.\n\t* tree-sra.c (build_ref_for_offset): Likewise.\n\t(build_debug_ref_for_model): Likewise.\n\t* tree-ssa-address.c (maybe_fold_tmr): Likewise.\n\t* tree-ssa-alias.c (ao_ref_init_from_ptr_and_size): Likewise.\n\t* tree-ssa-ccp.c (optimize_memcpy): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n\t(constant_pointer_difference): Likewise.\n\t* tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n\t* tree-ssa-phiopt.c (jump_function_from_stmt): Likewise.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Likewise.\n\t(vn_reference_maybe_forwprop_address, vn_reference_lookup_3): Likewise.\n\t(set_ssa_val_to): Likewise.\n\t* tree-ssa-strlen.c (get_addr_stridx, addr_stridxptr)\n\t(maybe_diag_stxncpy_trunc): Likewise.\n\t* tree-vrp.c (vrp_prop::check_array_ref): Likewise.\n\t* tree.c (build_simple_mem_ref_loc): Likewise.\n\t(array_at_struct_end_p): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255887", "tree": {"sha": "2e6dcba8a6c3ba6a73ae47044aa1ecc7a042c4ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e6dcba8a6c3ba6a73ae47044aa1ecc7a042c4ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/comments", "author": null, "committer": null, "parents": [{"sha": "588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20"}], "stats": {"total": 259, "additions": 148, "deletions": 111}, "files": [{"sha": "779d114d9b514646afcd04061cc560fd7b2fe7bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -1,3 +1,43 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-dfa.h (get_addr_base_and_unit_offset_1): Return the offset\n+\tas a poly_int64_pod rather than a HOST_WIDE_INT.\n+\t(get_addr_base_and_unit_offset): Likewise.\n+\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Likewise.\n+\t(get_addr_base_and_unit_offset): Likewise.\n+\t* doc/match-and-simplify.texi: Change off from HOST_WIDE_INT\n+\tto poly_int64 in example.\n+\t* fold-const.c (fold_binary_loc): Update call to\n+\tget_addr_base_and_unit_offset.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Likewise.\n+\t(maybe_canonicalize_mem_ref_addr): Likewise.\n+\t(gimple_fold_stmt_to_constant_1): Likewise.\n+\t* gimple-ssa-warn-restrict.c (builtin_memref::builtin_memref):\n+\tLikewise.\n+\t* ipa-param-manipulation.c (ipa_modify_call_arguments): Likewise.\n+\t* match.pd: Likewise.\n+\t* omp-low.c (lower_omp_target): Likewise.\n+\t* tree-sra.c (build_ref_for_offset): Likewise.\n+\t(build_debug_ref_for_model): Likewise.\n+\t* tree-ssa-address.c (maybe_fold_tmr): Likewise.\n+\t* tree-ssa-alias.c (ao_ref_init_from_ptr_and_size): Likewise.\n+\t* tree-ssa-ccp.c (optimize_memcpy): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n+\t(constant_pointer_difference): Likewise.\n+\t* tree-ssa-loop-niter.c (expand_simple_operations): Likewise.\n+\t* tree-ssa-phiopt.c (jump_function_from_stmt): Likewise.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n+\t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Likewise.\n+\t(vn_reference_maybe_forwprop_address, vn_reference_lookup_3): Likewise.\n+\t(set_ssa_val_to): Likewise.\n+\t* tree-ssa-strlen.c (get_addr_stridx, addr_stridxptr)\n+\t(maybe_diag_stxncpy_trunc): Likewise.\n+\t* tree-vrp.c (vrp_prop::check_array_ref): Likewise.\n+\t* tree.c (build_simple_mem_ref_loc): Likewise.\n+\t(array_at_struct_end_p): Likewise.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "35ceb11728cea0d05a41f424054e48103f85e329", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -205,7 +205,7 @@ Captures can also be used for capturing results of sub-expressions.\n   (pointer_plus (addr@@2 @@0) INTEGER_CST_P@@1)\n   (if (is_gimple_min_invariant (@@2)))\n   @{\n-    HOST_WIDE_INT off;\n+    poly_int64 off;\n     tree base = get_addr_base_and_unit_offset (@@0, &off);\n     off += tree_to_uhwi (@@1);\n     /* Now with that we should be able to simply write"}, {"sha": "c9551d93d1ebf4fa622737932c494c6a1555f4a5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -9358,7 +9358,7 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t  && handled_component_p (TREE_OPERAND (arg0, 0)))\n \t{\n \t  tree base;\n-\t  HOST_WIDE_INT coffset;\n+\t  poly_int64 coffset;\n \t  base = get_addr_base_and_unit_offset (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t\t&coffset);\n \t  if (!base)"}, {"sha": "7b3c6db919f85c4b582e6d376658c0b6d17479fe", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -865,8 +865,8 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t      && TREE_CODE (dest) == ADDR_EXPR)\n \t    {\n \t      tree src_base, dest_base, fn;\n-\t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n-\t      HOST_WIDE_INT maxsize;\n+\t      poly_int64 src_offset = 0, dest_offset = 0;\n+\t      poly_uint64 maxsize;\n \n \t      srcvar = TREE_OPERAND (src, 0);\n \t      src_base = get_addr_base_and_unit_offset (srcvar, &src_offset);\n@@ -877,16 +877,14 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t\t &dest_offset);\n \t      if (dest_base == NULL)\n \t\tdest_base = destvar;\n-\t      if (tree_fits_uhwi_p (len))\n-\t\tmaxsize = tree_to_uhwi (len);\n-\t      else\n+\t      if (!poly_int_tree_p (len, &maxsize))\n \t\tmaxsize = -1;\n \t      if (SSA_VAR_P (src_base)\n \t\t  && SSA_VAR_P (dest_base))\n \t\t{\n \t\t  if (operand_equal_p (src_base, dest_base, 0)\n-\t\t      && ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\t   dest_offset, maxsize))\n+\t\t      && ranges_maybe_overlap_p (src_offset, maxsize,\n+\t\t\t\t\t\t dest_offset, maxsize))\n \t\t    return false;\n \t\t}\n \t      else if (TREE_CODE (src_base) == MEM_REF\n@@ -895,17 +893,12 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n \t\t\t\t\t TREE_OPERAND (dest_base, 0), 0))\n \t\t    return false;\n-\t\t  offset_int off = mem_ref_offset (src_base) + src_offset;\n-\t\t  if (!wi::fits_shwi_p (off))\n-\t\t    return false;\n-\t\t  src_offset = off.to_shwi ();\n-\n-\t\t  off = mem_ref_offset (dest_base) + dest_offset;\n-\t\t  if (!wi::fits_shwi_p (off))\n-\t\t    return false;\n-\t\t  dest_offset = off.to_shwi ();\n-\t\t  if (ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\tdest_offset, maxsize))\n+\t\t  poly_offset_int full_src_offset\n+\t\t    = mem_ref_offset (src_base) + src_offset;\n+\t\t  poly_offset_int full_dest_offset\n+\t\t    = mem_ref_offset (dest_base) + dest_offset;\n+\t\t  if (ranges_maybe_overlap_p (full_src_offset, maxsize,\n+\t\t\t\t\t      full_dest_offset, maxsize))\n \t\t    return false;\n \t\t}\n \t      else\n@@ -4479,7 +4472,7 @@ maybe_canonicalize_mem_ref_addr (tree *t)\n \t      || handled_component_p (TREE_OPERAND (addr, 0))))\n \t{\n \t  tree base;\n-\t  HOST_WIDE_INT coffset;\n+\t  poly_int64 coffset;\n \t  base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n \t\t\t\t\t\t&coffset);\n \t  if (!base)\n@@ -6065,7 +6058,7 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t      else if (TREE_CODE (rhs) == ADDR_EXPR\n \t\t       && !is_gimple_min_invariant (rhs))\n \t\t{\n-\t\t  HOST_WIDE_INT offset = 0;\n+\t\t  poly_int64 offset = 0;\n \t\t  tree base;\n \t\t  base = get_addr_base_and_unit_offset_1 (TREE_OPERAND (rhs, 0),\n \t\t\t\t\t\t\t  &offset,"}, {"sha": "69992b89bd6250e17880b2ec675250b2b5d4fde2", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -311,17 +311,18 @@ builtin_memref::builtin_memref (tree expr, tree size)\n \n   if (TREE_CODE (expr) == ADDR_EXPR)\n     {\n-      HOST_WIDE_INT off;\n+      poly_int64 off;\n       tree oper = TREE_OPERAND (expr, 0);\n \n       /* Determine the base object or pointer of the reference\n \t and its constant offset from the beginning of the base.  */\n       base = get_addr_base_and_unit_offset (oper, &off);\n \n-      if (base)\n+      HOST_WIDE_INT const_off;\n+      if (base && off.is_constant (&const_off))\n \t{\n-\t  offrange[0] += off;\n-\t  offrange[1] += off;\n+\t  offrange[0] += const_off;\n+\t  offrange[1] += const_off;\n \n \t  /* Stash the reference for offset validation.  */\n \t  ref = oper;\n@@ -333,7 +334,7 @@ builtin_memref::builtin_memref (tree expr, tree size)\n \t      tree field = TREE_OPERAND (ref, 1);\n \t      tree fldoff = DECL_FIELD_OFFSET (field);\n \t      if (TREE_CODE (fldoff) == INTEGER_CST)\n-\t\trefoff = off + wi::to_offset (fldoff);\n+\t\trefoff = const_off + wi::to_offset (fldoff);\n \t    }\n \t}\n       else"}, {"sha": "f8610888cd58f4ccbf8b4771e7fb3d4d6b4a1e1a", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -303,7 +303,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t    off = build_int_cst (adj->alias_ptr_type, byte_offset);\n \t  else\n \t    {\n-\t      HOST_WIDE_INT base_offset;\n+\t      poly_int64 base_offset;\n \t      tree prev_base;\n \t      bool addrof;\n "}, {"sha": "7a7cb90ad17280ba65460fe5629c352ab9fa6651", "filename": "gcc/match.pd", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -3556,7 +3556,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (cmp (convert1?@2 addr@0) (convert2? addr@1))\n   (with\n    {\n-     HOST_WIDE_INT off0, off1;\n+     poly_int64 off0, off1;\n      tree base0 = get_addr_base_and_unit_offset (TREE_OPERAND (@0, 0), &off0);\n      tree base1 = get_addr_base_and_unit_offset (TREE_OPERAND (@1, 0), &off1);\n      if (base0 && TREE_CODE (base0) == MEM_REF)\n@@ -3595,23 +3595,23 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      }\n      (if (equal == 1)\n       (switch\n-       (if (cmp == EQ_EXPR)\n-\t{ constant_boolean_node (off0 == off1, type); })\n-       (if (cmp == NE_EXPR)\n-\t{ constant_boolean_node (off0 != off1, type); })\n-       (if (cmp == LT_EXPR)\n-\t{ constant_boolean_node (off0 < off1, type); })\n-       (if (cmp == LE_EXPR)\n-\t{ constant_boolean_node (off0 <= off1, type); })\n-       (if (cmp == GE_EXPR)\n-\t{ constant_boolean_node (off0 >= off1, type); })\n-       (if (cmp == GT_EXPR)\n-\t{ constant_boolean_node (off0 > off1, type); }))\n+       (if (cmp == EQ_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n+\t{ constant_boolean_node (known_eq (off0, off1), type); })\n+       (if (cmp == NE_EXPR && (known_eq (off0, off1) || known_ne (off0, off1)))\n+\t{ constant_boolean_node (known_ne (off0, off1), type); })\n+       (if (cmp == LT_EXPR && (known_lt (off0, off1) || known_ge (off0, off1)))\n+\t{ constant_boolean_node (known_lt (off0, off1), type); })\n+       (if (cmp == LE_EXPR && (known_le (off0, off1) || known_gt (off0, off1)))\n+\t{ constant_boolean_node (known_le (off0, off1), type); })\n+       (if (cmp == GE_EXPR && (known_ge (off0, off1) || known_lt (off0, off1)))\n+\t{ constant_boolean_node (known_ge (off0, off1), type); })\n+       (if (cmp == GT_EXPR && (known_gt (off0, off1) || known_le (off0, off1)))\n+\t{ constant_boolean_node (known_gt (off0, off1), type); }))\n       (if (equal == 0\n \t   && DECL_P (base0) && DECL_P (base1)\n \t   /* If we compare this as integers require equal offset.  */\n \t   && (!INTEGRAL_TYPE_P (TREE_TYPE (@2))\n-\t       || off0 == off1))\n+\t       || known_eq (off0, off1)))\n        (switch\n \t(if (cmp == EQ_EXPR)\n \t { constant_boolean_node (false, type); })"}, {"sha": "2b36732b0e0c84bf18c583d8e4bafb7c93ee276b", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -8329,7 +8329,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t|| OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n \t      {\n \t\tlocation_t clause_loc = OMP_CLAUSE_LOCATION (c);\n-\t\tHOST_WIDE_INT offset = 0;\n+\t\tpoly_int64 offset = 0;\n \t\tgcc_assert (prev);\n \t\tvar = OMP_CLAUSE_DECL (c);\n \t\tif (DECL_P (var)"}, {"sha": "681afbcd05646ecf1df5bfe6789cfa3ce558ba6c", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -706,10 +706,10 @@ get_ref_base_and_extent_hwi (tree exp, HOST_WIDE_INT *poffset,\n    its argument or a constant if the argument is known to be constant.  */\n \n tree\n-get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n+get_addr_base_and_unit_offset_1 (tree exp, poly_int64_pod *poffset,\n \t\t\t\t tree (*valueize) (tree))\n {\n-  HOST_WIDE_INT byte_offset = 0;\n+  poly_int64 byte_offset = 0;\n \n   /* Compute cumulative byte-offset for nested component-refs and array-refs,\n      and find the ultimate containing object.  */\n@@ -719,26 +719,28 @@ get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n \t{\n \tcase BIT_FIELD_REF:\n \t  {\n-\t    HOST_WIDE_INT this_off = TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n-\t    if (this_off % BITS_PER_UNIT)\n+\t    poly_int64 this_byte_offset;\n+\t    poly_uint64 this_bit_offset;\n+\t    if (!poly_int_tree_p (TREE_OPERAND (exp, 2), &this_bit_offset)\n+\t\t|| !multiple_p (this_bit_offset, BITS_PER_UNIT,\n+\t\t\t\t&this_byte_offset))\n \t      return NULL_TREE;\n-\t    byte_offset += this_off / BITS_PER_UNIT;\n+\t    byte_offset += this_byte_offset;\n \t  }\n \t  break;\n \n \tcase COMPONENT_REF:\n \t  {\n \t    tree field = TREE_OPERAND (exp, 1);\n \t    tree this_offset = component_ref_field_offset (exp);\n-\t    HOST_WIDE_INT hthis_offset;\n+\t    poly_int64 hthis_offset;\n \n \t    if (!this_offset\n-\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n+\t\t|| !poly_int_tree_p (this_offset, &hthis_offset)\n \t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n \t\t    % BITS_PER_UNIT))\n \t      return NULL_TREE;\n \n-\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n \t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n \t\t\t     / BITS_PER_UNIT);\n \t    byte_offset += hthis_offset;\n@@ -756,17 +758,18 @@ get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n \t      index = (*valueize) (index);\n \n \t    /* If the resulting bit-offset is constant, track it.  */\n-\t    if (TREE_CODE (index) == INTEGER_CST\n+\t    if (poly_int_tree_p (index)\n \t\t&& (low_bound = array_ref_low_bound (exp),\n-\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t    poly_int_tree_p (low_bound))\n \t\t&& (unit_size = array_ref_element_size (exp),\n \t\t    TREE_CODE (unit_size) == INTEGER_CST))\n \t      {\n-\t\toffset_int woffset\n-\t\t  = wi::sext (wi::to_offset (index) - wi::to_offset (low_bound),\n+\t\tpoly_offset_int woffset\n+\t\t  = wi::sext (wi::to_poly_offset (index)\n+\t\t\t      - wi::to_poly_offset (low_bound),\n \t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n \t\twoffset *= wi::to_offset (unit_size);\n-\t\tbyte_offset += woffset.to_shwi ();\n+\t\tbyte_offset += woffset.force_shwi ();\n \t      }\n \t    else\n \t      return NULL_TREE;\n@@ -843,7 +846,7 @@ get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n    is not BITS_PER_UNIT-aligned.  */\n \n tree\n-get_addr_base_and_unit_offset (tree exp, HOST_WIDE_INT *poffset)\n+get_addr_base_and_unit_offset (tree exp, poly_int64_pod *poffset)\n {\n   return get_addr_base_and_unit_offset_1 (exp, poffset, NULL);\n }"}, {"sha": "ce96360ae494ed25f4320ee6a9c5117e1fc564be", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -33,9 +33,9 @@ extern tree get_ref_base_and_extent (tree, poly_int64_pod *, poly_int64_pod *,\n \t\t\t\t     poly_int64_pod *, bool *);\n extern tree get_ref_base_and_extent_hwi (tree, HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *, bool *);\n-extern tree get_addr_base_and_unit_offset_1 (tree, HOST_WIDE_INT *,\n+extern tree get_addr_base_and_unit_offset_1 (tree, poly_int64_pod *,\n \t\t\t\t\t     tree (*) (tree));\n-extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n+extern tree get_addr_base_and_unit_offset (tree, poly_int64_pod *);\n extern bool stmt_references_abnormal_ssa_name (gimple *);\n extern void replace_abnormal_ssa_names (gimple *);\n extern void dump_enumerated_decls (FILE *, dump_flags_t);"}, {"sha": "36f7885cfcee9327f779e0666f138c020040c0e6", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -1713,7 +1713,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n   tree prev_base = base;\n   tree off;\n   tree mem_ref;\n-  HOST_WIDE_INT base_offset;\n+  poly_int64 base_offset;\n   unsigned HOST_WIDE_INT misalign;\n   unsigned int align;\n \n@@ -1821,7 +1821,7 @@ static tree\n build_debug_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t\t   struct access *model)\n {\n-  HOST_WIDE_INT base_offset;\n+  poly_int64 base_offset;\n   tree off;\n \n   if (TREE_CODE (model->expr) == COMPONENT_REF"}, {"sha": "f3913a85fc512b2c4c81957b754ac03ca70cf176", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -1061,7 +1061,7 @@ maybe_fold_tmr (tree ref)\n   else if (addr.symbol\n \t   && handled_component_p (TREE_OPERAND (addr.symbol, 0)))\n     {\n-      HOST_WIDE_INT offset;\n+      poly_int64 offset;\n       addr.symbol = build_fold_addr_expr\n \t\t      (get_addr_base_and_unit_offset\n \t\t         (TREE_OPERAND (addr.symbol, 0), &offset));"}, {"sha": "2f8ff40f04268dde35d4c9698f6a795e0be594ed", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -679,8 +679,7 @@ ao_ref_alias_set (ao_ref *ref)\n void\n ao_ref_init_from_ptr_and_size (ao_ref *ref, tree ptr, tree size)\n {\n-  HOST_WIDE_INT t;\n-  poly_int64 size_hwi, extra_offset = 0;\n+  poly_int64 t, size_hwi, extra_offset = 0;\n   ref->ref = NULL_TREE;\n   if (TREE_CODE (ptr) == SSA_NAME)\n     {"}, {"sha": "e38c0096b0f672bb15d00452e0395f02978d336b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -3032,7 +3032,7 @@ optimize_memcpy (gimple_stmt_iterator *gsip, tree dest, tree src, tree len)\n \n   gimple *defstmt = SSA_NAME_DEF_STMT (vuse);\n   tree src2 = NULL_TREE, len2 = NULL_TREE;\n-  HOST_WIDE_INT offset, offset2;\n+  poly_int64 offset, offset2;\n   tree val = integer_zero_node;\n   if (gimple_store_p (defstmt)\n       && gimple_assign_single_p (defstmt)\n@@ -3064,16 +3064,16 @@ optimize_memcpy (gimple_stmt_iterator *gsip, tree dest, tree src, tree len)\n \t    ? DECL_SIZE_UNIT (TREE_OPERAND (src2, 1))\n \t    : TYPE_SIZE_UNIT (TREE_TYPE (src2)));\n   if (len == NULL_TREE\n-      || TREE_CODE (len) != INTEGER_CST\n+      || !poly_int_tree_p (len)\n       || len2 == NULL_TREE\n-      || TREE_CODE (len2) != INTEGER_CST)\n+      || !poly_int_tree_p (len2))\n     return;\n \n   src = get_addr_base_and_unit_offset (src, &offset);\n   src2 = get_addr_base_and_unit_offset (src2, &offset2);\n   if (src == NULL_TREE\n       || src2 == NULL_TREE\n-      || offset < offset2)\n+      || maybe_lt (offset, offset2))\n     return;\n \n   if (!operand_equal_p (src, src2, 0))\n@@ -3082,7 +3082,8 @@ optimize_memcpy (gimple_stmt_iterator *gsip, tree dest, tree src, tree len)\n   /* [ src + offset2, src + offset2 + len2 - 1 ] is set to val.\n      Make sure that\n      [ src + offset, src + offset + len - 1 ] is a subset of that.  */\n-  if (wi::to_offset (len) + (offset - offset2) > wi::to_offset (len2))\n+  if (maybe_gt (wi::to_poly_offset (len) + (offset - offset2),\n+\t\twi::to_poly_offset (len2)))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "74a54c3fcb0769f17cd043c7228eb0504a549e1c", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -759,12 +759,12 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n       && TREE_OPERAND (lhs, 0) == name)\n     {\n       tree def_rhs_base;\n-      HOST_WIDE_INT def_rhs_offset;\n+      poly_int64 def_rhs_offset;\n       /* If the address is invariant we can always fold it.  */\n       if ((def_rhs_base = get_addr_base_and_unit_offset (TREE_OPERAND (def_rhs, 0),\n \t\t\t\t\t\t\t &def_rhs_offset)))\n \t{\n-\t  offset_int off = mem_ref_offset (lhs);\n+\t  poly_offset_int off = mem_ref_offset (lhs);\n \t  tree new_ptr;\n \t  off += def_rhs_offset;\n \t  if (TREE_CODE (def_rhs_base) == MEM_REF)\n@@ -851,11 +851,11 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n       && TREE_OPERAND (rhs, 0) == name)\n     {\n       tree def_rhs_base;\n-      HOST_WIDE_INT def_rhs_offset;\n+      poly_int64 def_rhs_offset;\n       if ((def_rhs_base = get_addr_base_and_unit_offset (TREE_OPERAND (def_rhs, 0),\n \t\t\t\t\t\t\t &def_rhs_offset)))\n \t{\n-\t  offset_int off = mem_ref_offset (rhs);\n+\t  poly_offset_int off = mem_ref_offset (rhs);\n \t  tree new_ptr;\n \t  off += def_rhs_offset;\n \t  if (TREE_CODE (def_rhs_base) == MEM_REF)\n@@ -1170,12 +1170,12 @@ constant_pointer_difference (tree p1, tree p2)\n \t  if (TREE_CODE (p) == ADDR_EXPR)\n \t    {\n \t      tree q = TREE_OPERAND (p, 0);\n-\t      HOST_WIDE_INT offset;\n+\t      poly_int64 offset;\n \t      tree base = get_addr_base_and_unit_offset (q, &offset);\n \t      if (base)\n \t\t{\n \t\t  q = base;\n-\t\t  if (offset)\n+\t\t  if (maybe_ne (offset, 0))\n \t\t    off = size_binop (PLUS_EXPR, off, size_int (offset));\n \t\t}\n \t      if (TREE_CODE (q) == MEM_REF"}, {"sha": "a8beeacd14db13bb856a043e3775ee1b65101654", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -1987,7 +1987,7 @@ expand_simple_operations (tree expr, tree stop)\n \treturn expand_simple_operations (e, stop);\n       else if (code == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT offset;\n+\t  poly_int64 offset;\n \t  tree base = get_addr_base_and_unit_offset (TREE_OPERAND (e, 0),\n \t\t\t\t\t\t     &offset);\n \t  if (base"}, {"sha": "71e7b67bf52e62a0b74fcfe826113d46e4727717", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -689,12 +689,12 @@ jump_function_from_stmt (tree *arg, gimple *stmt)\n     {\n       /* For arg = &p->i transform it to p, if possible.  */\n       tree rhs1 = gimple_assign_rhs1 (stmt);\n-      HOST_WIDE_INT offset;\n+      poly_int64 offset;\n       tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (rhs1, 0),\n \t\t\t\t\t\t&offset);\n       if (tem\n \t  && TREE_CODE (tem) == MEM_REF\n-\t  && (mem_ref_offset (tem) + offset) == 0)\n+\t  && known_eq (mem_ref_offset (tem) + offset, 0))\n \t{\n \t  *arg = TREE_OPERAND (tem, 0);\n \t  return true;"}, {"sha": "d91fec2a1361e90e515db83b1fa99e392ebdb451", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -2413,7 +2413,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \tif (TREE_CODE (baseop) == ADDR_EXPR\n \t    && handled_component_p (TREE_OPERAND (baseop, 0)))\n \t  {\n-\t    HOST_WIDE_INT off;\n+\t    poly_int64 off;\n \t    tree base;\n \t    base = get_addr_base_and_unit_offset (TREE_OPERAND (baseop, 0),\n \t\t\t\t\t\t  &off);"}, {"sha": "b59d8eb35149112c01e9e252991ba7b8c7772333", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -1163,7 +1163,7 @@ vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n   vn_reference_op_t op = &(*ops)[i];\n   vn_reference_op_t mem_op = &(*ops)[i - 1];\n   tree addr_base;\n-  HOST_WIDE_INT addr_offset = 0;\n+  poly_int64 addr_offset = 0;\n \n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n      from .foo.bar to the preceding MEM_REF offset and replace the\n@@ -1173,8 +1173,10 @@ vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n   gcc_checking_assert (addr_base && TREE_CODE (addr_base) != MEM_REF);\n   if (addr_base != TREE_OPERAND (op->op0, 0))\n     {\n-      offset_int off = offset_int::from (wi::to_wide (mem_op->op0), SIGNED);\n-      off += addr_offset;\n+      poly_offset_int off\n+\t= (poly_offset_int::from (wi::to_poly_wide (mem_op->op0),\n+\t\t\t\t  SIGNED)\n+\t   + addr_offset);\n       mem_op->op0 = wide_int_to_tree (TREE_TYPE (mem_op->op0), off);\n       op->op0 = build_fold_addr_expr (addr_base);\n       if (tree_fits_shwi_p (mem_op->op0))\n@@ -1197,7 +1199,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n   vn_reference_op_t mem_op = &(*ops)[i - 1];\n   gimple *def_stmt;\n   enum tree_code code;\n-  offset_int off;\n+  poly_offset_int off;\n \n   def_stmt = SSA_NAME_DEF_STMT (op->op0);\n   if (!is_gimple_assign (def_stmt))\n@@ -1208,15 +1210,15 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n       && code != POINTER_PLUS_EXPR)\n     return false;\n \n-  off = offset_int::from (wi::to_wide (mem_op->op0), SIGNED);\n+  off = poly_offset_int::from (wi::to_poly_wide (mem_op->op0), SIGNED);\n \n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n      from .foo.bar to the preceding MEM_REF offset and replace the\n      address with &OBJ.  */\n   if (code == ADDR_EXPR)\n     {\n       tree addr, addr_base;\n-      HOST_WIDE_INT addr_offset;\n+      poly_int64 addr_offset;\n \n       addr = gimple_assign_rhs1 (def_stmt);\n       addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n@@ -1226,7 +1228,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t dereference isn't offsetted.  */\n       if (!addr_base\n \t  && *i_p == ops->length () - 1\n-\t  && off == 0\n+\t  && known_eq (off, 0)\n \t  /* This makes us disable this transform for PRE where the\n \t     reference ops might be also used for code insertion which\n \t     is invalid.  */\n@@ -1243,7 +1245,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t      vn_reference_op_t new_mem_op = &tem[tem.length () - 2];\n \t      new_mem_op->op0\n \t\t= wide_int_to_tree (TREE_TYPE (mem_op->op0),\n-\t\t\t\t    wi::to_wide (new_mem_op->op0));\n+\t\t\t\t    wi::to_poly_wide (new_mem_op->op0));\n \t    }\n \t  else\n \t    gcc_assert (tem.last ().opcode == STRING_CST);\n@@ -2288,10 +2290,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t}\n       if (TREE_CODE (lhs) == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT tmp_lhs_offset;\n \t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (lhs, 0),\n-\t\t\t\t\t\t    &tmp_lhs_offset);\n-\t  lhs_offset = tmp_lhs_offset;\n+\t\t\t\t\t\t    &lhs_offset);\n \t  if (!tem)\n \t    return (void *)-1;\n \t  if (TREE_CODE (tem) == MEM_REF\n@@ -2318,10 +2318,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \trhs = SSA_VAL (rhs);\n       if (TREE_CODE (rhs) == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT tmp_rhs_offset;\n \t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t\t    &tmp_rhs_offset);\n-\t  rhs_offset = tmp_rhs_offset;\n+\t\t\t\t\t\t    &rhs_offset);\n \t  if (!tem)\n \t    return (void *)-1;\n \t  if (TREE_CODE (tem) == MEM_REF\n@@ -3329,7 +3327,7 @@ static inline bool\n set_ssa_val_to (tree from, tree to)\n {\n   tree currval = SSA_VAL (from);\n-  HOST_WIDE_INT toff, coff;\n+  poly_int64 toff, coff;\n \n   /* The only thing we allow as value numbers are ssa_names\n      and invariants.  So assert that here.  We don't allow VN_TOP\n@@ -3411,7 +3409,7 @@ set_ssa_val_to (tree from, tree to)\n \t   && TREE_CODE (to) == ADDR_EXPR\n \t   && (get_addr_base_and_unit_offset (TREE_OPERAND (currval, 0), &coff)\n \t       == get_addr_base_and_unit_offset (TREE_OPERAND (to, 0), &toff))\n-\t   && coff == toff))\n+\t   && known_eq (coff, toff)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" (changed)\\n\");"}, {"sha": "e812bd1e73501d4969543e8d53f6ea41186433c1", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -241,8 +241,9 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out)\n   if (!decl_to_stridxlist_htab)\n     return 0;\n \n-  base = get_addr_base_and_unit_offset (exp, &off);\n-  if (base == NULL || !DECL_P (base))\n+  poly_int64 poff;\n+  base = get_addr_base_and_unit_offset (exp, &poff);\n+  if (base == NULL || !DECL_P (base) || !poff.is_constant (&off))\n     return 0;\n \n   list = decl_to_stridxlist_htab->get (base);\n@@ -382,8 +383,9 @@ addr_stridxptr (tree exp)\n {\n   HOST_WIDE_INT off;\n \n-  tree base = get_addr_base_and_unit_offset (exp, &off);\n-  if (base == NULL_TREE || !DECL_P (base))\n+  poly_int64 poff;\n+  tree base = get_addr_base_and_unit_offset (exp, &poff);\n+  if (base == NULL_TREE || !DECL_P (base) || !poff.is_constant (&off))\n     return NULL;\n \n   if (!decl_to_stridxlist_htab)\n@@ -1869,13 +1871,13 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n       if (TREE_CODE (ref) == ARRAY_REF)\n \tref = TREE_OPERAND (ref, 0);\n \n-      HOST_WIDE_INT dstoff;\n+      poly_int64 dstoff;\n       tree dstbase = get_addr_base_and_unit_offset (ref, &dstoff);\n \n-      HOST_WIDE_INT lhsoff;\n+      poly_int64 lhsoff;\n       tree lhsbase = get_addr_base_and_unit_offset (lhs, &lhsoff);\n       if (lhsbase\n-\t  && dstoff == lhsoff\n+\t  && known_eq (dstoff, lhsoff)\n \t  && operand_equal_p (dstbase, lhsbase, 0))\n \treturn false;\n     }"}, {"sha": "9940f5012a18dc3e9e0e3caa7f490b8e64f1fdc2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -4822,9 +4822,9 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n \t{\n \t  tree maxbound = TYPE_MAX_VALUE (ptrdiff_type_node);\n \t  tree arg = TREE_OPERAND (ref, 0);\n-\t  HOST_WIDE_INT off;\n+\t  poly_int64 off;\n \n-\t  if (get_addr_base_and_unit_offset (arg, &off) && off > 0)\n+\t  if (get_addr_base_and_unit_offset (arg, &off) && known_gt (off, 0))\n \t    maxbound = wide_int_to_tree (sizetype,\n \t\t\t\t\t wi::sub (wi::to_wide (maxbound),\n \t\t\t\t\t\t  off));"}, {"sha": "400c5c7895e9c238dcfe395f78bf4490382a5f81", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "patch": "@@ -4827,7 +4827,7 @@ build5 (enum tree_code code, tree tt, tree arg0, tree arg1,\n tree\n build_simple_mem_ref_loc (location_t loc, tree ptr)\n {\n-  HOST_WIDE_INT offset = 0;\n+  poly_int64 offset = 0;\n   tree ptype = TREE_TYPE (ptr);\n   tree tem;\n   /* For convenience allow addresses that collapse to a simple base\n@@ -12919,7 +12919,7 @@ array_at_struct_end_p (tree ref)\n     {\n       /* Check whether the array domain covers all of the available\n          padding.  */\n-      HOST_WIDE_INT offset;\n+      poly_int64 offset;\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (atype))) != INTEGER_CST\n \t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST\n           || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST)\n@@ -12928,11 +12928,11 @@ array_at_struct_end_p (tree ref)\n \treturn true;\n \n       /* If at least one extra element fits it is a flexarray.  */\n-      if (wi::les_p ((wi::to_offset (TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n-\t\t      - wi::to_offset (TYPE_MIN_VALUE (TYPE_DOMAIN (atype)))\n-\t\t      + 2)\n-\t\t     * wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (atype))),\n-\t\t     wi::to_offset (DECL_SIZE_UNIT (ref)) - offset))\n+      if (known_le ((wi::to_offset (TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n+\t\t     - wi::to_offset (TYPE_MIN_VALUE (TYPE_DOMAIN (atype)))\n+\t\t     + 2)\n+\t\t    * wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (atype))),\n+\t\t    wi::to_offset (DECL_SIZE_UNIT (ref)) - offset))\n \treturn true;\n \n       return false;"}]}