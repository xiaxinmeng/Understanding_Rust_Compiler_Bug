{"sha": "7b1c3dd9e670da2041ff1af415999310f88888ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxYzNkZDllNjcwZGEyMDQxZmYxYWY0MTU5OTkzMTBmODg4ODhhZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-13T19:16:27Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-13T19:16:27Z"}, "message": "libgo: Update to weekly.2011-12-02.\n\nFrom-SVN: r182295", "tree": {"sha": "c5132538d5da85ed816c7e1f9d93c4a503b838ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5132538d5da85ed816c7e1f9d93c4a503b838ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1c3dd9e670da2041ff1af415999310f88888ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1c3dd9e670da2041ff1af415999310f88888ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1c3dd9e670da2041ff1af415999310f88888ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1c3dd9e670da2041ff1af415999310f88888ad/comments", "author": null, "committer": null, "parents": [{"sha": "36cfbee133027429a681ce585643d38228ab1213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cfbee133027429a681ce585643d38228ab1213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36cfbee133027429a681ce585643d38228ab1213"}], "stats": {"total": 11231, "additions": 6590, "deletions": 4641}, "files": [{"sha": "1b32475003a80872c391510dfac2c1a75a8f069c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug257.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug257.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug257.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug257.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -20047,19 +20047,18 @@ var gettysburg = \"  Four score and seven years ago our fathers brought forth on\\\n \t\"\\n\" +\n \t\"Abraham Lincoln, November 19, 1863, Gettysburg, Pennsylvania\\n\"\n \n-\n func main() {\n \tm := md5.New()\n \tio.WriteString(m, data)\n-\thash := fmt.Sprintf(\"%x\", m.Sum())\n+\thash := fmt.Sprintf(\"%x\", m.Sum(nil))\n \tif hash != \"525f06bc62a65017cd2217d7584e5920\" {\n \t\tprintln(\"BUG a\", hash)\n \t\treturn\n \t}\n \n \tm = md5.New()\n \tio.WriteString(m, gettysburg)\n-\thash = fmt.Sprintf(\"%x\", m.Sum())\n+\thash = fmt.Sprintf(\"%x\", m.Sum(nil))\n \tif hash != \"d7ec5d9d47a4d166091e8d9ebd7ea0aa\" {\n \t\tprintln(\"BUG gettysburg\", hash)\n \t\tprintln(len(gettysburg))"}, {"sha": "d0c26d2a83730909d9368c56689694ae1a48112e", "filename": "gcc/testsuite/go.test/test/initsyscall.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finitsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finitsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finitsyscall.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -19,9 +19,8 @@ func f() {\n \n func init() {\n \tgo f()\n-\ttime.Nanoseconds()\n+\ttime.Now()\n }\n \n func main() {\n }\n-"}, {"sha": "9847f4715a5c4b1b08458903488fc9a86893cdc9", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1,4 +1,4 @@\n-b4a91b693374\n+0beb796b4ef8\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "3db823e8e1a6af3e15dec70ee8899ae6e6fbf026", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -233,7 +233,6 @@ toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n-\texp/gui.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/spdy.gox \\\n@@ -242,11 +241,6 @@ toolexeclibgoexp_DATA = \\\n \texp/terminal.gox \\\n \texp/types.gox\n \n-toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n-\n-toolexeclibgoexpgui_DATA = \\\n-\texp/gui/x11.gox\n-\n toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n \n toolexeclibgoexpsql_DATA = \\\n@@ -447,6 +441,7 @@ runtime_files = \\\n \truntime/go-map-len.c \\\n \truntime/go-map-range.c \\\n \truntime/go-nanotime.c \\\n+\truntime/go-now.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-panic.c \\\n@@ -576,6 +571,7 @@ go_hash_files = \\\n go_html_files = \\\n \tgo/html/const.go \\\n \tgo/html/doc.go \\\n+\tgo/html/doctype.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n \tgo/html/node.go \\\n@@ -888,7 +884,7 @@ go_time_files = \\\n \tgo/time/sys_unix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n-\tgo/time/zoneinfo_posix.go \\\n+\tgo/time/zoneinfo.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_unicode_files = \\\n@@ -1038,6 +1034,7 @@ go_crypto_twofish_files = \\\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n+\tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n go_crypto_xtea_files = \\\n@@ -1135,8 +1132,6 @@ go_encoding_xml_files = \\\n go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n-go_exp_gui_files = \\\n-\tgo/exp/gui/gui.go\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n go_exp_norm_files = \\\n@@ -1178,10 +1173,6 @@ go_exp_types_files = \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n \n-go_exp_gui_x11_files = \\\n-\tgo/exp/gui/x11/auth.go \\\n-\tgo/exp/gui/x11/conn.go\n-\n go_exp_sql_driver_files = \\\n \tgo/exp/sql/driver/driver.go \\\n \tgo/exp/sql/driver/types.go\n@@ -1415,13 +1406,11 @@ go_text_template_files = \\\n \tgo/text/template/exec.go \\\n \tgo/text/template/funcs.go \\\n \tgo/text/template/helper.go \\\n-\tgo/text/template/parse.go \\\n-\tgo/text/template/set.go\n+\tgo/text/template/template.go\n go_text_template_parse_files = \\\n \tgo/text/template/parse/lex.go \\\n \tgo/text/template/parse/node.go \\\n-\tgo/text/template/parse/parse.go \\\n-\tgo/text/template/parse/set.go\n+\tgo/text/template/parse/parse.go\n \n go_sync_atomic_files = \\\n \tgo/sync/atomic/doc.go\n@@ -1725,14 +1714,12 @@ libgo_go_objs = \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n-\texp/gui.lo \\\n \texp/norm.lo \\\n \texp/spdy.lo \\\n \texp/sql.lo \\\n \texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n-\texp/gui/x11.lo \\\n \texp/sql/driver.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n@@ -2784,16 +2771,6 @@ exp/ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/ebnf/check\n \n-@go_include@ exp/gui.lo.dep\n-exp/gui.lo.dep: $(go_exp_gui_files)\n-\t$(BUILDDEPS)\n-exp/gui.lo: $(go_exp_gui_files)\n-\t$(BUILDPACKAGE)\n-exp/gui/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/gui\n-\t@$(CHECK)\n-.PHONY: exp/gui/check\n-\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -2854,16 +2831,6 @@ exp/types/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/types/check\n \n-@go_include@ exp/gui/x11.lo.dep\n-exp/gui/x11.lo.dep: $(go_exp_gui_x11_files)\n-\t$(BUILDDEPS)\n-exp/gui/x11.lo: $(go_exp_gui_x11_files)\n-\t$(BUILDPACKAGE)\n-exp/gui/x11/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/gui/x11\n-\t@$(CHECK)\n-.PHONY: exp/gui/x11/check\n-\n @go_include@ exp/inotify.lo.dep\n exp/inotify.lo.dep: $(go_exp_inotify_files)\n \t$(BUILDDEPS)\n@@ -3686,8 +3653,6 @@ encoding/xml.gox: encoding/xml.lo\n \n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n-exp/gui.gox: exp/gui.lo\n-\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n@@ -3703,9 +3668,6 @@ exp/terminal.gox: exp/terminal.lo\n exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n \n-exp/gui/x11.gox: exp/gui/x11.lo\n-\t$(BUILDGOX)\n-\n exp/sql/driver.gox: exp/sql/driver.lo\n \t$(BUILDGOX)\n \n@@ -3950,6 +3912,7 @@ TEST_PACKAGES = \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n+\tgo/doc/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\"}, {"sha": "6552074a3da22dd051cb0a5377b2622c413dc604", "filename": "libgo/Makefile.in", "status": "modified", "additions": 57, "deletions": 111, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -102,7 +102,6 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgodebugdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgoexpguidir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n@@ -161,15 +160,15 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tencoding/base64.lo encoding/binary.lo encoding/csv.lo \\\n \tencoding/git85.lo encoding/gob.lo encoding/hex.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/gui.lo exp/norm.lo exp/spdy.lo exp/sql.lo exp/ssh.lo \\\n-\texp/terminal.lo exp/types.lo exp/gui/x11.lo exp/sql/driver.lo \\\n-\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n-\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n-\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n-\tnet/http/pprof.lo image/bmp.lo image/color.lo image/draw.lo \\\n-\timage/gif.lo image/jpeg.lo image/png.lo image/tiff.lo \\\n-\timage/ycbcr.lo index/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n+\texp/norm.lo exp/spdy.lo exp/sql.lo exp/ssh.lo exp/terminal.lo \\\n+\texp/types.lo exp/sql/driver.lo html/template.lo go/ast.lo \\\n+\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n+\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n+\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n+\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n+\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n \tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n \tmime/mime.lo mime/multipart.lo net/dict.lo net/http.lo \\\n \tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n@@ -200,12 +199,12 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-interface-val-compare.c runtime/go-make-slice.c \\\n \truntime/go-map-delete.c runtime/go-map-index.c \\\n \truntime/go-map-len.c runtime/go-map-range.c \\\n-\truntime/go-nanotime.c runtime/go-new-map.c runtime/go-new.c \\\n-\truntime/go-panic.c runtime/go-print.c runtime/go-recover.c \\\n-\truntime/go-reflect.c runtime/go-reflect-call.c \\\n-\truntime/go-reflect-map.c runtime/go-rune.c \\\n-\truntime/go-runtime-error.c runtime/go-setenv.c \\\n-\truntime/go-signal.c runtime/go-strcmp.c \\\n+\truntime/go-nanotime.c runtime/go-now.c runtime/go-new-map.c \\\n+\truntime/go-new.c runtime/go-panic.c runtime/go-print.c \\\n+\truntime/go-recover.c runtime/go-reflect.c \\\n+\truntime/go-reflect-call.c runtime/go-reflect-map.c \\\n+\truntime/go-rune.c runtime/go-runtime-error.c \\\n+\truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n \truntime/go-strslice.c runtime/go-trampoline.c \\\n@@ -238,20 +237,20 @@ am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-make-slice.lo go-map-delete.lo \\\n \tgo-map-index.lo go-map-len.lo go-map-range.lo go-nanotime.lo \\\n-\tgo-new-map.lo go-new.lo go-panic.lo go-print.lo go-recover.lo \\\n-\tgo-reflect.lo go-reflect-call.lo go-reflect-map.lo go-rune.lo \\\n-\tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n-\tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n-\tgo-strplus.lo go-strslice.lo go-trampoline.lo go-type-eface.lo \\\n-\tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n-\tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n-\tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo chan.lo cpuprof.lo \\\n-\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n-\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n-\truntime.lo thread.lo yield.lo $(am__objects_3) iface.lo \\\n-\tmalloc.lo map.lo mprof.lo reflect.lo runtime1.lo sema.lo \\\n-\tsigqueue.lo string.lo time.lo\n+\tgo-now.lo go-new-map.lo go-new.lo go-panic.lo go-print.lo \\\n+\tgo-recover.lo go-reflect.lo go-reflect-call.lo \\\n+\tgo-reflect-map.lo go-rune.lo go-runtime-error.lo go-setenv.lo \\\n+\tgo-signal.lo go-strcmp.lo go-string-to-byte-array.lo \\\n+\tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n+\tgo-trampoline.lo go-type-eface.lo go-type-error.lo \\\n+\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n+\tgo-typedesc-equal.lo go-typestring.lo go-unreflect.lo \\\n+\tgo-unsafe-new.lo go-unsafe-newarray.lo go-unsafe-pointer.lo \\\n+\tgo-unwind.lo chan.lo cpuprof.lo $(am__objects_1) mcache.lo \\\n+\tmcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo mgc0.lo \\\n+\tmheap.lo msize.lo proc.lo runtime.lo thread.lo yield.lo \\\n+\t$(am__objects_3) iface.lo malloc.lo map.lo mprof.lo reflect.lo \\\n+\truntime1.lo sema.lo sigqueue.lo string.lo time.lo\n am_libgo_la_OBJECTS = $(am__objects_4)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -290,18 +289,18 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n \t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgoexpgui_DATA) $(toolexeclibgoexpsql_DATA) \\\n-\t$(toolexeclibgogo_DATA) $(toolexeclibgohash_DATA) \\\n-\t$(toolexeclibgohtml_DATA) $(toolexeclibgoimage_DATA) \\\n-\t$(toolexeclibgoindex_DATA) $(toolexeclibgoio_DATA) \\\n-\t$(toolexeclibgolog_DATA) $(toolexeclibgomath_DATA) \\\n-\t$(toolexeclibgomime_DATA) $(toolexeclibgonet_DATA) \\\n-\t$(toolexeclibgonethttp_DATA) $(toolexeclibgonetrpc_DATA) \\\n-\t$(toolexeclibgoold_DATA) $(toolexeclibgoos_DATA) \\\n-\t$(toolexeclibgopath_DATA) $(toolexeclibgoregexp_DATA) \\\n-\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n-\t$(toolexeclibgotesting_DATA) $(toolexeclibgotext_DATA) \\\n-\t$(toolexeclibgotexttemplate_DATA) $(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgoexpsql_DATA) $(toolexeclibgogo_DATA) \\\n+\t$(toolexeclibgohash_DATA) $(toolexeclibgohtml_DATA) \\\n+\t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n+\t$(toolexeclibgoio_DATA) $(toolexeclibgolog_DATA) \\\n+\t$(toolexeclibgomath_DATA) $(toolexeclibgomime_DATA) \\\n+\t$(toolexeclibgonet_DATA) $(toolexeclibgonethttp_DATA) \\\n+\t$(toolexeclibgonetrpc_DATA) $(toolexeclibgoold_DATA) \\\n+\t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n+\t$(toolexeclibgoregexp_DATA) $(toolexeclibgoruntime_DATA) \\\n+\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n+\t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n+\t$(toolexeclibgounicode_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -690,7 +689,6 @@ toolexeclibgoencoding_DATA = \\\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n-\texp/gui.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/spdy.gox \\\n@@ -699,10 +697,6 @@ toolexeclibgoexp_DATA = \\\n \texp/terminal.gox \\\n \texp/types.gox\n \n-toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n-toolexeclibgoexpgui_DATA = \\\n-\texp/gui/x11.gox\n-\n toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n toolexeclibgoexpsql_DATA = \\\n \texp/sql/driver.gox\n@@ -868,6 +862,7 @@ runtime_files = \\\n \truntime/go-map-len.c \\\n \truntime/go-map-range.c \\\n \truntime/go-nanotime.c \\\n+\truntime/go-now.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-panic.c \\\n@@ -960,6 +955,7 @@ go_hash_files = \\\n go_html_files = \\\n \tgo/html/const.go \\\n \tgo/html/doc.go \\\n+\tgo/html/doctype.go \\\n \tgo/html/entity.go \\\n \tgo/html/escape.go \\\n \tgo/html/node.go \\\n@@ -1204,7 +1200,7 @@ go_time_files = \\\n \tgo/time/sys_unix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n-\tgo/time/zoneinfo_posix.go \\\n+\tgo/time/zoneinfo.go \\\n \tgo/time/zoneinfo_unix.go\n \n go_unicode_files = \\\n@@ -1377,6 +1373,7 @@ go_crypto_twofish_files = \\\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n+\tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1495,9 +1492,6 @@ go_exp_ebnf_files = \\\n \tgo/exp/ebnf/ebnf.go \\\n \tgo/exp/ebnf/parser.go\n \n-go_exp_gui_files = \\\n-\tgo/exp/gui/gui.go\n-\n go_exp_inotify_files = \\\n \tgo/exp/inotify/inotify_linux.go\n \n@@ -1545,10 +1539,6 @@ go_exp_types_files = \\\n \tgo/exp/types/types.go \\\n \tgo/exp/types/universe.go\n \n-go_exp_gui_x11_files = \\\n-\tgo/exp/gui/x11/auth.go \\\n-\tgo/exp/gui/x11/conn.go\n-\n go_exp_sql_driver_files = \\\n \tgo/exp/sql/driver/driver.go \\\n \tgo/exp/sql/driver/types.go\n@@ -1805,14 +1795,12 @@ go_text_template_files = \\\n \tgo/text/template/exec.go \\\n \tgo/text/template/funcs.go \\\n \tgo/text/template/helper.go \\\n-\tgo/text/template/parse.go \\\n-\tgo/text/template/set.go\n+\tgo/text/template/template.go\n \n go_text_template_parse_files = \\\n \tgo/text/template/parse/lex.go \\\n \tgo/text/template/parse/node.go \\\n-\tgo/text/template/parse/parse.go \\\n-\tgo/text/template/parse/set.go\n+\tgo/text/template/parse/parse.go\n \n go_sync_atomic_files = \\\n \tgo/sync/atomic/doc.go\n@@ -2016,14 +2004,12 @@ libgo_go_objs = \\\n \tencoding/pem.lo \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n-\texp/gui.lo \\\n \texp/norm.lo \\\n \texp/spdy.lo \\\n \texp/sql.lo \\\n \texp/ssh.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n-\texp/gui/x11.lo \\\n \texp/sql/driver.lo \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n@@ -2295,6 +2281,7 @@ TEST_PACKAGES = \\\n \thtml/template/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n+\tgo/doc/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -2511,6 +2498,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-nanotime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-now.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-print.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n@@ -2799,6 +2787,13 @@ go-nanotime.lo: runtime/go-nanotime.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-nanotime.lo `test -f 'runtime/go-nanotime.c' || echo '$(srcdir)/'`runtime/go-nanotime.c\n \n+go-now.lo: runtime/go-now.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-now.lo -MD -MP -MF $(DEPDIR)/go-now.Tpo -c -o go-now.lo `test -f 'runtime/go-now.c' || echo '$(srcdir)/'`runtime/go-now.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-now.Tpo $(DEPDIR)/go-now.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-now.c' object='go-now.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-now.lo `test -f 'runtime/go-now.c' || echo '$(srcdir)/'`runtime/go-now.c\n+\n go-new-map.lo: runtime/go-new-map.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-new-map.lo -MD -MP -MF $(DEPDIR)/go-new-map.Tpo -c -o go-new-map.lo `test -f 'runtime/go-new-map.c' || echo '$(srcdir)/'`runtime/go-new-map.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-new-map.Tpo $(DEPDIR)/go-new-map.Plo\n@@ -3374,26 +3369,6 @@ uninstall-toolexeclibgoexpDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoexpdir)\" && rm -f $$files\n-install-toolexeclibgoexpguiDATA: $(toolexeclibgoexpgui_DATA)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(toolexeclibgoexpguidir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpguidir)\"\n-\t@list='$(toolexeclibgoexpgui_DATA)'; test -n \"$(toolexeclibgoexpguidir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpguidir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpguidir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toolexeclibgoexpguiDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgoexpgui_DATA)'; test -n \"$(toolexeclibgoexpguidir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpguidir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(toolexeclibgoexpguidir)\" && rm -f $$files\n install-toolexeclibgoexpsqlDATA: $(toolexeclibgoexpsql_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgoexpsqldir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpsqldir)\"\n@@ -4171,7 +4146,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpguidir)\" \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohtmldir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgologdir)\" \"$(DESTDIR)$(toolexeclibgomathdir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgonethttpdir)\" \"$(DESTDIR)$(toolexeclibgonetrpcdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\" \"$(DESTDIR)$(toolexeclibgotextdir)\" \"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \"$(DESTDIR)$(toolexeclibgounicodedir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -4241,7 +4216,6 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgoexpguiDATA \\\n \tinstall-toolexeclibgoexpsqlDATA install-toolexeclibgogoDATA \\\n \tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n \tinstall-toolexeclibgoimageDATA install-toolexeclibgoindexDATA \\\n@@ -4307,7 +4281,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA \\\n-\tuninstall-toolexeclibgoexpguiDATA \\\n \tuninstall-toolexeclibgoexpsqlDATA \\\n \tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n@@ -4355,7 +4328,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgocryptox509DATA \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n-\tinstall-toolexeclibgoexpguiDATA \\\n \tinstall-toolexeclibgoexpsqlDATA install-toolexeclibgogoDATA \\\n \tinstall-toolexeclibgohashDATA install-toolexeclibgohtmlDATA \\\n \tinstall-toolexeclibgoimageDATA install-toolexeclibgoindexDATA \\\n@@ -4385,7 +4357,6 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgodebugDATA \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA \\\n-\tuninstall-toolexeclibgoexpguiDATA \\\n \tuninstall-toolexeclibgoexpsqlDATA \\\n \tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohtmlDATA \\\n@@ -5383,16 +5354,6 @@ exp/ebnf/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/ebnf/check\n \n-@go_include@ exp/gui.lo.dep\n-exp/gui.lo.dep: $(go_exp_gui_files)\n-\t$(BUILDDEPS)\n-exp/gui.lo: $(go_exp_gui_files)\n-\t$(BUILDPACKAGE)\n-exp/gui/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/gui\n-\t@$(CHECK)\n-.PHONY: exp/gui/check\n-\n @go_include@ exp/norm.lo.dep\n exp/norm.lo.dep: $(go_exp_norm_files)\n \t$(BUILDDEPS)\n@@ -5453,16 +5414,6 @@ exp/types/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/types/check\n \n-@go_include@ exp/gui/x11.lo.dep\n-exp/gui/x11.lo.dep: $(go_exp_gui_x11_files)\n-\t$(BUILDDEPS)\n-exp/gui/x11.lo: $(go_exp_gui_x11_files)\n-\t$(BUILDPACKAGE)\n-exp/gui/x11/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/gui/x11\n-\t@$(CHECK)\n-.PHONY: exp/gui/x11/check\n-\n @go_include@ exp/inotify.lo.dep\n exp/inotify.lo.dep: $(go_exp_inotify_files)\n \t$(BUILDDEPS)\n@@ -6280,8 +6231,6 @@ encoding/xml.gox: encoding/xml.lo\n \n exp/ebnf.gox: exp/ebnf.lo\n \t$(BUILDGOX)\n-exp/gui.gox: exp/gui.lo\n-\t$(BUILDGOX)\n exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n@@ -6297,9 +6246,6 @@ exp/terminal.gox: exp/terminal.lo\n exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n \n-exp/gui/x11.gox: exp/gui/x11.lo\n-\t$(BUILDGOX)\n-\n exp/sql/driver.gox: exp/sql/driver.lo\n \t$(BUILDGOX)\n "}, {"sha": "fc7a40923cd2a918f22e116184597b96560d76b6", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -11,41 +11,42 @@\n //   http://www.gnu.org/software/tar/manual/html_node/Standard.html\n package tar\n \n+import \"time\"\n+\n const (\n \tblockSize = 512\n \n \t// Types\n-\tTypeReg           = '0'    // regular file.\n-\tTypeRegA          = '\\x00' // regular file.\n-\tTypeLink          = '1'    // hard link.\n-\tTypeSymlink       = '2'    // symbolic link.\n-\tTypeChar          = '3'    // character device node.\n-\tTypeBlock         = '4'    // block device node.\n-\tTypeDir           = '5'    // directory.\n-\tTypeFifo          = '6'    // fifo node.\n-\tTypeCont          = '7'    // reserved.\n-\tTypeXHeader       = 'x'    // extended header.\n-\tTypeXGlobalHeader = 'g'    // global extended header.\n+\tTypeReg           = '0'    // regular file\n+\tTypeRegA          = '\\x00' // regular file\n+\tTypeLink          = '1'    // hard link\n+\tTypeSymlink       = '2'    // symbolic link\n+\tTypeChar          = '3'    // character device node\n+\tTypeBlock         = '4'    // block device node\n+\tTypeDir           = '5'    // directory\n+\tTypeFifo          = '6'    // fifo node\n+\tTypeCont          = '7'    // reserved\n+\tTypeXHeader       = 'x'    // extended header\n+\tTypeXGlobalHeader = 'g'    // global extended header\n )\n \n // A Header represents a single header in a tar archive.\n // Some fields may not be populated.\n type Header struct {\n-\tName     string // name of header file entry.\n-\tMode     int64  // permission and mode bits.\n-\tUid      int    // user id of owner.\n-\tGid      int    // group id of owner.\n-\tSize     int64  // length in bytes.\n-\tMtime    int64  // modified time; seconds since epoch.\n-\tTypeflag byte   // type of header entry.\n-\tLinkname string // target name of link.\n-\tUname    string // user name of owner.\n-\tGname    string // group name of owner.\n-\tDevmajor int64  // major number of character or block device.\n-\tDevminor int64  // minor number of character or block device.\n-\tAtime    int64  // access time; seconds since epoch.\n-\tCtime    int64  // status change time; seconds since epoch.\n-\n+\tName       string    // name of header file entry\n+\tMode       int64     // permission and mode bits\n+\tUid        int       // user id of owner\n+\tGid        int       // group id of owner\n+\tSize       int64     // length in bytes\n+\tModTime    time.Time // modified time\n+\tTypeflag   byte      // type of header entry\n+\tLinkname   string    // target name of link\n+\tUname      string    // user name of owner\n+\tGname      string    // group name of owner\n+\tDevmajor   int64     // major number of character or block device\n+\tDevminor   int64     // minor number of character or block device\n+\tAccessTime time.Time // access time\n+\tChangeTime time.Time // status change time\n }\n \n var zeroBlock = make([]byte, blockSize)"}, {"sha": "76955e2ec03af9e04758014404799627a3a4f925", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n var (\n@@ -141,7 +142,7 @@ func (tr *Reader) readHeader() *Header {\n \thdr.Uid = int(tr.octal(s.next(8)))\n \thdr.Gid = int(tr.octal(s.next(8)))\n \thdr.Size = tr.octal(s.next(12))\n-\thdr.Mtime = tr.octal(s.next(12))\n+\thdr.ModTime = time.Unix(tr.octal(s.next(12)), 0)\n \ts.next(8) // chksum\n \thdr.Typeflag = s.next(1)[0]\n \thdr.Linkname = cString(s.next(100))\n@@ -178,8 +179,8 @@ func (tr *Reader) readHeader() *Header {\n \t\t\tprefix = cString(s.next(155))\n \t\tcase \"star\":\n \t\t\tprefix = cString(s.next(131))\n-\t\t\thdr.Atime = tr.octal(s.next(12))\n-\t\t\thdr.Ctime = tr.octal(s.next(12))\n+\t\t\thdr.AccessTime = time.Unix(tr.octal(s.next(12)), 0)\n+\t\t\thdr.ChangeTime = time.Unix(tr.octal(s.next(12)), 0)\n \t\t}\n \t\tif len(prefix) > 0 {\n \t\t\thdr.Name = prefix + \"/\" + hdr.Name"}, {"sha": "5ca4212ae7b1361dc5477c4236aa96c14baf44bb", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"os\"\n \t\"reflect\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type untarTest struct {\n@@ -29,7 +30,7 @@ var gnuTarTest = &untarTest{\n \t\t\tUid:      73025,\n \t\t\tGid:      5000,\n \t\t\tSize:     5,\n-\t\t\tMtime:    1244428340,\n+\t\t\tModTime:  time.Unix(1244428340, 0),\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n@@ -40,7 +41,7 @@ var gnuTarTest = &untarTest{\n \t\t\tUid:      73025,\n \t\t\tGid:      5000,\n \t\t\tSize:     11,\n-\t\t\tMtime:    1244436044,\n+\t\t\tModTime:  time.Unix(1244436044, 0),\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n@@ -58,30 +59,30 @@ var untarTests = []*untarTest{\n \t\tfile: \"testdata/star.tar\",\n \t\theaders: []*Header{\n \t\t\t&Header{\n-\t\t\t\tName:     \"small.txt\",\n-\t\t\t\tMode:     0640,\n-\t\t\t\tUid:      73025,\n-\t\t\t\tGid:      5000,\n-\t\t\t\tSize:     5,\n-\t\t\t\tMtime:    1244592783,\n-\t\t\t\tTypeflag: '0',\n-\t\t\t\tUname:    \"dsymonds\",\n-\t\t\t\tGname:    \"eng\",\n-\t\t\t\tAtime:    1244592783,\n-\t\t\t\tCtime:    1244592783,\n+\t\t\t\tName:       \"small.txt\",\n+\t\t\t\tMode:       0640,\n+\t\t\t\tUid:        73025,\n+\t\t\t\tGid:        5000,\n+\t\t\t\tSize:       5,\n+\t\t\t\tModTime:    time.Unix(1244592783, 0),\n+\t\t\t\tTypeflag:   '0',\n+\t\t\t\tUname:      \"dsymonds\",\n+\t\t\t\tGname:      \"eng\",\n+\t\t\t\tAccessTime: time.Unix(1244592783, 0),\n+\t\t\t\tChangeTime: time.Unix(1244592783, 0),\n \t\t\t},\n \t\t\t&Header{\n-\t\t\t\tName:     \"small2.txt\",\n-\t\t\t\tMode:     0640,\n-\t\t\t\tUid:      73025,\n-\t\t\t\tGid:      5000,\n-\t\t\t\tSize:     11,\n-\t\t\t\tMtime:    1244592783,\n-\t\t\t\tTypeflag: '0',\n-\t\t\t\tUname:    \"dsymonds\",\n-\t\t\t\tGname:    \"eng\",\n-\t\t\t\tAtime:    1244592783,\n-\t\t\t\tCtime:    1244592783,\n+\t\t\t\tName:       \"small2.txt\",\n+\t\t\t\tMode:       0640,\n+\t\t\t\tUid:        73025,\n+\t\t\t\tGid:        5000,\n+\t\t\t\tSize:       11,\n+\t\t\t\tModTime:    time.Unix(1244592783, 0),\n+\t\t\t\tTypeflag:   '0',\n+\t\t\t\tUname:      \"dsymonds\",\n+\t\t\t\tGname:      \"eng\",\n+\t\t\t\tAccessTime: time.Unix(1244592783, 0),\n+\t\t\t\tChangeTime: time.Unix(1244592783, 0),\n \t\t\t},\n \t\t},\n \t},\n@@ -94,7 +95,7 @@ var untarTests = []*untarTest{\n \t\t\t\tUid:      73025,\n \t\t\t\tGid:      5000,\n \t\t\t\tSize:     5,\n-\t\t\t\tMtime:    1244593104,\n+\t\t\t\tModTime:  time.Unix(1244593104, 0),\n \t\t\t\tTypeflag: '\\x00',\n \t\t\t},\n \t\t\t&Header{\n@@ -103,7 +104,7 @@ var untarTests = []*untarTest{\n \t\t\t\tUid:      73025,\n \t\t\t\tGid:      5000,\n \t\t\t\tSize:     11,\n-\t\t\t\tMtime:    1244593104,\n+\t\t\t\tModTime:  time.Unix(1244593104, 0),\n \t\t\t\tTypeflag: '\\x00',\n \t\t\t},\n \t\t},\n@@ -221,7 +222,7 @@ func TestIncrementalRead(t *testing.T) {\n \t\t\th.Write(rdbuf[0:nr])\n \t\t}\n \t\t// verify checksum\n-\t\thave := fmt.Sprintf(\"%x\", h.Sum())\n+\t\thave := fmt.Sprintf(\"%x\", h.Sum(nil))\n \t\twant := cksums[nread]\n \t\tif want != have {\n \t\t\tt.Errorf(\"Bad checksum on file %s:\\nhave %+v\\nwant %+v\", hdr.Name, have, want)"}, {"sha": "b9310b3f189dc080833d367727a96de97ecfdfe0", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -127,19 +127,19 @@ func (tw *Writer) WriteHeader(hdr *Header) error {\n \t// TODO(dsymonds): handle names longer than 100 chars\n \tcopy(s.next(100), []byte(hdr.Name))\n \n-\ttw.octal(s.next(8), hdr.Mode)          // 100:108\n-\ttw.numeric(s.next(8), int64(hdr.Uid))  // 108:116\n-\ttw.numeric(s.next(8), int64(hdr.Gid))  // 116:124\n-\ttw.numeric(s.next(12), hdr.Size)       // 124:136\n-\ttw.numeric(s.next(12), hdr.Mtime)      // 136:148\n-\ts.next(8)                              // chksum (148:156)\n-\ts.next(1)[0] = hdr.Typeflag            // 156:157\n-\ttw.cString(s.next(100), hdr.Linkname)  // linkname (157:257)\n-\tcopy(s.next(8), []byte(\"ustar\\x0000\")) // 257:265\n-\ttw.cString(s.next(32), hdr.Uname)      // 265:297\n-\ttw.cString(s.next(32), hdr.Gname)      // 297:329\n-\ttw.numeric(s.next(8), hdr.Devmajor)    // 329:337\n-\ttw.numeric(s.next(8), hdr.Devminor)    // 337:345\n+\ttw.octal(s.next(8), hdr.Mode)              // 100:108\n+\ttw.numeric(s.next(8), int64(hdr.Uid))      // 108:116\n+\ttw.numeric(s.next(8), int64(hdr.Gid))      // 116:124\n+\ttw.numeric(s.next(12), hdr.Size)           // 124:136\n+\ttw.numeric(s.next(12), hdr.ModTime.Unix()) // 136:148\n+\ts.next(8)                                  // chksum (148:156)\n+\ts.next(1)[0] = hdr.Typeflag                // 156:157\n+\ttw.cString(s.next(100), hdr.Linkname)      // linkname (157:257)\n+\tcopy(s.next(8), []byte(\"ustar\\x0000\"))     // 257:265\n+\ttw.cString(s.next(32), hdr.Uname)          // 265:297\n+\ttw.cString(s.next(32), hdr.Gname)          // 297:329\n+\ttw.numeric(s.next(8), hdr.Devmajor)        // 329:337\n+\ttw.numeric(s.next(8), hdr.Devminor)        // 337:345\n \n \t// Use the GNU magic instead of POSIX magic if we used any GNU extensions.\n \tif tw.usedBinary {"}, {"sha": "8d7ed32d32e4e2862759411fffe4e4c9bd7c528b", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"io/ioutil\"\n \t\"testing\"\n \t\"testing/iotest\"\n+\t\"time\"\n )\n \n type writerTestEntry struct {\n@@ -38,7 +39,7 @@ var writerTests = []*writerTest{\n \t\t\t\t\tUid:      73025,\n \t\t\t\t\tGid:      5000,\n \t\t\t\t\tSize:     5,\n-\t\t\t\t\tMtime:    1246508266,\n+\t\t\t\t\tModTime:  time.Unix(1246508266, 0),\n \t\t\t\t\tTypeflag: '0',\n \t\t\t\t\tUname:    \"dsymonds\",\n \t\t\t\t\tGname:    \"eng\",\n@@ -52,7 +53,7 @@ var writerTests = []*writerTest{\n \t\t\t\t\tUid:      73025,\n \t\t\t\t\tGid:      5000,\n \t\t\t\t\tSize:     11,\n-\t\t\t\t\tMtime:    1245217492,\n+\t\t\t\t\tModTime:  time.Unix(1245217492, 0),\n \t\t\t\t\tTypeflag: '0',\n \t\t\t\t\tUname:    \"dsymonds\",\n \t\t\t\t\tGname:    \"eng\",\n@@ -66,7 +67,7 @@ var writerTests = []*writerTest{\n \t\t\t\t\tUid:      1000,\n \t\t\t\t\tGid:      1000,\n \t\t\t\t\tSize:     0,\n-\t\t\t\t\tMtime:    1314603082,\n+\t\t\t\t\tModTime:  time.Unix(1314603082, 0),\n \t\t\t\t\tTypeflag: '2',\n \t\t\t\t\tLinkname: \"small.txt\",\n \t\t\t\t\tUname:    \"strings\",\n@@ -89,7 +90,7 @@ var writerTests = []*writerTest{\n \t\t\t\t\tUid:      73025,\n \t\t\t\t\tGid:      5000,\n \t\t\t\t\tSize:     16 << 30,\n-\t\t\t\t\tMtime:    1254699560,\n+\t\t\t\t\tModTime:  time.Unix(1254699560, 0),\n \t\t\t\t\tTypeflag: '0',\n \t\t\t\t\tUname:    \"dsymonds\",\n \t\t\t\t\tGname:    \"eng\","}, {"sha": "4365009a308f386a843c3eb1f6fddcdad9f1aa0f", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -56,7 +56,7 @@ func OpenReader(name string) (*ReadCloser, error) {\n \t\treturn nil, err\n \t}\n \tr := new(ReadCloser)\n-\tif err := r.init(f, fi.Size); err != nil {\n+\tif err := r.init(f, fi.Size()); err != nil {\n \t\tf.Close()\n \t\treturn nil, err\n \t}"}, {"sha": "8c0ecaa4386c1af86c16913e1082984f6875e947", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -164,8 +164,8 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t\tt.Error(err)\n \t\treturn\n \t}\n-\tif got, want := f.Mtime_ns()/1e9, mtime.Seconds(); got != want {\n-\t\tt.Errorf(\"%s: mtime=%s (%d); want %s (%d)\", f.Name, time.SecondsToUTC(got), got, mtime, want)\n+\tif ft := f.ModTime(); !ft.Equal(mtime) {\n+\t\tt.Errorf(\"%s: mtime=%s, want %s\", f.Name, ft, mtime)\n \t}\n \n \ttestFileMode(t, f, ft.Mode)"}, {"sha": "43c04bb27b2c4b3bee60d3de3815f62e209b5109", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -11,8 +11,10 @@ This package does not support ZIP64 or disk spanning.\n */\n package zip\n \n-import \"errors\"\n-import \"time\"\n+import (\n+\t\"errors\"\n+\t\"time\"\n+)\n \n // Compression methods.\n const (\n@@ -74,24 +76,26 @@ func recoverError(errp *error) {\n // The resolution is 2s.\n // See: http://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx\n func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n-\treturn time.Time{\n+\treturn time.Date(\n \t\t// date bits 0-4: day of month; 5-8: month; 9-15: years since 1980\n-\t\tYear:  int64(dosDate>>9 + 1980),\n-\t\tMonth: int(dosDate >> 5 & 0xf),\n-\t\tDay:   int(dosDate & 0x1f),\n+\t\tint(dosDate>>9+1980),\n+\t\ttime.Month(dosDate>>5&0xf),\n+\t\tint(dosDate&0x1f),\n \n \t\t// time bits 0-4: second/2; 5-10: minute; 11-15: hour\n-\t\tHour:   int(dosTime >> 11),\n-\t\tMinute: int(dosTime >> 5 & 0x3f),\n-\t\tSecond: int(dosTime & 0x1f * 2),\n-\t}\n+\t\tint(dosTime>>11),\n+\t\tint(dosTime>>5&0x3f),\n+\t\tint(dosTime&0x1f*2),\n+\t\t0, // nanoseconds\n+\n+\t\ttime.UTC,\n+\t)\n }\n \n-// Mtime_ns returns the modified time in ns since epoch.\n+// ModTime returns the modification time.\n // The resolution is 2s.\n-func (h *FileHeader) Mtime_ns() int64 {\n-\tt := msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n-\treturn t.Seconds() * 1e9\n+func (h *FileHeader) ModTime() time.Time {\n+\treturn msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n }\n \n // Mode returns the permission and mode bits for the FileHeader."}, {"sha": "829ef05319c41a0555b2b8cf9eec068a8412f368", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -702,7 +702,7 @@ func TestTrim(t *testing.T) {\n \t\tcase \"TrimRight\":\n \t\t\tf = TrimRight\n \t\tdefault:\n-\t\t\tt.Error(\"Undefined trim function %s\", name)\n+\t\t\tt.Errorf(\"Undefined trim function %s\", name)\n \t\t}\n \t\tactual := string(f([]byte(tc.in), tc.cutset))\n \t\tif actual != tc.out {"}, {"sha": "7c78b9e366d637dea2129c2f652c7a8c65307dc7", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n+\t\"time\"\n )\n \n // BUG(nigeltao): Comments and Names don't properly map UTF-8 character codes outside of\n@@ -42,11 +43,11 @@ var ChecksumError = errors.New(\"gzip checksum error\")\n // The gzip file stores a header giving metadata about the compressed file.\n // That header is exposed as the fields of the Compressor and Decompressor structs.\n type Header struct {\n-\tComment string // comment\n-\tExtra   []byte // \"extra data\"\n-\tMtime   uint32 // modification time (seconds since January 1, 1970)\n-\tName    string // file name\n-\tOS      byte   // operating system type\n+\tComment string    // comment\n+\tExtra   []byte    // \"extra data\"\n+\tModTime time.Time // modification time\n+\tName    string    // file name\n+\tOS      byte      // operating system type\n }\n \n // An Decompressor is an io.Reader that can be read to retrieve\n@@ -130,7 +131,7 @@ func (z *Decompressor) readHeader(save bool) error {\n \t}\n \tz.flg = z.buf[3]\n \tif save {\n-\t\tz.Mtime = get4(z.buf[4:8])\n+\t\tz.ModTime = time.Unix(int64(get4(z.buf[4:8])), 0)\n \t\t// z.buf[8] is xfl, ignored\n \t\tz.OS = z.buf[9]\n \t}"}, {"sha": "07b91b66823b31b707b1d5c98511dbfe2710be97", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -122,7 +122,7 @@ func (z *Compressor) Write(p []byte) (int, error) {\n \t\tif z.Comment != \"\" {\n \t\t\tz.buf[3] |= 0x10\n \t\t}\n-\t\tput4(z.buf[4:8], z.Mtime)\n+\t\tput4(z.buf[4:8], uint32(z.ModTime.Unix()))\n \t\tif z.level == BestCompression {\n \t\t\tz.buf[8] = 2\n \t\t} else if z.level == BestSpeed {"}, {"sha": "815825be99940e0466ac662a59315de1a91c25ea", "filename": "libgo/go/compress/gzip/gzip_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // pipe creates two ends of a pipe that gzip and gunzip, and runs dfunc at the\n@@ -53,7 +54,7 @@ func TestWriter(t *testing.T) {\n \t\tfunc(compressor *Compressor) {\n \t\t\tcompressor.Comment = \"comment\"\n \t\t\tcompressor.Extra = []byte(\"extra\")\n-\t\t\tcompressor.Mtime = 1e8\n+\t\t\tcompressor.ModTime = time.Unix(1e8, 0)\n \t\t\tcompressor.Name = \"name\"\n \t\t\t_, err := compressor.Write([]byte(\"payload\"))\n \t\t\tif err != nil {\n@@ -74,8 +75,8 @@ func TestWriter(t *testing.T) {\n \t\t\tif string(decompressor.Extra) != \"extra\" {\n \t\t\t\tt.Fatalf(\"extra is %q, want %q\", decompressor.Extra, \"extra\")\n \t\t\t}\n-\t\t\tif decompressor.Mtime != 1e8 {\n-\t\t\t\tt.Fatalf(\"mtime is %d, want %d\", decompressor.Mtime, uint32(1e8))\n+\t\t\tif decompressor.ModTime.Unix() != 1e8 {\n+\t\t\t\tt.Fatalf(\"mtime is %d, want %d\", decompressor.ModTime.Unix(), uint32(1e8))\n \t\t\t}\n \t\t\tif decompressor.Name != \"name\" {\n \t\t\t\tt.Fatalf(\"name is %q, want %q\", decompressor.Name, \"name\")"}, {"sha": "362b2eb53cb23a1cee45e671a0e744549cb25d75", "filename": "libgo/go/crypto/bcrypt/bcrypt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package bcrypt implements Provos and Mazi\u00e8res's bcrypt adapative hashing\n+// Package bcrypt implements Provos and Mazi\u00e8res's bcrypt adaptive hashing\n // algorithm. See http://www.usenix.org/event/usenix99/provos/provos.pdf\n package bcrypt\n "}, {"sha": "45433e102033cd8c4f97781afb6cc6eb673b762f", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -214,7 +214,7 @@ func TestVectors(t *testing.T) {\n \t\tmsg, _ := hex.DecodeString(test.msg)\n \t\tsha.Reset()\n \t\tsha.Write(msg)\n-\t\thashed := sha.Sum()\n+\t\thashed := sha.Sum(nil)\n \t\tr := fromHex(test.r)\n \t\ts := fromHex(test.s)\n \t\tif Verify(&pub, hashed, r, s) != test.ok {"}, {"sha": "deaceafb260a39f4caf04a220dd551d64582cba7", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -48,15 +48,15 @@ func (h *hmac) tmpPad(xor byte) {\n \t}\n }\n \n-func (h *hmac) Sum() []byte {\n-\tsum := h.inner.Sum()\n+func (h *hmac) Sum(in []byte) []byte {\n+\tsum := h.inner.Sum(nil)\n \th.tmpPad(0x5c)\n \tfor i, b := range sum {\n \t\th.tmp[padSize+i] = b\n \t}\n \th.outer.Reset()\n \th.outer.Write(h.tmp)\n-\treturn h.outer.Sum()\n+\treturn h.outer.Sum(in)\n }\n \n func (h *hmac) Write(p []byte) (n int, err error) {\n@@ -81,7 +81,7 @@ func New(h func() hash.Hash, key []byte) hash.Hash {\n \tif len(key) > padSize {\n \t\t// If key is too big, hash it.\n \t\thm.outer.Write(key)\n-\t\tkey = hm.outer.Sum()\n+\t\tkey = hm.outer.Sum(nil)\n \t}\n \thm.key = make([]byte, len(key))\n \tcopy(hm.key, key)"}, {"sha": "eac254b9d1910737d2dd84623bc52245d9c58669", "filename": "libgo/go/crypto/hmac/hmac_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -192,7 +192,7 @@ func TestHMAC(t *testing.T) {\n \n \t\t\t// Repetitive Sum() calls should return the same value\n \t\t\tfor k := 0; k < 2; k++ {\n-\t\t\t\tsum := fmt.Sprintf(\"%x\", h.Sum())\n+\t\t\t\tsum := fmt.Sprintf(\"%x\", h.Sum(nil))\n \t\t\t\tif sum != tt.out {\n \t\t\t\t\tt.Errorf(\"test %d.%d.%d: have %s want %s\\n\", i, j, k, sum, tt.out)\n \t\t\t\t}"}, {"sha": "e51e8bee50cff4eb2082e1ddcf235f3a08ab9938", "filename": "libgo/go/crypto/md4/md4.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -77,7 +77,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0, so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -103,14 +103,11 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 16)\n-\tj := 0\n \tfor _, s := range d.s {\n-\t\tp[j+0] = byte(s >> 0)\n-\t\tp[j+1] = byte(s >> 8)\n-\t\tp[j+2] = byte(s >> 16)\n-\t\tp[j+3] = byte(s >> 24)\n-\t\tj += 4\n+\t\tin = append(in, byte(s>>0))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>24))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "b56edd7875d8b6655cc07ccec0f65d8171d74680", "filename": "libgo/go/crypto/md4/md4_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -58,10 +58,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"md4[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "182cfb8537077383e6bdbc200032ad6262870b28", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -77,7 +77,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -103,14 +103,11 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 16)\n-\tj := 0\n \tfor _, s := range d.s {\n-\t\tp[j+0] = byte(s >> 0)\n-\t\tp[j+1] = byte(s >> 8)\n-\t\tp[j+2] = byte(s >> 16)\n-\t\tp[j+3] = byte(s >> 24)\n-\t\tj += 4\n+\t\tin = append(in, byte(s>>0))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>24))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "b15e4668c3219eb0e8ded352956afb2a71675cf3", "filename": "libgo/go/crypto/md5/md5_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -58,10 +58,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"md5[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "b9dfdf94e319a9567610c8c3868203d83e19bbf5", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -61,7 +61,7 @@ type responseData struct {\n \tVersion       int              `asn1:\"optional,default:1,explicit,tag:0\"`\n \tRequestorName pkix.RDNSequence `asn1:\"optional,explicit,tag:1\"`\n \tKeyHash       []byte           `asn1:\"optional,explicit,tag:2\"`\n-\tProducedAt    *time.Time\n+\tProducedAt    time.Time\n \tResponses     []singleResponse\n }\n \n@@ -70,12 +70,12 @@ type singleResponse struct {\n \tGood       asn1.Flag   `asn1:\"explicit,tag:0,optional\"`\n \tRevoked    revokedInfo `asn1:\"explicit,tag:1,optional\"`\n \tUnknown    asn1.Flag   `asn1:\"explicit,tag:2,optional\"`\n-\tThisUpdate *time.Time\n-\tNextUpdate *time.Time `asn1:\"explicit,tag:0,optional\"`\n+\tThisUpdate time.Time\n+\tNextUpdate time.Time `asn1:\"explicit,tag:0,optional\"`\n }\n \n type revokedInfo struct {\n-\tRevocationTime *time.Time\n+\tRevocationTime time.Time\n \tReason         int `asn1:\"explicit,tag:0,optional\"`\n }\n \n@@ -97,7 +97,7 @@ type Response struct {\n \t// Status is one of {Good, Revoked, Unknown, ServerFailed}\n \tStatus                                        int\n \tSerialNumber                                  []byte\n-\tProducedAt, ThisUpdate, NextUpdate, RevokedAt *time.Time\n+\tProducedAt, ThisUpdate, NextUpdate, RevokedAt time.Time\n \tRevocationReason                              int\n \tCertificate                                   *x509.Certificate\n }\n@@ -161,7 +161,7 @@ func ParseResponse(bytes []byte) (*Response, error) {\n \n \tpub := ret.Certificate.PublicKey.(*rsa.PublicKey)\n \th.Write(basicResp.TBSResponseData.Raw)\n-\tdigest := h.Sum()\n+\tdigest := h.Sum(nil)\n \tsignature := basicResp.Signature.RightAlign()\n \n \tif rsa.VerifyPKCS1v15(pub, hashType, digest, signature) != nil {"}, {"sha": "bacca558b48772addcec41e96b65cc783d0f3b08", "filename": "libgo/go/crypto/ocsp/ocsp_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,7 +15,13 @@ func TestOCSPDecode(t *testing.T) {\n \t\tt.Error(err)\n \t}\n \n-\texpected := Response{Status: 0, SerialNumber: []byte{0x1, 0xd0, 0xfa}, RevocationReason: 0, ThisUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 15, Minute: 1, Second: 5, ZoneOffset: 0, Zone: \"UTC\"}, NextUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 18, Minute: 35, Second: 17, ZoneOffset: 0, Zone: \"UTC\"}}\n+\texpected := Response{\n+\t\tStatus:           0,\n+\t\tSerialNumber:     []byte{0x1, 0xd0, 0xfa},\n+\t\tRevocationReason: 0,\n+\t\tThisUpdate:       time.Date(2010, 7, 7, 15, 1, 5, 0, time.UTC),\n+\t\tNextUpdate:       time.Date(2010, 7, 7, 18, 35, 17, 0, time.UTC),\n+\t}\n \n \tif !reflect.DeepEqual(resp.ThisUpdate, resp.ThisUpdate) {\n \t\tt.Errorf(\"resp.ThisUpdate: got %d, want %d\", resp.ThisUpdate, expected.ThisUpdate)"}, {"sha": "98cee5e75ae0950ad2702fb78eb24098981d42f0", "filename": "libgo/go/crypto/openpgp/canonical_text.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -41,8 +41,8 @@ func (cth *canonicalTextHash) Write(buf []byte) (int, error) {\n \treturn len(buf), nil\n }\n \n-func (cth *canonicalTextHash) Sum() []byte {\n-\treturn cth.h.Sum()\n+func (cth *canonicalTextHash) Sum(in []byte) []byte {\n+\treturn cth.h.Sum(in)\n }\n \n func (cth *canonicalTextHash) Reset() {"}, {"sha": "841475f80c0145c44f1a25301e439962587822f8", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -17,8 +17,8 @@ func (r recordingHash) Write(b []byte) (n int, err error) {\n \treturn r.buf.Write(b)\n }\n \n-func (r recordingHash) Sum() []byte {\n-\treturn r.buf.Bytes()\n+func (r recordingHash) Sum(in []byte) []byte {\n+\treturn append(in, r.buf.Bytes()...)\n }\n \n func (r recordingHash) Reset() {\n@@ -33,7 +33,7 @@ func testCanonicalText(t *testing.T, input, expected string) {\n \tr := recordingHash{bytes.NewBuffer(nil)}\n \tc := NewCanonicalTextHash(r)\n \tc.Write([]byte(input))\n-\tresult := c.Sum()\n+\tresult := c.Sum(nil)\n \tif expected != string(result) {\n \t\tt.Errorf(\"input: %x got: %x want: %x\", input, result, expected)\n \t}"}, {"sha": "df39970c0b672d176253b22dad1cbfb1c93adb97", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -381,7 +381,7 @@ const defaultRSAKeyBits = 2048\n // NewEntity returns an Entity that contains a fresh RSA/RSA keypair with a\n // single identity composed of the given full name, comment and email, any of\n // which may be empty but must not contain any of \"()<>\\x00\".\n-func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email string) (*Entity, error) {\n+func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email string) (*Entity, error) {\n \tuid := packet.NewUserId(name, comment, email)\n \tif uid == nil {\n \t\treturn nil, error_.InvalidArgumentError(\"user id field contained invalid characters\")\n@@ -395,19 +395,17 @@ func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email strin\n \t\treturn nil, err\n \t}\n \n-\tt := uint32(currentTimeSecs)\n-\n \te := &Entity{\n-\t\tPrimaryKey: packet.NewRSAPublicKey(t, &signingPriv.PublicKey, false /* not a subkey */ ),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(t, signingPriv, false /* not a subkey */ ),\n+\t\tPrimaryKey: packet.NewRSAPublicKey(currentTime, &signingPriv.PublicKey, false /* not a subkey */ ),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, signingPriv, false /* not a subkey */ ),\n \t\tIdentities: make(map[string]*Identity),\n \t}\n \tisPrimaryId := true\n \te.Identities[uid.Id] = &Identity{\n \t\tName:   uid.Name,\n \t\tUserId: uid,\n \t\tSelfSignature: &packet.Signature{\n-\t\t\tCreationTime: t,\n+\t\t\tCreationTime: currentTime,\n \t\t\tSigType:      packet.SigTypePositiveCert,\n \t\t\tPubKeyAlgo:   packet.PubKeyAlgoRSA,\n \t\t\tHash:         crypto.SHA256,\n@@ -421,10 +419,10 @@ func NewEntity(rand io.Reader, currentTimeSecs int64, name, comment, email strin\n \n \te.Subkeys = make([]Subkey, 1)\n \te.Subkeys[0] = Subkey{\n-\t\tPublicKey:  packet.NewRSAPublicKey(t, &encryptingPriv.PublicKey, true /* is a subkey */ ),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(t, encryptingPriv, true /* is a subkey */ ),\n+\t\tPublicKey:  packet.NewRSAPublicKey(currentTime, &encryptingPriv.PublicKey, true /* is a subkey */ ),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, encryptingPriv, true /* is a subkey */ ),\n \t\tSig: &packet.Signature{\n-\t\t\tCreationTime:              t,\n+\t\t\tCreationTime:              currentTime,\n \t\t\tSigType:                   packet.SigTypeSubkeyBinding,\n \t\t\tPubKeyAlgo:                packet.PubKeyAlgoRSA,\n \t\t\tHash:                      crypto.SHA256,\n@@ -533,7 +531,7 @@ func (e *Entity) SignIdentity(identity string, signer *Entity) error {\n \t\tSigType:      packet.SigTypeGenericCert,\n \t\tPubKeyAlgo:   signer.PrivateKey.PubKeyAlgo,\n \t\tHash:         crypto.SHA256,\n-\t\tCreationTime: uint32(time.Seconds()),\n+\t\tCreationTime: time.Now(),\n \t\tIssuerKeyId:  &signer.PrivateKey.KeyId,\n \t}\n \tif err := sig.SignKey(e.PrimaryKey, signer.PrivateKey); err != nil {"}, {"sha": "d67e968861758a183fa60784b05ff4cb2a18f87e", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"io/ioutil\"\n \t\"math/big\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // PrivateKey represents a possibly encrypted private key. See RFC 4880,\n@@ -32,9 +33,9 @@ type PrivateKey struct {\n \tiv            []byte\n }\n \n-func NewRSAPrivateKey(currentTimeSecs uint32, priv *rsa.PrivateKey, isSubkey bool) *PrivateKey {\n+func NewRSAPrivateKey(currentTime time.Time, priv *rsa.PrivateKey, isSubkey bool) *PrivateKey {\n \tpk := new(PrivateKey)\n-\tpk.PublicKey = *NewRSAPublicKey(currentTimeSecs, &priv.PublicKey, isSubkey)\n+\tpk.PublicKey = *NewRSAPublicKey(currentTime, &priv.PublicKey, isSubkey)\n \tpk.PrivateKey = priv\n \treturn pk\n }\n@@ -99,13 +100,9 @@ func (pk *PrivateKey) parse(r io.Reader) (err error) {\n }\n \n func mod64kHash(d []byte) uint16 {\n-\th := uint16(0)\n-\tfor i := 0; i < len(d); i += 2 {\n-\t\tv := uint16(d[i]) << 8\n-\t\tif i+1 < len(d) {\n-\t\t\tv += uint16(d[i+1])\n-\t\t}\n-\t\th += v\n+\tvar h uint16\n+\tfor _, b := range d {\n+\t\th += uint16(b)\n \t}\n \treturn h\n }\n@@ -195,7 +192,7 @@ func (pk *PrivateKey) Decrypt(passphrase []byte) error {\n \t\t}\n \t\th := sha1.New()\n \t\th.Write(data[:len(data)-sha1.Size])\n-\t\tsum := h.Sum()\n+\t\tsum := h.Sum(nil)\n \t\tif !bytes.Equal(sum, data[len(data)-sha1.Size:]) {\n \t\t\treturn error_.StructuralError(\"private key checksum failure\")\n \t\t}"}, {"sha": "35d8951a86b05077a3b186796e25e0f74956e686", "filename": "libgo/go/crypto/openpgp/packet/private_key_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,19 +6,20 @@ package packet\n \n import (\n \t\"testing\"\n+\t\"time\"\n )\n \n var privateKeyTests = []struct {\n \tprivateKeyHex string\n-\tcreationTime  uint32\n+\tcreationTime  time.Time\n }{\n \t{\n \t\tprivKeyRSAHex,\n-\t\t0x4cc349a8,\n+\t\ttime.Unix(0x4cc349a8, 0),\n \t},\n \t{\n \t\tprivKeyElGamalHex,\n-\t\t0x4df9ee1a,\n+\t\ttime.Unix(0x4df9ee1a, 0),\n \t},\n }\n \n@@ -43,7 +44,7 @@ func TestPrivateKeyRead(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tif privKey.CreationTime != test.creationTime || privKey.Encrypted {\n+\t\tif !privKey.CreationTime.Equal(test.creationTime) || privKey.Encrypted {\n \t\t\tt.Errorf(\"#%d: bad result, got: %#v\", i, privKey)\n \t\t}\n \t}"}, {"sha": "9aa30e0c15f0c85ce67ca9e8bba6c30a2ae7ba8c", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -16,11 +16,12 @@ import (\n \t\"io\"\n \t\"math/big\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // PublicKey represents an OpenPGP public key. See RFC 4880, section 5.5.2.\n type PublicKey struct {\n-\tCreationTime uint32 // seconds since the epoch\n+\tCreationTime time.Time\n \tPubKeyAlgo   PublicKeyAlgorithm\n \tPublicKey    interface{} // Either a *rsa.PublicKey or *dsa.PublicKey\n \tFingerprint  [20]byte\n@@ -38,9 +39,9 @@ func fromBig(n *big.Int) parsedMPI {\n }\n \n // NewRSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n-func NewRSAPublicKey(creationTimeSecs uint32, pub *rsa.PublicKey, isSubkey bool) *PublicKey {\n+func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey, isSubkey bool) *PublicKey {\n \tpk := &PublicKey{\n-\t\tCreationTime: creationTimeSecs,\n+\t\tCreationTime: creationTime,\n \t\tPubKeyAlgo:   PubKeyAlgoRSA,\n \t\tPublicKey:    pub,\n \t\tIsSubkey:     isSubkey,\n@@ -62,7 +63,7 @@ func (pk *PublicKey) parse(r io.Reader) (err error) {\n \tif buf[0] != 4 {\n \t\treturn error_.UnsupportedError(\"public key version\")\n \t}\n-\tpk.CreationTime = uint32(buf[1])<<24 | uint32(buf[2])<<16 | uint32(buf[3])<<8 | uint32(buf[4])\n+\tpk.CreationTime = time.Unix(int64(uint32(buf[1])<<24|uint32(buf[2])<<16|uint32(buf[3])<<8|uint32(buf[4])), 0)\n \tpk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])\n \tswitch pk.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n@@ -87,7 +88,7 @@ func (pk *PublicKey) setFingerPrintAndKeyId() {\n \tfingerPrint := sha1.New()\n \tpk.SerializeSignaturePrefix(fingerPrint)\n \tpk.serializeWithoutHeaders(fingerPrint)\n-\tcopy(pk.Fingerprint[:], fingerPrint.Sum())\n+\tcopy(pk.Fingerprint[:], fingerPrint.Sum(nil))\n \tpk.KeyId = binary.BigEndian.Uint64(pk.Fingerprint[12:20])\n }\n \n@@ -234,10 +235,11 @@ func (pk *PublicKey) Serialize(w io.Writer) (err error) {\n func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err error) {\n \tvar buf [6]byte\n \tbuf[0] = 4\n-\tbuf[1] = byte(pk.CreationTime >> 24)\n-\tbuf[2] = byte(pk.CreationTime >> 16)\n-\tbuf[3] = byte(pk.CreationTime >> 8)\n-\tbuf[4] = byte(pk.CreationTime)\n+\tt := uint32(pk.CreationTime.Unix())\n+\tbuf[1] = byte(t >> 24)\n+\tbuf[2] = byte(t >> 16)\n+\tbuf[3] = byte(t >> 8)\n+\tbuf[4] = byte(t)\n \tbuf[5] = byte(pk.PubKeyAlgo)\n \n \t_, err = w.Write(buf[:])\n@@ -269,7 +271,7 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err erro\n \t}\n \n \tsigned.Write(sig.HashSuffix)\n-\thashBytes := signed.Sum()\n+\thashBytes := signed.Sum(nil)\n \n \tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n \t\treturn error_.SignatureError(\"hash tag doesn't match\")"}, {"sha": "72f459f47bf028019844beb764ff4467cd6727f2", "filename": "libgo/go/crypto/openpgp/packet/public_key_test.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,19 +8,20 @@ import (\n \t\"bytes\"\n \t\"encoding/hex\"\n \t\"testing\"\n+\t\"time\"\n )\n \n var pubKeyTests = []struct {\n \thexData        string\n \thexFingerprint string\n-\tcreationTime   uint32\n+\tcreationTime   time.Time\n \tpubKeyAlgo     PublicKeyAlgorithm\n \tkeyId          uint64\n \tkeyIdString    string\n \tkeyIdShort     string\n }{\n-\t{rsaPkDataHex, rsaFingerprintHex, 0x4d3c5c10, PubKeyAlgoRSA, 0xa34d7e18c20c31bb, \"A34D7E18C20C31BB\", \"C20C31BB\"},\n-\t{dsaPkDataHex, dsaFingerprintHex, 0x4d432f89, PubKeyAlgoDSA, 0x8e8fbe54062f19ed, \"8E8FBE54062F19ED\", \"062F19ED\"},\n+\t{rsaPkDataHex, rsaFingerprintHex, time.Unix(0x4d3c5c10, 0), PubKeyAlgoRSA, 0xa34d7e18c20c31bb, \"A34D7E18C20C31BB\", \"C20C31BB\"},\n+\t{dsaPkDataHex, dsaFingerprintHex, time.Unix(0x4d432f89, 0), PubKeyAlgoDSA, 0x8e8fbe54062f19ed, \"8E8FBE54062F19ED\", \"062F19ED\"},\n }\n \n func TestPublicKeyRead(t *testing.T) {\n@@ -38,8 +39,8 @@ func TestPublicKeyRead(t *testing.T) {\n \t\tif pk.PubKeyAlgo != test.pubKeyAlgo {\n \t\t\tt.Errorf(\"#%d: bad public key algorithm got:%x want:%x\", i, pk.PubKeyAlgo, test.pubKeyAlgo)\n \t\t}\n-\t\tif pk.CreationTime != test.creationTime {\n-\t\t\tt.Errorf(\"#%d: bad creation time got:%x want:%x\", i, pk.CreationTime, test.creationTime)\n+\t\tif !pk.CreationTime.Equal(test.creationTime) {\n+\t\t\tt.Errorf(\"#%d: bad creation time got:%v want:%v\", i, pk.CreationTime, test.creationTime)\n \t\t}\n \t\texpectedFingerprint, _ := hex.DecodeString(test.hexFingerprint)\n \t\tif !bytes.Equal(expectedFingerprint, pk.Fingerprint[:]) {"}, {"sha": "1cdc1ee0f0c798e9dc62dc3dfec5e94b3669071e", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"hash\"\n \t\"io\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // Signature represents a signature. See RFC 4880, section 5.2.\n@@ -28,7 +29,7 @@ type Signature struct {\n \t// HashTag contains the first two bytes of the hash for fast rejection\n \t// of bad signed data.\n \tHashTag      [2]byte\n-\tCreationTime uint32 // Unix epoch time\n+\tCreationTime time.Time\n \n \tRSASignature     parsedMPI\n \tDSASigR, DSASigS parsedMPI\n@@ -151,7 +152,7 @@ func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool)\n \t\t}\n \t}\n \n-\tif sig.CreationTime == 0 {\n+\tif sig.CreationTime.IsZero() {\n \t\terr = error_.StructuralError(\"no creation time in signature\")\n \t}\n \n@@ -223,7 +224,12 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\terr = error_.StructuralError(\"signature creation time not four bytes\")\n \t\t\treturn\n \t\t}\n-\t\tsig.CreationTime = binary.BigEndian.Uint32(subpacket)\n+\t\tt := binary.BigEndian.Uint32(subpacket)\n+\t\tif t == 0 {\n+\t\t\tsig.CreationTime = time.Time{}\n+\t\t} else {\n+\t\t\tsig.CreationTime = time.Unix(int64(t), 0)\n+\t\t}\n \tcase signatureExpirationSubpacket:\n \t\t// Signature expiration time, section 5.2.3.10\n \t\tif !isHashed {\n@@ -417,7 +423,7 @@ func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err error) {\n \t}\n \n \th.Write(sig.HashSuffix)\n-\tdigest = h.Sum()\n+\tdigest = h.Sum(nil)\n \tcopy(sig.HashTag[:], digest)\n \treturn\n }\n@@ -541,10 +547,7 @@ type outputSubpacket struct {\n \n func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {\n \tcreationTime := make([]byte, 4)\n-\tcreationTime[0] = byte(sig.CreationTime >> 24)\n-\tcreationTime[1] = byte(sig.CreationTime >> 16)\n-\tcreationTime[2] = byte(sig.CreationTime >> 8)\n-\tcreationTime[3] = byte(sig.CreationTime)\n+\tbinary.BigEndian.PutUint32(creationTime, uint32(sig.CreationTime.Unix()))\n \tsubpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, false, creationTime})\n \n \tif sig.IssuerKeyId != nil {"}, {"sha": "dff776e3eb2f0ceb9dfd881c0f11df1558af42cc", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -201,7 +201,7 @@ func (ser *seMDCReader) Close() error {\n \t}\n \tser.h.Write(ser.trailer[:2])\n \n-\tfinal := ser.h.Sum()\n+\tfinal := ser.h.Sum(nil)\n \tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {\n \t\treturn error_.SignatureError(\"hash mismatch\")\n \t}\n@@ -227,7 +227,7 @@ func (w *seMDCWriter) Close() (err error) {\n \tbuf[0] = mdcPacketTagByte\n \tbuf[1] = sha1.Size\n \tw.h.Write(buf[:2])\n-\tdigest := w.h.Sum()\n+\tdigest := w.h.Sum(nil)\n \tcopy(buf[2:], digest)\n \n \t_, err = w.w.Write(buf[:])"}, {"sha": "83673e173353caaf30ff69bae031d947f3c833f5", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -34,7 +34,7 @@ func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {\n \t\t}\n \t\th.Write(salt)\n \t\th.Write(in)\n-\t\tn := copy(out[done:], h.Sum())\n+\t\tn := copy(out[done:], h.Sum(nil))\n \t\tdone += n\n \t}\n }\n@@ -68,7 +68,7 @@ func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {\n \t\t\t\twritten += len(combined)\n \t\t\t}\n \t\t}\n-\t\tn := copy(out[done:], h.Sum())\n+\t\tn := copy(out[done:], h.Sum(nil))\n \t\tdone += n\n \t}\n }"}, {"sha": "60dae01e64b2fa6da49942c3534b45f84f6674ef", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -68,7 +68,7 @@ func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.S\n \tsig.SigType = sigType\n \tsig.PubKeyAlgo = signer.PrivateKey.PubKeyAlgo\n \tsig.Hash = crypto.SHA256\n-\tsig.CreationTime = uint32(time.Seconds())\n+\tsig.CreationTime = time.Now()\n \tsig.IssuerKeyId = &signer.PrivateKey.KeyId\n \n \th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n@@ -95,8 +95,8 @@ type FileHints struct {\n \t// file should not be written to disk. It may be equal to \"_CONSOLE\" to\n \t// suggest the data should not be written to disk.\n \tFileName string\n-\t// EpochSeconds contains the modification time of the file, or 0 if not applicable.\n-\tEpochSeconds uint32\n+\t// ModTime contains the modification time of the file, or the zero time if not applicable.\n+\tModTime time.Time\n }\n \n // SymmetricallyEncrypt acts like gpg -c: it encrypts a file with a passphrase.\n@@ -115,7 +115,11 @@ func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHi\n \tif err != nil {\n \t\treturn\n \t}\n-\treturn packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, hints.EpochSeconds)\n+\tvar epochSeconds uint32\n+\tif !hints.ModTime.IsZero() {\n+\t\tepochSeconds = uint32(hints.ModTime.Unix())\n+\t}\n+\treturn packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, epochSeconds)\n }\n \n // intersectPreferences mutates and returns a prefix of a that contains only\n@@ -243,7 +247,11 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \t\tw = noOpCloser{encryptedData}\n \n \t}\n-\tliteralData, err := packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, hints.EpochSeconds)\n+\tvar epochSeconds uint32\n+\tif !hints.ModTime.IsZero() {\n+\t\tepochSeconds = uint32(hints.ModTime.Unix())\n+\t}\n+\tliteralData, err := packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, epochSeconds)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -275,7 +283,7 @@ func (s signatureWriter) Close() error {\n \t\tSigType:      packet.SigTypeBinary,\n \t\tPubKeyAlgo:   s.signer.PubKeyAlgo,\n \t\tHash:         s.hashType,\n-\t\tCreationTime: uint32(time.Seconds()),\n+\t\tCreationTime: time.Now(),\n \t\tIssuerKeyId:  &s.signer.KeyId,\n \t}\n "}, {"sha": "02fa5b75bff626300b2476ab5c1ab8cd1d83dd30", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -54,7 +54,7 @@ func TestNewEntity(t *testing.T) {\n \t\treturn\n \t}\n \n-\te, err := NewEntity(rand.Reader, time.Seconds(), \"Test User\", \"test\", \"test@example.com\")\n+\te, err := NewEntity(rand.Reader, time.Now(), \"Test User\", \"test\", \"test@example.com\")\n \tif err != nil {\n \t\tt.Errorf(\"failed to create entity: %s\", err)\n \t\treturn"}, {"sha": "d9cddf6d2ad2830d61cad1d6ece74a78cd06eb2f", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -100,7 +100,7 @@ func (r *reader) Read(b []byte) (n int, err error) {\n \t\t// t = encrypt(time)\n \t\t// dst = encrypt(t^seed)\n \t\t// seed = encrypt(t^dst)\n-\t\tns := time.Nanoseconds()\n+\t\tns := time.Now().UnixNano()\n \t\tr.time[0] = byte(ns >> 56)\n \t\tr.time[1] = byte(ns >> 48)\n \t\tr.time[2] = byte(ns >> 40)"}, {"sha": "c128ee445a5af95eb6369262bebe8e4a693ddb23", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -81,7 +81,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -107,11 +107,11 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 20)\n-\tj := 0\n \tfor _, s := range d.s {\n-\t\tp[j], p[j+1], p[j+2], p[j+3] = byte(s), byte(s>>8), byte(s>>16), byte(s>>24)\n-\t\tj += 4\n+\t\tin = append(in, byte(s))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>24))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "5df1b2593d2c16aa5bef5a54cb8fd18d0d895fa7", "filename": "libgo/go/crypto/ripemd160/ripemd160_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -38,10 +38,10 @@ func TestVectors(t *testing.T) {\n \t\t\t\tio.WriteString(md, tv.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(md, tv.in[0:len(tv.in)/2])\n-\t\t\t\tmd.Sum()\n+\t\t\t\tmd.Sum(nil)\n \t\t\t\tio.WriteString(md, tv.in[len(tv.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", md.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", md.Sum(nil))\n \t\t\tif s != tv.out {\n \t\t\t\tt.Fatalf(\"RIPEMD-160[%d](%s) = %s, expected %s\", j, tv.in, s, tv.out)\n \t\t\t}\n@@ -56,7 +56,7 @@ func TestMillionA(t *testing.T) {\n \t\tio.WriteString(md, \"aaaaaaaaaa\")\n \t}\n \tout := \"52783243c1697bdbe16d37f97f68f08325dc1528\"\n-\ts := fmt.Sprintf(\"%x\", md.Sum())\n+\ts := fmt.Sprintf(\"%x\", md.Sum(nil))\n \tif s != out {\n \t\tt.Fatalf(\"RIPEMD-160 (1 million 'a') = %s, expected %s\", s, out)\n \t}"}, {"sha": "58d5fda197628e55ffcf9c671667e0a20c85ce6c", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -168,7 +168,7 @@ func TestSignPKCS1v15(t *testing.T) {\n \tfor i, test := range signPKCS1v15Tests {\n \t\th := sha1.New()\n \t\th.Write([]byte(test.in))\n-\t\tdigest := h.Sum()\n+\t\tdigest := h.Sum(nil)\n \n \t\ts, err := SignPKCS1v15(nil, rsaPrivateKey, crypto.SHA1, digest)\n \t\tif err != nil {\n@@ -186,7 +186,7 @@ func TestVerifyPKCS1v15(t *testing.T) {\n \tfor i, test := range signPKCS1v15Tests {\n \t\th := sha1.New()\n \t\th.Write([]byte(test.in))\n-\t\tdigest := h.Sum()\n+\t\tdigest := h.Sum(nil)\n \n \t\tsig, _ := hex.DecodeString(test.out)\n "}, {"sha": "f74525c103ad453e8e7537b727260862b8f55fcd", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -194,7 +194,7 @@ func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {\n \tfor done < len(out) {\n \t\thash.Write(seed)\n \t\thash.Write(counter[0:4])\n-\t\tdigest := hash.Sum()\n+\t\tdigest := hash.Sum(nil)\n \t\thash.Reset()\n \n \t\tfor i := 0; i < len(digest) && done < len(out); i++ {\n@@ -231,7 +231,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \t}\n \n \thash.Write(label)\n-\tlHash := hash.Sum()\n+\tlHash := hash.Sum(nil)\n \thash.Reset()\n \n \tem := make([]byte, k)\n@@ -428,7 +428,7 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \t}\n \n \thash.Write(label)\n-\tlHash := hash.Sum()\n+\tlHash := hash.Sum(nil)\n \thash.Reset()\n \n \t// Converting the plaintext number to bytes will strip any"}, {"sha": "f41cdb5b0279d8be461559889fc255e226ca247a", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -79,7 +79,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -105,14 +105,11 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 20)\n-\tj := 0\n \tfor _, s := range d.h {\n-\t\tp[j+0] = byte(s >> 24)\n-\t\tp[j+1] = byte(s >> 16)\n-\t\tp[j+2] = byte(s >> 8)\n-\t\tp[j+3] = byte(s >> 0)\n-\t\tj += 4\n+\t\tin = append(in, byte(s>>24))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "c23df6c41e9de1794d555fe9c5cf90c1987049a2", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -60,10 +60,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha1[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "34861f6cf49522a87de9f69b4df3b5a4b98f59a4", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -123,7 +123,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -149,17 +149,15 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 32)\n-\tj := 0\n-\tfor _, s := range d.h {\n-\t\tp[j+0] = byte(s >> 24)\n-\t\tp[j+1] = byte(s >> 16)\n-\t\tp[j+2] = byte(s >> 8)\n-\t\tp[j+3] = byte(s >> 0)\n-\t\tj += 4\n-\t}\n+\th := d.h[:]\n \tif d.is224 {\n-\t\treturn p[0:28]\n+\t\th = d.h[:7]\n+\t}\n+\tfor _, s := range h {\n+\t\tin = append(in, byte(s>>24))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "a6efb37545602480437cec07d54f6f402e432e32", "filename": "libgo/go/crypto/sha256/sha256_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -94,10 +94,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha256[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}\n@@ -112,10 +112,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha224[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "3cf65cbe7c825e9b76e42549975efa039a3ba682", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -123,7 +123,7 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \treturn\n }\n \n-func (d0 *digest) Sum() []byte {\n+func (d0 *digest) Sum(in []byte) []byte {\n \t// Make a copy of d0 so that caller can keep writing and summing.\n \td := new(digest)\n \t*d = *d0\n@@ -149,21 +149,19 @@ func (d0 *digest) Sum() []byte {\n \t\tpanic(\"d.nx != 0\")\n \t}\n \n-\tp := make([]byte, 64)\n-\tj := 0\n-\tfor _, s := range d.h {\n-\t\tp[j+0] = byte(s >> 56)\n-\t\tp[j+1] = byte(s >> 48)\n-\t\tp[j+2] = byte(s >> 40)\n-\t\tp[j+3] = byte(s >> 32)\n-\t\tp[j+4] = byte(s >> 24)\n-\t\tp[j+5] = byte(s >> 16)\n-\t\tp[j+6] = byte(s >> 8)\n-\t\tp[j+7] = byte(s >> 0)\n-\t\tj += 8\n-\t}\n+\th := d.h[:]\n \tif d.is384 {\n-\t\treturn p[0:48]\n+\t\th = d.h[:6]\n+\t}\n+\tfor _, s := range h {\n+\t\tin = append(in, byte(s>>56))\n+\t\tin = append(in, byte(s>>48))\n+\t\tin = append(in, byte(s>>40))\n+\t\tin = append(in, byte(s>>32))\n+\t\tin = append(in, byte(s>>24))\n+\t\tin = append(in, byte(s>>16))\n+\t\tin = append(in, byte(s>>8))\n+\t\tin = append(in, byte(s))\n \t}\n-\treturn p\n+\treturn in\n }"}, {"sha": "a70f7c54e39e4e0a6f7dd4cedfa34c9ac028ed6c", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -94,10 +94,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha512[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}\n@@ -112,10 +112,10 @@ func TestGolden(t *testing.T) {\n \t\t\t\tio.WriteString(c, g.in)\n \t\t\t} else {\n \t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum()\n+\t\t\t\tc.Sum(nil)\n \t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n \t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum())\n+\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n \t\t\tif s != g.out {\n \t\t\t\tt.Fatalf(\"sha384[%d](%s) = %s want %s\", j, g.in, s, g.out)\n \t\t\t}"}, {"sha": "c0e8656f79b534c6960ad3ef2f22af43103c24dc", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -37,6 +37,7 @@ type keyAgreement interface {\n // A cipherSuite is a specific combination of key agreement, cipher and MAC\n // function. All cipher suites currently assume RSA key agreement.\n type cipherSuite struct {\n+\tid uint16\n \t// the lengths, in bytes, of the key material needed for each component.\n \tkeyLen int\n \tmacLen int\n@@ -50,13 +51,13 @@ type cipherSuite struct {\n \tmac      func(version uint16, macKey []byte) macFunction\n }\n \n-var cipherSuites = map[uint16]*cipherSuite{\n-\tTLS_RSA_WITH_RC4_128_SHA:            &cipherSuite{16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n-\tTLS_RSA_WITH_3DES_EDE_CBC_SHA:       &cipherSuite{24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n-\tTLS_RSA_WITH_AES_128_CBC_SHA:        &cipherSuite{16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n-\tTLS_ECDHE_RSA_WITH_RC4_128_SHA:      &cipherSuite{16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n-\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: &cipherSuite{24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n-\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:  &cipherSuite{16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n+var cipherSuites = []*cipherSuite{\n+\t&cipherSuite{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n+\t&cipherSuite{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n+\t&cipherSuite{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n+\t&cipherSuite{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n+\t&cipherSuite{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n+\t&cipherSuite{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n@@ -126,13 +127,13 @@ func (s ssl30MAC) MAC(seq, record []byte) []byte {\n \ts.h.Write(record[:1])\n \ts.h.Write(record[3:5])\n \ts.h.Write(record[recordHeaderLen:])\n-\tdigest := s.h.Sum()\n+\tdigest := s.h.Sum(nil)\n \n \ts.h.Reset()\n \ts.h.Write(s.key)\n \ts.h.Write(ssl30Pad2[:padLength])\n \ts.h.Write(digest)\n-\treturn s.h.Sum()\n+\treturn s.h.Sum(nil)\n }\n \n // tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.\n@@ -148,7 +149,7 @@ func (s tls10MAC) MAC(seq, record []byte) []byte {\n \ts.h.Reset()\n \ts.h.Write(seq)\n \ts.h.Write(record)\n-\treturn s.h.Sum()\n+\treturn s.h.Sum(nil)\n }\n \n func rsaKA() keyAgreement {\n@@ -159,15 +160,20 @@ func ecdheRSAKA() keyAgreement {\n \treturn new(ecdheRSAKeyAgreement)\n }\n \n-// mutualCipherSuite returns a cipherSuite and its id given a list of supported\n+// mutualCipherSuite returns a cipherSuite given a list of supported\n // ciphersuites and the id requested by the peer.\n-func mutualCipherSuite(have []uint16, want uint16) (suite *cipherSuite, id uint16) {\n+func mutualCipherSuite(have []uint16, want uint16) *cipherSuite {\n \tfor _, id := range have {\n \t\tif id == want {\n-\t\t\treturn cipherSuites[id], id\n+\t\t\tfor _, suite := range cipherSuites {\n+\t\t\t\tif suite.id == want {\n+\t\t\t\t\treturn suite\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n \t\t}\n \t}\n-\treturn\n+\treturn nil\n }\n \n // A list of the possible cipher suite ids. Taken from"}, {"sha": "f57d932a98f9a6602b51f61cf5ef032dcdb71481", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -121,7 +121,7 @@ type Config struct {\n \n \t// Time returns the current time as the number of seconds since the epoch.\n \t// If Time is nil, TLS uses the system time.Seconds.\n-\tTime func() int64\n+\tTime func() time.Time\n \n \t// Certificates contains one or more certificate chains\n \t// to present to the other side of the connection.\n@@ -175,10 +175,10 @@ func (c *Config) rand() io.Reader {\n \treturn r\n }\n \n-func (c *Config) time() int64 {\n+func (c *Config) time() time.Time {\n \tt := c.Time\n \tif t == nil {\n-\t\tt = time.Seconds\n+\t\tt = time.Now\n \t}\n \treturn t()\n }\n@@ -315,9 +315,7 @@ var (\n \n func initDefaultCipherSuites() {\n \tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))\n-\ti := 0\n-\tfor id := range cipherSuites {\n-\t\tvarDefaultCipherSuites[i] = id\n-\t\ti++\n+\tfor i, suite := range cipherSuites {\n+\t\tvarDefaultCipherSuites[i] = suite.id\n \t}\n }"}, {"sha": "b4337f2aac61f915a72daee9f8fc9ab6411cb336", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -32,7 +32,7 @@ func (c *Conn) clientHandshake() error {\n \t\tnextProtoNeg:       len(c.config.NextProtos) > 0,\n \t}\n \n-\tt := uint32(c.config.time())\n+\tt := uint32(c.config.time().Unix())\n \thello.random[0] = byte(t >> 24)\n \thello.random[1] = byte(t >> 16)\n \thello.random[2] = byte(t >> 8)\n@@ -72,7 +72,7 @@ func (c *Conn) clientHandshake() error {\n \t\treturn errors.New(\"server advertised unrequested NPN\")\n \t}\n \n-\tsuite, suiteId := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n+\tsuite := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n \tif suite == nil {\n \t\treturn c.sendAlert(alertHandshakeFailure)\n \t}\n@@ -232,8 +232,8 @@ func (c *Conn) clientHandshake() error {\n \tif cert != nil {\n \t\tcertVerify := new(certificateVerifyMsg)\n \t\tvar digest [36]byte\n-\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum())\n-\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum())\n+\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum(nil))\n+\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum(nil))\n \t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, crypto.MD5SHA1, digest[0:])\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n@@ -292,7 +292,7 @@ func (c *Conn) clientHandshake() error {\n \t}\n \n \tc.handshakeComplete = true\n-\tc.cipherSuite = suiteId\n+\tc.cipherSuite = suite.id\n \treturn nil\n }\n "}, {"sha": "bbb23c0c9f6dacbaf080ee65b27fbaa5ee36a5df", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -56,18 +56,25 @@ Curves:\n \tellipticOk := supportedCurve && supportedPointFormat\n \n \tvar suite *cipherSuite\n-\tvar suiteId uint16\n FindCipherSuite:\n \tfor _, id := range clientHello.cipherSuites {\n \t\tfor _, supported := range config.cipherSuites() {\n \t\t\tif id == supported {\n-\t\t\t\tsuite = cipherSuites[id]\n+\t\t\t\tsuite = nil\n+\t\t\t\tfor _, s := range cipherSuites {\n+\t\t\t\t\tif s.id == id {\n+\t\t\t\t\t\tsuite = s\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif suite == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t\t// Don't select a ciphersuite which we can't\n \t\t\t\t// support for this client.\n \t\t\t\tif suite.elliptic && !ellipticOk {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tsuiteId = id\n \t\t\t\tbreak FindCipherSuite\n \t\t\t}\n \t\t}\n@@ -87,8 +94,8 @@ FindCipherSuite:\n \t}\n \n \thello.vers = vers\n-\thello.cipherSuite = suiteId\n-\tt := uint32(config.time())\n+\thello.cipherSuite = suite.id\n+\tt := uint32(config.time().Unix())\n \thello.random = make([]byte, 32)\n \thello.random[0] = byte(t >> 24)\n \thello.random[1] = byte(t >> 16)\n@@ -228,8 +235,8 @@ FindCipherSuite:\n \t\t}\n \n \t\tdigest := make([]byte, 36)\n-\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum())\n-\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum())\n+\t\tcopy(digest[0:16], finishedHash.serverMD5.Sum(nil))\n+\t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum(nil))\n \t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n@@ -296,7 +303,7 @@ FindCipherSuite:\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n \tc.handshakeComplete = true\n-\tc.cipherSuite = suiteId\n+\tc.cipherSuite = suite.id\n \n \treturn nil\n }"}, {"sha": "e00c32c5508371645d710daddc831a95841a1ce3", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type zeroSource struct{}\n@@ -31,7 +32,7 @@ var testConfig *Config\n \n func init() {\n \ttestConfig = new(Config)\n-\ttestConfig.Time = func() int64 { return 0 }\n+\ttestConfig.Time = func() time.Time { return time.Unix(0, 0) }\n \ttestConfig.Rand = zeroSource{}\n \ttestConfig.Certificates = make([]Certificate, 1)\n \ttestConfig.Certificates[0].Certificate = [][]byte{testCertificate}"}, {"sha": "b531717d8401c78d170a72aef5f3ca9cf2239e37", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -90,13 +90,13 @@ func md5SHA1Hash(slices ...[]byte) []byte {\n \tfor _, slice := range slices {\n \t\thmd5.Write(slice)\n \t}\n-\tcopy(md5sha1, hmd5.Sum())\n+\tcopy(md5sha1, hmd5.Sum(nil))\n \n \thsha1 := sha1.New()\n \tfor _, slice := range slices {\n \t\thsha1.Write(slice)\n \t}\n-\tcopy(md5sha1[md5.Size:], hsha1.Sum())\n+\tcopy(md5sha1[md5.Size:], hsha1.Sum(nil))\n \treturn md5sha1\n }\n "}, {"sha": "637ef03e2d7844d38d471c14955606bc3d94e21e", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -22,14 +22,14 @@ func splitPreMasterSecret(secret []byte) (s1, s2 []byte) {\n func pHash(result, secret, seed []byte, hash func() hash.Hash) {\n \th := hmac.New(hash, secret)\n \th.Write(seed)\n-\ta := h.Sum()\n+\ta := h.Sum(nil)\n \n \tj := 0\n \tfor j < len(result) {\n \t\th.Reset()\n \t\th.Write(a)\n \t\th.Write(seed)\n-\t\tb := h.Sum()\n+\t\tb := h.Sum(nil)\n \t\ttodo := len(b)\n \t\tif j+todo > len(result) {\n \t\t\ttodo = len(result) - j\n@@ -39,7 +39,7 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {\n \n \t\th.Reset()\n \t\th.Write(a)\n-\t\ta = h.Sum()\n+\t\ta = h.Sum(nil)\n \t}\n }\n \n@@ -84,13 +84,13 @@ func pRF30(result, secret, label, seed []byte) {\n \t\thashSHA1.Write(b[:i+1])\n \t\thashSHA1.Write(secret)\n \t\thashSHA1.Write(seed)\n-\t\tdigest := hashSHA1.Sum()\n+\t\tdigest := hashSHA1.Sum(nil)\n \n \t\thashMD5.Reset()\n \t\thashMD5.Write(secret)\n \t\thashMD5.Write(digest)\n \n-\t\tdone += copy(result[done:], hashMD5.Sum())\n+\t\tdone += copy(result[done:], hashMD5.Sum(nil))\n \t\ti++\n \t}\n }\n@@ -182,24 +182,24 @@ func finishedSum30(md5, sha1 hash.Hash, masterSecret []byte, magic [4]byte) []by\n \tmd5.Write(magic[:])\n \tmd5.Write(masterSecret)\n \tmd5.Write(ssl30Pad1[:])\n-\tmd5Digest := md5.Sum()\n+\tmd5Digest := md5.Sum(nil)\n \n \tmd5.Reset()\n \tmd5.Write(masterSecret)\n \tmd5.Write(ssl30Pad2[:])\n \tmd5.Write(md5Digest)\n-\tmd5Digest = md5.Sum()\n+\tmd5Digest = md5.Sum(nil)\n \n \tsha1.Write(magic[:])\n \tsha1.Write(masterSecret)\n \tsha1.Write(ssl30Pad1[:40])\n-\tsha1Digest := sha1.Sum()\n+\tsha1Digest := sha1.Sum(nil)\n \n \tsha1.Reset()\n \tsha1.Write(masterSecret)\n \tsha1.Write(ssl30Pad2[:40])\n \tsha1.Write(sha1Digest)\n-\tsha1Digest = sha1.Sum()\n+\tsha1Digest = sha1.Sum(nil)\n \n \tret := make([]byte, len(md5Digest)+len(sha1Digest))\n \tcopy(ret, md5Digest)\n@@ -217,8 +217,8 @@ func (h finishedHash) clientSum(masterSecret []byte) []byte {\n \t\treturn finishedSum30(h.clientMD5, h.clientSHA1, masterSecret, ssl3ClientFinishedMagic)\n \t}\n \n-\tmd5 := h.clientMD5.Sum()\n-\tsha1 := h.clientSHA1.Sum()\n+\tmd5 := h.clientMD5.Sum(nil)\n+\tsha1 := h.clientSHA1.Sum(nil)\n \treturn finishedSum10(md5, sha1, clientFinishedLabel, masterSecret)\n }\n \n@@ -229,7 +229,7 @@ func (h finishedHash) serverSum(masterSecret []byte) []byte {\n \t\treturn finishedSum30(h.serverMD5, h.serverSHA1, masterSecret, ssl3ServerFinishedMagic)\n \t}\n \n-\tmd5 := h.serverMD5.Sum()\n-\tsha1 := h.serverSHA1.Sum()\n+\tmd5 := h.serverMD5.Sum(nil)\n+\tsha1 := h.serverSHA1.Sum(nil)\n \treturn finishedSum10(md5, sha1, serverFinishedLabel, masterSecret)\n }"}, {"sha": "1b9aeb03b5bfe1604104177acb6cab23c895e66a", "filename": "libgo/go/crypto/tls/root_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -14,6 +14,7 @@ var certFiles = []string{\n \t\"/etc/ssl/certs/ca-certificates.crt\", // Linux etc\n \t\"/etc/pki/tls/certs/ca-bundle.crt\",   // Fedora/RHEL\n \t\"/etc/ssl/ca-bundle.pem\",             // OpenSUSE\n+\t\"/etc/ssl/cert.pem\",                  // OpenBSD\n }\n \n func initDefaultRoots() {"}, {"sha": "319309ae6e7eb5a9ea74bdb1167f3377047cf6d4", "filename": "libgo/go/crypto/tls/root_windows.go", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"crypto/x509\"\n-\t\"reflect\"\n \t\"syscall\"\n \t\"unsafe\"\n )\n@@ -16,29 +15,23 @@ func loadStore(roots *x509.CertPool, name string) {\n \tif err != nil {\n \t\treturn\n \t}\n+\tdefer syscall.CertCloseStore(store, 0)\n \n \tvar cert *syscall.CertContext\n \tfor {\n-\t\tcert = syscall.CertEnumCertificatesInStore(store, cert)\n-\t\tif cert == nil {\n-\t\t\tbreak\n+\t\tcert, err = syscall.CertEnumCertificatesInStore(store, cert)\n+\t\tif err != nil {\n+\t\t\treturn\n \t\t}\n \n-\t\tvar asn1Slice []byte\n-\t\thdrp := (*reflect.SliceHeader)(unsafe.Pointer(&asn1Slice))\n-\t\thdrp.Data = cert.EncodedCert\n-\t\thdrp.Len = int(cert.Length)\n-\t\thdrp.Cap = int(cert.Length)\n-\n-\t\tbuf := make([]byte, len(asn1Slice))\n-\t\tcopy(buf, asn1Slice)\n-\n-\t\tif cert, err := x509.ParseCertificate(buf); err == nil {\n-\t\t\troots.AddCert(cert)\n+\t\tbuf := (*[1 << 20]byte)(unsafe.Pointer(cert.EncodedCert))[:]\n+\t\t// ParseCertificate requires its own copy of certificate data to keep.\n+\t\tbuf2 := make([]byte, cert.Length)\n+\t\tcopy(buf2, buf)\n+\t\tif c, err := x509.ParseCertificate(buf2); err == nil {\n+\t\t\troots.AddCert(c)\n \t\t}\n \t}\n-\n-\tsyscall.CertCloseStore(store, 0)\n }\n \n func initDefaultRoots() {"}, {"sha": "79ab50231293045e6b0eed4f0efd88818163fb24", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -157,10 +157,21 @@ func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)\n \t\treturn\n \t}\n \n-\tkey, err := x509.ParsePKCS1PrivateKey(keyDERBlock.Bytes)\n-\tif err != nil {\n-\t\terr = errors.New(\"crypto/tls: failed to parse key: \" + err.Error())\n-\t\treturn\n+\t// OpenSSL 0.9.8 generates PKCS#1 private keys by default, while\n+\t// OpenSSL 1.0.0 generates PKCS#8 keys. We try both.\n+\tvar key *rsa.PrivateKey\n+\tif key, err = x509.ParsePKCS1PrivateKey(keyDERBlock.Bytes); err != nil {\n+\t\tvar privKey interface{}\n+\t\tif privKey, err = x509.ParsePKCS8PrivateKey(keyDERBlock.Bytes); err != nil {\n+\t\t\terr = errors.New(\"crypto/tls: failed to parse key: \" + err.Error())\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar ok bool\n+\t\tif key, ok = privKey.(*rsa.PrivateKey); !ok {\n+\t\t\terr = errors.New(\"crypto/tls: found non-RSA private key in PKCS#8 wrapping\")\n+\t\t\treturn\n+\t\t}\n \t}\n \n \tcert.PrivateKey = key"}, {"sha": "adc7f9bc6d76e09bacbefd4703f9235b12f94756", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,7 +8,7 @@ import (\n \t\"encoding/pem\"\n )\n \n-// Roots is a set of certificates.\n+// CertPool is a set of certificates.\n type CertPool struct {\n \tbySubjectKeyId map[string][]int\n \tbyName         map[string][]int\n@@ -70,11 +70,11 @@ func (s *CertPool) AddCert(cert *Certificate) {\n \ts.byName[name] = append(s.byName[name], n)\n }\n \n-// AppendCertsFromPEM attempts to parse a series of PEM encoded root\n-// certificates. It appends any certificates found to s and returns true if any\n-// certificates were successfully parsed.\n+// AppendCertsFromPEM attempts to parse a series of PEM encoded certificates.\n+// It appends any certificates found to s and returns true if any certificates\n+// were successfully parsed.\n //\n-// On many Linux systems, /etc/ssl/cert.pem will contains the system wide set\n+// On many Linux systems, /etc/ssl/cert.pem will contain the system wide set\n // of root CAs in a format suitable for this function.\n func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool) {\n \tfor len(pemCerts) > 0 {"}, {"sha": "4d8e0518e02bcc9dc3ba64b3360fbb29b2e681f0", "filename": "libgo/go/crypto/x509/pkcs8.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"crypto/x509/pkix\"\n+\t\"encoding/asn1\"\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// pkcs8 reflects an ASN.1, PKCS#8 PrivateKey. See \n+// ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-8/pkcs-8v1_2.asn.\n+type pkcs8 struct {\n+\tVersion    int\n+\tAlgo       pkix.AlgorithmIdentifier\n+\tPrivateKey []byte\n+\t// optional attributes omitted.\n+}\n+\n+// ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See\n+// http://www.rsa.com/rsalabs/node.asp?id=2130\n+func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error) {\n+\tvar privKey pkcs8\n+\tif _, err := asn1.Unmarshal(der, &privKey); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch {\n+\tcase privKey.Algo.Algorithm.Equal(oidRSA):\n+\t\tkey, err = ParsePKCS1PrivateKey(privKey.PrivateKey)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"crypto/x509: failed to parse RSA private key embedded in PKCS#8: \" + err.Error())\n+\t\t}\n+\t\treturn key, nil\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"crypto/x509: PKCS#8 wrapping contained private key with unknown algorithm: %v\", privKey.Algo.Algorithm)\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "372005f908cf285a8a8e8d46ba68b4842ade9063", "filename": "libgo/go/crypto/x509/pkcs8_test.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs8_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+var pkcs8PrivateKeyHex = `30820278020100300d06092a864886f70d0101010500048202623082025e02010002818100cfb1b5bf9685ffa97b4f99df4ff122b70e59ac9b992f3bc2b3dde17d53c1a34928719b02e8fd17839499bfbd515bd6ef99c7a1c47a239718fe36bfd824c0d96060084b5f67f0273443007a24dfaf5634f7772c9346e10eb294c2306671a5a5e719ae24b4de467291bc571014b0e02dec04534d66a9bb171d644b66b091780e8d020301000102818100b595778383c4afdbab95d2bfed12b3f93bb0a73a7ad952f44d7185fd9ec6c34de8f03a48770f2009c8580bcd275e9632714e9a5e3f32f29dc55474b2329ff0ebc08b3ffcb35bc96e6516b483df80a4a59cceb71918cbabf91564e64a39d7e35dce21cb3031824fdbc845dba6458852ec16af5dddf51a8397a8797ae0337b1439024100ea0eb1b914158c70db39031dd8904d6f18f408c85fbbc592d7d20dee7986969efbda081fdf8bc40e1b1336d6b638110c836bfdc3f314560d2e49cd4fbde1e20b024100e32a4e793b574c9c4a94c8803db5152141e72d03de64e54ef2c8ed104988ca780cd11397bc359630d01b97ebd87067c5451ba777cf045ca23f5912f1031308c702406dfcdbbd5a57c9f85abc4edf9e9e29153507b07ce0a7ef6f52e60dcfebe1b8341babd8b789a837485da6c8d55b29bbb142ace3c24a1f5b54b454d01b51e2ad03024100bd6a2b60dee01e1b3bfcef6a2f09ed027c273cdbbaf6ba55a80f6dcc64e4509ee560f84b4f3e076bd03b11e42fe71a3fdd2dffe7e0902c8584f8cad877cdc945024100aa512fa4ada69881f1d8bb8ad6614f192b83200aef5edf4811313d5ef30a86cbd0a90f7b025c71ea06ec6b34db6306c86b1040670fd8654ad7291d066d06d031`\n+\n+func TestPKCS8(t *testing.T) {\n+\tderBytes, _ := hex.DecodeString(pkcs8PrivateKeyHex)\n+\t_, err := ParsePKCS8PrivateKey(derBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to decode PKCS8 key: %s\", err)\n+\t}\n+}"}, {"sha": "8eced55f932a01e658ca3615d1b1d772f65bdb1d", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -142,10 +142,9 @@ type CertificateList struct {\n \tSignatureValue     asn1.BitString\n }\n \n-// HasExpired returns true iff currentTimeSeconds is past the expiry time of\n-// certList.\n-func (certList *CertificateList) HasExpired(currentTimeSeconds int64) bool {\n-\treturn certList.TBSCertList.NextUpdate.Seconds() <= currentTimeSeconds\n+// HasExpired returns true iff now is past the expiry time of certList.\n+func (certList *CertificateList) HasExpired(now time.Time) bool {\n+\treturn now.After(certList.TBSCertList.NextUpdate)\n }\n \n // TBSCertificateList represents the ASN.1 structure of the same name. See RFC\n@@ -155,8 +154,8 @@ type TBSCertificateList struct {\n \tVersion             int `asn1:\"optional,default:2\"`\n \tSignature           AlgorithmIdentifier\n \tIssuer              RDNSequence\n-\tThisUpdate          *time.Time\n-\tNextUpdate          *time.Time\n+\tThisUpdate          time.Time\n+\tNextUpdate          time.Time\n \tRevokedCertificates []RevokedCertificate `asn1:\"optional\"`\n \tExtensions          []Extension          `asn1:\"tag:0,optional,explicit\"`\n }\n@@ -165,6 +164,6 @@ type TBSCertificateList struct {\n // 5280, section 5.1.\n type RevokedCertificate struct {\n \tSerialNumber   *big.Int\n-\tRevocationTime *time.Time\n+\tRevocationTime time.Time\n \tExtensions     []Extension `asn1:\"optional\"`\n }"}, {"sha": "50a3b66e55506a66ab9bea45f07eee93235b3918", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -76,7 +76,7 @@ type VerifyOptions struct {\n \tDNSName       string\n \tIntermediates *CertPool\n \tRoots         *CertPool\n-\tCurrentTime   int64 // if 0, the current system time is used.\n+\tCurrentTime   time.Time // if zero, the current time is used\n }\n \n const (\n@@ -87,8 +87,11 @@ const (\n \n // isValid performs validity checks on the c.\n func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n-\tif opts.CurrentTime < c.NotBefore.Seconds() ||\n-\t\topts.CurrentTime > c.NotAfter.Seconds() {\n+\tnow := opts.CurrentTime\n+\tif now.IsZero() {\n+\t\tnow = time.Now()\n+\t}\n+\tif now.Before(c.NotBefore) || now.After(c.NotAfter) {\n \t\treturn CertificateInvalidError{c, Expired}\n \t}\n \n@@ -136,9 +139,6 @@ func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n //\n // WARNING: this doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\n-\tif opts.CurrentTime == 0 {\n-\t\topts.CurrentTime = time.Seconds()\n-\t}\n \terr = c.isValid(leafCertificate, &opts)\n \tif err != nil {\n \t\treturn"}, {"sha": "df5443023ff9923d1633cb2df7e609309aaefe67", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"errors\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type verifyTest struct {\n@@ -133,7 +134,7 @@ func TestVerify(t *testing.T) {\n \t\t\tRoots:         NewCertPool(),\n \t\t\tIntermediates: NewCertPool(),\n \t\t\tDNSName:       test.dnsName,\n-\t\t\tCurrentTime:   test.currentTime,\n+\t\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n \t\t}\n \n \t\tfor j, root := range test.roots {"}, {"sha": "7e6b5c96f536c722e0c49c778f0872eb4720f9ab", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -107,7 +107,7 @@ type dsaSignature struct {\n }\n \n type validity struct {\n-\tNotBefore, NotAfter *time.Time\n+\tNotBefore, NotAfter time.Time\n }\n \n type publicKeyInfo struct {\n@@ -303,7 +303,7 @@ type Certificate struct {\n \tSerialNumber        *big.Int\n \tIssuer              pkix.Name\n \tSubject             pkix.Name\n-\tNotBefore, NotAfter *time.Time // Validity bounds.\n+\tNotBefore, NotAfter time.Time // Validity bounds.\n \tKeyUsage            KeyUsage\n \n \tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n@@ -398,7 +398,7 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t}\n \n \th.Write(signed)\n-\tdigest := h.Sum()\n+\tdigest := h.Sum(nil)\n \n \tswitch pub := c.PublicKey.(type) {\n \tcase *rsa.PublicKey:\n@@ -899,11 +899,10 @@ var (\n \toidRSA         = []int{1, 2, 840, 113549, 1, 1, 1}\n )\n \n-// CreateSelfSignedCertificate creates a new certificate based on\n-// a template. The following members of template are used: SerialNumber,\n-// Subject, NotBefore, NotAfter, KeyUsage, BasicConstraintsValid, IsCA,\n-// MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\n-// PermittedDNSDomains.\n+// CreateCertificate creates a new certificate based on a template. The\n+// following members of template are used: SerialNumber, Subject, NotBefore,\n+// NotAfter, KeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId,\n+// DNSNames, PermittedDNSDomainsCritical, PermittedDNSDomains.\n //\n // The certificate is signed by parent. If parent is equal to template then the\n // certificate is self-signed. The parameter pub is the public key of the\n@@ -958,7 +957,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \n \th := sha1.New()\n \th.Write(tbsCertContents)\n-\tdigest := h.Sum()\n+\tdigest := h.Sum(nil)\n \n \tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n \tif err != nil {\n@@ -1006,7 +1005,7 @@ func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error) {\n \n // CreateCRL returns a DER encoded CRL, signed by this Certificate, that\n // contains the given list of revoked certificates.\n-func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry *time.Time) (crlBytes []byte, err error) {\n+func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error) {\n \ttbsCertList := pkix.TBSCertificateList{\n \t\tVersion: 2,\n \t\tSignature: pkix.AlgorithmIdentifier{\n@@ -1025,7 +1024,7 @@ func (c *Certificate) CreateCRL(rand io.Reader, priv *rsa.PrivateKey, revokedCer\n \n \th := sha1.New()\n \th.Write(tbsCertListContents)\n-\tdigest := h.Sum()\n+\tdigest := h.Sum(nil)\n \n \tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n \tif err != nil {"}, {"sha": "f0327b0124d42bdfca67d079f3f7943cd5999163", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -250,8 +250,8 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\t\tCommonName:   commonName,\n \t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n-\t\tNotBefore: time.SecondsToUTC(1000),\n-\t\tNotAfter:  time.SecondsToUTC(100000),\n+\t\tNotBefore: time.Unix(1000, 0),\n+\t\tNotAfter:  time.Unix(100000, 0),\n \n \t\tSubjectKeyId: []byte{1, 2, 3, 4},\n \t\tKeyUsage:     KeyUsageCertSign,\n@@ -396,8 +396,8 @@ func TestCRLCreation(t *testing.T) {\n \tblock, _ = pem.Decode([]byte(pemCertificate))\n \tcert, _ := ParseCertificate(block.Bytes)\n \n-\tnow := time.SecondsToUTC(1000)\n-\texpiry := time.SecondsToUTC(10000)\n+\tnow := time.Unix(1000, 0)\n+\texpiry := time.Unix(10000, 0)\n \n \trevokedCerts := []pkix.RevokedCertificate{\n \t\t{\n@@ -443,7 +443,7 @@ func TestParseDERCRL(t *testing.T) {\n \t\tt.Errorf(\"bad number of revoked certificates. got: %d want: %d\", numCerts, expected)\n \t}\n \n-\tif certList.HasExpired(1302517272) {\n+\tif certList.HasExpired(time.Unix(1302517272, 0)) {\n \t\tt.Errorf(\"CRL has expired (but shouldn't have)\")\n \t}\n \n@@ -463,7 +463,7 @@ func TestParsePEMCRL(t *testing.T) {\n \t\tt.Errorf(\"bad number of revoked certificates. got: %d want: %d\", numCerts, expected)\n \t}\n \n-\tif certList.HasExpired(1302517272) {\n+\tif certList.HasExpired(time.Unix(1302517272, 0)) {\n \t\tt.Errorf(\"CRL has expired (but shouldn't have)\")\n \t}\n "}, {"sha": "22a0dde0da43d8e1d28a575d8429d3dbeaecbe62", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -247,7 +247,7 @@ func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err error)\n \n // UTCTime\n \n-func parseUTCTime(bytes []byte) (ret *time.Time, err error) {\n+func parseUTCTime(bytes []byte) (ret time.Time, err error) {\n \ts := string(bytes)\n \tret, err = time.Parse(\"0601021504Z0700\", s)\n \tif err == nil {\n@@ -259,7 +259,7 @@ func parseUTCTime(bytes []byte) (ret *time.Time, err error) {\n \n // parseGeneralizedTime parses the GeneralizedTime from the given byte slice\n // and returns the resulting time.\n-func parseGeneralizedTime(bytes []byte) (ret *time.Time, err error) {\n+func parseGeneralizedTime(bytes []byte) (ret time.Time, err error) {\n \treturn time.Parse(\"20060102150405Z0700\", string(bytes))\n }\n \n@@ -450,7 +450,7 @@ var (\n \tobjectIdentifierType = reflect.TypeOf(ObjectIdentifier{})\n \tenumeratedType       = reflect.TypeOf(Enumerated(0))\n \tflagType             = reflect.TypeOf(Flag(false))\n-\ttimeType             = reflect.TypeOf(&time.Time{})\n+\ttimeType             = reflect.TypeOf(time.Time{})\n \trawValueType         = reflect.TypeOf(RawValue{})\n \trawContentsType      = reflect.TypeOf(RawContent(nil))\n \tbigIntType           = reflect.TypeOf(new(big.Int))\n@@ -647,7 +647,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\terr = err1\n \t\treturn\n \tcase timeType:\n-\t\tvar time *time.Time\n+\t\tvar time time.Time\n \t\tvar err1 error\n \t\tif universalTag == tagUTCTime {\n \t\t\ttime, err1 = parseUTCTime(innerBytes)\n@@ -799,7 +799,7 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n //\n // An ASN.1 ENUMERATED can be written to an Enumerated.\n //\n-// An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a *time.Time.\n+// An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n //\n // An ASN.1 PrintableString or IA5String can be written to a string.\n //"}, {"sha": "2e6fccf7b80cc3a4df128d0f42ec6162938198fe", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -202,43 +202,51 @@ func TestObjectIdentifier(t *testing.T) {\n type timeTest struct {\n \tin  string\n \tok  bool\n-\tout *time.Time\n+\tout time.Time\n }\n \n var utcTestData = []timeTest{\n-\t{\"910506164540-0700\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, -7 * 60 * 60, \"\"}},\n-\t{\"910506164540+0730\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 7*60*60 + 30*60, \"\"}},\n-\t{\"910506234540Z\", true, &time.Time{1991, 05, 06, 23, 45, 40, 0, 0, \"UTC\"}},\n-\t{\"9105062345Z\", true, &time.Time{1991, 05, 06, 23, 45, 0, 0, 0, \"UTC\"}},\n-\t{\"a10506234540Z\", false, nil},\n-\t{\"91a506234540Z\", false, nil},\n-\t{\"9105a6234540Z\", false, nil},\n-\t{\"910506a34540Z\", false, nil},\n-\t{\"910506334a40Z\", false, nil},\n-\t{\"91050633444aZ\", false, nil},\n-\t{\"910506334461Z\", false, nil},\n-\t{\"910506334400Za\", false, nil},\n+\t{\"910506164540-0700\", true, time.Date(1991, 05, 06, 16, 45, 40, 0, time.FixedZone(\"\", -7*60*60))},\n+\t{\"910506164540+0730\", true, time.Date(1991, 05, 06, 16, 45, 40, 0, time.FixedZone(\"\", 7*60*60+30*60))},\n+\t{\"910506234540Z\", true, time.Date(1991, 05, 06, 23, 45, 40, 0, time.UTC)},\n+\t{\"9105062345Z\", true, time.Date(1991, 05, 06, 23, 45, 0, 0, time.UTC)},\n+\t{\"a10506234540Z\", false, time.Time{}},\n+\t{\"91a506234540Z\", false, time.Time{}},\n+\t{\"9105a6234540Z\", false, time.Time{}},\n+\t{\"910506a34540Z\", false, time.Time{}},\n+\t{\"910506334a40Z\", false, time.Time{}},\n+\t{\"91050633444aZ\", false, time.Time{}},\n+\t{\"910506334461Z\", false, time.Time{}},\n+\t{\"910506334400Za\", false, time.Time{}},\n }\n \n func TestUTCTime(t *testing.T) {\n \tfor i, test := range utcTestData {\n \t\tret, err := parseUTCTime([]byte(test.in))\n-\t\tif (err == nil) != test.ok {\n-\t\t\tt.Errorf(\"#%d: Incorrect error result (did fail? %v, expected: %v)\", i, err == nil, test.ok)\n-\t\t}\n-\t\tif err == nil {\n-\t\t\tif !reflect.DeepEqual(test.out, ret) {\n-\t\t\t\tt.Errorf(\"#%d: Bad result: %v (expected %v)\", i, ret, test.out)\n+\t\tif err != nil {\n+\t\t\tif test.ok {\n+\t\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = error %v\", i, err)\n \t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !test.ok {\n+\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) succeeded, should have failed\", i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tconst format = \"Jan _2 15:04:05 -0700 2006\" // ignore zone name, just offset\n+\t\thave := ret.Format(format)\n+\t\twant := test.out.Format(format)\n+\t\tif have != want {\n+\t\t\tt.Errorf(\"#%d: parseUTCTime(%q) = %s, want %s\", test.in, have, want)\n \t\t}\n \t}\n }\n \n var generalizedTimeTestData = []timeTest{\n-\t{\"20100102030405Z\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, \"UTC\"}},\n-\t{\"20100102030405\", false, nil},\n-\t{\"20100102030405+0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 6*60*60 + 7*60, \"\"}},\n-\t{\"20100102030405-0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, -6*60*60 - 7*60, \"\"}},\n+\t{\"20100102030405Z\", true, time.Date(2010, 01, 02, 03, 04, 05, 0, time.UTC)},\n+\t{\"20100102030405\", false, time.Time{}},\n+\t{\"20100102030405+0607\", true, time.Date(2010, 01, 02, 03, 04, 05, 0, time.FixedZone(\"\", 6*60*60+7*60))},\n+\t{\"20100102030405-0607\", true, time.Date(2010, 01, 02, 03, 04, 05, 0, time.FixedZone(\"\", -6*60*60-7*60))},\n }\n \n func TestGeneralizedTime(t *testing.T) {\n@@ -407,7 +415,7 @@ type AttributeTypeAndValue struct {\n }\n \n type Validity struct {\n-\tNotBefore, NotAfter *time.Time\n+\tNotBefore, NotAfter time.Time\n }\n \n type PublicKeyInfo struct {\n@@ -475,7 +483,10 @@ var derEncodedSelfSignedCert = Certificate{\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 3}, Value: \"false.example.com\"}},\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{1, 2, 840, 113549, 1, 9, 1}, Value: \"false@example.com\"}},\n \t\t},\n-\t\tValidity: Validity{NotBefore: &time.Time{Year: 2009, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, ZoneOffset: 0, Zone: \"UTC\"}, NotAfter: &time.Time{Year: 2010, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, ZoneOffset: 0, Zone: \"UTC\"}},\n+\t\tValidity: Validity{\n+\t\t\tNotBefore: time.Date(2009, 10, 8, 00, 25, 53, 0, time.UTC),\n+\t\t\tNotAfter:  time.Date(2010, 10, 8, 00, 25, 53, 0, time.UTC),\n+\t\t},\n \t\tSubject: RDNSequence{\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 6}, Value: \"XX\"}},\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 8}, Value: \"Some-State\"}},"}, {"sha": "c181e43f9798bc893823ace212343bcb60fc9c14", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -288,60 +288,66 @@ func marshalTwoDigits(out *forkableWriter, v int) (err error) {\n \treturn out.WriteByte(byte('0' + v%10))\n }\n \n-func marshalUTCTime(out *forkableWriter, t *time.Time) (err error) {\n+func marshalUTCTime(out *forkableWriter, t time.Time) (err error) {\n+\tutc := t.UTC()\n+\tyear, month, day := utc.Date()\n+\n \tswitch {\n-\tcase 1950 <= t.Year && t.Year < 2000:\n-\t\terr = marshalTwoDigits(out, int(t.Year-1900))\n-\tcase 2000 <= t.Year && t.Year < 2050:\n-\t\terr = marshalTwoDigits(out, int(t.Year-2000))\n+\tcase 1950 <= year && year < 2000:\n+\t\terr = marshalTwoDigits(out, int(year-1900))\n+\tcase 2000 <= year && year < 2050:\n+\t\terr = marshalTwoDigits(out, int(year-2000))\n \tdefault:\n \t\treturn StructuralError{\"Cannot represent time as UTCTime\"}\n \t}\n-\n \tif err != nil {\n \t\treturn\n \t}\n \n-\terr = marshalTwoDigits(out, t.Month)\n+\terr = marshalTwoDigits(out, int(month))\n \tif err != nil {\n \t\treturn\n \t}\n \n-\terr = marshalTwoDigits(out, t.Day)\n+\terr = marshalTwoDigits(out, day)\n \tif err != nil {\n \t\treturn\n \t}\n \n-\terr = marshalTwoDigits(out, t.Hour)\n+\thour, min, sec := utc.Clock()\n+\n+\terr = marshalTwoDigits(out, hour)\n \tif err != nil {\n \t\treturn\n \t}\n \n-\terr = marshalTwoDigits(out, t.Minute)\n+\terr = marshalTwoDigits(out, min)\n \tif err != nil {\n \t\treturn\n \t}\n \n-\terr = marshalTwoDigits(out, t.Second)\n+\terr = marshalTwoDigits(out, sec)\n \tif err != nil {\n \t\treturn\n \t}\n \n+\t_, offset := t.Zone()\n+\n \tswitch {\n-\tcase t.ZoneOffset/60 == 0:\n+\tcase offset/60 == 0:\n \t\terr = out.WriteByte('Z')\n \t\treturn\n-\tcase t.ZoneOffset > 0:\n+\tcase offset > 0:\n \t\terr = out.WriteByte('+')\n-\tcase t.ZoneOffset < 0:\n+\tcase offset < 0:\n \t\terr = out.WriteByte('-')\n \t}\n \n \tif err != nil {\n \t\treturn\n \t}\n \n-\toffsetMinutes := t.ZoneOffset / 60\n+\toffsetMinutes := offset / 60\n \tif offsetMinutes < 0 {\n \t\toffsetMinutes = -offsetMinutes\n \t}\n@@ -366,7 +372,7 @@ func stripTagAndLength(in []byte) []byte {\n func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameters) (err error) {\n \tswitch value.Type() {\n \tcase timeType:\n-\t\treturn marshalUTCTime(out, value.Interface().(*time.Time))\n+\t\treturn marshalUTCTime(out, value.Interface().(time.Time))\n \tcase bitStringType:\n \t\treturn marshalBitString(out, value.Interface().(BitString))\n \tcase objectIdentifierType:"}, {"sha": "d05b5d8d4e92e398bd359b4258410d8f00a56abf", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -51,10 +51,7 @@ type optionalRawValueTest struct {\n \n type testSET []int\n \n-func setPST(t *time.Time) *time.Time {\n-\tt.ZoneOffset = -28800\n-\treturn t\n-}\n+var PST = time.FixedZone(\"PST\", -8*60*60)\n \n type marshalTest struct {\n \tin  interface{}\n@@ -73,9 +70,9 @@ var marshalTests = []marshalTest{\n \t{[]byte{1, 2, 3}, \"0403010203\"},\n \t{implicitTagTest{64}, \"3003850140\"},\n \t{explicitTagTest{64}, \"3005a503020140\"},\n-\t{time.SecondsToUTC(0), \"170d3730303130313030303030305a\"},\n-\t{time.SecondsToUTC(1258325776), \"170d3039313131353232353631365a\"},\n-\t{setPST(time.SecondsToUTC(1258325776)), \"17113039313131353232353631362d30383030\"},\n+\t{time.Unix(0, 0).UTC(), \"170d3730303130313030303030305a\"},\n+\t{time.Unix(1258325776, 0).UTC(), \"170d3039313131353232353631365a\"},\n+\t{time.Unix(1258325776, 0).In(PST), \"17113039313131353232353631362d30383030\"},\n \t{BitString{[]byte{0x80}, 1}, \"03020780\"},\n \t{BitString{[]byte{0x81, 0xf0}, 12}, \"03030481f0\"},\n \t{ObjectIdentifier([]int{1, 2, 3, 4}), \"06032a0304\"},\n@@ -123,7 +120,8 @@ func TestMarshal(t *testing.T) {\n \t\t}\n \t\tout, _ := hex.DecodeString(test.out)\n \t\tif bytes.Compare(out, data) != 0 {\n-\t\t\tt.Errorf(\"#%d got: %x want %x\", i, data, out)\n+\t\t\tt.Errorf(\"#%d got: %x want %x\\n\\t%q\\n\\t%q\", i, data, out, data, out)\n+\n \t\t}\n \t}\n }"}, {"sha": "14284f50e47b5bf7f47a505f6a0e7c62269645d8", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 66, "deletions": 23, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"runtime\"\n \t\"sort\"\n \t\"strconv\"\n+\t\"sync\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n@@ -295,38 +296,20 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \n \tcase reflect.Struct:\n \t\te.WriteByte('{')\n-\t\tt := v.Type()\n-\t\tn := v.NumField()\n \t\tfirst := true\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tf := t.Field(i)\n-\t\t\tif f.PkgPath != \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\ttag, omitEmpty, quoted := f.Name, false, false\n-\t\t\tif tv := f.Tag.Get(\"json\"); tv != \"\" {\n-\t\t\t\tif tv == \"-\" {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tname, opts := parseTag(tv)\n-\t\t\t\tif isValidTag(name) {\n-\t\t\t\t\ttag = name\n-\t\t\t\t}\n-\t\t\t\tomitEmpty = opts.Contains(\"omitempty\")\n-\t\t\t\tquoted = opts.Contains(\"string\")\n-\t\t\t}\n-\t\t\tfieldValue := v.Field(i)\n-\t\t\tif omitEmpty && isEmptyValue(fieldValue) {\n+\t\tfor _, ef := range encodeFields(v.Type()) {\n+\t\t\tfieldValue := v.Field(ef.i)\n+\t\t\tif ef.omitEmpty && isEmptyValue(fieldValue) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif first {\n \t\t\t\tfirst = false\n \t\t\t} else {\n \t\t\t\te.WriteByte(',')\n \t\t\t}\n-\t\t\te.string(tag)\n+\t\t\te.string(ef.tag)\n \t\t\te.WriteByte(':')\n-\t\t\te.reflectValueQuoted(fieldValue, quoted)\n+\t\t\te.reflectValueQuoted(fieldValue, ef.quoted)\n \t\t}\n \t\te.WriteByte('}')\n \n@@ -470,3 +453,63 @@ func (e *encodeState) string(s string) (int, error) {\n \te.WriteByte('\"')\n \treturn e.Len() - len0, nil\n }\n+\n+// encodeField contains information about how to encode a field of a\n+// struct.\n+type encodeField struct {\n+\ti         int // field index in struct\n+\ttag       string\n+\tquoted    bool\n+\tomitEmpty bool\n+}\n+\n+var (\n+\ttypeCacheLock     sync.RWMutex\n+\tencodeFieldsCache = make(map[reflect.Type][]encodeField)\n+)\n+\n+// encodeFields returns a slice of encodeField for a given\n+// struct type.\n+func encodeFields(t reflect.Type) []encodeField {\n+\ttypeCacheLock.RLock()\n+\tfs, ok := encodeFieldsCache[t]\n+\ttypeCacheLock.RUnlock()\n+\tif ok {\n+\t\treturn fs\n+\t}\n+\n+\ttypeCacheLock.Lock()\n+\tdefer typeCacheLock.Unlock()\n+\tfs, ok = encodeFieldsCache[t]\n+\tif ok {\n+\t\treturn fs\n+\t}\n+\n+\tv := reflect.Zero(t)\n+\tn := v.NumField()\n+\tfor i := 0; i < n; i++ {\n+\t\tf := t.Field(i)\n+\t\tif f.PkgPath != \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar ef encodeField\n+\t\tef.i = i\n+\t\tef.tag = f.Name\n+\n+\t\ttv := f.Tag.Get(\"json\")\n+\t\tif tv != \"\" {\n+\t\t\tif tv == \"-\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tname, opts := parseTag(tv)\n+\t\t\tif isValidTag(name) {\n+\t\t\t\tef.tag = name\n+\t\t\t}\n+\t\t\tef.omitEmpty = opts.Contains(\"omitempty\")\n+\t\t\tef.quoted = opts.Contains(\"string\")\n+\t\t}\n+\t\tfs = append(fs, ef)\n+\t}\n+\tencodeFieldsCache[t] = fs\n+\treturn fs\n+}"}, {"sha": "d67a299f5bb657e87c58b366efac3aef8d407e8c", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -61,7 +61,7 @@ type StartElement struct {\n \n func (e StartElement) Copy() StartElement {\n \tattrs := make([]Attr, len(e.Attr))\n-\tcopy(e.Attr, attrs)\n+\tcopy(attrs, e.Attr)\n \te.Attr = attrs\n \treturn e\n }"}, {"sha": "25ffc917dcb135c3e8068405af0510d6a2530ee7", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -29,83 +29,81 @@ const testInput = `\n </body><!-- missing final newline -->`\n \n var rawTokens = []Token{\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tProcInst{\"xml\", []byte(`version=\"1.0\" encoding=\"UTF-8\"`)},\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"`),\n-\t),\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tStartElement{Name{\"\", \"body\"}, []Attr{{Name{\"xmlns\", \"foo\"}, \"ns1\"}, {Name{\"\", \"xmlns\"}, \"ns2\"}, {Name{\"xmlns\", \"tag\"}, \"ns3\"}}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"\", \"hello\"}, []Attr{{Name{\"\", \"lang\"}, \"en\"}}},\n-\tCharData([]byte(\"World <>'\\\" \u767d\u9d6c\u7fd4\")),\n+\tCharData(\"World <>'\\\" \u767d\u9d6c\u7fd4\"),\n \tEndElement{Name{\"\", \"hello\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"\", \"goodbye\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"\", \"outer\"}, []Attr{{Name{\"foo\", \"attr\"}, \"value\"}, {Name{\"xmlns\", \"tag\"}, \"ns4\"}}},\n-\tCharData([]byte(\"\\n    \")),\n+\tCharData(\"\\n    \"),\n \tStartElement{Name{\"\", \"inner\"}, []Attr{}},\n \tEndElement{Name{\"\", \"inner\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tEndElement{Name{\"\", \"outer\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"tag\", \"name\"}, []Attr{}},\n-\tCharData([]byte(\"\\n    \")),\n-\tCharData([]byte(\"Some text here.\")),\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n    \"),\n+\tCharData(\"Some text here.\"),\n+\tCharData(\"\\n  \"),\n \tEndElement{Name{\"tag\", \"name\"}},\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tEndElement{Name{\"\", \"body\"}},\n-\tComment([]byte(\" missing final newline \")),\n+\tComment(\" missing final newline \"),\n }\n \n var cookedTokens = []Token{\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tProcInst{\"xml\", []byte(`version=\"1.0\" encoding=\"UTF-8\"`)},\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n   \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"`),\n-\t),\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tStartElement{Name{\"ns2\", \"body\"}, []Attr{{Name{\"xmlns\", \"foo\"}, \"ns1\"}, {Name{\"\", \"xmlns\"}, \"ns2\"}, {Name{\"xmlns\", \"tag\"}, \"ns3\"}}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"ns2\", \"hello\"}, []Attr{{Name{\"\", \"lang\"}, \"en\"}}},\n-\tCharData([]byte(\"World <>'\\\" \u767d\u9d6c\u7fd4\")),\n+\tCharData(\"World <>'\\\" \u767d\u9d6c\u7fd4\"),\n \tEndElement{Name{\"ns2\", \"hello\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"ns2\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"ns2\", \"goodbye\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"ns2\", \"outer\"}, []Attr{{Name{\"ns1\", \"attr\"}, \"value\"}, {Name{\"xmlns\", \"tag\"}, \"ns4\"}}},\n-\tCharData([]byte(\"\\n    \")),\n+\tCharData(\"\\n    \"),\n \tStartElement{Name{\"ns2\", \"inner\"}, []Attr{}},\n \tEndElement{Name{\"ns2\", \"inner\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tEndElement{Name{\"ns2\", \"outer\"}},\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n  \"),\n \tStartElement{Name{\"ns3\", \"name\"}, []Attr{}},\n-\tCharData([]byte(\"\\n    \")),\n-\tCharData([]byte(\"Some text here.\")),\n-\tCharData([]byte(\"\\n  \")),\n+\tCharData(\"\\n    \"),\n+\tCharData(\"Some text here.\"),\n+\tCharData(\"\\n  \"),\n \tEndElement{Name{\"ns3\", \"name\"}},\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tEndElement{Name{\"ns2\", \"body\"}},\n-\tComment([]byte(\" missing final newline \")),\n+\tComment(\" missing final newline \"),\n }\n \n const testInputAltEncoding = `\n <?xml version=\"1.0\" encoding=\"x-testing-uppercase\"?>\n <TAG>VALUE</TAG>`\n \n var rawTokensAltEncoding = []Token{\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tProcInst{\"xml\", []byte(`version=\"1.0\" encoding=\"x-testing-uppercase\"`)},\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n \tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n-\tCharData([]byte(\"value\")),\n+\tCharData(\"value\"),\n \tEndElement{Name{\"\", \"tag\"}},\n }\n \n@@ -270,21 +268,21 @@ var nestedDirectivesInput = `\n `\n \n var nestedDirectivesTokens = []Token{\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY rdf \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt \">\">]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt \"<\">]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt '>'>]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt '<'>]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt '\">'>]`)),\n-\tCharData([]byte(\"\\n\")),\n-\tDirective([]byte(`DOCTYPE [<!ENTITY xlt \"'<\">]`)),\n-\tCharData([]byte(\"\\n\")),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY rdf \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt \">\">]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt \"<\">]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt '>'>]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt '<'>]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt '\">'>]`),\n+\tCharData(\"\\n\"),\n+\tDirective(`DOCTYPE [<!ENTITY xlt \"'<\">]`),\n+\tCharData(\"\\n\"),\n }\n \n func TestNestedDirectives(t *testing.T) {\n@@ -488,10 +486,13 @@ func TestCopyTokenStartElement(t *testing.T) {\n \telt := StartElement{Name{\"\", \"hello\"}, []Attr{{Name{\"\", \"lang\"}, \"en\"}}}\n \tvar tok1 Token = elt\n \ttok2 := CopyToken(tok1)\n+\tif tok1.(StartElement).Attr[0].Value != \"en\" {\n+\t\tt.Error(\"CopyToken overwrote Attr[0]\")\n+\t}\n \tif !reflect.DeepEqual(tok1, tok2) {\n \t\tt.Error(\"CopyToken(StartElement) != StartElement\")\n \t}\n-\telt.Attr[0] = Attr{Name{\"\", \"lang\"}, \"de\"}\n+\ttok1.(StartElement).Attr[0] = Attr{Name{\"\", \"lang\"}, \"de\"}\n \tif reflect.DeepEqual(tok1, tok2) {\n \t\tt.Error(\"CopyToken(CharData) uses same buffer.\")\n \t}"}, {"sha": "a2a9361866da418b44b8c318d93ee21b3efc4c94", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -150,15 +150,15 @@ func processFiles(filenames []string, allFiles bool) {\n \t\tswitch info, err := os.Stat(filename); {\n \t\tcase err != nil:\n \t\t\treport(err)\n-\t\tcase info.IsRegular():\n-\t\t\tif allFiles || isGoFilename(info.Name) {\n-\t\t\t\tfilenames[i] = filename\n-\t\t\t\ti++\n-\t\t\t}\n-\t\tcase info.IsDirectory():\n+\t\tcase info.IsDir():\n \t\t\tif allFiles || *recursive {\n \t\t\t\tprocessDirectory(filename)\n \t\t\t}\n+\t\tdefault:\n+\t\t\tif allFiles || isGoFilename(info.Name()) {\n+\t\t\t\tfilenames[i] = filename\n+\t\t\t\ti++\n+\t\t\t}\n \t\t}\n \t}\n \tfset := token.NewFileSet()"}, {"sha": "a69f83a1f509525849a77c58957bb4e90fe5a2aa", "filename": "libgo/go/exp/gui/gui.go", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fgui.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2009 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package gui defines a basic graphical user interface programming model.\n-package gui\n-\n-import (\n-\t\"image\"\n-\t\"image/draw\"\n-)\n-\n-// A Window represents a single graphics window.\n-type Window interface {\n-\t// Screen returns an editable Image for the window.\n-\tScreen() draw.Image\n-\t// FlushImage flushes changes made to Screen() back to screen.\n-\tFlushImage()\n-\t// EventChan returns a channel carrying UI events such as key presses,\n-\t// mouse movements and window resizes.\n-\tEventChan() <-chan interface{}\n-\t// Close closes the window.\n-\tClose() error\n-}\n-\n-// A KeyEvent is sent for a key press or release.\n-type KeyEvent struct {\n-\t// The value k represents key k being pressed.\n-\t// The value -k represents key k being released.\n-\t// The specific set of key values is not specified,\n-\t// but ordinary characters represent themselves.\n-\tKey int\n-}\n-\n-// A MouseEvent is sent for a button press or release or for a mouse movement.\n-type MouseEvent struct {\n-\t// Buttons is a bit mask of buttons: 1<<0 is left, 1<<1 middle, 1<<2 right.\n-\t// It represents button state and not necessarily the state delta: bit 0\n-\t// being on means that the left mouse button is down, but does not imply\n-\t// that the same button was up in the previous MouseEvent.\n-\tButtons int\n-\t// Loc is the location of the cursor.\n-\tLoc image.Point\n-\t// Nsec is the event's timestamp.\n-\tNsec int64\n-}\n-\n-// A ConfigEvent is sent each time the window's color model or size changes.\n-// The client should respond by calling Window.Screen to obtain a new image.\n-type ConfigEvent struct {\n-\tConfig image.Config\n-}\n-\n-// An ErrEvent is sent when an error occurs.\n-type ErrEvent struct {\n-\tErr error\n-}"}, {"sha": "24e941cb36bd837290e330ecb63af81e9d527477", "filename": "libgo/go/exp/gui/x11/auth.go", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fauth.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package x11\n-\n-import (\n-\t\"bufio\"\n-\t\"errors\"\n-\t\"io\"\n-\t\"os\"\n-)\n-\n-// readU16BE reads a big-endian uint16 from r, using b as a scratch buffer.\n-func readU16BE(r io.Reader, b []byte) (uint16, error) {\n-\t_, err := io.ReadFull(r, b[0:2])\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn uint16(b[0])<<8 + uint16(b[1]), nil\n-}\n-\n-// readStr reads a length-prefixed string from r, using b as a scratch buffer.\n-func readStr(r io.Reader, b []byte) (string, error) {\n-\tn, err := readU16BE(r, b)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif int(n) > len(b) {\n-\t\treturn \"\", errors.New(\"Xauthority entry too long for buffer\")\n-\t}\n-\t_, err = io.ReadFull(r, b[0:n])\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\treturn string(b[0:n]), nil\n-}\n-\n-// readAuth reads the X authority file and returns the name/data pair for the display.\n-// displayStr is the \"12\" out of a $DISPLAY like \":12.0\".\n-func readAuth(displayStr string) (name, data string, err error) {\n-\t// b is a scratch buffer to use and should be at least 256 bytes long\n-\t// (i.e. it should be able to hold a hostname).\n-\tvar b [256]byte\n-\t// As per /usr/include/X11/Xauth.h.\n-\tconst familyLocal = 256\n-\n-\tfn := os.Getenv(\"XAUTHORITY\")\n-\tif fn == \"\" {\n-\t\thome := os.Getenv(\"HOME\")\n-\t\tif home == \"\" {\n-\t\t\terr = errors.New(\"Xauthority not found: $XAUTHORITY, $HOME not set\")\n-\t\t\treturn\n-\t\t}\n-\t\tfn = home + \"/.Xauthority\"\n-\t}\n-\tr, err := os.Open(fn)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer r.Close()\n-\tbr := bufio.NewReader(r)\n-\n-\thostname, err := os.Hostname()\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tfor {\n-\t\tvar family uint16\n-\t\tvar addr, disp, name0, data0 string\n-\t\tfamily, err = readU16BE(br, b[0:2])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\taddr, err = readStr(br, b[0:])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tdisp, err = readStr(br, b[0:])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tname0, err = readStr(br, b[0:])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tdata0, err = readStr(br, b[0:])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif family == familyLocal && addr == hostname && disp == displayStr {\n-\t\t\treturn name0, data0, nil\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "15afc657ecbd6a259e6e85fcd9bf919c3b794b8b", "filename": "libgo/go/exp/gui/x11/conn.go", "status": "removed", "additions": 0, "deletions": 631, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,631 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package x11 implements an X11 backend for the exp/gui package.\n-//\n-// The X protocol specification is at ftp://ftp.x.org/pub/X11R7.0/doc/PDF/proto.pdf.\n-// A summary of the wire format can be found in XCB's xproto.xml.\n-package x11\n-\n-import (\n-\t\"bufio\"\n-\t\"errors\"\n-\t\"exp/gui\"\n-\t\"image\"\n-\t\"image/draw\"\n-\t\"io\"\n-\t\"log\"\n-\t\"net\"\n-\t\"os\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"time\"\n-)\n-\n-type resID uint32 // X resource IDs.\n-\n-// TODO(nigeltao): Handle window resizes.\n-const (\n-\twindowHeight = 600\n-\twindowWidth  = 800\n-)\n-\n-const (\n-\tkeymapLo = 8\n-\tkeymapHi = 255\n-)\n-\n-type conn struct {\n-\tc io.Closer\n-\tr *bufio.Reader\n-\tw *bufio.Writer\n-\n-\tgc, window, root, visual resID\n-\n-\timg        *image.RGBA\n-\teventc     chan interface{}\n-\tmouseState gui.MouseEvent\n-\n-\tbuf [256]byte // General purpose scratch buffer.\n-\n-\tflush     chan bool\n-\tflushBuf0 [24]byte\n-\tflushBuf1 [4 * 1024]byte\n-}\n-\n-// writeSocket runs in its own goroutine, serving both FlushImage calls\n-// directly from the exp/gui client and indirectly from X expose events.\n-// It paints c.img to the X server via PutImage requests.\n-func (c *conn) writeSocket() {\n-\tdefer c.c.Close()\n-\tfor _ = range c.flush {\n-\t\tb := c.img.Bounds()\n-\t\tif b.Empty() {\n-\t\t\tcontinue\n-\t\t}\n-\t\t// Each X request has a 16-bit length (in terms of 4-byte units). To avoid going over\n-\t\t// this limit, we send PutImage for each row of the image, rather than trying to paint\n-\t\t// the entire image in one X request. This approach could easily be optimized (or the\n-\t\t// X protocol may have an escape sequence to delimit very large requests).\n-\t\t// TODO(nigeltao): See what XCB's xcb_put_image does in this situation.\n-\t\tunits := 6 + b.Dx()\n-\t\tif units > 0xffff || b.Dy() > 0xffff {\n-\t\t\tlog.Print(\"x11: window is too large for PutImage\")\n-\t\t\treturn\n-\t\t}\n-\n-\t\tc.flushBuf0[0] = 0x48 // PutImage opcode.\n-\t\tc.flushBuf0[1] = 0x02 // XCB_IMAGE_FORMAT_Z_PIXMAP.\n-\t\tc.flushBuf0[2] = uint8(units)\n-\t\tc.flushBuf0[3] = uint8(units >> 8)\n-\t\tsetU32LE(c.flushBuf0[4:8], uint32(c.window))\n-\t\tsetU32LE(c.flushBuf0[8:12], uint32(c.gc))\n-\t\tsetU32LE(c.flushBuf0[12:16], 1<<16|uint32(b.Dx()))\n-\t\tc.flushBuf0[21] = 0x18 // depth = 24 bits.\n-\n-\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n-\t\t\tsetU32LE(c.flushBuf0[16:20], uint32(y<<16))\n-\t\t\tif _, err := c.w.Write(c.flushBuf0[:24]); err != nil {\n-\t\t\t\tif err != io.EOF {\n-\t\t\t\t\tlog.Println(\"x11:\", err)\n-\t\t\t\t}\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tp := c.img.Pix[(y-b.Min.Y)*c.img.Stride:]\n-\t\t\tfor x, dx := 0, 4*b.Dx(); x < dx; {\n-\t\t\t\tnx := dx - x\n-\t\t\t\tif nx > len(c.flushBuf1) {\n-\t\t\t\t\tnx = len(c.flushBuf1) &^ 3\n-\t\t\t\t}\n-\t\t\t\tfor i := 0; i < nx; i += 4 {\n-\t\t\t\t\t// X11's order is BGRX, not RGBA.\n-\t\t\t\t\tc.flushBuf1[i+0] = p[x+i+2]\n-\t\t\t\t\tc.flushBuf1[i+1] = p[x+i+1]\n-\t\t\t\t\tc.flushBuf1[i+2] = p[x+i+0]\n-\t\t\t\t}\n-\t\t\t\tx += nx\n-\t\t\t\tif _, err := c.w.Write(c.flushBuf1[:nx]); err != nil {\n-\t\t\t\t\tif err != io.EOF {\n-\t\t\t\t\t\tlog.Println(\"x11:\", err)\n-\t\t\t\t\t}\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif err := c.w.Flush(); err != nil {\n-\t\t\tif err != io.EOF {\n-\t\t\t\tlog.Println(\"x11:\", err)\n-\t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t}\n-}\n-\n-func (c *conn) Screen() draw.Image { return c.img }\n-\n-func (c *conn) FlushImage() {\n-\tselect {\n-\tcase c.flush <- false:\n-\t\t// Flush notification sent.\n-\tdefault:\n-\t\t// Could not send.\n-\t\t// Flush notification must be pending already.\n-\t}\n-}\n-\n-func (c *conn) Close() error {\n-\t// Shut down the writeSocket goroutine. This will close the socket to the\n-\t// X11 server, which will cause c.eventc to close.\n-\tclose(c.flush)\n-\tfor _ = range c.eventc {\n-\t\t// Drain the channel to allow the readSocket goroutine to shut down.\n-\t}\n-\treturn nil\n-}\n-\n-func (c *conn) EventChan() <-chan interface{} { return c.eventc }\n-\n-// readSocket runs in its own goroutine, reading X events and sending gui\n-// events on c's EventChan.\n-func (c *conn) readSocket() {\n-\tvar (\n-\t\tkeymap            [256][]int\n-\t\tkeysymsPerKeycode int\n-\t)\n-\tdefer close(c.eventc)\n-\tfor {\n-\t\t// X events are always 32 bytes long.\n-\t\tif _, err := io.ReadFull(c.r, c.buf[:32]); err != nil {\n-\t\t\tif err != io.EOF {\n-\t\t\t\tc.eventc <- gui.ErrEvent{err}\n-\t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tswitch c.buf[0] {\n-\t\tcase 0x01: // Reply from a request (e.g. GetKeyboardMapping).\n-\t\t\tcookie := int(c.buf[3])<<8 | int(c.buf[2])\n-\t\t\tif cookie != 1 {\n-\t\t\t\t// We issued only one request (GetKeyboardMapping) with a cookie of 1,\n-\t\t\t\t// so we shouldn't get any other reply from the X server.\n-\t\t\t\tc.eventc <- gui.ErrEvent{errors.New(\"x11: unexpected cookie\")}\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tkeysymsPerKeycode = int(c.buf[1])\n-\t\t\tb := make([]int, 256*keysymsPerKeycode)\n-\t\t\tfor i := range keymap {\n-\t\t\t\tkeymap[i] = b[i*keysymsPerKeycode : (i+1)*keysymsPerKeycode]\n-\t\t\t}\n-\t\t\tfor i := keymapLo; i <= keymapHi; i++ {\n-\t\t\t\tm := keymap[i]\n-\t\t\t\tfor j := range m {\n-\t\t\t\t\tu, err := readU32LE(c.r, c.buf[:4])\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tif err != io.EOF {\n-\t\t\t\t\t\t\tc.eventc <- gui.ErrEvent{err}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn\n-\t\t\t\t\t}\n-\t\t\t\t\tm[j] = int(u)\n-\t\t\t\t}\n-\t\t\t}\n-\t\tcase 0x02, 0x03: // Key press, key release.\n-\t\t\t// X Keyboard Encoding is documented at http://tronche.com/gui/x/xlib/input/keyboard-encoding.html\n-\t\t\t// TODO(nigeltao): Do we need to implement the \"MODE SWITCH / group modifier\" feature\n-\t\t\t// or is that some no-longer-used X construct?\n-\t\t\tif keysymsPerKeycode < 2 {\n-\t\t\t\t// Either we haven't yet received the GetKeyboardMapping reply or\n-\t\t\t\t// the X server has sent one that's too short.\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tkeycode := int(c.buf[1])\n-\t\t\tshift := int(c.buf[28]) & 0x01\n-\t\t\tkeysym := keymap[keycode][shift]\n-\t\t\tif keysym == 0 {\n-\t\t\t\tkeysym = keymap[keycode][0]\n-\t\t\t}\n-\t\t\t// TODO(nigeltao): Should we send KeyEvents for Shift/Ctrl/Alt? Should Shift-A send\n-\t\t\t// the same int down the channel as the sent on just the A key?\n-\t\t\t// TODO(nigeltao): How should IME events (e.g. key presses that should generate CJK text) work? Or\n-\t\t\t// is that outside the scope of the gui.Window interface?\n-\t\t\tif c.buf[0] == 0x03 {\n-\t\t\t\tkeysym = -keysym\n-\t\t\t}\n-\t\t\tc.eventc <- gui.KeyEvent{keysym}\n-\t\tcase 0x04, 0x05: // Button press, button release.\n-\t\t\tmask := 1 << (c.buf[1] - 1)\n-\t\t\tif c.buf[0] == 0x04 {\n-\t\t\t\tc.mouseState.Buttons |= mask\n-\t\t\t} else {\n-\t\t\t\tc.mouseState.Buttons &^= mask\n-\t\t\t}\n-\t\t\tc.mouseState.Nsec = time.Nanoseconds()\n-\t\t\tc.eventc <- c.mouseState\n-\t\tcase 0x06: // Motion notify.\n-\t\t\tc.mouseState.Loc.X = int(int16(c.buf[25])<<8 | int16(c.buf[24]))\n-\t\t\tc.mouseState.Loc.Y = int(int16(c.buf[27])<<8 | int16(c.buf[26]))\n-\t\t\tc.mouseState.Nsec = time.Nanoseconds()\n-\t\t\tc.eventc <- c.mouseState\n-\t\tcase 0x0c: // Expose.\n-\t\t\t// A single user action could trigger multiple expose events (e.g. if moving another\n-\t\t\t// window with XShape'd rounded corners over our window). In that case, the X server will\n-\t\t\t// send a uint16 count (in bytes 16-17) of the number of additional expose events coming.\n-\t\t\t// We could parse each event for the (x, y, width, height) and maintain a minimal dirty\n-\t\t\t// rectangle, but for now, the simplest approach is to paint the entire window, when\n-\t\t\t// receiving the final event in the series.\n-\t\t\tif c.buf[17] == 0 && c.buf[16] == 0 {\n-\t\t\t\t// TODO(nigeltao): Should we ignore the very first expose event? A freshly mapped window\n-\t\t\t\t// will trigger expose, but until the first c.FlushImage call, there's probably nothing to\n-\t\t\t\t// paint but black. For an 800x600 window, at 4 bytes per pixel, each repaint writes about\n-\t\t\t\t// 2MB over the socket.\n-\t\t\t\tc.FlushImage()\n-\t\t\t}\n-\t\t\t// TODO(nigeltao): Should we listen to DestroyNotify (0x11) and ResizeRequest (0x19) events?\n-\t\t\t// What about EnterNotify (0x07) and LeaveNotify (0x08)?\n-\t\t}\n-\t}\n-}\n-\n-// connect connects to the X server given by the full X11 display name (e.g.\n-// \":12.0\") and returns the connection as well as the portion of the full name\n-// that is the display number (e.g. \"12\").\n-// Examples:\n-//\tconnect(\":1\")                 // calls net.Dial(\"unix\", \"\", \"/tmp/.X11-unix/X1\"), displayStr=\"1\"\n-//\tconnect(\"/tmp/launch-123/:0\") // calls net.Dial(\"unix\", \"\", \"/tmp/launch-123/:0\"), displayStr=\"0\"\n-//\tconnect(\"hostname:2.1\")       // calls net.Dial(\"tcp\", \"\", \"hostname:6002\"), displayStr=\"2\"\n-//\tconnect(\"tcp/hostname:1.0\")   // calls net.Dial(\"tcp\", \"\", \"hostname:6001\"), displayStr=\"1\"\n-func connect(display string) (conn net.Conn, displayStr string, err error) {\n-\tcolonIdx := strings.LastIndex(display, \":\")\n-\tif colonIdx < 0 {\n-\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n-\t}\n-\t// Parse the section before the colon.\n-\tvar protocol, host, socket string\n-\tif display[0] == '/' {\n-\t\tsocket = display[:colonIdx]\n-\t} else {\n-\t\tif i := strings.LastIndex(display, \"/\"); i < 0 {\n-\t\t\t// The default protocol is TCP.\n-\t\t\tprotocol = \"tcp\"\n-\t\t\thost = display[:colonIdx]\n-\t\t} else {\n-\t\t\tprotocol = display[:i]\n-\t\t\thost = display[i+1 : colonIdx]\n-\t\t}\n-\t}\n-\t// Parse the section after the colon.\n-\tafter := display[colonIdx+1:]\n-\tif after == \"\" {\n-\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n-\t}\n-\tif i := strings.LastIndex(after, \".\"); i < 0 {\n-\t\tdisplayStr = after\n-\t} else {\n-\t\tdisplayStr = after[:i]\n-\t}\n-\tdisplayInt, err := strconv.Atoi(displayStr)\n-\tif err != nil || displayInt < 0 {\n-\t\treturn nil, \"\", errors.New(\"bad display: \" + display)\n-\t}\n-\t// Make the connection.\n-\tif socket != \"\" {\n-\t\tconn, err = net.Dial(\"unix\", socket+\":\"+displayStr)\n-\t} else if host != \"\" {\n-\t\tconn, err = net.Dial(protocol, host+\":\"+strconv.Itoa(6000+displayInt))\n-\t} else {\n-\t\tconn, err = net.Dial(\"unix\", \"/tmp/.X11-unix/X\"+displayStr)\n-\t}\n-\tif err != nil {\n-\t\treturn nil, \"\", errors.New(\"cannot connect to \" + display + \": \" + err.Error())\n-\t}\n-\treturn\n-}\n-\n-// authenticate authenticates ourselves with the X server.\n-// displayStr is the \"12\" out of \":12.0\".\n-func authenticate(w *bufio.Writer, displayStr string) error {\n-\tkey, value, err := readAuth(displayStr)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Assume that the authentication protocol is \"MIT-MAGIC-COOKIE-1\".\n-\tif len(key) != 18 || len(value) != 16 {\n-\t\treturn errors.New(\"unsupported Xauth\")\n-\t}\n-\t// 0x006c means little-endian. 0x000b, 0x0000 means X major version 11, minor version 0.\n-\t// 0x0012 and 0x0010 means the auth key and value have lengths 18 and 16.\n-\t// The final 0x0000 is padding, so that the string length is a multiple of 4.\n-\t_, err = io.WriteString(w, \"\\x6c\\x00\\x0b\\x00\\x00\\x00\\x12\\x00\\x10\\x00\\x00\\x00\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t_, err = io.WriteString(w, key)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Again, the 0x0000 is padding.\n-\t_, err = io.WriteString(w, \"\\x00\\x00\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t_, err = io.WriteString(w, value)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = w.Flush()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-// readU8 reads a uint8 from r, using b as a scratch buffer.\n-func readU8(r io.Reader, b []byte) (uint8, error) {\n-\t_, err := io.ReadFull(r, b[:1])\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn uint8(b[0]), nil\n-}\n-\n-// readU16LE reads a little-endian uint16 from r, using b as a scratch buffer.\n-func readU16LE(r io.Reader, b []byte) (uint16, error) {\n-\t_, err := io.ReadFull(r, b[:2])\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn uint16(b[0]) | uint16(b[1])<<8, nil\n-}\n-\n-// readU32LE reads a little-endian uint32 from r, using b as a scratch buffer.\n-func readU32LE(r io.Reader, b []byte) (uint32, error) {\n-\t_, err := io.ReadFull(r, b[:4])\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, nil\n-}\n-\n-// setU32LE sets b[:4] to be the little-endian representation of u.\n-func setU32LE(b []byte, u uint32) {\n-\tb[0] = byte((u >> 0) & 0xff)\n-\tb[1] = byte((u >> 8) & 0xff)\n-\tb[2] = byte((u >> 16) & 0xff)\n-\tb[3] = byte((u >> 24) & 0xff)\n-}\n-\n-// checkPixmapFormats checks that we have an agreeable X pixmap Format.\n-func checkPixmapFormats(r io.Reader, b []byte, n int) (agree bool, err error) {\n-\tfor i := 0; i < n; i++ {\n-\t\t_, err = io.ReadFull(r, b[:8])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\t// Byte 0 is depth, byte 1 is bits-per-pixel, byte 2 is scanline-pad, the rest (5) is padding.\n-\t\tif b[0] == 24 && b[1] == 32 {\n-\t\t\tagree = true\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// checkDepths checks that we have an agreeable X Depth (i.e. one that has an agreeable X VisualType).\n-func checkDepths(r io.Reader, b []byte, n int, visual uint32) (agree bool, err error) {\n-\tfor i := 0; i < n; i++ {\n-\t\tvar depth, visualsLen uint16\n-\t\tdepth, err = readU16LE(r, b)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tdepth &= 0xff\n-\t\tvisualsLen, err = readU16LE(r, b)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\t// Ignore 4 bytes of padding.\n-\t\t_, err = io.ReadFull(r, b[:4])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tfor j := 0; j < int(visualsLen); j++ {\n-\t\t\t// Read 24 bytes: visual(4), class(1), bits per rgb value(1), colormap entries(2),\n-\t\t\t// red mask(4), green mask(4), blue mask(4), padding(4).\n-\t\t\tv, _ := readU32LE(r, b)\n-\t\t\t_, _ = readU32LE(r, b)\n-\t\t\trm, _ := readU32LE(r, b)\n-\t\t\tgm, _ := readU32LE(r, b)\n-\t\t\tbm, _ := readU32LE(r, b)\n-\t\t\t_, err = readU32LE(r, b)\n-\t\t\tif err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif v == visual && rm == 0xff0000 && gm == 0xff00 && bm == 0xff && depth == 24 {\n-\t\t\t\tagree = true\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// checkScreens checks that we have an agreeable X Screen.\n-func checkScreens(r io.Reader, b []byte, n int) (root, visual uint32, err error) {\n-\tfor i := 0; i < n; i++ {\n-\t\tvar root0, visual0, x uint32\n-\t\troot0, err = readU32LE(r, b)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\t// Ignore the next 7x4 bytes, which is: colormap, whitepixel, blackpixel, current input masks,\n-\t\t// width and height (pixels), width and height (mm), min and max installed maps.\n-\t\t_, err = io.ReadFull(r, b[:28])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tvisual0, err = readU32LE(r, b)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\t// Next 4 bytes: backing stores, save unders, root depth, allowed depths length.\n-\t\tx, err = readU32LE(r, b)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tnDepths := int(x >> 24)\n-\t\tvar agree bool\n-\t\tagree, err = checkDepths(r, b, nDepths, visual0)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif agree && root == 0 {\n-\t\t\troot = root0\n-\t\t\tvisual = visual0\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// handshake performs the protocol handshake with the X server, and ensures\n-// that the server provides a compatible Screen, Depth, etc.\n-func (c *conn) handshake() error {\n-\t_, err := io.ReadFull(c.r, c.buf[:8])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Byte 0 should be 1 (success), bytes 2:6 should be 0xb0000000 (major/minor version 11.0).\n-\tif c.buf[0] != 1 || c.buf[2] != 11 || c.buf[3] != 0 || c.buf[4] != 0 || c.buf[5] != 0 {\n-\t\treturn errors.New(\"unsupported X version\")\n-\t}\n-\t// Ignore the release number.\n-\t_, err = io.ReadFull(c.r, c.buf[:4])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Read the resource ID base.\n-\tresourceIdBase, err := readU32LE(c.r, c.buf[:4])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Read the resource ID mask.\n-\tresourceIdMask, err := readU32LE(c.r, c.buf[:4])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif resourceIdMask < 256 {\n-\t\treturn errors.New(\"X resource ID mask is too small\")\n-\t}\n-\t// Ignore the motion buffer size.\n-\t_, err = io.ReadFull(c.r, c.buf[:4])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Read the vendor length and round it up to a multiple of 4,\n-\t// for X11 protocol alignment reasons.\n-\tvendorLen, err := readU16LE(c.r, c.buf[:2])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tvendorLen = (vendorLen + 3) &^ 3\n-\t// Read the maximum request length.\n-\tmaxReqLen, err := readU16LE(c.r, c.buf[:2])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif maxReqLen != 0xffff {\n-\t\treturn errors.New(\"unsupported X maximum request length\")\n-\t}\n-\t// Read the roots length.\n-\trootsLen, err := readU8(c.r, c.buf[:1])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Read the pixmap formats length.\n-\tpixmapFormatsLen, err := readU8(c.r, c.buf[:1])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Ignore some things that we don't care about (totaling 10 + vendorLen bytes):\n-\t// imageByteOrder(1), bitmapFormatBitOrder(1), bitmapFormatScanlineUnit(1) bitmapFormatScanlinePad(1),\n-\t// minKeycode(1), maxKeycode(1), padding(4), vendor (vendorLen).\n-\tif 10+int(vendorLen) > cap(c.buf) {\n-\t\treturn errors.New(\"unsupported X vendor\")\n-\t}\n-\t_, err = io.ReadFull(c.r, c.buf[:10+int(vendorLen)])\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Check that we have an agreeable pixmap format.\n-\tagree, err := checkPixmapFormats(c.r, c.buf[:8], int(pixmapFormatsLen))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif !agree {\n-\t\treturn errors.New(\"unsupported X pixmap formats\")\n-\t}\n-\t// Check that we have an agreeable screen.\n-\troot, visual, err := checkScreens(c.r, c.buf[:24], int(rootsLen))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif root == 0 || visual == 0 {\n-\t\treturn errors.New(\"unsupported X screen\")\n-\t}\n-\tc.gc = resID(resourceIdBase)\n-\tc.window = resID(resourceIdBase + 1)\n-\tc.root = resID(root)\n-\tc.visual = resID(visual)\n-\treturn nil\n-}\n-\n-// NewWindow calls NewWindowDisplay with $DISPLAY.\n-func NewWindow() (gui.Window, error) {\n-\tdisplay := os.Getenv(\"DISPLAY\")\n-\tif len(display) == 0 {\n-\t\treturn nil, errors.New(\"$DISPLAY not set\")\n-\t}\n-\treturn NewWindowDisplay(display)\n-}\n-\n-// NewWindowDisplay returns a new gui.Window, backed by a newly created and\n-// mapped X11 window. The X server to connect to is specified by the display\n-// string, such as \":1\".\n-func NewWindowDisplay(display string) (gui.Window, error) {\n-\tsocket, displayStr, err := connect(display)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tc := new(conn)\n-\tc.c = socket\n-\tc.r = bufio.NewReader(socket)\n-\tc.w = bufio.NewWriter(socket)\n-\terr = authenticate(c.w, displayStr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\terr = c.handshake()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\t// Now that we're connected, show a window, via three X protocol messages.\n-\t// First, issue a GetKeyboardMapping request. This is the first request, and\n-\t// will be associated with a cookie of 1.\n-\tsetU32LE(c.buf[0:4], 0x00020065) // 0x65 is the GetKeyboardMapping opcode, and the message is 2 x 4 bytes long.\n-\tsetU32LE(c.buf[4:8], uint32((keymapHi-keymapLo+1)<<8|keymapLo))\n-\t// Second, create a graphics context (GC).\n-\tsetU32LE(c.buf[8:12], 0x00060037) // 0x37 is the CreateGC opcode, and the message is 6 x 4 bytes long.\n-\tsetU32LE(c.buf[12:16], uint32(c.gc))\n-\tsetU32LE(c.buf[16:20], uint32(c.root))\n-\tsetU32LE(c.buf[20:24], 0x00010004) // Bit 2 is XCB_GC_FOREGROUND, bit 16 is XCB_GC_GRAPHICS_EXPOSURES.\n-\tsetU32LE(c.buf[24:28], 0x00000000) // The Foreground is black.\n-\tsetU32LE(c.buf[28:32], 0x00000000) // GraphicsExposures' value is unused.\n-\t// Third, create the window.\n-\tsetU32LE(c.buf[32:36], 0x000a0001) // 0x01 is the CreateWindow opcode, and the message is 10 x 4 bytes long.\n-\tsetU32LE(c.buf[36:40], uint32(c.window))\n-\tsetU32LE(c.buf[40:44], uint32(c.root))\n-\tsetU32LE(c.buf[44:48], 0x00000000) // Initial (x, y) is (0, 0).\n-\tsetU32LE(c.buf[48:52], windowHeight<<16|windowWidth)\n-\tsetU32LE(c.buf[52:56], 0x00010000) // Border width is 0, XCB_WINDOW_CLASS_INPUT_OUTPUT is 1.\n-\tsetU32LE(c.buf[56:60], uint32(c.visual))\n-\tsetU32LE(c.buf[60:64], 0x00000802) // Bit 1 is XCB_CW_BACK_PIXEL, bit 11 is XCB_CW_EVENT_MASK.\n-\tsetU32LE(c.buf[64:68], 0x00000000) // The Back-Pixel is black.\n-\tsetU32LE(c.buf[68:72], 0x0000804f) // Key/button press and release, pointer motion, and expose event masks.\n-\t// Fourth, map the window.\n-\tsetU32LE(c.buf[72:76], 0x00020008) // 0x08 is the MapWindow opcode, and the message is 2 x 4 bytes long.\n-\tsetU32LE(c.buf[76:80], uint32(c.window))\n-\t// Write the bytes.\n-\t_, err = c.w.Write(c.buf[:80])\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\terr = c.w.Flush()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tc.img = image.NewRGBA(image.Rect(0, 0, windowWidth, windowHeight))\n-\tc.eventc = make(chan interface{}, 16)\n-\tc.flush = make(chan bool, 1)\n-\tgo c.readSocket()\n-\tgo c.writeSocket()\n-\treturn c, nil\n-}"}, {"sha": "f0bcca291065d17c058b1cca1ba27d2ea5f5ad03", "filename": "libgo/go/exp/sql/driver/driver.go", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,7 +7,7 @@\n //\n // Code simply using databases should use package sql.\n //\n-// Drivers only need to be aware of a subset of Go's types.  The db package\n+// Drivers only need to be aware of a subset of Go's types.  The sql package\n // will convert all types into one of the following:\n //\n //   int64\n@@ -94,12 +94,35 @@ type Result interface {\n // used by multiple goroutines concurrently.\n type Stmt interface {\n \t// Close closes the statement.\n+\t//\n+\t// Closing a statement should not interrupt any outstanding\n+\t// query created from that statement. That is, the following\n+\t// order of operations is valid:\n+\t//\n+\t//  * create a driver statement\n+\t//  * call Query on statement, returning Rows\n+\t//  * close the statement\n+\t//  * read from Rows\n+\t//\n+\t// If closing a statement invalidates currently-running\n+\t// queries, the final step above will incorrectly fail.\n+\t//\n+\t// TODO(bradfitz): possibly remove the restriction above, if\n+\t// enough driver authors object and find it complicates their\n+\t// code too much. The sql package could be smarter about\n+\t// refcounting the statement and closing it at the appropriate\n+\t// time.\n \tClose() error\n \n \t// NumInput returns the number of placeholder parameters.\n-\t// -1 means the driver doesn't know how to count the number of\n-\t// placeholders, so we won't sanity check input here and instead let the\n-\t// driver deal with errors.\n+\t//\n+\t// If NumInput returns >= 0, the sql package will sanity check\n+\t// argument counts from callers and return errors to the caller\n+\t// before the statement's Exec or Query methods are called.\n+\t//\n+\t// NumInput may also return -1, if the driver doesn't know\n+\t// its number of placeholders. In that case, the sql package\n+\t// will not sanity check Exec or Query argument counts.\n \tNumInput() int\n \n \t// Exec executes a query that doesn't return rows, such"}, {"sha": "2474a86f644c46fc5d5988fad918fd7bcf82c9b3", "filename": "libgo/go/exp/sql/fakedb_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -90,6 +90,8 @@ type fakeStmt struct {\n \tcmd   string\n \ttable string\n \n+\tclosed bool\n+\n \tcolName      []string      // used by CREATE, INSERT, SELECT (selected columns)\n \tcolType      []string      // used by CREATE\n \tcolValue     []interface{} // used by INSERT (mix of strings and \"?\" for bound params)\n@@ -232,6 +234,9 @@ func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, e\n \tstmt.table = parts[0]\n \tstmt.colName = strings.Split(parts[1], \",\")\n \tfor n, colspec := range strings.Split(parts[2], \",\") {\n+\t\tif colspec == \"\" {\n+\t\t\tcontinue\n+\t\t}\n \t\tnameVal := strings.Split(colspec, \"=\")\n \t\tif len(nameVal) != 2 {\n \t\t\treturn nil, errf(\"SELECT on table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n@@ -342,10 +347,16 @@ func (s *fakeStmt) ColumnConverter(idx int) driver.ValueConverter {\n }\n \n func (s *fakeStmt) Close() error {\n+\ts.closed = true\n \treturn nil\n }\n \n+var errClosed = errors.New(\"fakedb: statement has been closed\")\n+\n func (s *fakeStmt) Exec(args []interface{}) (driver.Result, error) {\n+\tif s.closed {\n+\t\treturn nil, errClosed\n+\t}\n \terr := checkSubsetTypes(args)\n \tif err != nil {\n \t\treturn nil, err\n@@ -405,6 +416,9 @@ func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, error) {\n }\n \n func (s *fakeStmt) Query(args []interface{}) (driver.Rows, error) {\n+\tif s.closed {\n+\t\treturn nil, errClosed\n+\t}\n \terr := checkSubsetTypes(args)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "f17d12eaa13e27f69cd5eec288688617b02dd3ef", "filename": "libgo/go/exp/sql/sql.go", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -344,25 +344,26 @@ func (tx *Tx) Rollback() error {\n \treturn tx.txi.Rollback()\n }\n \n-// Prepare creates a prepared statement.\n+// Prepare creates a prepared statement for use within a transaction.\n //\n-// The statement is only valid within the scope of this transaction.\n+// The returned statement operates within the transaction and can no longer\n+// be used once the transaction has been committed or rolled back.\n+//\n+// To use an existing prepared statement on this transaction, see Tx.Stmt.\n func (tx *Tx) Prepare(query string) (*Stmt, error) {\n-\t// TODO(bradfitz): the restriction that the returned statement\n-\t// is only valid for this Transaction is lame and negates a\n-\t// lot of the benefit of prepared statements.  We could be\n-\t// more efficient here and either provide a method to take an\n-\t// existing Stmt (created on perhaps a different Conn), and\n-\t// re-create it on this Conn if necessary. Or, better: keep a\n-\t// map in DB of query string to Stmts, and have Stmt.Execute\n-\t// do the right thing and re-prepare if the Conn in use\n-\t// doesn't have that prepared statement.  But we'll want to\n-\t// avoid caching the statement in the case where we only call\n-\t// conn.Prepare implicitly (such as in db.Exec or tx.Exec),\n-\t// but the caller package can't be holding a reference to the\n-\t// returned statement.  Perhaps just looking at the reference\n-\t// count (by noting Stmt.Close) would be enough. We might also\n-\t// want a finalizer on Stmt to drop the reference count.\n+\t// TODO(bradfitz): We could be more efficient here and either\n+\t// provide a method to take an existing Stmt (created on\n+\t// perhaps a different Conn), and re-create it on this Conn if\n+\t// necessary. Or, better: keep a map in DB of query string to\n+\t// Stmts, and have Stmt.Execute do the right thing and\n+\t// re-prepare if the Conn in use doesn't have that prepared\n+\t// statement.  But we'll want to avoid caching the statement\n+\t// in the case where we only call conn.Prepare implicitly\n+\t// (such as in db.Exec or tx.Exec), but the caller package\n+\t// can't be holding a reference to the returned statement.\n+\t// Perhaps just looking at the reference count (by noting\n+\t// Stmt.Close) would be enough. We might also want a finalizer\n+\t// on Stmt to drop the reference count.\n \tci, err := tx.grabConn()\n \tif err != nil {\n \t\treturn nil, err\n@@ -383,6 +384,39 @@ func (tx *Tx) Prepare(query string) (*Stmt, error) {\n \treturn stmt, nil\n }\n \n+// Stmt returns a transaction-specific prepared statement from\n+// an existing statement.\n+//\n+// Example:\n+//  updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\")\n+//  ...\n+//  tx, err := db.Begin()\n+//  ...\n+//  res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)\n+func (tx *Tx) Stmt(stmt *Stmt) *Stmt {\n+\t// TODO(bradfitz): optimize this. Currently this re-prepares\n+\t// each time.  This is fine for now to illustrate the API but\n+\t// we should really cache already-prepared statements\n+\t// per-Conn. See also the big comment in Tx.Prepare.\n+\n+\tif tx.db != stmt.db {\n+\t\treturn &Stmt{stickyErr: errors.New(\"sql: Tx.Stmt: statement from different database used\")}\n+\t}\n+\tci, err := tx.grabConn()\n+\tif err != nil {\n+\t\treturn &Stmt{stickyErr: err}\n+\t}\n+\tdefer tx.releaseConn()\n+\tsi, err := ci.Prepare(stmt.query)\n+\treturn &Stmt{\n+\t\tdb:        tx.db,\n+\t\ttx:        tx,\n+\t\ttxsi:      si,\n+\t\tquery:     stmt.query,\n+\t\tstickyErr: err,\n+\t}\n+}\n+\n // Exec executes a query that doesn't return rows.\n // For example: an INSERT and UPDATE.\n func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n@@ -448,8 +482,9 @@ type connStmt struct {\n // Stmt is a prepared statement. Stmt is safe for concurrent use by multiple goroutines.\n type Stmt struct {\n \t// Immutable:\n-\tdb    *DB    // where we came from\n-\tquery string // that created the Sttm\n+\tdb        *DB    // where we came from\n+\tquery     string // that created the Stmt\n+\tstickyErr error  // if non-nil, this error is returned for all operations\n \n \t// If in a transaction, else both nil:\n \ttx   *Tx\n@@ -513,6 +548,9 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n // statement, a function to call to release the connection, and a\n // statement bound to that connection.\n func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, err error) {\n+\tif s.stickyErr != nil {\n+\t\treturn nil, nil, nil, s.stickyErr\n+\t}\n \ts.mu.Lock()\n \tif s.closed {\n \t\ts.mu.Unlock()\n@@ -621,6 +659,9 @@ func (s *Stmt) QueryRow(args ...interface{}) *Row {\n \n // Close closes the statement.\n func (s *Stmt) Close() error {\n+\tif s.stickyErr != nil {\n+\t\treturn s.stickyErr\n+\t}\n \ts.mu.Lock()\n \tdefer s.mu.Unlock()\n \tif s.closed {"}, {"sha": "4f8318d26ef7972884804f2a7a6dde463e7bae0b", "filename": "libgo/go/exp/sql/sql_test.go", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -5,6 +5,7 @@\n package sql\n \n import (\n+\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -22,7 +23,6 @@ func newTestDB(t *testing.T, name string) *DB {\n \t\texec(t, db, \"INSERT|people|name=Alice,age=?\", 1)\n \t\texec(t, db, \"INSERT|people|name=Bob,age=?\", 2)\n \t\texec(t, db, \"INSERT|people|name=Chris,age=?\", 3)\n-\n \t}\n \treturn db\n }\n@@ -42,6 +42,40 @@ func closeDB(t *testing.T, db *DB) {\n }\n \n func TestQuery(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\trows, err := db.Query(\"SELECT|people|age,name|\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Query: %v\", err)\n+\t}\n+\ttype row struct {\n+\t\tage  int\n+\t\tname string\n+\t}\n+\tgot := []row{}\n+\tfor rows.Next() {\n+\t\tvar r row\n+\t\terr = rows.Scan(&r.age, &r.name)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Scan: %v\", err)\n+\t\t}\n+\t\tgot = append(got, r)\n+\t}\n+\terr = rows.Err()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Err: %v\", err)\n+\t}\n+\twant := []row{\n+\t\t{age: 1, name: \"Alice\"},\n+\t\t{age: 2, name: \"Bob\"},\n+\t\t{age: 3, name: \"Chris\"},\n+\t}\n+\tif !reflect.DeepEqual(got, want) {\n+\t\tt.Logf(\" got: %#v\\nwant: %#v\", got, want)\n+\t}\n+}\n+\n+func TestQueryRow(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n \tvar name string\n@@ -75,6 +109,24 @@ func TestQuery(t *testing.T) {\n \t}\n }\n \n+func TestStatementErrorAfterClose(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\tstmt, err := db.Prepare(\"SELECT|people|age|name=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Prepare: %v\", err)\n+\t}\n+\terr = stmt.Close()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Close: %v\", err)\n+\t}\n+\tvar name string\n+\terr = stmt.QueryRow(\"foo\").Scan(&name)\n+\tif err == nil {\n+\t\tt.Errorf(\"expected error from QueryRow.Scan after Stmt.Close\")\n+\t}\n+}\n+\n func TestStatementQueryRow(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -114,7 +166,7 @@ func TestBogusPreboundParameters(t *testing.T) {\n \t}\n }\n \n-func TestDb(t *testing.T) {\n+func TestExec(t *testing.T) {\n \tdb := newTestDB(t, \"foo\")\n \tdefer closeDB(t, db)\n \texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n@@ -154,3 +206,25 @@ func TestDb(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestTxStmt(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\tstmt, err := db.Prepare(\"INSERT|t1|name=?,age=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n+\t}\n+\ttx, err := db.Begin()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Begin = %v\", err)\n+\t}\n+\t_, err = tx.Stmt(stmt).Exec(\"Bobby\", 7)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Exec = %v\", err)\n+\t}\n+\terr = tx.Commit()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Commit = %v\", err)\n+\t}\n+}"}, {"sha": "9d75f37de748fe35fef2f9f0bf38bb80a0ffef6c", "filename": "libgo/go/exp/ssh/channel.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -244,13 +244,13 @@ func (c *channel) Write(data []byte) (n int, err error) {\n \n \t\tpacket := make([]byte, 1+4+4+len(todo))\n \t\tpacket[0] = msgChannelData\n-\t\tpacket[1] = byte(c.theirId) >> 24\n-\t\tpacket[2] = byte(c.theirId) >> 16\n-\t\tpacket[3] = byte(c.theirId) >> 8\n+\t\tpacket[1] = byte(c.theirId >> 24)\n+\t\tpacket[2] = byte(c.theirId >> 16)\n+\t\tpacket[3] = byte(c.theirId >> 8)\n \t\tpacket[4] = byte(c.theirId)\n-\t\tpacket[5] = byte(len(todo)) >> 24\n-\t\tpacket[6] = byte(len(todo)) >> 16\n-\t\tpacket[7] = byte(len(todo)) >> 8\n+\t\tpacket[5] = byte(len(todo) >> 24)\n+\t\tpacket[6] = byte(len(todo) >> 16)\n+\t\tpacket[7] = byte(len(todo) >> 8)\n \t\tpacket[8] = byte(len(todo))\n \t\tcopy(packet[9:], todo)\n "}, {"sha": "429dee975bce754d9876a5b1ea12476bca4837ee", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -172,40 +172,12 @@ func (c *ClientConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \tmarshalInt(K, kInt)\n \th.Write(K)\n \n-\tH := h.Sum()\n+\tH := h.Sum(nil)\n \n \treturn H, K, nil\n }\n \n-// openChan opens a new client channel. The most common session type is \"session\". \n-// The full set of valid session types are listed in RFC 4250 4.9.1.\n-func (c *ClientConn) openChan(typ string) (*clientChan, error) {\n-\tch := c.newChan(c.transport)\n-\tif err := c.writePacket(marshal(msgChannelOpen, channelOpenMsg{\n-\t\tChanType:      typ,\n-\t\tPeersId:       ch.id,\n-\t\tPeersWindow:   1 << 14,\n-\t\tMaxPacketSize: 1 << 15, // RFC 4253 6.1\n-\t})); err != nil {\n-\t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, err\n-\t}\n-\t// wait for response\n-\tswitch msg := (<-ch.msg).(type) {\n-\tcase *channelOpenConfirmMsg:\n-\t\tch.peersId = msg.MyId\n-\t\tch.win <- int(msg.MyWindow)\n-\tcase *channelOpenFailureMsg:\n-\t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, errors.New(msg.Message)\n-\tdefault:\n-\t\tc.chanlist.remove(ch.id)\n-\t\treturn nil, errors.New(\"Unexpected packet\")\n-\t}\n-\treturn ch, nil\n-}\n-\n-// mainloop reads incoming messages and routes channel messages\n+// mainLoop reads incoming messages and routes channel messages\n // to their respective ClientChans.\n func (c *ClientConn) mainLoop() {\n \t// TODO(dfc) signal the underlying close to all channels\n@@ -271,7 +243,7 @@ func (c *ClientConn) mainLoop() {\n \t\t\tcase *windowAdjustMsg:\n \t\t\t\tc.getChan(msg.PeersId).win <- int(msg.AdditionalBytes)\n \t\t\tdefault:\n-\t\t\t\tfmt.Printf(\"mainLoop: unhandled %#v\\n\", msg)\n+\t\t\t\tfmt.Printf(\"mainLoop: unhandled message %T: %v\\n\", msg, msg)\n \t\t\t}\n \t\t}\n \t}\n@@ -338,27 +310,16 @@ func newClientChan(t *transport, id uint32) *clientChan {\n // Close closes the channel. This does not close the underlying connection.\n func (c *clientChan) Close() error {\n \treturn c.writePacket(marshal(msgChannelClose, channelCloseMsg{\n-\t\tPeersId: c.id,\n+\t\tPeersId: c.peersId,\n \t}))\n }\n \n-func (c *clientChan) sendChanReq(req channelRequestMsg) error {\n-\tif err := c.writePacket(marshal(msgChannelRequest, req)); err != nil {\n-\t\treturn err\n-\t}\n-\tmsg := <-c.msg\n-\tif _, ok := msg.(*channelRequestSuccessMsg); ok {\n-\t\treturn nil\n-\t}\n-\treturn fmt.Errorf(\"failed to complete request: %s, %#v\", req.Request, msg)\n-}\n-\n // Thread safe channel list.\n type chanlist struct {\n \t// protects concurrent access to chans\n \tsync.Mutex\n \t// chans are indexed by the local id of the channel, clientChan.id.\n-\t// The PeersId value of messages received by ClientConn.mainloop is\n+\t// The PeersId value of messages received by ClientConn.mainLoop is\n \t// used to locate the right local clientChan in this slice.\n \tchans []*clientChan\n }\n@@ -395,7 +356,7 @@ func (c *chanlist) remove(id uint32) {\n // A chanWriter represents the stdin of a remote process.\n type chanWriter struct {\n \twin          chan int // receives window adjustments\n-\tid           uint32   // this channel's id\n+\tpeersId      uint32   // the peer's id\n \trwin         int      // current rwin size\n \tpacketWriter          // for sending channelDataMsg\n }\n@@ -414,8 +375,8 @@ func (w *chanWriter) Write(data []byte) (n int, err error) {\n \t\tn = len(data)\n \t\tpacket := make([]byte, 0, 9+n)\n \t\tpacket = append(packet, msgChannelData,\n-\t\t\tbyte(w.id)>>24, byte(w.id)>>16, byte(w.id)>>8, byte(w.id),\n-\t\t\tbyte(n)>>24, byte(n)>>16, byte(n)>>8, byte(n))\n+\t\t\tbyte(w.peersId>>24), byte(w.peersId>>16), byte(w.peersId>>8), byte(w.peersId),\n+\t\t\tbyte(n>>24), byte(n>>16), byte(n>>8), byte(n))\n \t\terr = w.writePacket(append(packet, data...))\n \t\tw.rwin -= n\n \t\treturn\n@@ -424,7 +385,7 @@ func (w *chanWriter) Write(data []byte) (n int, err error) {\n }\n \n func (w *chanWriter) Close() error {\n-\treturn w.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.id}))\n+\treturn w.writePacket(marshal(msgChannelEOF, channelEOFMsg{w.peersId}))\n }\n \n // A chanReader represents stdout or stderr of a remote process.\n@@ -433,8 +394,8 @@ type chanReader struct {\n \t// If writes to this channel block, they will block mainLoop, making\n \t// it unable to receive new messages from the remote side.\n \tdata         chan []byte // receives data from remote\n-\tid           uint32\n-\tpacketWriter // for sending windowAdjustMsg\n+\tpeersId      uint32      // the peer's id\n+\tpacketWriter             // for sending windowAdjustMsg\n \tbuf          []byte\n }\n \n@@ -446,7 +407,7 @@ func (r *chanReader) Read(data []byte) (int, error) {\n \t\t\tn := copy(data, r.buf)\n \t\t\tr.buf = r.buf[n:]\n \t\t\tmsg := windowAdjustMsg{\n-\t\t\t\tPeersId:         r.id,\n+\t\t\t\tPeersId:         r.peersId,\n \t\t\t\tAdditionalBytes: uint32(n),\n \t\t\t}\n \t\t\treturn n, r.writePacket(marshal(msgChannelWindowAdjust, msg))\n@@ -458,7 +419,3 @@ func (r *chanReader) Read(data []byte) (int, error) {\n \t}\n \tpanic(\"unreachable\")\n }\n-\n-func (r *chanReader) Close() error {\n-\treturn r.writePacket(marshal(msgChannelEOF, channelEOFMsg{r.id}))\n-}"}, {"sha": "4ef9213a9cd061c72622d6e69d1c725831acac01", "filename": "libgo/go/exp/ssh/client_auth_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -70,7 +70,7 @@ func (k *keychain) Sign(i int, rand io.Reader, data []byte) (sig []byte, err err\n \thashFunc := crypto.SHA1\n \th := hashFunc.New()\n \th.Write(data)\n-\tdigest := h.Sum()\n+\tdigest := h.Sum(nil)\n \treturn rsa.SignPKCS1v15(rand, k.keys[i], hashFunc, digest)\n }\n "}, {"sha": "6844fb89b792c7824c6ecfc677087f3c3abe6345", "filename": "libgo/go/exp/ssh/common.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -224,3 +224,16 @@ func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubK\n \tr = marshalString(r, pubKey)\n \treturn ret\n }\n+\n+// safeString sanitises s according to RFC 4251, section 9.2. \n+// All control characters except tab, carriage return and newline are\n+// replaced by 0x20.\n+func safeString(s string) string {\n+\tout := []byte(s)\n+\tfor i, c := range out {\n+\t\tif c < 0x20 && c != 0xd && c != 0xa && c != 0x9 {\n+\t\t\tout[i] = 0x20\n+\t\t}\n+\t}\n+\treturn string(out)\n+}"}, {"sha": "2f4448a1bd43b15f750147cbfd58869455ffa5f8", "filename": "libgo/go/exp/ssh/common_test.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var strings = map[string]string{\n+\t\"\\x20\\x0d\\x0a\":  \"\\x20\\x0d\\x0a\",\n+\t\"flibble\":       \"flibble\",\n+\t\"new\\x20line\":   \"new\\x20line\",\n+\t\"123456\\x07789\": \"123456 789\",\n+\t\"\\t\\t\\x10\\r\\n\":  \"\\t\\t \\r\\n\",\n+}\n+\n+func TestSafeString(t *testing.T) {\n+\tfor s, expected := range strings {\n+\t\tactual := safeString(s)\n+\t\tif expected != actual {\n+\t\t\tt.Errorf(\"expected: %v, actual: %v\", []byte(expected), []byte(actual))\n+\t\t}\n+\t}\n+}"}, {"sha": "480f877191a1b705115e4097e7aea8764cea2cef", "filename": "libgo/go/exp/ssh/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -92,9 +92,9 @@ Each ClientConn can support multiple interactive sessions, represented by a Sess\n \tsession, err := client.NewSession()\n \n Once a Session is created, you can execute a single command on the remote side \n-using the Exec method.\n+using the Run method.\n \n-\tif err := session.Exec(\"/usr/bin/whoami\"); err != nil {\n+\tif err := session.Run(\"/usr/bin/whoami\"); err != nil {\n \t\tpanic(\"Failed to exec: \" + err.String())\n \t}\n \treader := bufio.NewReader(session.Stdin)"}, {"sha": "1eee9a4a9776c05ff2605cd25f7c0fb1383b38b0", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -207,11 +207,11 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \tmarshalInt(K, kInt)\n \th.Write(K)\n \n-\tH = h.Sum()\n+\tH = h.Sum(nil)\n \n \th.Reset()\n \th.Write(H)\n-\thh := h.Sum()\n+\thh := h.Sum(nil)\n \n \tvar sig []byte\n \tswitch hostKeyAlgo {\n@@ -478,7 +478,7 @@ userAuthLoop:\n \t\t\t\t\thashFunc := crypto.SHA1\n \t\t\t\t\th := hashFunc.New()\n \t\t\t\t\th.Write(signedData)\n-\t\t\t\t\tdigest := h.Sum()\n+\t\t\t\t\tdigest := h.Sum(nil)\n \t\t\t\t\trsaKey, ok := parseRSA(pubKey)\n \t\t\t\t\tif !ok {\n \t\t\t\t\t\treturn ParseError{msgUserAuthRequest}"}, {"sha": "5f98a8d58c683956b701cef5df1c1c9f9ace1fa9", "filename": "libgo/go/exp/ssh/session.go", "status": "modified", "additions": 368, "deletions": 84, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,125 +8,409 @@ package ssh\n // \"RFC 4254, section 6\".\n \n import (\n-\t\"encoding/binary\"\n+\t\"bytes\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n+)\n+\n+type Signal string\n+\n+// POSIX signals as listed in RFC 4254 Section 6.10.\n+const (\n+\tSIGABRT Signal = \"ABRT\"\n+\tSIGALRM Signal = \"ALRM\"\n+\tSIGFPE  Signal = \"FPE\"\n+\tSIGHUP  Signal = \"HUP\"\n+\tSIGILL  Signal = \"ILL\"\n+\tSIGINT  Signal = \"INT\"\n+\tSIGKILL Signal = \"KILL\"\n+\tSIGPIPE Signal = \"PIPE\"\n+\tSIGQUIT Signal = \"QUIT\"\n+\tSIGSEGV Signal = \"SEGV\"\n+\tSIGTERM Signal = \"TERM\"\n+\tSIGUSR1 Signal = \"USR1\"\n+\tSIGUSR2 Signal = \"USR2\"\n )\n \n // A Session represents a connection to a remote command or shell.\n type Session struct {\n-\t// Writes to Stdin are made available to the remote command's standard input.\n-\t// Closing Stdin causes the command to observe an EOF on its standard input.\n-\tStdin io.WriteCloser\n-\n-\t// Reads from Stdout and Stderr consume from the remote command's standard\n-\t// output and error streams, respectively.\n-\t// There is a fixed amount of buffering that is shared for the two streams.\n-\t// Failing to read from either may eventually cause the command to block.\n-\t// Closing Stdout unblocks such writes and causes them to return errors.\n-\tStdout io.ReadCloser\n-\tStderr io.Reader\n+\t// Stdin specifies the remote process's standard input.\n+\t// If Stdin is nil, the remote process reads from an empty\n+\t// bytes.Buffer.\n+\tStdin io.Reader\n+\n+\t// Stdout and Stderr specify the remote process's standard\n+\t// output and error.\n+\t//\n+\t// If either is nil, Run connects the corresponding file\n+\t// descriptor to an instance of ioutil.Discard. There is a\n+\t// fixed amount of buffering that is shared for the two streams.\n+\t// If either blocks it may eventually cause the remote\n+\t// command to block.\n+\tStdout io.Writer\n+\tStderr io.Writer\n \n \t*clientChan // the channel backing this session\n \n-\tstarted bool // started is set to true once a Shell or Exec is invoked.\n+\tstarted        bool // true once Start, Run or Shell is invoked.\n+\tcloseAfterWait []io.Closer\n+\tcopyFuncs      []func() error\n+\terrch          chan error // one send per copyFunc\n+}\n+\n+// RFC 4254 Section 6.4.\n+type setenvRequest struct {\n+\tPeersId   uint32\n+\tRequest   string\n+\tWantReply bool\n+\tName      string\n+\tValue     string\n }\n \n // Setenv sets an environment variable that will be applied to any\n-// command executed by Shell or Exec.\n+// command executed by Shell or Run.\n func (s *Session) Setenv(name, value string) error {\n-\tn, v := []byte(name), []byte(value)\n-\tnlen, vlen := stringLength(n), stringLength(v)\n-\tpayload := make([]byte, nlen+vlen)\n-\tmarshalString(payload[:nlen], n)\n-\tmarshalString(payload[nlen:], v)\n-\n-\treturn s.sendChanReq(channelRequestMsg{\n-\t\tPeersId:             s.id,\n-\t\tRequest:             \"env\",\n-\t\tWantReply:           true,\n-\t\tRequestSpecificData: payload,\n-\t})\n+\treq := setenvRequest{\n+\t\tPeersId:   s.peersId,\n+\t\tRequest:   \"env\",\n+\t\tWantReply: true,\n+\t\tName:      name,\n+\t\tValue:     value,\n+\t}\n+\tif err := s.writePacket(marshal(msgChannelRequest, req)); err != nil {\n+\t\treturn err\n+\t}\n+\treturn s.waitForResponse()\n }\n \n-// An empty mode list (a string of 1 character, opcode 0), see RFC 4254 Section 8.\n-var emptyModeList = []byte{0, 0, 0, 1, 0}\n+// An empty mode list, see RFC 4254 Section 8.\n+var emptyModelist = \"\\x00\"\n+\n+// RFC 4254 Section 6.2.\n+type ptyRequestMsg struct {\n+\tPeersId   uint32\n+\tRequest   string\n+\tWantReply bool\n+\tTerm      string\n+\tColumns   uint32\n+\tRows      uint32\n+\tWidth     uint32\n+\tHeight    uint32\n+\tModelist  string\n+}\n \n // RequestPty requests the association of a pty with the session on the remote host.\n func (s *Session) RequestPty(term string, h, w int) error {\n-\tbuf := make([]byte, 4+len(term)+16+len(emptyModeList))\n-\tb := marshalString(buf, []byte(term))\n-\tbinary.BigEndian.PutUint32(b, uint32(h))\n-\tbinary.BigEndian.PutUint32(b[4:], uint32(w))\n-\tbinary.BigEndian.PutUint32(b[8:], uint32(h*8))\n-\tbinary.BigEndian.PutUint32(b[12:], uint32(w*8))\n-\tcopy(b[16:], emptyModeList)\n-\n-\treturn s.sendChanReq(channelRequestMsg{\n-\t\tPeersId:             s.id,\n-\t\tRequest:             \"pty-req\",\n-\t\tWantReply:           true,\n-\t\tRequestSpecificData: buf,\n-\t})\n+\treq := ptyRequestMsg{\n+\t\tPeersId:   s.peersId,\n+\t\tRequest:   \"pty-req\",\n+\t\tWantReply: true,\n+\t\tTerm:      term,\n+\t\tColumns:   uint32(w),\n+\t\tRows:      uint32(h),\n+\t\tWidth:     uint32(w * 8),\n+\t\tHeight:    uint32(h * 8),\n+\t\tModelist:  emptyModelist,\n+\t}\n+\tif err := s.writePacket(marshal(msgChannelRequest, req)); err != nil {\n+\t\treturn err\n+\t}\n+\treturn s.waitForResponse()\n }\n \n-// Exec runs cmd on the remote host. Typically, the remote \n-// server passes cmd to the shell for interpretation. \n-// A Session only accepts one call to Exec or Shell.\n-func (s *Session) Exec(cmd string) error {\n+// RFC 4254 Section 6.9.\n+type signalMsg struct {\n+\tPeersId   uint32\n+\tRequest   string\n+\tWantReply bool\n+\tSignal    string\n+}\n+\n+// Signal sends the given signal to the remote process.\n+// sig is one of the SIG* constants.\n+func (s *Session) Signal(sig Signal) error {\n+\treq := signalMsg{\n+\t\tPeersId:   s.peersId,\n+\t\tRequest:   \"signal\",\n+\t\tWantReply: false,\n+\t\tSignal:    string(sig),\n+\t}\n+\treturn s.writePacket(marshal(msgChannelRequest, req))\n+}\n+\n+// RFC 4254 Section 6.5.\n+type execMsg struct {\n+\tPeersId   uint32\n+\tRequest   string\n+\tWantReply bool\n+\tCommand   string\n+}\n+\n+// Start runs cmd on the remote host. Typically, the remote\n+// server passes cmd to the shell for interpretation.\n+// A Session only accepts one call to Run, Start or Shell.\n+func (s *Session) Start(cmd string) error {\n \tif s.started {\n-\t\treturn errors.New(\"session already started\")\n+\t\treturn errors.New(\"ssh: session already started\")\n \t}\n-\tcmdLen := stringLength([]byte(cmd))\n-\tpayload := make([]byte, cmdLen)\n-\tmarshalString(payload, []byte(cmd))\n-\ts.started = true\n+\treq := execMsg{\n+\t\tPeersId:   s.peersId,\n+\t\tRequest:   \"exec\",\n+\t\tWantReply: true,\n+\t\tCommand:   cmd,\n+\t}\n+\tif err := s.writePacket(marshal(msgChannelRequest, req)); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := s.waitForResponse(); err != nil {\n+\t\treturn fmt.Errorf(\"ssh: could not execute command %s: %v\", cmd, err)\n+\t}\n+\treturn s.start()\n+}\n \n-\treturn s.sendChanReq(channelRequestMsg{\n-\t\tPeersId:             s.id,\n-\t\tRequest:             \"exec\",\n-\t\tWantReply:           true,\n-\t\tRequestSpecificData: payload,\n-\t})\n+// Run runs cmd on the remote host and waits for it to terminate.\n+// Typically, the remote server passes cmd to the shell for\n+// interpretation. A Session only accepts one call to Run,\n+// Start or Shell.\n+func (s *Session) Run(cmd string) error {\n+\terr := s.Start(cmd)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn s.Wait()\n }\n \n-// Shell starts a login shell on the remote host. A Session only \n-// accepts one call to Exec or Shell.\n+// Shell starts a login shell on the remote host. A Session only\n+// accepts one call to Run, Start or Shell.\n func (s *Session) Shell() error {\n \tif s.started {\n-\t\treturn errors.New(\"session already started\")\n+\t\treturn errors.New(\"ssh: session already started\")\n \t}\n-\ts.started = true\n-\n-\treturn s.sendChanReq(channelRequestMsg{\n-\t\tPeersId:   s.id,\n+\treq := channelRequestMsg{\n+\t\tPeersId:   s.peersId,\n \t\tRequest:   \"shell\",\n \t\tWantReply: true,\n+\t}\n+\tif err := s.writePacket(marshal(msgChannelRequest, req)); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := s.waitForResponse(); err != nil {\n+\t\treturn fmt.Errorf(\"ssh: cound not execute shell: %v\", err)\n+\t}\n+\treturn s.start()\n+}\n+\n+func (s *Session) waitForResponse() error {\n+\tmsg := <-s.msg\n+\tswitch msg.(type) {\n+\tcase *channelRequestSuccessMsg:\n+\t\treturn nil\n+\tcase *channelRequestFailureMsg:\n+\t\treturn errors.New(\"request failed\")\n+\t}\n+\treturn fmt.Errorf(\"unknown packet %T received: %v\", msg, msg)\n+}\n+\n+func (s *Session) start() error {\n+\ts.started = true\n+\n+\ttype F func(*Session) error\n+\tfor _, setupFd := range []F{(*Session).stdin, (*Session).stdout, (*Session).stderr} {\n+\t\tif err := setupFd(s); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\ts.errch = make(chan error, len(s.copyFuncs))\n+\tfor _, fn := range s.copyFuncs {\n+\t\tgo func(fn func() error) {\n+\t\t\ts.errch <- fn()\n+\t\t}(fn)\n+\t}\n+\treturn nil\n+}\n+\n+// Wait waits for the remote command to exit.\n+func (s *Session) Wait() error {\n+\tif !s.started {\n+\t\treturn errors.New(\"ssh: session not started\")\n+\t}\n+\twaitErr := s.wait()\n+\n+\tvar copyError error\n+\tfor _ = range s.copyFuncs {\n+\t\tif err := <-s.errch; err != nil && copyError == nil {\n+\t\t\tcopyError = err\n+\t\t}\n+\t}\n+\tfor _, fd := range s.closeAfterWait {\n+\t\tfd.Close()\n+\t}\n+\tif waitErr != nil {\n+\t\treturn waitErr\n+\t}\n+\treturn copyError\n+}\n+\n+func (s *Session) wait() error {\n+\tfor {\n+\t\tswitch msg := (<-s.msg).(type) {\n+\t\tcase *channelRequestMsg:\n+\t\t\t// TODO(dfc) improve this behavior to match os.Waitmsg\n+\t\t\tswitch msg.Request {\n+\t\t\tcase \"exit-status\":\n+\t\t\t\td := msg.RequestSpecificData\n+\t\t\t\tstatus := int(d[0])<<24 | int(d[1])<<16 | int(d[2])<<8 | int(d[3])\n+\t\t\t\tif status > 0 {\n+\t\t\t\t\treturn fmt.Errorf(\"remote process exited with %d\", status)\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\tcase \"exit-signal\":\n+\t\t\t\t// TODO(dfc) make a more readable error message\n+\t\t\t\treturn fmt.Errorf(\"%v\", msg.RequestSpecificData)\n+\t\t\tdefault:\n+\t\t\t\treturn fmt.Errorf(\"wait: unexpected channel request: %v\", msg)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"wait: unexpected packet %T received: %v\", msg, msg)\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (s *Session) stdin() error {\n+\tif s.Stdin == nil {\n+\t\ts.Stdin = new(bytes.Buffer)\n+\t}\n+\ts.copyFuncs = append(s.copyFuncs, func() error {\n+\t\tw := &chanWriter{\n+\t\t\tpacketWriter: s,\n+\t\t\tpeersId:      s.peersId,\n+\t\t\twin:          s.win,\n+\t\t}\n+\t\t_, err := io.Copy(w, s.Stdin)\n+\t\tif err1 := w.Close(); err == nil {\n+\t\t\terr = err1\n+\t\t}\n+\t\treturn err\n \t})\n+\treturn nil\n }\n \n+func (s *Session) stdout() error {\n+\tif s.Stdout == nil {\n+\t\ts.Stdout = ioutil.Discard\n+\t}\n+\ts.copyFuncs = append(s.copyFuncs, func() error {\n+\t\tr := &chanReader{\n+\t\t\tpacketWriter: s,\n+\t\t\tpeersId:      s.peersId,\n+\t\t\tdata:         s.data,\n+\t\t}\n+\t\t_, err := io.Copy(s.Stdout, r)\n+\t\treturn err\n+\t})\n+\treturn nil\n+}\n+\n+func (s *Session) stderr() error {\n+\tif s.Stderr == nil {\n+\t\ts.Stderr = ioutil.Discard\n+\t}\n+\ts.copyFuncs = append(s.copyFuncs, func() error {\n+\t\tr := &chanReader{\n+\t\t\tpacketWriter: s,\n+\t\t\tpeersId:      s.peersId,\n+\t\t\tdata:         s.dataExt,\n+\t\t}\n+\t\t_, err := io.Copy(s.Stderr, r)\n+\t\treturn err\n+\t})\n+\treturn nil\n+}\n+\n+// StdinPipe returns a pipe that will be connected to the\n+// remote command's standard input when the command starts.\n+func (s *Session) StdinPipe() (io.WriteCloser, error) {\n+\tif s.Stdin != nil {\n+\t\treturn nil, errors.New(\"ssh: Stdin already set\")\n+\t}\n+\tif s.started {\n+\t\treturn nil, errors.New(\"ssh: StdinPipe after process started\")\n+\t}\n+\tpr, pw := io.Pipe()\n+\ts.Stdin = pr\n+\ts.closeAfterWait = append(s.closeAfterWait, pr)\n+\treturn pw, nil\n+}\n+\n+// StdoutPipe returns a pipe that will be connected to the\n+// remote command's standard output when the command starts.\n+// There is a fixed amount of buffering that is shared between\n+// stdout and stderr streams. If the StdoutPipe reader is\n+// not serviced fast enought it may eventually cause the\n+// remote command to block.\n+func (s *Session) StdoutPipe() (io.ReadCloser, error) {\n+\tif s.Stdout != nil {\n+\t\treturn nil, errors.New(\"ssh: Stdout already set\")\n+\t}\n+\tif s.started {\n+\t\treturn nil, errors.New(\"ssh: StdoutPipe after process started\")\n+\t}\n+\tpr, pw := io.Pipe()\n+\ts.Stdout = pw\n+\ts.closeAfterWait = append(s.closeAfterWait, pw)\n+\treturn pr, nil\n+}\n+\n+// StderrPipe returns a pipe that will be connected to the\n+// remote command's standard error when the command starts.\n+// There is a fixed amount of buffering that is shared between\n+// stdout and stderr streams. If the StderrPipe reader is\n+// not serviced fast enought it may eventually cause the\n+// remote command to block.\n+func (s *Session) StderrPipe() (io.ReadCloser, error) {\n+\tif s.Stderr != nil {\n+\t\treturn nil, errors.New(\"ssh: Stderr already set\")\n+\t}\n+\tif s.started {\n+\t\treturn nil, errors.New(\"ssh: StderrPipe after process started\")\n+\t}\n+\tpr, pw := io.Pipe()\n+\ts.Stderr = pw\n+\ts.closeAfterWait = append(s.closeAfterWait, pw)\n+\treturn pr, nil\n+}\n+\n+// TODO(dfc) add Output and CombinedOutput helpers\n+\n // NewSession returns a new interactive session on the remote host.\n func (c *ClientConn) NewSession() (*Session, error) {\n-\tch, err := c.openChan(\"session\")\n-\tif err != nil {\n+\tch := c.newChan(c.transport)\n+\tif err := c.writePacket(marshal(msgChannelOpen, channelOpenMsg{\n+\t\tChanType:      \"session\",\n+\t\tPeersId:       ch.id,\n+\t\tPeersWindow:   1 << 14,\n+\t\tMaxPacketSize: 1 << 15, // RFC 4253 6.1\n+\t})); err != nil {\n+\t\tc.chanlist.remove(ch.id)\n \t\treturn nil, err\n \t}\n-\treturn &Session{\n-\t\tStdin: &chanWriter{\n-\t\t\tpacketWriter: ch,\n-\t\t\tid:           ch.id,\n-\t\t\twin:          ch.win,\n-\t\t},\n-\t\tStdout: &chanReader{\n-\t\t\tpacketWriter: ch,\n-\t\t\tid:           ch.id,\n-\t\t\tdata:         ch.data,\n-\t\t},\n-\t\tStderr: &chanReader{\n-\t\t\tpacketWriter: ch,\n-\t\t\tid:           ch.id,\n-\t\t\tdata:         ch.dataExt,\n-\t\t},\n-\t\tclientChan: ch,\n-\t}, nil\n+\t// wait for response\n+\tmsg := <-ch.msg\n+\tswitch msg := msg.(type) {\n+\tcase *channelOpenConfirmMsg:\n+\t\tch.peersId = msg.MyId\n+\t\tch.win <- int(msg.MyWindow)\n+\t\treturn &Session{\n+\t\t\tclientChan: ch,\n+\t\t}, nil\n+\tcase *channelOpenFailureMsg:\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, fmt.Errorf(\"ssh: channel open failed: %s\", msg.Message)\n+\t}\n+\tc.chanlist.remove(ch.id)\n+\treturn nil, fmt.Errorf(\"ssh: unexpected message %T: %v\", msg, msg)\n }"}, {"sha": "4be7746d17e2996064182329743cffbbf6c63f12", "filename": "libgo/go/exp/ssh/session_test.go", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+// Session tests.\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+// dial constructs a new test server and returns a *ClientConn.\n+func dial(t *testing.T) *ClientConn {\n+\tpw := password(\"tiger\")\n+\tserverConfig.PasswordCallback = func(user, pass string) bool {\n+\t\treturn user == \"testuser\" && pass == string(pw)\n+\t}\n+\tserverConfig.PubKeyCallback = nil\n+\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t}\n+\tgo func() {\n+\t\tdefer l.Close()\n+\t\tconn, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unable to accept: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer conn.Close()\n+\t\tif err := conn.Handshake(); err != nil {\n+\t\t\tt.Errorf(\"Unable to handshake: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tfor {\n+\t\t\tch, err := conn.Accept()\n+\t\t\tif err == io.EOF {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"Unable to accept incoming channel request: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif ch.ChannelType() != \"session\" {\n+\t\t\t\tch.Reject(UnknownChannelType, \"unknown channel type\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tch.Accept()\n+\t\t\tgo func() {\n+\t\t\t\tdefer ch.Close()\n+\t\t\t\t// this string is returned to stdout\n+\t\t\t\tshell := NewServerShell(ch, \"golang\")\n+\t\t\t\tshell.ReadLine()\n+\t\t\t\ttype exitMsg struct {\n+\t\t\t\t\tPeersId   uint32\n+\t\t\t\t\tRequest   string\n+\t\t\t\t\tWantReply bool\n+\t\t\t\t\tStatus    uint32\n+\t\t\t\t}\n+\t\t\t\t// TODO(dfc) casting to the concrete type should not be\n+\t\t\t\t// necessary to send a packet.\n+\t\t\t\tmsg := exitMsg{\n+\t\t\t\t\tPeersId:   ch.(*channel).theirId,\n+\t\t\t\t\tRequest:   \"exit-status\",\n+\t\t\t\t\tWantReply: false,\n+\t\t\t\t\tStatus:    0,\n+\t\t\t\t}\n+\t\t\t\tch.(*channel).serverConn.writePacket(marshal(msgChannelRequest, msg))\n+\t\t\t}()\n+\t\t}\n+\t\tt.Log(\"done\")\n+\t}()\n+\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(pw),\n+\t\t},\n+\t}\n+\n+\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n+\t}\n+\treturn c\n+}\n+\n+// Test a simple string is returned to session.Stdout.\n+func TestSessionShell(t *testing.T) {\n+\tconn := dial(t)\n+\tdefer conn.Close()\n+\tsession, err := conn.NewSession()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to request new session: %s\", err)\n+\t}\n+\tdefer session.Close()\n+\tstdout := new(bytes.Buffer)\n+\tsession.Stdout = stdout\n+\tif err := session.Shell(); err != nil {\n+\t\tt.Fatalf(\"Unable to execute command: %s\", err)\n+\t}\n+\tif err := session.Wait(); err != nil {\n+\t\tt.Fatalf(\"Remote command did not exit cleanly: %s\", err)\n+\t}\n+\tactual := stdout.String()\n+\tif actual != \"golang\" {\n+\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n+\t}\n+}\n+\n+// TODO(dfc) add support for Std{in,err}Pipe when the Server supports it.\n+\n+// Test a simple string is returned via StdoutPipe.\n+func TestSessionStdoutPipe(t *testing.T) {\n+\tconn := dial(t)\n+\tdefer conn.Close()\n+\tsession, err := conn.NewSession()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to request new session: %s\", err)\n+\t}\n+\tdefer session.Close()\n+\tstdout, err := session.StdoutPipe()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to request StdoutPipe(): %v\", err)\n+\t}\n+\tvar buf bytes.Buffer\n+\tif err := session.Shell(); err != nil {\n+\t\tt.Fatalf(\"Unable to execute command: %s\", err)\n+\t}\n+\tdone := make(chan bool, 1)\n+\tgo func() {\n+\t\tif _, err := io.Copy(&buf, stdout); err != nil {\n+\t\t\tt.Errorf(\"Copy of stdout failed: %v\", err)\n+\t\t}\n+\t\tdone <- true\n+\t}()\n+\tif err := session.Wait(); err != nil {\n+\t\tt.Fatalf(\"Remote command did not exit cleanly: %s\", err)\n+\t}\n+\t<-done\n+\tactual := buf.String()\n+\tif actual != \"golang\" {\n+\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n+\t}\n+}"}, {"sha": "f3bbac5d19e1071a07b8e86029692b96b0bfb13b", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -86,12 +86,12 @@ func (c *ClientConn) dial(laddr string, lport int, raddr string, rport int) (*tc\n \t\tclientChan: ch,\n \t\tReader: &chanReader{\n \t\t\tpacketWriter: ch,\n-\t\t\tid:           ch.id,\n+\t\t\tpeersId:      ch.peersId,\n \t\t\tdata:         ch.data,\n \t\t},\n \t\tWriter: &chanWriter{\n \t\t\tpacketWriter: ch,\n-\t\t\tid:           ch.id,\n+\t\t\tpeersId:      ch.peersId,\n \t\t\twin:          ch.win,\n \t\t},\n \t}, nil"}, {"sha": "261297241e9edcc41c6f8bb464d8f616d6f9038e", "filename": "libgo/go/exp/ssh/tcpip_func_test.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip_func_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+// direct-tcpip functional tests\n+\n+import (\n+\t\"net\"\n+\t\"net/http\"\n+\t\"testing\"\n+)\n+\n+func TestTCPIPHTTP(t *testing.T) {\n+\tif *sshuser == \"\" {\n+\t\tt.Log(\"ssh.user not defined, skipping test\")\n+\t\treturn\n+\t}\n+\t// google.com will generate at least one redirect, possibly three\n+\t// depending on your location.\n+\tdoTest(t, \"http://google.com\")\n+}\n+\n+func TestTCPIPHTTPS(t *testing.T) {\n+\tif *sshuser == \"\" {\n+\t\tt.Log(\"ssh.user not defined, skipping test\")\n+\t\treturn\n+\t}\n+\tdoTest(t, \"https://encrypted.google.com/\")\n+}\n+\n+func doTest(t *testing.T, url string) {\n+\tconfig := &ClientConfig{\n+\t\tUser: *sshuser,\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(password(*sshpass)),\n+\t\t},\n+\t}\n+\tconn, err := Dial(\"tcp\", \"localhost:22\", config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to connect: %s\", err)\n+\t}\n+\tdefer conn.Close()\n+\ttr := &http.Transport{\n+\t\tDial: func(n, addr string) (net.Conn, error) {\n+\t\t\treturn conn.Dial(n, addr)\n+\t\t},\n+\t}\n+\tclient := &http.Client{\n+\t\tTransport: tr,\n+\t}\n+\tresp, err := client.Get(url)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to proxy: %s\", err)\n+\t}\n+\t// got a body without error\n+\tt.Log(resp)\n+}"}, {"sha": "bcd073e7ce6ec11451df55aa479fa316d0e01ee1", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -123,7 +123,7 @@ func (r *reader) readOnePacket() ([]byte, error) {\n \n \tif r.mac != nil {\n \t\tr.mac.Write(packet[:length-1])\n-\t\tif subtle.ConstantTimeCompare(r.mac.Sum(), mac) != 1 {\n+\t\tif subtle.ConstantTimeCompare(r.mac.Sum(nil), mac) != 1 {\n \t\t\treturn nil, errors.New(\"ssh: MAC failure\")\n \t\t}\n \t}\n@@ -201,7 +201,7 @@ func (w *writer) writePacket(packet []byte) error {\n \t}\n \n \tif w.mac != nil {\n-\t\tif _, err := w.Write(w.mac.Sum()); err != nil {\n+\t\tif _, err := w.Write(w.mac.Sum(nil)); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -297,7 +297,7 @@ func generateKeyMaterial(out, tag []byte, K, H, sessionId []byte, h hash.Hash) {\n \t\t\th.Write(digestsSoFar)\n \t\t}\n \n-\t\tdigest := h.Sum()\n+\t\tdigest := h.Sum(nil)\n \t\tn := copy(out, digest)\n \t\tout = out[n:]\n \t\tif len(out) > 0 {\n@@ -317,9 +317,9 @@ func (t truncatingMAC) Write(data []byte) (int, error) {\n \treturn t.hmac.Write(data)\n }\n \n-func (t truncatingMAC) Sum() []byte {\n-\tdigest := t.hmac.Sum()\n-\treturn digest[:t.length]\n+func (t truncatingMAC) Sum(in []byte) []byte {\n+\tout := t.hmac.Sum(in)\n+\treturn out[:len(in)+t.length]\n }\n \n func (t truncatingMAC) Reset() {"}, {"sha": "35535ea406f0c40c566bbd04c63ccfdb6fd6f43d", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -202,7 +202,7 @@ func TestCheck(t *testing.T) {\n \t// For easy debugging w/o changing the testing code,\n \t// if there is a local test file, only test that file.\n \tconst testfile = \"test.go\"\n-\tif fi, err := os.Stat(testfile); err == nil && fi.IsRegular() {\n+\tif fi, err := os.Stat(testfile); err == nil && !fi.IsDir() {\n \t\tfmt.Printf(\"WARNING: Testing only %s (remove it to run all tests)\\n\", testfile)\n \t\tcheck(t, testfile, []string{testfile})\n \t\treturn"}, {"sha": "16a8667ff669bcc1a9c69f120a3f15aa81212730", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -59,7 +59,7 @@ func findPkg(path string) (filename, id string) {\n \t// try extensions\n \tfor _, ext := range pkgExts {\n \t\tfilename = noext + ext\n-\t\tif f, err := os.Stat(filename); err == nil && f.IsRegular() {\n+\t\tif f, err := os.Stat(filename); err == nil && !f.IsDir() {\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "7475d352209fc7c308d34c28ba831b70892b63d0", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -58,32 +58,32 @@ func testPath(t *testing.T, path string) bool {\n \treturn true\n }\n \n-const maxTime = 3e9 // maximum allotted testing time in ns\n+const maxTime = 3 * time.Second\n \n-func testDir(t *testing.T, dir string, endTime int64) (nimports int) {\n+func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {\n \tdirname := filepath.Join(pkgRoot, dir)\n \tlist, err := ioutil.ReadDir(dirname)\n \tif err != nil {\n \t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n \t}\n \tfor _, f := range list {\n-\t\tif time.Nanoseconds() >= endTime {\n+\t\tif time.Now().After(endTime) {\n \t\t\tt.Log(\"testing time used up\")\n \t\t\treturn\n \t\t}\n \t\tswitch {\n-\t\tcase f.IsRegular():\n+\t\tcase !f.IsDir():\n \t\t\t// try extensions\n \t\t\tfor _, ext := range pkgExts {\n-\t\t\t\tif strings.HasSuffix(f.Name, ext) {\n-\t\t\t\t\tname := f.Name[0 : len(f.Name)-len(ext)] // remove extension\n+\t\t\t\tif strings.HasSuffix(f.Name(), ext) {\n+\t\t\t\t\tname := f.Name()[0 : len(f.Name())-len(ext)] // remove extension\n \t\t\t\t\tif testPath(t, filepath.Join(dir, name)) {\n \t\t\t\t\t\tnimports++\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\tcase f.IsDirectory():\n-\t\t\tnimports += testDir(t, filepath.Join(dir, f.Name), endTime)\n+\t\tcase f.IsDir():\n+\t\t\tnimports += testDir(t, filepath.Join(dir, f.Name()), endTime)\n \t\t}\n \t}\n \treturn\n@@ -96,6 +96,6 @@ func TestGcImport(t *testing.T) {\n \tif testPath(t, \"./testdata/exports\") {\n \t\tnimports++\n \t}\n-\tnimports += testDir(t, \"\", time.Nanoseconds()+maxTime) // installed packages\n+\tnimports += testDir(t, \"\", time.Now().Add(maxTime)) // installed packages\n \tt.Logf(\"tested %d imports\", nimports)\n }"}, {"sha": "00aac798cb0fbc845b90daf7eb75525daaa6499e", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -47,8 +47,10 @@ func TestFmtInterface(t *testing.T) {\n const b32 uint32 = 1<<32 - 1\n const b64 uint64 = 1<<64 - 1\n \n-var array = []int{1, 2, 3, 4, 5}\n-var iarray = []interface{}{1, \"hello\", 2.5, nil}\n+var array = [5]int{1, 2, 3, 4, 5}\n+var iarray = [4]interface{}{1, \"hello\", 2.5, nil}\n+var slice = array[:]\n+var islice = iarray[:]\n \n type A struct {\n \ti int\n@@ -327,6 +329,12 @@ var fmttests = []struct {\n \t{\"%v\", &array, \"&[1 2 3 4 5]\"},\n \t{\"%v\", &iarray, \"&[1 hello 2.5 <nil>]\"},\n \n+\t// slices\n+\t{\"%v\", slice, \"[1 2 3 4 5]\"},\n+\t{\"%v\", islice, \"[1 hello 2.5 <nil>]\"},\n+\t{\"%v\", &slice, \"&[1 2 3 4 5]\"},\n+\t{\"%v\", &islice, \"&[1 hello 2.5 <nil>]\"},\n+\n \t// complexes with %v\n \t{\"%v\", 1 + 2i, \"(1+2i)\"},\n \t{\"%v\", complex64(1 + 2i), \"(1+2i)\"},\n@@ -359,6 +367,10 @@ var fmttests = []struct {\n \t{\"%#v\", SI{}, `fmt_test.SI{I:interface {}(nil)}`},\n \t{\"%#v\", []int(nil), `[]int(nil)`},\n \t{\"%#v\", []int{}, `[]int{}`},\n+\t{\"%#v\", array, `[5]int{1, 2, 3, 4, 5}`},\n+\t{\"%#v\", &array, `&[5]int{1, 2, 3, 4, 5}`},\n+\t{\"%#v\", iarray, `[4]interface {}{1, \"hello\", 2.5, interface {}(nil)}`},\n+\t{\"%#v\", &iarray, `&[4]interface {}{1, \"hello\", 2.5, interface {}(nil)}`},\n \t{\"%#v\", map[int]byte(nil), `map[int] uint8(nil)`},\n \t{\"%#v\", map[int]byte{}, `map[int] uint8{}`},\n "}, {"sha": "e5ca1172405c1799efc7474144dc7f559e45477e", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -877,7 +877,7 @@ BigSwitch:\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(value.Type().String())\n-\t\t\tif f.IsNil() {\n+\t\t\tif f.Kind() == reflect.Slice && f.IsNil() {\n \t\t\t\tp.buf.WriteString(\"(nil)\")\n \t\t\t\tbreak\n \t\t\t}"}, {"sha": "c7c8e7c101e4faae0bd96c258afe4bf1f741c6b2", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -113,7 +113,7 @@ func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer,\n \t\t\t\timportErrors = true\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tpath, _ := strconv.Unquote(string(spec.Path.Value))\n+\t\t\tpath, _ := strconv.Unquote(spec.Path.Value)\n \t\t\tpkg, err := importer(imports, path)\n \t\t\tif err != nil {\n \t\t\t\tp.errorf(spec.Path.Pos(), \"could not import %s (%s)\", path, err)"}, {"sha": "5301ab53e519d43b0bcce89ba652db9f899b6ceb", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"regexp\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"time\"\n )\n \n // Build produces a build Script for the given package.\n@@ -150,21 +151,21 @@ func (s *Script) Run() error {\n \n // Stale returns true if the build's inputs are newer than its outputs.\n func (s *Script) Stale() bool {\n-\tvar latest int64\n+\tvar latest time.Time\n \t// get latest mtime of outputs\n \tfor _, file := range s.Output {\n \t\tfi, err := os.Stat(file)\n \t\tif err != nil {\n \t\t\t// any error reading output files means stale\n \t\t\treturn true\n \t\t}\n-\t\tif m := fi.Mtime_ns; m > latest {\n-\t\t\tlatest = m\n+\t\tif mtime := fi.ModTime(); mtime.After(latest) {\n+\t\t\tlatest = mtime\n \t\t}\n \t}\n \tfor _, file := range s.Input {\n \t\tfi, err := os.Stat(file)\n-\t\tif err != nil || fi.Mtime_ns > latest {\n+\t\tif err != nil || fi.ModTime().After(latest) {\n \t\t\t// any error reading input files means stale\n \t\t\t// (attempt to rebuild to figure out why)\n \t\t\treturn true"}, {"sha": "12dc99942a742de3db84817b5c2d0332fe9ef598", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -38,16 +38,16 @@ type Context struct {\n \t// format of the strings dir and file: they can be\n \t// slash-separated, backslash-separated, even URLs.\n \n-\t// ReadDir returns a slice of *os.FileInfo, sorted by Name,\n+\t// ReadDir returns a slice of os.FileInfo, sorted by Name,\n \t// describing the content of the named directory.\n \t// The dir argument is the argument to ScanDir.\n \t// If ReadDir is nil, ScanDir uses io.ReadDir.\n-\tReadDir func(dir string) (fi []*os.FileInfo, err error)\n+\tReadDir func(dir string) (fi []os.FileInfo, err error)\n \n \t// ReadFile returns the content of the file named file\n \t// in the directory named dir.  The dir argument is the\n \t// argument to ScanDir, and the file argument is the\n-\t// Name field from an *os.FileInfo returned by ReadDir.\n+\t// Name field from an os.FileInfo returned by ReadDir.\n \t// The returned path is the full name of the file, to be\n \t// used in error messages.\n \t//\n@@ -56,7 +56,7 @@ type Context struct {\n \tReadFile func(dir, file string) (path string, content []byte, err error)\n }\n \n-func (ctxt *Context) readDir(dir string) ([]*os.FileInfo, error) {\n+func (ctxt *Context) readDir(dir string) ([]os.FileInfo, error) {\n \tif f := ctxt.ReadDir; f != nil {\n \t\treturn f(dir)\n \t}\n@@ -140,18 +140,19 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \ttestImported := make(map[string]bool)\n \tfset := token.NewFileSet()\n \tfor _, d := range dirs {\n-\t\tif !d.IsRegular() {\n+\t\tif d.IsDir() {\n \t\t\tcontinue\n \t\t}\n-\t\tif strings.HasPrefix(d.Name, \"_\") ||\n-\t\t\tstrings.HasPrefix(d.Name, \".\") {\n+\t\tname := d.Name()\n+\t\tif strings.HasPrefix(name, \"_\") ||\n+\t\t\tstrings.HasPrefix(name, \".\") {\n \t\t\tcontinue\n \t\t}\n-\t\tif !ctxt.goodOSArchFile(d.Name) {\n+\t\tif !ctxt.goodOSArchFile(name) {\n \t\t\tcontinue\n \t\t}\n \n-\t\text := path.Ext(d.Name)\n+\t\text := path.Ext(name)\n \t\tswitch ext {\n \t\tcase \".go\", \".c\", \".s\":\n \t\t\t// tentatively okay\n@@ -161,7 +162,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t}\n \n \t\t// Look for +build comments to accept or reject the file.\n-\t\tfilename, data, err := ctxt.readFile(dir, d.Name)\n+\t\tfilename, data, err := ctxt.readFile(dir, name)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -172,10 +173,10 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t// Going to save the file.  For non-Go files, can stop here.\n \t\tswitch ext {\n \t\tcase \".c\":\n-\t\t\tdi.CFiles = append(di.CFiles, d.Name)\n+\t\t\tdi.CFiles = append(di.CFiles, name)\n \t\t\tcontinue\n \t\tcase \".s\":\n-\t\t\tdi.SFiles = append(di.SFiles, d.Name)\n+\t\t\tdi.SFiles = append(di.SFiles, name)\n \t\t\tcontinue\n \t\t}\n \n@@ -192,7 +193,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tisTest := strings.HasSuffix(d.Name, \"_test.go\")\n+\t\tisTest := strings.HasSuffix(name, \"_test.go\")\n \t\tif isTest && strings.HasSuffix(pkg, \"_test\") {\n \t\t\tpkg = pkg[:len(pkg)-len(\"_test\")]\n \t\t}\n@@ -255,15 +256,15 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\t}\n \t\t}\n \t\tif isCgo {\n-\t\t\tdi.CgoFiles = append(di.CgoFiles, d.Name)\n+\t\t\tdi.CgoFiles = append(di.CgoFiles, name)\n \t\t} else if isTest {\n \t\t\tif pkg == string(pf.Name.Name) {\n-\t\t\t\tdi.TestGoFiles = append(di.TestGoFiles, d.Name)\n+\t\t\t\tdi.TestGoFiles = append(di.TestGoFiles, name)\n \t\t\t} else {\n-\t\t\t\tdi.XTestGoFiles = append(di.XTestGoFiles, d.Name)\n+\t\t\t\tdi.XTestGoFiles = append(di.XTestGoFiles, name)\n \t\t\t}\n \t\t} else {\n-\t\t\tdi.GoFiles = append(di.GoFiles, d.Name)\n+\t\t\tdi.GoFiles = append(di.GoFiles, name)\n \t\t}\n \t}\n \tif di.Package == \"\" {"}, {"sha": "91d6c430a9d6e398900314fdd7de6b4c4ee5c3a8", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -70,7 +70,7 @@ func (t *Tree) HasSrc(pkg string) bool {\n \tif err != nil {\n \t\treturn false\n \t}\n-\treturn fi.IsDirectory()\n+\treturn fi.IsDir()\n }\n \n // HasPkg returns whether the given package's\n@@ -80,7 +80,7 @@ func (t *Tree) HasPkg(pkg string) bool {\n \tif err != nil {\n \t\treturn false\n \t}\n-\treturn fi.IsRegular()\n+\treturn !fi.IsDir()\n \t// TODO(adg): check object version is consistent\n }\n "}, {"sha": "d7bb384ed03c5f5f7774989dac0665b34b782e1e", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,11 +7,14 @@\n package doc\n \n import (\n+\t\"bytes\"\n \t\"go/ast\"\n \t\"io\"\n \t\"regexp\"\n \t\"strings\"\n \t\"text/template\" // for HTMLEscape\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n )\n \n func isWhitespace(ch byte) bool { return ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r' }\n@@ -168,6 +171,8 @@ var (\n \thtml_endp   = []byte(\"</p>\\n\")\n \thtml_pre    = []byte(\"<pre>\")\n \thtml_endpre = []byte(\"</pre>\\n\")\n+\thtml_h      = []byte(\"<h3>\")\n+\thtml_endh   = []byte(\"</h3>\\n\")\n )\n \n // Emphasize and escape a line of text for HTML. URLs are converted into links;\n@@ -268,6 +273,51 @@ func unindent(block [][]byte) {\n \t}\n }\n \n+// heading returns the (possibly trimmed) line if it passes as a valid section\n+// heading; otherwise it returns nil. \n+func heading(line []byte) []byte {\n+\tline = bytes.TrimSpace(line)\n+\tif len(line) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\t// a heading must start with an uppercase letter\n+\tr, _ := utf8.DecodeRune(line)\n+\tif !unicode.IsLetter(r) || !unicode.IsUpper(r) {\n+\t\treturn nil\n+\t}\n+\n+\t// it must end in a letter, digit or ':'\n+\tr, _ = utf8.DecodeLastRune(line)\n+\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != ':' {\n+\t\treturn nil\n+\t}\n+\n+\t// strip trailing ':', if any\n+\tif r == ':' {\n+\t\tline = line[0 : len(line)-1]\n+\t}\n+\n+\t// exclude lines with illegal characters\n+\tif bytes.IndexAny(line, \",.;:!?+*/=()[]{}_^\u00b0&\u00a7~%#@<\\\">\\\\\") >= 0 {\n+\t\treturn nil\n+\t}\n+\n+\t// allow \"'\" for possessive \"'s\" only\n+\tfor b := line; ; {\n+\t\ti := bytes.IndexRune(b, '\\'')\n+\t\tif i < 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif i+1 >= len(b) || b[i+1] != 's' || (i+2 < len(b) && b[i+2] != ' ') {\n+\t\t\treturn nil // not followed by \"s \"\n+\t\t}\n+\t\tb = b[i+2:]\n+\t}\n+\n+\treturn line\n+}\n+\n // Convert comment text to formatted HTML.\n // The comment was prepared by DocReader,\n // so it is known not to have leading, trailing blank lines\n@@ -276,6 +326,7 @@ func unindent(block [][]byte) {\n //\n // Turn each run of multiple \\n into </p><p>.\n // Turn each run of indented lines into a <pre> block without indent.\n+// Enclose headings with header tags.\n //\n // URLs in the comment text are converted into links; if the URL also appears\n // in the words map, the link is taken from the map (if the corresponding map\n@@ -286,6 +337,8 @@ func unindent(block [][]byte) {\n // into a link.\n func ToHTML(w io.Writer, s []byte, words map[string]string) {\n \tinpara := false\n+\tlastWasBlank := false\n+\tlastWasHeading := false\n \n \tclose := func() {\n \t\tif inpara {\n@@ -308,6 +361,7 @@ func ToHTML(w io.Writer, s []byte, words map[string]string) {\n \t\t\t// close paragraph\n \t\t\tclose()\n \t\t\ti++\n+\t\t\tlastWasBlank = true\n \t\t\tcontinue\n \t\t}\n \t\tif indentLen(line) > 0 {\n@@ -334,10 +388,30 @@ func ToHTML(w io.Writer, s []byte, words map[string]string) {\n \t\t\t\temphasize(w, line, nil, false) // no nice text formatting\n \t\t\t}\n \t\t\tw.Write(html_endpre)\n+\t\t\tlastWasHeading = false\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif lastWasBlank && !lastWasHeading && i+2 < len(lines) &&\n+\t\t\tisBlank(lines[i+1]) && !isBlank(lines[i+2]) && indentLen(lines[i+2]) == 0 {\n+\t\t\t// current line is non-blank, sourounded by blank lines\n+\t\t\t// and the next non-blank line is not indented: this\n+\t\t\t// might be a heading.\n+\t\t\tif head := heading(line); head != nil {\n+\t\t\t\tclose()\n+\t\t\t\tw.Write(html_h)\n+\t\t\t\ttemplate.HTMLEscape(w, head)\n+\t\t\t\tw.Write(html_endh)\n+\t\t\t\ti += 2\n+\t\t\t\tlastWasHeading = true\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n \t\t// open paragraph\n \t\topen()\n+\t\tlastWasBlank = false\n+\t\tlastWasHeading = false\n \t\temphasize(w, lines[i], words, true) // nice text formatting\n \t\ti++\n \t}"}, {"sha": "870660ad62828b4a093d26ff3cf8a4a3567e4dd6", "filename": "libgo/go/go/doc/comment_test.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var headingTests = []struct {\n+\tline string\n+\tok   bool\n+}{\n+\t{\"Section\", true},\n+\t{\"A typical usage\", true},\n+\t{\"\u0394\u039b\u039e is Greek\", true},\n+\t{\"Foo 42\", true},\n+\t{\"\", false},\n+\t{\"section\", false},\n+\t{\"A typical usage:\", true},\n+\t{\"\u03b4 is Greek\", false},\n+\t{\"Foo \u00a7\", false},\n+\t{\"Fermat's Last Sentence\", true},\n+\t{\"Fermat's\", true},\n+\t{\"'sX\", false},\n+\t{\"Ted 'Too' Bar\", false},\n+\t{\"Use n+m\", false},\n+\t{\"Scanning:\", true},\n+\t{\"N:M\", false},\n+}\n+\n+func TestIsHeading(t *testing.T) {\n+\tfor _, tt := range headingTests {\n+\t\tif h := heading([]byte(tt.line)); (h != nil) != tt.ok {\n+\t\t\tt.Errorf(\"isHeading(%q) = %v, want %v\", tt.line, h, tt.ok)\n+\t\t}\n+\t}\n+}"}, {"sha": "83f24627c956fcfebad171cafc3e620d8c366266", "filename": "libgo/go/go/doc/headscan.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+\tThe headscan command extracts comment headings from package files;\n+\tit is used to detect false positives which may require an adjustment\n+\tto the comment formatting heuristics in comment.go.\n+\n+\tUsage: headscan [-root root_directory]\n+\n+\tBy default, the $GOROOT/src directory is scanned.\n+*/\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/doc\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+)\n+\n+var (\n+\troot    = flag.String(\"root\", filepath.Join(runtime.GOROOT(), \"src\"), \"root of filesystem tree to scan\")\n+\tverbose = flag.Bool(\"v\", false, \"verbose mode\")\n+)\n+\n+const (\n+\thtml_h    = \"<h3>\"\n+\thtml_endh = \"</h3>\\n\"\n+)\n+\n+func isGoFile(fi os.FileInfo) bool {\n+\treturn strings.HasSuffix(fi.Name(), \".go\") &&\n+\t\t!strings.HasSuffix(fi.Name(), \"_test.go\")\n+}\n+\n+func appendHeadings(list []string, comment string) []string {\n+\tvar buf bytes.Buffer\n+\tdoc.ToHTML(&buf, []byte(comment), nil)\n+\tfor s := buf.String(); ; {\n+\t\ti := strings.Index(s, html_h)\n+\t\tif i < 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\ti += len(html_h)\n+\t\tj := strings.Index(s, html_endh)\n+\t\tif j < 0 {\n+\t\t\tlist = append(list, s[i:]) // incorrect HTML\n+\t\t\tbreak\n+\t\t}\n+\t\tlist = append(list, s[i:j])\n+\t\ts = s[j+len(html_endh):]\n+\t}\n+\treturn list\n+}\n+\n+func main() {\n+\tflag.Parse()\n+\tfset := token.NewFileSet()\n+\tnheadings := 0\n+\terr := filepath.Walk(*root, func(path string, fi os.FileInfo, err error) error {\n+\t\tif !fi.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tpkgs, err := parser.ParseDir(fset, path, isGoFile, parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\tif *verbose {\n+\t\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t\tfor _, pkg := range pkgs {\n+\t\t\td := doc.NewPackageDoc(pkg, path)\n+\t\t\tlist := appendHeadings(nil, d.Doc)\n+\t\t\tfor _, d := range d.Consts {\n+\t\t\t\tlist = appendHeadings(list, d.Doc)\n+\t\t\t}\n+\t\t\tfor _, d := range d.Types {\n+\t\t\t\tlist = appendHeadings(list, d.Doc)\n+\t\t\t}\n+\t\t\tfor _, d := range d.Vars {\n+\t\t\t\tlist = appendHeadings(list, d.Doc)\n+\t\t\t}\n+\t\t\tfor _, d := range d.Funcs {\n+\t\t\t\tlist = appendHeadings(list, d.Doc)\n+\t\t\t}\n+\t\t\tif len(list) > 0 {\n+\t\t\t\t// directories may contain multiple packages;\n+\t\t\t\t// print path and package name\n+\t\t\t\tfmt.Printf(\"%s (package %s)\\n\", path, pkg.Name)\n+\t\t\t\tfor _, h := range list {\n+\t\t\t\t\tfmt.Printf(\"\\t%s\\n\", h)\n+\t\t\t\t}\n+\t\t\t\tnheadings += len(list)\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println(nheadings, \"headings found\")\n+}"}, {"sha": "be11f461c3b33b7351811c60335aad41c7761030", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -188,7 +188,7 @@ func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[st\n // returned. If a parse error occurred, a non-nil but incomplete map and the\n // error are returned.\n //\n-func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool, mode uint) (map[string]*ast.Package, error) {\n+func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode uint) (map[string]*ast.Package, error) {\n \tfd, err := os.Open(path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -202,10 +202,9 @@ func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool,\n \n \tfilenames := make([]string, len(list))\n \tn := 0\n-\tfor i := 0; i < len(list); i++ {\n-\t\td := &list[i]\n+\tfor _, d := range list {\n \t\tif filter == nil || filter(d) {\n-\t\t\tfilenames[n] = filepath.Join(path, d.Name)\n+\t\t\tfilenames[n] = filepath.Join(path, d.Name())\n \t\t\tn++\n \t\t}\n \t}"}, {"sha": "f602db8896db5e02e6fe962a98d0f3a656f21fd4", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -113,7 +113,7 @@ func nameFilter(filename string) bool {\n \treturn true\n }\n \n-func dirFilter(f *os.FileInfo) bool { return nameFilter(f.Name) }\n+func dirFilter(f os.FileInfo) bool { return nameFilter(f.Name()) }\n \n func TestParse4(t *testing.T) {\n \tpath := \".\""}, {"sha": "53f36092fdafd6c3cd5715014b839931d0c141ce", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1377,7 +1377,7 @@ func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {\n \t// in RawFormat\n \tcfg := Config{Mode: RawFormat}\n \tvar buf bytes.Buffer\n-\tif _, err := cfg.fprint(&buf, p.fset, n, p.nodeSizes); err != nil {\n+\tif err := cfg.fprint(&buf, p.fset, n, p.nodeSizes); err != nil {\n \t\treturn\n \t}\n \tif buf.Len() <= maxSize {"}, {"sha": "dbd942292b537c83ccd3a7b7b9f6384fda5c1f2c", "filename": "libgo/go/go/printer/performance_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -20,7 +20,7 @@ import (\n var testfile *ast.File\n \n func testprint(out io.Writer, file *ast.File) {\n-\tif _, err := (&Config{TabIndent | UseSpaces, 8}).Fprint(out, fset, file); err != nil {\n+\tif err := (&Config{TabIndent | UseSpaces, 8}).Fprint(out, fset, file); err != nil {\n \t\tlog.Fatalf(\"print error: %s\", err)\n \t}\n }"}, {"sha": "f8c22f1419d0bd1f8ea8e6eddc331e70198a826e", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 185, "deletions": 216, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -19,9 +19,9 @@ import (\n )\n \n const debug = false // enable for debugging\n+const infinity = 1 << 30\n \n-\n-type whiteSpace int\n+type whiteSpace byte\n \n const (\n \tignore   = whiteSpace(0)\n@@ -33,50 +33,27 @@ const (\n \tunindent = whiteSpace('<')\n )\n \n-var (\n-\tesc       = []byte{tabwriter.Escape}\n-\thtab      = []byte{'\\t'}\n-\thtabs     = []byte(\"\\t\\t\\t\\t\\t\\t\\t\\t\")\n-\tnewlines  = []byte(\"\\n\\n\\n\\n\\n\\n\\n\\n\") // more than the max determined by nlines\n-\tformfeeds = []byte(\"\\f\\f\\f\\f\\f\\f\\f\\f\") // more than the max determined by nlines\n-)\n-\n-// Special positions\n-var noPos token.Position // use noPos when a position is needed but not known\n-var infinity = 1 << 30\n-\n // Use ignoreMultiLine if the multiLine information is not important.\n var ignoreMultiLine = new(bool)\n \n // A pmode value represents the current printer mode.\n type pmode int\n \n const (\n-\tinLiteral pmode = 1 << iota\n-\tnoExtraLinebreak\n+\tnoExtraLinebreak pmode = 1 << iota\n )\n \n-// local error wrapper so we can distinguish errors we want to return\n-// as errors from genuine panics (which we don't want to return as errors)\n-type osError struct {\n-\terr error\n-}\n-\n type printer struct {\n \t// Configuration (does not change after initialization)\n-\toutput io.Writer\n \tConfig\n \tfset *token.FileSet\n \n \t// Current state\n-\twritten int         // number of bytes written\n-\tindent  int         // current indentation\n-\tmode    pmode       // current printer mode\n-\tlastTok token.Token // the last token printed (token.ILLEGAL if it's whitespace)\n-\n-\t// Reused buffers\n-\twsbuf  []whiteSpace // delayed white space\n-\tlitbuf bytes.Buffer // for creation of escaped literals and comments\n+\toutput  bytes.Buffer // raw printer result\n+\tindent  int          // current indentation\n+\tmode    pmode        // current printer mode\n+\tlastTok token.Token  // the last token printed (token.ILLEGAL if it's whitespace)\n+\twsbuf   []whiteSpace // delayed white space\n \n \t// The (possibly estimated) position in the generated output;\n \t// in AST space (i.e., pos is set whenever a token position is\n@@ -97,8 +74,7 @@ type printer struct {\n \tnodeSizes map[ast.Node]int\n }\n \n-func (p *printer) init(output io.Writer, cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]int) {\n-\tp.output = output\n+func (p *printer) init(cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]int) {\n \tp.Config = *cfg\n \tp.fset = fset\n \tp.wsbuf = make([]whiteSpace, 0, 16) // whitespace sequences are short\n@@ -113,19 +89,6 @@ func (p *printer) internalError(msg ...interface{}) {\n \t}\n }\n \n-// escape escapes string s by bracketing it with tabwriter.Escape.\n-// Escaped strings pass through tabwriter unchanged. (Note that\n-// valid Go programs cannot contain tabwriter.Escape bytes since\n-// they do not appear in legal UTF-8 sequences).\n-//\n-func (p *printer) escape(s string) string {\n-\tp.litbuf.Reset()\n-\tp.litbuf.WriteByte(tabwriter.Escape)\n-\tp.litbuf.WriteString(s)\n-\tp.litbuf.WriteByte(tabwriter.Escape)\n-\treturn p.litbuf.String()\n-}\n-\n // nlines returns the adjusted number of linebreaks given the desired number\n // of breaks n such that min <= result <= max.\n //\n@@ -140,82 +103,79 @@ func (p *printer) nlines(n, min int) int {\n \treturn n\n }\n \n-// write0 writes raw (uninterpreted) data to p.output and handles errors.\n-// write0 does not indent after newlines, and does not HTML-escape or update p.pos.\n-//\n-func (p *printer) write0(data []byte) {\n-\tif len(data) > 0 {\n-\t\tn, err := p.output.Write(data)\n-\t\tp.written += n\n-\t\tif err != nil {\n-\t\t\tpanic(osError{err})\n-\t\t}\n+// writeByte writes a single byte to p.output and updates p.pos.\n+func (p *printer) writeByte(ch byte) {\n+\tp.output.WriteByte(ch)\n+\tp.pos.Offset++\n+\tp.pos.Column++\n+\n+\tif ch == '\\n' || ch == '\\f' {\n+\t\t// write indentation\n+\t\t// use \"hard\" htabs - indentation columns\n+\t\t// must not be discarded by the tabwriter\n+\t\tconst htabs = \"\\t\\t\\t\\t\\t\\t\\t\\t\"\n+\t\tj := p.indent\n+\t\tfor j > len(htabs) {\n+\t\t\tp.output.WriteString(htabs)\n+\t\t\tj -= len(htabs)\n+\t\t}\n+\t\tp.output.WriteString(htabs[0:j])\n+\n+\t\t// update p.pos\n+\t\tp.pos.Line++\n+\t\tp.pos.Offset += p.indent\n+\t\tp.pos.Column = 1 + p.indent\n \t}\n }\n \n-// write interprets data and writes it to p.output. It inserts indentation\n-// after a line break unless in a tabwriter escape sequence.\n-// It updates p.pos as a side-effect.\n+// writeNewlines writes up to n newlines to p.output and updates p.pos.\n+// The actual number of newlines written is limited by nlines.\n+// nl must be one of '\\n' or '\\f'.\n //\n-func (p *printer) write(data []byte) {\n-\ti0 := 0\n-\tfor i, b := range data {\n-\t\tswitch b {\n-\t\tcase '\\n', '\\f':\n-\t\t\t// write segment ending in b\n-\t\t\tp.write0(data[i0 : i+1])\n-\n-\t\t\t// update p.pos\n-\t\t\tp.pos.Offset += i + 1 - i0\n-\t\t\tp.pos.Line++\n-\t\t\tp.pos.Column = 1\n-\n-\t\t\tif p.mode&inLiteral == 0 {\n-\t\t\t\t// write indentation\n-\t\t\t\t// use \"hard\" htabs - indentation columns\n-\t\t\t\t// must not be discarded by the tabwriter\n-\t\t\t\tj := p.indent\n-\t\t\t\tfor ; j > len(htabs); j -= len(htabs) {\n-\t\t\t\t\tp.write0(htabs)\n-\t\t\t\t}\n-\t\t\t\tp.write0(htabs[0:j])\n-\n-\t\t\t\t// update p.pos\n-\t\t\t\tp.pos.Offset += p.indent\n-\t\t\t\tp.pos.Column += p.indent\n-\t\t\t}\n-\n-\t\t\t// next segment start\n-\t\t\ti0 = i + 1\n-\n-\t\tcase tabwriter.Escape:\n-\t\t\tp.mode ^= inLiteral\n+func (p *printer) writeNewlines(n int, nl byte) {\n+\tfor n = p.nlines(n, 0); n > 0; n-- {\n+\t\tp.writeByte(nl)\n+\t}\n+}\n \n-\t\t\t// ignore escape chars introduced by printer - they are\n-\t\t\t// invisible and must not affect p.pos (was issue #1089)\n-\t\t\tp.pos.Offset--\n-\t\t\tp.pos.Column--\n-\t\t}\n+// writeString writes the string s to p.output and updates p.pos.\n+// If isLit is set, s is escaped w/ tabwriter.Escape characters\n+// to protect s from being interpreted by the tabwriter.\n+//\n+// Note: writeString is only used to write Go tokens, literals, and\n+// comments, all of which must be written literally. Thus, it is correct\n+// to always set isLit = true. However, setting it explicitly only when\n+// needed (i.e., when we don't know that s contains no tabs or line breaks)\n+// avoids processing extra escape characters and reduces run time of the\n+// printer benchmark by up to 10%.\n+//\n+func (p *printer) writeString(s string, isLit bool) {\n+\tif isLit {\n+\t\t// Protect s such that is passes through the tabwriter\n+\t\t// unchanged. Note that valid Go programs cannot contain\n+\t\t// tabwriter.Escape bytes since they do not appear in legal\n+\t\t// UTF-8 sequences.\n+\t\tp.output.WriteByte(tabwriter.Escape)\n \t}\n \n-\t// write remaining segment\n-\tp.write0(data[i0:])\n+\tp.output.WriteString(s)\n \n \t// update p.pos\n-\td := len(data) - i0\n-\tp.pos.Offset += d\n-\tp.pos.Column += d\n-}\n-\n-func (p *printer) writeNewlines(n int, useFF bool) {\n-\tif n > 0 {\n-\t\tn = p.nlines(n, 0)\n-\t\tif useFF {\n-\t\t\tp.write(formfeeds[0:n])\n-\t\t} else {\n-\t\t\tp.write(newlines[0:n])\n+\tnlines := 0\n+\tcolumn := p.pos.Column + len(s)\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == '\\n' {\n+\t\t\tnlines++\n+\t\t\tcolumn = len(s) - i\n \t\t}\n \t}\n+\tp.pos.Offset += len(s)\n+\tp.pos.Line += nlines\n+\tp.pos.Column = column\n+\n+\tif isLit {\n+\t\tp.output.WriteByte(tabwriter.Escape)\n+\t}\n }\n \n // writeItem writes data at position pos. data is the text corresponding to\n@@ -224,7 +184,7 @@ func (p *printer) writeNewlines(n int, useFF bool) {\n // source text. writeItem updates p.last to the position immediately following\n // the data.\n //\n-func (p *printer) writeItem(pos token.Position, data string) {\n+func (p *printer) writeItem(pos token.Position, data string, isLit bool) {\n \tif pos.IsValid() {\n \t\t// continue with previous position if we don't have a valid pos\n \t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n@@ -240,9 +200,9 @@ func (p *printer) writeItem(pos token.Position, data string) {\n \tif debug {\n \t\t// do not update p.pos - use write0\n \t\t_, filename := filepath.Split(pos.Filename)\n-\t\tp.write0([]byte(fmt.Sprintf(\"[%s:%d:%d]\", filename, pos.Line, pos.Column)))\n+\t\tfmt.Fprintf(&p.output, \"[%s:%d:%d]\", filename, pos.Line, pos.Column)\n \t}\n-\tp.write([]byte(data))\n+\tp.writeString(data, isLit)\n \tp.last = p.pos\n }\n \n@@ -257,14 +217,14 @@ const linePrefix = \"//line \"\n // next item is a keyword.\n //\n func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *ast.Comment, isKeyword bool) {\n-\tif p.written == 0 {\n+\tif p.output.Len() == 0 {\n \t\t// the comment is the first item to be printed - don't write any whitespace\n \t\treturn\n \t}\n \n \tif pos.IsValid() && pos.Filename != p.last.Filename {\n \t\t// comment in a different file - separate with newlines (writeNewlines will limit the number)\n-\t\tp.writeNewlines(10, true)\n+\t\tp.writeNewlines(10, '\\f')\n \t\treturn\n \t}\n \n@@ -297,14 +257,14 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\t}\n \t\t// make sure there is at least one separator\n \t\tif !hasSep {\n+\t\t\tsep := byte('\\t')\n \t\t\tif pos.Line == next.Line {\n \t\t\t\t// next item is on the same line as the comment\n \t\t\t\t// (which must be a /*-style comment): separate\n \t\t\t\t// with a blank instead of a tab\n-\t\t\t\tp.write([]byte{' '})\n-\t\t\t} else {\n-\t\t\t\tp.write(htab)\n+\t\t\t\tsep = ' '\n \t\t\t}\n+\t\t\tp.writeByte(sep)\n \t\t}\n \n \t} else {\n@@ -357,30 +317,31 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\tif n <= 0 && prev != nil && prev.Text[1] == '/' {\n \t\t\tn = 1\n \t\t}\n-\t\tp.writeNewlines(n, true)\n+\t\tif n > 0 {\n+\t\t\tp.writeNewlines(n, '\\f')\n+\t\t}\n \t\tp.indent = indent\n \t}\n }\n \n-// TODO(gri): It should be possible to convert the code below from using\n-//            []byte to string and in the process eliminate some conversions.\n-\n // Split comment text into lines\n-func split(text []byte) [][]byte {\n+// (using strings.Split(text, \"\\n\") is significantly slower for\n+// this specific purpose, as measured with: gotest -bench=Print)\n+func split(text string) []string {\n \t// count lines (comment text never ends in a newline)\n \tn := 1\n-\tfor _, c := range text {\n-\t\tif c == '\\n' {\n+\tfor i := 0; i < len(text); i++ {\n+\t\tif text[i] == '\\n' {\n \t\t\tn++\n \t\t}\n \t}\n \n \t// split\n-\tlines := make([][]byte, n)\n+\tlines := make([]string, n)\n \tn = 0\n \ti := 0\n-\tfor j, c := range text {\n-\t\tif c == '\\n' {\n+\tfor j := 0; j < len(text); j++ {\n+\t\tif text[j] == '\\n' {\n \t\t\tlines[n] = text[i:j] // exclude newline\n \t\t\ti = j + 1            // discard newline\n \t\t\tn++\n@@ -391,24 +352,26 @@ func split(text []byte) [][]byte {\n \treturn lines\n }\n \n-func isBlank(s []byte) bool {\n-\tfor _, b := range s {\n-\t\tif b > ' ' {\n+// Returns true if s contains only white space\n+// (only tabs and blanks can appear in the printer's context).\n+func isBlank(s string) bool {\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] > ' ' {\n \t\t\treturn false\n \t\t}\n \t}\n \treturn true\n }\n \n-func commonPrefix(a, b []byte) []byte {\n+func commonPrefix(a, b string) string {\n \ti := 0\n \tfor i < len(a) && i < len(b) && a[i] == b[i] && (a[i] <= ' ' || a[i] == '*') {\n \t\ti++\n \t}\n \treturn a[0:i]\n }\n \n-func stripCommonPrefix(lines [][]byte) {\n+func stripCommonPrefix(lines []string) {\n \tif len(lines) < 2 {\n \t\treturn // at most one line - nothing to do\n \t}\n@@ -432,19 +395,21 @@ func stripCommonPrefix(lines [][]byte) {\n \t// Note that the first and last line are never empty (they\n \t// contain the opening /* and closing */ respectively) and\n \t// thus they can be ignored by the blank line check.\n-\tvar prefix []byte\n+\tvar prefix string\n \tif len(lines) > 2 {\n+\t\tfirst := true\n \t\tfor i, line := range lines[1 : len(lines)-1] {\n \t\t\tswitch {\n \t\t\tcase isBlank(line):\n-\t\t\t\tlines[1+i] = nil // range starts at line 1\n-\t\t\tcase prefix == nil:\n+\t\t\t\tlines[1+i] = \"\" // range starts at line 1\n+\t\t\tcase first:\n \t\t\t\tprefix = commonPrefix(line, line)\n+\t\t\t\tfirst = false\n \t\t\tdefault:\n \t\t\t\tprefix = commonPrefix(prefix, line)\n \t\t\t}\n \t\t}\n-\t} else { // len(lines) == 2\n+\t} else { // len(lines) == 2, lines cannot be blank (contain /* and */)\n \t\tline := lines[1]\n \t\tprefix = commonPrefix(line, line)\n \t}\n@@ -453,7 +418,7 @@ func stripCommonPrefix(lines [][]byte) {\n \t * Check for vertical \"line of stars\" and correct prefix accordingly.\n \t */\n \tlineOfStars := false\n-\tif i := bytes.Index(prefix, []byte{'*'}); i >= 0 {\n+\tif i := strings.Index(prefix, \"*\"); i >= 0 {\n \t\t// Line of stars present.\n \t\tif i > 0 && prefix[i-1] == ' ' {\n \t\t\ti-- // remove trailing blank from prefix so stars remain aligned\n@@ -501,7 +466,7 @@ func stripCommonPrefix(lines [][]byte) {\n \t\t\t}\n \t\t\t// Shorten the computed common prefix by the length of\n \t\t\t// suffix, if it is found as suffix of the prefix.\n-\t\t\tif bytes.HasSuffix(prefix, suffix) {\n+\t\t\tif strings.HasSuffix(prefix, string(suffix)) {\n \t\t\t\tprefix = prefix[0 : len(prefix)-len(suffix)]\n \t\t\t}\n \t\t}\n@@ -511,19 +476,18 @@ func stripCommonPrefix(lines [][]byte) {\n \t// with the opening /*, otherwise align the text with the other\n \t// lines.\n \tlast := lines[len(lines)-1]\n-\tclosing := []byte(\"*/\")\n-\ti := bytes.Index(last, closing)\n+\tclosing := \"*/\"\n+\ti := strings.Index(last, closing) // i >= 0 (closing is always present)\n \tif isBlank(last[0:i]) {\n \t\t// last line only contains closing */\n-\t\tvar sep []byte\n \t\tif lineOfStars {\n-\t\t\t// insert an aligning blank\n-\t\t\tsep = []byte{' '}\n+\t\t\tclosing = \" */\" // add blank to align final star\n \t\t}\n-\t\tlines[len(lines)-1] = bytes.Join([][]byte{prefix, closing}, sep)\n+\t\tlines[len(lines)-1] = prefix + closing\n \t} else {\n \t\t// last line contains more comment text - assume\n-\t\t// it is aligned like the other lines\n+\t\t// it is aligned like the other lines and include\n+\t\t// in prefix computation\n \t\tprefix = commonPrefix(prefix, last)\n \t}\n \n@@ -549,9 +513,9 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \t\t\t// update our own idea of the file and line number\n \t\t\t// accordingly, after printing the directive.\n \t\t\tfile := pos[:i]\n-\t\t\tline, _ := strconv.Atoi(string(pos[i+1:]))\n+\t\t\tline, _ := strconv.Atoi(pos[i+1:])\n \t\t\tdefer func() {\n-\t\t\t\tp.pos.Filename = string(file)\n+\t\t\t\tp.pos.Filename = file\n \t\t\t\tp.pos.Line = line\n \t\t\t\tp.pos.Column = 1\n \t\t\t}()\n@@ -560,26 +524,25 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \n \t// shortcut common case of //-style comments\n \tif text[1] == '/' {\n-\t\tp.writeItem(p.fset.Position(comment.Pos()), p.escape(text))\n+\t\tp.writeItem(p.fset.Position(comment.Pos()), text, true)\n \t\treturn\n \t}\n \n \t// for /*-style comments, print line by line and let the\n \t// write function take care of the proper indentation\n-\tlines := split([]byte(text))\n+\tlines := split(text)\n \tstripCommonPrefix(lines)\n \n \t// write comment lines, separated by formfeed,\n \t// without a line break after the last line\n-\tlinebreak := formfeeds[0:1]\n \tpos := p.fset.Position(comment.Pos())\n \tfor i, line := range lines {\n \t\tif i > 0 {\n-\t\t\tp.write(linebreak)\n+\t\t\tp.writeByte('\\f')\n \t\t\tpos = p.pos\n \t\t}\n \t\tif len(line) > 0 {\n-\t\t\tp.writeItem(pos, p.escape(string(line)))\n+\t\t\tp.writeItem(pos, line, true)\n \t\t}\n \t}\n }\n@@ -615,7 +578,7 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n \n \t// make sure we have a line break\n \tif needsLinebreak {\n-\t\tp.write([]byte{'\\n'})\n+\t\tp.writeByte('\\n')\n \t}\n \n \treturn\n@@ -641,7 +604,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (dro\n \t\tif last.Text[1] == '*' && p.fset.Position(last.Pos()).Line == next.Line {\n \t\t\t// the last comment is a /*-style comment and the next item\n \t\t\t// follows on the same line: separate with an extra blank\n-\t\t\tp.write([]byte{' '})\n+\t\t\tp.writeByte(' ')\n \t\t}\n \t\t// ensure that there is a line break after a //-style comment,\n \t\t// before a closing '}' unless explicitly disabled, or at eof\n@@ -661,7 +624,6 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (dro\n // whiteWhitespace writes the first n whitespace entries.\n func (p *printer) writeWhitespace(n int) {\n \t// write entries\n-\tvar data [1]byte\n \tfor i := 0; i < n; i++ {\n \t\tswitch ch := p.wsbuf[i]; ch {\n \t\tcase ignore:\n@@ -693,8 +655,7 @@ func (p *printer) writeWhitespace(n int) {\n \t\t\t}\n \t\t\tfallthrough\n \t\tdefault:\n-\t\t\tdata[0] = byte(ch)\n-\t\t\tp.write(data[0:])\n+\t\t\tp.writeByte(byte(ch))\n \t\t}\n \t}\n \n@@ -710,7 +671,6 @@ func (p *printer) writeWhitespace(n int) {\n // ----------------------------------------------------------------------------\n // Printing interface\n \n-\n func mayCombine(prev token.Token, next byte) (b bool) {\n \tswitch prev {\n \tcase token.INT:\n@@ -743,7 +703,8 @@ func mayCombine(prev token.Token, next byte) (b bool) {\n func (p *printer) print(args ...interface{}) {\n \tfor _, f := range args {\n \t\tnext := p.pos // estimated position of next item\n-\t\tvar data string\n+\t\tdata := \"\"\n+\t\tisLit := false\n \t\tvar tok token.Token\n \n \t\tswitch x := f.(type) {\n@@ -771,7 +732,8 @@ func (p *printer) print(args ...interface{}) {\n \t\t\tdata = x.Name\n \t\t\ttok = token.IDENT\n \t\tcase *ast.BasicLit:\n-\t\t\tdata = p.escape(x.Value)\n+\t\t\tdata = x.Value\n+\t\t\tisLit = true\n \t\t\ttok = x.Kind\n \t\tcase token.Token:\n \t\t\ts := x.String()\n@@ -803,15 +765,20 @@ func (p *printer) print(args ...interface{}) {\n \t\tp.pos = next\n \n \t\tif data != \"\" {\n-\t\t\tdroppedFF := p.flush(next, tok)\n+\t\t\tnl := byte('\\n')\n+\t\t\tif p.flush(next, tok) {\n+\t\t\t\tnl = '\\f' // dropped formfeed before\n+\t\t\t}\n \n \t\t\t// intersperse extra newlines if present in the source\n \t\t\t// (don't do this in flush as it will cause extra newlines\n \t\t\t// at the end of a file) - use formfeeds if we dropped one\n \t\t\t// before\n-\t\t\tp.writeNewlines(next.Line-p.pos.Line, droppedFF)\n+\t\t\tif n := next.Line - p.pos.Line; n > 0 {\n+\t\t\t\tp.writeNewlines(n, nl)\n+\t\t\t}\n \n-\t\t\tp.writeItem(next, data)\n+\t\t\tp.writeItem(next, data, isLit)\n \t\t}\n \t}\n }\n@@ -840,6 +807,35 @@ func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n \treturn\n }\n \n+func (p *printer) printNode(node interface{}) error {\n+\tswitch n := node.(type) {\n+\tcase ast.Expr:\n+\t\tp.useNodeComments = true\n+\t\tp.expr(n, ignoreMultiLine)\n+\tcase ast.Stmt:\n+\t\tp.useNodeComments = true\n+\t\t// A labeled statement will un-indent to position the\n+\t\t// label. Set indent to 1 so we don't get indent \"underflow\".\n+\t\tif _, labeledStmt := n.(*ast.LabeledStmt); labeledStmt {\n+\t\t\tp.indent = 1\n+\t\t}\n+\t\tp.stmt(n, false, ignoreMultiLine)\n+\tcase ast.Decl:\n+\t\tp.useNodeComments = true\n+\t\tp.decl(n, ignoreMultiLine)\n+\tcase ast.Spec:\n+\t\tp.useNodeComments = true\n+\t\tp.spec(n, 1, false, ignoreMultiLine)\n+\tcase *ast.File:\n+\t\tp.comments = n.Comments\n+\t\tp.useNodeComments = n.Comments == nil\n+\t\tp.file(n)\n+\tdefault:\n+\t\treturn fmt.Errorf(\"go/printer: unsupported node type %T\", n)\n+\t}\n+\treturn nil\n+}\n+\n // ----------------------------------------------------------------------------\n // Trimmer\n \n@@ -869,6 +865,8 @@ const (\n //              However, this would mess up any formatting done by\n //              the tabwriter.\n \n+var aNewline = []byte(\"\\n\")\n+\n func (p *trimmer) Write(data []byte) (n int, err error) {\n \t// invariants:\n \t// p.state == inSpace:\n@@ -887,8 +885,8 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n \t\t\tcase '\\t', ' ':\n \t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n \t\t\tcase '\\n', '\\f':\n-\t\t\t\tp.space.Reset()                        // discard trailing space\n-\t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n+\t\t\t\tp.space.Reset() // discard trailing space\n+\t\t\t\t_, err = p.output.Write(aNewline)\n \t\t\tcase tabwriter.Escape:\n \t\t\t\t_, err = p.output.Write(p.space.Bytes())\n \t\t\t\tp.state = inEscape\n@@ -915,7 +913,7 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inSpace\n \t\t\t\tp.space.Reset()\n-\t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n+\t\t\t\t_, err = p.output.Write(aNewline)\n \t\t\tcase tabwriter.Escape:\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inEscape\n@@ -957,15 +955,22 @@ type Config struct {\n }\n \n // fprint implements Fprint and takes a nodesSizes map for setting up the printer state.\n-func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{}, nodeSizes map[ast.Node]int) (written int, err error) {\n+func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{}, nodeSizes map[ast.Node]int) (err error) {\n+\t// print node\n+\tvar p printer\n+\tp.init(cfg, fset, nodeSizes)\n+\tif err = p.printNode(node); err != nil {\n+\t\treturn\n+\t}\n+\tp.flush(token.Position{Offset: infinity, Line: infinity}, token.EOF)\n+\n \t// redirect output through a trimmer to eliminate trailing whitespace\n \t// (Input to a tabwriter must be untrimmed since trailing tabs provide\n \t// formatting information. The tabwriter could provide trimming\n \t// functionality but no tabwriter is used when RawFormat is set.)\n \toutput = &trimmer{output: output}\n \n-\t// setup tabwriter if needed and redirect output\n-\tvar tw *tabwriter.Writer\n+\t// redirect output through a tabwriter if necessary\n \tif cfg.Mode&RawFormat == 0 {\n \t\tminwidth := cfg.Tabwidth\n \n@@ -980,70 +985,34 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n \t\t\ttwmode |= tabwriter.TabIndent\n \t\t}\n \n-\t\ttw = tabwriter.NewWriter(output, minwidth, cfg.Tabwidth, 1, padchar, twmode)\n-\t\toutput = tw\n+\t\toutput = tabwriter.NewWriter(output, minwidth, cfg.Tabwidth, 1, padchar, twmode)\n \t}\n \n-\t// setup printer\n-\tvar p printer\n-\tp.init(output, cfg, fset, nodeSizes)\n-\tdefer func() {\n-\t\twritten = p.written\n-\t\tif e := recover(); e != nil {\n-\t\t\terr = e.(osError).err // re-panics if it's not a local osError\n-\t\t}\n-\t}()\n-\n-\t// print node\n-\tswitch n := node.(type) {\n-\tcase ast.Expr:\n-\t\tp.useNodeComments = true\n-\t\tp.expr(n, ignoreMultiLine)\n-\tcase ast.Stmt:\n-\t\tp.useNodeComments = true\n-\t\t// A labeled statement will un-indent to position the\n-\t\t// label. Set indent to 1 so we don't get indent \"underflow\".\n-\t\tif _, labeledStmt := n.(*ast.LabeledStmt); labeledStmt {\n-\t\t\tp.indent = 1\n-\t\t}\n-\t\tp.stmt(n, false, ignoreMultiLine)\n-\tcase ast.Decl:\n-\t\tp.useNodeComments = true\n-\t\tp.decl(n, ignoreMultiLine)\n-\tcase ast.Spec:\n-\t\tp.useNodeComments = true\n-\t\tp.spec(n, 1, false, ignoreMultiLine)\n-\tcase *ast.File:\n-\t\tp.comments = n.Comments\n-\t\tp.useNodeComments = n.Comments == nil\n-\t\tp.file(n)\n-\tdefault:\n-\t\tpanic(osError{fmt.Errorf(\"printer.Fprint: unsupported node type %T\", n)})\n+\t// write printer result via tabwriter/trimmer to output\n+\tif _, err = output.Write(p.output.Bytes()); err != nil {\n+\t\treturn\n \t}\n-\tp.flush(token.Position{Offset: infinity, Line: infinity}, token.EOF)\n \n \t// flush tabwriter, if any\n-\tif tw != nil {\n-\t\ttw.Flush() // ignore errors\n+\tif tw, _ := (output).(*tabwriter.Writer); tw != nil {\n+\t\terr = tw.Flush()\n \t}\n \n \treturn\n }\n \n-// Fprint \"pretty-prints\" an AST node to output and returns the number\n-// of bytes written and an error (if any) for a given configuration cfg.\n+// Fprint \"pretty-prints\" an AST node to output for a given configuration cfg.\n // Position information is interpreted relative to the file set fset.\n // The node type must be *ast.File, or assignment-compatible to ast.Expr,\n // ast.Decl, ast.Spec, or ast.Stmt.\n //\n-func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) (int, error) {\n+func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) error {\n \treturn cfg.fprint(output, fset, node, make(map[ast.Node]int))\n }\n \n // Fprint \"pretty-prints\" an AST node to output.\n // It calls Config.Fprint with default settings.\n //\n func Fprint(output io.Writer, fset *token.FileSet, node interface{}) error {\n-\t_, err := (&Config{Tabwidth: 8}).Fprint(output, fset, node) // don't care about number of bytes written\n-\treturn err\n+\treturn (&Config{Tabwidth: 8}).Fprint(output, fset, node)\n }"}, {"sha": "924d4dfdb2901a769901791be091aa9de579c58b", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -62,7 +62,7 @@ func runcheck(t *testing.T, source, golden string, mode checkMode) {\n \n \t// format source\n \tvar buf bytes.Buffer\n-\tif _, err := cfg.Fprint(&buf, fset, prog); err != nil {\n+\tif err := cfg.Fprint(&buf, fset, prog); err != nil {\n \t\tt.Error(err)\n \t}\n \tres := buf.Bytes()"}, {"sha": "8103a89d439058dc55c3d979381caa3206d0723d", "filename": "libgo/go/hash/adler32/adler32.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -71,14 +71,13 @@ func (d *digest) Write(p []byte) (nn int, err error) {\n \n func (d *digest) Sum32() uint32 { return finish(d.a, d.b) }\n \n-func (d *digest) Sum() []byte {\n-\tp := make([]byte, 4)\n+func (d *digest) Sum(in []byte) []byte {\n \ts := d.Sum32()\n-\tp[0] = byte(s >> 24)\n-\tp[1] = byte(s >> 16)\n-\tp[2] = byte(s >> 8)\n-\tp[3] = byte(s)\n-\treturn p\n+\tin = append(in, byte(s>>24))\n+\tin = append(in, byte(s>>16))\n+\tin = append(in, byte(s>>8))\n+\tin = append(in, byte(s))\n+\treturn in\n }\n \n // Checksum returns the Adler-32 checksum of data."}, {"sha": "557fab8a52e1a5314f4e404ad26a3f188d8e22fd", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -119,14 +119,13 @@ func (d *digest) Write(p []byte) (n int, err error) {\n \n func (d *digest) Sum32() uint32 { return d.crc }\n \n-func (d *digest) Sum() []byte {\n-\tp := make([]byte, 4)\n+func (d *digest) Sum(in []byte) []byte {\n \ts := d.Sum32()\n-\tp[0] = byte(s >> 24)\n-\tp[1] = byte(s >> 16)\n-\tp[2] = byte(s >> 8)\n-\tp[3] = byte(s)\n-\treturn p\n+\tin = append(in, byte(s>>24))\n+\tin = append(in, byte(s>>16))\n+\tin = append(in, byte(s>>8))\n+\tin = append(in, byte(s))\n+\treturn in\n }\n \n // Checksum returns the CRC-32 checksum of data"}, {"sha": "e5c1db4b3d2f8c9bffb67aa6552124c184420876", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -75,18 +75,17 @@ func (d *digest) Write(p []byte) (n int, err error) {\n \n func (d *digest) Sum64() uint64 { return d.crc }\n \n-func (d *digest) Sum() []byte {\n-\tp := make([]byte, 8)\n+func (d *digest) Sum(in []byte) []byte {\n \ts := d.Sum64()\n-\tp[0] = byte(s >> 56)\n-\tp[1] = byte(s >> 48)\n-\tp[2] = byte(s >> 40)\n-\tp[3] = byte(s >> 32)\n-\tp[4] = byte(s >> 24)\n-\tp[5] = byte(s >> 16)\n-\tp[6] = byte(s >> 8)\n-\tp[7] = byte(s)\n-\treturn p\n+\tin = append(in, byte(s>>56))\n+\tin = append(in, byte(s>>48))\n+\tin = append(in, byte(s>>40))\n+\tin = append(in, byte(s>>32))\n+\tin = append(in, byte(s>>24))\n+\tin = append(in, byte(s>>16))\n+\tin = append(in, byte(s>>8))\n+\tin = append(in, byte(s))\n+\treturn in\n }\n \n // Checksum returns the CRC-64 checksum of data"}, {"sha": "2c8a25118e24aeda190bb7c9c30a2e95e0e153db", "filename": "libgo/go/hash/fnv/fnv.go", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,7 +8,6 @@\n package fnv\n \n import (\n-\t\"encoding/binary\"\n \t\"hash\"\n )\n \n@@ -105,26 +104,46 @@ func (s *sum32a) Size() int { return 4 }\n func (s *sum64) Size() int  { return 8 }\n func (s *sum64a) Size() int { return 8 }\n \n-func (s *sum32) Sum() []byte {\n-\ta := make([]byte, 4)\n-\tbinary.BigEndian.PutUint32(a, uint32(*s))\n-\treturn a\n+func (s *sum32) Sum(in []byte) []byte {\n+\tv := uint32(*s)\n+\tin = append(in, byte(v>>24))\n+\tin = append(in, byte(v>>16))\n+\tin = append(in, byte(v>>8))\n+\tin = append(in, byte(v))\n+\treturn in\n }\n \n-func (s *sum32a) Sum() []byte {\n-\ta := make([]byte, 4)\n-\tbinary.BigEndian.PutUint32(a, uint32(*s))\n-\treturn a\n+func (s *sum32a) Sum(in []byte) []byte {\n+\tv := uint32(*s)\n+\tin = append(in, byte(v>>24))\n+\tin = append(in, byte(v>>16))\n+\tin = append(in, byte(v>>8))\n+\tin = append(in, byte(v))\n+\treturn in\n }\n \n-func (s *sum64) Sum() []byte {\n-\ta := make([]byte, 8)\n-\tbinary.BigEndian.PutUint64(a, uint64(*s))\n-\treturn a\n+func (s *sum64) Sum(in []byte) []byte {\n+\tv := uint64(*s)\n+\tin = append(in, byte(v>>56))\n+\tin = append(in, byte(v>>48))\n+\tin = append(in, byte(v>>40))\n+\tin = append(in, byte(v>>32))\n+\tin = append(in, byte(v>>24))\n+\tin = append(in, byte(v>>16))\n+\tin = append(in, byte(v>>8))\n+\tin = append(in, byte(v))\n+\treturn in\n }\n \n-func (s *sum64a) Sum() []byte {\n-\ta := make([]byte, 8)\n-\tbinary.BigEndian.PutUint64(a, uint64(*s))\n-\treturn a\n+func (s *sum64a) Sum(in []byte) []byte {\n+\tv := uint64(*s)\n+\tin = append(in, byte(v>>56))\n+\tin = append(in, byte(v>>48))\n+\tin = append(in, byte(v>>40))\n+\tin = append(in, byte(v>>32))\n+\tin = append(in, byte(v>>24))\n+\tin = append(in, byte(v>>16))\n+\tin = append(in, byte(v>>8))\n+\tin = append(in, byte(v))\n+\treturn in\n }"}, {"sha": "17454deda904ff29c0f024c4dc537bd17e82f111", "filename": "libgo/go/hash/fnv/fnv_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -72,7 +72,7 @@ func testGolden(t *testing.T, hash hash.Hash, gold []golden) {\n \t\tif done != len(g.text) {\n \t\t\tt.Fatalf(\"wrote only %d out of %d bytes\", done, len(g.text))\n \t\t}\n-\t\tif actual := hash.Sum(); !bytes.Equal(g.sum, actual) {\n+\t\tif actual := hash.Sum(nil); !bytes.Equal(g.sum, actual) {\n \t\t\tt.Errorf(\"hash(%q) = 0x%x want 0x%x\", g.text, actual, g.sum)\n \t\t}\n \t}\n@@ -97,26 +97,26 @@ func TestIntegrity64a(t *testing.T) {\n func testIntegrity(t *testing.T, h hash.Hash) {\n \tdata := []byte{'1', '2', 3, 4, 5}\n \th.Write(data)\n-\tsum := h.Sum()\n+\tsum := h.Sum(nil)\n \n \tif size := h.Size(); size != len(sum) {\n \t\tt.Fatalf(\"Size()=%d but len(Sum())=%d\", size, len(sum))\n \t}\n \n-\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\tif a := h.Sum(nil); !bytes.Equal(sum, a) {\n \t\tt.Fatalf(\"first Sum()=0x%x, second Sum()=0x%x\", sum, a)\n \t}\n \n \th.Reset()\n \th.Write(data)\n-\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\tif a := h.Sum(nil); !bytes.Equal(sum, a) {\n \t\tt.Fatalf(\"Sum()=0x%x, but after Reset() Sum()=0x%x\", sum, a)\n \t}\n \n \th.Reset()\n \th.Write(data[:2])\n \th.Write(data[2:])\n-\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\tif a := h.Sum(nil); !bytes.Equal(sum, a) {\n \t\tt.Fatalf(\"Sum()=0x%x, but with partial writes, Sum()=0x%x\", sum, a)\n \t}\n \n@@ -162,6 +162,6 @@ func benchmark(b *testing.B, h hash.Hash) {\n \tfor todo := b.N; todo != 0; todo-- {\n \t\th.Reset()\n \t\th.Write(data)\n-\t\th.Sum()\n+\t\th.Sum(nil)\n \t}\n }"}, {"sha": "0d7765dc505b155f26c7835c5af9db75c2d0f24c", "filename": "libgo/go/hash/hash.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fhash.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -13,9 +13,9 @@ type Hash interface {\n \t// It never returns an error.\n \tio.Writer\n \n-\t// Sum returns the current hash, without changing the\n-\t// underlying hash state.\n-\tSum() []byte\n+\t// Sum appends the current hash in the same manner as append(), without\n+\t// changing the underlying hash state.\n+\tSum(in []byte) []byte\n \n \t// Reset resets the hash to one with zero bytes written.\n \tReset()"}, {"sha": "f692061a551f7ac6df4a8571dd238de4e45b294a", "filename": "libgo/go/html/doctype.go", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fdoctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fdoctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoctype.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"strings\"\n+)\n+\n+// parseDoctype parses the data from a DoctypeToken into a name,\n+// public identifier, and system identifier. It returns a Node whose Type \n+// is DoctypeNode, whose Data is the name, and which has attributes\n+// named \"system\" and \"public\" for the two identifiers if they were present.\n+// quirks is whether the document should be parsed in \"quirks mode\".\n+func parseDoctype(s string) (n *Node, quirks bool) {\n+\tn = &Node{Type: DoctypeNode}\n+\n+\t// Find the name.\n+\tspace := strings.IndexAny(s, whitespace)\n+\tif space == -1 {\n+\t\tspace = len(s)\n+\t}\n+\tn.Data = s[:space]\n+\t// The comparison to \"html\" is case-sensitive.\n+\tif n.Data != \"html\" {\n+\t\tquirks = true\n+\t}\n+\tn.Data = strings.ToLower(n.Data)\n+\ts = strings.TrimLeft(s[space:], whitespace)\n+\n+\tif len(s) < 6 {\n+\t\t// It can't start with \"PUBLIC\" or \"SYSTEM\".\n+\t\t// Ignore the rest of the string.\n+\t\treturn n, quirks || s != \"\"\n+\t}\n+\n+\tkey := strings.ToLower(s[:6])\n+\ts = s[6:]\n+\tfor key == \"public\" || key == \"system\" {\n+\t\ts = strings.TrimLeft(s, whitespace)\n+\t\tif s == \"\" {\n+\t\t\tbreak\n+\t\t}\n+\t\tquote := s[0]\n+\t\tif quote != '\"' && quote != '\\'' {\n+\t\t\tbreak\n+\t\t}\n+\t\ts = s[1:]\n+\t\tq := strings.IndexRune(s, rune(quote))\n+\t\tvar id string\n+\t\tif q == -1 {\n+\t\t\tid = s\n+\t\t\ts = \"\"\n+\t\t} else {\n+\t\t\tid = s[:q]\n+\t\t\ts = s[q+1:]\n+\t\t}\n+\t\tn.Attr = append(n.Attr, Attribute{Key: key, Val: id})\n+\t\tif key == \"public\" {\n+\t\t\tkey = \"system\"\n+\t\t} else {\n+\t\t\tkey = \"\"\n+\t\t}\n+\t}\n+\n+\tif key != \"\" || s != \"\" {\n+\t\tquirks = true\n+\t} else if len(n.Attr) > 0 {\n+\t\tif n.Attr[0].Key == \"public\" {\n+\t\t\tpublic := strings.ToLower(n.Attr[0].Val)\n+\t\t\tswitch public {\n+\t\t\tcase \"-//w3o//dtd w3 html strict 3.0//en//\", \"-/w3d/dtd html 4.0 transitional/en\", \"html\":\n+\t\t\t\tquirks = true\n+\t\t\tdefault:\n+\t\t\t\tfor _, q := range quirkyIDs {\n+\t\t\t\t\tif strings.HasPrefix(public, q) {\n+\t\t\t\t\t\tquirks = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// The following two public IDs only cause quirks mode if there is no system ID.\n+\t\t\tif len(n.Attr) == 1 && (strings.HasPrefix(public, \"-//w3c//dtd html 4.01 frameset//\") ||\n+\t\t\t\tstrings.HasPrefix(public, \"-//w3c//dtd html 4.01 transitional//\")) {\n+\t\t\t\tquirks = true\n+\t\t\t}\n+\t\t}\n+\t\tif lastAttr := n.Attr[len(n.Attr)-1]; lastAttr.Key == \"system\" &&\n+\t\t\tstrings.ToLower(lastAttr.Val) == \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\" {\n+\t\t\tquirks = true\n+\t\t}\n+\t}\n+\n+\treturn n, quirks\n+}\n+\n+// quirkyIDs is a list of public doctype identifiers that cause a document\n+// to be interpreted in quirks mode. The identifiers should be in lower case.\n+var quirkyIDs = []string{\n+\t\"+//silmaril//dtd html pro v0r11 19970101//\",\n+\t\"-//advasoft ltd//dtd html 3.0 aswedit + extensions//\",\n+\t\"-//as//dtd html 3.0 aswedit + extensions//\",\n+\t\"-//ietf//dtd html 2.0 level 1//\",\n+\t\"-//ietf//dtd html 2.0 level 2//\",\n+\t\"-//ietf//dtd html 2.0 strict level 1//\",\n+\t\"-//ietf//dtd html 2.0 strict level 2//\",\n+\t\"-//ietf//dtd html 2.0 strict//\",\n+\t\"-//ietf//dtd html 2.0//\",\n+\t\"-//ietf//dtd html 2.1e//\",\n+\t\"-//ietf//dtd html 3.0//\",\n+\t\"-//ietf//dtd html 3.2 final//\",\n+\t\"-//ietf//dtd html 3.2//\",\n+\t\"-//ietf//dtd html 3//\",\n+\t\"-//ietf//dtd html level 0//\",\n+\t\"-//ietf//dtd html level 1//\",\n+\t\"-//ietf//dtd html level 2//\",\n+\t\"-//ietf//dtd html level 3//\",\n+\t\"-//ietf//dtd html strict level 0//\",\n+\t\"-//ietf//dtd html strict level 1//\",\n+\t\"-//ietf//dtd html strict level 2//\",\n+\t\"-//ietf//dtd html strict level 3//\",\n+\t\"-//ietf//dtd html strict//\",\n+\t\"-//ietf//dtd html//\",\n+\t\"-//metrius//dtd metrius presentational//\",\n+\t\"-//microsoft//dtd internet explorer 2.0 html strict//\",\n+\t\"-//microsoft//dtd internet explorer 2.0 html//\",\n+\t\"-//microsoft//dtd internet explorer 2.0 tables//\",\n+\t\"-//microsoft//dtd internet explorer 3.0 html strict//\",\n+\t\"-//microsoft//dtd internet explorer 3.0 html//\",\n+\t\"-//microsoft//dtd internet explorer 3.0 tables//\",\n+\t\"-//netscape comm. corp.//dtd html//\",\n+\t\"-//netscape comm. corp.//dtd strict html//\",\n+\t\"-//o'reilly and associates//dtd html 2.0//\",\n+\t\"-//o'reilly and associates//dtd html extended 1.0//\",\n+\t\"-//o'reilly and associates//dtd html extended relaxed 1.0//\",\n+\t\"-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//\",\n+\t\"-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//\",\n+\t\"-//spyglass//dtd html 2.0 extended//\",\n+\t\"-//sq//dtd html 2.0 hotmetal + extensions//\",\n+\t\"-//sun microsystems corp.//dtd hotjava html//\",\n+\t\"-//sun microsystems corp.//dtd hotjava strict html//\",\n+\t\"-//w3c//dtd html 3 1995-03-24//\",\n+\t\"-//w3c//dtd html 3.2 draft//\",\n+\t\"-//w3c//dtd html 3.2 final//\",\n+\t\"-//w3c//dtd html 3.2//\",\n+\t\"-//w3c//dtd html 3.2s draft//\",\n+\t\"-//w3c//dtd html 4.0 frameset//\",\n+\t\"-//w3c//dtd html 4.0 transitional//\",\n+\t\"-//w3c//dtd html experimental 19960712//\",\n+\t\"-//w3c//dtd html experimental 970421//\",\n+\t\"-//w3c//dtd w3 html//\",\n+\t\"-//w3o//dtd w3 html 3.0//\",\n+\t\"-//webtechs//dtd mozilla html 2.0//\",\n+\t\"-//webtechs//dtd mozilla html//\",\n+}"}, {"sha": "97fbc514d827abc75ba8b81a79c325afe6ace497", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 144, "deletions": 25, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -37,6 +37,11 @@ type parser struct {\n \t// fosterParenting is whether new elements should be inserted according to\n \t// the foster parenting rules (section 11.2.5.3).\n \tfosterParenting bool\n+\t// quirks is whether the parser is operating in \"quirks mode.\"\n+\tquirks bool\n+\t// context is the context element when parsing an HTML fragment\n+\t// (section 11.4).\n+\tcontext *Node\n }\n \n func (p *parser) top() *Node {\n@@ -285,9 +290,10 @@ func (p *parser) setOriginalIM() {\n func (p *parser) resetInsertionMode() {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\tn := p.oe[i]\n-\t\tif i == 0 {\n-\t\t\t// TODO: set n to the context element, for HTML fragment parsing.\n+\t\tif i == 0 && p.context != nil {\n+\t\t\tn = p.context\n \t\t}\n+\n \t\tswitch n.Data {\n \t\tcase \"select\":\n \t\t\tp.im = inSelectIM\n@@ -319,32 +325,44 @@ func (p *parser) resetInsertionMode() {\n \tp.im = inBodyIM\n }\n \n+const whitespace = \" \\t\\r\\n\\f\"\n+\n // Section 11.2.5.4.1.\n func initialIM(p *parser) bool {\n \tswitch p.tok.Type {\n+\tcase TextToken:\n+\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(p.tok.Data) == 0 {\n+\t\t\t// It was all whitespace, so ignore it.\n+\t\t\treturn true\n+\t\t}\n \tcase CommentToken:\n \t\tp.doc.Add(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n \t\treturn true\n \tcase DoctypeToken:\n-\t\tp.doc.Add(&Node{\n-\t\t\tType: DoctypeNode,\n-\t\t\tData: p.tok.Data,\n-\t\t})\n+\t\tn, quirks := parseDoctype(p.tok.Data)\n+\t\tp.doc.Add(n)\n+\t\tp.quirks = quirks\n \t\tp.im = beforeHTMLIM\n \t\treturn true\n \t}\n-\t// TODO: set \"quirks mode\"? It's defined in the DOM spec instead of HTML5 proper,\n-\t// and so switching on \"quirks mode\" might belong in a different package.\n+\tp.quirks = true\n \tp.im = beforeHTMLIM\n \treturn false\n }\n \n // Section 11.2.5.4.2.\n func beforeHTMLIM(p *parser) bool {\n \tswitch p.tok.Type {\n+\tcase TextToken:\n+\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(p.tok.Data) == 0 {\n+\t\t\t// It was all whitespace, so ignore it.\n+\t\t\treturn true\n+\t\t}\n \tcase StartTagToken:\n \t\tif p.tok.Data == \"html\" {\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -383,7 +401,11 @@ func beforeHeadIM(p *parser) bool {\n \tcase ErrorToken:\n \t\timplied = true\n \tcase TextToken:\n-\t\t// TODO: distinguish whitespace text from others.\n+\t\tp.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(p.tok.Data) == 0 {\n+\t\t\t// It was all whitespace, so ignore it.\n+\t\t\treturn true\n+\t\t}\n \t\timplied = true\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n@@ -417,8 +439,6 @@ func beforeHeadIM(p *parser) bool {\n \treturn !implied\n }\n \n-const whitespace = \" \\t\\r\\n\\f\"\n-\n // Section 11.2.5.4.4.\n func inHeadIM(p *parser) bool {\n \tvar (\n@@ -441,6 +461,8 @@ func inHeadIM(p *parser) bool {\n \t\timplied = true\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\treturn inBodyIM(p)\n \t\tcase \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\":\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.oe.pop()\n@@ -450,6 +472,9 @@ func inHeadIM(p *parser) bool {\n \t\t\tp.setOriginalIM()\n \t\t\tp.im = textIM\n \t\t\treturn true\n+\t\tcase \"head\":\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\tdefault:\n \t\t\timplied = true\n \t\t}\n@@ -560,11 +585,30 @@ func copyAttributes(dst *Node, src Token) {\n func inBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase TextToken:\n+\t\tswitch n := p.oe.top(); n.Data {\n+\t\tcase \"pre\", \"listing\", \"textarea\":\n+\t\t\tif len(n.Child) == 0 {\n+\t\t\t\t// Ignore a newline at the start of a <pre> block.\n+\t\t\t\td := p.tok.Data\n+\t\t\t\tif d != \"\" && d[0] == '\\r' {\n+\t\t\t\t\td = d[1:]\n+\t\t\t\t}\n+\t\t\t\tif d != \"\" && d[0] == '\\n' {\n+\t\t\t\t\td = d[1:]\n+\t\t\t\t}\n+\t\t\t\tif d == \"\" {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t\tp.tok.Data = d\n+\t\t\t}\n+\t\t}\n \t\tp.reconstructActiveFormattingElements()\n \t\tp.addText(p.tok.Data)\n \t\tp.framesetOK = false\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\tcopyAttributes(p.oe[0], p.tok)\n \t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\":\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -589,6 +633,13 @@ func inBodyIM(p *parser) bool {\n \t\tcase \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\":\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n+\t\tcase \"nobr\":\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tif p.elementInScope(defaultScopeStopTags, \"nobr\") {\n+\t\t\t\tp.inBodyEndTagFormatting(\"nobr\")\n+\t\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\t}\n+\t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"applet\", \"marquee\", \"object\":\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -601,7 +652,9 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.acknowledgeSelfClosingTag()\n \t\t\tp.framesetOK = false\n \t\tcase \"table\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\") // TODO: skip this step in quirks mode.\n+\t\t\tif !p.quirks {\n+\t\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\t}\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n \t\t\tp.im = inTableIM\n@@ -721,6 +774,11 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.oe.pop()\n \t\t\tp.oe.pop()\n \t\t\tp.form = nil\n+\t\tcase \"xmp\":\n+\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.framesetOK = false\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// Ignore the token.\n \t\tdefault:\n@@ -1462,18 +1520,7 @@ func afterAfterFramesetIM(p *parser) bool {\n \treturn true\n }\n \n-// Parse returns the parse tree for the HTML from the given Reader.\n-// The input is assumed to be UTF-8 encoded.\n-func Parse(r io.Reader) (*Node, error) {\n-\tp := &parser{\n-\t\ttokenizer: NewTokenizer(r),\n-\t\tdoc: &Node{\n-\t\t\tType: DocumentNode,\n-\t\t},\n-\t\tscripting:  true,\n-\t\tframesetOK: true,\n-\t\tim:         initialIM,\n-\t}\n+func (p *parser) parse() error {\n \t// Iterate until EOF. Any other error will cause an early return.\n \tconsumed := true\n \tfor {\n@@ -1482,7 +1529,7 @@ func Parse(r io.Reader) (*Node, error) {\n \t\t\t\tif err == io.EOF {\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\treturn nil, err\n+\t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t\tconsumed = p.im(p)\n@@ -1493,5 +1540,77 @@ func Parse(r io.Reader) (*Node, error) {\n \t\t\tbreak\n \t\t}\n \t}\n+\treturn nil\n+}\n+\n+// Parse returns the parse tree for the HTML from the given Reader.\n+// The input is assumed to be UTF-8 encoded.\n+func Parse(r io.Reader) (*Node, error) {\n+\tp := &parser{\n+\t\ttokenizer: NewTokenizer(r),\n+\t\tdoc: &Node{\n+\t\t\tType: DocumentNode,\n+\t\t},\n+\t\tscripting:  true,\n+\t\tframesetOK: true,\n+\t\tim:         initialIM,\n+\t}\n+\terr := p.parse()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \treturn p.doc, nil\n }\n+\n+// ParseFragment parses a fragment of HTML and returns the nodes that were \n+// found. If the fragment is the InnerHTML for an existing element, pass that\n+// element in context.\n+func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {\n+\tp := &parser{\n+\t\ttokenizer: NewTokenizer(r),\n+\t\tdoc: &Node{\n+\t\t\tType: DocumentNode,\n+\t\t},\n+\t\tscripting: true,\n+\t\tcontext:   context,\n+\t}\n+\n+\tif context != nil {\n+\t\tswitch context.Data {\n+\t\tcase \"iframe\", \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"title\", \"textarea\", \"xmp\":\n+\t\t\tp.tokenizer.rawTag = context.Data\n+\t\t}\n+\t}\n+\n+\troot := &Node{\n+\t\tType: ElementNode,\n+\t\tData: \"html\",\n+\t}\n+\tp.doc.Add(root)\n+\tp.oe = nodeStack{root}\n+\tp.resetInsertionMode()\n+\n+\tfor n := context; n != nil; n = n.Parent {\n+\t\tif n.Type == ElementNode && n.Data == \"form\" {\n+\t\t\tp.form = n\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\terr := p.parse()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tparent := p.doc\n+\tif context != nil {\n+\t\tparent = root\n+\t}\n+\n+\tresult := parent.Child\n+\tparent.Child = nil\n+\tfor _, n := range result {\n+\t\tn.Parent = nil\n+\t}\n+\treturn result, nil\n+}"}, {"sha": "e0c19cff6da5f91deccd66de4cfe7fd694dcb764", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 110, "deletions": 72, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -10,65 +10,77 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n \n-func pipeErr(err error) io.Reader {\n-\tpr, pw := io.Pipe()\n-\tpw.CloseWithError(err)\n-\treturn pr\n-}\n-\n-func readDat(filename string, c chan io.Reader) {\n-\tdefer close(c)\n-\tf, err := os.Open(\"testdata/webkit/\" + filename)\n+// readParseTest reads a single test case from r.\n+func readParseTest(r *bufio.Reader) (text, want, context string, err error) {\n+\tline, err := r.ReadSlice('\\n')\n \tif err != nil {\n-\t\tc <- pipeErr(err)\n-\t\treturn\n+\t\treturn \"\", \"\", \"\", err\n \t}\n-\tdefer f.Close()\n+\tvar b []byte\n \n-\t// Loop through the lines of the file. Each line beginning with \"#\" denotes\n-\t// a new section, which is returned as a separate io.Reader.\n-\tr := bufio.NewReader(f)\n-\tvar pw *io.PipeWriter\n+\t// Read the HTML.\n+\tif string(line) != \"#data\\n\" {\n+\t\treturn \"\", \"\", \"\", fmt.Errorf(`got %q want \"#data\\n\"`, line)\n+\t}\n \tfor {\n-\t\tline, err := r.ReadSlice('\\n')\n+\t\tline, err = r.ReadSlice('\\n')\n \t\tif err != nil {\n-\t\t\tif pw != nil {\n-\t\t\t\tpw.CloseWithError(err)\n-\t\t\t\tpw = nil\n-\t\t\t} else {\n-\t\t\t\tc <- pipeErr(err)\n-\t\t\t}\n-\t\t\treturn\n+\t\t\treturn \"\", \"\", \"\", err\n \t\t}\n-\t\tif len(line) == 0 {\n-\t\t\tcontinue\n+\t\tif line[0] == '#' {\n+\t\t\tbreak\n+\t\t}\n+\t\tb = append(b, line...)\n+\t}\n+\ttext = strings.TrimRight(string(b), \"\\n\")\n+\tb = b[:0]\n+\n+\t// Skip the error list.\n+\tif string(line) != \"#errors\\n\" {\n+\t\treturn \"\", \"\", \"\", fmt.Errorf(`got %q want \"#errors\\n\"`, line)\n+\t}\n+\tfor {\n+\t\tline, err = r.ReadSlice('\\n')\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n \t\t}\n \t\tif line[0] == '#' {\n-\t\t\tif pw != nil {\n-\t\t\t\tpw.Close()\n-\t\t\t}\n-\t\t\tvar pr *io.PipeReader\n-\t\t\tpr, pw = io.Pipe()\n-\t\t\tc <- pr\n-\t\t\tcontinue\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif string(line) == \"#document-fragment\\n\" {\n+\t\tline, err = r.ReadSlice('\\n')\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n \t\t}\n-\t\tif line[0] != '|' {\n-\t\t\t// Strip the trailing '\\n'.\n-\t\t\tline = line[:len(line)-1]\n+\t\tcontext = strings.TrimSpace(string(line))\n+\t\tline, err = r.ReadSlice('\\n')\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n \t\t}\n-\t\tif pw != nil {\n-\t\t\tif _, err := pw.Write(line); err != nil {\n-\t\t\t\tpw.CloseWithError(err)\n-\t\t\t\tpw = nil\n-\t\t\t}\n+\t}\n+\n+\t// Read the dump of what the parse tree should be.\n+\tif string(line) != \"#document\\n\" {\n+\t\treturn \"\", \"\", \"\", fmt.Errorf(`got %q want \"#document\\n\"`, line)\n+\t}\n+\tfor {\n+\t\tline, err = r.ReadSlice('\\n')\n+\t\tif err != nil && err != io.EOF {\n+\t\t\treturn \"\", \"\", \"\", err\n+\t\t}\n+\t\tif len(line) == 0 || len(line) == 1 && line[0] == '\\n' {\n+\t\t\tbreak\n \t\t}\n+\t\tb = append(b, line...)\n \t}\n+\treturn text, string(b), context, nil\n }\n \n func dumpIndent(w io.Writer, level int) {\n@@ -93,11 +105,27 @@ func dumpLevel(w io.Writer, n *Node, level int) error {\n \t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n \t\t}\n \tcase TextNode:\n-\t\tfmt.Fprintf(w, \"%q\", n.Data)\n+\t\tfmt.Fprintf(w, `\"%s\"`, n.Data)\n \tcase CommentNode:\n \t\tfmt.Fprintf(w, \"<!-- %s -->\", n.Data)\n \tcase DoctypeNode:\n-\t\tfmt.Fprintf(w, \"<!DOCTYPE %s>\", n.Data)\n+\t\tfmt.Fprintf(w, \"<!DOCTYPE %s\", n.Data)\n+\t\tif n.Attr != nil {\n+\t\t\tvar p, s string\n+\t\t\tfor _, a := range n.Attr {\n+\t\t\t\tswitch a.Key {\n+\t\t\t\tcase \"public\":\n+\t\t\t\t\tp = a.Val\n+\t\t\t\tcase \"system\":\n+\t\t\t\t\ts = a.Val\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif p != \"\" || s != \"\" {\n+\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, p)\n+\t\t\t\tfmt.Fprintf(w, ` \"%s\"`, s)\n+\t\t\t}\n+\t\t}\n+\t\tio.WriteString(w, \">\")\n \tcase scopeMarkerNode:\n \t\treturn errors.New(\"unexpected scopeMarkerNode\")\n \tdefault:\n@@ -133,46 +161,62 @@ func TestParser(t *testing.T) {\n \t\tn int\n \t}{\n \t\t// TODO(nigeltao): Process all the test cases from all the .dat files.\n+\t\t{\"doctype01.dat\", -1},\n \t\t{\"tests1.dat\", -1},\n-\t\t{\"tests2.dat\", 43},\n-\t\t{\"tests3.dat\", 0},\n+\t\t{\"tests2.dat\", -1},\n+\t\t{\"tests3.dat\", -1},\n+\t\t{\"tests4.dat\", -1},\n+\t\t{\"tests5.dat\", -1},\n \t}\n \tfor _, tf := range testFiles {\n-\t\trc := make(chan io.Reader)\n-\t\tgo readDat(tf.filename, rc)\n+\t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tr := bufio.NewReader(f)\n \t\tfor i := 0; i != tf.n; i++ {\n-\t\t\t// Parse the #data section.\n-\t\t\tdataReader := <-rc\n-\t\t\tif dataReader == nil {\n+\t\t\ttext, want, context, err := readParseTest(r)\n+\t\t\tif err == io.EOF && tf.n == -1 {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tb, err := ioutil.ReadAll(dataReader)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n-\t\t\ttext := string(b)\n-\t\t\tdoc, err := Parse(strings.NewReader(text))\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n+\n+\t\t\tvar doc *Node\n+\t\t\tif context == \"\" {\n+\t\t\t\tdoc, err = Parse(strings.NewReader(text))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcontextNode := &Node{\n+\t\t\t\t\tType: ElementNode,\n+\t\t\t\t\tData: context,\n+\t\t\t\t}\n+\t\t\t\tnodes, err := ParseFragment(strings.NewReader(text), contextNode)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tdoc = &Node{\n+\t\t\t\t\tType: DocumentNode,\n+\t\t\t\t}\n+\t\t\t\tfor _, n := range nodes {\n+\t\t\t\t\tdoc.Add(n)\n+\t\t\t\t}\n \t\t\t}\n+\n \t\t\tgot, err := dump(doc)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n-\t\t\t// Skip the #error section.\n-\t\t\tif _, err := io.Copy(ioutil.Discard, <-rc); err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n \t\t\t// Compare the parsed tree to the #document section.\n-\t\t\tb, err = ioutil.ReadAll(<-rc)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif want := string(b); got != want {\n+\t\t\tif got != want {\n \t\t\t\tt.Errorf(\"%s test #%d %q, got vs want:\\n----\\n%s----\\n%s----\", tf.filename, i, text, got, want)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif renderTestBlacklist[text] {\n+\t\t\tif renderTestBlacklist[text] || context != \"\" {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Check that rendering and re-parsing results in an identical tree.\n@@ -193,12 +237,6 @@ func TestParser(t *testing.T) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n-\t\t// Drain any untested cases for the test file.\n-\t\tfor r := range rc {\n-\t\t\tif _, err := ioutil.ReadAll(r); err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t}\n \t}\n }\n "}, {"sha": "7e1a4669657d1fce4262272eafff29992aeb0b71", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"strings\"\n )\n \n type writer interface {\n@@ -98,6 +99,40 @@ func render1(w writer, n *Node) error {\n \t\tif _, err := w.WriteString(n.Data); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif n.Attr != nil {\n+\t\t\tvar p, s string\n+\t\t\tfor _, a := range n.Attr {\n+\t\t\t\tswitch a.Key {\n+\t\t\t\tcase \"public\":\n+\t\t\t\t\tp = a.Val\n+\t\t\t\tcase \"system\":\n+\t\t\t\t\ts = a.Val\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif p != \"\" {\n+\t\t\t\tif _, err := w.WriteString(\" PUBLIC \"); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif err := writeQuoted(w, p); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif s != \"\" {\n+\t\t\t\t\tif err := w.WriteByte(' '); err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t\tif err := writeQuoted(w, s); err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if s != \"\" {\n+\t\t\t\tif _, err := w.WriteString(\" SYSTEM \"); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tif err := writeQuoted(w, s); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\treturn w.WriteByte('>')\n \tdefault:\n \t\treturn errors.New(\"html: unknown node type\")\n@@ -138,9 +173,19 @@ func render1(w writer, n *Node) error {\n \t\treturn err\n \t}\n \n+\t// Add initial newline where there is danger of a newline beging ignored.\n+\tif len(n.Child) > 0 && n.Child[0].Type == TextNode && strings.HasPrefix(n.Child[0].Data, \"\\n\") {\n+\t\tswitch n.Data {\n+\t\tcase \"pre\", \"listing\", \"textarea\":\n+\t\t\tif err := w.WriteByte('\\n'); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// Render any child nodes.\n \tswitch n.Data {\n-\tcase \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\":\n+\tcase \"iframe\", \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"xmp\":\n \t\tfor _, c := range n.Child {\n \t\t\tif c.Type != TextNode {\n \t\t\t\treturn fmt.Errorf(\"html: raw text element <%s> has non-text child node\", n.Data)\n@@ -181,6 +226,27 @@ func render1(w writer, n *Node) error {\n \treturn w.WriteByte('>')\n }\n \n+// writeQuoted writes s to w surrounded by quotes. Normally it will use double\n+// quotes, but if s contains a double quote, it will use single quotes.\n+// It is used for writing the identifiers in a doctype declaration.\n+// In valid HTML, they can't contain both types of quotes.\n+func writeQuoted(w writer, s string) error {\n+\tvar q byte = '\"'\n+\tif strings.Contains(s, `\"`) {\n+\t\tq = '\\''\n+\t}\n+\tif err := w.WriteByte(q); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := w.WriteString(s); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := w.WriteByte(q); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n // Section 13.1.2, \"Elements\", gives this list of void elements. Void elements\n // are those that can't have any contents.\n var voidElements = map[string]bool{"}, {"sha": "39788173b999019022e57bf6333de7aaf0dc3c39", "filename": "libgo/go/html/template/clone_test.go", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,8 +7,6 @@ package template\n import (\n \t\"bytes\"\n \t\"testing\"\n-\t\"text/template\"\n-\t\"text/template/parse\"\n )\n \n func TestClone(t *testing.T) {\n@@ -48,15 +46,20 @@ func TestClone(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\ts := template.Must(template.New(\"s\").Parse(test.input))\n-\t\td := template.New(\"d\")\n-\t\td.Tree = &parse.Tree{Name: d.Name(), Root: cloneList(s.Root)}\n+\t\ts, err := New(\"s\").Parse(test.input)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"input=%q: unexpected parse error %v\", test.input, err)\n+\t\t}\n+\n+\t\td, _ := New(\"d\").Parse(test.input)\n+\t\t// Hack: just replace the root of the tree.\n+\t\td.text.Root = cloneList(s.text.Root)\n \n-\t\tif want, got := s.Root.String(), d.Root.String(); want != got {\n+\t\tif want, got := s.text.Root.String(), d.text.Root.String(); want != got {\n \t\t\tt.Errorf(\"want %q, got %q\", want, got)\n \t\t}\n \n-\t\terr := escape(d)\n+\t\terr = escapeTemplates(d, \"d\")\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%q: failed to escape: %s\", test.input, err)\n \t\t\tcontinue\n@@ -73,18 +76,17 @@ func TestClone(t *testing.T) {\n \n \t\tdata := []string{\"foo\", \"<bar>\", \"baz\"}\n \n-\t\t// Make sure escaping d did not affect s.\n \t\tvar b bytes.Buffer\n-\t\ts.Execute(&b, data)\n-\t\tif got := b.String(); got != test.want {\n-\t\t\tt.Errorf(\"%q: want %q, got %q\", test.input, test.want, got)\n-\t\t\tcontinue\n+\t\td.Execute(&b, data)\n+\t\tif got := b.String(); got != test.wantClone {\n+\t\t\tt.Errorf(\"input=%q: want %q, got %q\", test.input, test.wantClone, got)\n \t\t}\n \n+\t\t// Make sure escaping d did not affect s.\n \t\tb.Reset()\n-\t\td.Execute(&b, data)\n-\t\tif got := b.String(); got != test.wantClone {\n-\t\t\tt.Errorf(\"%q: want %q, got %q\", test.input, test.wantClone, got)\n+\t\ts.text.Execute(&b, data)\n+\t\tif got := b.String(); got != test.want {\n+\t\t\tt.Errorf(\"input=%q: want %q, got %q\", test.input, test.want, got)\n \t\t}\n \t}\n }"}, {"sha": "4de7ccde9127c1247b3067692a1ea8236387c13c", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -12,10 +12,10 @@ import (\n // Strings of content from a trusted source.\n type (\n \t// CSS encapsulates known safe content that matches any of:\n-\t// (1) The CSS3 stylesheet production, such as `p { color: purple }`.\n-\t// (2) The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n-\t// (3) CSS3 declaration productions, such as `color: red; margin: 2px`.\n-\t// (4) The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n+\t//   1. The CSS3 stylesheet production, such as `p { color: purple }`.\n+\t//   2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n+\t//   3. CSS3 declaration productions, such as `color: red; margin: 2px`.\n+\t//   4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n \t// See http://www.w3.org/TR/css3-syntax/#style\n \tCSS string\n \n@@ -41,8 +41,8 @@ type (\n \t// JSStr encapsulates a sequence of characters meant to be embedded\n \t// between quotes in a JavaScript expression.\n \t// The string must match a series of StringCharacters:\n-\t// StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n-\t//                  | EscapeSequence\n+\t//   StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n+\t//                    | EscapeSequence\n \t// Note that LineContinuations are not allowed.\n \t// JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not.\n \tJSStr string"}, {"sha": "fc0e3826442c05b0809ed9ba2e4d84494d981a1d", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -13,9 +13,9 @@ Introduction\n This package wraps package template so you can use the standard template API\n to parse and execute templates.\n \n-    set, err := new(template.Set).Parse(...)\n-    // Error checking elided\n-    err = set.Execute(out, \"Foo\", data)\n+  set, err := new(template.Set).Parse(...)\n+  // Error checking elided\n+  err = set.Execute(out, \"Foo\", data)\n \n If successful, set will now be injection-safe. Otherwise, err is an error\n defined in the docs for ErrorCode.\n@@ -29,25 +29,25 @@ trusted, while Execute's data parameter is not. More details are provided below.\n \n Example\n \n-    import \"template\"\n-    ...\n-    t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n-    err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n+  import \"text/template\"\n+  ...\n+  t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n+  err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n \n produces\n \n-    Hello, <script>alert('you have been pwned')</script>!\n+  Hello, <script>alert('you have been pwned')</script>!\n \n but with contextual autoescaping,\n \n-    import \"html/template\"\n-    ...\n-    t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n-    err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n+  import \"html/template\"\n+  ...\n+  t, err := (&template.Set{}).Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n+  err = t.Execute(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n \n produces safe, escaped HTML output\n \n-    Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!\n+  Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!\n \n \n Contexts\n@@ -80,36 +80,36 @@ Contexts\n Assuming {{.}} is `O'Reilly: How are <i>you</i>?`, the table below shows\n how {{.}} appears when used in the context to the left.\n \n-Context                          {{.}} After\n-{{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n-<a title='{{.}}'>                O&#39;Reilly: How are you?\n-<a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n-<a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n-<a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n-<a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n-<a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n+  Context                          {{.}} After\n+  {{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n+  <a title='{{.}}'>                O&#39;Reilly: How are you?\n+  <a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n+  <a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n+  <a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n+  <a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n+  <a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n \n If used in an unsafe context, then the value might be filtered out:\n \n-Context                          {{.}} After\n-<a href=\"{{.}}\">                 #ZgotmplZ\n+  Context                          {{.}} After\n+  <a href=\"{{.}}\">                 #ZgotmplZ\n \n since \"O'Reilly:\" is not an allowed protocol like \"http:\".\n \n \n If {{.}} is the innocuous word, `left`, then it can appear more widely,\n \n-Context                              {{.}} After\n-{{.}}                                left\n-<a title='{{.}}'>                    left\n-<a href='{{.}}'>                     left\n-<a href='/{{.}}'>                    left\n-<a href='?dir={{.}}'>                left\n-<a style=\"border-{{.}}: 4px\">        left\n-<a style=\"align: {{.}}\">             left\n-<a style=\"background: '{{.}}'>       left\n-<a style=\"background: url('{{.}}')>  left\n-<style>p.{{.}} {color:red}</style>   left\n+  Context                              {{.}} After\n+  {{.}}                                left\n+  <a title='{{.}}'>                    left\n+  <a href='{{.}}'>                     left\n+  <a href='/{{.}}'>                    left\n+  <a href='?dir={{.}}'>                left\n+  <a style=\"border-{{.}}: 4px\">        left\n+  <a style=\"align: {{.}}\">             left\n+  <a style=\"background: '{{.}}'>       left\n+  <a style=\"background: url('{{.}}')>  left\n+  <style>p.{{.}} {color:red}</style>   left\n \n Non-string values can be used in JavaScript contexts.\n If {{.}} is"}, {"sha": "4a7a9354c93f5863e00003606d2b5b5f31795ca0", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -12,24 +12,15 @@ import (\n \t\"text/template/parse\"\n )\n \n-// escape rewrites each action in the template to guarantee that the output is\n-// properly escaped.\n-func escape(t *template.Template) error {\n-\tvar s template.Set\n-\ts.Add(t)\n-\treturn escapeSet(&s, t.Name())\n-\t// TODO: if s contains cloned dependencies due to self-recursion\n-\t// cross-context, error out.\n-}\n-\n-// escapeSet rewrites the template set to guarantee that the output of any of\n-// the named templates is properly escaped.\n-// Names should include the names of all templates that might be Executed but\n-// need not include helper templates.\n-// If no error is returned, then the named templates have been modified. \n-// Otherwise the named templates have been rendered unusable.\n-func escapeSet(s *template.Set, names ...string) error {\n-\te := newEscaper(s)\n+// escapeTemplates rewrites the named templates, which must be\n+// associated with t, to guarantee that the output of any of the named\n+// templates is properly escaped.  Names should include the names of\n+// all templates that might be Executed but need not include helper\n+// templates.  If no error is returned, then the named templates have\n+// been modified.  Otherwise the named templates have been rendered\n+// unusable.\n+func escapeTemplates(tmpl *Template, names ...string) error {\n+\te := newEscaper(tmpl)\n \tfor _, name := range names {\n \t\tc, _ := e.escapeTree(context{}, name, 0)\n \t\tvar err error\n@@ -41,12 +32,13 @@ func escapeSet(s *template.Set, names ...string) error {\n \t\tif err != nil {\n \t\t\t// Prevent execution of unsafe templates.\n \t\t\tfor _, name := range names {\n-\t\t\t\tif t := s.Template(name); t != nil {\n-\t\t\t\t\tt.Tree = nil\n+\t\t\t\tif t := tmpl.set[name]; t != nil {\n+\t\t\t\t\tt.text.Tree = nil\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn err\n \t\t}\n+\t\ttmpl.escaped = true\n \t}\n \te.commit()\n \treturn nil\n@@ -83,8 +75,7 @@ var equivEscapers = map[string]string{\n // escaper collects type inferences about templates and changes needed to make\n // templates injection safe.\n type escaper struct {\n-\t// set is the template set being escaped.\n-\tset *template.Set\n+\ttmpl *Template\n \t// output[templateName] is the output context for a templateName that\n \t// has been mangled to include its input context.\n \toutput map[string]context\n@@ -102,9 +93,9 @@ type escaper struct {\n }\n \n // newEscaper creates a blank escaper for the given set.\n-func newEscaper(s *template.Set) *escaper {\n+func newEscaper(t *Template) *escaper {\n \treturn &escaper{\n-\t\ts,\n+\t\tt,\n \t\tmap[string]context{},\n \t\tmap[string]*template.Template{},\n \t\tmap[string]bool{},\n@@ -442,7 +433,7 @@ func (e *escaper) escapeList(c context, n *parse.ListNode) context {\n // It returns the best guess at an output context, and the result of the filter\n // which is the same as whether e was updated.\n func (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool) {\n-\te1 := newEscaper(e.set)\n+\te1 := newEscaper(e.tmpl)\n \t// Make type inferences available to f.\n \tfor k, v := range e.output {\n \t\te1.output[k] = v\n@@ -501,7 +492,7 @@ func (e *escaper) escapeTree(c context, name string, line int) (context, string)\n \t\t}, dname\n \t}\n \tif dname != name {\n-\t\t// Use any template derived during an earlier call to escapeSet\n+\t\t// Use any template derived during an earlier call to escapeTemplate\n \t\t// with different top level templates, or clone if necessary.\n \t\tdt := e.template(dname)\n \t\tif dt == nil {\n@@ -529,7 +520,7 @@ func (e *escaper) computeOutCtx(c context, t *template.Template) context {\n \tif !ok && c1.state != stateError {\n \t\treturn context{\n \t\t\tstate: stateError,\n-\t\t\t// TODO: Find the first node with a line in t.Tree.Root\n+\t\t\t// TODO: Find the first node with a line in t.text.Tree.Root\n \t\t\terr: errorf(ErrOutputContext, 0, \"cannot compute output context for template %s\", t.Name()),\n \t\t}\n \t}\n@@ -729,7 +720,9 @@ func (e *escaper) commit() {\n \t\te.template(name).Funcs(funcMap)\n \t}\n \tfor _, t := range e.derived {\n-\t\te.set.Add(t)\n+\t\tif _, err := e.tmpl.text.AddParseTree(t.Name(), t.Tree); err != nil {\n+\t\t\tpanic(\"error adding derived template\")\n+\t\t}\n \t}\n \tfor n, s := range e.actionNodeEdits {\n \t\tensurePipelineContains(n.Pipe, s)\n@@ -744,7 +737,7 @@ func (e *escaper) commit() {\n \n // template returns the named template given a mangled template name.\n func (e *escaper) template(name string) *template.Template {\n-\tt := e.set.Template(name)\n+\tt := e.tmpl.text.Lookup(name)\n \tif t == nil {\n \t\tt = e.derived[name]\n \t}"}, {"sha": "b4daca7d6bdc3c9ec47d7d4ebd98fe07d8bfdb21", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -806,13 +806,15 @@ func TestEscapeSet(t *testing.T) {\n \t\tfor name, body := range test.inputs {\n \t\t\tsource += fmt.Sprintf(\"{{define %q}}%s{{end}} \", name, body)\n \t\t}\n-\t\ts := &Set{}\n-\t\ts.Funcs(fns)\n-\t\ts.Parse(source)\n+\t\ttmpl, err := New(\"root\").Funcs(fns).Parse(source)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error parsing %q: %v\", source, err)\n+\t\t\tcontinue\n+\t\t}\n \t\tvar b bytes.Buffer\n \n-\t\tif err := s.Execute(&b, \"main\", data); err != nil {\n-\t\t\tt.Errorf(\"%q executing %v\", err.Error(), s.Template(\"main\"))\n+\t\tif err := tmpl.ExecuteTemplate(&b, \"main\", data); err != nil {\n+\t\t\tt.Errorf(\"%q executing %v\", err.Error(), tmpl.Lookup(\"main\"))\n \t\t\tcontinue\n \t\t}\n \t\tif got := b.String(); test.want != got {\n@@ -929,13 +931,13 @@ func TestErrors(t *testing.T) {\n \t\t\t\"z:1: no such template foo\",\n \t\t},\n \t\t{\n-\t\t\t`{{define \"z\"}}<div{{template \"y\"}}>{{end}}` +\n+\t\t\t`<div{{template \"y\"}}>` +\n \t\t\t\t// Illegal starting in stateTag but not in stateText.\n \t\t\t\t`{{define \"y\"}} foo<b{{end}}`,\n \t\t\t`\"<\" in attribute name: \" foo<b\"`,\n \t\t},\n \t\t{\n-\t\t\t`{{define \"z\"}}<script>reverseList = [{{template \"t\"}}]</script>{{end}}` +\n+\t\t\t`<script>reverseList = [{{template \"t\"}}]</script>` +\n \t\t\t\t// Missing \" after recursive call.\n \t\t\t\t`{{define \"t\"}}{{if .Tail}}{{template \"t\" .Tail}}{{end}}{{.Head}}\",{{end}}`,\n \t\t\t`: cannot compute output context for template t$htmltemplate_stateJS_elementScript`,\n@@ -967,21 +969,13 @@ func TestErrors(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\tvar err error\n \t\tbuf := new(bytes.Buffer)\n-\t\tif strings.HasPrefix(test.input, \"{{define\") {\n-\t\t\tvar s *Set\n-\t\t\ts, err = (&Set{}).Parse(test.input)\n-\t\t\tif err == nil {\n-\t\t\t\terr = s.Execute(buf, \"z\", nil)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tvar t *Template\n-\t\t\tt, err = New(\"z\").Parse(test.input)\n-\t\t\tif err == nil {\n-\t\t\t\terr = t.Execute(buf, nil)\n-\t\t\t}\n+\t\ttmpl, err := New(\"z\").Parse(test.input)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"input=%q: unexpected parse error %s\\n\", test.input, err)\n+\t\t\tcontinue\n \t\t}\n+\t\terr = tmpl.Execute(buf, nil)\n \t\tvar got string\n \t\tif err != nil {\n \t\t\tgot = err.Error()\n@@ -1569,11 +1563,11 @@ func TestEscapeErrorsNotIgnorable(t *testing.T) {\n \n func TestEscapeSetErrorsNotIgnorable(t *testing.T) {\n \tvar b bytes.Buffer\n-\ts, err := (&Set{}).Parse(`{{define \"t\"}}<a{{end}}`)\n+\ttmpl, err := New(\"root\").Parse(`{{define \"t\"}}<a{{end}}`)\n \tif err != nil {\n \t\tt.Errorf(\"failed to parse set: %q\", err)\n \t}\n-\terr = s.Execute(&b, \"t\", nil)\n+\terr = tmpl.ExecuteTemplate(&b, \"t\", nil)\n \tif err == nil {\n \t\tt.Errorf(\"Expected error\")\n \t} else if b.Len() != 0 {"}, {"sha": "f05ca190f739829cea60d5eb547d77314d939f85", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 200, "deletions": 176, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,233 +7,257 @@ package template\n import (\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"path/filepath\"\n+\t\"sync\"\n \t\"text/template\"\n+\t\"text/template/parse\"\n )\n \n-// Set is a specialized template.Set that produces a safe HTML document\n-// fragment.\n-type Set struct {\n-\tescaped map[string]bool\n-\ttemplate.Set\n-}\n-\n // Template is a specialized template.Template that produces a safe HTML\n // document fragment.\n type Template struct {\n \tescaped bool\n-\t*template.Template\n+\t// We could embed the text/template field, but it's safer not to because\n+\t// we need to keep our version of the name space and the underlying\n+\t// template's in sync.\n+\ttext       *template.Template\n+\t*nameSpace // common to all associated templates\n }\n \n-// Execute applies the named template to the specified data object, writing\n-// the output to wr.\n-func (s *Set) Execute(wr io.Writer, name string, data interface{}) error {\n-\tif !s.escaped[name] {\n-\t\tif err := escapeSet(&s.Set, name); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif s.escaped == nil {\n-\t\t\ts.escaped = make(map[string]bool)\n+// nameSpace is the data structure shared by all templates in an association.\n+type nameSpace struct {\n+\tmu  sync.Mutex\n+\tset map[string]*Template\n+}\n+\n+// Execute applies a parsed template to the specified data object,\n+// writing the output to wr.\n+func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n+\tt.nameSpace.mu.Lock()\n+\tif !t.escaped {\n+\t\tif err = escapeTemplates(t, t.Name()); err != nil {\n+\t\t\tt.escaped = true\n \t\t}\n-\t\ts.escaped[name] = true\n \t}\n-\treturn s.Set.Execute(wr, name, data)\n+\tt.nameSpace.mu.Unlock()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn t.text.Execute(wr, data)\n }\n \n-// Parse parses a string into a set of named templates.  Parse may be called\n-// multiple times for a given set, adding the templates defined in the string\n-// to the set.  If a template is redefined, the element in the set is\n-// overwritten with the new definition.\n-func (set *Set) Parse(src string) (*Set, error) {\n-\tset.escaped = nil\n-\ts, err := set.Set.Parse(src)\n-\tif err != nil {\n-\t\treturn nil, err\n+// ExecuteTemplate applies the template associated with t that has the given name\n+// to the specified data object and writes the output to wr.\n+func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) (err error) {\n+\tt.nameSpace.mu.Lock()\n+\ttmpl := t.set[name]\n+\tif tmpl == nil {\n+\t\tt.nameSpace.mu.Unlock()\n+\t\treturn fmt.Errorf(\"template: no template %q associated with template %q\", name, t.Name())\n \t}\n-\tif s != &(set.Set) {\n-\t\tpanic(\"allocated new set\")\n+\tif !tmpl.escaped {\n+\t\terr = escapeTemplates(tmpl, name)\n+\t}\n+\tt.nameSpace.mu.Unlock()\n+\tif err != nil {\n+\t\treturn\n \t}\n-\treturn set, nil\n+\treturn tmpl.text.ExecuteTemplate(wr, name, data)\n }\n \n-// Parse parses the template definition string to construct an internal\n-// representation of the template for execution.\n-func (tmpl *Template) Parse(src string) (*Template, error) {\n-\ttmpl.escaped = false\n-\tt, err := tmpl.Template.Parse(src)\n+// Parse parses a string into a template. Nested template definitions\n+// will be associated with the top-level template t. Parse may be\n+// called multiple times to parse definitions of templates to associate\n+// with t. It is an error if a resulting template is non-empty (contains\n+// content other than template definitions) and would replace a\n+// non-empty template with the same name.  (In multiple calls to Parse\n+// with the same receiver template, only one call can contain text\n+// other than space, comments, and template definitions.)\n+func (t *Template) Parse(src string) (*Template, error) {\n+\tt.nameSpace.mu.Lock()\n+\tt.escaped = false\n+\tt.nameSpace.mu.Unlock()\n+\tret, err := t.text.Parse(src)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\ttmpl.Template = t\n-\treturn tmpl, nil\n-}\n-\n-// Execute applies a parsed template to the specified data object,\n-// writing the output to wr.\n-func (t *Template) Execute(wr io.Writer, data interface{}) error {\n-\tif !t.escaped {\n-\t\tif err := escape(t.Template); err != nil {\n-\t\t\treturn err\n+\t// In general, all the named templates might have changed underfoot.\n+\t// Regardless, some new ones may have been defined.\n+\t// The template.Template set has been updated; update ours.\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\tfor _, v := range ret.Templates() {\n+\t\tname := v.Name()\n+\t\ttmpl := t.set[name]\n+\t\tif tmpl == nil {\n+\t\t\ttmpl = t.new(name)\n \t\t}\n-\t\tt.escaped = true\n+\t\ttmpl.escaped = false\n+\t\ttmpl.text = v\n \t}\n-\treturn t.Template.Execute(wr, data)\n+\treturn t, nil\n+}\n+\n+// AddParseTree is unimplemented.\n+func (t *Template) AddParseTree(name string, tree *parse.Tree) error {\n+\treturn fmt.Errorf(\"html/template: AddParseTree unimplemented\")\n+}\n+\n+// Clone is unimplemented.\n+func (t *Template) Clone(name string) error {\n+\treturn fmt.Errorf(\"html/template: Add unimplemented\")\n }\n \n // New allocates a new HTML template with the given name.\n func New(name string) *Template {\n-\treturn &Template{false, template.New(name)}\n+\ttmpl := &Template{\n+\t\tfalse,\n+\t\ttemplate.New(name),\n+\t\t&nameSpace{\n+\t\t\tset: make(map[string]*Template),\n+\t\t},\n+\t}\n+\ttmpl.set[name] = tmpl\n+\treturn tmpl\n }\n \n-// Must panics if err is non-nil in the same way as template.Must.\n-func Must(t *Template, err error) *Template {\n-\tt.Template = template.Must(t.Template, err)\n-\treturn t\n+// New allocates a new HTML template associated with the given one\n+// and with the same delimiters. The association, which is transitive,\n+// allows one template to invoke another with a {{template}} action.\n+func (t *Template) New(name string) *Template {\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\treturn t.new(name)\n }\n \n-// ParseFile creates a new Template and parses the template definition from\n-// the named file.  The template name is the base name of the file.\n-func ParseFile(filename string) (*Template, error) {\n-\tt, err := template.ParseFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n+// new is the implementation of New, without the lock.\n+func (t *Template) new(name string) *Template {\n+\ttmpl := &Template{\n+\t\tfalse,\n+\t\tt.text.New(name),\n+\t\tt.nameSpace,\n \t}\n-\treturn &Template{false, t}, nil\n+\ttmpl.set[name] = tmpl\n+\treturn tmpl\n }\n \n-// ParseFile reads the template definition from a file and parses it to\n-// construct an internal representation of the template for execution.\n-// The returned template will be nil if an error occurs.\n-func (tmpl *Template) ParseFile(filename string) (*Template, error) {\n-\tt, err := tmpl.Template.ParseFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\ttmpl.Template = t\n-\treturn tmpl, nil\n+// Name returns the name of the template.\n+func (t *Template) Name() string {\n+\treturn t.text.Name()\n }\n \n-// SetMust panics if the error is non-nil just like template.SetMust.\n-func SetMust(s *Set, err error) *Set {\n-\tif err != nil {\n-\t\ttemplate.SetMust(&(s.Set), err)\n-\t}\n-\treturn s\n+// Funcs adds the elements of the argument map to the template's function map.\n+// It panics if a value in the map is not a function with appropriate return\n+// type. However, it is legal to overwrite elements of the map. The return\n+// value is the template, so calls can be chained.\n+func (t *Template) Funcs(funcMap template.FuncMap) *Template {\n+\tt.text.Funcs(funcMap)\n+\treturn t\n }\n \n-// ParseFiles parses the named files into a set of named templates.\n-// Each file must be parseable by itself.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (set *Set) ParseFiles(filenames ...string) (*Set, error) {\n-\ts, err := set.Set.ParseFiles(filenames...)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif s != &(set.Set) {\n-\t\tpanic(\"allocated new set\")\n-\t}\n-\treturn set, nil\n+// Delims sets the action delimiters to the specified strings, to be used in\n+// subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template\n+// definitions will inherit the settings. An empty delimiter stands for the\n+// corresponding default: {{ or }}.\n+// The return value is the template, so calls can be chained.\n+func (t *Template) Delims(left, right string) *Template {\n+\tt.text.Delims(left, right)\n+\treturn t\n }\n \n-// ParseSetFiles creates a new Set and parses the set definition from the\n-// named files. Each file must be individually parseable.\n-func ParseSetFiles(filenames ...string) (*Set, error) {\n-\tset := new(Set)\n-\ts, err := set.Set.ParseFiles(filenames...)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif s != &(set.Set) {\n-\t\tpanic(\"allocated new set\")\n-\t}\n-\treturn set, nil\n+// Lookup returns the template with the given name that is associated with t,\n+// or nil if there is no such template.\n+func (t *Template) Lookup(name string) *Template {\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\treturn t.set[name]\n }\n \n-// ParseGlob parses the set definition from the files identified by the\n-// pattern. The pattern is processed by filepath.Glob and must match at\n-// least one file.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseGlob(pattern string) (*Set, error) {\n-\tfilenames, err := filepath.Glob(pattern)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif len(filenames) == 0 {\n-\t\treturn nil, fmt.Errorf(\"pattern matches no files: %#q\", pattern)\n-\t}\n-\treturn s.ParseFiles(filenames...)\n+// Must panics if err is non-nil in the same way as template.Must.\n+func Must(t *Template, err error) *Template {\n+\tt.text = template.Must(t.text, err)\n+\treturn t\n }\n \n-// ParseSetGlob creates a new Set and parses the set definition from the\n-// files identified by the pattern. The pattern is processed by filepath.Glob\n-// and must match at least one file.\n-func ParseSetGlob(pattern string) (*Set, error) {\n-\tset, err := new(Set).ParseGlob(pattern)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn set, nil\n+// ParseFiles creates a new Template and parses the template definitions from\n+// the named files. The returned template's name will have the (base) name and\n+// (parsed) contents of the first file. There must be at least one file.\n+// If an error occurs, parsing stops and the returned *Template is nil.\n+func ParseFiles(filenames ...string) (*Template, error) {\n+\treturn parseFiles(nil, filenames...)\n }\n \n-// Functions and methods to parse stand-alone template files into a set.\n+// ParseFiles parses the named files and associates the resulting templates with\n+// t. If an error occurs, parsing stops and the returned template is nil;\n+// otherwise it is t. There must be at least one file.\n+func (t *Template) ParseFiles(filenames ...string) (*Template, error) {\n+\treturn parseFiles(t, filenames...)\n+}\n \n-// ParseTemplateFiles parses the named template files and adds them to the set\n-// in the same way as template.ParseTemplateFiles but ensures that templates\n-// with upper-case names are contextually-autoescaped.\n-func (set *Set) ParseTemplateFiles(filenames ...string) (*Set, error) {\n-\ts, err := set.Set.ParseTemplateFiles(filenames...)\n-\tif err != nil {\n-\t\treturn nil, err\n+// parseFiles is the helper for the method and function. If the argument\n+// template is nil, it is created from the first file.\n+func parseFiles(t *Template, filenames ...string) (*Template, error) {\n+\tif len(filenames) == 0 {\n+\t\t// Not really a problem, but be consistent.\n+\t\treturn nil, fmt.Errorf(\"template: no files named in call to ParseFiles\")\n \t}\n-\tif s != &(set.Set) {\n-\t\tpanic(\"new set allocated\")\n+\tfor _, filename := range filenames {\n+\t\tb, err := ioutil.ReadFile(filename)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ts := string(b)\n+\t\tname := filepath.Base(filename)\n+\t\t// First template becomes return value if not already defined,\n+\t\t// and we use that one for subsequent New calls to associate\n+\t\t// all the templates together. Also, if this file has the same name\n+\t\t// as t, this file becomes the contents of t, so\n+\t\t//  t, err := New(name).Funcs(xxx).ParseFiles(name)\n+\t\t// works. Otherwise we create a new template associated with t.\n+\t\tvar tmpl *Template\n+\t\tif t == nil {\n+\t\t\tt = New(name)\n+\t\t}\n+\t\tif name == t.Name() {\n+\t\t\ttmpl = t\n+\t\t} else {\n+\t\t\ttmpl = t.New(name)\n+\t\t}\n+\t\t_, err = tmpl.Parse(s)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n-\treturn set, nil\n-}\n-\n-// ParseTemplateGlob parses the template files matched by the\n-// patern and adds them to the set. Each template will be named\n-// the base name of its file.\n-// Unlike with ParseGlob, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateGlob is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseTemplateGlob(pattern string) (*Set, error) {\n+\treturn t, nil\n+}\n+\n+// ParseGlob creates a new Template and parses the template definitions from the\n+// files identified by the pattern, which must match at least one file. The\n+// returned template will have the (base) name and (parsed) contents of the\n+// first file matched by the pattern. ParseGlob is equivalent to calling\n+// ParseFiles with the list of files matched by the pattern.\n+func ParseGlob(pattern string) (*Template, error) {\n+\treturn parseGlob(nil, pattern)\n+}\n+\n+// ParseGlob parses the template definitions in the files identified by the\n+// pattern and associates the resulting templates with t. The pattern is\n+// processed by filepath.Glob and must match at least one file. ParseGlob is\n+// equivalent to calling t.ParseFiles with the list of files matched by the\n+// pattern.\n+func (t *Template) ParseGlob(pattern string) (*Template, error) {\n+\treturn parseGlob(t, pattern)\n+}\n+\n+// parseGlob is the implementation of the function and method ParseGlob.\n+func parseGlob(t *Template, pattern string) (*Template, error) {\n \tfilenames, err := filepath.Glob(pattern)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn s.ParseTemplateFiles(filenames...)\n-}\n-\n-// ParseTemplateFiles creates a set by parsing the named files,\n-// each of which defines a single template. Each template will be\n-// named the base name of its file.\n-// Unlike with ParseFiles, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateFiles is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself. Parsing stops if an error is\n-// encountered.\n-func ParseTemplateFiles(filenames ...string) (*Set, error) {\n-\treturn new(Set).ParseTemplateFiles(filenames...)\n-}\n-\n-// ParseTemplateGlob creates a set by parsing the files matched\n-// by the pattern, each of which defines a single template. The pattern\n-// is processed by filepath.Glob and must match at least one file. Each\n-// template will be named the base name of its file.\n-// Unlike with ParseGlob, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateGlob is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself. Parsing stops if an error is\n-// encountered.\n-func ParseTemplateGlob(pattern string) (*Set, error) {\n-\treturn new(Set).ParseTemplateGlob(pattern)\n+\tif len(filenames) == 0 {\n+\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n+\t}\n+\treturn parseFiles(t, filenames...)\n }"}, {"sha": "69af96840c272b1c8bfa9313b174315d24f1d9ee", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -289,7 +289,11 @@ func (z *Tokenizer) readComment() {\n \tfor dashCount := 2; ; {\n \t\tc := z.readByte()\n \t\tif z.err != nil {\n-\t\t\tz.data.end = z.raw.end\n+\t\t\t// Ignore up to two dashes at EOF.\n+\t\t\tif dashCount > 2 {\n+\t\t\t\tdashCount = 2\n+\t\t\t}\n+\t\t\tz.data.end = z.raw.end - dashCount\n \t\t\treturn\n \t\t}\n \t\tswitch c {\n@@ -375,6 +379,28 @@ func (z *Tokenizer) readMarkupDeclaration() TokenType {\n \treturn DoctypeToken\n }\n \n+// startTagIn returns whether the start tag in z.buf[z.data.start:z.data.end]\n+// case-insensitively matches any element of ss.\n+func (z *Tokenizer) startTagIn(ss ...string) bool {\n+loop:\n+\tfor _, s := range ss {\n+\t\tif z.data.end-z.data.start != len(s) {\n+\t\t\tcontinue loop\n+\t\t}\n+\t\tfor i := 0; i < len(s); i++ {\n+\t\t\tc := z.buf[z.data.start+i]\n+\t\t\tif 'A' <= c && c <= 'Z' {\n+\t\t\t\tc += 'a' - 'A'\n+\t\t\t}\n+\t\t\tif c != s[i] {\n+\t\t\t\tcontinue loop\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // readStartTag reads the next start tag token. The opening \"<a\" has already\n // been consumed, where 'a' means anything in [A-Za-z].\n func (z *Tokenizer) readStartTag() TokenType {\n@@ -401,17 +427,27 @@ func (z *Tokenizer) readStartTag() TokenType {\n \t\t\tbreak\n \t\t}\n \t}\n-\t// Any \"<noembed>\", \"<noframes>\", \"<noscript>\", \"<plaintext\", \"<script>\", \"<style>\",\n-\t// \"<textarea>\" or \"<title>\" tag flags the tokenizer's next token as raw.\n-\t// The tag name lengths of these special cases ranges in [5, 9].\n-\tif x := z.data.end - z.data.start; 5 <= x && x <= 9 {\n-\t\tswitch z.buf[z.data.start] {\n-\t\tcase 'n', 'p', 's', 't', 'N', 'P', 'S', 'T':\n-\t\t\tswitch s := strings.ToLower(string(z.buf[z.data.start:z.data.end])); s {\n-\t\t\tcase \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"textarea\", \"title\":\n-\t\t\t\tz.rawTag = s\n-\t\t\t}\n-\t\t}\n+\t// Several tags flag the tokenizer's next token as raw.\n+\tc, raw := z.buf[z.data.start], false\n+\tif 'A' <= c && c <= 'Z' {\n+\t\tc += 'a' - 'A'\n+\t}\n+\tswitch c {\n+\tcase 'i':\n+\t\traw = z.startTagIn(\"iframe\")\n+\tcase 'n':\n+\t\traw = z.startTagIn(\"noembed\", \"noframes\", \"noscript\")\n+\tcase 'p':\n+\t\traw = z.startTagIn(\"plaintext\")\n+\tcase 's':\n+\t\traw = z.startTagIn(\"script\", \"style\")\n+\tcase 't':\n+\t\traw = z.startTagIn(\"textarea\", \"title\")\n+\tcase 'x':\n+\t\traw = z.startTagIn(\"xmp\")\n+\t}\n+\tif raw {\n+\t\tz.rawTag = strings.ToLower(string(z.buf[z.data.start:z.data.end]))\n \t}\n \t// Look for a self-closing token like \"<br/>\".\n \tif z.err == nil && z.buf[z.raw.end-2] == '/' {"}, {"sha": "672d60c420940b558f85822013faa9b82d0e80ed", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -325,6 +325,26 @@ var tokenTests = []tokenTest{\n \t},\n \t{\n \t\t\"comment9\",\n+\t\t\"a<!--z-\",\n+\t\t\"a$<!--z-->\",\n+\t},\n+\t{\n+\t\t\"comment10\",\n+\t\t\"a<!--z--\",\n+\t\t\"a$<!--z-->\",\n+\t},\n+\t{\n+\t\t\"comment11\",\n+\t\t\"a<!--z---\",\n+\t\t\"a$<!--z--->\",\n+\t},\n+\t{\n+\t\t\"comment12\",\n+\t\t\"a<!--z----\",\n+\t\t\"a$<!--z---->\",\n+\t},\n+\t{\n+\t\t\"comment13\",\n \t\t\"a<!--x--!>z\",\n \t\t\"a$<!--x-->$z\",\n \t},"}, {"sha": "be7fa5f2bc8bc8da61afe778c4f2308251d998d5", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -36,8 +36,8 @@ func ReadFile(filename string) ([]byte, error) {\n \t// read, so let's try it but be prepared for the answer to be wrong.\n \tfi, err := f.Stat()\n \tvar n int64\n-\tif err == nil && fi.Size < 2e9 { // Don't preallocate a huge buffer, just in case.\n-\t\tn = fi.Size\n+\tif size := fi.Size(); err == nil && size < 2e9 { // Don't preallocate a huge buffer, just in case.\n+\t\tn = size\n \t}\n \t// As initial capacity for readAll, use n + a little extra in case Size is zero,\n \t// and to avoid another allocation after Read has filled the buffer.  The readAll\n@@ -63,16 +63,16 @@ func WriteFile(filename string, data []byte, perm uint32) error {\n \treturn err\n }\n \n-// A fileInfoList implements sort.Interface.\n-type fileInfoList []*os.FileInfo\n+// byName implements sort.Interface.\n+type byName []os.FileInfo\n \n-func (f fileInfoList) Len() int           { return len(f) }\n-func (f fileInfoList) Less(i, j int) bool { return f[i].Name < f[j].Name }\n-func (f fileInfoList) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n+func (f byName) Len() int           { return len(f) }\n+func (f byName) Less(i, j int) bool { return f[i].Name() < f[j].Name() }\n+func (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n \n // ReadDir reads the directory named by dirname and returns\n // a list of sorted directory entries.\n-func ReadDir(dirname string) ([]*os.FileInfo, error) {\n+func ReadDir(dirname string) ([]os.FileInfo, error) {\n \tf, err := os.Open(dirname)\n \tif err != nil {\n \t\treturn nil, err\n@@ -82,12 +82,8 @@ func ReadDir(dirname string) ([]*os.FileInfo, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tfi := make(fileInfoList, len(list))\n-\tfor i := range list {\n-\t\tfi[i] = &list[i]\n-\t}\n-\tsort.Sort(fi)\n-\treturn fi, nil\n+\tsort.Sort(byName(list))\n+\treturn list, nil\n }\n \n type nopCloser struct {"}, {"sha": "89d6815ad503beaf2e25dd63b1248fc7e9518687", "filename": "libgo/go/io/ioutil/ioutil_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,8 +15,8 @@ func checkSize(t *testing.T, path string, size int64) {\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %q (looking for size %d): %s\", path, size, err)\n \t}\n-\tif dir.Size != size {\n-\t\tt.Errorf(\"Stat %q: size %d want %d\", path, dir.Size, size)\n+\tif dir.Size() != size {\n+\t\tt.Errorf(\"Stat %q: size %d want %d\", path, dir.Size(), size)\n \t}\n }\n \n@@ -76,9 +76,9 @@ func TestReadDir(t *testing.T) {\n \tfoundTestDir := false\n \tfor _, dir := range list {\n \t\tswitch {\n-\t\tcase dir.IsRegular() && dir.Name == \"ioutil_test.go\":\n+\t\tcase !dir.IsDir() && dir.Name() == \"ioutil_test.go\":\n \t\t\tfoundTest = true\n-\t\tcase dir.IsDirectory() && dir.Name == \"_test\":\n+\t\tcase dir.IsDir() && dir.Name() == \"_test\":\n \t\t\tfoundTestDir = true\n \t\t}\n \t}"}, {"sha": "645eed6abb855489554cd833dd21b45b849b22d4", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -18,7 +18,7 @@ import (\n var rand uint32\n \n func reseed() uint32 {\n-\treturn uint32(time.Nanoseconds() + int64(os.Getpid()))\n+\treturn uint32(time.Now().UnixNano() + int64(os.Getpid()))\n }\n \n func nextSuffix() string {"}, {"sha": "eb717f7bc21c7405bf1716aa100b06a21d9f22b1", "filename": "libgo/go/io/multi_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fio%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -77,7 +77,7 @@ func TestMultiWriter(t *testing.T) {\n \t\tt.Errorf(\"unexpected error: %v\", err)\n \t}\n \n-\tsha1hex := fmt.Sprintf(\"%x\", sha1.Sum())\n+\tsha1hex := fmt.Sprintf(\"%x\", sha1.Sum(nil))\n \tif sha1hex != \"01cb303fa8c30a64123067c5aa6284ba7ec2d31b\" {\n \t\tt.Error(\"incorrect sha1 value\")\n \t}"}, {"sha": "a5d88fd9b349f4ff1267932d60bb5ffa3784a9da", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -83,27 +83,28 @@ func itoa(buf *bytes.Buffer, i int, wid int) {\n \t}\n }\n \n-func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, file string, line int) {\n+func (l *Logger) formatHeader(buf *bytes.Buffer, t time.Time, file string, line int) {\n \tbuf.WriteString(l.prefix)\n \tif l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {\n-\t\tt := time.SecondsToLocalTime(ns / 1e9)\n \t\tif l.flag&Ldate != 0 {\n-\t\t\titoa(buf, int(t.Year), 4)\n+\t\t\tyear, month, day := t.Date()\n+\t\t\titoa(buf, year, 4)\n \t\t\tbuf.WriteByte('/')\n-\t\t\titoa(buf, int(t.Month), 2)\n+\t\t\titoa(buf, int(month), 2)\n \t\t\tbuf.WriteByte('/')\n-\t\t\titoa(buf, int(t.Day), 2)\n+\t\t\titoa(buf, day, 2)\n \t\t\tbuf.WriteByte(' ')\n \t\t}\n \t\tif l.flag&(Ltime|Lmicroseconds) != 0 {\n-\t\t\titoa(buf, int(t.Hour), 2)\n+\t\t\thour, min, sec := t.Clock()\n+\t\t\titoa(buf, hour, 2)\n \t\t\tbuf.WriteByte(':')\n-\t\t\titoa(buf, int(t.Minute), 2)\n+\t\t\titoa(buf, min, 2)\n \t\t\tbuf.WriteByte(':')\n-\t\t\titoa(buf, int(t.Second), 2)\n+\t\t\titoa(buf, sec, 2)\n \t\t\tif l.flag&Lmicroseconds != 0 {\n \t\t\t\tbuf.WriteByte('.')\n-\t\t\t\titoa(buf, int(ns%1e9)/1e3, 6)\n+\t\t\t\titoa(buf, t.Nanosecond()/1e3, 6)\n \t\t\t}\n \t\t\tbuf.WriteByte(' ')\n \t\t}\n@@ -133,7 +134,7 @@ func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, file string, line int\n // provided for generality, although at the moment on all pre-defined\n // paths it will be 2.\n func (l *Logger) Output(calldepth int, s string) error {\n-\tnow := time.Nanoseconds() // get this early.\n+\tnow := time.Now() // get this early.\n \tvar file string\n \tvar line int\n \tl.mu.Lock()"}, {"sha": "4c6297c6f3327005f6dbd5eed35760119caffcb5", "filename": "libgo/go/math/abs.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fabs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fabs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fabs.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,8 +7,7 @@ package math\n // Abs returns the absolute value of x.\n //\n // Special cases are:\n-//\tAbs(+Inf) = +Inf\n-//\tAbs(-Inf) = +Inf\n+//\tAbs(\u00b1Inf) = +Inf\n //\tAbs(NaN) = NaN\n func Abs(x float64) float64 {\n \tswitch {"}, {"sha": "d6979463d65f70b03294ef863ab7b4d1316fef66", "filename": "libgo/go/math/asinh.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fasinh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fasinh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fasinh.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -33,8 +33,7 @@ package math\n // Asinh(x) calculates the inverse hyperbolic sine of x.\n //\n // Special cases are:\n-//\tAsinh(+Inf) = +Inf\n-//\tAsinh(-Inf) = -Inf\n+//\tAsinh(\u00b1Inf) = \u00b1Inf\n //\tAsinh(NaN) = NaN\n func Asinh(x float64) float64 {\n \tconst ("}, {"sha": "0950eeedbd2f3757dc324f030d77c6ae721b058d", "filename": "libgo/go/math/big/calibrate_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -22,14 +22,14 @@ import (\n var calibrate = flag.Bool(\"calibrate\", false, \"run calibration test\")\n \n // measure returns the time to run f\n-func measure(f func()) int64 {\n+func measure(f func()) time.Duration {\n \tconst N = 100\n-\tstart := time.Nanoseconds()\n+\tstart := time.Now()\n \tfor i := N; i > 0; i-- {\n \t\tf()\n \t}\n-\tstop := time.Nanoseconds()\n-\treturn (stop - start) / N\n+\tstop := time.Now()\n+\treturn stop.Sub(start) / N\n }\n \n func computeThresholds() {\n@@ -46,7 +46,7 @@ func computeThresholds() {\n \tth1 := -1\n \tth2 := -1\n \n-\tvar deltaOld int64\n+\tvar deltaOld time.Duration\n \tfor count := -1; count != 0; count-- {\n \t\t// determine Tk, the work load execution time using Karatsuba multiplication\n \t\tkaratsubaThreshold = n // enable karatsuba"}, {"sha": "aa7c19495494fff3778d2d5d326eb789ba8a9371", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1242,10 +1242,14 @@ func TestBitSet(t *testing.T) {\n \t\tx.SetString(test.x, 0)\n \t\tb := x.Bit(test.i)\n \t\tif b != test.b {\n-\n-\t\t\tt.Errorf(\"#%d want %v got %v\", i, test.b, b)\n+\t\t\tt.Errorf(\"#%d got %v want %v\", i, b, test.b)\n \t\t}\n \t}\n+\tz := NewInt(1)\n+\tz.SetBit(NewInt(0), 2, 1)\n+\tif z.Cmp(NewInt(4)) != 0 {\n+\t\tt.Errorf(\"destination leaked into result; got %s want 4\", z)\n+\t}\n }\n \n func BenchmarkBitset(b *testing.B) {"}, {"sha": "680445dc9a73a30d24f4020b8fcd57a99b877d3d", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 191, "deletions": 38, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -21,7 +21,9 @@ package big\n import (\n \t\"errors\"\n \t\"io\"\n+\t\"math\"\n \t\"math/rand\"\n+\t\"sync\"\n )\n \n // An unsigned integer x of the form\n@@ -719,17 +721,17 @@ func (x nat) string(charset string) string {\n \n \t// special cases\n \tswitch {\n-\tcase b < 2 || b > 256:\n+\tcase b < 2 || MaxBase < b:\n \t\tpanic(\"illegal base\")\n \tcase len(x) == 0:\n \t\treturn string(charset[0])\n \t}\n \n \t// allocate buffer for conversion\n-\ti := x.bitLen()/log2(b) + 1 // +1: round up\n+\ti := int(float64(x.bitLen())/math.Log2(float64(b))) + 1 // off by one at most\n \ts := make([]byte, i)\n \n-\t// special case: power of two bases can avoid divisions completely\n+\t// convert power of two and non power of two bases separately\n \tif b == b&-b {\n \t\t// shift is base-b digit size in bits\n \t\tshift := uint(trailingZeroBits(b)) // shift > 0 because b >= 2\n@@ -771,65 +773,209 @@ func (x nat) string(charset string) string {\n \t\t\tw >>= shift\n \t\t\tnbits -= shift\n \t\t}\n+\t} else {\n+\t\t// determine \"big base\" as in 10^19 for 19 decimal digits in a 64 bit Word\n+\t\tbb := Word(1) // big base is b**ndigits\n+\t\tndigits := 0  // number of base b digits\n+\t\tfor max := Word(_M / b); bb <= max; bb *= b {\n+\t\t\tndigits++ // maximize ndigits where bb = b**ndigits, bb <= _M\n+\t\t}\n \n-\t\treturn string(s[i:])\n-\t}\n+\t\t// construct table of successive squares of bb*leafSize to use in subdivisions\n+\t\ttable := divisors(len(x), b, ndigits, bb)\n \n-\t// general case: extract groups of digits by multiprecision division\n+\t\t// preserve x, create local copy for use in divisions\n+\t\tq := nat(nil).set(x)\n \n-\t// maximize ndigits where b**ndigits < 2^_W; bb (big base) is b**ndigits\n-\tbb := Word(1)\n-\tndigits := 0\n-\tfor max := Word(_M / b); bb <= max; bb *= b {\n-\t\tndigits++\n+\t\t// convert q to string s in base b with index of MSD indicated by return value\n+\t\ti = q.convertWords(0, i, s, charset, b, ndigits, bb, table)\n \t}\n \n-\t// preserve x, create local copy for use in repeated divisions\n-\tq := nat(nil).set(x)\n-\tvar r Word\n+\treturn string(s[i:])\n+}\n+\n+// Convert words of q to base b digits in s directly using iterated nat/Word divison to extract\n+// low-order Words and indirectly by recursive subdivision and nat/nat division by tabulated \n+// divisors. \n+//\n+// The direct method processes n Words by n divW() calls, each of which visits every Word in the \n+// incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. \n+// Indirect conversion divides q by its approximate square root, yielding two parts, each half \n+// the size of q. Using the direct method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s plus \n+// the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and is \n+// made better by splitting the subblocks recursively. Best is to split blocks until one more \n+// split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the \n+// direct approach. This threshold is represented by leafSize. Benchmarking of leafSize in the \n+// range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and \n+// ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for \n+// specfic hardware.\n+//\n+// lo and hi index character array s. conversion starts with the LSD at hi and moves down toward\n+// the MSD, which will be at s[0] or s[1]. lo == 0 signals span includes the most significant word.\n+//\n+func (q nat) convertWords(lo, hi int, s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) int {\n+\t// indirect conversion: split larger blocks to reduce quadratic expense of iterated nat/W division\n+\tif leafSize > 0 && len(q) > leafSize && table != nil {\n+\t\tvar r nat\n+\t\tindex := len(table) - 1\n+\t\tfor len(q) > leafSize {\n+\t\t\t// find divisor close to sqrt(q) if possible, but in any case < q\n+\t\t\tmaxLength := q.bitLen()     // ~= log2 q, or at of least largest possible q of this bit length\n+\t\t\tminLength := maxLength >> 1 // ~= log2 sqrt(q)\n+\t\t\tfor index > 0 && table[index-1].nbits > minLength {\n+\t\t\t\tindex-- // desired\n+\t\t\t}\n+\t\t\tif table[index].nbits >= maxLength && table[index].bbb.cmp(q) >= 0 {\n+\t\t\t\tindex--\n+\t\t\t\tif index < 0 {\n+\t\t\t\t\tpanic(\"internal inconsistency\")\n+\t\t\t\t}\n+\t\t\t}\n \n-\t// convert\n-\tif b == 10 { // hard-coding for 10 here speeds this up by 1.25x\n+\t\t\t// split q into the two digit number (q'*bbb + r) to form independent subblocks\n+\t\t\tq, r = q.div(r, q, table[index].bbb)\n+\n+\t\t\t// convert subblocks and collect results in s[lo:partition] and s[partition:hi]\n+\t\t\tpartition := hi - table[index].ndigits\n+\t\t\tr.convertWords(partition, hi, s, charset, b, ndigits, bb, table[0:index])\n+\t\t\thi = partition // i.e., q.convertWords(lo, partition, s, charset, b, ndigits, bb, table[0:index+1])\n+\t\t}\n+\t} // having split any large blocks now process the remaining small block\n+\n+\t// direct conversion: process smaller blocks monolithically to avoid overhead of nat/nat division\n+\tvar r Word\n+\tif b == 10 { // hard-coding for 10 here speeds this up by 1.25x (allows mod as mul vs div)\n \t\tfor len(q) > 0 {\n \t\t\t// extract least significant, base bb \"digit\"\n-\t\t\tq, r = q.divW(q, bb) // N.B. >82% of time is here. Optimize divW\n-\t\t\tif len(q) == 0 {\n+\t\t\tq, r = q.divW(q, bb)\n+\t\t\tif lo == 0 && len(q) == 0 {\n \t\t\t\t// skip leading zeros in most-significant group of digits\n \t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n-\t\t\t\t\ti--\n-\t\t\t\t\ts[i] = charset[r%10]\n-\t\t\t\t\tr /= 10\n+\t\t\t\t\thi--\n+\t\t\t\t\tt := r / 10\n+\t\t\t\t\ts[hi] = charset[r-(t<<3+t<<1)] // 8*t + 2*t = 10*t; r - 10*int(r/10) = r mod 10\n+\t\t\t\t\tr = t\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tfor j := 0; j < ndigits; j++ {\n-\t\t\t\t\ti--\n-\t\t\t\t\ts[i] = charset[r%10]\n-\t\t\t\t\tr /= 10\n+\t\t\t\tfor j := 0; j < ndigits && hi > lo; j++ {\n+\t\t\t\t\thi--\n+\t\t\t\t\tt := r / 10\n+\t\t\t\t\ts[hi] = charset[r-(t<<3+t<<1)] // 8*t + 2*t = 10*t; r - 10*int(r/10) = r mod 10\n+\t\t\t\t\tr = t\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t} else {\n \t\tfor len(q) > 0 {\n \t\t\t// extract least significant group of digits\n-\t\t\tq, r = q.divW(q, bb) // N.B. >82% of time is here. Optimize divW\n-\t\t\tif len(q) == 0 {\n+\t\t\tq, r = q.divW(q, bb)\n+\t\t\tif lo == 0 && len(q) == 0 {\n \t\t\t\t// skip leading zeros in most-significant group of digits\n \t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n-\t\t\t\t\ti--\n-\t\t\t\t\ts[i] = charset[r%b]\n-\t\t\t\t\tr /= b\n+\t\t\t\t\thi--\n+\t\t\t\t\ts[hi] = charset[r%b]\n+\t\t\t\t\tr = r / b\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tfor j := 0; j < ndigits; j++ {\n-\t\t\t\t\ti--\n-\t\t\t\t\ts[i] = charset[r%b]\n-\t\t\t\t\tr /= b\n+\t\t\t\tfor j := 0; j < ndigits && hi > lo; j++ {\n+\t\t\t\t\thi--\n+\t\t\t\t\ts[hi] = charset[r%b]\n+\t\t\t\t\tr = r / b\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn string(s[i:])\n+\t// prepend high-order zeroes when q has been normalized to a short number of Words.\n+\t// however, do not prepend zeroes when converting the most dignificant digits.\n+\tif lo != 0 { // if not MSD\n+\t\tzero := charset[0]\n+\t\tfor hi > lo { // while need more leading zeroes\n+\t\t\thi--\n+\t\t\ts[hi] = zero\n+\t\t}\n+\t}\n+\n+\t// return index of most significant output digit in s[] (stored in lowest index)\n+\treturn hi\n+}\n+\n+// Split blocks greater than leafSize Words (or set to 0 to disable indirect conversion)\n+// Benchmark and configure leafSize using: gotest -test.bench=\"Leaf\"\n+//   8 and 16 effective on 3.0 GHz Xeon \"Clovertown\" CPU (128 byte cache lines)\n+//   8 and 16 effective on 2.66 GHz Core 2 Duo \"Penryn\" CPU\n+var leafSize int = 8 // number of Word-size binary values treat as a monolithic block\n+\n+type divisor struct {\n+\tbbb     nat // divisor\n+\tnbits   int // bit length of divisor (discounting leading zeroes) ~= log2(bbb)\n+\tndigits int // digit length of divisor in terms of output base digits\n+}\n+\n+const maxCache = 64               // maximum number of divisors in a single table\n+var cacheBase10 [maxCache]divisor // cached divisors for base 10\n+var cacheLock sync.Mutex          // defense against concurrent table extensions\n+\n+// construct table of powers of bb*leafSize to use in subdivisions\n+func divisors(m int, b Word, ndigits int, bb Word) []divisor {\n+\t// only build table when indirect conversion is enabled and x is large\n+\tif leafSize == 0 || m <= leafSize {\n+\t\treturn nil\n+\t}\n+\n+\t// determine k where (bb**leafSize)**(2**k) >= sqrt(x)\n+\tk := 1\n+\tfor words := leafSize; words < m>>1 && k < maxCache; words <<= 1 {\n+\t\tk++\n+\t}\n+\n+\t// create new table of divisors or extend and reuse existing table as appropriate\n+\tvar cached bool\n+\tvar table []divisor\n+\tswitch b {\n+\tcase 10:\n+\t\ttable = cacheBase10[0:k] // reuse old table for this conversion\n+\t\tcached = true\n+\tdefault:\n+\t\ttable = make([]divisor, k) // new table for this conversion\n+\t}\n+\n+\t// extend table\n+\tif table[k-1].ndigits == 0 {\n+\t\tif cached {\n+\t\t\tcacheLock.Lock() // begin critical section\n+\t\t}\n+\n+\t\tvar i int\n+\t\tvar larger nat\n+\t\tfor i < k && table[i].ndigits != 0 { // skip existing entries\n+\t\t\ti++\n+\t\t}\n+\t\tfor ; i < k; i++ { // add new entries\n+\t\t\tif i == 0 {\n+\t\t\t\ttable[i].bbb = nat(nil).expWW(bb, Word(leafSize))\n+\t\t\t\ttable[i].ndigits = ndigits * leafSize\n+\t\t\t} else {\n+\t\t\t\ttable[i].bbb = nat(nil).mul(table[i-1].bbb, table[i-1].bbb)\n+\t\t\t\ttable[i].ndigits = 2 * table[i-1].ndigits\n+\t\t\t}\n+\n+\t\t\t// optimization: exploit aggregated extra bits in macro blocks\n+\t\t\tlarger = nat(nil).set(table[i].bbb)\n+\t\t\tfor mulAddVWW(larger, larger, b, 0) == 0 {\n+\t\t\t\ttable[i].bbb = table[i].bbb.set(larger)\n+\t\t\t\ttable[i].ndigits++\n+\t\t\t}\n+\n+\t\t\ttable[i].nbits = table[i].bbb.bitLen()\n+\t\t}\n+\n+\t\tif cached {\n+\t\t\tcacheLock.Unlock() // end critical section\n+\t\t}\n+\t}\n+\n+\treturn table\n }\n \n const deBruijn32 = 0x077CB531\n@@ -919,9 +1065,11 @@ func (z nat) setBit(x nat, i uint, b uint) nat {\n \t\treturn z.norm()\n \tcase 1:\n \t\tif j >= n {\n-\t\t\tn = j + 1\n+\t\t\tz = z.make(j + 1)\n+\t\t\tz[n:].clear()\n+\t\t} else {\n+\t\t\tz = z.make(n)\n \t\t}\n-\t\tz = z.make(n)\n \t\tcopy(z, x)\n \t\tz[j] |= m\n \t\t// no need to normalize\n@@ -1140,7 +1288,12 @@ func (z nat) expNN(x, y, m nat) nat {\n \t\t}\n \t}\n \n-\treturn z\n+\treturn z.norm()\n+}\n+\n+// calculate x**y for Word arguments y and y\n+func (z nat) expWW(x, y Word) nat {\n+\treturn z.expNN(nat(nil).setWord(x), nat(nil).setWord(y), nil)\n }\n \n // probablyPrime performs reps Miller-Rabin tests to check whether n is prime."}, {"sha": "e3c6552d9fb3de34cb8a75400dbb4da7066c0db2", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 116, "deletions": 124, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -370,86 +370,34 @@ func BenchmarkScanPi(b *testing.B) {\n \t}\n }\n \n-const (\n-\t// 314**271\n-\t// base  2: 2249 digits\n-\t// base  8:  751 digits\n-\t// base 10:  678 digits\n-\t// base 16:  563 digits\n-\tshortBase     = 314\n-\tshortExponent = 271\n-\n-\t// 3141**2178\n-\t// base  2: 31577 digits\n-\t// base  8: 10527 digits\n-\t// base 10:  9507 digits\n-\t// base 16:  7895 digits\n-\tmediumBase     = 3141\n-\tmediumExponent = 2718\n-\n-\t// 3141**2178\n-\t// base  2: 406078 digits\n-\t// base  8: 135360 digits\n-\t// base 10: 122243 digits\n-\t// base 16: 101521 digits\n-\tlongBase     = 31415\n-\tlongExponent = 27182\n-)\n-\n-func BenchmarkScanShort2(b *testing.B) {\n-\tScanHelper(b, 2, shortBase, shortExponent)\n-}\n-\n-func BenchmarkScanShort8(b *testing.B) {\n-\tScanHelper(b, 8, shortBase, shortExponent)\n-}\n-\n-func BenchmarkScanSort10(b *testing.B) {\n-\tScanHelper(b, 10, shortBase, shortExponent)\n-}\n-\n-func BenchmarkScanShort16(b *testing.B) {\n-\tScanHelper(b, 16, shortBase, shortExponent)\n-}\n-\n-func BenchmarkScanMedium2(b *testing.B) {\n-\tScanHelper(b, 2, mediumBase, mediumExponent)\n-}\n-\n-func BenchmarkScanMedium8(b *testing.B) {\n-\tScanHelper(b, 8, mediumBase, mediumExponent)\n-}\n-\n-func BenchmarkScanMedium10(b *testing.B) {\n-\tScanHelper(b, 10, mediumBase, mediumExponent)\n-}\n-\n-func BenchmarkScanMedium16(b *testing.B) {\n-\tScanHelper(b, 16, mediumBase, mediumExponent)\n-}\n-\n-func BenchmarkScanLong2(b *testing.B) {\n-\tScanHelper(b, 2, longBase, longExponent)\n-}\n-\n-func BenchmarkScanLong8(b *testing.B) {\n-\tScanHelper(b, 8, longBase, longExponent)\n-}\n-\n-func BenchmarkScanLong10(b *testing.B) {\n-\tScanHelper(b, 10, longBase, longExponent)\n-}\n-\n-func BenchmarkScanLong16(b *testing.B) {\n-\tScanHelper(b, 16, longBase, longExponent)\n-}\n-\n-func ScanHelper(b *testing.B, base int, xv, yv Word) {\n+func BenchmarkScan10Base2(b *testing.B)     { ScanHelper(b, 2, 10, 10) }\n+func BenchmarkScan100Base2(b *testing.B)    { ScanHelper(b, 2, 10, 100) }\n+func BenchmarkScan1000Base2(b *testing.B)   { ScanHelper(b, 2, 10, 1000) }\n+func BenchmarkScan10000Base2(b *testing.B)  { ScanHelper(b, 2, 10, 10000) }\n+func BenchmarkScan100000Base2(b *testing.B) { ScanHelper(b, 2, 10, 100000) }\n+\n+func BenchmarkScan10Base8(b *testing.B)     { ScanHelper(b, 8, 10, 10) }\n+func BenchmarkScan100Base8(b *testing.B)    { ScanHelper(b, 8, 10, 100) }\n+func BenchmarkScan1000Base8(b *testing.B)   { ScanHelper(b, 8, 10, 1000) }\n+func BenchmarkScan10000Base8(b *testing.B)  { ScanHelper(b, 8, 10, 10000) }\n+func BenchmarkScan100000Base8(b *testing.B) { ScanHelper(b, 8, 10, 100000) }\n+\n+func BenchmarkScan10Base10(b *testing.B)     { ScanHelper(b, 10, 10, 10) }\n+func BenchmarkScan100Base10(b *testing.B)    { ScanHelper(b, 10, 10, 100) }\n+func BenchmarkScan1000Base10(b *testing.B)   { ScanHelper(b, 10, 10, 1000) }\n+func BenchmarkScan10000Base10(b *testing.B)  { ScanHelper(b, 10, 10, 10000) }\n+func BenchmarkScan100000Base10(b *testing.B) { ScanHelper(b, 10, 10, 100000) }\n+\n+func BenchmarkScan10Base16(b *testing.B)     { ScanHelper(b, 16, 10, 10) }\n+func BenchmarkScan100Base16(b *testing.B)    { ScanHelper(b, 16, 10, 100) }\n+func BenchmarkScan1000Base16(b *testing.B)   { ScanHelper(b, 16, 10, 1000) }\n+func BenchmarkScan10000Base16(b *testing.B)  { ScanHelper(b, 16, 10, 10000) }\n+func BenchmarkScan100000Base16(b *testing.B) { ScanHelper(b, 16, 10, 100000) }\n+\n+func ScanHelper(b *testing.B, base int, x, y Word) {\n \tb.StopTimer()\n-\tvar x, y, z nat\n-\tx = x.setWord(xv)\n-\ty = y.setWord(yv)\n-\tz = z.expNN(x, y, nil)\n+\tvar z nat\n+\tz = z.expWW(x, y)\n \n \tvar s string\n \ts = z.string(lowercaseDigits[0:base])\n@@ -459,68 +407,112 @@ func ScanHelper(b *testing.B, base int, xv, yv Word) {\n \tb.StartTimer()\n \n \tfor i := 0; i < b.N; i++ {\n-\t\tx.scan(strings.NewReader(s), base)\n+\t\tz.scan(strings.NewReader(s), base)\n \t}\n }\n \n-func BenchmarkStringShort2(b *testing.B) {\n-\tStringHelper(b, 2, shortBase, shortExponent)\n-}\n+func BenchmarkString10Base2(b *testing.B)     { StringHelper(b, 2, 10, 10) }\n+func BenchmarkString100Base2(b *testing.B)    { StringHelper(b, 2, 10, 100) }\n+func BenchmarkString1000Base2(b *testing.B)   { StringHelper(b, 2, 10, 1000) }\n+func BenchmarkString10000Base2(b *testing.B)  { StringHelper(b, 2, 10, 10000) }\n+func BenchmarkString100000Base2(b *testing.B) { StringHelper(b, 2, 10, 100000) }\n \n-func BenchmarkStringShort8(b *testing.B) {\n-\tStringHelper(b, 8, shortBase, shortExponent)\n-}\n+func BenchmarkString10Base8(b *testing.B)     { StringHelper(b, 8, 10, 10) }\n+func BenchmarkString100Base8(b *testing.B)    { StringHelper(b, 8, 10, 100) }\n+func BenchmarkString1000Base8(b *testing.B)   { StringHelper(b, 8, 10, 1000) }\n+func BenchmarkString10000Base8(b *testing.B)  { StringHelper(b, 8, 10, 10000) }\n+func BenchmarkString100000Base8(b *testing.B) { StringHelper(b, 8, 10, 100000) }\n \n-func BenchmarkStringShort10(b *testing.B) {\n-\tStringHelper(b, 10, shortBase, shortExponent)\n-}\n-\n-func BenchmarkStringShort16(b *testing.B) {\n-\tStringHelper(b, 16, shortBase, shortExponent)\n-}\n+func BenchmarkString10Base10(b *testing.B)     { StringHelper(b, 10, 10, 10) }\n+func BenchmarkString100Base10(b *testing.B)    { StringHelper(b, 10, 10, 100) }\n+func BenchmarkString1000Base10(b *testing.B)   { StringHelper(b, 10, 10, 1000) }\n+func BenchmarkString10000Base10(b *testing.B)  { StringHelper(b, 10, 10, 10000) }\n+func BenchmarkString100000Base10(b *testing.B) { StringHelper(b, 10, 10, 100000) }\n \n-func BenchmarkStringMedium2(b *testing.B) {\n-\tStringHelper(b, 2, mediumBase, mediumExponent)\n-}\n+func BenchmarkString10Base16(b *testing.B)     { StringHelper(b, 16, 10, 10) }\n+func BenchmarkString100Base16(b *testing.B)    { StringHelper(b, 16, 10, 100) }\n+func BenchmarkString1000Base16(b *testing.B)   { StringHelper(b, 16, 10, 1000) }\n+func BenchmarkString10000Base16(b *testing.B)  { StringHelper(b, 16, 10, 10000) }\n+func BenchmarkString100000Base16(b *testing.B) { StringHelper(b, 16, 10, 100000) }\n \n-func BenchmarkStringMedium8(b *testing.B) {\n-\tStringHelper(b, 8, mediumBase, mediumExponent)\n-}\n+func StringHelper(b *testing.B, base int, x, y Word) {\n+\tb.StopTimer()\n+\tvar z nat\n+\tz = z.expWW(x, y)\n+\tz.string(lowercaseDigits[0:base]) // warm divisor cache\n+\tb.StartTimer()\n \n-func BenchmarkStringMedium10(b *testing.B) {\n-\tStringHelper(b, 10, mediumBase, mediumExponent)\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = z.string(lowercaseDigits[0:base])\n+\t}\n }\n \n-func BenchmarkStringMedium16(b *testing.B) {\n-\tStringHelper(b, 16, mediumBase, mediumExponent)\n-}\n+func BenchmarkLeafSize0(b *testing.B)  { LeafSizeHelper(b, 10, 0) } // test without splitting\n+func BenchmarkLeafSize1(b *testing.B)  { LeafSizeHelper(b, 10, 1) }\n+func BenchmarkLeafSize2(b *testing.B)  { LeafSizeHelper(b, 10, 2) }\n+func BenchmarkLeafSize3(b *testing.B)  { LeafSizeHelper(b, 10, 3) }\n+func BenchmarkLeafSize4(b *testing.B)  { LeafSizeHelper(b, 10, 4) }\n+func BenchmarkLeafSize5(b *testing.B)  { LeafSizeHelper(b, 10, 5) }\n+func BenchmarkLeafSize6(b *testing.B)  { LeafSizeHelper(b, 10, 6) }\n+func BenchmarkLeafSize7(b *testing.B)  { LeafSizeHelper(b, 10, 7) }\n+func BenchmarkLeafSize8(b *testing.B)  { LeafSizeHelper(b, 10, 8) }\n+func BenchmarkLeafSize9(b *testing.B)  { LeafSizeHelper(b, 10, 9) }\n+func BenchmarkLeafSize10(b *testing.B) { LeafSizeHelper(b, 10, 10) }\n+func BenchmarkLeafSize11(b *testing.B) { LeafSizeHelper(b, 10, 11) }\n+func BenchmarkLeafSize12(b *testing.B) { LeafSizeHelper(b, 10, 12) }\n+func BenchmarkLeafSize13(b *testing.B) { LeafSizeHelper(b, 10, 13) }\n+func BenchmarkLeafSize14(b *testing.B) { LeafSizeHelper(b, 10, 14) }\n+func BenchmarkLeafSize15(b *testing.B) { LeafSizeHelper(b, 10, 15) }\n+func BenchmarkLeafSize16(b *testing.B) { LeafSizeHelper(b, 10, 16) }\n+func BenchmarkLeafSize32(b *testing.B) { LeafSizeHelper(b, 10, 32) } // try some large lengths \n+func BenchmarkLeafSize64(b *testing.B) { LeafSizeHelper(b, 10, 64) }\n+\n+func LeafSizeHelper(b *testing.B, base Word, size int) {\n+\tb.StopTimer()\n+\toriginalLeafSize := leafSize\n+\tresetTable(cacheBase10[:])\n+\tleafSize = size\n+\tb.StartTimer()\n \n-func BenchmarkStringLong2(b *testing.B) {\n-\tStringHelper(b, 2, longBase, longExponent)\n-}\n+\tfor d := 1; d <= 10000; d *= 10 {\n+\t\tb.StopTimer()\n+\t\tvar z nat\n+\t\tz = z.expWW(base, Word(d))            // build target number\n+\t\t_ = z.string(lowercaseDigits[0:base]) // warm divisor cache\n+\t\tb.StartTimer()\n \n-func BenchmarkStringLong8(b *testing.B) {\n-\tStringHelper(b, 8, longBase, longExponent)\n-}\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t_ = z.string(lowercaseDigits[0:base])\n+\t\t}\n+\t}\n \n-func BenchmarkStringLong10(b *testing.B) {\n-\tStringHelper(b, 10, longBase, longExponent)\n+\tb.StopTimer()\n+\tresetTable(cacheBase10[:])\n+\tleafSize = originalLeafSize\n+\tb.StartTimer()\n }\n \n-func BenchmarkStringLong16(b *testing.B) {\n-\tStringHelper(b, 16, longBase, longExponent)\n+func resetTable(table []divisor) {\n+\tif table != nil && table[0].bbb != nil {\n+\t\tfor i := 0; i < len(table); i++ {\n+\t\t\ttable[i].bbb = nil\n+\t\t\ttable[i].nbits = 0\n+\t\t\ttable[i].ndigits = 0\n+\t\t}\n+\t}\n }\n \n-func StringHelper(b *testing.B, base int, xv, yv Word) {\n-\tb.StopTimer()\n-\tvar x, y, z nat\n-\tx = x.setWord(xv)\n-\ty = y.setWord(yv)\n-\tz = z.expNN(x, y, nil)\n-\tb.StartTimer()\n-\n-\tfor i := 0; i < b.N; i++ {\n-\t\tz.string(lowercaseDigits[0:base])\n+func TestStringPowers(t *testing.T) {\n+\tvar b, p Word\n+\tfor b = 2; b <= 16; b++ {\n+\t\tfor p = 0; p <= 512; p++ {\n+\t\t\tx := nat(nil).expWW(b, p)\n+\t\t\txs := x.string(lowercaseDigits[0:b])\n+\t\t\txs2 := toString(x, lowercaseDigits[0:b])\n+\t\t\tif xs != xs2 {\n+\t\t\t\tt.Errorf(\"failed at %d ** %d in base %d: %s != %s\", b, p, b, xs, xs2)\n+\t\t\t}\n+\t\t}\n \t}\n }\n "}, {"sha": "09edc0eae881ab6f8c6b827898bb03ccde796c3a", "filename": "libgo/go/math/cbrt.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fcbrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fcbrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fcbrt.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -45,22 +45,21 @@ func Cbrt(x float64) float64 {\n \t\tx = -x\n \t\tsign = true\n \t}\n-\t// Reduce argument\n-\tf, e := Frexp(x)\n+\t// Reduce argument and estimate cube root\n+\tf, e := Frexp(x) // 0.5 <= f < 1.0\n \tm := e % 3\n \tif m > 0 {\n \t\tm -= 3\n \t\te -= m // e is multiple of 3\n \t}\n-\tf = Ldexp(f, m) // 0.125 <= f < 1.0\n-\n-\t// Estimate cube root\n \tswitch m {\n \tcase 0: // 0.5 <= f < 1.0\n \t\tf = A1*f + A2 - A3/(A4+f)\n-\tcase -1: // 0.25 <= f < 0.5\n+\tcase -1:\n+\t\tf *= 0.5 // 0.25 <= f < 0.5\n \t\tf = B1*f + B2 - B3/(B4+f)\n-\tdefault: // 0.125 <= f < 0.25\n+\tdefault: // m == -2\n+\t\tf *= 0.25 // 0.125 <= f < 0.25\n \t\tf = C1*f + C2 - C3/(C4+f)\n \t}\n \ty := Ldexp(f, e/3) // e/3 = exponent of cube root"}, {"sha": "8de4d7e2ce68cc1147ef0d088500f59c4f083dce", "filename": "libgo/go/math/floor.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Ffloor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Ffloor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ffloor.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,8 +7,7 @@ package math\n // Floor returns the greatest integer value less than or equal to x.\n //\n // Special cases are:\n-//\tFloor(+Inf) = +Inf\n-//\tFloor(-Inf) = -Inf\n+//\tFloor(\u00b1Inf) = \u00b1Inf\n //\tFloor(NaN) = NaN\n func Floor(x float64) float64 {\n \t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n@@ -30,16 +29,14 @@ func Floor(x float64) float64 {\n // Ceil returns the least integer value greater than or equal to x.\n //\n // Special cases are:\n-//\tCeil(+Inf) = +Inf\n-//\tCeil(-Inf) = -Inf\n+//\tCeil(\u00b1Inf) = \u00b1Inf\n //\tCeil(NaN) = NaN\n func Ceil(x float64) float64 { return -Floor(-x) }\n \n // Trunc returns the integer value of x.\n //\n // Special cases are:\n-//\tTrunc(+Inf) = +Inf\n-//\tTrunc(-Inf) = -Inf\n+//\tTrunc(\u00b1Inf) = \u00b1Inf\n //\tTrunc(NaN) = NaN\n func Trunc(x float64) float64 {\n \t// TODO(rsc): Remove manual inlining of IsNaN, IsInf"}, {"sha": "7365d8e77541b0446f209e56b13c96444e6697cb", "filename": "libgo/go/math/gamma.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fgamma.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -113,8 +113,7 @@ func stirling(x float64) float64 {\n // Gamma(x) returns the Gamma function of x.\n //\n // Special cases are:\n-//\tGamma(Inf) = Inf\n-//\tGamma(-Inf) = -Inf\n+//\tGamma(\u00b1Inf) = \u00b1Inf\n //\tGamma(NaN) = NaN\n // Large values overflow to +Inf.\n // Negative integer values equal \u00b1Inf."}, {"sha": "e8914a1d0533b79916ac95da8429e4ec4011c2bd", "filename": "libgo/go/math/log1p.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Flog1p.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Flog1p.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flog1p.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -44,7 +44,7 @@ package math\n //                      2      4      6      8      10      12      14\n //          R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s\n //      (the values of Lp1 to Lp7 are listed in the program)\n-//      a-0.2929nd\n+//      and\n //          |      2          14          |     -58.45\n //          | Lp1*s +...+Lp7*s    -  R(z) | <= 2\n //          |                             |\n@@ -88,6 +88,7 @@ package math\n //\n // Special cases are:\n //\tLog1p(+Inf) = +Inf\n+//\tLog1p(\u00b10) = \u00b10\n //\tLog1p(-1) = -Inf\n //\tLog1p(x < -1) = NaN\n //\tLog1p(NaN) = NaN"}, {"sha": "34889e0c0af8732d9f51c7c6636cc094e9ff135e", "filename": "libgo/go/math/modf.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fmodf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fmodf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fmodf.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,8 +8,7 @@ package math\n // that sum to f.  Both values have the same sign as f.\n //\n // Special cases are:\n-//\tModf(+Inf) = +Inf, NaN\n-//\tModf(-Inf) = -Inf, NaN\n+//\tModf(\u00b1Inf) = \u00b1Inf, NaN\n //\tModf(NaN) = NaN, NaN\n func Modf(f float64) (int float64, frac float64) {\n \tif f < 1 {"}, {"sha": "f5412fd726f62ad2d33544eebc898c7ef7bcb59c", "filename": "libgo/go/math/sincos.go", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fsincos.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fmath%2Fsincos.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsincos.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -4,10 +4,66 @@\n \n package math\n \n+// Coefficients _sin[] and _cos[] are found in pkg/math/sin.go.\n+\n // Sincos(x) returns Sin(x), Cos(x).\n //\n // Special conditions are:\n-//\tSincos(+Inf) = NaN, NaN\n-//\tSincos(-Inf) = NaN, NaN\n+//\tSincos(\u00b10) = \u00b10, 1\n+//\tSincos(\u00b1Inf) = NaN, NaN\n //\tSincos(NaN) = NaN, NaN\n-func Sincos(x float64) (sin, cos float64) { return Sin(x), Cos(x) }\n+func Sincos(x float64) (sin, cos float64) {\n+\tconst (\n+\t\tPI4A = 7.85398125648498535156E-1                             // 0x3fe921fb40000000, Pi/4 split into three parts\n+\t\tPI4B = 3.77489470793079817668E-8                             // 0x3e64442d00000000,\n+\t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n+\t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n+\t)\n+\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n+\t// when compiler does it for us\n+\t// special cases\n+\tswitch {\n+\tcase x == 0:\n+\t\treturn x, 1 // return \u00b10.0, 1.0\n+\tcase x != x || x < -MaxFloat64 || x > MaxFloat64: // IsNaN(x) || IsInf(x, 0):\n+\t\treturn NaN(), NaN()\n+\t}\n+\n+\t// make argument positive\n+\tsinSign, cosSign := false, false\n+\tif x < 0 {\n+\t\tx = -x\n+\t\tsinSign = true\n+\t}\n+\n+\tj := int64(x * M4PI) // integer part of x/(Pi/4), as integer for tests on the phase angle\n+\ty := float64(j)      // integer part of x/(Pi/4), as float\n+\n+\tif j&1 == 1 { // map zeros to origin\n+\t\tj += 1\n+\t\ty += 1\n+\t}\n+\tj &= 7     // octant modulo 2Pi radians (360 degrees)\n+\tif j > 3 { // reflect in x axis\n+\t\tj -= 4\n+\t\tsinSign, cosSign = !sinSign, !cosSign\n+\t}\n+\tif j > 1 {\n+\t\tcosSign = !cosSign\n+\t}\n+\n+\tz := ((x - y*PI4A) - y*PI4B) - y*PI4C // Extended precision modular arithmetic\n+\tzz := z * z\n+\tcos = 1.0 - 0.5*zz + zz*zz*((((((_cos[0]*zz)+_cos[1])*zz+_cos[2])*zz+_cos[3])*zz+_cos[4])*zz+_cos[5])\n+\tsin = z + z*zz*((((((_sin[0]*zz)+_sin[1])*zz+_sin[2])*zz+_sin[3])*zz+_sin[4])*zz+_sin[5])\n+\tif j == 1 || j == 2 {\n+\t\tsin, cos = cos, sin\n+\t}\n+\tif cosSign {\n+\t\tcos = -cos\n+\t}\n+\tif sinSign {\n+\t\tsin = -sin\n+\t}\n+\treturn\n+}"}, {"sha": "79a958e3cd0b9d0999d3053cb102530f86c9db95", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -29,7 +29,7 @@ func exchange(cfg *dnsConfig, c Conn, name string, qtype uint16) (*dnsMsg, error\n \t\treturn nil, &DNSError{Err: \"name too long\", Name: name}\n \t}\n \tout := new(dnsMsg)\n-\tout.id = uint16(rand.Int()) ^ uint16(time.Nanoseconds())\n+\tout.id = uint16(rand.Int()) ^ uint16(time.Now().UnixNano())\n \tout.question = []dnsQuestion{\n \t\t{name, qtype, dnsClassINET},\n \t}"}, {"sha": "5318c51c9a2d7142a8f96a4fa3aa76789a5000ad", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -171,7 +171,7 @@ func (s *pollServer) WakeFD(fd *netFD, mode int) {\n }\n \n func (s *pollServer) Now() int64 {\n-\treturn time.Nanoseconds()\n+\treturn time.Now().UnixNano()\n }\n \n func (s *pollServer) CheckDeadlines() {"}, {"sha": "264b918c57dc147a2ad4f2cdb493d068aa3ad2ec", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -172,11 +172,12 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n \t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, e}\n \t}\n \t// Wait for our request to complete.\n+\t// TODO(rsc): This should stop the timer.\n \tvar r ioResult\n \tif deadline_delta > 0 {\n \t\tselect {\n \t\tcase r = <-o.resultc:\n-\t\tcase <-time.After(deadline_delta):\n+\t\tcase <-time.After(time.Duration(deadline_delta) * time.Nanosecond):\n \t\t\ts.canchan <- oi\n \t\t\t<-o.errnoc\n \t\t\tr = <-o.resultc"}, {"sha": "e6674ba3415a8be028fa47d1d733eb65b6271ddc", "filename": "libgo/go/net/hosts.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhosts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhosts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"time\"\n )\n \n-const cacheMaxAge = int64(300) // 5 minutes.\n+const cacheMaxAge = 5 * time.Minute\n \n // hostsPath points to the file with static IP/address entries.\n var hostsPath = \"/etc/hosts\"\n@@ -21,14 +21,14 @@ var hosts struct {\n \tsync.Mutex\n \tbyName map[string][]string\n \tbyAddr map[string][]string\n-\ttime   int64\n+\texpire time.Time\n \tpath   string\n }\n \n func readHosts() {\n-\tnow := time.Seconds()\n+\tnow := time.Now()\n \thp := hostsPath\n-\tif len(hosts.byName) == 0 || hosts.time+cacheMaxAge <= now || hosts.path != hp {\n+\tif len(hosts.byName) == 0 || now.After(hosts.expire) || hosts.path != hp {\n \t\ths := make(map[string][]string)\n \t\tis := make(map[string][]string)\n \t\tvar file *file\n@@ -51,7 +51,7 @@ func readHosts() {\n \t\t\t}\n \t\t}\n \t\t// Update the data cache.\n-\t\thosts.time = time.Seconds()\n+\t\thosts.expire = time.Now().Add(cacheMaxAge)\n \t\thosts.path = hp\n \t\thosts.byName = hs\n \t\thosts.byAddr = is"}, {"sha": "849cb008b76663ce891d9847587a657660bc0f17", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -365,7 +365,7 @@ func TestCopyError(t *testing.T) {\n \n \ttries := 0\n \tfor tries < 15 && childRunning() {\n-\t\ttime.Sleep(50e6 * int64(tries))\n+\t\ttime.Sleep(50 * time.Millisecond * time.Duration(tries))\n \t\ttries++\n \t}\n \tif childRunning() {"}, {"sha": "cad852242e2e520d6db5defe39d5758f0cae6b0f", "filename": "libgo/go/net/http/cookie.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -115,7 +115,7 @@ func readSetCookies(h Header) []*Cookie {\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tc.Expires = *exptime\n+\t\t\t\tc.Expires = exptime.UTC()\n \t\t\t\tcontinue\n \t\t\tcase \"path\":\n \t\t\t\tc.Path = val\n@@ -146,8 +146,8 @@ func (c *Cookie) String() string {\n \tif len(c.Domain) > 0 {\n \t\tfmt.Fprintf(&b, \"; Domain=%s\", sanitizeValue(c.Domain))\n \t}\n-\tif len(c.Expires.Zone) > 0 {\n-\t\tfmt.Fprintf(&b, \"; Expires=%s\", c.Expires.Format(time.RFC1123))\n+\tif c.Expires.Unix() > 0 {\n+\t\tfmt.Fprintf(&b, \"; Expires=%s\", c.Expires.UTC().Format(time.RFC1123))\n \t}\n \tif c.MaxAge > 0 {\n \t\tfmt.Fprintf(&b, \"; Max-Age=%d\", c.MaxAge)"}, {"sha": "26bff93f6437cac5d5ab6a267bded419b6026041", "filename": "libgo/go/net/http/cookie_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -123,7 +123,7 @@ var readSetCookiesTests = []struct {\n \t\t\tPath:       \"/\",\n \t\t\tDomain:     \".google.ch\",\n \t\t\tHttpOnly:   true,\n-\t\t\tExpires:    time.Time{Year: 2011, Month: 11, Day: 23, Hour: 1, Minute: 5, Second: 3, ZoneOffset: 0, Zone: \"GMT\"},\n+\t\t\tExpires:    time.Date(2011, 11, 23, 1, 5, 3, 0, time.UTC),\n \t\t\tRawExpires: \"Wed, 23-Nov-2011 01:05:03 GMT\",\n \t\t\tRaw:        \"NID=99=YsDT5i3E-CXax-; expires=Wed, 23-Nov-2011 01:05:03 GMT; path=/; domain=.google.ch; HttpOnly\",\n \t\t}},"}, {"sha": "13640ca85ee260f22670ada0fc3645fbd85b97d5", "filename": "libgo/go/net/http/export_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,6 +7,8 @@\n \n package http\n \n+import \"time\"\n+\n func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n \tkeys = make([]string, 0)\n \tt.lk.Lock()\n@@ -33,8 +35,8 @@ func (t *Transport) IdleConnCountForTesting(cacheKey string) int {\n \treturn len(conns)\n }\n \n-func NewTestTimeoutHandler(handler Handler, ch <-chan int64) Handler {\n-\tf := func() <-chan int64 {\n+func NewTestTimeoutHandler(handler Handler, ch <-chan time.Time) Handler {\n+\tf := func() <-chan time.Time {\n \t\treturn ch\n \t}\n \treturn &timeoutHandler{handler, f, \"\"}"}, {"sha": "c94b9a7b24919dd372765584aa3082186bf89b55", "filename": "libgo/go/net/http/fcgi/child.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -103,7 +103,7 @@ func (r *response) WriteHeader(code int) {\n \t}\n \n \tif r.header.Get(\"Date\") == \"\" {\n-\t\tr.header.Set(\"Date\", time.UTC().Format(http.TimeFormat))\n+\t\tr.header.Set(\"Date\", time.Now().UTC().Format(http.TimeFormat))\n \t}\n \n \tfmt.Fprintf(r.w, \"Status: %d %s\\r\\n\", code, http.StatusText(code))"}, {"sha": "70e7849f16701bad9365ec9831a356f76292aa68", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -52,7 +52,7 @@ type FileSystem interface {\n // served by the FileServer implementation.\n type File interface {\n \tClose() error\n-\tStat() (*os.FileInfo, error)\n+\tStat() (os.FileInfo, error)\n \tReaddir(count int) ([]os.FileInfo, error)\n \tRead([]byte) (int, error)\n \tSeek(offset int64, whence int) (int64, error)\n@@ -93,8 +93,8 @@ func dirList(w ResponseWriter, f File) {\n \t\t\tbreak\n \t\t}\n \t\tfor _, d := range dirs {\n-\t\t\tname := d.Name\n-\t\t\tif d.IsDirectory() {\n+\t\t\tname := d.Name()\n+\t\t\tif d.IsDir() {\n \t\t\t\tname += \"/\"\n \t\t\t}\n \t\t\t// TODO htmlescape\n@@ -135,7 +135,7 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t// redirect to canonical path: / at end of directory url\n \t\t// r.URL.Path always begins with /\n \t\turl := r.URL.Path\n-\t\tif d.IsDirectory() {\n+\t\tif d.IsDir() {\n \t\t\tif url[len(url)-1] != '/' {\n \t\t\t\tlocalRedirect(w, r, path.Base(url)+\"/\")\n \t\t\t\treturn\n@@ -148,14 +148,14 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t}\n \t}\n \n-\tif t, _ := time.Parse(TimeFormat, r.Header.Get(\"If-Modified-Since\")); t != nil && d.Mtime_ns/1e9 <= t.Seconds() {\n+\tif t, err := time.Parse(TimeFormat, r.Header.Get(\"If-Modified-Since\")); err == nil && !d.ModTime().After(t) {\n \t\tw.WriteHeader(StatusNotModified)\n \t\treturn\n \t}\n-\tw.Header().Set(\"Last-Modified\", time.SecondsToUTC(d.Mtime_ns/1e9).Format(TimeFormat))\n+\tw.Header().Set(\"Last-Modified\", d.ModTime().UTC().Format(TimeFormat))\n \n \t// use contents of index.html for directory, if present\n-\tif d.IsDirectory() {\n+\tif d.IsDir() {\n \t\tindex := name + indexPage\n \t\tff, err := fs.Open(index)\n \t\tif err == nil {\n@@ -169,13 +169,13 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t}\n \t}\n \n-\tif d.IsDirectory() {\n+\tif d.IsDir() {\n \t\tdirList(w, f)\n \t\treturn\n \t}\n \n \t// serve file\n-\tsize := d.Size\n+\tsize := d.Size()\n \tcode := StatusOK\n \n \t// If Content-Type isn't set, use the file's extension to find it.\n@@ -215,7 +215,7 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t}\n \t\tsize = ra.length\n \t\tcode = StatusPartialContent\n-\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, d.Size))\n+\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, d.Size()))\n \t}\n \n \tw.Header().Set(\"Accept-Ranges\", \"bytes\")"}, {"sha": "976ee75c7dd0710a1b6a99afcc5ab1935d14df57", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -190,8 +190,8 @@ func TestDirJoin(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"stat of %s: %v\", name, err)\n \t\t}\n-\t\tif gfi.Ino != wfi.Ino {\n-\t\t\tt.Errorf(\"%s got different inode\", name)\n+\t\tif !gfi.(*os.FileStat).SameFile(wfi.(*os.FileStat)) {\n+\t\t\tt.Errorf(\"%s got different file\", name)\n \t\t}\n \t}\n \ttest(Dir(\"/etc/\"), \"/hosts\")"}, {"sha": "5b02e143d4a2b8f4294acc2022dbfae46ec30c91", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -7,14 +7,12 @@\n package httptest\n \n import (\n-\t\"crypto/rand\"\n \t\"crypto/tls\"\n \t\"flag\"\n \t\"fmt\"\n \t\"net\"\n \t\"net/http\"\n \t\"os\"\n-\t\"time\"\n )\n \n // A Server is an HTTP server listening on a system-chosen port on the\n@@ -113,8 +111,6 @@ func (s *Server) StartTLS() {\n \t}\n \n \ts.TLS = &tls.Config{\n-\t\tRand:         rand.Reader,\n-\t\tTime:         time.Seconds,\n \t\tNextProtos:   []string{\"http/1.1\"},\n \t\tCertificates: []tls.Certificate{cert},\n \t}"}, {"sha": "1dc83e7d032610ec2b9f160ccf64afa7ba53eff5", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -31,11 +31,11 @@ type ReverseProxy struct {\n \t// If nil, http.DefaultTransport is used.\n \tTransport http.RoundTripper\n \n-\t// FlushInterval specifies the flush interval, in\n-\t// nanoseconds, to flush to the client while\n-\t// coping the response body.\n+\t// FlushInterval specifies the flush interval\n+\t// to flush to the client while copying the\n+\t// response body.\n \t// If zero, no periodic flushing is done.\n-\tFlushInterval int64\n+\tFlushInterval time.Duration\n }\n \n func singleJoiningSlash(a, b string) string {\n@@ -135,7 +135,7 @@ type writeFlusher interface {\n \n type maxLatencyWriter struct {\n \tdst     writeFlusher\n-\tlatency int64 // nanos\n+\tlatency time.Duration\n \n \tlk   sync.Mutex // protects init of done, as well Write + Flush\n \tdone chan bool"}, {"sha": "2de147579d1fae1a537f72c67d42a41c85898afa", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -80,7 +80,7 @@ func Profile(w http.ResponseWriter, r *http.Request) {\n \t\tfmt.Fprintf(w, \"Could not enable CPU profiling: %s\\n\", err)\n \t\treturn\n \t}\n-\ttime.Sleep(sec * 1e9)\n+\ttime.Sleep(time.Duration(sec) * time.Second)\n \tpprof.StopCPUProfile()\n }\n "}, {"sha": "670b5418fcd36e376cde63d747f8055436704164", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -266,19 +266,19 @@ func TestServerTimeouts(t *testing.T) {\n \t}\n \n \t// Slow client that should timeout.\n-\tt1 := time.Nanoseconds()\n+\tt1 := time.Now()\n \tconn, err := net.Dial(\"tcp\", addr.String())\n \tif err != nil {\n \t\tt.Fatalf(\"Dial: %v\", err)\n \t}\n \tbuf := make([]byte, 1)\n \tn, err := conn.Read(buf)\n-\tlatency := time.Nanoseconds() - t1\n+\tlatency := time.Now().Sub(t1)\n \tif n != 0 || err != io.EOF {\n \t\tt.Errorf(\"Read = %v, %v, wanted %v, %v\", n, err, 0, io.EOF)\n \t}\n-\tif latency < second*0.20 /* fudge from 0.25 above */ {\n-\t\tt.Errorf(\"got EOF after %d ns, want >= %d\", latency, second*0.20)\n+\tif latency < 200*time.Millisecond /* fudge from 0.25 above */ {\n+\t\tt.Errorf(\"got EOF after %s, want >= %s\", latency, 200*time.Millisecond)\n \t}\n \n \t// Hit the HTTP server successfully again, verifying that the\n@@ -760,7 +760,7 @@ func TestTimeoutHandler(t *testing.T) {\n \t\t_, werr := w.Write([]byte(\"hi\"))\n \t\twriteErrors <- werr\n \t})\n-\ttimeout := make(chan int64, 1) // write to this to force timeouts\n+\ttimeout := make(chan time.Time, 1) // write to this to force timeouts\n \tts := httptest.NewServer(NewTestTimeoutHandler(sayHi, timeout))\n \tdefer ts.Close()\n \n@@ -782,7 +782,7 @@ func TestTimeoutHandler(t *testing.T) {\n \t}\n \n \t// Times out:\n-\ttimeout <- 1\n+\ttimeout <- time.Time{}\n \tres, err = Get(ts.URL)\n \tif err != nil {\n \t\tt.Error(err)"}, {"sha": "125f3f214bb270d61c834f0cbc409041c713821b", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -347,7 +347,7 @@ func (w *response) WriteHeader(code int) {\n \t}\n \n \tif _, ok := w.header[\"Date\"]; !ok {\n-\t\tw.Header().Set(\"Date\", time.UTC().Format(TimeFormat))\n+\t\tw.Header().Set(\"Date\", time.Now().UTC().Format(TimeFormat))\n \t}\n \n \tte := w.header.Get(\"Transfer-Encoding\")\n@@ -467,7 +467,7 @@ func (w *response) Write(data []byte) (n int, err error) {\n \t\t// determine the content type.  Accumulate the\n \t\t// initial writes in w.conn.body.\n \t\t// Cap m so that append won't allocate.\n-\t\tm := cap(w.conn.body) - len(w.conn.body)\n+\t\tm = cap(w.conn.body) - len(w.conn.body)\n \t\tif m > len(data) {\n \t\t\tm = len(data)\n \t\t}\n@@ -1013,8 +1013,8 @@ func (srv *Server) Serve(l net.Listener) error {\n //\tpackage main\n //\n //\timport (\n-//\t\t\"http\"\n //\t\t\"io\"\n+//\t\t\"net/http\"\n //\t\t\"log\"\n //\t)\n //\n@@ -1044,8 +1044,8 @@ func ListenAndServe(addr string, handler Handler) error {\n // A trivial example server is:\n //\n //\timport (\n-//\t\t\"http\"\n //\t\t\"log\"\n+//\t\t\"net/http\"\n //\t)\n //\n //\tfunc handler(w http.ResponseWriter, req *http.Request) {\n@@ -1084,7 +1084,6 @@ func (s *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \t}\n \tconfig := &tls.Config{\n \t\tRand:       rand.Reader,\n-\t\tTime:       time.Seconds,\n \t\tNextProtos: []string{\"http/1.1\"},\n \t}\n \n@@ -1112,9 +1111,9 @@ func (s *Server) ListenAndServeTLS(certFile, keyFile string) error {\n // (If msg is empty, a suitable default message will be sent.)\n // After such a timeout, writes by h to its ResponseWriter will return\n // ErrHandlerTimeout.\n-func TimeoutHandler(h Handler, ns int64, msg string) Handler {\n-\tf := func() <-chan int64 {\n-\t\treturn time.After(ns)\n+func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler {\n+\tf := func() <-chan time.Time {\n+\t\treturn time.After(dt)\n \t}\n \treturn &timeoutHandler{h, f, msg}\n }\n@@ -1125,7 +1124,7 @@ var ErrHandlerTimeout = errors.New(\"http: Handler timeout\")\n \n type timeoutHandler struct {\n \thandler Handler\n-\ttimeout func() <-chan int64 // returns channel producing a timeout\n+\ttimeout func() <-chan time.Time // returns channel producing a timeout\n \tbody    string\n }\n "}, {"sha": "c1c78e2417d3f0024c00df1b2e3d6691f1a94cc7", "filename": "libgo/go/net/http/sniff.go", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -48,23 +48,23 @@ type sniffSig interface {\n \n // Data matching the table in section 6.\n var sniffSignatures = []sniffSig{\n-\thtmlSig([]byte(\"<!DOCTYPE HTML\")),\n-\thtmlSig([]byte(\"<HTML\")),\n-\thtmlSig([]byte(\"<HEAD\")),\n-\thtmlSig([]byte(\"<SCRIPT\")),\n-\thtmlSig([]byte(\"<IFRAME\")),\n-\thtmlSig([]byte(\"<H1\")),\n-\thtmlSig([]byte(\"<DIV\")),\n-\thtmlSig([]byte(\"<FONT\")),\n-\thtmlSig([]byte(\"<TABLE\")),\n-\thtmlSig([]byte(\"<A\")),\n-\thtmlSig([]byte(\"<STYLE\")),\n-\thtmlSig([]byte(\"<TITLE\")),\n-\thtmlSig([]byte(\"<B\")),\n-\thtmlSig([]byte(\"<BODY\")),\n-\thtmlSig([]byte(\"<BR\")),\n-\thtmlSig([]byte(\"<P\")),\n-\thtmlSig([]byte(\"<!--\")),\n+\thtmlSig(\"<!DOCTYPE HTML\"),\n+\thtmlSig(\"<HTML\"),\n+\thtmlSig(\"<HEAD\"),\n+\thtmlSig(\"<SCRIPT\"),\n+\thtmlSig(\"<IFRAME\"),\n+\thtmlSig(\"<H1\"),\n+\thtmlSig(\"<DIV\"),\n+\thtmlSig(\"<FONT\"),\n+\thtmlSig(\"<TABLE\"),\n+\thtmlSig(\"<A\"),\n+\thtmlSig(\"<STYLE\"),\n+\thtmlSig(\"<TITLE\"),\n+\thtmlSig(\"<B\"),\n+\thtmlSig(\"<BODY\"),\n+\thtmlSig(\"<BR\"),\n+\thtmlSig(\"<P\"),\n+\thtmlSig(\"<!--\"),\n \n \t&maskedSig{mask: []byte(\"\\xFF\\xFF\\xFF\\xFF\\xFF\"), pat: []byte(\"<?xml\"), skipWS: true, ct: \"text/xml; charset=utf-8\"},\n "}, {"sha": "6efa8ce1ca228de6cd938eb76dafa44ed11a3472", "filename": "libgo/go/net/http/sniff_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,12 +6,14 @@ package http_test\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -112,3 +114,24 @@ func TestContentTypeWithCopy(t *testing.T) {\n \t}\n \tresp.Body.Close()\n }\n+\n+func TestSniffWriteSize(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tsize, _ := strconv.Atoi(r.FormValue(\"size\"))\n+\t\twritten, err := io.WriteString(w, strings.Repeat(\"a\", size))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"write of %d bytes: %v\", size, err)\n+\t\t\treturn\n+\t\t}\n+\t\tif written != size {\n+\t\t\tt.Errorf(\"write of %d bytes wrote %d bytes\", size, written)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\tfor _, size := range []int{0, 1, 200, 600, 999, 1000, 1023, 1024, 512 << 10, 1 << 20} {\n+\t\t_, err := Get(fmt.Sprintf(\"%s/?size=%d\", ts.URL, size))\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"size %d: %v\", size, err)\n+\t\t}\n+\t}\n+}"}, {"sha": "6f50f6f27677786157e282957b1a65f422764bbf", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -263,7 +263,7 @@ func TestTransportServerClosingUnexpectedly(t *testing.T) {\n \t\t\t\tt.Fatalf(format, arg...)\n \t\t\t}\n \t\t\tt.Logf(\"retrying shortly after expected error: \"+format, arg...)\n-\t\t\ttime.Sleep(1e9 / int64(retries))\n+\t\t\ttime.Sleep(time.Second / time.Duration(retries))\n \t\t}\n \t\tfor retries >= 0 {\n \t\t\tretries--"}, {"sha": "e1afa32062f99bb07d951cb3027b7f0eaa3ce0a4", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -89,14 +89,14 @@ func init() {\n \t}\n }\n \n-func parseDate(date string) (*time.Time, error) {\n+func parseDate(date string) (time.Time, error) {\n \tfor _, layout := range dateLayouts {\n \t\tt, err := time.Parse(layout, date)\n \t\tif err == nil {\n \t\t\treturn t, nil\n \t\t}\n \t}\n-\treturn nil, errors.New(\"mail: header could not be parsed\")\n+\treturn time.Time{}, errors.New(\"mail: header could not be parsed\")\n }\n \n // A Header represents the key-value pairs in a mail message header.\n@@ -111,10 +111,10 @@ func (h Header) Get(key string) string {\n var ErrHeaderNotPresent = errors.New(\"mail: header not in message\")\n \n // Date parses the Date header field.\n-func (h Header) Date() (*time.Time, error) {\n+func (h Header) Date() (time.Time, error) {\n \thdr := h.Get(\"Date\")\n \tif hdr == \"\" {\n-\t\treturn nil, ErrHeaderNotPresent\n+\t\treturn time.Time{}, ErrHeaderNotPresent\n \t}\n \treturn parseDate(hdr)\n }\n@@ -185,7 +185,7 @@ func (a *Address) String() string {\n type addrParser []byte\n \n func newAddrParser(s string) *addrParser {\n-\tp := addrParser([]byte(s))\n+\tp := addrParser(s)\n \treturn &p\n }\n "}, {"sha": "1f71cc480aff8b78eda742241b825d7b042140d5", "filename": "libgo/go/net/mail/message_test.go", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -82,34 +82,18 @@ func headerEq(a, b Header) bool {\n func TestDateParsing(t *testing.T) {\n \ttests := []struct {\n \t\tdateStr string\n-\t\texp     *time.Time\n+\t\texp     time.Time\n \t}{\n \t\t// RFC 5322, Appendix A.1.1\n \t\t{\n \t\t\t\"Fri, 21 Nov 1997 09:55:06 -0600\",\n-\t\t\t&time.Time{\n-\t\t\t\tYear:       1997,\n-\t\t\t\tMonth:      11,\n-\t\t\t\tDay:        21,\n-\t\t\t\tHour:       9,\n-\t\t\t\tMinute:     55,\n-\t\t\t\tSecond:     6,\n-\t\t\t\tZoneOffset: -6 * 60 * 60,\n-\t\t\t},\n+\t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.FixedZone(\"\", -6*60*60)),\n \t\t},\n \t\t// RFC5322, Appendix A.6.2\n \t\t// Obsolete date.\n \t\t{\n \t\t\t\"21 Nov 97 09:55:06 GMT\",\n-\t\t\t&time.Time{\n-\t\t\t\tYear:   1997,\n-\t\t\t\tMonth:  11,\n-\t\t\t\tDay:    21,\n-\t\t\t\tHour:   9,\n-\t\t\t\tMinute: 55,\n-\t\t\t\tSecond: 6,\n-\t\t\t\tZone:   \"GMT\",\n-\t\t\t},\n+\t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.FixedZone(\"GMT\", 0)),\n \t\t},\n \t}\n \tfor _, test := range tests {"}, {"sha": "f6e5238c1b1d481873be8886fb258f58f491ca27", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -17,7 +17,7 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \t\treturn\n \t}\n \tdefer fd.Close()\n-\tt0 := time.Nanoseconds()\n+\tt0 := time.Now()\n \tfd.SetReadTimeout(1e8) // 100ms\n \tvar b [100]byte\n \tvar n int\n@@ -27,16 +27,16 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \t} else {\n \t\tn, err1 = fd.Read(b[0:])\n \t}\n-\tt1 := time.Nanoseconds()\n+\tt1 := time.Now()\n \twhat := \"Read\"\n \tif readFrom {\n \t\twhat = \"ReadFrom\"\n \t}\n \tif n != 0 || err1 == nil || !err1.(Error).Timeout() {\n \t\tt.Errorf(\"fd.%s on %s %s did not return 0, timeout: %v, %v\", what, network, addr, n, err1)\n \t}\n-\tif t1-t0 < 0.5e8 || t1-t0 > 1.5e8 {\n-\t\tt.Errorf(\"fd.%s on %s %s took %f seconds, expected 0.1\", what, network, addr, float64(t1-t0)/1e9)\n+\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || dt > 150*time.Millisecond {\n+\t\tt.Errorf(\"fd.%s on %s %s took %s, expected 0.1s\", what, network, addr, dt)\n \t}\n }\n "}, {"sha": "03fa8ff6c4128661b1dbdb93e007e5ffbdef8f83", "filename": "libgo/go/old/netchan/common.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fcommon.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -129,8 +129,8 @@ func (ed *encDec) encode(hdr *header, payloadType int, payload interface{}) erro\n }\n \n // See the comment for Exporter.Drain.\n-func (cs *clientSet) drain(timeout int64) error {\n-\tstartTime := time.Nanoseconds()\n+func (cs *clientSet) drain(timeout time.Duration) error {\n+\tdeadline := time.Now().Add(timeout)\n \tfor {\n \t\tpending := false\n \t\tcs.mu.Lock()\n@@ -152,7 +152,7 @@ func (cs *clientSet) drain(timeout int64) error {\n \t\tif !pending {\n \t\t\tbreak\n \t\t}\n-\t\tif timeout > 0 && time.Nanoseconds()-startTime >= timeout {\n+\t\tif timeout > 0 && time.Now().After(deadline) {\n \t\t\treturn errors.New(\"timeout\")\n \t\t}\n \t\ttime.Sleep(100 * 1e6) // 100 milliseconds\n@@ -161,8 +161,8 @@ func (cs *clientSet) drain(timeout int64) error {\n }\n \n // See the comment for Exporter.Sync.\n-func (cs *clientSet) sync(timeout int64) error {\n-\tstartTime := time.Nanoseconds()\n+func (cs *clientSet) sync(timeout time.Duration) error {\n+\tdeadline := time.Now().Add(timeout)\n \t// seq remembers the clients and their seqNum at point of entry.\n \tseq := make(map[unackedCounter]int64)\n \tfor client := range cs.clients {\n@@ -185,7 +185,7 @@ func (cs *clientSet) sync(timeout int64) error {\n \t\tif !pending {\n \t\t\tbreak\n \t\t}\n-\t\tif timeout > 0 && time.Nanoseconds()-startTime >= timeout {\n+\t\tif timeout > 0 && time.Now().After(deadline) {\n \t\t\treturn errors.New(\"timeout\")\n \t\t}\n \t\ttime.Sleep(100 * 1e6) // 100 milliseconds"}, {"sha": "d94c4b16b21e3c80555f0763b3eb02a9dc25c378", "filename": "libgo/go/old/netchan/export.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fexport.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -29,6 +29,7 @@ import (\n \t\"reflect\"\n \t\"strconv\"\n \t\"sync\"\n+\t\"time\"\n )\n \n // Export\n@@ -322,20 +323,19 @@ func (exp *Exporter) delClient(client *expClient) {\n // those not yet sent to any client and possibly including those sent while\n // Drain was executing, have been received by the importer.  In short, it\n // waits until all the exporter's messages have been received by a client.\n-// If the timeout (measured in nanoseconds) is positive and Drain takes\n-// longer than that to complete, an error is returned.\n-func (exp *Exporter) Drain(timeout int64) error {\n+// If the timeout is positive and Drain takes longer than that to complete,\n+// an error is returned.\n+func (exp *Exporter) Drain(timeout time.Duration) error {\n \t// This wrapper function is here so the method's comment will appear in godoc.\n \treturn exp.clientSet.drain(timeout)\n }\n \n // Sync waits until all clients of the exporter have received the messages\n // that were sent at the time Sync was invoked.  Unlike Drain, it does not\n // wait for messages sent while it is running or messages that have not been\n-// dispatched to any client.  If the timeout (measured in nanoseconds) is\n-// positive and Sync takes longer than that to complete, an error is\n-// returned.\n-func (exp *Exporter) Sync(timeout int64) error {\n+// dispatched to any client.  If the timeout is positive and Sync takes longer\n+// than that to complete, an error is returned.\n+func (exp *Exporter) Sync(timeout time.Duration) error {\n \t// This wrapper function is here so the method's comment will appear in godoc.\n \treturn exp.clientSet.sync(timeout)\n }"}, {"sha": "a6da8210b99ccce86804274b5438eec43d582f47", "filename": "libgo/go/old/netchan/import.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fold%2Fnetchan%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fnetchan%2Fimport.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -276,9 +276,9 @@ func (imp *Importer) unackedCount() int64 {\n // If the timeout (measured in nanoseconds) is positive and Drain takes\n // longer than that to complete, an error is returned.\n func (imp *Importer) Drain(timeout int64) error {\n-\tstartTime := time.Nanoseconds()\n+\tdeadline := time.Now().Add(time.Duration(timeout))\n \tfor imp.unackedCount() > 0 {\n-\t\tif timeout > 0 && time.Nanoseconds()-startTime >= timeout {\n+\t\tif timeout > 0 && time.Now().After(deadline) {\n \t\t\treturn errors.New(\"timeout\")\n \t\t}\n \t\ttime.Sleep(100 * 1e6)"}, {"sha": "9665ea8f4138a516a01200cf130b1e5537f57246", "filename": "libgo/go/os/exec/lp_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -20,7 +20,7 @@ func findExecutable(file string) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif d.IsRegular() && d.Permission()&0111 != 0 {\n+\tif m := d.Mode(); !m.IsDir() && m&0111 != 0 {\n \t\treturn nil\n \t}\n \treturn os.EPERM"}, {"sha": "ef5bd921668f7e613242a0f2c5a4082099b6d3ad", "filename": "libgo/go/os/exec/lp_windows.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Flp_windows.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -18,10 +18,10 @@ func chkStat(file string) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif d.IsRegular() {\n-\t\treturn nil\n+\tif d.IsDir() {\n+\t\treturn os.EPERM\n \t}\n-\treturn os.EPERM\n+\treturn nil\n }\n \n func findExecutable(file string, exts []string) (string, error) {"}, {"sha": "9c6ef429744daf31b7b7ee6389b70f7715fc5f2c", "filename": "libgo/go/os/export_test.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexport_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+// Export for testing.\n+\n+var Atime = atime"}, {"sha": "71845d3c9c93d833d25be13136acae0acf90e7cb", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -14,7 +14,7 @@ import (\n )\n \n // Name returns the name of the file as presented to Open.\n-func (file *File) Name() string { return file.name }\n+func (f *File) Name() string { return f.name }\n \n // Stdin, Stdout, and Stderr are open Files pointing to the standard input,\n // standard output, and standard error file descriptors.\n@@ -51,38 +51,38 @@ const (\n // Read reads up to len(b) bytes from the File.\n // It returns the number of bytes read and an error, if any.\n // EOF is signaled by a zero count with err set to io.EOF.\n-func (file *File) Read(b []byte) (n int, err error) {\n-\tif file == nil {\n+func (f *File) Read(b []byte) (n int, err error) {\n+\tif f == nil {\n \t\treturn 0, EINVAL\n \t}\n-\tn, e := file.read(b)\n+\tn, e := f.read(b)\n \tif n < 0 {\n \t\tn = 0\n \t}\n \tif n == 0 && len(b) > 0 && e == nil {\n \t\treturn 0, io.EOF\n \t}\n \tif e != nil {\n-\t\terr = &PathError{\"read\", file.name, e}\n+\t\terr = &PathError{\"read\", f.name, e}\n \t}\n \treturn n, err\n }\n \n // ReadAt reads len(b) bytes from the File starting at byte offset off.\n // It returns the number of bytes read and the error, if any.\n-// EOF is signaled by a zero count with err set to io.EOF.\n-// ReadAt always returns a non-nil error when n != len(b).\n-func (file *File) ReadAt(b []byte, off int64) (n int, err error) {\n-\tif file == nil {\n+// ReadAt always returns a non-nil error when n < len(b).\n+// At end of file, that error is io.EOF.\n+func (f *File) ReadAt(b []byte, off int64) (n int, err error) {\n+\tif f == nil {\n \t\treturn 0, EINVAL\n \t}\n \tfor len(b) > 0 {\n-\t\tm, e := file.pread(b, off)\n+\t\tm, e := f.pread(b, off)\n \t\tif m == 0 && e == nil {\n \t\t\treturn n, io.EOF\n \t\t}\n \t\tif e != nil {\n-\t\t\terr = &PathError{\"read\", file.name, e}\n+\t\t\terr = &PathError{\"read\", f.name, e}\n \t\t\tbreak\n \t\t}\n \t\tn += m\n@@ -95,34 +95,34 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err error) {\n // Write writes len(b) bytes to the File.\n // It returns the number of bytes written and an error, if any.\n // Write returns a non-nil error when n != len(b).\n-func (file *File) Write(b []byte) (n int, err error) {\n-\tif file == nil {\n+func (f *File) Write(b []byte) (n int, err error) {\n+\tif f == nil {\n \t\treturn 0, EINVAL\n \t}\n-\tn, e := file.write(b)\n+\tn, e := f.write(b)\n \tif n < 0 {\n \t\tn = 0\n \t}\n \n-\tepipecheck(file, e)\n+\tepipecheck(f, e)\n \n \tif e != nil {\n-\t\terr = &PathError{\"write\", file.name, e}\n+\t\terr = &PathError{\"write\", f.name, e}\n \t}\n \treturn n, err\n }\n \n // WriteAt writes len(b) bytes to the File starting at byte offset off.\n // It returns the number of bytes written and an error, if any.\n // WriteAt returns a non-nil error when n != len(b).\n-func (file *File) WriteAt(b []byte, off int64) (n int, err error) {\n-\tif file == nil {\n+func (f *File) WriteAt(b []byte, off int64) (n int, err error) {\n+\tif f == nil {\n \t\treturn 0, EINVAL\n \t}\n \tfor len(b) > 0 {\n-\t\tm, e := file.pwrite(b, off)\n+\t\tm, e := f.pwrite(b, off)\n \t\tif e != nil {\n-\t\t\terr = &PathError{\"write\", file.name, e}\n+\t\t\terr = &PathError{\"write\", f.name, e}\n \t\t\tbreak\n \t\t}\n \t\tn += m\n@@ -136,24 +136,24 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err error) {\n // according to whence: 0 means relative to the origin of the file, 1 means\n // relative to the current offset, and 2 means relative to the end.\n // It returns the new offset and an error, if any.\n-func (file *File) Seek(offset int64, whence int) (ret int64, err error) {\n-\tr, e := file.seek(offset, whence)\n-\tif e == nil && file.dirinfo != nil && r != 0 {\n+func (f *File) Seek(offset int64, whence int) (ret int64, err error) {\n+\tr, e := f.seek(offset, whence)\n+\tif e == nil && f.dirinfo != nil && r != 0 {\n \t\te = syscall.EISDIR\n \t}\n \tif e != nil {\n-\t\treturn 0, &PathError{\"seek\", file.name, e}\n+\t\treturn 0, &PathError{\"seek\", f.name, e}\n \t}\n \treturn r, nil\n }\n \n // WriteString is like Write, but writes the contents of string s rather than\n // an array of bytes.\n-func (file *File) WriteString(s string) (ret int, err error) {\n-\tif file == nil {\n+func (f *File) WriteString(s string) (ret int, err error) {\n+\tif f == nil {\n \t\treturn 0, EINVAL\n \t}\n-\treturn file.Write([]byte(s))\n+\treturn f.Write([]byte(s))\n }\n \n // Mkdir creates a new directory with the specified name and permission bits."}, {"sha": "a4ab5d6ae25d36b4d6572d20193ee991234b1854", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -8,6 +8,7 @@ package os\n \n import (\n \t\"syscall\"\n+\t\"time\"\n )\n \n func sigpipe() // implemented in package runtime\n@@ -168,11 +169,11 @@ func (f *File) Truncate(size int64) error {\n // Sync commits the current contents of the file to stable storage.\n // Typically, this means flushing the file system's in-memory copy\n // of recently written data to disk.\n-func (file *File) Sync() (err error) {\n-\tif file == nil {\n+func (f *File) Sync() (err error) {\n+\tif f == nil {\n \t\treturn EINVAL\n \t}\n-\tif e := syscall.Fsync(file.fd); e != nil {\n+\tif e := syscall.Fsync(f.fd); e != nil {\n \t\treturn NewSyscallError(\"fsync\", e)\n \t}\n \treturn nil\n@@ -181,11 +182,12 @@ func (file *File) Sync() (err error) {\n // Chtimes changes the access and modification times of the named\n // file, similar to the Unix utime() or utimes() functions.\n //\n-// The argument times are in nanoseconds, although the underlying\n-// filesystem may truncate or round the values to a more\n-// coarse time unit.\n-func Chtimes(name string, atime_ns int64, mtime_ns int64) error {\n+// The underlying filesystem may truncate or round the values to a\n+// less precise time unit.\n+func Chtimes(name string, atime time.Time, mtime time.Time) error {\n \tvar utimes [2]syscall.Timeval\n+\tatime_ns := atime.Unix()*1e9 + int64(atime.Nanosecond())\n+\tmtime_ns := mtime.Unix()*1e9 + int64(mtime.Nanosecond())\n \tutimes[0] = syscall.NsecToTimeval(atime_ns)\n \tutimes[1] = syscall.NsecToTimeval(mtime_ns)\n \tif e := syscall.Utimes(name, utimes[0:]); e != nil {"}, {"sha": "671d1a4cb62e73772180f5780af36fc40c63129f", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -28,11 +28,11 @@ type file struct {\n }\n \n // Fd returns the integer Unix file descriptor referencing the open file.\n-func (file *File) Fd() int {\n-\tif file == nil {\n+func (f *File) Fd() int {\n+\tif f == nil {\n \t\treturn -1\n \t}\n-\treturn file.fd\n+\treturn f.fd\n }\n \n // NewFile returns a new File with the given file descriptor and name.\n@@ -77,8 +77,8 @@ func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n \n // Close closes the File, rendering it unusable for I/O.\n // It returns an error, if any.\n-func (file *File) Close() error {\n-\treturn file.file.close()\n+func (f *File) Close() error {\n+\treturn f.file.close()\n }\n \n func (file *file) close() error {\n@@ -105,50 +105,43 @@ func (file *file) close() error {\n \n // Stat returns the FileInfo structure describing file.\n // It returns the FileInfo and an error, if any.\n-func (file *File) Stat() (fi *FileInfo, err error) {\n+func (f *File) Stat() (fi FileInfo, err error) {\n \tvar stat syscall.Stat_t\n-\te := syscall.Fstat(file.fd, &stat)\n-\tif e != nil {\n-\t\treturn nil, &PathError{\"stat\", file.name, e}\n+\terr = syscall.Fstat(f.fd, &stat)\n+\tif err != nil {\n+\t\treturn nil, &PathError{\"stat\", f.name, err}\n \t}\n-\treturn fileInfoFromStat(file.name, new(FileInfo), &stat, &stat), nil\n+\treturn fileInfoFromStat(&stat, f.name), nil\n }\n \n-// Stat returns a FileInfo structure describing the named file and an error, if any.\n+// Stat returns a FileInfo describing the named file and an error, if any.\n // If name names a valid symbolic link, the returned FileInfo describes\n // the file pointed at by the link and has fi.FollowedSymlink set to true.\n // If name names an invalid symbolic link, the returned FileInfo describes\n // the link itself and has fi.FollowedSymlink set to false.\n-func Stat(name string) (fi *FileInfo, err error) {\n-\tvar lstat, stat syscall.Stat_t\n-\te := syscall.Lstat(name, &lstat)\n-\tif e != nil {\n-\t\treturn nil, &PathError{\"stat\", name, e}\n-\t}\n-\tstatp := &lstat\n-\tif lstat.Mode&syscall.S_IFMT == syscall.S_IFLNK {\n-\t\te := syscall.Stat(name, &stat)\n-\t\tif e == nil {\n-\t\t\tstatp = &stat\n-\t\t}\n+func Stat(name string) (fi FileInfo, err error) {\n+\tvar stat syscall.Stat_t\n+\terr = syscall.Stat(name, &stat)\n+\tif err != nil {\n+\t\treturn nil, &PathError{\"stat\", name, err}\n \t}\n-\treturn fileInfoFromStat(name, new(FileInfo), &lstat, statp), nil\n+\treturn fileInfoFromStat(&stat, name), nil\n }\n \n-// Lstat returns the FileInfo structure describing the named file and an\n+// Lstat returns a FileInfo describing the named file and an\n // error, if any.  If the file is a symbolic link, the returned FileInfo\n // describes the symbolic link.  Lstat makes no attempt to follow the link.\n-func Lstat(name string) (fi *FileInfo, err error) {\n+func Lstat(name string) (fi FileInfo, err error) {\n \tvar stat syscall.Stat_t\n-\te := syscall.Lstat(name, &stat)\n-\tif e != nil {\n-\t\treturn nil, &PathError{\"lstat\", name, e}\n+\terr = syscall.Lstat(name, &stat)\n+\tif err != nil {\n+\t\treturn nil, &PathError{\"lstat\", name, err}\n \t}\n-\treturn fileInfoFromStat(name, new(FileInfo), &stat, &stat), nil\n+\treturn fileInfoFromStat(&stat, name), nil\n }\n \n // Readdir reads the contents of the directory associated with file and\n-// returns an array of up to n FileInfo structures, as would be returned\n+// returns an array of up to n FileInfo values, as would be returned\n // by Lstat, in directory order. Subsequent calls on the same file will yield\n // further FileInfos.\n //\n@@ -162,23 +155,23 @@ func Lstat(name string) (fi *FileInfo, err error) {\n // nil error. If it encounters an error before the end of the\n // directory, Readdir returns the FileInfo read until that point\n // and a non-nil error.\n-func (file *File) Readdir(n int) (fi []FileInfo, err error) {\n-\tdirname := file.name\n+func (f *File) Readdir(n int) (fi []FileInfo, err error) {\n+\tdirname := f.name\n \tif dirname == \"\" {\n \t\tdirname = \".\"\n \t}\n \tdirname += \"/\"\n-\tnames, err := file.Readdirnames(n)\n+\tnames, err := f.Readdirnames(n)\n \tfi = make([]FileInfo, len(names))\n \tfor i, filename := range names {\n \t\tfip, err := Lstat(dirname + filename)\n-\t\tif fip == nil || err != nil {\n-\t\t\tfi[i].Name = filename // rest is already zeroed out\n+\t\tif err == nil {\n+\t\t\tfi[i] = fip\n \t\t} else {\n-\t\t\tfi[i] = *fip\n+\t\t\tfi[i] = &FileStat{name: filename}\n \t\t}\n \t}\n-\treturn\n+\treturn fi, err\n }\n \n // read reads up to len(b) bytes from the File."}, {"sha": "a0d3c99a503eeaab5d1f11ab5fcf57fc4ffd775b", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -12,7 +12,7 @@ import (\n // current directory.  If the current directory can be\n // reached via multiple paths (due to symbolic links),\n // Getwd may return any one of them.\n-func Getwd() (string, error) {\n+func Getwd() (pwd string, err error) {\n \t// If the operating system provides a Getwd call, use it.\n \tif syscall.ImplementsGetwd {\n \t\ts, e := syscall.Getwd()\n@@ -27,10 +27,10 @@ func Getwd() (string, error) {\n \n \t// Clumsy but widespread kludge:\n \t// if $PWD is set and matches \".\", use it.\n-\tpwd := Getenv(\"PWD\")\n+\tpwd = Getenv(\"PWD\")\n \tif len(pwd) > 0 && pwd[0] == '/' {\n \t\td, err := Stat(pwd)\n-\t\tif err == nil && d.Dev == dot.Dev && d.Ino == dot.Ino {\n+\t\tif err == nil && dot.(*FileStat).SameFile(d.(*FileStat)) {\n \t\t\treturn pwd, nil\n \t\t}\n \t}\n@@ -42,7 +42,7 @@ func Getwd() (string, error) {\n \t\t// Can't stat root - no hope.\n \t\treturn \"\", err\n \t}\n-\tif root.Dev == dot.Dev && root.Ino == dot.Ino {\n+\tif root.(*FileStat).SameFile(dot.(*FileStat)) {\n \t\treturn \"/\", nil\n \t}\n \n@@ -67,7 +67,7 @@ func Getwd() (string, error) {\n \t\t\t}\n \t\t\tfor _, name := range names {\n \t\t\t\td, _ := Lstat(parent + \"/\" + name)\n-\t\t\t\tif d.Dev == dot.Dev && d.Ino == dot.Ino {\n+\t\t\t\tif d.(*FileStat).SameFile(dot.(*FileStat)) {\n \t\t\t\t\tpwd = \"/\" + name + pwd\n \t\t\t\t\tgoto Found\n \t\t\t\t}\n@@ -82,7 +82,7 @@ func Getwd() (string, error) {\n \t\t\treturn \"\", err\n \t\t}\n \t\tfd.Close()\n-\t\tif pd.Dev == root.Dev && pd.Ino == root.Ino {\n+\t\tif pd.(*FileStat).SameFile(root.(*FileStat)) {\n \t\t\tbreak\n \t\t}\n \t\t// Set up for next round."}, {"sha": "299d2e86155bcd8010a03333ceaab6ea4de73453", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 48, "deletions": 98, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"strings\"\n \t\"syscall\"\n \t\"testing\"\n+\t\"time\"\n )\n \n var dot = []string{\n@@ -119,12 +120,12 @@ func TestStat(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"stat failed:\", err)\n \t}\n-\tif !equal(sfname, dir.Name) {\n-\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name)\n+\tif !equal(sfname, dir.Name()) {\n+\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name())\n \t}\n \tfilesize := size(path, t)\n-\tif dir.Size != filesize {\n-\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size)\n+\tif dir.Size() != filesize {\n+\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size())\n \t}\n }\n \n@@ -139,12 +140,12 @@ func TestFstat(t *testing.T) {\n \tif err2 != nil {\n \t\tt.Fatal(\"fstat failed:\", err2)\n \t}\n-\tif !equal(sfname, dir.Name) {\n-\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name)\n+\tif !equal(sfname, dir.Name()) {\n+\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name())\n \t}\n \tfilesize := size(path, t)\n-\tif dir.Size != filesize {\n-\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size)\n+\tif dir.Size() != filesize {\n+\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size())\n \t}\n }\n \n@@ -154,12 +155,12 @@ func TestLstat(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"lstat failed:\", err)\n \t}\n-\tif !equal(sfname, dir.Name) {\n-\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name)\n+\tif !equal(sfname, dir.Name()) {\n+\t\tt.Error(\"name should be \", sfname, \"; is\", dir.Name())\n \t}\n \tfilesize := size(path, t)\n-\tif dir.Size != filesize {\n-\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size)\n+\tif dir.Size() != filesize {\n+\t\tt.Error(\"size should be\", filesize, \"; is\", dir.Size())\n \t}\n }\n \n@@ -226,7 +227,7 @@ func testReaddir(dir string, contents []string, t *testing.T) {\n \tfor _, m := range contents {\n \t\tfound := false\n \t\tfor _, n := range s {\n-\t\t\tif equal(m, n.Name) {\n+\t\t\tif equal(m, n.Name()) {\n \t\t\t\tif found {\n \t\t\t\t\tt.Error(\"present twice:\", m)\n \t\t\t\t}\n@@ -405,7 +406,7 @@ func TestHardLink(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", from, err)\n \t}\n-\tif tostat.Dev != fromstat.Dev || tostat.Ino != fromstat.Ino {\n+\tif !tostat.(*FileStat).SameFile(fromstat.(*FileStat)) {\n \t\tt.Errorf(\"link %q, %q did not create hard link\", to, from)\n \t}\n }\n@@ -430,32 +431,32 @@ func TestSymLink(t *testing.T) {\n \t\tt.Fatalf(\"symlink %q, %q failed: %v\", to, from, err)\n \t}\n \tdefer Remove(from)\n-\ttostat, err := Stat(to)\n+\ttostat, err := Lstat(to)\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", to, err)\n \t}\n-\tif tostat.FollowedSymlink {\n-\t\tt.Fatalf(\"stat %q claims to have followed a symlink\", to)\n+\tif tostat.Mode()&ModeSymlink != 0 {\n+\t\tt.Fatalf(\"stat %q claims to have found a symlink\", to)\n \t}\n \tfromstat, err := Stat(from)\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", from, err)\n \t}\n-\tif tostat.Dev != fromstat.Dev || tostat.Ino != fromstat.Ino {\n+\tif !tostat.(*FileStat).SameFile(fromstat.(*FileStat)) {\n \t\tt.Errorf(\"symlink %q, %q did not create symlink\", to, from)\n \t}\n \tfromstat, err = Lstat(from)\n \tif err != nil {\n \t\tt.Fatalf(\"lstat %q failed: %v\", from, err)\n \t}\n-\tif !fromstat.IsSymlink() {\n+\tif fromstat.Mode()&ModeSymlink == 0 {\n \t\tt.Fatalf(\"symlink %q, %q did not create symlink\", to, from)\n \t}\n \tfromstat, err = Stat(from)\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", from, err)\n \t}\n-\tif !fromstat.FollowedSymlink {\n+\tif fromstat.Mode()&ModeSymlink != 0 {\n \t\tt.Fatalf(\"stat %q did not follow symlink\", from)\n \t}\n \ts, err := Readlink(from)\n@@ -563,13 +564,13 @@ func TestStartProcess(t *testing.T) {\n \texec(t, cmddir, cmdbase, args, filepath.Clean(cmddir)+le)\n }\n \n-func checkMode(t *testing.T, path string, mode uint32) {\n+func checkMode(t *testing.T, path string, mode FileMode) {\n \tdir, err := Stat(path)\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %q (looking for mode %#o): %s\", path, mode, err)\n \t}\n-\tif dir.Mode&0777 != mode {\n-\t\tt.Errorf(\"Stat %q: mode %#o want %#o\", path, dir.Mode, mode)\n+\tif dir.Mode()&0777 != mode {\n+\t\tt.Errorf(\"Stat %q: mode %#o want %#o\", path, dir.Mode(), mode)\n \t}\n }\n \n@@ -593,73 +594,13 @@ func TestChmod(t *testing.T) {\n \tcheckMode(t, f.Name(), 0123)\n }\n \n-func checkUidGid(t *testing.T, path string, uid, gid int) {\n-\tdir, err := Stat(path)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Stat %q (looking for uid/gid %d/%d): %s\", path, uid, gid, err)\n-\t}\n-\tif dir.Uid != uid {\n-\t\tt.Errorf(\"Stat %q: uid %d want %d\", path, dir.Uid, uid)\n-\t}\n-\tif dir.Gid != gid {\n-\t\tt.Errorf(\"Stat %q: gid %d want %d\", path, dir.Gid, gid)\n-\t}\n-}\n-\n-func TestChown(t *testing.T) {\n-\t// Chown is not supported under windows or Plan 9.\n-\t// Plan9 provides a native ChownPlan9 version instead.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n-\t\treturn\n-\t}\n-\t// Use TempDir() to make sure we're on a local file system,\n-\t// so that the group ids returned by Getgroups will be allowed\n-\t// on the file.  On NFS, the Getgroups groups are\n-\t// basically useless.\n-\tf := newFile(\"TestChown\", t)\n-\tdefer Remove(f.Name())\n-\tdefer f.Close()\n-\tdir, err := f.Stat()\n-\tif err != nil {\n-\t\tt.Fatalf(\"stat %s: %s\", f.Name(), err)\n-\t}\n-\n-\t// Can't change uid unless root, but can try\n-\t// changing the group id.  First try our current group.\n-\tgid := Getgid()\n-\tt.Log(\"gid:\", gid)\n-\tif err = Chown(f.Name(), -1, gid); err != nil {\n-\t\tt.Fatalf(\"chown %s -1 %d: %s\", f.Name(), gid, err)\n-\t}\n-\tcheckUidGid(t, f.Name(), dir.Uid, gid)\n-\n-\t// Then try all the auxiliary groups.\n-\tgroups, err := Getgroups()\n-\tif err != nil {\n-\t\tt.Fatalf(\"getgroups: %s\", err)\n-\t}\n-\tt.Log(\"groups: \", groups)\n-\tfor _, g := range groups {\n-\t\tif err = Chown(f.Name(), -1, g); err != nil {\n-\t\t\tt.Fatalf(\"chown %s -1 %d: %s\", f.Name(), g, err)\n-\t\t}\n-\t\tcheckUidGid(t, f.Name(), dir.Uid, g)\n-\n-\t\t// change back to gid to test fd.Chown\n-\t\tif err = f.Chown(-1, gid); err != nil {\n-\t\t\tt.Fatalf(\"fchown %s -1 %d: %s\", f.Name(), gid, err)\n-\t\t}\n-\t\tcheckUidGid(t, f.Name(), dir.Uid, gid)\n-\t}\n-}\n-\n func checkSize(t *testing.T, f *File, size int64) {\n \tdir, err := f.Stat()\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %q (looking for size %d): %s\", f.Name(), size, err)\n \t}\n-\tif dir.Size != size {\n-\t\tt.Errorf(\"Stat %q: size %d want %d\", f.Name(), dir.Size, size)\n+\tif dir.Size() != size {\n+\t\tt.Errorf(\"Stat %q: size %d want %d\", f.Name(), dir.Size(), size)\n \t}\n }\n \n@@ -711,37 +652,38 @@ func TestChtimes(t *testing.T) {\n \tf.Write([]byte(\"hello, world\\n\"))\n \tf.Close()\n \n-\tpreStat, err := Stat(f.Name())\n+\tst, err := Stat(f.Name())\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %s: %s\", f.Name(), err)\n \t}\n+\tpreStat := st.(*FileStat)\n \n \t// Move access and modification time back a second\n-\tconst OneSecond = 1e9 // in nanoseconds\n-\terr = Chtimes(f.Name(), preStat.Atime_ns-OneSecond, preStat.Mtime_ns-OneSecond)\n+\tat := Atime(preStat)\n+\tmt := preStat.ModTime()\n+\terr = Chtimes(f.Name(), at.Add(-time.Second), mt.Add(-time.Second))\n \tif err != nil {\n \t\tt.Fatalf(\"Chtimes %s: %s\", f.Name(), err)\n \t}\n \n-\tpostStat, err := Stat(f.Name())\n+\tst, err = Stat(f.Name())\n \tif err != nil {\n \t\tt.Fatalf(\"second Stat %s: %s\", f.Name(), err)\n \t}\n+\tpostStat := st.(*FileStat)\n \n \t/* Plan 9:\n \t\tMtime is the time of the last change of content.  Similarly, atime is set whenever the\n \t    contents are accessed; also, it is set whenever mtime is set.\n \t*/\n-\tif postStat.Atime_ns >= preStat.Atime_ns && syscall.OS != \"plan9\" {\n-\t\tt.Errorf(\"Atime_ns didn't go backwards; was=%d, after=%d\",\n-\t\t\tpreStat.Atime_ns,\n-\t\t\tpostStat.Atime_ns)\n+\tpat := Atime(postStat)\n+\tpmt := postStat.ModTime()\n+\tif !pat.Before(at) && syscall.OS != \"plan9\" {\n+\t\tt.Errorf(\"AccessTime didn't go backwards; was=%d, after=%d\", at, pat)\n \t}\n \n-\tif postStat.Mtime_ns >= preStat.Mtime_ns {\n-\t\tt.Errorf(\"Mtime_ns didn't go backwards; was=%d, after=%d\",\n-\t\t\tpreStat.Mtime_ns,\n-\t\t\tpostStat.Mtime_ns)\n+\tif !pmt.Before(mt) {\n+\t\tt.Errorf(\"ModTime didn't go backwards; was=%d, after=%d\", mt, pmt)\n \t}\n }\n \n@@ -883,7 +825,7 @@ func TestOpenError(t *testing.T) {\n \t\t}\n \t\tperr, ok := err.(*PathError)\n \t\tif !ok {\n-\t\t\tt.Errorf(\"Open(%q, %d) returns error of %T type; want *os.PathError\", tt.path, tt.mode, err)\n+\t\t\tt.Errorf(\"Open(%q, %d) returns error of %T type; want *PathError\", tt.path, tt.mode, err)\n \t\t}\n \t\tif perr.Err != tt.error {\n \t\t\tif syscall.OS == \"plan9\" {\n@@ -899,6 +841,14 @@ func TestOpenError(t *testing.T) {\n \t}\n }\n \n+func TestOpenNoName(t *testing.T) {\n+\tf, err := Open(\"\")\n+\tif err == nil {\n+\t\tt.Fatal(`Open(\"\") succeeded`)\n+\t\tf.Close()\n+\t}\n+}\n+\n func run(t *testing.T, cmd []string) string {\n \t// Run /bin/hostname and collect output.\n \tr, w, err := Pipe()"}, {"sha": "3109a8171a58bc6607907ca27cf49da2e196fd1e", "filename": "libgo/go/os/os_unix_test.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fos_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fos_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_unix_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux openbsd\n+\n+package os_test\n+\n+import (\n+\t. \"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+func checkUidGid(t *testing.T, path string, uid, gid int) {\n+\tdir, err := Stat(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat %q (looking for uid/gid %d/%d): %s\", path, uid, gid, err)\n+\t}\n+\tsys := dir.(*FileStat).Sys.(*syscall.Stat_t)\n+\tif int(sys.Uid) != uid {\n+\t\tt.Errorf(\"Stat %q: uid %d want %d\", path, sys.Uid, uid)\n+\t}\n+\tif int(sys.Gid) != gid {\n+\t\tt.Errorf(\"Stat %q: gid %d want %d\", path, sys.Gid, gid)\n+\t}\n+}\n+\n+func TestChown(t *testing.T) {\n+\t// Chown is not supported under windows or Plan 9.\n+\t// Plan9 provides a native ChownPlan9 version instead.\n+\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\t\treturn\n+\t}\n+\t// Use TempDir() to make sure we're on a local file system,\n+\t// so that the group ids returned by Getgroups will be allowed\n+\t// on the file.  On NFS, the Getgroups groups are\n+\t// basically useless.\n+\tf := newFile(\"TestChown\", t)\n+\tdefer Remove(f.Name())\n+\tdefer f.Close()\n+\tdir, err := f.Stat()\n+\tif err != nil {\n+\t\tt.Fatalf(\"stat %s: %s\", f.Name(), err)\n+\t}\n+\n+\t// Can't change uid unless root, but can try\n+\t// changing the group id.  First try our current group.\n+\tgid := Getgid()\n+\tt.Log(\"gid:\", gid)\n+\tif err = Chown(f.Name(), -1, gid); err != nil {\n+\t\tt.Fatalf(\"chown %s -1 %d: %s\", f.Name(), gid, err)\n+\t}\n+\tsys := dir.(*FileStat).Sys.(*syscall.Stat_t)\n+\tcheckUidGid(t, f.Name(), int(sys.Uid), gid)\n+\n+\t// Then try all the auxiliary groups.\n+\tgroups, err := Getgroups()\n+\tif err != nil {\n+\t\tt.Fatalf(\"getgroups: %s\", err)\n+\t}\n+\tt.Log(\"groups: \", groups)\n+\tfor _, g := range groups {\n+\t\tif err = Chown(f.Name(), -1, g); err != nil {\n+\t\t\tt.Fatalf(\"chown %s -1 %d: %s\", f.Name(), g, err)\n+\t\t}\n+\t\tcheckUidGid(t, f.Name(), int(sys.Uid), g)\n+\n+\t\t// change back to gid to test fd.Chown\n+\t\tif err = f.Chown(-1, gid); err != nil {\n+\t\t\tt.Fatalf(\"fchown %s -1 %d: %s\", f.Name(), gid, err)\n+\t\t}\n+\t\tcheckUidGid(t, f.Name(), int(sys.Uid), gid)\n+\t}\n+}"}, {"sha": "bc14a78318811d8d9e5678c0f1c6f5517b9209f6", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -17,7 +17,7 @@ func MkdirAll(path string, perm uint32) error {\n \t// If path exists, stop with success or error.\n \tdir, err := Stat(path)\n \tif err == nil {\n-\t\tif dir.IsDirectory() {\n+\t\tif dir.IsDir() {\n \t\t\treturn nil\n \t\t}\n \t\treturn &PathError{\"mkdir\", path, ENOTDIR}\n@@ -48,7 +48,7 @@ func MkdirAll(path string, perm uint32) error {\n \t\t// Handle arguments like \"foo/.\" by\n \t\t// double-checking that directory doesn't exist.\n \t\tdir, err1 := Lstat(path)\n-\t\tif err1 == nil && dir.IsDirectory() {\n+\t\tif err1 == nil && dir.IsDir() {\n \t\t\treturn nil\n \t\t}\n \t\treturn err\n@@ -75,7 +75,7 @@ func RemoveAll(path string) error {\n \t\t}\n \t\treturn serr\n \t}\n-\tif !dir.IsDirectory() {\n+\tif !dir.IsDir() {\n \t\t// Not a directory; return the error from Remove.\n \t\treturn err\n \t}"}, {"sha": "c664fc189b88cb2905952d81d113eeff64e426b6", "filename": "libgo/go/os/stat.go", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fstat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fstat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -2,39 +2,55 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// AMD64, Linux\n-\n package os\n \n-import syscall \"syscall\"\n+import (\n+\t\"syscall\"\n+\t\"time\"\n+)\n \n-func isSymlink(stat *syscall.Stat_t) bool {\n-\treturn stat.Mode & syscall.S_IFMT == syscall.S_IFLNK\n+func sameFile(fs1, fs2 *FileStat) bool {\n+\tsys1 := fs1.Sys.(*syscall.Stat_t)\n+\tsys2 := fs2.Sys.(*syscall.Stat_t)\n+\treturn sys1.Dev == sys2.Dev && sys1.Ino == sys2.Ino\n }\n \n-func fileInfoFromStat(name string, fi *FileInfo, lstat, stat *syscall.Stat_t) *FileInfo {\n-\tfi.Dev = uint64(stat.Dev)\n-\tfi.Ino = uint64(stat.Ino)\n-\tfi.Nlink = uint64(stat.Nlink)\n-\tfi.Mode = uint32(stat.Mode)\n-\tfi.Uid = int(stat.Uid)\n-\tfi.Gid = int(stat.Gid)\n-\tfi.Rdev = uint64(stat.Rdev)\n-\tfi.Size = int64(stat.Size)\n-\tfi.Blksize = int64(stat.Blksize)\n-\tfi.Blocks = int64(stat.Blocks)\n-\tfi.Atime_ns = int64(stat.Atime.Sec)*1e9 + int64(stat.Atime.Nsec)\n-\tfi.Mtime_ns = int64(stat.Mtime.Sec)*1e9 + int64(stat.Mtime.Nsec)\n-\tfi.Ctime_ns = int64(stat.Ctime.Sec)*1e9 + int64(stat.Ctime.Nsec)\n-\tfor i := len(name)-1; i >= 0; i-- {\n-\t\tif name[i] == '/' {\n-\t\t\tname = name[i+1:]\n-\t\t\tbreak\n-\t\t}\n+func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n+\tfs := &FileStat{\n+\t\tname:    basename(name),\n+\t\tsize:    int64(st.Size),\n+\t\tmodTime: timespecToTime(st.Mtime),\n+\t\tSys:     st,\n+\t}\n+\tfs.mode = FileMode(st.Mode & 0777)\n+\tswitch st.Mode & syscall.S_IFMT {\n+\tcase syscall.S_IFBLK, syscall.S_IFCHR:\n+\t\tfs.mode |= ModeDevice\n+\tcase syscall.S_IFDIR:\n+\t\tfs.mode |= ModeDir\n+\tcase syscall.S_IFIFO:\n+\t\tfs.mode |= ModeNamedPipe\n+\tcase syscall.S_IFLNK:\n+\t\tfs.mode |= ModeSymlink\n+\tcase syscall.S_IFREG:\n+\t\t// nothing to do\n+\tcase syscall.S_IFSOCK:\n+\t\tfs.mode |= ModeSocket\n \t}\n-\tfi.Name = name\n-\tif isSymlink(lstat) && !isSymlink(stat) {\n-\t\tfi.FollowedSymlink = true\n+\tif st.Mode&syscall.S_ISGID != 0 {\n+\t\tfs.mode |= ModeSetgid\n \t}\n-\treturn fi\n+\tif st.Mode&syscall.S_ISUID != 0 {\n+\t\tfs.mode |= ModeSetuid\n+\t}\n+\treturn fs\n+}\n+\n+func timespecToTime(ts syscall.Timespec) time.Time {\n+\treturn time.Unix(int64(ts.Sec), int64(ts.Nsec))\n+}\n+\n+// For testing.\n+func atime(fi FileInfo) time.Time {\n+\treturn timespecToTime(fi.(*FileStat).Sys.(*syscall.Stat_t).Atime)\n }"}, {"sha": "66189a6b9baaa323ae807eb5904c70a5d45b1d07", "filename": "libgo/go/os/stat_openbsd.go", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_openbsd.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -4,29 +4,53 @@\n \n package os\n \n-import \"syscall\"\n+import (\n+\t\"syscall\"\n+\t\"time\"\n+)\n \n-func isSymlink(stat *syscall.Stat_t) bool {\n-\treturn stat.Mode&syscall.S_IFMT == syscall.S_IFLNK\n+func sameFile(fs1, fs2 *FileStat) bool {\n+\tsys1 := fs1.Sys.(*syscall.Stat_t)\n+\tsys2 := fs2.Sys.(*syscall.Stat_t)\n+\treturn sys1.Dev == sys2.Dev && sys1.Ino == sys2.Ino\n }\n \n-func fileInfoFromStat(name string, fi *FileInfo, lstat, stat *syscall.Stat_t) *FileInfo {\n-\tfi.Dev = uint64(stat.Dev)\n-\tfi.Ino = uint64(stat.Ino)\n-\tfi.Nlink = uint64(stat.Nlink)\n-\tfi.Mode = uint32(stat.Mode)\n-\tfi.Uid = int(stat.Uid)\n-\tfi.Gid = int(stat.Gid)\n-\tfi.Rdev = uint64(stat.Rdev)\n-\tfi.Size = int64(stat.Size)\n-\tfi.Blksize = int64(stat.Blksize)\n-\tfi.Blocks = stat.Blocks\n-\tfi.Atime_ns = syscall.TimespecToNsec(stat.Atim)\n-\tfi.Mtime_ns = syscall.TimespecToNsec(stat.Mtim)\n-\tfi.Ctime_ns = syscall.TimespecToNsec(stat.Ctim)\n-\tfi.Name = basename(name)\n-\tif isSymlink(lstat) && !isSymlink(stat) {\n-\t\tfi.FollowedSymlink = true\n+func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n+\tfs := &FileStat{\n+\t\tname:    basename(name),\n+\t\tsize:    int64(st.Size),\n+\t\tmodTime: timespecToTime(st.Mtim),\n+\t\tSys:     st,\n \t}\n-\treturn fi\n+\tfs.mode = FileMode(st.Mode & 0777)\n+\tswitch st.Mode & syscall.S_IFMT {\n+\tcase syscall.S_IFBLK, syscall.S_IFCHR:\n+\t\tfs.mode |= ModeDevice\n+\tcase syscall.S_IFDIR:\n+\t\tfs.mode |= ModeDir\n+\tcase syscall.S_IFIFO:\n+\t\tfs.mode |= ModeNamedPipe\n+\tcase syscall.S_IFLNK:\n+\t\tfs.mode |= ModeSymlink\n+\tcase syscall.S_IFREG:\n+\t\t// nothing to do\n+\tcase syscall.S_IFSOCK:\n+\t\tfs.mode |= ModeSocket\n+\t}\n+\tif st.Mode&syscall.S_ISGID != 0 {\n+\t\tfs.mode |= ModeSetgid\n+\t}\n+\tif st.Mode&syscall.S_ISUID != 0 {\n+\t\tfs.mode |= ModeSetuid\n+\t}\n+\treturn fs\n+}\n+\n+func timespecToTime(ts syscall.Timespec) time.Time {\n+\treturn time.Unix(int64(ts.Sec), int64(ts.Nsec))\n+}\n+\n+// For testing.\n+func atime(fi FileInfo) time.Time {\n+\treturn timespecToTime(fi.(*FileStat).Sys.(*syscall.Stat_t).Atim)\n }"}, {"sha": "2638153ddbe1d1fa6ebad5f852d1cbcbdd61a938", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 95, "deletions": 37, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -4,53 +4,111 @@\n \n package os\n \n-import \"syscall\"\n-\n-// An operating-system independent representation of Unix data structures.\n-// OS-specific routines in this directory convert the OS-local versions to these.\n+import (\n+\t\"syscall\"\n+\t\"time\"\n+)\n \n // Getpagesize returns the underlying system's memory page size.\n func Getpagesize() int { return syscall.Getpagesize() }\n \n-// A FileInfo describes a file and is returned by Stat, Fstat, and Lstat\n-type FileInfo struct {\n-\tDev             uint64 // device number of file system holding file.\n-\tIno             uint64 // inode number.\n-\tNlink           uint64 // number of hard links.\n-\tMode            uint32 // permission and mode bits.\n-\tUid             int    // user id of owner.\n-\tGid             int    // group id of owner.\n-\tRdev            uint64 // device type for special file.\n-\tSize            int64  // length in bytes.\n-\tBlksize         int64  // size of blocks, in bytes.\n-\tBlocks          int64  // number of blocks allocated for file.\n-\tAtime_ns        int64  // access time; nanoseconds since epoch.\n-\tMtime_ns        int64  // modified time; nanoseconds since epoch.\n-\tCtime_ns        int64  // status change time; nanoseconds since epoch.\n-\tName            string // base name of the file name provided in Open, Stat, etc.\n-\tFollowedSymlink bool   // followed a symlink to get this information\n+// A FileInfo describes a file and is returned by Stat and Lstat\n+type FileInfo interface {\n+\tName() string       // base name of the file\n+\tSize() int64        // length in bytes\n+\tMode() FileMode     // file mode bits\n+\tModTime() time.Time // modification time\n+\tIsDir() bool        // abbreviation for Mode().IsDir()\n }\n \n-// IsFifo reports whether the FileInfo describes a FIFO file.\n-func (f *FileInfo) IsFifo() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFIFO }\n+// A FileMode represents a file's mode and permission bits.\n+// The bits have the same definition on all systems, so that\n+// information about files can be moved from one system\n+// to another portably.  Not all bits apply to all systems.\n+// The only required bit is ModeDir for directories.\n+type FileMode uint32\n \n-// IsChar reports whether the FileInfo describes a character special file.\n-func (f *FileInfo) IsChar() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFCHR }\n+// The defined file mode bits are the most significant bits of the FileMode.\n+// The nine least-significant bits are the standard Unix rwxrwxrwx permissions.\n+const (\n+\t// The single letters are the abbreviations\n+\t// used by the String method's formatting.\n+\tModeDir       FileMode = 1 << (32 - 1 - iota) // d: is a directory\n+\tModeAppend                                    // a: append-only\n+\tModeExclusive                                 // l: exclusive use\n+\tModeTemporary                                 // t: temporary file (not backed up)\n+\tModeSymlink                                   // L: symbolic link\n+\tModeDevice                                    // D: device file\n+\tModeNamedPipe                                 // p: named pipe (FIFO)\n+\tModeSocket                                    // S: Unix domain socket\n+\tModeSetuid                                    // u: setuid\n+\tModeSetgid                                    // g: setgid\n \n-// IsDirectory reports whether the FileInfo describes a directory.\n-func (f *FileInfo) IsDirectory() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFDIR }\n+\t// Mask for the type bits. For regular files, none will be set.\n+\tModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n \n-// IsBlock reports whether the FileInfo describes a block special file.\n-func (f *FileInfo) IsBlock() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFBLK }\n+\tModePerm FileMode = 0777 // permission bits\n+)\n \n-// IsRegular reports whether the FileInfo describes a regular file.\n-func (f *FileInfo) IsRegular() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFREG }\n+func (m FileMode) String() string {\n+\tconst str = \"daltLDpSug\"\n+\tvar buf [20]byte\n+\tw := 0\n+\tfor i, c := range str {\n+\t\tif m&(1<<uint(32-1-i)) != 0 {\n+\t\t\tbuf[w] = byte(c)\n+\t\t\tw++\n+\t\t}\n+\t}\n+\tif w == 0 {\n+\t\tbuf[w] = '-'\n+\t\tw++\n+\t}\n+\tconst rwx = \"rwxrwxrwx\"\n+\tfor i, c := range rwx {\n+\t\tif m&(1<<uint(9-1-i)) != 0 {\n+\t\t\tbuf[w] = byte(c)\n+\t\t} else {\n+\t\t\tbuf[w] = '-'\n+\t\t}\n+\t\tw++\n+\t}\n+\treturn string(buf[:w])\n+}\n \n-// IsSymlink reports whether the FileInfo describes a symbolic link.\n-func (f *FileInfo) IsSymlink() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFLNK }\n+// IsDir reports whether m describes a directory.\n+// That is, it tests for the ModeDir bit being set in m.\n+func (m FileMode) IsDir() bool {\n+\treturn m&ModeDir != 0\n+}\n+\n+// Perm returns the Unix permission bits in m.\n+func (m FileMode) Perm() FileMode {\n+\treturn m & ModePerm\n+}\n \n-// IsSocket reports whether the FileInfo describes a socket.\n-func (f *FileInfo) IsSocket() bool { return (f.Mode & syscall.S_IFMT) == syscall.S_IFSOCK }\n+// A FileStat is the implementation of FileInfo returned by Stat and Lstat.\n+// Clients that need access to the underlying system-specific stat information\n+// can test for *os.FileStat and then consult the Sys field.\n+type FileStat struct {\n+\tname    string\n+\tsize    int64\n+\tmode    FileMode\n+\tmodTime time.Time\n \n-// Permission returns the file permission bits.\n-func (f *FileInfo) Permission() uint32 { return f.Mode & 0777 }\n+\tSys interface{}\n+}\n+\n+func (fs *FileStat) Name() string       { return fs.name }\n+func (fs *FileStat) Size() int64        { return fs.size }\n+func (fs *FileStat) Mode() FileMode     { return fs.mode }\n+func (fs *FileStat) ModTime() time.Time { return fs.modTime }\n+func (fs *FileStat) IsDir() bool        { return fs.mode.IsDir() }\n+\n+// SameFile reports whether fs and other describe the same file.\n+// For example, on Unix this means that the device and inode fields\n+// of the two underlying structures are identical; on other systems\n+// the decision may be based on the path names.\n+func (fs *FileStat) SameFile(other *FileStat) bool {\n+\treturn sameFile(fs, other)\n+}"}, {"sha": "f9f44af8a93a9007c657b434e38310cf1dd1eb3b", "filename": "libgo/go/os/user/user_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -41,8 +41,8 @@ func TestLookup(t *testing.T) {\n \t\tt.Errorf(\"expected Uid of %d; got %d\", e, g)\n \t}\n \tfi, err := os.Stat(u.HomeDir)\n-\tif err != nil || !fi.IsDirectory() {\n-\t\tt.Errorf(\"expected a valid HomeDir; stat(%q): err=%v, IsDirectory=%v\", u.HomeDir, err, fi.IsDirectory())\n+\tif err != nil || !fi.IsDir() {\n+\t\tt.Errorf(\"expected a valid HomeDir; stat(%q): err=%v, IsDir=%v\", u.HomeDir, err, fi.IsDir())\n \t}\n \tif u.Username == \"\" {\n \t\tt.Fatalf(\"didn't get a username\")"}, {"sha": "5c233fbaebff6f6e66180d344d449a97d52f3541", "filename": "libgo/go/patch/git.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpatch%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpatch%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpatch%2Fgit.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -22,7 +22,7 @@ func gitSHA1(data []byte) []byte {\n \th := sha1.New()\n \tfmt.Fprintf(h, \"blob %d\\x00\", len(data))\n \th.Write(data)\n-\treturn h.Sum()\n+\treturn h.Sum(nil)\n }\n \n // BUG(rsc): The Git binary delta format is not implemented, only Git binary literals."}, {"sha": "c3678f541d4631b13f61d7c000665922535a14bc", "filename": "libgo/go/path/filepath/match.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -260,7 +260,7 @@ func glob(dir, pattern string, matches []string) (m []string, e error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\tif !fi.IsDirectory() {\n+\tif !fi.IsDir() {\n \t\treturn\n \t}\n \td, err := os.Open(dir)"}, {"sha": "e3d6c342ca6878ca209f54a10f8d9c81bf0f3996", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -223,7 +223,7 @@ func EvalSymlinks(path string) (string, error) {\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n-\t\tif !fi.IsSymlink() {\n+\t\tif fi.Mode()&os.ModeSymlink == 0 {\n \t\t\tb.WriteString(p)\n \t\t\tif path != \"\" {\n \t\t\t\tb.WriteRune(Separator)\n@@ -312,7 +312,11 @@ func Rel(basepath, targpath string) (string, error) {\n \tif b0 != bl {\n \t\t// Base elements left. Must go up before going down.\n \t\tseps := strings.Count(base[b0:bl], string(Separator))\n-\t\tbuf := make([]byte, 3+seps*3+tl-t0)\n+\t\tsize := 2 + seps*3\n+\t\tif tl != t0 {\n+\t\t\tsize += 1 + tl - t0\n+\t\t}\n+\t\tbuf := make([]byte, size)\n \t\tn := copy(buf, \"..\")\n \t\tfor i := 0; i < seps; i++ {\n \t\t\tbuf[n] = Separator\n@@ -341,19 +345,19 @@ var SkipDir = errors.New(\"skip this directory\")\n // sole exception is that if path is a directory and the function returns the\n // special value SkipDir, the contents of the directory are skipped\n // and processing continues as usual on the next file.\n-type WalkFunc func(path string, info *os.FileInfo, err error) error\n+type WalkFunc func(path string, info os.FileInfo, err error) error\n \n // walk recursively descends path, calling w.\n-func walk(path string, info *os.FileInfo, walkFn WalkFunc) error {\n+func walk(path string, info os.FileInfo, walkFn WalkFunc) error {\n \terr := walkFn(path, info, nil)\n \tif err != nil {\n-\t\tif info.IsDirectory() && err == SkipDir {\n+\t\tif info.IsDir() && err == SkipDir {\n \t\t\treturn nil\n \t\t}\n \t\treturn err\n \t}\n \n-\tif !info.IsDirectory() {\n+\tif !info.IsDir() {\n \t\treturn nil\n \t}\n \n@@ -363,7 +367,7 @@ func walk(path string, info *os.FileInfo, walkFn WalkFunc) error {\n \t}\n \n \tfor _, fileInfo := range list {\n-\t\tif err = walk(Join(path, fileInfo.Name), fileInfo, walkFn); err != nil {\n+\t\tif err = walk(Join(path, fileInfo.Name()), fileInfo, walkFn); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -386,7 +390,7 @@ func Walk(root string, walkFn WalkFunc) error {\n // readDir reads the directory named by dirname and returns\n // a sorted list of directory entries.\n // Copied from io/ioutil to avoid the circular import.\n-func readDir(dirname string) ([]*os.FileInfo, error) {\n+func readDir(dirname string) ([]os.FileInfo, error) {\n \tf, err := os.Open(dirname)\n \tif err != nil {\n \t\treturn nil, err\n@@ -396,20 +400,16 @@ func readDir(dirname string) ([]*os.FileInfo, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tfi := make(fileInfoList, len(list))\n-\tfor i := range list {\n-\t\tfi[i] = &list[i]\n-\t}\n-\tsort.Sort(fi)\n-\treturn fi, nil\n+\tsort.Sort(byName(list))\n+\treturn list, nil\n }\n \n-// A dirList implements sort.Interface.\n-type fileInfoList []*os.FileInfo\n+// byName implements sort.Interface.\n+type byName []os.FileInfo\n \n-func (f fileInfoList) Len() int           { return len(f) }\n-func (f fileInfoList) Less(i, j int) bool { return f[i].Name < f[j].Name }\n-func (f fileInfoList) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n+func (f byName) Len() int           { return len(f) }\n+func (f byName) Less(i, j int) bool { return f[i].Name() < f[j].Name() }\n+func (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n \n // Base returns the last element of path.\n // Trailing path separators are removed before extracting the last element."}, {"sha": "2bd62d34aeb5659a06fbef82a783d8a2085eb402", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -317,16 +317,17 @@ func checkMarks(t *testing.T, report bool) {\n // Assumes that each node name is unique. Good enough for a test.\n // If clear is true, any incoming error is cleared before return. The errors\n // are always accumulated, though.\n-func mark(path string, info *os.FileInfo, err error, errors *[]error, clear bool) error {\n+func mark(path string, info os.FileInfo, err error, errors *[]error, clear bool) error {\n \tif err != nil {\n \t\t*errors = append(*errors, err)\n \t\tif clear {\n \t\t\treturn nil\n \t\t}\n \t\treturn err\n \t}\n+\tname := info.Name()\n \twalkTree(tree, tree.name, func(path string, n *Node) {\n-\t\tif n.name == info.Name {\n+\t\tif n.name == name {\n \t\t\tn.mark++\n \t\t}\n \t})\n@@ -337,7 +338,7 @@ func TestWalk(t *testing.T) {\n \tmakeTree(t)\n \terrors := make([]error, 0, 10)\n \tclear := true\n-\tmarkFn := func(path string, info *os.FileInfo, err error) error {\n+\tmarkFn := func(path string, info os.FileInfo, err error) error {\n \t\treturn mark(path, info, err, &errors, clear)\n \t}\n \t// Expect no errors.\n@@ -548,7 +549,7 @@ func TestEvalSymlinks(t *testing.T) {\n \t// relative\n \ttestEvalSymlinks(t, tests)\n \t// absolute\n-/* These tests do not work in the gccgo test environment.\n+\t/* These tests do not work in the gccgo test environment.\n \tgoroot, err := filepath.EvalSymlinks(os.Getenv(\"GOROOT\"))\n \tif err != nil {\n \t\tt.Fatalf(\"EvalSymlinks(%q) error: %v\", os.Getenv(\"GOROOT\"), err)\n@@ -564,7 +565,7 @@ func TestEvalSymlinks(t *testing.T) {\n \t\t}\n \t}\n \ttestEvalSymlinks(t, tests)\n-*/\n+\t*/\n }\n \n /* These tests do not work in the gccgo test environment.\n@@ -603,7 +604,7 @@ func TestAbs(t *testing.T) {\n \t\t\tt.Errorf(\"Abs(%q) error: %v\", path, err)\n \t\t}\n \t\tabsinfo, err := os.Stat(abspath)\n-\t\tif err != nil || absinfo.Ino != info.Ino {\n+\t\tif err != nil || !absinfo.(*os.FileStat).SameFile(info.(*os.FileStat)) {\n \t\t\tt.Errorf(\"Abs(%q)=%q, not the same file\", path, abspath)\n \t\t}\n \t\tif !filepath.IsAbs(abspath) {\n@@ -634,6 +635,10 @@ var reltests = []RelTests{\n \t{\"a/b/../c\", \"a/b\", \"../b\"},\n \t{\"a/b/c\", \"a/c/d\", \"../../c/d\"},\n \t{\"a/b\", \"c/d\", \"../../c/d\"},\n+\t{\"a/b/c/d\", \"a/b\", \"../..\"},\n+\t{\"a/b/c/d\", \"a/b/\", \"../..\"},\n+\t{\"a/b/c/d/\", \"a/b\", \"../..\"},\n+\t{\"a/b/c/d/\", \"a/b/\", \"../..\"},\n \t{\"../../a/b\", \"../../a/b/c/d\", \"c/d\"},\n \t{\"/a/b\", \"/a/b\", \".\"},\n \t{\"/a/b/.\", \"/a/b\", \".\"},\n@@ -645,6 +650,10 @@ var reltests = []RelTests{\n \t{\"/a/b/../c\", \"/a/b\", \"../b\"},\n \t{\"/a/b/c\", \"/a/c/d\", \"../../c/d\"},\n \t{\"/a/b\", \"/c/d\", \"../../c/d\"},\n+\t{\"/a/b/c/d\", \"/a/b\", \"../..\"},\n+\t{\"/a/b/c/d\", \"/a/b/\", \"../..\"},\n+\t{\"/a/b/c/d/\", \"/a/b\", \"../..\"},\n+\t{\"/a/b/c/d/\", \"/a/b/\", \"../..\"},\n \t{\"/../../a/b\", \"/../../a/b/c/d\", \"c/d\"},\n \t{\".\", \"a/b\", \"a/b\"},\n \t{\".\", \"..\", \"..\"},"}, {"sha": "53fdeadf97b42659e501e24bc504cee533d84c67", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -64,7 +64,17 @@ func Count(s, sep string) int {\n \n // Contains returns true if substr is within s.\n func Contains(s, substr string) bool {\n-\treturn Index(s, substr) != -1\n+\treturn Index(s, substr) >= 0\n+}\n+\n+// ContainsAny returns true if any Unicode code points in chars are within s.\n+func ContainsAny(s, chars string) bool {\n+\treturn IndexAny(s, chars) >= 0\n+}\n+\n+// ContainsRune returns true if the Unicode code point r is within s.\n+func ContainsRune(s string, r rune) bool {\n+\treturn IndexRune(s, r) >= 0\n }\n \n // Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n@@ -269,7 +279,7 @@ func FieldsFunc(s string, f func(rune) bool) []string {\n \t\t\tfieldStart = i\n \t\t}\n \t}\n-\tif fieldStart != -1 { // Last field might end at EOF.\n+\tif fieldStart >= 0 { // Last field might end at EOF.\n \t\ta[na] = s[fieldStart:]\n \t}\n \treturn a\n@@ -512,7 +522,7 @@ func lastIndexFunc(s string, f func(rune) bool, truth bool) int {\n }\n \n func makeCutsetFunc(cutset string) func(rune) bool {\n-\treturn func(r rune) bool { return IndexRune(cutset, r) != -1 }\n+\treturn func(r rune) bool { return IndexRune(cutset, r) >= 0 }\n }\n \n // Trim returns a slice of the string s with all leading and"}, {"sha": "957af67b2ba5d4aa4505bfc409a4e19cb1015394", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -527,7 +527,7 @@ func TestTrim(t *testing.T) {\n \t\tcase \"TrimRight\":\n \t\t\tf = TrimRight\n \t\tdefault:\n-\t\t\tt.Error(\"Undefined trim function %s\", name)\n+\t\t\tt.Errorf(\"Undefined trim function %s\", name)\n \t\t}\n \t\tactual := f(tc.in, tc.cutset)\n \t\tif actual != tc.out {\n@@ -908,6 +908,56 @@ func TestContains(t *testing.T) {\n \t}\n }\n \n+var ContainsAnyTests = []struct {\n+\tstr, substr string\n+\texpected    bool\n+}{\n+\t{\"\", \"\", false},\n+\t{\"\", \"a\", false},\n+\t{\"\", \"abc\", false},\n+\t{\"a\", \"\", false},\n+\t{\"a\", \"a\", true},\n+\t{\"aaa\", \"a\", true},\n+\t{\"abc\", \"xyz\", false},\n+\t{\"abc\", \"xcz\", true},\n+\t{\"a\u263ab\u263bc\u2639d\", \"uvw\u263bxyz\", true},\n+\t{\"aRegExp*\", \".(|)*+?^$[]\", true},\n+\t{dots + dots + dots, \" \", false},\n+}\n+\n+func TestContainsAny(t *testing.T) {\n+\tfor _, ct := range ContainsAnyTests {\n+\t\tif ContainsAny(ct.str, ct.substr) != ct.expected {\n+\t\t\tt.Errorf(\"ContainsAny(%s, %s) = %v, want %v\",\n+\t\t\t\tct.str, ct.substr, !ct.expected, ct.expected)\n+\t\t}\n+\t}\n+}\n+\n+var ContainsRuneTests = []struct {\n+\tstr      string\n+\tr        rune\n+\texpected bool\n+}{\n+\t{\"\", 'a', false},\n+\t{\"a\", 'a', true},\n+\t{\"aaa\", 'a', true},\n+\t{\"abc\", 'y', false},\n+\t{\"abc\", 'c', true},\n+\t{\"a\u263ab\u263bc\u2639d\", 'x', false},\n+\t{\"a\u263ab\u263bc\u2639d\", '\u263b', true},\n+\t{\"aRegExp*\", '*', true},\n+}\n+\n+func TestContainsRune(t *testing.T) {\n+\tfor _, ct := range ContainsRuneTests {\n+\t\tif ContainsRune(ct.str, ct.r) != ct.expected {\n+\t\t\tt.Errorf(\"ContainsRune(%s, %s) = %v, want %v\",\n+\t\t\t\tct.str, ct.r, !ct.expected, ct.expected)\n+\t\t}\n+\t}\n+}\n+\n var EqualFoldTests = []struct {\n \ts, t string\n \tout  bool"}, {"sha": "e81e5c5845c3ae901c9b5e3b74326dda2df46494", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -27,35 +27,37 @@ type InternalBenchmark struct {\n type B struct {\n \tN         int\n \tbenchmark InternalBenchmark\n-\tns        int64\n+\tns        time.Duration\n \tbytes     int64\n-\tstart     int64\n+\tstart     time.Time\n+\ttimerOn   bool\n }\n \n // StartTimer starts timing a test.  This function is called automatically\n // before a benchmark starts, but it can also used to resume timing after\n // a call to StopTimer.\n func (b *B) StartTimer() {\n-\tif b.start == 0 {\n-\t\tb.start = time.Nanoseconds()\n+\tif !b.timerOn {\n+\t\tb.start = time.Now()\n+\t\tb.timerOn = true\n \t}\n }\n \n // StopTimer stops timing a test.  This can be used to pause the timer\n // while performing complex initialization that you don't\n // want to measure.\n func (b *B) StopTimer() {\n-\tif b.start > 0 {\n-\t\tb.ns += time.Nanoseconds() - b.start\n+\tif b.timerOn {\n+\t\tb.ns += time.Now().Sub(b.start)\n+\t\tb.timerOn = false\n \t}\n-\tb.start = 0\n }\n \n // ResetTimer sets the elapsed benchmark time to zero.\n // It does not affect whether the timer is running.\n func (b *B) ResetTimer() {\n-\tif b.start > 0 {\n-\t\tb.start = time.Nanoseconds()\n+\tif b.timerOn {\n+\t\tb.start = time.Now()\n \t}\n \tb.ns = 0\n }\n@@ -68,7 +70,7 @@ func (b *B) nsPerOp() int64 {\n \tif b.N <= 0 {\n \t\treturn 0\n \t}\n-\treturn b.ns / int64(b.N)\n+\treturn b.ns.Nanoseconds() / int64(b.N)\n }\n \n // runN runs a single benchmark for the specified number of iterations.\n@@ -134,14 +136,14 @@ func (b *B) run() BenchmarkResult {\n \tn := 1\n \tb.runN(n)\n \t// Run the benchmark for at least the specified amount of time.\n-\ttime := int64(*benchTime * 1e9)\n-\tfor b.ns < time && n < 1e9 {\n+\td := time.Duration(*benchTime * float64(time.Second))\n+\tfor b.ns < d && n < 1e9 {\n \t\tlast := n\n \t\t// Predict iterations/sec.\n \t\tif b.nsPerOp() == 0 {\n \t\t\tn = 1e9\n \t\t} else {\n-\t\t\tn = int(time / b.nsPerOp())\n+\t\t\tn = int(d.Nanoseconds() / b.nsPerOp())\n \t\t}\n \t\t// Run more iterations than we think we'll need for a second (1.5x).\n \t\t// Don't grow too fast in case we had timing errors previously.\n@@ -156,23 +158,23 @@ func (b *B) run() BenchmarkResult {\n \n // The results of a benchmark run.\n type BenchmarkResult struct {\n-\tN     int   // The number of iterations.\n-\tNs    int64 // The total time taken.\n-\tBytes int64 // Bytes processed in one iteration.\n+\tN     int           // The number of iterations.\n+\tT     time.Duration // The total time taken.\n+\tBytes int64         // Bytes processed in one iteration.\n }\n \n func (r BenchmarkResult) NsPerOp() int64 {\n \tif r.N <= 0 {\n \t\treturn 0\n \t}\n-\treturn r.Ns / int64(r.N)\n+\treturn r.T.Nanoseconds() / int64(r.N)\n }\n \n func (r BenchmarkResult) mbPerSec() float64 {\n-\tif r.Bytes <= 0 || r.Ns <= 0 || r.N <= 0 {\n+\tif r.Bytes <= 0 || r.T <= 0 || r.N <= 0 {\n \t\treturn 0\n \t}\n-\treturn float64(r.Bytes) * float64(r.N) / float64(r.Ns) * 1e3\n+\treturn (float64(r.Bytes) * float64(r.N) / 1e6) / r.T.Seconds()\n }\n \n func (r BenchmarkResult) String() string {\n@@ -187,9 +189,9 @@ func (r BenchmarkResult) String() string {\n \t\t// The format specifiers here make sure that\n \t\t// the ones digits line up for all three possible formats.\n \t\tif nsop < 10 {\n-\t\t\tns = fmt.Sprintf(\"%13.2f ns/op\", float64(r.Ns)/float64(r.N))\n+\t\t\tns = fmt.Sprintf(\"%13.2f ns/op\", float64(r.T.Nanoseconds())/float64(r.N))\n \t\t} else {\n-\t\t\tns = fmt.Sprintf(\"%12.1f ns/op\", float64(r.Ns)/float64(r.N))\n+\t\t\tns = fmt.Sprintf(\"%12.1f ns/op\", float64(r.T.Nanoseconds())/float64(r.N))\n \t\t}\n \t}\n \treturn fmt.Sprintf(\"%8d\\t%s%s\", r.N, ns, mb)"}, {"sha": "e23f13b6f16794b5d01c94d14c887a30d93b5201", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -56,17 +56,17 @@ func RunExamples(examples []InternalExample) (ok bool) {\n \t\t}()\n \n \t\t// run example\n-\t\tns := -time.Nanoseconds()\n+\t\tt0 := time.Now()\n \t\teg.F()\n-\t\tns += time.Nanoseconds()\n+\t\tdt := time.Now().Sub(t0)\n \n \t\t// close pipe, restore stdout/stderr, get output\n \t\tw.Close()\n \t\tos.Stdout, os.Stderr = stdout, stderr\n \t\tout := <-outC\n \n \t\t// report any errors\n-\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(ns)/1e9)\n+\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", dt.Seconds())\n \t\tif out != eg.Output {\n \t\t\tfmt.Printf(\n \t\t\t\t\"--- FAIL: %s %s\\ngot:\\n%s\\nwant:\\n%s\\n\","}, {"sha": "0b3a07108ccb68b21f8845015af394845ff2a10f", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -111,12 +111,13 @@ func decorate(s string, addFileLine bool) string {\n // T is a type passed to Test functions to manage test state and support formatted test logs.\n // Logs are accumulated during execution and dumped to standard error when done.\n type T struct {\n-\tname          string    // Name of test.\n-\terrors        string    // Error string from test.\n-\tfailed        bool      // Test has failed.\n-\tch            chan *T   // Output for serial tests.\n-\tstartParallel chan bool // Parallel tests will wait on this.\n-\tns            int64     // Duration of test in nanoseconds.\n+\tname          string        // Name of test.\n+\terrors        string        // Error string from test.\n+\tfailed        bool          // Test has failed.\n+\tch            chan *T       // Output for serial tests.\n+\tstartParallel chan bool     // Parallel tests will wait on this.\n+\tstart         time.Time     // Time test started\n+\tdt            time.Duration // Length of test\n }\n \n // Fail marks the Test function as having failed but continues execution.\n@@ -128,7 +129,7 @@ func (t *T) Failed() bool { return t.failed }\n // FailNow marks the Test function as having failed and stops its execution.\n // Execution will continue at the next Test.\n func (t *T) FailNow() {\n-\tt.ns = time.Nanoseconds() - t.ns\n+\tt.dt = time.Now().Sub(t.start)\n \tt.Fail()\n \tt.ch <- t\n \truntime.Goexit()\n@@ -184,9 +185,9 @@ type InternalTest struct {\n }\n \n func tRunner(t *T, test *InternalTest) {\n-\tt.ns = time.Nanoseconds()\n+\tt.start = time.Now()\n \ttest.F(t)\n-\tt.ns = time.Nanoseconds() - t.ns\n+\tt.dt = time.Now().Sub(t.start)\n \tt.ch <- t\n }\n \n@@ -211,7 +212,7 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n }\n \n func report(t *T) {\n-\ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(t.ns)/1e9)\n+\ttstr := fmt.Sprintf(\"(%.2f seconds)\", t.dt.Seconds())\n \tformat := \"--- %s: %s %s\\n%s\"\n \tif t.failed {\n \t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.errors)"}, {"sha": "4208d53a0a47eabba94ea87820cb14db9f6767d1", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -18,8 +18,7 @@ The input text for a template is UTF-8-encoded text in any format.\n \"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.\n Actions may not span newlines, although comments can.\n \n-Once constructed, templates and template sets can be executed safely in\n-parallel.\n+Once constructed, a template may be executed safely in parallel.\n \n Actions\n \n@@ -221,10 +220,9 @@ All produce the quoted word \"output\":\n \n Functions\n \n-During execution functions are found in three function maps: first in the\n-template, then in the \"template set\" (described below), and finally in the\n-global function map. By default, no functions are defined in the template or\n-the set but the Funcs methods can be used to add them.\n+During execution functions are found in two function maps: first in the\n+template, then in the global function map. By default, no functions are defined\n+in the template but the Funcs methods can be used to add them.\n \n Predefined global functions are named as follows.\n \n@@ -265,49 +263,63 @@ Predefined global functions are named as follows.\n The boolean functions take any zero value to be false and a non-zero value to\n be true.\n \n-Template sets\n+Associated templates\n \n-Each template is named by a string specified when it is created.  A template may\n-use a template invocation to instantiate another template directly or by its\n-name; see the explanation of the template action above. The name is looked up\n-in the template set associated with the template.\n+Each template is named by a string specified when it is created. Also, each\n+template is associated with zero or more other templates that it may invoke by\n+name; such associations are transitive and form a name space of templates.\n \n-If no template invocation actions occur in the template, the issue of template\n-sets can be ignored.  If it does contain invocations, though, the template\n-containing the invocations must be part of a template set in which to look up\n-the names.\n+A template may use a template invocation to instantiate another associated\n+template; see the explanation of the \"template\" action above. The name must be\n+that of a template associated with the template that contains the invocation.\n \n-There are two ways to construct template sets.\n+Nested template definitions\n \n-The first is to use a Set's Parse method to create a set of named templates from\n-a single input defining multiple templates.  The syntax of the definitions is to\n-surround each template declaration with a define and end action.\n+When parsing a template, another template may be defined and associated with the\n+template being parsed. Template definitions must appear at the top level of the\n+template, much like global variables in a Go program.\n+\n+The syntax of such definitions is to surround each template declaration with a\n+\"define\" and \"end\" action.\n \n The define action names the template being created by providing a string\n-constant. Here is a simple example of input to Set.Parse:\n+constant. Here is a simple example:\n \n-\t`{{define \"T1\"}} definition of template T1 {{end}}\n-\t{{define \"T2\"}} definition of template T2 {{end}}\n-\t{{define \"T3\"}} {{template \"T1\"}} {{template \"T2\"}} {{end}}`\n+\t`{{define \"T1\"}}ONE{{end}}\n+\t{{define \"T2\"}}TWO{{end}}\n+\t{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n+\t{{template \"T3\"}}`\n \n This defines two templates, T1 and T2, and a third T3 that invokes the other two\n-when it is executed.\n+when it is executed. Finally it invokes T3. If executed this template will\n+produce the text\n+\n+\tONE TWO\n+\n+By construction, a template may reside in only one association. If it's\n+necessary to have a template addressable from multiple associations, the\n+template definition must be parsed multiple times to create distinct *Template\n+values.\n+\n+Parse may be called multiple times to assemble the various associated templates;\n+see the ParseFiles and ParseGlob functions and methods for simple ways to parse\n+related templates stored in files.\n \n-The second way to build a template set is to use Set's Add method to add a\n-parsed template to a set.  A template may be bound to at most one set.  If it's\n-necessary to have a template in multiple sets, the template definition must be\n-parsed multiple times to create distinct *Template values.\n+A template may be executed directly or through ExecuteTemplate, which executes\n+an associated template identified by name. To invoke our example above, we\n+might write,\n \n-Set.Parse may be called multiple times on different inputs to construct the set.\n-Two sets may therefore be constructed with a common base set of templates plus,\n-through a second Parse call each, specializations for some elements.\n+\terr := tmpl.Execute(os.Stdout, \"no data needed\")\n+\tif err != nil {\n+\t\tlog.Fatalf(\"execution failed: %s\", err)\n+\t}\n \n-A template may be executed directly or through Set.Execute, which executes a\n-named template from the set.  To invoke our example above, we might write,\n+or to invoke a particular template explicitly by name,\n \n-\terr := set.Execute(os.Stdout, \"T3\", \"no data needed\")\n+\terr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\n \tif err != nil {\n \t\tlog.Fatalf(\"execution failed: %s\", err)\n \t}\n+\n */\n package template"}, {"sha": "b74bc3b01c90847363d7f19e6d1b6a518d8a2256", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -85,8 +85,18 @@ func errRecover(errp *error) {\n \t}\n }\n \n+// ExecuteTemplate applies the template associated with t that has the given name\n+// to the specified data object and writes the output to wr.\n+func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error {\n+\ttmpl := t.tmpl[name]\n+\tif tmpl == nil {\n+\t\treturn fmt.Errorf(\"template: no template %q associated with template %q\", name, t.name)\n+\t}\n+\treturn tmpl.Execute(wr, data)\n+}\n+\n // Execute applies a parsed template to the specified data object,\n-// writing the output to wr.\n+// and writes the output to wr.\n func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n \tdefer errRecover(&err)\n \tvalue := reflect.ValueOf(data)\n@@ -251,13 +261,9 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {\n }\n \n func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) {\n-\tset := s.tmpl.set\n-\tif set == nil {\n-\t\ts.errorf(\"no set defined in which to invoke template named %q\", t.Name)\n-\t}\n-\ttmpl := set.tmpl[t.Name]\n+\ttmpl := s.tmpl.tmpl[t.Name]\n \tif tmpl == nil {\n-\t\ts.errorf(\"template %q not in set\", t.Name)\n+\t\ts.errorf(\"template %q not defined\", t.Name)\n \t}\n \t// Variables declared by the pipeline persist.\n \tdot = s.evalPipeline(dot, t.Pipe)\n@@ -376,7 +382,7 @@ func (s *state) evalFieldChain(dot, receiver reflect.Value, ident []string, args\n }\n \n func (s *state) evalFunction(dot reflect.Value, name string, args []parse.Node, final reflect.Value) reflect.Value {\n-\tfunction, ok := findFunction(name, s.tmpl, s.tmpl.set)\n+\tfunction, ok := findFunction(name, s.tmpl)\n \tif !ok {\n \t\ts.errorf(\"%q is not a defined function\", name)\n \t}\n@@ -398,7 +404,7 @@ func (s *state) evalField(dot reflect.Value, fieldName string, args []parse.Node\n \tif ptr.Kind() != reflect.Interface && ptr.CanAddr() {\n \t\tptr = ptr.Addr()\n \t}\n-\tif method, ok := methodByName(ptr, fieldName); ok {\n+\tif method := ptr.MethodByName(fieldName); method.IsValid() {\n \t\treturn s.evalCall(dot, method, fieldName, args, final)\n \t}\n \thasArgs := len(args) > 1 || final.IsValid()\n@@ -433,17 +439,6 @@ func (s *state) evalField(dot reflect.Value, fieldName string, args []parse.Node\n \tpanic(\"not reached\")\n }\n \n-// TODO: delete when reflect's own MethodByName is released.\n-func methodByName(receiver reflect.Value, name string) (reflect.Value, bool) {\n-\ttyp := receiver.Type()\n-\tfor i := 0; i < typ.NumMethod(); i++ {\n-\t\tif typ.Method(i).Name == name {\n-\t\t\treturn receiver.Method(i), true // This value includes the receiver.\n-\t\t}\n-\t}\n-\treturn zero, false\n-}\n-\n var (\n \terrorType       = reflect.TypeOf((*error)(nil)).Elem()\n \tfmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()"}, {"sha": "cf3c41572816f578b98a539db57b85e8bc975d4e", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -476,7 +476,7 @@ func vfunc(V, *V) string {\n \treturn \"vfunc\"\n }\n \n-func testExecute(execTests []execTest, set *Set, t *testing.T) {\n+func testExecute(execTests []execTest, template *Template, t *testing.T) {\n \tb := new(bytes.Buffer)\n \tfuncs := FuncMap{\n \t\t\"count\":    count,\n@@ -486,12 +486,13 @@ func testExecute(execTests []execTest, set *Set, t *testing.T) {\n \t\t\"zeroArgs\": zeroArgs,\n \t}\n \tfor _, test := range execTests {\n-\t\ttmpl := New(test.name).Funcs(funcs)\n-\t\ttheSet := set\n-\t\tif theSet == nil {\n-\t\t\ttheSet = new(Set)\n+\t\tvar tmpl *Template\n+\t\tvar err error\n+\t\tif template == nil {\n+\t\t\ttmpl, err = New(test.name).Funcs(funcs).Parse(test.input)\n+\t\t} else {\n+\t\t\ttmpl, err = template.New(test.name).Funcs(funcs).Parse(test.input)\n \t\t}\n-\t\t_, err := tmpl.ParseInSet(test.input, theSet)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s: parse error: %s\", test.name, err)\n \t\t\tcontinue\n@@ -663,24 +664,34 @@ func TestTree(t *testing.T) {\n \t\t\t},\n \t\t},\n \t}\n-\tset := new(Set)\n-\t_, err := set.Delims(\"(\", \")\").Parse(treeTemplate)\n+\ttmpl, err := New(\"root\").Delims(\"(\", \")\").Parse(treeTemplate)\n \tif err != nil {\n \t\tt.Fatal(\"parse error:\", err)\n \t}\n \tvar b bytes.Buffer\n-\terr = set.Execute(&b, \"tree\", tree)\n-\tif err != nil {\n-\t\tt.Fatal(\"exec error:\", err)\n-\t}\n \tstripSpace := func(r rune) rune {\n \t\tif r == '\\t' || r == '\\n' {\n \t\t\treturn -1\n \t\t}\n \t\treturn r\n \t}\n-\tresult := strings.Map(stripSpace, b.String())\n \tconst expect = \"[1[2[3[4]][5[6]]][7[8[9]][10[11]]]]\"\n+\t// First by looking up the template.\n+\terr = tmpl.Lookup(\"tree\").Execute(&b, tree)\n+\tif err != nil {\n+\t\tt.Fatal(\"exec error:\", err)\n+\t}\n+\tresult := strings.Map(stripSpace, b.String())\n+\tif result != expect {\n+\t\tt.Errorf(\"expected %q got %q\", expect, result)\n+\t}\n+\t// Then direct to execution.\n+\tb.Reset()\n+\terr = tmpl.ExecuteTemplate(&b, \"tree\", tree)\n+\tif err != nil {\n+\t\tt.Fatal(\"exec error:\", err)\n+\t}\n+\tresult = strings.Map(stripSpace, b.String())\n \tif result != expect {\n \t\tt.Errorf(\"expected %q got %q\", expect, result)\n \t}"}, {"sha": "d6e4bf1a216dd927f473e05a8740b089a912774c", "filename": "libgo/go/text/template/funcs.go", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -17,8 +17,9 @@ import (\n \n // FuncMap is the type of the map defining the mapping from names to functions.\n // Each function must have either a single return value, or two return values of\n-// which the second has type error. If the second argument evaluates to non-nil\n-// during execution, execution terminates and Execute returns an error.\n+// which the second has type error. In that case, if the second (error)\n+// argument evaluates to non-nil during execution, execution terminates and\n+// Execute returns that error.\n type FuncMap map[string]interface{}\n \n var builtins = FuncMap{\n@@ -78,18 +79,13 @@ func goodFunc(typ reflect.Type) bool {\n \treturn false\n }\n \n-// findFunction looks for a function in the template, set, and global map.\n-func findFunction(name string, tmpl *Template, set *Set) (reflect.Value, bool) {\n-\tif tmpl != nil {\n+// findFunction looks for a function in the template, and global map.\n+func findFunction(name string, tmpl *Template) (reflect.Value, bool) {\n+\tif tmpl != nil && tmpl.common != nil {\n \t\tif fn := tmpl.execFuncs[name]; fn.IsValid() {\n \t\t\treturn fn, true\n \t\t}\n \t}\n-\tif set != nil {\n-\t\tif fn := set.execFuncs[name]; fn.IsValid() {\n-\t\t\treturn fn, true\n-\t\t}\n-\t}\n \tif fn := builtinFuncs[name]; fn.IsValid() {\n \t\treturn fn, true\n \t}\n@@ -310,7 +306,6 @@ func JSEscape(w io.Writer, b []byte) {\n \t\t\tif unicode.IsPrint(r) {\n \t\t\t\tw.Write(b[i : i+size])\n \t\t\t} else {\n-\t\t\t\t// TODO(dsymonds): Do this without fmt?\n \t\t\t\tfmt.Fprintf(w, \"\\\\u%04X\", r)\n \t\t\t}\n \t\t\ti += size - 1"}, {"sha": "3636fb54d697f635a9411e063f75c0a296482730", "filename": "libgo/go/text/template/helper.go", "status": "modified", "additions": 56, "deletions": 189, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fhelper.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fhelper.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fhelper.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Helper functions to make constructing templates and sets easier.\n+// Helper functions to make constructing templates easier.\n \n package template\n \n@@ -12,11 +12,11 @@ import (\n \t\"path/filepath\"\n )\n \n-// Functions and methods to parse a single template.\n+// Functions and methods to parse templates.\n \n // Must is a helper that wraps a call to a function returning (*Template, error)\n-// and panics if the error is non-nil. It is intended for use in variable initializations\n-// such as\n+// and panics if the error is non-nil. It is intended for use in variable\n+// initializations such as\n //\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n func Must(t *Template, err error) *Template {\n \tif err != nil {\n@@ -25,217 +25,84 @@ func Must(t *Template, err error) *Template {\n \treturn t\n }\n \n-// ParseFile creates a new Template and parses the template definition from\n-// the named file.  The template name is the base name of the file.\n-func ParseFile(filename string) (*Template, error) {\n-\tt := New(filepath.Base(filename))\n-\treturn t.ParseFile(filename)\n+// ParseFiles creates a new Template and parses the template definitions from\n+// the named files. The returned template's name will have the (base) name and\n+// (parsed) contents of the first file. There must be at least one file.\n+// If an error occurs, parsing stops and the returned *Template is nil.\n+func ParseFiles(filenames ...string) (*Template, error) {\n+\treturn parseFiles(nil, filenames...)\n }\n \n-// parseFileInSet creates a new Template and parses the template\n-// definition from the named file. The template name is the base name\n-// of the file. It also adds the template to the set. Function bindings are\n-// checked against those in the set.\n-func parseFileInSet(filename string, set *Set) (*Template, error) {\n-\tt := New(filepath.Base(filename))\n-\treturn t.parseFileInSet(filename, set)\n+// ParseFiles parses the named files and associates the resulting templates with\n+// t. If an error occurs, parsing stops and the returned template is nil;\n+// otherwise it is t. There must be at least one file.\n+func (t *Template) ParseFiles(filenames ...string) (*Template, error) {\n+\treturn parseFiles(t, filenames...)\n }\n \n-// ParseFile reads the template definition from a file and parses it to\n-// construct an internal representation of the template for execution.\n-// The returned template will be nil if an error occurs.\n-func (t *Template) ParseFile(filename string) (*Template, error) {\n-\tb, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn t.Parse(string(b))\n-}\n-\n-// parseFileInSet is the same as ParseFile except that function bindings\n-// are checked against those in the set and the template is added\n-// to the set.\n-// The returned template will be nil if an error occurs.\n-func (t *Template) parseFileInSet(filename string, set *Set) (*Template, error) {\n-\tb, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn t.ParseInSet(string(b), set)\n-}\n-\n-// Functions and methods to parse a set.\n-\n-// SetMust is a helper that wraps a call to a function returning (*Set, error)\n-// and panics if the error is non-nil. It is intended for use in variable initializations\n-// such as\n-//\tvar s = template.SetMust(template.ParseSetFiles(\"file\"))\n-func SetMust(s *Set, err error) *Set {\n-\tif err != nil {\n-\t\tpanic(err)\n+// parseFiles is the helper for the method and function. If the argument\n+// template is nil, it is created from the first file.\n+func parseFiles(t *Template, filenames ...string) (*Template, error) {\n+\tif len(filenames) == 0 {\n+\t\t// Not really a problem, but be consistent.\n+\t\treturn nil, fmt.Errorf(\"template: no files named in call to ParseFiles\")\n \t}\n-\treturn s\n-}\n-\n-// ParseFiles parses the named files into a set of named templates.\n-// Each file must be parseable by itself.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseFiles(filenames ...string) (*Set, error) {\n \tfor _, filename := range filenames {\n \t\tb, err := ioutil.ReadFile(filename)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\t_, err = s.Parse(string(b))\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\ts := string(b)\n+\t\tname := filepath.Base(filename)\n+\t\t// First template becomes return value if not already defined,\n+\t\t// and we use that one for subsequent New calls to associate\n+\t\t// all the templates together. Also, if this file has the same name\n+\t\t// as t, this file becomes the contents of t, so\n+\t\t//  t, err := New(name).Funcs(xxx).ParseFiles(name)\n+\t\t// works. Otherwise we create a new template associated with t.\n+\t\tvar tmpl *Template\n+\t\tif t == nil {\n+\t\t\tt = New(name)\n \t\t}\n-\t}\n-\treturn s, nil\n-}\n-\n-// ParseSetFiles creates a new Set and parses the set definition from the\n-// named files. Each file must be individually parseable.\n-func ParseSetFiles(filenames ...string) (*Set, error) {\n-\ts := new(Set)\n-\tfor _, filename := range filenames {\n-\t\tb, err := ioutil.ReadFile(filename)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tif name == t.Name() {\n+\t\t\ttmpl = t\n+\t\t} else {\n+\t\t\ttmpl = t.New(name)\n \t\t}\n-\t\t_, err = s.Parse(string(b))\n+\t\t_, err = tmpl.Parse(s)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n-\treturn s, nil\n+\treturn t, nil\n }\n \n-// ParseGlob parses the set definition from the files identified by the\n-// pattern.  The pattern is processed by filepath.Glob and must match at\n-// least one file.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseGlob(pattern string) (*Set, error) {\n-\tfilenames, err := filepath.Glob(pattern)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif len(filenames) == 0 {\n-\t\treturn nil, fmt.Errorf(\"pattern matches no files: %#q\", pattern)\n-\t}\n-\treturn s.ParseFiles(filenames...)\n+// ParseGlob creates a new Template and parses the template definitions from the\n+// files identified by the pattern, which must match at least one file. The\n+// returned template will have the (base) name and (parsed) contents of the\n+// first file matched by the pattern. ParseGlob is equivalent to calling\n+// ParseFiles with the list of files matched by the pattern.\n+func ParseGlob(pattern string) (*Template, error) {\n+\treturn parseGlob(nil, pattern)\n }\n \n-// ParseSetGlob creates a new Set and parses the set definition from the\n-// files identified by the pattern. The pattern is processed by filepath.Glob\n-// and must match at least one file.\n-func ParseSetGlob(pattern string) (*Set, error) {\n-\tset, err := new(Set).ParseGlob(pattern)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn set, nil\n+// ParseGlob parses the template definitions in the files identified by the\n+// pattern and associates the resulting templates with t. The pattern is\n+// processed by filepath.Glob and must match at least one file. ParseGlob is\n+// equivalent to calling t.ParseFiles with the list of files matched by the\n+// pattern.\n+func (t *Template) ParseGlob(pattern string) (*Template, error) {\n+\treturn parseGlob(t, pattern)\n }\n \n-// Functions and methods to parse stand-alone template files into a set.\n-\n-// ParseTemplateFiles parses the named template files and adds\n-// them to the set. Each template will be named the base name of\n-// its file.\n-// Unlike with ParseFiles, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateFiles is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseTemplateFiles(filenames ...string) (*Set, error) {\n-\tfor _, filename := range filenames {\n-\t\t_, err := parseFileInSet(filename, s)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\treturn s, nil\n-}\n-\n-// ParseTemplateGlob parses the template files matched by the\n-// patern and adds them to the set. Each template will be named\n-// the base name of its file.\n-// Unlike with ParseGlob, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateGlob is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself.\n-// If an error occurs, parsing stops and the returned set is nil.\n-func (s *Set) ParseTemplateGlob(pattern string) (*Set, error) {\n-\tfilenames, err := filepath.Glob(pattern)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tfor _, filename := range filenames {\n-\t\t_, err := parseFileInSet(filename, s)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\treturn s, nil\n-}\n-\n-// ParseTemplateFiles creates a set by parsing the named files,\n-// each of which defines a single template. Each template will be\n-// named the base name of its file.\n-// Unlike with ParseFiles, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateFiles is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself. Parsing stops if an error is\n-// encountered.\n-func ParseTemplateFiles(filenames ...string) (*Set, error) {\n-\tset := new(Set)\n-\tset.init()\n-\tfor _, filename := range filenames {\n-\t\tt, err := ParseFile(filename)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif err := set.add(t); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\treturn set, nil\n-}\n-\n-// ParseTemplateGlob creates a set by parsing the files matched\n-// by the pattern, each of which defines a single template. The pattern\n-// is processed by filepath.Glob and must match at least one file. Each\n-// template will be named the base name of its file.\n-// Unlike with ParseGlob, each file should be a stand-alone template\n-// definition suitable for Template.Parse (not Set.Parse); that is, the\n-// file does not contain {{define}} clauses. ParseTemplateGlob is\n-// therefore equivalent to calling the ParseFile function to create\n-// individual templates, which are then added to the set.\n-// Each file must be parseable by itself. Parsing stops if an error is\n-// encountered.\n-func ParseTemplateGlob(pattern string) (*Set, error) {\n-\tset := new(Set)\n+// parseGlob is the implementation of the function and method ParseGlob.\n+func parseGlob(t *Template, pattern string) (*Template, error) {\n \tfilenames, err := filepath.Glob(pattern)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tif len(filenames) == 0 {\n-\t\treturn nil, fmt.Errorf(\"pattern matches no files: %#q\", pattern)\n-\t}\n-\tfor _, filename := range filenames {\n-\t\tt, err := ParseFile(filename)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif err := set.add(t); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n \t}\n-\treturn set, nil\n+\treturn parseFiles(t, filenames...)\n }"}, {"sha": "7b35d2633d5786953fed16142593694de282ecc0", "filename": "libgo/go/text/template/multi_test.go", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,288 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package template\n+\n+// Tests for mulitple-template parsing and execution.\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"testing\"\n+\t\"text/template/parse\"\n+)\n+\n+type isEmptyTest struct {\n+\tname  string\n+\tinput string\n+\tempty bool\n+}\n+\n+var isEmptyTests = []isEmptyTest{\n+\t{\"empty\", ``, true},\n+\t{\"nonempty\", `hello`, false},\n+\t{\"spaces only\", \" \\t\\n \\t\\n\", true},\n+\t{\"definition\", `{{define \"x\"}}something{{end}}`, true},\n+\t{\"definitions and space\", \"{{define `x`}}something{{end}}\\n\\n{{define `y`}}something{{end}}\\n\\n\", true},\n+\t{\"definitions and text\", \"{{define `x`}}something{{end}}\\nx\\n{{define `y`}}something{{end}}\\ny\\n}}\", false},\n+\t{\"definition and action\", \"{{define `x`}}something{{end}}{{if 3}}foo{{end}}\", false},\n+}\n+\n+func TestIsEmpty(t *testing.T) {\n+\tfor _, test := range isEmptyTests {\n+\t\ttemplate, err := New(\"root\").Parse(test.input)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif empty := isEmpty(template.Root); empty != test.empty {\n+\t\t\tt.Errorf(\"%q: expected %t got %t\", test.name, test.empty, empty)\n+\t\t}\n+\t}\n+}\n+\n+const (\n+\tnoError  = true\n+\thasError = false\n+)\n+\n+type multiParseTest struct {\n+\tname    string\n+\tinput   string\n+\tok      bool\n+\tnames   []string\n+\tresults []string\n+}\n+\n+var multiParseTests = []multiParseTest{\n+\t{\"empty\", \"\", noError,\n+\t\tnil,\n+\t\tnil},\n+\t{\"one\", `{{define \"foo\"}} FOO {{end}}`, noError,\n+\t\t[]string{\"foo\"},\n+\t\t[]string{`[(text: \" FOO \")]`}},\n+\t{\"two\", `{{define \"foo\"}} FOO {{end}}{{define \"bar\"}} BAR {{end}}`, noError,\n+\t\t[]string{\"foo\", \"bar\"},\n+\t\t[]string{`[(text: \" FOO \")]`, `[(text: \" BAR \")]`}},\n+\t// errors\n+\t{\"missing end\", `{{define \"foo\"}} FOO `, hasError,\n+\t\tnil,\n+\t\tnil},\n+\t{\"malformed name\", `{{define \"foo}} FOO `, hasError,\n+\t\tnil,\n+\t\tnil},\n+}\n+\n+func TestMultiParse(t *testing.T) {\n+\tfor _, test := range multiParseTests {\n+\t\ttemplate, err := New(\"root\").Parse(test.input)\n+\t\tswitch {\n+\t\tcase err == nil && !test.ok:\n+\t\t\tt.Errorf(\"%q: expected error; got none\", test.name)\n+\t\t\tcontinue\n+\t\tcase err != nil && test.ok:\n+\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n+\t\t\tcontinue\n+\t\tcase err != nil && !test.ok:\n+\t\t\t// expected error, got one\n+\t\t\tif *debug {\n+\t\t\t\tfmt.Printf(\"%s: %s\\n\\t%s\\n\", test.name, test.input, err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif template == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(template.tmpl) != len(test.names)+1 { // +1 for root\n+\t\t\tt.Errorf(\"%s: wrong number of templates; wanted %d got %d\", test.name, len(test.names), len(template.tmpl))\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor i, name := range test.names {\n+\t\t\ttmpl, ok := template.tmpl[name]\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"%s: can't find template %q\", test.name, name)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tresult := tmpl.Root.String()\n+\t\t\tif result != test.results[i] {\n+\t\t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.results[i])\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var multiExecTests = []execTest{\n+\t{\"empty\", \"\", \"\", nil, true},\n+\t{\"text\", \"some text\", \"some text\", nil, true},\n+\t{\"invoke x\", `{{template \"x\" .SI}}`, \"TEXT\", tVal, true},\n+\t{\"invoke x no args\", `{{template \"x\"}}`, \"TEXT\", tVal, true},\n+\t{\"invoke dot int\", `{{template \"dot\" .I}}`, \"17\", tVal, true},\n+\t{\"invoke dot []int\", `{{template \"dot\" .SI}}`, \"[3 4 5]\", tVal, true},\n+\t{\"invoke dotV\", `{{template \"dotV\" .U}}`, \"v\", tVal, true},\n+\t{\"invoke nested int\", `{{template \"nested\" .I}}`, \"17\", tVal, true},\n+\t{\"variable declared by template\", `{{template \"nested\" $x=.SI}},{{index $x 1}}`, \"[3 4 5],4\", tVal, true},\n+\n+\t// User-defined function: test argument evaluator.\n+\t{\"testFunc literal\", `{{oneArg \"joe\"}}`, \"oneArg=joe\", tVal, true},\n+\t{\"testFunc .\", `{{oneArg .}}`, \"oneArg=joe\", \"joe\", true},\n+}\n+\n+// These strings are also in testdata/*.\n+const multiText1 = `\n+\t{{define \"x\"}}TEXT{{end}}\n+\t{{define \"dotV\"}}{{.V}}{{end}}\n+`\n+\n+const multiText2 = `\n+\t{{define \"dot\"}}{{.}}{{end}}\n+\t{{define \"nested\"}}{{template \"dot\" .}}{{end}}\n+`\n+\n+func TestMultiExecute(t *testing.T) {\n+\t// Declare a couple of templates first.\n+\ttemplate, err := New(\"root\").Parse(multiText1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"parse error for 1: %s\", err)\n+\t}\n+\t_, err = template.Parse(multiText2)\n+\tif err != nil {\n+\t\tt.Fatalf(\"parse error for 2: %s\", err)\n+\t}\n+\ttestExecute(multiExecTests, template, t)\n+}\n+\n+func TestParseFiles(t *testing.T) {\n+\t_, err := ParseFiles(\"DOES NOT EXIST\")\n+\tif err == nil {\n+\t\tt.Error(\"expected error for non-existent file; got none\")\n+\t}\n+\ttemplate := New(\"root\")\n+\t_, err = template.ParseFiles(\"testdata/file1.tmpl\", \"testdata/file2.tmpl\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"error parsing files: %v\", err)\n+\t}\n+\ttestExecute(multiExecTests, template, t)\n+}\n+\n+func TestParseGlob(t *testing.T) {\n+\t_, err := ParseGlob(\"DOES NOT EXIST\")\n+\tif err == nil {\n+\t\tt.Error(\"expected error for non-existent file; got none\")\n+\t}\n+\t_, err = New(\"error\").ParseGlob(\"[x\")\n+\tif err == nil {\n+\t\tt.Error(\"expected error for bad pattern; got none\")\n+\t}\n+\ttemplate := New(\"root\")\n+\t_, err = template.ParseGlob(\"testdata/file*.tmpl\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"error parsing files: %v\", err)\n+\t}\n+\ttestExecute(multiExecTests, template, t)\n+}\n+\n+// In these tests, actual content (not just template definitions) comes from the parsed files.\n+\n+var templateFileExecTests = []execTest{\n+\t{\"test\", `{{template \"tmpl1.tmpl\"}}{{template \"tmpl2.tmpl\"}}`, \"template1\\n\\ny\\ntemplate2\\n\\nx\\n\", 0, true},\n+}\n+\n+func TestParseFilesWithData(t *testing.T) {\n+\ttemplate, err := New(\"root\").ParseFiles(\"testdata/tmpl1.tmpl\", \"testdata/tmpl2.tmpl\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"error parsing files: %v\", err)\n+\t}\n+\ttestExecute(templateFileExecTests, template, t)\n+}\n+\n+func TestParseGlobWithData(t *testing.T) {\n+\ttemplate, err := New(\"root\").ParseGlob(\"testdata/tmpl*.tmpl\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"error parsing files: %v\", err)\n+\t}\n+\ttestExecute(templateFileExecTests, template, t)\n+}\n+\n+const (\n+\tcloneText1 = `{{define \"a\"}}{{template \"b\"}}{{template \"c\"}}{{end}}`\n+\tcloneText2 = `{{define \"b\"}}b{{end}}`\n+\tcloneText3 = `{{define \"c\"}}root{{end}}`\n+\tcloneText4 = `{{define \"c\"}}clone{{end}}`\n+)\n+\n+func TestClone(t *testing.T) {\n+\t// Create some templates and clone the root.\n+\troot, err := New(\"root\").Parse(cloneText1)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = root.Parse(cloneText2)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tclone := root.Clone()\n+\t// Add variants to both.\n+\t_, err = root.Parse(cloneText3)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = clone.Parse(cloneText4)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Verify that the clone is self-consistent.\n+\tfor k, v := range clone.tmpl {\n+\t\tif k == clone.name && v.tmpl[k] != clone {\n+\t\t\tt.Error(\"clone does not contain root\")\n+\t\t}\n+\t\tif v != v.tmpl[v.name] {\n+\t\t\tt.Errorf(\"clone does not contain self for %q\", k)\n+\t\t}\n+\t}\n+\t// Execute root.\n+\tvar b bytes.Buffer\n+\terr = root.ExecuteTemplate(&b, \"a\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif b.String() != \"broot\" {\n+\t\tt.Errorf(\"expected %q got %q\", \"broot\", b.String())\n+\t}\n+\t// Execute copy.\n+\tb.Reset()\n+\terr = clone.ExecuteTemplate(&b, \"a\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif b.String() != \"bclone\" {\n+\t\tt.Errorf(\"expected %q got %q\", \"bclone\", b.String())\n+\t}\n+}\n+\n+func TestAddParseTree(t *testing.T) {\n+\t// Create some templates.\n+\troot, err := New(\"root\").Parse(cloneText1)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = root.Parse(cloneText2)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// Add a new parse tree.\n+\ttree, err := parse.Parse(\"cloneText3\", cloneText3, \"\", \"\", nil, builtins)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tadded, err := root.AddParseTree(\"c\", tree[\"c\"])\n+\t// Execute.\n+\tvar b bytes.Buffer\n+\terr = added.ExecuteTemplate(&b, \"a\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif b.String() != \"broot\" {\n+\t\tt.Errorf(\"expected %q got %q\", \"broot\", b.String())\n+\t}\n+}"}, {"sha": "7075f2ac20e61d0d016da087cb17f3f683088b21", "filename": "libgo/go/text/template/parse.go", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package template\n-\n-import (\n-\t\"reflect\"\n-\t\"text/template/parse\"\n-)\n-\n-// Template is the representation of a parsed template.\n-type Template struct {\n-\tname string\n-\t*parse.Tree\n-\tleftDelim  string\n-\trightDelim string\n-\t// We use two maps, one for parsing and one for execution.\n-\t// This separation makes the API cleaner since it doesn't\n-\t// expose reflection to the client.\n-\tparseFuncs FuncMap\n-\texecFuncs  map[string]reflect.Value\n-\tset        *Set // can be nil.\n-}\n-\n-// Name returns the name of the template.\n-func (t *Template) Name() string {\n-\treturn t.name\n-}\n-\n-// Parsing.\n-\n-// New allocates a new template with the given name.\n-func New(name string) *Template {\n-\treturn &Template{\n-\t\tname:       name,\n-\t\tparseFuncs: make(FuncMap),\n-\t\texecFuncs:  make(map[string]reflect.Value),\n-\t}\n-}\n-\n-// Delims sets the action delimiters, to be used in a subsequent\n-// parse, to the specified strings.\n-// An empty delimiter stands for the corresponding default: {{ or }}.\n-// The return value is the template, so calls can be chained.\n-func (t *Template) Delims(left, right string) *Template {\n-\tt.leftDelim = left\n-\tt.rightDelim = right\n-\treturn t\n-}\n-\n-// Funcs adds the elements of the argument map to the template's function\n-// map.  It panics if a value in the map is not a function with appropriate\n-// return type.\n-// The return value is the template, so calls can be chained.\n-func (t *Template) Funcs(funcMap FuncMap) *Template {\n-\taddValueFuncs(t.execFuncs, funcMap)\n-\taddFuncs(t.parseFuncs, funcMap)\n-\treturn t\n-}\n-\n-// Parse parses the template definition string to construct an internal\n-// representation of the template for execution.\n-func (t *Template) Parse(s string) (tmpl *Template, err error) {\n-\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, nil, t.parseFuncs, builtins)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn t, nil\n-}\n-\n-// ParseInSet parses the template definition string to construct an internal\n-// representation of the template for execution. It also adds the template\n-// to the set, which must not be nil. It is an error if s is already defined in the set.\n-// Function bindings are checked against those in the set.\n-func (t *Template) ParseInSet(s string, set *Set) (tmpl *Template, err error) {\n-\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, set.trees, t.parseFuncs, set.parseFuncs, builtins)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\terr = set.add(t)\n-\treturn t, err\n-}"}, {"sha": "346f613b048398e8bda870c62a6998a73085c45b", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -13,10 +13,10 @@ import (\n \t\"unicode\"\n )\n \n-// Tree is the representation of a parsed template.\n+// Tree is the representation of a single parsed template.\n type Tree struct {\n-\tName string    // Name is the name of the template.\n-\tRoot *ListNode // Root is the top-level root of the parse tree.\n+\tName string    // name of the template represented by the tree.\n+\tRoot *ListNode // top-level root of the tree.\n \t// Parsing only; cleared after parse.\n \tfuncs     []map[string]interface{}\n \tlex       *lexer\n@@ -25,6 +25,16 @@ type Tree struct {\n \tvars      []string // variables defined at the moment.\n }\n \n+// Parse returns a map from template name to parse.Tree, created by parsing the\n+// templates described in the argument string. The top-level template will be\n+// given the specified name. If an error is encountered, parsing stops and an\n+// empty map is returned with the error.\n+func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (treeSet map[string]*Tree, err error) {\n+\ttreeSet = make(map[string]*Tree)\n+\t_, err = New(name).Parse(text, leftDelim, rightDelim, treeSet, funcs...)\n+\treturn\n+}\n+\n // next returns the next token.\n func (t *Tree) next() item {\n \tif t.peekCount > 0 {\n@@ -58,7 +68,7 @@ func (t *Tree) peek() item {\n \n // Parsing.\n \n-// New allocates a new template with the given name.\n+// New allocates a new parse tree with the given name.\n func New(name string, funcs ...map[string]interface{}) *Tree {\n \treturn &Tree{\n \t\tName:  name,\n@@ -87,6 +97,15 @@ func (t *Tree) expect(expected itemType, context string) item {\n \treturn token\n }\n \n+// expectEither consumes the next token and guarantees it has one of the required types.\n+func (t *Tree) expectOneOf(expected1, expected2 itemType, context string) item {\n+\ttoken := t.next()\n+\tif token.typ != expected1 && token.typ != expected2 {\n+\t\tt.errorf(\"expected %s or %s in %s; got %s\", expected1, expected2, context, token)\n+\t}\n+\treturn token\n+}\n+\n // unexpected complains about the token and terminates processing.\n func (t *Tree) unexpected(token item, context string) {\n \tt.errorf(\"unexpected %s in %s\", token, context)\n@@ -107,7 +126,7 @@ func (t *Tree) recover(errp *error) {\n \treturn\n }\n \n-// startParse starts the template parsing from the lexer.\n+// startParse initializes the parser, using the lexer.\n func (t *Tree) startParse(funcs []map[string]interface{}, lex *lexer) {\n \tt.Root = nil\n \tt.lex = lex\n@@ -143,17 +162,27 @@ func (t *Tree) atEOF() bool {\n \treturn false\n }\n \n-// Parse parses the template definition string to construct an internal\n-// representation of the template for execution. If either action delimiter\n-// string is empty, the default (\"{{\" or \"}}\") is used.\n+// Parse parses the template definition string to construct a representation of\n+// the template for execution. If either action delimiter string is empty, the\n+// default (\"{{\" or \"}}\") is used. Embedded template definitions are added to\n+// the treeSet map.\n func (t *Tree) Parse(s, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error) {\n \tdefer t.recover(&err)\n \tt.startParse(funcs, lex(t.Name, s, leftDelim, rightDelim))\n \tt.parse(treeSet)\n+\tt.add(treeSet)\n \tt.stopParse()\n \treturn t, nil\n }\n \n+// add adds tree to the treeSet.\n+func (t *Tree) add(treeSet map[string]*Tree) {\n+\tif _, present := treeSet[t.Name]; present {\n+\t\tt.errorf(\"template: multiple definition of template %q\", t.Name)\n+\t}\n+\ttreeSet[t.Name] = t\n+}\n+\n // parse is the top-level parser for a template, essentially the same\n // as itemList except it also parses {{define}} actions.\n // It runs to EOF.\n@@ -163,7 +192,7 @@ func (t *Tree) parse(treeSet map[string]*Tree) (next Node) {\n \t\tif t.peek().typ == itemLeftDelim {\n \t\t\tdelim := t.next()\n \t\t\tif t.next().typ == itemDefine {\n-\t\t\t\tnewT := New(\"new definition\") // name will be updated once we know it.\n+\t\t\t\tnewT := New(\"definition\") // name will be updated once we know it.\n \t\t\t\tnewT.startParse(t.funcs, t.lex)\n \t\t\t\tnewT.parseDefinition(treeSet)\n \t\t\t\tcontinue\n@@ -183,11 +212,8 @@ func (t *Tree) parse(treeSet map[string]*Tree) (next Node) {\n // installs the definition in the treeSet map.  The \"define\" keyword has already\n // been scanned.\n func (t *Tree) parseDefinition(treeSet map[string]*Tree) {\n-\tif treeSet == nil {\n-\t\tt.errorf(\"no set specified for template definition\")\n-\t}\n \tconst context = \"define clause\"\n-\tname := t.expect(itemString, context)\n+\tname := t.expectOneOf(itemString, itemRawString, context)\n \tvar err error\n \tt.Name, err = strconv.Unquote(name.val)\n \tif err != nil {\n@@ -200,10 +226,7 @@ func (t *Tree) parseDefinition(treeSet map[string]*Tree) {\n \t\tt.errorf(\"unexpected %s in %s\", end, context)\n \t}\n \tt.stopParse()\n-\tif _, present := treeSet[t.Name]; present {\n-\t\tt.errorf(\"template: %q multiply defined\", name)\n-\t}\n-\ttreeSet[t.Name] = t\n+\tt.add(treeSet)\n }\n \n // itemList:"}, {"sha": "fc93455ecbc1fbc1781356745ba857e478d82dec", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -236,7 +236,7 @@ var builtins = map[string]interface{}{\n \n func TestParse(t *testing.T) {\n \tfor _, test := range parseTests {\n-\t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", nil, builtins)\n+\t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", make(map[string]*Tree), builtins)\n \t\tswitch {\n \t\tcase err == nil && !test.ok:\n \t\t\tt.Errorf(\"%q: expected error; got none\", test.name)"}, {"sha": "55f3ceb3d515ae432424f73df428238e058e823e", "filename": "libgo/go/text/template/parse/set.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package parse\n-\n-// Set returns a slice of Trees created by parsing the template set\n-// definition in the argument string. If an error is encountered,\n-// parsing stops and an empty slice is returned with the error.\n-func Set(text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (tree map[string]*Tree, err error) {\n-\ttree = make(map[string]*Tree)\n-\t// Top-level template name is needed but unused. TODO: clean this up.\n-\t_, err = New(\"ROOT\").Parse(text, leftDelim, rightDelim, tree, funcs...)\n-\treturn\n-}"}, {"sha": "48417044e7755799bd92e8439357bc18f3f0cbcf", "filename": "libgo/go/text/template/set.go", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,121 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package template\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"reflect\"\n-\t\"text/template/parse\"\n-)\n-\n-// Set holds a set of related templates that can refer to one another by name.\n-// The zero value represents an empty set.\n-// A template may be a member of multiple sets.\n-type Set struct {\n-\ttmpl       map[string]*Template\n-\ttrees      map[string]*parse.Tree // maintained by parse package\n-\tleftDelim  string\n-\trightDelim string\n-\tparseFuncs FuncMap\n-\texecFuncs  map[string]reflect.Value\n-}\n-\n-func (s *Set) init() {\n-\tif s.tmpl == nil {\n-\t\ts.tmpl = make(map[string]*Template)\n-\t\ts.parseFuncs = make(FuncMap)\n-\t\ts.execFuncs = make(map[string]reflect.Value)\n-\t}\n-}\n-\n-// Delims sets the action delimiters, to be used in a subsequent\n-// parse, to the specified strings.\n-// An empty delimiter stands for the corresponding default: {{ or }}.\n-// The return value is the set, so calls can be chained.\n-func (s *Set) Delims(left, right string) *Set {\n-\ts.leftDelim = left\n-\ts.rightDelim = right\n-\treturn s\n-}\n-\n-// Funcs adds the elements of the argument map to the set's function map.  It\n-// panics if a value in the map is not a function with appropriate return\n-// type.\n-// The return value is the set, so calls can be chained.\n-func (s *Set) Funcs(funcMap FuncMap) *Set {\n-\ts.init()\n-\taddValueFuncs(s.execFuncs, funcMap)\n-\taddFuncs(s.parseFuncs, funcMap)\n-\treturn s\n-}\n-\n-// Add adds the argument templates to the set. It panics if two templates\n-// with the same name are added or if a template is already a member of\n-// a set.\n-// The return value is the set, so calls can be chained.\n-func (s *Set) Add(templates ...*Template) *Set {\n-\tfor _, t := range templates {\n-\t\tif err := s.add(t); err != nil {\n-\t\t\tpanic(err)\n-\t\t}\n-\t}\n-\treturn s\n-}\n-\n-// add adds the argument template to the set.\n-func (s *Set) add(t *Template) error {\n-\ts.init()\n-\tif t.set != nil {\n-\t\treturn fmt.Errorf(\"template: %q already in a set\", t.name)\n-\t}\n-\tif _, ok := s.tmpl[t.name]; ok {\n-\t\treturn fmt.Errorf(\"template: %q already defined in set\", t.name)\n-\t}\n-\ts.tmpl[t.name] = t\n-\tt.set = s\n-\treturn nil\n-}\n-\n-// Template returns the template with the given name in the set,\n-// or nil if there is no such template.\n-func (s *Set) Template(name string) *Template {\n-\treturn s.tmpl[name]\n-}\n-\n-// FuncMap returns the set's function map.\n-func (s *Set) FuncMap() FuncMap {\n-\treturn s.parseFuncs\n-}\n-\n-// Execute applies the named template to the specified data object, writing\n-// the output to wr.\n-func (s *Set) Execute(wr io.Writer, name string, data interface{}) error {\n-\ttmpl := s.tmpl[name]\n-\tif tmpl == nil {\n-\t\treturn fmt.Errorf(\"template: no template %q in set\", name)\n-\t}\n-\treturn tmpl.Execute(wr, data)\n-}\n-\n-// Parse parses a string into a set of named templates.  Parse may be called\n-// multiple times for a given set, adding the templates defined in the string\n-// to the set.  It is an error if a template has a name already defined in the set.\n-func (s *Set) Parse(text string) (*Set, error) {\n-\ttrees, err := parse.Set(text, s.leftDelim, s.rightDelim, s.parseFuncs, builtins)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\ts.init()\n-\tfor name, tree := range trees {\n-\t\ttmpl := New(name)\n-\t\ttmpl.Tree = tree\n-\t\terr = s.add(tmpl)\n-\t\tif err != nil {\n-\t\t\treturn s, err\n-\t\t}\n-\t}\n-\treturn s, nil\n-}"}, {"sha": "f437bc779c2c53f9c8c3392b9872cb0eeb388b86", "filename": "libgo/go/text/template/set_test.go", "status": "removed", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fset_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftext%2Ftemplate%2Fset_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fset_test.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,239 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package template\n-\n-import (\n-\t\"fmt\"\n-\t\"testing\"\n-)\n-\n-const (\n-\tnoError  = true\n-\thasError = false\n-)\n-\n-type setParseTest struct {\n-\tname    string\n-\tinput   string\n-\tok      bool\n-\tnames   []string\n-\tresults []string\n-}\n-\n-var setParseTests = []setParseTest{\n-\t{\"empty\", \"\", noError,\n-\t\tnil,\n-\t\tnil},\n-\t{\"one\", `{{define \"foo\"}} FOO {{end}}`, noError,\n-\t\t[]string{\"foo\"},\n-\t\t[]string{`[(text: \" FOO \")]`}},\n-\t{\"two\", `{{define \"foo\"}} FOO {{end}}{{define \"bar\"}} BAR {{end}}`, noError,\n-\t\t[]string{\"foo\", \"bar\"},\n-\t\t[]string{`[(text: \" FOO \")]`, `[(text: \" BAR \")]`}},\n-\t// errors\n-\t{\"missing end\", `{{define \"foo\"}} FOO `, hasError,\n-\t\tnil,\n-\t\tnil},\n-\t{\"malformed name\", `{{define \"foo}} FOO `, hasError,\n-\t\tnil,\n-\t\tnil},\n-}\n-\n-func TestSetParse(t *testing.T) {\n-\tfor _, test := range setParseTests {\n-\t\tset, err := new(Set).Parse(test.input)\n-\t\tswitch {\n-\t\tcase err == nil && !test.ok:\n-\t\t\tt.Errorf(\"%q: expected error; got none\", test.name)\n-\t\t\tcontinue\n-\t\tcase err != nil && test.ok:\n-\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n-\t\t\tcontinue\n-\t\tcase err != nil && !test.ok:\n-\t\t\t// expected error, got one\n-\t\t\tif *debug {\n-\t\t\t\tfmt.Printf(\"%s: %s\\n\\t%s\\n\", test.name, test.input, err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif set == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif len(set.tmpl) != len(test.names) {\n-\t\t\tt.Errorf(\"%s: wrong number of templates; wanted %d got %d\", test.name, len(test.names), len(set.tmpl))\n-\t\t\tcontinue\n-\t\t}\n-\t\tfor i, name := range test.names {\n-\t\t\ttmpl, ok := set.tmpl[name]\n-\t\t\tif !ok {\n-\t\t\t\tt.Errorf(\"%s: can't find template %q\", test.name, name)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tresult := tmpl.Root.String()\n-\t\t\tif result != test.results[i] {\n-\t\t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.results[i])\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var setExecTests = []execTest{\n-\t{\"empty\", \"\", \"\", nil, true},\n-\t{\"text\", \"some text\", \"some text\", nil, true},\n-\t{\"invoke x\", `{{template \"x\" .SI}}`, \"TEXT\", tVal, true},\n-\t{\"invoke x no args\", `{{template \"x\"}}`, \"TEXT\", tVal, true},\n-\t{\"invoke dot int\", `{{template \"dot\" .I}}`, \"17\", tVal, true},\n-\t{\"invoke dot []int\", `{{template \"dot\" .SI}}`, \"[3 4 5]\", tVal, true},\n-\t{\"invoke dotV\", `{{template \"dotV\" .U}}`, \"v\", tVal, true},\n-\t{\"invoke nested int\", `{{template \"nested\" .I}}`, \"17\", tVal, true},\n-\t{\"variable declared by template\", `{{template \"nested\" $x=.SI}},{{index $x 1}}`, \"[3 4 5],4\", tVal, true},\n-\n-\t// User-defined function: test argument evaluator.\n-\t{\"testFunc literal\", `{{oneArg \"joe\"}}`, \"oneArg=joe\", tVal, true},\n-\t{\"testFunc .\", `{{oneArg .}}`, \"oneArg=joe\", \"joe\", true},\n-}\n-\n-// These strings are also in testdata/*.\n-const setText1 = `\n-\t{{define \"x\"}}TEXT{{end}}\n-\t{{define \"dotV\"}}{{.V}}{{end}}\n-`\n-\n-const setText2 = `\n-\t{{define \"dot\"}}{{.}}{{end}}\n-\t{{define \"nested\"}}{{template \"dot\" .}}{{end}}\n-`\n-\n-func TestSetExecute(t *testing.T) {\n-\t// Declare a set with a couple of templates first.\n-\tset := new(Set)\n-\t_, err := set.Parse(setText1)\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing set: %s\", err)\n-\t}\n-\t_, err = set.Parse(setText2)\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing set: %s\", err)\n-\t}\n-\ttestExecute(setExecTests, set, t)\n-}\n-\n-func TestSetParseFiles(t *testing.T) {\n-\tset := new(Set)\n-\t_, err := set.ParseFiles(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\t_, err = set.ParseFiles(\"testdata/file1.tmpl\", \"testdata/file2.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(setExecTests, set, t)\n-}\n-\n-func TestParseSetFiles(t *testing.T) {\n-\tset := new(Set)\n-\t_, err := ParseSetFiles(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\tset, err = ParseSetFiles(\"testdata/file1.tmpl\", \"testdata/file2.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(setExecTests, set, t)\n-}\n-\n-func TestSetParseGlob(t *testing.T) {\n-\t_, err := new(Set).ParseGlob(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\t_, err = new(Set).ParseGlob(\"[x\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for bad pattern; got none\")\n-\t}\n-\tset, err := new(Set).ParseGlob(\"testdata/file*.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(setExecTests, set, t)\n-}\n-\n-func TestParseSetGlob(t *testing.T) {\n-\t_, err := ParseSetGlob(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\t_, err = ParseSetGlob(\"[x\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for bad pattern; got none\")\n-\t}\n-\tset, err := ParseSetGlob(\"testdata/file*.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(setExecTests, set, t)\n-}\n-\n-var templateFileExecTests = []execTest{\n-\t{\"test\", `{{template \"tmpl1.tmpl\"}}{{template \"tmpl2.tmpl\"}}`, \"template1\\ntemplate2\\n\", 0, true},\n-}\n-\n-func TestSetParseTemplateFiles(t *testing.T) {\n-\t_, err := ParseTemplateFiles(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\tset, err := new(Set).ParseTemplateFiles(\"testdata/tmpl1.tmpl\", \"testdata/tmpl2.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(templateFileExecTests, set, t)\n-}\n-\n-func TestParseTemplateFiles(t *testing.T) {\n-\t_, err := ParseTemplateFiles(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\tset, err := new(Set).ParseTemplateFiles(\"testdata/tmpl1.tmpl\", \"testdata/tmpl2.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(templateFileExecTests, set, t)\n-}\n-\n-func TestSetParseTemplateGlob(t *testing.T) {\n-\t_, err := ParseTemplateGlob(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\t_, err = new(Set).ParseTemplateGlob(\"[x\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for bad pattern; got none\")\n-\t}\n-\tset, err := new(Set).ParseTemplateGlob(\"testdata/tmpl*.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(templateFileExecTests, set, t)\n-}\n-\n-func TestParseTemplateGlob(t *testing.T) {\n-\t_, err := ParseTemplateGlob(\"DOES NOT EXIST\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for non-existent file; got none\")\n-\t}\n-\t_, err = ParseTemplateGlob(\"[x\")\n-\tif err == nil {\n-\t\tt.Error(\"expected error for bad pattern; got none\")\n-\t}\n-\tset, err := ParseTemplateGlob(\"testdata/tmpl*.tmpl\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"error parsing files: %v\", err)\n-\t}\n-\ttestExecute(templateFileExecTests, set, t)\n-}"}, {"sha": "04fca407c10783b2469d4246edfc66391289589d", "filename": "libgo/go/text/template/template.go", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,236 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package template\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"text/template/parse\"\n+)\n+\n+// common holds the information shared by related templates.\n+type common struct {\n+\ttmpl map[string]*Template\n+\t// We use two maps, one for parsing and one for execution.\n+\t// This separation makes the API cleaner since it doesn't\n+\t// expose reflection to the client.\n+\tparseFuncs FuncMap\n+\texecFuncs  map[string]reflect.Value\n+}\n+\n+// Template is the representation of a parsed template. The *parse.Tree\n+// field is exported only for use by html/template and should be treated\n+// as unexported by all other clients.\n+type Template struct {\n+\tname string\n+\t*parse.Tree\n+\t*common\n+\tleftDelim  string\n+\trightDelim string\n+}\n+\n+// New allocates a new template with the given name.\n+func New(name string) *Template {\n+\treturn &Template{\n+\t\tname: name,\n+\t}\n+}\n+\n+// Name returns the name of the template.\n+func (t *Template) Name() string {\n+\treturn t.name\n+}\n+\n+// New allocates a new template associated with the given one and with the same\n+// delimiters. The association, which is transitive, allows one template to\n+// invoke another with a {{template}} action.\n+func (t *Template) New(name string) *Template {\n+\tt.init()\n+\treturn &Template{\n+\t\tname:       name,\n+\t\tcommon:     t.common,\n+\t\tleftDelim:  t.leftDelim,\n+\t\trightDelim: t.rightDelim,\n+\t}\n+}\n+\n+func (t *Template) init() {\n+\tif t.common == nil {\n+\t\tt.common = new(common)\n+\t\tt.tmpl = make(map[string]*Template)\n+\t\tt.parseFuncs = make(FuncMap)\n+\t\tt.execFuncs = make(map[string]reflect.Value)\n+\t}\n+}\n+\n+// Clone returns a duplicate of the template, including all associated\n+// templates. The actual representation is not copied, but the name space of\n+// associated templates is, so further calls to Parse in the copy will add\n+// templates to the copy but not to the original. Clone can be used to prepare\n+// common templates and use them with variant definitions for other templates by\n+// adding the variants after the clone is made.\n+func (t *Template) Clone() *Template {\n+\tnt := t.copy(nil)\n+\tnt.init()\n+\tnt.tmpl[t.name] = nt\n+\tfor k, v := range t.tmpl {\n+\t\tif k == t.name { // Already installed.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// The associated templates share nt's common structure.\n+\t\ttmpl := v.copy(nt.common)\n+\t\tnt.tmpl[k] = tmpl\n+\t}\n+\tfor k, v := range t.parseFuncs {\n+\t\tnt.parseFuncs[k] = v\n+\t}\n+\tfor k, v := range t.execFuncs {\n+\t\tnt.execFuncs[k] = v\n+\t}\n+\treturn nt\n+}\n+\n+// copy returns a shallow copy of t, with common set to the argument.\n+func (t *Template) copy(c *common) *Template {\n+\tnt := New(t.name)\n+\tnt.Tree = t.Tree\n+\tnt.common = c\n+\tnt.leftDelim = t.leftDelim\n+\tnt.rightDelim = t.rightDelim\n+\treturn nt\n+}\n+\n+// AddParseTree creates a new template with the name and parse tree\n+// and associates it with t.\n+func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error) {\n+\tif t.tmpl[name] != nil {\n+\t\treturn nil, fmt.Errorf(\"template: redefinition of template %q\", name)\n+\t}\n+\tnt := t.New(name)\n+\tnt.Tree = tree\n+\tt.tmpl[name] = nt\n+\treturn nt, nil\n+}\n+\n+// Templates returns a slice of the templates associated with t, including t\n+// itself.\n+func (t *Template) Templates() []*Template {\n+\t// Return a slice so we don't expose the map.\n+\tm := make([]*Template, 0, len(t.tmpl))\n+\tfor _, v := range t.tmpl {\n+\t\tm = append(m, v)\n+\t}\n+\treturn m\n+}\n+\n+// Delims sets the action delimiters to the specified strings, to be used in\n+// subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template\n+// definitions will inherit the settings. An empty delimiter stands for the\n+// corresponding default: {{ or }}.\n+// The return value is the template, so calls can be chained.\n+func (t *Template) Delims(left, right string) *Template {\n+\tt.leftDelim = left\n+\tt.rightDelim = right\n+\treturn t\n+}\n+\n+// Funcs adds the elements of the argument map to the template's function map.\n+// It panics if a value in the map is not a function with appropriate return\n+// type. However, it is legal to overwrite elements of the map. The return\n+// value is the template, so calls can be chained.\n+func (t *Template) Funcs(funcMap FuncMap) *Template {\n+\tt.init()\n+\taddValueFuncs(t.execFuncs, funcMap)\n+\taddFuncs(t.parseFuncs, funcMap)\n+\treturn t\n+}\n+\n+// Lookup returns the template with the given name that is associated with t,\n+// or nil if there is no such template.\n+func (t *Template) Lookup(name string) *Template {\n+\tif t.common == nil {\n+\t\treturn nil\n+\t}\n+\treturn t.tmpl[name]\n+}\n+\n+// Parse parses a string into a template. Nested template definitions will be\n+// associated with the top-level template t. Parse may be called multiple times\n+// to parse definitions of templates to associate with t. It is an error if a\n+// resulting template is non-empty (contains content other than template\n+// definitions) and would replace a non-empty template with the same name.\n+// (In multiple calls to Parse with the same receiver template, only one call\n+// can contain text other than space, comments, and template definitions.)\n+func (t *Template) Parse(text string) (*Template, error) {\n+\tt.init()\n+\ttrees, err := parse.Parse(t.name, text, t.leftDelim, t.rightDelim, t.parseFuncs, builtins)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// Add the newly parsed trees, including the one for t, into our common structure.\n+\tfor name, tree := range trees {\n+\t\t// If the name we parsed is the name of this template, overwrite this template.\n+\t\t// The associate method checks it's not a redefinition.\n+\t\ttmpl := t\n+\t\tif name != t.name {\n+\t\t\ttmpl = t.New(name)\n+\t\t}\n+\t\t// Even if t == tmpl, we need to install it in the common.tmpl map.\n+\t\tif err := t.associate(tmpl); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttmpl.Tree = tree\n+\t\ttmpl.leftDelim = t.leftDelim\n+\t\ttmpl.rightDelim = t.rightDelim\n+\t}\n+\treturn t, nil\n+}\n+\n+// associate installs the new template into the group of templates associated\n+// with t. It is an error to reuse a name except to overwrite an empty\n+// template. The two are already known to share the common structure.\n+func (t *Template) associate(new *Template) error {\n+\tif new.common != t.common {\n+\t\tpanic(\"internal error: associate not common\")\n+\t}\n+\tname := new.name\n+\tif old := t.tmpl[name]; old != nil {\n+\t\toldIsEmpty := isEmpty(old.Root)\n+\t\tnewIsEmpty := isEmpty(new.Root)\n+\t\tif !oldIsEmpty && !newIsEmpty {\n+\t\t\treturn fmt.Errorf(\"template: redefinition of template %q\", name)\n+\t\t}\n+\t\tif newIsEmpty {\n+\t\t\t// Whether old is empty or not, new is empty; no reason to replace old.\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tt.tmpl[name] = new\n+\treturn nil\n+}\n+\n+// isEmpty reports whether this tree (node) is empty of everything but space.\n+func isEmpty(n parse.Node) bool {\n+\tswitch n := n.(type) {\n+\tcase *parse.ActionNode:\n+\tcase *parse.IfNode:\n+\tcase *parse.ListNode:\n+\t\tfor _, node := range n.Nodes {\n+\t\t\tif !isEmpty(node) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\tcase *parse.RangeNode:\n+\tcase *parse.TemplateNode:\n+\tcase *parse.TextNode:\n+\t\treturn len(bytes.TrimSpace(n.Text)) == 0\n+\tcase *parse.WithNode:\n+\tdefault:\n+\t\tpanic(\"unknown node: \" + n.String())\n+\t}\n+\treturn false\n+}"}, {"sha": "b72b3a340c7a2b9c36c69da7881357a2d7924040", "filename": "libgo/go/text/template/testdata/tmpl1.tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl1.tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl1.tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl1.tmpl?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1 +1,3 @@\n template1\n+{{define \"x\"}}x{{end}}\n+{{template \"y\"}}"}, {"sha": "16beba6e7ddc291ed5db32c210da29358b8a8d56", "filename": "libgo/go/text/template/testdata/tmpl2.tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl2.tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl2.tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftestdata%2Ftmpl2.tmpl?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1 +1,3 @@\n template2\n+{{define \"y\"}}y{{end}}\n+{{template \"x\"}}"}, {"sha": "153b1a3b660ed0f1ee548fa260b26423b9515b96", "filename": "libgo/go/time/example_test.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexample_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package time_test\n+\n+import (\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+func expensiveCall() {}\n+\n+func ExampleDuration() {\n+\tt0 := time.Now()\n+\texpensiveCall()\n+\tt1 := time.Now()\n+\tfmt.Printf(\"The call took %v to run.\\n\", t1.Sub(t0))\n+}\n+\n+var c chan int\n+\n+func handle(int) {}\n+\n+func ExampleAfter() {\n+\tselect {\n+\tcase m := <-c:\n+\t\thandle(m)\n+\tcase <-time.After(5 * time.Minute):\n+\t\tfmt.Println(\"timed out\")\n+\t}\n+}\n+\n+func ExampleSleep() {\n+\ttime.Sleep(100 * time.Millisecond)\n+}\n+\n+func statusUpdate() string { return \"\" }\n+\n+func ExampleTick() {\n+\tc := time.Tick(1 * time.Minute)\n+\tfor now := range c {\n+\t\tfmt.Printf(\"%v %s\\n\", now, statusUpdate())\n+\t}\n+}\n+\n+func ExampleMonth() {\n+\t_, month, day := time.Now().Date()\n+\tif month == time.November && day == 10 {\n+\t\tfmt.Println(\"Happy Go day!\")\n+\t}\n+}\n+\n+// Go launched at Tue Nov 10 15:00:00 -0800 PST 2009\n+func ExampleDate() {\n+\tt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n+\tfmt.Printf(\"Go launched at %s\\n\", t.Local())\n+}"}, {"sha": "082a51a1621ddac36123841b8c5e7e40eb8b6249", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 291, "deletions": 150, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -1,10 +1,6 @@\n package time\n \n-import (\n-\t\"bytes\"\n-\t\"errors\"\n-\t\"strconv\"\n-)\n+import \"errors\"\n \n const (\n \tnumeric = iota\n@@ -259,8 +255,60 @@ func lookup(tab []string, val string) (int, string, error) {\n \treturn -1, val, errBad\n }\n \n+// Duplicates functionality in strconv, but avoids dependency.\n+func itoa(x int) string {\n+\tvar buf [32]byte\n+\tn := len(buf)\n+\tif x == 0 {\n+\t\treturn \"0\"\n+\t}\n+\tu := uint(x)\n+\tif x < 0 {\n+\t\tu = -u\n+\t}\n+\tfor u > 0 {\n+\t\tn--\n+\t\tbuf[n] = byte(u%10 + '0')\n+\t\tu /= 10\n+\t}\n+\tif x < 0 {\n+\t\tn--\n+\t\tbuf[n] = '-'\n+\t}\n+\treturn string(buf[n:])\n+}\n+\n+// Never printed, just needs to be non-nil for return by atoi.\n+var atoiError = errors.New(\"time: invalid number\")\n+\n+// Duplicates functionality in strconv, but avoids dependency.\n+func atoi(s string) (x int, err error) {\n+\ti := 0\n+\tif len(s) > 0 && s[0] == '-' {\n+\t\ti++\n+\t}\n+\tif i >= len(s) {\n+\t\treturn 0, atoiError\n+\t}\n+\tfor ; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c < '0' || c > '9' {\n+\t\t\treturn 0, atoiError\n+\t\t}\n+\t\tif x >= (1<<31-10)/10 {\n+\t\t\t// will overflow\n+\t\t\treturn 0, atoiError\n+\t\t}\n+\t\tx = x*10 + int(c) - '0'\n+\t}\n+\tif s[0] == '-' {\n+\t\tx = -x\n+\t}\n+\treturn x, nil\n+}\n+\n func pad(i int, padding string) string {\n-\ts := strconv.Itoa(i)\n+\ts := itoa(i)\n \tif i < 10 {\n \t\ts = padding + s\n \t}\n@@ -273,7 +321,7 @@ func zeroPad(i int) string { return pad(i, \"0\") }\n func formatNano(nanosec, n int) string {\n \t// User might give us bad data. Make sure it's positive and in range.\n \t// They'll get nonsense output but it will have the right format.\n-\ts := strconv.Uitoa(uint(nanosec) % 1e9)\n+\ts := itoa(int(uint(nanosec) % 1e9))\n \t// Zero pad left without fmt.\n \tif len(s) < 9 {\n \t\ts = \"000000000\"[:9-len(s)] + s\n@@ -284,77 +332,135 @@ func formatNano(nanosec, n int) string {\n \treturn \".\" + s[:n]\n }\n \n+// String returns the time formatted using the format string\n+//\t\"Mon Jan _2 15:04:05 -0700 MST 2006\"\n+func (t Time) String() string {\n+\treturn t.Format(\"Mon Jan _2 15:04:05 -0700 MST 2006\")\n+}\n+\n+type buffer []byte\n+\n+func (b *buffer) WriteString(s string) {\n+\t*b = append(*b, s...)\n+}\n+\n+func (b *buffer) WriteByte(c byte) {\n+\t*b = append(*b, c)\n+}\n+\n+func (b *buffer) String() string {\n+\treturn string([]byte(*b))\n+}\n+\n // Format returns a textual representation of the time value formatted\n // according to layout.  The layout defines the format by showing the\n // representation of a standard time, which is then used to describe\n // the time to be formatted.  Predefined layouts ANSIC, UnixDate,\n // RFC3339 and others describe standard representations. For more\n // information about the formats, see the documentation for ANSIC.\n-func (t *Time) Format(layout string) string {\n-\tb := new(bytes.Buffer)\n+func (t Time) Format(layout string) string {\n+\tvar (\n+\t\tyear  int = -1\n+\t\tmonth Month\n+\t\tday   int\n+\t\thour  int = -1\n+\t\tmin   int\n+\t\tsec   int\n+\t\tb     buffer\n+\t)\n \t// Each iteration generates one std value.\n \tfor {\n \t\tprefix, std, suffix := nextStdChunk(layout)\n \t\tb.WriteString(prefix)\n \t\tif std == \"\" {\n \t\t\tbreak\n \t\t}\n+\n+\t\t// Compute year, month, day if needed.\n+\t\tif year < 0 {\n+\t\t\t// Jan 01 02 2006\n+\t\t\tif a, z := std[0], std[len(std)-1]; a == 'J' || a == 'j' || z == '1' || z == '2' || z == '6' {\n+\t\t\t\tyear, month, day = t.Date()\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Compute hour, minute, second if needed.\n+\t\tif hour < 0 {\n+\t\t\t// 03 04 05 15 pm\n+\t\t\tif z := std[len(std)-1]; z == '3' || z == '4' || z == '5' || z == 'm' || z == 'M' {\n+\t\t\t\thour, min, sec = t.Clock()\n+\t\t\t}\n+\t\t}\n+\n \t\tvar p string\n \t\tswitch std {\n \t\tcase stdYear:\n-\t\t\tp = zeroPad(int(t.Year % 100))\n+\t\t\tp = zeroPad(year % 100)\n \t\tcase stdLongYear:\n-\t\t\tp = strconv.Itoa64(t.Year)\n+\t\t\tp = itoa(year)\n \t\tcase stdMonth:\n-\t\t\tp = shortMonthNames[t.Month]\n+\t\t\tp = month.String()[:3]\n \t\tcase stdLongMonth:\n-\t\t\tp = longMonthNames[t.Month]\n+\t\t\tp = month.String()\n \t\tcase stdNumMonth:\n-\t\t\tp = strconv.Itoa(t.Month)\n+\t\t\tp = itoa(int(month))\n \t\tcase stdZeroMonth:\n-\t\t\tp = zeroPad(t.Month)\n+\t\t\tp = zeroPad(int(month))\n \t\tcase stdWeekDay:\n-\t\t\tp = shortDayNames[t.Weekday()]\n+\t\t\tp = t.Weekday().String()[:3]\n \t\tcase stdLongWeekDay:\n-\t\t\tp = longDayNames[t.Weekday()]\n+\t\t\tp = t.Weekday().String()\n \t\tcase stdDay:\n-\t\t\tp = strconv.Itoa(t.Day)\n+\t\t\tp = itoa(day)\n \t\tcase stdUnderDay:\n-\t\t\tp = pad(t.Day, \" \")\n+\t\t\tp = pad(day, \" \")\n \t\tcase stdZeroDay:\n-\t\t\tp = zeroPad(t.Day)\n+\t\t\tp = zeroPad(day)\n \t\tcase stdHour:\n-\t\t\tp = zeroPad(t.Hour)\n+\t\t\tp = zeroPad(hour)\n \t\tcase stdHour12:\n \t\t\t// Noon is 12PM, midnight is 12AM.\n-\t\t\thr := t.Hour % 12\n+\t\t\thr := hour % 12\n \t\t\tif hr == 0 {\n \t\t\t\thr = 12\n \t\t\t}\n-\t\t\tp = strconv.Itoa(hr)\n+\t\t\tp = itoa(hr)\n \t\tcase stdZeroHour12:\n \t\t\t// Noon is 12PM, midnight is 12AM.\n-\t\t\thr := t.Hour % 12\n+\t\t\thr := hour % 12\n \t\t\tif hr == 0 {\n \t\t\t\thr = 12\n \t\t\t}\n \t\t\tp = zeroPad(hr)\n \t\tcase stdMinute:\n-\t\t\tp = strconv.Itoa(t.Minute)\n+\t\t\tp = itoa(min)\n \t\tcase stdZeroMinute:\n-\t\t\tp = zeroPad(t.Minute)\n+\t\t\tp = zeroPad(min)\n \t\tcase stdSecond:\n-\t\t\tp = strconv.Itoa(t.Second)\n+\t\t\tp = itoa(sec)\n \t\tcase stdZeroSecond:\n-\t\t\tp = zeroPad(t.Second)\n+\t\t\tp = zeroPad(sec)\n+\t\tcase stdPM:\n+\t\t\tif hour >= 12 {\n+\t\t\t\tp = \"PM\"\n+\t\t\t} else {\n+\t\t\t\tp = \"AM\"\n+\t\t\t}\n+\t\tcase stdpm:\n+\t\t\tif hour >= 12 {\n+\t\t\t\tp = \"pm\"\n+\t\t\t} else {\n+\t\t\t\tp = \"am\"\n+\t\t\t}\n \t\tcase stdISO8601TZ, stdISO8601ColonTZ, stdNumTZ, stdNumColonTZ:\n \t\t\t// Ugly special case.  We cheat and take the \"Z\" variants\n \t\t\t// to mean \"the time zone as formatted for ISO 8601\".\n-\t\t\tif t.ZoneOffset == 0 && std[0] == 'Z' {\n+\t\t\t_, offset := t.Zone()\n+\t\t\tif offset == 0 && std[0] == 'Z' {\n \t\t\t\tp = \"Z\"\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tzone := t.ZoneOffset / 60 // convert to minutes\n+\t\t\tzone := offset / 60 // convert to minutes\n \t\t\tif zone < 0 {\n \t\t\t\tp = \"-\"\n \t\t\t\tzone = -zone\n@@ -366,25 +472,14 @@ func (t *Time) Format(layout string) string {\n \t\t\t\tp += \":\"\n \t\t\t}\n \t\t\tp += zeroPad(zone % 60)\n-\t\tcase stdPM:\n-\t\t\tif t.Hour >= 12 {\n-\t\t\t\tp = \"PM\"\n-\t\t\t} else {\n-\t\t\t\tp = \"AM\"\n-\t\t\t}\n-\t\tcase stdpm:\n-\t\t\tif t.Hour >= 12 {\n-\t\t\t\tp = \"pm\"\n-\t\t\t} else {\n-\t\t\t\tp = \"am\"\n-\t\t\t}\n \t\tcase stdTZ:\n-\t\t\tif t.Zone != \"\" {\n-\t\t\t\tp = t.Zone\n+\t\t\tname, offset := t.Zone()\n+\t\t\tif name != \"\" {\n+\t\t\t\tp = name\n \t\t\t} else {\n \t\t\t\t// No time zone known for this time, but we must print one.\n \t\t\t\t// Use the -0700 format.\n-\t\t\t\tzone := t.ZoneOffset / 60 // convert to minutes\n+\t\t\t\tzone := offset / 60 // convert to minutes\n \t\t\t\tif zone < 0 {\n \t\t\t\t\tp = \"-\"\n \t\t\t\t\tzone = -zone\n@@ -396,7 +491,7 @@ func (t *Time) Format(layout string) string {\n \t\t\t}\n \t\tdefault:\n \t\t\tif len(std) >= 2 && std[0:2] == \".0\" {\n-\t\t\t\tp = formatNano(t.Nanosecond, len(std)-1)\n+\t\t\t\tp = formatNano(t.Nanosecond(), len(std)-1)\n \t\t\t}\n \t\t}\n \t\tb.WriteString(p)\n@@ -405,14 +500,6 @@ func (t *Time) Format(layout string) string {\n \treturn b.String()\n }\n \n-// String returns a Unix-style representation of the time value.\n-func (t *Time) String() string {\n-\tif t == nil {\n-\t\treturn \"<nil>\"\n-\t}\n-\treturn t.Format(UnixDate)\n-}\n-\n var errBad = errors.New(\"bad value for field\") // placeholder not passed to user\n \n // ParseError describes a problem parsing a time string.\n@@ -424,17 +511,21 @@ type ParseError struct {\n \tMessage    string\n }\n \n-// String is the string representation of a ParseError.\n+func quote(s string) string {\n+\treturn \"\\\"\" + s + \"\\\"\"\n+}\n+\n+// Error returns the string representation of a ParseError.\n func (e *ParseError) Error() string {\n \tif e.Message == \"\" {\n \t\treturn \"parsing time \" +\n-\t\t\tstrconv.Quote(e.Value) + \" as \" +\n-\t\t\tstrconv.Quote(e.Layout) + \": cannot parse \" +\n-\t\t\tstrconv.Quote(e.ValueElem) + \" as \" +\n-\t\t\tstrconv.Quote(e.LayoutElem)\n+\t\t\tquote(e.Value) + \" as \" +\n+\t\t\tquote(e.Layout) + \": cannot parse \" +\n+\t\t\tquote(e.ValueElem) + \" as \" +\n+\t\t\tquote(e.LayoutElem)\n \t}\n \treturn \"parsing time \" +\n-\t\tstrconv.Quote(e.Value) + e.Message\n+\t\tquote(e.Value) + e.Message\n }\n \n // isDigit returns true if s[i] is a decimal digit, false if not or\n@@ -498,30 +589,42 @@ func skip(value, prefix string) (string, error) {\n // representations.For more information about the formats, see the\n // documentation for ANSIC.\n //\n-// Only those elements present in the value will be set in the returned time\n-// structure.  Also, if the input string represents an inconsistent time\n-// (such as having the wrong day of the week), the returned value will also\n-// be inconsistent.  In any case, the elements of the returned time will be\n-// sane: hours in 0..23, minutes in 0..59, day of month in 1..31, etc.\n+// Elements omitted from the value are assumed to be zero, or when\n+// zero is impossible, one, so parsing \"3:04pm\" returns the time\n+// corresponding to Jan 1, year 0, 15:04:00 UTC.\n // Years must be in the range 0000..9999. The day of the week is checked\n // for syntax but it is otherwise ignored.\n-func Parse(alayout, avalue string) (*Time, error) {\n-\tvar t Time\n+func Parse(layout, value string) (Time, error) {\n+\talayout, avalue := layout, value\n \trangeErrString := \"\" // set if a value is out of range\n \tamSet := false       // do we need to subtract 12 from the hour for midnight?\n \tpmSet := false       // do we need to add 12 to the hour?\n-\tlayout, value := alayout, avalue\n+\n+\t// Time being constructed.\n+\tvar (\n+\t\tyear       int\n+\t\tmonth      int = 1 // January\n+\t\tday        int = 1\n+\t\thour       int\n+\t\tmin        int\n+\t\tsec        int\n+\t\tnsec       int\n+\t\tz          *Location\n+\t\tzoneOffset int = -1\n+\t\tzoneName   string\n+\t)\n+\n \t// Each iteration processes one std value.\n \tfor {\n \t\tvar err error\n \t\tprefix, std, suffix := nextStdChunk(layout)\n \t\tvalue, err = skip(value, prefix)\n \t\tif err != nil {\n-\t\t\treturn nil, &ParseError{alayout, avalue, prefix, value, \"\"}\n+\t\t\treturn Time{}, &ParseError{alayout, avalue, prefix, value, \"\"}\n \t\t}\n \t\tif len(std) == 0 {\n \t\t\tif len(value) != 0 {\n-\t\t\t\treturn nil, &ParseError{alayout, avalue, \"\", value, \": extra text: \" + value}\n+\t\t\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": extra text: \" + value}\n \t\t\t}\n \t\t\tbreak\n \t\t}\n@@ -534,26 +637,26 @@ func Parse(alayout, avalue string) (*Time, error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp, value = value[0:2], value[2:]\n-\t\t\tt.Year, err = strconv.Atoi64(p)\n-\t\t\tif t.Year >= 69 { // Unix time starts Dec 31 1969 in some time zones\n-\t\t\t\tt.Year += 1900\n+\t\t\tyear, err = atoi(p)\n+\t\t\tif year >= 69 { // Unix time starts Dec 31 1969 in some time zones\n+\t\t\t\tyear += 1900\n \t\t\t} else {\n-\t\t\t\tt.Year += 2000\n+\t\t\t\tyear += 2000\n \t\t\t}\n \t\tcase stdLongYear:\n \t\t\tif len(value) < 4 || !isDigit(value, 0) {\n \t\t\t\terr = errBad\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp, value = value[0:4], value[4:]\n-\t\t\tt.Year, err = strconv.Atoi64(p)\n+\t\t\tyear, err = atoi(p)\n \t\tcase stdMonth:\n-\t\t\tt.Month, value, err = lookup(shortMonthNames, value)\n+\t\t\tmonth, value, err = lookup(shortMonthNames, value)\n \t\tcase stdLongMonth:\n-\t\t\tt.Month, value, err = lookup(longMonthNames, value)\n+\t\t\tmonth, value, err = lookup(longMonthNames, value)\n \t\tcase stdNumMonth, stdZeroMonth:\n-\t\t\tt.Month, value, err = getnum(value, std == stdZeroMonth)\n-\t\t\tif t.Month <= 0 || 12 < t.Month {\n+\t\t\tmonth, value, err = getnum(value, std == stdZeroMonth)\n+\t\t\tif month <= 0 || 12 < month {\n \t\t\t\trangeErrString = \"month\"\n \t\t\t}\n \t\tcase stdWeekDay:\n@@ -565,29 +668,28 @@ func Parse(alayout, avalue string) (*Time, error) {\n \t\t\tif std == stdUnderDay && len(value) > 0 && value[0] == ' ' {\n \t\t\t\tvalue = value[1:]\n \t\t\t}\n-\t\t\tt.Day, value, err = getnum(value, std == stdZeroDay)\n-\t\t\tif t.Day < 0 || 31 < t.Day {\n-\t\t\t\t// TODO: be more thorough in date check?\n+\t\t\tday, value, err = getnum(value, std == stdZeroDay)\n+\t\t\tif day < 0 || 31 < day {\n \t\t\t\trangeErrString = \"day\"\n \t\t\t}\n \t\tcase stdHour:\n-\t\t\tt.Hour, value, err = getnum(value, false)\n-\t\t\tif t.Hour < 0 || 24 <= t.Hour {\n+\t\t\thour, value, err = getnum(value, false)\n+\t\t\tif hour < 0 || 24 <= hour {\n \t\t\t\trangeErrString = \"hour\"\n \t\t\t}\n \t\tcase stdHour12, stdZeroHour12:\n-\t\t\tt.Hour, value, err = getnum(value, std == stdZeroHour12)\n-\t\t\tif t.Hour < 0 || 12 < t.Hour {\n+\t\t\thour, value, err = getnum(value, std == stdZeroHour12)\n+\t\t\tif hour < 0 || 12 < hour {\n \t\t\t\trangeErrString = \"hour\"\n \t\t\t}\n \t\tcase stdMinute, stdZeroMinute:\n-\t\t\tt.Minute, value, err = getnum(value, std == stdZeroMinute)\n-\t\t\tif t.Minute < 0 || 60 <= t.Minute {\n+\t\t\tmin, value, err = getnum(value, std == stdZeroMinute)\n+\t\t\tif min < 0 || 60 <= min {\n \t\t\t\trangeErrString = \"minute\"\n \t\t\t}\n \t\tcase stdSecond, stdZeroSecond:\n-\t\t\tt.Second, value, err = getnum(value, std == stdZeroSecond)\n-\t\t\tif t.Second < 0 || 60 <= t.Second {\n+\t\t\tsec, value, err = getnum(value, std == stdZeroSecond)\n+\t\t\tif sec < 0 || 60 <= sec {\n \t\t\t\trangeErrString = \"second\"\n \t\t\t}\n \t\t\t// Special case: do we have a fractional second but no\n@@ -602,16 +704,44 @@ func Parse(alayout, avalue string) (*Time, error) {\n \t\t\t\tn := 2\n \t\t\t\tfor ; n < len(value) && isDigit(value, n); n++ {\n \t\t\t\t}\n-\t\t\t\trangeErrString, err = t.parseNanoseconds(value, n)\n+\t\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, n)\n \t\t\t\tvalue = value[n:]\n \t\t\t}\n+\t\tcase stdPM:\n+\t\t\tif len(value) < 2 {\n+\t\t\t\terr = errBad\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tp, value = value[0:2], value[2:]\n+\t\t\tswitch p {\n+\t\t\tcase \"PM\":\n+\t\t\t\tpmSet = true\n+\t\t\tcase \"AM\":\n+\t\t\t\tamSet = true\n+\t\t\tdefault:\n+\t\t\t\terr = errBad\n+\t\t\t}\n+\t\tcase stdpm:\n+\t\t\tif len(value) < 2 {\n+\t\t\t\terr = errBad\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tp, value = value[0:2], value[2:]\n+\t\t\tswitch p {\n+\t\t\tcase \"pm\":\n+\t\t\t\tpmSet = true\n+\t\t\tcase \"am\":\n+\t\t\t\tamSet = true\n+\t\t\tdefault:\n+\t\t\t\terr = errBad\n+\t\t\t}\n \t\tcase stdISO8601TZ, stdISO8601ColonTZ, stdNumTZ, stdNumShortTZ, stdNumColonTZ:\n \t\t\tif std[0] == 'Z' && len(value) >= 1 && value[0] == 'Z' {\n \t\t\t\tvalue = value[1:]\n-\t\t\t\tt.Zone = \"UTC\"\n+\t\t\t\tz = UTC\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tvar sign, hh, mm string\n+\t\t\tvar sign, hour, min string\n \t\t\tif std == stdISO8601ColonTZ || std == stdNumColonTZ {\n \t\t\t\tif len(value) < 6 {\n \t\t\t\t\terr = errBad\n@@ -621,65 +751,38 @@ func Parse(alayout, avalue string) (*Time, error) {\n \t\t\t\t\terr = errBad\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tsign, hh, mm, value = value[0:1], value[1:3], value[4:6], value[6:]\n+\t\t\t\tsign, hour, min, value = value[0:1], value[1:3], value[4:6], value[6:]\n \t\t\t} else if std == stdNumShortTZ {\n \t\t\t\tif len(value) < 3 {\n \t\t\t\t\terr = errBad\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tsign, hh, mm, value = value[0:1], value[1:3], \"00\", value[3:]\n+\t\t\t\tsign, hour, min, value = value[0:1], value[1:3], \"00\", value[3:]\n \t\t\t} else {\n \t\t\t\tif len(value) < 5 {\n \t\t\t\t\terr = errBad\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tsign, hh, mm, value = value[0:1], value[1:3], value[3:5], value[5:]\n+\t\t\t\tsign, hour, min, value = value[0:1], value[1:3], value[3:5], value[5:]\n \t\t\t}\n-\t\t\tvar hr, min int\n-\t\t\thr, err = strconv.Atoi(hh)\n+\t\t\tvar hr, mm int\n+\t\t\thr, err = atoi(hour)\n \t\t\tif err == nil {\n-\t\t\t\tmin, err = strconv.Atoi(mm)\n+\t\t\t\tmm, err = atoi(min)\n \t\t\t}\n-\t\t\tt.ZoneOffset = (hr*60 + min) * 60 // offset is in seconds\n+\t\t\tzoneOffset = (hr*60 + mm) * 60 // offset is in seconds\n \t\t\tswitch sign[0] {\n \t\t\tcase '+':\n \t\t\tcase '-':\n-\t\t\t\tt.ZoneOffset = -t.ZoneOffset\n-\t\t\tdefault:\n-\t\t\t\terr = errBad\n-\t\t\t}\n-\t\tcase stdPM:\n-\t\t\tif len(value) < 2 {\n-\t\t\t\terr = errBad\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tp, value = value[0:2], value[2:]\n-\t\t\tswitch p {\n-\t\t\tcase \"PM\":\n-\t\t\t\tpmSet = true\n-\t\t\tcase \"AM\":\n-\t\t\t\tamSet = true\n-\t\t\tdefault:\n-\t\t\t\terr = errBad\n-\t\t\t}\n-\t\tcase stdpm:\n-\t\t\tif len(value) < 2 {\n-\t\t\t\terr = errBad\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tp, value = value[0:2], value[2:]\n-\t\t\tswitch p {\n-\t\t\tcase \"pm\":\n-\t\t\t\tpmSet = true\n-\t\t\tcase \"am\":\n-\t\t\t\tamSet = true\n+\t\t\t\tzoneOffset = -zoneOffset\n \t\t\tdefault:\n \t\t\t\terr = errBad\n \t\t\t}\n \t\tcase stdTZ:\n \t\t\t// Does it look like a time zone?\n \t\t\tif len(value) >= 3 && value[0:3] == \"UTC\" {\n-\t\t\t\tt.Zone, value = value[0:3], value[3:]\n+\t\t\t\tz = UTC\n+\t\t\t\tvalue = value[3:]\n \t\t\t\tbreak\n \t\t\t}\n \n@@ -700,47 +803,86 @@ func Parse(alayout, avalue string) (*Time, error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\t// It's a valid format.\n-\t\t\tt.Zone = p\n-\t\t\t// Can we find its offset?\n-\t\t\tif offset, found := lookupByName(p); found {\n-\t\t\t\tt.ZoneOffset = offset\n-\t\t\t}\n+\t\t\tzoneName = p\n \t\tdefault:\n \t\t\tif len(value) < len(std) {\n \t\t\t\terr = errBad\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif len(std) >= 2 && std[0:2] == \".0\" {\n-\t\t\t\trangeErrString, err = t.parseNanoseconds(value, len(std))\n+\t\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, len(std))\n \t\t\t\tvalue = value[len(std):]\n \t\t\t}\n \t\t}\n \t\tif rangeErrString != \"\" {\n-\t\t\treturn nil, &ParseError{alayout, avalue, std, value, \": \" + rangeErrString + \" out of range\"}\n+\t\t\treturn Time{}, &ParseError{alayout, avalue, std, value, \": \" + rangeErrString + \" out of range\"}\n \t\t}\n \t\tif err != nil {\n-\t\t\treturn nil, &ParseError{alayout, avalue, std, value, \"\"}\n+\t\t\treturn Time{}, &ParseError{alayout, avalue, std, value, \"\"}\n+\t\t}\n+\t}\n+\tif pmSet && hour < 12 {\n+\t\thour += 12\n+\t} else if amSet && hour == 12 {\n+\t\thour = 0\n+\t}\n+\n+\t// TODO: be more aggressive checking day?\n+\tif z != nil {\n+\t\treturn Date(year, Month(month), day, hour, min, sec, nsec, z), nil\n+\t}\n+\n+\tt := Date(year, Month(month), day, hour, min, sec, nsec, UTC)\n+\tif zoneOffset != -1 {\n+\t\tt.sec -= int64(zoneOffset)\n+\n+\t\t// Look for local zone with the given offset.\n+\t\t// If that zone was in effect at the given time, use it.\n+\t\tname, offset, _, _, _ := Local.lookup(t.sec + internalToUnix)\n+\t\tif offset == zoneOffset && (zoneName == \"\" || name == zoneName) {\n+\t\t\tt.loc = Local\n+\t\t\treturn t, nil\n \t\t}\n+\n+\t\t// Otherwise create fake zone to record offset.\n+\t\tt.loc = FixedZone(zoneName, zoneOffset)\n+\t\treturn t, nil\n \t}\n-\tif pmSet && t.Hour < 12 {\n-\t\tt.Hour += 12\n-\t} else if amSet && t.Hour == 12 {\n-\t\tt.Hour = 0\n+\n+\tif zoneName != \"\" {\n+\t\t// Look for local zone with the given offset.\n+\t\t// If that zone was in effect at the given time, use it.\n+\t\toffset, _, ok := Local.lookupName(zoneName)\n+\t\tif ok {\n+\t\t\tname, off, _, _, _ := Local.lookup(t.sec + internalToUnix - int64(offset))\n+\t\t\tif name == zoneName && off == offset {\n+\t\t\t\tt.sec -= int64(offset)\n+\t\t\t\tt.loc = Local\n+\t\t\t\treturn t, nil\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Otherwise, create fake zone with unknown offset.\n+\t\tt.loc = FixedZone(zoneName, 0)\n+\t\treturn t, nil\n \t}\n-\treturn &t, nil\n+\n+\t// Otherwise, fall back to UTC.\n+\treturn t, nil\n }\n \n-func (t *Time) parseNanoseconds(value string, nbytes int) (rangErrString string, err error) {\n+func parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string, err error) {\n \tif value[0] != '.' {\n-\t\treturn \"\", errBad\n+\t\terr = errBad\n+\t\treturn\n \t}\n-\tvar ns int\n-\tns, err = strconv.Atoi(value[1:nbytes])\n+\tns, err = atoi(value[1:nbytes])\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn\n \t}\n \tif ns < 0 || 1e9 <= ns {\n-\t\treturn \"fractional second\", nil\n+\t\trangeErrString = \"fractional second\"\n+\t\treturn\n \t}\n \t// We need nanoseconds, which means scaling by the number\n \t// of missing digits in the format, maximum length 10. If it's\n@@ -749,6 +891,5 @@ func (t *Time) parseNanoseconds(value string, nbytes int) (rangErrString string,\n \tfor i := 0; i < scaleDigits; i++ {\n \t\tns *= 10\n \t}\n-\tt.Nanosecond = ns\n \treturn\n }"}, {"sha": "2c4df335f9b44a4e247e4cc3183eb65d71e5bd7e", "filename": "libgo/go/time/internal_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Finternal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Finternal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Finternal_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,7 +6,7 @@ package time\n \n func init() {\n \t// force US/Pacific for time zone tests\n-\tonceSetupZone.Do(setupTestingZone)\n+\tlocalOnce.Do(initTestingZone)\n }\n \n var Interrupt = interrupt"}, {"sha": "1e23118f3786152bd4b2d584d7a3f01bba378adb", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -4,6 +4,11 @@\n \n package time\n \n+func nano() int64 {\n+\tsec, nsec := now()\n+\treturn sec*1e9 + int64(nsec)\n+}\n+\n // Interface to timers implemented in package runtime.\n // Must be in sync with ../runtime/runtime.h:/^struct.Timer$\n type runtimeTimer struct {\n@@ -21,7 +26,7 @@ func stopTimer(*runtimeTimer) bool\n // When the Timer expires, the current time will be sent on C,\n // unless the Timer was created by AfterFunc.\n type Timer struct {\n-\tC <-chan int64\n+\tC <-chan Time\n \tr runtimeTimer\n }\n \n@@ -34,12 +39,12 @@ func (t *Timer) Stop() (ok bool) {\n \n // NewTimer creates a new Timer that will send\n // the current time on its channel after at least ns nanoseconds.\n-func NewTimer(ns int64) *Timer {\n-\tc := make(chan int64, 1)\n+func NewTimer(d Duration) *Timer {\n+\tc := make(chan Time, 1)\n \tt := &Timer{\n \t\tC: c,\n \t\tr: runtimeTimer{\n-\t\t\twhen: Nanoseconds() + ns,\n+\t\t\twhen: nano() + int64(d),\n \t\t\tf:    sendTime,\n \t\t\targ:  c,\n \t\t},\n@@ -55,16 +60,16 @@ func sendTime(now int64, c interface{}) {\n \t// the desired behavior when the reader gets behind,\n \t// because the sends are periodic.\n \tselect {\n-\tcase c.(chan int64) <- now:\n+\tcase c.(chan Time) <- Unix(0, now):\n \tdefault:\n \t}\n }\n \n-// After waits at least ns nanoseconds before sending the current time\n+// After waits for the duration to elapse and then sends the current time\n // on the returned channel.\n // It is equivalent to NewTimer(ns).C.\n-func After(ns int64) <-chan int64 {\n-\treturn NewTimer(ns).C\n+func After(d Duration) <-chan Time {\n+\treturn NewTimer(d).C\n }\n \n // AfterFunc waits at least ns nanoseconds before calling f\n@@ -73,7 +78,7 @@ func After(ns int64) <-chan int64 {\n func AfterFunc(ns int64, f func()) *Timer {\n \tt := &Timer{\n \t\tr: runtimeTimer{\n-\t\t\twhen: Nanoseconds() + ns,\n+\t\t\twhen: nano() + ns,\n \t\t\tf:    goFunc,\n \t\t\targ:  f,\n \t\t},"}, {"sha": "cbcc897fd405bc3a10a2b4d0dd5f2ccf2e055898", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -15,16 +15,16 @@ import (\n )\n \n func TestSleep(t *testing.T) {\n-\tconst delay = int64(100e6)\n+\tconst delay = 100 * Millisecond\n \tgo func() {\n \t\tSleep(delay / 2)\n \t\tInterrupt()\n \t}()\n-\tstart := Nanoseconds()\n+\tstart := Now()\n \tSleep(delay)\n-\tduration := Nanoseconds() - start\n+\tduration := Now().Sub(start)\n \tif duration < delay {\n-\t\tt.Fatalf(\"Sleep(%d) slept for only %d ns\", delay, duration)\n+\t\tt.Fatalf(\"Sleep(%s) slept for only %s\", delay, duration)\n \t}\n }\n \n@@ -96,32 +96,32 @@ func BenchmarkStop(b *testing.B) {\n }\n \n func TestAfter(t *testing.T) {\n-\tconst delay = int64(100e6)\n-\tstart := Nanoseconds()\n+\tconst delay = 100 * Millisecond\n+\tstart := Now()\n \tend := <-After(delay)\n-\tif duration := Nanoseconds() - start; duration < delay {\n-\t\tt.Fatalf(\"After(%d) slept for only %d ns\", delay, duration)\n+\tif duration := Now().Sub(start); duration < delay {\n+\t\tt.Fatalf(\"After(%s) slept for only %d ns\", delay, duration)\n \t}\n-\tif min := start + delay; end < min {\n-\t\tt.Fatalf(\"After(%d) expect >= %d, got %d\", delay, min, end)\n+\tif min := start.Add(delay); end.Before(min) {\n+\t\tt.Fatalf(\"After(%s) expect >= %s, got %s\", delay, min, end)\n \t}\n }\n \n func TestAfterTick(t *testing.T) {\n \tconst (\n-\t\tDelta = 100 * 1e6\n+\t\tDelta = 100 * Millisecond\n \t\tCount = 10\n \t)\n-\tt0 := Nanoseconds()\n+\tt0 := Now()\n \tfor i := 0; i < Count; i++ {\n \t\t<-After(Delta)\n \t}\n-\tt1 := Nanoseconds()\n-\tns := t1 - t0\n-\ttarget := int64(Delta * Count)\n+\tt1 := Now()\n+\td := t1.Sub(t0)\n+\ttarget := Delta * Count\n \tslop := target * 2 / 10\n-\tif ns < target-slop || ns > target+slop {\n-\t\tt.Fatalf(\"%d ticks of %g ns took %g ns, expected %g\", Count, float64(Delta), float64(ns), float64(target))\n+\tif d < target-slop || d > target+slop {\n+\t\tt.Fatalf(\"%d ticks of %s took %s, expected %s\", Count, Delta, d, target)\n \t}\n }\n \n@@ -171,38 +171,54 @@ var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8 /*0*/ }\n \n type afterResult struct {\n \tslot int\n-\tt    int64\n+\tt    Time\n }\n \n-func await(slot int, result chan<- afterResult, ac <-chan int64) {\n+func await(slot int, result chan<- afterResult, ac <-chan Time) {\n \tresult <- afterResult{slot, <-ac}\n }\n \n func testAfterQueuing(t *testing.T) error {\n \tconst (\n-\t\tDelta = 100 * 1e6\n+\t\tDelta = 100 * Millisecond\n \t)\n \t// make the result channel buffered because we don't want\n \t// to depend on channel queueing semantics that might\n \t// possibly change in the future.\n \tresult := make(chan afterResult, len(slots))\n \n-\tt0 := Nanoseconds()\n+\tt0 := Now()\n \tfor _, slot := range slots {\n-\t\tgo await(slot, result, After(int64(slot)*Delta))\n+\t\tgo await(slot, result, After(Duration(slot)*Delta))\n \t}\n \tsort.Ints(slots)\n \tfor _, slot := range slots {\n \t\tr := <-result\n \t\tif r.slot != slot {\n-\t\t\treturn fmt.Errorf(\"after queue got slot %d, expected %d\", r.slot, slot)\n+\t\t\treturn fmt.Errorf(\"after slot %d, expected %d\", r.slot, slot)\n \t\t}\n-\t\tns := r.t - t0\n-\t\ttarget := int64(slot * Delta)\n-\t\tslop := int64(Delta) / 4\n-\t\tif ns < target-slop || ns > target+slop {\n-\t\t\treturn fmt.Errorf(\"after queue slot %d arrived at %g, expected [%g,%g]\", slot, float64(ns), float64(target-slop), float64(target+slop))\n+\t\tdt := r.t.Sub(t0)\n+\t\ttarget := Duration(slot) * Delta\n+\t\tslop := Delta / 4\n+\t\tif dt < target-slop || dt > target+slop {\n+\t\t\treturn fmt.Errorf(\"After(%s) arrived at %s, expected [%s,%s]\", target, dt, target-slop, target+slop)\n \t\t}\n \t}\n \treturn nil\n }\n+\n+func TestTimerStopStress(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < 100; i++ {\n+\t\tgo func(i int) {\n+\t\t\ttimer := AfterFunc(2e9, func() {\n+\t\t\t\tt.Fatalf(\"timer %d was not stopped\", i)\n+\t\t\t})\n+\t\t\tSleep(1e9)\n+\t\t\ttimer.Stop()\n+\t\t}(i)\n+\t}\n+\tSleep(3e9)\n+}"}, {"sha": "fe6bc27d301f113e9ee460010f00eb105c3c5750", "filename": "libgo/go/time/sys.go", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -4,17 +4,33 @@\n \n package time\n \n-// Seconds reports the number of seconds since the Unix epoch,\n-// January 1, 1970 00:00:00 UTC.\n-func Seconds() int64 {\n-\treturn Nanoseconds() / 1e9\n-}\n-\n-// Nanoseconds is implemented by package runtime.\n+import \"syscall\"\n \n-// Nanoseconds reports the number of nanoseconds since the Unix epoch,\n-// January 1, 1970 00:00:00 UTC.\n-func Nanoseconds() int64\n+// Sleep pauses the current goroutine for the duration d.\n+func Sleep(d Duration)\n \n-// Sleep pauses the current goroutine for at least ns nanoseconds.\n-func Sleep(ns int64)\n+// readFile reads and returns the content of the named file.\n+// It is a trivial implementation of ioutil.ReadFile, reimplemented\n+// here to avoid depending on io/ioutil or os.\n+func readFile(name string) ([]byte, error) {\n+\tf, err := syscall.Open(name, syscall.O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.Close(f)\n+\tvar (\n+\t\tbuf [4096]byte\n+\t\tret []byte\n+\t\tn   int\n+\t)\n+\tfor {\n+\t\tn, err = syscall.Read(f, buf[:])\n+\t\tif n > 0 {\n+\t\t\tret = append(ret, buf[:n]...)\n+\t\t}\n+\t\tif n == 0 || err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn ret, err\n+}"}, {"sha": "715d186be17fc72ac5130e30193164fdcced4ae7", "filename": "libgo/go/time/sys_unix.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsys_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fsys_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,12 +6,9 @@\n \n package time\n \n-import (\n-\t\"os\"\n-\t\"syscall\"\n-)\n+import \"syscall\"\n \n // for testing: whatever interrupts a sleep\n func interrupt() {\n-\tsyscall.Kill(os.Getpid(), syscall.SIGCHLD)\n+\tsyscall.Kill(syscall.Getpid(), syscall.SIGCHLD)\n }"}, {"sha": "4440c2207b33715ce54d087051b10ba5547c6121", "filename": "libgo/go/time/tick.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -9,27 +9,27 @@ import \"errors\"\n // A Ticker holds a synchronous channel that delivers `ticks' of a clock\n // at intervals.\n type Ticker struct {\n-\tC <-chan int64 // The channel on which the ticks are delivered.\n+\tC <-chan Time // The channel on which the ticks are delivered.\n \tr runtimeTimer\n }\n \n-// NewTicker returns a new Ticker containing a channel that will\n-// send the time, in nanoseconds, every ns nanoseconds.  It adjusts the\n-// intervals to make up for pauses in delivery of the ticks. The value of\n-// ns must be greater than zero; if not, NewTicker will panic.\n-func NewTicker(ns int64) *Ticker {\n-\tif ns <= 0 {\n+// NewTicker returns a new Ticker containing a channel that will send the\n+// time, in nanoseconds, with a period specified by the duration argument.\n+// It adjusts the intervals or drops ticks to make up for slow receivers.\n+// The duration d must be greater than zero; if not, NewTicker will panic.\n+func NewTicker(d Duration) *Ticker {\n+\tif d <= 0 {\n \t\tpanic(errors.New(\"non-positive interval for NewTicker\"))\n \t}\n \t// Give the channel a 1-element time buffer.\n \t// If the client falls behind while reading, we drop ticks\n \t// on the floor until the client catches up.\n-\tc := make(chan int64, 1)\n+\tc := make(chan Time, 1)\n \tt := &Ticker{\n \t\tC: c,\n \t\tr: runtimeTimer{\n-\t\t\twhen:   Nanoseconds() + ns,\n-\t\t\tperiod: ns,\n+\t\t\twhen:   nano() + int64(d),\n+\t\t\tperiod: int64(d),\n \t\t\tf:      sendTime,\n \t\t\targ:    c,\n \t\t},\n@@ -45,9 +45,9 @@ func (t *Ticker) Stop() {\n \n // Tick is a convenience wrapper for NewTicker providing access to the ticking\n // channel only.  Useful for clients that have no need to shut down the ticker.\n-func Tick(ns int64) <-chan int64 {\n-\tif ns <= 0 {\n+func Tick(d Duration) <-chan Time {\n+\tif d <= 0 {\n \t\treturn nil\n \t}\n-\treturn NewTicker(ns).C\n+\treturn NewTicker(d).C\n }"}, {"sha": "36349349ce0ff4644ded7b953a9b3120fa1580b7", "filename": "libgo/go/time/tick_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftick_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftick_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -11,21 +11,21 @@ import (\n \n func TestTicker(t *testing.T) {\n \tconst (\n-\t\tDelta = 100 * 1e6\n+\t\tDelta = 100 * Millisecond\n \t\tCount = 10\n \t)\n \tticker := NewTicker(Delta)\n-\tt0 := Nanoseconds()\n+\tt0 := Now()\n \tfor i := 0; i < Count; i++ {\n \t\t<-ticker.C\n \t}\n \tticker.Stop()\n-\tt1 := Nanoseconds()\n-\tns := t1 - t0\n-\ttarget := int64(Delta * Count)\n+\tt1 := Now()\n+\tdt := t1.Sub(t0)\n+\ttarget := Delta * Count\n \tslop := target * 2 / 10\n-\tif ns < target-slop || ns > target+slop {\n-\t\tt.Fatalf(\"%d ticks of %g ns took %g ns, expected %g\", Count, float64(Delta), float64(ns), float64(target))\n+\tif dt < target-slop || dt > target+slop {\n+\t\tt.Fatalf(\"%d %s ticks took %s, expected [%s,%s]\", Count, Delta, dt, target-slop, target+slop)\n \t}\n \t// Now test that the ticker stopped\n \tSleep(2 * Delta)"}, {"sha": "04ed86cf25f860e8de782092627a184db98d3e62", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 783, "deletions": 220, "changes": 1003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -3,11 +3,109 @@\n // license that can be found in the LICENSE file.\n \n // Package time provides functionality for measuring and displaying time.\n+//\n+// The calendrical calculations always assume a Gregorian calendar.\n package time\n \n-// Days of the week.\n+// A Time represents an instant in time with nanosecond precision.\n+//\n+// Programs using times should typically store and pass them as values,\n+// not pointers.  That is, time variables and struct fields should be of\n+// type time.Time, not *time.Time.\n+//\n+// Time instants can be compared using the Before, After, and Equal methods.\n+// The Sub method subtracts two instants, producing a Duration.\n+// The Add method adds a Time and a Duration, producing a Time.\n+//\n+// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.\n+// As this time is unlikely to come up in practice, the IsZero method gives\n+// a simple way of detecting a time that has not been initialized explicitly.\n+//\n+// Each Time has associated with it a Location, consulted when computing the\n+// presentation form of the time, such as in the Format, Hour, and Year methods.\n+// The methods Local, UTC, and In return a Time with a specific location.\n+// Changing the location in this way changes only the presentation; it does not\n+// change the instant in time being denoted and therefore does not affect the\n+// computations described in earlier paragraphs.\n+//\n+type Time struct {\n+\t// sec gives the number of seconds elapsed since\n+\t// January 1, year 1 00:00:00 UTC.\n+\tsec int64\n+\n+\t// nsec specifies a non-negative nanosecond\n+\t// offset within the second named by Seconds.\n+\t// It must be in the range [0, 999999999].\n+\tnsec int32\n+\n+\t// loc specifies the Location that should be used to\n+\t// determine the minute, hour, month, day, and year\n+\t// that correspond to this Time.\n+\t// Only the zero Time has a nil Location.\n+\t// In that case it is interpreted to mean UTC.\n+\tloc *Location\n+}\n+\n+// After reports whether the time instant t is after u.\n+func (t Time) After(u Time) bool {\n+\treturn t.sec > u.sec || t.sec == u.sec && t.nsec > u.nsec\n+}\n+\n+// Before reports whether the time instant t is before u.\n+func (t Time) Before(u Time) bool {\n+\treturn t.sec < u.sec || t.sec == u.sec && t.nsec < u.nsec\n+}\n+\n+// Equal reports whether t and u represent the same time instant.\n+// Two times can be equal even if they are in different locations.\n+// For example, 6:00 +0200 CEST and 4:00 UTC are Equal.\n+// This comparison is different from using t == u, which also compares\n+// the locations.\n+func (t Time) Equal(u Time) bool {\n+\treturn t.sec == u.sec && t.nsec == u.nsec\n+}\n+\n+// A Month specifies a month of the year (January = 1, ...).\n+type Month int\n+\n const (\n-\tSunday = iota\n+\tJanuary Month = 1 + iota\n+\tFebruary\n+\tMarch\n+\tApril\n+\tMay\n+\tJune\n+\tJuly\n+\tAugust\n+\tSeptember\n+\tOctober\n+\tNovember\n+\tDecember\n+)\n+\n+var months = [...]string{\n+\t\"January\",\n+\t\"February\",\n+\t\"March\",\n+\t\"April\",\n+\t\"May\",\n+\t\"June\",\n+\t\"July\",\n+\t\"August\",\n+\t\"September\",\n+\t\"October\",\n+\t\"November\",\n+\t\"December\",\n+}\n+\n+// String returns the English name of the month (\"January\", \"February\", ...).\n+func (m Month) String() string { return months[m-1] }\n+\n+// A Weekday specifies a day of the week (Sunday = 0, ...).\n+type Weekday int\n+\n+const (\n+\tSunday Weekday = iota\n \tMonday\n \tTuesday\n \tWednesday\n@@ -16,284 +114,749 @@ const (\n \tSaturday\n )\n \n-// Time is the struct representing a parsed time value.\n-type Time struct {\n-\tYear                 int64  // 2006 is 2006\n-\tMonth, Day           int    // Jan-2 is 1, 2\n-\tHour, Minute, Second int    // 15:04:05 is 15, 4, 5.\n-\tNanosecond           int    // Fractional second.\n-\tZoneOffset           int    // seconds east of UTC, e.g. -7*60*60 for -0700\n-\tZone                 string // e.g., \"MST\"\n+var days = [...]string{\n+\t\"Sunday\",\n+\t\"Monday\",\n+\t\"Tuesday\",\n+\t\"Wednesday\",\n+\t\"Thursday\",\n+\t\"Friday\",\n+\t\"Saturday\",\n }\n \n-var nonleapyear = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n-var leapyear = []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n+// String returns the English name of the day (\"Sunday\", \"Monday\", ...).\n+func (d Weekday) String() string { return days[d] }\n+\n+// Computations on time.\n+// \n+// The zero value for a Time is defined to be\n+//\tJanuary 1, year 1, 00:00:00.000000000 UTC\n+// which (1) looks like a zero, or as close as you can get in a date\n+// (1-1-1 00:00:00 UTC), (2) is unlikely enough to arise in practice to\n+// be a suitable \"not set\" sentinel, unlike Jan 1 1970, and (3) has a\n+// non-negative year even in time zones west of UTC, unlike 1-1-0\n+// 00:00:00 UTC, which would be 12-31-(-1) 19:00:00 in New York.\n+// \n+// The zero Time value does not force a specific epoch for the time\n+// representation.  For example, to use the Unix epoch internally, we\n+// could define that to distinguish a zero value from Jan 1 1970, that\n+// time would be represented by sec=-1, nsec=1e9.  However, it does\n+// suggest a representation, namely using 1-1-1 00:00:00 UTC as the\n+// epoch, and that's what we do.\n+// \n+// The Add and Sub computations are oblivious to the choice of epoch.\n+// \n+// The presentation computations - year, month, minute, and so on - all\n+// rely heavily on division and modulus by positive constants.  For\n+// calendrical calculations we want these divisions to round down, even\n+// for negative values, so that the remainder is always positive, but\n+// Go's division (like most hardware divison instructions) rounds to\n+// zero.  We can still do those computations and then adjust the result\n+// for a negative numerator, but it's annoying to write the adjustment\n+// over and over.  Instead, we can change to a different epoch so long\n+// ago that all the times we care about will be positive, and then round\n+// to zero and round down coincide.  These presentation routines already\n+// have to add the zone offset, so adding the translation to the\n+// alternate epoch is cheap.  For example, having a non-negative time t\n+// means that we can write\n+//\n+//\tsec = t % 60\n+//\n+// instead of\n+//\n+//\tsec = t % 60\n+//\tif sec < 0 {\n+//\t\tsec += 60\n+//\t}\n+//\n+// everywhere.\n+// \n+// The calendar runs on an exact 400 year cycle: a 400-year calendar\n+// printed for 1970-2469 will apply as well to 2470-2869.  Even the days\n+// of the week match up.  It simplifies the computations to choose the\n+// cycle boundaries so that the exceptional years are always delayed as\n+// long as possible.  That means choosing a year equal to 1 mod 400, so\n+// that the first leap year is the 4th year, the first missed leap year\n+// is the 100th year, and the missed missed leap year is the 400th year.\n+// So we'd prefer instead to print a calendar for 2001-2400 and reuse it\n+// for 2401-2800.\n+// \n+// Finally, it's convenient if the delta between the Unix epoch and\n+// long-ago epoch is representable by an int64 constant.\n+// \n+// These three considerations\u2014choose an epoch as early as possible, that\n+// uses a year equal to 1 mod 400, and that is no more than 2\u2076\u00b3 seconds\n+// earlier than 1970\u2014bring us to the year -292277022399.  We refer to\n+// this year as the absolute zero year, and to times measured as a uint64\n+// seconds since this year as absolute times.\n+// \n+// Times measured as an int64 seconds since the year 1\u2014the representation\n+// used for Time's sec field\u2014are called internal times.\n+// \n+// Times measured as an int64 seconds since the year 1970 are called Unix\n+// times.\n+// \n+// It is tempting to just use the year 1 as the absolute epoch, defining\n+// that the routines are only valid for years >= 1.  However, the\n+// routines would then be invalid when displaying the epoch in time zones\n+// west of UTC, since it is year 0.  It doesn't seem tenable to say that\n+// printing the zero time correctly isn't supported in half the time\n+// zones.  By comparison, it's reasonable to mishandle some times in\n+// the year -292277022399.\n+// \n+// All this is opaque to clients of the API and can be changed if a\n+// better implementation presents itself.\n \n-func months(year int64) []int {\n-\tif year%4 == 0 && (year%100 != 0 || year%400 == 0) {\n-\t\treturn leapyear\n+const (\n+\t// The unsigned zero year for internal calculations.\n+\t// Must be 1 mod 400, and times before it will not compute correctly,\n+\t// but otherwise can be changed at will.\n+\tabsoluteZeroYear = -292277022399\n+\n+\t// The year of the zero Time.\n+\t// Assumed by the unixToInternal computation below.\n+\tinternalYear = 1\n+\n+\t// The year of the zero Unix time.\n+\tunixYear = 1970\n+\n+\t// Offsets to convert between internal and absolute or Unix times.\n+\tabsoluteToInternal int64 = (absoluteZeroYear - internalYear) * 365.2425 * secondsPerDay\n+\tinternalToAbsolute       = -absoluteToInternal\n+\n+\tunixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay\n+\tinternalToUnix int64 = -unixToInternal\n+)\n+\n+// IsZero reports whether t represents the zero time instant,\n+// January 1, year 1, 00:00:00 UTC.\n+func (t Time) IsZero() bool {\n+\treturn t.sec == 0 && t.nsec == 0\n+}\n+\n+// abs returns the time t as an absolute time, adjusted by the zone offset.\n+// It is called when computing a presentation property like Month or Hour.\n+func (t Time) abs() uint64 {\n+\tl := t.loc\n+\tif l == nil {\n+\t\tl = &utcLoc\n \t}\n-\treturn nonleapyear\n+\t// Avoid function call if we hit the local time cache.\n+\tsec := t.sec + internalToUnix\n+\tif l != &utcLoc {\n+\t\tif l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {\n+\t\t\tsec += int64(l.cacheZone.offset)\n+\t\t} else {\n+\t\t\t_, offset, _, _, _ := l.lookup(sec)\n+\t\t\tsec += int64(offset)\n+\t\t}\n+\t}\n+\treturn uint64(sec + (unixToInternal + internalToAbsolute))\n }\n \n-const (\n-\tsecondsPerDay   = 24 * 60 * 60\n-\tdaysPer400Years = 365*400 + 97\n-\tdaysPer100Years = 365*100 + 24\n-\tdaysPer4Years   = 365*4 + 1\n-\tdays1970To2001  = 31*365 + 8\n-)\n+// Date returns the year, month, and day in which t occurs.\n+func (t Time) Date() (year int, month Month, day int) {\n+\tyear, month, day, _ = t.date(true)\n+\treturn\n+}\n \n-// SecondsToUTC converts sec, in number of seconds since the Unix epoch,\n-// into a parsed Time value in the UTC time zone.\n-func SecondsToUTC(sec int64) *Time {\n-\tt := new(Time)\n+// Year returns the year in which t occurs.\n+func (t Time) Year() int {\n+\tyear, _, _, _ := t.date(false)\n+\treturn year\n+}\n \n-\t// Split into time and day.\n-\tday := sec / secondsPerDay\n-\tsec -= day * secondsPerDay\n-\tif sec < 0 {\n-\t\tday--\n-\t\tsec += secondsPerDay\n+// Month returns the month of the year specified by t.\n+func (t Time) Month() Month {\n+\t_, month, _, _ := t.date(true)\n+\treturn month\n+}\n+\n+// Day returns the day of the month specified by t.\n+func (t Time) Day() int {\n+\t_, _, day, _ := t.date(true)\n+\treturn day\n+}\n+\n+// Weekday returns the day of the week specified by t.\n+func (t Time) Weekday() Weekday {\n+\t// January 1 of the absolute year, like January 1 of 2001, was a Monday.\n+\tsec := (t.abs() + uint64(Monday)*secondsPerDay) % secondsPerWeek\n+\treturn Weekday(int(sec) / secondsPerDay)\n+}\n+\n+// ISOWeek returns the ISO 8601 year and week number in which t occurs.\n+// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to \n+// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 \n+// of year n+1.\n+func (t Time) ISOWeek() (year, week int) {\n+\tyear, month, day, yday := t.date(true)\n+\twday := int(t.Weekday()+6) % 7 // weekday but Monday = 0.\n+\tconst (\n+\t\tMon int = iota\n+\t\tTue\n+\t\tWed\n+\t\tThu\n+\t\tFri\n+\t\tSat\n+\t\tSun\n+\t)\n+\n+\t// Calculate week as number of Mondays in year up to\n+\t// and including today, plus 1 because the first week is week 0.\n+\t// Putting the + 1 inside the numerator as a + 7 keeps the\n+\t// numerator from being negative, which would cause it to\n+\t// round incorrectly.\n+\tweek = (yday - wday + 7) / 7\n+\n+\t// The week number is now correct under the assumption\n+\t// that the first Monday of the year is in week 1.\n+\t// If Jan 1 is a Tuesday, Wednesday, or Thursday, the first Monday\n+\t// is actually in week 2.\n+\tjan1wday := (wday - yday + 7*53) % 7\n+\tif Tue <= jan1wday && jan1wday <= Thu {\n+\t\tweek++\n \t}\n \n-\t// Time\n-\tt.Hour = int(sec / 3600)\n-\tt.Minute = int((sec / 60) % 60)\n-\tt.Second = int(sec % 60)\n-\n-\t// Change day from 0 = 1970 to 0 = 2001,\n-\t// to make leap year calculations easier\n-\t// (2001 begins 4-, 100-, and 400-year cycles ending in a leap year.)\n-\tday -= days1970To2001\n-\n-\tyear := int64(2001)\n-\tif day < 0 {\n-\t\t// Go back enough 400 year cycles to make day positive.\n-\t\tn := -day/daysPer400Years + 1\n-\t\tyear -= 400 * n\n-\t\tday += daysPer400Years * n\n+\t// If the week number is still 0, we're in early January but in\n+\t// the last week of last year.\n+\tif week == 0 {\n+\t\tyear--\n+\t\tweek = 52\n+\t\t// A year has 53 weeks when Jan 1 or Dec 31 is a Thursday,\n+\t\t// meaning Jan 1 of the next year is a Friday\n+\t\t// or it was a leap year and Jan 1 of the next year is a Saturday.\n+\t\tif jan1wday == Fri || (jan1wday == Sat && isLeap(year)) {\n+\t\t\tweek++\n+\t\t}\n \t}\n \n-\t// Cut off 400 year cycles.\n-\tn := day / daysPer400Years\n-\tyear += 400 * n\n-\tday -= daysPer400Years * n\n+\t// December 29 to 31 are in week 1 of next year if\n+\t// they are after the last Thursday of the year and\n+\t// December 31 is a Monday, Tuesday, or Wednesday.\n+\tif month == December && day >= 29 && wday < Thu {\n+\t\tif dec31wday := (wday + 31 - day) % 7; Mon <= dec31wday && dec31wday <= Wed {\n+\t\t\tyear++\n+\t\t\tweek = 1\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// Clock returns the hour, minute, and second within the day specified by t.\n+func (t Time) Clock() (hour, min, sec int) {\n+\tsec = int(t.abs() % secondsPerDay)\n+\thour = sec / secondsPerHour\n+\tsec -= hour * secondsPerHour\n+\tmin = sec / secondsPerMinute\n+\tsec -= min * secondsPerMinute\n+\treturn\n+}\n+\n+// Hour returns the hour within the day specified by t, in the range [0, 23].\n+func (t Time) Hour() int {\n+\treturn int(t.abs()%secondsPerDay) / secondsPerHour\n+}\n+\n+// Minute returns the minute offset within the hour specified by t, in the range [0, 59].\n+func (t Time) Minute() int {\n+\treturn int(t.abs()%secondsPerHour) / secondsPerMinute\n+}\n+\n+// Second returns the second offset within the minute specified by t, in the range [0, 59].\n+func (t Time) Second() int {\n+\treturn int(t.abs() % secondsPerMinute)\n+}\n+\n+// Nanosecond returns the nanosecond offset within the second specified by t,\n+// in the range [0, 999999999].\n+func (t Time) Nanosecond() int {\n+\treturn int(t.nsec)\n+}\n+\n+// A Duration represents the elapsed time between two instants\n+// as an int64 nanosecond count.  The representation limits the\n+// largest representable duration to approximately 290 years.\n+type Duration int64\n \n-\t// Cut off 100-year cycles\n-\tn = day / daysPer100Years\n-\tif n > 3 { // happens on last day of 400th year\n-\t\tn = 3\n+// Common durations.  There is no definition for units of Day or larger\n+// to avoid confusion across daylight savings time zone transitions.\n+const (\n+\tNanosecond  Duration = 1\n+\tMicrosecond          = 1000 * Nanosecond\n+\tMillisecond          = 1000 * Microsecond\n+\tSecond               = 1000 * Millisecond\n+\tMinute               = 60 * Second\n+\tHour                 = 60 * Minute\n+)\n+\n+// Duration returns a string representing the duration in the form \"72h3m0.5s\".\n+// Leading zero units are omitted.  As a special case, durations less than one\n+// second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure\n+// that the leading digit is non-zero.  The zero duration formats as 0,\n+// with no unit.\n+func (d Duration) String() string {\n+\t// Largest time is 2540400h10m10.000000000s\n+\tvar buf [32]byte\n+\tw := len(buf)\n+\n+\tu := uint64(d)\n+\tneg := d < 0\n+\tif neg {\n+\t\tu = -u\n \t}\n-\tyear += 100 * n\n-\tday -= daysPer100Years * n\n \n-\t// Cut off 4-year cycles\n-\tn = day / daysPer4Years\n-\tif n > 24 { // happens on last day of 100th year\n-\t\tn = 24\n+\tif u < uint64(Second) {\n+\t\t// Special case: if duration is smaller than a second,\n+\t\t// use smaller units, like 1.2ms\n+\t\tvar (\n+\t\t\tprec int\n+\t\t\tunit byte\n+\t\t)\n+\t\tswitch {\n+\t\tcase u == 0:\n+\t\t\treturn \"0\"\n+\t\tcase u < uint64(Microsecond):\n+\t\t\t// print nanoseconds\n+\t\t\tprec = 0\n+\t\t\tunit = 'n'\n+\t\tcase u < uint64(Millisecond):\n+\t\t\t// print microseconds\n+\t\t\tprec = 3\n+\t\t\tunit = 'u'\n+\t\tdefault:\n+\t\t\t// print milliseconds\n+\t\t\tprec = 6\n+\t\t\tunit = 'm'\n+\t\t}\n+\t\tw -= 2\n+\t\tbuf[w] = unit\n+\t\tbuf[w+1] = 's'\n+\t\tw, u = fmtFrac(buf[:w], u, prec)\n+\t\tw = fmtInt(buf[:w], u)\n+\t} else {\n+\t\tw--\n+\t\tbuf[w] = 's'\n+\n+\t\tw, u = fmtFrac(buf[:w], u, 9)\n+\n+\t\t// u is now integer seconds\n+\t\tw = fmtInt(buf[:w], u%60)\n+\t\tu /= 60\n+\n+\t\t// u is now integer minutes\n+\t\tif u > 0 {\n+\t\t\tw--\n+\t\t\tbuf[w] = 'm'\n+\t\t\tw = fmtInt(buf[:w], u%60)\n+\t\t\tu /= 60\n+\n+\t\t\t// u is now integer hours\n+\t\t\t// Stop at hours because days can be different lengths.\n+\t\t\tif u > 0 {\n+\t\t\t\tw--\n+\t\t\t\tbuf[w] = 'h'\n+\t\t\t\tw = fmtInt(buf[:w], u)\n+\t\t\t}\n+\t\t}\n \t}\n-\tyear += 4 * n\n-\tday -= daysPer4Years * n\n \n-\t// Cut off non-leap years.\n-\tn = day / 365\n-\tif n > 3 { // happens on last day of 4th year\n-\t\tn = 3\n+\tif neg {\n+\t\tw--\n+\t\tbuf[w] = '-'\n \t}\n-\tyear += n\n-\tday -= 365 * n\n \n-\tt.Year = year\n+\treturn string(buf[w:])\n+}\n \n-\t// If someone ever needs yearday,\n-\t// tyearday = day (+1?)\n+// fmtFrac formats the fraction of v/10**prec (e.g., \".12345\") into the\n+// tail of buf, omitting trailing zeros.  it omits the decimal\n+// point too when the fraction is 0.  It returns the index where the\n+// output bytes begin and the value v/10**prec.\n+func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64) {\n+\t// Omit trailing zeros up to and including decimal point.\n+\tw := len(buf)\n+\tprint := false\n+\tfor i := 0; i < prec; i++ {\n+\t\tdigit := v % 10\n+\t\tprint = print || digit != 0\n+\t\tif print {\n+\t\t\tw--\n+\t\t\tbuf[w] = byte(digit) + '0'\n+\t\t}\n+\t\tv /= 10\n+\t}\n+\tif print {\n+\t\tw--\n+\t\tbuf[w] = '.'\n+\t}\n+\treturn w, v\n+}\n \n-\tmonths := months(year)\n-\tvar m int\n-\tyday := int(day)\n-\tfor m = 0; m < 12 && yday >= months[m]; m++ {\n-\t\tyday -= months[m]\n+// fmtInt formats v into the tail of buf.\n+// It returns the index where the output begins.\n+func fmtInt(buf []byte, v uint64) int {\n+\tw := len(buf)\n+\tif v == 0 {\n+\t\tw--\n+\t\tbuf[w] = '0'\n+\t} else {\n+\t\tfor v > 0 {\n+\t\t\tw--\n+\t\t\tbuf[w] = byte(v%10) + '0'\n+\t\t\tv /= 10\n+\t\t}\n \t}\n-\tt.Month = m + 1\n-\tt.Day = yday + 1\n-\tt.Zone = \"UTC\"\n+\treturn w\n+}\n \n-\treturn t\n+// Nanoseconds returns the duration as an integer nanosecond count.\n+func (d Duration) Nanoseconds() int64 { return int64(d) }\n+\n+// These methods return float64 because the dominant\n+// use case is for printing a floating point number like 1.5s, and\n+// a truncation to integer would make them not useful in those cases.\n+// Splitting the integer and fraction ourselves guarantees that\n+// converting the returned float64 to an integer rounds the same\n+// way that a pure integer conversion would have, even in cases\n+// where, say, float64(d.Nanoseconds())/1e9 would have rounded\n+// differently.\n+\n+// Seconds returns the duration as a floating point number of seconds.\n+func (d Duration) Seconds() float64 {\n+\tsec := d / Second\n+\tnsec := d % Second\n+\treturn float64(sec) + float64(nsec)*1e-9\n }\n \n-// NanosecondsToUTC converts nsec, in number of nanoseconds since the Unix epoch,\n-// into a parsed Time value in the UTC time zone.\n-func NanosecondsToUTC(nsec int64) *Time {\n-\t// This one calls SecondsToUTC rather than the other way around because\n-\t// that admits a much larger span of time; NanosecondsToUTC is limited\n-\t// to a few hundred years only.\n-\tt := SecondsToUTC(nsec / 1e9)\n-\tt.Nanosecond = int(nsec % 1e9)\n-\treturn t\n+// Minutes returns the duration as a floating point number of minutes.\n+func (d Duration) Minutes() float64 {\n+\tmin := d / Minute\n+\tnsec := d % Minute\n+\treturn float64(min) + float64(nsec)*(1e-9/60)\n }\n \n-// UTC returns the current time as a parsed Time value in the UTC time zone.\n-func UTC() *Time { return NanosecondsToUTC(Nanoseconds()) }\n+// Hours returns the duration as a floating point number of hours.\n+func (d Duration) Hours() float64 {\n+\thour := d / Hour\n+\tnsec := d % Hour\n+\treturn float64(hour) + float64(nsec)*(1e-9/60/60)\n+}\n \n-// SecondsToLocalTime converts sec, in number of seconds since the Unix epoch,\n-// into a parsed Time value in the local time zone.\n-func SecondsToLocalTime(sec int64) *Time {\n-\tz, offset := lookupTimezone(sec)\n-\tt := SecondsToUTC(sec + int64(offset))\n-\tt.Zone = z\n-\tt.ZoneOffset = offset\n+// Add returns the time t+d.\n+func (t Time) Add(d Duration) Time {\n+\tt.sec += int64(d / 1e9)\n+\tt.nsec += int32(d % 1e9)\n+\tif t.nsec > 1e9 {\n+\t\tt.sec++\n+\t\tt.nsec -= 1e9\n+\t} else if t.nsec < 0 {\n+\t\tt.sec--\n+\t\tt.nsec += 1e9\n+\t}\n \treturn t\n }\n \n-// NanosecondsToLocalTime converts nsec, in number of nanoseconds since the Unix epoch,\n-// into a parsed Time value in the local time zone.\n-func NanosecondsToLocalTime(nsec int64) *Time {\n-\tt := SecondsToLocalTime(nsec / 1e9)\n-\tt.Nanosecond = int(nsec % 1e9)\n-\treturn t\n+// Sub returns the duration t-u.\n+// To compute t-d for a duration d, use t.Add(-d).\n+func (t Time) Sub(u Time) Duration {\n+\treturn Duration(t.sec-u.sec)*Second + Duration(t.nsec-u.nsec)\n }\n \n-// LocalTime returns the current time as a parsed Time value in the local time zone.\n-func LocalTime() *Time { return NanosecondsToLocalTime(Nanoseconds()) }\n-\n-// Seconds returns the number of seconds since January 1, 1970 represented by the\n-// parsed Time value.\n-func (t *Time) Seconds() int64 {\n-\t// First, accumulate days since January 1, 2001.\n-\t// Using 2001 instead of 1970 makes the leap-year\n-\t// handling easier (see SecondsToUTC), because\n-\t// it is at the beginning of the 4-, 100-, and 400-year cycles.\n-\tday := int64(0)\n-\n-\t// Rewrite year to be >= 2001.\n-\tyear := t.Year\n-\tif year < 2001 {\n-\t\tn := (2001-year)/400 + 1\n-\t\tyear += 400 * n\n-\t\tday -= daysPer400Years * n\n+const (\n+\tsecondsPerMinute = 60\n+\tsecondsPerHour   = 60 * 60\n+\tsecondsPerDay    = 24 * secondsPerHour\n+\tsecondsPerWeek   = 7 * secondsPerDay\n+\tdaysPer400Years  = 365*400 + 97\n+\tdaysPer100Years  = 365*100 + 24\n+\tdaysPer4Years    = 365*4 + 1\n+\tdays1970To2001   = 31*365 + 8\n+)\n+\n+// date computes the year and, only when full=true,\n+// the month and day in which t occurs.\n+func (t Time) date(full bool) (year int, month Month, day int, yday int) {\n+\t// Split into time and day.\n+\td := t.abs() / secondsPerDay\n+\n+\t// Account for 400 year cycles.\n+\tn := d / daysPer400Years\n+\ty := 400 * n\n+\td -= daysPer400Years * n\n+\n+\t// Cut off 100-year cycles.\n+\t// The last cycle has one extra leap year, so on the last day\n+\t// of that year, day / daysPer100Years will be 4 instead of 3.\n+\t// Cut it back down to 3 by subtracting n>>2.\n+\tn = d / daysPer100Years\n+\tn -= n >> 2\n+\ty += 100 * n\n+\td -= daysPer100Years * n\n+\n+\t// Cut off 4-year cycles.\n+\t// The last cycle has a missing leap year, which does not\n+\t// affect the computation.\n+\tn = d / daysPer4Years\n+\ty += 4 * n\n+\td -= daysPer4Years * n\n+\n+\t// Cut off years within a 4-year cycle.\n+\t// The last year is a leap year, so on the last day of that year,\n+\t// day / 365 will be 4 instead of 3.  Cut it back down to 3\n+\t// by subtracting n>>2.\n+\tn = d / 365\n+\tn -= n >> 2\n+\ty += n\n+\td -= 365 * n\n+\n+\tyear = int(int64(y) + absoluteZeroYear)\n+\tyday = int(d)\n+\n+\tif !full {\n+\t\treturn\n \t}\n \n-\t// Add in days from 400-year cycles.\n-\tn := (year - 2001) / 400\n-\tyear -= 400 * n\n-\tday += daysPer400Years * n\n+\tday = yday\n+\tif isLeap(year) {\n+\t\t// Leap year\n+\t\tswitch {\n+\t\tcase day > 31+29-1:\n+\t\t\t// After leap day; pretend it wasn't there.\n+\t\t\tday--\n+\t\tcase day == 31+29-1:\n+\t\t\t// Leap day.\n+\t\t\tmonth = February\n+\t\t\tday = 29\n+\t\t\treturn\n+\t\t}\n+\t}\n \n-\t// Add in 100-year cycles.\n-\tn = (year - 2001) / 100\n-\tyear -= 100 * n\n-\tday += daysPer100Years * n\n+\t// Estimate month on assumption that every month has 31 days.\n+\t// The estimate may be too low by at most one month, so adjust.\n+\tmonth = Month(day / 31)\n+\tend := int(daysBefore[month+1])\n+\tvar begin int\n+\tif day >= end {\n+\t\tmonth++\n+\t\tbegin = end\n+\t} else {\n+\t\tbegin = int(daysBefore[month])\n+\t}\n \n-\t// Add in 4-year cycles.\n-\tn = (year - 2001) / 4\n-\tyear -= 4 * n\n-\tday += daysPer4Years * n\n+\tmonth++ // because January is 1\n+\tday = day - begin + 1\n+\treturn\n+}\n \n-\t// Add in non-leap years.\n-\tn = year - 2001\n-\tday += 365 * n\n+// daysBefore[m] counts the number of days in a non-leap year\n+// before month m begins.  There is an entry for m=12, counting\n+// the number of days before January of next year (365).\n+var daysBefore = [...]int32{\n+\t0,\n+\t31,\n+\t31 + 28,\n+\t31 + 28 + 31,\n+\t31 + 28 + 31 + 30,\n+\t31 + 28 + 31 + 30 + 31,\n+\t31 + 28 + 31 + 30 + 31 + 30,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,\n+\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,\n+}\n \n-\t// Add in days this year.\n-\tmonths := months(t.Year)\n-\tfor m := 0; m < t.Month-1; m++ {\n-\t\tday += int64(months[m])\n+func daysIn(m Month, year int) int {\n+\tif m == February && isLeap(year) {\n+\t\treturn 29\n \t}\n-\tday += int64(t.Day - 1)\n-\n-\t// Convert days to seconds since January 1, 2001.\n-\tsec := day * secondsPerDay\n+\treturn int(daysBefore[m+1] - daysBefore[m])\n+}\n \n-\t// Add in time elapsed today.\n-\tsec += int64(t.Hour) * 3600\n-\tsec += int64(t.Minute) * 60\n-\tsec += int64(t.Second)\n+// Provided by package runtime.\n+func now() (sec int64, nsec int32)\n \n-\t// Convert from seconds since 2001 to seconds since 1970.\n-\tsec += days1970To2001 * secondsPerDay\n+// Now returns the current local time.\n+func Now() Time {\n+\tsec, nsec := now()\n+\treturn Time{sec + unixToInternal, nsec, Local}\n+}\n \n-\t// Account for local time zone.\n-\tsec -= int64(t.ZoneOffset)\n-\treturn sec\n+// UTC returns t with the location set to UTC.\n+func (t Time) UTC() Time {\n+\tt.loc = UTC\n+\treturn t\n }\n \n-// Nanoseconds returns the number of nanoseconds since January 1, 1970 represented by the\n-// parsed Time value.\n-func (t *Time) Nanoseconds() int64 {\n-\treturn t.Seconds()*1e9 + int64(t.Nanosecond)\n+// Local returns t with the location set to local time.\n+func (t Time) Local() Time {\n+\tt.loc = Local\n+\treturn t\n }\n \n-// Weekday returns the time's day of the week. Sunday is day 0.\n-func (t *Time) Weekday() int {\n-\tsec := t.Seconds() + int64(t.ZoneOffset)\n-\tday := sec / secondsPerDay\n-\tsec -= day * secondsPerDay\n-\tif sec < 0 {\n-\t\tday--\n+// In returns t with the location information set to loc.\n+//\n+// In panics if loc is nil.\n+func (t Time) In(loc *Location) Time {\n+\tif loc == nil {\n+\t\tpanic(\"time: missing Location in call to Time.In\")\n \t}\n-\t// Day 0 = January 1, 1970 was a Thursday\n-\tweekday := int((day + Thursday) % 7)\n-\tif weekday < 0 {\n-\t\tweekday += 7\n-\t}\n-\treturn weekday\n+\tt.loc = loc\n+\treturn t\n }\n \n-// julianDayNumber returns the time's Julian Day Number\n-// relative to the epoch 12:00 January 1, 4713 BC, Monday.\n-func julianDayNumber(year int64, month, day int) int64 {\n-\ta := int64(14-month) / 12\n-\ty := year + 4800 - a\n-\tm := int64(month) + 12*a - 3\n-\treturn int64(day) + (153*m+2)/5 + 365*y + y/4 - y/100 + y/400 - 32045\n+// Location returns the time zone information associated with t.\n+func (t Time) Location() *Location {\n+\tl := t.loc\n+\tif l == nil {\n+\t\tl = UTC\n+\t}\n+\treturn l\n }\n \n-// startOfFirstWeek returns the julian day number of the first day\n-// of the first week of the given year.\n-func startOfFirstWeek(year int64) (d int64) {\n-\tjan01 := julianDayNumber(year, 1, 1)\n-\tweekday := (jan01 % 7) + 1\n-\tif weekday <= 4 {\n-\t\td = jan01 - weekday + 1\n-\t} else {\n-\t\td = jan01 + 8 - weekday\n-\t}\n+// Zone computes the time zone in effect at time t, returning the abbreviated\n+// name of the zone (such as \"CET\") and its offset in seconds east of UTC.\n+func (t Time) Zone() (name string, offset int) {\n+\tname, offset, _, _, _ = t.loc.lookup(t.sec + internalToUnix)\n \treturn\n }\n \n-// dayOfWeek returns the weekday of the given date.\n-func dayOfWeek(year int64, month, day int) int {\n-\tt := Time{Year: year, Month: month, Day: day}\n-\treturn t.Weekday()\n+// Unix returns the Unix time, the number of seconds elapsed\n+// since January 1, 1970 UTC.\n+func (t Time) Unix() int64 {\n+\treturn t.sec + internalToUnix\n }\n \n-// ISOWeek returns the time's year and week number according to ISO 8601. \n-// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to \n-// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 \n-// of year n+1.\n-func (t *Time) ISOWeek() (year int64, week int) {\n-\td := julianDayNumber(t.Year, t.Month, t.Day)\n-\tweek1Start := startOfFirstWeek(t.Year)\n-\n-\tif d < week1Start {\n-\t\t// Previous year, week 52 or 53\n-\t\tyear = t.Year - 1\n-\t\tif dayOfWeek(t.Year-1, 1, 1) == 4 || dayOfWeek(t.Year-1, 12, 31) == 4 {\n-\t\t\tweek = 53\n-\t\t} else {\n-\t\t\tweek = 52\n+// UnixNano returns the Unix time, the number of nanoseconds elapsed\n+// since January 1, 1970 UTC.\n+func (t Time) UnixNano() int64 {\n+\treturn (t.sec+internalToUnix)*1e9 + int64(t.nsec)\n+}\n+\n+// Unix returns the local Time corresponding to the given Unix time,\n+// sec seconds and nsec nanoseconds since January 1, 1970 UTC.\n+// It is valid to pass nsec outside the range [0, 999999999].\n+func Unix(sec int64, nsec int64) Time {\n+\tif nsec < 0 || nsec >= 1e9 {\n+\t\tn := nsec / 1e9\n+\t\tsec += n\n+\t\tnsec -= n * 1e9\n+\t\tif nsec < 0 {\n+\t\t\tnsec += 1e9\n+\t\t\tsec--\n \t\t}\n-\t\treturn\n \t}\n+\treturn Time{sec + unixToInternal, int32(nsec), Local}\n+}\n+\n+func isLeap(year int) bool {\n+\treturn year%4 == 0 && (year%100 != 0 || year%400 == 0)\n+}\n+\n+// norm returns nhi, nlo such that\n+//\thi * base + lo == nhi * base + nlo\n+//\t0 <= nlo < base\n+func norm(hi, lo, base int) (nhi, nlo int) {\n+\tif lo < 0 {\n+\t\tn := (-lo-1)/base + 1\n+\t\thi -= n\n+\t\tlo += n * base\n+\t}\n+\tif lo >= base {\n+\t\tn := lo / base\n+\t\thi += n\n+\t\tlo -= n * base\n+\t}\n+\treturn hi, lo\n+}\n \n-\tif d < startOfFirstWeek(t.Year+1) {\n-\t\t// Current year, week 01..52(,53)\n-\t\tyear = t.Year\n-\t\tweek = int((d-week1Start)/7 + 1)\n-\t\treturn\n+// Date returns the Time corresponding to\n+//\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\n+// in the appropriate zone for that time in the given location.\n+//\n+// The month, day, hour, min, sec, and nsec values may be outside\n+// their usual ranges and will be normalized during the conversion.\n+// For example, October 32 converts to November 1.\n+//\n+// A daylight savings time transition skips or repeats times.\n+// For example, in the United States, March 13, 2011 2:15am never occurred,\n+// while November 6, 2011 1:15am occurred twice.  In such cases, the\n+// choice of time zone, and therefore the time, is not well-defined.\n+// Date returns a time that is correct in one of the two zones involved\n+// in the transition, but it does not guarantee which.\n+//\n+// Date panics if loc is nil.\n+func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {\n+\tif loc == nil {\n+\t\tpanic(\"time: missing Location in call to Date\")\n \t}\n \n-\t// Next year, week 1\n-\tyear = t.Year + 1\n-\tweek = 1\n-\treturn\n+\t// Normalize month, overflowing into year.\n+\tm := int(month) - 1\n+\tyear, m = norm(year, m, 12)\n+\tmonth = Month(m) + 1\n+\n+\t// Normalize nsec, sec, min, hour, overflowing into day.\n+\tsec, nsec = norm(sec, nsec, 1e9)\n+\tmin, sec = norm(min, sec, 60)\n+\thour, min = norm(hour, min, 60)\n+\tday, hour = norm(day, hour, 24)\n+\n+\ty := uint64(int64(year) - absoluteZeroYear)\n+\n+\t// Compute days since the absolute epoch.\n+\n+\t// Add in days from 400-year cycles.\n+\tn := y / 400\n+\ty -= 400 * n\n+\td := daysPer400Years * n\n+\n+\t// Add in 100-year cycles.\n+\tn = y / 100\n+\ty -= 100 * n\n+\td += daysPer100Years * n\n+\n+\t// Add in 4-year cycles.\n+\tn = y / 4\n+\ty -= 4 * n\n+\td += daysPer4Years * n\n+\n+\t// Add in non-leap years.\n+\tn = y\n+\td += 365 * n\n+\n+\t// Add in days before this month.\n+\td += uint64(daysBefore[month-1])\n+\tif isLeap(year) && month >= March {\n+\t\td++ // February 29\n+\t}\n+\n+\t// Add in days before today.\n+\td += uint64(day - 1)\n+\n+\t// Add in time elapsed today.\n+\tabs := d * secondsPerDay\n+\tabs += uint64(hour*secondsPerHour + min*secondsPerMinute + sec)\n+\n+\tunix := int64(abs) + (absoluteToInternal + internalToUnix)\n+\n+\t// Look for zone offset for t, so we can adjust to UTC.\n+\t// The lookup function expects UTC, so we pass t in the\n+\t// hope that it will not be too close to a zone transition,\n+\t// and then adjust if it is.\n+\t_, offset, _, start, end := loc.lookup(unix)\n+\tif offset != 0 {\n+\t\tswitch utc := unix - int64(offset); {\n+\t\tcase utc < start:\n+\t\t\t_, offset, _, _, _ = loc.lookup(start - 1)\n+\t\tcase utc >= end:\n+\t\t\t_, offset, _, _, _ = loc.lookup(end)\n+\t\t}\n+\t\tunix -= int64(offset)\n+\t}\n+\n+\treturn Time{unix + unixToInternal, int32(nsec), loc}\n }"}, {"sha": "9590e281a66bef30675fa011c285fdd0c140f906", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 220, "deletions": 106, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -16,73 +16,89 @@ import (\n // won't be. The purpose of this test is to at least explain why some of\n // the subsequent tests fail.\n func TestZoneData(t *testing.T) {\n-\tlt := LocalTime()\n+\tlt := Now()\n \t// PST is 8 hours west, PDT is 7 hours west.  We could use the name but it's not unique.\n-\tif off := lt.ZoneOffset; off != -8*60*60 && off != -7*60*60 {\n-\t\tt.Errorf(\"Unable to find US Pacific time zone data for testing; time zone is %q offset %d\", lt.Zone, off)\n+\tif name, off := lt.Zone(); off != -8*60*60 && off != -7*60*60 {\n+\t\tt.Errorf(\"Unable to find US Pacific time zone data for testing; time zone is %q offset %d\", name, off)\n \t\tt.Error(\"Likely problem: the time zone files have not been installed.\")\n \t}\n }\n \n+// parsedTime is the struct representing a parsed time value.\n+type parsedTime struct {\n+\tYear                 int\n+\tMonth                Month\n+\tDay                  int\n+\tHour, Minute, Second int // 15:04:05 is 15, 4, 5.\n+\tNanosecond           int // Fractional second.\n+\tWeekday              Weekday\n+\tZoneOffset           int    // seconds east of UTC, e.g. -7*60*60 for -0700\n+\tZone                 string // e.g., \"MST\"\n+}\n+\n type TimeTest struct {\n \tseconds int64\n-\tgolden  Time\n+\tgolden  parsedTime\n }\n \n var utctests = []TimeTest{\n-\t{0, Time{1970, 1, 1, 0, 0, 0, 0, 0, \"UTC\"}},\n-\t{1221681866, Time{2008, 9, 17, 20, 4, 26, 0, 0, \"UTC\"}},\n-\t{-1221681866, Time{1931, 4, 16, 3, 55, 34, 0, 0, \"UTC\"}},\n-\t{-11644473600, Time{1601, 1, 1, 0, 0, 0, 0, 0, \"UTC\"}},\n-\t{599529660, Time{1988, 12, 31, 0, 1, 0, 0, 0, \"UTC\"}},\n-\t{978220860, Time{2000, 12, 31, 0, 1, 0, 0, 0, \"UTC\"}},\n-\t{1e18, Time{31688740476, 10, 23, 1, 46, 40, 0, 0, \"UTC\"}},\n-\t{-1e18, Time{-31688736537, 3, 10, 22, 13, 20, 0, 0, \"UTC\"}},\n-\t{0x7fffffffffffffff, Time{292277026596, 12, 4, 15, 30, 7, 0, 0, \"UTC\"}},\n-\t{-0x8000000000000000, Time{-292277022657, 1, 27, 8, 29, 52, 0, 0, \"UTC\"}},\n+\t{0, parsedTime{1970, January, 1, 0, 0, 0, 0, Thursday, 0, \"UTC\"}},\n+\t{1221681866, parsedTime{2008, September, 17, 20, 4, 26, 0, Wednesday, 0, \"UTC\"}},\n+\t{-1221681866, parsedTime{1931, April, 16, 3, 55, 34, 0, Thursday, 0, \"UTC\"}},\n+\t{-11644473600, parsedTime{1601, January, 1, 0, 0, 0, 0, Monday, 0, \"UTC\"}},\n+\t{599529660, parsedTime{1988, December, 31, 0, 1, 0, 0, Saturday, 0, \"UTC\"}},\n+\t{978220860, parsedTime{2000, December, 31, 0, 1, 0, 0, Sunday, 0, \"UTC\"}},\n }\n \n var nanoutctests = []TimeTest{\n-\t{0, Time{1970, 1, 1, 0, 0, 0, 1e8, 0, \"UTC\"}},\n-\t{1221681866, Time{2008, 9, 17, 20, 4, 26, 2e8, 0, \"UTC\"}},\n+\t{0, parsedTime{1970, January, 1, 0, 0, 0, 1e8, Thursday, 0, \"UTC\"}},\n+\t{1221681866, parsedTime{2008, September, 17, 20, 4, 26, 2e8, Wednesday, 0, \"UTC\"}},\n }\n \n var localtests = []TimeTest{\n-\t{0, Time{1969, 12, 31, 16, 0, 0, 0, -8 * 60 * 60, \"PST\"}},\n-\t{1221681866, Time{2008, 9, 17, 13, 4, 26, 0, -7 * 60 * 60, \"PDT\"}},\n+\t{0, parsedTime{1969, December, 31, 16, 0, 0, 0, Wednesday, -8 * 60 * 60, \"PST\"}},\n+\t{1221681866, parsedTime{2008, September, 17, 13, 4, 26, 0, Wednesday, -7 * 60 * 60, \"PDT\"}},\n }\n \n var nanolocaltests = []TimeTest{\n-\t{0, Time{1969, 12, 31, 16, 0, 0, 1e8, -8 * 60 * 60, \"PST\"}},\n-\t{1221681866, Time{2008, 9, 17, 13, 4, 26, 3e8, -7 * 60 * 60, \"PDT\"}},\n-}\n-\n-func same(t, u *Time) bool {\n-\treturn t.Year == u.Year &&\n-\t\tt.Month == u.Month &&\n-\t\tt.Day == u.Day &&\n-\t\tt.Hour == u.Hour &&\n-\t\tt.Minute == u.Minute &&\n-\t\tt.Second == u.Second &&\n-\t\tt.Nanosecond == u.Nanosecond &&\n-\t\tt.Weekday() == u.Weekday() &&\n-\t\tt.ZoneOffset == u.ZoneOffset &&\n-\t\tt.Zone == u.Zone\n+\t{0, parsedTime{1969, December, 31, 16, 0, 0, 1e8, Wednesday, -8 * 60 * 60, \"PST\"}},\n+\t{1221681866, parsedTime{2008, September, 17, 13, 4, 26, 3e8, Wednesday, -7 * 60 * 60, \"PDT\"}},\n+}\n+\n+func same(t Time, u *parsedTime) bool {\n+\t// Check aggregates.\n+\tyear, month, day := t.Date()\n+\thour, min, sec := t.Clock()\n+\tname, offset := t.Zone()\n+\tif year != u.Year || month != u.Month || day != u.Day ||\n+\t\thour != u.Hour || min != u.Minute || sec != u.Second ||\n+\t\tname != u.Zone || offset != u.ZoneOffset {\n+\t\treturn false\n+\t}\n+\t// Check individual entries.\n+\treturn t.Year() == u.Year &&\n+\t\tt.Month() == u.Month &&\n+\t\tt.Day() == u.Day &&\n+\t\tt.Hour() == u.Hour &&\n+\t\tt.Minute() == u.Minute &&\n+\t\tt.Second() == u.Second &&\n+\t\tt.Nanosecond() == u.Nanosecond &&\n+\t\tt.Weekday() == u.Weekday\n }\n \n func TestSecondsToUTC(t *testing.T) {\n \tfor _, test := range utctests {\n \t\tsec := test.seconds\n \t\tgolden := &test.golden\n-\t\ttm := SecondsToUTC(sec)\n-\t\tnewsec := tm.Seconds()\n+\t\ttm := Unix(sec, 0).UTC()\n+\t\tnewsec := tm.Unix()\n \t\tif newsec != sec {\n \t\t\tt.Errorf(\"SecondsToUTC(%d).Seconds() = %d\", sec, newsec)\n \t\t}\n \t\tif !same(tm, golden) {\n-\t\t\tt.Errorf(\"SecondsToUTC(%d):\", sec)\n+\t\t\tt.Errorf(\"SecondsToUTC(%d):  // %#v\", sec, tm)\n \t\t\tt.Errorf(\"  want=%+v\", *golden)\n-\t\t\tt.Errorf(\"  have=%+v\", *tm)\n+\t\t\tt.Errorf(\"  have=%v\", tm.Format(RFC3339+\" MST\"))\n \t\t}\n \t}\n }\n@@ -91,15 +107,15 @@ func TestNanosecondsToUTC(t *testing.T) {\n \tfor _, test := range nanoutctests {\n \t\tgolden := &test.golden\n \t\tnsec := test.seconds*1e9 + int64(golden.Nanosecond)\n-\t\ttm := NanosecondsToUTC(nsec)\n-\t\tnewnsec := tm.Nanoseconds()\n+\t\ttm := Unix(0, nsec).UTC()\n+\t\tnewnsec := tm.Unix()*1e9 + int64(tm.Nanosecond())\n \t\tif newnsec != nsec {\n \t\t\tt.Errorf(\"NanosecondsToUTC(%d).Nanoseconds() = %d\", nsec, newnsec)\n \t\t}\n \t\tif !same(tm, golden) {\n \t\t\tt.Errorf(\"NanosecondsToUTC(%d):\", nsec)\n \t\t\tt.Errorf(\"  want=%+v\", *golden)\n-\t\t\tt.Errorf(\"  have=%+v\", *tm)\n+\t\t\tt.Errorf(\"  have=%+v\", tm.Format(RFC3339+\" MST\"))\n \t\t}\n \t}\n }\n@@ -108,38 +124,38 @@ func TestSecondsToLocalTime(t *testing.T) {\n \tfor _, test := range localtests {\n \t\tsec := test.seconds\n \t\tgolden := &test.golden\n-\t\ttm := SecondsToLocalTime(sec)\n-\t\tnewsec := tm.Seconds()\n+\t\ttm := Unix(sec, 0)\n+\t\tnewsec := tm.Unix()\n \t\tif newsec != sec {\n \t\t\tt.Errorf(\"SecondsToLocalTime(%d).Seconds() = %d\", sec, newsec)\n \t\t}\n \t\tif !same(tm, golden) {\n \t\t\tt.Errorf(\"SecondsToLocalTime(%d):\", sec)\n \t\t\tt.Errorf(\"  want=%+v\", *golden)\n-\t\t\tt.Errorf(\"  have=%+v\", *tm)\n+\t\t\tt.Errorf(\"  have=%+v\", tm.Format(RFC3339+\" MST\"))\n \t\t}\n \t}\n }\n \n-func TestNanoecondsToLocalTime(t *testing.T) {\n+func TestNanosecondsToLocalTime(t *testing.T) {\n \tfor _, test := range nanolocaltests {\n \t\tgolden := &test.golden\n \t\tnsec := test.seconds*1e9 + int64(golden.Nanosecond)\n-\t\ttm := NanosecondsToLocalTime(nsec)\n-\t\tnewnsec := tm.Nanoseconds()\n+\t\ttm := Unix(0, nsec)\n+\t\tnewnsec := tm.Unix()*1e9 + int64(tm.Nanosecond())\n \t\tif newnsec != nsec {\n \t\t\tt.Errorf(\"NanosecondsToLocalTime(%d).Seconds() = %d\", nsec, newnsec)\n \t\t}\n \t\tif !same(tm, golden) {\n \t\t\tt.Errorf(\"NanosecondsToLocalTime(%d):\", nsec)\n \t\t\tt.Errorf(\"  want=%+v\", *golden)\n-\t\t\tt.Errorf(\"  have=%+v\", *tm)\n+\t\t\tt.Errorf(\"  have=%+v\", tm.Format(RFC3339+\" MST\"))\n \t\t}\n \t}\n }\n \n func TestSecondsToUTCAndBack(t *testing.T) {\n-\tf := func(sec int64) bool { return SecondsToUTC(sec).Seconds() == sec }\n+\tf := func(sec int64) bool { return Unix(sec, 0).UTC().Unix() == sec }\n \tf32 := func(sec int32) bool { return f(int64(sec)) }\n \tcfg := &quick.Config{MaxCount: 10000}\n \n@@ -153,7 +169,11 @@ func TestSecondsToUTCAndBack(t *testing.T) {\n }\n \n func TestNanosecondsToUTCAndBack(t *testing.T) {\n-\tf := func(nsec int64) bool { return NanosecondsToUTC(nsec).Nanoseconds() == nsec }\n+\tf := func(nsec int64) bool {\n+\t\tt := Unix(0, nsec).UTC()\n+\t\tns := t.Unix()*1e9 + int64(t.Nanosecond())\n+\t\treturn ns == nsec\n+\t}\n \tf32 := func(nsec int32) bool { return f(int64(nsec)) }\n \tcfg := &quick.Config{MaxCount: 10000}\n \n@@ -173,9 +193,9 @@ type TimeFormatTest struct {\n }\n \n var rfc3339Formats = []TimeFormatTest{\n-\t{Time{2008, 9, 17, 20, 4, 26, 0, 0, \"UTC\"}, \"2008-09-17T20:04:26Z\"},\n-\t{Time{1994, 9, 17, 20, 4, 26, 0, -18000, \"EST\"}, \"1994-09-17T20:04:26-05:00\"},\n-\t{Time{2000, 12, 26, 1, 15, 6, 0, 15600, \"OTO\"}, \"2000-12-26T01:15:06+04:20\"},\n+\t{Date(2008, 9, 17, 20, 4, 26, 0, UTC), \"2008-09-17T20:04:26Z\"},\n+\t{Date(1994, 9, 17, 20, 4, 26, 0, FixedZone(\"EST\", -18000)), \"1994-09-17T20:04:26-05:00\"},\n+\t{Date(2000, 12, 26, 1, 15, 6, 0, FixedZone(\"OTO\", 15600)), \"2000-12-26T01:15:06+04:20\"},\n }\n \n func TestRFC3339Conversion(t *testing.T) {\n@@ -216,7 +236,7 @@ var formatTests = []FormatTest{\n \n func TestFormat(t *testing.T) {\n \t// The numeric time represents Thu Feb  4 21:00:57.012345678 PST 2010\n-\ttime := NanosecondsToLocalTime(1233810057012345678)\n+\ttime := Unix(0, 1233810057012345678)\n \tfor _, test := range formatTests {\n \t\tresult := time.Format(test.format)\n \t\tif result != test.result {\n@@ -229,10 +249,10 @@ type ParseTest struct {\n \tname       string\n \tformat     string\n \tvalue      string\n-\thasTZ      bool  // contains a time zone\n-\thasWD      bool  // contains a weekday\n-\tyearSign   int64 // sign of year\n-\tfracDigits int   // number of digits of fractional second\n+\thasTZ      bool // contains a time zone\n+\thasWD      bool // contains a weekday\n+\tyearSign   int  // sign of year\n+\tfracDigits int  // number of digits of fractional second\n }\n \n var parseTests = []ParseTest{\n@@ -298,47 +318,48 @@ func TestRubyParse(t *testing.T) {\n \t}\n }\n \n-func checkTime(time *Time, test *ParseTest, t *testing.T) {\n+func checkTime(time Time, test *ParseTest, t *testing.T) {\n \t// The time should be Thu Feb  4 21:00:57 PST 2010\n-\tif test.yearSign*time.Year != 2010 {\n-\t\tt.Errorf(\"%s: bad year: %d not %d\", test.name, time.Year, 2010)\n+\tif test.yearSign*time.Year() != 2010 {\n+\t\tt.Errorf(\"%s: bad year: %d not %d\", test.name, time.Year(), 2010)\n \t}\n-\tif time.Month != 2 {\n-\t\tt.Errorf(\"%s: bad month: %d not %d\", test.name, time.Month, 2)\n+\tif time.Month() != February {\n+\t\tt.Errorf(\"%s: bad month: %s not %s\", test.name, time.Month(), February)\n \t}\n-\tif time.Day != 4 {\n-\t\tt.Errorf(\"%s: bad day: %d not %d\", test.name, time.Day, 4)\n+\tif time.Day() != 4 {\n+\t\tt.Errorf(\"%s: bad day: %d not %d\", test.name, time.Day(), 4)\n \t}\n-\tif time.Hour != 21 {\n-\t\tt.Errorf(\"%s: bad hour: %d not %d\", test.name, time.Hour, 21)\n+\tif time.Hour() != 21 {\n+\t\tt.Errorf(\"%s: bad hour: %d not %d\", test.name, time.Hour(), 21)\n \t}\n-\tif time.Minute != 0 {\n-\t\tt.Errorf(\"%s: bad minute: %d not %d\", test.name, time.Minute, 0)\n+\tif time.Minute() != 0 {\n+\t\tt.Errorf(\"%s: bad minute: %d not %d\", test.name, time.Minute(), 0)\n \t}\n-\tif time.Second != 57 {\n-\t\tt.Errorf(\"%s: bad second: %d not %d\", test.name, time.Second, 57)\n+\tif time.Second() != 57 {\n+\t\tt.Errorf(\"%s: bad second: %d not %d\", test.name, time.Second(), 57)\n \t}\n \t// Nanoseconds must be checked against the precision of the input.\n \tnanosec, err := strconv.Atoui(\"012345678\"[:test.fracDigits] + \"000000000\"[:9-test.fracDigits])\n \tif err != nil {\n \t\tpanic(err)\n \t}\n-\tif time.Nanosecond != int(nanosec) {\n-\t\tt.Errorf(\"%s: bad nanosecond: %d not %d\", test.name, time.Nanosecond, nanosec)\n+\tif time.Nanosecond() != int(nanosec) {\n+\t\tt.Errorf(\"%s: bad nanosecond: %d not %d\", test.name, time.Nanosecond(), nanosec)\n \t}\n-\tif test.hasTZ && time.ZoneOffset != -28800 {\n-\t\tt.Errorf(\"%s: bad tz offset: %d not %d\", test.name, time.ZoneOffset, -28800)\n+\tname, offset := time.Zone()\n+\tif test.hasTZ && offset != -28800 {\n+\t\tt.Errorf(\"%s: bad tz offset: %s %d not %d\", test.name, name, offset, -28800)\n \t}\n-\tif test.hasWD && time.Weekday() != 4 {\n-\t\tt.Errorf(\"%s: bad weekday: %d not %d\", test.name, time.Weekday(), 4)\n+\tif test.hasWD && time.Weekday() != Thursday {\n+\t\tt.Errorf(\"%s: bad weekday: %s not %s\", test.name, time.Weekday(), Thursday)\n \t}\n }\n \n func TestFormatAndParse(t *testing.T) {\n \tconst fmt = \"Mon MST \" + RFC3339 // all fields\n \tf := func(sec int64) bool {\n-\t\tt1 := SecondsToLocalTime(sec)\n-\t\tif t1.Year < 1000 || t1.Year > 9999 {\n+\t\tt1 := Unix(sec, 0)\n+\t\tif t1.Year() < 1000 || t1.Year() > 9999 {\n \t\t\t// not required to work\n \t\t\treturn true\n \t\t}\n@@ -347,8 +368,8 @@ func TestFormatAndParse(t *testing.T) {\n \t\t\tt.Errorf(\"error: %s\", err)\n \t\t\treturn false\n \t\t}\n-\t\tif !same(t1, t2) {\n-\t\t\tt.Errorf(\"different: %q %q\", t1, t2)\n+\t\tif t1.Unix() != t2.Unix() || t1.Nanosecond() != t2.Nanosecond() {\n+\t\t\tt.Errorf(\"FormatAndParse %d: %q(%d) %q(%d)\", sec, t1, t1.Unix(), t2, t2.Unix())\n \t\t\treturn false\n \t\t}\n \t\treturn true\n@@ -394,7 +415,7 @@ func TestParseErrors(t *testing.T) {\n }\n \n func TestNoonIs12PM(t *testing.T) {\n-\tnoon := Time{Hour: 12}\n+\tnoon := Date(0, January, 1, 12, 0, 0, 0, UTC)\n \tconst expect = \"12:00PM\"\n \tgot := noon.Format(\"3:04PM\")\n \tif got != expect {\n@@ -407,7 +428,7 @@ func TestNoonIs12PM(t *testing.T) {\n }\n \n func TestMidnightIs12AM(t *testing.T) {\n-\tmidnight := Time{Hour: 0}\n+\tmidnight := Date(0, January, 1, 0, 0, 0, 0, UTC)\n \texpect := \"12:00AM\"\n \tgot := midnight.Format(\"3:04PM\")\n \tif got != expect {\n@@ -424,15 +445,15 @@ func Test12PMIsNoon(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"error parsing date:\", err)\n \t}\n-\tif noon.Hour != 12 {\n-\t\tt.Errorf(\"got %d; expect 12\", noon.Hour)\n+\tif noon.Hour() != 12 {\n+\t\tt.Errorf(\"got %d; expect 12\", noon.Hour())\n \t}\n \tnoon, err = Parse(\"03:04PM\", \"12:00PM\")\n \tif err != nil {\n \t\tt.Fatal(\"error parsing date:\", err)\n \t}\n-\tif noon.Hour != 12 {\n-\t\tt.Errorf(\"got %d; expect 12\", noon.Hour)\n+\tif noon.Hour() != 12 {\n+\t\tt.Errorf(\"got %d; expect 12\", noon.Hour())\n \t}\n }\n \n@@ -441,15 +462,15 @@ func Test12AMIsMidnight(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"error parsing date:\", err)\n \t}\n-\tif midnight.Hour != 0 {\n-\t\tt.Errorf(\"got %d; expect 0\", midnight.Hour)\n+\tif midnight.Hour() != 0 {\n+\t\tt.Errorf(\"got %d; expect 0\", midnight.Hour())\n \t}\n \tmidnight, err = Parse(\"03:04PM\", \"12:00AM\")\n \tif err != nil {\n \t\tt.Fatal(\"error parsing date:\", err)\n \t}\n-\tif midnight.Hour != 0 {\n-\t\tt.Errorf(\"got %d; expect 0\", midnight.Hour)\n+\tif midnight.Hour() != 0 {\n+\t\tt.Errorf(\"got %d; expect 0\", midnight.Hour())\n \t}\n }\n \n@@ -463,7 +484,7 @@ func TestMissingZone(t *testing.T) {\n \texpect := \"Thu Feb  2 16:10:03 -0500 2006\" // -0500 not EST\n \tstr := time.Format(UnixDate)               // uses MST as its time zone\n \tif str != expect {\n-\t\tt.Errorf(\"expected %q got %q\", expect, str)\n+\t\tt.Errorf(\"got %s; expect %s\", str, expect)\n \t}\n }\n \n@@ -473,16 +494,17 @@ func TestMinutesInTimeZone(t *testing.T) {\n \t\tt.Fatal(\"error parsing date:\", err)\n \t}\n \texpected := (1*60 + 23) * 60\n-\tif time.ZoneOffset != expected {\n-\t\tt.Errorf(\"ZoneOffset incorrect, expected %d got %d\", expected, time.ZoneOffset)\n+\t_, offset := time.Zone()\n+\tif offset != expected {\n+\t\tt.Errorf(\"ZoneOffset = %d, want %d\", offset, expected)\n \t}\n }\n \n type ISOWeekTest struct {\n-\tyear       int64 // year\n-\tmonth, day int   // month and day\n-\tyex        int64 // expected year\n-\twex        int   // expected week\n+\tyear       int // year\n+\tmonth, day int // month and day\n+\tyex        int // expected year\n+\twex        int // expected week\n }\n \n var isoWeekTests = []ISOWeekTest{\n@@ -524,7 +546,7 @@ var isoWeekTests = []ISOWeekTest{\n func TestISOWeek(t *testing.T) {\n \t// Selected dates and corner cases\n \tfor _, wt := range isoWeekTests {\n-\t\tdt := &Time{Year: wt.year, Month: wt.month, Day: wt.day}\n+\t\tdt := Date(wt.year, Month(wt.month), wt.day, 0, 0, 0, 0, UTC)\n \t\ty, w := dt.ISOWeek()\n \t\tif w != wt.wex || y != wt.yex {\n \t\t\tt.Errorf(\"got %d/%d; expected %d/%d for %d-%02d-%02d\",\n@@ -533,27 +555,91 @@ func TestISOWeek(t *testing.T) {\n \t}\n \n \t// The only real invariant: Jan 04 is in week 1\n-\tfor year := int64(1950); year < 2100; year++ {\n-\t\tif y, w := (&Time{Year: year, Month: 1, Day: 4}).ISOWeek(); y != year || w != 1 {\n+\tfor year := 1950; year < 2100; year++ {\n+\t\tif y, w := Date(year, January, 4, 0, 0, 0, 0, UTC).ISOWeek(); y != year || w != 1 {\n \t\t\tt.Errorf(\"got %d/%d; expected %d/1 for Jan 04\", y, w, year)\n \t\t}\n \t}\n }\n \n-func BenchmarkSeconds(b *testing.B) {\n-\tfor i := 0; i < b.N; i++ {\n-\t\tSeconds()\n+var durationTests = []struct {\n+\tstr string\n+\td   Duration\n+}{\n+\t{\"0\", 0},\n+\t{\"1ns\", 1 * Nanosecond},\n+\t{\"1.1us\", 1100 * Nanosecond},\n+\t{\"2.2ms\", 2200 * Microsecond},\n+\t{\"3.3s\", 3300 * Millisecond},\n+\t{\"4m5s\", 4*Minute + 5*Second},\n+\t{\"4m5.001s\", 4*Minute + 5001*Millisecond},\n+\t{\"5h6m7.001s\", 5*Hour + 6*Minute + 7001*Millisecond},\n+\t{\"8m0.000000001s\", 8*Minute + 1*Nanosecond},\n+\t{\"2562047h47m16.854775807s\", 1<<63 - 1},\n+\t{\"-2562047h47m16.854775808s\", -1 << 63},\n+}\n+\n+func TestDurationString(t *testing.T) {\n+\tfor _, tt := range durationTests {\n+\t\tif str := tt.d.String(); str != tt.str {\n+\t\t\tt.Errorf(\"Duration(%d).String() = %s, want %s\", int64(tt.d), str, tt.str)\n+\t\t}\n+\t\tif tt.d > 0 {\n+\t\t\tif str := (-tt.d).String(); str != \"-\"+tt.str {\n+\t\t\t\tt.Errorf(\"Duration(%d).String() = %s, want %s\", int64(-tt.d), str, \"-\"+tt.str)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n-func BenchmarkNanoseconds(b *testing.B) {\n+var dateTests = []struct {\n+\tyear, month, day, hour, min, sec, nsec int\n+\tz                                      *Location\n+\tunix                                   int64\n+}{\n+\t{2011, 11, 6, 1, 0, 0, 0, Local, 1320566400},   // 1:00:00 PDT\n+\t{2011, 11, 6, 1, 59, 59, 0, Local, 1320569999}, // 1:59:59 PDT\n+\t{2011, 11, 6, 2, 0, 0, 0, Local, 1320573600},   // 2:00:00 PST\n+\n+\t{2011, 3, 13, 1, 0, 0, 0, Local, 1300006800},   // 1:00:00 PST\n+\t{2011, 3, 13, 1, 59, 59, 0, Local, 1300010399}, // 1:59:59 PST\n+\t{2011, 3, 13, 3, 0, 0, 0, Local, 1300010400},   // 3:00:00 PDT\n+\t{2011, 3, 13, 2, 30, 0, 0, Local, 1300008600},  // 2:30:00 PDT \u2261 1:30 PST\n+\n+\t// Many names for Fri Nov 18 7:56:35 PST 2011\n+\t{2011, 11, 18, 7, 56, 35, 0, Local, 1321631795},                 // Nov 18 7:56:35\n+\t{2011, 11, 19, -17, 56, 35, 0, Local, 1321631795},               // Nov 19 -17:56:35\n+\t{2011, 11, 17, 31, 56, 35, 0, Local, 1321631795},                // Nov 17 31:56:35\n+\t{2011, 11, 18, 6, 116, 35, 0, Local, 1321631795},                // Nov 18 6:116:35\n+\t{2011, 10, 49, 7, 56, 35, 0, Local, 1321631795},                 // Oct 49 7:56:35\n+\t{2011, 11, 18, 7, 55, 95, 0, Local, 1321631795},                 // Nov 18 7:55:95\n+\t{2011, 11, 18, 7, 56, 34, 1e9, Local, 1321631795},               // Nov 18 7:56:34 + 10\u2079ns\n+\t{2011, 12, -12, 7, 56, 35, 0, Local, 1321631795},                // Dec -21 7:56:35\n+\t{2012, 1, -43, 7, 56, 35, 0, Local, 1321631795},                 // Jan -52 7:56:35 2012\n+\t{2012, int(January - 2), 18, 7, 56, 35, 0, Local, 1321631795},   // (Jan-2) 18 7:56:35 2012\n+\t{2010, int(December + 11), 18, 7, 56, 35, 0, Local, 1321631795}, // (Dec+11) 18 7:56:35 2010\n+}\n+\n+func TestDate(t *testing.T) {\n+\tfor _, tt := range dateTests {\n+\t\ttime := Date(tt.year, Month(tt.month), tt.day, tt.hour, tt.min, tt.sec, tt.nsec, tt.z)\n+\t\twant := Unix(tt.unix, 0)\n+\t\tif !time.Equal(want) {\n+\t\t\tt.Errorf(\"Date(%d, %d, %d, %d, %d, %d, %d, %s) = %v, want %v\",\n+\t\t\t\ttt.year, tt.month, tt.day, tt.hour, tt.min, tt.sec, tt.nsec, tt.z,\n+\t\t\t\ttime, want)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkNow(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n-\t\tNanoseconds()\n+\t\tNow()\n \t}\n }\n \n func BenchmarkFormat(b *testing.B) {\n-\ttime := SecondsToLocalTime(1265346057)\n+\ttime := Unix(1265346057, 0)\n \tfor i := 0; i < b.N; i++ {\n \t\ttime.Format(\"Mon Jan  2 15:04:05 2006\")\n \t}\n@@ -564,3 +650,31 @@ func BenchmarkParse(b *testing.B) {\n \t\tParse(ANSIC, \"Mon Jan  2 15:04:05 2006\")\n \t}\n }\n+\n+func BenchmarkHour(b *testing.B) {\n+\tt := Now()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = t.Hour()\n+\t}\n+}\n+\n+func BenchmarkSecond(b *testing.B) {\n+\tt := Now()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = t.Second()\n+\t}\n+}\n+\n+func BenchmarkYear(b *testing.B) {\n+\tt := Now()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = t.Year()\n+\t}\n+}\n+\n+func BenchmarkDay(b *testing.B) {\n+\tt := Now()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = t.Day()\n+\t}\n+}"}, {"sha": "aca56e746af1870e8e65d0d54ae9994841029615", "filename": "libgo/go/time/zoneinfo.go", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package time\n+\n+import \"sync\"\n+\n+// A Location maps time instants to the zone in use at that time.\n+// Typically, the Location represents the collection of time offsets\n+// in use in a geographical area, such as CEST and CET for central Europe.\n+type Location struct {\n+\tname string\n+\tzone []zone\n+\ttx   []zoneTrans\n+\n+\t// Most lookups will be for the current time.\n+\t// To avoid the binary search through tx, keep a\n+\t// static one-element cache that gives the correct\n+\t// zone for the time when the Location was created.\n+\t// if cacheStart <= t <= cacheEnd,\n+\t// lookup can return cacheZone.\n+\t// The units for cacheStart and cacheEnd are seconds\n+\t// since January 1, 1970 UTC, to match the argument\n+\t// to lookup.\n+\tcacheStart int64\n+\tcacheEnd   int64\n+\tcacheZone  *zone\n+}\n+\n+// A zone represents a single time zone such as CEST or CET.\n+type zone struct {\n+\tname   string // abbreviated name, \"CET\"\n+\toffset int    // seconds east of UTC\n+\tisDST  bool   // is this zone Daylight Savings Time?\n+}\n+\n+// A zoneTrans represents a single time zone transition.\n+type zoneTrans struct {\n+\twhen         int64 // transition time, in seconds since 1970 GMT\n+\tindex        uint8 // the index of the zone that goes into effect at that time\n+\tisstd, isutc bool  // ignored - no idea what these mean\n+}\n+\n+// UTC represents Universal Coordinated Time (UTC).\n+var UTC *Location = &utcLoc\n+\n+// utcLoc is separate so that get can refer to &utcLoc\n+// and ensure that it never returns a nil *Location,\n+// even if a badly behaved client has changed UTC.\n+var utcLoc = Location{name: \"UTC\"}\n+\n+// Local represents the system's local time zone.\n+var Local *Location = &localLoc\n+\n+// localLoc is separate so that initLocal can initialize\n+// it even if a client has changed Local.\n+var localLoc Location\n+var localOnce sync.Once\n+\n+func (l *Location) get() *Location {\n+\tif l == nil {\n+\t\treturn &utcLoc\n+\t}\n+\tif l == &localLoc {\n+\t\tlocalOnce.Do(initLocal)\n+\t}\n+\treturn l\n+}\n+\n+// String returns a descriptive name for the time zone information,\n+// corresponding to the argument to LoadLocation.\n+func (l *Location) String() string {\n+\treturn l.get().name\n+}\n+\n+// FixedZone returns a Location that always uses\n+// the given zone name and offset (seconds east of UTC).\n+func FixedZone(name string, offset int) *Location {\n+\tl := &Location{\n+\t\tname:       name,\n+\t\tzone:       []zone{{name, offset, false}},\n+\t\ttx:         []zoneTrans{{-1 << 63, 0, false, false}},\n+\t\tcacheStart: -1 << 63,\n+\t\tcacheEnd:   1<<63 - 1,\n+\t}\n+\tl.cacheZone = &l.zone[0]\n+\treturn l\n+}\n+\n+// lookup returns information about the time zone in use at an\n+// instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.\n+//\n+// The returned information gives the name of the zone (such as \"CET\"),\n+// the start and end times bracketing sec when that zone is in effect,\n+// the offset in seconds east of UTC (such as -5*60*60), and whether\n+// the daylight savings is being observed at that time.\n+func (l *Location) lookup(sec int64) (name string, offset int, isDST bool, start, end int64) {\n+\tl = l.get()\n+\n+\tif len(l.tx) == 0 {\n+\t\tname = \"UTC\"\n+\t\toffset = 0\n+\t\tisDST = false\n+\t\tstart = -1 << 63\n+\t\tend = 1<<63 - 1\n+\t\treturn\n+\t}\n+\n+\tif zone := l.cacheZone; zone != nil && l.cacheStart <= sec && sec < l.cacheEnd {\n+\t\tname = zone.name\n+\t\toffset = zone.offset\n+\t\tisDST = zone.isDST\n+\t\tstart = l.cacheStart\n+\t\tend = l.cacheEnd\n+\t\treturn\n+\t}\n+\n+\t// Binary search for entry with largest time <= sec.\n+\t// Not using sort.Search to avoid dependencies.\n+\ttx := l.tx\n+\tend = 1<<63 - 1\n+\tfor len(tx) > 1 {\n+\t\tm := len(tx) / 2\n+\t\tlim := tx[m].when\n+\t\tif sec < lim {\n+\t\t\tend = lim\n+\t\t\ttx = tx[0:m]\n+\t\t} else {\n+\t\t\ttx = tx[m:]\n+\t\t}\n+\t}\n+\tzone := &l.zone[tx[0].index]\n+\tname = zone.name\n+\toffset = zone.offset\n+\tisDST = zone.isDST\n+\tstart = tx[0].when\n+\t// end = maintained during the search\n+\treturn\n+}\n+\n+// lookupName returns information about the time zone with\n+// the given name (such as \"EST\").\n+func (l *Location) lookupName(name string) (offset int, isDST bool, ok bool) {\n+\tl = l.get()\n+\tfor i := range l.zone {\n+\t\tzone := &l.zone[i]\n+\t\tif zone.name == name {\n+\t\t\treturn zone.offset, zone.isDST, true\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// lookupOffset returns information about the time zone with\n+// the given offset (such as -5*60*60).\n+func (l *Location) lookupOffset(offset int) (name string, isDST bool, ok bool) {\n+\tl = l.get()\n+\tfor i := range l.zone {\n+\t\tzone := &l.zone[i]\n+\t\tif zone.offset == offset {\n+\t\t\treturn zone.name, zone.isDST, true\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// NOTE(rsc): Eventually we will need to accept the POSIX TZ environment\n+// syntax too, but I don't feel like implementing it today.\n+\n+// NOTE(rsc): Using the IANA names below means ensuring we have access\n+// to the database.  Probably we will ship the files in $GOROOT/lib/zoneinfo/\n+// and only look there if there are no system files available (such as on Windows).\n+// The files total 200 kB.\n+\n+// LoadLocation returns the Location with the given name.\n+//\n+// If the name is \"\" or \"UTC\", LoadLocation returns UTC.\n+// If the name is \"Local\", LoadLocation returns Local.\n+//\n+// Otherwise, the name is taken to be a location name corresponding to a file\n+// in the IANA Time Zone database, such as \"America/New_York\".\n+func LoadLocation(name string) (*Location, error) {\n+\tif name == \"\" || name == \"UTC\" {\n+\t\treturn UTC, nil\n+\t}\n+\tif name == \"Local\" {\n+\t\treturn Local, nil\n+\t}\n+\treturn loadLocation(name)\n+}"}, {"sha": "38aefc7a977c729b1d2eb6265cbf02b26dcea09e", "filename": "libgo/go/time/zoneinfo_plan9.go", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_plan9.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,11 +6,10 @@\n \n package time\n \n-import (\n-\t\"os\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n+//import (\n+//\t\"strconv\"\n+//\t\"strings\"\n+//)\n \n func parseZones(s string) (zt []zonetime) {\n \tf := strings.Fields(s)\n@@ -49,7 +48,7 @@ func parseZones(s string) (zt []zonetime) {\n \treturn\n }\n \n-func setupZone() {\n+func initLocal() {\n \tt, err := os.Getenverror(\"timezone\")\n \tif err != nil {\n \t\t// do nothing: use UTC\n@@ -58,16 +57,8 @@ func setupZone() {\n \tzones = parseZones(t)\n }\n \n-func setupTestingZone() {\n-\tf, err := os.Open(\"/adm/timezone/US_Pacific\")\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer f.Close()\n-\tl, _ := f.Seek(0, 2)\n-\tf.Seek(0, 0)\n-\tbuf := make([]byte, l)\n-\t_, err = f.Read(buf)\n+func initTestingZone() {\n+\tbuf, err := readFile(\"/adm/timezone/US_Pacific\")\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "b0fa6c33b65afc4dc1f7538d18b30bc3ee7bb58e", "filename": "libgo/go/time/zoneinfo_posix.go", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftime%2Fzoneinfo_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cfbee133027429a681ce585643d38228ab1213/libgo%2Fgo%2Ftime%2Fzoneinfo_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_posix.go?ref=36cfbee133027429a681ce585643d38228ab1213", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin freebsd linux openbsd plan9\n-\n-package time\n-\n-import \"sync\"\n-\n-// Parsed representation\n-type zone struct {\n-\tutcoff int\n-\tisdst  bool\n-\tname   string\n-}\n-\n-type zonetime struct {\n-\ttime         int32 // transition time, in seconds since 1970 GMT\n-\tzone         *zone // the zone that goes into effect at that time\n-\tisstd, isutc bool  // ignored - no idea what these mean\n-}\n-\n-var zones []zonetime\n-var onceSetupZone sync.Once\n-\n-// Look up the correct time zone (daylight savings or not) for the given unix time, in the current location.\n-func lookupTimezone(sec int64) (zone string, offset int) {\n-\tonceSetupZone.Do(setupZone)\n-\tif len(zones) == 0 {\n-\t\treturn \"UTC\", 0\n-\t}\n-\n-\t// Binary search for entry with largest time <= sec\n-\ttz := zones\n-\tfor len(tz) > 1 {\n-\t\tm := len(tz) / 2\n-\t\tif sec < int64(tz[m].time) {\n-\t\t\ttz = tz[0:m]\n-\t\t} else {\n-\t\t\ttz = tz[m:]\n-\t\t}\n-\t}\n-\tz := tz[0].zone\n-\treturn z.name, z.utcoff\n-}\n-\n-// lookupByName returns the time offset for the\n-// time zone with the given abbreviation. It only considers\n-// time zones that apply to the current system.\n-// For example, for a system configured as being in New York,\n-// it only recognizes \"EST\" and \"EDT\".\n-// For a system in San Francisco, \"PST\" and \"PDT\".\n-// For a system in Sydney, \"EST\" and \"EDT\", though they have\n-// different meanings than they do in New York.\n-func lookupByName(name string) (off int, found bool) {\n-\tonceSetupZone.Do(setupZone)\n-\tfor _, z := range zones {\n-\t\tif name == z.zone.name {\n-\t\t\treturn z.zone.utcoff, true\n-\t\t}\n-\t}\n-\treturn 0, false\n-}"}, {"sha": "83d5b983c6ec928bea451b346bc3d5652a8712c8", "filename": "libgo/go/time/zoneinfo_unix.go", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -12,8 +12,8 @@\n package time\n \n import (\n-\t\"bytes\"\n-\t\"os\"\n+\t\"errors\"\n+\t\"syscall\"\n )\n \n const (\n@@ -65,18 +65,20 @@ func byteString(p []byte) string {\n \treturn string(p)\n }\n \n-func parseinfo(bytes []byte) (zt []zonetime, ok bool) {\n+var badData = errors.New(\"malformed time zone information\")\n+\n+func loadZoneData(bytes []byte) (l *Location, err error) {\n \td := data{bytes, false}\n \n \t// 4-byte magic \"TZif\"\n \tif magic := d.read(4); string(magic) != \"TZif\" {\n-\t\treturn nil, false\n+\t\treturn nil, badData\n \t}\n \n \t// 1-byte version, then 15 bytes of padding\n \tvar p []byte\n \tif p = d.read(16); len(p) != 16 || p[0] != 0 && p[0] != '2' {\n-\t\treturn nil, false\n+\t\treturn nil, badData\n \t}\n \n \t// six big-endian 32-bit integers:\n@@ -98,7 +100,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {\n \tfor i := 0; i < 6; i++ {\n \t\tnn, ok := d.big4()\n \t\tif !ok {\n-\t\t\treturn nil, false\n+\t\t\treturn nil, badData\n \t\t}\n \t\tn[i] = int(nn)\n \t}\n@@ -127,7 +129,7 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {\n \tisutc := d.read(n[NUTCLocal])\n \n \tif d.error { // ran out of data\n-\t\treturn nil, false\n+\t\treturn nil, badData\n \t}\n \n \t// If version == 2, the entire file repeats, this time using\n@@ -137,90 +139,119 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {\n \t// Now we can build up a useful data structure.\n \t// First the zone information.\n \t//\tutcoff[4] isdst[1] nameindex[1]\n-\tz := make([]zone, n[NZone])\n-\tfor i := 0; i < len(z); i++ {\n+\tzone := make([]zone, n[NZone])\n+\tfor i := range zone {\n \t\tvar ok bool\n \t\tvar n uint32\n \t\tif n, ok = zonedata.big4(); !ok {\n-\t\t\treturn nil, false\n+\t\t\treturn nil, badData\n \t\t}\n-\t\tz[i].utcoff = int(n)\n+\t\tzone[i].offset = int(n)\n \t\tvar b byte\n \t\tif b, ok = zonedata.byte(); !ok {\n-\t\t\treturn nil, false\n+\t\t\treturn nil, badData\n \t\t}\n-\t\tz[i].isdst = b != 0\n+\t\tzone[i].isDST = b != 0\n \t\tif b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {\n-\t\t\treturn nil, false\n+\t\t\treturn nil, badData\n \t\t}\n-\t\tz[i].name = byteString(abbrev[b:])\n+\t\tzone[i].name = byteString(abbrev[b:])\n \t}\n \n \t// Now the transition time info.\n-\tzt = make([]zonetime, n[NTime])\n-\tfor i := 0; i < len(zt); i++ {\n+\ttx := make([]zoneTrans, n[NTime])\n+\tfor i := range tx {\n \t\tvar ok bool\n \t\tvar n uint32\n \t\tif n, ok = txtimes.big4(); !ok {\n-\t\t\treturn nil, false\n+\t\t\treturn nil, badData\n \t\t}\n-\t\tzt[i].time = int32(n)\n-\t\tif int(txzones[i]) >= len(z) {\n-\t\t\treturn nil, false\n+\t\ttx[i].when = int64(int32(n))\n+\t\tif int(txzones[i]) >= len(zone) {\n+\t\t\treturn nil, badData\n \t\t}\n-\t\tzt[i].zone = &z[txzones[i]]\n+\t\ttx[i].index = txzones[i]\n \t\tif i < len(isstd) {\n-\t\t\tzt[i].isstd = isstd[i] != 0\n+\t\t\ttx[i].isstd = isstd[i] != 0\n \t\t}\n \t\tif i < len(isutc) {\n-\t\t\tzt[i].isutc = isutc[i] != 0\n+\t\t\ttx[i].isutc = isutc[i] != 0\n \t\t}\n \t}\n-\treturn zt, true\n-}\n \n-func readinfofile(name string) ([]zonetime, bool) {\n-\tvar b bytes.Buffer\n+\t// Commited to succeed.\n+\tl = &Location{zone: zone, tx: tx}\n \n-\tf, err := os.Open(name)\n-\tif err != nil {\n-\t\treturn nil, false\n+\t// Fill in the cache with information about right now,\n+\t// since that will be the most common lookup.\n+\tsec, _ := now()\n+\tfor i := range tx {\n+\t\tif tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {\n+\t\t\tl.cacheStart = tx[i].when\n+\t\t\tl.cacheEnd = 1<<63 - 1\n+\t\t\tif i+1 < len(tx) {\n+\t\t\t\tl.cacheEnd = tx[i+1].when\n+\t\t\t}\n+\t\t\tl.cacheZone = &l.zone[tx[i].index]\n+\t\t}\n \t}\n-\tdefer f.Close()\n-\tif _, err := b.ReadFrom(f); err != nil {\n-\t\treturn nil, false\n+\n+\treturn l, nil\n+}\n+\n+func loadZoneFile(name string) (l *Location, err error) {\n+\tbuf, err := readFile(name)\n+\tif err != nil {\n+\t\treturn\n \t}\n-\treturn parseinfo(b.Bytes())\n+\treturn loadZoneData(buf)\n }\n \n-func setupTestingZone() {\n-\tos.Setenv(\"TZ\", \"America/Los_Angeles\")\n-\tsetupZone()\n+func initTestingZone() {\n+\tsyscall.Setenv(\"TZ\", \"America/Los_Angeles\")\n+\tinitLocal()\n }\n \n-func setupZone() {\n+// Many systems use /usr/share/zoneinfo, Solaris 2 has\n+// /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ.\n+var zoneDirs = []string{\n+\t\"/usr/share/zoneinfo/\",\n+\t\"/usr/share/lib/zoneinfo/\",\n+\t\"/usr/lib/locale/TZ/\",\n+}\n+\n+func initLocal() {\n \t// consult $TZ to find the time zone to use.\n \t// no $TZ means use the system default /etc/localtime.\n \t// $TZ=\"\" means use UTC.\n \t// $TZ=\"foo\" means use /usr/share/zoneinfo/foo.\n-\t// Many systems use /usr/share/zoneinfo, Solaris 2 has\n-\t// /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ.\n-\tzoneDirs := []string{\"/usr/share/zoneinfo/\",\n-\t\t\"/usr/share/lib/zoneinfo/\",\n-\t\t\"/usr/lib/locale/TZ/\"}\n \n-\ttz, err := os.Getenverror(\"TZ\")\n+\ttz, ok := syscall.Getenv(\"TZ\")\n \tswitch {\n-\tcase err == os.ENOENV:\n-\t\tzones, _ = readinfofile(\"/etc/localtime\")\n-\tcase len(tz) > 0:\n-\t\tfor _, zoneDir := range zoneDirs {\n-\t\t\tvar ok bool\n-\t\t\tif zones, ok = readinfofile(zoneDir + tz); ok {\n-\t\t\t\tbreak\n-\t\t\t}\n+\tcase !ok:\n+\t\tz, err := loadZoneFile(\"/etc/localtime\")\n+\t\tif err == nil {\n+\t\t\tlocalLoc = *z\n+\t\t\tlocalLoc.name = \"Local\"\n+\t\t\treturn\n+\t\t}\n+\tcase tz != \"\" && tz != \"UTC\":\n+\t\tif z, err := loadLocation(tz); err == nil {\n+\t\t\tlocalLoc = *z\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// Fall back to UTC.\n+\tlocalLoc.name = \"UTC\"\n+}\n+\n+func loadLocation(name string) (*Location, error) {\n+\tfor _, zoneDir := range zoneDirs {\n+\t\tif z, err := loadZoneFile(zoneDir + name); err == nil {\n+\t\t\tz.name = name\n+\t\t\treturn z, nil\n \t\t}\n-\tcase len(tz) == 0:\n-\t\t// do nothing: use UTC\n \t}\n+\treturn nil, errors.New(\"unknown time zone \" + name)\n }"}, {"sha": "beef4de92b077f70f4eca693303531874fa23d92", "filename": "libgo/go/time/zoneinfo_windows.go", "status": "modified", "additions": 93, "deletions": 185, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -5,34 +5,21 @@\n package time\n \n import (\n-\t\"os\"\n-\t\"sync\"\n+\t\"errors\"\n \t\"syscall\"\n )\n \n-// BUG(brainman): The Windows implementation assumes that\n-// this year's rules for daylight savings time apply to all previous\n-// and future years as well.\n-\n-// TODO(brainman): use GetDynamicTimeZoneInformation, whenever possible (Vista and up),\n-// to improve on situation described in the bug above.\n-\n-type zone struct {\n-\tname                  string\n-\toffset                int\n-\tyear                  int64\n-\tmonth, day, dayofweek int\n-\thour, minute, second  int\n-\tabssec                int64\n-\tprev                  *zone\n-}\n+// TODO(rsc): Fall back to copy of zoneinfo files.\n \n-// BUG(rsc): On Windows, time zone abbreviations are unavailable.\n-// This package constructs them using the capital letters from a longer\n-// time zone description.\n+// BUG(brainman,rsc): On Windows, the operating system does not provide complete\n+// time zone information.\n+// The implementation assumes that this year's rules for daylight savings\n+// time apply to all previous and future years as well. \n+// Also, time zone abbreviations are unavailable.  The implementation constructs\n+// them using the capital letters from a longer time zone description.\t\n \n-// Populate zone struct with Windows supplied information. Returns true, if data is valid.\n-func (z *zone) populate(bias, biasdelta int32, d *syscall.Systemtime, name []uint16) (dateisgood bool) {\n+// abbrev returns the abbreviation to use for the given zone name.\n+func abbrev(name []uint16) string {\n \t// name is 'Pacific Standard Time' but we want 'PST'.\n \t// Extract just capital letters.  It's not perfect but the\n \t// information we need is not available from the kernel.\n@@ -41,147 +28,101 @@ func (z *zone) populate(bias, biasdelta int32, d *syscall.Systemtime, name []uin\n \t//\n \t// http://social.msdn.microsoft.com/Forums/eu/vclanguage/thread/a87e1d25-fb71-4fe0-ae9c-a9578c9753eb\n \t// http://stackoverflow.com/questions/4195948/windows-time-zone-abbreviations-in-asp-net\n-\tshort := make([]uint16, len(name))\n-\tw := 0\n+\tvar short []rune\n \tfor _, c := range name {\n \t\tif 'A' <= c && c <= 'Z' {\n-\t\t\tshort[w] = c\n-\t\t\tw++\n-\t\t}\n-\t}\n-\tz.name = syscall.UTF16ToString(short[:w])\n-\n-\tz.offset = int(bias)\n-\tz.year = int64(d.Year)\n-\tz.month = int(d.Month)\n-\tz.day = int(d.Day)\n-\tz.dayofweek = int(d.DayOfWeek)\n-\tz.hour = int(d.Hour)\n-\tz.minute = int(d.Minute)\n-\tz.second = int(d.Second)\n-\tdateisgood = d.Month != 0\n-\tif dateisgood {\n-\t\tz.offset += int(biasdelta)\n-\t}\n-\tz.offset = -z.offset * 60\n-\treturn\n-}\n-\n-// Pre-calculate cutoff time in seconds since the Unix epoch, if data is supplied in \"absolute\" format.\n-func (z *zone) preCalculateAbsSec() {\n-\tif z.year != 0 {\n-\t\tt := &Time{\n-\t\t\tYear:   z.year,\n-\t\t\tMonth:  int(z.month),\n-\t\t\tDay:    int(z.day),\n-\t\t\tHour:   int(z.hour),\n-\t\t\tMinute: int(z.minute),\n-\t\t\tSecond: int(z.second),\n+\t\t\tshort = append(short, rune(c))\n \t\t}\n-\t\tz.abssec = t.Seconds()\n-\t\t// Time given is in \"local\" time. Adjust it for \"utc\".\n-\t\tz.abssec -= int64(z.prev.offset)\n \t}\n+\treturn string(short)\n }\n \n-// Convert zone cutoff time to sec in number of seconds since the Unix epoch, given particular year.\n-func (z *zone) cutoffSeconds(year int64) int64 {\n+// pseudoUnix returns the pseudo-Unix time (seconds since Jan 1 1970 *LOCAL TIME*)\n+// denoted by the system date+time d in the given year.\n+// It is up to the caller to convert this local time into a UTC-based time.\n+func pseudoUnix(year int, d *syscall.Systemtime) int64 {\n \t// Windows specifies daylight savings information in \"day in month\" format:\n-\t// z.month is month number (1-12)\n-\t// z.dayofweek is appropriate weekday (Sunday=0 to Saturday=6)\n-\t// z.day is week within the month (1 to 5, where 5 is last week of the month)\n-\t// z.hour, z.minute and z.second are absolute time\n-\tt := &Time{\n-\t\tYear:   year,\n-\t\tMonth:  int(z.month),\n-\t\tDay:    1,\n-\t\tHour:   int(z.hour),\n-\t\tMinute: int(z.minute),\n-\t\tSecond: int(z.second),\n-\t}\n-\tt = SecondsToUTC(t.Seconds())\n-\ti := int(z.dayofweek) - t.Weekday()\n+\t// d.Month is month number (1-12)\n+\t// d.DayOfWeek is appropriate weekday (Sunday=0 to Saturday=6)\n+\t// d.Day is week within the month (1 to 5, where 5 is last week of the month)\n+\t// d.Hour, d.Minute and d.Second are absolute time\n+\tday := 1\n+\tt := Date(year, Month(d.Month), day, int(d.Hour), int(d.Minute), int(d.Second), 0, UTC)\n+\ti := int(d.DayOfWeek) - int(t.Weekday())\n \tif i < 0 {\n \t\ti += 7\n \t}\n-\tt.Day += i\n-\tif week := int(z.day) - 1; week < 4 {\n-\t\tt.Day += week * 7\n+\tday += i\n+\tif week := int(d.Day) - 1; week < 4 {\n+\t\tday += week * 7\n \t} else {\n \t\t// \"Last\" instance of the day.\n-\t\tt.Day += 4 * 7\n-\t\tif t.Day > months(year)[t.Month] {\n-\t\t\tt.Day -= 7\n+\t\tday += 4 * 7\n+\t\tif day > daysIn(Month(d.Month), year) {\n+\t\t\tday -= 7\n \t\t}\n \t}\n-\t// Result is in \"local\" time. Adjust it for \"utc\".\n-\treturn t.Seconds() - int64(z.prev.offset)\n+\treturn t.sec + int64(day-1)*secondsPerDay + internalToUnix\n }\n \n-// Is t before the cutoff for switching to z?\n-func (z *zone) isBeforeCutoff(t *Time) bool {\n-\tvar coff int64\n-\tif z.year == 0 {\n-\t\t// \"day in month\" format used\n-\t\tcoff = z.cutoffSeconds(t.Year)\n-\t} else {\n-\t\t// \"absolute\" format used\n-\t\tcoff = z.abssec\n-\t}\n-\treturn t.Seconds() < coff\n-}\n-\n-type zoneinfo struct {\n-\tdisabled         bool // daylight saving time is not used locally\n-\toffsetIfDisabled int\n-\tjanuaryIsStd     bool // is january 1 standard time?\n-\tstd, dst         zone\n-}\n+func initLocalFromTZI(i *syscall.Timezoneinformation) {\n+\tl := &localLoc\n \n-// Pick zone (std or dst) t time belongs to.\n-func (zi *zoneinfo) pickZone(t *Time) *zone {\n-\tz := &zi.std\n-\tif tz.januaryIsStd {\n-\t\tif !zi.dst.isBeforeCutoff(t) && zi.std.isBeforeCutoff(t) {\n-\t\t\t// after switch to daylight time and before the switch back to standard\n-\t\t\tz = &zi.dst\n-\t\t}\n-\t} else {\n-\t\tif zi.std.isBeforeCutoff(t) || !zi.dst.isBeforeCutoff(t) {\n-\t\t\t// before switch to standard time or after the switch back to daylight\n-\t\t\tz = &zi.dst\n-\t\t}\n+\tnzone := 1\n+\tif i.StandardDate.Month > 0 {\n+\t\tnzone++\n \t}\n-\treturn z\n-}\n-\n-var tz zoneinfo\n-var initError error\n-var onceSetupZone sync.Once\n+\tl.zone = make([]zone, nzone)\n \n-func setupZone() {\n-\tvar i syscall.Timezoneinformation\n-\tif _, e := syscall.GetTimeZoneInformation(&i); e != nil {\n-\t\tinitError = os.NewSyscallError(\"GetTimeZoneInformation\", e)\n+\tstd := &l.zone[0]\n+\tstd.name = abbrev(i.StandardName[0:])\n+\tif nzone == 1 {\n+\t\t// No daylight savings.\n+\t\tstd.offset = -int(i.Bias) * 60\n+\t\tl.cacheStart = -1 << 63\n+\t\tl.cacheEnd = 1<<63 - 1\n+\t\tl.cacheZone = std\n \t\treturn\n \t}\n-\tsetupZoneFromTZI(&i)\n-}\n \n-func setupZoneFromTZI(i *syscall.Timezoneinformation) {\n-\tif !tz.std.populate(i.Bias, i.StandardBias, &i.StandardDate, i.StandardName[0:]) {\n-\t\ttz.disabled = true\n-\t\ttz.offsetIfDisabled = tz.std.offset\n-\t\treturn\n+\t// StandardBias must be ignored if StandardDate is not set,\n+\t// so this computation is delayed until after the nzone==1\n+\t// return above.\n+\tstd.offset = -int(i.Bias+i.StandardBias) * 60\n+\n+\tdst := &l.zone[1]\n+\tdst.name = abbrev(i.DaylightName[0:])\n+\tdst.offset = -int(i.Bias+i.DaylightBias) * 60\n+\tdst.isDST = true\n+\n+\t// Arrange so that d0 is first transition date, d1 second,\n+\t// i0 is index of zone after first transition, i1 second.\n+\td0 := &i.StandardDate\n+\td1 := &i.DaylightDate\n+\ti0 := 0\n+\ti1 := 1\n+\tif d0.Month > d1.Month {\n+\t\td0, d1 = d1, d0\n+\t\ti0, i1 = i1, i0\n+\t}\n+\n+\t// 2 tx per year, 100 years on each side of this year\n+\tl.tx = make([]zoneTrans, 400)\n+\n+\tt := Now().UTC()\n+\tyear := t.Year()\n+\ttxi := 0\n+\tfor y := year - 100; y < year+100; y++ {\n+\t\ttx := &l.tx[txi]\n+\t\ttx.when = pseudoUnix(y, d0) - int64(l.zone[i1].offset)\n+\t\ttx.index = uint8(i0)\n+\t\ttxi++\n+\n+\t\ttx = &l.tx[txi]\n+\t\ttx.when = pseudoUnix(y, d1) - int64(l.zone[i0].offset)\n+\t\ttx.index = uint8(i1)\n+\t\ttxi++\n \t}\n-\ttz.std.prev = &tz.dst\n-\ttz.dst.populate(i.Bias, i.DaylightBias, &i.DaylightDate, i.DaylightName[0:])\n-\ttz.dst.prev = &tz.std\n-\ttz.std.preCalculateAbsSec()\n-\ttz.dst.preCalculateAbsSec()\n-\t// Is january 1 standard time this year?\n-\tt := UTC()\n-\ttz.januaryIsStd = tz.dst.cutoffSeconds(t.Year) < tz.std.cutoffSeconds(t.Year)\n }\n \n var usPacific = syscall.Timezoneinformation{\n@@ -197,53 +138,20 @@ var usPacific = syscall.Timezoneinformation{\n \tDaylightBias: -60,\n }\n \n-func setupTestingZone() {\n-\tsetupZoneFromTZI(&usPacific)\n+func initTestingZone() {\n+\tinitLocalFromTZI(&usPacific)\n }\n \n-// Look up the correct time zone (daylight savings or not) for the given unix time, in the current location.\n-func lookupTimezone(sec int64) (zone string, offset int) {\n-\tonceSetupZone.Do(setupZone)\n-\tif initError != nil {\n-\t\treturn \"\", 0\n-\t}\n-\tif tz.disabled {\n-\t\treturn \"\", tz.offsetIfDisabled\n-\t}\n-\tt := SecondsToUTC(sec)\n-\tz := &tz.std\n-\tif tz.std.year == 0 {\n-\t\t// \"day in month\" format used\n-\t\tz = tz.pickZone(t)\n-\t} else {\n-\t\t// \"absolute\" format used\n-\t\tif tz.std.year == t.Year {\n-\t\t\t// we have rule for the year in question\n-\t\t\tz = tz.pickZone(t)\n-\t\t} else {\n-\t\t\t// we do not have any information for that year,\n-\t\t\t// will assume standard offset all year around\n-\t\t}\n+func initLocal() {\n+\tvar i syscall.Timezoneinformation\n+\tif _, err := syscall.GetTimeZoneInformation(&i); err != nil {\n+\t\tlocalLoc.name = \"UTC\"\n+\t\treturn\n \t}\n-\treturn z.name, z.offset\n+\tinitLocalFromTZI(&i)\n }\n \n-// lookupByName returns the time offset for the\n-// time zone with the given abbreviation. It only considers\n-// time zones that apply to the current system.\n-func lookupByName(name string) (off int, found bool) {\n-\tonceSetupZone.Do(setupZone)\n-\tif initError != nil {\n-\t\treturn 0, false\n-\t}\n-\tif tz.disabled {\n-\t\treturn tz.offsetIfDisabled, false\n-\t}\n-\tswitch name {\n-\tcase tz.std.name:\n-\t\treturn tz.std.offset, true\n-\tcase tz.dst.name:\n-\t\treturn tz.dst.offset, true\n-\t}\n-\treturn 0, false\n+// TODO(rsc): Implement.\n+func loadLocation(name string) (*Location, error) {\n+\treturn nil, errors.New(\"unknown time zone \" + name)\n }"}, {"sha": "89cdcda71aeda5bd27947c32cac0a3d15e35a3fc", "filename": "libgo/go/websocket/client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fclient.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -72,8 +72,8 @@ A trivial example client:\n \tpackage main\n \n \timport (\n-\t\t\"http\"\n \t\t\"log\"\n+\t\t\"net/http\"\n \t\t\"strings\"\n \t\t\"websocket\"\n \t)"}, {"sha": "ec7b7ae0a452a5ae722f5d87cc37fb5fd7899d9b", "filename": "libgo/go/websocket/hixie.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fhixie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhixie.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -274,7 +274,7 @@ func getChallengeResponse(number1, number2 uint32, key3 []byte) (expected []byte\n \tif _, err = h.Write(challenge); err != nil {\n \t\treturn\n \t}\n-\texpected = h.Sum()\n+\texpected = h.Sum(nil)\n \treturn\n }\n "}, {"sha": "ff386dc7f2105cfbbbee3b1314c3c122fbd5e6c3", "filename": "libgo/go/websocket/hybi.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fhybi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fhybi.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -371,7 +371,7 @@ func getNonceAccept(nonce []byte) (expected []byte, err error) {\n \t\treturn\n \t}\n \texpected = make([]byte, 28)\n-\tbase64.StdEncoding.Encode(expected, h.Sum())\n+\tbase64.StdEncoding.Encode(expected, h.Sum(nil))\n \treturn\n }\n "}, {"sha": "8320b032ead3abae7f65aad00fddfc725a770bfd", "filename": "libgo/go/websocket/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fgo%2Fwebsocket%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fserver.go?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -60,8 +60,8 @@ A trivial example server:\n \tpackage main\n \n \timport (\n-\t\t\"http\"\n \t\t\"io\"\n+\t\t\"net/http\"\n \t\t\"websocket\"\n \t)\n "}, {"sha": "7e5e3e098a99101df3cb5883f4433095402da95f", "filename": "libgo/runtime/go-nanotime.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Fgo-nanotime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Fgo-nanotime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-nanotime.c?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -6,17 +6,16 @@\n \n #include <sys/time.h>\n \n-#include \"go-assert.h\"\n #include \"runtime.h\"\n \n+int64 runtime_nanotime (void)\n+  __attribute__ ((no_split_stack));\n+\n int64\n runtime_nanotime (void)\n {\n-  int i;\n   struct timeval tv;\n \n-  i = gettimeofday (&tv, NULL);\n-  __go_assert (i == 0);\n-\n+  gettimeofday (&tv, NULL);\n   return (int64) tv.tv_sec * 1000000000 + (int64) tv.tv_usec * 1000;\n }"}, {"sha": "5df8085c6a86458f40baf4c498b12e51cf0ef41b", "filename": "libgo/runtime/go-now.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Fgo-now.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Fgo-now.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-now.c?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <sys/time.h>\n+\n+// Return current time.  This is the implementation of time.now().\n+\n+struct time_now_ret\n+{\n+  int64_t sec;\n+  int32_t nsec;\n+};\n+\n+struct time_now_ret now()\n+  __asm__ (\"libgo_time.time.now\")\n+  __attribute__ ((no_split_stack));\n+\n+struct time_now_ret\n+now()\n+{\n+  struct timeval tv;\n+  struct time_now_ret ret;\n+\n+  gettimeofday (&tv, NULL);\n+  ret.sec = tv.tv_sec;\n+  ret.nsec = tv.tv_usec * 1000;\n+  return ret;\n+}"}, {"sha": "cae15e5946a1ae4de33768a6fd481c0d08462a9b", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1c3dd9e670da2041ff1af415999310f88888ad/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=7b1c3dd9e670da2041ff1af415999310f88888ad", "patch": "@@ -18,10 +18,7 @@ static bool deltimer(Timer*);\n // Package time APIs.\n // Godoc uses the comments in package time, not these.\n \n-// Nanoseconds returns the current time in nanoseconds.\n-func Nanoseconds() (ret int64) {\n-\tret = runtime_nanotime();\n-}\n+// time.now is implemented in assembly.\n \n // Sleep puts the current goroutine to sleep for at least ns nanoseconds.\n func Sleep(ns int64) {"}]}