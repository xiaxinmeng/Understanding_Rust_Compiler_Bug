{"sha": "56ee928168998aec1d6b54e265686bd9dc179c40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlZTkyODE2ODk5OGFlYzFkNmI1NGUyNjU2ODZiZDlkYzE3OWM0MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-10-13T22:07:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-13T22:07:24Z"}, "message": "I can't believe I havn't done work on my home machine in nearly a month...\n\n\tI can't believe I havn't done work on my home machine in\n\tnearly a month...\n        * alias.c (base_alias_check): Accept new args for the modes of the\n        two references.  Use them to determine if an AND can overlap.  Update\n        all callers.\n        (memrefs_conflict_p): Assume sizes are aligned, and uses them\n        to determine if an AND can overlap.\n\nFrom-SVN: r23060", "tree": {"sha": "0e2da5f2e7147bccc1aa4a42bc70611a50fecb3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e2da5f2e7147bccc1aa4a42bc70611a50fecb3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56ee928168998aec1d6b54e265686bd9dc179c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ee928168998aec1d6b54e265686bd9dc179c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ee928168998aec1d6b54e265686bd9dc179c40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ee928168998aec1d6b54e265686bd9dc179c40/comments", "author": null, "committer": null, "parents": [{"sha": "7c5fa4cb372689483089341bf4d82355c9fe7ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5fa4cb372689483089341bf4d82355c9fe7ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c5fa4cb372689483089341bf4d82355c9fe7ec8"}], "stats": {"total": 72, "additions": 48, "deletions": 24}, "files": [{"sha": "5dc0e935e90fa4c05837d2e98e85920d3b69bf61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ee928168998aec1d6b54e265686bd9dc179c40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ee928168998aec1d6b54e265686bd9dc179c40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56ee928168998aec1d6b54e265686bd9dc179c40", "patch": "@@ -1,3 +1,11 @@\n+Tue Oct 13 22:05:49 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alias.c (base_alias_check): Accept new args for the modes of the\n+\ttwo references.  Use them to determine if an AND can overlap.  Update\n+\tall callers.\n+\t(memrefs_conflict_p): Assume sizes are aligned, and uses them\n+\tto determine if an AND can overlap.\n+\n Tue Oct 13 17:51:04 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* config/m68k/m68k.h (HARD_REGNO_MODE_OK): For FP regs, add REGNO >= 16"}, {"sha": "4d696ddc47d343850a10a2d21d0890b0ab6d4835", "filename": "gcc/alias.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ee928168998aec1d6b54e265686bd9dc179c40/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ee928168998aec1d6b54e265686bd9dc179c40/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=56ee928168998aec1d6b54e265686bd9dc179c40", "patch": "@@ -36,7 +36,8 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n \t\t\t\t\t       HOST_WIDE_INT));\n static void record_set\t\t\tPROTO((rtx, rtx));\n static rtx find_base_term\t\tPROTO((rtx));\n-static int base_alias_check\t\tPROTO((rtx, rtx));\n+static int base_alias_check\t\tPROTO((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t       enum machine_mode));\n static rtx find_base_value\t\tPROTO((rtx));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n@@ -596,8 +597,9 @@ find_base_term (x)\n    objects, 1 if they might be pointers to the same object.  */\n \n static int\n-base_alias_check (x, y)\n+base_alias_check (x, y, x_mode, y_mode)\n      rtx x, y;\n+     enum machine_mode x_mode, y_mode;\n {\n   rtx x_base = find_base_term (x);\n   rtx y_base = find_base_term (y);\n@@ -629,17 +631,23 @@ base_alias_check (x, y)\n   if (rtx_equal_p (x_base, y_base))\n     return 1;\n \n-  /* The base addresses of the read and write are different\n-     expressions.  If they are both symbols and they are not accessed\n-     via AND, there is no conflict.  */\n-  /* XXX: We can bring knowledge of object alignment and offset into \n-     play here.  For example, on alpha, \"char a, b;\" can alias one\n-     another, though \"char a; long b;\" cannot.  Similarly, offsets\n-     into strutures may be brought into play.  Given \"char a, b[40];\",\n-     a and b[1] may overlap, but a and b[20] do not.  */\n+  /* The base addresses of the read and write are different expressions. \n+     If they are both symbols and they are not accessed via AND, there is\n+     no conflict.  We can bring knowledge of object alignment into play\n+     here.  For example, on alpha, \"char a, b;\" can alias one another,\n+     though \"char a; long b;\" cannot.  */\n   if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)\n     {\n-      return GET_CODE (x) == AND || GET_CODE (y) == AND;\n+      if (GET_CODE (x) == AND && GET_CODE (y) == AND)\n+\treturn 1;\n+      if (GET_CODE (x) == AND\n+\t  && (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t      || GET_MODE_UNIT_SIZE (y_mode) < -INTVAL (XEXP (x, 1))))\n+\treturn 1;\n+      if (GET_CODE (y) == AND\n+\t  && (GET_CODE (XEXP (y, 1)) != CONST_INT\n+\t      || GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))\n+\treturn 1;\n     }\n \n   /* If one address is a stack reference there can be no alias:\n@@ -811,18 +819,24 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n       }\n \n   /* Treat an access through an AND (e.g. a subword access on an Alpha)\n-     as an access with indeterminate size.\n-     ??? Could instead convert an n byte reference at (and x y) to an\n-     n-y byte reference at (plus x y). */\n+     as an access with indeterminate size.  Assume that references \n+     besides AND are aligned, so if the size of the other reference is\n+     at least as large as the alignment, assume no other overlap.  */\n   if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    return memrefs_conflict_p (-1, XEXP (x, 0), ysize, y, c);\n+    {\n+      if (ysize < -INTVAL (XEXP (x, 1)))\n+\txsize = -1;\n+      return memrefs_conflict_p (xsize, XEXP (x, 0), ysize, y, c);\n+    }\n   if (GET_CODE (y) == AND && GET_CODE (XEXP (y, 1)) == CONST_INT)\n     {\n-      /* XXX: If we are indexing far enough into the array/structure, we\n+      /* ??? If we are indexing far enough into the array/structure, we\n \t may yet be able to determine that we can not overlap.  But we \n \t also need to that we are far enough from the end not to overlap\n-\t a following reference, so we do nothing for now.  */\n-      return memrefs_conflict_p (xsize, x, -1, XEXP (y, 0), c);\n+\t a following reference, so we do nothing with that for now.  */\n+      if (xsize < -INTVAL (XEXP (y, 1)))\n+\tysize = -1;\n+      return memrefs_conflict_p (xsize, x, ysize, XEXP (y, 0), c);\n     }\n \n   if (CONSTANT_P (x))\n@@ -917,15 +931,15 @@ true_dependence (mem, mem_mode, x, varies)\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+  if (mem_mode == VOIDmode)\n+    mem_mode = GET_MODE (mem);\n+\n+  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x), mem_mode))\n     return 0;\n \n   x_addr = canon_rtx (XEXP (x, 0));\n   mem_addr = canon_rtx (XEXP (mem, 0));\n \n-  if (mem_mode == VOIDmode)\n-    mem_mode = GET_MODE (mem);\n-\n   if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n \t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n     return 0;\n@@ -974,7 +988,8 @@ anti_dependence (mem, x)\n   if (RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x),\n+\t\t\t  GET_MODE (mem)))\n     return 0;\n \n   x = canon_rtx (x);\n@@ -1008,7 +1023,8 @@ output_dependence (mem, x)\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x),\n+\t\t\t  GET_MODE (mem)))\n     return 0;\n \n   x = canon_rtx (x);"}]}