{"sha": "7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RkZWRkYTRhYWQ4M2RmYzllMWYwMmU2NDJiY2FmYTJhYTI3NzA0NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-11-17T12:51:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-11-17T12:51:20Z"}, "message": "cp-tree.h (TYPE_ALIAS_SET): Document language-dependent uses.\n\n\t* cp-tree.h (TYPE_ALIAS_SET): Document language-dependent uses.\n\t(TYPE_BINFO): Likewise.\n\t(IS_AGGR_TYPE): Tweak.\n\t(SET_IS_AGGR_TYPE): New macro.\n\t(CLASS_TYPE_P): Tweak.\n\t(lang_type): Group mark bitfields together.  Remove linenum.\n\t(CLASSTYPE_SOURCE_LINE): Remove macro.\n\t(CLASSTYPE_MARKED_N): New macro.\n\t(SET_CLASSTYPE_MARKED_N): Likewise.\n\t(CLEAR_CLASSTYPE_MARKED_N): Likewise.\n\t(CLASS_TYPE_MARKED_*): Use them.\n\t(SET_CLASSTYPE_MARKED_*): Likewise.\n\t(CLEAR_CLASSTYPE_MARKED_*): Likewise.\n\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Likewise.\n\t(TYPE_TEMPLATE_INFO): Handle TEMPLATE_TEMPLATE_PARMs as well.\n\t(TYPENAME_TYPE_FULLNAME): Use TYPE_BINFO rather than CLASSTYPE_SIZE.\n\t* class.c (class_cache_obstack): New variable.\n\t(class_cache_firstobj): Likewise.\n\t(finish_struct): Don't set CLASSTYPE_SOURCE_LINE.\n\t(pushclass): Free the cache, when appropriate.\n\t(popclass): Tidy.\n\t(maybe_push_cache_obstack): Use class_cache_obstack.\n\t* decl.c (include hash.h).\n\t(typename_hash): New function.\n\t(typename_compare): Likewise.\n\t(build_typename_type): Check the hash table to avoid creating\n\tduplicates.\n\t(build_ptrmemfunc_type): Use SET_IS_AGGR_TYPE.\n\t(grokdeclarator): Use CLASS_TYPE_P.\n\t(xref_basetypes): Likewise.\n\t(start_function): Likewise.  Don't put current_class_ref on the\n\tpermanent obstack.\n\t* error.c (dump_type_real): Use\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO\n\tand TYPE_TI_ARGS.\n\t* lex.c (note_got_semicolon): Use CLASS_TYPE_P.\n\t(make_lang_type): Don't create TYPE_LANG_SPECIFIC and associated\n\tfields for types other than class types.  Do clear TYPE_ALIAS_SET\n\tfor types other than class types, though.\n\t* method.c (build_overload_identifier): Use CLASS_TYPE_P and\n\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n\t* pt.c (process_template_parm): Don't set\n\tCLASSTYPE_GOT_SEMICOLON.\n\t(lookup_template_class) Use TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n\tCoerce arguments on the momentary obstack.\n\t(for_each_template_parm): Use TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n\t(instantiate_class_template): Calculate template arguments on the\n\tmomentary obstack.  Tidy.\n\t(tsubst_template_arg_vector): Use make_temp_vec.\n\t(tsubst_aggr_type): Put template arguments on the momentary\n\tobstack.\n\t(tsubst_decl): Likewise.\n\t(tsubst): Copy the array bounds index to the permanent obstack\n\tbefore building index types.  Use new macros.\n\t(unify): Use new macros.\n\t(do_type_instantiation): Likewise.\n\t* search.c (lookup_fnfields_1): Use new macros.\n\t(dfs_pushdecls): Build envelopes on the cache obstack.\n\t(dfs_compress_decls): Use new macros.\n\t(push_class_decls): Build on the cache obstack.\n\t* semantics.c (finish_typeof): Don't set CLASSTYPE_GOT_SEMICOLON.\n\t* sign.c (build_signature_pointer_or_reference_type): Use\n\tSET_IS_AGGR_TYPE.\n\t* tree.c (make_binfo): Check CLASS_TYPE_P.\n\t(copy_template_template_parm): Adjust.\n\t(make_temp_vec): Use push_expresion_obstack.\n\t* typeck.c (complete_type): Use new macros.\n\t(comptypes): Likewise.\n\nFrom-SVN: r23686", "tree": {"sha": "3439fd2a750854a5d9ede4589c0ff9cabf158a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3439fd2a750854a5d9ede4589c0ff9cabf158a03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/comments", "author": null, "committer": null, "parents": [{"sha": "990ece87bdd06355a9aaffa1b3ebc1165e102d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990ece87bdd06355a9aaffa1b3ebc1165e102d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/990ece87bdd06355a9aaffa1b3ebc1165e102d31"}], "stats": {"total": 589, "additions": 435, "deletions": 154}, "files": [{"sha": "1102b9ee511af9fb2a1c27823dad49bd99e198d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -1,3 +1,73 @@\n+1998-11-17  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (TYPE_ALIAS_SET): Document language-dependent uses.\n+\t(TYPE_BINFO): Likewise.\n+\t(IS_AGGR_TYPE): Tweak.\n+\t(SET_IS_AGGR_TYPE): New macro.\n+\t(CLASS_TYPE_P): Tweak.\n+\t(lang_type): Group mark bitfields together.  Remove linenum.\n+\t(CLASSTYPE_SOURCE_LINE): Remove macro.\n+\t(CLASSTYPE_MARKED_N): New macro.\n+\t(SET_CLASSTYPE_MARKED_N): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED_N): Likewise.\n+\t(CLASS_TYPE_MARKED_*): Use them.\n+\t(SET_CLASSTYPE_MARKED_*): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED_*): Likewise.\n+\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Likewise.\n+\t(TYPE_TEMPLATE_INFO): Handle TEMPLATE_TEMPLATE_PARMs as well.\n+\t(TYPENAME_TYPE_FULLNAME): Use TYPE_BINFO rather than CLASSTYPE_SIZE.\n+\t* class.c (class_cache_obstack): New variable.\n+\t(class_cache_firstobj): Likewise.\n+\t(finish_struct): Don't set CLASSTYPE_SOURCE_LINE.\n+\t(pushclass): Free the cache, when appropriate.\n+\t(popclass): Tidy.\n+\t(maybe_push_cache_obstack): Use class_cache_obstack.\n+\t* decl.c (include hash.h).\n+\t(typename_hash): New function.\n+\t(typename_compare): Likewise.\n+\t(build_typename_type): Check the hash table to avoid creating\n+\tduplicates.\n+\t(build_ptrmemfunc_type): Use SET_IS_AGGR_TYPE.\n+\t(grokdeclarator): Use CLASS_TYPE_P.\n+\t(xref_basetypes): Likewise.\n+\t(start_function): Likewise.  Don't put current_class_ref on the\n+\tpermanent obstack.\n+\t* error.c (dump_type_real): Use\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO\n+\tand TYPE_TI_ARGS.\n+\t* lex.c (note_got_semicolon): Use CLASS_TYPE_P.\n+\t(make_lang_type): Don't create TYPE_LANG_SPECIFIC and associated\n+\tfields for types other than class types.  Do clear TYPE_ALIAS_SET\n+\tfor types other than class types, though.\n+\t* method.c (build_overload_identifier): Use CLASS_TYPE_P and\n+\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\t* pt.c (process_template_parm): Don't set\n+\tCLASSTYPE_GOT_SEMICOLON.  \n+\t(lookup_template_class) Use TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\tCoerce arguments on the momentary obstack.\n+\t(for_each_template_parm): Use TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\t(instantiate_class_template): Calculate template arguments on the\n+\tmomentary obstack.  Tidy.\n+\t(tsubst_template_arg_vector): Use make_temp_vec.\n+\t(tsubst_aggr_type): Put template arguments on the momentary\n+\tobstack. \n+\t(tsubst_decl): Likewise.\n+\t(tsubst): Copy the array bounds index to the permanent obstack\n+\tbefore building index types.  Use new macros.\n+\t(unify): Use new macros.\n+\t(do_type_instantiation): Likewise.\n+\t* search.c (lookup_fnfields_1): Use new macros.\n+\t(dfs_pushdecls): Build envelopes on the cache obstack.\n+\t(dfs_compress_decls): Use new macros.\n+\t(push_class_decls): Build on the cache obstack.\n+\t* semantics.c (finish_typeof): Don't set CLASSTYPE_GOT_SEMICOLON.\n+\t* sign.c (build_signature_pointer_or_reference_type): Use\n+\tSET_IS_AGGR_TYPE.\n+\t* tree.c (make_binfo): Check CLASS_TYPE_P.\n+\t(copy_template_template_parm): Adjust.\n+\t(make_temp_vec): Use push_expresion_obstack.\n+\t* typeck.c (complete_type): Use new macros.\n+\t(comptypes): Likewise.\n+\t\n 1998-11-17  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (tsubst): Add diagnostics for invalid array, reference"}, {"sha": "463c0f6880d129d24812dd6238c3044b3d1dd22b", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -184,8 +184,8 @@ CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  repo.o @extra_cxx_objs@\n \n # Language-independent object files.\n-OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n-OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n+OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o ../hash.o\n+OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o ../hash.o\n \n compiler: ../cc1plus$(exeext)\n ../cc1plus$(exeext): $(P) $(OBJDEPS) $(CXX_OBJS) $(LIBDEPS)\n@@ -249,7 +249,8 @@ lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n   $(srcdir)/../output.h $(srcdir)/../mbchar.h\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n-  $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../hash.h\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n   $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\"}, {"sha": "766869794cc49218ab5cfd87028d176bdf93f67d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -82,6 +82,12 @@ tree previous_class_type;\t/* _TYPE: the previous type that was a class */\n tree previous_class_values;\t/* TREE_LIST: copy of the class_shadowed list\n \t\t\t\t   when leaving an outermost class scope.  */\n \n+/* The obstack on which the cached class declarations are kept.  */\n+static struct obstack class_cache_obstack;\n+/* The first object allocated on that obstack.  We can use\n+   obstack_free with tis value to free the entire obstack.  */\n+static char *class_cache_firstobj;\n+\n struct base_info;\n \n static tree get_vfield_name PROTO((tree));\n@@ -4404,7 +4410,6 @@ finish_struct (t, attributes, warn_anon)\n \t will fill in the right line number.  (mrs) */\n       if (DECL_SOURCE_LINE (name))\n \tDECL_SOURCE_LINE (name) = lineno;\n-      CLASSTYPE_SOURCE_LINE (t) = lineno;\n       name = DECL_NAME (name);\n     }\n \n@@ -4701,6 +4706,11 @@ pushclass (type, modify)\n       /* Forcibly remove any old class remnants.  */\n       popclass (-1);\n       previous_class_type = NULL_TREE;\n+\n+      /* Now, free the obstack on which we cached all the values.  */\n+      obstack_free (&class_cache_obstack, class_cache_firstobj);\n+      class_cache_firstobj \n+\t= (char*) obstack_finish (&class_cache_obstack);\n     }\n \n   pushlevel_class ();\n@@ -4794,7 +4804,8 @@ popclass (modify)\n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n \t  tags = TREE_CHAIN (tags);\n \t}\n-      goto ret;\n+\n+      return;\n     }\n \n   if (modify)\n@@ -4824,9 +4835,6 @@ popclass (modify)\n   current_class_name = current_class_stack[current_class_depth].name;\n   current_class_type = current_class_stack[current_class_depth].type;\n   current_access_specifier = current_class_stack[current_class_depth].access;\n-\n- ret:\n-  ;\n }\n \n /* Returns 1 if current_class_type is either T or a nested type of T.  */\n@@ -5443,16 +5451,24 @@ print_class_statistics ()\n }\n \n /* Push an obstack which is sufficiently long-lived to hold such class\n-   decls that may be cached in the previous_class_values list.  For now, let's\n-   use the permanent obstack, later we may create a dedicated obstack just\n-   for this purpose.  The effect is undone by pop_obstacks.  */\n+   decls that may be cached in the previous_class_values list. The\n+   effect is undone by pop_obstacks.  */\n \n void\n maybe_push_cache_obstack ()\n {\n+  static int cache_obstack_initialized;\n+\n+  if (!cache_obstack_initialized)\n+    {\n+      gcc_obstack_init (&class_cache_obstack);\n+      class_cache_firstobj \n+\t= (char*) obstack_finish (&class_cache_obstack);\n+      cache_obstack_initialized = 1;\n+    }\n+\n   push_obstacks_nochange ();\n-  if (current_class_depth == 1)\n-    current_obstack = &permanent_obstack;\n+  current_obstack = &class_cache_obstack;\n }\n \n /* Build a dummy reference to ourselves so Derived::Base (and A::A) works,"}, {"sha": "99cb2d9ecd917f53b245557c2dd13f986307a5f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 90, "deletions": 43, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -72,6 +72,19 @@ Boston, MA 02111-1307, USA.  */\n    5: DECL_INTERFACE_KNOWN.\n    6: DECL_THIS_STATIC (in VAR_DECL or FUNCTION_DECL).\n    7: DECL_DEAD_FOR_LOCAL (in VAR_DECL).\n+\n+   Usage of language-independent fields in a language-dependent manner:\n+   \n+   TYPE_ALIAS_SET\n+     This field is used by TYPENAME_TYPEs, TEMPLATE_TYPE_PARMs, and so\n+     forth as a substitute for the mark bits provided in `lang_type'.\n+     At present, only the six low-order bits are used.\n+\n+   TYPE_BINFO\n+     For an ENUMERAL_TYPE, this is ENUM_TEMPLATE_INFO.\n+     For a TYPENAME_TYPE, this is TYPENAME_TYPE_FULLNAME.\n+     For a TEMPLATE_TEMPLATE_PARM, this is\n+     TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n */\n \n /* Language-dependent contents of an identifier.  */\n@@ -517,12 +530,21 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    for template type parameters and typename types.  Despite its name,\n    this macro has nothing to do with the definition of aggregate given\n    in the standard.  Think of this macro as MAYBE_CLASS_TYPE_P.  */\n-#define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n+#define IS_AGGR_TYPE(t)\t\t\t\t\\\n+  (TREE_CODE (t) == TEMPLATE_TYPE_PARM \t\t\\\n+   || TREE_CODE (t) == TYPENAME_TYPE \t\t\\\n+   || TREE_CODE (t) == TYPEOF_TYPE\t\t\\\n+   || TYPE_LANG_FLAG_5 (t))\n+\n+/* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or \n+   union type.  */ \n+#define SET_IS_AGGR_TYPE(T, VAL) \\\n+  (TYPE_LANG_FLAG_5 (T) = (VAL))\n \n /* Nonzero if T is a class type.  Zero for template type parameters,\n    typename types, and so forth.  */\n #define CLASS_TYPE_P(t) \\\n-  (IS_AGGR_TYPE (t) && IS_AGGR_TYPE_CODE (TREE_CODE (t)))\n+  (IS_AGGR_TYPE_CODE (TREE_CODE (t)) && IS_AGGR_TYPE (t))\n \n #define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n@@ -591,11 +613,19 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n #define DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) != -1)\n \f\n-/* Statistics show that while the GNU C++ compiler may generate\n-   thousands of different types during a compilation run, it\n-   generates relatively few (tens) of classtypes.  Because of this,\n-   it is not costly to store a generous amount of information\n-   in classtype nodes.  This struct must fill out to a multiple of 4 bytes.  */\n+/* This structure provides additional information above and beyond\n+   what is provide in the ordinary tree_type.  In the past, we used it\n+   for the types of class types, template parameters types, typename\n+   types, and so forth.  However, there can be many (tens to hundreds\n+   of thousands) of template parameter types in a compilation, and\n+   there's no need for this additional information in that case.\n+   Therefore, we now use this data structure only for class types.\n+\n+   In the past, it was thought that there would be relatively few\n+   class types.  However, in the presence of heavy use of templates,\n+   many (i.e., thousands) of classes can easily be generated.\n+   Therefore, we should endeavor to keep the size of this structure to\n+   a minimum.  */\n struct lang_type\n {\n   struct\n@@ -621,34 +651,29 @@ struct lang_type\n       unsigned has_arrow_overloaded : 1;\n       unsigned interface_only : 1;\n       unsigned interface_unknown : 1;\n-\n       unsigned needs_virtual_reinit : 1;\n+\n+      unsigned marks: 6;\n       unsigned vec_delete_takes_size : 1;\n       unsigned declared_class : 1;\n+\n       unsigned being_defined : 1;\n       unsigned redefined : 1;\n-      unsigned marked : 1;\n-      unsigned marked2 : 1;\n-      unsigned marked3 : 1;\n-\n-      unsigned marked4 : 1;\n-      unsigned marked5 : 1;\n-      unsigned marked6 : 1;\n       unsigned debug_requested : 1;\n       unsigned use_template : 2;\n       unsigned got_semicolon : 1;\n       unsigned ptrmemfunc_flag : 1;\n-\n       unsigned is_signature : 1;\n+\n       unsigned is_signature_pointer : 1;\n       unsigned is_signature_reference : 1;\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n       unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n-\n       unsigned has_const_init_ref : 1;\n+\n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n@@ -695,12 +720,8 @@ struct lang_type\n   union tree_node *signature_reference_to;\n \n   union tree_node *template_info;\n-\n-  int linenum;\n };\n \n-#define CLASSTYPE_SOURCE_LINE(NODE) (TYPE_LANG_SPECIFIC(NODE)->linenum)\n-\n /* Indicates whether or not (and how) a template was expanded for this class.\n      0=no information yet/non-template class\n      1=implicit template instantiation\n@@ -839,25 +860,45 @@ struct lang_type\n #define CLASSTYPE_BASELINK_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->baselink_vec)\n \n /* Mark bits for depth-first and breath-first searches.  */\n-#define CLASSTYPE_MARKED(NODE)  (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked)\n-#define CLASSTYPE_MARKED2(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked2)\n-#define CLASSTYPE_MARKED3(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked3)\n-#define CLASSTYPE_MARKED4(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked4)\n-#define CLASSTYPE_MARKED5(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked5)\n-#define CLASSTYPE_MARKED6(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.marked6)\n+\n+/* Get the value of the Nth mark bit.  */\n+#define CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\t\\\n+  (((CLASS_TYPE_P (NODE) ? TYPE_LANG_SPECIFIC (NODE)->type_flags.marks\t\\\n+     : TYPE_ALIAS_SET (NODE)) & (1 << N)) != 0)\n+\n+/* Set the Nth mark bit.  */\n+#define SET_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\t\\\n+  (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\t\\\n+   ? (TYPE_LANG_SPECIFIC (NODE)->type_flags.marks |= (1 << (N)))\t\\\n+   : (TYPE_ALIAS_SET (NODE) |= (1 << (N))))\n+\n+/* Clear the Nth mark bit.  */\n+#define CLEAR_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n+  (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\t\\\n+   ? (TYPE_LANG_SPECIFIC (NODE)->type_flags.marks &= ~(1 << (N)))\t\\\n+   : (TYPE_ALIAS_SET (NODE) &= ~(1 << (N))))\n+\n+/* Get the value of the mark bits.  */\n+#define CLASSTYPE_MARKED(NODE) CLASSTYPE_MARKED_N(NODE, 0)\n+#define CLASSTYPE_MARKED2(NODE) CLASSTYPE_MARKED_N(NODE, 1)\n+#define CLASSTYPE_MARKED3(NODE) CLASSTYPE_MARKED_N(NODE, 2)\n+#define CLASSTYPE_MARKED4(NODE) CLASSTYPE_MARKED_N(NODE, 3)\n+#define CLASSTYPE_MARKED5(NODE) CLASSTYPE_MARKED_N(NODE, 4)\n+#define CLASSTYPE_MARKED6(NODE) CLASSTYPE_MARKED_N(NODE, 5)\n+\n /* Macros to modify the above flags */\n-#define SET_CLASSTYPE_MARKED(NODE)\t(CLASSTYPE_MARKED(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED(NODE)\t(CLASSTYPE_MARKED(NODE) = 0)\n-#define SET_CLASSTYPE_MARKED2(NODE)\t(CLASSTYPE_MARKED2(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED2(NODE)\t(CLASSTYPE_MARKED2(NODE) = 0)\n-#define SET_CLASSTYPE_MARKED3(NODE)\t(CLASSTYPE_MARKED3(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED3(NODE)\t(CLASSTYPE_MARKED3(NODE) = 0)\n-#define SET_CLASSTYPE_MARKED4(NODE)\t(CLASSTYPE_MARKED4(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED4(NODE)\t(CLASSTYPE_MARKED4(NODE) = 0)\n-#define SET_CLASSTYPE_MARKED5(NODE)\t(CLASSTYPE_MARKED5(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED5(NODE)\t(CLASSTYPE_MARKED5(NODE) = 0)\n-#define SET_CLASSTYPE_MARKED6(NODE)\t(CLASSTYPE_MARKED6(NODE) = 1)\n-#define CLEAR_CLASSTYPE_MARKED6(NODE)\t(CLASSTYPE_MARKED6(NODE) = 0)\n+#define SET_CLASSTYPE_MARKED(NODE)    SET_CLASSTYPE_MARKED_N(NODE, 0)\n+#define CLEAR_CLASSTYPE_MARKED(NODE)  CLEAR_CLASSTYPE_MARKED_N(NODE, 0)\n+#define SET_CLASSTYPE_MARKED2(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 1)\n+#define CLEAR_CLASSTYPE_MARKED2(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 1)\n+#define SET_CLASSTYPE_MARKED3(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 2)\n+#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 2)\t\n+#define SET_CLASSTYPE_MARKED4(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 3)\n+#define CLEAR_CLASSTYPE_MARKED4(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 3)\n+#define SET_CLASSTYPE_MARKED5(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 4)\n+#define CLEAR_CLASSTYPE_MARKED5(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 4)\n+#define SET_CLASSTYPE_MARKED6(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 5)\n+#define CLEAR_CLASSTYPE_MARKED6(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 5)\n \n /* A list of the nested tag-types (class, struct, union, or enum)\n    found within this class.  The TREE_PURPOSE of each node is the name\n@@ -1301,10 +1342,16 @@ struct lang_decl\n    non-type template parameters.  */\n #define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n \n+/* Template information for a template template parameter.  */\n+#define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n+\n /* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n-#define TYPE_TEMPLATE_INFO(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == ENUMERAL_TYPE \t\t\t\t\t\\\n-   ? ENUM_TEMPLATE_INFO (NODE) : CLASSTYPE_TEMPLATE_INFO (NODE))\n+#define TYPE_TEMPLATE_INFO(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\t\\\n+   ? ENUM_TEMPLATE_INFO (NODE) : \t\t\t\\\n+   (TREE_CODE (NODE) == TEMPLATE_TEMPLATE_PARM\t\t\\\n+    ? TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE)\t\\\n+    : CLASSTYPE_TEMPLATE_INFO (NODE)))\n \n /* Set the template information for an ENUMERAL_, RECORD_, or\n    UNION_TYPE to VAL.  */\n@@ -1387,7 +1434,7 @@ struct lang_decl\n    this is an IDENTIFIER_NODE, and the same as the DECL_NAME on the\n    corresponding TYPE_DECL.  However, this may also be a\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n-#define TYPENAME_TYPE_FULLNAME(NODE)\tCLASSTYPE_SIZE (NODE)\n+#define TYPENAME_TYPE_FULLNAME(NODE) TYPE_BINFO (NODE)\n \n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */"}, {"sha": "bd8c5c870c5d4dc24b9a7dd64c1e0d199df88c4f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 105, "deletions": 22, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n+#include \"../hash.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -178,6 +179,8 @@ static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n static void lang_print_error_function PROTO((char *));\n static tree maybe_process_template_type_declaration PROTO((tree, int, struct binding_level*));\n static void check_for_uninitialized_const_var PROTO((tree));\n+static unsigned long typename_hash PROTO((hash_table_key));\n+static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -4778,6 +4781,47 @@ lookup_namespace_name (namespace, name)\n   return error_mark_node;\n }\n \n+/* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n+\n+static unsigned long\n+typename_hash (k)\n+     hash_table_key k;\n+{\n+  unsigned long hash;\n+  tree t;\n+\n+  t = (tree) k;\n+  hash = (((unsigned long) TYPE_CONTEXT (t))\n+\t  ^ ((unsigned long) DECL_NAME (TYPE_NAME (t))));\n+\n+  return hash;\n+}\n+\n+/* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */\n+\n+static boolean\n+typename_compare (k1, k2)\n+     hash_table_key k1;\n+     hash_table_key k2;\n+{\n+  tree t1;\n+  tree t2;\n+  tree d1;\n+  tree d2;\n+\n+  t1 = (tree) k1;\n+  t2 = (tree) k2;\n+  d1 = TYPE_NAME (t1);\n+  d2 = TYPE_NAME (t2);\n+  \n+  return (DECL_NAME (d1) == DECL_NAME (d2)\n+\t  && same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2))\n+\t  && ((TREE_TYPE (t1) != NULL_TREE) \n+\t      == (TREE_TYPE (t2) != NULL_TREE))\n+\t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  && TYPENAME_TYPE_FULLNAME (t1) == TYPENAME_TYPE_FULLNAME (t2));\n+}\n+\n /* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is\n    the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE\n    is non-NULL, this type is being created by the implicit typename\n@@ -4795,25 +4839,43 @@ build_typename_type (context, name, fullname, base_type)\n {\n   tree t;\n   tree d;\n+  struct hash_entry* e;\n \n-  if (processing_template_decl)\n-    push_obstacks (&permanent_obstack, &permanent_obstack);\n+  static struct hash_table ht;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  if (!ht.table\n+      && !hash_table_init (&ht, &hash_newfunc, &typename_hash, \n+\t\t\t   &typename_compare))\n+    fatal (\"virtual memory exhausted\");\n \n   /* Build the TYPENAME_TYPE.  */\n   t = make_lang_type (TYPENAME_TYPE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TYPENAME_TYPE_FULLNAME (t) = fullname;\n   TREE_TYPE (t) = base_type;\n-  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \n   /* Build the corresponding TYPE_DECL.  */\n   d = build_decl (TYPE_DECL, name, t);\n   TYPE_NAME (TREE_TYPE (d)) = d;\n   TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n   DECL_CONTEXT (d) = FROB_CONTEXT (context);\n \n-  if (processing_template_decl)\n-    pop_obstacks ();\n+  /* See if we already have this type.  */\n+  e = hash_lookup (&ht, t, /*create=*/false, /*copy=*/0);\n+  if (e)\n+    {\n+      /* This will free not only TREE_TYPE, but the lang-specific data\n+\t and the TYPE_DECL as well.  */\n+      obstack_free (&permanent_obstack, t);\n+      t = (tree) e->key;\n+    }\n+  else\n+    /* Insert the type into the table.  */\n+    hash_lookup (&ht, t, /*create=*/true, /*copy=*/0);\n+\n+  pop_obstacks ();\n \n   return t;\n }\n@@ -8399,7 +8461,7 @@ build_ptrmemfunc_type (type)\n   push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n \n   u = make_lang_type (UNION_TYPE);\n-  IS_AGGR_TYPE (u) = 0;\n+  SET_IS_AGGR_TYPE (u, 0);\n   fields[0] = build_lang_field_decl (FIELD_DECL, pfn_identifier, type);\n   fields[1] = build_lang_field_decl (FIELD_DECL, delta2_identifier,\n \t\t\t\t     delta_type_node);\n@@ -8411,7 +8473,7 @@ build_ptrmemfunc_type (type)\n   /* Let the front-end know this is a pointer to member function...  */\n   TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* ... and not really an aggregate.  */\n-  IS_AGGR_TYPE (t) = 0;\n+  SET_IS_AGGR_TYPE (t, 0);\n \n   fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n \t\t\t\t     delta_type_node);\n@@ -10074,7 +10136,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    ctype = TREE_OPERAND (declarator, 0);\n \n \t    t = ctype;\n-\t    while (t != NULL_TREE) \n+\t    while (t != NULL_TREE && CLASS_TYPE_P (t)) \n \t      {\n \t\tif (CLASSTYPE_TEMPLATE_INFO (t) &&\n \t\t    !CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n@@ -12001,9 +12063,12 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t     individual inheritance contains flags which say what\n \t     the `accessibility' of that particular inheritance is.)  */\n   \n-\t  base_binfo = make_binfo (integer_zero_node, basetype,\n-\t\t\t\t   TYPE_BINFO_VTABLE (basetype),\n-\t\t\t\t   TYPE_BINFO_VIRTUALS (basetype));\n+\t  base_binfo \n+\t    = make_binfo (integer_zero_node, basetype,\n+\t\t\t  CLASS_TYPE_P (basetype)\n+\t\t\t  ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n+\t\t\t  CLASS_TYPE_P (basetype)\n+\t\t\t  ? TYPE_BINFO_VIRTUALS (basetype) : NULL_TREE);\n  \n \t  TREE_VEC_ELT (binfos, i) = base_binfo;\n \t  TREE_VIA_PUBLIC (base_binfo) = via_public;\n@@ -12025,8 +12090,12 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n \t    }\n \n-\t  TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n-\t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t  if (CLASS_TYPE_P (basetype))\n+\t    {\n+\t      TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n+\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t    }\n+\n \t  i += 1;\n \t}\n     }\n@@ -12038,8 +12107,14 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   if (i > 1)\n     TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n   else if (i == 1)\n-    TYPE_USES_MULTIPLE_INHERITANCE (ref)\n-      = TYPE_USES_MULTIPLE_INHERITANCE (BINFO_TYPE (TREE_VEC_ELT (binfos, 0)));\n+    {\n+      tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, 0));\n+      \n+      if (CLASS_TYPE_P (basetype))\n+\tTYPE_USES_MULTIPLE_INHERITANCE (ref)\n+\t  = TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n+    }\n+\n   if (TYPE_USES_MULTIPLE_INHERITANCE (ref))\n     TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n \n@@ -12466,8 +12541,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       fntype = TREE_TYPE (decl1);\n \n       restype = TREE_TYPE (fntype);\n-      if (IS_AGGR_TYPE (restype) && ! TYPE_PTRMEMFUNC_P (restype)\n-\t  && ! CLASSTYPE_GOT_SEMICOLON (restype))\n+      if (CLASS_TYPE_P (restype) && !CLASSTYPE_GOT_SEMICOLON (restype))\n \t{\n \t  cp_error (\"semicolon missing after declaration of `%#T'\", restype);\n \t  shadow_tag (build_expr_list (NULL_TREE, restype));\n@@ -12678,13 +12752,24 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \n \t  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n \t    {\n-\t      int i = suspend_momentary ();\n+\t      int i;\n \n-\t      /* Fool build_indirect_ref.  */\n+\t      if (! hack_decl_function_context (decl1))\n+\t\ttemporary_allocation ();\n+\t      i = suspend_momentary ();\n+\n+\t      /* Normally, build_indirect_ref returns\n+\t\t current_class_ref whenever current_class_ptr is\n+\t\t dereferenced.  This time, however, we want it to\n+\t\t *create* current_class_ref, so we temporarily clear\n+\t\t current_class_ptr to fool it.  */\n \t      current_class_ptr = NULL_TREE;\n \t      current_class_ref = build_indirect_ref (t, NULL_PTR);\n \t      current_class_ptr = t;\n+\n \t      resume_momentary (i);\n+\t      if (! hack_decl_function_context (decl1))\n+\t\tend_temporary_allocation ();\n \t    }\n \t  else\n \t    /* We're having a signature pointer here.  */\n@@ -12693,9 +12778,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t}\n     }\n   else\n-    {\n-      current_class_ptr = current_class_ref = NULL_TREE;\n-    }\n+    current_class_ptr = current_class_ref = NULL_TREE;\n \n   pushlevel (0);\n   current_binding_level->parm_flag = 1;"}, {"sha": "d754601d4dddab13a07dd4837bc79752fae70d34", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -271,7 +271,7 @@ dump_type_real (t, v, canonical_name)\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n-      if (!CLASSTYPE_TEMPLATE_INFO (t))\n+      if (!TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n \t{\n \t  /* For parameters inside template signature. */\n \t  if (TYPE_IDENTIFIER (t))\n@@ -282,7 +282,7 @@ dump_type_real (t, v, canonical_name)\n       else\n \t{\n \t  int i;\n-\t  tree args = CLASSTYPE_TI_ARGS (t);\n+\t  tree args = TYPE_TI_ARGS (t);\n \t  OB_PUTID (TYPE_IDENTIFIER (t));\n \t  OB_PUTC ('<');\n \t  for (i = 0; i < TREE_VEC_LENGTH (args); i++)"}, {"sha": "5bbb966f9362118ecee357c95f670a0b919222aa", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -2129,7 +2129,7 @@ note_got_semicolon (type)\n {\n   if (TREE_CODE_CLASS (TREE_CODE (type)) != 't')\n     my_friendly_abort (60);\n-  if (IS_AGGR_TYPE (type))\n+  if (CLASS_TYPE_P (type))\n     CLASSTYPE_GOT_SEMICOLON (type) = 1;\n }\n \n@@ -4666,38 +4666,48 @@ make_lang_type (code)\n {\n   extern struct obstack *current_obstack, *saveable_obstack;\n   register tree t = make_node (code);\n-  struct obstack *obstack = current_obstack;\n-  register int i = sizeof (struct lang_type) / sizeof (int);\n-  register int *pi;\n \n   /* Set up some flags that give proper default behavior.  */\n-  IS_AGGR_TYPE (t) = 1;\n+  if (IS_AGGR_TYPE_CODE (code))\n+    {\n+      struct obstack *obstack = current_obstack;\n+      register int i = sizeof (struct lang_type) / sizeof (int);\n+      register int *pi;\n+      \n+      SET_IS_AGGR_TYPE (t, 1);\n \n-  if (! TREE_PERMANENT (t))\n-    obstack = saveable_obstack;\n-  else\n-    my_friendly_assert (obstack == &permanent_obstack, 236);\n+      if (! TREE_PERMANENT (t))\n+\tobstack = saveable_obstack;\n+      else\n+\tmy_friendly_assert (obstack == &permanent_obstack, 236);\n \n-  pi = (int *) obstack_alloc (obstack, sizeof (struct lang_type));\n-  while (i > 0)\n-    pi[--i] = 0;\n+      pi = (int *) obstack_alloc (obstack, sizeof (struct lang_type));\n+      while (i > 0)\n+\tpi[--i] = 0;\n \n-  TYPE_LANG_SPECIFIC (t) = (struct lang_type *) pi;\n-  CLASSTYPE_AS_LIST (t) = build_expr_list (NULL_TREE, t);\n-  SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n-  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-  TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE);\n-  CLASSTYPE_BINFO_AS_LIST (t) = build_tree_list (NULL_TREE, TYPE_BINFO (t));\n+      TYPE_LANG_SPECIFIC (t) = (struct lang_type *) pi;\n+      CLASSTYPE_AS_LIST (t) = build_expr_list (NULL_TREE, t);\n+      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n+      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+      TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE);\n+      CLASSTYPE_BINFO_AS_LIST (t) \n+\t= build_tree_list (NULL_TREE, TYPE_BINFO (t));\n \n-  /* Make sure this is laid out, for ease of use later.\n-     In the presence of parse errors, the normal was of assuring\n-     this might not ever get executed, so we lay it out *immediately*.  */\n-  build_pointer_type (t);\n+      /* Make sure this is laid out, for ease of use later.  In the\n+\t presence of parse errors, the normal was of assuring this\n+\t might not ever get executed, so we lay it out *immediately*.  */\n+      build_pointer_type (t);\n \n #ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)lang_type] += 1;\n-  tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n+      tree_node_counts[(int)lang_type] += 1;\n+      tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n #endif\n+    }\n+  else\n+    /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,\n+       TYPE_ALIAS_SET is initialized to -1 by default, so we must\n+       clear it here.  */\n+    TYPE_ALIAS_SET (t) = 0;\n \n   return t;\n }"}, {"sha": "8428e8529752e8f19bcad78eeda75ca1cad02d43", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -916,7 +916,7 @@ build_overload_identifier (name)\n      tree name;\n {\n   if (TREE_CODE (name) == TYPE_DECL\n-      && IS_AGGR_TYPE (TREE_TYPE (name))\n+      && CLASS_TYPE_P (TREE_TYPE (name))\n       && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name))\n       && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name)))\n \t  || (TREE_CODE (DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE \n@@ -1435,14 +1435,14 @@ process_overload_item (parmtype, extra_Gcode)\n     case TEMPLATE_TEMPLATE_PARM:\n       /* Find and output the original template parameter \n          declaration. */\n-      if (CLASSTYPE_TEMPLATE_INFO (parmtype))\n+      if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parmtype))\n         {\n \t  build_mangled_template_parm_index (\"tzX\",\n \t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n \t\t\t\t\t     (parmtype));\n           build_template_parm_names\n-            (DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n-\t     CLASSTYPE_TI_ARGS (parmtype));\n+            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (parmtype)),\n+\t     TYPE_TI_ARGS (parmtype));\n         }\n       else\n         {"}, {"sha": "9955835244e7a2417734a69465f2b21643a604cb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -1656,7 +1656,6 @@ process_template_parm (list, next)\n \t  decl = build_decl (TYPE_DECL, parm, t);\n \t}\n         \n-      CLASSTYPE_GOT_SEMICOLON (t) = 1;\n       TYPE_NAME (t) = decl;\n       TYPE_STUB_DECL (t) = decl;\n       parm = decl;\n@@ -2885,7 +2884,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     = ((TREE_CODE (arg) == TEMPLATE_DECL\n \t&& TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n        || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-\t   && !CLASSTYPE_TEMPLATE_INFO (arg))\n+\t   && !TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (arg))\n        || (TREE_CODE (arg) == RECORD_TYPE\n \t   && CLASSTYPE_TEMPLATE_INFO (arg)\n \t   && TREE_CODE (TYPE_NAME (arg)) == TYPE_DECL\n@@ -3464,15 +3463,14 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       tree template2 = TYPE_STUB_DECL (parm);\n       tree arglist2;\n \n-      CLASSTYPE_GOT_SEMICOLON (parm) = 1;\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n       arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1);\n       if (arglist2 == error_mark_node)\n \treturn error_mark_node;\n \n       arglist2 = copy_to_permanent (arglist2);\n-      CLASSTYPE_TEMPLATE_INFO (parm)\n+      TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm)\n \t= perm_tree_cons (template2, arglist2, NULL_TREE);\n       TYPE_SIZE (parm) = 0;\n       return parm;\n@@ -3491,6 +3489,10 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       parm_depth = TMPL_PARMS_DEPTH (parmlist);\n       arg_depth = TMPL_ARGS_DEPTH (arglist);\n \n+      /* We build up the coerced arguments and such on the\n+\t momentary_obstack.  */\n+      push_momentary ();\n+\n       if (arg_depth == 1 && parm_depth > 1)\n \t{\n \t  /* We've been given an incomplete set of template arguments.\n@@ -3626,8 +3628,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       \n       if (found)\n \t{\n-\t  if (can_free (&permanent_obstack, arglist))\n-\t    obstack_free (&permanent_obstack, arglist);\n+\t  pop_momentary ();\n \t  return found;\n \t}\n \n@@ -3753,6 +3754,9 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n       /* We're done with the permanent obstack, now.  */\n       pop_obstacks ();\n+      /* We're also done with the momentary allocation we started\n+\t above.  */\n+      pop_momentary ();\n \n       /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n \t is set up.  */\n@@ -3928,8 +3932,8 @@ for_each_template_parm (t, fn, data)\n       /* template parm nodes */\n     case TEMPLATE_TEMPLATE_PARM:\n       /* Record template parameters such as `T' inside `TT<T>'.  */\n-      if (CLASSTYPE_TEMPLATE_INFO (t)\n-\t  && for_each_template_parm (CLASSTYPE_TI_ARGS (t), fn, data))\n+      if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t)\n+\t  && for_each_template_parm (TYPE_TI_ARGS (t), fn, data))\n \treturn 1;\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_PARM_INDEX:\n@@ -4454,6 +4458,12 @@ instantiate_class_template (type)\n   if (TYPE_BEING_DEFINED (type) || TYPE_SIZE (type))\n     return type;\n \n+  /* We want to allocate temporary vectors of template arguments and\n+     template argument expressions on the momentary obstack, not on\n+     the expression obstack.  Otherwise, all the space allocated in\n+     argument coercion and such is simply lost.  */\n+  push_momentary ();\n+\n   template = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n   args = CLASSTYPE_TI_ARGS (type);\n   my_friendly_assert (TREE_CODE (template) == TEMPLATE_DECL, 279);\n@@ -4473,15 +4483,16 @@ instantiate_class_template (type)\n \t    }\n \t}\n       TYPE_BEING_DEFINED (type) = 1;\n-      return error_mark_node;\n+      type = error_mark_node;\n+      goto end;\n     }\n   else if (t)\n     pattern = TREE_TYPE (t);\n   else\n     pattern = TREE_TYPE (template);\n \n   if (TYPE_SIZE (pattern) == NULL_TREE)\n-    return type;\n+    goto end;\n \n   if (t)\n     {\n@@ -4520,13 +4531,13 @@ instantiate_class_template (type)\n \t type as complete so that, for example, declaring one of its\n \t members to be a friend will not be rejected.  */\n       TYPE_SIZE (type) = integer_zero_node;\n-      return type;\n+      goto end;\n     }\n \n   TYPE_BEING_DEFINED (type) = 1;\n \n   if (! push_tinst_level (type))\n-    return type;\n+    goto end;\n \n   maybe_push_to_top_level (uses_template_parms (type));\n   pushclass (type, 0);\n@@ -4598,7 +4609,7 @@ instantiate_class_template (type)\n       TYPE_METHODS (type) = TYPE_METHODS (pattern);\n       CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n       TYPE_SIZE (type) = integer_zero_node;\n-      goto end;\n+      goto done_with_instantiation;\n     }\n \n   {\n@@ -4830,13 +4841,16 @@ instantiate_class_template (type)\n   TYPE_BEING_DEFINED (type) = 0;\n   repo_template_used (type);\n \n- end:\n+ done_with_instantiation:\n   TYPE_BEING_DEFINED (type) = 0;\n   popclass (0);\n \n   pop_from_top_level ();\n   pop_tinst_level ();\n \n+ end:\n+  pop_momentary ();\n+\n   return type;\n }\n \n@@ -4921,7 +4935,7 @@ tsubst_template_arg_vector (t, args)\n   if (!need_new)\n     return t;\n   \n-  t = make_tree_vec (len);\n+  t = make_temp_vec (len);\n   for (i = 0; i < len; i++)\n     TREE_VEC_ELT (t, i) = elts[i];\n   \n@@ -5026,10 +5040,12 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t     and supposing that we are instantiating f<int, double>,\n \t     then our ARGS will be {int, double}, but, when looking up\n \t     S we only want {double}.  */\n-\t  argvec = tsubst (TYPE_TI_ARGS (t), args, in_decl);\n+\t  push_momentary ();\n+\t  argvec = tsubst_template_arg_vector (TYPE_TI_ARGS (t), args);\n \n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope);\n+\t  pop_momentary ();\n \n \t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n \t}\n@@ -5083,14 +5099,18 @@ tsubst_decl (t, args, type, in_decl)\n \t    tree tmpl_args = DECL_CLASS_TEMPLATE_P (t) \n \t      ? CLASSTYPE_TI_ARGS (TREE_TYPE (t))\n \t      : DECL_TI_ARGS (DECL_RESULT (t));\n-\t    tree full_args = tsubst (tmpl_args, args, in_decl);\n+\t    tree full_args;\n+\t    \n+\t    push_momentary ();\n+\t    full_args = tsubst_template_arg_vector (tmpl_args, args);\n \n \t    /* tsubst_template_arg_vector doesn't copy the vector if\n \t       nothing changed.  But, *something* should have\n \t       changed.  */\n \t    my_friendly_assert (full_args != tmpl_args, 0);\n \n \t    spec = retrieve_specialization (t, full_args);\n+\t    pop_momentary ();\n \t    if (spec != NULL_TREE)\n \t      {\n \t\tr = spec;\n@@ -5234,21 +5254,34 @@ tsubst_decl (t, args, type, in_decl)\n \t  {\n \t    tree spec;\n \n+\t    /* Allocate template arguments on the momentary obstack,\n+\t       in case we don't need to keep them.  */\n+\t    push_momentary ();\n+\n \t    /* Calculate the most general template of which R is a\n \t       specialization, and the complete set of arguments used to\n \t       specialize R.  */\n \t    gen_tmpl = most_general_template (DECL_TI_TEMPLATE (t));\n-\t    argvec = tsubst (DECL_TI_ARGS (DECL_TEMPLATE_RESULT (gen_tmpl)),\n-\t\t\t     args, in_decl); \n+\t    argvec \n+\t      = tsubst_template_arg_vector (DECL_TI_ARGS \n+\t\t\t\t\t    (DECL_TEMPLATE_RESULT (gen_tmpl)),\n+\t\t\t\t\t    args); \n \n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n+\n \t    if (spec)\n \t      {\n \t\tr = spec;\n+\t\tpop_momentary ();\n \t\tbreak;\n \t      }\n \n+\t    /* We're going to need to keep the ARGVEC, so we copy it\n+\t       here.  */\n+\t    argvec = copy_to_permanent (argvec);\n+\t    pop_momentary ();\n+\n \t    /* Here, we deal with the peculiar case:\n \n \t\t template <class T> struct S { \n@@ -5375,6 +5408,9 @@ tsubst_decl (t, args, type, in_decl)\n \t   case mentioned above where GEN_TMPL is NULL.  */\n \tif (gen_tmpl)\n \t  {\n+\t    /* The ARGVEC was built on the momentary obstack.  Make it\n+\t       permanent now.  */\n+\t    argvec = copy_to_permanent (argvec);\n \t    DECL_TEMPLATE_INFO (r) \n \t      = perm_tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -5631,6 +5667,7 @@ tsubst (t, args, in_decl)\n \n       {\n \ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n+\n \tmax = tsubst_expr (max, args, in_decl);\n \tif (processing_template_decl)\n \t  {\n@@ -5650,6 +5687,8 @@ tsubst (t, args, in_decl)\n \t  }\n \n \tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n+\tif (!TREE_PERMANENT (max) && !allocation_temporary_p ())\n+\t  max = copy_to_permanent (max);\n \treturn build_index_type (max);\n       }\n \n@@ -5696,11 +5735,11 @@ tsubst (t, args, in_decl)\n \t\t  }\n \t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n-\t\t    if (CLASSTYPE_TEMPLATE_INFO (t))\n+\t\t    if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n \t\t      {\n \t\t\t/* We are processing a type constructed from\n \t\t\t   a template template parameter */\n-\t\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n+\t\t\ttree argvec = tsubst (TYPE_TI_ARGS (t),\n \t\t\t\t\t      args, in_decl);\n \n \t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n@@ -5751,10 +5790,10 @@ tsubst (t, args, in_decl)\n \t    TYPE_REFERENCE_TO (r) = NULL_TREE;\n \n \t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n-\t\t&& CLASSTYPE_TEMPLATE_INFO (t))\n+\t\t&& TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n \t      {\n-\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, in_decl);\n-\t\tCLASSTYPE_TEMPLATE_INFO (r)\n+\t\ttree argvec = tsubst (TYPE_TI_ARGS (t), args, in_decl);\n+\t\tTEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n \t\t  = perm_tree_cons (TYPE_NAME (t), argvec, NULL_TREE);\n \t      }\n \t    break;\n@@ -7348,7 +7387,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \n       if (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n \t{\n-\t  if (CLASSTYPE_TEMPLATE_INFO (parm))\n+\t  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm))\n \t    {\n \t      /* We arrive here when PARM does not involve template \n \t\t specialization.  */\n@@ -7358,8 +7397,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\treturn 1;\n \n \t      {\n-\t\ttree parmtmpl = CLASSTYPE_TI_TEMPLATE (parm);\n-\t\ttree parmvec = CLASSTYPE_TI_ARGS (parm);\n+\t\ttree parmtmpl = TYPE_TI_TEMPLATE (parm);\n+\t\ttree parmvec = TYPE_TI_ARGS (parm);\n \t\ttree argvec = CLASSTYPE_TI_ARGS (arg);\n \t\ttree argtmplvec\n \t\t  = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n@@ -8170,7 +8209,7 @@ do_type_instantiation (t, storage)\n   if (TREE_CODE (t) == TYPE_DECL)\n     t = TREE_TYPE (t);\n \n-  if (! IS_AGGR_TYPE (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n+  if (! CLASS_TYPE_P (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n     {\n       cp_error (\"explicit instantiation of non-template type `%T'\", t);\n       return;"}, {"sha": "ee44bba48048579434da0022a8246b6b4cc31a1b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -1281,7 +1281,8 @@ static int\n lookup_fnfields_1 (type, name)\n      tree type, name;\n {\n-  register tree method_vec = CLASSTYPE_METHOD_VEC (type);\n+  register tree method_vec \n+    = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n \n   if (method_vec != 0)\n     {\n@@ -3006,6 +3007,7 @@ dfs_pushdecls (binfo)\n \n \t  /* If the class value is not an envelope of the kind described in\n \t     the comment above, we create a new envelope.  */\n+\t  maybe_push_cache_obstack ();\n \t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n \t      || TREE_PURPOSE (class_value) == NULL_TREE\n \t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n@@ -3018,10 +3020,11 @@ dfs_pushdecls (binfo)\n \t    }\n \n \t  envelope_add_decl (type, fields, &TREE_PURPOSE (class_value));\n+\t  pop_obstacks ();\n \t}\n     }\n \n-  method_vec = CLASSTYPE_METHOD_VEC (type);\n+  method_vec = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n   if (method_vec && ! dummy)\n     {\n       tree *methods;\n@@ -3043,6 +3046,8 @@ dfs_pushdecls (binfo)\n \t  name = DECL_NAME (OVL_CURRENT (*methods));\n \t  class_value = IDENTIFIER_CLASS_VALUE (name);\n \n+\t  maybe_push_cache_obstack ();\n+\n \t  /* If the class value is not an envelope of the kind described in\n \t     the comment above, we create a new envelope.  */\n \t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n@@ -3059,7 +3064,6 @@ dfs_pushdecls (binfo)\n \t  /* Here we try to rule out possible ambiguities.\n \t     If we can't do that, keep a TREE_LIST with possibly ambiguous\n \t     decls in there.  */\n-\t  maybe_push_cache_obstack ();\n \t  /* Arbitrarily choose the first function in the list.  This is OK\n \t     because this is only used for initial lookup; anything that\n \t     actually uses the function will look it up again.  */\n@@ -3081,7 +3085,8 @@ dfs_compress_decls (binfo)\n      tree binfo;\n {\n   tree type = BINFO_TYPE (binfo);\n-  tree method_vec = CLASSTYPE_METHOD_VEC (type);\n+  tree method_vec \n+    = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n \n   if (processing_template_decl && type != current_class_type\n       && dependent_base_p (binfo))\n@@ -3131,6 +3136,11 @@ push_class_decls (type)\n   struct obstack *ambient_obstack = current_obstack;\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n+  /* Build up all the relevant bindings and such on the cache\n+     obstack.  That way no memory is wasted when we throw away the\n+     cache later.  */\n+  maybe_push_cache_obstack ();\n+\n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarked_pushdecls_p);\n \n@@ -3198,6 +3208,10 @@ push_class_decls (type)\n \tpushdecl_class_level (new);\n       closed_envelopes = TREE_CHAIN (closed_envelopes);\n     }\n+  \n+  /* Undo the call to maybe_push_cache_obstack above.  */\n+  pop_obstacks ();\n+\n   current_obstack = ambient_obstack;\n }\n "}, {"sha": "5e3876f045b3f02120ede3f78784cd2f7eaf66f7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -1616,7 +1616,6 @@ finish_typeof (expr)\n       end_temporary_allocation ();\n \n       t = make_lang_type (TYPEOF_TYPE);\n-      CLASSTYPE_GOT_SEMICOLON (t) = 1;\n       TYPE_FIELDS (t) = expr;\n \n       pop_obstacks ();"}, {"sha": "fdc1ea2f26fde79be5235af762c9b62d02a5461f", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -209,7 +209,7 @@ build_signature_pointer_or_reference_type (to_type, type_quals, refp)\n \t\t\t  TYPE_ALIGN (optr_type));\n \n     /* A signature pointer/reference type isn't a `real' class type.  */\n-    IS_AGGR_TYPE (t) = 0;\n+    SET_IS_AGGR_TYPE (t, 0);\n   }\n \n   {"}, {"sha": "deaa20c90fc51fe86f029194d286ae1c2fa1bde1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -1169,7 +1169,7 @@ make_binfo (offset, binfo, vtable, virtuals)\n   else\n     {\n       type = binfo;\n-      binfo = TYPE_BINFO (binfo);\n+      binfo = CLASS_TYPE_P (type) ? TYPE_BINFO (binfo) : NULL_TREE;\n     }\n \n   TREE_TYPE (new_binfo) = TYPE_MAIN_VARIANT (type);\n@@ -1506,7 +1506,8 @@ copy_template_template_parm (t)\n \n   /* No need to copy these */\n   TYPE_FIELDS (t2) = TYPE_FIELDS (t);\n-  CLASSTYPE_TEMPLATE_INFO (t2) = CLASSTYPE_TEMPLATE_INFO (t);\n+  TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t2) \n+    = TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t);\n   return t2;\n }\n \n@@ -2490,17 +2491,17 @@ cp_tree_equal (t1, t2)\n   return -1;\n }\n \n-/* Similar to make_tree_vec, but build on a temporary obstack.  */\n+/* Similar to make_tree_vec, but build on the momentary_obstack.\n+   Thus, these vectors are really and truly temporary.  */\n \n tree\n make_temp_vec (len)\n      int len;\n {\n   register tree node;\n-  register struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = expression_obstack;\n+  push_expression_obstack ();\n   node = make_tree_vec (len);\n-  current_obstack = ambient_obstack;\n+  pop_obstacks ();\n   return node;\n }\n "}, {"sha": "8f7e329d988c4100949873c5d42164817a050ffe", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ddedda4aad83dfc9e1f02e642bcafa2aa277045/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7ddedda4aad83dfc9e1f02e642bcafa2aa277045", "patch": "@@ -154,7 +154,7 @@ complete_type (type)\n       TYPE_NEEDS_DESTRUCTOR (type)\n \t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (t));\n     }\n-  else if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+  else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n     instantiate_class_template (TYPE_MAIN_VARIANT (type));\n \n   return type;\n@@ -773,19 +773,20 @@ comptypes (type1, type2, strict)\n       if (! comp_template_parms (DECL_TEMPLATE_PARMS (TYPE_NAME (t1)),\n \t\t\t\t DECL_TEMPLATE_PARMS (TYPE_NAME (t2))))\n \treturn 0;\n-      if (! CLASSTYPE_TEMPLATE_INFO (t1) && ! CLASSTYPE_TEMPLATE_INFO (t2))\n+      if (!TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t1) \n+\t  && ! TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t2))\n \treturn 1;\n       /* Don't check inheritance.  */\n       strict = COMPARE_STRICT;\n       /* fall through */\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      if (CLASSTYPE_TEMPLATE_INFO (t1) && CLASSTYPE_TEMPLATE_INFO (t2)\n-\t  && (CLASSTYPE_TI_TEMPLATE (t1) == CLASSTYPE_TI_TEMPLATE (t2)\n+      if (TYPE_TEMPLATE_INFO (t1) && TYPE_TEMPLATE_INFO (t2)\n+\t  && (TYPE_TI_TEMPLATE (t1) == TYPE_TI_TEMPLATE (t2)\n \t      || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM))\n-\tval = comp_template_args (CLASSTYPE_TI_ARGS (t1),\n-\t\t\t\t  CLASSTYPE_TI_ARGS (t2));\n+\tval = comp_template_args (TYPE_TI_ARGS (t1),\n+\t\t\t\t  TYPE_TI_ARGS (t2));\n     look_hard:\n       if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n \t{"}]}