{"sha": "caf07df9db933fc7c97c41060dfa940fa78bb345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmMDdkZjlkYjkzM2ZjN2M5N2M0MTA2MGRmYTk0MGZhNzhiYjM0NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T12:47:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T12:47:19Z"}, "message": "[multiple changes]\n\n2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb Node32 is now used as Encapsulating_State.\n\tNode37 is now used as Associated_Entity.\n\t(Associated_Entity): New routine.\n\t(Encapsulating_State): Update the assertion guard\n\tto include constants.\n\t(Set_Associated_Entity): New routine.\n\t(Set_Encapsulating_State): Update the assertion guard to\n\tinclude constants.\n\t(Write_Field10_Name): Remove the output for Encapsulating_State.\n\t(Write_Field32_Name): Add output for Encapsulating_State.\n\t(Write_Field37_Name): Add output for Associated_Entity.\n\t* einfo.ads New attribute Associated_Entity along with placement\n\tin entities. Attribute Encapsulating_State now uses Node32.\n\t(Associated_Entity): New routine along with pragma Inline.\n\t(Set_Associated_Entity): New routine along with pragma Inline.\n\t* inline.ads Code reformatting.\n\t* sem_attr.adb (Analyze_Attribute): Correct the prefix of\n\tattribute 'Result when the context is a generic instantiation.\n\t(Analyze_Attribute_Old_Result): Pragmas Depends and\n\tRefined_Depends are a valid context for attribute 'Result.\n\t(Denote_Same_Function): Allow attribute 'Result to denote\n\tgeneric functions.\n\t* sem_ch3.adb Add with and use clauses for Sem_Ch12.\n\t(Analyze_Declarations): Capture global references within the\n\tcontracts of packages, subprograms and their respective bodies.\n\t* sem_ch6.adb (Analyze_Aspects_On_Body_Or_Stub): Removed.\n\t(Analyze_Completion_Contract): Removed.\n\t(Analyze_Generic_Subprogram_Body): Enchange the aspects after\n\tcreating the generic copy. Create a generic contract for the\n\ttemplate. Analyze the aspects of the generic body. Analyze the\n\tcontract of the generic body when it is a compilation unit and\n\tcapture global references.\n\t(Analyze_Subprogram_Body_Contract): Code cleanup.\n\t(Analyze_Subprogram_Contract): Do not save global references here.\n\t(Save_Global_References_In_List): Removed.\n\t* sem_ch7.adb (Analyze_Package_Body_Contract): Code cleanup.\n\t(Analyze_Package_Body_Helper): Create a generic contract for\n\tthe template.\n\t(Analyze_Package_Contract): Code cleanup.\n\t* sem_ch10.adb Add with and use clauses for Sem_Ch12.\n\t(Analyze_Compilation_Unit): Capture global references in a\n\tgeneric subprogram declaration that acts as a compilation unit.\n\t* sem_ch12.adb Add with and use clauses for Sem_Prag. Illustrate\n\tthe implementation of generic contracts. Alphabetize various\n\tsubprograms.\n\t(Analyze_Generic_Package_Declaration):\n\tCreate a generic contract for the template.\n\t(Analyze_Generic_Subprogram_Declaration): Create a generic\n\tcontract for the template.\n\t(Analyze_Subprogram_Instantiation): Instantiate the contract of the\n\tsubprogram.\n\t(Copy_Generic_Node): Link defining entities of the generic template\n\twith the corresponding defining entities of the generic copy. Update\n\tthe processing of pragmas.\n\t(Instantiate_Contract): Removed.\n\t(Instantiate_Subprogram_Contract): New routine.\n\t(Requires_Delayed_Save): New routine.\n\t(Save_Global_References): Rename formal parameter N to Templ. Various\n\tcleanups.\n\t(Save_Global_References_In_Aspects): Moved from the spec.\n\t(Save_Global_References_In_Contract): New routine.\n\t(Save_References_In_Aggregate): New routine.\n\t(Save_References_In_Char_Lit_Or_Op_Symbol): New routine.\n\t(Save_References_In_Descendants): New routine.\n\t(Save_References_In_Identifier): New routine.\n\t(Save_References_In_Operator): New routine.\n\t(Save_References_In_Pragma): New routine.\n\t* sem_ch12.ads (Save_Global_References): Rename formal\n\tparameter N to Templ. Update the comment on usage.\n\t(Save_Global_References_In_Aspects): Moved to the body.\n\t(Save_Global_References_In_Contract): New routine.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications_On_Body_Or_Stub):\n\tNew routine.\n\t* sem_ch13.ads (Analyze_Aspect_Specifications_On_Body_Or_Stub):\n\tNew routine.\n\t* sem_prag.adb (Add_Item_To_Name_Buffer): Add support for\n\tgeneric parameters.\n\t(Analyze_Contract_Cases_In_Decl_Part): Code cleanup.\n\t(Analyze_Depends_Global): New routine.\n\t(Analyze_Depends_In_Decl_Part): Code cleanup.\n\t(Analyze_Global_In_Decl_Part): Code cleanup.\n\t(Analyze_Global_Item): Constants are now valid global items. Do\n\tnot perform state-related checks in an instance. Change the way\n\trenamings are handled.\t(Analyze_Initial_Condition_In_Decl_Part):\n\tCode cleanup.\n\t(Analyze_Initializes_In_Decl_Part): Code cleanup.\n\t(Analyze_Input_Output): The analysis of attribute 'Result in\n\tthe context of pragmas Depends or Refined_Depends now reuses\n\tthe existing attribute analysis machinery. Constants and\n\tgeneric parameters are now valid dependency items. Do not\n\tperform state-related checks in an instance. Change the way\n\trenamings are handled.\t(Analyze_Pragma): Add a \"characteristics\"\n\tsection for pragmas Abstract_State, Contract_Cases, Depends,\n\tExtensions_Visible, Global, Initial_Condition, Initializes,\n\tPost, Post_Class, Postcondition, Pre, Pre_Class, Precondition,\n\tRefined_Depends, Refined_Global, Refined_Post, Refined_State, Test_Case.\n\t(Analyze_Pre_Post_Condition): Do not create a generic\n\ttemplate here.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Code cleanup.\n\t(Analyze_Refined_Depends_Global_Post): New routine.\n\t(Analyze_Refined_Depends_In_Decl_Part): Code cleanup.\n\t(Analyze_Refined_Global_In_Decl_Part): Code cleanup.\n\t(Analyze_Refined_Pragma): Removed.\n\t(Analyze_Refined_State_In_Decl_Part): Code cleanup.\n\t(Analyze_Test_Case_In_Decl_Part): Code cleanup.\n\t(Check_Dependency_Clause): Do not perform this check in an instance.\n\t(Check_Function_Return): Add support for generic functions.\n\t(Check_In_Out_States): Do not perform this check in an instance.\n\t(Check_Input_States): Do not perform this check in an instance.\n\t(Check_Mode_Restriction_In_Function): Add support for generic functions.\n\t(Check_Output_States): Do not perform this check in an instance.\n\t(Check_Postcondition_Use_In_Inlined_Subprogram): Rename\n\tparameter Subp_Id to Spec_Id and update comment on usage.\n\t(Check_Proof_In_States): Do not perform this check in an instance.\n\t(Check_Refined_Global_Item): Add support for constants.\n\t(Check_Refined_Global_List): Do not perform this check in an instance.\n\t(Collect_Global_Items): Reimplemented.\n\t(Collect_Subprogram_Inputs_Outputs): Add support for generic parameters.\n\t(Create_Generic_Template): Removed.\n\t(Find_Related_Package_Or_Body): Moved to spec.\n\t(Find_Role): Add support for generic parameters and constants.\n\t(Get_Argument): Moved to spec. Rename parameter Spec_Id to Context_Id.\n\t(Match_Item): Add support for constants.\n\t(Preanalyze_Test_Case_Arg): Reimplemented.\n\t(Report_Extra_Clauses): Do not perform this check in an instance.\n\t(Report_Extra_Constituents): Do not perform this check in an instance.\n\t* sem_prag.ads (Collect_Subprogram_Inputs_Outputs): Update\n\tthe comment on usage.\n\t(Find_Related_Package_Or_Body): Moved from body.\n\t(Get_Argument): Moved from body.\n\t* sem_util.adb Add with and use clauses for Sem_Ch12.\n\t(Corresponding_Spec_Of): Add support for packages and package bodies.\n\t(Create_Generic_Contract): New routine.\n\t(Is_Contract_Annotation): Reimplemented.\n\t(Is_Generic_Declaration_Or_Body): New routine.\n\t(Is_Package_Contract_Annotation): New routine.\n\t(Is_Subprogram_Contract_Annotation): New routine.\n\t* sem_util.ads (Corresponding_Spec_Of): Update the comment on usage.\n\t(Create_Generic_Contract): New routine.\n\t(Is_Generic_Declaration_Or_Body): New routine.\n\t(Is_Package_Contract_Annotation): New routine.\n\t(Is_Subprogram_Contract_Annotation): New routine.\n\t* sinfo.adb (Is_Generic_Contract_Pragma): New routine.\n\t(Set_Is_Generic_Contract_Pragma): New routine.\n\t* sinfo.ads Add new attribute Is_Generic_Contract_Pragma along\n\twith occurrences in nodes.\n\t(Is_Generic_Contract_Pragma): New routine along with pragma Inline.\n\t(Set_Is_Generic_Contract_Pragma): New routine along with pragma Inline.\n\t* treepr.adb (Print_Entity_Info): Output fields 36 to 41.\n\n2015-05-12  Robert Dewar  <dewar@adacore.com>\n\n\t* a-taster.ads: Minor comment fix: fix bad header, this is a\n\tpure RM unit.\n\nFrom-SVN: r223064", "tree": {"sha": "58ad2c244f063e7749fa8e4f7f3f84954975f6ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58ad2c244f063e7749fa8e4f7f3f84954975f6ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf07df9db933fc7c97c41060dfa940fa78bb345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf07df9db933fc7c97c41060dfa940fa78bb345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf07df9db933fc7c97c41060dfa940fa78bb345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf07df9db933fc7c97c41060dfa940fa78bb345/comments", "author": null, "committer": null, "parents": [{"sha": "c944345b5d210e9f003bd1088f0087b9a22068c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c944345b5d210e9f003bd1088f0087b9a22068c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c944345b5d210e9f003bd1088f0087b9a22068c0"}], "stats": {"total": 4226, "additions": 2731, "deletions": 1495}, "files": [{"sha": "e1a377fe3ae98fac9f28ddf91aeb17cc321ec115", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -1,3 +1,160 @@\n+2015-05-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb Node32 is now used as Encapsulating_State.\n+\tNode37 is now used as Associated_Entity.\n+\t(Associated_Entity): New routine.\n+\t(Encapsulating_State): Update the assertion guard\n+\tto include constants.\n+\t(Set_Associated_Entity): New routine.\n+\t(Set_Encapsulating_State): Update the assertion guard to\n+\tinclude constants.\n+\t(Write_Field10_Name): Remove the output for Encapsulating_State.\n+\t(Write_Field32_Name): Add output for Encapsulating_State.\n+\t(Write_Field37_Name): Add output for Associated_Entity.\n+\t* einfo.ads New attribute Associated_Entity along with placement\n+\tin entities. Attribute Encapsulating_State now uses Node32.\n+\t(Associated_Entity): New routine along with pragma Inline.\n+\t(Set_Associated_Entity): New routine along with pragma Inline.\n+\t* inline.ads Code reformatting.\n+\t* sem_attr.adb (Analyze_Attribute): Correct the prefix of\n+\tattribute 'Result when the context is a generic instantiation.\n+\t(Analyze_Attribute_Old_Result): Pragmas Depends and\n+\tRefined_Depends are a valid context for attribute 'Result.\n+\t(Denote_Same_Function): Allow attribute 'Result to denote\n+\tgeneric functions.\n+\t* sem_ch3.adb Add with and use clauses for Sem_Ch12.\n+\t(Analyze_Declarations): Capture global references within the\n+\tcontracts of packages, subprograms and their respective bodies.\n+\t* sem_ch6.adb (Analyze_Aspects_On_Body_Or_Stub): Removed.\n+\t(Analyze_Completion_Contract): Removed.\n+\t(Analyze_Generic_Subprogram_Body): Enchange the aspects after\n+\tcreating the generic copy. Create a generic contract for the\n+\ttemplate. Analyze the aspects of the generic body. Analyze the\n+\tcontract of the generic body when it is a compilation unit and\n+\tcapture global references.\n+\t(Analyze_Subprogram_Body_Contract): Code cleanup.\n+\t(Analyze_Subprogram_Contract): Do not save global references here.\n+\t(Save_Global_References_In_List): Removed.\n+\t* sem_ch7.adb (Analyze_Package_Body_Contract): Code cleanup.\n+\t(Analyze_Package_Body_Helper): Create a generic contract for\n+\tthe template.\n+\t(Analyze_Package_Contract): Code cleanup.\n+\t* sem_ch10.adb Add with and use clauses for Sem_Ch12.\n+\t(Analyze_Compilation_Unit): Capture global references in a\n+\tgeneric subprogram declaration that acts as a compilation unit.\n+\t* sem_ch12.adb Add with and use clauses for Sem_Prag. Illustrate\n+\tthe implementation of generic contracts. Alphabetize various\n+\tsubprograms.\n+\t(Analyze_Generic_Package_Declaration):\n+\tCreate a generic contract for the template.\n+\t(Analyze_Generic_Subprogram_Declaration): Create a generic\n+\tcontract for the template.\n+\t(Analyze_Subprogram_Instantiation): Instantiate the contract of the\n+\tsubprogram.\n+\t(Copy_Generic_Node): Link defining entities of the generic template\n+\twith the corresponding defining entities of the generic copy. Update\n+\tthe processing of pragmas.\n+\t(Instantiate_Contract): Removed.\n+\t(Instantiate_Subprogram_Contract): New routine.\n+\t(Requires_Delayed_Save): New routine.\n+\t(Save_Global_References): Rename formal parameter N to Templ. Various\n+\tcleanups.\n+\t(Save_Global_References_In_Aspects): Moved from the spec.\n+\t(Save_Global_References_In_Contract): New routine.\n+\t(Save_References_In_Aggregate): New routine.\n+\t(Save_References_In_Char_Lit_Or_Op_Symbol): New routine.\n+\t(Save_References_In_Descendants): New routine.\n+\t(Save_References_In_Identifier): New routine.\n+\t(Save_References_In_Operator): New routine.\n+\t(Save_References_In_Pragma): New routine.\n+\t* sem_ch12.ads (Save_Global_References): Rename formal\n+\tparameter N to Templ. Update the comment on usage.\n+\t(Save_Global_References_In_Aspects): Moved to the body.\n+\t(Save_Global_References_In_Contract): New routine.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications_On_Body_Or_Stub):\n+\tNew routine.\n+\t* sem_ch13.ads (Analyze_Aspect_Specifications_On_Body_Or_Stub):\n+\tNew routine.\n+\t* sem_prag.adb (Add_Item_To_Name_Buffer): Add support for\n+\tgeneric parameters.\n+\t(Analyze_Contract_Cases_In_Decl_Part): Code cleanup.\n+\t(Analyze_Depends_Global): New routine.\n+\t(Analyze_Depends_In_Decl_Part): Code cleanup.\n+\t(Analyze_Global_In_Decl_Part): Code cleanup.\n+\t(Analyze_Global_Item): Constants are now valid global items. Do\n+\tnot perform state-related checks in an instance. Change the way\n+\trenamings are handled.\t(Analyze_Initial_Condition_In_Decl_Part):\n+\tCode cleanup.\n+\t(Analyze_Initializes_In_Decl_Part): Code cleanup.\n+\t(Analyze_Input_Output): The analysis of attribute 'Result in\n+\tthe context of pragmas Depends or Refined_Depends now reuses\n+\tthe existing attribute analysis machinery. Constants and\n+\tgeneric parameters are now valid dependency items. Do not\n+\tperform state-related checks in an instance. Change the way\n+\trenamings are handled.\t(Analyze_Pragma): Add a \"characteristics\"\n+\tsection for pragmas Abstract_State, Contract_Cases, Depends,\n+\tExtensions_Visible, Global, Initial_Condition, Initializes,\n+\tPost, Post_Class, Postcondition, Pre, Pre_Class, Precondition,\n+\tRefined_Depends, Refined_Global, Refined_Post, Refined_State, Test_Case.\n+\t(Analyze_Pre_Post_Condition): Do not create a generic\n+\ttemplate here.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Code cleanup.\n+\t(Analyze_Refined_Depends_Global_Post): New routine.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Code cleanup.\n+\t(Analyze_Refined_Global_In_Decl_Part): Code cleanup.\n+\t(Analyze_Refined_Pragma): Removed.\n+\t(Analyze_Refined_State_In_Decl_Part): Code cleanup.\n+\t(Analyze_Test_Case_In_Decl_Part): Code cleanup.\n+\t(Check_Dependency_Clause): Do not perform this check in an instance.\n+\t(Check_Function_Return): Add support for generic functions.\n+\t(Check_In_Out_States): Do not perform this check in an instance.\n+\t(Check_Input_States): Do not perform this check in an instance.\n+\t(Check_Mode_Restriction_In_Function): Add support for generic functions.\n+\t(Check_Output_States): Do not perform this check in an instance.\n+\t(Check_Postcondition_Use_In_Inlined_Subprogram): Rename\n+\tparameter Subp_Id to Spec_Id and update comment on usage.\n+\t(Check_Proof_In_States): Do not perform this check in an instance.\n+\t(Check_Refined_Global_Item): Add support for constants.\n+\t(Check_Refined_Global_List): Do not perform this check in an instance.\n+\t(Collect_Global_Items): Reimplemented.\n+\t(Collect_Subprogram_Inputs_Outputs): Add support for generic parameters.\n+\t(Create_Generic_Template): Removed.\n+\t(Find_Related_Package_Or_Body): Moved to spec.\n+\t(Find_Role): Add support for generic parameters and constants.\n+\t(Get_Argument): Moved to spec. Rename parameter Spec_Id to Context_Id.\n+\t(Match_Item): Add support for constants.\n+\t(Preanalyze_Test_Case_Arg): Reimplemented.\n+\t(Report_Extra_Clauses): Do not perform this check in an instance.\n+\t(Report_Extra_Constituents): Do not perform this check in an instance.\n+\t* sem_prag.ads (Collect_Subprogram_Inputs_Outputs): Update\n+\tthe comment on usage.\n+\t(Find_Related_Package_Or_Body): Moved from body.\n+\t(Get_Argument): Moved from body.\n+\t* sem_util.adb Add with and use clauses for Sem_Ch12.\n+\t(Corresponding_Spec_Of): Add support for packages and package bodies.\n+\t(Create_Generic_Contract): New routine.\n+\t(Is_Contract_Annotation): Reimplemented.\n+\t(Is_Generic_Declaration_Or_Body): New routine.\n+\t(Is_Package_Contract_Annotation): New routine.\n+\t(Is_Subprogram_Contract_Annotation): New routine.\n+\t* sem_util.ads (Corresponding_Spec_Of): Update the comment on usage.\n+\t(Create_Generic_Contract): New routine.\n+\t(Is_Generic_Declaration_Or_Body): New routine.\n+\t(Is_Package_Contract_Annotation): New routine.\n+\t(Is_Subprogram_Contract_Annotation): New routine.\n+\t* sinfo.adb (Is_Generic_Contract_Pragma): New routine.\n+\t(Set_Is_Generic_Contract_Pragma): New routine.\n+\t* sinfo.ads Add new attribute Is_Generic_Contract_Pragma along\n+\twith occurrences in nodes.\n+\t(Is_Generic_Contract_Pragma): New routine along with pragma Inline.\n+\t(Set_Is_Generic_Contract_Pragma): New routine along with pragma Inline.\n+\t* treepr.adb (Print_Entity_Info): Output fields 36 to 41.\n+\n+2015-05-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-taster.ads: Minor comment fix: fix bad header, this is a\n+\tpure RM unit.\n+\n 2015-05-12  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_intr.adb: (Check_Shift): Diagnose bad modulus value."}, {"sha": "21408b54bbf22205f20a316a25af469fcac428d0", "filename": "gcc/ada/a-taster.ads", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fa-taster.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fa-taster.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taster.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -6,14 +6,10 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n---                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n --                                                                          --\n ------------------------------------------------------------------------------\n "}, {"sha": "f364960fe0fd7581039969a91cb7d229d92e45a0", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -70,6 +70,7 @@ package body Einfo is\n    --    Homonym                         Node4\n    --    First_Rep_Item                  Node6\n    --    Freeze_Node                     Node7\n+   --    Associated_Entity               Node37\n \n    --  The usage of other fields (and the entity kinds to which it applies)\n    --  depends on the particular field (see Einfo spec for details).\n@@ -88,7 +89,6 @@ package body Einfo is\n    --    Part_Of_Constituents            Elist9\n    --    Renaming_Map                    Uint9\n \n-   --    Encapsulating_State             Node10\n    --    Direct_Primitive_Operations     Elist10\n    --    Discriminal_Link                Node10\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n@@ -215,10 +215,10 @@ package body Einfo is\n    --    Related_Expression              Node24\n    --    Subps_Index                     Uint24\n \n-   --    Interface_Alias                 Node25\n-   --    Interfaces                      Elist25\n    --    Debug_Renaming_Link             Node25\n    --    DT_Offset_To_Top_Func           Node25\n+   --    Interface_Alias                 Node25\n+   --    Interfaces                      Elist25\n    --    PPC_Wrapper                     Node25\n    --    Related_Array_Object            Node25\n    --    Static_Discrete_Predicate       List25\n@@ -253,6 +253,7 @@ package body Einfo is\n    --    Thunk_Entity                    Node31\n    --    Activation_Record_Component     Node31\n \n+   --    Encapsulating_State             Node32\n    --    SPARK_Pragma                    Node32\n    --    No_Tagged_Streams_Pragma        Node32\n \n@@ -264,7 +265,6 @@ package body Einfo is\n    --    Import_Pragma                   Node35\n \n    --    (unused)                        Node36\n-   --    (unused)                        Node37\n    --    (unused)                        Node38\n    --    (unused)                        Node39\n    --    (unused)                        Node40\n@@ -753,6 +753,11 @@ package body Einfo is\n       return Uint14 (Id);\n    end Alignment;\n \n+   function Associated_Entity (Id : E) return E is\n+   begin\n+      return Node37 (Id);\n+   end Associated_Entity;\n+\n    function Associated_Formal_Package (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Package);\n@@ -1111,8 +1116,8 @@ package body Einfo is\n \n    function Encapsulating_State (Id : E) return N is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n-      return Node10 (Id);\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Constant, E_Variable));\n+      return Node32 (Id);\n    end Encapsulating_State;\n \n    function Enclosing_Scope (Id : E) return E is\n@@ -1176,7 +1181,8 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body,\n                        E_Subprogram_Body,\n-                       E_Variable)\n+                       E_Variable,\n+                       E_Void)\n           or else Is_Subprogram_Or_Generic_Subprogram (Id));\n       return Node34 (Id);\n    end Contract;\n@@ -3558,6 +3564,11 @@ package body Einfo is\n       Set_Elist16 (Id, V);\n    end Set_Access_Disp_Table;\n \n+   procedure Set_Associated_Entity (Id : E; V : E) is\n+   begin\n+      Set_Node37 (Id, V);\n+   end Set_Associated_Entity;\n+\n    procedure Set_Associated_Formal_Package (Id : E; V : E) is\n    begin\n       Set_Node12 (Id, V);\n@@ -3733,13 +3744,13 @@ package body Einfo is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Entry,\n-                         E_Entry_Family,\n-                         E_Generic_Package,\n-                         E_Package,\n-                         E_Package_Body,\n-                         E_Subprogram_Body,\n-                         E_Variable,\n-                         E_Void)\n+                       E_Entry_Family,\n+                       E_Generic_Package,\n+                       E_Package,\n+                       E_Package_Body,\n+                       E_Subprogram_Body,\n+                       E_Variable,\n+                       E_Void)\n           or else Is_Subprogram_Or_Generic_Subprogram (Id));\n       Set_Node34 (Id, V);\n    end Set_Contract;\n@@ -3993,8 +4004,8 @@ package body Einfo is\n \n    procedure Set_Encapsulating_State (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n-      Set_Node10 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Constant, E_Variable));\n+      Set_Node32 (Id, V);\n    end Set_Encapsulating_State;\n \n    procedure Set_Enclosing_Scope (Id : E; V : E) is\n@@ -8993,7 +9004,7 @@ package body Einfo is\n    -----------------------\n \n    procedure Write_Field6_Name (Id : Entity_Id) is\n-      pragma Warnings (Off, Id);\n+      pragma Unreferenced (Id);\n    begin\n       Write_Str (\"First_Rep_Item\");\n    end Write_Field6_Name;\n@@ -9003,7 +9014,7 @@ package body Einfo is\n    -----------------------\n \n    procedure Write_Field7_Name (Id : Entity_Id) is\n-      pragma Warnings (Off, Id);\n+      pragma Unreferenced (Id);\n    begin\n       Write_Str (\"Freeze_Node\");\n    end Write_Field7_Name;\n@@ -9083,10 +9094,6 @@ package body Einfo is\n    procedure Write_Field10_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Abstract_State                             |\n-              E_Variable                                   =>\n-            Write_Str (\"Encapsulating_State\");\n-\n          when Class_Wide_Kind                              |\n               Incomplete_Kind                              |\n               E_Record_Type                                |\n@@ -9095,13 +9102,13 @@ package body Einfo is\n               Concurrent_Kind                              =>\n             Write_Str (\"Direct_Primitive_Operations\");\n \n-         when Float_Kind                                   =>\n-            Write_Str (\"Float_Rep\");\n-\n          when E_In_Parameter                               |\n               E_Constant                                   =>\n             Write_Str (\"Discriminal_Link\");\n \n+         when Float_Kind                                   =>\n+            Write_Str (\"Float_Rep\");\n+\n          when E_Function                                   |\n               E_Package                                    |\n               E_Package_Body                               |\n@@ -9995,6 +10002,11 @@ package body Einfo is\n    procedure Write_Field32_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Abstract_State                             |\n+              E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Encapsulating_State\");\n+\n          when E_Function                                   |\n               E_Generic_Function                           |\n               E_Generic_Package                            |\n@@ -10050,6 +10062,7 @@ package body Einfo is\n               E_Package_Body                               |\n               E_Subprogram_Body                            |\n               E_Variable                                   |\n+              E_Void                                       |\n               Generic_Subprogram_Kind                      |\n               Subprogram_Kind                              =>\n             Write_Str (\"Contract\");\n@@ -10091,11 +10104,9 @@ package body Einfo is\n    ------------------------\n \n    procedure Write_Field37_Name (Id : Entity_Id) is\n+      pragma Unreferenced (Id);\n    begin\n-      case Ekind (Id) is\n-         when others                                       =>\n-            Write_Str (\"Field37??\");\n-      end case;\n+      Write_Str (\"Associated_Entity\");\n    end Write_Field37_Name;\n \n    ------------------------"}, {"sha": "b9b5c42d8462f2441d66702aca9a9324c3a24f80", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -436,6 +436,13 @@ package Einfo is\n --       definition clause with an (obsolescent) mod clause is converted\n --       into an attribute definition clause for this purpose.\n \n+--    Associated_Entity (Node37)\n+--       Defined in all entities. This field is similar to Associated_Node, but\n+--       applied to entities. The attribute links an entity from the generic\n+--       template with its corresponding entity in the analyzed generic copy.\n+--       The global references mechanism relies on the Associated_Entity to\n+--       infer the context.\n+\n --    Associated_Formal_Package (Node12)\n --       Defined in packages that are the actuals of formal_packages. Points\n --       to the entity in the declaration for the formal package.\n@@ -882,7 +889,6 @@ package Einfo is\n --       primitives that come from source must be stored in this list in the\n --       order of their occurrence in the sources. For incomplete types the\n --       list is always empty.\n---\n --       When expansion is disabled the corresponding record type of a\n --       synchronized type is not constructed. In that case, such types\n --       carry this attribute directly, for ASIS use.\n@@ -1033,9 +1039,10 @@ package Einfo is\n --       then if there is no other elaboration code, obviously there is no\n --       need to set the flag.\n \n---    Encapsulating_State (Node10)\n---       Defined in abstract states and variables. Contains the entity of an\n---       ancestor state whose refinement utilizes this item as a constituent.\n+--    Encapsulating_State (Node32)\n+--       Defined in abstract states, constants and variables. Contains the\n+--       entity of an ancestor state whose refinement utilizes this item as\n+--       a constituent.\n \n --    Enclosing_Scope (Node18)\n --       Defined in labels. Denotes the innermost enclosing construct that\n@@ -1089,10 +1096,10 @@ package Einfo is\n --       'COUNT when it applies to a family member.\n \n --    Contract (Node34)\n---       Defined in entry, entry family, package, package body, subprogram and\n---       subprogram body entities as well as their respective generic forms. A\n---       contract is also applicable to a variable. Points to the contract of\n---       the entity, holding various assertion items and data classifiers.\n+--       Defined in entry, entry family, [generic] package, package body,\n+--       [generic] subprogram, subprogram body and variable entities. Points\n+--       to the contract of the entity, holding various assertion items and\n+--       data classifiers.\n \n --    Entry_Parameters_Type (Node15)\n --       Defined in entries. Points to the access-to-record type that is\n@@ -1657,7 +1664,7 @@ package Einfo is\n --    Has_Inherited_Default_Init_Cond (Flag133)\n --       Defined in type and subtype entities. Set if a derived type inherits\n --       pragma Default_Initial_Condition from its parent type. This flag must\n---       be mutually exclusive with Had_Default_Init_Cond.\n+--       be mutually exclusive with Has_Default_Init_Cond.\n \n --    Has_Initial_Value (Flag219)\n --       Defined in entities for variables and out parameters. Set if there\n@@ -5238,6 +5245,7 @@ package Einfo is\n    --    Etype                               (Node5)\n    --    First_Rep_Item                      (Node6)\n    --    Freeze_Node                         (Node7)\n+   --    Associated_Entity                   (Node37)\n \n    --    Address_Taken                       (Flag104)\n    --    Can_Never_Be_Null                   (Flag38)\n@@ -5454,9 +5462,9 @@ package Einfo is\n    --  E_Abstract_State\n    --    Refinement_Constituents             (Elist8)\n    --    Part_Of_Constituents                (Elist9)\n-   --    Encapsulating_State                 (Node10)\n    --    Body_References                     (Elist16)\n    --    Non_Limited_View                    (Node19)\n+   --    Encapsulating_State                 (Node32)\n    --    From_Limited_With                   (Flag159)\n    --    Has_Visible_Refinement              (Flag263)\n    --    Has_Non_Limited_View                (synth)\n@@ -5615,6 +5623,7 @@ package Einfo is\n    --    BIP_Initialization_Call             (Node29)\n    --    Last_Aggregate_Assignment           (Node30)\n    --    Activation_Record_Component         (Node31)\n+   --    Encapsulating_State                 (Node32)   (constants only)\n    --    Linker_Section_Pragma               (Node33)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n@@ -5964,14 +5973,14 @@ package Einfo is\n    --    Alias                               (Node18)\n    --    Extra_Accessibility_Of_Result       (Node19)\n    --    Last_Entity                         (Node20)\n-   --    Has_Nested_Subprogram               (Flag282)\n    --    Subps_Index                         (Uint24)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)\n    --    Has_Invariants                      (Flag232)\n+   --    Has_Nested_Subprogram               (Flag282)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n    --    Is_Pure                             (Flag44)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n@@ -6017,8 +6026,8 @@ package Einfo is\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Aux_Pragma                    (Node33)\n    --    SPARK_Pragma                        (Node32)\n+   --    SPARK_Aux_Pragma                    (Node33)\n    --    Contract                            (Node34)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -6054,8 +6063,8 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Aux_Pragma                    (Node33)\n    --    SPARK_Pragma                        (Node32)\n+   --    SPARK_Aux_Pragma                    (Node33)\n    --    Contract                            (Node34)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n@@ -6325,7 +6334,6 @@ package Einfo is\n    --  E_Variable\n    --    Hiding_Loop_Variable                (Node8)\n    --    Current_Value                       (Node9)\n-   --    Encapsulating_State                 (Node10)\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n@@ -6346,6 +6354,7 @@ package Einfo is\n    --    BIP_Initialization_Call             (Node29)\n    --    Last_Aggregate_Assignment           (Node30)\n    --    Activation_Record_Component         (Node31)\n+   --    Encapsulating_State                 (Node32)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Has_Alignment_Clause                (Flag46)\n@@ -6616,6 +6625,7 @@ package Einfo is\n    function Address_Taken                       (Id : E) return B;\n    function Alias                               (Id : E) return E;\n    function Alignment                           (Id : E) return U;\n+   function Associated_Entity                   (Id : E) return E;\n    function Associated_Formal_Package           (Id : E) return E;\n    function Associated_Node_For_Itype           (Id : E) return N;\n    function Associated_Storage_Pool             (Id : E) return E;\n@@ -7267,6 +7277,7 @@ package Einfo is\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n    procedure Set_Alignment                       (Id : E; V : U);\n+   procedure Set_Associated_Entity               (Id : E; V : E);\n    procedure Set_Associated_Formal_Package       (Id : E; V : E);\n    procedure Set_Associated_Node_For_Itype       (Id : E; V : N);\n    procedure Set_Associated_Storage_Pool         (Id : E; V : E);\n@@ -8039,6 +8050,7 @@ package Einfo is\n    pragma Inline (Address_Taken);\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n+   pragma Inline (Associated_Entity);\n    pragma Inline (Associated_Formal_Package);\n    pragma Inline (Associated_Node_For_Itype);\n    pragma Inline (Associated_Storage_Pool);\n@@ -8537,6 +8549,7 @@ package Einfo is\n    pragma Inline (Set_Address_Taken);\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n+   pragma Inline (Set_Associated_Entity);\n    pragma Inline (Set_Associated_Formal_Package);\n    pragma Inline (Set_Associated_Node_For_Itype);\n    pragma Inline (Set_Associated_Storage_Pool);"}, {"sha": "5d1c5bb72789ef111dc9b82b7bbae5e7309e34e5", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -169,6 +169,16 @@ package Inline is\n    --  enabled and the subprogram contains a construct that cannot be inlined,\n    --  the problematic construct is flagged accordingly.\n \n+   function Can_Be_Inlined_In_GNATprove_Mode\n+     (Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id) return Boolean;\n+   --  Returns True if the subprogram identified by Spec_Id and Body_Id can\n+   --  be inlined in GNATprove mode. One but not both of Spec_Id and Body_Id\n+   --  can be Empty. Body_Id is Empty when doing a partial check on a call\n+   --  to a subprogram whose body has not been seen yet, to know whether this\n+   --  subprogram could possibly be inlined. GNATprove relies on this to adapt\n+   --  its treatment of the subprogram.\n+\n    procedure Cannot_Inline\n      (Msg        : String;\n       N          : Node_Id;\n@@ -251,14 +261,4 @@ package Inline is\n    --  If an instantiation appears in unreachable code, delete the pending\n    --  body instance.\n \n-   function Can_Be_Inlined_In_GNATprove_Mode\n-     (Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id) return Boolean;\n-   --  Returns True if the subprogram identified by Spec_Id and Body_Id can\n-   --  be inlined in GNATprove mode. One but not both of Spec_Id and Body_Id\n-   --  can be Empty. Body_Id is Empty when doing a partial check on a call\n-   --  to a subprogram whose body has not been seen yet, to know whether this\n-   --  subprogram could possibly be inlined. GNATprove relies on this to adapt\n-   --  its treatment of the subprogram.\n-\n end Inline;"}, {"sha": "7a15789c2e447dedc652b9f90c4914c3397e02ec", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -1295,6 +1295,14 @@ package body Sem_Attr is\n             elsif Prag_Nam = Name_Contract_Cases then\n                Check_Placement_In_Contract_Cases (Prag);\n \n+            --  Attribute 'Result is allowed to appear in aspect or pragma\n+            --  [Refined_]Depends (SPARK RM 6.1.5(11)).\n+\n+            elsif Nam_In (Prag_Nam, Name_Depends, Name_Refined_Depends)\n+              and then Aname = Name_Result\n+            then\n+               null;\n+\n             elsif Nam_In (Prag_Nam, Name_Post,\n                                     Name_Post_Class,\n                                     Name_Postcondition,\n@@ -5123,17 +5131,21 @@ package body Sem_Attr is\n \n             elsif Nkind (Subp_Spec) = N_Function_Specification\n               and then Present (Generic_Parent (Subp_Spec))\n-              and then Ekind (Pref_Id) = E_Function\n-              and then Present (Alias (Pref_Id))\n-              and then Alias (Pref_Id) = Spec_Id\n+              and then Ekind_In (Pref_Id, E_Generic_Function, E_Function)\n             then\n-               return True;\n+               if Generic_Parent (Subp_Spec) = Pref_Id then\n+                  return True;\n+\n+               elsif Present (Alias (Pref_Id))\n+                 and then Alias (Pref_Id) = Spec_Id\n+               then\n+                  return True;\n+               end if;\n+            end if;\n \n             --  Otherwise the prefix does not denote the related subprogram\n \n-            else\n-               return False;\n-            end if;\n+            return False;\n          end Denote_Same_Function;\n \n          --  Local variables\n@@ -5199,6 +5211,15 @@ package body Sem_Attr is\n \n                if Ekind_In (Pref_Id, E_Function, E_Generic_Function) then\n                   if Denote_Same_Function (Pref_Id, Spec_Id) then\n+\n+                     --  Correct the prefix of the attribute when the context\n+                     --  is a generic function.\n+\n+                     if Pref_Id /= Spec_Id then\n+                        Rewrite (P, New_Occurrence_Of (Spec_Id, Loc));\n+                        Analyze (P);\n+                     end if;\n+\n                      Set_Etype (N, Etype (Spec_Id));\n \n                   --  Otherwise the prefix denotes some unrelated function"}, {"sha": "63d2cb75542a5d0f5279d645cf629fa5c200223e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -53,6 +53,7 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n with Sem_Dist; use Sem_Dist;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n@@ -939,6 +940,15 @@ package body Sem_Ch10 is\n                               N_Subprogram_Declaration)\n       then\n          Analyze_Subprogram_Contract (Defining_Entity (Unit_Node));\n+\n+         --  Capture all global references in a generic subprogram that acts as\n+         --  a compilation unit now that the contract has been analyzed.\n+\n+         if Is_Generic_Declaration_Or_Body (Unit_Node) then\n+            Save_Global_References_In_Contract\n+              (Templ  => Original_Node (Unit_Node),\n+               Gen_Id => Defining_Entity (Unit_Node));\n+         end if;\n       end if;\n \n       --  Generate distribution stubs if requested and no error"}, {"sha": "cac9db9cbf3735553ff9c8aa5f5d098e7b1674c2", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 789, "deletions": 397, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -59,6 +59,7 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n@@ -239,6 +240,118 @@ package body Sem_Ch12 is\n    --  circularity is detected, and used to abandon compilation after the\n    --  messages have been posted.\n \n+   -----------------------------------------\n+   -- Implementation of Generic Contracts --\n+   -----------------------------------------\n+\n+   --  A \"contract\" is a collection of aspects and pragmas that either verify a\n+   --  property of a construct at runtime or classify the data flow to and from\n+   --  the construct in some fashion.\n+\n+   --  Generic packages, subprograms and their respective bodies may be subject\n+   --  to the following contract-related aspects or pragmas collectively known\n+   --  as annotations:\n+\n+   --     package                  subprogram [body]\n+   --       Abstract_State           Contract_Cases\n+   --       Initial_Condition        Depends\n+   --       Initializes              Extensions_Visible\n+   --                                Global\n+   --     package body               Post\n+   --       Refined_State            Post_Class\n+   --                                Postcondition\n+   --                                Pre\n+   --                                Pre_Class\n+   --                                Precondition\n+   --                                Refined_Depends\n+   --                                Refined_Global\n+   --                                Refined_Post\n+   --                                Test_Case\n+\n+   --  Most package contract annotations utilize forward references to classify\n+   --  data declared within the package [body]. Subprogram annotations then use\n+   --  the classifications to further refine them. These inter dependencies are\n+   --  problematic with respect to the implementation of generics because their\n+   --  analysis, capture of global references and instantiation does not mesh\n+   --  well with the existing mechanism.\n+\n+   --  1) Analysis of generic contracts is carried out the same way non-generic\n+   --  contracts are analyzed:\n+\n+   --    1.1) General rule - a contract is analyzed after all related aspects\n+   --    and pragmas are analyzed. This is done by routines\n+\n+   --       Analyze_Package_Body_Contract\n+   --       Analyze_Package_Contract\n+   --       Analyze_Subprogram_Body_Contract\n+   --       Analyze_Subprogram_Contract\n+\n+   --    1.2) Compilation unit - the contract is analyzed after Pragmas_After\n+   --    are processed.\n+\n+   --    1.3) Compilation unit body - the contract is analyzed at the end of\n+   --    the body declaration list.\n+\n+   --    1.4) Package - the contract is analyzed at the end of the private or\n+   --    visible declarations, prior to analyzing the contracts of any nested\n+   --    packages or subprograms.\n+\n+   --    1.5) Package body - the contract is analyzed at the end of the body\n+   --    declaration list, prior to analyzing the contracts of any nested\n+   --    packages or subprograms.\n+\n+   --    1.6) Subprogram - if the subprogram is declared inside a block, a\n+   --    package or a subprogram, then its contract is analyzed at the end of\n+   --    the enclosing declarations, otherwise the subprogram is a compilation\n+   --    unit 1.2).\n+\n+   --    1.7) Subprogram body - if the subprogram body is declared inside a\n+   --    block, a package body or a subprogram body, then its contract is\n+   --    analyzed at the end of the enclosing declarations, otherwise the\n+   --    subprogram is a compilation unit 1.3).\n+\n+   --  2) Capture of global references within contracts is done after capturing\n+   --  global references within the generic template. There are two reasons for\n+   --  this delay - pragma annotations are not part of the generic template in\n+   --  the case of a generic subprogram declaration, and analysis of contracts\n+   --  is delayed.\n+\n+   --  Contract-related source pragmas within generic templates are prepared\n+   --  for delayed capture of global references by routine\n+\n+   --    Create_Generic_Contract\n+\n+   --  The routine associates these pragmas with the contract of the template.\n+   --  In the case of a generic subprogram declaration, the routine creates\n+   --  generic templates for the pragmas declared after the subprogram because\n+   --  they are not part of the template.\n+\n+   --    generic                                --  template starts\n+   --    procedure Gen_Proc (Input : Integer);  --  template ends\n+   --    pragma Precondition (Input > 0);       --  requires own template\n+\n+   --    2.1) The capture of global references with aspect specifications and\n+   --    source pragmas that apply to a generic unit must be suppressed when\n+   --    the generic template is being processed because the contracts have not\n+   --    been analyzed yet. Any attempts to capture global references at that\n+   --    point will destroy the Associated_Node linkages and leave the template\n+   --    undecorated. This delay is controlled by routine\n+\n+   --       Requires_Delayed_Save\n+\n+   --    2.2) The real capture of global references within a contract is done\n+   --    after the contract has been analyzed, by routine\n+\n+   --       Save_Global_References_In_Contract\n+\n+   --  3) The instantiation of a generic contract occurs as part of the\n+   --  instantiation of the contract owner. Generic subprogram declarations\n+   --  require additional processing when the contract is specified by pragmas\n+   --  because the pragmas are not part of the generic template. This is done\n+   --  by routine\n+\n+   --    Instantiate_Subprogram_Contract\n+\n    Circularity_Detected : Boolean := False;\n    --  This should really be reset on encountering a new main unit, but in\n    --  practice we are not using multiple main units so it is not critical.\n@@ -476,6 +589,74 @@ package body Sem_Ch12 is\n    --  packages, and the prefix of the formal type may be needed to resolve\n    --  the ambiguity in the instance ???\n \n+   procedure Freeze_Subprogram_Body\n+     (Inst_Node : Node_Id;\n+      Gen_Body  : Node_Id;\n+      Pack_Id   : Entity_Id);\n+   --  The generic body may appear textually after the instance, including\n+   --  in the proper body of a stub, or within a different package instance.\n+   --  Given that the instance can only be elaborated after the generic, we\n+   --  place freeze_nodes for the instance and/or for packages that may enclose\n+   --  the instance and the generic, so that the back-end can establish the\n+   --  proper order of elaboration.\n+\n+   function Get_Associated_Node (N : Node_Id) return Node_Id;\n+   --  In order to propagate semantic information back from the analyzed copy\n+   --  to the original generic, we maintain links between selected nodes in the\n+   --  generic and their corresponding copies. At the end of generic analysis,\n+   --  the routine Save_Global_References traverses the generic tree, examines\n+   --  the semantic information, and preserves the links to those nodes that\n+   --  contain global information. At instantiation, the information from the\n+   --  associated node is placed on the new copy, so that name resolution is\n+   --  not repeated.\n+   --\n+   --  Three kinds of source nodes have associated nodes:\n+   --\n+   --    a) those that can reference (denote) entities, that is identifiers,\n+   --       character literals, expanded_names, operator symbols, operators,\n+   --       and attribute reference nodes. These nodes have an Entity field\n+   --       and are the set of nodes that are in N_Has_Entity.\n+   --\n+   --    b) aggregates (N_Aggregate and N_Extension_Aggregate)\n+   --\n+   --    c) selected components (N_Selected_Component)\n+   --\n+   --  For the first class, the associated node preserves the entity if it is\n+   --  global. If the generic contains nested instantiations, the associated\n+   --  node itself has been recopied, and a chain of them must be followed.\n+   --\n+   --  For aggregates, the associated node allows retrieval of the type, which\n+   --  may otherwise not appear in the generic. The view of this type may be\n+   --  different between generic and instantiation, and the full view can be\n+   --  installed before the instantiation is analyzed. For aggregates of type\n+   --  extensions, the same view exchange may have to be performed for some of\n+   --  the ancestor types, if their view is private at the point of\n+   --  instantiation.\n+   --\n+   --  Nodes that are selected components in the parse tree may be rewritten\n+   --  as expanded names after resolution, and must be treated as potential\n+   --  entity holders, which is why they also have an Associated_Node.\n+   --\n+   --  Nodes that do not come from source, such as freeze nodes, do not appear\n+   --  in the generic tree, and need not have an associated node.\n+   --\n+   --  The associated node is stored in the Associated_Node field. Note that\n+   --  this field overlaps Entity, which is fine, because the whole point is\n+   --  that we don't need or want the normal Entity field in this situation.\n+\n+   function Has_Been_Exchanged (E : Entity_Id) return Boolean;\n+   --  Traverse the Exchanged_Views list to see if a type was private\n+   --  and has already been flipped during this phase of instantiation.\n+\n+   procedure Hide_Current_Scope;\n+   --  When instantiating a generic child unit, the parent context must be\n+   --  present, but the instance and all entities that may be generated\n+   --  must be inserted in the current scope. We leave the current scope\n+   --  on the stack, but make its entities invisible to avoid visibility\n+   --  problems. This is reversed at the end of the instantiation. This is\n+   --  not done for the instantiation of the bodies, which only require the\n+   --  instances of the generic parents to be in scope.\n+\n    function In_Same_Declarative_Part\n      (F_Node : Node_Id;\n       Inst   : Node_Id) return Boolean;\n@@ -492,32 +673,31 @@ package body Sem_Ch12 is\n    --  Used to determine whether its body should be elaborated to allow\n    --  front-end inlining.\n \n-   procedure Set_Instance_Env\n-     (Gen_Unit : Entity_Id;\n-      Act_Unit : Entity_Id);\n-   --  Save current instance on saved environment, to be used to determine\n-   --  the global status of entities in nested instances. Part of Save_Env.\n-   --  called after verifying that the generic unit is legal for the instance,\n-   --  The procedure also examines whether the generic unit is a predefined\n-   --  unit, in order to set configuration switches accordingly. As a result\n-   --  the procedure must be called after analyzing and freezing the actuals.\n+   procedure Inherit_Context (Gen_Decl : Node_Id; Inst : Node_Id);\n+   --  Add the context clause of the unit containing a generic unit to a\n+   --  compilation unit that is, or contains, an instantiation.\n \n-   procedure Set_Instance_Of (A : Entity_Id; B : Entity_Id);\n-   --  Associate analyzed generic parameter with corresponding\n-   --  instance. Used for semantic checks at instantiation time.\n+   procedure Init_Env;\n+   --  Establish environment for subsequent instantiation. Separated from\n+   --  Save_Env because data-structures for visibility handling must be\n+   --  initialized before call to Check_Generic_Child_Unit.\n \n-   function Has_Been_Exchanged (E : Entity_Id) return Boolean;\n-   --  Traverse the Exchanged_Views list to see if a type was private\n-   --  and has already been flipped during this phase of instantiation.\n+   procedure Inline_Instance_Body\n+     (N        : Node_Id;\n+      Gen_Unit : Entity_Id;\n+      Act_Decl : Node_Id);\n+   --  If front-end inlining is requested, instantiate the package body,\n+   --  and preserve the visibility of its compilation unit, to insure\n+   --  that successive instantiations succeed.\n \n-   procedure Hide_Current_Scope;\n-   --  When instantiating a generic child unit, the parent context must be\n-   --  present, but the instance and all entities that may be generated\n-   --  must be inserted in the current scope. We leave the current scope\n-   --  on the stack, but make its entities invisible to avoid visibility\n-   --  problems. This is reversed at the end of the instantiation. This is\n-   --  not done for the instantiation of the bodies, which only require the\n-   --  instances of the generic parents to be in scope.\n+   procedure Insert_Freeze_Node_For_Instance\n+     (N      : Node_Id;\n+      F_Node : Node_Id);\n+   --  N denotes a package or a subprogram instantiation and F_Node is the\n+   --  associated freeze node. Insert the freeze node before the first source\n+   --  body which follows immediately after N. If no such body is found, the\n+   --  freeze node is inserted at the end of the declarative region which\n+   --  contains N.\n \n    procedure Install_Body\n      (Act_Body : Node_Id;\n@@ -534,46 +714,11 @@ package body Sem_Ch12 is\n    --  of packages that are early instantiations are delayed, and their freeze\n    --  node appears after the generic body.\n \n-   procedure Insert_Freeze_Node_For_Instance\n-     (N      : Node_Id;\n-      F_Node : Node_Id);\n-   --  N denotes a package or a subprogram instantiation and F_Node is the\n-   --  associated freeze node. Insert the freeze node before the first source\n-   --  body which follows immediately after N. If no such body is found, the\n-   --  freeze node is inserted at the end of the declarative region which\n-   --  contains N.\n-\n-   procedure Freeze_Subprogram_Body\n-     (Inst_Node : Node_Id;\n-      Gen_Body  : Node_Id;\n-      Pack_Id   : Entity_Id);\n-   --  The generic body may appear textually after the instance, including\n-   --  in the proper body of a stub, or within a different package instance.\n-   --  Given that the instance can only be elaborated after the generic, we\n-   --  place freeze_nodes for the instance and/or for packages that may enclose\n-   --  the instance and the generic, so that the back-end can establish the\n-   --  proper order of elaboration.\n-\n-   procedure Init_Env;\n-   --  Establish environment for subsequent instantiation. Separated from\n-   --  Save_Env because data-structures for visibility handling must be\n-   --  initialized before call to Check_Generic_Child_Unit.\n-\n    procedure Install_Formal_Packages (Par : Entity_Id);\n    --  Install the visible part of any formal of the parent that is a formal\n    --  package. Note that for the case of a formal package with a box, this\n    --  includes the formal part of the formal package (12.7(10/2)).\n \n-   procedure Install_Parent (P : Entity_Id; In_Body : Boolean := False);\n-   --  When compiling an instance of a child unit the parent (which is\n-   --  itself an instance) is an enclosing scope that must be made\n-   --  immediately visible. This procedure is also used to install the non-\n-   --  generic parent of a generic child unit when compiling its body, so\n-   --  that full views of types in the parent are made visible.\n-\n-   procedure Remove_Parent (In_Body : Boolean := False);\n-   --  Reverse effect after instantiation of child is complete\n-\n    procedure Install_Hidden_Primitives\n      (Prims_List : in out Elist_Id;\n       Gen_T      : Entity_Id;\n@@ -582,17 +727,12 @@ package body Sem_Ch12 is\n    --  visibility of primitives of Gen_T. The list of primitives to which\n    --  the suffix is removed is added to Prims_List to restore them later.\n \n-   procedure Restore_Hidden_Primitives (Prims_List : in out Elist_Id);\n-   --  Restore suffix 'P' to primitives of Prims_List and leave Prims_List\n-   --  set to No_Elist.\n-\n-   procedure Inline_Instance_Body\n-     (N        : Node_Id;\n-      Gen_Unit : Entity_Id;\n-      Act_Decl : Node_Id);\n-   --  If front-end inlining is requested, instantiate the package body,\n-   --  and preserve the visibility of its compilation unit, to insure\n-   --  that successive instantiations succeed.\n+   procedure Install_Parent (P : Entity_Id; In_Body : Boolean := False);\n+   --  When compiling an instance of a child unit the parent (which is\n+   --  itself an instance) is an enclosing scope that must be made\n+   --  immediately visible. This procedure is also used to install the non-\n+   --  generic parent of a generic child unit when compiling its body, so\n+   --  that full views of types in the parent are made visible.\n \n    --  The functions Instantiate_XXX perform various legality checks and build\n    --  the declarations for instantiated generic parameters. In all of these\n@@ -662,54 +802,6 @@ package body Sem_Ch12 is\n    --  instances in the current declarative part that precede the one being\n    --  loaded. In that case a missing body is acceptable.\n \n-   procedure Inherit_Context (Gen_Decl : Node_Id; Inst : Node_Id);\n-   --  Add the context clause of the unit containing a generic unit to a\n-   --  compilation unit that is, or contains, an instantiation.\n-\n-   function Get_Associated_Node (N : Node_Id) return Node_Id;\n-   --  In order to propagate semantic information back from the analyzed copy\n-   --  to the original generic, we maintain links between selected nodes in the\n-   --  generic and their corresponding copies. At the end of generic analysis,\n-   --  the routine Save_Global_References traverses the generic tree, examines\n-   --  the semantic information, and preserves the links to those nodes that\n-   --  contain global information. At instantiation, the information from the\n-   --  associated node is placed on the new copy, so that name resolution is\n-   --  not repeated.\n-   --\n-   --  Three kinds of source nodes have associated nodes:\n-   --\n-   --    a) those that can reference (denote) entities, that is identifiers,\n-   --       character literals, expanded_names, operator symbols, operators,\n-   --       and attribute reference nodes. These nodes have an Entity field\n-   --       and are the set of nodes that are in N_Has_Entity.\n-   --\n-   --    b) aggregates (N_Aggregate and N_Extension_Aggregate)\n-   --\n-   --    c) selected components (N_Selected_Component)\n-   --\n-   --  For the first class, the associated node preserves the entity if it is\n-   --  global. If the generic contains nested instantiations, the associated\n-   --  node itself has been recopied, and a chain of them must be followed.\n-   --\n-   --  For aggregates, the associated node allows retrieval of the type, which\n-   --  may otherwise not appear in the generic. The view of this type may be\n-   --  different between generic and instantiation, and the full view can be\n-   --  installed before the instantiation is analyzed. For aggregates of type\n-   --  extensions, the same view exchange may have to be performed for some of\n-   --  the ancestor types, if their view is private at the point of\n-   --  instantiation.\n-   --\n-   --  Nodes that are selected components in the parse tree may be rewritten\n-   --  as expanded names after resolution, and must be treated as potential\n-   --  entity holders, which is why they also have an Associated_Node.\n-   --\n-   --  Nodes that do not come from source, such as freeze nodes, do not appear\n-   --  in the generic tree, and need not have an associated node.\n-   --\n-   --  The associated node is stored in the Associated_Node field. Note that\n-   --  this field overlaps Entity, which is fine, because the whole point is\n-   --  that we don't need or want the normal Entity field in this situation.\n-\n    procedure Map_Formal_Package_Entities (Form : Entity_Id; Act : Entity_Id);\n    --  Within the generic part, entities in the formal package are\n    --  visible. To validate subsequent type declarations, indicate\n@@ -739,6 +831,31 @@ package body Sem_Ch12 is\n    --  before installing parents of generics, that are not visible for the\n    --  actuals themselves.\n \n+   procedure Remove_Parent (In_Body : Boolean := False);\n+   --  Reverse effect after instantiation of child is complete\n+\n+   procedure Restore_Hidden_Primitives (Prims_List : in out Elist_Id);\n+   --  Restore suffix 'P' to primitives of Prims_List and leave Prims_List\n+   --  set to No_Elist.\n+\n+   procedure Save_Global_References_In_Aspects (N : Node_Id);\n+   --  Save all global references found within the expressions of all aspects\n+   --  that appear on node N.\n+\n+   procedure Set_Instance_Env\n+     (Gen_Unit : Entity_Id;\n+      Act_Unit : Entity_Id);\n+   --  Save current instance on saved environment, to be used to determine\n+   --  the global status of entities in nested instances. Part of Save_Env.\n+   --  called after verifying that the generic unit is legal for the instance,\n+   --  The procedure also examines whether the generic unit is a predefined\n+   --  unit, in order to set configuration switches accordingly. As a result\n+   --  the procedure must be called after analyzing and freezing the actuals.\n+\n+   procedure Set_Instance_Of (A : Entity_Id; B : Entity_Id);\n+   --  Associate analyzed generic parameter with corresponding instance. Used\n+   --  for semantic checks at instantiation time.\n+\n    function True_Parent (N : Node_Id) return Node_Id;\n    --  For a subunit, return parent of corresponding stub, else return\n    --  parent of node.\n@@ -2305,10 +2422,11 @@ package body Sem_Ch12 is\n                  (Specification (Original_Node (Gen_Decl)),\n                     Empty, Instantiating => True));\n \n-         Renaming := Make_Package_Renaming_Declaration (Loc,\n+         Renaming :=\n+           Make_Package_Renaming_Declaration (Loc,\n              Defining_Unit_Name =>\n                Make_Defining_Identifier (Loc, Chars (Gen_Unit)),\n-             Name => New_Occurrence_Of (Formal, Loc));\n+             Name               => New_Occurrence_Of (Formal, Loc));\n \n          if Nkind (Gen_Id) = N_Identifier\n            and then Chars (Gen_Id) = Chars (Pack_Id)\n@@ -3064,6 +3182,13 @@ package body Sem_Ch12 is\n       --  do the same for their respective aspect specifications.\n \n       Exchange_Aspects (N, New_N);\n+\n+      --  Collect all contract-related source pragmas found within the template\n+      --  and attach them to the contract of the package spec. This contract is\n+      --  used in the capture of global references within annotations.\n+\n+      Create_Generic_Contract (N);\n+\n       Id := Defining_Entity (N);\n       Generate_Definition (Id);\n \n@@ -3201,6 +3326,12 @@ package body Sem_Ch12 is\n \n       Exchange_Aspects (N, New_N);\n \n+      --  Collect all contract-related source pragmas found within the template\n+      --  and attach them to the contract of the subprogram spec. This contract\n+      --  is used in the capture of global references within annotations.\n+\n+      Create_Generic_Contract (N);\n+\n       Spec := Specification (N);\n       Id := Defining_Entity (Spec);\n       Generate_Definition (Id);\n@@ -4620,9 +4751,10 @@ package body Sem_Ch12 is\n       --  aspects that appear in the generic. This renaming declaration is\n       --  inserted after the instance declaration which it renames.\n \n-      procedure Instantiate_Contract (Subp_Id : Entity_Id);\n-      --  Instantiate all source pragmas found in the contract of subprogram\n-      --  Subp_Id. The instantiated pragmas are added to list Renaming_List.\n+      procedure Instantiate_Subprogram_Contract (Templ : Node_Id);\n+      --  Instantiate all source pragmas found in the contract of the generic\n+      --  subprogram declaration template denoted by Templ. The instantiated\n+      --  pragmas are added to list Renaming_List.\n \n       ------------------------------------\n       -- Analyze_Instance_And_Renamings --\n@@ -4825,11 +4957,11 @@ package body Sem_Ch12 is\n          end if;\n       end Build_Subprogram_Renaming;\n \n-      --------------------------\n-      -- Instantiate_Contract --\n-      --------------------------\n+      -------------------------------------\n+      -- Instantiate_Subprogram_Contract --\n+      -------------------------------------\n \n-      procedure Instantiate_Contract (Subp_Id : Entity_Id) is\n+      procedure Instantiate_Subprogram_Contract (Templ : Node_Id) is\n          procedure Instantiate_Pragmas (First_Prag : Node_Id);\n          --  Instantiate all contract-related source pragmas found in the list\n          --  starting with pragma First_Prag. Each instantiated pragma is added\n@@ -4846,18 +4978,9 @@ package body Sem_Ch12 is\n          begin\n             Prag := First_Prag;\n             while Present (Prag) loop\n-               if Comes_From_Source (Prag)\n-                 and then Nam_In (Pragma_Name (Prag), Name_Contract_Cases,\n-                                                      Name_Depends,\n-                                                      Name_Extensions_Visible,\n-                                                      Name_Global,\n-                                                      Name_Postcondition,\n-                                                      Name_Precondition,\n-                                                      Name_Test_Case)\n-               then\n+               if Is_Generic_Contract_Pragma (Prag) then\n                   Inst_Prag :=\n-                    Copy_Generic_Node\n-                      (Original_Node (Prag), Empty, Instantiating => True);\n+                    Copy_Generic_Node (Prag, Empty, Instantiating => True);\n \n                   Set_Analyzed (Inst_Prag, False);\n                   Append_To (Renaming_List, Inst_Prag);\n@@ -4869,17 +4992,17 @@ package body Sem_Ch12 is\n \n          --  Local variables\n \n-         Items : constant Node_Id := Contract (Subp_Id);\n+         Items : constant Node_Id := Contract (Defining_Entity (Templ));\n \n-      --  Start of processing for Instantiate_Contract\n+      --  Start of processing for Instantiate_Subprogram_Contract\n \n       begin\n          if Present (Items) then\n             Instantiate_Pragmas (Pre_Post_Conditions (Items));\n             Instantiate_Pragmas (Contract_Test_Cases (Items));\n             Instantiate_Pragmas (Classifications     (Items));\n          end if;\n-      end Instantiate_Contract;\n+      end Instantiate_Subprogram_Contract;\n \n       --  Local variables\n \n@@ -5046,7 +5169,12 @@ package body Sem_Ch12 is\n          end if;\n \n          Append (Act_Decl, Renaming_List);\n-         Instantiate_Contract (Gen_Unit);\n+\n+         --  Contract-related source pragmas that follow a generic subprogram\n+         --  must be instantiated explicitly because they are not part of the\n+         --  subprogram template.\n+\n+         Instantiate_Subprogram_Contract (Original_Node (Gen_Decl));\n          Build_Subprogram_Renaming;\n \n          Analyze_Instance_And_Renamings;\n@@ -6888,7 +7016,6 @@ package body Sem_Ch12 is\n       ----------------------\n \n       procedure Copy_Descendants is\n-\n          use Atree.Unchecked_Access;\n          --  This code section is part of the implementation of an untyped\n          --  tree traversal, so it needs direct access to node fields.\n@@ -6987,11 +7114,12 @@ package body Sem_Ch12 is\n \n       function In_Defining_Unit_Name (Nam : Node_Id) return Boolean is\n       begin\n-         return Present (Parent (Nam))\n-           and then (Nkind (Parent (Nam)) = N_Defining_Program_Unit_Name\n-                      or else\n-                        (Nkind (Parent (Nam)) = N_Expanded_Name\n-                          and then In_Defining_Unit_Name (Parent (Nam))));\n+         return\n+           Present (Parent (Nam))\n+             and then (Nkind (Parent (Nam)) = N_Defining_Program_Unit_Name\n+                        or else\n+                          (Nkind (Parent (Nam)) = N_Expanded_Name\n+                            and then In_Defining_Unit_Name (Parent (Nam))));\n       end In_Defining_Unit_Name;\n \n    --  Start of processing for Copy_Generic_Node\n@@ -7019,17 +7147,12 @@ package body Sem_Ch12 is\n          Set_Parent (New_N, Parent_Id);\n       end if;\n \n-      --  If defining identifier, then all fields have been copied already\n-\n-      if Nkind (New_N) in N_Entity then\n-         null;\n-\n       --  Special casing for identifiers and other entity names and operators\n \n-      elsif Nkind_In (New_N, N_Identifier,\n-                             N_Character_Literal,\n-                             N_Expanded_Name,\n-                             N_Operator_Symbol)\n+      if Nkind_In (New_N, N_Character_Literal,\n+                          N_Expanded_Name,\n+                          N_Identifier,\n+                          N_Operator_Symbol)\n         or else Nkind (New_N) in N_Op\n       then\n          if not Instantiating then\n@@ -7160,6 +7283,19 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n+      --  Establish a link between an entity from the generic template and the\n+      --  corresponding entity in the generic copy to be analyzed.\n+\n+      elsif Nkind (N) in N_Entity then\n+         if not Instantiating then\n+            Set_Associated_Entity (N, New_N);\n+         end if;\n+\n+         --  Clear any existing link the copy may inherit from the replicated\n+         --  generic template entity.\n+\n+         Set_Associated_Entity (New_N, Empty);\n+\n       --  Special casing for stubs\n \n       elsif Nkind (N) in N_Body_Stub then\n@@ -7432,19 +7568,24 @@ package body Sem_Ch12 is\n             S_Adjustment := Save_Adjustment;\n          end;\n \n-      --  Don't copy Ident or Comment pragmas, since the comment belongs to the\n-      --  generic unit, not to the instantiating unit.\n-\n       elsif Nkind (N) = N_Pragma and then Instantiating then\n-         declare\n-            Prag_Id : constant Pragma_Id := Get_Pragma_Id (N);\n-         begin\n-            if Prag_Id = Pragma_Ident or else Prag_Id = Pragma_Comment then\n-               New_N := Make_Null_Statement (Sloc (N));\n-            else\n-               Copy_Descendants;\n-            end if;\n-         end;\n+\n+         --  Do not copy Comment or Ident pragmas their content is relevant to\n+         --  the generic unit, not to the instantiating unit.\n+\n+         if Nam_In (Pragma_Name (N), Name_Comment, Name_Ident) then\n+            New_N := Make_Null_Statement (Sloc (N));\n+\n+         --  Do not copy pragmas generated from aspects because the pragmas do\n+         --  not carry any semantic information, plus they will be regenerated\n+         --  in the instance.\n+\n+         elsif From_Aspect_Specification (N) then\n+            New_N := Make_Null_Statement (Sloc (N));\n+\n+         else\n+            Copy_Descendants;\n+         end if;\n \n       elsif Nkind_In (N, N_Integer_Literal, N_Real_Literal) then\n \n@@ -13516,10 +13657,18 @@ package body Sem_Ch12 is\n    -- Save_Global_References --\n    ----------------------------\n \n-   procedure Save_Global_References (N : Node_Id) is\n+   procedure Save_Global_References (Templ : Node_Id) is\n+\n+      --  ??? it is horrible to use global variables in highly recursive code\n+\n+      E : Entity_Id;\n+      --  The entity of the current associated node\n+\n       Gen_Scope : Entity_Id;\n-      E         : Entity_Id;\n-      N2        : Node_Id;\n+      --  The scope of the generic for which references are being saved\n+\n+      N2 : Node_Id;\n+      --  The current associated node\n \n       function Is_Global (E : Entity_Id) return Boolean;\n       --  Check whether entity is defined outside of generic unit. Examine the\n@@ -13548,7 +13697,7 @@ package body Sem_Ch12 is\n       --  nodes. N can also be a character literal, identifier, or operator\n       --  symbol node, but the call has no effect in these cases.\n \n-      procedure Save_Global_Defaults (N1, N2 : Node_Id);\n+      procedure Save_Global_Defaults (N1 : Node_Id; N2 : Node_Id);\n       --  Default actuals in nested instances must be handled specially\n       --  because there is no link to them from the original tree. When an\n       --  actual subprogram is given by a default, we add an explicit generic\n@@ -13561,8 +13710,7 @@ package body Sem_Ch12 is\n       --  so that it can be properly resolved in a subsequent instantiation.\n \n       procedure Save_Global_Descendant (D : Union_Id);\n-      --  Apply Save_Global_References recursively to the descendents of the\n-      --  current node.\n+      --  Apply Save_References recursively to the descendents of node D\n \n       procedure Save_References (N : Node_Id);\n       --  This is the recursive procedure that does the work, once the\n@@ -13630,7 +13778,6 @@ package body Sem_Ch12 is\n       ------------------\n \n       procedure Reset_Entity (N : Node_Id) is\n-\n          procedure Set_Global_Type (N : Node_Id; N2 : Node_Id);\n          --  If the type of N2 is global to the generic unit, save the type in\n          --  the generic node. Just as we perform name capture for explicit\n@@ -13654,14 +13801,12 @@ package body Sem_Ch12 is\n          begin\n             Set_Etype (N, Typ);\n \n-            if Entity (N) /= N2\n-              and then Has_Private_View (Entity (N))\n-            then\n-               --  If the entity of N is not the associated node, this is a\n-               --  nested generic and it has an associated node as well, whose\n-               --  type is already the full view (see below). Indicate that the\n-               --  original node has a private view.\n+            --  If the entity of N is not the associated node, this is a\n+            --  nested generic and it has an associated node as well, whose\n+            --  type is already the full view (see below). Indicate that the\n+            --  original node has a private view.\n \n+            if Entity (N) /= N2 and then Has_Private_View (Entity (N)) then\n                Set_Has_Private_View (N);\n             end if;\n \n@@ -13712,7 +13857,7 @@ package body Sem_Ch12 is\n \n       begin\n          N2 := Get_Associated_Node (N);\n-         E := Entity (N2);\n+         E  := Entity (N2);\n \n          if Present (E) then\n \n@@ -13721,12 +13866,12 @@ package body Sem_Ch12 is\n             --  preserve in this case, since the expansion will be redone in\n             --  the instance.\n \n-            if not Nkind_In (E, N_Defining_Identifier,\n-                                N_Defining_Character_Literal,\n+            if not Nkind_In (E, N_Defining_Character_Literal,\n+                                N_Defining_Identifier,\n                                 N_Defining_Operator_Symbol)\n             then\n                Set_Associated_Node (N, Empty);\n-               Set_Etype  (N, Empty);\n+               Set_Etype (N, Empty);\n                return;\n             end if;\n \n@@ -13767,11 +13912,11 @@ package body Sem_Ch12 is\n                      Set_Associated_Node (N, N2);\n                      Set_Global_Type (N, N2);\n \n-                  else\n-                     --  Renaming is local, and will be resolved in instance\n+                  --  Renaming is local, and will be resolved in instance\n \n+                  else\n                      Set_Associated_Node (N, Empty);\n-                     Set_Etype  (N, Empty);\n+                     Set_Etype (N, Empty);\n                   end if;\n \n                else\n@@ -13782,17 +13927,17 @@ package body Sem_Ch12 is\n               and then Is_Generic_Type (Etype (N2))\n               and then (Base_Type (Etype (Right_Opnd (N2))) = Etype (N2)\n                           or else\n-                        Base_Type (Etype (Left_Opnd (N2)))  = Etype (N2))\n+                        Base_Type (Etype (Left_Opnd  (N2))) = Etype (N2))\n               and then Is_Intrinsic_Subprogram (E)\n             then\n                null;\n \n-            else\n-               --  Entity is local. Mark generic node as unresolved.\n-               --  Note that now it does not have an entity.\n+            --  Entity is local. Mark generic node as unresolved. Note that now\n+            --  it does not have an entity.\n \n+            else\n                Set_Associated_Node (N, Empty);\n-               Set_Etype  (N, Empty);\n+               Set_Etype (N, Empty);\n             end if;\n \n             if Nkind (Parent (N)) in N_Generic_Instantiation\n@@ -13837,7 +13982,7 @@ package body Sem_Ch12 is\n               and then Parent (N) = Name (Parent (Parent (N)))\n             then\n                Save_Global_Defaults\n-                 (Parent (Parent (N)), Parent (Parent ((N2))));\n+                 (Parent (Parent (N)), Parent (Parent (N2)));\n             end if;\n \n          --  A selected component may denote a static constant that has been\n@@ -13852,9 +13997,6 @@ package body Sem_Ch12 is\n             then\n                Rewrite (Parent (N), New_Copy (Parent (N2)));\n                Set_Analyzed (Parent (N), False);\n-\n-            else\n-               null;\n             end if;\n \n          --  A selected component may be transformed into a parameterless\n@@ -13907,17 +14049,20 @@ package body Sem_Ch12 is\n       begin\n          case Nkind (N) is\n             when N_Binary_Op =>\n-               Save_Global_Descendant (Union_Id (Left_Opnd (N)));\n+               Save_Global_Descendant (Union_Id (Left_Opnd  (N)));\n                Save_Global_Descendant (Union_Id (Right_Opnd (N)));\n \n             when N_Unary_Op =>\n                Save_Global_Descendant (Union_Id (Right_Opnd (N)));\n \n-            when N_Expanded_Name | N_Selected_Component =>\n+            when N_Expanded_Name      |\n+                 N_Selected_Component =>\n                Save_Global_Descendant (Union_Id (Prefix (N)));\n                Save_Global_Descendant (Union_Id (Selector_Name (N)));\n \n-            when N_Identifier | N_Character_Literal | N_Operator_Symbol =>\n+            when N_Identifier         |\n+                 N_Character_Literal  |\n+                 N_Operator_Symbol    =>\n                null;\n \n             when others =>\n@@ -13929,7 +14074,7 @@ package body Sem_Ch12 is\n       -- Save_Global_Defaults --\n       --------------------------\n \n-      procedure Save_Global_Defaults (N1, N2 : Node_Id) is\n+      procedure Save_Global_Defaults (N1 : Node_Id; N2 : Node_Id) is\n          Loc    : constant Source_Ptr := Sloc (N1);\n          Assoc2 : constant List_Id    := Generic_Associations (N2);\n          Gen_Id : constant Entity_Id  := Get_Generic_Entity (N2);\n@@ -13998,9 +14143,10 @@ package body Sem_Ch12 is\n                if Is_Global (Actual) then\n                   Ndec :=\n                     Make_Generic_Association (Loc,\n-                      Selector_Name => New_Occurrence_Of (Subp, Loc),\n-                        Explicit_Generic_Actual_Parameter =>\n-                          New_Occurrence_Of (Actual, Loc));\n+                      Selector_Name                     =>\n+                        New_Occurrence_Of (Subp, Loc),\n+                      Explicit_Generic_Actual_Parameter =>\n+                        New_Occurrence_Of (Actual, Loc));\n \n                   Set_Associated_Node\n                     (Explicit_Generic_Actual_Parameter (Ndec), Def);\n@@ -14013,8 +14159,9 @@ package body Sem_Ch12 is\n                elsif Present (Next (Act2)) then\n                   Ndec :=\n                     Make_Generic_Association (Loc,\n-                      Selector_Name => New_Occurrence_Of (Subp, Loc),\n-                        Explicit_Generic_Actual_Parameter => Empty);\n+                      Selector_Name                     =>\n+                        New_Occurrence_Of (Subp, Loc),\n+                      Explicit_Generic_Actual_Parameter => Empty);\n \n                   Append (Ndec, Assoc1);\n                end if;\n@@ -14054,7 +14201,6 @@ package body Sem_Ch12 is\n               (Selector_Name (Name (N1)), Selector_Name (Name (N2)));\n             Set_Etype (Name (N1), Etype (Gen_Id));\n          end if;\n-\n       end Save_Global_Defaults;\n \n       ----------------------------\n@@ -14107,99 +14253,197 @@ package body Sem_Ch12 is\n       procedure Save_References (N : Node_Id) is\n          Loc : constant Source_Ptr := Sloc (N);\n \n-      begin\n-         if N = Empty then\n-            null;\n+         function Requires_Delayed_Save (Nod : Node_Id) return Boolean;\n+         --  Determine whether arbitrary node Nod requires delayed capture of\n+         --  global references within its aspect specifications.\n \n-         elsif Nkind_In (N, N_Character_Literal, N_Operator_Symbol) then\n-            if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n-               Reset_Entity (N);\n+         procedure Save_References_In_Aggregate (N : Node_Id);\n+         --  Save all global references in [extension] aggregate node N\n \n-            elsif Nkind (N) = N_Operator_Symbol\n-              and then Nkind (Get_Associated_Node (N)) = N_String_Literal\n-            then\n-               Change_Operator_Symbol_To_String_Literal (N);\n-            end if;\n+         procedure Save_References_In_Char_Lit_Or_Op_Symbol (N : Node_Id);\n+         --  Save all global references in a character literal or operator\n+         --  symbol denoted by N.\n \n-         elsif Nkind (N) in N_Op then\n-            if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n-               if Nkind (N) = N_Op_Concat then\n-                  Set_Is_Component_Left_Opnd (N,\n-                    Is_Component_Left_Opnd (Get_Associated_Node (N)));\n+         procedure Save_References_In_Descendants (N : Node_Id);\n+         --  Save all global references in all descendants of node N\n \n-                  Set_Is_Component_Right_Opnd (N,\n-                    Is_Component_Right_Opnd (Get_Associated_Node (N)));\n-               end if;\n+         procedure Save_References_In_Identifier (N : Node_Id);\n+         --  Save all global references in identifier node N\n \n-               Reset_Entity (N);\n+         procedure Save_References_In_Operator (N : Node_Id);\n+         --  Save all global references in operator node N\n \n-            else\n-               --  Node may be transformed into call to a user-defined operator\n+         procedure Save_References_In_Pragma (Prag : Node_Id);\n+         --  Save all global references found within the expression of pragma\n+         --  Prag.\n \n-               N2 := Get_Associated_Node (N);\n+         ---------------------------\n+         -- Requires_Delayed_Save --\n+         ---------------------------\n \n-               if Nkind (N2) = N_Function_Call then\n-                  E := Entity (Name (N2));\n+         function Requires_Delayed_Save (Nod : Node_Id) return Boolean is\n+         begin\n+            --  Generic packages and subprograms require delayed capture of\n+            --  global references within their aspects due to the timing of\n+            --  annotation analysis.\n \n-                  if Present (E)\n-                    and then Is_Global (E)\n-                  then\n-                     Set_Etype (N, Etype (N2));\n-                  else\n-                     Set_Associated_Node (N, Empty);\n-                     Set_Etype (N, Empty);\n-                  end if;\n+            if Nkind_In (Nod, N_Generic_Package_Declaration,\n+                              N_Generic_Subprogram_Declaration,\n+                              N_Package_Body,\n+                              N_Package_Body_Stub,\n+                              N_Subprogram_Body,\n+                              N_Subprogram_Body_Stub)\n+            then\n+               --  Since the capture of global references is done on the\n+               --  unanalyzed generic template, there is no information around\n+               --  to infer the context. Use the Associated_Entity linkages to\n+               --  peek into the analyzed generic copy and determine what the\n+               --  template corresponds to.\n+\n+               if Nod = Templ then\n+                  return\n+                    Is_Generic_Declaration_Or_Body\n+                      (Unit_Declaration_Node\n+                        (Associated_Entity (Defining_Entity (Nod))));\n+\n+               --  Otherwise the generic unit being processed is not the top\n+               --  level template. It is safe to capture of global references\n+               --  within the generic unit because at this point the top level\n+               --  copy is fully analyzed.\n \n-               elsif Nkind_In (N2, N_Integer_Literal,\n-                                   N_Real_Literal,\n-                                   N_String_Literal)\n-               then\n-                  if Present (Original_Node (N2))\n-                    and then Nkind (Original_Node (N2)) = Nkind (N)\n-                  then\n+               else\n+                  return False;\n+               end if;\n \n-                     --  Operation was constant-folded. Whenever possible,\n-                     --  recover semantic information from unfolded node,\n-                     --  for ASIS use.\n+            --  Otherwise capture the global references without interference\n \n-                     Set_Associated_Node (N, Original_Node (N2));\n+            else\n+               return False;\n+            end if;\n+         end Requires_Delayed_Save;\n \n-                     if Nkind (N) = N_Op_Concat then\n-                        Set_Is_Component_Left_Opnd (N,\n-                          Is_Component_Left_Opnd  (Get_Associated_Node (N)));\n-                        Set_Is_Component_Right_Opnd (N,\n-                          Is_Component_Right_Opnd (Get_Associated_Node (N)));\n-                     end if;\n+         ----------------------------------\n+         -- Save_References_In_Aggregate --\n+         ----------------------------------\n \n-                     Reset_Entity (N);\n+         procedure Save_References_In_Aggregate (N : Node_Id) is\n+            Nam   : Node_Id;\n+            Qual  : Node_Id   := Empty;\n+            Typ   : Entity_Id := Empty;\n \n-                  else\n-                     --  If original node is already modified, propagate\n-                     --  constant-folding to template.\n+            use Atree.Unchecked_Access;\n+            --  This code section is part of implementing an untyped tree\n+            --  traversal, so it needs direct access to node fields.\n \n-                     Rewrite (N, New_Copy (N2));\n-                     Set_Analyzed (N, False);\n-                  end if;\n+         begin\n+            N2 := Get_Associated_Node (N);\n \n-               elsif Nkind (N2) = N_Identifier\n-                 and then Ekind (Entity (N2)) = E_Enumeration_Literal\n+            if Present (N2) then\n+               Typ := Etype (N2);\n+\n+               --  In an instance within a generic, use the name of the actual\n+               --  and not the original generic parameter. If the actual is\n+               --  global in the current generic it must be preserved for its\n+               --  instantiation.\n+\n+               if Nkind (Parent (Typ)) = N_Subtype_Declaration\n+                 and then Present (Generic_Parent_Type (Parent (Typ)))\n                then\n-                  --  Same if call was folded into a literal, but in this case\n-                  --  retain the entity to avoid spurious ambiguities if it is\n-                  --  overloaded at the point of instantiation or inlining.\n+                  Typ := Base_Type (Typ);\n+                  Set_Etype (N2, Typ);\n+               end if;\n+            end if;\n \n-                  Rewrite (N, New_Copy (N2));\n-                  Set_Analyzed (N, False);\n+            if No (N2) or else No (Typ) or else not Is_Global (Typ) then\n+               Set_Associated_Node (N, Empty);\n+\n+               --  If the aggregate is an actual in a call, it has been\n+               --  resolved in the current context, to some local type. The\n+               --  enclosing call may have been disambiguated by the aggregate,\n+               --  and this disambiguation might fail at instantiation time\n+               --  because the type to which the aggregate did resolve is not\n+               --  preserved. In order to preserve some of this information,\n+               --  wrap the aggregate in a qualified expression, using the id\n+               --  of its type. For further disambiguation we qualify the type\n+               --  name with its scope (if visible) because both id's will have\n+               --  corresponding entities in an instance. This resolves most of\n+               --  the problems with missing type information on aggregates in\n+               --  instances.\n+\n+               if Present (N2)\n+                 and then Nkind (N2) = Nkind (N)\n+                 and then Nkind (Parent (N2)) in N_Subprogram_Call\n+                 and then Present (Typ)\n+                 and then Comes_From_Source (Typ)\n+               then\n+                  Nam := Make_Identifier (Loc, Chars (Typ));\n+\n+                  if Is_Immediately_Visible (Scope (Typ)) then\n+                     Nam :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix        =>\n+                           Make_Identifier (Loc, Chars (Scope (Typ))),\n+                         Selector_Name => Nam);\n+                  end if;\n+\n+                  Qual :=\n+                    Make_Qualified_Expression (Loc,\n+                      Subtype_Mark => Nam,\n+                      Expression   => Relocate_Node (N));\n                end if;\n             end if;\n \n-            --  Complete operands check if node has not been constant-folded\n+            Save_Global_Descendant (Field1 (N));\n+            Save_Global_Descendant (Field2 (N));\n+            Save_Global_Descendant (Field3 (N));\n+            Save_Global_Descendant (Field5 (N));\n \n-            if Nkind (N) in N_Op then\n-               Save_Entity_Descendants (N);\n+            if Present (Qual) then\n+               Rewrite (N, Qual);\n             end if;\n+         end Save_References_In_Aggregate;\n+\n+         ----------------------------------------------\n+         -- Save_References_In_Char_Lit_Or_Op_Symbol --\n+         ----------------------------------------------\n+\n+         procedure Save_References_In_Char_Lit_Or_Op_Symbol (N : Node_Id) is\n+         begin\n+            if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n+               Reset_Entity (N);\n+\n+            elsif Nkind (N) = N_Operator_Symbol\n+              and then Nkind (Get_Associated_Node (N)) = N_String_Literal\n+            then\n+               Change_Operator_Symbol_To_String_Literal (N);\n+            end if;\n+         end Save_References_In_Char_Lit_Or_Op_Symbol;\n+\n+         ------------------------------------\n+         -- Save_References_In_Descendants --\n+         ------------------------------------\n+\n+         procedure Save_References_In_Descendants (N : Node_Id) is\n+            use Atree.Unchecked_Access;\n+            --  This code section is part of implementing an untyped tree\n+            --  traversal, so it needs direct access to node fields.\n+\n+         begin\n+            Save_Global_Descendant (Field1 (N));\n+            Save_Global_Descendant (Field2 (N));\n+            Save_Global_Descendant (Field3 (N));\n+            Save_Global_Descendant (Field4 (N));\n+            Save_Global_Descendant (Field5 (N));\n+         end Save_References_In_Descendants;\n+\n+         -----------------------------------\n+         -- Save_References_In_Identifier --\n+         -----------------------------------\n+\n+         procedure Save_References_In_Identifier (N : Node_Id) is\n+         begin\n+            --  The node did not undergo a transformation\n \n-         elsif Nkind (N) = N_Identifier then\n             if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n \n                --  If this is a discriminant reference, always save it. It is\n@@ -14210,65 +14454,64 @@ package body Sem_Ch12 is\n                  (N, Original_Discriminant (Get_Associated_Node (N)));\n                Reset_Entity (N);\n \n+            --  The analysis of the generic copy transformed the identifier\n+            --  into another construct. Propagate the changes to the template.\n+\n             else\n                N2 := Get_Associated_Node (N);\n \n+               --  The identifier denotes a call to a parameterless function.\n+               --  Mark the node as resolved when the function is external.\n+\n                if Nkind (N2) = N_Function_Call then\n                   E := Entity (Name (N2));\n \n-                  --  Name resolves to a call to parameterless function. If\n-                  --  original entity is global, mark node as resolved.\n-\n-                  if Present (E)\n-                    and then Is_Global (E)\n-                  then\n+                  if Present (E) and then Is_Global (E) then\n                      Set_Etype (N, Etype (N2));\n                   else\n                      Set_Associated_Node (N, Empty);\n                      Set_Etype (N, Empty);\n                   end if;\n \n+               --  The identifier denotes a named number that was constant\n+               --  folded. Preserve the original name for ASIS and undo the\n+               --  constant folding which will be repeated in the instance.\n+\n                elsif Nkind_In (N2, N_Integer_Literal, N_Real_Literal)\n                  and then Is_Entity_Name (Original_Node (N2))\n                then\n-                  --  Name resolves to named number that is constant-folded,\n-                  --  We must preserve the original name for ASIS use, and\n-                  --  undo the constant-folding, which will be repeated in\n-                  --  each instance.\n-\n                   Set_Associated_Node (N, Original_Node (N2));\n                   Reset_Entity (N);\n \n-               elsif Nkind (N2) = N_String_Literal then\n-\n-                  --  Name resolves to string literal. Perform the same\n-                  --  replacement in generic.\n+               --  The identifier resolved to a string literal. Propagate this\n+               --  information to the generic template.\n \n+               elsif Nkind (N2) = N_String_Literal then\n                   Rewrite (N, New_Copy (N2));\n \n-               elsif Nkind (N2) = N_Explicit_Dereference then\n-\n-                  --  An identifier is rewritten as a dereference if it is the\n-                  --  prefix in an implicit dereference (call or attribute).\n-                  --  The analysis of an instantiation will expand the node\n-                  --  again, so we preserve the original tree but link it to\n-                  --  the resolved entity in case it is global.\n+               --  The identifier is rewritten as a dereference if it is the\n+               --  prefix of an implicit dereference. Preserve the original\n+               --  tree as the analysis of the instance will expand the node\n+               --  again, but preserve the resolved entity if it is global.\n \n+               elsif Nkind (N2) = N_Explicit_Dereference then\n                   if Is_Entity_Name (Prefix (N2))\n                     and then Present (Entity (Prefix (N2)))\n                     and then Is_Global (Entity (Prefix (N2)))\n                   then\n                      Set_Associated_Node (N, Prefix (N2));\n \n                   elsif Nkind (Prefix (N2)) = N_Function_Call\n+                    and then Present (Entity (Name (Prefix (N2))))\n                     and then Is_Global (Entity (Name (Prefix (N2))))\n                   then\n                      Rewrite (N,\n                        Make_Explicit_Dereference (Loc,\n-                          Prefix => Make_Function_Call (Loc,\n-                            Name =>\n-                              New_Occurrence_Of\n-                                (Entity (Name (Prefix (N2))), Loc))));\n+                         Prefix =>\n+                           Make_Function_Call (Loc,\n+                             Name =>\n+                               New_Occurrence_Of\n+                                 (Entity (Name (Prefix (N2))), Loc))));\n \n                   else\n                      Set_Associated_Node (N, Empty);\n@@ -14284,117 +14527,211 @@ package body Sem_Ch12 is\n                then\n                   Set_Associated_Node (N, Original_Node (N2));\n                   Reset_Entity (N);\n-\n-               else\n-                  null;\n                end if;\n             end if;\n+         end Save_References_In_Identifier;\n \n-         elsif Nkind (N) in N_Entity then\n-            null;\n+         ---------------------------------\n+         -- Save_References_In_Operator --\n+         ---------------------------------\n \n-         else\n-            declare\n-               Qual : Node_Id := Empty;\n-               Typ  : Entity_Id := Empty;\n-               Nam  : Node_Id;\n+         procedure Save_References_In_Operator (N : Node_Id) is\n+         begin\n+            --  The node did not undergo a transformation\n \n-               use Atree.Unchecked_Access;\n-               --  This code section is part of implementing an untyped tree\n-               --  traversal, so it needs direct access to node fields.\n+            if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n+               if Nkind (N) = N_Op_Concat then\n+                  Set_Is_Component_Left_Opnd (N,\n+                    Is_Component_Left_Opnd (Get_Associated_Node (N)));\n \n-            begin\n-               if Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n-                  N2 := Get_Associated_Node (N);\n+                  Set_Is_Component_Right_Opnd (N,\n+                    Is_Component_Right_Opnd (Get_Associated_Node (N)));\n+               end if;\n \n-                  if No (N2) then\n-                     Typ := Empty;\n+               Reset_Entity (N);\n \n-                  else\n-                     Typ := Etype (N2);\n+            --  The analysis of the generic copy transformed the operator into\n+            --  some other construct. Propagate the changes to the template.\n \n-                     --  In an instance within a generic, use the name of the\n-                     --  actual and not the original generic parameter. If the\n-                     --  actual is global in the current generic it must be\n-                     --  preserved for its instantiation.\n+            else\n+               N2 := Get_Associated_Node (N);\n \n-                     if Nkind (Parent (Typ)) = N_Subtype_Declaration\n-                       and then\n-                         Present (Generic_Parent_Type (Parent (Typ)))\n-                     then\n-                        Typ := Base_Type (Typ);\n-                        Set_Etype (N2, Typ);\n-                     end if;\n-                  end if;\n+               --  The operator resoved to a function call\n \n-                  if No (N2) or else No (Typ) or else not Is_Global (Typ) then\n+               if Nkind (N2) = N_Function_Call then\n+                  E := Entity (Name (N2));\n+\n+                  if Present (E) and then Is_Global (E) then\n+                     Set_Etype (N, Etype (N2));\n+                  else\n                      Set_Associated_Node (N, Empty);\n+                     Set_Etype (N, Empty);\n+                  end if;\n \n-                     --  If the aggregate is an actual in a call, it has been\n-                     --  resolved in the current context, to some local type.\n-                     --  The enclosing call may have been disambiguated by the\n-                     --  aggregate, and this disambiguation might fail at\n-                     --  instantiation time because the type to which the\n-                     --  aggregate did resolve is not preserved. In order to\n-                     --  preserve some of this information, we wrap the\n-                     --  aggregate in a qualified expression, using the id of\n-                     --  its type. For further disambiguation we qualify the\n-                     --  type name with its scope (if visible) because both\n-                     --  id's will have corresponding entities in an instance.\n-                     --  This resolves most of the problems with missing type\n-                     --  information on aggregates in instances.\n-\n-                     if Nkind (N2) = Nkind (N)\n-                       and then Nkind (Parent (N2)) in N_Subprogram_Call\n-                       and then Comes_From_Source (Typ)\n-                     then\n-                        if Is_Immediately_Visible (Scope (Typ)) then\n-                           Nam :=\n-                             Make_Selected_Component (Loc,\n-                               Prefix        =>\n-                                 Make_Identifier (Loc, Chars (Scope (Typ))),\n-                               Selector_Name =>\n-                                 Make_Identifier (Loc, Chars (Typ)));\n-                        else\n-                           Nam := Make_Identifier (Loc, Chars (Typ));\n-                        end if;\n+               --  The operator was folded into a literal\n \n-                        Qual :=\n-                          Make_Qualified_Expression (Loc,\n-                            Subtype_Mark => Nam,\n-                            Expression   => Relocate_Node (N));\n+               elsif Nkind_In (N2, N_Integer_Literal,\n+                                   N_Real_Literal,\n+                                   N_String_Literal)\n+               then\n+                  if Present (Original_Node (N2))\n+                    and then Nkind (Original_Node (N2)) = Nkind (N)\n+                  then\n+                     --  Operation was constant-folded. Whenever possible,\n+                     --  recover semantic information from unfolded node,\n+                     --  for ASIS use.\n+\n+                     Set_Associated_Node (N, Original_Node (N2));\n+\n+                     if Nkind (N) = N_Op_Concat then\n+                        Set_Is_Component_Left_Opnd (N,\n+                          Is_Component_Left_Opnd  (Get_Associated_Node (N)));\n+                        Set_Is_Component_Right_Opnd (N,\n+                          Is_Component_Right_Opnd (Get_Associated_Node (N)));\n                      end if;\n-                  end if;\n \n-                  Save_Global_Descendant (Field1 (N));\n-                  Save_Global_Descendant (Field2 (N));\n-                  Save_Global_Descendant (Field3 (N));\n-                  Save_Global_Descendant (Field5 (N));\n+                     Reset_Entity (N);\n \n-                  if Present (Qual) then\n-                     Rewrite (N, Qual);\n+                  --  Propagate the constant folding back to the template\n+\n+                  else\n+                     Rewrite (N, New_Copy (N2));\n+                     Set_Analyzed (N, False);\n                   end if;\n \n-               --  All other cases than aggregates\n+               --  The operator was folded into an enumeration literal. Retain\n+               --  the entity to avoid spurious ambiguities if it is overloaded\n+               --  at the point of instantiation or inlining.\n+\n+               elsif Nkind (N2) = N_Identifier\n+                 and then Ekind (Entity (N2)) = E_Enumeration_Literal\n+               then\n+                  Rewrite (N, New_Copy (N2));\n+                  Set_Analyzed (N, False);\n+               end if;\n+            end if;\n+\n+            --  Complete the operands check if node has not been constant\n+            --  folded.\n+\n+            if Nkind (N) in N_Op then\n+               Save_Entity_Descendants (N);\n+            end if;\n+         end Save_References_In_Operator;\n+\n+         -------------------------------\n+         -- Save_References_In_Pragma --\n+         -------------------------------\n+\n+         procedure Save_References_In_Pragma (Prag : Node_Id) is\n+            Context : Node_Id;\n+            Do_Save : Boolean := True;\n+\n+            use Atree.Unchecked_Access;\n+            --  This code section is part of implementing an untyped tree\n+            --  traversal, so it needs direct access to node fields.\n+\n+         begin\n+            --  Do not save global references in pragmas generated from aspects\n+            --  because the pragmas will be regenerated at instantiation time.\n+\n+            if From_Aspect_Specification (Prag) then\n+               Do_Save := False;\n+\n+            --  The capture of global references within contract-related source\n+            --  pragmas associated with generic packages, subprograms or their\n+            --  respective bodies must be delayed due to timing of annotation\n+            --  analysis. Global references are still captured in routine\n+            --  Save_Global_References_In_Contract.\n+\n+            elsif Is_Generic_Contract_Pragma (Prag) and then Prag /= Templ then\n+               if Is_Package_Contract_Annotation (Prag) then\n+                  Context := Find_Related_Package_Or_Body (Prag);\n \n                else\n-                  Save_Global_Descendant (Field1 (N));\n-                  Save_Global_Descendant (Field2 (N));\n-                  Save_Global_Descendant (Field3 (N));\n-                  Save_Global_Descendant (Field4 (N));\n-                  Save_Global_Descendant (Field5 (N));\n+                  pragma Assert (Is_Subprogram_Contract_Annotation (Prag));\n+                  Context := Find_Related_Subprogram_Or_Body (Prag);\n                end if;\n-            end;\n+\n+               --  The use of Original_Node accounts for the case when the\n+               --  related context is generic template.\n+\n+               if Requires_Delayed_Save (Original_Node (Context)) then\n+                  Do_Save := False;\n+               end if;\n+            end if;\n+\n+            --  For all other cases, save all global references within the\n+            --  descendants, but skip the following semantic fields:\n+\n+            --    Field1 - Next_Pragma\n+            --    Field3 - Corresponding_Aspect\n+            --    Field5 - Next_Rep_Item\n+\n+            if Do_Save then\n+               Save_Global_Descendant (Field2 (Prag));\n+               Save_Global_Descendant (Field4 (Prag));\n+            end if;\n+         end Save_References_In_Pragma;\n+\n+      --  Start of processing for Save_References\n+\n+      begin\n+         if N = Empty then\n+            null;\n+\n+         --  Aggregates\n+\n+         elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n+            Save_References_In_Aggregate (N);\n+\n+         --  Character literals, operator symbols\n+\n+         elsif Nkind_In (N, N_Character_Literal, N_Operator_Symbol) then\n+            Save_References_In_Char_Lit_Or_Op_Symbol (N);\n+\n+         --  Defining identifiers\n+\n+         elsif Nkind (N) in N_Entity then\n+            null;\n+\n+         --  Identifiers\n+\n+         elsif Nkind (N) = N_Identifier then\n+            Save_References_In_Identifier (N);\n+\n+         --  Operators\n+\n+         elsif Nkind (N) in N_Op then\n+            Save_References_In_Operator (N);\n+\n+         --  Pragmas\n+\n+         elsif Nkind (N) = N_Pragma then\n+            Save_References_In_Pragma (N);\n+\n+         else\n+            Save_References_In_Descendants (N);\n          end if;\n \n-         --  Save all global references found within the aspects of the related\n-         --  node. This is not done for generic subprograms because the aspects\n-         --  must be delayed and analyzed at the end of the declarative part.\n-         --  Only then can global references be saved. This action is performed\n-         --  by the analysis of the generic subprogram contract.\n+         --  Save all global references found within the aspect specifications\n+         --  of the related node.\n \n-         if Nkind (N) /= N_Generic_Subprogram_Declaration then\n-            Save_Global_References_In_Aspects (N);\n+         if Permits_Aspect_Specifications (N) and then Has_Aspects (N) then\n+\n+            --  The capture of global references within aspects associated with\n+            --  generic packages, subprograms or their bodies must be delayed\n+            --  due to timing of annotation analysis. Global references are\n+            --  still captured in routine Save_Global_References_In_Contract.\n+\n+            if Requires_Delayed_Save (N) then\n+               null;\n+\n+            --  Otherwise save all global references within the aspects\n+\n+            else\n+               Save_Global_References_In_Aspects (N);\n+            end if;\n          end if;\n       end Save_References;\n \n@@ -14413,7 +14750,7 @@ package body Sem_Ch12 is\n          Gen_Scope := Scope (Gen_Scope);\n       end loop;\n \n-      Save_References (N);\n+      Save_References (Templ);\n    end Save_Global_References;\n \n    ---------------------------------------\n@@ -14425,19 +14762,74 @@ package body Sem_Ch12 is\n       Expr : Node_Id;\n \n    begin\n-      if Permits_Aspect_Specifications (N) and then Has_Aspects (N) then\n-         Asp := First (Aspect_Specifications (N));\n-         while Present (Asp) loop\n-            Expr := Expression (Asp);\n+      Asp := First (Aspect_Specifications (N));\n+      while Present (Asp) loop\n+         Expr := Expression (Asp);\n+\n+         if Present (Expr) then\n+            Save_Global_References (Expr);\n+         end if;\n \n-            if Present (Expr) then\n-               Save_Global_References (Expr);\n+         Next (Asp);\n+      end loop;\n+   end Save_Global_References_In_Aspects;\n+\n+   ----------------------------------------\n+   -- Save_Global_References_In_Contract --\n+   ----------------------------------------\n+\n+   procedure Save_Global_References_In_Contract\n+     (Templ  : Node_Id;\n+      Gen_Id : Entity_Id)\n+   is\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n+      --  Save all global references in contract-related source pragmas found\n+      --  in the list starting with pragma First_Prag.\n+\n+      ------------------------------------\n+      -- Save_Global_References_In_List --\n+      ------------------------------------\n+\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n+         Prag : Node_Id;\n+\n+      begin\n+         Prag := First_Prag;\n+         while Present (Prag) loop\n+            if Is_Generic_Contract_Pragma (Prag) then\n+               Save_Global_References (Prag);\n             end if;\n \n-            Next (Asp);\n+            Prag := Next_Pragma (Prag);\n          end loop;\n+      end Save_Global_References_In_List;\n+\n+      --  Local variables\n+\n+      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n+\n+   --  Start of processing for Save_Global_References_In_Contract\n+\n+   begin\n+      --  The entity of the analyzed generic copy must be on the scope stack\n+      --  to ensure proper detection of global references.\n+\n+      Push_Scope (Gen_Id);\n+\n+      if Permits_Aspect_Specifications (Templ)\n+        and then Has_Aspects (Templ)\n+      then\n+         Save_Global_References_In_Aspects (Templ);\n       end if;\n-   end Save_Global_References_In_Aspects;\n+\n+      if Present (Items) then\n+         Save_Global_References_In_List (Pre_Post_Conditions (Items));\n+         Save_Global_References_In_List (Contract_Test_Cases (Items));\n+         Save_Global_References_In_List (Classifications     (Items));\n+      end if;\n+\n+      Pop_Scope;\n+   end Save_Global_References_In_Contract;\n \n    --------------------------------------\n    -- Set_Copied_Sloc_For_Inlined_Body --"}, {"sha": "53ff6c50e9567c5bec6b41c0c23e2046c4cbb8ab", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -136,24 +136,28 @@ package Sem_Ch12 is\n    --  pragma, or because a pragma appears for the instance in the scope.\n    --  of the instance.\n \n-   procedure Save_Global_References (N : Node_Id);\n+   procedure Save_Global_References (Templ : Node_Id);\n    --  Traverse the original generic unit, and capture all references to\n-   --  entities that are defined outside of the generic in the analyzed\n-   --  tree for the template. These references are copied into the original\n-   --  tree, so that they appear automatically in every instantiation.\n-   --  A critical invariant in this approach is that if an id in the generic\n-   --  resolves to a local entity, the corresponding id in the instance\n-   --  will resolve to the homologous entity in the instance, even though\n-   --  the enclosing context for resolution is different, as long as the\n-   --  global references have been captured as described here.\n+   --  entities that are defined outside of the generic in the analyzed tree\n+   --  for the template. These references are copied into the original tree,\n+   --  so that they appear automatically in every instantiation. A critical\n+   --  invariant in this approach is that if an id in the generic resolves to\n+   --  a local entity, the corresponding id in the instance will resolve to\n+   --  the homologous entity in the instance, even though the enclosing context\n+   --  for resolution is different, as long as the global references have been\n+   --  captured as described here.\n \n    --  Because instantiations can be nested, the environment of the instance,\n    --  involving the actuals and other data-structures, must be saved and\n    --  restored in stack-like fashion. Front-end inlining also uses these\n    --  structures for the management of private/full views.\n \n-   procedure Save_Global_References_In_Aspects (N : Node_Id);\n-   --  Save all global references in the aspect specifications of node N\n+   procedure Save_Global_References_In_Contract\n+     (Templ  : Node_Id;\n+      Gen_Id : Entity_Id);\n+   --  Save all global references found within the aspect specifications and\n+   --  the contract-related source pragmas assocated with generic template\n+   --  Templ. Gen_Id denotes the entity of the analyzed generic copy.\n \n    procedure Set_Copied_Sloc_For_Inlined_Body (N : Node_Id; E : Entity_Id);\n    --  This procedure is used when a subprogram body is inlined. This process"}, {"sha": "30437ba5eea0b425971af77bf9d648b7f59d8f1e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -3416,6 +3416,147 @@ package body Sem_Ch13 is\n       end if;\n    end Analyze_Aspect_Specifications;\n \n+   ---------------------------------------------------\n+   -- Analyze_Aspect_Specifications_On_Body_Or_Stub --\n+   ---------------------------------------------------\n+\n+   procedure Analyze_Aspect_Specifications_On_Body_Or_Stub (N : Node_Id) is\n+      Body_Id : constant Entity_Id := Defining_Entity (N);\n+\n+      procedure Diagnose_Misplaced_Aspects (Spec_Id : Entity_Id);\n+      --  Subprogram body [stub] N has aspects, but they are not properly\n+      --  placed. Emit an error message depending on the aspects involved.\n+      --  Spec_Id is the entity of the corresponding spec.\n+\n+      --------------------------------\n+      -- Diagnose_Misplaced_Aspects --\n+      --------------------------------\n+\n+      procedure Diagnose_Misplaced_Aspects (Spec_Id : Entity_Id) is\n+         procedure Misplaced_Aspect_Error\n+           (Asp     : Node_Id;\n+            Ref_Nam : Name_Id);\n+         --  Emit an error message concerning misplaced aspect Asp. Ref_Nam is\n+         --  the name of the refined version of the aspect.\n+\n+         ----------------------------\n+         -- Misplaced_Aspect_Error --\n+         ----------------------------\n+\n+         procedure Misplaced_Aspect_Error\n+           (Asp     : Node_Id;\n+            Ref_Nam : Name_Id)\n+         is\n+            Asp_Nam : constant Name_Id   := Chars (Identifier (Asp));\n+            Asp_Id  : constant Aspect_Id := Get_Aspect_Id (Asp_Nam);\n+\n+         begin\n+            --  The corresponding spec already contains the aspect in question\n+            --  and the one appearing on the body must be the refined form:\n+\n+            --    procedure P with Global ...;\n+            --    procedure P with Global ... is ... end P;\n+            --                     ^\n+            --                     Refined_Global\n+\n+            if Has_Aspect (Spec_Id, Asp_Id) then\n+               Error_Msg_Name_1 := Asp_Nam;\n+\n+               --  Subunits cannot carry aspects that apply to a subprogram\n+               --  declaration.\n+\n+               if Nkind (Parent (N)) = N_Subunit then\n+                  Error_Msg_N (\"aspect % cannot apply to a subunit\", Asp);\n+\n+               --  Otherwise suggest the refined form\n+\n+               else\n+                  Error_Msg_Name_2 := Ref_Nam;\n+                  Error_Msg_N (\"aspect % should be %\", Asp);\n+               end if;\n+\n+            --  Otherwise the aspect must appear on the spec, not on the body\n+\n+            --    procedure P;\n+            --    procedure P with Global ... is ... end P;\n+\n+            else\n+               Error_Msg_N\n+                 (\"aspect specification must appear in subprogram declaration\",\n+                  Asp);\n+            end if;\n+         end Misplaced_Aspect_Error;\n+\n+         --  Local variables\n+\n+         Asp     : Node_Id;\n+         Asp_Nam : Name_Id;\n+\n+      --  Start of processing for Diagnose_Misplaced_Aspects\n+\n+      begin\n+         --  Iterate over the aspect specifications and emit specific errors\n+         --  where applicable.\n+\n+         Asp := First (Aspect_Specifications (N));\n+         while Present (Asp) loop\n+            Asp_Nam := Chars (Identifier (Asp));\n+\n+            --  Do not emit errors on aspects that can appear on a subprogram\n+            --  body. This scenario occurs when the aspect specification list\n+            --  contains both misplaced and properly placed aspects.\n+\n+            if Aspect_On_Body_Or_Stub_OK (Get_Aspect_Id (Asp_Nam)) then\n+               null;\n+\n+            --  Special diagnostics for SPARK aspects\n+\n+            elsif Asp_Nam = Name_Depends then\n+               Misplaced_Aspect_Error (Asp, Name_Refined_Depends);\n+\n+            elsif Asp_Nam = Name_Global then\n+               Misplaced_Aspect_Error (Asp, Name_Refined_Global);\n+\n+            elsif Asp_Nam = Name_Post then\n+               Misplaced_Aspect_Error (Asp, Name_Refined_Post);\n+\n+            --  Otherwise a language-defined aspect is misplaced\n+\n+            else\n+               Error_Msg_N\n+                 (\"aspect specification must appear in subprogram declaration\",\n+                  Asp);\n+            end if;\n+\n+            Next (Asp);\n+         end loop;\n+      end Diagnose_Misplaced_Aspects;\n+\n+      --  Local variables\n+\n+      Spec_Id : Entity_Id;\n+\n+   --  Start of processing for Analyze_Aspects_On_Body_Or_Stub\n+\n+   begin\n+      if Nkind (N) = N_Subprogram_Body_Stub then\n+         Spec_Id := Corresponding_Spec_Of_Stub (N);\n+      else\n+         Spec_Id := Corresponding_Spec (N);\n+      end if;\n+\n+      --  Language-defined aspects cannot be associated with a subprogram body\n+      --  [stub] if the subprogram has a spec. Certain implementation defined\n+      --  aspects are allowed to break this rule (for all applicable cases, see\n+      --  table Aspects.Aspect_On_Body_Or_Stub_OK).\n+\n+      if Present (Spec_Id) and then not Aspects_On_Body_Or_Stub_OK (N) then\n+         Diagnose_Misplaced_Aspects (Spec_Id);\n+      else\n+         Analyze_Aspect_Specifications (N, Body_Id);\n+      end if;\n+   end Analyze_Aspect_Specifications_On_Body_Or_Stub;\n+\n    -----------------------\n    -- Analyze_At_Clause --\n    -----------------------"}, {"sha": "df7790860659da6bc9f99a2d43d0767d0ff38e73", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,12 @@ package Sem_Ch13 is\n    --  is the corresponding entity declared by the declaration node N. Callers\n    --  should check that Has_Aspects (N) is True before calling this routine.\n \n+   procedure Analyze_Aspect_Specifications_On_Body_Or_Stub (N : Node_Id);\n+   --  Analyze the aspect specifications of [generic] subprogram body or stub\n+   --  N. Callers should check that Has_Aspects (N) is True before calling the\n+   --  routine. This routine diagnoses misplaced aspects that should appear on\n+   --  the initial declaration of N and offers suggestions for replacements.\n+\n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id);\n    --  Called from Freeze where R is a record entity for which reverse bit\n    --  order is specified and there is at least one component clause. Adjusts"}, {"sha": "75bf87448a71ffa6d0a8055ba4c8c20c665c5c2c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -58,6 +58,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n+with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n@@ -2302,17 +2303,14 @@ package body Sem_Ch3 is\n \n       --  Local variables\n \n-      Context     : Node_Id;\n+      Context     : Node_Id   := Empty;\n       Freeze_From : Entity_Id := Empty;\n       Next_Decl   : Node_Id;\n-      Spec_Id     : Entity_Id;\n+      Pack_Decl   : Node_Id   := Empty;\n \n       Body_Seen : Boolean := False;\n       --  Flag set when the first body [stub] is encountered\n \n-      In_Package_Body : Boolean := False;\n-      --  Flag set when the current declaration list belongs to a package body\n-\n    --  Start of processing for Analyze_Declarations\n \n    begin\n@@ -2456,6 +2454,7 @@ package body Sem_Ch3 is\n          Context := Parent (L);\n \n          if Nkind (Context) = N_Package_Specification then\n+            Pack_Decl := Parent (Context);\n \n             --  When a package has private declarations, its contract must be\n             --  analyzed at the end of the said declarations. This way both the\n@@ -2484,44 +2483,71 @@ package body Sem_Ch3 is\n             end if;\n \n          elsif Nkind (Context) = N_Package_Body then\n-            In_Package_Body := True;\n-            Spec_Id := Corresponding_Spec (Context);\n-\n+            Pack_Decl := Context;\n             Analyze_Package_Body_Contract (Defining_Entity (Context));\n          end if;\n-      end if;\n \n-      --  Analyze the contracts of subprogram declarations, subprogram bodies\n-      --  and variables now due to the delayed visibility requirements of their\n-      --  aspects.\n+         --  Analyze the contracts of all subprogram declarations, subprogram\n+         --  bodies and variables now due to the delayed visibility needs of\n+         --  of their aspects and pragmas. Capture global references in generic\n+         --  subprograms or bodies.\n \n-      Decl := First (L);\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Object_Declaration then\n-            Analyze_Object_Contract (Defining_Entity (Decl));\n+         Decl := First (L);\n+         while Present (Decl) loop\n+            if Nkind (Decl) = N_Object_Declaration then\n+               Analyze_Object_Contract (Defining_Entity (Decl));\n \n-         elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n-                               N_Generic_Subprogram_Declaration,\n-                               N_Subprogram_Declaration)\n-         then\n-            Analyze_Subprogram_Contract (Defining_Entity (Decl));\n+            elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                                  N_Generic_Subprogram_Declaration,\n+                                  N_Subprogram_Declaration)\n+            then\n+               Analyze_Subprogram_Contract (Defining_Entity (Decl));\n \n-         elsif Nkind (Decl) = N_Subprogram_Body then\n-            Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n+            elsif Nkind (Decl) = N_Subprogram_Body then\n+               Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n \n-         elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n-            Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n-         end if;\n+            elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n+               Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n+            end if;\n \n-         Next (Decl);\n-      end loop;\n+            --  Capture all global references in a generic subprogram or a body\n+            --  [stub] now that the contract has been analyzed.\n+\n+            if Nkind_In (Decl, N_Generic_Subprogram_Declaration,\n+                               N_Subprogram_Body,\n+                               N_Subprogram_Body_Stub)\n+              and then Is_Generic_Declaration_Or_Body (Decl)\n+            then\n+               Save_Global_References_In_Contract\n+                 (Templ  => Original_Node (Decl),\n+                  Gen_Id => Corresponding_Spec_Of (Decl));\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         --  The owner of the declarations is a package [body]\n+\n+         if Present (Pack_Decl) then\n \n-      --  State refinements are visible upto the end the of the package body\n-      --  declarations. Hide the refinements from visibility to restore the\n-      --  original state conditions.\n+            --  Capture all global references in a generic package or a body\n+            --  after all nested generic subprograms and bodies were subjected\n+            --  to the same processing.\n \n-      if In_Package_Body then\n-         Remove_Visible_Refinements (Spec_Id);\n+            if Is_Generic_Declaration_Or_Body (Pack_Decl) then\n+               Save_Global_References_In_Contract\n+                 (Templ  => Original_Node (Pack_Decl),\n+                  Gen_Id => Corresponding_Spec_Of (Pack_Decl));\n+            end if;\n+\n+            --  State refinements are visible upto the end the of the package\n+            --  body declarations. Hide the state refinements from visibility\n+            --  to restore the original state conditions.\n+\n+            if Nkind (Pack_Decl) = N_Package_Body then\n+               Remove_Visible_Refinements (Corresponding_Spec (Pack_Decl));\n+            end if;\n+         end if;\n       end if;\n    end Analyze_Declarations;\n "}, {"sha": "42fb1ddd2f2fc107b14f9147d9235faba1e67154", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 96, "deletions": 299, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -1154,6 +1154,19 @@ package body Sem_Ch6 is\n       if Nkind (N) /= N_Subprogram_Body_Stub then\n          New_N := Copy_Generic_Node (N, Empty, Instantiating => False);\n          Rewrite (N, New_N);\n+\n+         --  Once the contents of the generic copy and the template are\n+         --  swapped, do the same for their respective aspect specifications.\n+\n+         Exchange_Aspects (N, New_N);\n+\n+         --  Collect all contract-related source pragmas found within the\n+         --  template and attach them to the contract of the subprogram body.\n+         --  This contract is used in the capture of global references within\n+         --  annotations.\n+\n+         Create_Generic_Contract (N);\n+\n          Start_Generic;\n       end if;\n \n@@ -1293,10 +1306,35 @@ package body Sem_Ch6 is\n          Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id, True);\n \n+         --  Analyze any aspect specifications that appear on the generic\n+         --  subprogram body.\n+\n+         if Has_Aspects (N) then\n+            Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n+         end if;\n+\n          Analyze_Declarations (Declarations (N));\n          Check_Completion;\n-         Analyze (Handled_Statement_Sequence (N));\n \n+         --  When a generic subprogram body appears inside a package, its\n+         --  contract is analyzed at the end of the package body declarations.\n+         --  This is due to the delay with respect of the package contract upon\n+         --  which the body contract may depend. When the generic subprogram\n+         --  body is a compilation unit, this delay is not necessary.\n+\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            Analyze_Subprogram_Body_Contract (Body_Id);\n+\n+            --  Capture all global references in a generic subprogram body\n+            --  that acts as a compilation unit now that the contract has\n+            --  been analyzed.\n+\n+            Save_Global_References_In_Contract\n+              (Templ  => Original_Node (N),\n+               Gen_Id => Gen_Id);\n+         end if;\n+\n+         Analyze (Handled_Statement_Sequence (N));\n          Save_Global_References (Original_Node (N));\n \n          --  Prior to exiting the scope, include generic formals again (if any\n@@ -2125,53 +2163,57 @@ package body Sem_Ch6 is\n    --------------------------------------\n \n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Body_Decl : constant Node_Id := Unit_Declaration_Node (Body_Id);\n+      Items       : constant Node_Id := Contract (Body_Id);\n+      Mode        : SPARK_Mode_Type;\n+      Prag        : Node_Id;\n+      Prag_Nam    : Name_Id;\n+      Ref_Depends : Node_Id := Empty;\n+      Ref_Global  : Node_Id := Empty;\n \n-      procedure Analyze_Completion_Contract (Spec_Id : Entity_Id);\n-      --  Analyze all delayed pragmas chained on the contract of subprogram\n-      --  body Body_Id as if they appeared at the end of a declarative region.\n-      --  Spec_Id denotes the corresponding spec. The aspects in question are:\n-      --    Refined_Depends\n-      --    Refined_Global\n-      --  Note that pragma Refined_Post is analyzed immediately\n+   begin\n+      --  When a subprogram body declaration is illegal, its defining entity is\n+      --  left unanalyzed. There is nothing left to do in this case because the\n+      --  body lacks a contract, or even a proper Ekind.\n \n-      ---------------------------------\n-      -- Analyze_Completion_Contract --\n-      ---------------------------------\n+      if Ekind (Body_Id) = E_Void then\n+         return;\n+      end if;\n \n-      procedure Analyze_Completion_Contract (Spec_Id : Entity_Id) is\n-         Items         : constant Node_Id := Contract (Body_Id);\n-         Prag          : Node_Id;\n-         Prag_Nam      : Name_Id;\n-         Ref_Depends   : Node_Id := Empty;\n-         Ref_Global    : Node_Id := Empty;\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n \n-      begin\n-         --  All subprograms carry a contract, but for some it is not\n-         --  significant and should not be processed.\n+      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n \n-         if not Has_Significant_Contract (Spec_Id) then\n-            return;\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n \n-         elsif Present (Items) then\n+      if not Has_Significant_Contract (Body_Id) then\n+         null;\n \n-            --  Locate and store pragmas Refined_Depends and Refined_Global\n-            --  since their order of analysis matters.\n+      --  The subprogram body is a completion, analyze all delayed pragmas that\n+      --  apply. Note that when the body is stand alone, the pragmas are always\n+      --  analyzed on the spot.\n \n-            Prag := Classifications (Items);\n-            while Present (Prag) loop\n-               Prag_Nam := Pragma_Name (Prag);\n+      elsif Present (Items) then\n \n-               if Prag_Nam = Name_Refined_Depends then\n-                  Ref_Depends := Prag;\n+         --  Locate and store pragmas Refined_Depends and Refined_Global since\n+         --  their order of analysis matters.\n \n-               elsif Prag_Nam = Name_Refined_Global then\n-                  Ref_Global := Prag;\n-               end if;\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n \n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end if;\n+            if Prag_Nam = Name_Refined_Depends then\n+               Ref_Depends := Prag;\n+\n+            elsif Prag_Nam = Name_Refined_Global then\n+               Ref_Global := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n \n          --  Analyze Refined_Global first as Refined_Depends may mention items\n          --  classified in the global refinement.\n@@ -2186,43 +2228,6 @@ package body Sem_Ch6 is\n          if Present (Ref_Depends) then\n             Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n          end if;\n-      end Analyze_Completion_Contract;\n-\n-      --  Local variables\n-\n-      Mode    : SPARK_Mode_Type;\n-      Spec_Id : Entity_Id;\n-\n-   --  Start of processing for Analyze_Subprogram_Body_Contract\n-\n-   begin\n-      --  When a subprogram body declaration is illegal, its defining entity is\n-      --  left unanalyzed. There is nothing left to do in this case because the\n-      --  body lacks a contract, or even a proper Ekind.\n-\n-      if Ekind (Body_Id) = E_Void then\n-         return;\n-      end if;\n-\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n-\n-      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n-\n-      if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n-         Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n-      else\n-         Spec_Id := Corresponding_Spec (Body_Decl);\n-      end if;\n-\n-      --  The subprogram body is a completion, analyze all delayed pragmas that\n-      --  apply. Note that when the body is stand alone, the pragmas are always\n-      --  analyzed on the spot.\n-\n-      if Present (Spec_Id) then\n-         Analyze_Completion_Contract (Spec_Id);\n       end if;\n \n       --  Ensure that the contract cases or postconditions mention 'Result or\n@@ -2276,10 +2281,6 @@ package body Sem_Ch6 is\n       --  chained beyond that point. It is initialized to Empty to deal with\n       --  the case where there is no separate spec.\n \n-      procedure Analyze_Aspects_On_Body_Or_Stub;\n-      --  Analyze the aspect specifications of a subprogram body [stub]. It is\n-      --  assumed that N has aspects.\n-\n       function Body_Has_Contract return Boolean;\n       --  Check whether unanalyzed body has an aspect or pragma that may\n       --  generate a SPARK contract.\n@@ -2338,127 +2339,6 @@ package body Sem_Ch6 is\n       --  indicator, check that it is consistent with the known status of the\n       --  entity.\n \n-      -------------------------------------\n-      -- Analyze_Aspects_On_Body_Or_Stub --\n-      -------------------------------------\n-\n-      procedure Analyze_Aspects_On_Body_Or_Stub is\n-         procedure Diagnose_Misplaced_Aspects;\n-         --  Subprogram body [stub] N has aspects, but they are not properly\n-         --  placed. Provide precise diagnostics depending on the aspects\n-         --  involved.\n-\n-         --------------------------------\n-         -- Diagnose_Misplaced_Aspects --\n-         --------------------------------\n-\n-         procedure Diagnose_Misplaced_Aspects is\n-            Asp     : Node_Id;\n-            Asp_Nam : Name_Id;\n-            Asp_Id  : Aspect_Id;\n-            --  The current aspect along with its name and id\n-\n-            procedure SPARK_Aspect_Error (Ref_Nam : Name_Id);\n-            --  Emit an error message concerning SPARK aspect Asp. Ref_Nam is\n-            --  the name of the refined version of the aspect.\n-\n-            ------------------------\n-            -- SPARK_Aspect_Error --\n-            ------------------------\n-\n-            procedure SPARK_Aspect_Error (Ref_Nam : Name_Id) is\n-            begin\n-               --  The corresponding spec already contains the aspect in\n-               --  question and the one appearing on the body must be the\n-               --  refined form:\n-\n-               --    procedure P with Global ...;\n-               --    procedure P with Global ... is ... end P;\n-               --                     ^\n-               --                     Refined_Global\n-\n-               if Has_Aspect (Spec_Id, Asp_Id) then\n-                  Error_Msg_Name_1 := Asp_Nam;\n-\n-                  --  Subunits cannot carry aspects that apply to a subprogram\n-                  --  declaration.\n-\n-                  if Nkind (Parent (N)) = N_Subunit then\n-                     Error_Msg_N (\"aspect % cannot apply to a subunit\", Asp);\n-\n-                  else\n-                     Error_Msg_Name_2 := Ref_Nam;\n-                     Error_Msg_N (\"aspect % should be %\", Asp);\n-                  end if;\n-\n-               --  Otherwise the aspect must appear in the spec, not in the\n-               --  body:\n-\n-               --    procedure P;\n-               --    procedure P with Global ... is ... end P;\n-\n-               else\n-                  Error_Msg_N\n-                    (\"aspect specification must appear in subprogram \"\n-                     & \"declaration\", Asp);\n-               end if;\n-            end SPARK_Aspect_Error;\n-\n-         --  Start of processing for Diagnose_Misplaced_Aspects\n-\n-         begin\n-            --  Iterate over the aspect specifications and emit specific errors\n-            --  where applicable.\n-\n-            Asp := First (Aspect_Specifications (N));\n-            while Present (Asp) loop\n-               Asp_Nam := Chars (Identifier (Asp));\n-               Asp_Id  := Get_Aspect_Id (Asp_Nam);\n-\n-               --  Do not emit errors on aspects that can appear on a\n-               --  subprogram body. This scenario occurs when the aspect\n-               --  specification list contains both misplaced and properly\n-               --  placed aspects.\n-\n-               if Aspect_On_Body_Or_Stub_OK (Asp_Id) then\n-                  null;\n-\n-               --  Special diagnostics for SPARK aspects\n-\n-               elsif Asp_Nam = Name_Depends then\n-                  SPARK_Aspect_Error (Name_Refined_Depends);\n-\n-               elsif Asp_Nam = Name_Global then\n-                  SPARK_Aspect_Error (Name_Refined_Global);\n-\n-               elsif Asp_Nam = Name_Post then\n-                  SPARK_Aspect_Error (Name_Refined_Post);\n-\n-               else\n-                  Error_Msg_N\n-                    (\"aspect specification must appear in subprogram \"\n-                     & \"declaration\", Asp);\n-               end if;\n-\n-               Next (Asp);\n-            end loop;\n-         end Diagnose_Misplaced_Aspects;\n-\n-      --  Start of processing for Analyze_Aspects_On_Body_Or_Stub\n-\n-      begin\n-         --  Language-defined aspects cannot be associated with a subprogram\n-         --  body [stub] if the subprogram has a spec. Certain implementation\n-         --  defined aspects are allowed to break this rule (for list, see\n-         --  table Aspect_On_Body_Or_Stub_OK).\n-\n-         if Present (Spec_Id) and then not Aspects_On_Body_Or_Stub_OK (N) then\n-            Diagnose_Misplaced_Aspects;\n-         else\n-            Analyze_Aspect_Specifications (N, Body_Id);\n-         end if;\n-      end Analyze_Aspects_On_Body_Or_Stub;\n-\n       -----------------------\n       -- Body_Has_Contract --\n       -----------------------\n@@ -3637,18 +3517,15 @@ package body Sem_Ch6 is\n       Set_Has_Completion (Body_Id);\n       Check_Eliminated (Body_Id);\n \n-      if Nkind (N) = N_Subprogram_Body_Stub then\n-\n-         --  Analyze any aspect specifications that appear on the subprogram\n-         --  body stub.\n+      --  Analyze any aspect specifications that appear on the subprogram body\n+      --  stub. Stop the analysis now as the stub does not have a declarative\n+      --  or a statement part, and it cannot be inlined.\n \n+      if Nkind (N) = N_Subprogram_Body_Stub then\n          if Has_Aspects (N) then\n-            Analyze_Aspects_On_Body_Or_Stub;\n+            Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n          end if;\n \n-         --  Stop the analysis now as the stub cannot be inlined, plus it does\n-         --  not have declarative or statement lists.\n-\n          return;\n       end if;\n \n@@ -3830,7 +3707,7 @@ package body Sem_Ch6 is\n       --  Analyze any aspect specifications that appear on the subprogram body\n \n       if Has_Aspects (N) then\n-         Analyze_Aspects_On_Body_Or_Stub;\n+         Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n       end if;\n \n       Analyze_Declarations (Declarations (N));\n@@ -4119,79 +3996,28 @@ package body Sem_Ch6 is\n    ---------------------------------\n \n    procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id) is\n-      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n-      --  Save all global references in contract-related source pragma found in\n-      --  the list starting from pragma First_Prag.\n-\n-      ------------------------------------\n-      -- Save_Global_References_In_List --\n-      ------------------------------------\n-\n-      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n-         Prag : Node_Id;\n-\n-      begin\n-         Prag := First_Prag;\n-         while Present (Prag) loop\n-            if Comes_From_Source (Prag)\n-              and then Nam_In (Pragma_Name (Prag), Name_Contract_Cases,\n-                                                   Name_Depends,\n-                                                   Name_Extensions_Visible,\n-                                                   Name_Global,\n-                                                   Name_Postcondition,\n-                                                   Name_Precondition,\n-                                                   Name_Test_Case)\n-            then\n-               Save_Global_References (Original_Node (Prag));\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end Save_Global_References_In_List;\n-\n-      --  Local variables\n-\n-      Items         : constant Node_Id := Contract (Subp_Id);\n-      Subp_Decl     : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n-      Depends       : Node_Id := Empty;\n-      Global        : Node_Id := Empty;\n-      Mode          : SPARK_Mode_Type;\n-      Prag          : Node_Id;\n-      Prag_Nam      : Name_Id;\n-      Restore_Scope : Boolean := False;\n-\n-   --  Start of processing for Analyze_Subprogram_Contract\n+      Items    : constant Node_Id := Contract (Subp_Id);\n+      Depends  : Node_Id := Empty;\n+      Global   : Node_Id := Empty;\n+      Mode     : SPARK_Mode_Type;\n+      Prag     : Node_Id;\n+      Prag_Nam : Name_Id;\n \n    begin\n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed.\n-\n-      if not Has_Significant_Contract (Subp_Id) then\n-         return;\n-      end if;\n-\n       --  Due to the timing of contract analysis, delayed pragmas may be\n       --  subject to the wrong SPARK_Mode, usually that of the enclosing\n       --  context. To remedy this, restore the original SPARK_Mode of the\n       --  related subprogram body.\n \n       Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n \n-      --  Ensure that the formal parameters are visible when analyzing all\n-      --  contract items.\n-\n-      if not In_Open_Scopes (Subp_Id) then\n-         Restore_Scope := True;\n-         Push_Scope (Subp_Id);\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n \n-         if Is_Generic_Subprogram (Subp_Id) then\n-            Install_Generic_Formals (Subp_Id);\n-         else\n-            Install_Formals (Subp_Id);\n-         end if;\n-      end if;\n+      if not Has_Significant_Contract (Subp_Id) then\n+         null;\n \n-      if Present (Items) then\n+      elsif Present (Items) then\n \n          --  Analyze pre- and postconditions\n \n@@ -4256,35 +4082,6 @@ package body Sem_Ch6 is\n          Check_Result_And_Post_State (Subp_Id);\n       end if;\n \n-      --  The aspects and contract-related source pragmas associated with a\n-      --  generic subprogram are treated separately from the declaration as\n-      --  they need to be analyzed when the subprogram contract is analyzed.\n-      --  Once this is done, global references can be successfully saved.\n-\n-      if Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n-\n-         --  Save all global references found in the aspect specifications of\n-         --  the parameter profile of the generic subprogram.\n-\n-         Save_Global_References_In_Aspects (Original_Node (Subp_Decl));\n-\n-         --  Save all global references found in contract-related source\n-         --  pragmas. These pragmas usually appear after the declaration of\n-         --  the generic subprogram, either in the same declarative part or\n-         --  in the Pragmas_After list when the generic subprogram is a\n-         --  compilation unit.\n-\n-         if Present (Items) then\n-            Save_Global_References_In_List (Pre_Post_Conditions (Items));\n-            Save_Global_References_In_List (Contract_Test_Cases (Items));\n-            Save_Global_References_In_List (Classifications     (Items));\n-         end if;\n-      end if;\n-\n-      if Restore_Scope then\n-         End_Scope;\n-      end if;\n-\n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n "}, {"sha": "3369fad4aa8f55ed17ef835282a52f17d37e839e", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -187,9 +187,9 @@ package body Sem_Ch7 is\n    -----------------------------------\n \n    procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id) is\n-      Spec_Id : constant Entity_Id := Spec_Entity (Body_Id);\n-      Mode    : SPARK_Mode_Type;\n-      Prag    : Node_Id;\n+      Spec_Id   : constant Entity_Id := Spec_Entity (Body_Id);\n+      Mode      : SPARK_Mode_Type;\n+      Ref_State : Node_Id;\n \n    begin\n       --  Due to the timing of contract analysis, delayed pragmas may be\n@@ -199,13 +199,13 @@ package body Sem_Ch7 is\n \n       Save_SPARK_Mode_And_Set (Body_Id, Mode);\n \n-      Prag := Get_Pragma (Body_Id, Pragma_Refined_State);\n+      Ref_State := Get_Pragma (Body_Id, Pragma_Refined_State);\n \n       --  The analysis of pragma Refined_State detects whether the spec has\n       --  abstract states available for refinement.\n \n-      if Present (Prag) then\n-         Analyze_Refined_State_In_Decl_Part (Prag);\n+      if Present (Ref_State) then\n+         Analyze_Refined_State_In_Decl_Part (Ref_State);\n \n       --  State refinement is required when the package declaration defines at\n       --  least one abstract state. Null states are not considered. Refinement\n@@ -677,6 +677,13 @@ package body Sem_Ch7 is\n \n          Exchange_Aspects (N, New_N);\n \n+         --  Collect all contract-related source pragmas found within the\n+         --  template and attach them to the contract of the package body.\n+         --  This contract is used in the capture of global references within\n+         --  annotations.\n+\n+         Create_Generic_Contract (N);\n+\n          --  Update Body_Id to point to the copied node for the remainder of\n          --  the processing.\n \n@@ -940,8 +947,12 @@ package body Sem_Ch7 is\n    ------------------------------\n \n    procedure Analyze_Package_Contract (Pack_Id : Entity_Id) is\n-      Mode : SPARK_Mode_Type;\n-      Prag : Node_Id;\n+      Items     : constant Node_Id := Contract (Pack_Id);\n+      Init      : Node_Id := Empty;\n+      Init_Cond : Node_Id := Empty;\n+      Mode      : SPARK_Mode_Type;\n+      Prag      : Node_Id;\n+      Prag_Nam  : Name_Id;\n \n    begin\n       --  Due to the timing of contract analysis, delayed pragmas may be\n@@ -951,19 +962,35 @@ package body Sem_Ch7 is\n \n       Save_SPARK_Mode_And_Set (Pack_Id, Mode);\n \n-      --  Analyze the initialization related pragmas. Initializes must come\n-      --  before Initial_Condition due to item dependencies.\n+      if Present (Items) then\n \n-      Prag := Get_Pragma (Pack_Id, Pragma_Initializes);\n+         --  Locate and store pragmas Initial_Condition and Initializes since\n+         --  their order of analysis matters.\n \n-      if Present (Prag) then\n-         Analyze_Initializes_In_Decl_Part (Prag);\n-      end if;\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n \n-      Prag := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+            if Prag_Nam = Name_Initial_Condition then\n+               Init_Cond := Prag;\n \n-      if Present (Prag) then\n-         Analyze_Initial_Condition_In_Decl_Part (Prag);\n+            elsif Prag_Nam = Name_Initializes then\n+               Init := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze the initialization related pragmas. Initializes must come\n+         --  before Initial_Condition due to item dependencies.\n+\n+         if Present (Init) then\n+            Analyze_Initializes_In_Decl_Part (Init);\n+         end if;\n+\n+         if Present (Init_Cond) then\n+            Analyze_Initial_Condition_In_Decl_Part (Init_Cond);\n+         end if;\n       end if;\n \n       --  Check whether the lack of indicator Part_Of agrees with the placement"}, {"sha": "758aed07a72f0edd226314a9363fb0ef4d67d364", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 879, "deletions": 611, "changes": 1490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345"}, {"sha": "cb3f82e647d1076a356cc1a9283ca72a3d81369d", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -172,9 +172,10 @@ package Sem_Prag is\n    --  inputs and outputs of subprogram Subp_Id in lists Subp_Inputs (inputs)\n    --  and Subp_Outputs (outputs). The inputs and outputs are gathered from:\n    --    1) The formal parameters of the subprogram\n-   --    2) The items of pragma [Refined_]Global\n+   --    2) The generic formal parameters of the generic subprogram\n+   --    3) The items of pragma [Refined_]Global\n    --         or\n-   --    3) The items of pragma [Refined_]Depends if there is no pragma\n+   --    4) The items of pragma [Refined_]Depends if there is no pragma\n    --       [Refined_]Global present and flag Synthesize is set to True.\n    --  If the subprogram has no inputs and/or outputs, then the returned list\n    --  is No_Elist. Flag Global_Seen is set when the related subprogram has\n@@ -190,6 +191,16 @@ package Sem_Prag is\n    --  True have their analysis delayed until after the main program is parsed\n    --  and analyzed.\n \n+   function Find_Related_Package_Or_Body\n+     (Prag      : Node_Id;\n+      Do_Checks : Boolean := False) return Node_Id;\n+   --  Subsidiary to the analysis of pragmas Abstract_State, Initial_Condition,\n+   --  Initializes and Refined_State. Find the declaration of the related\n+   --  package [body] subject to pragma Prag. The return value is either\n+   --  N_Package_Declaration, N_Package_Body or Empty if the placement of\n+   --  the pragma is illegal. If flag Do_Checks is set, the routine reports\n+   --  duplicate pragmas.\n+\n    function Find_Related_Subprogram_Or_Body\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id;\n@@ -207,6 +218,20 @@ package Sem_Prag is\n    --       N_Subprogram_Body or N_Subprogram_Body_Stub nodes or Empty if\n    --       illegal.\n \n+   function Get_Argument\n+     (Prag       : Node_Id;\n+      Context_Id : Node_Id := Empty) return Node_Id;\n+   --  Obtain the argument of pragma Prag depending on context and the nature\n+   --  of the pragma. The argument is extracted in the following manner:\n+   --\n+   --    When the pragma is generated from an aspect, return the corresponding\n+   --    aspect for ASIS or when Context_Id denotes a generic unit.\n+   --\n+   --    Otherwise return the first argument of Prag\n+   --\n+   --  Context denotes the entity of the function, package or procedure where\n+   --  Prag resides.\n+\n    function Get_SPARK_Mode_From_Pragma (N : Node_Id) return SPARK_Mode_Type;\n    --  Given a pragma SPARK_Mode node, return corresponding mode id\n "}, {"sha": "01dc53163d903090bfa0665a1f8b9a8811ed5c76", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 246, "deletions": 34, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -49,6 +49,7 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Attr; use Sem_Attr;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n@@ -4523,23 +4524,164 @@ package body Sem_Util is\n    -- Corresponding_Spec_Of --\n    ---------------------------\n \n-   function Corresponding_Spec_Of (Subp_Decl : Node_Id) return Entity_Id is\n+   function Corresponding_Spec_Of (Decl : Node_Id) return Entity_Id is\n    begin\n-      if Nkind (Subp_Decl) = N_Subprogram_Body\n-        and then Present (Corresponding_Spec (Subp_Decl))\n+      if Nkind_In (Decl, N_Package_Body, N_Subprogram_Body)\n+        and then Present (Corresponding_Spec (Decl))\n       then\n-         return Corresponding_Spec (Subp_Decl);\n+         return Corresponding_Spec (Decl);\n \n-      elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n-        and then Present (Corresponding_Spec_Of_Stub (Subp_Decl))\n+      elsif Nkind_In (Decl, N_Package_Body_Stub, N_Subprogram_Body_Stub)\n+        and then Present (Corresponding_Spec_Of_Stub (Decl))\n       then\n-         return Corresponding_Spec_Of_Stub (Subp_Decl);\n+         return Corresponding_Spec_Of_Stub (Decl);\n \n       else\n-         return Defining_Entity (Subp_Decl);\n+         return Defining_Entity (Decl);\n       end if;\n    end Corresponding_Spec_Of;\n \n+   -----------------------------\n+   -- Create_Generic_Contract --\n+   -----------------------------\n+\n+   procedure Create_Generic_Contract (Unit : Node_Id) is\n+      Templ    : constant Node_Id   := Original_Node (Unit);\n+      Templ_Id : constant Entity_Id := Defining_Entity (Templ);\n+\n+      procedure Add_Generic_Contract_Pragma (Prag : Node_Id);\n+      --  Add a single contract-related source pragma Prag to the contract of\n+      --  generic template Templ_Id.\n+\n+      ---------------------------------\n+      -- Add_Generic_Contract_Pragma --\n+      ---------------------------------\n+\n+      procedure Add_Generic_Contract_Pragma (Prag : Node_Id) is\n+         Prag_Templ : Node_Id;\n+\n+      begin\n+         --  Mark the pragma to prevent the premature capture of global\n+         --  references when capturing global references of the context\n+         --  (see Save_References_In_Pragma).\n+\n+         Set_Is_Generic_Contract_Pragma (Prag);\n+\n+         --  Pragmas that apply to a generic subprogram declaration are not\n+         --  part of the semantic structure of the generic template:\n+\n+         --    generic\n+         --    procedure Example (Formal : Integer);\n+         --    pragma Precondition (Formal > 0);\n+\n+         --  Create a generic template for such pragmas and link the template\n+         --  of the pragma with the generic template.\n+\n+         if Nkind (Templ) = N_Generic_Subprogram_Declaration then\n+            Rewrite\n+              (Prag, Copy_Generic_Node (Prag, Empty, Instantiating => False));\n+            Prag_Templ := Original_Node (Prag);\n+\n+            Set_Is_Generic_Contract_Pragma (Prag_Templ);\n+            Add_Contract_Item (Prag_Templ, Templ_Id);\n+\n+         --  Otherwise link the pragma with the generic template\n+\n+         else\n+            Add_Contract_Item (Prag, Templ_Id);\n+         end if;\n+      end Add_Generic_Contract_Pragma;\n+\n+      --  Local variables\n+\n+      Context : constant Node_Id   := Parent (Unit);\n+      Decl    : Node_Id := Empty;\n+\n+   --  Start of processing for Create_Generic_Contract\n+\n+   begin\n+      --  A generic package declaration carries contract-related source pragmas\n+      --  in its visible declarations.\n+\n+      if Nkind (Templ) = N_Generic_Package_Declaration then\n+         Set_Ekind (Templ_Id, E_Generic_Package);\n+\n+         if Present (Visible_Declarations (Specification (Templ))) then\n+            Decl := First (Visible_Declarations (Specification (Templ)));\n+         end if;\n+\n+      --  A generic package body carries contract-related source pragmas in its\n+      --  declarations.\n+\n+      elsif Nkind (Templ) = N_Package_Body then\n+         Set_Ekind (Templ_Id, E_Package_Body);\n+\n+         if Present (Declarations (Templ)) then\n+            Decl := First (Declarations (Templ));\n+         end if;\n+\n+      --  Generic subprogram declaration\n+\n+      elsif Nkind (Templ) = N_Generic_Subprogram_Declaration then\n+         if Nkind (Specification (Templ)) = N_Function_Specification then\n+            Set_Ekind (Templ_Id, E_Generic_Function);\n+         else\n+            Set_Ekind (Templ_Id, E_Generic_Procedure);\n+         end if;\n+\n+         --  When the generic subprogram acts as a compilation unit, inspect\n+         --  the Pragmas_After list for contract-related source pragmas.\n+\n+         if Nkind (Context) = N_Compilation_Unit then\n+            if Present (Aux_Decls_Node (Context))\n+              and then Present (Pragmas_After (Aux_Decls_Node (Context)))\n+            then\n+               Decl := First (Pragmas_After (Aux_Decls_Node (Context)));\n+            end if;\n+\n+         --  Otherwise inspect the successive declarations for contract-related\n+         --  source pragmas.\n+\n+         else\n+            Decl := Next (Unit);\n+         end if;\n+\n+      --  A generic subprogram body carries contract-related source pragmas in\n+      --  its declarations.\n+\n+      elsif Nkind (Templ) = N_Subprogram_Body then\n+         Set_Ekind (Templ_Id, E_Subprogram_Body);\n+\n+         if Present (Declarations (Templ)) then\n+            Decl := First (Declarations (Templ));\n+         end if;\n+      end if;\n+\n+      --  Inspect the relevant declarations looking for contract-related source\n+      --  pragmas and add them to the contract of the generic unit.\n+\n+      while Present (Decl) loop\n+         if Comes_From_Source (Decl) then\n+            if Nkind (Decl) = N_Pragma then\n+\n+               --  The source pragma is a contract annotation\n+\n+               if Is_Contract_Annotation (Decl) then\n+                  Add_Generic_Contract_Pragma (Decl);\n+               end if;\n+\n+            --  The region where a contract-related source pragma may appear\n+            --  ends with the first source non-pragma declaration or statement.\n+\n+            else\n+               exit;\n+            end if;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Create_Generic_Contract;\n+\n    --------------------\n    -- Current_Entity --\n    --------------------\n@@ -10541,33 +10683,10 @@ package body Sem_Util is\n    ----------------------------\n \n    function Is_Contract_Annotation (Item : Node_Id) return Boolean is\n-      Nam : Name_Id;\n-\n    begin\n-      if Nkind (Item) = N_Aspect_Specification then\n-         Nam := Chars (Identifier (Item));\n-\n-      else pragma Assert (Nkind (Item) = N_Pragma);\n-         Nam := Pragma_Name (Item);\n-      end if;\n-\n-      return      Nam = Name_Abstract_State\n-          or else Nam = Name_Contract_Cases\n-          or else Nam = Name_Depends\n-          or else Nam = Name_Extensions_Visible\n-          or else Nam = Name_Global\n-          or else Nam = Name_Initial_Condition\n-          or else Nam = Name_Initializes\n-          or else Nam = Name_Post\n-          or else Nam = Name_Post_Class\n-          or else Nam = Name_Postcondition\n-          or else Nam = Name_Pre\n-          or else Nam = Name_Pre_Class\n-          or else Nam = Name_Precondition\n-          or else Nam = Name_Refined_Depends\n-          or else Nam = Name_Refined_Global\n-          or else Nam = Name_Refined_State\n-          or else Nam = Name_Test_Case;\n+      return Is_Package_Contract_Annotation (Item)\n+               or else\n+             Is_Subprogram_Contract_Annotation (Item);\n    end Is_Contract_Annotation;\n \n    --------------------------------------\n@@ -11426,6 +11545,45 @@ package body Sem_Util is\n       end if;\n    end Is_Fully_Initialized_Variant;\n \n+   ------------------------------------\n+   -- Is_Generic_Declaration_Or_Body --\n+   ------------------------------------\n+\n+   function Is_Generic_Declaration_Or_Body (Decl : Node_Id) return Boolean is\n+      Spec_Decl : Node_Id;\n+\n+   begin\n+      --  Package/subprogram body\n+\n+      if Nkind_In (Decl, N_Package_Body, N_Subprogram_Body)\n+        and then Present (Corresponding_Spec (Decl))\n+      then\n+         Spec_Decl := Unit_Declaration_Node (Corresponding_Spec (Decl));\n+\n+      --  Package/subprogram body stub\n+\n+      elsif Nkind_In (Decl, N_Package_Body_Stub, N_Subprogram_Body_Stub)\n+        and then Present (Corresponding_Spec_Of_Stub (Decl))\n+      then\n+         Spec_Decl :=\n+           Unit_Declaration_Node (Corresponding_Spec_Of_Stub (Decl));\n+\n+      --  All other cases\n+\n+      else\n+         Spec_Decl := Decl;\n+      end if;\n+\n+      --  Rather than inspecting the defining entity of the spec declaration,\n+      --  look at its Nkind. This takes care of the case where the analysis of\n+      --  a generic body modifies the Ekind of its spec to allow for recursive\n+      --  calls.\n+\n+      return\n+        Nkind_In (Spec_Decl, N_Generic_Package_Declaration,\n+                             N_Generic_Subprogram_Declaration);\n+   end Is_Generic_Declaration_Or_Body;\n+\n    ----------------------------\n    -- Is_Inherited_Operation --\n    ----------------------------\n@@ -11827,6 +11985,27 @@ package body Sem_Util is\n       end if;\n    end Is_OK_Variable_For_Out_Formal;\n \n+   ------------------------------------\n+   -- Is_Package_Contract_Annotation --\n+   ------------------------------------\n+\n+   function Is_Package_Contract_Annotation (Item : Node_Id) return Boolean is\n+      Nam : Name_Id;\n+\n+   begin\n+      if Nkind (Item) = N_Aspect_Specification then\n+         Nam := Chars (Identifier (Item));\n+\n+      else pragma Assert (Nkind (Item) = N_Pragma);\n+         Nam := Pragma_Name (Item);\n+      end if;\n+\n+      return    Nam = Name_Abstract_State\n+        or else Nam = Name_Initial_Condition\n+        or else Nam = Name_Initializes\n+        or else Nam = Name_Refined_State;\n+   end Is_Package_Contract_Annotation;\n+\n    -----------------------------------\n    -- Is_Partially_Initialized_Type --\n    -----------------------------------\n@@ -12530,6 +12709,39 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n+   ---------------------------------------\n+   -- Is_Subprogram_Contract_Annotation --\n+   ---------------------------------------\n+\n+   function Is_Subprogram_Contract_Annotation\n+     (Item : Node_Id) return Boolean\n+   is\n+      Nam : Name_Id;\n+\n+   begin\n+      if Nkind (Item) = N_Aspect_Specification then\n+         Nam := Chars (Identifier (Item));\n+\n+      else pragma Assert (Nkind (Item) = N_Pragma);\n+         Nam := Pragma_Name (Item);\n+      end if;\n+\n+      return    Nam = Name_Contract_Cases\n+        or else Nam = Name_Depends\n+        or else Nam = Name_Extensions_Visible\n+        or else Nam = Name_Global\n+        or else Nam = Name_Post\n+        or else Nam = Name_Post_Class\n+        or else Nam = Name_Postcondition\n+        or else Nam = Name_Pre\n+        or else Nam = Name_Pre_Class\n+        or else Nam = Name_Precondition\n+        or else Nam = Name_Refined_Depends\n+        or else Nam = Name_Refined_Global\n+        or else Nam = Name_Refined_Post\n+        or else Nam = Name_Test_Case;\n+   end Is_Subprogram_Contract_Annotation;\n+\n    --------------------------------------------------\n    -- Is_Subprogram_Stub_Without_Prior_Declaration --\n    --------------------------------------------------"}, {"sha": "84d04903c72e1468697f322f594d139583cf4779", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -53,7 +53,7 @@ package Sem_Util is\n    --  Add pragma Prag to the contract of an entry, a package [body], a\n    --  subprogram [body] or variable denoted by Id. The following are valid\n    --  pragmas:\n-   --    Abstract_States\n+   --    Abstract_State\n    --    Async_Readers\n    --    Async_Writers\n    --    Contract_Cases\n@@ -421,10 +421,14 @@ package Sem_Util is\n    --  attribute, except in the case of formal private and derived types.\n    --  Possible optimization???\n \n-   function Corresponding_Spec_Of (Subp_Decl : Node_Id) return Entity_Id;\n-   --  Return the corresponding spec of Subp_Decl when it denotes a body [stub]\n-   --  or the defining entity of subprogram declaration Subp_Decl in all other\n-   --  cases.\n+   function Corresponding_Spec_Of (Decl : Node_Id) return Entity_Id;\n+   --  Return the corresponding spec of Decl when it denotes a package or a\n+   --  subprogram [stub], or the defining entity of Decl.\n+\n+   procedure Create_Generic_Contract (Unit : Node_Id);\n+   --  Create a contract node for a generic package, generic subprogram or a\n+   --  generic body denoted by Unit by collecting all source contract-related\n+   --  pragmas in the contract of the unit.\n \n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n@@ -1283,6 +1287,10 @@ package Sem_Util is\n    --  means that the result returned is not crucial, but should err on the\n    --  side of thinking things are fully initialized if it does not know.\n \n+   function Is_Generic_Declaration_Or_Body (Decl : Node_Id) return Boolean;\n+   --  Determine whether arbitrary declaration Decl denotes a generic package,\n+   --  a generic subprogram or a generic body.\n+\n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declaration.\n@@ -1333,6 +1341,14 @@ package Sem_Util is\n    --  the Is_Variable sense) with an untagged type target are considered view\n    --  conversions and hence variables.\n \n+   function Is_Package_Contract_Annotation (Item : Node_Id) return Boolean;\n+   --  Determine whether aspect specification or pragma Item is one of the\n+   --  following package contract annotations:\n+   --    Abstract_State\n+   --    Initial_Condition\n+   --    Initializes\n+   --    Refined_State\n+\n    function Is_Partially_Initialized_Type\n      (Typ              : Entity_Id;\n       Include_Implicit : Boolean := True) return Boolean;\n@@ -1411,6 +1427,24 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n+   function Is_Subprogram_Contract_Annotation (Item : Node_Id) return Boolean;\n+   --  Determine whether aspect specification or pragma Item is one of the\n+   --  following subprogram contract annotations:\n+   --    Contract_Cases\n+   --    Depends\n+   --    Extensions_Visible\n+   --    Global\n+   --    Post\n+   --    Post_Class\n+   --    Postcondition\n+   --    Pre\n+   --    Pre_Class\n+   --    Precondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case\n+\n    function Is_Subprogram_Stub_Without_Prior_Declaration\n      (N : Node_Id) return Boolean;\n    --  Return True if N is a subprogram stub with no prior subprogram"}, {"sha": "136195ee33ab4d60f15be8443d477187763c5432", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1872,6 +1872,14 @@ package body Sinfo is\n       return Flag4 (N);\n    end Is_Folded_In_Parser;\n \n+   function Is_Generic_Contract_Pragma\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag2 (N);\n+   end Is_Generic_Contract_Pragma;\n+\n    function Is_Ignored\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5069,6 +5077,14 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_Is_Folded_In_Parser;\n \n+   procedure Set_Is_Generic_Contract_Pragma\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag2 (N, Val);\n+   end Set_Is_Generic_Contract_Pragma;\n+\n    procedure Set_Is_Ignored\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "5ced3564aa8df43df00e8b9fa608228f264a2d1f", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -1560,17 +1560,17 @@ package Sinfo is\n    --    operand is of the component type of the result. Used in resolving\n    --    concatenation nodes in instances.\n \n+   --  Is_Controlling_Actual (Flag16-Sem)\n+   --    This flag is set on in an expression that is a controlling argument in\n+   --    a dispatching call. It is off in all other cases. See Sem_Disp for\n+   --    details of its use.\n+\n    --  Is_Delayed_Aspect (Flag14-Sem)\n    --    Present in N_Pragma and N_Attribute_Definition_Clause nodes which\n    --    come from aspect specifications, where the evaluation of the aspect\n    --    must be delayed to the freeze point. This flag is also set True in\n    --    the corresponding N_Aspect_Specification node.\n \n-   --  Is_Controlling_Actual (Flag16-Sem)\n-   --    This flag is set on in an expression that is a controlling argument in\n-   --    a dispatching call. It is off in all other cases. See Sem_Disp for\n-   --    details of its use.\n-\n    --  Is_Disabled (Flag15-Sem)\n    --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n    --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n@@ -1601,6 +1601,29 @@ package Sinfo is\n    --    objects. The wrapper prevents interference between exception handlers\n    --    and At_End handlers.\n \n+   --  Is_Generic_Contract_Pragma (Flag2-Sem)\n+   --    This flag is present in N_Pragma nodes. It is set when the pragma is\n+   --    a source construct, applies to a generic unit or its body and denotes\n+   --    one of the following contract-related annotations:\n+   --      Abstract_State\n+   --      Contract_Cases\n+   --      Depends\n+   --      Extensions_Visible\n+   --      Global\n+   --      Initial_Condition\n+   --      Initializes\n+   --      Post\n+   --      Post_Class\n+   --      Postcondition\n+   --      Pre\n+   --      Pre_Class\n+   --      Precondition\n+   --      Refined_Depends\n+   --      Refined_Global\n+   --      Refined_Post\n+   --      Refined_State\n+   --      Test_Case\n+\n    --  Is_Ignored (Flag9-Sem)\n    --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n    --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n@@ -2441,6 +2464,7 @@ package Sinfo is\n       --  Is_Checked (Flag11-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n+      --  Is_Generic_Contract_Pragma (Flag2-Sem)\n       --  Is_Ignored (Flag9-Sem)\n       --  Is_Inherited (Flag4-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n@@ -7518,9 +7542,9 @@ package Sinfo is\n \n       --  N_Contract\n       --  Sloc points to the subprogram's name\n-      --  Pre_Post_Conditions (Node1) (set to Empty if none)\n-      --  Contract_Test_Cases (Node2) (set to Empty if none)\n-      --  Classifications (Node3) (set to Empty if none)\n+      --  Pre_Post_Conditions (Node1-Sem) (set to Empty if none)\n+      --  Contract_Test_Cases (Node2-Sem) (set to Empty if none)\n+      --  Classifications (Node3-Sem) (set to Empty if none)\n \n       --  Pre_Post_Conditions contains a collection of pragmas that correspond\n       --  to pre- and postconditions associated with an entry or a subprogram\n@@ -8696,7 +8720,7 @@ package Sinfo is\n \n    subtype N_Unit_Body is Node_Kind range\n      N_Package_Body ..\n-       N_Subprogram_Body;\n+     N_Subprogram_Body;\n \n    ---------------------------\n    -- Node Access Functions --\n@@ -9285,6 +9309,9 @@ package Sinfo is\n    function Is_Folded_In_Parser\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function Is_Generic_Contract_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag2\n+\n    function Is_Ignored\n      (N : Node_Id) return Boolean;    -- Flag9\n \n@@ -10287,9 +10314,6 @@ package Sinfo is\n    procedure Set_Is_Disabled\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n-   procedure Set_Is_Ignored\n-     (N : Node_Id; Val : Boolean := True);    -- Flag9\n-\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -10308,6 +10332,12 @@ package Sinfo is\n    procedure Set_Is_Folded_In_Parser\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_Is_Generic_Contract_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag2\n+\n+   procedure Set_Is_Ignored\n+     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+\n    procedure Set_Is_In_Discriminant_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n@@ -10913,7 +10943,7 @@ package Sinfo is\n      N_Pragma =>\n        (1 => False,   --  Next_Pragma (Node1-Sem)\n         2 => True,    --  Pragma_Argument_Associations (List2)\n-        3 => False,   --  unused\n+        3 => False,   --  Corresponding_Aspect (Node3-Sem)\n         4 => True,    --  Pragma_Identifier (Node4)\n         5 => False),  --  Next_Rep_Item (Node5-Sem)\n \n@@ -12297,9 +12327,9 @@ package Sinfo is\n         5 => False),  --  unused\n \n      N_Contract =>\n-       (1 => False,   --  Pre_Post_Conditions (Node1)\n-        2 => False,   --  Contract_Test_Cases (Node2)\n-        3 => False,   --  Classifications (Node3)\n+       (1 => False,   --  Pre_Post_Conditions (Node1-Sem)\n+        2 => False,   --  Contract_Test_Cases (Node2-Sem)\n+        3 => False,   --  Classifications (Node3-Sem)\n         4 => False,   --  unused\n         5 => False),  --  unused\n \n@@ -12695,6 +12725,7 @@ package Sinfo is\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Is_Finalization_Wrapper);\n    pragma Inline (Is_Folded_In_Parser);\n+   pragma Inline (Is_Generic_Contract_Pragma);\n    pragma Inline (Is_Ignored);\n    pragma Inline (Is_In_Discriminant_Check);\n    pragma Inline (Is_Inherited);\n@@ -13030,6 +13061,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Set_Is_Finalization_Wrapper);\n    pragma Inline (Set_Is_Folded_In_Parser);\n+   pragma Inline (Set_Is_Generic_Contract_Pragma);\n    pragma Inline (Set_Is_Ignored);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n    pragma Inline (Set_Is_Inherited);"}, {"sha": "103038a2bc90abae31f0754ecbbe1c434c711415", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf07df9db933fc7c97c41060dfa940fa78bb345/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=caf07df9db933fc7c97c41060dfa940fa78bb345", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -731,6 +731,54 @@ package body Treepr is\n          Print_Eol;\n       end if;\n \n+      if Field_Present (Field36 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field36_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field36 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field37 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field37_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field37 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field38 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field38_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field38 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field39 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field39_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field39 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field40 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field40_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field40 (Ent));\n+         Print_Eol;\n+      end if;\n+\n+      if Field_Present (Field41 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field41_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field41 (Ent));\n+         Print_Eol;\n+      end if;\n+\n       Write_Entity_Flags (Ent, Prefix);\n    end Print_Entity_Info;\n "}]}