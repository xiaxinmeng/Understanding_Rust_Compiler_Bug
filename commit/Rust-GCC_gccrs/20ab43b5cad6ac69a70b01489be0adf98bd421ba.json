{"sha": "20ab43b5cad6ac69a70b01489be0adf98bd421ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhYjQzYjVjYWQ2YWM2OWE3MGIwMTQ4OWJlMGFkZjk4YmQ0MjFiYQ==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:26Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:26Z"}, "message": "RTL: Add `const_double_zero' syntactic rtx\n\nThe use of a constant double zero is required for post-reload compare\nelimination to be able to discard redundant floating-point comparisons,\nfor example with a VAX RTL instruction stream like:\n\n(insn 34 4 3 2 (parallel [\n            (set (reg/v:DF 0 %r0 [orig:24 x ] [24])\n                (mem/c:DF (plus:SI (reg/f:SI 12 %ap)\n                        (const_int 4 [0x4])) [1 x+0 S8 A32]))\n            (clobber (reg:CC 16 %psl))\n        ]) \".../gcc/testsuite/gcc.target/vax/cmpelim-eq-movdf.c\":9:1 37 {*movdf}\n     (nil))\n(note 3 34 35 2 NOTE_INSN_FUNCTION_BEG)\n(insn 35 3 36 2 (set (reg:CCZ 16 %psl)\n        (compare:CCZ (reg/v:DF 0 %r0 [orig:24 x ] [24])\n            (const_double:DF 0.0 [0x0.0p+0]))) \".../gcc/testsuite/gcc.target/vax/cmpelim-eq-movdf.c\":10:6 21 {*cmpdf_ccz}\n     (nil))\n(jump_insn 36 35 9 2 (set (pc)\n        (if_then_else (eq (reg:CCZ 16 %psl)\n                (const_int 0 [0]))\n            (label_ref 11)\n            (pc))) \".../gcc/testsuite/gcc.target/vax/cmpelim-eq-movdf.c\":10:6 537 {*branch_ccz}\n     (int_list:REG_BR_PROB 536870916 (nil))\n -> 11)\n\nthat we want to transform into:\n\n(insn 34 4 3 2 (parallel [\n            (set (reg:CCZ 16 %psl)\n                (compare:CCZ (mem/c:DF (plus:SI (reg/f:SI 12 %ap)\n                            (const_int 4 [0x4])) [1 x+0 S8 A32])\n                    (const_double:DF 0.0 [0x0.0p+0])))\n            (set (reg/v:DF 0 %r0 [orig:24 x ] [24])\n                (mem/c:DF (plus:SI (reg/f:SI 12 %ap)\n                        (const_int 4 [0x4])) [1 x+0 S8 A32]))\n        ]) \".../gcc/testsuite/gcc.target/vax/cmpelim-eq-movdf.c\":9:1 40 {*movdf_ccz}\n     (nil))\n(note 3 34 36 2 NOTE_INSN_FUNCTION_BEG)\n(jump_insn 36 3 9 2 (set (pc)\n        (if_then_else (eq (reg:CCZ 16 %psl)\n                (const_int 0 [0]))\n            (label_ref 11)\n            (pc))) \".../gcc/testsuite/gcc.target/vax/cmpelim-eq-movdf.c\":10:6 537 {*branch_ccz}\n     (int_list:REG_BR_PROB 536870916 (nil))\n -> 11)\n\nwith the upcoming MODE_CC representation.\n\nFor this we need to express the `const_double:DF 0.0 [0x0.0p+0]' rtx as\nrecorded above in the relevant pattern(s) in machine description.  The\nway we represent double constants, as a host-dependent number of wide\nintegers, however means that we currently have no portable way to encode\na double zero constant in machine description.\n\nDefine a syntactic rtx alias then to represent `(const_double 0 0 ...)'\nas if the suitable number of zeros have been supplied according to the\nhost-specific definition of CONST_DOUBLE_FORMAT.\n\n\tgcc/\n\t* read-rtl.c (rtx_reader::read_rtx_code): Handle syntactic\n\t`const_double_zero' rtx.\n\t* doc/rtl.texi (Constant Expression Types): Document it.", "tree": {"sha": "c1f04a774da1e532df4270fcb3c8e6fa9a8273eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1f04a774da1e532df4270fcb3c8e6fa9a8273eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20ab43b5cad6ac69a70b01489be0adf98bd421ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20ab43b5cad6ac69a70b01489be0adf98bd421ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20ab43b5cad6ac69a70b01489be0adf98bd421ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20ab43b5cad6ac69a70b01489be0adf98bd421ba/comments", "author": null, "committer": null, "parents": [{"sha": "1be9edfa826f2c7c7a999ff02defab97d468d277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be9edfa826f2c7c7a999ff02defab97d468d277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be9edfa826f2c7c7a999ff02defab97d468d277"}], "stats": {"total": 28, "additions": 28, "deletions": 0}, "files": [{"sha": "7c12991e54dfaf3b70ab5790a1af42ca40d3d1e6", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20ab43b5cad6ac69a70b01489be0adf98bd421ba/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20ab43b5cad6ac69a70b01489be0adf98bd421ba/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=20ab43b5cad6ac69a70b01489be0adf98bd421ba", "patch": "@@ -1711,6 +1711,24 @@ machine's or host machine's floating point format.  To convert them to\n the precise bit pattern used by the target machine, use the macro\n @code{REAL_VALUE_TO_TARGET_DOUBLE} and friends (@pxref{Data Output}).\n \n+@findex const_double_zero\n+The host dependency for the number of integers used to store a double\n+value makes it problematic for machine descriptions to use expressions\n+of code @code{const_double} and therefore a syntactic alias has been\n+provided:\n+\n+@smallexample\n+(const_double_zero)\n+@end smallexample\n+\n+standing for:\n+\n+@smallexample\n+(const_double 0 0 @dots{})\n+@end smallexample\n+\n+for matching the floating-point value zero, possibly the only useful one.\n+\n @findex CONST_WIDE_INT\n @item (const_wide_int:@var{m} @var{nunits} @var{elt0} @dots{})\n This contains an array of @code{HOST_WIDE_INT}s that is large enough"}, {"sha": "2922af5d111842e232f9ca9216ef77ceaf1c465a", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20ab43b5cad6ac69a70b01489be0adf98bd421ba/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20ab43b5cad6ac69a70b01489be0adf98bd421ba/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=20ab43b5cad6ac69a70b01489be0adf98bd421ba", "patch": "@@ -1651,6 +1651,16 @@ rtx_reader::read_rtx_code (const char *code_name)\n       return return_rtx;\n     }\n \n+  /* Handle \"const_double_zero\".  */\n+  if (strcmp (code_name, \"const_double_zero\") == 0)\n+    {\n+      code = CONST_DOUBLE;\n+      return_rtx = rtx_alloc (code);\n+      memset (return_rtx, 0, RTX_CODE_SIZE (code));\n+      PUT_CODE (return_rtx, code);\n+      return return_rtx;\n+    }\n+\n   /* If we end up with an insn expression then we free this space below.  */\n   return_rtx = rtx_alloc_for_name (code_name);\n   code = GET_CODE (return_rtx);"}]}