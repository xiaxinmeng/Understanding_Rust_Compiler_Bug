{"sha": "eaf618e3a990a27563ffd46f9042c826485a34e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmNjE4ZTNhOTkwYTI3NTYzZmZkNDZmOTA0MmM4MjY0ODVhMzRlNg==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-02-25T10:32:19Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-02-25T10:32:19Z"}, "message": "re PR fortran/23092 ([4.1 only] scalar mask for minval/maxval/sum/product)\n\n2006-02-25  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/23092\n\t* trans-intrinsic.c (gfc_conv_intrinsic_arith):  If the\n\tmask expression exists and has rank 0, enclose the generated\n\tloop in an \"if (mask)\".\n\t* (gfc_conv_intrinsic_minmaxloc):  Likewise.\n\n2006-02-25  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/23092\n\t* scalar_mask_1.f90:  New test.\n\nFrom-SVN: r111438", "tree": {"sha": "48fbd3a405f48a2c5a5b42dfd111d2cc2c0b1002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48fbd3a405f48a2c5a5b42dfd111d2cc2c0b1002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaf618e3a990a27563ffd46f9042c826485a34e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf618e3a990a27563ffd46f9042c826485a34e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf618e3a990a27563ffd46f9042c826485a34e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf618e3a990a27563ffd46f9042c826485a34e6/comments", "author": null, "committer": null, "parents": [{"sha": "a4876725625720be4440e612ef1acdfdfc4f9ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4876725625720be4440e612ef1acdfdfc4f9ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4876725625720be4440e612ef1acdfdfc4f9ac8"}], "stats": {"total": 75, "additions": 69, "deletions": 6}, "files": [{"sha": "b1172ba3fc9dbca127c9f7cd8a44080560d183f1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eaf618e3a990a27563ffd46f9042c826485a34e6", "patch": "@@ -1,3 +1,11 @@\n+2006-02-25  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/23092\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_arith):  If the\n+\tmask expression exists and has rank 0, enclose the generated\n+\tloop in an \"if (mask)\".\n+\t* (gfc_conv_intrinsic_minmaxloc):  Likewise.\n+\n 2006-02-24  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26409"}, {"sha": "21477b126d40623f1b230103098bfc2d85a79d73", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=eaf618e3a990a27563ffd46f9042c826485a34e6", "patch": "@@ -1474,7 +1474,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   actual = actual->next->next;\n   gcc_assert (actual);\n   maskexpr = actual->expr;\n-  if (maskexpr)\n+  if (maskexpr && maskexpr->rank != 0)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n       gcc_assert (maskss != gfc_ss_terminator);\n@@ -1535,8 +1535,27 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_expr_to_block (&body, tmp);\n \n   gfc_trans_scalarizing_loops (&loop, &body);\n-  gfc_add_block_to_block (&se->pre, &loop.pre);\n-  gfc_add_block_to_block (&se->pre, &loop.post);\n+\n+  /* For a scalar mask, enclose the loop in an if statement.  */\n+  if (maskexpr && maskss == NULL)\n+    {\n+      gfc_init_se (&maskse, NULL);\n+      gfc_conv_expr_val (&maskse, maskexpr);\n+      gfc_init_block (&block);\n+      gfc_add_block_to_block (&block, &loop.pre);\n+      gfc_add_block_to_block (&block, &loop.post);\n+      tmp = gfc_finish_block (&block);\n+\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&se->pre, &block);\n+    }\n+  else\n+    {\n+      gfc_add_block_to_block (&se->pre, &loop.pre);\n+      gfc_add_block_to_block (&se->pre, &loop.post);\n+    }\n+\n   gfc_cleanup_loop (&loop);\n \n   se->expr = resvar;\n@@ -1762,7 +1781,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   actual = actual->next->next;\n   gcc_assert (actual);\n   maskexpr = actual->expr;\n-  if (maskexpr)\n+  if (maskexpr && maskexpr->rank != 0)\n     {\n       maskss = gfc_walk_expr (maskexpr);\n       gcc_assert (maskss != gfc_ss_terminator);\n@@ -1824,8 +1843,26 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n \n   gfc_trans_scalarizing_loops (&loop, &body);\n \n-  gfc_add_block_to_block (&se->pre, &loop.pre);\n-  gfc_add_block_to_block (&se->pre, &loop.post);\n+  /* For a scalar mask, enclose the loop in an if statement.  */\n+  if (maskexpr && maskss == NULL)\n+    {\n+      gfc_init_se (&maskse, NULL);\n+      gfc_conv_expr_val (&maskse, maskexpr);\n+      gfc_init_block (&block);\n+      gfc_add_block_to_block (&block, &loop.pre);\n+      gfc_add_block_to_block (&block, &loop.post);\n+      tmp = gfc_finish_block (&block);\n+\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&se->pre, &block);\n+    }\n+  else\n+    {\n+      gfc_add_block_to_block (&se->pre, &loop.pre);\n+      gfc_add_block_to_block (&se->pre, &loop.post);\n+    }\n+\n   gfc_cleanup_loop (&loop);\n \n   se->expr = limit;"}, {"sha": "387e690134b26206b72b47e44d6ff43efc3fdae7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eaf618e3a990a27563ffd46f9042c826485a34e6", "patch": "@@ -1,3 +1,8 @@\n+2006-02-25  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/23092\n+\t* scalar_mask_1.f90:  New test.\n+\n 2006-02-24  Geoffrey Keating  <geoffk@apple.com>\n \n \t* g++.dg/eh/uncaught1.C: Add dg-options for ppc-darwin."}, {"sha": "4f2a877f3d53f1fe0d7e80e8db3b9a08c277eebb", "filename": "gcc/testsuite/gfortran.dg/scalar_mask_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf618e3a990a27563ffd46f9042c826485a34e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_1.f90?ref=eaf618e3a990a27563ffd46f9042c826485a34e6", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  real, dimension(2) :: a\n+  a(1) = 2.0\n+  a(2) = 3.0\n+  if (product (a, .false.) /= 1.0) call abort\n+  if (product (a, .true.) /= 6.0) call abort\n+  if (sum (a, .false.) /= 0.0) call abort\n+  if (sum (a, .true.) /= 5.0) call abort\n+  if (maxval (a, .true.) /= 3.0) call abort\n+  if (maxval (a, .false.) > -1e38) call abort\n+end program main"}]}