{"sha": "017e0eb94d164300f87adc5759eeffea42d02300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3ZTBlYjk0ZDE2NDMwMGY4N2FkYzU3NTllZWZmZWE0MmQwMjMwMA==", "commit": {"author": {"name": "Mark Dettinger", "email": "dettinge@de.ibm.com", "date": "2004-11-30T15:14:05Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-11-30T15:14:05Z"}, "message": "s390.c (struct processor_costs): New data type.\n\n2004-11-30  Mark Dettinger  <dettinge@de.ibm.com>\n\n\t* config/s390/s390.c (struct processor_costs): New data type.\n\t(s390_cost, z900_cost, z990_cost): New global variables.\n\t(override_options): Initialize s390_cost.\n\t(s390_rtx_costs): Reimplement.\n\nFrom-SVN: r91527", "tree": {"sha": "f237010b241f7afe9762a07901357b5f68b8e8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f237010b241f7afe9762a07901357b5f68b8e8f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/017e0eb94d164300f87adc5759eeffea42d02300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017e0eb94d164300f87adc5759eeffea42d02300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017e0eb94d164300f87adc5759eeffea42d02300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017e0eb94d164300f87adc5759eeffea42d02300/comments", "author": null, "committer": null, "parents": [{"sha": "472c29c36418690550ac46005b58ff474d757e1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c29c36418690550ac46005b58ff474d757e1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472c29c36418690550ac46005b58ff474d757e1f"}], "stats": {"total": 162, "additions": 132, "deletions": 30}, "files": [{"sha": "c3983bcb2915002911011374b16182f549c29c73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017e0eb94d164300f87adc5759eeffea42d02300/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017e0eb94d164300f87adc5759eeffea42d02300/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=017e0eb94d164300f87adc5759eeffea42d02300", "patch": "@@ -1,3 +1,10 @@\n+2004-11-30  Mark Dettinger  <dettinge@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct processor_costs): New data type.\n+\t(s390_cost, z900_cost, z990_cost): New global variables.\n+\t(override_options): Initialize s390_cost.\n+\t(s390_rtx_costs): Reimplement.\n+\n 2004-11-29  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/18673"}, {"sha": "cf0a01156c198247ee4114644dee535a28c6316d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 125, "deletions": 30, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017e0eb94d164300f87adc5759eeffea42d02300/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017e0eb94d164300f87adc5759eeffea42d02300/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=017e0eb94d164300f87adc5759eeffea42d02300", "patch": "@@ -86,6 +86,61 @@ static enum machine_mode s390_cc_modes_compatible (enum machine_mode,\n  \t\t\t\t\t\t   enum machine_mode);\n \n \n+/* Define the specific costs for a given cpu.  */\n+\n+struct processor_costs \n+{\n+  const int m;        /* cost of an M instruction.  */\n+  const int mghi;     /* cost of an MGHI instruction.  */\n+  const int mh;       /* cost of an MH instruction.  */\n+  const int mhi;      /* cost of an MHI instruction.  */\n+  const int mr;       /* cost of an MR instruction.  */\n+  const int ms;       /* cost of an MS instruction.  */\n+  const int msg;      /* cost of an MSG instruction.  */\n+  const int msgf;     /* cost of an MSGF instruction.  */\n+  const int msgfr;    /* cost of an MSGFR instruction.  */\n+  const int msgr;     /* cost of an MSGR instruction.  */\n+  const int msr;      /* cost of an MSR instruction.  */\n+  const int mult_df;  /* cost of multiplication in DFmode.  */\n+};\n+\n+const struct processor_costs *s390_cost;\n+\n+static const\n+struct processor_costs z900_cost = \n+{\n+  COSTS_N_INSNS (5),     /* M     */\n+  COSTS_N_INSNS (10),    /* MGHI  */\n+  COSTS_N_INSNS (5),     /* MH    */\n+  COSTS_N_INSNS (4),     /* MHI   */\n+  COSTS_N_INSNS (5),     /* MR    */\n+  COSTS_N_INSNS (4),     /* MS    */\n+  COSTS_N_INSNS (15),    /* MSG   */\n+  COSTS_N_INSNS (7),     /* MSGF  */\n+  COSTS_N_INSNS (7),     /* MSGFR */\n+  COSTS_N_INSNS (10),    /* MSGR  */\n+  COSTS_N_INSNS (4),     /* MSR   */\n+  COSTS_N_INSNS (7),     /* multiplication in DFmode */\n+};\n+\n+static const\n+struct processor_costs z990_cost = \n+{\n+  COSTS_N_INSNS (4),     /* M     */\n+  COSTS_N_INSNS (2),     /* MGHI  */\n+  COSTS_N_INSNS (2),     /* MH    */\n+  COSTS_N_INSNS (2),     /* MHI   */\n+  COSTS_N_INSNS (4),     /* MR    */\n+  COSTS_N_INSNS (5),     /* MS    */\n+  COSTS_N_INSNS (6),     /* MSG   */\n+  COSTS_N_INSNS (4),     /* MSGF  */\n+  COSTS_N_INSNS (4),     /* MSGFR */\n+  COSTS_N_INSNS (4),     /* MSGR  */\n+  COSTS_N_INSNS (4),     /* MSR   */\n+  COSTS_N_INSNS (1),     /* multiplication in DFmode */\n+};\n+\n+\n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n #undef  TARGET_ASM_ALIGNED_DI_OP\n@@ -1318,6 +1373,14 @@ override_options (void)\n   if (TARGET_64BIT && !TARGET_ZARCH)\n     error (\"64-bit ABI not supported in ESA/390 mode.\");\n \n+\n+  /* Set processor cost function.  */\n+  if (s390_tune == PROCESSOR_2084_Z990) \n+    s390_cost = &z990_cost;\n+  else\n+    s390_cost = &z900_cost;\n+\n+\n   if (s390_warn_framesize_string)\n     {\n       if (sscanf (s390_warn_framesize_string, HOST_WIDE_INT_PRINT_DEC,\n@@ -1782,36 +1845,17 @@ s390_const_ok_for_constraint_p (HOST_WIDE_INT value,\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n-   scanned.  In either case, *TOTAL contains the cost result.  */\n+   scanned.  In either case, *TOTAL contains the cost result.  \n+   CODE contains GET_CODE (x), OUTER_CODE contains the code \n+   of the superexpression of x.  */\n \n static bool\n s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n     case CONST:\n-      if (GET_CODE (XEXP (x, 0)) == MINUS\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) != CONST_INT)\n-\t*total = 1000;\n-      else\n-\t*total = 0;\n-      return true;\n-\n     case CONST_INT:\n-      /* Force_const_mem does not work out of reload, because the\n-\t saveable_obstack is set to reload_obstack, which does not\n-\t live long enough.  Because of this we cannot use force_const_mem\n-\t in addsi3.  This leads to problems with gen_add2_insn with a\n-\t constant greater than a short. Because of that we give an\n-\t addition of greater constants a cost of 3 (reload1.c 10096).  */\n-      /* ??? saveable_obstack no longer exists.  */\n-      if (outer_code == PLUS\n-\t  && (INTVAL (x) > 32767 || INTVAL (x) < -32768))\n-\t*total = COSTS_N_INSNS (3);\n-      else\n-\t*total = 0;\n-      return true;\n-\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST_DOUBLE:\n@@ -1821,6 +1865,8 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n+    case ROTATE:\n+    case ROTATERT:\n     case PLUS:\n     case AND:\n     case IOR:\n@@ -1829,21 +1875,70 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case NEG:\n     case NOT:\n       *total = COSTS_N_INSNS (1);\n-      return true;\n+      return false;\n \n-    case MULT:\n-      if (GET_MODE (XEXP (x, 0)) == DImode)\n-        *total = COSTS_N_INSNS (40);\n-      else\n-        *total = COSTS_N_INSNS (7);\n-      return true;\n+    case MULT:      \n+      switch (GET_MODE (x))\n+\t{\n+\tcase SImode:\n+\t  {\t  \n+\t    rtx left = XEXP (x, 0);\n+\t    rtx right = XEXP (x, 1);\n+\t    if (GET_CODE (right) == CONST_INT\n+\t\t&& CONST_OK_FOR_CONSTRAINT_P (INTVAL (right), 'K', \"K\"))\n+\t      *total = s390_cost->mhi;\n+\t    else if (GET_CODE (left) == SIGN_EXTEND)\n+\t      *total = s390_cost->mh;\n+\t    else\n+\t      *total = s390_cost->ms;  /* msr, ms, msy */\n+\t    break;\n+\t  }\n+\tcase DImode:\n+\t  {\n+\t    rtx left = XEXP (x, 0);\n+\t    rtx right = XEXP (x, 1);\n+\t    if (TARGET_64BIT)\n+\t      {\n+\t\tif (GET_CODE (right) == CONST_INT\n+\t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (right), 'K', \"K\"))\n+\t\t  *total = s390_cost->mghi;\n+\t\telse if (GET_CODE (left) == SIGN_EXTEND)\n+\t\t  *total = s390_cost->msgf;\n+\t\telse\n+\t\t  *total = s390_cost->msg;  /* msgr, msg */\n+\t      }\n+\t    else /* TARGET_31BIT */\n+\t      {\n+\t\tif (GET_CODE (left) == SIGN_EXTEND\n+\t\t    && GET_CODE (right) == SIGN_EXTEND)\n+\t\t  /* mulsidi case: mr, m */\n+\t\t  *total = s390_cost->m;\n+\t\telse\n+\t\t  /* Complex calculation is required.  */\n+\t\t  *total = COSTS_N_INSNS (40);\n+\t      }\n+\t    break;\n+\t  }\n+\tcase SFmode:\n+\tcase DFmode:\n+\t  *total = s390_cost->mult_df;\n+\t  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      return false;\n \n     case DIV:\n     case UDIV:\n     case MOD:\n     case UMOD:\n       *total = COSTS_N_INSNS (33);\n-      return true;\n+      return false;\n+\n+    case SIGN_EXTEND:\n+      if (outer_code == MULT)\n+\t*total = 0;\n+      return false;\n \n     default:\n       return false;"}]}