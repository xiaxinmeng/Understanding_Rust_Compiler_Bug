{"sha": "f46939f9d4091e78e60d8d4d78d023a48a1608aa", "node_id": "C_kwDOANBUbNoAKGY0NjkzOWY5ZDQwOTFlNzhlNjBkOGQ0ZDc4ZDAyM2E0OGExNjA4YWE", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-09-02T21:29:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-05T08:20:00Z"}, "message": "[Ada] Proof of Ada.Strings.Maps\n\ngcc/ada/\n\n\t* libgnat/a-strmap.adb: Add ghost code for proof.\n\t(To_Range): This is the most involved proof, as it requires\n\tcreating the result of the call to To_Domain as a ghost\n\tvariable, and show the unicity of this result in order to prove\n\tthe postcondition.\n\t* libgnat/a-strmap.ads: (SPARK_Proof_Sorted_Character_Sequence):\n\tNew ghost function.\n\t(To_Domain): Add postcondition regarding sorting of result.\n\t(To_Range): Fix postcondition that should compare Length instead\n\tof Last for the results of To_Domain and To_Range, as the value\n\tof Last for an empty result is not specified in the Ada RM.", "tree": {"sha": "4ab552062771cc195fa37fd26bddb90b9f1cf18d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab552062771cc195fa37fd26bddb90b9f1cf18d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f46939f9d4091e78e60d8d4d78d023a48a1608aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46939f9d4091e78e60d8d4d78d023a48a1608aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46939f9d4091e78e60d8d4d78d023a48a1608aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46939f9d4091e78e60d8d4d78d023a48a1608aa/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec8ccc712cc15124090dab1ae44dccee280ce4ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ccc712cc15124090dab1ae44dccee280ce4ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8ccc712cc15124090dab1ae44dccee280ce4ad"}], "stats": {"total": 433, "additions": 395, "deletions": 38}, "files": [{"sha": "c87f4e52d7442fd81356ac0505bb8866902b3aa7", "filename": "gcc/ada/libgnat/a-strmap.adb", "status": "modified", "additions": 309, "deletions": 28, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46939f9d4091e78e60d8d4d78d023a48a1608aa/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46939f9d4091e78e60d8d4d78d023a48a1608aa/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strmap.adb?ref=f46939f9d4091e78e60d8d4d78d023a48a1608aa", "patch": "@@ -35,7 +35,17 @@\n --  is bit-by-bit or character-by-character and therefore rather slow.\n --  Generally for character sets we favor the full 32-byte representation.\n \n-package body Ada.Strings.Maps is\n+--  Assertions, ghost code and loop invariants in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Assert         => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore);\n+\n+package body Ada.Strings.Maps\n+  with SPARK_Mode\n+is\n \n    ---------\n    -- \"-\" --\n@@ -102,9 +112,7 @@ package body Ada.Strings.Maps is\n      (Element : Character;\n       Set     : Character_Set) return Boolean\n    is\n-   begin\n-      return Set (Element);\n-   end Is_In;\n+      (Set (Element));\n \n    ---------------\n    -- Is_Subset --\n@@ -122,18 +130,37 @@ package body Ada.Strings.Maps is\n    -- To_Domain --\n    ---------------\n \n-   function To_Domain (Map : Character_Mapping) return Character_Sequence\n-   is\n-      Result : String (1 .. Map'Length);\n+   function To_Domain (Map : Character_Mapping) return Character_Sequence is\n+      Result : String (1 .. Map'Length) with Relaxed_Initialization;\n       J      : Natural;\n \n+      type Character_Index is array (Character) of Natural with Ghost;\n+      Indexes : Character_Index := (others => 0) with Ghost;\n+\n    begin\n       J := 0;\n       for C in Map'Range loop\n          if Map (C) /= C then\n             J := J + 1;\n             Result (J) := C;\n+            Indexes (C) := J;\n          end if;\n+\n+         pragma Loop_Invariant (if Map = Identity then J = 0);\n+         pragma Loop_Invariant (J <= Character'Pos (C) + 1);\n+         pragma Loop_Invariant (Result (1 .. J)'Initialized);\n+         pragma Loop_Invariant (for all K in 1 .. J => Result (K) <= C);\n+         pragma Loop_Invariant\n+           (SPARK_Proof_Sorted_Character_Sequence (Result (1 .. J)));\n+         pragma Loop_Invariant\n+           (for all D in Map'First .. C =>\n+              (if Map (D) = D then\n+                 Indexes (D) = 0\n+               else\n+                 Indexes (D) in 1 .. J\n+                   and then Result (Indexes (D)) = D));\n+         pragma Loop_Invariant\n+           (for all Char of Result (1 .. J) => Map (Char) /= Char);\n       end loop;\n \n       return Result (1 .. J);\n@@ -146,7 +173,7 @@ package body Ada.Strings.Maps is\n    function To_Mapping\n      (From, To : Character_Sequence) return Character_Mapping\n    is\n-      Result   : Character_Mapping;\n+      Result   : Character_Mapping with Relaxed_Initialization;\n       Inserted : Character_Set := Null_Set;\n       From_Len : constant Natural := From'Length;\n       To_Len   : constant Natural := To'Length;\n@@ -158,6 +185,9 @@ package body Ada.Strings.Maps is\n \n       for Char in Character loop\n          Result (Char) := Char;\n+         pragma Loop_Invariant (Result (Result'First .. Char)'Initialized);\n+         pragma Loop_Invariant\n+           (for all C in Result'First .. Char => Result (C) = C);\n       end loop;\n \n       for J in From'Range loop\n@@ -167,6 +197,23 @@ package body Ada.Strings.Maps is\n \n          Result   (From (J)) := To (J - From'First + To'First);\n          Inserted (From (J)) := True;\n+\n+         pragma Loop_Invariant (Result'Initialized);\n+         pragma Loop_Invariant\n+           (for all K in From'First .. J =>\n+              Result (From (K)) = To (K - From'First + To'First)\n+                and then Inserted (From (K)));\n+         pragma Loop_Invariant\n+           (for all Char in Character =>\n+              (Inserted (Char) =\n+                 (for some K in From'First .. J => Char = From (K))));\n+         pragma Loop_Invariant\n+           (for all Char in Character =>\n+              (if not Inserted (Char) then Result (Char) = Char));\n+         pragma Loop_Invariant\n+           (if (for all K in From'First .. J =>\n+                  From (K) = To (J - From'First + To'First))\n+            then Result = Identity);\n       end loop;\n \n       return Result;\n@@ -176,19 +223,195 @@ package body Ada.Strings.Maps is\n    -- To_Range --\n    --------------\n \n-   function To_Range (Map : Character_Mapping) return Character_Sequence\n-   is\n-      Result : String (1 .. Map'Length);\n+   function To_Range (Map : Character_Mapping) return Character_Sequence is\n+\n+      --  Extract from the postcondition of To_Domain the essential properties\n+      --  that define Seq as the domain of Map.\n+      function Is_Domain\n+        (Map : Character_Mapping;\n+         Seq : Character_Sequence)\n+         return Boolean\n+      is\n+        (Seq'First = 1\n+           and then\n+         SPARK_Proof_Sorted_Character_Sequence (Seq)\n+           and then\n+         (for all Char in Character =>\n+            (if (for all X of Seq => X /= Char)\n+             then Map (Char) = Char))\n+           and then\n+         (for all Char of Seq => Map (Char) /= Char))\n+      with\n+        Ghost;\n+\n+      --  Given Map, there is a unique sequence Seq for which\n+      --  Is_Domain(Map,Seq) holds.\n+      procedure Lemma_Domain_Unicity\n+        (Map        : Character_Mapping;\n+         Seq1, Seq2 : Character_Sequence)\n+      with\n+        Ghost,\n+        Pre  => Is_Domain (Map, Seq1)\n+          and then Is_Domain (Map, Seq2),\n+        Post => Seq1 = Seq2;\n+\n+      --  Isolate the proof that To_Domain(Map) returns a sequence for which\n+      --  Is_Domain holds.\n+      procedure Lemma_Is_Domain (Map : Character_Mapping)\n+      with\n+        Ghost,\n+        Post => Is_Domain (Map, To_Domain (Map));\n+\n+      --  Deduce the alternative expression of sortedness from the one in\n+      --  SPARK_Proof_Sorted_Character_Sequence which compares consecutive\n+      --  elements.\n+      procedure Lemma_Is_Sorted (Seq : Character_Sequence)\n+      with\n+        Ghost,\n+        Pre  => SPARK_Proof_Sorted_Character_Sequence (Seq),\n+        Post => (for all J in Seq'Range =>\n+                   (for all K in Seq'Range =>\n+                      (if J < K then Seq (J) < Seq (K))));\n+\n+      --------------------------\n+      -- Lemma_Domain_Unicity --\n+      --------------------------\n+\n+      procedure Lemma_Domain_Unicity\n+        (Map        : Character_Mapping;\n+         Seq1, Seq2 : Character_Sequence)\n+      is\n+         J : Positive := 1;\n+\n+      begin\n+         while J <= Seq1'Last\n+           and then J <= Seq2'Last\n+           and then Seq1 (J) = Seq2 (J)\n+         loop\n+            pragma Loop_Invariant\n+              (Seq1 (Seq1'First .. J) = Seq2 (Seq2'First .. J));\n+\n+            if J = Positive'Last then\n+               return;\n+            end if;\n+\n+            J := J + 1;\n+         end loop;\n+\n+         Lemma_Is_Sorted (Seq1);\n+         Lemma_Is_Sorted (Seq2);\n+\n+         if J <= Seq1'Last\n+           and then J <= Seq2'Last\n+         then\n+            if Seq1 (J) < Seq2 (J) then\n+               pragma Assert (for all X of Seq2 => X /= Seq1 (J));\n+               pragma Assert (Map (Seq1 (J)) = Seq1 (J));\n+               pragma Assert (False);\n+            else\n+               pragma Assert (for all X of Seq1 => X /= Seq2 (J));\n+               pragma Assert (Map (Seq2 (J)) = Seq2 (J));\n+               pragma Assert (False);\n+            end if;\n+\n+         elsif J <= Seq1'Last then\n+            pragma Assert (for all X of Seq2 => X /= Seq1 (J));\n+            pragma Assert (Map (Seq1 (J)) = Seq1 (J));\n+            pragma Assert (False);\n+\n+         elsif J <= Seq2'Last then\n+            pragma Assert (for all X of Seq1 => X /= Seq2 (J));\n+            pragma Assert (Map (Seq2 (J)) = Seq2 (J));\n+            pragma Assert (False);\n+         end if;\n+      end Lemma_Domain_Unicity;\n+\n+      ---------------------\n+      -- Lemma_Is_Domain --\n+      ---------------------\n+\n+      procedure Lemma_Is_Domain (Map : Character_Mapping) is\n+         Ignore : constant Character_Sequence := To_Domain (Map);\n+      begin\n+         null;\n+      end Lemma_Is_Domain;\n+\n+      ---------------------\n+      -- Lemma_Is_Sorted --\n+      ---------------------\n+\n+      procedure Lemma_Is_Sorted (Seq : Character_Sequence) is\n+      begin\n+         for A in Seq'Range loop\n+            exit when A = Positive'Last;\n+\n+            for B in A + 1 .. Seq'Last loop\n+               pragma Loop_Invariant\n+                 (for all K in A + 1 .. B => Seq (A) < Seq (K));\n+            end loop;\n+\n+            pragma Loop_Invariant\n+              (for all J in Seq'First .. A =>\n+                 (for all K in Seq'Range =>\n+                    (if J < K then Seq (J) < Seq (K))));\n+         end loop;\n+      end Lemma_Is_Sorted;\n+\n+      --  Local variables\n+\n+      Result : String (1 .. Map'Length) with Relaxed_Initialization;\n       J      : Natural;\n+\n+      --  Repeat the computation from To_Domain in ghost code, in order to\n+      --  prove the relationship between Result and To_Domain(Map).\n+\n+      Domain : String (1 .. Map'Length) with Ghost, Relaxed_Initialization;\n+      type Character_Index is array (Character) of Natural with Ghost;\n+      Indexes : Character_Index := (others => 0) with Ghost;\n+\n+   --  Start of processing for To_Range\n+\n    begin\n       J := 0;\n       for C in Map'Range loop\n          if Map (C) /= C then\n             J := J + 1;\n             Result (J) := Map (C);\n+            Domain (J) := C;\n+            Indexes (C) := J;\n          end if;\n+\n+         --  Repeat the loop invariants from To_Domain regarding Domain and\n+         --  Indexes. Add similar loop invariants for Result and Indexes.\n+\n+         pragma Loop_Invariant (J <= Character'Pos (C) + 1);\n+         pragma Loop_Invariant (Result (1 .. J)'Initialized);\n+         pragma Loop_Invariant (Domain (1 .. J)'Initialized);\n+         pragma Loop_Invariant (for all K in 1 .. J => Domain (K) <= C);\n+         pragma Loop_Invariant\n+           (SPARK_Proof_Sorted_Character_Sequence (Domain (1 .. J)));\n+         pragma Loop_Invariant\n+           (for all D in Map'First .. C =>\n+              (if Map (D) = D then\n+                 Indexes (D) = 0\n+               else\n+                 Indexes (D) in 1 .. J\n+                   and then Domain (Indexes (D)) = D\n+                   and then Result (Indexes (D)) = Map (D)));\n+         pragma Loop_Invariant\n+           (for all Char of Domain (1 .. J) => Map (Char) /= Char);\n+         pragma Loop_Invariant\n+           (for all K in 1 .. J => Result (K) = Map (Domain (K)));\n       end loop;\n \n+      --  Show the equality of Domain and To_Domain(Map)\n+\n+      Lemma_Is_Domain (Map);\n+      Lemma_Domain_Unicity (Map, Domain (1 .. J), To_Domain (Map));\n+      pragma Assert\n+        (for all K in 1 .. J => Domain (K) = To_Domain (Map) (K));\n+      pragma Assert (To_Domain (Map)'Length = J);\n+\n       return Result (1 .. J);\n    end To_Range;\n \n@@ -197,18 +420,26 @@ package body Ada.Strings.Maps is\n    ---------------\n \n    function To_Ranges (Set : Character_Set) return Character_Ranges is\n-      Max_Ranges : Character_Ranges (1 .. Set'Length / 2 + 1);\n+      Max_Ranges : Character_Ranges (1 .. Set'Length / 2 + 1)\n+        with Relaxed_Initialization;\n       Range_Num  : Natural;\n       C          : Character;\n+      C_Iter     : Character with Ghost;\n \n    begin\n       C := Character'First;\n       Range_Num := 0;\n \n       loop\n+         C_Iter := C;\n+\n          --  Skip gap between subsets\n \n          while not Set (C) loop\n+            pragma Loop_Invariant\n+              (Character'Pos (C) >= Character'Pos (C'Loop_Entry));\n+            pragma Loop_Invariant\n+              (for all Char in C'Loop_Entry .. C => not Set (Char));\n             exit when C = Character'Last;\n             C := Character'Succ (C);\n          end loop;\n@@ -221,16 +452,45 @@ package body Ada.Strings.Maps is\n          --  Span a subset\n \n          loop\n+            pragma Loop_Invariant\n+              (Character'Pos (C) >= Character'Pos (C'Loop_Entry));\n+            pragma Loop_Invariant\n+              (for all Char in C'Loop_Entry .. C =>\n+                 (if Char /= C then Set (Char)));\n             exit when not Set (C) or else C = Character'Last;\n             C := Character'Succ (C);\n          end loop;\n \n          if Set (C) then\n-            Max_Ranges (Range_Num). High := C;\n+            Max_Ranges (Range_Num).High := C;\n             exit;\n          else\n-            Max_Ranges (Range_Num). High := Character'Pred (C);\n+            Max_Ranges (Range_Num).High := Character'Pred (C);\n          end if;\n+\n+         pragma Assert\n+           (for all Char in C_Iter .. C =>\n+              (Set (Char) =\n+                 (Char in Max_Ranges (Range_Num).Low ..\n+                          Max_Ranges (Range_Num).High)));\n+         pragma Assert\n+           (for all Char in Character'First .. C_Iter =>\n+              (if Char /= C_Iter then\n+                 (Set (Char) =\n+                    (for some Span of Max_Ranges (1 .. Range_Num - 1) =>\n+                       Char in Span.Low .. Span.High))));\n+\n+         pragma Loop_Invariant (2 * Range_Num <= Character'Pos (C) + 1);\n+         pragma Loop_Invariant (Max_Ranges (1 .. Range_Num)'Initialized);\n+         pragma Loop_Invariant (not Set (C));\n+         pragma Loop_Invariant\n+           (for all Char in Character'First .. C =>\n+              (Set (Char) =\n+                 (for some Span of Max_Ranges (1 .. Range_Num) =>\n+                    Char in Span.Low .. Span.High)));\n+         pragma Loop_Invariant\n+           (for all Span of Max_Ranges (1 .. Range_Num) =>\n+              (for all Char in Span.Low .. Span.High => Set (Char)));\n       end loop;\n \n       return Max_Ranges (1 .. Range_Num);\n@@ -241,14 +501,26 @@ package body Ada.Strings.Maps is\n    -----------------\n \n    function To_Sequence (Set : Character_Set) return Character_Sequence is\n-      Result : String (1 .. Character'Pos (Character'Last) + 1);\n+      Result : String (1 .. Character'Pos (Character'Last) + 1)\n+        with Relaxed_Initialization;\n       Count  : Natural := 0;\n    begin\n       for Char in Set'Range loop\n          if Set (Char) then\n             Count := Count + 1;\n             Result (Count) := Char;\n          end if;\n+\n+         pragma Loop_Invariant (Count <= Character'Pos (Char) + 1);\n+         pragma Loop_Invariant (Result (1 .. Count)'Initialized);\n+         pragma Loop_Invariant (for all K in 1 .. Count => Result (K) <= Char);\n+         pragma Loop_Invariant\n+           (SPARK_Proof_Sorted_Character_Sequence (Result (1 .. Count)));\n+         pragma Loop_Invariant\n+           (for all C in Set'First .. Char =>\n+              (Set (C) = (for some X of Result (1 .. Count) => C = X)));\n+         pragma Loop_Invariant\n+           (for all Char of Result (1 .. Count) => Is_In (Char, Set));\n       end loop;\n \n       return Result (1 .. Count);\n@@ -259,30 +531,37 @@ package body Ada.Strings.Maps is\n    ------------\n \n    function To_Set (Ranges : Character_Ranges) return Character_Set is\n-      Result : Character_Set;\n+      Result : Character_Set := Null_Set;\n    begin\n-      for C in Result'Range loop\n-         Result (C) := False;\n-      end loop;\n-\n       for R in Ranges'Range loop\n          for C in Ranges (R).Low .. Ranges (R).High loop\n             Result (C) := True;\n+            pragma Loop_Invariant\n+              (for all Char in Character =>\n+                 Result (Char) =\n+                   ((for some Prev in Ranges'First .. R - 1 =>\n+                       Char in Ranges (Prev).Low .. Ranges (Prev).High)\n+                    or else (Char in Ranges (R).Low .. C)));\n          end loop;\n+\n+         pragma Loop_Invariant\n+           (for all Char in Character =>\n+              Result (Char) =\n+                (for some Prev in Ranges'First .. R =>\n+                   Char in Ranges (Prev).Low .. Ranges (Prev).High));\n       end loop;\n \n       return Result;\n    end To_Set;\n \n    function To_Set (Span : Character_Range) return Character_Set is\n-      Result : Character_Set;\n+      Result : Character_Set := Null_Set;\n    begin\n-      for C in Result'Range loop\n-         Result (C) := False;\n-      end loop;\n-\n       for C in Span.Low .. Span.High loop\n          Result (C) := True;\n+         pragma Loop_Invariant\n+           (for all Char in Character =>\n+              Result (Char) = (Char in Span.Low .. C));\n       end loop;\n \n       return Result;\n@@ -293,6 +572,10 @@ package body Ada.Strings.Maps is\n    begin\n       for J in Sequence'Range loop\n          Result (Sequence (J)) := True;\n+         pragma Loop_Invariant\n+           (for all Char in Character =>\n+              Result (Char) =\n+                (for some K in Sequence'First .. J => Char = Sequence (K)));\n       end loop;\n \n       return Result;\n@@ -313,8 +596,6 @@ package body Ada.Strings.Maps is\n      (Map     : Character_Mapping;\n       Element : Character) return Character\n    is\n-   begin\n-      return Map (Element);\n-   end Value;\n+      (Map (Element));\n \n end Ada.Strings.Maps;"}, {"sha": "1a15d5dc2d6e76c996fe8a3344349b13282df400", "filename": "gcc/ada/libgnat/a-strmap.ads", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46939f9d4091e78e60d8d4d78d023a48a1608aa/gcc%2Fada%2Flibgnat%2Fa-strmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46939f9d4091e78e60d8d4d78d023a48a1608aa/gcc%2Fada%2Flibgnat%2Fa-strmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strmap.ads?ref=f46939f9d4091e78e60d8d4d78d023a48a1608aa", "patch": "@@ -33,6 +33,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  The package Strings.Maps defines the types, operations, and other entities\n+--  needed for character sets and character-to-character mappings.\n+\n --  Preconditions in this unit are meant for analysis only, not for run-time\n --  checking, so that the expected exceptions are raised. This is enforced by\n --  setting the corresponding assertion policy to Ignore. Postconditions and\n@@ -45,7 +48,9 @@ pragma Assertion_Policy (Pre   => Ignore,\n \n with Ada.Characters.Latin_1;\n \n-package Ada.Strings.Maps is\n+package Ada.Strings.Maps\n+  with SPARK_Mode\n+is\n    pragma Pure;\n    --  In accordance with Ada 2005 AI-362\n \n@@ -55,9 +60,10 @@ package Ada.Strings.Maps is\n \n    type Character_Set is private;\n    pragma Preelaborable_Initialization (Character_Set);\n-   --  Representation for a set of character values:\n+   --  An object of type Character_Set represents a set of characters.\n \n    Null_Set : constant Character_Set;\n+   --  Null_Set represents the set containing no characters.\n \n    ---------------------------\n    -- Constructors for Sets --\n@@ -67,9 +73,12 @@ package Ada.Strings.Maps is\n       Low  : Character;\n       High : Character;\n    end record;\n-   --  Represents Character range Low .. High\n+   --  An object Obj of type Character_Range represents the set of characters\n+   --  in the range Obj.Low .. Obj.High.\n \n    type Character_Ranges is array (Positive range <>) of Character_Range;\n+   --  An object Obj of type Character_Ranges represents the union of the sets\n+   --  corresponding to Obj(I) for I in Obj'Range.\n \n    function To_Set    (Ranges : Character_Ranges) return Character_Set with\n      Post =>\n@@ -82,6 +91,8 @@ package Ada.Strings.Maps is\n        (for all Span of Ranges =>\n           (for all Char in Span.Low .. Span.High =>\n              Is_In (Char, To_Set'Result)));\n+   --  If Ranges'Length=0 then Null_Set is returned; otherwise, the returned\n+   --  value represents the set corresponding to Ranges.\n \n    function To_Set    (Span   : Character_Range)  return Character_Set with\n      Post =>\n@@ -91,6 +102,7 @@ package Ada.Strings.Maps is\n           (if Is_In (Char, To_Set'Result) then Char in Span.Low .. Span.High))\n           and then\n        (for all Char in Span.Low .. Span.High => Is_In (Char, To_Set'Result));\n+   --  The returned value represents the set containing each character in Span.\n \n    function To_Ranges (Set    : Character_Set)    return Character_Ranges with\n      Post =>\n@@ -104,6 +116,12 @@ package Ada.Strings.Maps is\n           and then\n        (for all Span of To_Ranges'Result =>\n           (for all Char in Span.Low .. Span.High => Is_In (Char, Set)));\n+   --  If Set = Null_Set, then an empty Character_Ranges array is returned;\n+   --  otherwise, the shortest array of contiguous ranges of Character values\n+   --  in Set, in increasing order of Low, is returned.\n+   --\n+   --  The postcondition above does not express that the result is the shortest\n+   --  array and that it is sorted.\n \n    ----------------------------------\n    -- Operations on Character Sets --\n@@ -115,6 +133,13 @@ package Ada.Strings.Maps is\n          =\n        (for all Char in Character =>\n           (Is_In (Char, Left) = Is_In (Char, Right)));\n+   --  The function \"=\" returns True if Left and Right represent identical\n+   --  sets, and False otherwise.\n+\n+   --  Each of the logical operators \"not\", \"and\", \"or\", and \"xor\" returns a\n+   --  Character_Set value that represents the set obtained by applying the\n+   --  corresponding operation to the set(s) represented by the parameter(s)\n+   --  of the operator.\n \n    function \"not\" (Right       : Character_Set) return Character_Set with\n      Post =>\n@@ -150,10 +175,12 @@ package Ada.Strings.Maps is\n           (Is_In (Char, \"-\"'Result)\n              =\n            (Is_In (Char, Left) and not Is_In (Char, Right))));\n+   --  \"-\"(Left, Right) is equivalent to \"and\"(Left, \"not\"(Right)).\n \n    function Is_In\n      (Element : Character;\n       Set     : Character_Set) return Boolean;\n+   --  Is_In returns True if Element is in Set, and False otherwise.\n \n    function Is_Subset\n      (Elements : Character_Set;\n@@ -164,14 +191,32 @@ package Ada.Strings.Maps is\n            =\n          (for all Char in Character =>\n             (if Is_In (Char, Elements) then Is_In (Char, Set)));\n+   --  Is_Subset returns True if Elements is a subset of Set, and False\n+   --  otherwise.\n \n    function \"<=\"\n      (Left  : Character_Set;\n       Right : Character_Set) return Boolean\n    renames Is_Subset;\n \n    subtype Character_Sequence is String;\n-   --  Alternative representation for a set of character values\n+   --  The Character_Sequence subtype is used to portray a set of character\n+   --  values and also to identify the domain and range of a character mapping.\n+\n+   function SPARK_Proof_Sorted_Character_Sequence\n+     (Seq : Character_Sequence) return Boolean\n+   is\n+     (for all J in Seq'Range =>\n+        (if J /= Seq'Last then Seq (J) < Seq (J + 1)))\n+   with\n+     Ghost;\n+   --  Check whether the Character_Sequence is sorted in stricly increasing\n+   --  order, as expected from the result of To_Sequence and To_Domain.\n+\n+   --  Sequence portrays the set of character values that it explicitly\n+   --  contains (ignoring duplicates). Singleton portrays the set comprising a\n+   --  single Character. Each of the To_Set functions returns a Character_Set\n+   --  value that represents the set portrayed by Sequence or Singleton.\n \n    function To_Set (Sequence  : Character_Sequence) return Character_Set with\n      Post =>\n@@ -201,18 +246,19 @@ package Ada.Strings.Maps is\n           and then\n        (for all Char of To_Sequence'Result => Is_In (Char, Set))\n           and then\n-       (for all J in To_Sequence'Result'Range =>\n-          (for all K in To_Sequence'Result'Range =>\n-             (if J /= K\n-              then To_Sequence'Result (J) /= To_Sequence'Result (K))));\n+       SPARK_Proof_Sorted_Character_Sequence (To_Sequence'Result);\n+   --  The function To_Sequence returns a Character_Sequence value containing\n+   --  each of the characters in the set represented by Set, in ascending order\n+   --  with no duplicates.\n \n    ------------------------------------\n    -- Character Mapping Declarations --\n    ------------------------------------\n \n    type Character_Mapping is private;\n    pragma Preelaborable_Initialization (Character_Mapping);\n-   --  Representation for a character to character mapping:\n+   --  An object of type Character_Mapping represents a Character-to-Character\n+   --  mapping.\n \n    type SPARK_Proof_Character_Mapping_Model is\n      array (Character) of Character\n@@ -233,7 +279,17 @@ package Ada.Strings.Maps is\n    --  The function Value returns the Character value to which Element maps\n    --  with respect to the mapping represented by Map.\n \n+   --  A character C matches a pattern character P with respect to a given\n+   --  Character_Mapping value Map if Value(Map, C) = P. A string S matches\n+   --  a pattern string P with respect to a given Character_Mapping if\n+   --  their lengths are the same and if each character in S matches its\n+   --  corresponding character in the pattern string P.\n+\n+   --  String handling subprograms that deal with character mappings have\n+   --  parameters whose type is Character_Mapping.\n+\n    Identity : constant Character_Mapping;\n+   --  Identity maps each Character to itself.\n \n    ----------------------------\n    -- Operations on Mappings --\n@@ -259,6 +315,10 @@ package Ada.Strings.Maps is\n              and then\n            (if (for all X of From => Char /= X)\n             then Value (To_Mapping'Result, Char) = Char)));\n+   --  To_Mapping produces a Character_Mapping such that each element of From\n+   --  maps to the corresponding element of To, and each other character maps\n+   --  to itself. If From'Length /= To'Length, or if some character is repeated\n+   --  in From, then Translation_Error is propagated.\n \n    function To_Domain\n      (Map : Character_Mapping) return Character_Sequence with\n@@ -267,24 +327,40 @@ package Ada.Strings.Maps is\n           and then\n        To_Domain'Result'First = 1\n           and then\n+       SPARK_Proof_Sorted_Character_Sequence (To_Domain'Result)\n+          and then\n        (for all Char in Character =>\n           (if (for all X of To_Domain'Result => X /= Char)\n            then Value (Map, Char) = Char))\n           and then\n        (for all Char of To_Domain'Result => Value (Map, Char) /= Char);\n+   --  To_Domain returns the shortest Character_Sequence value D such that each\n+   --  character not in D maps to itself, and such that the characters in D are\n+   --  in ascending order. The lower bound of D is 1.\n \n    function To_Range\n      (Map : Character_Mapping) return Character_Sequence with\n      Post =>\n        To_Range'Result'First = 1\n          and then\n-       To_Range'Result'Last = To_Domain (Map)'Last\n+       To_Range'Result'Length = To_Domain (Map)'Length\n          and then\n        (for all J in To_Range'Result'Range =>\n           To_Range'Result (J) = Value (Map, To_Domain (Map) (J)));\n+   --  To_Range returns the Character_Sequence value R, such that if D =\n+   --  To_Domain(Map), then R has the same bounds as D, and D(I) maps to\n+   --  R(I) for each I in D'Range.\n+   --\n+   --  A direct encoding of the Ada RM would be the postcondition\n+   --    To_Range'Result'Last = To_Domain (Map)'Last\n+   --  which is not provable unless the postcondition of To_Domain is also\n+   --  strengthened to state the value of the high bound for an empty result.\n \n    type Character_Mapping_Function is\n       access function (From : Character) return Character;\n+   --  An object F of type Character_Mapping_Function maps a Character value C\n+   --  to the Character value F.all(C), which is said to match C with respect\n+   --  to mapping function F.\n \n private\n    pragma Inline (Is_In);"}]}