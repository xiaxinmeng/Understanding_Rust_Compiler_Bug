{"sha": "b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyZDVlYWE0NDc4OWQ2Yzk1OTNjMTJkN2QxYzE0MTlmZTU5YjBjMQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-11-23T01:27:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-11-23T01:27:42Z"}, "message": "fold-const.c (nondestructive_fold_binary_to_constant): Rename to fold_binary_to_constant.\n\n\n\t* fold-const.c (nondestructive_fold_binary_to_constant): Rename\n\tto fold_binary_to_constant.\n\t(nondestructive_fold_unary_to_constant): Likewise, rename to\n\tfold_unary_to_constant.\n\t(fold_relational_hi_lo): Update call to fold_binary_to_constant.\n\t* tree.h (nondestructive_fold_binary_to_constant): Update prototype.\n\t(nondestructive_fold_unary_to_constant): Likewise.\n\t* tree-ssa-ccp.c (ccp_fold): Update calls to fold_unary_to_constant\n\tand fold_binary_to_constant.\n\t* tree-ssa-loop-niter.c (EXEC_BINARY, EXEC_UNARY): Delete macros.\n\t(inverse, number_of_iterations_cond): Replace uses of EXEC_BINARY\n\tand EXEC_UNARY with calls to fold_*nary_to_constant.\n\t* tree-ssa-loop-ivopts.c (EXEC_BINARY, EXEC_UNARY): Delete macros.\n\t(idx_find_step): Replace uses of EXEC_BINARY with calls to\n\tfold_binary_to_constant.\n\nFrom-SVN: r91063", "tree": {"sha": "cbdc035bbae2cbaa36d0c682f7035fccc80e4ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbdc035bbae2cbaa36d0c682f7035fccc80e4ec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/comments", "author": null, "committer": null, "parents": [{"sha": "ba2baa55a34a75ddde02a3ac05daf805fc413e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba2baa55a34a75ddde02a3ac05daf805fc413e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba2baa55a34a75ddde02a3ac05daf805fc413e1c"}], "stats": {"total": 96, "additions": 53, "deletions": 43}, "files": [{"sha": "4604a925b69a4f6ceffba7b6053074034ecc0a82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -1,3 +1,21 @@\n+2004-11-22  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (nondestructive_fold_binary_to_constant): Rename\n+\tto fold_binary_to_constant.\n+\t(nondestructive_fold_unary_to_constant): Likewise, rename to\n+\tfold_unary_to_constant.\n+\t(fold_relational_hi_lo): Update call to fold_binary_to_constant.\n+\t* tree.h (nondestructive_fold_binary_to_constant): Update prototype.\n+\t(nondestructive_fold_unary_to_constant): Likewise.\n+\t* tree-ssa-ccp.c (ccp_fold): Update calls to fold_unary_to_constant\n+\tand fold_binary_to_constant.\n+\t* tree-ssa-loop-niter.c (EXEC_BINARY, EXEC_UNARY): Delete macros.\n+\t(inverse, number_of_iterations_cond): Replace uses of EXEC_BINARY\n+\tand EXEC_UNARY with calls to fold_*nary_to_constant.\n+\t* tree-ssa-loop-ivopts.c (EXEC_BINARY, EXEC_UNARY): Delete macros.\n+\t(idx_find_step): Replace uses of EXEC_BINARY with calls to\n+\tfold_binary_to_constant.\n+\n 2004-11-22  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.h (TARGET_USE_FANCY_MATH_387): New macro."}, {"sha": "0a7b7d226a314351e679f8552c4fcf8e247744df", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -10110,11 +10110,10 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n \t\t\t    fold_convert (st0, op0),\n \t\t\t    fold_convert (st1, integer_zero_node));\n \n-\t      retval\n-\t\t= nondestructive_fold_binary_to_constant (TREE_CODE (exp),\n-\t\t\t\t\t\t\t  TREE_TYPE (exp),\n-\t\t\t\t\t\t\t  TREE_OPERAND (exp, 0),\n-\t\t\t\t\t\t\t  TREE_OPERAND (exp, 1));\n+\t      retval = fold_binary_to_constant (TREE_CODE (exp),\n+\t\t\t\t\t\tTREE_TYPE (exp),\n+\t\t\t\t\t\tTREE_OPERAND (exp, 0),\n+\t\t\t\t\t\tTREE_OPERAND (exp, 1));\n \n \t      /* If we are in gimple form, then returning EXP would create\n \t\t non-gimple expressions.  Clearing it is safe and insures\n@@ -10145,8 +10144,7 @@ fold_relational_hi_lo (enum tree_code *code_p, const tree type, tree *op0_p,\n    simpler than the generic fold routine.  */\n \n tree\n-nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n-\t\t\t\t\ttree op0, tree op1)\n+fold_binary_to_constant (enum tree_code code, tree type, tree op0, tree op1)\n {\n   int wins = 1;\n   tree subop0;\n@@ -10440,8 +10438,7 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n    the generic fold routine.  */\n \n tree\n-nondestructive_fold_unary_to_constant (enum tree_code code, tree type,\n-\t\t\t\t       tree op0)\n+fold_unary_to_constant (enum tree_code code, tree type, tree op0)\n {\n   /* Make sure we have a suitable constant argument.  */\n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)"}, {"sha": "31807fec59d9cc528bd26b3f646030a2104890c0", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -847,9 +847,7 @@ ccp_fold (tree stmt)\n \t    op0 = get_value (op0)->const_val;\n \t}\n \n-      retval = nondestructive_fold_unary_to_constant (code,\n-\t\t     \t\t\t\t      TREE_TYPE (rhs),\n-\t\t\t\t\t\t      op0);\n+      retval = fold_unary_to_constant (code, TREE_TYPE (rhs), op0);\n \n       /* If we folded, but did not create an invariant, then we can not\n \t use this expression.  */\n@@ -900,9 +898,7 @@ ccp_fold (tree stmt)\n \t    op1 = val->const_val;\n \t}\n \n-      retval = nondestructive_fold_binary_to_constant (code,\n-\t\t     \t\t\t\t       TREE_TYPE (rhs),\n-\t\t\t\t\t\t       op0, op1);\n+      retval = fold_binary_to_constant (code, TREE_TYPE (rhs), op0, op1);\n \n       /* If we folded, but did not create an invariant, then we can not\n \t use this expression.  */"}, {"sha": "1de1e8292f8390c2120ec0ed1ec2f4ea058d5750", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -96,9 +96,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    this.  */\n #define AVG_LOOP_NITER(LOOP) 5\n \n-/* Just to shorten the ugly names.  */\n-#define EXEC_BINARY nondestructive_fold_binary_to_constant\n-#define EXEC_UNARY nondestructive_fold_unary_to_constant\n \n /* Representation of the induction variable.  */\n struct iv\n@@ -1364,12 +1361,13 @@ idx_find_step (tree base, tree *idx, void *data)\n       return false;\n     }\n \n-  step = EXEC_BINARY (MULT_EXPR, type, step, iv_step);\n+  step = fold_binary_to_constant (MULT_EXPR, type, step, iv_step);\n \n   if (!*dta->step_p)\n     *dta->step_p = step;\n   else\n-    *dta->step_p = EXEC_BINARY (PLUS_EXPR, type, *dta->step_p, step);\n+    *dta->step_p = fold_binary_to_constant (PLUS_EXPR, type,\n+\t\t\t\t\t    *dta->step_p, step);\n \n   return true;\n }"}, {"sha": "6a429b73cac41c09a5f4dde0278f5ba686b79598", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -43,9 +43,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define SWAP(X, Y) do { void *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n \n-/* Just to shorten the ugly names.  */\n-#define EXEC_BINARY nondestructive_fold_binary_to_constant\n-#define EXEC_UNARY nondestructive_fold_unary_to_constant\n \n /*\n \n@@ -156,10 +153,10 @@ inverse (tree x, tree mask)\n       rslt = build_int_cst_type (type, 1);\n       for (; ctr; ctr--)\n \t{\n-\t  rslt = EXEC_BINARY (MULT_EXPR, type, rslt, x);\n-\t  x = EXEC_BINARY (MULT_EXPR, type, x, x);\n+\t  rslt = fold_binary_to_constant (MULT_EXPR, type, rslt, x);\n+\t  x = fold_binary_to_constant (MULT_EXPR, type, x, x);\n \t}\n-      rslt = EXEC_BINARY (BIT_AND_EXPR, type, rslt, mask);\n+      rslt = fold_binary_to_constant (BIT_AND_EXPR, type, rslt, mask);\n     }\n \n   return rslt;\n@@ -217,7 +214,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       if (code != NE_EXPR)\n \treturn;\n \n-      step0 = EXEC_BINARY (MINUS_EXPR, type, step0, step1);\n+      step0 = fold_binary_to_constant (MINUS_EXPR, type, step0, step1);\n       step1 = NULL_TREE;\n     }\n \n@@ -311,7 +308,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n   if (code != NE_EXPR)\n     {\n       if (zero_p (step0))\n-\tstep = EXEC_UNARY (NEGATE_EXPR, type, step1);\n+\tstep = fold_unary_to_constant (NEGATE_EXPR, type, step1);\n       else\n \tstep = step0;\n       delta = build2 (MINUS_EXPR, type, base1, base0);\n@@ -320,8 +317,8 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \n       if (TREE_CODE (delta) == INTEGER_CST)\n \t{\n-\t  tmp = EXEC_BINARY (MINUS_EXPR, type, step,\n-\t\t\t     build_int_cst_type (type, 1));\n+\t  tmp = fold_binary_to_constant (MINUS_EXPR, type, step,\n+\t\t\t\t\t build_int_cst_type (type, 1));\n \t  if (was_sharp\n \t      && operand_equal_p (delta, tmp, 0))\n \t    {\n@@ -342,8 +339,10 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\tmay_xform = boolean_true_node;\n \t      else\n \t\t{\n-\t\t  bound = EXEC_BINARY (PLUS_EXPR, type, mmin, step);\n-\t\t  bound = EXEC_BINARY (MINUS_EXPR, type, bound, delta);\n+\t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n+\t\t\t\t\t\t   mmin, step);\n+\t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t\t   bound, delta);\n \t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   bound, base0));\n \t\t}\n@@ -354,8 +353,10 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\tmay_xform = boolean_true_node;\n \t      else\n \t\t{\n-\t\t  bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step);\n-\t\t  bound = EXEC_BINARY (PLUS_EXPR, type, bound, delta);\n+\t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t\t   mmax, step);\n+\t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n+\t\t\t\t\t\t   bound, delta);\n \t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   base1, bound));\n \t\t}\n@@ -401,11 +402,11 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       base1 = fold (build2 (MINUS_EXPR, type, base1, base0));\n       base0 = NULL_TREE;\n       if (!zero_p (step1))\n-  \tstep0 = EXEC_UNARY (NEGATE_EXPR, type, step1);\n+  \tstep0 = fold_unary_to_constant (NEGATE_EXPR, type, step1);\n       step1 = NULL_TREE;\n       if (!tree_expr_nonnegative_p (fold_convert (signed_niter_type, step0)))\n \t{\n-\t  step0 = EXEC_UNARY (NEGATE_EXPR, type, step0);\n+\t  step0 = fold_unary_to_constant (NEGATE_EXPR, type, step0);\n \t  base1 = fold (build1 (NEGATE_EXPR, type, base1));\n \t}\n \n@@ -416,9 +417,9 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t is infinite.  Otherwise, the number of iterations is\n \t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n       bits = num_ending_zeros (step0);\n-      d = EXEC_BINARY (LSHIFT_EXPR, niter_type,\n-\t\t       build_int_cst_type (niter_type, 1), bits);\n-      s = EXEC_BINARY (RSHIFT_EXPR, niter_type, step0, bits);\n+      d = fold_binary_to_constant (LSHIFT_EXPR, niter_type,\n+\t\t\t\t   build_int_cst_type (niter_type, 1), bits);\n+      s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, step0, bits);\n \n       bound = build_low_bits_mask (niter_type,\n \t\t\t\t   (TYPE_PRECISION (niter_type)\n@@ -447,7 +448,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t{\n \t  if (mmax)\n \t    {\n-\t      bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step0);\n+\t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmax, step0);\n \t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t base1, bound));\n \t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n@@ -468,7 +469,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t     we can again compute number of iterations as (b - (a - s)) / s.  */\n \t  if (mmin)\n \t    {\n-\t      bound = EXEC_BINARY (MINUS_EXPR, type, mmin, step1);\n+\t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmin, step1);\n \t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\tbound, base0));\n \t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,"}, {"sha": "c95c84d0afa5e713a9144a26a0d5eed17a760a2d", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "patch": "@@ -3525,8 +3525,8 @@ extern int operand_equal_p (tree, tree, unsigned int);\n extern tree omit_one_operand (tree, tree, tree);\n extern tree omit_two_operands (tree, tree, tree, tree);\n extern tree invert_truthvalue (tree);\n-extern tree nondestructive_fold_unary_to_constant (enum tree_code, tree, tree);\n-extern tree nondestructive_fold_binary_to_constant (enum tree_code, tree, tree, tree);\n+extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n+extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);\n extern tree fold_read_from_constant_string (tree);\n extern tree int_const_binop (enum tree_code, tree, tree, int);\n extern tree build_fold_addr_expr (tree);"}]}