{"sha": "839c47964ea35b14d873a5c0774d85bcc0c5cbd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM5YzQ3OTY0ZWEzNWIxNGQ4NzNhNWMwNzc0ZDg1YmNjMGM1Y2JkOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:18:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:18:33Z"}, "message": "(get_inner_reference): Add new arg PALIGNMENT and compute it.\n\n(expand_assignment, do_jump): Pass new arg to get_inner_reference.\n(expand_expr, case COMPONENT_REF): Likewise.\n\nFrom-SVN: r13187", "tree": {"sha": "42803204ac925bc7d93705741acb3cc7be69ef88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42803204ac925bc7d93705741acb3cc7be69ef88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/839c47964ea35b14d873a5c0774d85bcc0c5cbd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839c47964ea35b14d873a5c0774d85bcc0c5cbd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839c47964ea35b14d873a5c0774d85bcc0c5cbd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839c47964ea35b14d873a5c0774d85bcc0c5cbd9/comments", "author": null, "committer": null, "parents": [{"sha": "aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849"}], "stats": {"total": 36, "additions": 27, "deletions": 9}, "files": [{"sha": "834b5a1bfe659f4277f01db2fb9e350c7a45ad06", "filename": "gcc/expr.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/839c47964ea35b14d873a5c0774d85bcc0c5cbd9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/839c47964ea35b14d873a5c0774d85bcc0c5cbd9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=839c47964ea35b14d873a5c0774d85bcc0c5cbd9", "patch": "@@ -2791,16 +2791,15 @@ expand_assignment (to, from, want_value, suggest_reg)\n       int alignment;\n \n       push_temp_slots ();\n-      tem = get_inner_reference (to, &bitsize, &bitpos, &offset,\n-\t\t\t\t      &mode1, &unsignedp, &volatilep);\n+      tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n+\t\t\t\t &unsignedp, &volatilep, &alignment);\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */\n \n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      alignment = TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT;\n       to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n       if (offset != 0)\n \t{\n@@ -4188,6 +4187,9 @@ get_inner_unaligned_p (exp)\n    giving the variable offset (in units) in *POFFSET.\n    This offset is in addition to the bit position.\n    If the position is not variable, we store 0 in *POFFSET.\n+   We set *PALIGNMENT to the alignment in bytes of the address that will be\n+   computed.  This is the alignment of the thing we return if *POFFSET\n+   is zero, but can be more less strictly aligned if *POFFSET is nonzero.\n \n    If any of the extraction expressions is volatile,\n    we store 1 in *PVOLATILEP.  Otherwise we don't change that.\n@@ -4198,23 +4200,25 @@ get_inner_unaligned_p (exp)\n \n    If the field describes a variable-sized object, *PMODE is set to\n    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in\n-   this case, but the address of the object can be found.  */\n+   this case, but the address of the object can be found.   */\n \n tree\n get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n-\t\t     punsignedp, pvolatilep)\n+\t\t     punsignedp, pvolatilep, palignment)\n      tree exp;\n      int *pbitsize;\n      int *pbitpos;\n      tree *poffset;\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int *pvolatilep;\n+     int *palignment;\n {\n   tree orig_exp = exp;\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n   tree offset = integer_zero_node;\n+  int alignment = BIGGEST_ALIGNMENT;\n \n   if (TREE_CODE (exp) == COMPONENT_REF)\n     {\n@@ -4323,9 +4327,20 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n       /* If any reference in the chain is volatile, the effect is volatile.  */\n       if (TREE_THIS_VOLATILE (exp))\n \t*pvolatilep = 1;\n+\n+      /* If the offset is non-constant already, then we can't assume any\n+\t alignment more than the alignment here.  */\n+      if (! integer_zerop (offset))\n+\talignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));\n+\n       exp = TREE_OPERAND (exp, 0);\n     }\n \n+  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+    alignment = MIN (alignment, DECL_ALIGN (exp));\n+  else\n+    alignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));\n+\n   if (integer_zerop (offset))\n     offset = 0;\n \n@@ -4334,6 +4349,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \n   *pmode = mode;\n   *poffset = offset;\n+  *palignment = alignment / BITS_PER_UNIT;\n   return exp;\n }\n \f\n@@ -5461,9 +5477,10 @@ expand_expr (exp, target, tmode, modifier)\n \tint bitpos;\n \ttree offset;\n \tint volatilep = 0;\n-\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep);\n \tint alignment;\n+\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep,\n+\t\t\t\t\t&alignment);\n \n \t/* If we got back the original object, something is wrong.  Perhaps\n \t   we are evaluating an expression too early.  In any event, don't\n@@ -5494,7 +5511,6 @@ expand_expr (exp, target, tmode, modifier)\n \t      op0 = validize_mem (force_const_mem (mode, op0));\n \t  }\n \n-\talignment = TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT;\n \tif (offset != 0)\n \t  {\n \t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n@@ -10154,11 +10170,13 @@ do_jump (exp, if_false_label, if_true_label)\n \ttree type;\n \ttree offset;\n \tint volatilep = 0;\n+\tint alignment;\n \n \t/* Get description of this reference.  We don't actually care\n \t   about the underlying object here.  */\n \tget_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t     &mode, &unsignedp, &volatilep);\n+\t\t\t     &mode, &unsignedp, &volatilep,\n+\t\t\t     &alignment);\n \n \ttype = type_for_size (bitsize, unsignedp);\n \tif (! SLOW_BYTE_ACCESS"}]}