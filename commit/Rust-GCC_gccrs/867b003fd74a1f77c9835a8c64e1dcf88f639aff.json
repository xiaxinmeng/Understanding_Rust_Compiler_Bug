{"sha": "867b003fd74a1f77c9835a8c64e1dcf88f639aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3YjAwM2ZkNzRhMWY3N2M5ODM1YThjNjRlMWRjZjg4ZjYzOWFmZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-13T20:39:02Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-13T20:39:02Z"}, "message": "runtime: skip zero-sized fields in structs when converting to FFI\n    \n    The libffi library doesn't understand zero-sized objects.\n    When we see a zero-sized field in a struct, just skip it when\n    converting to the FFI data structures. There is no value to pass in\n    any case, so not telling libffi about the field doesn't affect\n    anything.\n    \n    The test case for this is https://golang.org/cl/123316.\n    \n    Fixes golang/go#26335\n    \n    Reviewed-on: https://go-review.googlesource.com/123335\n\nFrom-SVN: r262651", "tree": {"sha": "56301120971100639a4f923361812cb8d0b79362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56301120971100639a4f923361812cb8d0b79362"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/867b003fd74a1f77c9835a8c64e1dcf88f639aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867b003fd74a1f77c9835a8c64e1dcf88f639aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867b003fd74a1f77c9835a8c64e1dcf88f639aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867b003fd74a1f77c9835a8c64e1dcf88f639aff/comments", "author": null, "committer": null, "parents": [{"sha": "7264261f64fab95545cd1e5bae429fad5f2b44d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7264261f64fab95545cd1e5bae429fad5f2b44d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7264261f64fab95545cd1e5bae429fad5f2b44d7"}], "stats": {"total": 50, "additions": 46, "deletions": 4}, "files": [{"sha": "3e0b65593cd0177bebaa2feca0537e489f048f97", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867b003fd74a1f77c9835a8c64e1dcf88f639aff/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867b003fd74a1f77c9835a8c64e1dcf88f639aff/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=867b003fd74a1f77c9835a8c64e1dcf88f639aff", "patch": "@@ -1,4 +1,4 @@\n-3f7e72eca3f9221e67c055841d42851aa6a66aff\n+db991403fc97854201b3f40492f4f6b9d471cabc\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "00858f19ab43e89b2f39a70661a8cfc7e02e5206", "filename": "libgo/go/runtime/ffi.go", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867b003fd74a1f77c9835a8c64e1dcf88f639aff/libgo%2Fgo%2Fruntime%2Fffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867b003fd74a1f77c9835a8c64e1dcf88f639aff/libgo%2Fgo%2Fruntime%2Fffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fffi.go?ref=867b003fd74a1f77c9835a8c64e1dcf88f639aff", "patch": "@@ -225,11 +225,40 @@ func structToFFI(typ *structtype) *__ffi_type {\n \t\treturn emptyStructToFFI()\n \t}\n \n-\tfields := make([]*__ffi_type, c+1)\n+\tfields := make([]*__ffi_type, 0, c+1)\n+\tcheckPad := false\n \tfor i, v := range typ.fields {\n-\t\tfields[i] = typeToFFI(v.typ)\n+\t\t// Skip zero-sized fields; they confuse libffi,\n+\t\t// and there is no value to pass in any case.\n+\t\t// We do have to check whether the alignment of the\n+\t\t// zero-sized field introduces any padding for the\n+\t\t// next field.\n+\t\tif v.typ.size == 0 {\n+\t\t\tcheckPad = true\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif checkPad {\n+\t\t\toff := uintptr(0)\n+\t\t\tfor j := i - 1; j >= 0; j-- {\n+\t\t\t\tif typ.fields[j].typ.size > 0 {\n+\t\t\t\t\toff = typ.fields[j].offset() + typ.fields[j].typ.size\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\toff += uintptr(v.typ.align) - 1\n+\t\t\toff &^= uintptr(v.typ.align) - 1\n+\t\t\tif off != v.offset() {\n+\t\t\t\tfields = append(fields, padFFI(v.offset()-off))\n+\t\t\t}\n+\t\t\tcheckPad = false\n+\t\t}\n+\n+\t\tfields = append(fields, typeToFFI(v.typ))\n \t}\n-\tfields[c] = nil\n+\n+\tfields = append(fields, nil)\n+\n \treturn &__ffi_type{\n \t\t_type:    _FFI_TYPE_STRUCT,\n \t\telements: &fields[0],\n@@ -305,6 +334,19 @@ func emptyStructToFFI() *__ffi_type {\n \t}\n }\n \n+// padFFI returns a padding field of the given size\n+func padFFI(size uintptr) *__ffi_type {\n+\telements := make([]*__ffi_type, size+1)\n+\tfor i := uintptr(0); i < size; i++ {\n+\t\telements[i] = ffi_type_uint8()\n+\t}\n+\telements[size] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n //go:linkname makeCIF reflect.makeCIF\n \n // makeCIF is used by the reflect package to allocate a CIF."}]}