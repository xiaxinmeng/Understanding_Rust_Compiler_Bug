{"sha": "a7753db4a7c071fef7a4e7fe2650d6c59cc34066", "node_id": "C_kwDOANBUbNoAKGE3NzUzZGI0YTdjMDcxZmVmN2E0ZTdmZTI2NTBkNmM1OWNjMzQwNjY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-11T15:12:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-11T21:13:17Z"}, "message": "Remove loop crossing restriction from the backward threader.\n\nWe have much more thorough restrictions, that are shared between both\nthreader implementations, in the registry.  I've been meaning to\nremove the backward threader one, since it's only purpose was reducing\nthe search space.  Previously there was a small time penalty for its\nremoval, but with the various patches in the past month, it looks like\nthe removal is a wash performance wise.\n\nThis catches 8 more jump threads in the backward threader in my suite.\nPresumably, because we disallowed all loop crossing, whereas the\nregistry restrictions allow some crossing (if we exit the loop, etc).\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c\n\t(back_threader_profitability::profitable_path_p): Remove loop\n\tcrossing restriction.", "tree": {"sha": "d2b37dbb84682571cca65114fea68eacf267155a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2b37dbb84682571cca65114fea68eacf267155a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7753db4a7c071fef7a4e7fe2650d6c59cc34066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7753db4a7c071fef7a4e7fe2650d6c59cc34066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7753db4a7c071fef7a4e7fe2650d6c59cc34066", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7753db4a7c071fef7a4e7fe2650d6c59cc34066/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a8458ac6bbc4263dd2c1ee55979b29fc7195794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8458ac6bbc4263dd2c1ee55979b29fc7195794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8458ac6bbc4263dd2c1ee55979b29fc7195794"}], "stats": {"total": 36, "additions": 6, "deletions": 30}, "files": [{"sha": "61aee25d2363d7b655519213d70788a22e251b1c", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7753db4a7c071fef7a4e7fe2650d6c59cc34066/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7753db4a7c071fef7a4e7fe2650d6c59cc34066/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=a7753db4a7c071fef7a4e7fe2650d6c59cc34066", "patch": "@@ -615,7 +615,6 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n   int n_insns = 0;\n   gimple_stmt_iterator gsi;\n   loop_p loop = m_path[0]->loop_father;\n-  bool path_crosses_loops = false;\n   bool threaded_through_latch = false;\n   bool multiway_branch_in_path = false;\n   bool threaded_multiway_branch = false;\n@@ -634,30 +633,15 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" bb:%i\", bb->index);\n-      /* Remember, blocks in the path are stored in opposite order\n-\t in the PATH array.  The last entry in the array represents\n-\t the block with an outgoing edge that we will redirect to the\n-\t jump threading path.  Thus we don't care about that block's\n-\t loop father, nor how many statements are in that block because\n-\t it will not be copied or whether or not it ends in a multiway\n-\t branch.  */\n+      /* Remember, blocks in the path are stored in opposite order in\n+\t the PATH array.  The last entry in the array represents the\n+\t block with an outgoing edge that we will redirect to the jump\n+\t threading path.  Thus we don't care how many statements are\n+\t in that block because it will not be copied or whether or not\n+\t it ends in a multiway branch.  */\n       if (j < m_path.length () - 1)\n \t{\n \t  int orig_n_insns = n_insns;\n-\t  if (bb->loop_father != loop)\n-\t    {\n-\t      path_crosses_loops = true;\n-\n-\t      // Dump rest of blocks.\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfor (j++; j < m_path.length (); j++)\n-\t\t  {\n-\t\t    bb = m_path[j];\n-\t\t    fprintf (dump_file, \" bb:%i\", bb->index);\n-\t\t  }\n-\t      break;\n-\t    }\n-\n \t  /* PHIs in the path will create degenerate PHIS in the\n \t     copied path which will then get propagated away, so\n \t     looking at just the duplicate path the PHIs would\n@@ -776,14 +760,6 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \t*creates_irreducible_loop = true;\n     }\n \n-  if (path_crosses_loops)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n-\t\t \"the path crosses loops.\\n\");\n-      return false;\n-    }\n-\n   /* Threading is profitable if the path duplicated is hot but also\n      in a case we separate cold path from hot path and permit optimization\n      of the hot path later.  Be on the agressive side here. In some testcases,"}]}