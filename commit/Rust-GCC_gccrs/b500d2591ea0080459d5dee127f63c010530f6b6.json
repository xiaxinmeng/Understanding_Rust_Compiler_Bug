{"sha": "b500d2591ea0080459d5dee127f63c010530f6b6", "node_id": "C_kwDOANBUbNoAKGI1MDBkMjU5MWVhMDA4MDQ1OWQ1ZGVlMTI3ZjYzYzAxMDUzMGY2YjY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-01-28T09:28:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-01-28T10:28:09Z"}, "message": "Make graph dumping work for fn != cfun\n\nThe following makes dumping of a function as graph work as intended\nwhen specifying a function other than cfun.  Unfortunately the loop\nand the dominance APIs are not set up to work for other functions\nthan cfun so you won't get any fancy loop dumps but the non-loop\ndump works up to reaching mark_dfs_back_edges which I trivially made\nfunction aware and adjusted current callers with a wrapper.\n\nWith all this, doing dot-fn id->src_cfun from the debugger when\ndebugging inlining works.  Previously you got a strange mix of\nthe src and dest functions visualized ;)\n\n2022-01-28  Richard Biener  <rguenther@suse.de>\n\n\t* cfganal.h (mark_dfs_back_edges): Provide API with struct\n\tfunction argument.\n\t* cfganal.cc (mark_dfs_back_edges): Take a struct function\n\tto work on, add a wrapper passing cfun.\n\t* graph.cc (draw_cfg_nodes_no_loops): Replace stray cfun\n\tuses with fun which is already passed.\n\t(draw_cfg_edges): Likewise.\n\t(draw_cfg_nodes_for_loop): Do not use draw_cfg_nodes_for_loop\n\tfor fun != cfun.", "tree": {"sha": "b386e601c3e57f56cab6d98d20eb523f71c06015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b386e601c3e57f56cab6d98d20eb523f71c06015"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b500d2591ea0080459d5dee127f63c010530f6b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b500d2591ea0080459d5dee127f63c010530f6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b500d2591ea0080459d5dee127f63c010530f6b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b500d2591ea0080459d5dee127f63c010530f6b6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16a3dea1d1bfa3dde556af84b3592140320b605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16a3dea1d1bfa3dde556af84b3592140320b605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16a3dea1d1bfa3dde556af84b3592140320b605"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "79c627a1716a008ab4205aaf3380c0ba744a8a43", "filename": "gcc/cfganal.cc", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fcfganal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fcfganal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.cc?ref=b500d2591ea0080459d5dee127f63c010530f6b6", "patch": "@@ -58,7 +58,7 @@ class depth_first_search\n    and heavily borrowed from pre_and_rev_post_order_compute.  */\n \n bool\n-mark_dfs_back_edges (void)\n+mark_dfs_back_edges (struct function *fun)\n {\n   int *pre;\n   int *post;\n@@ -67,20 +67,20 @@ mark_dfs_back_edges (void)\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n-  pre = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n-  post = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n+  pre = XCNEWVEC (int, last_basic_block_for_fn (fun));\n+  post = XCNEWVEC (int, last_basic_block_for_fn (fun));\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (fun) + 1);\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (fun));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs));\n+  stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (fun)->succs));\n \n   while (!stack.is_empty ())\n     {\n@@ -94,8 +94,8 @@ mark_dfs_back_edges (void)\n       ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun) && ! bitmap_bit_p (visited,\n-\t\t\t\t\t\t\t\t  dest->index))\n+      if (dest != EXIT_BLOCK_PTR_FOR_FN (fun) && ! bitmap_bit_p (visited,\n+\t\t\t\t\t\t\t\t dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  bitmap_set_bit (visited, dest->index);\n@@ -112,14 +112,14 @@ mark_dfs_back_edges (void)\n \t}\n       else\n \t{\n-\t  if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  if (dest != EXIT_BLOCK_PTR_FOR_FN (fun)\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (fun)\n \t      && pre[src->index] >= pre[dest->index]\n \t      && post[dest->index] == 0)\n \t    ei_edge (ei)->flags |= EDGE_DFS_BACK, found = true;\n \n \t  if (ei_one_before_end_p (ei)\n-\t      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (fun))\n \t    post[src->index] = postnum++;\n \n \t  if (!ei_one_before_end_p (ei))\n@@ -135,6 +135,12 @@ mark_dfs_back_edges (void)\n   return found;\n }\n \n+bool\n+mark_dfs_back_edges (void)\n+{\n+  return mark_dfs_back_edges (cfun);\n+}\n+\n /* Find unreachable blocks.  An unreachable block will have 0 in\n    the reachable bit in block->flags.  A nonzero value indicates the\n    block is reachable.  */"}, {"sha": "ac637de2b5aa6f84403707425ad042f9de76c095", "filename": "gcc/cfganal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=b500d2591ea0080459d5dee127f63c010530f6b6", "patch": "@@ -49,6 +49,7 @@ class control_dependences\n   bitmap_obstack m_bitmaps;\n };\n \n+extern bool mark_dfs_back_edges (struct function *);\n extern bool mark_dfs_back_edges (void);\n extern void find_unreachable_blocks (void);\n extern void verify_no_unreachable_blocks (void);"}, {"sha": "bc29862fcad231d5162d3af84d9ffe2227b02dee", "filename": "gcc/graph.cc", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b500d2591ea0080459d5dee127f63c010530f6b6/gcc%2Fgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.cc?ref=b500d2591ea0080459d5dee127f63c010530f6b6", "patch": "@@ -169,14 +169,14 @@ draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int i, n;\n \n-  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n+  auto_sbitmap visited (last_basic_block_for_fn (fun));\n   bitmap_clear (visited);\n \n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, true);\n   for (i = n_basic_blocks_for_fn (fun) - n;\n        i < n_basic_blocks_for_fn (fun); i++)\n     {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, rpo[i]);\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n       draw_cfg_node (pp, fun->funcdef_no, bb);\n       bitmap_set_bit (visited, bb->index);\n     }\n@@ -248,7 +248,8 @@ draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n static void\n draw_cfg_nodes (pretty_printer *pp, struct function *fun)\n {\n-  if (loops_for_fn (fun))\n+  /* ???  The loop and dominance APIs are dependent on fun == cfun.  */\n+  if (fun == cfun && loops_for_fn (fun))\n     draw_cfg_nodes_for_loop (pp, fun->funcdef_no, get_loop (fun, 0));\n   else\n     draw_cfg_nodes_no_loops (pp, fun);\n@@ -267,21 +268,21 @@ draw_cfg_edges (pretty_printer *pp, struct function *fun)\n   edge e;\n   edge_iterator ei;\n   unsigned int idx = 0;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n \tif (e->flags & EDGE_DFS_BACK)\n \t  bitmap_set_bit (dfs_back, idx);\n \tidx++;\n       }\n \n-  mark_dfs_back_edges ();\n-  FOR_ALL_BB_FN (bb, cfun)\n+  mark_dfs_back_edges (fun);\n+  FOR_ALL_BB_FN (bb, fun)\n     draw_cfg_node_succ_edges (pp, fun->funcdef_no, bb);\n \n   /* Restore EDGE_DFS_BACK flag from dfs_back.  */\n   idx = 0;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n \tif (bitmap_bit_p (dfs_back, idx))"}]}