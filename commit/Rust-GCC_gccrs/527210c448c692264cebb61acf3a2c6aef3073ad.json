{"sha": "527210c448c692264cebb61acf3a2c6aef3073ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3MjEwYzQ0OGM2OTIyNjRjZWJiNjFhY2YzYTJjNmFlZjMwNzNhZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-07-19T17:43:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-19T17:43:27Z"}, "message": "rtl.texi (MEM_OFFSET_KNOWN_P): Document.\n\ngcc/\n\t* doc/rtl.texi (MEM_OFFSET_KNOWN_P): Document.\n\t(MEM_OFFSET): Change from returning an rtx to returning a\n\tHOST_WIDE_INT.\n\t* rtl.h (MEM_OFFSET_KNOWN_P): New macro.\n\t(MEM_OFFSET): Return a HOST_WIDE_INT rather than an rtx.\n\t* emit-rtl.h (set_mem_offset): Take a HOST_WIDE_INT rather than an rtx.\n\t(clear_mem_offset): Declare.\n\t* alias.c (ao_ref_from_mem): Adjust uses of MEM_OFFSET, using\n\tMEM_OFFSET_KNOWN_P to test whether the offset is known, and\n\tMEM_OFFSET to get a HOST_WIDE_INT offset.\n\t(nonoverlapping_memrefs_p): Likewise.  Adjust calls to...\n\t(adjust_offset_for_component_ref): Take a bool \"known_p\"\n\tparameter and a HOST_WIDE_INT \"offset\" parameter.\n\t* builtins.c (get_memory_rtx): As for ao_ref_from_mem.\n\tAdjust calls to set_mem_offset, passing a HOST_WIDE_INT rather\n\tthan an rtx.  Use clear_mem_offset to clear the offset.\n\t* cfgcleanup.c (merge_memattrs): Likewise.\n\t* dwarf2out.c (tls_mem_loc_descriptor): Likewise.\n\t* function.c (assign_parm_find_stack_rtl): Likewise.\n\t(assign_parm_setup_stack): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* reload.c (find_reloads_subreg_address): Likewise.\n\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n\t* var-tracking.c (INT_MEM_OFFSET): Likewise.\n\t* emit-rtl.c (set_reg_attrs_from_value): Likewise.\n\t(get_mem_align_offset): Likewise.\n\t(set_mem_offset): Take a HOST_WIDE_INT rather than an rtx.\n\t(clear_mem_offset): New function.\n\t* config/mips/mips.c (r10k_safe_mem_expr_p): Take a HOST_WIDE_INT\n\toffset rather than an rtx.  Assume both the expressio and offset\n\tare available.\n\t(r10k_needs_protection_p_1): Update accordingly, checking the\n\texpression and offset availability here instead.\n\nFrom-SVN: r176477", "tree": {"sha": "dc0b299847e998d99b662b29fa6960f8e4d4b826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0b299847e998d99b662b29fa6960f8e4d4b826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/527210c448c692264cebb61acf3a2c6aef3073ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527210c448c692264cebb61acf3a2c6aef3073ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527210c448c692264cebb61acf3a2c6aef3073ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527210c448c692264cebb61acf3a2c6aef3073ad/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5541398efc0174bbdc40933be77747ad2000426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5541398efc0174bbdc40933be77747ad2000426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5541398efc0174bbdc40933be77747ad2000426"}], "stats": {"total": 228, "additions": 142, "deletions": 86}, "files": [{"sha": "d4bd6d765f66f18555f88bef88a7425d994a42ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -1,3 +1,39 @@\n+2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/rtl.texi (MEM_OFFSET_KNOWN_P): Document.\n+\t(MEM_OFFSET): Change from returning an rtx to returning a\n+\tHOST_WIDE_INT.\n+\t* rtl.h (MEM_OFFSET_KNOWN_P): New macro.\n+\t(MEM_OFFSET): Return a HOST_WIDE_INT rather than an rtx.\n+\t* emit-rtl.h (set_mem_offset): Take a HOST_WIDE_INT rather than an rtx.\n+\t(clear_mem_offset): Declare.\n+\t* alias.c (ao_ref_from_mem): Adjust uses of MEM_OFFSET, using\n+\tMEM_OFFSET_KNOWN_P to test whether the offset is known, and\n+\tMEM_OFFSET to get a HOST_WIDE_INT offset.\n+\t(nonoverlapping_memrefs_p): Likewise.  Adjust calls to...\n+\t(adjust_offset_for_component_ref): Take a bool \"known_p\"\n+\tparameter and a HOST_WIDE_INT \"offset\" parameter.\n+\t* builtins.c (get_memory_rtx): As for ao_ref_from_mem.\n+\tAdjust calls to set_mem_offset, passing a HOST_WIDE_INT rather\n+\tthan an rtx.  Use clear_mem_offset to clear the offset.\n+\t* cfgcleanup.c (merge_memattrs): Likewise.\n+\t* dwarf2out.c (tls_mem_loc_descriptor): Likewise.\n+\t* function.c (assign_parm_find_stack_rtl): Likewise.\n+\t(assign_parm_setup_stack): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* reload.c (find_reloads_subreg_address): Likewise.\n+\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n+\t* var-tracking.c (INT_MEM_OFFSET): Likewise.\n+\t* emit-rtl.c (set_reg_attrs_from_value): Likewise.\n+\t(get_mem_align_offset): Likewise.\n+\t(set_mem_offset): Take a HOST_WIDE_INT rather than an rtx.\n+\t(clear_mem_offset): New function.\n+\t* config/mips/mips.c (r10k_safe_mem_expr_p): Take a HOST_WIDE_INT\n+\toffset rather than an rtx.  Assume both the expressio and offset\n+\tare available.\n+\t(r10k_needs_protection_p_1): Update accordingly, checking the\n+\texpression and offset availability here instead.\n+\n 2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* doc/rtl.texi (MEM_SIZE_KNOWN_P): Document."}, {"sha": "ef624a1bfe44ca7ee49dc859550e27f1e8ecd832", "filename": "gcc/alias.c", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -162,7 +162,6 @@ static const_rtx fixed_scalar_and_varying_struct_p (const_rtx, const_rtx, rtx, r\n static int aliases_everything_p (const_rtx);\n static bool nonoverlapping_component_refs_p (const_tree, const_tree);\n static tree decl_for_component_ref (tree);\n-static rtx adjust_offset_for_component_ref (tree, rtx);\n static int write_dependence_p (const_rtx, const_rtx, int);\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n@@ -315,7 +314,7 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n \n   /* If MEM_OFFSET or MEM_SIZE are unknown we have to punt.\n      Keep points-to related information though.  */\n-  if (!MEM_OFFSET (mem)\n+  if (!MEM_OFFSET_KNOWN_P (mem)\n       || !MEM_SIZE_KNOWN_P (mem))\n     {\n       ref->ref = NULL_TREE;\n@@ -328,12 +327,11 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n   /* If the base decl is a parameter we can have negative MEM_OFFSET in\n      case of promoted subregs on bigendian targets.  Trust the MEM_EXPR\n      here.  */\n-  if (INTVAL (MEM_OFFSET (mem)) < 0\n-      && ((MEM_SIZE (mem) + INTVAL (MEM_OFFSET (mem)))\n-\t  * BITS_PER_UNIT) == ref->size)\n+  if (MEM_OFFSET (mem) < 0\n+      && (MEM_SIZE (mem) + MEM_OFFSET (mem)) * BITS_PER_UNIT == ref->size)\n     return true;\n \n-  ref->offset += INTVAL (MEM_OFFSET (mem)) * BITS_PER_UNIT;\n+  ref->offset += MEM_OFFSET (mem) * BITS_PER_UNIT;\n   ref->size = MEM_SIZE (mem) * BITS_PER_UNIT;\n \n   /* The MEM may extend into adjacent fields, so adjust max_size if\n@@ -2201,34 +2199,33 @@ decl_for_component_ref (tree x)\n   return x && DECL_P (x) ? x : NULL_TREE;\n }\n \n-/* Walk up the COMPONENT_REF list and adjust OFFSET to compensate for the\n-   offset of the field reference.  */\n+/* Walk up the COMPONENT_REF list in X and adjust *OFFSET to compensate\n+   for the offset of the field reference.  *KNOWN_P says whether the\n+   offset is known.  */\n \n-static rtx\n-adjust_offset_for_component_ref (tree x, rtx offset)\n+static void\n+adjust_offset_for_component_ref (tree x, bool *known_p,\n+\t\t\t\t HOST_WIDE_INT *offset)\n {\n-  HOST_WIDE_INT ioffset;\n-\n-  if (! offset)\n-    return NULL_RTX;\n-\n-  ioffset = INTVAL (offset);\n+  if (!*known_p)\n+    return;\n   do\n     {\n-      tree offset = component_ref_field_offset (x);\n+      tree xoffset = component_ref_field_offset (x);\n       tree field = TREE_OPERAND (x, 1);\n \n-      if (! host_integerp (offset, 1))\n-\treturn NULL_RTX;\n-      ioffset += (tree_low_cst (offset, 1)\n+      if (! host_integerp (xoffset, 1))\n+\t{\n+\t  *known_p = false;\n+\t  return;\n+\t}\n+      *offset += (tree_low_cst (xoffset, 1)\n \t\t  + (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n \t\t     / BITS_PER_UNIT));\n \n       x = TREE_OPERAND (x, 0);\n     }\n   while (x && TREE_CODE (x) == COMPONENT_REF);\n-\n-  return GEN_INT (ioffset);\n }\n \n /* Return nonzero if we can determine the exprs corresponding to memrefs\n@@ -2241,7 +2238,8 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n   tree exprx = MEM_EXPR (x), expry = MEM_EXPR (y);\n   rtx rtlx, rtly;\n   rtx basex, basey;\n-  rtx moffsetx, moffsety;\n+  bool moffsetx_known_p, moffsety_known_p;\n+  HOST_WIDE_INT moffsetx = 0, moffsety = 0;\n   HOST_WIDE_INT offsetx = 0, offsety = 0, sizex, sizey, tem;\n \n   /* Unless both have exprs, we can't tell anything.  */\n@@ -2250,9 +2248,9 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n \n   /* For spill-slot accesses make sure we have valid offsets.  */\n   if ((exprx == get_spill_slot_decl (false)\n-       && ! MEM_OFFSET (x))\n+       && ! MEM_OFFSET_KNOWN_P (x))\n       || (expry == get_spill_slot_decl (false)\n-\t  && ! MEM_OFFSET (y)))\n+\t  && ! MEM_OFFSET_KNOWN_P (y)))\n     return 0;\n \n   /* If both are field references, we may be able to determine something.  */\n@@ -2263,23 +2261,27 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n \n \n   /* If the field reference test failed, look at the DECLs involved.  */\n-  moffsetx = MEM_OFFSET (x);\n+  moffsetx_known_p = MEM_OFFSET_KNOWN_P (x);\n+  if (moffsetx_known_p)\n+    moffsetx = MEM_OFFSET (x);\n   if (TREE_CODE (exprx) == COMPONENT_REF)\n     {\n       tree t = decl_for_component_ref (exprx);\n       if (! t)\n \treturn 0;\n-      moffsetx = adjust_offset_for_component_ref (exprx, moffsetx);\n+      adjust_offset_for_component_ref (exprx, &moffsetx_known_p, &moffsetx);\n       exprx = t;\n     }\n \n-  moffsety = MEM_OFFSET (y);\n+  moffsety_known_p = MEM_OFFSET_KNOWN_P (y);\n+  if (moffsety_known_p)\n+    moffsety = MEM_OFFSET (y);\n   if (TREE_CODE (expry) == COMPONENT_REF)\n     {\n       tree t = decl_for_component_ref (expry);\n       if (! t)\n \treturn 0;\n-      moffsety = adjust_offset_for_component_ref (expry, moffsety);\n+      adjust_offset_for_component_ref (expry, &moffsety_known_p, &moffsety);\n       expry = t;\n     }\n \n@@ -2346,17 +2348,17 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n \n   /* If we have an offset for either memref, it can update the values computed\n      above.  */\n-  if (moffsetx)\n-    offsetx += INTVAL (moffsetx), sizex -= INTVAL (moffsetx);\n-  if (moffsety)\n-    offsety += INTVAL (moffsety), sizey -= INTVAL (moffsety);\n+  if (moffsetx_known_p)\n+    offsetx += moffsetx, sizex -= moffsetx;\n+  if (moffsety_known_p)\n+    offsety += moffsety, sizey -= moffsety;\n \n   /* If a memref has both a size and an offset, we can use the smaller size.\n      We can't do this if the offset isn't known because we must view this\n      memref as being anywhere inside the DECL's MEM.  */\n-  if (MEM_SIZE_KNOWN_P (x) && moffsetx)\n+  if (MEM_SIZE_KNOWN_P (x) && moffsetx_known_p)\n     sizex = MEM_SIZE (x);\n-  if (MEM_SIZE_KNOWN_P (y) && moffsety)\n+  if (MEM_SIZE_KNOWN_P (y) && moffsety_known_p)\n     sizey = MEM_SIZE (y);\n \n   /* Put the values of the memref with the lower offset in X's values.  */"}, {"sha": "afe1ed05a2f870085bd5e7a97e724b1fd65c81aa", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -1238,9 +1238,8 @@ get_memory_rtx (tree exp, tree len)\n \n \t  gcc_assert (TREE_CODE (inner) == COMPONENT_REF);\n \n-\t  if (MEM_OFFSET (mem)\n-\t      && CONST_INT_P (MEM_OFFSET (mem)))\n-\t    offset = INTVAL (MEM_OFFSET (mem));\n+\t  if (MEM_OFFSET_KNOWN_P (mem))\n+\t    offset = MEM_OFFSET (mem);\n \n \t  if (offset >= 0 && len && host_integerp (len, 0))\n \t    length = tree_low_cst (len, 0);\n@@ -1295,7 +1294,10 @@ get_memory_rtx (tree exp, tree len)\n \t  if (mem_expr != MEM_EXPR (mem))\n \t    {\n \t      set_mem_expr (mem, mem_expr);\n-\t      set_mem_offset (mem, offset >= 0 ? GEN_INT (offset) : NULL_RTX);\n+\t      if (offset >= 0)\n+\t\tset_mem_offset (mem, offset);\n+\t      else\n+\t\tclear_mem_offset (mem);\n \t    }\n \t}\n       set_mem_alias_set (mem, 0);"}, {"sha": "7f72e6834826a2ed098c54fcb58b18174e8db515", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -895,13 +895,15 @@ merge_memattrs (rtx x, rtx y)\n \t    {\n \t      set_mem_expr (x, 0);\n \t      set_mem_expr (y, 0);\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n+\t      clear_mem_offset (x);\n+\t      clear_mem_offset (y);\n \t    }\n-\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n+\t  else if (MEM_OFFSET_KNOWN_P (x) != MEM_OFFSET_KNOWN_P (y)\n+\t\t   || (MEM_OFFSET_KNOWN_P (x)\n+\t\t       && MEM_OFFSET (x) != MEM_OFFSET (y)))\n \t    {\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n+\t      clear_mem_offset (x);\n+\t      clear_mem_offset (y);\n \t    }\n \n \t  if (MEM_SIZE_KNOWN_P (x) && MEM_SIZE_KNOWN_P (y))"}, {"sha": "89371734d4e5de22563c7340cdd9b962dac58d43", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -13765,13 +13765,9 @@ r10k_safe_address_p (rtx x, rtx insn)\n    a link-time-constant address.  */\n \n static bool\n-r10k_safe_mem_expr_p (tree expr, rtx offset)\n+r10k_safe_mem_expr_p (tree expr, HOST_WIDE_INT offset)\n {\n-  if (expr == NULL_TREE\n-      || offset == NULL_RTX\n-      || !CONST_INT_P (offset)\n-      || INTVAL (offset) < 0\n-      || INTVAL (offset) >= int_size_in_bytes (TREE_TYPE (expr)))\n+  if (offset < 0 || offset >= int_size_in_bytes (TREE_TYPE (expr)))\n     return false;\n \n   while (TREE_CODE (expr) == COMPONENT_REF)\n@@ -13797,7 +13793,9 @@ r10k_needs_protection_p_1 (rtx *loc, void *data)\n   if (!MEM_P (mem))\n     return 0;\n \n-  if (r10k_safe_mem_expr_p (MEM_EXPR (mem), MEM_OFFSET (mem)))\n+  if (MEM_EXPR (mem)\n+      && MEM_OFFSET_KNOWN_P (mem)\n+      && r10k_safe_mem_expr_p (MEM_EXPR (mem), MEM_OFFSET (mem)))\n     return -1;\n \n   if (r10k_safe_address_p (XEXP (mem, 0), (rtx) data))"}, {"sha": "0d60594e38eeeba9959fef89f915d2a27e35a4b1", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -409,9 +409,15 @@ and @code{TREE_OPERAND (@var{x}, 0)} contains the declaration,\n or another @code{COMPONENT_REF}, or null if there is no compile-time\n object associated with the reference.\n \n+@findex MEM_OFFSET_KNOWN_P\n+@item MEM_OFFSET_KNOWN_P (@var{x})\n+True if the offset of the memory reference from @code{MEM_EXPR} is known.\n+@samp{MEM_OFFSET (@var{x})} provides the offset if so.\n+\n @findex MEM_OFFSET\n @item MEM_OFFSET (@var{x})\n-The offset from the start of @code{MEM_EXPR} as a @code{CONST_INT} rtx.\n+The offset from the start of @code{MEM_EXPR}.  The value is only valid if\n+@samp{MEM_OFFSET_KNOWN_P (@var{x})} is true.\n \n @findex MEM_SIZE_KNOWN_P\n @item MEM_SIZE_KNOWN_P (@var{x})"}, {"sha": "6046ba9c6ab1961d27552ed758d7f2ec64f5d9b4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -10453,7 +10453,7 @@ tls_mem_loc_descriptor (rtx mem)\n   tree base;\n   dw_loc_descr_ref loc_result;\n \n-  if (MEM_EXPR (mem) == NULL_TREE || MEM_OFFSET (mem) == NULL_RTX)\n+  if (MEM_EXPR (mem) == NULL_TREE || !MEM_OFFSET_KNOWN_P (mem))\n     return NULL;\n \n   base = get_base_address (MEM_EXPR (mem));\n@@ -10466,8 +10466,8 @@ tls_mem_loc_descriptor (rtx mem)\n   if (loc_result == NULL)\n     return NULL;\n \n-  if (INTVAL (MEM_OFFSET (mem)))\n-    loc_descr_plus_const (&loc_result, INTVAL (MEM_OFFSET (mem)));\n+  if (MEM_OFFSET (mem))\n+    loc_descr_plus_const (&loc_result, MEM_OFFSET (mem));\n \n   return loc_result;\n }"}, {"sha": "fd1e5dbe6c34241bf61012044d7f943358035ad5", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -969,9 +969,9 @@ set_reg_attrs_from_value (rtx reg, rtx x)\n   offset = byte_lowpart_offset (GET_MODE (reg), GET_MODE (x));\n   if (MEM_P (x))\n     {\n-      if (MEM_OFFSET (x) && CONST_INT_P (MEM_OFFSET (x)))\n-\tREG_ATTRS (reg)\n-\t  = get_reg_attrs (MEM_EXPR (x), INTVAL (MEM_OFFSET (x)) + offset);\n+      if (MEM_OFFSET_KNOWN_P (x))\n+\tREG_ATTRS (reg) = get_reg_attrs (MEM_EXPR (x),\n+\t\t\t\t\t MEM_OFFSET (x) + offset);\n       if (MEM_POINTER (x))\n \tmark_reg_pointer (reg, 0);\n     }\n@@ -1460,14 +1460,13 @@ get_mem_align_offset (rtx mem, unsigned int align)\n   unsigned HOST_WIDE_INT offset;\n \n   /* This function can't use\n-     if (!MEM_EXPR (mem) || !MEM_OFFSET (mem)\n-\t || !CONST_INT_P (MEM_OFFSET (mem))\n+     if (!MEM_EXPR (mem) || !MEM_OFFSET_KNOWN_P (mem)\n \t || (MAX (MEM_ALIGN (mem),\n \t          get_object_alignment (MEM_EXPR (mem), align))\n \t     < align))\n        return -1;\n      else\n-       return (- INTVAL (MEM_OFFSET (mem))) & (align / BITS_PER_UNIT - 1);\n+       return (- MEM_OFFSET (mem)) & (align / BITS_PER_UNIT - 1);\n      for two reasons:\n      - COMPONENT_REFs in MEM_EXPR can have NULL first operand,\n        for <variable>.  get_inner_reference doesn't handle it and\n@@ -1477,12 +1476,10 @@ get_mem_align_offset (rtx mem, unsigned int align)\n        isn't sufficiently aligned, the object it is in might be.  */\n   gcc_assert (MEM_P (mem));\n   expr = MEM_EXPR (mem);\n-  if (expr == NULL_TREE\n-      || MEM_OFFSET (mem) == NULL_RTX\n-      || !CONST_INT_P (MEM_OFFSET (mem)))\n+  if (expr == NULL_TREE || !MEM_OFFSET_KNOWN_P (mem))\n     return -1;\n \n-  offset = INTVAL (MEM_OFFSET (mem));\n+  offset = MEM_OFFSET (mem);\n   if (DECL_P (expr))\n     {\n       if (DECL_ALIGN (expr) < align)\n@@ -1901,12 +1898,24 @@ set_mem_expr (rtx mem, tree expr)\n /* Set the offset of MEM to OFFSET.  */\n \n void\n-set_mem_offset (rtx mem, rtx offset)\n+set_mem_offset (rtx mem, HOST_WIDE_INT offset)\n {\n   struct mem_attrs attrs;\n \n   attrs = *get_mem_attrs (mem);\n-  attrs.offset = offset;\n+  attrs.offset = GEN_INT (offset);\n+  set_mem_attrs (mem, &attrs);\n+}\n+\n+/* Clear the offset of MEM.  */\n+\n+void\n+clear_mem_offset (rtx mem)\n+{\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.offset = NULL_RTX;\n   set_mem_attrs (mem, &attrs);\n }\n "}, {"sha": "bc91193fb62a849fa7949f7aaaa67042d554196c", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -33,7 +33,10 @@ extern void set_mem_addr_space (rtx, addr_space_t);\n extern void set_mem_expr (rtx, tree);\n \n /* Set the offset for MEM to OFFSET.  */\n-extern void set_mem_offset (rtx, rtx);\n+extern void set_mem_offset (rtx, HOST_WIDE_INT);\n+\n+/* Clear the offset recorded for MEM.  */\n+extern void clear_mem_offset (rtx);\n \n /* Set the size for MEM to SIZE.  */\n extern void set_mem_size (rtx, HOST_WIDE_INT);"}, {"sha": "361a8dce19737a146d900cba1dc679c211e138fd", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -2577,14 +2577,12 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n \t  && data->promoted_mode != DECL_MODE (parm))\n \t{\n \t  set_mem_size (stack_parm, GET_MODE_SIZE (data->promoted_mode));\n-\t  if (MEM_EXPR (stack_parm) && MEM_OFFSET (stack_parm))\n+\t  if (MEM_EXPR (stack_parm) && MEM_OFFSET_KNOWN_P (stack_parm))\n \t    {\n \t      int offset = subreg_lowpart_offset (DECL_MODE (parm),\n \t\t\t\t\t\t  data->promoted_mode);\n \t      if (offset)\n-\t\tset_mem_offset (stack_parm,\n-\t\t\t\tplus_constant (MEM_OFFSET (stack_parm),\n-\t\t\t\t\t       -offset));\n+\t\tset_mem_offset (stack_parm, MEM_OFFSET (stack_parm) - offset);\n \t    }\n \t}\n     }\n@@ -3198,10 +3196,9 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t  /* ??? This may need a big-endian conversion on sparc64.  */\n \t  data->stack_parm\n \t    = adjust_address (data->stack_parm, data->nominal_mode, 0);\n-\t  if (offset && MEM_OFFSET (data->stack_parm))\n+\t  if (offset && MEM_OFFSET_KNOWN_P (data->stack_parm))\n \t    set_mem_offset (data->stack_parm,\n-\t\t\t    plus_constant (MEM_OFFSET (data->stack_parm),\n-\t\t\t\t\t   offset));\n+\t\t\t    MEM_OFFSET (data->stack_parm) + offset);\n \t}\n     }\n "}, {"sha": "8e80630fbb363125871613285f09cc3ca7318317", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -597,9 +597,8 @@ print_rtx (const_rtx in_rtx)\n       if (MEM_EXPR (in_rtx))\n \tprint_mem_expr (outfile, MEM_EXPR (in_rtx));\n \n-      if (MEM_OFFSET (in_rtx))\n-\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t INTVAL (MEM_OFFSET (in_rtx)));\n+      if (MEM_OFFSET_KNOWN_P (in_rtx))\n+\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC, MEM_OFFSET (in_rtx));\n \n       if (MEM_SIZE_KNOWN_P (in_rtx))\n \tfprintf (outfile, \" S\" HOST_WIDE_INT_PRINT_DEC, MEM_SIZE (in_rtx));"}, {"sha": "b5e991e386da3c53579de75137bb6f6a504d6fb3", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -6137,8 +6137,8 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \n \t      XEXP (tem, 0) = plus_constant (XEXP (tem, 0), offset);\n \t      PUT_MODE (tem, GET_MODE (x));\n-\t      if (MEM_OFFSET (tem))\n-\t\tset_mem_offset (tem, plus_constant (MEM_OFFSET (tem), offset));\n+\t      if (MEM_OFFSET_KNOWN_P (tem))\n+\t\tset_mem_offset (tem, MEM_OFFSET (tem) + offset);\n \t      if (MEM_SIZE_KNOWN_P (tem)\n \t\t  && MEM_SIZE (tem) != (HOST_WIDE_INT) outer_size)\n \t\tset_mem_size (tem, outer_size);"}, {"sha": "2ef6d1e32aaa88ac4d7cf4c430624687d64cc411", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -1302,9 +1302,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n    refer to part of a DECL.  It may also be a COMPONENT_REF.  */\n #define MEM_EXPR(RTX) (get_mem_attrs (RTX)->expr)\n \n-/* For a MEM rtx, the offset from the start of MEM_EXPR, if known, as a\n-   RTX that is always a CONST_INT.  */\n-#define MEM_OFFSET(RTX) (get_mem_attrs (RTX)->offset)\n+/* For a MEM rtx, true if its MEM_OFFSET is known.  */\n+#define MEM_OFFSET_KNOWN_P(RTX) (get_mem_attrs (RTX)->offset != NULL_RTX)\n+\n+/* For a MEM rtx, the offset from the start of MEM_EXPR.  */\n+#define MEM_OFFSET(RTX) INTVAL (get_mem_attrs (RTX)->offset)\n \n /* For a MEM rtx, the address space.  */\n #define MEM_ADDR_SPACE(RTX) (get_mem_attrs (RTX)->addrspace)"}, {"sha": "2d7d8dd03f9c80f4587c246c980b657ed26bdba7", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -268,7 +268,7 @@ delegitimize_mem_from_attrs (rtx x)\n      use their base addresses as equivalent.  */\n   if (MEM_P (x)\n       && MEM_EXPR (x)\n-      && MEM_OFFSET (x))\n+      && MEM_OFFSET_KNOWN_P (x))\n     {\n       tree decl = MEM_EXPR (x);\n       enum machine_mode mode = GET_MODE (x);\n@@ -321,7 +321,7 @@ delegitimize_mem_from_attrs (rtx x)\n \t{\n \t  rtx newx;\n \n-\t  offset += INTVAL (MEM_OFFSET (x));\n+\t  offset += MEM_OFFSET (x);\n \n \t  newx = DECL_RTL (decl);\n "}, {"sha": "d5a45483ab707478a1b2ee2ec91d616d5aa7b34e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527210c448c692264cebb61acf3a2c6aef3073ad/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=527210c448c692264cebb61acf3a2c6aef3073ad", "patch": "@@ -365,7 +365,7 @@ typedef const struct value_chain_def *const_value_chain;\n #define VTI(BB) ((variable_tracking_info) (BB)->aux)\n \n /* Macro to access MEM_OFFSET as an HOST_WIDE_INT.  Evaluates MEM twice.  */\n-#define INT_MEM_OFFSET(mem) (MEM_OFFSET (mem) ? INTVAL (MEM_OFFSET (mem)) : 0)\n+#define INT_MEM_OFFSET(mem) (MEM_OFFSET_KNOWN_P (mem) ? MEM_OFFSET (mem) : 0)\n \n /* Alloc pool for struct attrs_def.  */\n static alloc_pool attrs_pool;"}]}