{"sha": "0881653ce25559ff10a7f8d5832f8d120eb27568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4MTY1M2NlMjU1NTlmZjEwYTdmOGQ1ODMyZjhkMTIwZWIyNzU2OA==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2007-05-17T12:37:24Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2007-05-17T12:37:24Z"}, "message": "re PR fortran/31919 ([4.1/4.2 only] min/max do not check array conformance)\n\ngcc/fortran:\n2007-05-15  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/31919\n        PR fortran/31929\n        PR fortran/31930\n        * intrinsic.c (check_specific): Check elemental intrinsics for\n        rank and shape.\n        (add_functions): Fixed dummy argument names of BESJN and BESYN.\n        Fixed elemental status of MCLOCK and MCLOCK8.\n        * check.c (check_rest): Added check for array conformance.\n        (gfc_check_merge): Removed check for array conformance.\n        (gfc_check_besn): Removed check for scalarity.\n        * intrinsic.texi (CSHIFT, EOSHIFT): Fixed typos.\n        (BESJN, BESYN): Clarified documentation.\n\ngcc/testsuite:\n2007-05-17  Daniel Franke <franke.daniel@gmail.com>\n\n        PR fortran/31919\n        * gfortran.dg/min_max_conformance.f90: New test.\n\nFrom-SVN: r124794", "tree": {"sha": "78925dedfbc44cc11059cf1caff2dd802bb42629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78925dedfbc44cc11059cf1caff2dd802bb42629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0881653ce25559ff10a7f8d5832f8d120eb27568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0881653ce25559ff10a7f8d5832f8d120eb27568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0881653ce25559ff10a7f8d5832f8d120eb27568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0881653ce25559ff10a7f8d5832f8d120eb27568/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4e6a80f678161b6882c73375be2804402a39211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4e6a80f678161b6882c73375be2804402a39211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4e6a80f678161b6882c73375be2804402a39211"}], "stats": {"total": 148, "additions": 98, "deletions": 50}, "files": [{"sha": "dbd2cc85136a8992b0165e4e45e2aa0524b50ee6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -1,3 +1,18 @@\n+2007-05-15  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/31919\n+\tPR fortran/31929\n+\tPR fortran/31930\n+\t* intrinsic.c (check_specific): Check elemental intrinsics for\n+\trank and shape.\n+\t(add_functions): Fixed dummy argument names of BESJN and BESYN.\n+\tFixed elemental status of MCLOCK and MCLOCK8.\n+\t* check.c (check_rest): Added check for array conformance.\n+\t(gfc_check_merge): Removed check for array conformance.\n+\t(gfc_check_besn): Removed check for scalarity.\n+\t* intrinsic.texi (CSHIFT, EOSHIFT): Fixed typos.\n+\t(BESJN, BESYN): Clarified documentation.\n+\n 2007-05-17  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi (GFORTRAN_CONVERT_UNIT): Improve documentation."}, {"sha": "4c0a5920b55b9217601b1642a2c577f892e19e78", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -649,9 +649,6 @@ gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n try\n gfc_check_besn (gfc_expr *n, gfc_expr *x)\n {\n-  if (scalar_check (n, 0) == FAILURE)\n-    return FAILURE;\n-\n   if (type_check (n, 0, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n@@ -1491,14 +1488,16 @@ min_max_args (gfc_actual_arglist *arg)\n static try\n check_rest (bt type, int kind, gfc_actual_arglist *arg)\n {\n-  gfc_expr *x;\n+  gfc_expr *x, *first_arg;\n   int n;\n+  char buffer[80];\n \n   if (min_max_args (arg) == FAILURE)\n     return FAILURE;\n \n   n = 1;\n \n+  first_arg = arg->expr;\n   for (; arg; arg = arg->next, n++)\n     {\n       x = arg->expr;\n@@ -1518,6 +1517,12 @@ check_rest (bt type, int kind, gfc_actual_arglist *arg)\n \t      return FAILURE;\n \t    }\n \t}\n+\n+      snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[n-1],\n+\t\tgfc_current_intrinsic);\n+      if (gfc_check_conformance (buffer, first_arg, x) == FAILURE)\n+        return FAILURE;\n     }\n \n   return SUCCESS;\n@@ -1797,26 +1802,12 @@ gfc_check_product_sum (gfc_actual_arglist *ap)\n try\n gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {\n-  char buffer[80];\n-\n   if (same_type_check (tsource, 0, fsource, 1) == FAILURE)\n     return FAILURE;\n \n   if (type_check (mask, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n-  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n-\t    gfc_current_intrinsic);\n-  if (gfc_check_conformance (buffer, tsource, fsource) == FAILURE)\n-    return FAILURE;\n-\n-  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n-\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n-\t    gfc_current_intrinsic);\n-  if (gfc_check_conformance (buffer, tsource, mask) == FAILURE)\n-    return FAILURE;\n-\n   return SUCCESS;\n }\n "}, {"sha": "d64f77f94faddf48376fd5f9dfff76e4b442e44b", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -896,7 +896,7 @@ add_functions (void)\n   const char\n     *a = \"a\", *f = \"field\", *pt = \"pointer\", *tg = \"target\",\n     *b = \"b\", *m = \"matrix\", *ma = \"matrix_a\", *mb = \"matrix_b\",\n-    *c = \"c\", *n = \"ncopies\", *pos = \"pos\", *bck = \"back\",\n+    *c = \"c\", *n = \"n\", *ncopies= \"ncopies\", *pos = \"pos\", *bck = \"back\",\n     *i = \"i\", *v = \"vector\", *va = \"vector_a\", *vb = \"vector_b\",\n     *j = \"j\", *a1 = \"a1\", *fs = \"fsource\", *ts = \"tsource\",\n     *l = \"l\", *a2 = \"a2\", *mo = \"mold\", *ord = \"order\",\n@@ -1819,12 +1819,12 @@ add_functions (void)\n \n   make_generic (\"maxval\", GFC_ISYM_MAXVAL, GFC_STD_F95);\n \n-  add_sym_0 (\"mclock\", ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n+  add_sym_0 (\"mclock\", NOT_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_mclock);\n \n   make_generic (\"mclock\", GFC_ISYM_MCLOCK, GFC_STD_GNU);\n \n-  add_sym_0 (\"mclock8\", ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n+  add_sym_0 (\"mclock8\", NOT_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_mclock8);\n \n   make_generic (\"mclock8\", GFC_ISYM_MCLOCK8, GFC_STD_GNU);\n@@ -2013,7 +2013,7 @@ add_functions (void)\n   \n   add_sym_2 (\"repeat\", NOT_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_F95,\n \t     gfc_check_repeat, gfc_simplify_repeat, gfc_resolve_repeat,\n-\t     stg, BT_CHARACTER, dc, REQUIRED, n, BT_INTEGER, di, REQUIRED);\n+\t     stg, BT_CHARACTER, dc, REQUIRED, ncopies, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"repeat\", GFC_ISYM_REPEAT, GFC_STD_F95);\n \n@@ -2147,7 +2147,7 @@ add_functions (void)\n   add_sym_3 (\"spread\", NOT_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_spread, NULL, gfc_resolve_spread,\n \t     src, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, REQUIRED,\n-\t     n, BT_INTEGER, di, REQUIRED);\n+\t     ncopies, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"spread\", GFC_ISYM_SPREAD, GFC_STD_F95);\n \n@@ -3201,7 +3201,6 @@ static try\n check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n {\n   gfc_actual_arglist *arg, **ap;\n-  int r;\n   try t;\n \n   ap = &expr->value.function.actual;\n@@ -3242,26 +3241,25 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n \t t = do_check (specific, *ap);\n      }\n \n-  /* Check ranks for elemental intrinsics.  */\n+  /* Check conformance of elemental intrinsics.  */\n   if (t == SUCCESS && specific->elemental)\n     {\n-      r = 0;\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (arg->expr == NULL || arg->expr->rank == 0)\n-\t    continue;\n-\t  if (r == 0)\n-\t    {\n-\t      r = arg->expr->rank;\n-\t      continue;\n-\t    }\n+      int n = 0;\n+      gfc_expr *first_expr;\n+      arg = expr->value.function.actual;\n \n-\t  if (arg->expr->rank != r)\n-\t    {\n-\t      gfc_error (\"Ranks of arguments to elemental intrinsic '%s' \"\n-\t\t\t \"differ at %L\", specific->name, &arg->expr->where);\n-\t      return FAILURE;\n-\t    }\n+      /* There is no elemental intrinsic without arguments.  */\n+      gcc_assert(arg != NULL);\n+      first_expr = arg->expr;\n+\n+      for ( ; arg && arg->expr; arg = arg->next, n++)\n+\t{\n+          char buffer[80];\n+\t  snprintf (buffer, 80, \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t\t    gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[n],\n+\t\t    gfc_current_intrinsic);\n+\t  if (gfc_check_conformance (buffer, first_expr, arg->expr) == FAILURE)\n+\t    return FAILURE;\n \t}\n     }\n "}, {"sha": "52d09fba526d5c36c7265fa55222afa11ca1ce0b", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -1575,6 +1575,8 @@ end program test_besj1\n @code{BESJN(N, X)} computes the Bessel function of the first kind of order\n @var{N} of @var{X}.\n \n+If both arguments are arrays, their ranks and shapes shall conform.\n+\n @item @emph{Standard}:\n GNU extension\n \n@@ -1586,8 +1588,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER(*)}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1712,6 +1714,8 @@ end program test_besy1\n @code{BESYN(N, X)} computes the Bessel function of the second kind of order\n @var{N} of @var{X}.\n \n+If both arguments are arrays, their ranks and shapes shall conform.\n+\n @item @emph{Standard}:\n GNU extension\n \n@@ -1723,8 +1727,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{N} @tab The type shall be @code{INTEGER(*)}, and it shall be scalar.\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER(*)}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL(*)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -2487,14 +2491,14 @@ shifted out one end of each rank one section are shifted back in the other end.\n F95 and later\n \n @item @emph{Class}:\n-transformational function\n+Transformational function\n \n @item @emph{Syntax}:\n-@code{RESULT = CSHIFT(A, SHIFT [, DIM])}\n+@code{RESULT = CSHIFT(ARRAY, SHIFT [, DIM])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY}  @tab May be any type, not scaler.\n+@item @var{ARRAY}  @tab Shall be an array of any type.\n @item @var{SHIFT}  @tab The type shall be @code{INTEGER}.\n @item @var{DIM}    @tab The type shall be @code{INTEGER}.\n @end multitable\n@@ -3120,10 +3124,10 @@ following are copied in depending on the type of @var{ARRAY}.\n F95 and later\n \n @item @emph{Class}:\n-transformational function\n+Transformational function\n \n @item @emph{Syntax}:\n-@code{RESULT = EOSHIFT(A, SHIFT [, BOUNDARY, DIM])}\n+@code{RESULT = EOSHIFT(ARRAY, SHIFT [, BOUNDARY, DIM])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70"}, {"sha": "a78f6753b557e5d88110dece8aa318203d1808d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -1,3 +1,8 @@\n+2007-05-17  Daniel Franke <franke.daniel@gmail.com>\n+\n+\tPR fortran/31919\n+\t* gfortran.dg/min_max_conformance.f90: New test.\n+\n 2007-05-17  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/ssa-dom-thread-2.c: New test."}, {"sha": "565408cd26a69f8fad05e4b0114b92aa6b631575", "filename": "gcc/testsuite/gfortran.dg/min_max_conformance.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_conformance.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0881653ce25559ff10a7f8d5832f8d120eb27568/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_conformance.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_conformance.f90?ref=0881653ce25559ff10a7f8d5832f8d120eb27568", "patch": "@@ -0,0 +1,35 @@\n+! { dg-compile }\n+! PR 31919:  Tests for different ranks in min/max were missing.\n+program pr31919\n+  integer :: i4a(2, 2), i4b(2), i4c(4)\n+  real(4) :: r4a(2, 2), r4b(2), r4c(4)\n+  real(8) :: r8a(2, 2), r8b(2), r8c(4)\n+\n+  i4a = max(i4a, i4b)            ! { dg-error \"Incompatible ranks\" }\n+  i4a = max0(i4a, i4b)           ! { dg-error \"Incompatible ranks\" }\n+  r4a = amax0(i4a, i4b)          ! { dg-error \"Incompatible ranks\" }\n+  i4a = max1(r4a, r4b)           ! { dg-error \"Incompatible ranks\" }\n+  r4a = amax1(r4a, r4b)          ! { dg-error \"Incompatible ranks\" }\n+  r8a = dmax1(r8a, r8b)          ! { dg-error \"Incompatible ranks\" }\n+\n+  i4a = min(i4a, i4b)            ! { dg-error \"Incompatible ranks\" }\n+  i4a = min0(i4a, i4b)           ! { dg-error \"Incompatible ranks\" }\n+  i4a = amin0(i4a, i4b)          ! { dg-error \"Incompatible ranks\" }\n+  r4a = min1(r4a, r4b)           ! { dg-error \"Incompatible ranks\" }\n+  r4a = amin1(r4a, r4b)          ! { dg-error \"Incompatible ranks\" }\n+  r8a = dmin1(r8a, r8b)          ! { dg-error \"Incompatible ranks\" }\n+\n+  i4a = max(i4b, i4c)            ! { dg-error \"different shape for arguments\" }\n+  i4a = max0(i4b, i4c)           ! { dg-error \"different shape for arguments\" }\n+  r4a = amax0(i4b, i4c)          ! { dg-error \"different shape for arguments\" }\n+  i4a = max1(r4b, r4c)           ! { dg-error \"different shape for arguments\" }\n+  r4a = amax1(r4b, r4c)          ! { dg-error \"different shape for arguments\" }\n+  r8a = dmax1(r8B, r8c)          ! { dg-error \"different shape for arguments\" }\n+\n+  i4a = min(i4b, i4c)            ! { dg-error \"different shape for arguments\" }\n+  i4a = min0(i4b, i4c)           ! { dg-error \"different shape for arguments\" }\n+  i4a = amin0(i4b, i4c)          ! { dg-error \"different shape for arguments\" }\n+  r4a = min1(r4b, r4c)           ! { dg-error \"different shape for arguments\" }\n+  r4a = amin1(r4b, r4c)          ! { dg-error \"different shape for arguments\" }\n+  r8a = dmin1(r8b, r8c)          ! { dg-error \"different shape for arguments\" }\n+end program"}]}